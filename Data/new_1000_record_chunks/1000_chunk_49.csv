record_number,buggy_code,fixed_code
48001,"/** 
 * Build data set.
 * @param summaries HashMap containing data of chart.
 * @return CategoryDataset Interface for a dataset with one or moreseries, and values associated with categories.
 */
private static CategoryDataset buildDataSet(Map<LocalDate,JacocoCoverageResultSummary> summaries){
  DataSetBuilder<String,LocalDate> dataSetBuilder=new DataSetBuilder<String,LocalDate>();
  for (  Map.Entry<LocalDate,JacocoCoverageResultSummary> entry : summaries.entrySet()) {
    float classCoverage=0;
    float lineCoverage=0;
    float methodCoverage=0;
    float branchCoverage=0;
    float instructionCoverage=0;
    float complexityScore=0;
    int count=0;
    List<JacocoCoverageResultSummary> list=entry.getValue().getJacocoCoverageResults();
    for (    JacocoCoverageResultSummary item : list) {
      classCoverage+=item.getClassCoverage();
      lineCoverage+=item.getLineCoverage();
      methodCoverage+=item.getMethodCoverage();
      branchCoverage+=item.getBranchCoverage();
      instructionCoverage+=item.getInstructionCoverage();
      complexityScore+=item.getComplexityScore();
      count++;
    }
    dataSetBuilder.add((classCoverage / count),""String_Node_Str"",entry.getKey());
    dataSetBuilder.add((lineCoverage / count),""String_Node_Str"",entry.getKey());
    dataSetBuilder.add((methodCoverage / count),""String_Node_Str"",entry.getKey());
    dataSetBuilder.add((branchCoverage / count),""String_Node_Str"",entry.getKey());
    dataSetBuilder.add((instructionCoverage / count),""String_Node_Str"",entry.getKey());
    dataSetBuilder.add((complexityScore / count),""String_Node_Str"",entry.getKey());
  }
  return dataSetBuilder.build();
}","/** 
 * Build data set.
 * @param summaries HashMap containing data of chart.
 * @return CategoryDataset Interface for a dataset with one or moreseries, and values associated with categories.
 */
private static CategoryDataset buildDataSet(Map<LocalDate,JacocoCoverageResultSummary> summaries){
  DataSetBuilder<String,LocalDate> dataSetBuilder=new DataSetBuilder<>();
  for (  Map.Entry<LocalDate,JacocoCoverageResultSummary> entry : summaries.entrySet()) {
    float classCoverage=0;
    float lineCoverage=0;
    float methodCoverage=0;
    float branchCoverage=0;
    float instructionCoverage=0;
    float complexityScore=0;
    int count=0;
    List<JacocoCoverageResultSummary> list=entry.getValue().getJacocoCoverageResults();
    for (    JacocoCoverageResultSummary item : list) {
      classCoverage+=item.getClassCoverage();
      lineCoverage+=item.getLineCoverage();
      methodCoverage+=item.getMethodCoverage();
      branchCoverage+=item.getBranchCoverage();
      instructionCoverage+=item.getInstructionCoverage();
      complexityScore+=item.getComplexityScore();
      count++;
    }
    dataSetBuilder.add((classCoverage / count),""String_Node_Str"",entry.getKey());
    dataSetBuilder.add((lineCoverage / count),""String_Node_Str"",entry.getKey());
    dataSetBuilder.add((methodCoverage / count),""String_Node_Str"",entry.getKey());
    dataSetBuilder.add((branchCoverage / count),""String_Node_Str"",entry.getKey());
    dataSetBuilder.add((instructionCoverage / count),""String_Node_Str"",entry.getKey());
    dataSetBuilder.add((complexityScore / count),""String_Node_Str"",entry.getKey());
  }
  return dataSetBuilder.build();
}"
48002,"protected String resolveFilePaths(Run<?,?> build,TaskListener listener,String input){
  try {
    return build.getEnvironment(listener).expand(input);
  }
 catch (  Exception e) {
    listener.getLogger().println(""String_Node_Str"" + input + ""String_Node_Str""+ e.getMessage());
  }
  return input;
}","protected String resolveFilePaths(AbstractBuild<?,?> build,TaskListener listener,String input){
  try {
    final EnvVars environment=build.getEnvironment(listener);
    environment.overrideAll(build.getBuildVariables());
    return environment.expand(input);
  }
 catch (  Exception e) {
    listener.getLogger().println(""String_Node_Str"" + input + ""String_Node_Str""+ e.getMessage());
  }
  return input;
}"
48003,"@Override public void perform(@Nonnull Run<?,?> run,@Nonnull FilePath filePath,@Nonnull Launcher launcher,@Nonnull TaskListener taskListener) throws InterruptedException, IOException {
  Map<String,String> envs=run instanceof AbstractBuild ? ((AbstractBuild)run).getBuildVariables() : Collections.<String,String>emptyMap();
  healthReports=createJacocoHealthReportThresholds();
  final PrintStream logger=taskListener.getLogger();
  FilePath[] matchedClassDirs=null;
  FilePath[] matchedSrcDirs=null;
  if (run.getResult() == Result.FAILURE || run.getResult() == Result.ABORTED) {
    return;
  }
  logger.println(""String_Node_Str"");
  EnvVars env=run.getEnvironment(taskListener);
  env.overrideAll(envs);
  if ((execPattern == null) || (classPattern == null) || (sourcePattern == null)) {
    if (run.getResult().isWorseThan(Result.UNSTABLE)) {
      return;
    }
    logger.println(""String_Node_Str"");
    run.setResult(Result.FAILURE);
    return;
  }
  logger.println(""String_Node_Str"" + execPattern + ""String_Node_Str""+ classPattern+ ""String_Node_Str""+ sourcePattern+ ""String_Node_Str""+ ""String_Node_Str"");
  JacocoReportDir dir=new JacocoReportDir(run.getRootDir());
  List<FilePath> matchedExecFiles=Arrays.asList(filePath.list(resolveFilePaths(run,taskListener,execPattern)));
  logger.println(""String_Node_Str"" + execPattern + ""String_Node_Str""+ matchedExecFiles.size());
  logger.print(""String_Node_Str"");
  dir.addExecFiles(matchedExecFiles);
  logger.print(""String_Node_Str"" + Util.join(matchedExecFiles,""String_Node_Str""));
  matchedClassDirs=resolveDirPaths(filePath,taskListener,classPattern);
  logger.print(""String_Node_Str"" + classPattern + ""String_Node_Str"");
  for (  FilePath file : matchedClassDirs) {
    dir.saveClassesFrom(file);
    logger.print(""String_Node_Str"" + file);
  }
  matchedSrcDirs=resolveDirPaths(filePath,taskListener,sourcePattern);
  logger.print(""String_Node_Str"" + sourcePattern + ""String_Node_Str"");
  for (  FilePath file : matchedSrcDirs) {
    dir.saveSourcesFrom(file);
    logger.print(""String_Node_Str"" + file);
  }
  logger.println(""String_Node_Str"");
  String[] includes={};
  if (inclusionPattern != null) {
    includes=inclusionPattern.split(DIR_SEP);
    logger.println(""String_Node_Str"" + Arrays.toString(includes));
  }
  String[] excludes={};
  if (exclusionPattern != null) {
    excludes=exclusionPattern.split(DIR_SEP);
    logger.println(""String_Node_Str"" + Arrays.toString(excludes));
  }
  final JacocoBuildAction action=JacocoBuildAction.load(run,healthReports,taskListener,dir,includes,excludes);
  action.getThresholds().ensureValid();
  logger.println(""String_Node_Str"" + action.getThresholds());
  run.getActions().add(action);
  logger.println(""String_Node_Str"");
  final CoverageReport result=action.getResult();
  if (result == null) {
    logger.println(""String_Node_Str"");
    run.setResult(Result.FAILURE);
  }
 else {
    logger.println(""String_Node_Str"" + result.getClassCoverage().getPercentage() + ""String_Node_Str""+ result.getMethodCoverage().getPercentage()+ ""String_Node_Str""+ result.getLineCoverage().getPercentage()+ ""String_Node_Str""+ result.getBranchCoverage().getPercentage()+ ""String_Node_Str""+ result.getInstructionCoverage().getPercentage());
    result.setThresholds(healthReports);
    if (changeBuildStatus) {
      run.setResult(checkResult(action));
    }
  }
  return;
}","@Override public void perform(@Nonnull Run<?,?> run,@Nonnull FilePath filePath,@Nonnull Launcher launcher,@Nonnull TaskListener taskListener) throws InterruptedException, IOException {
  Map<String,String> envs=run instanceof AbstractBuild ? ((AbstractBuild)run).getBuildVariables() : Collections.<String,String>emptyMap();
  healthReports=createJacocoHealthReportThresholds();
  final PrintStream logger=taskListener.getLogger();
  FilePath[] matchedClassDirs=null;
  FilePath[] matchedSrcDirs=null;
  if (run.getResult() == Result.FAILURE || run.getResult() == Result.ABORTED) {
    return;
  }
  logger.println(""String_Node_Str"");
  EnvVars env=run.getEnvironment(taskListener);
  env.overrideAll(envs);
  if ((execPattern == null) || (classPattern == null) || (sourcePattern == null)) {
    if (run.getResult().isWorseThan(Result.UNSTABLE)) {
      return;
    }
    logger.println(""String_Node_Str"");
    run.setResult(Result.FAILURE);
    return;
  }
  logger.println(""String_Node_Str"" + execPattern + ""String_Node_Str""+ classPattern+ ""String_Node_Str""+ sourcePattern+ ""String_Node_Str""+ ""String_Node_Str"");
  JacocoReportDir dir=new JacocoReportDir(run.getRootDir());
  if (run instanceof AbstractBuild) {
    execPattern=resolveFilePaths((AbstractBuild)run,taskListener,execPattern);
  }
  List<FilePath> matchedExecFiles=Arrays.asList(filePath.list(resolveFilePaths(run,taskListener,execPattern,env)));
  logger.println(""String_Node_Str"" + execPattern + ""String_Node_Str""+ matchedExecFiles.size());
  logger.print(""String_Node_Str"");
  dir.addExecFiles(matchedExecFiles);
  logger.print(""String_Node_Str"" + Util.join(matchedExecFiles,""String_Node_Str""));
  matchedClassDirs=resolveDirPaths(filePath,taskListener,classPattern);
  logger.print(""String_Node_Str"" + classPattern + ""String_Node_Str"");
  for (  FilePath file : matchedClassDirs) {
    dir.saveClassesFrom(file);
    logger.print(""String_Node_Str"" + file);
  }
  matchedSrcDirs=resolveDirPaths(filePath,taskListener,sourcePattern);
  logger.print(""String_Node_Str"" + sourcePattern + ""String_Node_Str"");
  for (  FilePath file : matchedSrcDirs) {
    dir.saveSourcesFrom(file);
    logger.print(""String_Node_Str"" + file);
  }
  logger.println(""String_Node_Str"");
  String[] includes={};
  if (inclusionPattern != null) {
    includes=inclusionPattern.split(DIR_SEP);
    logger.println(""String_Node_Str"" + Arrays.toString(includes));
  }
  String[] excludes={};
  if (exclusionPattern != null) {
    excludes=exclusionPattern.split(DIR_SEP);
    logger.println(""String_Node_Str"" + Arrays.toString(excludes));
  }
  final JacocoBuildAction action=JacocoBuildAction.load(run,healthReports,taskListener,dir,includes,excludes);
  action.getThresholds().ensureValid();
  logger.println(""String_Node_Str"" + action.getThresholds());
  run.getActions().add(action);
  logger.println(""String_Node_Str"");
  final CoverageReport result=action.getResult();
  if (result == null) {
    logger.println(""String_Node_Str"");
    run.setResult(Result.FAILURE);
  }
 else {
    logger.println(""String_Node_Str"" + result.getClassCoverage().getPercentage() + ""String_Node_Str""+ result.getMethodCoverage().getPercentage()+ ""String_Node_Str""+ result.getLineCoverage().getPercentage()+ ""String_Node_Str""+ result.getBranchCoverage().getPercentage()+ ""String_Node_Str""+ result.getInstructionCoverage().getPercentage());
    result.setThresholds(healthReports);
    if (changeBuildStatus) {
      run.setResult(checkResult(action));
    }
  }
  return;
}"
48004,"@Test public void test() throws Exception {
  AbstractReport<ClassReport,MethodReport> report=new AbstractReport<ClassReport,MethodReport>(){
  }
;
  assertNotNull(report);
  report.setParent(new ClassReport());
  report.getParent().setParent(new PackageReport());
  TaskListener taskListener=new TaskListener(){
    public PrintStream getLogger(){
      return null;
    }
    public void annotate(    ConsoleNote consoleNote) throws IOException {
    }
    public void hyperlink(    String s,    String s1) throws IOException {
    }
    public PrintWriter error(    String s){
      return null;
    }
    public PrintWriter error(    String s,    Object... objects){
      return null;
    }
    public PrintWriter fatalError(    String s){
      return null;
    }
    public PrintWriter fatalError(    String s,    Object... objects){
      return null;
    }
  }
;
  JacocoBuildAction action=new JacocoBuildAction(null,null,taskListener,null,null);
  report.getParent().getParent().setParent(new CoverageReport(action,null));
  assertNull(report.getBuild());
  assertNull(report.getName());
  assertNull(report.getDisplayName());
  report.setName(""String_Node_Str"");
  assertEquals(""String_Node_Str"",report.getName());
  assertEquals(""String_Node_Str"",report.getDisplayName());
}","@Test public void test() throws Exception {
  AbstractReport<ClassReport,MethodReport> report=new AbstractReport<ClassReport,MethodReport>(){
  }
;
  assertNotNull(report);
  report.setParent(new ClassReport());
  report.getParent().setParent(new PackageReport());
  TaskListener taskListener=StreamTaskListener.fromStdout();
  JacocoBuildAction action=new JacocoBuildAction(null,null,taskListener,null,null);
  report.getParent().getParent().setParent(new CoverageReport(action,null));
  assertNull(report.getBuild());
  assertNull(report.getName());
  assertNull(report.getDisplayName());
  report.setName(""String_Node_Str"");
  assertEquals(""String_Node_Str"",report.getName());
  assertEquals(""String_Node_Str"",report.getDisplayName());
}"
48005,"@Test public void testGetPercentWithBuildAndAction(){
  ServletContext context=EasyMock.createNiceMock(ServletContext.class);
  EasyMock.replay(context);
  final Job<?,?> mockJob=new MyJob(""String_Node_Str""){
    @Override @Exported @QuickSilver public Run<?,?> getLastSuccessfulBuild(){
      try {
        Run<?,?> newBuild=newBuild();
        newBuild.getActions().add(new JacocoBuildAction(null,null,new TaskListener(){
          private static final long serialVersionUID=1L;
          public void hyperlink(          String url,          String text) throws IOException {
          }
          public PrintStream getLogger(){
            return null;
          }
          public PrintWriter fatalError(          String format,          Object... args){
            return null;
          }
          public PrintWriter fatalError(          String msg){
            return null;
          }
          public PrintWriter error(          String format,          Object... args){
            return null;
          }
          public PrintWriter error(          String msg){
            return null;
          }
          public void annotate(          @SuppressWarnings(""String_Node_Str"") ConsoleNote ann) throws IOException {
          }
          public void started(          List<Cause> causes){
          }
          public void finished(          Result result){
          }
        }
,null,null));
        assertEquals(1,newBuild.getActions().size());
        return newBuild;
      }
 catch (      IOException e) {
        throw new IllegalStateException(e);
      }
    }
    @Override protected synchronized void saveNextBuildNumber() throws IOException {
    }
  }
;
  assertTrue(jacocoColumn.hasCoverage(mockJob));
  assertEquals(""String_Node_Str"",jacocoColumn.getPercent(mockJob));
  assertEquals(new BigDecimal(""String_Node_Str""),jacocoColumn.getLineCoverage(mockJob));
  EasyMock.verify(context);
}","@Test public void testGetPercentWithBuildAndAction(){
  ServletContext context=EasyMock.createNiceMock(ServletContext.class);
  EasyMock.replay(context);
  final Job<?,?> mockJob=new MyJob(""String_Node_Str""){
    @Override @Exported @QuickSilver public Run<?,?> getLastSuccessfulBuild(){
      try {
        Run<?,?> newBuild=newBuild();
        newBuild.getActions().add(new JacocoBuildAction(null,null,StreamTaskListener.fromStdout(),null,null));
        assertEquals(1,newBuild.getActions().size());
        return newBuild;
      }
 catch (      IOException e) {
        throw new IllegalStateException(e);
      }
    }
    @Override protected synchronized void saveNextBuildNumber() throws IOException {
    }
  }
;
  assertTrue(jacocoColumn.hasCoverage(mockJob));
  assertEquals(""String_Node_Str"",jacocoColumn.getPercent(mockJob));
  assertEquals(new BigDecimal(""String_Node_Str""),jacocoColumn.getLineCoverage(mockJob));
  EasyMock.verify(context);
}"
48006,"/** 
 * @return A map which represents coverage objects and their status to show on build status page (summary.jelly).
 */
public Map<Coverage,Boolean> getCoverageRatios(){
  CoverageReport result=getResult();
  Map<Coverage,Boolean> ratios=new LinkedHashMap<Coverage,Boolean>();
  if (result != null) {
    Coverage instructionCoverage=result.getInstructionCoverage();
    Coverage classCoverage=result.getClassCoverage();
    Coverage complexityScore=result.getComplexityScore();
    Coverage branchCoverage=result.getBranchCoverage();
    Coverage lineCoverage=result.getLineCoverage();
    Coverage methodCoverage=result.getMethodCoverage();
    instructionCoverage.setType(CoverageElement.Type.INSTRUCTION);
    classCoverage.setType(CoverageElement.Type.CLASS);
    complexityScore.setType(CoverageElement.Type.COMPLEXITY);
    branchCoverage.setType(CoverageElement.Type.BRANCH);
    lineCoverage.setType(CoverageElement.Type.LINE);
    methodCoverage.setType(CoverageElement.Type.METHOD);
    ratios.put(instructionCoverage,JacocoHealthReportThresholds.RESULT.BELLOWMINIMUM == thresholds.getResultByTypeAndRatio(instructionCoverage));
    ratios.put(branchCoverage,JacocoHealthReportThresholds.RESULT.BELLOWMINIMUM == thresholds.getResultByTypeAndRatio(branchCoverage));
    ratios.put(complexityScore,JacocoHealthReportThresholds.RESULT.BELLOWMINIMUM == thresholds.getResultByTypeAndRatio(complexityScore));
    ratios.put(lineCoverage,JacocoHealthReportThresholds.RESULT.BELLOWMINIMUM == thresholds.getResultByTypeAndRatio(lineCoverage));
    ratios.put(methodCoverage,JacocoHealthReportThresholds.RESULT.BELLOWMINIMUM == thresholds.getResultByTypeAndRatio(methodCoverage));
    ratios.put(classCoverage,JacocoHealthReportThresholds.RESULT.BELLOWMINIMUM == thresholds.getResultByTypeAndRatio(classCoverage));
  }
  return ratios;
}","/** 
 * @return A map which represents coverage objects and their status to show on build status page (summary.jelly).
 */
public Map<Coverage,Boolean> getCoverageRatios(){
  CoverageReport result=getResult();
  Map<Coverage,Boolean> ratios=new LinkedHashMap<Coverage,Boolean>();
  if (result != null) {
    Coverage instructionCoverage=result.getInstructionCoverage();
    Coverage classCoverage=result.getClassCoverage();
    Coverage complexityScore=result.getComplexityScore();
    Coverage branchCoverage=result.getBranchCoverage();
    Coverage lineCoverage=result.getLineCoverage();
    Coverage methodCoverage=result.getMethodCoverage();
    instructionCoverage.setType(CoverageElement.Type.INSTRUCTION);
    classCoverage.setType(CoverageElement.Type.CLASS);
    complexityScore.setType(CoverageElement.Type.COMPLEXITY);
    branchCoverage.setType(CoverageElement.Type.BRANCH);
    lineCoverage.setType(CoverageElement.Type.LINE);
    methodCoverage.setType(CoverageElement.Type.METHOD);
    ratios.put(instructionCoverage,JacocoHealthReportThresholds.RESULT.BELOWMINIMUM == thresholds.getResultByTypeAndRatio(instructionCoverage));
    ratios.put(branchCoverage,JacocoHealthReportThresholds.RESULT.BELOWMINIMUM == thresholds.getResultByTypeAndRatio(branchCoverage));
    ratios.put(complexityScore,JacocoHealthReportThresholds.RESULT.BELOWMINIMUM == thresholds.getResultByTypeAndRatio(complexityScore));
    ratios.put(lineCoverage,JacocoHealthReportThresholds.RESULT.BELOWMINIMUM == thresholds.getResultByTypeAndRatio(lineCoverage));
    ratios.put(methodCoverage,JacocoHealthReportThresholds.RESULT.BELOWMINIMUM == thresholds.getResultByTypeAndRatio(methodCoverage));
    ratios.put(classCoverage,JacocoHealthReportThresholds.RESULT.BELOWMINIMUM == thresholds.getResultByTypeAndRatio(classCoverage));
  }
  return ratios;
}"
48007,"public RESULT getResultByTypeAndRatio(Coverage ratio){
  RESULT result=RESULT.ABOVEMAXIMUM;
  Type covType=ratio.getType();
  if (covType == Type.INSTRUCTION) {
    if (ratio.getPercentageFloat() < minInstruction) {
      result=RESULT.BELLOWMINIMUM;
    }
 else     if (ratio.getPercentageFloat() < maxInstruction) {
      result=RESULT.BETWEENMINMAX;
    }
  }
 else   if (covType == Type.BRANCH) {
    if (ratio.getPercentageFloat() < minBranch) {
      result=RESULT.BELLOWMINIMUM;
    }
 else     if (ratio.getPercentageFloat() < maxBranch) {
      result=RESULT.BETWEENMINMAX;
    }
  }
 else   if (covType == Type.LINE) {
    if (ratio.getPercentageFloat() < minLine) {
      result=RESULT.BELLOWMINIMUM;
    }
 else     if (ratio.getPercentageFloat() < maxLine) {
      result=RESULT.BETWEENMINMAX;
    }
  }
 else   if (covType == Type.COMPLEXITY) {
    if (ratio.getPercentageFloat() < minComplexity) {
      result=RESULT.BELLOWMINIMUM;
    }
 else     if (ratio.getPercentageFloat() < maxComplexity) {
      result=RESULT.BETWEENMINMAX;
    }
  }
 else   if (covType == Type.METHOD) {
    if (ratio.getPercentageFloat() < minMethod) {
      result=RESULT.BELLOWMINIMUM;
    }
 else     if (ratio.getPercentageFloat() < maxMethod) {
      result=RESULT.BETWEENMINMAX;
    }
  }
 else   if (covType == Type.CLASS) {
    if (ratio.getPercentageFloat() < minClass) {
      result=RESULT.BELLOWMINIMUM;
    }
 else     if (ratio.getPercentageFloat() < maxClass) {
      result=RESULT.BETWEENMINMAX;
    }
  }
  return result;
}","public RESULT getResultByTypeAndRatio(Coverage ratio){
  RESULT result=RESULT.ABOVEMAXIMUM;
  Type covType=ratio.getType();
  if (covType == Type.INSTRUCTION) {
    if (ratio.getPercentageFloat() < minInstruction) {
      result=RESULT.BELOWMINIMUM;
    }
 else     if (ratio.getPercentageFloat() < maxInstruction) {
      result=RESULT.BETWEENMINMAX;
    }
  }
 else   if (covType == Type.BRANCH) {
    if (ratio.getPercentageFloat() < minBranch) {
      result=RESULT.BELOWMINIMUM;
    }
 else     if (ratio.getPercentageFloat() < maxBranch) {
      result=RESULT.BETWEENMINMAX;
    }
  }
 else   if (covType == Type.LINE) {
    if (ratio.getPercentageFloat() < minLine) {
      result=RESULT.BELOWMINIMUM;
    }
 else     if (ratio.getPercentageFloat() < maxLine) {
      result=RESULT.BETWEENMINMAX;
    }
  }
 else   if (covType == Type.COMPLEXITY) {
    if (ratio.getPercentageFloat() < minComplexity) {
      result=RESULT.BELOWMINIMUM;
    }
 else     if (ratio.getPercentageFloat() < maxComplexity) {
      result=RESULT.BETWEENMINMAX;
    }
  }
 else   if (covType == Type.METHOD) {
    if (ratio.getPercentageFloat() < minMethod) {
      result=RESULT.BELOWMINIMUM;
    }
 else     if (ratio.getPercentageFloat() < maxMethod) {
      result=RESULT.BETWEENMINMAX;
    }
  }
 else   if (covType == Type.CLASS) {
    if (ratio.getPercentageFloat() < minClass) {
      result=RESULT.BELOWMINIMUM;
    }
 else     if (ratio.getPercentageFloat() < maxClass) {
      result=RESULT.BETWEENMINMAX;
    }
  }
  return result;
}"
48008,"@Override protected void printRatioCell(boolean failed,Coverage ratio,StringBuilder buf){
  if (ratio != null && ratio.isInitialized()) {
    String bgColor=""String_Node_Str"";
    if (JacocoHealthReportThresholds.RESULT.BETWEENMINMAX == healthReports.getResultByTypeAndRatio(ratio)) {
      bgColor=""String_Node_Str"";
    }
 else     if (JacocoHealthReportThresholds.RESULT.BELLOWMINIMUM == healthReports.getResultByTypeAndRatio(ratio)) {
      bgColor=""String_Node_Str"";
    }
    buf.append(""String_Node_Str"").append(bgColor).append(""String_Node_Str"");
    buf.append(""String_Node_Str"").append(dataFormat.format(ratio.getPercentageFloat()));
    buf.append(""String_Node_Str"");
    printRatioTable(ratio,buf);
    buf.append(""String_Node_Str"");
  }
}","@Override protected void printRatioCell(boolean failed,Coverage ratio,StringBuilder buf){
  if (ratio != null && ratio.isInitialized()) {
    String bgColor=""String_Node_Str"";
    if (JacocoHealthReportThresholds.RESULT.BETWEENMINMAX == healthReports.getResultByTypeAndRatio(ratio)) {
      bgColor=""String_Node_Str"";
    }
 else     if (JacocoHealthReportThresholds.RESULT.BELOWMINIMUM == healthReports.getResultByTypeAndRatio(ratio)) {
      bgColor=""String_Node_Str"";
    }
    buf.append(""String_Node_Str"").append(bgColor).append(""String_Node_Str"");
    buf.append(""String_Node_Str"").append(dataFormat.format(ratio.getPercentageFloat()));
    buf.append(""String_Node_Str"");
    printRatioTable(ratio,buf);
    buf.append(""String_Node_Str"");
  }
}"
48009,"/** 
 * @return Map<CoverageRatio,Failed?> to represents coverage objects and its status to show on build status page (summary.jelly).
 */
public Map<Coverage,Boolean> getCoverageRatios(){
  CoverageReport result=getResult();
  Map<Coverage,Boolean> ratios=new LinkedHashMap<Coverage,Boolean>();
  if (result != null) {
    Coverage instructionCoverage=result.getInstructionCoverage();
    Coverage classCoverage=result.getClassCoverage();
    Coverage complexityScore=result.getComplexityScore();
    Coverage branchCoverage=result.getBranchCoverage();
    Coverage lineCoverage=result.getLineCoverage();
    Coverage methodCoverage=result.getMethodCoverage();
    instructionCoverage.setType(CoverageElement.Type.INSTRUCTION);
    classCoverage.setType(CoverageElement.Type.CLASS);
    complexityScore.setType(CoverageElement.Type.COMPLEXITY);
    branchCoverage.setType(CoverageElement.Type.BRANCH);
    lineCoverage.setType(CoverageElement.Type.LINE);
    methodCoverage.setType(CoverageElement.Type.METHOD);
    ratios.put(instructionCoverage,JacocoHealthReportThresholds.RESULT.BELLOWMINIMUM == thresholds.getResultByTypeAndRatio(instructionCoverage));
    ratios.put(branchCoverage,JacocoHealthReportThresholds.RESULT.BELLOWMINIMUM == thresholds.getResultByTypeAndRatio(branchCoverage));
    ratios.put(complexityScore,JacocoHealthReportThresholds.RESULT.BELLOWMINIMUM == thresholds.getResultByTypeAndRatio(complexityScore));
    ratios.put(lineCoverage,JacocoHealthReportThresholds.RESULT.BELLOWMINIMUM == thresholds.getResultByTypeAndRatio(lineCoverage));
    ratios.put(methodCoverage,JacocoHealthReportThresholds.RESULT.BELLOWMINIMUM == thresholds.getResultByTypeAndRatio(methodCoverage));
    ratios.put(classCoverage,JacocoHealthReportThresholds.RESULT.BELLOWMINIMUM == thresholds.getResultByTypeAndRatio(classCoverage));
  }
  return ratios;
}","/** 
 * @return A map which represents coverage objects and their status to show on build status page (summary.jelly).
 */
public Map<Coverage,Boolean> getCoverageRatios(){
  CoverageReport result=getResult();
  Map<Coverage,Boolean> ratios=new LinkedHashMap<Coverage,Boolean>();
  if (result != null) {
    Coverage instructionCoverage=result.getInstructionCoverage();
    Coverage classCoverage=result.getClassCoverage();
    Coverage complexityScore=result.getComplexityScore();
    Coverage branchCoverage=result.getBranchCoverage();
    Coverage lineCoverage=result.getLineCoverage();
    Coverage methodCoverage=result.getMethodCoverage();
    instructionCoverage.setType(CoverageElement.Type.INSTRUCTION);
    classCoverage.setType(CoverageElement.Type.CLASS);
    complexityScore.setType(CoverageElement.Type.COMPLEXITY);
    branchCoverage.setType(CoverageElement.Type.BRANCH);
    lineCoverage.setType(CoverageElement.Type.LINE);
    methodCoverage.setType(CoverageElement.Type.METHOD);
    ratios.put(instructionCoverage,JacocoHealthReportThresholds.RESULT.BELLOWMINIMUM == thresholds.getResultByTypeAndRatio(instructionCoverage));
    ratios.put(branchCoverage,JacocoHealthReportThresholds.RESULT.BELLOWMINIMUM == thresholds.getResultByTypeAndRatio(branchCoverage));
    ratios.put(complexityScore,JacocoHealthReportThresholds.RESULT.BELLOWMINIMUM == thresholds.getResultByTypeAndRatio(complexityScore));
    ratios.put(lineCoverage,JacocoHealthReportThresholds.RESULT.BELLOWMINIMUM == thresholds.getResultByTypeAndRatio(lineCoverage));
    ratios.put(methodCoverage,JacocoHealthReportThresholds.RESULT.BELLOWMINIMUM == thresholds.getResultByTypeAndRatio(methodCoverage));
    ratios.put(classCoverage,JacocoHealthReportThresholds.RESULT.BELLOWMINIMUM == thresholds.getResultByTypeAndRatio(classCoverage));
  }
  return ratios;
}"
48010,"/** 
 * Constructor with parameters.
 * @param job the related Job
 * @param blockCoverage block coverage percentage
 * @param lineCoverage line coverage percentage
 * @param methodCoverage method coverage percentage
 * @param classCoverage coverage percentage
 */
public JacocoCoverageResultSummary(Job<?,?> job,float lineCoverage,float methodCoverage,float classCoverage,float branchCoverage,float instructionCoverage,float complexityScore){
  this.job=job;
  this.lineCoverage=lineCoverage;
  this.methodCoverage=methodCoverage;
  this.classCoverage=classCoverage;
  this.branchCoverage=branchCoverage;
  this.instructionCoverage=instructionCoverage;
  this.complexityScore=complexityScore;
}","/** 
 * Constructor with parameters.
 * @param job the related Job
 * @param lineCoverage line coverage percentage
 * @param methodCoverage method coverage percentage
 * @param classCoverage coverage percentage
 */
public JacocoCoverageResultSummary(Job<?,?> job,float lineCoverage,float methodCoverage,float classCoverage,float branchCoverage,float instructionCoverage,float complexityScore){
  this.job=job;
  this.lineCoverage=lineCoverage;
  this.methodCoverage=methodCoverage;
  this.classCoverage=classCoverage;
  this.branchCoverage=branchCoverage;
  this.instructionCoverage=instructionCoverage;
  this.complexityScore=complexityScore;
}"
48011,"/** 
 * Loads the exec files using JaCoCo API. Creates the reporting objects and the report tree.
 * @param action
 * @param reports
 * @throws IOException
 */
public CoverageReport(JacocoBuildAction action,ExecutionFileLoader executionFileLoader){
  this(action);
  try {
    action.getLogger().println(""String_Node_Str"");
    if (executionFileLoader.getBundleCoverage() != null) {
      setAllCovTypes(this,executionFileLoader.getBundleCoverage());
      ArrayList<IPackageCoverage> packageList=new ArrayList<IPackageCoverage>(executionFileLoader.getBundleCoverage().getPackages());
      for (      IPackageCoverage packageCov : packageList) {
        PackageReport packageReport=new PackageReport();
        packageReport.setName(packageCov.getName());
        packageReport.setParent(this);
        this.setCoverage(packageReport,packageCov);
        ArrayList<IClassCoverage> classList=new ArrayList<IClassCoverage>(packageCov.getClasses());
        for (        IClassCoverage classCov : classList) {
          ClassReport classReport=new ClassReport();
          classReport.setName(classCov.getName());
          classReport.setParent(packageReport);
          classReport.setSrcFileInfo(classCov,executionFileLoader.getSrcDir() + ""String_Node_Str"" + packageCov.getName()+ ""String_Node_Str""+ classCov.getSourceFileName());
          packageReport.setCoverage(classReport,classCov);
          ArrayList<IMethodCoverage> methodList=new ArrayList<IMethodCoverage>(classCov.getMethods());
          for (          IMethodCoverage methodCov : methodList) {
            MethodReport methodReport=new MethodReport();
            methodReport.setName(getMethodName(classCov,methodCov));
            methodReport.setParent(classReport);
            classReport.setCoverage(methodReport,methodCov);
            methodReport.setSrcFileInfo(methodCov);
            classReport.add(methodReport);
          }
          packageReport.add(classReport);
        }
        this.add(packageReport);
      }
    }
    action.getLogger().println(""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","/** 
 * Loads the exec files using JaCoCo API. Creates the reporting objects and the report tree.
 * @param action
 * @param executionFileLoader
 */
public CoverageReport(JacocoBuildAction action,ExecutionFileLoader executionFileLoader){
  this(action);
  try {
    action.getLogger().println(""String_Node_Str"");
    if (executionFileLoader.getBundleCoverage() != null) {
      setAllCovTypes(this,executionFileLoader.getBundleCoverage());
      ArrayList<IPackageCoverage> packageList=new ArrayList<IPackageCoverage>(executionFileLoader.getBundleCoverage().getPackages());
      for (      IPackageCoverage packageCov : packageList) {
        PackageReport packageReport=new PackageReport();
        packageReport.setName(packageCov.getName());
        packageReport.setParent(this);
        this.setCoverage(packageReport,packageCov);
        ArrayList<IClassCoverage> classList=new ArrayList<IClassCoverage>(packageCov.getClasses());
        for (        IClassCoverage classCov : classList) {
          ClassReport classReport=new ClassReport();
          classReport.setName(classCov.getName());
          classReport.setParent(packageReport);
          classReport.setSrcFileInfo(classCov,executionFileLoader.getSrcDir() + ""String_Node_Str"" + packageCov.getName()+ ""String_Node_Str""+ classCov.getSourceFileName());
          packageReport.setCoverage(classReport,classCov);
          ArrayList<IMethodCoverage> methodList=new ArrayList<IMethodCoverage>(classCov.getMethods());
          for (          IMethodCoverage methodCov : methodList) {
            MethodReport methodReport=new MethodReport();
            methodReport.setName(getMethodName(classCov,methodCov));
            methodReport.setParent(classReport);
            classReport.setCoverage(methodReport,methodCov);
            methodReport.setSrcFileInfo(methodCov);
            classReport.add(methodReport);
          }
          packageReport.add(classReport);
        }
        this.add(packageReport);
      }
    }
    action.getLogger().println(""String_Node_Str"");
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
48012,"public FilePath[] invoke(File f,VirtualChannel channel) throws IOException {
  FilePath base=new FilePath(f);
  ArrayList<FilePath> localDirectoryPaths=new ArrayList<FilePath>();
  String[] includes=input.split(""String_Node_Str"");
  DirectoryScanner ds=new DirectoryScanner();
  ds.setIncludes(includes);
  ds.setCaseSensitive(false);
  ds.setBasedir(f);
  ds.scan();
  String[] dirs=ds.getIncludedDirectories();
  for (  String dir : dirs) {
    localDirectoryPaths.add(base.child(dir));
  }
  FilePath[] lfp={};
  return localDirectoryPaths.toArray(lfp);
}","public FilePath[] invoke(File f,VirtualChannel channel) throws IOException {
  FilePath base=new FilePath(f);
  ArrayList<FilePath> localDirectoryPaths=new ArrayList<FilePath>();
  String[] includes=input.split(DIR_SEP);
  DirectoryScanner ds=new DirectoryScanner();
  ds.setIncludes(includes);
  ds.setCaseSensitive(false);
  ds.setBasedir(f);
  ds.scan();
  String[] dirs=ds.getIncludedDirectories();
  for (  String dir : dirs) {
    localDirectoryPaths.add(base.child(dir));
  }
  FilePath[] lfp={};
  return localDirectoryPaths.toArray(lfp);
}"
48013,"protected static FilePath[] resolveDirPaths(AbstractBuild<?,?> build,BuildListener listener,final String input){
  FilePath[] directoryPaths=null;
  try {
    directoryPaths=build.getWorkspace().act(new FilePath.FileCallable<FilePath[]>(){
      static final long serialVersionUID=1552178457453558870L;
      public FilePath[] invoke(      File f,      VirtualChannel channel) throws IOException {
        FilePath base=new FilePath(f);
        ArrayList<FilePath> localDirectoryPaths=new ArrayList<FilePath>();
        String[] includes=input.split(""String_Node_Str"");
        DirectoryScanner ds=new DirectoryScanner();
        ds.setIncludes(includes);
        ds.setCaseSensitive(false);
        ds.setBasedir(f);
        ds.scan();
        String[] dirs=ds.getIncludedDirectories();
        for (        String dir : dirs) {
          localDirectoryPaths.add(base.child(dir));
        }
        FilePath[] lfp={};
        return localDirectoryPaths.toArray(lfp);
      }
    }
);
  }
 catch (  InterruptedException ie) {
    ie.printStackTrace();
  }
catch (  IOException io) {
    io.printStackTrace();
  }
  return directoryPaths;
}","protected static FilePath[] resolveDirPaths(AbstractBuild<?,?> build,BuildListener listener,final String input){
  FilePath[] directoryPaths=null;
  try {
    directoryPaths=build.getWorkspace().act(new FilePath.FileCallable<FilePath[]>(){
      static final long serialVersionUID=1552178457453558870L;
      public FilePath[] invoke(      File f,      VirtualChannel channel) throws IOException {
        FilePath base=new FilePath(f);
        ArrayList<FilePath> localDirectoryPaths=new ArrayList<FilePath>();
        String[] includes=input.split(DIR_SEP);
        DirectoryScanner ds=new DirectoryScanner();
        ds.setIncludes(includes);
        ds.setCaseSensitive(false);
        ds.setBasedir(f);
        ds.scan();
        String[] dirs=ds.getIncludedDirectories();
        for (        String dir : dirs) {
          localDirectoryPaths.add(base.child(dir));
        }
        FilePath[] lfp={};
        return localDirectoryPaths.toArray(lfp);
      }
    }
);
  }
 catch (  InterruptedException ie) {
    ie.printStackTrace();
  }
catch (  IOException io) {
    io.printStackTrace();
  }
  return directoryPaths;
}"
48014,"@SuppressWarnings(""String_Node_Str"") @Override public boolean perform(AbstractBuild<?,?> build,Launcher launcher,BuildListener listener) throws InterruptedException, IOException {
  final PrintStream logger=listener.getLogger();
  FilePath[] matchedClassDirs=null;
  FilePath[] matchedSrcDirs=null;
  if (build.getResult() == Result.FAILURE || build.getResult() == Result.ABORTED) {
    return true;
  }
  logger.println(""String_Node_Str"");
  EnvVars env=build.getEnvironment(listener);
  env.overrideAll(build.getBuildVariables());
  try {
    healthReports=new JacocoHealthReportThresholds(Integer.parseInt(minimumClassCoverage),Integer.parseInt(maximumClassCoverage),Integer.parseInt(minimumMethodCoverage),Integer.parseInt(maximumMethodCoverage),Integer.parseInt(minimumLineCoverage),Integer.parseInt(maximumLineCoverage),Integer.parseInt(minimumBranchCoverage),Integer.parseInt(maximumBranchCoverage),Integer.parseInt(minimumInstructionCoverage),Integer.parseInt(maximumInstructionCoverage),Integer.parseInt(minimumComplexityCoverage),Integer.parseInt(maximumComplexityCoverage));
  }
 catch (  NumberFormatException nfe) {
    healthReports=new JacocoHealthReportThresholds(0,0,0,0,0,0,0,0,0,0,0,0);
  }
  if ((execPattern == null) || (classPattern == null) || (sourcePattern == null)) {
    if (build.getResult().isWorseThan(Result.UNSTABLE)) {
      return true;
    }
    logger.println(""String_Node_Str"");
    build.setResult(Result.FAILURE);
    return true;
  }
  logger.println(""String_Node_Str"" + execPattern + ""String_Node_Str""+ classPattern+ ""String_Node_Str""+ sourcePattern+ ""String_Node_Str""+ ""String_Node_Str"");
  JacocoReportDir dir=new JacocoReportDir(build);
  List<FilePath> matchedExecFiles=Arrays.asList(build.getWorkspace().list(resolveFilePaths(build,listener,execPattern)));
  logger.println(""String_Node_Str"" + execPattern + ""String_Node_Str""+ matchedExecFiles.size());
  logger.print(""String_Node_Str"");
  dir.addExecFiles(matchedExecFiles);
  logger.print(""String_Node_Str"" + Util.join(matchedExecFiles,""String_Node_Str""));
  matchedClassDirs=resolveDirPaths(build,listener,classPattern);
  logger.print(""String_Node_Str"" + classPattern + ""String_Node_Str"");
  for (  FilePath file : matchedClassDirs) {
    dir.saveClassesFrom(file);
    logger.print(""String_Node_Str"" + file);
  }
  matchedSrcDirs=resolveDirPaths(build,listener,sourcePattern);
  logger.print(""String_Node_Str"" + sourcePattern + ""String_Node_Str"");
  for (  FilePath file : matchedSrcDirs) {
    dir.saveSourcesFrom(file);
    logger.print(""String_Node_Str"" + file);
  }
  logger.println(""String_Node_Str"");
  String[] includes={};
  if (inclusionPattern != null) {
    includes=inclusionPattern.split(""String_Node_Str"");
    logger.println(""String_Node_Str"" + Arrays.toString(includes));
  }
  String[] excludes={};
  if (exclusionPattern != null) {
    excludes=exclusionPattern.split(""String_Node_Str"");
    logger.println(""String_Node_Str"" + Arrays.toString(excludes));
  }
  final JacocoBuildAction action=JacocoBuildAction.load(build,rule,healthReports,listener,dir,includes,excludes);
  action.getThresholds().ensureValid();
  logger.println(""String_Node_Str"" + action.getThresholds());
  build.getActions().add(action);
  logger.println(""String_Node_Str"");
  final CoverageReport result=action.getResult();
  if (result == null) {
    logger.println(""String_Node_Str"");
    build.setResult(Result.FAILURE);
  }
 else {
    logger.println(""String_Node_Str"" + result.getClassCoverage().getPercentage() + ""String_Node_Str""+ result.getMethodCoverage().getPercentage()+ ""String_Node_Str""+ result.getLineCoverage().getPercentage()+ ""String_Node_Str""+ result.getBranchCoverage().getPercentage()+ ""String_Node_Str""+ result.getInstructionCoverage().getPercentage());
    result.setThresholds(healthReports);
    if (changeBuildStatus) {
      build.setResult(checkResult(action));
    }
  }
  return true;
}","@SuppressWarnings(""String_Node_Str"") @Override public boolean perform(AbstractBuild<?,?> build,Launcher launcher,BuildListener listener) throws InterruptedException, IOException {
  final PrintStream logger=listener.getLogger();
  FilePath[] matchedClassDirs=null;
  FilePath[] matchedSrcDirs=null;
  if (build.getResult() == Result.FAILURE || build.getResult() == Result.ABORTED) {
    return true;
  }
  logger.println(""String_Node_Str"");
  EnvVars env=build.getEnvironment(listener);
  env.overrideAll(build.getBuildVariables());
  try {
    healthReports=new JacocoHealthReportThresholds(Integer.parseInt(minimumClassCoverage),Integer.parseInt(maximumClassCoverage),Integer.parseInt(minimumMethodCoverage),Integer.parseInt(maximumMethodCoverage),Integer.parseInt(minimumLineCoverage),Integer.parseInt(maximumLineCoverage),Integer.parseInt(minimumBranchCoverage),Integer.parseInt(maximumBranchCoverage),Integer.parseInt(minimumInstructionCoverage),Integer.parseInt(maximumInstructionCoverage),Integer.parseInt(minimumComplexityCoverage),Integer.parseInt(maximumComplexityCoverage));
  }
 catch (  NumberFormatException nfe) {
    healthReports=new JacocoHealthReportThresholds(0,0,0,0,0,0,0,0,0,0,0,0);
  }
  if ((execPattern == null) || (classPattern == null) || (sourcePattern == null)) {
    if (build.getResult().isWorseThan(Result.UNSTABLE)) {
      return true;
    }
    logger.println(""String_Node_Str"");
    build.setResult(Result.FAILURE);
    return true;
  }
  logger.println(""String_Node_Str"" + execPattern + ""String_Node_Str""+ classPattern+ ""String_Node_Str""+ sourcePattern+ ""String_Node_Str""+ ""String_Node_Str"");
  JacocoReportDir dir=new JacocoReportDir(build);
  List<FilePath> matchedExecFiles=Arrays.asList(build.getWorkspace().list(resolveFilePaths(build,listener,execPattern)));
  logger.println(""String_Node_Str"" + execPattern + ""String_Node_Str""+ matchedExecFiles.size());
  logger.print(""String_Node_Str"");
  dir.addExecFiles(matchedExecFiles);
  logger.print(""String_Node_Str"" + Util.join(matchedExecFiles,""String_Node_Str""));
  matchedClassDirs=resolveDirPaths(build,listener,classPattern);
  logger.print(""String_Node_Str"" + classPattern + ""String_Node_Str"");
  for (  FilePath file : matchedClassDirs) {
    dir.saveClassesFrom(file);
    logger.print(""String_Node_Str"" + file);
  }
  matchedSrcDirs=resolveDirPaths(build,listener,sourcePattern);
  logger.print(""String_Node_Str"" + sourcePattern + ""String_Node_Str"");
  for (  FilePath file : matchedSrcDirs) {
    dir.saveSourcesFrom(file);
    logger.print(""String_Node_Str"" + file);
  }
  logger.println(""String_Node_Str"");
  String[] includes={};
  if (inclusionPattern != null) {
    includes=inclusionPattern.split(DIR_SEP);
    logger.println(""String_Node_Str"" + Arrays.toString(includes));
  }
  String[] excludes={};
  if (exclusionPattern != null) {
    excludes=exclusionPattern.split(DIR_SEP);
    logger.println(""String_Node_Str"" + Arrays.toString(excludes));
  }
  final JacocoBuildAction action=JacocoBuildAction.load(build,rule,healthReports,listener,dir,includes,excludes);
  action.getThresholds().ensureValid();
  logger.println(""String_Node_Str"" + action.getThresholds());
  build.getActions().add(action);
  logger.println(""String_Node_Str"");
  final CoverageReport result=action.getResult();
  if (result == null) {
    logger.println(""String_Node_Str"");
    build.setResult(Result.FAILURE);
  }
 else {
    logger.println(""String_Node_Str"" + result.getClassCoverage().getPercentage() + ""String_Node_Str""+ result.getMethodCoverage().getPercentage()+ ""String_Node_Str""+ result.getLineCoverage().getPercentage()+ ""String_Node_Str""+ result.getBranchCoverage().getPercentage()+ ""String_Node_Str""+ result.getInstructionCoverage().getPercentage());
    result.setThresholds(healthReports);
    if (changeBuildStatus) {
      build.setResult(checkResult(action));
    }
  }
  return true;
}"
48015,"protected void printRatioTable(Coverage ratio,StringBuilder buf){
  String percent=percentFormat.format(ratio.getPercentageFloat());
  String numerator=intFormat.format(ratio.getMissed());
  String denominator=intFormat.format(ratio.getCovered());
  int maximumCovered=2;
  int maximumMissed=2;
  if (ratio.getType().equals(CoverageElement.Type.INSTRUCTION)) {
    maximumCovered=getParent().maxCoveredInstruction;
    maximumMissed=getParent().maxMissedInstruction;
  }
 else   if (ratio.getType().equals(CoverageElement.Type.BRANCH)) {
    maximumCovered=getParent().maxCoveredBranch;
    maximumMissed=getParent().maxMissedBranch;
  }
 else   if (ratio.getType().equals(CoverageElement.Type.COMPLEXITY)) {
    maximumCovered=getParent().maxCoveredComplexity;
    maximumMissed=getParent().maxMissedComplexity;
  }
 else   if (ratio.getType().equals(CoverageElement.Type.LINE)) {
    maximumCovered=getParent().maxCoveredLine;
    maximumMissed=getParent().maxMissedLine;
  }
 else   if (ratio.getType().equals(CoverageElement.Type.METHOD)) {
    maximumCovered=getParent().maxCoveredMethod;
    maximumMissed=getParent().maxMissedMethod;
  }
 else   if (ratio.getType().equals(CoverageElement.Type.CLASS)) {
    maximumCovered=getParent().maxCoveredClazz;
    maximumMissed=getParent().maxMissedClazz;
  }
  buf.append(""String_Node_Str"").append(""String_Node_Str"").append(ratio.getPercentage()).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(((float)ratio.getCovered() / (float)maximumCovered) * 100).append(""String_Node_Str"").append(""String_Node_Str"").append(ratio.getMissed() > ratio.getCovered() ? ((float)ratio.getMissed() / (float)maximumMissed) * 100 : ((float)ratio.getMissed() / (float)maximumCovered) * 100).append(""String_Node_Str"").append(""String_Node_Str"" + ""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"" + numerator).append(""String_Node_Str"").append(""String_Node_Str"" + denominator).append(""String_Node_Str"").append(""String_Node_Str"");
}","protected void printRatioTable(Coverage ratio,StringBuilder buf){
  String percent=percentFormat.format(ratio.getPercentageFloat());
  String numerator=intFormat.format(ratio.getMissed());
  String denominator=intFormat.format(ratio.getCovered());
  int maximumCovered=2;
  int maximumMissed=2;
  if (ratio.getType().equals(CoverageElement.Type.INSTRUCTION)) {
    maximumCovered=getParent().maxCoveredInstruction;
    maximumMissed=getParent().maxMissedInstruction;
  }
 else   if (ratio.getType().equals(CoverageElement.Type.BRANCH)) {
    maximumCovered=getParent().maxCoveredBranch;
    maximumMissed=getParent().maxMissedBranch;
  }
 else   if (ratio.getType().equals(CoverageElement.Type.COMPLEXITY)) {
    maximumCovered=getParent().maxCoveredComplexity;
    maximumMissed=getParent().maxMissedComplexity;
  }
 else   if (ratio.getType().equals(CoverageElement.Type.LINE)) {
    maximumCovered=getParent().maxCoveredLine;
    maximumMissed=getParent().maxMissedLine;
  }
 else   if (ratio.getType().equals(CoverageElement.Type.METHOD)) {
    maximumCovered=getParent().maxCoveredMethod;
    maximumMissed=getParent().maxMissedMethod;
  }
 else   if (ratio.getType().equals(CoverageElement.Type.CLASS)) {
    maximumCovered=getParent().maxCoveredClazz;
    maximumMissed=getParent().maxMissedClazz;
  }
  buf.append(""String_Node_Str"").append(""String_Node_Str"" + ""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"" + numerator).append(""String_Node_Str"").append(""String_Node_Str"" + denominator).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(ratio.getPercentage()).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(((float)ratio.getCovered() / (float)maximumCovered) * 100).append(""String_Node_Str"").append(""String_Node_Str"").append(ratio.getMissed() > ratio.getCovered() ? ((float)ratio.getMissed() / (float)maximumMissed) * 100 : ((float)ratio.getMissed() / (float)maximumCovered) * 100).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
}"
48016,"protected void printRatioCell(boolean failed,Coverage ratio,StringBuilder buf){
  if (ratio != null && ratio.isInitialized()) {
    String className=""String_Node_Str"" + (failed ? ""String_Node_Str"" : ""String_Node_Str"");
    buf.append(""String_Node_Str"").append(className).append(""String_Node_Str"");
    buf.append(""String_Node_Str"").append(dataFormat.format(ratio.getPercentageFloat()));
    buf.append(""String_Node_Str"");
    printRatioTable(ratio,buf);
    buf.append(""String_Node_Str"");
  }
}","protected void printRatioCell(boolean failed,Coverage ratio,StringBuilder buf){
  if (ratio != null && ratio.isInitialized()) {
    buf.append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
    buf.append(""String_Node_Str"").append(dataFormat.format(ratio.getPercentageFloat()));
    buf.append(""String_Node_Str"");
    printRatioTable(ratio,buf);
    buf.append(""String_Node_Str"");
  }
}"
48017,"/** 
 * Adds the given missed and covered values to the ones already contained in this ratio.
 * @param missed The amount to add to the missed.
 * @param covered The amount to add to the covered.
 */
public void accumulate(int missed,int covered){
  this.missed+=missed;
  this.covered+=covered;
  initialized=true;
}","/** 
 * Adds the given missed and covered values to the ones already contained in this ratio.
 * @param missed The amount to add to the missed.
 * @param covered The amount to add to the covered.
 */
public void accumulate(int missed,int covered){
  this.missed=missed;
  this.covered=covered;
  initialized=true;
}"
48018,"@Test public void testPackageReport() throws Exception {
  CoverageReport r=new CoverageReport(null,getClass().getResourceAsStream(""String_Node_Str""));
  PackageReport pkg=r.getChildren().get(""String_Node_Str"");
  assertCoverage(pkg.getLineCoverage(),68,82);
}","@Test public void testPackageReport() throws Exception {
  CoverageReport r=new CoverageReport(null,getClass().getResourceAsStream(""String_Node_Str""));
  PackageReport pkg=r.getChildren().get(""String_Node_Str"");
  assertCoverage(pkg.getLineCoverage(),34,41);
}"
48019,"/** 
 * Ensures the coverage after loading two reports represents the combined metrics of both reports.
 */
@Test public void testLoadMultipleReports() throws Exception {
  CoverageReport r=new CoverageReport(null,getClass().getResourceAsStream(""String_Node_Str""),getClass().getResourceAsStream(""String_Node_Str""));
  assertCoverage(r.getLineCoverage(),595 + 513,293 + 361);
  PackageReport pkg=r.getChildren().get(""String_Node_Str"");
  assertCoverage(pkg.getLineCoverage(),68,82);
  pkg=r.getChildren().get(""String_Node_Str"");
  assertCoverage(pkg.getLineCoverage(),136,0 + 2);
}","/** 
 * Ensures the coverage after loading two reports represents the combined metrics of both reports.
 */
@Test public void testLoadMultipleReports() throws Exception {
  CoverageReport r=new CoverageReport(null,getClass().getResourceAsStream(""String_Node_Str""),getClass().getResourceAsStream(""String_Node_Str""));
  assertCoverage(r.getLineCoverage(),513,361);
  PackageReport pkg=r.getChildren().get(""String_Node_Str"");
  assertCoverage(pkg.getLineCoverage(),34,41);
  pkg=r.getChildren().get(""String_Node_Str"");
  assertCoverage(pkg.getLineCoverage(),68,1);
}"
48020,"@Test public void testLoad() throws Exception {
  CoverageReport r=new CoverageReport(null,getClass().getResourceAsStream(""String_Node_Str""));
  PackageReport pkg=r.getChildren().get(""String_Node_Str"");
  System.out.println(pkg);
  assertCoverage(pkg.getLineCoverage(),786,392);
  assertEquals(595,r.getLineCoverage().getMissed());
}","@Test public void testLoad() throws Exception {
  CoverageReport r=new CoverageReport(null,getClass().getResourceAsStream(""String_Node_Str""));
  PackageReport pkg=r.getChildren().get(""String_Node_Str"");
  System.out.println(pkg);
  assertCoverage(pkg.getLineCoverage(),393,196);
  assertEquals(595,r.getLineCoverage().getMissed());
}"
48021,"@Test public void testLoadMultipleReports() throws Exception {
  JacocoBuildAction r=JacocoBuildAction.load(null,null,new JacocoHealthReportThresholds(30,90,25,80,15,60,15,60,20,70,0,0),getClass().getResourceAsStream(""String_Node_Str""),getClass().getResourceAsStream(""String_Node_Str""));
  assertEquals(65,r.clazz.getPercentage());
  assertEquals(37,r.line.getPercentage());
  assertCoverage(r.clazz,17 + 9,20 + 28);
  assertCoverage(r.method,167 + 122,69 + 116);
  assertCoverage(r.line,595 + 513,293 + 361);
  assertCoverage(r.branch,223 + 224,67 + 66);
  assertCoverage(r.instruction,2733 + 2548,1351 + 1613);
  assertCoverage(r.complexity,289 + 246,92 + 137);
  assertEquals(""String_Node_Str"",r.getBuildHealth().getDescription());
}","@Test public void testLoadMultipleReports() throws Exception {
  JacocoBuildAction r=JacocoBuildAction.load(null,null,new JacocoHealthReportThresholds(30,90,25,80,15,60,15,60,20,70,0,0),getClass().getResourceAsStream(""String_Node_Str""),getClass().getResourceAsStream(""String_Node_Str""));
  assertEquals(76,r.clazz.getPercentage());
  assertEquals(41,r.line.getPercentage());
  assertCoverage(r.clazz,9,28);
  assertCoverage(r.method,122,116);
  assertCoverage(r.line,513,361);
  assertCoverage(r.branch,224,66);
  assertCoverage(r.instruction,2548,1613);
  assertCoverage(r.complexity,246,137);
  assertEquals(""String_Node_Str"" + ""String_Node_Str"",r.getBuildHealth().getDescription());
}"
48022,"protected static FilePath[] getJacocoReports(File file) throws IOException, InterruptedException {
  FilePath path=new FilePath(file);
  if (path.isDirectory()) {
    return path.list(""String_Node_Str"");
  }
 else {
    FilePath report=new FilePath(new File(path.getName() + ""String_Node_Str""));
    return report.exists() ? new FilePath[]{report} : new FilePath[0];
  }
}","protected static ArrayList<ModuleInfo> getJacocoReports(File file) throws IOException {
  FilePath path=new FilePath(file);
  ArrayList<ModuleInfo> reports=new ArrayList<ModuleInfo>();
  int i=0;
  try {
    FilePath checkPath=null;
    while (true) {
      if ((checkPath=new FilePath(path,""String_Node_Str"" + i)).exists()) {
        ModuleInfo moduleInfo=new ModuleInfo();
        moduleInfo.setClassDir(new FilePath(checkPath,""String_Node_Str""));
        moduleInfo.setSrcDir(new FilePath(checkPath,""String_Node_Str""));
        moduleInfo.setExecFile(new FilePath(checkPath,""String_Node_Str""));
        moduleInfo.create();
        reports.add(moduleInfo);
      }
 else {
        break;
      }
      i++;
    }
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  return reports;
}"
48023,"/** 
 * Obtains the detailed   {@link CoverageReport} instance.
 */
public synchronized CoverageReport getResult(){
  if (report != null) {
    final CoverageReport r=report.get();
    if (r != null)     return r;
  }
  final File reportFolder=JacocoPublisher.getJacocoReport(owner);
  try {
    CoverageReport r=new CoverageReport(this,reports);
    report=new WeakReference<CoverageReport>(r);
    return r;
  }
 catch (  IOException e) {
    logger.println(""String_Node_Str"" + reportFolder);
    e.printStackTrace(logger);
    return null;
  }
}","/** 
 * Obtains the detailed   {@link CoverageReport} instance.
 */
public synchronized CoverageReport getResult(){
  if (report != null) {
    final CoverageReport r=report.get();
    if (r != null)     return r;
  }
  final File reportFolder=JacocoPublisher.getJacocoReport(owner);
  try {
    ArrayList<ModuleInfo> reports=getJacocoReports(reportFolder);
    CoverageReport r=new CoverageReport(this,reports);
    report=new WeakReference<CoverageReport>(r);
    return r;
  }
 catch (  IOException e) {
    logger.println(""String_Node_Str"" + reportFolder);
    e.printStackTrace(logger);
    return null;
  }
}"
48024,"@Override public boolean perform(AbstractBuild<?,?> build,Launcher launcher,BuildListener listener) throws InterruptedException, IOException {
  EnvVars env=build.getEnvironment(listener);
  env.overrideAll(build.getBuildVariables());
  includes=env.expand(includes);
  final PrintStream logger=listener.getLogger();
  try {
    ReportFactory reportFactory=new ReportFactory(new File(build.getWorkspace().getRemote()),listener);
    reportFactory.createReport();
    logger.println(""String_Node_Str"");
  }
 catch (  IOException e) {
    logger.println(""String_Node_Str"" + build.getWorkspace().getRemote() + e.getMessage());
  }
  ArrayList<ModuleInfo> reports=new ArrayList<ModuleInfo>();
  moduleNum=1;
  FilePath actualBuildDirRoot=new FilePath(getJacocoReport(build));
  for (int i=0; i < moduleNum; ++i) {
    ModuleInfo moduleInfo=new ModuleInfo(listener);
    FilePath actualBuildModuleDir=new FilePath(actualBuildDirRoot,""String_Node_Str"" + i);
    FilePath actualDestination=new FilePath(actualBuildModuleDir,""String_Node_Str"");
    moduleInfo.setClassDir(actualDestination);
    saveCoverageReports(actualDestination,new FilePath(new File(build.getWorkspace().getRemote(),""String_Node_Str"")));
    actualDestination=new FilePath(actualBuildModuleDir,""String_Node_Str"");
    moduleInfo.setSrcDir(actualDestination);
    saveCoverageReports(actualDestination,new FilePath(new File(build.getWorkspace().getRemote(),""String_Node_Str"")));
    FilePath execfile=new FilePath(new File(build.getWorkspace().getRemote(),""String_Node_Str""));
    FilePath seged=actualBuildModuleDir.child(""String_Node_Str"");
    moduleInfo.setExecFile(seged);
    execfile.copyTo(seged);
    moduleInfo.setTitle(new File(actualBuildModuleDir.getRemote()).getName());
    actualDestination=new FilePath(actualBuildModuleDir,""String_Node_Str"");
    saveCoverageReports(actualDestination,new FilePath(new File(build.getWorkspace().getRemote(),""String_Node_Str"")));
    moduleInfo.setGeneratedHTMLsDir(actualDestination);
    reports.add(moduleInfo);
  }
  final JacocoBuildAction action=JacocoBuildAction.load(build,rule,healthReports,listener,reports);
  action.setReports(reports);
  build.getActions().add(action);
  final CoverageReport result=action.getResult();
  if (result == null) {
    logger.println(""String_Node_Str"");
    build.setResult(Result.FAILURE);
  }
  return true;
}","@Override public boolean perform(AbstractBuild<?,?> build,Launcher launcher,BuildListener listener) throws InterruptedException, IOException {
  EnvVars env=build.getEnvironment(listener);
  env.overrideAll(build.getBuildVariables());
  includes=env.expand(includes);
  final PrintStream logger=listener.getLogger();
  try {
    ReportFactory reportFactory=new ReportFactory(new File(build.getWorkspace().getRemote()),listener);
    reportFactory.createReport();
    logger.println(""String_Node_Str"");
  }
 catch (  IOException e) {
    logger.println(""String_Node_Str"" + build.getWorkspace().getRemote() + e.getMessage());
  }
  ArrayList<ModuleInfo> reports=new ArrayList<ModuleInfo>();
  moduleNum=1;
  FilePath actualBuildDirRoot=new FilePath(getJacocoReport(build));
  for (int i=0; i < moduleNum; ++i) {
    ModuleInfo moduleInfo=new ModuleInfo();
    FilePath actualBuildModuleDir=new FilePath(actualBuildDirRoot,""String_Node_Str"" + i);
    FilePath actualDestination=new FilePath(actualBuildModuleDir,""String_Node_Str"");
    moduleInfo.setClassDir(actualDestination);
    saveCoverageReports(actualDestination,new FilePath(new File(build.getWorkspace().getRemote(),""String_Node_Str"")));
    actualDestination=new FilePath(actualBuildModuleDir,""String_Node_Str"");
    moduleInfo.setSrcDir(actualDestination);
    saveCoverageReports(actualDestination,new FilePath(new File(build.getWorkspace().getRemote(),""String_Node_Str"")));
    FilePath execfile=new FilePath(new File(build.getWorkspace().getRemote(),""String_Node_Str""));
    FilePath seged=actualBuildModuleDir.child(""String_Node_Str"");
    moduleInfo.setExecFile(seged);
    execfile.copyTo(seged);
    moduleInfo.setTitle(new File(actualBuildModuleDir.getRemote()).getName());
    actualDestination=new FilePath(actualBuildModuleDir,""String_Node_Str"");
    saveCoverageReports(actualDestination,new FilePath(new File(build.getWorkspace().getRemote(),""String_Node_Str"")));
    moduleInfo.setGeneratedHTMLsDir(actualDestination);
    reports.add(moduleInfo);
  }
  final JacocoBuildAction action=JacocoBuildAction.load(build,rule,healthReports,listener,reports);
  action.setReports(reports);
  build.getActions().add(action);
  final CoverageReport result=action.getResult();
  if (result == null) {
    logger.println(""String_Node_Str"");
    build.setResult(Result.FAILURE);
  }
  return true;
}"
48025,"protected void printRatioTable(Coverage ratio,StringBuilder buf){
  String percent=percentFormat.format(ratio.getPercentageFloat());
  String numerator=intFormat.format(ratio.getMissed());
  String denominator=intFormat.format(ratio.getCovered());
  int maximumCovered=1;
  if (ratio.getType().equals(CoverageElement.Type.INSTRUCTION)) {
    maximumCovered=maxInstruction;
  }
 else   if (ratio.getType().equals(CoverageElement.Type.BRANCH)) {
    maximumCovered=maxBranch;
  }
 else   if (ratio.getType().equals(CoverageElement.Type.COMPLEXITY)) {
    maximumCovered=maxComplexity;
  }
 else   if (ratio.getType().equals(CoverageElement.Type.LINE)) {
    maximumCovered=maxLine;
  }
 else   if (ratio.getType().equals(CoverageElement.Type.METHOD)) {
    maximumCovered=maxMethod;
  }
 else   if (ratio.getType().equals(CoverageElement.Type.CLASS)) {
    maximumCovered=maxClazz;
  }
  buf.append(""String_Node_Str"").append(""String_Node_Str"").append(percent).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(((float)ratio.getCovered() / (float)maximumCovered) * 100).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"" + numerator).append(""String_Node_Str"").append(""String_Node_Str"" + denominator).append(""String_Node_Str"");
}","protected void printRatioTable(Coverage ratio,StringBuilder buf){
  String percent=percentFormat.format(ratio.getPercentageFloat());
  String numerator=intFormat.format(ratio.getMissed());
  String denominator=intFormat.format(ratio.getCovered());
  int maximumCovered=1;
  if (ratio.getType().equals(CoverageElement.Type.INSTRUCTION)) {
    maximumCovered=maxInstruction;
  }
 else   if (ratio.getType().equals(CoverageElement.Type.BRANCH)) {
    maximumCovered=maxBranch;
  }
 else   if (ratio.getType().equals(CoverageElement.Type.COMPLEXITY)) {
    maximumCovered=maxComplexity;
  }
 else   if (ratio.getType().equals(CoverageElement.Type.LINE)) {
    maximumCovered=maxLine;
  }
 else   if (ratio.getType().equals(CoverageElement.Type.METHOD)) {
    maximumCovered=maxMethod;
  }
 else   if (ratio.getType().equals(CoverageElement.Type.CLASS)) {
    maximumCovered=maxClazz;
  }
  buf.append(""String_Node_Str"").append(""String_Node_Str"").append(percent).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(((float)ratio.getCovered() / (float)maximumCovered) * 100).append(""String_Node_Str"").append(""String_Node_Str"").append(((float)ratio.getMissed() / (float)maximumCovered) * 100).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"" + numerator).append(""String_Node_Str"").append(""String_Node_Str"" + denominator).append(""String_Node_Str"");
}"
48026,"protected JFreeChart createGraph(){
  final CategoryDataset dataset=createDataSet(obj).build();
  final JFreeChart chart=ChartFactory.createLineChart(null,null,""String_Node_Str"",dataset,PlotOrientation.VERTICAL,true,true,false);
  final LegendTitle legend=chart.getLegend();
  legend.setPosition(RectangleEdge.RIGHT);
  chart.setBackgroundPaint(Color.white);
  final CategoryPlot plot=chart.getCategoryPlot();
  plot.setBackgroundPaint(Color.WHITE);
  plot.setOutlinePaint(null);
  plot.setRangeGridlinesVisible(true);
  plot.setRangeGridlinePaint(Color.black);
  CategoryAxis domainAxis=new ShiftedCategoryAxis(null);
  plot.setDomainAxis(domainAxis);
  domainAxis.setCategoryLabelPositions(CategoryLabelPositions.UP_90);
  domainAxis.setLowerMargin(0.0);
  domainAxis.setUpperMargin(0.0);
  domainAxis.setCategoryMargin(0.0);
  final NumberAxis rangeAxis=(NumberAxis)plot.getRangeAxis();
  rangeAxis.setStandardTickUnits(NumberAxis.createIntegerTickUnits());
  rangeAxis.setUpperBound(100);
  rangeAxis.setLowerBound(0);
  final LineAndShapeRenderer renderer=(LineAndShapeRenderer)plot.getRenderer();
  renderer.setBaseStroke(new BasicStroke(4.0f));
  ColorPalette.apply(renderer);
  plot.setInsets(new RectangleInsets(5.0,0,0,5.0));
  return chart;
}","protected JFreeChart createGraph(){
  final CategoryDataset dataset=createDataSet(obj).build();
  final JFreeChart chart=ChartFactory.createLineChart(null,null,""String_Node_Str"",dataset,PlotOrientation.VERTICAL,true,true,false);
  final LegendTitle legend=chart.getLegend();
  legend.setPosition(RectangleEdge.RIGHT);
  chart.setBackgroundPaint(Color.white);
  final CategoryPlot plot=chart.getCategoryPlot();
  plot.setBackgroundPaint(Color.WHITE);
  plot.setOutlinePaint(null);
  plot.setRangeGridlinesVisible(true);
  plot.setRangeGridlinePaint(Color.black);
  CategoryAxis domainAxis=new ShiftedCategoryAxis(null);
  plot.setDomainAxis(domainAxis);
  domainAxis.setCategoryLabelPositions(CategoryLabelPositions.UP_90);
  domainAxis.setLowerMargin(0.0);
  domainAxis.setUpperMargin(0.0);
  domainAxis.setCategoryMargin(0.0);
  final NumberAxis rangeAxis=(NumberAxis)plot.getRangeAxis();
  rangeAxis.setStandardTickUnits(NumberAxis.createIntegerTickUnits());
  rangeAxis.setUpperBound(maxLine);
  rangeAxis.setLowerBound(0);
  final LineAndShapeRenderer renderer=(LineAndShapeRenderer)plot.getRenderer();
  renderer.setBaseStroke(new BasicStroke(4.0f));
  ColorPalette.apply(renderer);
  plot.setInsets(new RectangleInsets(5.0,0,0,5.0));
  return chart;
}"
48027,"/** 
 * Generates the graph that shows the coverage trend up to this report.
 */
public void doGraph(StaplerRequest req,StaplerResponse rsp) throws IOException {
  if (ChartUtil.awtProblemCause != null) {
    rsp.sendRedirect2(req.getContextPath() + ""String_Node_Str"");
    return;
  }
  AbstractBuild<?,?> build=getBuild();
  Calendar t=build.getTimestamp();
  String w=Util.fixEmptyAndTrim(req.getParameter(""String_Node_Str""));
  String h=Util.fixEmptyAndTrim(req.getParameter(""String_Node_Str""));
  int width=(w != null) ? Integer.valueOf(w) : 500;
  int height=(h != null) ? Integer.valueOf(h) : 200;
  new GraphImpl(this,t,width,height){
    @Override protected DataSetBuilder<String,NumberOnlyBuildLabel> createDataSet(    CoverageObject<SELF> obj){
      DataSetBuilder<String,NumberOnlyBuildLabel> dsb=new DataSetBuilder<String,NumberOnlyBuildLabel>();
      for (CoverageObject<SELF> a=obj; a != null; a=a.getPreviousResult()) {
        NumberOnlyBuildLabel label=new NumberOnlyBuildLabel(a.getBuild());
        if (a.line != null) {
          dsb.add(a.line.getCovered(),Messages.CoverageObject_Legend_Line(),label);
        }
      }
      return dsb;
    }
  }
.doPng(req,rsp);
}","/** 
 * Generates the graph that shows the coverage trend up to this report.
 */
public void doGraph(StaplerRequest req,StaplerResponse rsp) throws IOException {
  if (ChartUtil.awtProblemCause != null) {
    rsp.sendRedirect2(req.getContextPath() + ""String_Node_Str"");
    return;
  }
  AbstractBuild<?,?> build=getBuild();
  Calendar t=build.getTimestamp();
  String w=Util.fixEmptyAndTrim(req.getParameter(""String_Node_Str""));
  String h=Util.fixEmptyAndTrim(req.getParameter(""String_Node_Str""));
  int width=(w != null) ? Integer.valueOf(w) : 500;
  int height=(h != null) ? Integer.valueOf(h) : 200;
  new GraphImpl(this,t,width,height){
    @Override protected DataSetBuilder<String,NumberOnlyBuildLabel> createDataSet(    CoverageObject<SELF> obj){
      DataSetBuilder<String,NumberOnlyBuildLabel> dsb=new DataSetBuilder<String,NumberOnlyBuildLabel>();
      for (CoverageObject<SELF> a=obj; a != null; a=a.getPreviousResult()) {
        NumberOnlyBuildLabel label=new NumberOnlyBuildLabel(a.getBuild());
        if (a.line != null) {
          dsb.add(a.line.getCovered(),Messages.CoverageObject_Legend_Line(),label);
          dsb.add(a.line.getMissed(),Messages.CoverageObject_Legend_Line(),label);
        }
      }
      return dsb;
    }
  }
.doPng(req,rsp);
}"
48028,"private void loadExecutionData() throws IOException {
  final PrintStream logger=listener.getLogger();
  logger.println(""String_Node_Str"");
  File executionDataFile=new File(execFile.getRemote());
  logger.println(""String_Node_Str"" + executionDataFile.getAbsolutePath());
  logger.println(""String_Node_Str"" + title);
  final FileInputStream fis=new FileInputStream(executionDataFile);
  final ExecutionDataReader executionDataReader=new ExecutionDataReader(fis);
  executionDataStore=new ExecutionDataStore();
  sessionInfoStore=new SessionInfoStore();
  executionDataReader.setExecutionDataVisitor(executionDataStore);
  executionDataReader.setSessionInfoVisitor(sessionInfoStore);
  while (executionDataReader.read()) {
  }
  fis.close();
}","private void loadExecutionData() throws IOException {
  File executionDataFile=new File(execFile.getRemote());
  final FileInputStream fis=new FileInputStream(executionDataFile);
  final ExecutionDataReader executionDataReader=new ExecutionDataReader(fis);
  executionDataStore=new ExecutionDataStore();
  sessionInfoStore=new SessionInfoStore();
  executionDataReader.setExecutionDataVisitor(executionDataStore);
  executionDataReader.setSessionInfoVisitor(sessionInfoStore);
  while (executionDataReader.read()) {
  }
  fis.close();
}"
48029,"private IBundleCoverage analyzeStructure() throws IOException {
  final PrintStream logger=listener.getLogger();
  logger.println(""String_Node_Str"");
  File classDirectory=new File(classDir.getRemote());
  logger.println(""String_Node_Str"" + classDirectory.getAbsolutePath());
  final CoverageBuilder coverageBuilder=new CoverageBuilder();
  final Analyzer analyzer=new Analyzer(executionDataStore,coverageBuilder);
  analyzer.analyzeAll(classDirectory);
  return coverageBuilder.getBundle(title);
}","private IBundleCoverage analyzeStructure() throws IOException {
  File classDirectory=new File(classDir.getRemote());
  final CoverageBuilder coverageBuilder=new CoverageBuilder();
  final Analyzer analyzer=new Analyzer(executionDataStore,coverageBuilder);
  analyzer.analyzeAll(classDirectory);
  return coverageBuilder.getBundle(title);
}"
48030,"@Override protected JFreeChart createGraph(){
  if (summaries == null) {
    JFreeChart chart=ChartFactory.createStackedAreaChart(null,Constants.AXIS_LABEL,Constants.AXIS_LABEL_VALUE,null,PlotOrientation.VERTICAL,true,false,false);
    return chart;
  }
  int lineNumber=0;
  JFreeChart chart=ChartFactory.createLineChart(""String_Node_Str"",Constants.AXIS_LABEL,Constants.AXIS_LABEL_VALUE,buildDataSet(summaries),PlotOrientation.VERTICAL,true,false,false);
  chart.setBackgroundPaint(Color.white);
  CategoryPlot plot=chart.getCategoryPlot();
  CategoryItemRenderer renderer=plot.getRenderer();
  BasicStroke stroke=new BasicStroke(Constants.LINE_THICKNESS,BasicStroke.CAP_ROUND,BasicStroke.JOIN_ROUND);
  renderer.setSeriesStroke(lineNumber++,stroke);
  renderer.setSeriesStroke(lineNumber++,stroke);
  renderer.setSeriesStroke(lineNumber++,stroke);
  renderer.setSeriesStroke(lineNumber,stroke);
  plot.setBackgroundPaint(Color.WHITE);
  plot.setOutlinePaint(null);
  plot.setForegroundAlpha(Constants.FOREGROUND_ALPHA);
  plot.setRangeGridlinesVisible(true);
  plot.setRangeGridlinePaint(Color.black);
  CategoryAxis domainAxis=new ShiftedCategoryAxis(null);
  plot.setDomainAxis(domainAxis);
  domainAxis.setCategoryLabelPositions(CategoryLabelPositions.UP_90);
  domainAxis.setLowerMargin(Constants.DEFAULT_MARGIN);
  domainAxis.setUpperMargin(Constants.DEFAULT_MARGIN);
  domainAxis.setCategoryMargin(Constants.DEFAULT_MARGIN);
  NumberAxis rangeAxis=(NumberAxis)plot.getRangeAxis();
  rangeAxis.setStandardTickUnits(NumberAxis.createIntegerTickUnits());
  rangeAxis.setUpperBound(Constants.UPPER_BOUND);
  rangeAxis.setLowerBound(Constants.LOWER_BOUND);
  return chart;
}","@Override protected JFreeChart createGraph(){
  if (summaries == null) {
    JFreeChart chart=ChartFactory.createStackedAreaChart(null,Constants.AXIS_LABEL,Constants.AXIS_LABEL_VALUE,null,PlotOrientation.VERTICAL,true,false,false);
    return chart;
  }
  int lineNumber=0;
  JFreeChart chart=ChartFactory.createLineChart(""String_Node_Str"",Constants.AXIS_LABEL,Constants.AXIS_LABEL_VALUE,buildDataSet(summaries),PlotOrientation.VERTICAL,true,false,false);
  chart.setBackgroundPaint(Color.white);
  CategoryPlot plot=chart.getCategoryPlot();
  CategoryItemRenderer renderer=plot.getRenderer();
  BasicStroke stroke=new BasicStroke(Constants.LINE_THICKNESS,BasicStroke.CAP_ROUND,BasicStroke.JOIN_ROUND);
  renderer.setSeriesStroke(lineNumber++,stroke);
  renderer.setSeriesStroke(lineNumber++,stroke);
  renderer.setSeriesStroke(lineNumber++,stroke);
  renderer.setSeriesStroke(lineNumber,stroke);
  plot.setBackgroundPaint(Color.WHITE);
  plot.setOutlinePaint(null);
  plot.setForegroundAlpha(Constants.FOREGROUND_ALPHA);
  plot.setRangeGridlinesVisible(true);
  plot.setRangeGridlinePaint(Color.black);
  CategoryAxis domainAxis=new ShiftedCategoryAxis(null);
  plot.setDomainAxis(domainAxis);
  domainAxis.setCategoryLabelPositions(CategoryLabelPositions.UP_90);
  domainAxis.setLowerMargin(Constants.DEFAULT_MARGIN);
  domainAxis.setUpperMargin(Constants.DEFAULT_MARGIN);
  domainAxis.setCategoryMargin(Constants.DEFAULT_MARGIN);
  NumberAxis rangeAxis=(NumberAxis)plot.getRangeAxis();
  rangeAxis.setStandardTickUnits(NumberAxis.createIntegerTickUnits());
  rangeAxis.setLowerBound(Constants.LOWER_BOUND);
  return chart;
}"
48031,"/** 
 * Creates a graph for JaCoCo Coverage results.
 * @param summaries HashMap(key = run date and value = Instrumentation tests results)
 * @param widthParam the chart width
 * @param heightParam the chart height
 * @return Graph (JFreeChart)
 */
private static Graph createTrendChart(final Map<LocalDate,JacocoCoverageResultSummary> summaries,int widthParam,int heightParam){
  return new Graph(-1,widthParam,heightParam){
    @Override protected JFreeChart createGraph(){
      if (summaries == null) {
        JFreeChart chart=ChartFactory.createStackedAreaChart(null,Constants.AXIS_LABEL,Constants.AXIS_LABEL_VALUE,null,PlotOrientation.VERTICAL,true,false,false);
        return chart;
      }
      int lineNumber=0;
      JFreeChart chart=ChartFactory.createLineChart(""String_Node_Str"",Constants.AXIS_LABEL,Constants.AXIS_LABEL_VALUE,buildDataSet(summaries),PlotOrientation.VERTICAL,true,false,false);
      chart.setBackgroundPaint(Color.white);
      CategoryPlot plot=chart.getCategoryPlot();
      CategoryItemRenderer renderer=plot.getRenderer();
      BasicStroke stroke=new BasicStroke(Constants.LINE_THICKNESS,BasicStroke.CAP_ROUND,BasicStroke.JOIN_ROUND);
      renderer.setSeriesStroke(lineNumber++,stroke);
      renderer.setSeriesStroke(lineNumber++,stroke);
      renderer.setSeriesStroke(lineNumber++,stroke);
      renderer.setSeriesStroke(lineNumber,stroke);
      plot.setBackgroundPaint(Color.WHITE);
      plot.setOutlinePaint(null);
      plot.setForegroundAlpha(Constants.FOREGROUND_ALPHA);
      plot.setRangeGridlinesVisible(true);
      plot.setRangeGridlinePaint(Color.black);
      CategoryAxis domainAxis=new ShiftedCategoryAxis(null);
      plot.setDomainAxis(domainAxis);
      domainAxis.setCategoryLabelPositions(CategoryLabelPositions.UP_90);
      domainAxis.setLowerMargin(Constants.DEFAULT_MARGIN);
      domainAxis.setUpperMargin(Constants.DEFAULT_MARGIN);
      domainAxis.setCategoryMargin(Constants.DEFAULT_MARGIN);
      NumberAxis rangeAxis=(NumberAxis)plot.getRangeAxis();
      rangeAxis.setStandardTickUnits(NumberAxis.createIntegerTickUnits());
      rangeAxis.setUpperBound(Constants.UPPER_BOUND);
      rangeAxis.setLowerBound(Constants.LOWER_BOUND);
      return chart;
    }
  }
;
}","/** 
 * Creates a graph for JaCoCo Coverage results.
 * @param summaries HashMap(key = run date and value = Instrumentation tests results)
 * @param widthParam the chart width
 * @param heightParam the chart height
 * @return Graph (JFreeChart)
 */
private static Graph createTrendChart(final Map<LocalDate,JacocoCoverageResultSummary> summaries,int widthParam,int heightParam){
  return new Graph(-1,widthParam,heightParam){
    @Override protected JFreeChart createGraph(){
      if (summaries == null) {
        JFreeChart chart=ChartFactory.createStackedAreaChart(null,Constants.AXIS_LABEL,Constants.AXIS_LABEL_VALUE,null,PlotOrientation.VERTICAL,true,false,false);
        return chart;
      }
      int lineNumber=0;
      JFreeChart chart=ChartFactory.createLineChart(""String_Node_Str"",Constants.AXIS_LABEL,Constants.AXIS_LABEL_VALUE,buildDataSet(summaries),PlotOrientation.VERTICAL,true,false,false);
      chart.setBackgroundPaint(Color.white);
      CategoryPlot plot=chart.getCategoryPlot();
      CategoryItemRenderer renderer=plot.getRenderer();
      BasicStroke stroke=new BasicStroke(Constants.LINE_THICKNESS,BasicStroke.CAP_ROUND,BasicStroke.JOIN_ROUND);
      renderer.setSeriesStroke(lineNumber++,stroke);
      renderer.setSeriesStroke(lineNumber++,stroke);
      renderer.setSeriesStroke(lineNumber++,stroke);
      renderer.setSeriesStroke(lineNumber,stroke);
      plot.setBackgroundPaint(Color.WHITE);
      plot.setOutlinePaint(null);
      plot.setForegroundAlpha(Constants.FOREGROUND_ALPHA);
      plot.setRangeGridlinesVisible(true);
      plot.setRangeGridlinePaint(Color.black);
      CategoryAxis domainAxis=new ShiftedCategoryAxis(null);
      plot.setDomainAxis(domainAxis);
      domainAxis.setCategoryLabelPositions(CategoryLabelPositions.UP_90);
      domainAxis.setLowerMargin(Constants.DEFAULT_MARGIN);
      domainAxis.setUpperMargin(Constants.DEFAULT_MARGIN);
      domainAxis.setCategoryMargin(Constants.DEFAULT_MARGIN);
      NumberAxis rangeAxis=(NumberAxis)plot.getRangeAxis();
      rangeAxis.setStandardTickUnits(NumberAxis.createIntegerTickUnits());
      rangeAxis.setLowerBound(Constants.LOWER_BOUND);
      return chart;
    }
  }
;
}"
48032,"/** 
 * Gets the previous   {@link EmmaBuildAction} of the given build.
 */
static EmmaBuildAction getPreviousResult(Build start){
  Build b=start;
  while (true) {
    b=b.getPreviousBuild();
    if (b == null)     return null;
    if (b.getResult() == Result.FAILURE)     continue;
    EmmaBuildAction r=b.getAction(EmmaBuildAction.class);
    if (r != null)     return r;
  }
}","/** 
 * Gets the previous   {@link EmmaBuildAction} of the given build.
 */
static EmmaBuildAction getPreviousResult(Build start){
  Build<?,?> b=start;
  while (true) {
    b=b.getPreviousBuild();
    if (b == null)     return null;
    if (b.getResult() == Result.FAILURE)     continue;
    EmmaBuildAction r=b.getAction(EmmaBuildAction.class);
    if (r != null)     return r;
  }
}"
48033,"/** 
 * Gets the most recent   {@link EmmaBuildAction} object.
 */
public EmmaBuildAction getLastResult(){
  for (Build b=project.getLastBuild(); b != null; b=b.getPreviousBuild()) {
    if (b.getResult() == Result.FAILURE)     continue;
    EmmaBuildAction r=b.getAction(EmmaBuildAction.class);
    if (r != null)     return r;
  }
  return null;
}","/** 
 * Gets the most recent   {@link EmmaBuildAction} object.
 */
public EmmaBuildAction getLastResult(){
  for (Build<?,?> b=project.getLastBuild(); b != null; b=b.getPreviousBuild()) {
    if (b.getResult() == Result.FAILURE)     continue;
    EmmaBuildAction r=b.getAction(EmmaBuildAction.class);
    if (r != null)     return r;
  }
  return null;
}"
48034,"@Override public SELF getPreviousResult(){
  PARENT p=parent;
  while (true) {
    p=p.getPreviousResult();
    if (p == null)     return null;
    SELF prev=(SELF)parent.getChildren().get(name);
    if (prev != null)     return prev;
  }
}","@Override public SELF getPreviousResult(){
  PARENT p=parent;
  while (true) {
    p=p.getPreviousResult();
    if (p == null)     return null;
    SELF prev=(SELF)p.getChildren().get(name);
    if (prev != null)     return prev;
  }
}"
48035,"@Nullable public static long getLong(CkAttribute raw){
  int dataLen=raw.getLength().intValue();
  if (dataLen > 0) {
    if (dataLen == 4) {
      return raw.getData().getInt(0);
    }
 else {
      return raw.getData().getLong(0);
    }
  }
 else {
    return -1;
  }
}","@Nullable public static long getLong(CkAttribute raw){
  int dataLen=raw.getLength().intValue();
  if (dataLen > 0) {
    return getLongFromPointer(raw.getData(),0);
  }
 else {
    return -1;
  }
}"
48036,"@Nullable public static long[] getLongs(CkAttribute raw){
  int dataLen=raw.getLength().intValue();
  if (dataLen > 0) {
    return raw.getData().getLongArray(0,dataLen / 8);
  }
 else {
    return new long[0];
  }
}","@Nullable public static long[] getLongs(CkAttribute raw){
  int dataLen=raw.getLength().intValue();
  long[] result=new long[dataLen / NativeLong.SIZE];
  for (int i=0, o=0; o < dataLen; i++, o+=NativeLong.SIZE) {
    result[i]=getLongFromPointer(raw.getData(),o);
  }
  return result;
}"
48037,"@Override public void signalEvent(EventType eventType,EventObject eventData){
  LOG.debug(""String_Node_Str"",eventType);
  ConnectionHandleType ch=eventData.getHandle();
  if (ch == null) {
    LOG.error(""String_Node_Str"",eventType);
    return;
  }
  LOG.debug(""String_Node_Str"",ch);
  RecognitionInfo info=ch.getRecognitionInfo();
  LOG.debug(""String_Node_Str"",info);
  String ifdName=ch.getIFDName();
  LOG.debug(""String_Node_Str"",ifdName);
  if (null != eventType) {
switch (eventType) {
case TERMINAL_ADDED:
      addInfo(ifdName,info);
    break;
case TERMINAL_REMOVED:
  removeInfo(ifdName);
break;
default :
EventType lastStatus=cardStatus.get(ifdName);
if (EventType.CARD_RECOGNIZED == lastStatus) {
if (EventType.CARD_REMOVED == eventType) {
cardStatus.remove(ifdName);
updateInfo(ifdName,info);
}
}
 else {
if (EventType.CARD_REMOVED == eventType) {
cardStatus.remove(ifdName);
}
 else {
cardStatus.put(ifdName,eventType);
}
updateInfo(ifdName,info);
}
}
}
}","@Override public synchronized void signalEvent(EventType eventType,EventObject eventData){
  LOG.debug(""String_Node_Str"",eventType);
  ConnectionHandleType ch=eventData.getHandle();
  if (ch == null) {
    LOG.error(""String_Node_Str"",eventType);
    return;
  }
  LOG.debug(""String_Node_Str"",ch);
  RecognitionInfo info=ch.getRecognitionInfo();
  LOG.debug(""String_Node_Str"",info);
  String ifdName=ch.getIFDName();
  LOG.debug(""String_Node_Str"",ifdName);
  if (null != eventType) {
switch (eventType) {
case TERMINAL_ADDED:
      addInfo(ifdName,info);
    break;
case TERMINAL_REMOVED:
  removeInfo(ifdName);
break;
default :
EventType lastStatus=cardStatus.get(ifdName);
if (EventType.CARD_RECOGNIZED == lastStatus) {
if (EventType.CARD_REMOVED == eventType) {
cardStatus.remove(ifdName);
updateInfo(ifdName,info);
}
}
 else {
if (EventType.CARD_REMOVED == eventType) {
cardStatus.remove(ifdName);
}
 else {
cardStatus.put(ifdName,eventType);
}
updateInfo(ifdName,info);
}
}
}
}"
48038,"public void initialize() throws UnableToInitialize, NfcUnavailable, NfcDisabled, ApduExtLengthNotSupported {
  String errorMsg=SERVICE_RESPONSE_FAILED;
  if (initialized) {
    throw new UnableToInitialize(SERVICE_ALREADY_INITIALIZED);
  }
  Runnable delegatingRunnable=new Runnable(){
    @Override public void run(){
      Runnable runner=getEacStarter();
      if (runner == null) {
        LOG.error(""String_Node_Str"");
      }
 else {
        runner.run();
      }
    }
  }
;
  List<UserConsentNavigatorFactory> factories=Arrays.asList(new EacNavigatorFactory(delegatingRunnable),new InsertCardNavigatorFactory());
  gui=new AndroidUserConsent(this,factories);
  IFDProperties.setProperty(IFD_FACTORY_KEY,IFD_FACTORY_VALUE);
  WsdefProperties.setProperty(WSDEF_MARSHALLER_KEY,WSDEF_MARSHALLER_VALUE);
  NFCFactory.setContext(this);
  try {
    nfcAvailable=NFCFactory.isNFCAvailable();
    nfcEnabled=NFCFactory.isNFCEnabled();
    nfcExtendedLengthSupport=NfcUtils.supportsExtendedLength(this);
    if (!nfcAvailable) {
      throw new NfcUnavailable();
    }
 else     if (!nfcEnabled) {
      throw new NfcDisabled();
    }
 else     if (!nfcExtendedLengthSupport) {
      throw new ApduExtLengthNotSupported(NFC_NO_EXTENDED_LENGTH_SUPPORT);
    }
    terminalFactory=IFDTerminalFactory.getInstance();
    LOG.info(""String_Node_Str"");
  }
 catch (  IFDException ex) {
    errorMsg=UNABLE_TO_INITIALIZE_TF;
    throw new UnableToInitialize(errorMsg,ex);
  }
  try {
    env=new ClientEnv();
    dispatcher=new MessageDispatcher(env);
    env.setDispatcher(dispatcher);
    LOG.info(""String_Node_Str"");
    management=new TinyManagement(env);
    env.setManagement(management);
    LOG.info(""String_Node_Str"");
    eventDispatcher=new EventDispatcherImpl();
    env.setEventDispatcher(eventDispatcher);
    LOG.info(""String_Node_Str"");
    cardStates=new CardStateMap();
    SALStateCallback salCallback=new SALStateCallback(env,cardStates);
    eventDispatcher.add(salCallback);
    ifd=new IFD();
    ifd.addProtocol(ECardConstants.Protocol.PACE,new PACEProtocolFactory());
    ifd.setGUI(gui);
    ifd.setEnvironment(env);
    env.setIFD(ifd);
    LOG.info(""String_Node_Str"");
    try {
      recognition=new CardRecognitionImpl(env);
      recognition.setGUI(gui);
      env.setRecognition(recognition);
      LOG.info(""String_Node_Str"");
    }
 catch (    Exception ex) {
      errorMsg=CARD_REC_INIT_FAILED;
      throw ex;
    }
    TinySAL mainSAL=new TinySAL(env,cardStates);
    mainSAL.setGUI(gui);
    sal=new SelectorSAL(mainSAL,env);
    env.setSAL(sal);
    env.setCIFProvider(sal);
    LOG.info(""String_Node_Str"");
    try {
      manager=new AddonManager(env,gui,cardStates,new StubViewController(),new ClasspathRegistry());
      mainSAL.setAddonManager(manager);
    }
 catch (    Exception ex) {
      errorMsg=ADD_ON_INIT_FAILED;
      throw ex;
    }
    eventDispatcher.add(this,EventType.TERMINAL_ADDED,EventType.TERMINAL_REMOVED,EventType.CARD_INSERTED,EventType.CARD_RECOGNIZED,EventType.CARD_REMOVED);
    eventDispatcher.start();
    LOG.info(""String_Node_Str"");
    try {
      WSHelper.checkResult(sal.initialize(new Initialize()));
    }
 catch (    WSHelper.WSException ex) {
      errorMsg=ex.getMessage();
      throw ex;
    }
    try {
      EstablishContext establishContext=new EstablishContext();
      EstablishContextResponse establishContextResponse=ifd.establishContext(establishContext);
      WSHelper.checkResult(establishContextResponse);
      contextHandle=establishContextResponse.getContextHandle();
      LOG.info(""String_Node_Str"",ByteUtils.toHexString(contextHandle));
    }
 catch (    WSHelper.WSException ex) {
      errorMsg=ESTABLISH_IFD_CONTEXT_FAILED;
      throw ex;
    }
    IntentBinding.getInstance().setAddonManager(manager);
    initialized=true;
  }
 catch (  Exception ex) {
    LOG.error(errorMsg,ex);
    throw new UnableToInitialize(errorMsg,ex);
  }
}","public void initialize() throws UnableToInitialize, NfcUnavailable, NfcDisabled, ApduExtLengthNotSupported {
  String errorMsg=SERVICE_RESPONSE_FAILED;
  if (initialized) {
    throw new UnableToInitialize(SERVICE_ALREADY_INITIALIZED);
  }
  if (appCtx == null) {
    throw new IllegalStateException(NO_APPLICATION_CONTEXT);
  }
  Runnable delegatingRunnable=new Runnable(){
    @Override public void run(){
      Runnable runner=getEacStarter();
      if (runner == null) {
        LOG.error(""String_Node_Str"");
      }
 else {
        runner.run();
      }
    }
  }
;
  List<UserConsentNavigatorFactory> factories=Arrays.asList(new EacNavigatorFactory(delegatingRunnable),new InsertCardNavigatorFactory());
  gui=new AndroidUserConsent(appCtx,factories);
  IFDProperties.setProperty(IFD_FACTORY_KEY,IFD_FACTORY_VALUE);
  WsdefProperties.setProperty(WSDEF_MARSHALLER_KEY,WSDEF_MARSHALLER_VALUE);
  NFCFactory.setContext(appCtx);
  try {
    nfcAvailable=NFCFactory.isNFCAvailable();
    nfcEnabled=NFCFactory.isNFCEnabled();
    nfcExtendedLengthSupport=NfcUtils.supportsExtendedLength(appCtx);
    if (!nfcAvailable) {
      throw new NfcUnavailable();
    }
 else     if (!nfcEnabled) {
      throw new NfcDisabled();
    }
 else     if (!nfcExtendedLengthSupport) {
      throw new ApduExtLengthNotSupported(NFC_NO_EXTENDED_LENGTH_SUPPORT);
    }
    terminalFactory=IFDTerminalFactory.getInstance();
    LOG.info(""String_Node_Str"");
  }
 catch (  IFDException ex) {
    errorMsg=UNABLE_TO_INITIALIZE_TF;
    throw new UnableToInitialize(errorMsg,ex);
  }
  try {
    env=new ClientEnv();
    dispatcher=new MessageDispatcher(env);
    env.setDispatcher(dispatcher);
    LOG.info(""String_Node_Str"");
    management=new TinyManagement(env);
    env.setManagement(management);
    LOG.info(""String_Node_Str"");
    eventDispatcher=new EventDispatcherImpl();
    env.setEventDispatcher(eventDispatcher);
    LOG.info(""String_Node_Str"");
    cardStates=new CardStateMap();
    SALStateCallback salCallback=new SALStateCallback(env,cardStates);
    eventDispatcher.add(salCallback);
    ifd=new IFD();
    ifd.addProtocol(ECardConstants.Protocol.PACE,new PACEProtocolFactory());
    ifd.setGUI(gui);
    ifd.setEnvironment(env);
    env.setIFD(ifd);
    LOG.info(""String_Node_Str"");
    try {
      recognition=new CardRecognitionImpl(env);
      recognition.setGUI(gui);
      env.setRecognition(recognition);
      LOG.info(""String_Node_Str"");
    }
 catch (    Exception ex) {
      errorMsg=CARD_REC_INIT_FAILED;
      throw ex;
    }
    TinySAL mainSAL=new TinySAL(env,cardStates);
    mainSAL.setGUI(gui);
    sal=new SelectorSAL(mainSAL,env);
    env.setSAL(sal);
    env.setCIFProvider(sal);
    LOG.info(""String_Node_Str"");
    try {
      manager=new AddonManager(env,gui,cardStates,new StubViewController(),new ClasspathRegistry());
      mainSAL.setAddonManager(manager);
    }
 catch (    Exception ex) {
      errorMsg=ADD_ON_INIT_FAILED;
      throw ex;
    }
    eventDispatcher.add(this,EventType.TERMINAL_ADDED,EventType.TERMINAL_REMOVED,EventType.CARD_INSERTED,EventType.CARD_RECOGNIZED,EventType.CARD_REMOVED);
    eventDispatcher.start();
    LOG.info(""String_Node_Str"");
    try {
      WSHelper.checkResult(sal.initialize(new Initialize()));
    }
 catch (    WSHelper.WSException ex) {
      errorMsg=ex.getMessage();
      throw ex;
    }
    try {
      EstablishContext establishContext=new EstablishContext();
      EstablishContextResponse establishContextResponse=ifd.establishContext(establishContext);
      WSHelper.checkResult(establishContextResponse);
      contextHandle=establishContextResponse.getContextHandle();
      LOG.info(""String_Node_Str"",ByteUtils.toHexString(contextHandle));
    }
 catch (    WSHelper.WSException ex) {
      errorMsg=ESTABLISH_IFD_CONTEXT_FAILED;
      throw ex;
    }
    IntentBinding.getInstance().setAddonManager(manager);
    initialized=true;
  }
 catch (  Exception ex) {
    LOG.error(errorMsg,ex);
    throw new UnableToInitialize(errorMsg,ex);
  }
}"
48039,"public synchronized static ServiceContext getServiceContext(){
  return ctx;
}","public static ServiceContext getServiceContext(){
synchronized (ServiceContext.class) {
    if (ctx == null) {
      ctx=new ServiceContext();
    }
  }
  return ctx;
}"
48040,"@Override public void setResultOfBindingTask(BindingTaskResponse response){
  redirectToResultLocation(response.getBindingResult());
}","@Override public void setResultOfBindingTask(BindingTaskResponse response){
  BindingResult result=response.getBindingResult();
switch (result.getResultCode()) {
case OK:
    authenticationSuccess(result);
  break;
case REDIRECT:
authenticationSuccess(result);
redirectToResultLocation(result);
break;
default :
authenticationFailure(response.getBindingResult());
break;
}
}"
48041,"private ServiceContext getServiceContext() throws UnableToInitialize, NfcUnavailable, NfcDisabled, ApduExtLengthNotSupported {
  ServiceContext ctx=null;
  if (isRequiredAPIUsed) {
    ctx=(ServiceContext)((ContextWrapper)calling).getApplicationContext();
    if (!ctx.isInitialized()) {
      ctx.initialize();
    }
  }
 else {
    LOG.warn(BELOW_API_LEVEL_21_NOT_SUPPORTED);
  }
  return ctx;
}","private ServiceContext getServiceContext() throws UnableToInitialize, NfcUnavailable, NfcDisabled, ApduExtLengthNotSupported {
  ServiceContext ctx=null;
  if (isRequiredAPIUsed) {
    ctx=ServiceContext.getServiceContext();
    if (!ctx.isInitialized()) {
      ctx.initialize();
    }
  }
 else {
    LOG.warn(BELOW_API_LEVEL_21_NOT_SUPPORTED);
  }
  return ctx;
}"
48042,"public synchronized void startService(){
  if (isServiceBinded && !isConnected) {
    startOpeneCardService();
  }
 else   if (!isServiceBinded) {
    Intent i=createOpeneCardIntent();
    LOG.info(""String_Node_Str"");
    ctx.startService(i);
    LOG.info(""String_Node_Str"");
    ctx.bindService(i,serviceConnection,ServiceContext.BIND_AUTO_CREATE);
  }
}","public synchronized void startService(){
  if (isServiceBinded && !isConnected) {
    startOpeneCardService();
  }
 else   if (!isServiceBinded) {
    Intent i=createOpeneCardIntent();
    LOG.info(""String_Node_Str"");
    ctx.startService(i);
    LOG.info(""String_Node_Str"");
    ctx.bindService(i,serviceConnection,Context.BIND_AUTO_CREATE);
  }
}"
48043,"private void startOpeneCardService(){
  try {
    ServiceResponse response=mService.start();
    isConnected=false;
switch (response.getResponseLevel()) {
case INFO:
      isConnected=true;
    responseHandler.onConnectionSuccess();
  break;
case WARNING:
responseHandler.onConnectionFailure((ServiceWarningResponse)response);
break;
case ERROR:
responseHandler.onConnectionFailure((ServiceErrorResponse)response);
break;
default :
break;
}
}
 catch (RemoteException ex) {
responseHandler.onConnectionFailure(buildErrorResponse(ex));
}
}","private void startOpeneCardService(){
  ServiceContext.getServiceContext().setApplicationContext(ctx);
  try {
    ServiceResponse response=mService.start();
    isConnected=false;
switch (response.getResponseLevel()) {
case INFO:
      isConnected=true;
    responseHandler.onConnectionSuccess();
  break;
case WARNING:
responseHandler.onConnectionFailure((ServiceWarningResponse)response);
break;
case ERROR:
responseHandler.onConnectionFailure((ServiceErrorResponse)response);
break;
default :
break;
}
}
 catch (RemoteException ex) {
responseHandler.onConnectionFailure(buildErrorResponse(ex));
}
}"
48044,"@Override public ServiceResponse stop() throws RemoteException {
  LOG.info(""String_Node_Str"");
  ServiceContext ctx=(ServiceContext)service.getApplicationContext();
  ShutdownTask task=new ShutdownTask(ctx,(ShutdownTaskResult)service);
  try {
    ShutdownTaskResponse response=task.execute().get();
    stopSelf();
    return response.getResponse();
  }
 catch (  ExecutionException|InterruptedException ex) {
    LOG.warn(ex.getMessage(),ex);
    stopSelf();
    return new ServiceErrorResponse(ServiceResponseStatusCodes.INTERNAL_ERROR,ex.getMessage());
  }
}","@Override public ServiceResponse stop() throws RemoteException {
  LOG.info(""String_Node_Str"");
  ServiceContext ctx=ServiceContext.getServiceContext();
  ShutdownTask task=new ShutdownTask(ctx,(ShutdownTaskResult)service);
  try {
    ShutdownTaskResponse response=task.execute().get();
    stopSelf();
    return response.getResponse();
  }
 catch (  ExecutionException|InterruptedException ex) {
    LOG.warn(ex.getMessage(),ex);
    stopSelf();
    return new ServiceErrorResponse(ServiceResponseStatusCodes.INTERNAL_ERROR,ex.getMessage());
  }
}"
48045,"public void enableNFCDispatch(Activity activity){
  if (isNFCAvailable && isNFCEnabled && isContextInitialized()) {
    LOG.debug(""String_Node_Str"");
    Intent activityIntent=new Intent(activity,activity.getClass()).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
    PendingIntent pendingIntent=PendingIntent.getActivity(activity,0,activityIntent,0);
    NfcAdapter.getDefaultAdapter(ctx).enableForegroundDispatch(activity,pendingIntent,null,null);
  }
}","public void enableNFCDispatch(Activity activity){
  if (isNFCAvailable && isNFCEnabled && isContextInitialized()) {
    LOG.debug(""String_Node_Str"");
    Intent activityIntent=new Intent(activity,activity.getClass()).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
    PendingIntent pendingIntent=PendingIntent.getActivity(activity,0,activityIntent,0);
    Context appCtx=ctx.getApplicationContext();
    NfcAdapter.getDefaultAdapter(appCtx).enableForegroundDispatch(activity,pendingIntent,null,null);
  }
}"
48046,"public void disableNFCDispatch(Activity activity){
  if (isNFCAvailable && isNFCEnabled && isContextInitialized()) {
    LOG.debug(""String_Node_Str"");
    NfcAdapter.getDefaultAdapter(ctx).disableForegroundDispatch(activity);
  }
}","public void disableNFCDispatch(Activity activity){
  if (isNFCAvailable && isNFCEnabled && isContextInitialized()) {
    LOG.debug(""String_Node_Str"");
    Context appCtx=ctx.getApplicationContext();
    NfcAdapter.getDefaultAdapter(appCtx).disableForegroundDispatch(activity);
  }
}"
48047,"public static void prepare(){
  serviceImpl=new Promise<>();
}","public static void prepare(){
  if (serviceImpl.isDelivered()) {
    initialise();
  }
}"
48048,"@Override public void close(){
  EacGuiService.prepare();
}","@Override public void close(){
  EacGuiService.close();
}"
48049,"@AfterMethod public void tearDown(){
  EacGuiService.prepare();
}","@AfterMethod public void tearDown(){
  EacGuiService.close();
}"
48050,"@Test public void testPinOkFirstTime() throws InterruptedException, RemoteException {
  EacGuiService.prepare();
  final EacGuiImpl anyGuiImpl=new EacGuiImpl();
  Thread t=new Thread(new Runnable(){
    @Override public void run(){
      UserConsentDescription uc=new UserConsentDescription(""String_Node_Str"");
      uc.getSteps().addAll(createInitialSteps());
      EacNavigator nav=new EacNavigator(anyGuiImpl,uc);
      ExecutionEngine exe=new ExecutionEngine(nav);
      exe.process();
    }
  }
,""String_Node_Str"");
  t.start();
  ServerData sd=anyGuiImpl.getServerData();
  assertEquals(sd.getSubject(),""String_Node_Str"");
  anyGuiImpl.selectAttributes(sd.getReadAccessAttributes(),sd.getWriteAccessAttributes());
  assertEquals(anyGuiImpl.getPinStatus(),""String_Node_Str"");
  assertTrue(anyGuiImpl.enterPin(null,""String_Node_Str""));
  t.join();
}","@Test public void testPinOkFirstTime() throws InterruptedException, RemoteException {
  final EacGuiImpl anyGuiImpl=new EacGuiImpl();
  Thread t=new Thread(new Runnable(){
    @Override public void run(){
      UserConsentDescription uc=new UserConsentDescription(""String_Node_Str"");
      uc.getSteps().addAll(createInitialSteps());
      EacNavigator nav=new EacNavigator(anyGuiImpl,uc);
      ExecutionEngine exe=new ExecutionEngine(nav);
      exe.process();
    }
  }
,""String_Node_Str"");
  t.start();
  ServerData sd=anyGuiImpl.getServerData();
  assertEquals(sd.getSubject(),""String_Node_Str"");
  anyGuiImpl.selectAttributes(sd.getReadAccessAttributes(),sd.getWriteAccessAttributes());
  assertEquals(anyGuiImpl.getPinStatus(),""String_Node_Str"");
  assertTrue(anyGuiImpl.enterPin(null,""String_Node_Str""));
  t.join();
}"
48051,"@AfterMethod public void tearDown(){
  EacGuiService.prepare();
}","@AfterMethod public void tearDown(){
  EacGuiService.close();
}"
48052,"@Test public void givenBindingStartsBeforeGuiAssignmentThenBindingWaitsForGuiAssignment(@Tested final EacGuiService sut,@Mocked final Intent inputIntent,@Mocked EacGuiImpl inputGui) throws InterruptedException, ExecutionException {
  Future<IBinder> future=callBindAsync(sut,inputIntent);
  TimeUnit.MILLISECONDS.sleep(2);
  EacGuiService.setGuiImpl(inputGui);
  IBinder result=future.get();
  assertEquals(result,inputGui);
}","@Test public void givenBindingStartsBeforeGuiAssignmentThenBindingWaitsForGuiAssignment(@Tested final EacGuiService sut,@Mocked final Intent inputIntent,@Mocked EacGuiImpl inputGui) throws InterruptedException, ExecutionException, TimeoutException {
  Future<IBinder> future=callBindAsync(sut,inputIntent);
  TimeUnit.MILLISECONDS.sleep(2);
  EacGuiService.setGuiImpl(inputGui);
  IBinder result=getValueImmediately(future);
  assertEquals(result,inputGui);
}"
48053,"@AfterMethod public void tearDown(){
  EacGuiService.prepare();
}","@AfterMethod public void tearDown(){
  EacGuiService.close();
}"
48054,"@Override public void disconnect(boolean arg0) throws SCIOException {
  try {
    nfcCardChannel.close();
    if (isodep != null) {
      isodep.close();
      isodep=null;
    }
  }
 catch (  IOException e) {
    throw new SCIOException(""String_Node_Str"",SCIOErrorCode.SCARD_F_UNKNOWN_ERROR,e);
  }
}","@Override public void disconnect(boolean arg0) throws SCIOException {
  try {
    nfcCardChannel.close();
synchronized (this) {
      if (isodep != null) {
        isodep.close();
        isodep=null;
      }
    }
  }
 catch (  IOException e) {
    throw new SCIOException(""String_Node_Str"",SCIOErrorCode.SCARD_F_UNKNOWN_ERROR,e);
  }
}"
48055,"public List<OutputInfoUnit> getPinResult(Step pinStep) throws InterruptedException {
  boolean hasPin=false;
  boolean hasCan=false;
  for (  InputInfoUnit nextIn : pinStep.getInputInfoUnits()) {
    if (nextIn.getID().equals(""String_Node_Str"")) {
      hasPin=true;
    }
 else     if (nextIn.getID().equals(""String_Node_Str"")) {
      hasCan=true;
    }
  }
  if (hasPin && !hasCan) {
    this.pinStatus.deliver(PinStatus.PIN.name());
  }
 else   if (hasPin && hasCan) {
    this.pinStatus.deliver(PinStatus.CAN.name());
  }
 else {
    this.pinStatus.deliver(PinStatus.BLOCKED.name());
    return Collections.EMPTY_LIST;
  }
  String pinValue=this.userPin.deref();
  String canValue=this.userCan.deref();
  ArrayList<OutputInfoUnit> result=new ArrayList<>();
  for (  InputInfoUnit nextIn : pinStep.getInputInfoUnits()) {
    if (pinValue != null && nextIn instanceof PasswordField && nextIn.getID().equals(""String_Node_Str"")) {
      PasswordField pw=new PasswordField(nextIn.getID());
      pw.copyContentFrom(nextIn);
      pw.setValue(pinValue.toCharArray());
    }
 else     if (canValue != null && nextIn instanceof PasswordField && nextIn.getID().equals(""String_Node_Str"")) {
      PasswordField pw=new PasswordField(nextIn.getID());
      pw.copyContentFrom(nextIn);
      pw.setValue(canValue.toCharArray());
    }
  }
  return result;
}","public List<OutputInfoUnit> getPinResult(Step pinStep) throws InterruptedException {
  boolean hasPin=false;
  boolean hasCan=false;
  for (  InputInfoUnit nextIn : pinStep.getInputInfoUnits()) {
    if (nextIn.getID().equals(""String_Node_Str"")) {
      hasPin=true;
    }
 else     if (nextIn.getID().equals(""String_Node_Str"")) {
      hasCan=true;
    }
  }
  if (hasPin && !hasCan) {
    this.pinStatus.deliver(PinStatus.PIN.name());
  }
 else   if (hasPin && hasCan) {
    this.pinStatus.deliver(PinStatus.CAN.name());
  }
 else {
    this.pinStatus.deliver(PinStatus.BLOCKED.name());
    return Collections.EMPTY_LIST;
  }
  String pinValue=this.userPin.deref();
  String canValue=this.userCan.deref();
  ArrayList<OutputInfoUnit> result=new ArrayList<>();
  for (  InputInfoUnit nextIn : pinStep.getInputInfoUnits()) {
    if (pinValue != null && nextIn instanceof PasswordField && nextIn.getID().equals(""String_Node_Str"")) {
      PasswordField pw=new PasswordField(nextIn.getID());
      pw.copyContentFrom(nextIn);
      pw.setValue(pinValue.toCharArray());
      result.add(pw);
    }
 else     if (canValue != null && nextIn instanceof PasswordField && nextIn.getID().equals(""String_Node_Str"")) {
      PasswordField pw=new PasswordField(nextIn.getID());
      pw.copyContentFrom(nextIn);
      pw.setValue(canValue.toCharArray());
      result.add(pw);
    }
  }
  return result;
}"
48056,"public static synchronized Promise<EacGuiImpl> getServiceImpl(){
  return serviceImpl;
}","static synchronized Promise<EacGuiImpl> getServiceImpl(){
  return serviceImpl;
}"
48057,"private void writeBackValues(List<InputInfoUnit> inInfo,List<OutputInfoUnit> outInfo){
  for (  InputInfoUnit infoInUnit : inInfo) {
    for (    OutputInfoUnit infoOutUnit : outInfo) {
      if (infoInUnit.getID().equals(infoOutUnit.getID())) {
        infoOutUnit.copyContentFrom(infoInUnit);
      }
    }
  }
}","private void writeBackValues(List<InputInfoUnit> inInfo,List<OutputInfoUnit> outInfo){
  for (  InputInfoUnit infoInUnit : inInfo) {
    for (    OutputInfoUnit infoOutUnit : outInfo) {
      if (infoInUnit.getID().equals(infoOutUnit.getID())) {
        infoInUnit.copyContentFrom(infoOutUnit);
      }
    }
  }
}"
48058,"/** 
 * Sets the body (LE, DATA, LC) of the APDU.
 * @param body Body of the APDU
 */
public final void setBody(byte[] body){
  try {
    ByteArrayInputStream bais=new ByteArrayInputStream(body);
    int length=bais.available();
    lc=-1;
    le=-1;
    data=new byte[0];
    if (length == 0) {
    }
 else     if (length == 1) {
      le=(bais.read() & 0xFF);
    }
 else     if (length < 65536) {
      int tmp=bais.read();
      if (tmp == 0) {
        if (bais.available() < 3) {
          le=((bais.read() & 0xFF) << 8) | (bais.read() & 0xFF);
        }
 else {
          lc=((bais.read() & 0xFF) << 8) | (bais.read() & 0xFF);
          data=new byte[lc];
          bais.read(data);
          if (bais.available() == 1) {
            le=(bais.read() & 0xFF);
          }
 else           if (bais.available() == 2) {
            le=((bais.read() & 0xFF) << 8) | (bais.read() & 0xFF);
          }
 else           if (bais.available() == 3) {
            if (bais.read() == 0) {
              le=((bais.read() & 0xFF) << 8) | (bais.read() & 0xFF);
            }
 else {
              throw new IllegalArgumentException(""String_Node_Str"");
            }
          }
 else           if (bais.available() > 3) {
            throw new IllegalArgumentException(""String_Node_Str"");
          }
        }
      }
 else       if (tmp > 0) {
        lc=(tmp & 0xFF);
        data=new byte[lc];
        bais.read(data);
        if (bais.available() == 1 || bais.available() == 3) {
          tmp=bais.read();
          if (tmp != 0) {
            le=(tmp & 0xFF);
          }
 else {
            le=((bais.read() & 0xFF) << 8) | (bais.read() & 0xFF);
          }
        }
 else         if (bais.available() == 2 || bais.available() > 3) {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
}","/** 
 * Sets the body (LE, DATA, LC) of the APDU.
 * @param body Body of the APDU
 */
public final void setBody(byte[] body){
  try {
    ByteArrayInputStream bais=new ByteArrayInputStream(body);
    int length=bais.available();
    lc=-1;
    le=-1;
    data=new byte[0];
    if (length == 0) {
    }
 else     if (length == 1) {
      le=(bais.read() & 0xFF);
    }
 else     if (length < 65536) {
      int tmp=bais.read();
      if (tmp == 0) {
        if (bais.available() < 3) {
          le=((bais.read() & 0xFF) << 8) | (bais.read() & 0xFF);
        }
 else {
          lc=((bais.read() & 0xFF) << 8) | (bais.read() & 0xFF);
          data=new byte[lc];
          bais.read(data);
          if (bais.available() == 1) {
            le=(bais.read() & 0xFF);
          }
 else           if (bais.available() == 2) {
            le=((bais.read() & 0xFF) << 8) | (bais.read() & 0xFF);
          }
 else           if (bais.available() == 3) {
            if (bais.read() == 0) {
              le=((bais.read() & 0xFF) << 8) | (bais.read() & 0xFF);
            }
 else {
              throw new IllegalArgumentException(""String_Node_Str"");
            }
          }
 else           if (bais.available() > 3) {
            throw new IllegalArgumentException(""String_Node_Str"");
          }
        }
      }
 else       if (tmp > 0) {
        lc=(tmp & 0xFF);
        data=new byte[lc];
        bais.read(data);
        if (bais.available() == 1) {
          setLE((byte)bais.read());
        }
 else         if (bais.available() == 3) {
          bais.read();
          setLE((short)(((bais.read() & 0xFF) << 8) | (bais.read() & 0xFF)));
        }
 else         if (bais.available() == 2 || bais.available() > 3) {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
      }
 else {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",e);
  }
}"
48059,"/** 
 * Returns the encoded APDU: CLA | INS | P1 | P2 | (EXT)LC | DATA | (EXT)LE
 * @return Encoded APDU
 */
public final byte[] toByteArray(){
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try {
    baos.write(header);
    if (lc > 255 || (le > 256 && lc > 0)) {
      baos.write(x00);
      baos.write((byte)(lc >> 8));
      baos.write((byte)lc);
    }
 else     if (lc > 0) {
      baos.write((byte)lc);
    }
    baos.write(data);
    if (le > 256) {
      if (lc == 0 || lc == -1) {
        baos.write(x00);
      }
      if (le >= 65536) {
        baos.write(x00);
        baos.write(x00);
      }
 else {
        baos.write((byte)(le >> 8));
        baos.write((byte)le);
      }
    }
 else     if (le > 0) {
      if (lc > 255) {
        baos.write((byte)(le >> 8));
        baos.write((byte)le);
      }
 else {
        baos.write((byte)le);
      }
    }
  }
 catch (  IOException ex) {
    logger.error(""String_Node_Str"",ex);
  }
  return baos.toByteArray();
}","/** 
 * Returns the encoded APDU: CLA | INS | P1 | P2 | (EXT)LC | DATA | (EXT)LE
 * @return Encoded APDU
 */
public final byte[] toByteArray(){
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  try {
    baos.write(header);
    if (lc > 255 || (le > 256 && lc > 0)) {
      baos.write(x00);
      baos.write((byte)(lc >> 8));
      baos.write((byte)lc);
    }
 else     if (lc > 0) {
      baos.write((byte)lc);
    }
    baos.write(data);
    if (le > 256) {
      if (lc == 0 || lc == -1) {
        baos.write(x00);
      }
      if (le >= 65536) {
        baos.write(x00);
        baos.write(x00);
      }
 else {
        baos.write((byte)(le >> 8));
        baos.write((byte)le);
      }
    }
 else     if (le > 0) {
      if (lc > 255) {
        baos.write((byte)(le >> 8));
        baos.write((byte)le);
      }
 else {
        baos.write((byte)le);
      }
    }
  }
 catch (  IOException ex) {
    LOG.error(""String_Node_Str"",ex);
  }
  return baos.toByteArray();
}"
48060,"private void revalidate(JComponent c){
  for (int i=0; i < c.getComponentCount(); i++) {
    this.revalidate((JComponent)c.getComponent(i));
  }
  c.revalidate();
  c.repaint();
}","private void revalidate(Component c){
  c.revalidate();
  c.repaint();
}"
48061,"/** 
 * Creates a new EAC1InputType.
 * @param baseType DIDAuthenticationDataType
 * @throws Exception
 */
public EAC1InputType(DIDAuthenticationDataType baseType) throws Exception {
  parseCertificateDescriptionElement(baseType);
  authMap=new AuthDataMap(baseType);
  certificates=new ArrayList<>();
  for (  Element element : baseType.getAny()) {
    if (element.getLocalName().equals(CERTIFICATE)) {
      byte[] value=StringUtils.toByteArray(element.getTextContent());
      CardVerifiableCertificate cvc=new CardVerifiableCertificate(value);
      certificates.add(cvc);
    }
  }
  certificateDescription=authMap.getContentAsBytes(CERTIFICATE_DESCRIPTION);
  providerInfo=authMap.getContentAsBytes(PROVIDER_INFO);
  byte[] requiredCHATtmp=authMap.getContentAsBytes(REQUIRED_CHAT);
  byte[] optionalCHATtmp=authMap.getContentAsBytes(OPTIONAL_CHAT);
  if (requiredCHATtmp == null) {
    requiredCHATtmp=new CHAT().toByteArray();
  }
 else {
    requiredCHATtmp=fixChatValue(requiredCHATtmp);
  }
  if (optionalCHATtmp == null) {
    CardVerifiableCertificateChain certChain=new CardVerifiableCertificateChain(certificates);
    CardVerifiableCertificate terminalCert=certChain.getTerminalCertificate();
    optionalCHATtmp=terminalCert.getCHAT().toByteArray();
  }
 else {
    optionalCHATtmp=fixChatValue(optionalCHATtmp);
  }
  requiredCHAT=requiredCHATtmp;
  optionalCHAT=optionalCHATtmp;
  authenticatedAuxiliaryData=authMap.getContentAsBytes(AUTHENTICATED_AUXILIARY_DATA);
  transactionInfo=authMap.getContentAsString(TRANSACTION_INFO);
}","/** 
 * Creates a new EAC1InputType.
 * @param baseType DIDAuthenticationDataType
 * @throws Exception Thrown in cause the type iss errornous.
 */
public EAC1InputType(DIDAuthenticationDataType baseType) throws Exception {
  parseCertificateDescriptionElement(baseType);
  authMap=new AuthDataMap(baseType);
  certificates=new ArrayList<>();
  for (  Element element : baseType.getAny()) {
    if (element.getLocalName().equals(CERTIFICATE)) {
      byte[] value=StringUtils.toByteArray(element.getTextContent());
      CardVerifiableCertificate cvc=new CardVerifiableCertificate(value);
      certificates.add(cvc);
    }
  }
  certificateDescription=authMap.getContentAsBytes(CERTIFICATE_DESCRIPTION);
  providerInfo=authMap.getContentAsBytes(PROVIDER_INFO);
  byte[] requiredCHATtmp=authMap.getContentAsBytes(REQUIRED_CHAT);
  byte[] optionalCHATtmp=authMap.getContentAsBytes(OPTIONAL_CHAT);
  if (requiredCHATtmp == null) {
    requiredCHATtmp=new CHAT().toByteArray();
  }
 else {
    requiredCHATtmp=fixChatValue(requiredCHATtmp);
  }
  if (optionalCHATtmp == null) {
    CardVerifiableCertificateChain certChain=new CardVerifiableCertificateChain(certificates);
    CardVerifiableCertificate terminalCert=certChain.getTerminalCertificate();
    optionalCHATtmp=terminalCert.getCHAT().toByteArray();
  }
 else {
    optionalCHATtmp=fixChatValue(optionalCHATtmp);
  }
  requiredCHAT=requiredCHATtmp;
  optionalCHAT=optionalCHATtmp;
  authenticatedAuxiliaryData=authMap.getContentAsBytes(AUTHENTICATED_AUXILIARY_DATA);
  transactionInfo=authMap.getContentAsString(TRANSACTION_INFO);
}"
48062,"/** 
 * Creates a new EAC2InputType.
 * @param baseType DIDAuthenticationDataType
 * @throws Exception
 */
public EAC2InputType(DIDAuthenticationDataType baseType) throws Exception {
  this.authMap=new AuthDataMap(baseType);
  certificates=new ArrayList<>();
  for (  Element element : baseType.getAny()) {
    if (element.getLocalName().equals(CERTIFICATE)) {
      byte[] value=StringUtils.toByteArray(element.getTextContent());
      CardVerifiableCertificate cvc=new CardVerifiableCertificate(value);
      certificates.add(cvc);
    }
  }
  ephemeralPublicKey=authMap.getContentAsBytes(EPHEMERAL_PUBLIC_KEY);
  signature=authMap.getContentAsBytes(SIGNATURE);
}","/** 
 * Creates a new EAC2InputType.
 * @param baseType DIDAuthenticationDataType
 * @throws Exception Thrown in cause the type iss errornous.
 */
public EAC2InputType(DIDAuthenticationDataType baseType) throws Exception {
  this.authMap=new AuthDataMap(baseType);
  certificates=new ArrayList<>();
  for (  Element element : baseType.getAny()) {
    if (element.getLocalName().equals(CERTIFICATE)) {
      byte[] value=StringUtils.toByteArray(element.getTextContent());
      CardVerifiableCertificate cvc=new CardVerifiableCertificate(value);
      certificates.add(cvc);
    }
  }
  ephemeralPublicKey=authMap.getContentAsBytes(EPHEMERAL_PUBLIC_KEY);
  signature=authMap.getContentAsBytes(SIGNATURE);
}"
48063,"/** 
 * Sets the challenge.
 * @param challenge
 */
public void setChallenge(byte[] challenge){
  this.challenge=challenge;
}","/** 
 * Sets the challenge.
 * @param challenge Challenge value.
 */
public void setChallenge(byte[] challenge){
  this.challenge=challenge;
}"
48064,"/** 
 * Creates a new EACAdditionalInputType.
 * @param baseType DIDAuthenticationDataType
 * @throws ParserConfigurationException
 */
public EACAdditionalInputType(DIDAuthenticationDataType baseType) throws ParserConfigurationException {
  authMap=new AuthDataMap(baseType);
  signature=authMap.getContentAsBytes(SIGNATURE);
}","/** 
 * Creates a new EACAdditionalInputType.
 * @param baseType DIDAuthenticationDataType
 * @throws ParserConfigurationException Thrown in case the parser couldn't be loaded.
 */
public EACAdditionalInputType(DIDAuthenticationDataType baseType) throws ParserConfigurationException {
  authMap=new AuthDataMap(baseType);
  signature=authMap.getContentAsBytes(SIGNATURE);
}"
48065,"/** 
 * Creates a new PACEInputType.
 * @param baseType DIDAuthenticationDataType
 * @throws ParserConfigurationException
 */
public PACEInputType(DIDAuthenticationDataType baseType) throws ParserConfigurationException {
  authMap=new AuthDataMap(baseType);
  pinID=authMap.getContentAsBytes(PIN_ID)[0];
  chat=authMap.getContentAsBytes(CHAT);
  pin=authMap.getContentAsString(PIN);
  certDesc=authMap.getContentAsBytes(CERTIFICATE_DESCRIPTION);
}","/** 
 * Creates a new PACEInputType.
 * @param baseType DIDAuthenticationDataType
 * @throws ParserConfigurationException Thrown in case the parser couldn't be loaded.
 */
public PACEInputType(DIDAuthenticationDataType baseType) throws ParserConfigurationException {
  authMap=new AuthDataMap(baseType);
  pinID=authMap.getContentAsBytes(PIN_ID)[0];
  chat=authMap.getContentAsBytes(CHAT);
  pin=authMap.getContentAsString(PIN);
  certDesc=authMap.getContentAsBytes(CERTIFICATE_DESCRIPTION);
}"
48066,"private static ResourceContext getStreamInt(URL url,CertificateValidator v,List<Pair<URL,Certificate>> serverCerts,int maxRedirects) throws IOException, ResourceException, ValidationError, InvalidAddressException {
  try {
    DynamicContext dynCtx=DynamicContext.getInstance(TR03112Keys.INSTANCE_KEY);
    CookieManager cManager=(CookieManager)dynCtx.get(TR03112Keys.COOKIE_MANAGER);
    logger.info(""String_Node_Str"",url);
    if (maxRedirects == 0) {
      throw new ResourceException(MAX_REDIRECTS);
    }
    maxRedirects--;
    String protocol=url.getProtocol();
    String hostname=url.getHost();
    int port=url.getPort();
    if (port == -1) {
      port=url.getDefaultPort();
    }
    String resource=url.getFile();
    resource=resource.isEmpty() ? ""String_Node_Str"" : resource;
    if (!""String_Node_Str"".equals(protocol)) {
      throw new InvalidAddressException(INVALID_ADDRESS);
    }
    TlsClientProtocol h;
    DynamicAuthentication tlsAuth=new DynamicAuthentication(hostname);
    if (isPKIXVerify()) {
      tlsAuth.addCertificateVerifier(new JavaSecVerifier());
    }
    ClientCertTlsClient tlsClient=new ClientCertDefaultTlsClient(hostname,true);
    tlsClient.setAuthentication(tlsAuth);
    tlsClient.setClientVersion(ProtocolVersion.TLSv12);
    Socket socket=ProxySettings.getDefault().getSocket(hostname,port);
    SecureRandom sr=ReusableSecureRandom.getInstance();
    h=new TlsClientProtocol(socket.getInputStream(),socket.getOutputStream(),sr);
    logger.debug(""String_Node_Str"");
    h.connect(tlsClient);
    logger.debug(""String_Node_Str"");
    serverCerts.add(new Pair<>(url,tlsAuth.getServerCertificate()));
    CertificateValidator.VerifierResult verifyResult=v.validate(url,tlsAuth.getServerCertificate());
    if (verifyResult == CertificateValidator.VerifierResult.FINISH) {
      List<Pair<URL,Certificate>> pairs=Collections.unmodifiableList(serverCerts);
      return new ResourceContext(tlsClient,h,pairs);
    }
    StreamHttpClientConnection conn=new StreamHttpClientConnection(h.getInputStream(),h.getOutputStream());
    HttpContext ctx=new BasicHttpContext();
    HttpRequestExecutor httpexecutor=new HttpRequestExecutor();
    BasicHttpEntityEnclosingRequest req=new BasicHttpEntityEnclosingRequest(""String_Node_Str"",resource);
    req.setParams(conn.getParams());
    HttpRequestHelper.setDefaultHeader(req,url);
    req.setHeader(""String_Node_Str"",""String_Node_Str"");
    req.setHeader(""String_Node_Str"",""String_Node_Str"");
    setCookieHeader(req,cManager,url);
    HttpUtils.dumpHttpRequest(logger,req);
    logger.debug(""String_Node_Str"");
    HttpResponse response=httpexecutor.execute(req,conn,ctx);
    storeCookies(response,cManager,url);
    logger.debug(""String_Node_Str"");
    StatusLine status=response.getStatusLine();
    int statusCode=status.getStatusCode();
    String reason=status.getReasonPhrase();
    HttpUtils.dumpHttpResponse(logger,response,null);
    HttpEntity entity=null;
    boolean finished=false;
    if (TR03112Utils.isRedirectStatusCode(statusCode)) {
      Header[] headers=response.getHeaders(""String_Node_Str"");
      if (headers.length > 0) {
        String uri=headers[0].getValue();
        url=new URL(uri);
      }
 else {
        throw new ResourceException(MISSING_LOCATION_HEADER);
      }
    }
 else     if (statusCode >= 400) {
      logger.debug(""String_Node_Str"",statusCode,reason);
      throw new InvalidResultStatus(lang.translationForKey(INVALID_RESULT_STATUS,statusCode,reason));
    }
 else {
      if (verifyResult == CertificateValidator.VerifierResult.CONTINUE) {
        throw new InvalidAddressException(INVALID_REFRESH_ADDRESS_NOSOP);
      }
 else {
        conn.receiveResponseEntity(response);
        entity=response.getEntity();
        finished=true;
      }
    }
    if (finished) {
      ResourceContext result=new ResourceContext(tlsClient,h,serverCerts);
      LimitedInputStream is=new LimitedInputStream(entity.getContent());
      result.setStream(is);
      return result;
    }
 else {
      h.close();
      return getStreamInt(url,v,serverCerts,maxRedirects);
    }
  }
 catch (  URISyntaxException ex) {
    throw new IOException(lang.translationForKey(FAILED_PROXY),ex);
  }
catch (  HttpException ex) {
    throw new IOException(""String_Node_Str"",ex);
  }
}","private static ResourceContext getStreamInt(URL url,CertificateValidator v,List<Pair<URL,Certificate>> serverCerts,int maxRedirects) throws IOException, ResourceException, ValidationError, InvalidAddressException {
  try {
    DynamicContext dynCtx=DynamicContext.getInstance(TR03112Keys.INSTANCE_KEY);
    CookieManager cManager=(CookieManager)dynCtx.get(TR03112Keys.COOKIE_MANAGER);
    logger.info(""String_Node_Str"",url);
    if (maxRedirects == 0) {
      throw new ResourceException(MAX_REDIRECTS);
    }
    maxRedirects--;
    String protocol=url.getProtocol();
    String hostname=url.getHost();
    int port=url.getPort();
    if (port == -1) {
      port=url.getDefaultPort();
    }
    String resource=url.getFile();
    resource=resource.isEmpty() ? ""String_Node_Str"" : resource;
    if (!""String_Node_Str"".equals(protocol)) {
      throw new InvalidAddressException(INVALID_ADDRESS);
    }
    TlsClientProtocol h;
    DynamicAuthentication tlsAuth=new DynamicAuthentication(hostname);
    if (isPKIXVerify()) {
      tlsAuth.addCertificateVerifier(new JavaSecVerifier());
    }
    ClientCertTlsClient tlsClient=new ClientCertDefaultTlsClient(hostname,true);
    tlsClient.setAuthentication(tlsAuth);
    tlsClient.setClientVersion(ProtocolVersion.TLSv12);
    Socket socket=ProxySettings.getDefault().getSocket(hostname,port);
    SecureRandom sr=ReusableSecureRandom.getInstance();
    h=new TlsClientProtocol(socket.getInputStream(),socket.getOutputStream(),sr);
    logger.debug(""String_Node_Str"");
    h.connect(tlsClient);
    logger.debug(""String_Node_Str"");
    serverCerts.add(new Pair<>(url,tlsAuth.getServerCertificate()));
    CertificateValidator.VerifierResult verifyResult=v.validate(url,tlsAuth.getServerCertificate());
    if (verifyResult == CertificateValidator.VerifierResult.FINISH) {
      List<Pair<URL,Certificate>> pairs=Collections.unmodifiableList(serverCerts);
      return new ResourceContext(tlsClient,h,pairs);
    }
    StreamHttpClientConnection conn=new StreamHttpClientConnection(h.getInputStream(),h.getOutputStream());
    HttpContext ctx=new BasicHttpContext();
    HttpRequestExecutor httpexecutor=new HttpRequestExecutor();
    BasicHttpEntityEnclosingRequest req=new BasicHttpEntityEnclosingRequest(""String_Node_Str"",resource);
    req.setParams(conn.getParams());
    HttpRequestHelper.setDefaultHeader(req,url);
    req.setHeader(""String_Node_Str"",""String_Node_Str"");
    req.setHeader(""String_Node_Str"",""String_Node_Str"");
    setCookieHeader(req,cManager,url);
    HttpUtils.dumpHttpRequest(logger,req);
    logger.debug(""String_Node_Str"");
    HttpResponse response=httpexecutor.execute(req,conn,ctx);
    storeCookies(response,cManager,url);
    logger.debug(""String_Node_Str"");
    StatusLine status=response.getStatusLine();
    int statusCode=status.getStatusCode();
    String reason=status.getReasonPhrase();
    HttpUtils.dumpHttpResponse(logger,response,null);
    HttpEntity entity=null;
    boolean finished=false;
    if (TR03112Utils.isRedirectStatusCode(statusCode)) {
      Header[] headers=response.getHeaders(""String_Node_Str"");
      if (headers.length > 0) {
        String uri=headers[0].getValue();
        url=new URL(uri);
      }
 else {
        throw new ResourceException(MISSING_LOCATION_HEADER);
      }
    }
 else     if (statusCode >= 400) {
      logger.debug(""String_Node_Str"",statusCode,reason);
      throw new InvalidResultStatus(lang.translationForKey(INVALID_RESULT_STATUS,statusCode,reason));
    }
 else {
      if (verifyResult == CertificateValidator.VerifierResult.CONTINUE) {
        throw new InvalidAddressException(INVALID_REFRESH_ADDRESS_NOSOP);
      }
 else {
        conn.receiveResponseEntity(response);
        entity=response.getEntity();
        finished=true;
      }
    }
    if (finished) {
      assert(entity != null);
      ResourceContext result=new ResourceContext(tlsClient,h,serverCerts);
      LimitedInputStream is=new LimitedInputStream(entity.getContent());
      result.setStream(is);
      return result;
    }
 else {
      h.close();
      return getStreamInt(url,v,serverCerts,maxRedirects);
    }
  }
 catch (  URISyntaxException ex) {
    throw new IOException(lang.translationForKey(FAILED_PROXY),ex);
  }
catch (  HttpException ex) {
    throw new IOException(""String_Node_Str"",ex);
  }
}"
48067,"/** 
 * Replace minor code for use in refresh URLs. BSI TR-03124-1 defines non URL versions of the ResultMinor codes from BSI TR-03112.
 * @param minor
 * @return
 */
public static String fixResultMinor(@Nonnull String minor){
  int idx=minor.lastIndexOf(""String_Node_Str"");
  if (idx != -1) {
    idx++;
    if (idx < minor.length()) {
      minor=minor.substring(idx);
    }
  }
  return minor;
}","/** 
 * Replace minor code for use in refresh URLs. BSI TR-03124-1 defines non URL versions of the ResultMinor codes from BSI TR-03112.
 * @param minor
 * @return Code part of the minor code URL.
 */
@Nonnull public static String fixResultMinor(@Nonnull String minor){
  int idx=minor.lastIndexOf(""String_Node_Str"");
  if (idx != -1) {
    idx++;
    if (idx < minor.length()) {
      minor=minor.substring(idx);
    }
  }
  return minor;
}"
48068,"/** 
 * Get translated version of a file depending on current locale. <p>The file's base path equals the component directory. The language definition is enclosed between the filename and the file ending plus a '.'.</p> <p>An example looks like this:<br/> <pre> I18n l = I18n.getTranslation(""gui""); l.translationForFile(""about"", ""html""); // this code in a german environment tries to load the following files until one is found // - openecard_i18n/gui/about_de_DE.html // - openecard_i18n/gui/about_de.html // - openecard_i18n/gui/about_C.html</pre> </p>
 * @param name Name part of the file
 * @param fileEnding File ending if available, null otherwise.
 * @return URL pointing to the translated, or default file.
 * @throws IOException Thrown in case no resource is available.
 */
public synchronized URL translationForFile(String name,String fileEnding) throws IOException {
  fileEnding=fileEnding != null ? (""String_Node_Str"" + fileEnding) : ""String_Node_Str"";
  String mapKey=name + fileEnding;
  if (translatedFiles.containsKey(mapKey)) {
    URL url=translatedFiles.get(mapKey);
    if (url == null) {
      throw new IOException(""String_Node_Str"" + name + fileEnding+ ""String_Node_Str"");
    }
 else {
      return url;
    }
  }
  Locale locale=Locale.getDefault();
  String lang=locale.getLanguage();
  String country=locale.getCountry();
  String fnameBase=""String_Node_Str"" + component + ""String_Node_Str""+ name;
  if (!lang.isEmpty() && !country.isEmpty()) {
    String fileName=fnameBase + ""String_Node_Str"" + lang+ ""String_Node_Str""+ country+ fileEnding;
    URL url=FileUtils.resolveResourceAsURL(loaderReference,fileName);
    if (url != null) {
      translatedFiles.put(mapKey,url);
      return url;
    }
  }
  if (!lang.isEmpty()) {
    String fileName=fnameBase + ""String_Node_Str"" + lang+ fileEnding;
    URL url=FileUtils.resolveResourceAsURL(loaderReference,fileName);
    if (url != null) {
      translatedFiles.put(mapKey,url);
      return url;
    }
  }
  String fileName=fnameBase + ""String_Node_Str"" + fileEnding;
  URL url=FileUtils.resolveResourceAsURL(loaderReference,fileName);
  if (url != null) {
    translatedFiles.put(mapKey,url);
    return url;
  }
  translatedFiles.put(mapKey,null);
  throw new IOException(""String_Node_Str"" + name + fileEnding+ ""String_Node_Str"");
}","/** 
 * Get translated version of a file depending on current locale. <p>The file's base path equals the component directory. The language definition is enclosed between the filename and the file ending plus a '.'.</p> <p>An example looks like this:<br/> <pre> I18n l = I18n.getTranslation(""gui""); l.translationForFile(""about"", ""html""); // this code in a german environment tries to load the following files until one is found // - openecard_i18n/gui/about_de_DE.html // - openecard_i18n/gui/about_de.html // - openecard_i18n/gui/about_C.html</pre> </p>
 * @param name Name part of the file.
 * @param fileEnding File ending if available, null otherwise.
 * @return URL pointing to the translated, or default file.
 * @throws IOException Thrown in case no resource is available.
 */
@Nonnull public synchronized URL translationForFile(String name,String fileEnding) throws IOException {
  fileEnding=fileEnding != null ? (""String_Node_Str"" + fileEnding) : ""String_Node_Str"";
  String mapKey=name + fileEnding;
  if (translatedFiles.containsKey(mapKey)) {
    URL url=translatedFiles.get(mapKey);
    if (url == null) {
      throw new IOException(""String_Node_Str"" + name + fileEnding+ ""String_Node_Str"");
    }
 else {
      return url;
    }
  }
  Locale locale=Locale.getDefault();
  String lang=locale.getLanguage();
  String country=locale.getCountry();
  String fnameBase=""String_Node_Str"" + component + ""String_Node_Str""+ name;
  if (!lang.isEmpty() && !country.isEmpty()) {
    String fileName=fnameBase + ""String_Node_Str"" + lang+ ""String_Node_Str""+ country+ fileEnding;
    URL url=FileUtils.resolveResourceAsURL(loaderReference,fileName);
    if (url != null) {
      translatedFiles.put(mapKey,url);
      return url;
    }
  }
  if (!lang.isEmpty()) {
    String fileName=fnameBase + ""String_Node_Str"" + lang+ fileEnding;
    URL url=FileUtils.resolveResourceAsURL(loaderReference,fileName);
    if (url != null) {
      translatedFiles.put(mapKey,url);
      return url;
    }
  }
  String fileName=fnameBase + ""String_Node_Str"" + fileEnding;
  URL url=FileUtils.resolveResourceAsURL(loaderReference,fileName);
  if (url != null) {
    translatedFiles.put(mapKey,url);
    return url;
  }
  translatedFiles.put(mapKey,null);
  throw new IOException(""String_Node_Str"" + name + fileEnding+ ""String_Node_Str"");
}"
48069,"/** 
 * Get the translated value for the given key. The implementation tries to find the key in the requested language, then the default language and if nothing is specified at all, a special string in the form of &lt;No translation for key &lt;requested.key&gt;&gt; is returned.
 * @param key Key as defined in language properties file.
 * @param parameters If any parameters are given here, the string is interpreted as a template and the parametersare applied. The template interpretation uses  {@link String#format()} as the rendering method.
 * @return Translation as specified in the translation, or default file.
 */
public String translationForKey(I18nKey key,Object... parameters){
  return translationForKey(key.getKey(),parameters);
}","/** 
 * Get the translated value for the given key. The implementation tries to find the key in the requested language, then the default language and if nothing is specified at all, a special string in the form of &lt;No translation for key &lt;requested.key&gt;&gt; is returned.
 * @param key Key as defined in language properties file.
 * @param parameters If any parameters are given here, the string is interpreted as a template and the parametersare applied. The template interpretation uses  {@link String#format(String,Object)} as the rendering method.
 * @return Translation as specified in the translation, or default file.
 */
public String translationForKey(I18nKey key,Object... parameters){
  return translationForKey(key.getKey(),parameters);
}"
48070,"/** 
 * Returns a iterator over the chaining APDUs.
 * @return
 */
public final Iterable getChainingIterator(){
  throw new IllegalAccessError(""String_Node_Str"");
}","/** 
 * Returns a iterator over the chaining APDUs.
 * @return Iterator containing the APDUs.
 */
public final Iterable getChainingIterator(){
  throw new IllegalAccessError(""String_Node_Str"");
}"
48071,"/** 
 * Select an application by the application identifier. This method requests the FCP of the application.
 * @param dispatcher
 * @param slotHandle
 * @param aid Application identifier
 * @return
 * @throws APDUException
 */
public static CardResponseAPDU selectApplicationByAID(Dispatcher dispatcher,byte[] slotHandle,byte[] aid) throws APDUException {
  Select selectApp=new Select((byte)0x04,(byte)0x04);
  selectApp.setData(aid);
  selectApp.setLE((byte)0xFF);
  CardResponseAPDU result=selectApp.transmit(dispatcher,slotHandle);
  return result;
}","/** 
 * Select an application by the application identifier. This method requests the FCP of the application.
 * @param dispatcher
 * @param slotHandle
 * @param aid Application identifier
 * @return Response APDU of the select command.
 * @throws APDUException Thrown in case there was an error while processing the command APDU.
 */
public static CardResponseAPDU selectApplicationByAID(Dispatcher dispatcher,byte[] slotHandle,byte[] aid) throws APDUException {
  Select selectApp=new Select((byte)0x04,(byte)0x04);
  selectApp.setData(aid);
  selectApp.setLE((byte)0xFF);
  CardResponseAPDU result=selectApp.transmit(dispatcher,slotHandle);
  return result;
}"
48072,"/** 
 * Get the value of the identifier property. The identifier is here a credential identifier.
 * @return
 */
public TLV getIdentifier(){
  return identifier;
}","/** 
 * Get the value of the identifier property. The identifier here is a credential identifier.
 * @return Identifier structure.
 */
public TLV getIdentifier(){
  return identifier;
}"
48073,"/** 
 * List of credential identifiers.
 * @return
 */
public TLV getIdentifiers(){
  return identifiers;
}","/** 
 * List of credential identifiers.
 * @return Identifiers structure.
 */
public TLV getIdentifiers(){
  return identifiers;
}"
48074,"/** 
 * Get the uniform resource locator which points to part of the software required in the interface device to  communicate with the application in the card.
 * @return 
 */
public String getURL(){
  return uniformResourceLocator;
}","/** 
 * Get the uniform resource locator which points to the part of the software required in the interface device to communicate with the application in the card.
 * @return The URL contained in the FMD.
 */
public String getURL(){
  return uniformResourceLocator;
}"
48075,"/** 
 * @param tlv
 * @throws TLVException
 * @throws UnsupportedEncodingException
 */
public FMD(TLV tlv) throws TLVException, UnsupportedEncodingException {
  this.tlv=tlv;
  TLV child=tlv.getChild();
  if (child.getTagNumWithClass() != 0x64) {
    throw new TLVException(""String_Node_Str"");
  }
  if (tlv.getValue().length == 0) {
    content=false;
  }
 else {
    if (child.getTagNumWithClass() == 0x61) {
      Parser p=new Parser(child);
      applicationTemplates=new LinkedList<ApplicationTemplate>();
      while (p.match(0x61)) {
        if (p.match(0x61)) {
          applicationTemplates.add(new ApplicationTemplate(p.next(0)));
        }
      }
    }
 else     if (child.getTagNumWithClass() == 0x53) {
      discretionaryData=child.getValue();
    }
 else     if (child.getTagNumWithClass() == 0x73) {
      discretionaryDataTemplate=child.getValue();
    }
 else     if (child.getTagNumWithClass() == 0x5F50) {
      uniformResourceLocator=new String(child.getValue(),""String_Node_Str"");
    }
 else     if (child.getTagNumWithClass() == 0x50) {
      applicationLabel=new String(child.getValue());
    }
 else     if (child.getTagNumWithClass() == 0x51) {
      fileReference=child.getValue();
    }
 else     if (child.getTagNumWithClass() == 0xA2) {
      Parser p=new Parser(child);
      references=new ArrayList<Pair<byte[],byte[]>>();
      while (p.match(0x88) || p.match(0x51)) {
        byte[] shortRef=null;
        byte[] fileRef=null;
        if (p.match(0x88)) {
          shortRef=p.next(0).getValue();
        }
        if (p.match(0x51)) {
          fileRef=p.next(0).getValue();
        }
        Pair<byte[],byte[]> refPair=new Pair<byte[],byte[]>(shortRef,fileRef);
        references.add(refPair);
      }
    }
 else     if (child.getTagNumWithClass() == 0x85) {
      Parser p=new Parser(child);
      proprietaryInformation=new ArrayList<TLV>();
      while (p.match(0x85)) {
        proprietaryInformation.add(p.next(0));
      }
    }
  }
}","/** 
 * Creats an FMD object.
 * @param tlv
 * @throws TLVException
 * @throws UnsupportedEncodingException
 */
public FMD(TLV tlv) throws TLVException, UnsupportedEncodingException {
  this.tlv=tlv;
  TLV child=tlv.getChild();
  if (child.getTagNumWithClass() != 0x64) {
    throw new TLVException(""String_Node_Str"");
  }
  if (tlv.getValue().length == 0) {
    content=false;
  }
 else {
    if (child.getTagNumWithClass() == 0x61) {
      Parser p=new Parser(child);
      applicationTemplates=new LinkedList<>();
      while (p.match(0x61)) {
        if (p.match(0x61)) {
          applicationTemplates.add(new ApplicationTemplate(p.next(0)));
        }
      }
    }
 else     if (child.getTagNumWithClass() == 0x53) {
      discretionaryData=child.getValue();
    }
 else     if (child.getTagNumWithClass() == 0x73) {
      discretionaryDataTemplate=child.getValue();
    }
 else     if (child.getTagNumWithClass() == 0x5F50) {
      uniformResourceLocator=new String(child.getValue(),""String_Node_Str"");
    }
 else     if (child.getTagNumWithClass() == 0x50) {
      applicationLabel=new String(child.getValue());
    }
 else     if (child.getTagNumWithClass() == 0x51) {
      fileReference=child.getValue();
    }
 else     if (child.getTagNumWithClass() == 0xA2) {
      Parser p=new Parser(child);
      references=new ArrayList<>();
      while (p.match(0x88) || p.match(0x51)) {
        byte[] shortRef=null;
        byte[] fileRef=null;
        if (p.match(0x88)) {
          shortRef=p.next(0).getValue();
        }
        if (p.match(0x51)) {
          fileRef=p.next(0).getValue();
        }
        Pair<byte[],byte[]> refPair=new Pair<>(shortRef,fileRef);
        references.add(refPair);
      }
    }
 else     if (child.getTagNumWithClass() == 0x85) {
      Parser p=new Parser(child);
      proprietaryInformation=new ArrayList<>();
      while (p.match(0x85)) {
        proprietaryInformation.add(p.next(0));
      }
    }
  }
}"
48076,"/** 
 * Uninstall an add-on. This i primarily a wrapper method for the  {@link FileRegistry#uninstallAddon(org.openecard.addon.manifest.AddonSpecification)}
 * @param addonSpec The {@link AddonSpecification} of the add-on to uninstall.
 */
public void uninstallAddon(@Nonnull AddonSpecification addonSpec){
  registry.getFileRegistry().uninstallAddon(addonSpec);
}","/** 
 * Uninstall an add-on. This is primarily a wrapper method for the   {@link FileRegistry#uninstallAddon(AddonSpecification)}
 * @param addonSpec The specification of the add-on to uninstall.
 */
public void uninstallAddon(@Nonnull AddonSpecification addonSpec){
  registry.getFileRegistry().uninstallAddon(addonSpec);
}"
48077,"/** 
 * Get the additional label. <br /> This value might be null because it is optional.
 * @return The additional label.
 */
private String getAddLabel(){
  return addLabel;
}","/** 
 * Get the additional label. <br> This value might be null because it is optional.
 * @return The additional label.
 */
private String getAddLabel(){
  return addLabel;
}"
48078,"/** 
 * The constructor parses a string as semantic version. <br /> If the string does not contain a semantic version major, minor and patch version are set to zero and the
 * @param version The version string which should be parsed as semantic version.
 */
private SemanticVersion(String version){
  String[] groups=new String[4];
  Pattern p=Pattern.compile(""String_Node_Str"");
  Matcher m=p.matcher(version);
  if (m.matches() && m.groupCount() >= 3) {
    groups[0]=m.group(1);
    groups[1]=m.group(2);
    groups[2]=m.group(3);
    groups[3]=m.group(4);
    if (groups[3] != null) {
      groups[3]=groups[3].substring(1);
    }
    major=Integer.parseInt(groups[0]);
    minor=Integer.parseInt(groups[1]);
    patch=Integer.parseInt(groups[2]);
    addLabel=groups[3];
    isSemVersion=true;
  }
 else {
    major=0;
    minor=0;
    patch=0;
    addLabel=null;
    isSemVersion=false;
  }
}","/** 
 * The constructor parses a string as semantic version. <br> If the string does not contain a semantic version major, minor and patch version are set to zero and the
 * @param version The version string which should be parsed as semantic version.
 */
private SemanticVersion(String version){
  String[] groups=new String[4];
  Pattern p=Pattern.compile(""String_Node_Str"");
  Matcher m=p.matcher(version);
  if (m.matches() && m.groupCount() >= 3) {
    groups[0]=m.group(1);
    groups[1]=m.group(2);
    groups[2]=m.group(3);
    groups[3]=m.group(4);
    if (groups[3] != null) {
      groups[3]=groups[3].substring(1);
    }
    major=Integer.parseInt(groups[0]);
    minor=Integer.parseInt(groups[1]);
    patch=Integer.parseInt(groups[2]);
    addLabel=groups[3];
    isSemVersion=true;
  }
 else {
    major=0;
    minor=0;
    patch=0;
    addLabel=null;
    isSemVersion=false;
  }
}"
48079,"/** 
 * Get a byte array containing the logo. <br /> Note: This method creates always a new input stream and does not store the byte array internally.
 * @return A byte array containing the logo bytes or null if no logo is present or an error occurred.
 */
public byte[] getLogoBytes(){
  if (logo != null && !logo.isEmpty()) {
    try {
      InputStream logoStream=FileUtils.resolveResourceAsStream(AddonSpecification.class,logo);
      return FileUtils.toByteArray(logoStream);
    }
 catch (    FileNotFoundException e) {
      logger.error(""String_Node_Str"",e);
      return null;
    }
catch (    IOException|NullPointerException e) {
      logger.error(""String_Node_Str"",e);
      return null;
    }
  }
  return null;
}","/** 
 * Get a byte array containing the logo. <br> Note: This method creates always a new input stream and does not store the byte array internally.
 * @return A byte array containing the logo bytes or null if no logo is present or an error occurred.
 */
public byte[] getLogoBytes(){
  if (logo != null && !logo.isEmpty()) {
    try {
      InputStream logoStream=FileUtils.resolveResourceAsStream(AddonSpecification.class,logo);
      return FileUtils.toByteArray(logoStream);
    }
 catch (    FileNotFoundException e) {
      logger.error(""String_Node_Str"",e);
      return null;
    }
catch (    IOException|NullPointerException e) {
      logger.error(""String_Node_Str"",e);
      return null;
    }
  }
  return null;
}"
48080,"public synchronized IFDStatusType getStatus() throws IFDException {
  try {
    IFDStatusType status=new IFDStatusType();
    status.setIFDName(getName());
    status.setConnected(true);
    SlotStatusType stype=new SlotStatusType();
    status.getSlotStatus().add(stype);
    boolean cardPresent=isCardPresent();
    stype.setCardAvailable(cardPresent);
    stype.setIndex(IFDUtils.getSlotIndex(getName()));
    if (cardPresent) {
      if (isConnected()) {
        SCIOATR atr=scCard.getATR();
        stype.setATRorATS(atr.getBytes());
      }
 else {
        SCIOCard c=terminal.connect(""String_Node_Str"");
        SCIOATR atr=c.getATR();
        stype.setATRorATS(atr.getBytes());
        c.disconnect(false);
      }
    }
    return status;
  }
 catch (  Exception ex) {
    IFDException ifdex=new IFDException(ex);
    _logger.warn(ifdex.getMessage(),ifdex);
    throw ifdex;
  }
}","public synchronized IFDStatusType getStatus() throws IFDException {
  try {
    IFDStatusType status=new IFDStatusType();
    status.setIFDName(getName());
    status.setConnected(true);
    SlotStatusType stype=new SlotStatusType();
    status.getSlotStatus().add(stype);
    boolean cardPresent=isCardPresent();
    stype.setCardAvailable(cardPresent);
    stype.setIndex(IFDUtils.getSlotIndex(getName()));
    if (cardPresent) {
      if (isConnected()) {
        SCIOATR atr=scCard.getATR();
        stype.setATRorATS(atr.getBytes());
      }
 else {
        SCIOCard c=terminal.connect(""String_Node_Str"");
        SCIOATR atr=c.getATR();
        stype.setATRorATS(atr.getBytes());
        c.disconnect(false);
        scCard=new SCCard(c,this);
      }
    }
    return status;
  }
 catch (  Exception ex) {
    IFDException ifdex=new IFDException(ex);
    _logger.warn(ifdex.getMessage(),ifdex);
    throw ifdex;
  }
}"
48081,"/** 
 * Returns the byte encoded APDU: TRAILER | DATA
 * @return Encoded APDU
 */
public byte[] toByteArray(){
  ByteArrayOutputStream baos=new ByteArrayOutputStream(data.length + 2);
  try {
    baos.write(trailer);
    baos.write(data);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  return baos.toByteArray();
}","/** 
 * Returns the byte encoded APDU: TRAILER | DATA
 * @return Encoded APDU
 */
public byte[] toByteArray(){
  ByteArrayOutputStream baos=new ByteArrayOutputStream(data.length + 2);
  try {
    baos.write(data);
    baos.write(trailer);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  return baos.toByteArray();
}"
48082,Object initialize();,void initialize();
48083,"public EventTypeFilter(EventType... eventType){
  if (eventType.length == 0) {
    this.eventType=new ArrayList<EventType>(Arrays.asList(EventType.values()));
  }
 else {
    this.eventType=new ArrayList<EventType>(Arrays.asList(eventType));
  }
}","public EventTypeFilter(EventType... eventType){
  if (eventType.length == 0) {
    this.eventType=new ArrayList<>(Arrays.asList(EventType.values()));
  }
 else {
    this.eventType=new ArrayList<>(Arrays.asList(eventType));
  }
}"
48084,"public EventDispatcher(EventManager manager){
  this.manager=manager;
  this.guard=new Semaphore(1);
  this.eventFilter=new ConcurrentHashMap<EventCallback,ArrayList<EventFilter>>();
}","public EventDispatcher(EventManager manager){
  this.manager=manager;
  this.guard=new Semaphore(1);
  this.eventFilter=new ConcurrentHashMap<>();
}"
48085,"protected List<IFDStatusType> ifdStatus() throws WSException {
  GetStatus status=new GetStatus();
  status.setContextHandle(ctx);
  GetStatusResponse statusResponse=env.getIFD().getStatus(status);
  List<IFDStatusType> result;
  WSHelper.checkResult(statusResponse);
  result=statusResponse.getIFDStatus();
  return result;
}","@Nonnull protected List<IFDStatusType> ifdStatus() throws WSException {
  GetStatus status=new GetStatus();
  status.setContextHandle(ctx);
  GetStatusResponse statusResponse=env.getIFD().getStatus(status);
  List<IFDStatusType> result;
  WSHelper.checkResult(statusResponse);
  result=statusResponse.getIFDStatus();
  return result;
}"
48086,"@Override public synchronized Object initialize(){
  threadPool=Executors.newCachedThreadPool();
  watcher=threadPool.submit(new EventRunner(this,builder));
  return new ArrayList<ConnectionHandleType>();
}","@Override public synchronized void initialize(){
  threadPool=Executors.newCachedThreadPool();
  try {
    watcher=threadPool.submit(new EventRunner(this,builder));
  }
 catch (  WSException ex) {
    throw new RuntimeException(""String_Node_Str"");
  }
}"
48087,"/** 
 * @param ifdName
 * @return
 * @throws NoSuchTerminal
 * @throws SCIOException
 * @throws IllegalStateException
 * @throws NullPointerException
 * @throws SecurityException
 */
@Nonnull public byte[] openChannel(@Nonnull String ifdName) throws NoSuchTerminal, SCIOException, IllegalStateException {
  SCIOTerminal t=terminals.getTerminal(ifdName);
  SCIOCard card=t.connect(SCIOProtocol.ANY);
  SCIOChannel channel=card.getBasicChannel();
  byte[] slotHandle=createSlotHandle();
  HandledChannel ch=new HandledChannel(slotHandle,channel);
  channels.put(slotHandle,ch);
  return slotHandle.clone();
}","/** 
 * @param ifdName
 * @return
 * @throws NoSuchTerminal
 * @throws SCIOException
 * @throws IllegalStateException
 * @throws NullPointerException
 * @throws SecurityException
 */
@Nonnull public byte[] openChannel(@Nonnull String ifdName) throws NoSuchTerminal, SCIOException, IllegalStateException {
  SCIOTerminal t=getTerminals().getTerminal(ifdName);
  SCIOCard card=t.connect(SCIOProtocol.ANY);
  SCIOChannel channel=card.getBasicChannel();
  byte[] slotHandle=createSlotHandle();
  HandledChannel ch=new HandledChannel(slotHandle,channel);
  channels.put(slotHandle,ch);
  return slotHandle.clone();
}"
48088,"/** 
 * Wait for events in the system. The SmartcardIO wait function only reacts on card events, new and removed terminals go unseen. in order to fix this, we wait only a short time and check the terminal list periodically.
 * @param timeout Timeout values as in {@link #waitForChange(long)}.
 * @return {@code true} if a change the terminals happened, {@code false} if a timeout occurred.
 */
private boolean internalWait(long timeout) throws CardException {
  if (timeout < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else   if (timeout == 0) {
    timeout=Long.MAX_VALUE;
  }
  while (true) {
    if (timeout == 0) {
      return false;
    }
    long waitTime;
    if (timeout < WAIT_DELTA) {
      waitTime=timeout;
      timeout=0;
    }
 else {
      timeout=timeout - WAIT_DELTA;
      waitTime=WAIT_DELTA;
    }
    boolean change=own.terminals.waitForChange(waitTime);
    if (change) {
      return true;
    }
    ArrayList<CardTerminal> currentTerms=new ArrayList<>(own.terminals.list());
    if (currentTerms.size() != terminals.size()) {
      return true;
    }
    HashSet<String> newTermNames=new HashSet<>();
    for (    CardTerminal next : currentTerms) {
      newTermNames.add(next.getName());
    }
    int sizeBefore=newTermNames.size();
    if (sizeBefore != terminals.size()) {
      return false;
    }
    newTermNames.addAll(terminals);
    int sizeAfter=newTermNames.size();
    if (sizeBefore != sizeAfter) {
      return false;
    }
  }
}","/** 
 * Wait for events in the system. The SmartcardIO wait function only reacts on card events, new and removed terminals go unseen. in order to fix this, we wait only a short time and check the terminal list periodically.
 * @param timeout Timeout values as in {@link #waitForChange(long)}.
 * @return {@code true} if a change the terminals happened, {@code false} if a timeout occurred.
 */
private boolean internalWait(long timeout) throws CardException {
  if (timeout < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else   if (timeout == 0) {
    timeout=Long.MAX_VALUE;
  }
  while (true) {
    if (timeout == 0) {
      return false;
    }
    long waitTime;
    if (timeout < WAIT_DELTA) {
      waitTime=timeout;
      timeout=0;
    }
 else {
      timeout=timeout - WAIT_DELTA;
      waitTime=WAIT_DELTA;
    }
    boolean change=own.terminals.waitForChange(1);
    if (change) {
      return true;
    }
    try {
      Thread.sleep(waitTime);
    }
 catch (    InterruptedException ex) {
      throw new CardException(""String_Node_Str"");
    }
    change=own.terminals.waitForChange(1);
    if (change) {
      return true;
    }
    ArrayList<CardTerminal> currentTerms=new ArrayList<>(own.terminals.list());
    if (currentTerms.size() != terminals.size()) {
      return true;
    }
    HashSet<String> newTermNames=new HashSet<>();
    for (    CardTerminal next : currentTerms) {
      newTermNames.add(next.getName());
    }
    int sizeBefore=newTermNames.size();
    if (sizeBefore != terminals.size()) {
      return false;
    }
    newTermNames.addAll(terminals);
    int sizeAfter=newTermNames.size();
    if (sizeBefore != sizeAfter) {
      return false;
    }
  }
}"
48089,"/** 
 * Activates the client according to the received TCToken.
 * @param request The activation request containing the TCToken.
 * @return The response containing the result of the activation process.
 * @throws InvalidRedirectUrlException Thrown in case no redirect URL could be determined.
 * @throws SecurityViolationException
 * @throws NonGuiException
 */
public TCTokenResponse handleActivate(TCTokenRequest request) throws InvalidRedirectUrlException, SecurityViolationException, NonGuiException {
  TCToken token=request.getTCToken();
  if (logger.isDebugEnabled()) {
    try {
      WSMarshaller m=WSMarshallerFactory.createInstance();
      logger.debug(""String_Node_Str"",m.doc2str(m.marshal(token)));
    }
 catch (    TransformerException|WSMarshallerException ex) {
    }
  }
  final DynamicContext dynCtx=DynamicContext.getInstance(TR03112Keys.INSTANCE_KEY);
  boolean performChecks=isPerformTR03112Checks(request);
  if (!performChecks) {
    logger.warn(""String_Node_Str"");
  }
  boolean isObjectActivation=request.getTCTokenURL() == null;
  if (isObjectActivation) {
    logger.warn(""String_Node_Str"");
  }
  dynCtx.put(TR03112Keys.TCTOKEN_CHECKS,performChecks);
  dynCtx.put(TR03112Keys.OBJECT_ACTIVATION,isObjectActivation);
  dynCtx.put(TR03112Keys.TCTOKEN_SERVER_CERTIFICATES,request.getCertificates());
  ConnectionHandleType connectionHandle=null;
  TCTokenResponse response=new TCTokenResponse();
  response.setTCToken(token);
  byte[] requestedContextHandle=request.getContextHandle();
  String ifdName=request.getIFDName();
  BigInteger requestedSlotIndex=request.getSlotIndex();
  if (requestedContextHandle == null || ifdName == null || requestedSlotIndex == null) {
    connectionHandle=getFirstHandle(request.getCardType());
  }
 else {
    ConnectionHandleType requestedHandle=new ConnectionHandleType();
    requestedHandle.setContextHandle(requestedContextHandle);
    requestedHandle.setIFDName(ifdName);
    requestedHandle.setSlotIndex(requestedSlotIndex);
    Set<CardStateEntry> matchingHandles=cardStates.getMatchingEntries(requestedHandle);
    if (!matchingHandles.isEmpty()) {
      connectionHandle=matchingHandles.toArray(new CardStateEntry[]{})[0].handleCopy();
    }
  }
  if (connectionHandle == null) {
    String msg=lang.translationForKey(""String_Node_Str"");
    logger.error(msg);
    response.setResult(WSHelper.makeResultError(ECardConstants.Minor.SAL.CANCELLATION_BY_USER,msg));
    response=determineRefreshURL(request,response);
    response.finishResponse(true);
    return response;
  }
  try {
    response=processBinding(request,connectionHandle);
    response=determineRefreshURL(request,response);
    response.finishResponse(isObjectActivation);
    return response;
  }
 catch (  DispatcherException w) {
    logger.error(w.getMessage(),w);
    response.setResultCode(BindingResultCode.INTERNAL_ERROR);
    response.setResult(WSHelper.makeResultError(ECardConstants.Minor.App.INT_ERROR,w.getMessage()));
    showErrorMessage(w.getMessage());
    throw new NonGuiException(response,w.getMessage(),w);
  }
catch (  PAOSException w) {
    logger.error(w.getMessage(),w);
    Throwable innerException=w.getCause();
    if (innerException == null) {
      innerException=w;
    }
 else     if (innerException instanceof ExecutionException) {
      innerException=innerException.getCause();
    }
    String errorMsg=innerException.getLocalizedMessage();
switch (errorMsg) {
case ""String_Node_Str"":
      errorMsg=langTr03112.translationForKey(NO_RESPONSE_FROM_SERVER);
    break;
case ECardConstants.Minor.App.INT_ERROR + ""String_Node_Str"":
  errorMsg=langTr03112.translationForKey(UNKNOWN_ECARD_ERROR);
break;
}
showErrorMessage(errorMsg);
if (innerException instanceof WSException) {
response.setResult(((WSException)innerException).getResult());
}
 else {
response.setResult(WSHelper.makeResultError(ECardConstants.Minor.App.INCORRECT_PARM,w.getMessage()));
}
try {
response=determineRefreshURL(request,response);
response.finishResponse(true);
}
 catch (InvalidRedirectUrlException ex) {
logger.error(ex.getMessage(),ex);
response.setResultCode(BindingResultCode.INTERNAL_ERROR);
throw new NonGuiException(response,ex.getMessage(),ex);
}
catch (SecurityViolationException ex) {
String msg2=""String_Node_Str"" + ""String_Node_Str"";
logger.error(msg2,ex);
response.setResultCode(BindingResultCode.REDIRECT);
response.addAuxResultData(AuxDataKeys.REDIRECT_LOCATION,ex.getBindingResult().getAuxResultData().get(AuxDataKeys.REDIRECT_LOCATION));
}
return response;
}
}","/** 
 * Activates the client according to the received TCToken.
 * @param request The activation request containing the TCToken.
 * @return The response containing the result of the activation process.
 * @throws InvalidRedirectUrlException Thrown in case no redirect URL could be determined.
 * @throws SecurityViolationException
 * @throws NonGuiException
 */
public TCTokenResponse handleActivate(TCTokenRequest request) throws InvalidRedirectUrlException, SecurityViolationException, NonGuiException {
  TCToken token=request.getTCToken();
  if (logger.isDebugEnabled()) {
    try {
      WSMarshaller m=WSMarshallerFactory.createInstance();
      logger.debug(""String_Node_Str"",m.doc2str(m.marshal(token)));
    }
 catch (    TransformerException|WSMarshallerException ex) {
    }
  }
  final DynamicContext dynCtx=DynamicContext.getInstance(TR03112Keys.INSTANCE_KEY);
  boolean performChecks=isPerformTR03112Checks(request);
  if (!performChecks) {
    logger.warn(""String_Node_Str"");
  }
  boolean isObjectActivation=request.getTCTokenURL() == null;
  if (isObjectActivation) {
    logger.warn(""String_Node_Str"");
  }
  dynCtx.put(TR03112Keys.TCTOKEN_CHECKS,performChecks);
  dynCtx.put(TR03112Keys.OBJECT_ACTIVATION,isObjectActivation);
  dynCtx.put(TR03112Keys.TCTOKEN_SERVER_CERTIFICATES,request.getCertificates());
  ConnectionHandleType connectionHandle=null;
  TCTokenResponse response=new TCTokenResponse();
  response.setTCToken(token);
  byte[] requestedContextHandle=request.getContextHandle();
  String ifdName=request.getIFDName();
  BigInteger requestedSlotIndex=request.getSlotIndex();
  if (requestedContextHandle == null || ifdName == null || requestedSlotIndex == null) {
    connectionHandle=getFirstHandle(request.getCardType());
  }
 else {
    ConnectionHandleType requestedHandle=new ConnectionHandleType();
    requestedHandle.setContextHandle(requestedContextHandle);
    requestedHandle.setIFDName(ifdName);
    requestedHandle.setSlotIndex(requestedSlotIndex);
    Set<CardStateEntry> matchingHandles=cardStates.getMatchingEntries(requestedHandle);
    if (!matchingHandles.isEmpty()) {
      connectionHandle=matchingHandles.toArray(new CardStateEntry[]{})[0].handleCopy();
    }
  }
  if (connectionHandle == null) {
    String msg=lang.translationForKey(""String_Node_Str"");
    logger.error(msg);
    response.setResult(WSHelper.makeResultError(ECardConstants.Minor.SAL.CANCELLATION_BY_USER,msg));
    response=determineRefreshURL(request,response);
    response.finishResponse(true);
    return response;
  }
  try {
    response=processBinding(request,connectionHandle);
    response=determineRefreshURL(request,response);
    response.finishResponse(isObjectActivation);
    return response;
  }
 catch (  DispatcherException w) {
    logger.error(w.getMessage(),w);
    response.setResultCode(BindingResultCode.INTERNAL_ERROR);
    response.setResult(WSHelper.makeResultError(ECardConstants.Minor.App.INT_ERROR,w.getMessage()));
    showErrorMessage(w.getMessage());
    throw new NonGuiException(response,w.getMessage(),w);
  }
catch (  PAOSException w) {
    logger.error(w.getMessage(),w);
    Throwable innerException=w.getCause();
    if (innerException == null) {
      innerException=w;
    }
 else     if (innerException instanceof ExecutionException) {
      innerException=innerException.getCause();
    }
    String errorMsg=innerException.getLocalizedMessage();
switch (errorMsg) {
case ""String_Node_Str"":
      errorMsg=langTr03112.translationForKey(NO_RESPONSE_FROM_SERVER);
    break;
case ECardConstants.Minor.App.INT_ERROR + ""String_Node_Str"":
  errorMsg=langTr03112.translationForKey(UNKNOWN_ECARD_ERROR);
break;
}
if (innerException instanceof WSException) {
errorMsg=langTr03112.translationForKey(ERROR_WHILE_AUTHENTICATION);
response.setResult(WSHelper.makeResultError(((WSException)innerException).getResultMinor(),errorMsg));
}
 else if (innerException instanceof PAOSConnectionException) {
response.setResult(WSHelper.makeResultError(ECardConstants.Minor.App.COMMUNICATION_ERROR,w.getLocalizedMessage()));
}
 else {
response.setResult(WSHelper.makeResultError(ECardConstants.Minor.App.INCORRECT_PARM,w.getLocalizedMessage()));
}
showErrorMessage(errorMsg);
try {
response=determineRefreshURL(request,response);
response.finishResponse(true);
}
 catch (InvalidRedirectUrlException ex) {
logger.error(ex.getMessage(),ex);
response.setResultCode(BindingResultCode.INTERNAL_ERROR);
throw new NonGuiException(response,ex.getMessage(),ex);
}
catch (SecurityViolationException ex) {
String msg2=""String_Node_Str"" + ""String_Node_Str"";
logger.error(msg2,ex);
response.setResultCode(BindingResultCode.REDIRECT);
response.addAuxResultData(AuxDataKeys.REDIRECT_LOCATION,ex.getBindingResult().getAuxResultData().get(AuxDataKeys.REDIRECT_LOCATION));
}
return response;
}
}"
48090,"@Override public DIDAuthenticateResponse perform(DIDAuthenticate didAuthenticate,Map<String,Object> internalData){
  DIDAuthenticateResponse response=new DIDAuthenticateResponse();
  DynamicContext dynCtx=DynamicContext.getInstance(TR03112Keys.INSTANCE_KEY);
  try {
    ObjectSchemaValidator valid=(ObjectSchemaValidator)dynCtx.getPromise(EACProtocol.SCHEMA_VALIDATOR).deref();
    boolean messageValid=valid.validateObject(didAuthenticate);
    if (!messageValid) {
      String msg=""String_Node_Str"";
      logger.error(msg);
      dynCtx.put(EACProtocol.AUTHENTICATION_FAILED,true);
      response.setResult(WSHelper.makeResultError(ECardConstants.Minor.App.INCORRECT_PARM,msg));
      return response;
    }
  }
 catch (  ObjectValidatorException ex) {
    String msg=""String_Node_Str"";
    logger.error(msg,ex);
    dynCtx.put(EACProtocol.AUTHENTICATION_FAILED,true);
    response.setResult(WSHelper.makeResultError(ECardConstants.Minor.App.INT_ERROR,msg));
    return response;
  }
catch (  InterruptedException ex) {
    String msg=""String_Node_Str"";
    logger.error(msg,ex);
    dynCtx.put(EACProtocol.AUTHENTICATION_FAILED,true);
    response.setResult(WSHelper.makeResultError(ECardConstants.Minor.App.INT_ERROR,msg));
    return response;
  }
  byte[] slotHandle=didAuthenticate.getConnectionHandle().getSlotHandle();
  try {
    EAC2InputType eac2Input=new EAC2InputType(didAuthenticate.getAuthenticationProtocolData());
    EAC2OutputType eac2Output=eac2Input.getOutputType();
    TerminalAuthentication ta=new TerminalAuthentication(dispatcher,slotHandle);
    CardVerifiableCertificateChain certificateChain;
    certificateChain=(CardVerifiableCertificateChain)internalData.get(EACConstants.IDATA_CERTIFICATES);
    certificateChain.addCertificates(eac2Input.getCertificates());
    byte[] currentCAR=(byte[])internalData.get(EACConstants.IDATA_CURRENT_CAR);
    certificateChain=certificateChain.getCertificateChainFromCAR(currentCAR);
    ta.verifyCertificates(certificateChain);
    CardVerifiableCertificate terminalCertificate=certificateChain.getTerminalCertificate();
    byte[] key=eac2Input.getEphemeralPublicKey();
    byte[] signature=eac2Input.getSignature();
    internalData.put(EACConstants.IDATA_PK_PCD,key);
    internalData.put(EACConstants.IDATA_SIGNATURE,signature);
    internalData.put(EACConstants.IDATA_TERMINAL_CERTIFICATE,terminalCertificate);
    if (signature != null) {
      logger.trace(""String_Node_Str"");
      ChipAuthentication ca=new ChipAuthentication(dispatcher,slotHandle);
      AuthenticationHelper auth=new AuthenticationHelper(ta,ca);
      eac2Output=auth.performAuth(eac2Output,internalData);
      DynamicContext ctx=DynamicContext.getInstance(TR03112Keys.INSTANCE_KEY);
      ctx.put(EACProtocol.AUTHENTICATION_DONE,true);
    }
 else {
      logger.trace(""String_Node_Str"");
      byte[] rPICC=(byte[])internalData.get(EACConstants.IDATA_CHALLENGE);
      eac2Output.setChallenge(rPICC);
    }
    response.setResult(WSHelper.makeResultOK());
    response.setAuthenticationProtocolData(eac2Output.getAuthDataType());
  }
 catch (  Exception e) {
    logger.error(e.getMessage(),e);
    response.setResult(WSHelper.makeResultUnknownError(e.getMessage()));
    dynCtx.put(EACProtocol.AUTHENTICATION_FAILED,true);
  }
  return response;
}","@Override public DIDAuthenticateResponse perform(DIDAuthenticate didAuthenticate,Map<String,Object> internalData){
  DIDAuthenticateResponse response=new DIDAuthenticateResponse();
  DynamicContext dynCtx=DynamicContext.getInstance(TR03112Keys.INSTANCE_KEY);
  try {
    ObjectSchemaValidator valid=(ObjectSchemaValidator)dynCtx.getPromise(EACProtocol.SCHEMA_VALIDATOR).deref();
    boolean messageValid=valid.validateObject(didAuthenticate);
    if (!messageValid) {
      String msg=""String_Node_Str"";
      logger.error(msg);
      dynCtx.put(EACProtocol.AUTHENTICATION_FAILED,true);
      response.setResult(WSHelper.makeResultError(ECardConstants.Minor.App.INCORRECT_PARM,msg));
      return response;
    }
  }
 catch (  ObjectValidatorException ex) {
    String msg=""String_Node_Str"";
    logger.error(msg,ex);
    dynCtx.put(EACProtocol.AUTHENTICATION_FAILED,true);
    response.setResult(WSHelper.makeResultError(ECardConstants.Minor.App.INT_ERROR,msg));
    return response;
  }
catch (  InterruptedException ex) {
    String msg=""String_Node_Str"";
    logger.error(msg,ex);
    dynCtx.put(EACProtocol.AUTHENTICATION_FAILED,true);
    response.setResult(WSHelper.makeResultError(ECardConstants.Minor.App.INT_ERROR,msg));
    return response;
  }
  byte[] slotHandle=didAuthenticate.getConnectionHandle().getSlotHandle();
  try {
    EAC2InputType eac2Input=new EAC2InputType(didAuthenticate.getAuthenticationProtocolData());
    EAC2OutputType eac2Output=eac2Input.getOutputType();
    TerminalAuthentication ta=new TerminalAuthentication(dispatcher,slotHandle);
    CardVerifiableCertificateChain certificateChain;
    certificateChain=(CardVerifiableCertificateChain)internalData.get(EACConstants.IDATA_CERTIFICATES);
    certificateChain.addCertificates(eac2Input.getCertificates());
    byte[] currentCAR=(byte[])internalData.get(EACConstants.IDATA_CURRENT_CAR);
    certificateChain=certificateChain.getCertificateChainFromCAR(currentCAR);
    if (certificateChain.getCertificates().isEmpty()) {
      String msg=""String_Node_Str"";
      logger.error(msg);
      response.setResult(WSHelper.makeResultError(ECardConstants.Minor.App.PARM_ERROR,msg));
      return response;
    }
    ta.verifyCertificates(certificateChain);
    CardVerifiableCertificate terminalCertificate=certificateChain.getTerminalCertificate();
    byte[] key=eac2Input.getEphemeralPublicKey();
    byte[] signature=eac2Input.getSignature();
    internalData.put(EACConstants.IDATA_PK_PCD,key);
    internalData.put(EACConstants.IDATA_SIGNATURE,signature);
    internalData.put(EACConstants.IDATA_TERMINAL_CERTIFICATE,terminalCertificate);
    if (signature != null) {
      logger.trace(""String_Node_Str"");
      ChipAuthentication ca=new ChipAuthentication(dispatcher,slotHandle);
      AuthenticationHelper auth=new AuthenticationHelper(ta,ca);
      eac2Output=auth.performAuth(eac2Output,internalData);
      DynamicContext ctx=DynamicContext.getInstance(TR03112Keys.INSTANCE_KEY);
      ctx.put(EACProtocol.AUTHENTICATION_DONE,true);
    }
 else {
      logger.trace(""String_Node_Str"");
      byte[] rPICC=(byte[])internalData.get(EACConstants.IDATA_CHALLENGE);
      eac2Output.setChallenge(rPICC);
    }
    response.setResult(WSHelper.makeResultOK());
    response.setAuthenticationProtocolData(eac2Output.getAuthDataType());
  }
 catch (  Exception e) {
    logger.error(e.getMessage(),e);
    response.setResult(WSHelper.makeResultUnknownError(e.getMessage()));
    dynCtx.put(EACProtocol.AUTHENTICATION_FAILED,true);
  }
  return response;
}"
48091,"/** 
 * Sends start PAOS and answers all successor messages to the server associated with this instance. Messages are exchanged until the server replies with a   {@code StartPAOSResponse} message.
 * @param message The StartPAOS message which is sent in the first message.
 * @return The {@code StartPAOSResponse} message from the server.
 * @throws DispatcherException In case there errors with the message conversion or the dispatcher.
 * @throws PAOSException In case there were errors in the transport layer.
 * @throws PAOSConnectionException
 */
public StartPAOSResponse sendStartPAOS(StartPAOS message) throws DispatcherException, PAOSException, PAOSConnectionException {
  Object msg=message;
  StreamHttpClientConnection conn=null;
  HttpContext ctx=new BasicHttpContext();
  HttpRequestExecutor httpexecutor=new HttpRequestExecutor();
  DefaultConnectionReuseStrategy reuse=new DefaultConnectionReuseStrategy();
  boolean firstLoop=true;
  boolean connectionDropped=false;
  try {
    while (true) {
      if (!firstLoop && tlsHandler.isSameChannel()) {
        throw new PAOSException(CONNECTION_CLOSED);
      }
      firstLoop=false;
      conn=openHttpStream();
      boolean isReusable;
      try {
        do {
          String resource=tlsHandler.getResource();
          BasicHttpEntityEnclosingRequest req=new BasicHttpEntityEnclosingRequest(""String_Node_Str"",resource);
          req.setParams(conn.getParams());
          HttpRequestHelper.setDefaultHeader(req,tlsHandler.getServerAddress());
          req.setHeader(HEADER_KEY_PAOS,headerValuePaos);
          req.setHeader(""String_Node_Str"",""String_Node_Str"");
          ContentType reqContentType=ContentType.create(""String_Node_Str"",""String_Node_Str"");
          HttpUtils.dumpHttpRequest(logger,""String_Node_Str"",req);
          String reqMsgStr=createPAOSResponse(msg);
          StringEntity reqMsg=new StringEntity(reqMsgStr,reqContentType);
          req.setEntity(reqMsg);
          req.setHeader(reqMsg.getContentType());
          req.setHeader(""String_Node_Str"",Long.toString(reqMsg.getContentLength()));
          HttpResponse response=httpexecutor.execute(req,conn,ctx);
          int statusCode=response.getStatusLine().getStatusCode();
          checkHTTPStatusCode(statusCode);
          conn.receiveResponseEntity(response);
          HttpEntity entity=response.getEntity();
          byte[] entityData=FileUtils.toByteArray(entity.getContent());
          HttpUtils.dumpHttpResponse(logger,response,entityData);
          Object requestObj=processPAOSRequest(new ByteArrayInputStream(entityData));
          if (requestObj instanceof StartPAOSResponse) {
            StartPAOSResponse startPAOSResponse=(StartPAOSResponse)requestObj;
            WSHelper.checkResult(startPAOSResponse);
            return startPAOSResponse;
          }
          msg=dispatcher.deliver(requestObj);
          isReusable=reuse.keepAlive(response,ctx);
          connectionDropped=false;
        }
 while (isReusable);
      }
 catch (      IOException ex) {
        if (!connectionDropped) {
          connectionDropped=true;
          logger.warn(""String_Node_Str"");
        }
 else {
          String errMsg=""String_Node_Str"";
          logger.error(errMsg);
          throw new PAOSException(DELIVERY_FAILED,ex);
        }
      }
    }
  }
 catch (  HttpException ex) {
    throw new PAOSException(DELIVERY_FAILED,ex);
  }
catch (  SOAPException ex) {
    throw new PAOSException(SOAP_MESSAGE_FAILURE,ex);
  }
catch (  MarshallingTypeException ex) {
    throw new PAOSDispatcherException(MARSHALLING_ERROR,ex);
  }
catch (  InvocationTargetException ex) {
    throw new PAOSDispatcherException(DISPATCHER_ERROR,ex);
  }
catch (  TransformerException ex) {
    throw new DispatcherException(ex);
  }
catch (  WSException ex) {
    throw new PAOSException(ex);
  }
 finally {
    try {
      if (conn != null) {
        conn.close();
      }
    }
 catch (    IOException ex) {
    }
  }
}","/** 
 * Sends start PAOS and answers all successor messages to the server associated with this instance. Messages are exchanged until the server replies with a   {@code StartPAOSResponse} message.
 * @param message The StartPAOS message which is sent in the first message.
 * @return The {@code StartPAOSResponse} message from the server.
 * @throws DispatcherException In case there errors with the message conversion or the dispatcher.
 * @throws PAOSException In case there were errors in the transport layer.
 * @throws PAOSConnectionException
 */
public StartPAOSResponse sendStartPAOS(StartPAOS message) throws DispatcherException, PAOSException, PAOSConnectionException {
  Object msg=message;
  StreamHttpClientConnection conn=null;
  HttpContext ctx=new BasicHttpContext();
  HttpRequestExecutor httpexecutor=new HttpRequestExecutor();
  DefaultConnectionReuseStrategy reuse=new DefaultConnectionReuseStrategy();
  boolean firstLoop=true;
  boolean connectionDropped=false;
  ResponseBaseType lastResponse=new ResponseBaseType();
  try {
    while (true) {
      if (!firstLoop && tlsHandler.isSameChannel()) {
        throw new PAOSException(CONNECTION_CLOSED);
      }
      firstLoop=false;
      conn=openHttpStream();
      boolean isReusable;
      try {
        do {
          if (msg instanceof ResponseBaseType) {
            lastResponse=(ResponseBaseType)msg;
          }
          String resource=tlsHandler.getResource();
          BasicHttpEntityEnclosingRequest req=new BasicHttpEntityEnclosingRequest(""String_Node_Str"",resource);
          req.setParams(conn.getParams());
          HttpRequestHelper.setDefaultHeader(req,tlsHandler.getServerAddress());
          req.setHeader(HEADER_KEY_PAOS,headerValuePaos);
          req.setHeader(""String_Node_Str"",""String_Node_Str"");
          ContentType reqContentType=ContentType.create(""String_Node_Str"",""String_Node_Str"");
          HttpUtils.dumpHttpRequest(logger,""String_Node_Str"",req);
          String reqMsgStr=createPAOSResponse(msg);
          StringEntity reqMsg=new StringEntity(reqMsgStr,reqContentType);
          req.setEntity(reqMsg);
          req.setHeader(reqMsg.getContentType());
          req.setHeader(""String_Node_Str"",Long.toString(reqMsg.getContentLength()));
          HttpResponse response=httpexecutor.execute(req,conn,ctx);
          int statusCode=response.getStatusLine().getStatusCode();
          checkHTTPStatusCode(statusCode);
          conn.receiveResponseEntity(response);
          HttpEntity entity=response.getEntity();
          byte[] entityData=FileUtils.toByteArray(entity.getContent());
          HttpUtils.dumpHttpResponse(logger,response,entityData);
          Object requestObj=processPAOSRequest(new ByteArrayInputStream(entityData));
          if (requestObj instanceof StartPAOSResponse) {
            StartPAOSResponse startPAOSResponse=(StartPAOSResponse)requestObj;
            WSHelper.checkResult(startPAOSResponse);
            WSHelper.checkResult(lastResponse);
            return startPAOSResponse;
          }
          msg=dispatcher.deliver(requestObj);
          isReusable=reuse.keepAlive(response,ctx);
          connectionDropped=false;
        }
 while (isReusable);
      }
 catch (      IOException ex) {
        if (!connectionDropped) {
          connectionDropped=true;
          logger.warn(""String_Node_Str"");
        }
 else {
          String errMsg=""String_Node_Str"";
          logger.error(errMsg);
          throw new PAOSException(DELIVERY_FAILED,ex);
        }
      }
    }
  }
 catch (  HttpException ex) {
    throw new PAOSException(DELIVERY_FAILED,ex);
  }
catch (  SOAPException ex) {
    throw new PAOSException(SOAP_MESSAGE_FAILURE,ex);
  }
catch (  MarshallingTypeException ex) {
    throw new PAOSDispatcherException(MARSHALLING_ERROR,ex);
  }
catch (  InvocationTargetException ex) {
    throw new PAOSDispatcherException(DISPATCHER_ERROR,ex);
  }
catch (  TransformerException ex) {
    throw new DispatcherException(ex);
  }
catch (  WSException ex) {
    throw new PAOSException(ex);
  }
 finally {
    try {
      if (conn != null) {
        conn.close();
      }
    }
 catch (    IOException ex) {
    }
  }
}"
48092,"/** 
 * Check the status code returned from the server. If the status code indicates an error, a PAOSException will be thrown.
 * @param statusCode The status code we received from the server
 * @throws PAOSException If the server returned a HTTP error code
 */
private void checkHTTPStatusCode(int statusCode) throws PAOSException {
  if (statusCode != 200 && statusCode != 202) {
    throw new PAOSException(INVALID_HTTP_STATUS,statusCode);
  }
 else   if (statusCode == 200) {
    String msg2=""String_Node_Str"" + ""String_Node_Str"";
    logger.warn(msg2);
  }
}","/** 
 * Check the status code returned from the server. If the status code indicates an error, a PAOSException will be thrown.
 * @param statusCode The status code we received from the server
 * @throws PAOSException If the server returned a HTTP error code
 */
private void checkHTTPStatusCode(int statusCode) throws PAOSConnectionException {
  if (statusCode != 200 && statusCode != 202) {
    throw new PAOSConnectionException(INVALID_HTTP_STATUS,statusCode);
  }
 else   if (statusCode == 200) {
    String msg2=""String_Node_Str"" + ""String_Node_Str"";
    logger.warn(msg2);
  }
}"
48093,"public PAOSConnectionException(Throwable cause){
  super(lang,PAOS_CONNECTION_EXCEPTION,cause);
}","/** 
 * Creates an instance and initializes the exception with a localized message.
 * @param key Translation key.
 * @param params Parameters adding values into the translation.
 */
public PAOSConnectionException(I18nKey key,Object... params){
  super(lang,key,params);
}"
48094,"/** 
 * Transform query parameters into a java map. The parameters are not decoded, but taken as is. The query string has the form <pre>key(=value)?&key((=value)?)*</pre>. If a key does not have a value, null is taken as value.
 * @param queryStr Query string as found in the HTTP request line.
 * @return Map with key value pairs of the query parameters.
 */
public static Map<String,String> transformRaw(String queryStr){
  HashMap<String,String> result=new HashMap<>();
  if (queryStr != null) {
    String[] queries=queryStr.split(""String_Node_Str"");
    for (    String query : queries) {
      String[] kv=query.split(""String_Node_Str"");
      if (kv.length == 1) {
        result.put(kv[0],null);
      }
 else       if (kv.length == 2) {
        result.put(kv[0],kv[1]);
      }
    }
  }
  return result;
}","/** 
 * Transform query parameters into a java map. The parameters are not decoded, but taken as is. The query string has the form <pre>key(=value)?&key((=value)?)*</pre>. If a key does not have a value, null is taken as value.
 * @param queryStr Query string as found in the HTTP request line.
 * @return Map with key value pairs of the query parameters.
 */
public static Map<String,String> transformRaw(String queryStr){
  HashMap<String,String> result=new HashMap<>();
  if (queryStr != null) {
    String[] queries=queryStr.split(""String_Node_Str"");
    for (    String query : queries) {
      int first=query.indexOf('=');
      if (first == -1) {
        result.put(query,""String_Node_Str"");
      }
 else {
        String key=query.substring(0,first);
        String value=query.substring(first + 1,query.length());
        result.put(key,value);
      }
    }
  }
  return result;
}"
48095,"/** 
 * This method performs the signature creation according to BSI TR-03112 part 7.
 * @param cryptoMarker The {@link CryptoMarkerType} containing the SignatureCreationInfo for creating the signature.
 * @param keyReference A byte array containing the reference of the key to use.
 * @param algorithmIdentifier A byte array containing the identifier of the signing algorithm.
 * @param message The message to sign.
 * @param slotHandle The slotHandle identifying the card.
 * @param hashRef The variable contains the reference for the hash algorithm which have to be used.
 * @param hashInfo A HashGenerationInfo object which indicates how the hash computation is to perform.
 * @return A {@link SignResponse} object containing the signature of the <b>message</b>.
 * @throws TLVException Thrown if the TLV creation for the key identifier or algorithm identifier failed.
 * @throws IncorrectParameterException Thrown if the SignatureGenerationInfo does not contain PSO_CDS or INT_AUTHafter an MSE_KEY command.
 * @throws APDUException Thrown if one of the command to create the signature failed.
 * @throws org.openecard.common.WSHelper.WSException Thrown if the checkResults method of WSHelper failed.
 */
private SignResponse performSignature(CryptoMarkerType cryptoMarker,byte[] keyReference,byte[] algorithmIdentifier,byte[] message,byte[] slotHandle,byte[] hashRef,HashGenerationInfoType hashInfo) throws TLVException, IncorrectParameterException, APDUException, WSHelper.WSException {
  SignResponse response=WSHelper.makeResponse(SignResponse.class,WSHelper.makeResultOK());
  TLV tagAlgorithmIdentifier=new TLV();
  tagAlgorithmIdentifier.setTagNumWithClass(CARD_ALG_REF);
  tagAlgorithmIdentifier.setValue(algorithmIdentifier);
  TLV tagKeyReference=new TLV();
  tagKeyReference.setTagNumWithClass(KEY_REFERENCE_PRIVATE_KEY);
  tagKeyReference.setValue(keyReference);
  CardCommandAPDU cmdAPDU=null;
  CardResponseAPDU responseAPDU=null;
  String[] signatureGenerationInfo=cryptoMarker.getSignatureGenerationInfo();
  for (  String command : signatureGenerationInfo) {
    HashSet<String> signGenInfo=new HashSet<String>(java.util.Arrays.asList(signatureGenerationInfo));
    if (command.equals(""String_Node_Str"")) {
      byte[] mseData=tagKeyReference.toBER();
      if (signGenInfo.contains(""String_Node_Str"")) {
        cmdAPDU=new ManageSecurityEnvironment(SET_COMPUTATION,ManageSecurityEnvironment.DST,mseData);
      }
 else       if (signGenInfo.contains(""String_Node_Str"") && !signGenInfo.contains(""String_Node_Str"")) {
        cmdAPDU=new ManageSecurityEnvironment(SET_COMPUTATION,ManageSecurityEnvironment.AT,mseData);
      }
 else {
        String msg=""String_Node_Str"";
        logger.error(msg);
        throw new IncorrectParameterException(msg);
      }
    }
 else     if (command.equals(""String_Node_Str"")) {
      cmdAPDU=new PSOComputeDigitalSignature(message,BLOCKSIZE);
    }
 else     if (command.equals(""String_Node_Str"")) {
      cmdAPDU=new InternalAuthenticate(message,BLOCKSIZE);
    }
 else     if (command.equals(""String_Node_Str"")) {
      cmdAPDU=new ManageSecurityEnvironment.Restore(ManageSecurityEnvironment.DST);
    }
 else     if (command.equals(""String_Node_Str"")) {
      cmdAPDU=new ManageSecurityEnvironment.Set(SET_COMPUTATION,ManageSecurityEnvironment.HT);
      TLV mseDataTLV=new TLV();
      mseDataTLV.setTagNumWithClass((byte)0x80);
      mseDataTLV.setValue(hashRef);
      cmdAPDU.setData(mseDataTLV.toBER());
    }
 else     if (command.equals(""String_Node_Str"")) {
      if (hashInfo.value().equals(HashGenerationInfoType.LAST_ROUND_ON_CARD.value()) || hashInfo.value().equals(HashGenerationInfoType.NOT_ON_CARD.value())) {
        cmdAPDU=new PSOHash(PSOHash.P2_SET_HASH_OR_PART,message);
      }
 else {
        cmdAPDU=new PSOHash(PSOHash.P2_HASH_MESSAGE,message);
      }
    }
 else     if (command.equals(""String_Node_Str"")) {
      byte[] mseData=tagAlgorithmIdentifier.toBER();
      cmdAPDU=new ManageSecurityEnvironment(SET_COMPUTATION,ManageSecurityEnvironment.DST,mseData);
    }
 else     if (command.equals(""String_Node_Str"")) {
      byte[] mseData=ByteUtils.concatenate(tagKeyReference.toBER(),tagAlgorithmIdentifier.toBER());
      cmdAPDU=new ManageSecurityEnvironment(SET_COMPUTATION,ManageSecurityEnvironment.DST,mseData);
    }
 else     if (command.equals(""String_Node_Str"")) {
      byte[] mseData=tagKeyReference.toBER();
      cmdAPDU=new ManageSecurityEnvironment(SET_COMPUTATION,ManageSecurityEnvironment.AT,mseData);
    }
 else     if (command.equals(""String_Node_Str"")) {
      byte[] mseData=ByteUtils.concatenate(tagKeyReference.toBER(),tagAlgorithmIdentifier.toBER());
      cmdAPDU=new ManageSecurityEnvironment(SET_COMPUTATION,ManageSecurityEnvironment.AT,mseData);
    }
 else {
      String msg=""String_Node_Str"" + command + ""String_Node_Str"";
      throw new IncorrectParameterException(msg);
    }
    responseAPDU=cmdAPDU.transmit(dispatcher,slotHandle,Collections.<byte[]>emptyList());
  }
  byte[] signedMessage=responseAPDU.getData();
  while (responseAPDU.getTrailer()[0] == (byte)0x61) {
    GetResponse getResponseData=new GetResponse();
    responseAPDU=getResponseData.transmit(dispatcher,slotHandle,Collections.<byte[]>emptyList());
    signedMessage=Arrays.concatenate(signedMessage,responseAPDU.getData());
  }
  if (!Arrays.areEqual(responseAPDU.getTrailer(),new byte[]{(byte)0x90,(byte)0x00})) {
    TransmitResponse tr=new TransmitResponse();
    tr.getOutputAPDU().add(responseAPDU.toByteArray());
    WSHelper.checkResult(response);
  }
  response.setSignature(signedMessage);
  return response;
}","/** 
 * This method performs the signature creation according to BSI TR-03112 part 7.
 * @param cryptoMarker The {@link CryptoMarkerType} containing the SignatureCreationInfo for creating the signature.
 * @param keyReference A byte array containing the reference of the key to use.
 * @param algorithmIdentifier A byte array containing the identifier of the signing algorithm.
 * @param message The message to sign.
 * @param slotHandle The slotHandle identifying the card.
 * @param hashRef The variable contains the reference for the hash algorithm which have to be used.
 * @param hashInfo A HashGenerationInfo object which indicates how the hash computation is to perform.
 * @return A {@link SignResponse} object containing the signature of the <b>message</b>.
 * @throws TLVException Thrown if the TLV creation for the key identifier or algorithm identifier failed.
 * @throws IncorrectParameterException Thrown if the SignatureGenerationInfo does not contain PSO_CDS or INT_AUTHafter an MSE_KEY command.
 * @throws APDUException Thrown if one of the command to create the signature failed.
 * @throws org.openecard.common.WSHelper.WSException Thrown if the checkResults method of WSHelper failed.
 */
private SignResponse performSignature(CryptoMarkerType cryptoMarker,byte[] keyReference,byte[] algorithmIdentifier,byte[] message,byte[] slotHandle,byte[] hashRef,HashGenerationInfoType hashInfo) throws TLVException, IncorrectParameterException, APDUException, WSHelper.WSException {
  SignResponse response=WSHelper.makeResponse(SignResponse.class,WSHelper.makeResultOK());
  TLV tagAlgorithmIdentifier=new TLV();
  tagAlgorithmIdentifier.setTagNumWithClass(CARD_ALG_REF);
  tagAlgorithmIdentifier.setValue(algorithmIdentifier);
  TLV tagKeyReference=new TLV();
  tagKeyReference.setTagNumWithClass(KEY_REFERENCE_PRIVATE_KEY);
  tagKeyReference.setValue(keyReference);
  CardCommandAPDU cmdAPDU=null;
  CardResponseAPDU responseAPDU=null;
  String[] signatureGenerationInfo=cryptoMarker.getSignatureGenerationInfo();
  for (  String command : signatureGenerationInfo) {
    HashSet<String> signGenInfo=new HashSet<>(java.util.Arrays.asList(signatureGenerationInfo));
    if (command.equals(""String_Node_Str"")) {
      byte[] mseData=tagKeyReference.toBER();
      if (signGenInfo.contains(""String_Node_Str"")) {
        cmdAPDU=new ManageSecurityEnvironment(SET_COMPUTATION,ManageSecurityEnvironment.DST,mseData);
      }
 else       if (signGenInfo.contains(""String_Node_Str"") && !signGenInfo.contains(""String_Node_Str"")) {
        cmdAPDU=new ManageSecurityEnvironment(SET_COMPUTATION,ManageSecurityEnvironment.AT,mseData);
      }
 else {
        String msg=""String_Node_Str"";
        logger.error(msg);
        throw new IncorrectParameterException(msg);
      }
    }
 else     if (command.equals(""String_Node_Str"")) {
      cmdAPDU=new PSOComputeDigitalSignature(message,BLOCKSIZE);
    }
 else     if (command.equals(""String_Node_Str"")) {
      cmdAPDU=new InternalAuthenticate(message,BLOCKSIZE);
    }
 else     if (command.equals(""String_Node_Str"")) {
      cmdAPDU=new ManageSecurityEnvironment.Restore(ManageSecurityEnvironment.DST);
    }
 else     if (command.equals(""String_Node_Str"")) {
      cmdAPDU=new ManageSecurityEnvironment.Set(SET_COMPUTATION,ManageSecurityEnvironment.HT);
      TLV mseDataTLV=new TLV();
      mseDataTLV.setTagNumWithClass((byte)0x80);
      mseDataTLV.setValue(hashRef);
      cmdAPDU.setData(mseDataTLV.toBER());
    }
 else     if (command.equals(""String_Node_Str"")) {
      if (hashInfo.value().equals(HashGenerationInfoType.LAST_ROUND_ON_CARD.value()) || hashInfo.value().equals(HashGenerationInfoType.NOT_ON_CARD.value())) {
        cmdAPDU=new PSOHash(PSOHash.P2_SET_HASH_OR_PART,message);
      }
 else {
        cmdAPDU=new PSOHash(PSOHash.P2_HASH_MESSAGE,message);
      }
    }
 else     if (command.equals(""String_Node_Str"")) {
      byte[] mseData=tagAlgorithmIdentifier.toBER();
      cmdAPDU=new ManageSecurityEnvironment(SET_COMPUTATION,ManageSecurityEnvironment.DST,mseData);
    }
 else     if (command.equals(""String_Node_Str"")) {
      byte[] mseData=ByteUtils.concatenate(tagKeyReference.toBER(),tagAlgorithmIdentifier.toBER());
      cmdAPDU=new ManageSecurityEnvironment(SET_COMPUTATION,ManageSecurityEnvironment.DST,mseData);
    }
 else     if (command.equals(""String_Node_Str"")) {
      byte[] mseData=tagKeyReference.toBER();
      cmdAPDU=new ManageSecurityEnvironment(SET_COMPUTATION,ManageSecurityEnvironment.AT,mseData);
    }
 else     if (command.equals(""String_Node_Str"")) {
      byte[] mseData=ByteUtils.concatenate(tagKeyReference.toBER(),tagAlgorithmIdentifier.toBER());
      cmdAPDU=new ManageSecurityEnvironment(SET_COMPUTATION,ManageSecurityEnvironment.AT,mseData);
    }
 else {
      String msg=""String_Node_Str"" + command + ""String_Node_Str"";
      throw new IncorrectParameterException(msg);
    }
    responseAPDU=cmdAPDU.transmit(dispatcher,slotHandle,Collections.<byte[]>emptyList());
  }
  byte[] signedMessage=responseAPDU.getData();
  while (responseAPDU.getTrailer()[0] == (byte)0x61) {
    GetResponse getResponseData=new GetResponse();
    responseAPDU=getResponseData.transmit(dispatcher,slotHandle,Collections.<byte[]>emptyList());
    signedMessage=Arrays.concatenate(signedMessage,responseAPDU.getData());
  }
  if (!Arrays.areEqual(responseAPDU.getTrailer(),new byte[]{(byte)0x90,(byte)0x00})) {
    response.setResult(WSHelper.makeResultError(ECardConstants.Minor.Disp.COMM_ERROR,responseAPDU.getStatusMessage()));
    return response;
  }
  response.setSignature(signedMessage);
  return response;
}"
48096,"/** 
 * The method performs the SignatureCreation if no standard commands are possible. This method creates a signature with APDUs which are not covered by the methods defined in TR-03112 part 7.
 * @param cryptoMarker A {@link CryptoMarkerType} object containing the information about the creation of a signaturein a legacy way.
 * @param slotHandle A slotHandle identifying the current card.
 * @param templateCTX A Map containing the context data for the evaluation of the template variables. This objectcontains per default the message to sign and the  {@link TLVFunction}.
 * @return A {@link SignResponse} object containing the signature of the <b>message</b>.
 * @throws APDUTemplateException Thrown if the evaluation of the {@link CardCommandTemplate} failed.
 * @throws APDUException Thrown if one of the commands to execute failed.
 * @throws org.openecard.common.WSHelper.WSException Thrown if the checkResult method of WSHelper failed.
 */
private SignResponse performLegacySignature(CryptoMarkerType cryptoMarker,byte[] slotHandle,BaseTemplateContext templateCTX) throws APDUTemplateException, APDUException, WSHelper.WSException {
  SignResponse response=WSHelper.makeResponse(SignResponse.class,WSHelper.makeResultOK());
  List<CardCallTemplateType> legacyCommands=cryptoMarker.getLegacySignatureGenerationInfo();
  CardCommandAPDU cmdAPDU=null;
  CardResponseAPDU responseAPDU=null;
  byte[] signedMessage;
  for (  CardCallTemplateType cctt : legacyCommands) {
    CardCommandTemplate template=new CardCommandTemplate(cctt);
    cmdAPDU=template.evaluate(templateCTX);
    responseAPDU=cmdAPDU.transmit(dispatcher,slotHandle,Collections.<byte[]>emptyList());
  }
  signedMessage=responseAPDU.getData();
  while (responseAPDU.getTrailer()[0] == (byte)0x61) {
    CardCommandAPDU getResponseData=new CardCommandAPDU((byte)0x00,(byte)0xC0,(byte)0x00,(byte)0x00,responseAPDU.getTrailer()[1]);
    responseAPDU=getResponseData.transmit(dispatcher,slotHandle,Collections.<byte[]>emptyList());
    signedMessage=Arrays.concatenate(signedMessage,responseAPDU.getData());
  }
  if (!Arrays.areEqual(responseAPDU.getTrailer(),new byte[]{(byte)0x90,(byte)0x00})) {
    TransmitResponse tr=new TransmitResponse();
    tr.getOutputAPDU().add(responseAPDU.toByteArray());
    WSHelper.checkResult(response);
  }
  response.setSignature(signedMessage);
  return response;
}","/** 
 * The method performs the SignatureCreation if no standard commands are possible. This method creates a signature with APDUs which are not covered by the methods defined in TR-03112 part 7.
 * @param cryptoMarker A {@link CryptoMarkerType} object containing the information about the creation of a signaturein a legacy way.
 * @param slotHandle A slotHandle identifying the current card.
 * @param templateCTX A Map containing the context data for the evaluation of the template variables. This objectcontains per default the message to sign and the  {@link TLVFunction}.
 * @return A {@link SignResponse} object containing the signature of the <b>message</b>.
 * @throws APDUTemplateException Thrown if the evaluation of the {@link CardCommandTemplate} failed.
 * @throws APDUException Thrown if one of the commands to execute failed.
 * @throws org.openecard.common.WSHelper.WSException Thrown if the checkResult method of WSHelper failed.
 */
private SignResponse performLegacySignature(CryptoMarkerType cryptoMarker,byte[] slotHandle,BaseTemplateContext templateCTX) throws APDUTemplateException, APDUException, WSHelper.WSException {
  SignResponse response=WSHelper.makeResponse(SignResponse.class,WSHelper.makeResultOK());
  List<CardCallTemplateType> legacyCommands=cryptoMarker.getLegacySignatureGenerationInfo();
  CardCommandAPDU cmdAPDU;
  CardResponseAPDU responseAPDU=null;
  byte[] signedMessage;
  for (  CardCallTemplateType cctt : legacyCommands) {
    CardCommandTemplate template=new CardCommandTemplate(cctt);
    cmdAPDU=template.evaluate(templateCTX);
    responseAPDU=cmdAPDU.transmit(dispatcher,slotHandle,Collections.<byte[]>emptyList());
  }
  signedMessage=responseAPDU.getData();
  while (responseAPDU.getTrailer()[0] == (byte)0x61) {
    CardCommandAPDU getResponseData=new CardCommandAPDU((byte)0x00,(byte)0xC0,(byte)0x00,(byte)0x00,responseAPDU.getTrailer()[1]);
    responseAPDU=getResponseData.transmit(dispatcher,slotHandle,Collections.<byte[]>emptyList());
    signedMessage=Arrays.concatenate(signedMessage,responseAPDU.getData());
  }
  if (!Arrays.areEqual(responseAPDU.getTrailer(),new byte[]{(byte)0x90,(byte)0x00})) {
    response.setResult(WSHelper.makeResultError(ECardConstants.Minor.Disp.COMM_ERROR,responseAPDU.getStatusMessage()));
    return response;
  }
  response.setSignature(signedMessage);
  return response;
}"
48097,"/** 
 * Writes the changes, not the defaults in the given Properties instance to the user's config file. This function preserves the property values already present in the config file.
 * @param changes Properties to be written.
 * @throws IOException Thrown in case there was a problem reading or writing the config file.
 */
public static synchronized void writeChanges(Properties changes) throws IOException {
  Properties homeProps=new Properties();
  InputStream homeStream=loadHomeProps();
  homeProps.load(homeStream);
  homeStream.close();
  for (  Map.Entry<Object,Object> next : changes.entrySet()) {
    homeProps.put(next.getKey(),next.getValue());
  }
  saveHomeProps(homeProps);
}","/** 
 * Writes the changes, not the defaults in the given Properties instance to the user's config file. This function preserves the property values already present in the config file.
 * @param changes Properties to be written.
 * @throws IOException Thrown in case there was a problem reading or writing the config file.
 */
public static synchronized void writeChanges(Properties changes) throws IOException {
  Properties homeProps=new Properties();
  InputStream homeStream=loadHomeProps();
  if (homeStream != null) {
    homeProps.load(homeStream);
    homeStream.close();
  }
  for (  Map.Entry<Object,Object> next : changes.entrySet()) {
    homeProps.put(next.getKey(),next.getValue());
  }
  saveHomeProps(homeProps);
}"
48098,"/** 
 * Replace minor code for use in refresh URLs. BSI TR-03124-1 defines non URL versions of the ResultMinor codes from BSI TR-03112.
 * @param minor
 * @return
 */
public static String fixResultMinor(@Nonnull String minor){
switch (minor) {
case ECardConstants.Minor.App.UNKNOWN_ERROR:
    minor=""String_Node_Str"";
  break;
default :
}
return minor;
}","/** 
 * Replace minor code for use in refresh URLs. BSI TR-03124-1 defines non URL versions of the ResultMinor codes from BSI TR-03112.
 * @param minor
 * @return
 */
public static String fixResultMinor(@Nonnull String minor){
switch (minor) {
case ECardConstants.Minor.App.UNKNOWN_ERROR:
    minor=""String_Node_Str"";
  break;
case ECardConstants.Minor.App.INT_ERROR:
minor=""String_Node_Str"";
break;
case ECardConstants.Minor.App.COMMUNICATION_ERROR:
minor=""String_Node_Str"";
default :
}
return minor;
}"
48099,"/** 
 * Creates a new PACE protocol step.
 * @param dispatcher Dispatcher
 * @param gui GUI
 */
public PACEStep(Dispatcher dispatcher,UserConsent gui){
  this.dispatcher=dispatcher;
  this.gui=gui;
}","/** 
 * Creates a new PACE protocol step.
 * @param dispatcher Dispatcher
 * @param gui GUI
 */
public PACEStep(Dispatcher dispatcher,UserConsent gui){
  this.dispatcher=dispatcher;
  this.gui=gui;
  pin=langPace.translationForKey(""String_Node_Str"");
  puk=langPace.translationForKey(""String_Node_Str"");
}"
48100,"@Override public DIDAuthenticateResponse perform(DIDAuthenticate request,Map<String,Object> internalData){
  DIDAuthenticate didAuthenticate=request;
  DIDAuthenticateResponse response=new DIDAuthenticateResponse();
  byte[] slotHandle=didAuthenticate.getConnectionHandle().getSlotHandle();
  try {
    EAC1InputType eac1Input=new EAC1InputType(didAuthenticate.getAuthenticationProtocolData());
    EAC1OutputType eac1Output=eac1Input.getOutputType();
    CardStateEntry cardState=(CardStateEntry)internalData.get(EACConstants.IDATA_CARD_STATE_ENTRY);
    boolean nativePace=genericPACESupport(cardState.handleCopy());
    CardVerifiableCertificateChain certChain=new CardVerifiableCertificateChain(eac1Input.getCertificates());
    byte[] rawCertificateDescription=eac1Input.getCertificateDescription();
    CertificateDescription certDescription=CertificateDescription.getInstance(rawCertificateDescription);
    final DynamicContext dynCtx=DynamicContext.getInstance(TR03112Keys.INSTANCE_KEY);
    Promise<Object> promise=dynCtx.getPromise(TR03112Keys.ESERVICE_CERTIFICATE_DESC);
    promise.deliver(certDescription);
    Result activationChecksResult=performChecks(certDescription,dynCtx);
    if (!ECardConstants.Major.OK.equals(activationChecksResult.getResultMajor())) {
      response.setResult(activationChecksResult);
      return response;
    }
    CHAT requiredCHAT=new CHAT(eac1Input.getRequiredCHAT());
    CHAT optionalCHAT=new CHAT(eac1Input.getOptionalCHAT());
    AuthenticatedAuxiliaryData aad=new AuthenticatedAuxiliaryData(eac1Input.getAuthenticatedAuxiliaryData());
    byte pinID=PasswordID.valueOf(didAuthenticate.getDIDName()).getByte();
    String passwordType=PasswordID.parse(pinID).getString();
    PACEMarkerType paceMarker=getPaceMarker(cardState,passwordType);
    CardVerifiableCertificate taCert=certChain.getTerminalCertificates().get(0);
    CardVerifiableCertificateVerifier.verify(taCert,certDescription);
    CHATVerifier.verfiy(taCert.getCHAT(),requiredCHAT);
    optionalCHAT.restrictAccessRights(taCert.getCHAT());
    EACData eacData=new EACData();
    eacData.didRequest=didAuthenticate;
    eacData.certificate=certChain.getTerminalCertificates().get(0);
    eacData.certificateDescription=certDescription;
    eacData.rawCertificateDescription=rawCertificateDescription;
    eacData.transactionInfo=eac1Input.getTransactionInfo();
    eacData.requiredCHAT=requiredCHAT;
    eacData.optionalCHAT=optionalCHAT;
    eacData.selectedCHAT=requiredCHAT;
    eacData.aad=aad;
    eacData.pinID=pinID;
    eacData.passwordType=passwordType;
    InputAPDUInfoType input=new InputAPDUInfoType();
    input.setInputAPDU(new byte[]{(byte)0x00,(byte)0x22,(byte)0xC1,(byte)0xA4,(byte)0x0F,(byte)0x80,(byte)0x0A,(byte)0x04,(byte)0x00,(byte)0x7F,(byte)0x00,(byte)0x07,(byte)0x02,(byte)0x02,(byte)0x04,(byte)0x02,(byte)0x02,(byte)0x83,(byte)0x01,(byte)0x03});
    input.getAcceptableStatusCode().add(new byte[]{(byte)0x90,(byte)0x00});
    input.getAcceptableStatusCode().add(new byte[]{(byte)0x63,(byte)0xC2});
    input.getAcceptableStatusCode().add(new byte[]{(byte)0x63,(byte)0xC1});
    input.getAcceptableStatusCode().add(new byte[]{(byte)0x63,(byte)0xC0});
    input.getAcceptableStatusCode().add(new byte[]{(byte)0x62,(byte)0x83});
    Transmit transmit=new Transmit();
    transmit.setSlotHandle(slotHandle);
    transmit.getInputAPDUInfo().add(input);
    TransmitResponse pinCheckResponse=(TransmitResponse)dispatcher.deliver(transmit);
    byte[] output=pinCheckResponse.getOutputAPDU().get(0);
    ResponseAPDU outputApdu=new ResponseAPDU(output);
    byte[] status={(byte)outputApdu.getSW1(),(byte)outputApdu.getSW2()};
    UserConsentDescription uc=new UserConsentDescription(lang.translationForKey(TITLE));
    if (!Arrays.equals(status,new byte[]{(byte)0x63,(byte)0xC0})) {
      CVCStep cvcStep=new CVCStep(eacData);
      CHATStep chatStep=new CHATStep(eacData);
      PINStep pinStep=new PINStep(eacData,!nativePace,paceMarker);
      uc.getSteps().add(cvcStep);
      uc.getSteps().add(chatStep);
      uc.getSteps().add(pinStep);
      StepAction chatAction=new CHATStepAction(eacData,chatStep);
      chatStep.setAction(chatAction);
      StepAction pinAction=new PINStepAction(eacData,!nativePace,slotHandle,dispatcher,pinStep,status);
      pinStep.setAction(pinAction);
    }
 else {
      StepAction errorAction=new ErrorStepAction(""String_Node_Str"");
      ErrorStep eStep=new ErrorStep(langPace.translationForKey(""String_Node_Str""),langPace.translationForKey(""String_Node_Str""));
      eStep.setAction(errorAction);
      uc.getSteps().add(eStep);
    }
    UserConsentNavigator navigator=gui.obtainNavigator(uc);
    ExecutionEngine exec=new ExecutionEngine(navigator);
    ResultStatus guiResult=exec.process();
    if (guiResult == ResultStatus.CANCEL) {
      String protocol=didAuthenticate.getAuthenticationProtocolData().getProtocol();
      cardState.removeProtocol(protocol);
      String msg=""String_Node_Str"";
      Result r=WSHelper.makeResultError(ECardConstants.Minor.SAL.CANCELLATION_BY_USER,msg);
      response.setResult(r);
      return response;
    }
    TerminalAuthentication ta=new TerminalAuthentication(dispatcher,slotHandle);
    byte[] challenge=ta.getChallenge();
    DIDAuthenticationDataType data=eacData.paceResponse.getAuthenticationProtocolData();
    AuthDataMap paceOutputMap=new AuthDataMap(data);
    byte[] efCardAccess=paceOutputMap.getContentAsBytes(PACEOutputType.EF_CARD_ACCESS);
    byte[] currentCAR=paceOutputMap.getContentAsBytes(PACEOutputType.CURRENT_CAR);
    byte[] previousCAR=paceOutputMap.getContentAsBytes(PACEOutputType.PREVIOUS_CAR);
    byte[] idpicc=paceOutputMap.getContentAsBytes(PACEOutputType.ID_PICC);
    SecurityInfos securityInfos=SecurityInfos.getInstance(efCardAccess);
    internalData.put(EACConstants.IDATA_SECURITY_INFOS,securityInfos);
    internalData.put(EACConstants.IDATA_AUTHENTICATED_AUXILIARY_DATA,aad);
    internalData.put(EACConstants.IDATA_CERTIFICATES,certChain);
    internalData.put(EACConstants.IDATA_CURRENT_CAR,currentCAR);
    internalData.put(EACConstants.IDATA_CHALLENGE,challenge);
    eac1Output.setCHAT(eacData.selectedCHAT.toByteArray());
    eac1Output.setCurrentCAR(currentCAR);
    eac1Output.setPreviousCAR(previousCAR);
    eac1Output.setEFCardAccess(efCardAccess);
    eac1Output.setIDPICC(idpicc);
    eac1Output.setChallenge(challenge);
    response.setResult(WSHelper.makeResultOK());
    response.setAuthenticationProtocolData(eac1Output.getAuthDataType());
  }
 catch (  CertificateException ex) {
    logger.error(ex.getMessage(),ex);
    String msg=ex.getMessage();
    response.setResult(WSHelper.makeResultError(ECardConstants.Minor.SAL.EAC.DOC_VALID_FAILED,msg));
  }
catch (  WSHelper.WSException e) {
    logger.error(e.getMessage(),e);
    response.setResult(e.getResult());
  }
catch (  Exception e) {
    logger.error(e.getMessage(),e);
    response.setResult(WSHelper.makeResultUnknownError(e.getMessage()));
  }
  return response;
}","@Override public DIDAuthenticateResponse perform(DIDAuthenticate request,Map<String,Object> internalData){
  DIDAuthenticate didAuthenticate=request;
  DIDAuthenticateResponse response=new DIDAuthenticateResponse();
  byte[] slotHandle=didAuthenticate.getConnectionHandle().getSlotHandle();
  try {
    EAC1InputType eac1Input=new EAC1InputType(didAuthenticate.getAuthenticationProtocolData());
    EAC1OutputType eac1Output=eac1Input.getOutputType();
    CardStateEntry cardState=(CardStateEntry)internalData.get(EACConstants.IDATA_CARD_STATE_ENTRY);
    boolean nativePace=genericPACESupport(cardState.handleCopy());
    CardVerifiableCertificateChain certChain=new CardVerifiableCertificateChain(eac1Input.getCertificates());
    byte[] rawCertificateDescription=eac1Input.getCertificateDescription();
    CertificateDescription certDescription=CertificateDescription.getInstance(rawCertificateDescription);
    final DynamicContext dynCtx=DynamicContext.getInstance(TR03112Keys.INSTANCE_KEY);
    Promise<Object> promise=dynCtx.getPromise(TR03112Keys.ESERVICE_CERTIFICATE_DESC);
    promise.deliver(certDescription);
    Result activationChecksResult=performChecks(certDescription,dynCtx);
    if (!ECardConstants.Major.OK.equals(activationChecksResult.getResultMajor())) {
      response.setResult(activationChecksResult);
      return response;
    }
    CHAT requiredCHAT=new CHAT(eac1Input.getRequiredCHAT());
    CHAT optionalCHAT=new CHAT(eac1Input.getOptionalCHAT());
    AuthenticatedAuxiliaryData aad=new AuthenticatedAuxiliaryData(eac1Input.getAuthenticatedAuxiliaryData());
    byte pinID=PasswordID.valueOf(didAuthenticate.getDIDName()).getByte();
    String passwordType=PasswordID.parse(pinID).getString();
    PACEMarkerType paceMarker=getPaceMarker(cardState,passwordType);
    CardVerifiableCertificate taCert=certChain.getTerminalCertificates().get(0);
    CardVerifiableCertificateVerifier.verify(taCert,certDescription);
    CHATVerifier.verfiy(taCert.getCHAT(),requiredCHAT);
    optionalCHAT.restrictAccessRights(taCert.getCHAT());
    EACData eacData=new EACData();
    eacData.didRequest=didAuthenticate;
    eacData.certificate=certChain.getTerminalCertificates().get(0);
    eacData.certificateDescription=certDescription;
    eacData.rawCertificateDescription=rawCertificateDescription;
    eacData.transactionInfo=eac1Input.getTransactionInfo();
    eacData.requiredCHAT=requiredCHAT;
    eacData.optionalCHAT=optionalCHAT;
    eacData.selectedCHAT=requiredCHAT;
    eacData.aad=aad;
    eacData.pinID=pinID;
    eacData.passwordType=passwordType;
    InputAPDUInfoType input=new InputAPDUInfoType();
    input.setInputAPDU(new byte[]{(byte)0x00,(byte)0x22,(byte)0xC1,(byte)0xA4,(byte)0x0F,(byte)0x80,(byte)0x0A,(byte)0x04,(byte)0x00,(byte)0x7F,(byte)0x00,(byte)0x07,(byte)0x02,(byte)0x02,(byte)0x04,(byte)0x02,(byte)0x02,(byte)0x83,(byte)0x01,(byte)0x03});
    input.getAcceptableStatusCode().add(new byte[]{(byte)0x90,(byte)0x00});
    input.getAcceptableStatusCode().add(new byte[]{(byte)0x63,(byte)0xC2});
    input.getAcceptableStatusCode().add(new byte[]{(byte)0x63,(byte)0xC1});
    input.getAcceptableStatusCode().add(new byte[]{(byte)0x63,(byte)0xC0});
    input.getAcceptableStatusCode().add(new byte[]{(byte)0x62,(byte)0x83});
    Transmit transmit=new Transmit();
    transmit.setSlotHandle(slotHandle);
    transmit.getInputAPDUInfo().add(input);
    TransmitResponse pinCheckResponse=(TransmitResponse)dispatcher.deliver(transmit);
    byte[] output=pinCheckResponse.getOutputAPDU().get(0);
    ResponseAPDU outputApdu=new ResponseAPDU(output);
    byte[] status={(byte)outputApdu.getSW1(),(byte)outputApdu.getSW2()};
    UserConsentDescription uc=new UserConsentDescription(lang.translationForKey(TITLE));
    if (!Arrays.equals(status,new byte[]{(byte)0x63,(byte)0xC0})) {
      CVCStep cvcStep=new CVCStep(eacData);
      CHATStep chatStep=new CHATStep(eacData);
      PINStep pinStep=new PINStep(eacData,!nativePace,paceMarker);
      uc.getSteps().add(cvcStep);
      uc.getSteps().add(chatStep);
      uc.getSteps().add(pinStep);
      StepAction chatAction=new CHATStepAction(eacData,chatStep);
      chatStep.setAction(chatAction);
      StepAction pinAction=new PINStepAction(eacData,!nativePace,slotHandle,dispatcher,pinStep,status);
      pinStep.setAction(pinAction);
    }
 else {
      StepAction errorAction=new ErrorStepAction(""String_Node_Str"");
      ErrorStep eStep=new ErrorStep(langPace.translationForKey(""String_Node_Str"",pin),langPace.translationForKey(""String_Node_Str"",pin,pin,puk,pin));
      eStep.setAction(errorAction);
      uc.getSteps().add(eStep);
    }
    UserConsentNavigator navigator=gui.obtainNavigator(uc);
    ExecutionEngine exec=new ExecutionEngine(navigator);
    ResultStatus guiResult=exec.process();
    if (guiResult == ResultStatus.CANCEL) {
      String protocol=didAuthenticate.getAuthenticationProtocolData().getProtocol();
      cardState.removeProtocol(protocol);
      String msg=""String_Node_Str"";
      Result r=WSHelper.makeResultError(ECardConstants.Minor.SAL.CANCELLATION_BY_USER,msg);
      response.setResult(r);
      return response;
    }
    TerminalAuthentication ta=new TerminalAuthentication(dispatcher,slotHandle);
    byte[] challenge=ta.getChallenge();
    DIDAuthenticationDataType data=eacData.paceResponse.getAuthenticationProtocolData();
    AuthDataMap paceOutputMap=new AuthDataMap(data);
    byte[] efCardAccess=paceOutputMap.getContentAsBytes(PACEOutputType.EF_CARD_ACCESS);
    byte[] currentCAR=paceOutputMap.getContentAsBytes(PACEOutputType.CURRENT_CAR);
    byte[] previousCAR=paceOutputMap.getContentAsBytes(PACEOutputType.PREVIOUS_CAR);
    byte[] idpicc=paceOutputMap.getContentAsBytes(PACEOutputType.ID_PICC);
    SecurityInfos securityInfos=SecurityInfos.getInstance(efCardAccess);
    internalData.put(EACConstants.IDATA_SECURITY_INFOS,securityInfos);
    internalData.put(EACConstants.IDATA_AUTHENTICATED_AUXILIARY_DATA,aad);
    internalData.put(EACConstants.IDATA_CERTIFICATES,certChain);
    internalData.put(EACConstants.IDATA_CURRENT_CAR,currentCAR);
    internalData.put(EACConstants.IDATA_CHALLENGE,challenge);
    eac1Output.setCHAT(eacData.selectedCHAT.toByteArray());
    eac1Output.setCurrentCAR(currentCAR);
    eac1Output.setPreviousCAR(previousCAR);
    eac1Output.setEFCardAccess(efCardAccess);
    eac1Output.setIDPICC(idpicc);
    eac1Output.setChallenge(challenge);
    response.setResult(WSHelper.makeResultOK());
    response.setAuthenticationProtocolData(eac1Output.getAuthDataType());
  }
 catch (  CertificateException ex) {
    logger.error(ex.getMessage(),ex);
    String msg=ex.getMessage();
    response.setResult(WSHelper.makeResultError(ECardConstants.Minor.SAL.EAC.DOC_VALID_FAILED,msg));
  }
catch (  WSHelper.WSException e) {
    logger.error(e.getMessage(),e);
    response.setResult(e.getResult());
  }
catch (  Exception e) {
    logger.error(e.getMessage(),e);
    response.setResult(WSHelper.makeResultUnknownError(e.getMessage()));
  }
  return response;
}"
48101,"public PINStepAction(EACData eacData,boolean capturePin,byte[] slotHandle,Dispatcher dispatcher,PINStep step,byte[] status){
  super(step);
  this.eacData=eacData;
  this.capturePin=capturePin;
  this.slotHandle=slotHandle;
  this.dispatcher=dispatcher;
  this.step=step;
  if (Arrays.equals(status,BLOCKED)) {
    retryCounter=3;
  }
 else   if (Arrays.equals(status,RC3)) {
    retryCounter=0;
  }
 else   if (Arrays.equals(status,RC2)) {
    retryCounter=1;
    step.updateAttemptsDisplay(2);
  }
 else   if (Arrays.equals(status,RC1)) {
    retryCounter=2;
    step.updateAttemptsDisplay(1);
    if (capturePin) {
      step.addCANEntry();
    }
 else {
      step.addNativeCANNotice();
    }
  }
 else   if (Arrays.equals(status,DEAKTIVATED)) {
    retryCounter=-1;
  }
}","public PINStepAction(EACData eacData,boolean capturePin,byte[] slotHandle,Dispatcher dispatcher,PINStep step,byte[] status){
  super(step);
  this.eacData=eacData;
  this.capturePin=capturePin;
  this.slotHandle=slotHandle;
  this.dispatcher=dispatcher;
  this.step=step;
  if (Arrays.equals(status,RC3)) {
    retryCounter=0;
  }
 else   if (Arrays.equals(status,RC2)) {
    retryCounter=1;
    step.updateAttemptsDisplay(2);
  }
 else   if (Arrays.equals(status,RC1)) {
    retryCounter=2;
    step.updateAttemptsDisplay(1);
    if (capturePin) {
      step.addCANEntry();
    }
 else {
      step.addNativeCANNotice();
    }
  }
 else   if (Arrays.equals(status,DEAKTIVATED)) {
    retryCounter=-1;
  }
  pin=lang.translationForKey(""String_Node_Str"");
  puk=lang.translationForKey(""String_Node_Str"");
}"
48102,"@Override public StepActionResult perform(Map<String,ExecutionResults> oldResults,StepResult result){
  if (result.isBack()) {
    return new StepActionResult(StepActionResultStatus.BACK);
  }
  if (retryCounter == 2) {
    try {
      EstablishChannelResponse response=performPACEWithCAN(oldResults);
      if (response == null) {
        logger.debug(""String_Node_Str"");
        return new StepActionResult(StepActionResultStatus.REPEAT);
      }
      WSHelper.checkResult(response);
    }
 catch (    DispatcherException|InvocationTargetException ex) {
      logger.error(""String_Node_Str"",ex);
    }
catch (    WSException ex) {
      logger.error(""String_Node_Str"",ex);
      return new StepActionResult(StepActionResultStatus.REPEAT);
    }
  }
  if (retryCounter < 3) {
    try {
      EstablishChannelResponse establishChannelResponse=performPACEWithPIN(oldResults);
      WSHelper.checkResult(establishChannelResponse);
      eacData.paceResponse=establishChannelResponse;
      return new StepActionResult(StepActionResultStatus.NEXT);
    }
 catch (    WSException ex) {
      if (ex.getResultMinor().equals(ECardConstants.Minor.IFD.CANCELLATION_BY_USER)) {
        logger.error(""String_Node_Str"",ex);
        return new StepActionResult(StepActionResultStatus.CANCEL);
      }
      retryCounter++;
      step.updateAttemptsDisplay(3 - retryCounter);
      if (retryCounter >= 3) {
        logger.warn(""String_Node_Str"");
        return new StepActionResult(StepActionResultStatus.REPEAT,new ErrorStep(lang.translationForKey(""String_Node_Str"",""String_Node_Str""),lang.translationForKey(""String_Node_Str"",""String_Node_Str"")));
      }
      if (retryCounter == 2 && capturePin) {
        step.addCANEntry();
      }
 else       if (retryCounter == 2) {
        step.addNativeCANNotice();
      }
      logger.info(""String_Node_Str"",retryCounter);
      return new StepActionResult(StepActionResultStatus.REPEAT);
    }
catch (    DispatcherException|InvocationTargetException ex) {
      logger.error(""String_Node_Str"",ex);
      return new StepActionResult(StepActionResultStatus.CANCEL);
    }
  }
 else {
    logger.error(""String_Node_Str"");
    return new StepActionResult(StepActionResultStatus.NEXT,new ErrorStep(lang.translationForKey(""String_Node_Str""),lang.translationForKey(""String_Node_Str"")));
  }
}","@Override public StepActionResult perform(Map<String,ExecutionResults> oldResults,StepResult result){
  if (result.isBack()) {
    return new StepActionResult(StepActionResultStatus.BACK);
  }
  if (retryCounter == 2) {
    try {
      EstablishChannelResponse response=performPACEWithCAN(oldResults);
      if (response == null) {
        logger.debug(""String_Node_Str"");
        return new StepActionResult(StepActionResultStatus.REPEAT);
      }
      WSHelper.checkResult(response);
    }
 catch (    DispatcherException|InvocationTargetException ex) {
      logger.error(""String_Node_Str"",ex);
    }
catch (    WSException ex) {
      logger.error(""String_Node_Str"",ex);
      return new StepActionResult(StepActionResultStatus.REPEAT);
    }
  }
  try {
    EstablishChannelResponse establishChannelResponse=performPACEWithPIN(oldResults);
    WSHelper.checkResult(establishChannelResponse);
    eacData.paceResponse=establishChannelResponse;
    return new StepActionResult(StepActionResultStatus.NEXT);
  }
 catch (  WSException ex) {
    if (ex.getResultMinor().equals(ECardConstants.Minor.IFD.CANCELLATION_BY_USER)) {
      logger.error(""String_Node_Str"",ex);
      return new StepActionResult(StepActionResultStatus.CANCEL);
    }
    retryCounter++;
    step.updateAttemptsDisplay(3 - retryCounter);
    if (retryCounter >= 3) {
      logger.warn(""String_Node_Str"");
      return new StepActionResult(StepActionResultStatus.REPEAT,new ErrorStep(lang.translationForKey(""String_Node_Str"",pin),lang.translationForKey(""String_Node_Str"",pin,pin,puk,pin)));
    }
    if (retryCounter == 2 && capturePin) {
      step.addCANEntry();
    }
 else     if (retryCounter == 2) {
      step.addNativeCANNotice();
    }
    logger.info(""String_Node_Str"",retryCounter);
    return new StepActionResult(StepActionResultStatus.REPEAT);
  }
catch (  DispatcherException|InvocationTargetException ex) {
    logger.error(""String_Node_Str"",ex);
    return new StepActionResult(StepActionResultStatus.CANCEL);
  }
}"
48103,"private EstablishChannelResponse performPACEWithPIN(Map<String,ExecutionResults> oldResults) throws DispatcherException, InvocationTargetException {
  DIDAuthenticationDataType protoData=eacData.didRequest.getAuthenticationProtocolData();
  AuthDataMap paceAuthMap;
  try {
    paceAuthMap=new AuthDataMap(protoData);
  }
 catch (  ParserConfigurationException ex) {
    logger.error(""String_Node_Str"",ex);
    return null;
  }
  AuthDataResponse paceInputMap=paceAuthMap.createResponse(protoData);
  if (capturePin) {
    ExecutionResults executionResults=oldResults.get(getStepID());
    PasswordField p=(PasswordField)executionResults.getResult(PINStep.PIN_FIELD);
    String pin=p.getValue();
    if (pin.isEmpty()) {
      return null;
    }
 else {
      paceInputMap.addElement(PACEInputType.PIN,pin);
    }
  }
  paceInputMap.addElement(PACEInputType.PIN_ID,PasswordID.parse(eacData.pinID).getByteAsString());
  paceInputMap.addElement(PACEInputType.CHAT,eacData.selectedCHAT.toString());
  String certDesc=ByteUtils.toHexString(eacData.rawCertificateDescription);
  paceInputMap.addElement(PACEInputType.CERTIFICATE_DESCRIPTION,certDesc);
  EstablishChannel eChannel=createEstablishChannelStructure(paceInputMap);
  return (EstablishChannelResponse)dispatcher.deliver(eChannel);
}","private EstablishChannelResponse performPACEWithPIN(Map<String,ExecutionResults> oldResults) throws DispatcherException, InvocationTargetException {
  DIDAuthenticationDataType protoData=eacData.didRequest.getAuthenticationProtocolData();
  AuthDataMap paceAuthMap;
  try {
    paceAuthMap=new AuthDataMap(protoData);
  }
 catch (  ParserConfigurationException ex) {
    logger.error(""String_Node_Str"",ex);
    return null;
  }
  AuthDataResponse paceInputMap=paceAuthMap.createResponse(protoData);
  if (capturePin) {
    ExecutionResults executionResults=oldResults.get(getStepID());
    PasswordField p=(PasswordField)executionResults.getResult(PINStep.PIN_FIELD);
    String pinIn=p.getValue();
    if (pinIn.isEmpty()) {
      return null;
    }
 else {
      paceInputMap.addElement(PACEInputType.PIN,pinIn);
    }
  }
  paceInputMap.addElement(PACEInputType.PIN_ID,PasswordID.parse(eacData.pinID).getByteAsString());
  paceInputMap.addElement(PACEInputType.CHAT,eacData.selectedCHAT.toString());
  String certDesc=ByteUtils.toHexString(eacData.rawCertificateDescription);
  paceInputMap.addElement(PACEInputType.CERTIFICATE_DESCRIPTION,certDesc);
  EstablishChannel eChannel=createEstablishChannelStructure(paceInputMap);
  return (EstablishChannelResponse)dispatcher.deliver(eChannel);
}"
48104,"/** 
 * Verifies the ServerAddress element of the TCToken.
 * @throws TCTokenException
 */
public void verifyServerAddress() throws TCTokenException {
  String value=token.getServerAddress();
  assertRequired(""String_Node_Str"",value);
  assertURL(""String_Node_Str"",value);
}","/** 
 * Verifies the ServerAddress element of the TCToken.
 * @throws TCTokenException
 */
public void verifyServerAddress() throws TCTokenException {
  String value=token.getServerAddress();
  assertRequired(""String_Node_Str"",value);
  assertHttpsURL(""String_Node_Str"",value);
}"
48105,"/** 
 * Encrypt the APDU.
 * @param apdu APDU
 * @param secureMessagingSSC Secure Messaging Send Sequence Counter
 * @return Encrypted APDU
 * @throws Exception
 */
private byte[] encrypt(byte[] apdu,byte[] secureMessagingSSC) throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  CardCommandAPDU cAPDU=new CardCommandAPDU(apdu);
  if (cAPDU.isSecureMessaging()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  byte[] data=cAPDU.getData();
  byte[] header=cAPDU.getHeader();
  int lc=cAPDU.getLC();
  int le=cAPDU.getLE();
  if (data != null) {
    data=pad(data,16);
    Cipher c=getCipher(secureMessagingSSC,Cipher.ENCRYPT_MODE);
    byte[] dataEncrypted=c.doFinal(data);
    dataEncrypted=ByteUtils.concatenate((byte)0x01,dataEncrypted);
    TLV dataObject=new TLV();
    dataObject.setTagNumWithClass((byte)0x87);
    dataObject.setValue(dataEncrypted);
    baos.write(dataObject.toBER());
  }
  if (le >= 0) {
    TLV leObject=new TLV();
    leObject.setTagNumWithClass((byte)0x97);
    if (le == 0x100) {
      leObject.setValue(NULL);
    }
 else     if (le > 0x100) {
      leObject.setValue(new byte[]{(byte)((le >> 8) & 0xFF),(byte)(le & 0xFF)});
    }
 else {
      leObject.setValue(new byte[]{(byte)le});
    }
    baos.write(leObject.toBER());
  }
  header[0]|=0x0C;
  byte[] mac=new byte[16];
  CMac cmac=getCMAC(secureMessagingSSC);
  byte[] paddedHeader=pad(header,16);
  cmac.update(paddedHeader,0,paddedHeader.length);
  if (baos.size() > 0) {
    byte[] paddedData=pad(baos.toByteArray(),16);
    cmac.update(paddedData,0,paddedData.length);
    lc=baos.size();
  }
  cmac.doFinal(mac,0);
  mac=ByteUtils.copy(mac,0,8);
  ByteArrayOutputStream out=new ByteArrayOutputStream();
  out.write(header);
  lc+=10;
  if ((lc > 0xFF) || (le > 0x100)) {
    out.write(NULL);
    out.write((lc >> 8) & 0xFF);
    out.write(lc & 0xFF);
  }
 else {
    out.write(lc & 0xFF);
  }
  if (baos.size() > 0) {
    out.write(baos.toByteArray());
  }
  out.write(new byte[]{(byte)0x8E,(byte)0x08});
  out.write(mac);
  out.write(NULL);
  if ((lc > 0xFF) || (le > 0x100)) {
    out.write(NULL);
  }
  return out.toByteArray();
}","/** 
 * Encrypt the APDU.
 * @param apdu APDU
 * @param secureMessagingSSC Secure Messaging Send Sequence Counter
 * @return Encrypted APDU
 * @throws Exception
 */
private byte[] encrypt(byte[] apdu,byte[] secureMessagingSSC) throws Exception {
  ByteArrayOutputStream baos=new ByteArrayOutputStream();
  CardCommandAPDU cAPDU=new CardCommandAPDU(apdu);
  if (cAPDU.isSecureMessaging()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  byte[] data=cAPDU.getData();
  byte[] header=cAPDU.getHeader();
  int lc=cAPDU.getLC();
  int le=cAPDU.getLE();
  if (data != null) {
    data=pad(data,16);
    Cipher c=getCipher(secureMessagingSSC,Cipher.ENCRYPT_MODE);
    byte[] dataEncrypted=c.doFinal(data);
    dataEncrypted=ByteUtils.concatenate((byte)0x01,dataEncrypted);
    TLV dataObject=new TLV();
    dataObject.setTagNumWithClass((byte)0x87);
    dataObject.setValue(dataEncrypted);
    baos.write(dataObject.toBER());
  }
  if (le >= 0) {
    TLV leObject=new TLV();
    leObject.setTagNumWithClass((byte)0x97);
    if (le == 0x100) {
      leObject.setValue(NULL);
    }
 else     if (le > 0x100) {
      leObject.setValue(new byte[]{(byte)((le >> 8) & 0xFF),(byte)(le & 0xFF)});
    }
 else {
      leObject.setValue(new byte[]{(byte)le});
    }
    baos.write(leObject.toBER());
  }
  header[0]|=0x0C;
  byte[] mac=new byte[16];
  CMac cmac=getCMAC(secureMessagingSSC);
  byte[] paddedHeader=pad(header,16);
  cmac.update(paddedHeader,0,paddedHeader.length);
  if (baos.size() > 0) {
    byte[] paddedData=pad(baos.toByteArray(),16);
    cmac.update(paddedData,0,paddedData.length);
  }
  cmac.doFinal(mac,0);
  mac=ByteUtils.copy(mac,0,8);
  TLV macStructure=new TLV();
  macStructure.setTagNumWithClass((byte)0x8E);
  macStructure.setValue(mac);
  byte[] secureData=ByteUtils.concatenate(baos.toByteArray(),macStructure.toBER());
  CardCommandAPDU secureCommand=new CardCommandAPDU(header[0],header[1],header[2],header[3],secureData);
  if ((lc > 0xFF) || (le > 0x100)) {
    secureCommand.setLE(65536);
  }
 else {
    secureCommand.setLE(256);
  }
  return secureCommand.toByteArray();
}"
48106,"/** 
 * Sends start PAOS and answers all successor messages to the server associated with this instance. Messages are exchanged until the server replies with a   {@code StartPAOSResponse} message.
 * @param message The StartPAOS message which is sent in the first message.
 * @return The {@code StartPAOSResponse} message from the server.
 * @throws DispatcherException In case there errors with the message conversion or the dispatcher.
 * @throws PAOSException In case there were errors in the transport layer.
 */
public StartPAOSResponse sendStartPAOS(StartPAOS message) throws DispatcherException, PAOSException {
  Object msg=message;
  try {
    boolean firstLoop=true;
    while (true) {
      if (!firstLoop && tlsHandler.isSameChannel()) {
        throw new PAOSException(""String_Node_Str"");
      }
      firstLoop=false;
      StreamHttpClientConnection conn=openHttpStream();
      HttpContext ctx=new BasicHttpContext();
      HttpRequestExecutor httpexecutor=new HttpRequestExecutor();
      DefaultConnectionReuseStrategy reuse=new DefaultConnectionReuseStrategy();
      boolean isReusable;
      do {
        String resource=tlsHandler.getResource();
        BasicHttpEntityEnclosingRequest req=new BasicHttpEntityEnclosingRequest(""String_Node_Str"",resource);
        req.setParams(conn.getParams());
        HttpRequestHelper.setDefaultHeader(req,tlsHandler.getServerAddress());
        req.setHeader(HEADER_KEY_PAOS,HEADER_VALUE_PAOS);
        req.setHeader(""String_Node_Str"",""String_Node_Str"");
        ContentType reqContentType=ContentType.create(""String_Node_Str"",""String_Node_Str"");
        HttpUtils.dumpHttpRequest(logger,""String_Node_Str"",req);
        String reqMsgStr=createPAOSResponse(msg);
        StringEntity reqMsg=new StringEntity(reqMsgStr,reqContentType);
        req.setEntity(reqMsg);
        req.setHeader(reqMsg.getContentType());
        req.setHeader(""String_Node_Str"",Long.toString(reqMsg.getContentLength()));
        HttpResponse response=httpexecutor.execute(req,conn,ctx);
        int statusCode=response.getStatusLine().getStatusCode();
        conn.receiveResponseEntity(response);
        HttpEntity entity=response.getEntity();
        byte[] entityData=FileUtils.toByteArray(entity.getContent());
        HttpUtils.dumpHttpResponse(logger,response,entityData);
        checkHTTPStatusCode(msg,statusCode);
        Object requestObj=processPAOSRequest(new ByteArrayInputStream(entityData));
        if (requestObj instanceof StartPAOSResponse) {
          StartPAOSResponse startPAOSResponse=(StartPAOSResponse)requestObj;
          WSHelper.checkResult(startPAOSResponse);
          return startPAOSResponse;
        }
        msg=dispatcher.deliver(requestObj);
        isReusable=reuse.keepAlive(response,ctx);
      }
 while (isReusable);
    }
  }
 catch (  HttpException ex) {
    throw new PAOSException(""String_Node_Str"",ex);
  }
catch (  IOException ex) {
    throw new PAOSException(ex);
  }
catch (  SOAPException ex) {
    throw new PAOSException(""String_Node_Str"",ex);
  }
catch (  URISyntaxException ex) {
    throw new PAOSException(""String_Node_Str"",ex);
  }
catch (  MarshallingTypeException ex) {
    throw new DispatcherException(""String_Node_Str"",ex);
  }
catch (  InvocationTargetException ex) {
    throw new DispatcherException(""String_Node_Str"",ex);
  }
catch (  TransformerException ex) {
    throw new DispatcherException(ex);
  }
catch (  WSException ex) {
    throw new PAOSException(ex);
  }
}","/** 
 * Sends start PAOS and answers all successor messages to the server associated with this instance. Messages are exchanged until the server replies with a   {@code StartPAOSResponse} message.
 * @param message The StartPAOS message which is sent in the first message.
 * @return The {@code StartPAOSResponse} message from the server.
 * @throws DispatcherException In case there errors with the message conversion or the dispatcher.
 * @throws PAOSException In case there were errors in the transport layer.
 */
public StartPAOSResponse sendStartPAOS(StartPAOS message) throws DispatcherException, PAOSException {
  Object msg=message;
  try {
    boolean firstLoop=true;
    while (true) {
      if (!firstLoop && tlsHandler.isSameChannel()) {
        throw new PAOSException(""String_Node_Str"");
      }
      firstLoop=false;
      StreamHttpClientConnection conn=openHttpStream();
      HttpContext ctx=new BasicHttpContext();
      HttpRequestExecutor httpexecutor=new HttpRequestExecutor();
      DefaultConnectionReuseStrategy reuse=new DefaultConnectionReuseStrategy();
      boolean isReusable;
      do {
        String resource=tlsHandler.getResource();
        BasicHttpEntityEnclosingRequest req=new BasicHttpEntityEnclosingRequest(""String_Node_Str"",resource);
        req.setParams(conn.getParams());
        HttpRequestHelper.setDefaultHeader(req,tlsHandler.getServerAddress());
        req.setHeader(HEADER_KEY_PAOS,headerValuePaos);
        req.setHeader(""String_Node_Str"",""String_Node_Str"");
        ContentType reqContentType=ContentType.create(""String_Node_Str"",""String_Node_Str"");
        HttpUtils.dumpHttpRequest(logger,""String_Node_Str"",req);
        String reqMsgStr=createPAOSResponse(msg);
        StringEntity reqMsg=new StringEntity(reqMsgStr,reqContentType);
        req.setEntity(reqMsg);
        req.setHeader(reqMsg.getContentType());
        req.setHeader(""String_Node_Str"",Long.toString(reqMsg.getContentLength()));
        HttpResponse response=httpexecutor.execute(req,conn,ctx);
        int statusCode=response.getStatusLine().getStatusCode();
        conn.receiveResponseEntity(response);
        HttpEntity entity=response.getEntity();
        byte[] entityData=FileUtils.toByteArray(entity.getContent());
        HttpUtils.dumpHttpResponse(logger,response,entityData);
        checkHTTPStatusCode(msg,statusCode);
        Object requestObj=processPAOSRequest(new ByteArrayInputStream(entityData));
        if (requestObj instanceof StartPAOSResponse) {
          StartPAOSResponse startPAOSResponse=(StartPAOSResponse)requestObj;
          WSHelper.checkResult(startPAOSResponse);
          return startPAOSResponse;
        }
        msg=dispatcher.deliver(requestObj);
        isReusable=reuse.keepAlive(response,ctx);
      }
 while (isReusable);
    }
  }
 catch (  HttpException ex) {
    throw new PAOSException(""String_Node_Str"",ex);
  }
catch (  IOException ex) {
    throw new PAOSException(ex);
  }
catch (  SOAPException ex) {
    throw new PAOSException(""String_Node_Str"",ex);
  }
catch (  URISyntaxException ex) {
    throw new PAOSException(""String_Node_Str"",ex);
  }
catch (  MarshallingTypeException ex) {
    throw new DispatcherException(""String_Node_Str"",ex);
  }
catch (  InvocationTargetException ex) {
    throw new DispatcherException(""String_Node_Str"",ex);
  }
catch (  TransformerException ex) {
    throw new DispatcherException(ex);
  }
catch (  WSException ex) {
    throw new PAOSException(ex);
  }
}"
48107,"/** 
 * Creates a PAOS instance and configures it for a given endpoint. If tlsClient is not null the connection must be HTTPs, else HTTP.
 * @param dispatcher The dispatcher instance capable of dispatching the received messages.
 * @param tlsHandler The TlsClient containing the configuration of the yet to be established TLS channel, or{@code null} if TLS should not be used.
 * @throws PAOSException In case the PAOS module could not be initialized.
 */
public PAOS(@Nonnull Dispatcher dispatcher,@Nonnull TlsConnectionHandler tlsHandler) throws PAOSException {
  this.dispatcher=dispatcher;
  this.tlsHandler=tlsHandler;
  try {
    this.idGenerator=new MessageIdGenerator();
    this.m=WSMarshallerFactory.createInstance();
  }
 catch (  WSMarshallerException e) {
    logger.error(e.getMessage(),e);
    throw new PAOSException(e);
  }
}","/** 
 * Creates a PAOS instance and configures it for a given endpoint. If tlsClient is not null the connection must be HTTPs, else HTTP.
 * @param dispatcher The dispatcher instance capable of dispatching the received messages.
 * @param tlsHandler The TlsClient containing the configuration of the yet to be established TLS channel, or{@code null} if TLS should not be used.
 * @throws PAOSException In case the PAOS module could not be initialized.
 */
public PAOS(@Nonnull Dispatcher dispatcher,@Nonnull TlsConnectionHandler tlsHandler) throws PAOSException {
  this.dispatcher=dispatcher.getFilter();
  this.tlsHandler=tlsHandler;
  serviceString=buildServiceString();
  headerValuePaos=""String_Node_Str"" + ECardConstants.PAOS_VERSION_20 + ""String_Node_Str""+ serviceString;
  try {
    this.idGenerator=new MessageIdGenerator();
    this.m=WSMarshallerFactory.createInstance();
  }
 catch (  WSMarshallerException e) {
    logger.error(e.getMessage(),e);
    throw new PAOSException(e);
  }
}"
48108,"/** 
 * Check the status code returned from the server.  If the status code indicates an error, a PAOSException will be thrown.
 * @param msg The last message we sent to the server
 * @param statusCode The status code we received from the server
 * @throws PAOSException If the server returned a HTTP error code
 */
private void checkHTTPStatusCode(Object msg,int statusCode) throws PAOSException {
  if (statusCode < 200 || statusCode > 299) {
    if (msg instanceof ResponseType) {
      ResponseType resp=(ResponseType)msg;
      try {
        WSHelper.checkResult(resp);
      }
 catch (      WSException ex) {
        throw new PAOSException(""String_Node_Str"" + statusCode,ex);
      }
    }
    throw new PAOSException(""String_Node_Str"" + statusCode);
  }
}","/** 
 * Check the status code returned from the server. If the status code indicates an error, a PAOSException will be thrown.
 * @param msg The last message we sent to the server
 * @param statusCode The status code we received from the server
 * @throws PAOSException If the server returned a HTTP error code
 */
private void checkHTTPStatusCode(Object msg,int statusCode) throws PAOSException {
  if (statusCode < 200 || statusCode > 299) {
    if (msg instanceof ResponseType) {
      ResponseType resp=(ResponseType)msg;
      try {
        WSHelper.checkResult(resp);
      }
 catch (      WSException ex) {
        throw new PAOSException(""String_Node_Str"" + statusCode,ex);
      }
    }
    throw new PAOSException(""String_Node_Str"" + statusCode);
  }
}"
48109,"@XmlElement(name=""String_Node_Str"") public String getVersion(){
  return version;
}","public String getVersion(){
  return version;
}"
48110,"public void setLogo(String logo){
  this.logoFile=logo;
  logger.debug(""String_Node_Str"" + logoFile);
  if (logoFile != null && !logoFile.isEmpty()) {
    try {
      InputStream logoStream=FileUtils.resolveResourceAsStream(AddonSpecification.class,logoFile);
      this.logoBytes=FileUtils.toByteArray(logoStream);
    }
 catch (    FileNotFoundException e) {
      logger.error(""String_Node_Str"",e);
    }
catch (    IOException e) {
      logger.error(""String_Node_Str"",e);
    }
catch (    NullPointerException e) {
      logger.error(""String_Node_Str"",e);
    }
  }
}","public void setLogo(String logo){
  this.logo=logo;
  logger.debug(""String_Node_Str"" + logo);
}"
48111,"@XmlElement(name=""String_Node_Str"") public String getLogo(){
  return logoFile;
}","public String getLogo(){
  return logo;
}"
48112,"@XmlElement(name=""String_Node_Str"") public Configuration getConfigDescription(){
  return configDescription;
}","public Configuration getConfigDescription(){
  return configDescription;
}"
48113,"public AppPluginSpecification searchByResourceName(String resourceName){
  for (  AppPluginSpecification desc : appPluginActions) {
    if (resourceName.equals(desc.getResourceName())) {
      return desc;
    }
  }
  return null;
}","public AppPluginSpecification searchByResourceName(String resourceName){
  for (  AppPluginSpecification desc : bindingActions) {
    if (resourceName.equals(desc.getResourceName())) {
      return desc;
    }
  }
  return null;
}"
48114,"@XmlElement(name=""String_Node_Str"") public String getId(){
  return id;
}","public String getId(){
  return id;
}"
48115,"@XmlElementWrapper(name=""String_Node_Str"") @XmlElement(name=""String_Node_Str"") public ArrayList<AppExtensionSpecification> getApplicationActions(){
  return appExtensionActions;
}","public ArrayList<AppExtensionSpecification> getApplicationActions(){
  return applicationActions;
}"
48116,"@XmlElementWrapper(name=""String_Node_Str"") @XmlElement(name=""String_Node_Str"") public ArrayList<AppPluginSpecification> getBindingActions(){
  return appPluginActions;
}","public ArrayList<AppPluginSpecification> getBindingActions(){
  return bindingActions;
}"
48117,"public void setConfigDescription(Configuration configDescription){
  this.configDescription=configDescription;
}","public void setConfigDescription(Configuration configDescriptionNew){
  this.configDescription=configDescription;
}"
48118,"public AppExtensionSpecification searchByActionId(String id){
  for (  AppExtensionSpecification desc : appExtensionActions) {
    if (desc.getId().equals(id)) {
      return desc;
    }
  }
  return null;
}","public AppExtensionSpecification searchByActionId(String id){
  for (  AppExtensionSpecification desc : applicationActions) {
    if (desc.getId().equals(id)) {
      return desc;
    }
  }
  return null;
}"
48119,"@XmlElementWrapper(name=""String_Node_Str"") @XmlElement(name=""String_Node_Str"") public ArrayList<ProtocolPluginSpecification> getSalActions(){
  return salActions;
}","public ArrayList<ProtocolPluginSpecification> getSalActions(){
  return salActions;
}"
48120,"@XmlElement(name=""String_Node_Str"") public String getLicense(){
  return license;
}","public String getLicense(){
  return license;
}"
48121,"@XmlElementWrapper(name=""String_Node_Str"") @XmlElement(name=""String_Node_Str"") public ArrayList<ProtocolPluginSpecification> getIfdActions(){
  return ifdActions;
}","public ArrayList<ProtocolPluginSpecification> getIfdActions(){
  return ifdActions;
}"
48122,"public byte[] getLogoBytes(){
  return logoBytes;
}","/** 
 * Get a byte array containing the logo. <br /> Note: This method creates always a new input stream and does not store the byte array internally.
 * @return A byte array containing the logo bytes or null if no logo is present or an error occurred.
 */
public byte[] getLogoBytes(){
  if (logo != null && !logo.isEmpty()) {
    try {
      InputStream logoStream=FileUtils.resolveResourceAsStream(AddonSpecification.class,logo);
      return FileUtils.toByteArray(logoStream);
    }
 catch (    FileNotFoundException e) {
      logger.error(""String_Node_Str"",e);
      return null;
    }
catch (    IOException|NullPointerException e) {
      logger.error(""String_Node_Str"",e);
      return null;
    }
  }
  return null;
}"
48123,"@XmlElement(name=""String_Node_Str"") public Configuration getConfigDescription(){
  return configDescription;
}","public Configuration getConfigDescription(){
  return configDescription;
}"
48124,"@XmlElement(name=""String_Node_Str"",required=false,defaultValue=""String_Node_Str"") public Boolean isLoadOnStartup(){
  if (loadOnStartup == null) {
    return false;
  }
  return loadOnStartup;
}","public Boolean isLoadOnStartup(){
  if (loadOnStartup == null) {
    return false;
  }
  return loadOnStartup;
}"
48125,"@XmlElement(name=""String_Node_Str"") public String getId(){
  return id;
}","public String getId(){
  return id;
}"
48126,"@XmlElement(name=""String_Node_Str"") public String getClassName(){
  return className;
}","public String getClassName(){
  return className;
}"
48127,"@XmlElement(name=""String_Node_Str"") public List<LocalizedString> getLocalizedName(){
  return localizedName;
}","public List<LocalizedString> getLocalizedName(){
  return localizedName;
}"
48128,"@XmlElement(name=""String_Node_Str"") public Configuration getConfigDescription(){
  return configDescription;
}","public Configuration getConfigDescription(){
  return configDescription;
}"
48129,"@XmlElement(name=""String_Node_Str"",required=false,defaultValue=""String_Node_Str"") public Boolean isLoadOnStartup(){
  if (loadOnStartup == null) {
    return false;
  }
  return loadOnStartup;
}","public Boolean isLoadOnStartup(){
  if (loadOnStartup == null) {
    return false;
  }
  return loadOnStartup;
}"
48130,"@XmlElement(name=""String_Node_Str"") public String getResourceName(){
  return resourceName;
}","public String getResourceName(){
  return resourceName;
}"
48131,"@XmlElement(name=""String_Node_Str"") public String getClassName(){
  return className;
}","public String getClassName(){
  return className;
}"
48132,"@XmlElement(name=""String_Node_Str"") public List<LocalizedString> getLocalizedDescription(){
  return localizedDescription;
}","public List<LocalizedString> getLocalizedDescription(){
  return localizedDescription;
}"
48133,"/** 
 * Check if the two given URLs comply the Same-Origin-Policy.
 * @param url1 the first URL
 * @param url2 the second URL
 * @return {@code true} if the Same-Origin-Policy has been complied with, {@code false} otherwise
 */
public static boolean checkSameOriginPolicy(URL url1,URL url2){
  logger.debug(""String_Node_Str"",url1,url2);
  String endpointProtocol=url1.getProtocol();
  String subjectProtocol=url2.getProtocol();
  if (!endpointProtocol.equals(subjectProtocol)) {
    logger.error(""String_Node_Str"");
    return false;
  }
  String endpointHost=url1.getHost();
  String subjectHost=url2.getHost();
  if (!endpointHost.equals(subjectHost)) {
    logger.error(""String_Node_Str"");
    return false;
  }
  int endpointPort=url1.getPort();
  if (endpointPort == -1) {
    endpointPort=url1.getDefaultPort();
  }
  int subjectPort=url2.getPort();
  if (subjectPort == -1) {
    subjectPort=url2.getDefaultPort();
  }
  if (!(endpointPort == subjectPort)) {
    logger.error(""String_Node_Str"");
    return false;
  }
  return true;
}","/** 
 * Check if the two given URLs comply the Same-Origin-Policy.
 * @param url1 the first URL
 * @param url2 the second URL
 * @return {@code true} if the Same-Origin-Policy has been complied with, {@code false} otherwise
 */
public static boolean checkSameOriginPolicy(URL url1,URL url2){
  logger.debug(""String_Node_Str"",url1,url2);
  String endpointProtocol=url1.getProtocol();
  String subjectProtocol=url2.getProtocol();
  if (!endpointProtocol.equalsIgnoreCase(subjectProtocol)) {
    logger.error(""String_Node_Str"");
    return false;
  }
  String endpointHost=url1.getHost();
  String subjectHost=url2.getHost();
  if (!endpointHost.equalsIgnoreCase(subjectHost)) {
    logger.error(""String_Node_Str"");
    return false;
  }
  int endpointPort=url1.getPort();
  if (endpointPort == -1) {
    endpointPort=url1.getDefaultPort();
  }
  int subjectPort=url2.getPort();
  if (subjectPort == -1) {
    subjectPort=url2.getDefaultPort();
  }
  if (!(endpointPort == subjectPort)) {
    logger.error(""String_Node_Str"");
    return false;
  }
  return true;
}"
48134,"/** 
 * This method performs the signature creation according to BSI TR-03112 part 7.
 * @param cryptoMarker The {@link CryptoMarkerType} containing the SignatureCreationInfo for creating the signature.
 * @param keyReference A byte array containing the reference of the key to use.
 * @param algorithmIdentifier A byte array containing the identifier of the signing algorithm.
 * @param message The message to sign.
 * @param slotHandle The slotHandle identifying the card.
 * @param hashRef The variable contains the reference for the hash algorithm which have to be used.
 * @param hashInfo A HashGenerationInfo object which indicates how the hash computation is to perform.
 * @return A {@link SignResponse} object containing the signature of the <b>message</b>.
 * @throws TLVException Thrown if the TLV creation for the key identifier or algorithm identifier failed.
 * @throws IncorrectParameterException Thrown if the SignatureGenerationInfo does not contain PSO_CDS or INT_AUTHafter an MSE_KEY command.
 * @throws APDUException Thrown if one of the command to create the signature failed.
 * @throws org.openecard.common.WSHelper.WSException Thrown if the checkResults method of WSHelper failed.
 */
private SignResponse performSignature(CryptoMarkerType cryptoMarker,byte[] keyReference,byte[] algorithmIdentifier,byte[] message,byte[] slotHandle,byte[] hashRef,HashGenerationInfoType hashInfo) throws TLVException, IncorrectParameterException, APDUException, WSHelper.WSException {
  SignResponse response=WSHelper.makeResponse(SignResponse.class,WSHelper.makeResultOK());
  TLV tagAlgorithmIdentifier=new TLV();
  tagAlgorithmIdentifier.setTagNumWithClass(CARD_ALG_REF);
  tagAlgorithmIdentifier.setValue(algorithmIdentifier);
  TLV tagKeyReference=new TLV();
  tagKeyReference.setTagNumWithClass(KEY_REFERENCE_PRIVATE_KEY);
  tagKeyReference.setValue(keyReference);
  CardCommandAPDU cmdAPDU=null;
  CardResponseAPDU responseAPDU=null;
  String[] signatureGenerationInfo=cryptoMarker.getSignatureGenerationInfo();
  for (  String command : signatureGenerationInfo) {
    HashSet<String> signGenInfo=new HashSet<String>(java.util.Arrays.asList(signatureGenerationInfo));
    if (command.equals(""String_Node_Str"")) {
      byte[] mseData=tagKeyReference.toBER();
      if (signGenInfo.contains(""String_Node_Str"")) {
        cmdAPDU=new ManageSecurityEnvironment(SET_COMPUTATION,ManageSecurityEnvironment.DST,mseData);
      }
 else       if (signGenInfo.contains(""String_Node_Str"") && !signGenInfo.contains(""String_Node_Str"")) {
        cmdAPDU=new ManageSecurityEnvironment(SET_COMPUTATION,ManageSecurityEnvironment.AT,mseData);
      }
 else {
        String msg=""String_Node_Str"";
        logger.error(msg);
        throw new IncorrectParameterException(msg);
      }
    }
 else     if (command.equals(""String_Node_Str"")) {
      cmdAPDU=new PSOComputeDigitalSignature(message,BLOCKSIZE);
    }
 else     if (command.equals(""String_Node_Str"")) {
      cmdAPDU=new InternalAuthenticate(message,BLOCKSIZE);
    }
 else     if (command.equals(""String_Node_Str"")) {
      cmdAPDU=new ManageSecurityEnvironment.Restore(ManageSecurityEnvironment.DST);
    }
 else     if (command.equals(""String_Node_Str"")) {
      cmdAPDU=new ManageSecurityEnvironment.Set(SET_COMPUTATION,ManageSecurityEnvironment.HT);
      TLV mseDataTLV=new TLV();
      mseDataTLV.setTagNumWithClass((byte)0x80);
      mseDataTLV.setValue(hashRef);
      cmdAPDU.setData(mseDataTLV.toBER());
    }
 else     if (command.equals(""String_Node_Str"")) {
      if (hashInfo.value().equals(HashGenerationInfoType.LAST_ROUND_ON_CARD.value()) || hashInfo.value().equals(HashGenerationInfoType.NOT_ON_CARD.value())) {
        cmdAPDU=new PSOHash(PSOHash.P2_SET_HASH_OR_PART,message);
      }
 else {
        cmdAPDU=new PSOHash(PSOHash.P2_HASH_MESSAGE,message);
      }
    }
 else     if (command.equals(""String_Node_Str"")) {
      byte[] mseData=tagAlgorithmIdentifier.toBER();
      cmdAPDU=new ManageSecurityEnvironment(SET_COMPUTATION,ManageSecurityEnvironment.DST,mseData);
    }
 else     if (command.equals(""String_Node_Str"")) {
      byte[] mseData=ByteUtils.concatenate(tagKeyReference.toBER(),tagAlgorithmIdentifier.toBER());
      cmdAPDU=new ManageSecurityEnvironment(SET_COMPUTATION,ManageSecurityEnvironment.DST,mseData);
    }
 else     if (command.equals(""String_Node_Str"")) {
      byte[] mseData=tagKeyReference.toBER();
      cmdAPDU=new ManageSecurityEnvironment(SET_COMPUTATION,ManageSecurityEnvironment.AT,mseData);
    }
 else     if (command.equals(""String_Node_Str"")) {
      byte[] mseData=ByteUtils.concatenate(tagKeyReference.toBER(),tagAlgorithmIdentifier.toBER());
      cmdAPDU=new ManageSecurityEnvironment(SET_COMPUTATION,ManageSecurityEnvironment.AT,mseData);
    }
 else {
      String msg=""String_Node_Str"" + command + ""String_Node_Str"";
      throw new IncorrectParameterException(msg);
    }
    responseAPDU=cmdAPDU.transmit(dispatcher,slotHandle,Collections.<byte[]>emptyList());
  }
  byte[] signedMessage=responseAPDU.getData();
  while (responseAPDU.getTrailer()[0] == (byte)0x61) {
    CardCommandAPDU getResponseData=new CardCommandAPDU((byte)0x00,(byte)0xC0,(byte)0x00,(byte)0x00,responseAPDU.getTrailer()[1]);
    responseAPDU=getResponseData.transmit(dispatcher,slotHandle,Collections.<byte[]>emptyList());
    signedMessage=Arrays.concatenate(signedMessage,responseAPDU.getData());
  }
  if (!Arrays.areEqual(responseAPDU.getTrailer(),new byte[]{(byte)0x90,(byte)0x00})) {
    TransmitResponse tr=new TransmitResponse();
    tr.getOutputAPDU().add(responseAPDU.toByteArray());
    WSHelper.checkResult(response);
  }
  response.setSignature(signedMessage);
  return response;
}","/** 
 * This method performs the signature creation according to BSI TR-03112 part 7.
 * @param cryptoMarker The {@link CryptoMarkerType} containing the SignatureCreationInfo for creating the signature.
 * @param keyReference A byte array containing the reference of the key to use.
 * @param algorithmIdentifier A byte array containing the identifier of the signing algorithm.
 * @param message The message to sign.
 * @param slotHandle The slotHandle identifying the card.
 * @param hashRef The variable contains the reference for the hash algorithm which have to be used.
 * @param hashInfo A HashGenerationInfo object which indicates how the hash computation is to perform.
 * @return A {@link SignResponse} object containing the signature of the <b>message</b>.
 * @throws TLVException Thrown if the TLV creation for the key identifier or algorithm identifier failed.
 * @throws IncorrectParameterException Thrown if the SignatureGenerationInfo does not contain PSO_CDS or INT_AUTHafter an MSE_KEY command.
 * @throws APDUException Thrown if one of the command to create the signature failed.
 * @throws org.openecard.common.WSHelper.WSException Thrown if the checkResults method of WSHelper failed.
 */
private SignResponse performSignature(CryptoMarkerType cryptoMarker,byte[] keyReference,byte[] algorithmIdentifier,byte[] message,byte[] slotHandle,byte[] hashRef,HashGenerationInfoType hashInfo) throws TLVException, IncorrectParameterException, APDUException, WSHelper.WSException {
  SignResponse response=WSHelper.makeResponse(SignResponse.class,WSHelper.makeResultOK());
  TLV tagAlgorithmIdentifier=new TLV();
  tagAlgorithmIdentifier.setTagNumWithClass(CARD_ALG_REF);
  tagAlgorithmIdentifier.setValue(algorithmIdentifier);
  TLV tagKeyReference=new TLV();
  tagKeyReference.setTagNumWithClass(KEY_REFERENCE_PRIVATE_KEY);
  tagKeyReference.setValue(keyReference);
  CardCommandAPDU cmdAPDU=null;
  CardResponseAPDU responseAPDU=null;
  String[] signatureGenerationInfo=cryptoMarker.getSignatureGenerationInfo();
  for (  String command : signatureGenerationInfo) {
    HashSet<String> signGenInfo=new HashSet<String>(java.util.Arrays.asList(signatureGenerationInfo));
    if (command.equals(""String_Node_Str"")) {
      byte[] mseData=tagKeyReference.toBER();
      if (signGenInfo.contains(""String_Node_Str"")) {
        cmdAPDU=new ManageSecurityEnvironment(SET_COMPUTATION,ManageSecurityEnvironment.DST,mseData);
      }
 else       if (signGenInfo.contains(""String_Node_Str"") && !signGenInfo.contains(""String_Node_Str"")) {
        cmdAPDU=new ManageSecurityEnvironment(SET_COMPUTATION,ManageSecurityEnvironment.AT,mseData);
      }
 else {
        String msg=""String_Node_Str"";
        logger.error(msg);
        throw new IncorrectParameterException(msg);
      }
    }
 else     if (command.equals(""String_Node_Str"")) {
      cmdAPDU=new PSOComputeDigitalSignature(message,BLOCKSIZE);
    }
 else     if (command.equals(""String_Node_Str"")) {
      cmdAPDU=new InternalAuthenticate(message,BLOCKSIZE);
    }
 else     if (command.equals(""String_Node_Str"")) {
      cmdAPDU=new ManageSecurityEnvironment.Restore(ManageSecurityEnvironment.DST);
    }
 else     if (command.equals(""String_Node_Str"")) {
      cmdAPDU=new ManageSecurityEnvironment.Set(SET_COMPUTATION,ManageSecurityEnvironment.HT);
      TLV mseDataTLV=new TLV();
      mseDataTLV.setTagNumWithClass((byte)0x80);
      mseDataTLV.setValue(hashRef);
      cmdAPDU.setData(mseDataTLV.toBER());
    }
 else     if (command.equals(""String_Node_Str"")) {
      if (hashInfo.value().equals(HashGenerationInfoType.LAST_ROUND_ON_CARD.value()) || hashInfo.value().equals(HashGenerationInfoType.NOT_ON_CARD.value())) {
        cmdAPDU=new PSOHash(PSOHash.P2_SET_HASH_OR_PART,message);
      }
 else {
        cmdAPDU=new PSOHash(PSOHash.P2_HASH_MESSAGE,message);
      }
    }
 else     if (command.equals(""String_Node_Str"")) {
      byte[] mseData=tagAlgorithmIdentifier.toBER();
      cmdAPDU=new ManageSecurityEnvironment(SET_COMPUTATION,ManageSecurityEnvironment.DST,mseData);
    }
 else     if (command.equals(""String_Node_Str"")) {
      byte[] mseData=ByteUtils.concatenate(tagKeyReference.toBER(),tagAlgorithmIdentifier.toBER());
      cmdAPDU=new ManageSecurityEnvironment(SET_COMPUTATION,ManageSecurityEnvironment.DST,mseData);
    }
 else     if (command.equals(""String_Node_Str"")) {
      byte[] mseData=tagKeyReference.toBER();
      cmdAPDU=new ManageSecurityEnvironment(SET_COMPUTATION,ManageSecurityEnvironment.AT,mseData);
    }
 else     if (command.equals(""String_Node_Str"")) {
      byte[] mseData=ByteUtils.concatenate(tagKeyReference.toBER(),tagAlgorithmIdentifier.toBER());
      cmdAPDU=new ManageSecurityEnvironment(SET_COMPUTATION,ManageSecurityEnvironment.AT,mseData);
    }
 else {
      String msg=""String_Node_Str"" + command + ""String_Node_Str"";
      throw new IncorrectParameterException(msg);
    }
    responseAPDU=cmdAPDU.transmit(dispatcher,slotHandle,Collections.<byte[]>emptyList());
  }
  byte[] signedMessage=responseAPDU.getData();
  while (responseAPDU.getTrailer()[0] == (byte)0x61) {
    GetResponse getResponseData=new GetResponse();
    responseAPDU=getResponseData.transmit(dispatcher,slotHandle,Collections.<byte[]>emptyList());
    signedMessage=Arrays.concatenate(signedMessage,responseAPDU.getData());
  }
  if (!Arrays.areEqual(responseAPDU.getTrailer(),new byte[]{(byte)0x90,(byte)0x00})) {
    TransmitResponse tr=new TransmitResponse();
    tr.getOutputAPDU().add(responseAPDU.toByteArray());
    WSHelper.checkResult(response);
  }
  response.setSignature(signedMessage);
  return response;
}"
48135,"/** 
 * Returns a list of ConnectionHandles.
 * @return List of ConnectionHandles
 */
public List<ConnectionHandleType> getConnectionHandles(){
  ConnectionHandleType handle=new ConnectionHandleType();
  Set<CardStateEntry> entries=states.getMatchingEntries(handle);
  ArrayList<ConnectionHandleType> result=new ArrayList<ConnectionHandleType>(entries.size());
  for (  CardStateEntry entry : entries) {
    result.add(entry.handleCopy());
  }
  return result;
}","/** 
 * Returns a list of ConnectionHandles.
 * @return List of ConnectionHandles
 */
public List<ConnectionHandleType> getConnectionHandles(){
  ConnectionHandleType handle=new ConnectionHandleType();
  Set<CardStateEntry> entries=states.getMatchingEntries(handle);
  ArrayList<ConnectionHandleType> result=new ArrayList<>(entries.size());
  for (  CardStateEntry entry : entries) {
    result.add(entry.handleCopy());
  }
  return result;
}"
48136,"/** 
 * The DSIRead function reads out the content of a specific DSI (Data Structure for Interoperability). See BSI-TR-03112-4, version 1.1.2, section 3.4.9.
 * @param request DSIRead
 * @return DSIReadResponse
 */
@Override public DSIReadResponse dsiRead(DSIRead request){
  DSIReadResponse response=WSHelper.makeResponse(DSIReadResponse.class,WSHelper.makeResultOK());
  try {
    ConnectionHandleType connectionHandle=SALUtils.getConnectionHandle(request);
    CardStateEntry cardStateEntry=SALUtils.getCardStateEntry(states,connectionHandle);
    byte[] applicationID=cardStateEntry.getCurrentCardApplication().getApplicationIdentifier();
    String dsiName=request.getDSIName();
    Assert.assertIncorrectParameter(dsiName,""String_Node_Str"");
    if (cardStateEntry.getFCPOfSelectedEF() == null) {
      throw new PrerequisitesNotSatisfiedException(""String_Node_Str"");
    }
    CardInfoWrapper cardInfoWrapper=cardStateEntry.getInfo();
    DataSetInfoType dataSetInfo=cardInfoWrapper.getDataSetByDsiName(dsiName);
    if (dataSetInfo == null) {
      dataSetInfo=cardInfoWrapper.getDataSetByName(dsiName);
      if (dataSetInfo != null) {
        if (!cardStateEntry.getFCPOfSelectedEF().getFileIdentifiers().isEmpty()) {
          byte[] path=dataSetInfo.getDataSetPath().getEfIdOrPath();
          byte[] fid=Arrays.copyOfRange(path,path.length - 2,path.length);
          if (!Arrays.equals(fid,cardStateEntry.getFCPOfSelectedEF().getFileIdentifiers().get(0))) {
            String msg=""String_Node_Str"" + dsiName + ""String_Node_Str"";
            throw new PrerequisitesNotSatisfiedException(msg);
          }
        }
      }
 else {
        String msg=""String_Node_Str"";
        throw new IncorrectParameterException(msg);
      }
    }
    Assert.securityConditionDataSet(cardStateEntry,applicationID,dsiName,NamedDataServiceActionName.DSI_READ);
    byte[] slotHandle=connectionHandle.getSlotHandle();
    byte[] fileContent=CardUtils.readFile(cardStateEntry.getFCPOfSelectedEF(),env.getDispatcher(),slotHandle);
    response.setDSIContent(fileContent);
  }
 catch (  ECardException e) {
    response.setResult(e.getResult());
  }
catch (  Exception e) {
    logger.error(e.getMessage(),e);
    response.setResult(WSHelper.makeResult(e));
  }
  return response;
}","/** 
 * The DSIRead function reads out the content of a specific DSI (Data Structure for Interoperability). See BSI-TR-03112-4, version 1.1.2, section 3.4.9.
 * @param request DSIRead
 * @return DSIReadResponse
 */
@Override public DSIReadResponse dsiRead(DSIRead request){
  DSIReadResponse response=WSHelper.makeResponse(DSIReadResponse.class,WSHelper.makeResultOK());
  try {
    ConnectionHandleType connectionHandle=SALUtils.getConnectionHandle(request);
    CardStateEntry cardStateEntry=SALUtils.getCardStateEntry(states,connectionHandle);
    byte[] applicationID=cardStateEntry.getCurrentCardApplication().getApplicationIdentifier();
    String dsiName=request.getDSIName();
    byte[] slotHandle=connectionHandle.getSlotHandle();
    Assert.assertIncorrectParameter(dsiName,""String_Node_Str"");
    Assert.securityConditionDataSet(cardStateEntry,applicationID,dsiName,NamedDataServiceActionName.DSI_READ);
    if (cardStateEntry.getFCPOfSelectedEF() == null) {
      throw new PrerequisitesNotSatisfiedException(""String_Node_Str"");
    }
    CardInfoWrapper cardInfoWrapper=cardStateEntry.getInfo();
    DataSetInfoType dataSetInfo=cardInfoWrapper.getDataSetByDsiName(dsiName);
    if (dataSetInfo == null) {
      dataSetInfo=cardInfoWrapper.getDataSetByName(dsiName);
      if (dataSetInfo != null) {
        if (!cardStateEntry.getFCPOfSelectedEF().getFileIdentifiers().isEmpty()) {
          byte[] path=dataSetInfo.getDataSetPath().getEfIdOrPath();
          byte[] fid=Arrays.copyOfRange(path,path.length - 2,path.length);
          if (!Arrays.equals(fid,cardStateEntry.getFCPOfSelectedEF().getFileIdentifiers().get(0))) {
            String msg=""String_Node_Str"" + dsiName + ""String_Node_Str"";
            throw new PrerequisitesNotSatisfiedException(msg);
          }
        }
        byte[] fileContent=CardUtils.readFile(cardStateEntry.getFCPOfSelectedEF(),env.getDispatcher(),slotHandle);
        response.setDSIContent(fileContent);
      }
 else {
        String msg=""String_Node_Str"";
        throw new IncorrectParameterException(msg);
      }
    }
 else {
      byte[] dataSetPath=dataSetInfo.getDataSetPath().getEfIdOrPath();
      byte[] dataSetFID=new byte[]{dataSetPath[dataSetPath.length - 2],dataSetPath[dataSetPath.length - 1]};
      if (Arrays.equals(dataSetFID,cardStateEntry.getFCPOfSelectedEF().getFileIdentifiers().get(0))) {
        DSIType dsi=cardInfoWrapper.getDSIbyName(dsiName);
        PathType dsiPath=dsi.getDSIPath();
        if (dsiPath.getTagRef() != null) {
          TagRef tagReference=dsiPath.getTagRef();
          byte[] tag=tagReference.getTag();
          GetData getDataRequest;
          if (tag.length == 2) {
            getDataRequest=new GetData(GetData.INS_DATA,tag[0],tag[1]);
            CardResponseAPDU cardResponse=getDataRequest.transmit(env.getDispatcher(),slotHandle,Collections.EMPTY_LIST);
            byte[] responseData=cardResponse.getData();
            while (cardResponse.getTrailer()[0] == (byte)0x61) {
              GetResponse allData=new GetResponse();
              cardResponse=allData.transmit(env.getDispatcher(),slotHandle,Collections.EMPTY_LIST);
              responseData=ByteUtils.concatenate(responseData,cardResponse.getData());
            }
            response.setDSIContent(responseData);
          }
 else           if (tag.length == 1) {
            getDataRequest=new GetData(GetData.INS_DATA,GetData.SIMPLE_TLV,tag[0]);
            CardResponseAPDU cardResponse=getDataRequest.transmit(env.getDispatcher(),slotHandle,Collections.EMPTY_LIST);
            byte[] responseData=cardResponse.getData();
            if (Arrays.equals(cardResponse.getTrailer(),new byte[]{(byte)0x6A,(byte)0x88})) {
              getDataRequest=new GetData(GetData.INS_DATA,GetData.BER_TLV_ONE_BYTE,tag[0]);
              cardResponse=getDataRequest.transmit(env.getDispatcher(),slotHandle,Collections.EMPTY_LIST);
              responseData=cardResponse.getData();
            }
            while (cardResponse.getTrailer()[0] == (byte)0x61) {
              GetResponse allData=new GetResponse();
              cardResponse=allData.transmit(env.getDispatcher(),slotHandle,Collections.EMPTY_LIST);
              responseData=ByteUtils.concatenate(responseData,cardResponse.getData());
            }
            response.setDSIContent(responseData);
          }
        }
 else         if (dsiPath.getIndex() != null) {
          byte[] index=dsiPath.getIndex();
          byte[] length=dsiPath.getLength();
          List<byte[]> allowedResponse=new ArrayList<>();
          allowedResponse.add(new byte[]{(byte)0x90,(byte)0x00});
          allowedResponse.add(new byte[]{(byte)0x62,(byte)0x82});
          if (cardStateEntry.getFCPOfSelectedEF().getDataElements().isLinear()) {
            ReadRecord readRecord=new ReadRecord(index[0]);
            CardResponseAPDU cardResponse=readRecord.transmit(env.getDispatcher(),slotHandle,allowedResponse);
            response.setDSIContent(cardResponse.getData());
          }
 else {
            ReadBinary readBinary=new ReadBinary(ByteUtils.toShort(index),ByteUtils.toShort(length));
            CardResponseAPDU cardResponse=readBinary.transmit(env.getDispatcher(),slotHandle,allowedResponse);
            response.setDSIContent(cardResponse.getData());
          }
        }
 else {
          String msg=""String_Node_Str"" + dsiName;
          throw new PrerequisitesNotSatisfiedException(msg);
        }
      }
    }
  }
 catch (  ECardException e) {
    response.setResult(e.getResult());
  }
catch (  Exception e) {
    logger.error(e.getMessage(),e);
    response.setResult(WSHelper.makeResult(e));
  }
  return response;
}"
48137,"/** 
 * The DIDList function returns a list of the existing DIDs in the card application addressed by the ConnectionHandle or the ApplicationIdentifier element within the Filter. See BSI-TR-03112-4, version 1.1.2, section 3.6.1.
 * @param request DIDList
 * @return DIDListResponse
 */
@Override public DIDListResponse didList(DIDList request){
  DIDListResponse response=WSHelper.makeResponse(DIDListResponse.class,WSHelper.makeResultOK());
  try {
    ConnectionHandleType connectionHandle=SALUtils.getConnectionHandle(request);
    byte[] appId=connectionHandle.getCardApplication();
    CardStateEntry cardStateEntry=SALUtils.getCardStateEntry(states,connectionHandle,false);
    Assert.securityConditionApplication(cardStateEntry,appId,DifferentialIdentityServiceActionName.DID_LIST);
    byte[] applicationIDFilter=null;
    String objectIDFilter=null;
    String applicationFunctionFilter=null;
    DIDQualifierType didQualifier=request.getFilter();
    if (didQualifier != null) {
      applicationIDFilter=didQualifier.getApplicationIdentifier();
      objectIDFilter=didQualifier.getObjectIdentifier();
      applicationFunctionFilter=didQualifier.getApplicationFunction();
    }
    CardApplicationWrapper cardApplication;
    if (applicationIDFilter != null) {
      cardApplication=cardStateEntry.getInfo().getCardApplication(applicationIDFilter);
      Assert.assertIncorrectParameter(cardApplication,""String_Node_Str"");
    }
 else {
      cardApplication=cardStateEntry.getCurrentCardApplication();
    }
    List<DIDInfoType> didInfos=new ArrayList<DIDInfoType>(cardApplication.getDIDInfoList());
    if (objectIDFilter != null) {
      Iterator<DIDInfoType> it=didInfos.iterator();
      while (it.hasNext()) {
        DIDInfoType next=it.next();
        if (!next.getDifferentialIdentity().getDIDProtocol().equals(objectIDFilter)) {
          it.remove();
        }
      }
    }
    if (applicationFunctionFilter != null) {
      Iterator<DIDInfoType> it=didInfos.iterator();
      while (it.hasNext()) {
        DIDInfoType next=it.next();
        if (next.getDifferentialIdentity().getDIDMarker().getCryptoMarker() == null) {
          it.remove();
        }
 else {
          iso.std.iso_iec._24727.tech.schema.CryptoMarkerType rawMarker;
          rawMarker=next.getDifferentialIdentity().getDIDMarker().getCryptoMarker();
          CryptoMarkerType cryptoMarker=new CryptoMarkerType(rawMarker);
          AlgorithmInfoType algInfo=cryptoMarker.getAlgorithmInfo();
          if (!algInfo.getSupportedOperations().contains(applicationFunctionFilter)) {
            it.remove();
          }
        }
      }
    }
    DIDNameListType didNameList=new DIDNameListType();
    for (    DIDInfoType didInfo : didInfos) {
      didNameList.getDIDName().add(didInfo.getDifferentialIdentity().getDIDName());
    }
    response.setDIDNameList(didNameList);
  }
 catch (  ECardException e) {
    response.setResult(e.getResult());
  }
catch (  Exception e) {
    logger.error(e.getMessage(),e);
    response.setResult(WSHelper.makeResult(e));
  }
  return response;
}","/** 
 * The DIDList function returns a list of the existing DIDs in the card application addressed by the ConnectionHandle or the ApplicationIdentifier element within the Filter. See BSI-TR-03112-4, version 1.1.2, section 3.6.1.
 * @param request DIDList
 * @return DIDListResponse
 */
@Override public DIDListResponse didList(DIDList request){
  DIDListResponse response=WSHelper.makeResponse(DIDListResponse.class,WSHelper.makeResultOK());
  try {
    ConnectionHandleType connectionHandle=SALUtils.getConnectionHandle(request);
    byte[] appId=connectionHandle.getCardApplication();
    CardStateEntry cardStateEntry=SALUtils.getCardStateEntry(states,connectionHandle,false);
    Assert.securityConditionApplication(cardStateEntry,appId,DifferentialIdentityServiceActionName.DID_LIST);
    byte[] applicationIDFilter=null;
    String objectIDFilter=null;
    String applicationFunctionFilter=null;
    DIDQualifierType didQualifier=request.getFilter();
    if (didQualifier != null) {
      applicationIDFilter=didQualifier.getApplicationIdentifier();
      objectIDFilter=didQualifier.getObjectIdentifier();
      applicationFunctionFilter=didQualifier.getApplicationFunction();
    }
    CardApplicationWrapper cardApplication;
    if (applicationIDFilter != null) {
      cardApplication=cardStateEntry.getInfo().getCardApplication(applicationIDFilter);
      Assert.assertIncorrectParameter(cardApplication,""String_Node_Str"");
    }
 else {
      cardApplication=cardStateEntry.getCurrentCardApplication();
    }
    List<DIDInfoType> didInfos=new ArrayList<>(cardApplication.getDIDInfoList());
    if (objectIDFilter != null) {
      Iterator<DIDInfoType> it=didInfos.iterator();
      while (it.hasNext()) {
        DIDInfoType next=it.next();
        if (!next.getDifferentialIdentity().getDIDProtocol().equals(objectIDFilter)) {
          it.remove();
        }
      }
    }
    if (applicationFunctionFilter != null) {
      Iterator<DIDInfoType> it=didInfos.iterator();
      while (it.hasNext()) {
        DIDInfoType next=it.next();
        if (next.getDifferentialIdentity().getDIDMarker().getCryptoMarker() == null) {
          it.remove();
        }
 else {
          iso.std.iso_iec._24727.tech.schema.CryptoMarkerType rawMarker;
          rawMarker=next.getDifferentialIdentity().getDIDMarker().getCryptoMarker();
          CryptoMarkerType cryptoMarker=new CryptoMarkerType(rawMarker);
          AlgorithmInfoType algInfo=cryptoMarker.getAlgorithmInfo();
          if (!algInfo.getSupportedOperations().contains(applicationFunctionFilter)) {
            it.remove();
          }
        }
      }
    }
    DIDNameListType didNameList=new DIDNameListType();
    for (    DIDInfoType didInfo : didInfos) {
      didNameList.getDIDName().add(didInfo.getDifferentialIdentity().getDIDName());
    }
    response.setDIDNameList(didNameList);
  }
 catch (  ECardException e) {
    response.setResult(e.getResult());
  }
catch (  Exception e) {
    logger.error(e.getMessage(),e);
    response.setResult(WSHelper.makeResult(e));
  }
  return response;
}"
48138,"/** 
 * The CardApplicationConnect function establishes an unauthenticated connection between the client application and the card application. See BSI-TR-03112-4, version 1.1.2, section 3.2.1.
 * @param request CardApplicationConnect
 * @return CardApplicationConnectResponse
 */
@Override public CardApplicationConnectResponse cardApplicationConnect(CardApplicationConnect request){
  CardApplicationConnectResponse response=WSHelper.makeResponse(CardApplicationConnectResponse.class,WSHelper.makeResultOK());
  try {
    CardApplicationPathType cardAppPath=request.getCardApplicationPath();
    Assert.assertIncorrectParameter(cardAppPath,""String_Node_Str"");
    Set<CardStateEntry> cardStateEntrySet=states.getMatchingEntries(cardAppPath,false);
    Assert.assertIncorrectParameter(cardStateEntrySet,""String_Node_Str"");
    CardStateEntry cardStateEntry=cardStateEntrySet.iterator().next();
    byte[] applicationID=cardAppPath.getCardApplication();
    if (applicationID == null) {
      if (cardStateEntry.getImplicitlySelectedApplicationIdentifier() != null) {
        applicationID=cardStateEntry.getImplicitlySelectedApplicationIdentifier();
      }
 else {
        applicationID=MF;
      }
    }
    Assert.securityConditionApplication(cardStateEntry,applicationID,ConnectionServiceActionName.CARD_APPLICATION_CONNECT);
    CardApplicationPathType cardApplicationPath=cardStateEntry.pathCopy();
    Connect connect=new Connect();
    connect.setContextHandle(cardApplicationPath.getContextHandle());
    connect.setIFDName(cardApplicationPath.getIFDName());
    connect.setSlot(cardApplicationPath.getSlotIndex());
    ConnectResponse connectResponse=(ConnectResponse)env.getDispatcher().deliver(connect);
    WSHelper.checkResult(connectResponse);
    CardCommandAPDU select;
    if (applicationID.length == 2) {
      select=new Select.File(applicationID);
    }
 else {
      select=new Select.Application(applicationID);
    }
    select.transmit(env.getDispatcher(),connectResponse.getSlotHandle());
    cardStateEntry.setCurrentCardApplication(applicationID);
    cardStateEntry.setSlotHandle(connectResponse.getSlotHandle());
    cardStateEntry.unsetFCPOfSelectedEF();
    states.addEntry(cardStateEntry);
    response.setConnectionHandle(cardStateEntry.handleCopy());
    response.getConnectionHandle().setCardApplication(applicationID);
  }
 catch (  ECardException e) {
    response.setResult(e.getResult());
  }
catch (  DispatcherException e) {
    logger.error(e.getMessage(),e);
    response.setResult(WSHelper.makeResult(e));
  }
catch (  InvocationTargetException e) {
    logger.error(e.getMessage(),e);
    response.setResult(WSHelper.makeResult(e));
  }
  return response;
}","/** 
 * The CardApplicationConnect function establishes an unauthenticated connection between the client application and the card application. See BSI-TR-03112-4, version 1.1.2, section 3.2.1.
 * @param request CardApplicationConnect
 * @return CardApplicationConnectResponse
 */
@Override public CardApplicationConnectResponse cardApplicationConnect(CardApplicationConnect request){
  CardApplicationConnectResponse response=WSHelper.makeResponse(CardApplicationConnectResponse.class,WSHelper.makeResultOK());
  try {
    CardApplicationPathType cardAppPath=request.getCardApplicationPath();
    Assert.assertIncorrectParameter(cardAppPath,""String_Node_Str"");
    Set<CardStateEntry> cardStateEntrySet=states.getMatchingEntries(cardAppPath,false);
    Assert.assertIncorrectParameter(cardStateEntrySet,""String_Node_Str"");
    CardStateEntry cardStateEntry=cardStateEntrySet.iterator().next();
    byte[] applicationID=cardAppPath.getCardApplication();
    if (applicationID == null) {
      if (cardStateEntry.getImplicitlySelectedApplicationIdentifier() != null) {
        applicationID=cardStateEntry.getImplicitlySelectedApplicationIdentifier();
      }
 else {
        applicationID=MF;
      }
    }
    Assert.securityConditionApplication(cardStateEntry,applicationID,ConnectionServiceActionName.CARD_APPLICATION_CONNECT);
    CardApplicationPathType cardApplicationPath=cardStateEntry.pathCopy();
    Connect connect=new Connect();
    connect.setContextHandle(cardApplicationPath.getContextHandle());
    connect.setIFDName(cardApplicationPath.getIFDName());
    connect.setSlot(cardApplicationPath.getSlotIndex());
    ConnectResponse connectResponse=(ConnectResponse)env.getDispatcher().deliver(connect);
    WSHelper.checkResult(connectResponse);
    CardCommandAPDU select;
    if (applicationID.length == 2) {
      select=new Select.File(applicationID);
    }
 else {
      select=new Select.Application(applicationID);
    }
    select.transmit(env.getDispatcher(),connectResponse.getSlotHandle());
    cardStateEntry.setCurrentCardApplication(applicationID);
    cardStateEntry.setSlotHandle(connectResponse.getSlotHandle());
    cardStateEntry.unsetFCPOfSelectedEF();
    states.addEntry(cardStateEntry);
    response.setConnectionHandle(cardStateEntry.handleCopy());
    response.getConnectionHandle().setCardApplication(applicationID);
  }
 catch (  ECardException e) {
    response.setResult(e.getResult());
  }
catch (  DispatcherException|InvocationTargetException e) {
    logger.error(e.getMessage(),e);
    response.setResult(WSHelper.makeResult(e));
  }
  return response;
}"
48139,"private I18n(String component){
  Locale userLocale=Locale.getDefault();
  String lang=userLocale.getLanguage();
  String country=userLocale.getCountry();
  Properties defaults=loadFile(component,""String_Node_Str"");
  if (!lang.isEmpty()) {
    Properties target=loadFile(component,lang);
    defaults=mergeProperties(defaults,target);
  }
  if (!lang.isEmpty() && !country.isEmpty()) {
    Properties target=loadFile(component,lang + ""String_Node_Str"" + country);
    defaults=mergeProperties(defaults,target);
  }
  this.component=component;
  this.translation=defaults;
  this.translatedFiles=new TreeMap<String,URL>();
}","private I18n(String component){
  Locale userLocale=getLocale();
  String lang=userLocale.getLanguage();
  String country=userLocale.getCountry();
  Properties defaults=loadFile(component,""String_Node_Str"");
  if (!lang.isEmpty()) {
    Properties target=loadFile(component,lang);
    defaults=mergeProperties(defaults,target);
  }
  if (!lang.isEmpty() && !country.isEmpty()) {
    Properties target=loadFile(component,lang + ""String_Node_Str"" + country);
    defaults=mergeProperties(defaults,target);
  }
  this.component=component;
  this.translation=defaults;
  this.translatedFiles=new TreeMap<String,URL>();
}"
48140,"private void prepareStructure(PasswordAttributesType attributes,byte[] cmdTemplate) throws IFDException {
  byte[] pinTemplate;
  try {
    pinTemplate=PINUtils.createPinMask(attributes);
  }
 catch (  UtilException e) {
    IFDException ex=new IFDException(e);
    throw ex;
  }
  byte[] template=cmdTemplate;
  if (pinTemplate.length > 0) {
    template=ByteUtils.concatenate(cmdTemplate,(byte)pinTemplate.length);
    template=ByteUtils.concatenate(template,pinTemplate);
  }
  setData(template);
  boolean nibbleHandling=pwdType == PasswordTypeType.BCD || pwdType == PasswordTypeType.ISO_9564_1;
  boolean isoPin=pwdType == PasswordTypeType.ISO_9564_1;
  int pinLenIdx=template.length;
  int pinPos=isoPin ? pinLenIdx + 1 : pinLenIdx;
  byte bmSysUnits=1;
  byte bmPinPos=(byte)(isoPin ? 1 : 0);
  byte bmJustify=0;
  byte bmPinType=0;
  if (nibbleHandling) {
    bmPinType=1;
  }
 else   if (pwdType == PasswordTypeType.ASCII_NUMERIC) {
    bmPinType=2;
  }
  this.bmFormatString=(byte)((bmSysUnits << 7) | (bmPinPos << 3) | (bmJustify << 2)| bmPinType);
  byte bmPinManagement=(byte)(isoPin ? 4 : 0);
  byte pinSize=(byte)(isoPin ? storedLen - 1 : storedLen);
  this.bmPINBlockString=(byte)((bmPinManagement << 4) | pinSize);
  byte bmPinLengthUnit=0;
  byte bmPinBytePos=(byte)(isoPin ? 4 : 0);
  bmPINLengthFormat=(byte)((bmPinLengthUnit << 4) | bmPinBytePos);
  setMinPINSize((byte)minLen);
  setMaxPINSize((byte)maxLen);
}","private void prepareStructure(PasswordAttributesType attributes,byte[] cmdTemplate) throws IFDException {
  byte[] pinTemplate;
  try {
    pinTemplate=PINUtils.createPinMask(attributes);
  }
 catch (  UtilException e) {
    IFDException ex=new IFDException(e);
    throw ex;
  }
  byte[] template=cmdTemplate;
  if (pinTemplate.length > 0) {
    template=ByteUtils.concatenate(cmdTemplate,(byte)pinTemplate.length);
    template=ByteUtils.concatenate(template,pinTemplate);
  }
  setData(template);
  boolean nibbleHandling=pwdType == PasswordTypeType.BCD || pwdType == PasswordTypeType.ISO_9564_1;
  boolean isoPin=pwdType == PasswordTypeType.ISO_9564_1;
  int pinLenIdx=template.length;
  int pinPos=isoPin ? pinLenIdx + 1 : pinLenIdx;
  byte bmSysUnits=1;
  byte bmPinPos=(byte)(isoPin ? 1 : 0);
  byte bmJustify=0;
  byte bmPinType=0;
  if (nibbleHandling) {
    bmPinType=1;
  }
 else   if (pwdType == PasswordTypeType.ASCII_NUMERIC || pwdType == PasswordTypeType.UTF_8) {
    bmPinType=2;
  }
  this.bmFormatString=(byte)((bmSysUnits << 7) | (bmPinPos << 3) | (bmJustify << 2)| bmPinType);
  byte bmPinManagement=(byte)(isoPin ? 4 : 0);
  byte pinSize=(byte)(isoPin ? storedLen - 1 : storedLen);
  this.bmPINBlockString=(byte)((bmPinManagement << 4) | pinSize);
  byte bmPinLengthUnit=0;
  byte bmPinBytePos=(byte)(isoPin ? 4 : 0);
  bmPINLengthFormat=(byte)((bmPinLengthUnit << 4) | bmPinBytePos);
  setMinPINSize((byte)minLen);
  setMaxPINSize((byte)maxLen);
}"
48141,"public byte[] toBytes(){
  ByteArrayOutputStream o=new ByteArrayOutputStream(42);
  o.write(bTimeOut);
  o.write(bTimeOut2);
  o.write(bmFormatString);
  o.write(bmPINBlockString);
  o.write(bmPINLengthFormat);
  o.write(getMaxPINSize());
  o.write(getMinPINSize());
  o.write(bEntryValidationCondition);
  o.write(bNumberMessage);
  byte lang_low=(byte)(wLangId & 0xFF);
  byte lang_high=(byte)((wLangId >> 8) & 0xFF);
  o.write(lang_high);
  o.write(lang_low);
  o.write(bMsgIndex);
  o.write(bTeoPrologue,0,bTeoPrologue.length);
  byte[] ulDataLength_bytes=IntegerUtils.toByteArray(ulDataLength);
  for (int i=ulDataLength_bytes.length - 1; i >= 0; i--) {
    o.write(ulDataLength_bytes[i]);
  }
  for (int i=ulDataLength_bytes.length; i < 4; i++) {
    o.write(0);
  }
  if (ulDataLength > 0) {
    o.write(abData,0,abData.length);
  }
  byte[] result=o.toByteArray();
  return result;
}","public byte[] toBytes(){
  ByteArrayOutputStream o=new ByteArrayOutputStream(42);
  o.write(bTimeOut);
  o.write(bTimeOut2);
  o.write(bmFormatString);
  o.write(bmPINBlockString);
  o.write(bmPINLengthFormat);
  o.write(getMaxPINSize());
  o.write(getMinPINSize());
  o.write(bEntryValidationCondition);
  o.write(bNumberMessage);
  byte lang_low=(byte)((wLangId >> 8) & 0xFF);
  byte lang_high=(byte)(wLangId & 0xFF);
  o.write(lang_high);
  o.write(lang_low);
  o.write(bMsgIndex);
  o.write(bTeoPrologue,0,bTeoPrologue.length);
  byte[] ulDataLength_bytes=IntegerUtils.toByteArray(ulDataLength);
  for (int i=ulDataLength_bytes.length - 1; i >= 0; i--) {
    o.write(ulDataLength_bytes[i]);
  }
  for (int i=ulDataLength_bytes.length; i < 4; i++) {
    o.write(0);
  }
  if (ulDataLength > 0) {
    o.write(abData,0,abData.length);
  }
  byte[] result=o.toByteArray();
  return result;
}"
48142,"@Override public VerifySignatureResponse perform(VerifySignature request,Map<String,Object> internalData){
  VerifySignatureResponse response=WSHelper.makeResponse(VerifySignatureResponse.class,WSHelper.makeResultOK());
  try {
    ConnectionHandleType connectionHandle=SALUtils.getConnectionHandle(request);
    CardStateEntry cardStateEntry=SALUtils.getCardStateEntry(internalData,connectionHandle);
    String didName=SALUtils.getDIDName(request);
    DIDStructureType didStructure=SALUtils.getDIDStructure(request,didName,cardStateEntry,connectionHandle);
    byte[] signature=request.getSignature();
    byte[] message=request.getMessage();
    CryptoMarkerType cryptoMarker=new CryptoMarkerType(didStructure.getDIDMarker());
    String dataSetNameCertificate=cryptoMarker.getCertificateRef().getDataSetName();
    String algorithmIdentifier=cryptoMarker.getAlgorithmInfo().getAlgorithmIdentifier().getAlgorithm();
    DSIRead dsiRead=new DSIRead();
    dsiRead.setConnectionHandle(connectionHandle);
    dsiRead.setDSIName(dataSetNameCertificate);
    DSIReadResponse dsiReadResponse=(DSIReadResponse)dispatcher.deliver(dsiRead);
    WSHelper.checkResult(dsiReadResponse);
    CertificateFactory certFactory=CertificateFactory.getInstance(""String_Node_Str"");
    Certificate cert=(X509Certificate)certFactory.generateCertificate(new ByteArrayInputStream(dsiReadResponse.getDSIContent()));
    Signature signatureAlgorithm;
    if (algorithmIdentifier.equals(GenericCryptoObjectIdentifier.pkcs_1)) {
      signatureAlgorithm=Signature.getInstance(""String_Node_Str"",new BouncyCastleProvider());
    }
 else     if (algorithmIdentifier.equals(GenericCryptoObjectIdentifier.id_RSASSA_PSS)) {
      signatureAlgorithm=Signature.getInstance(""String_Node_Str"",new BouncyCastleProvider());
      signatureAlgorithm.setParameter(new PSSParameterSpec(""String_Node_Str"",""String_Node_Str"",new MGF1ParameterSpec(""String_Node_Str""),32,1));
    }
 else     if (algorithmIdentifier.equals(GenericCryptoObjectIdentifier.sigS_ISO9796_2)) {
      return WSHelper.makeResponse(VerifySignatureResponse.class,WSHelper.makeResultUnknownError(algorithmIdentifier + ""String_Node_Str""));
    }
 else     if (algorithmIdentifier.equals(GenericCryptoObjectIdentifier.sigS_ISO9796_2rnd)) {
      return WSHelper.makeResponse(VerifySignatureResponse.class,WSHelper.makeResultUnknownError(algorithmIdentifier + ""String_Node_Str""));
    }
 else {
      throw new IncorrectParameterException(""String_Node_Str"");
    }
    signatureAlgorithm.initVerify(cert);
    if (message != null) {
      signatureAlgorithm.update(message);
    }
    if (!signatureAlgorithm.verify(signature)) {
      throw new InvalidSignatureException();
    }
  }
 catch (  ECardException e) {
    logger.error(e.getMessage(),e);
    response.setResult(e.getResult());
  }
catch (  Exception e) {
    response.setResult(WSHelper.makeResult(e));
  }
  return response;
}","@Override public VerifySignatureResponse perform(VerifySignature request,Map<String,Object> internalData){
  VerifySignatureResponse response=WSHelper.makeResponse(VerifySignatureResponse.class,WSHelper.makeResultOK());
  try {
    ConnectionHandleType connectionHandle=SALUtils.getConnectionHandle(request);
    CardStateEntry cardStateEntry=SALUtils.getCardStateEntry(internalData,connectionHandle);
    String didName=SALUtils.getDIDName(request);
    DIDStructureType didStructure=SALUtils.getDIDStructure(request,didName,cardStateEntry,connectionHandle);
    byte[] signature=request.getSignature();
    byte[] message=request.getMessage();
    CryptoMarkerType cryptoMarker=new CryptoMarkerType(didStructure.getDIDMarker());
    String dataSetNameCertificate=cryptoMarker.getCertificateRefs().get(0).getDataSetName();
    String algorithmIdentifier=cryptoMarker.getAlgorithmInfo().getAlgorithmIdentifier().getAlgorithm();
    DSIRead dsiRead=new DSIRead();
    dsiRead.setConnectionHandle(connectionHandle);
    dsiRead.setDSIName(dataSetNameCertificate);
    DSIReadResponse dsiReadResponse=(DSIReadResponse)dispatcher.deliver(dsiRead);
    WSHelper.checkResult(dsiReadResponse);
    CertificateFactory certFactory=CertificateFactory.getInstance(""String_Node_Str"");
    Certificate cert=(X509Certificate)certFactory.generateCertificate(new ByteArrayInputStream(dsiReadResponse.getDSIContent()));
    Signature signatureAlgorithm;
    if (algorithmIdentifier.equals(GenericCryptoObjectIdentifier.pkcs_1)) {
      signatureAlgorithm=Signature.getInstance(""String_Node_Str"",new BouncyCastleProvider());
    }
 else     if (algorithmIdentifier.equals(GenericCryptoObjectIdentifier.id_RSASSA_PSS)) {
      signatureAlgorithm=Signature.getInstance(""String_Node_Str"",new BouncyCastleProvider());
      signatureAlgorithm.setParameter(new PSSParameterSpec(""String_Node_Str"",""String_Node_Str"",new MGF1ParameterSpec(""String_Node_Str""),32,1));
    }
 else     if (algorithmIdentifier.equals(GenericCryptoObjectIdentifier.sigS_ISO9796_2)) {
      return WSHelper.makeResponse(VerifySignatureResponse.class,WSHelper.makeResultUnknownError(algorithmIdentifier + ""String_Node_Str""));
    }
 else     if (algorithmIdentifier.equals(GenericCryptoObjectIdentifier.sigS_ISO9796_2rnd)) {
      return WSHelper.makeResponse(VerifySignatureResponse.class,WSHelper.makeResultUnknownError(algorithmIdentifier + ""String_Node_Str""));
    }
 else {
      throw new IncorrectParameterException(""String_Node_Str"");
    }
    signatureAlgorithm.initVerify(cert);
    if (message != null) {
      signatureAlgorithm.update(message);
    }
    if (!signatureAlgorithm.verify(signature)) {
      throw new InvalidSignatureException();
    }
  }
 catch (  ECardException e) {
    logger.error(e.getMessage(),e);
    response.setResult(e.getResult());
  }
catch (  Exception e) {
    response.setResult(WSHelper.makeResult(e));
  }
  return response;
}"
48143,"@Test public void testDIDGet() throws ParserConfigurationException {
  CardApplicationPath cardApplicationPath=new CardApplicationPath();
  CardApplicationPathType cardApplicationPathType=new CardApplicationPathType();
  cardApplicationPathType.setCardApplication(cardApplication);
  cardApplicationPath.setCardAppPathRequest(cardApplicationPathType);
  CardApplicationPathResponse cardApplicationPathResponse=instance.cardApplicationPath(cardApplicationPath);
  CardApplicationConnect parameters=new CardApplicationConnect();
  CardAppPathResultSet cardAppPathResultSet=cardApplicationPathResponse.getCardAppPathResultSet();
  parameters.setCardApplicationPath(cardAppPathResultSet.getCardApplicationPathResult().get(0));
  CardApplicationConnectResponse result=instance.cardApplicationConnect(parameters);
  assertEquals(ECardConstants.Major.OK,result.getResult().getResultMajor());
  DIDList didList=new DIDList();
  didList.setConnectionHandle(result.getConnectionHandle());
  DIDQualifierType didQualifier=new DIDQualifierType();
  didQualifier.setApplicationIdentifier(cardApplication);
  didQualifier.setObjectIdentifier(ECardConstants.Protocol.GENERIC_CRYPTO);
  didQualifier.setApplicationFunction(""String_Node_Str"");
  didList.setFilter(didQualifier);
  DIDListResponse didListResponse=instance.didList(didList);
  assertTrue(didListResponse.getDIDNameList().getDIDName().size() > 0);
  DIDGet didGet=new DIDGet();
  didGet.setConnectionHandle(result.getConnectionHandle());
  didGet.setDIDName(didListResponse.getDIDNameList().getDIDName().get(0));
  didGet.setDIDScope(DIDScopeType.LOCAL);
  DIDGetResponse didGetResponse=instance.didGet(didGet);
  assertEquals(ECardConstants.Major.OK,didGetResponse.getResult().getResultMajor());
  org.openecard.common.sal.anytype.CryptoMarkerType cryptoMarker=new org.openecard.common.sal.anytype.CryptoMarkerType((CryptoMarkerType)didGetResponse.getDIDStructure().getDIDMarker());
  assertEquals(cryptoMarker.getCertificateRef().getDataSetName(),""String_Node_Str"");
}","@Test public void testDIDGet() throws ParserConfigurationException {
  CardApplicationPath cardApplicationPath=new CardApplicationPath();
  CardApplicationPathType cardApplicationPathType=new CardApplicationPathType();
  cardApplicationPathType.setCardApplication(cardApplication);
  cardApplicationPath.setCardAppPathRequest(cardApplicationPathType);
  CardApplicationPathResponse cardApplicationPathResponse=instance.cardApplicationPath(cardApplicationPath);
  CardApplicationConnect parameters=new CardApplicationConnect();
  CardAppPathResultSet cardAppPathResultSet=cardApplicationPathResponse.getCardAppPathResultSet();
  parameters.setCardApplicationPath(cardAppPathResultSet.getCardApplicationPathResult().get(0));
  CardApplicationConnectResponse result=instance.cardApplicationConnect(parameters);
  assertEquals(ECardConstants.Major.OK,result.getResult().getResultMajor());
  DIDList didList=new DIDList();
  didList.setConnectionHandle(result.getConnectionHandle());
  DIDQualifierType didQualifier=new DIDQualifierType();
  didQualifier.setApplicationIdentifier(cardApplication);
  didQualifier.setObjectIdentifier(ECardConstants.Protocol.GENERIC_CRYPTO);
  didQualifier.setApplicationFunction(""String_Node_Str"");
  didList.setFilter(didQualifier);
  DIDListResponse didListResponse=instance.didList(didList);
  assertTrue(didListResponse.getDIDNameList().getDIDName().size() > 0);
  DIDGet didGet=new DIDGet();
  didGet.setConnectionHandle(result.getConnectionHandle());
  didGet.setDIDName(didListResponse.getDIDNameList().getDIDName().get(0));
  didGet.setDIDScope(DIDScopeType.LOCAL);
  DIDGetResponse didGetResponse=instance.didGet(didGet);
  assertEquals(ECardConstants.Major.OK,didGetResponse.getResult().getResultMajor());
  org.openecard.crypto.common.sal.CryptoMarkerType cryptoMarker=new org.openecard.crypto.common.sal.CryptoMarkerType((CryptoMarkerType)didGetResponse.getDIDStructure().getDIDMarker());
  assertEquals(cryptoMarker.getCertificateRefs().get(0).getDataSetName(),""String_Node_Str"");
}"
48144,"/** 
 * Test for the Sign Step of the Generic Cryptography protocol. After we connected to the ESIGN application of the eGK, we use DIDList to get a List of DIDs that support the compute signature function. For each DID we let the card compute a signature. If the result is OK we're satisfied.
 * @throws Exception when something in this test went unexpectedly wrong
 */
@Test public void testSign() throws Exception {
  CardApplicationPath cardApplicationPath=new CardApplicationPath();
  CardApplicationPathType cardApplicationPathType=new CardApplicationPathType();
  cardApplicationPathType.setCardApplication(cardApplication);
  cardApplicationPath.setCardAppPathRequest(cardApplicationPathType);
  CardApplicationPathResponse cardApplicationPathResponse=instance.cardApplicationPath(cardApplicationPath);
  WSHelper.checkResult(cardApplicationPathResponse);
  CardApplicationConnect parameters=new CardApplicationConnect();
  CardAppPathResultSet cardAppPathResultSet=cardApplicationPathResponse.getCardAppPathResultSet();
  parameters.setCardApplicationPath(cardAppPathResultSet.getCardApplicationPathResult().get(0));
  CardApplicationConnectResponse result=instance.cardApplicationConnect(parameters);
  WSHelper.checkResult(result);
  assertEquals(ECardConstants.Major.OK,result.getResult().getResultMajor());
  DIDList didList=new DIDList();
  didList.setConnectionHandle(result.getConnectionHandle());
  DIDQualifierType didQualifier=new DIDQualifierType();
  didQualifier.setApplicationIdentifier(cardApplication);
  didQualifier.setObjectIdentifier(ECardConstants.Protocol.GENERIC_CRYPTO);
  didQualifier.setApplicationFunction(""String_Node_Str"");
  didList.setFilter(didQualifier);
  DIDListResponse didListResponse=instance.didList(didList);
  assertTrue(didListResponse.getDIDNameList().getDIDName().size() > 0);
  WSHelper.checkResult(didListResponse);
  DIDAuthenticate didAthenticate=new DIDAuthenticate();
  didAthenticate.setDIDName(""String_Node_Str"");
  PinCompareDIDAuthenticateInputType didAuthenticationData=new PinCompareDIDAuthenticateInputType();
  didAthenticate.setAuthenticationProtocolData(didAuthenticationData);
  didAthenticate.setConnectionHandle(result.getConnectionHandle());
  didAthenticate.getConnectionHandle().setCardApplication(cardApplication_ROOT);
  didAuthenticationData.setProtocol(ECardConstants.Protocol.PIN_COMPARE);
  didAthenticate.setAuthenticationProtocolData(didAuthenticationData);
  DIDAuthenticateResponse didAuthenticateResult=instance.didAuthenticate(didAthenticate);
  WSHelper.checkResult(didAuthenticateResult);
  assertEquals(didAuthenticateResult.getAuthenticationProtocolData().getProtocol(),ECardConstants.Protocol.PIN_COMPARE);
  assertEquals(didAuthenticateResult.getAuthenticationProtocolData().getAny().size(),0);
  assertEquals(ECardConstants.Major.OK,didAuthenticateResult.getResult().getResultMajor());
  for (int numOfDIDs=0; numOfDIDs < didListResponse.getDIDNameList().getDIDName().size(); numOfDIDs++) {
    String didName=didListResponse.getDIDNameList().getDIDName().get(numOfDIDs);
    System.out.println(didName);
    DIDGet didGet=new DIDGet();
    didGet.setDIDName(didName);
    didGet.setDIDScope(DIDScopeType.LOCAL);
    didGet.setConnectionHandle(result.getConnectionHandle());
    didGet.getConnectionHandle().setCardApplication(cardApplication);
    DIDGetResponse didGetResponse=instance.didGet(didGet);
    org.openecard.common.sal.anytype.CryptoMarkerType cryptoMarker=new org.openecard.common.sal.anytype.CryptoMarkerType((CryptoMarkerType)didGetResponse.getDIDStructure().getDIDMarker());
    Sign sign=new Sign();
    byte[] message=StringUtils.toByteArray(""String_Node_Str"");
    String algorithm=cryptoMarker.getAlgorithmInfo().getAlgorithmIdentifier().getAlgorithm();
    if (algorithm.equals(GenericCryptoObjectIdentifier.sigS_ISO9796_2rnd)) {
      continue;
    }
    sign.setMessage(message);
    sign.setConnectionHandle(result.getConnectionHandle());
    sign.getConnectionHandle().setCardApplication(cardApplication);
    sign.setDIDName(didName);
    sign.setDIDScope(DIDScopeType.LOCAL);
    SignResponse signResponse=instance.sign(sign);
    WSHelper.checkResult(signResponse);
    assertTrue(signResponse.getSignature() != null);
  }
}","/** 
 * Test for the Sign Step of the Generic Cryptography protocol. After we connected to the ESIGN application of the eGK, we use DIDList to get a List of DIDs that support the compute signature function. For each DID we let the card compute a signature. If the result is OK we're satisfied.
 * @throws Exception when something in this test went unexpectedly wrong
 */
@Test public void testSign() throws Exception {
  CardApplicationPath cardApplicationPath=new CardApplicationPath();
  CardApplicationPathType cardApplicationPathType=new CardApplicationPathType();
  cardApplicationPathType.setCardApplication(cardApplication);
  cardApplicationPath.setCardAppPathRequest(cardApplicationPathType);
  CardApplicationPathResponse cardApplicationPathResponse=instance.cardApplicationPath(cardApplicationPath);
  WSHelper.checkResult(cardApplicationPathResponse);
  CardApplicationConnect parameters=new CardApplicationConnect();
  CardAppPathResultSet cardAppPathResultSet=cardApplicationPathResponse.getCardAppPathResultSet();
  parameters.setCardApplicationPath(cardAppPathResultSet.getCardApplicationPathResult().get(0));
  CardApplicationConnectResponse result=instance.cardApplicationConnect(parameters);
  WSHelper.checkResult(result);
  assertEquals(ECardConstants.Major.OK,result.getResult().getResultMajor());
  DIDList didList=new DIDList();
  didList.setConnectionHandle(result.getConnectionHandle());
  DIDQualifierType didQualifier=new DIDQualifierType();
  didQualifier.setApplicationIdentifier(cardApplication);
  didQualifier.setObjectIdentifier(ECardConstants.Protocol.GENERIC_CRYPTO);
  didQualifier.setApplicationFunction(""String_Node_Str"");
  didList.setFilter(didQualifier);
  DIDListResponse didListResponse=instance.didList(didList);
  assertTrue(didListResponse.getDIDNameList().getDIDName().size() > 0);
  WSHelper.checkResult(didListResponse);
  DIDAuthenticate didAthenticate=new DIDAuthenticate();
  didAthenticate.setDIDName(""String_Node_Str"");
  PinCompareDIDAuthenticateInputType didAuthenticationData=new PinCompareDIDAuthenticateInputType();
  didAthenticate.setAuthenticationProtocolData(didAuthenticationData);
  didAthenticate.setConnectionHandle(result.getConnectionHandle());
  didAthenticate.getConnectionHandle().setCardApplication(cardApplication_ROOT);
  didAuthenticationData.setProtocol(ECardConstants.Protocol.PIN_COMPARE);
  didAthenticate.setAuthenticationProtocolData(didAuthenticationData);
  DIDAuthenticateResponse didAuthenticateResult=instance.didAuthenticate(didAthenticate);
  WSHelper.checkResult(didAuthenticateResult);
  assertEquals(didAuthenticateResult.getAuthenticationProtocolData().getProtocol(),ECardConstants.Protocol.PIN_COMPARE);
  assertEquals(didAuthenticateResult.getAuthenticationProtocolData().getAny().size(),0);
  assertEquals(ECardConstants.Major.OK,didAuthenticateResult.getResult().getResultMajor());
  for (int numOfDIDs=0; numOfDIDs < didListResponse.getDIDNameList().getDIDName().size(); numOfDIDs++) {
    String didName=didListResponse.getDIDNameList().getDIDName().get(numOfDIDs);
    System.out.println(didName);
    DIDGet didGet=new DIDGet();
    didGet.setDIDName(didName);
    didGet.setDIDScope(DIDScopeType.LOCAL);
    didGet.setConnectionHandle(result.getConnectionHandle());
    didGet.getConnectionHandle().setCardApplication(cardApplication);
    DIDGetResponse didGetResponse=instance.didGet(didGet);
    org.openecard.crypto.common.sal.CryptoMarkerType cryptoMarker=new org.openecard.crypto.common.sal.CryptoMarkerType((CryptoMarkerType)didGetResponse.getDIDStructure().getDIDMarker());
    Sign sign=new Sign();
    byte[] message=StringUtils.toByteArray(""String_Node_Str"");
    String algorithm=cryptoMarker.getAlgorithmInfo().getAlgorithmIdentifier().getAlgorithm();
    if (algorithm.equals(GenericCryptoObjectIdentifier.sigS_ISO9796_2rnd)) {
      continue;
    }
    sign.setMessage(message);
    sign.setConnectionHandle(result.getConnectionHandle());
    sign.getConnectionHandle().setCardApplication(cardApplication);
    sign.setDIDName(didName);
    sign.setDIDScope(DIDScopeType.LOCAL);
    SignResponse signResponse=instance.sign(sign);
    WSHelper.checkResult(signResponse);
    assertTrue(signResponse.getSignature() != null);
  }
}"
48145,"/** 
 * Test for the Decipher Step of the Generic Cryptography protocol. After we connected to the ESIGN application of the eGK, we use DIDList to get a List of DIDs that support the Decipher function. We then authenticate with PIN.home and read the contents of the DIDs certificate. With it's public key we encrypt the contents of plaintext.txt and finally let the card decrypt it through a call to Decipher. In the end we match the result with the original plaintext.
 * @throws Exception when something in this test went unexpectedly wrong
 */
@Test public void testDecipher() throws Exception {
  CardApplicationPath cardApplicationPath=new CardApplicationPath();
  CardApplicationPathType cardApplicationPathType=new CardApplicationPathType();
  cardApplicationPathType.setCardApplication(cardApplication);
  cardApplicationPath.setCardAppPathRequest(cardApplicationPathType);
  CardApplicationPathResponse cardApplicationPathResponse=instance.cardApplicationPath(cardApplicationPath);
  WSHelper.checkResult(cardApplicationPathResponse);
  CardApplicationConnect parameters=new CardApplicationConnect();
  CardAppPathResultSet cardAppPathResultSet=cardApplicationPathResponse.getCardAppPathResultSet();
  parameters.setCardApplicationPath(cardAppPathResultSet.getCardApplicationPathResult().get(0));
  CardApplicationConnectResponse result=instance.cardApplicationConnect(parameters);
  WSHelper.checkResult(result);
  assertEquals(ECardConstants.Major.OK,result.getResult().getResultMajor());
  DIDList didList=new DIDList();
  didList.setConnectionHandle(result.getConnectionHandle());
  DIDQualifierType didQualifier=new DIDQualifierType();
  didQualifier.setApplicationIdentifier(cardApplication);
  didQualifier.setObjectIdentifier(ECardConstants.Protocol.GENERIC_CRYPTO);
  didQualifier.setApplicationFunction(""String_Node_Str"");
  didList.setFilter(didQualifier);
  DIDListResponse didListResponse=instance.didList(didList);
  assertTrue(didListResponse.getDIDNameList().getDIDName().size() > 0);
  WSHelper.checkResult(didListResponse);
  DIDAuthenticate didAthenticate=new DIDAuthenticate();
  didAthenticate.setDIDName(""String_Node_Str"");
  PinCompareDIDAuthenticateInputType didAuthenticationData=new PinCompareDIDAuthenticateInputType();
  didAthenticate.setAuthenticationProtocolData(didAuthenticationData);
  didAthenticate.setConnectionHandle(result.getConnectionHandle());
  didAthenticate.getConnectionHandle().setCardApplication(cardApplication_ROOT);
  didAuthenticationData.setProtocol(ECardConstants.Protocol.PIN_COMPARE);
  didAthenticate.setAuthenticationProtocolData(didAuthenticationData);
  DIDAuthenticateResponse didAuthenticateResult=instance.didAuthenticate(didAthenticate);
  WSHelper.checkResult(didAuthenticateResult);
  assertEquals(didAuthenticateResult.getAuthenticationProtocolData().getProtocol(),ECardConstants.Protocol.PIN_COMPARE);
  assertEquals(didAuthenticateResult.getAuthenticationProtocolData().getAny().size(),0);
  assertEquals(ECardConstants.Major.OK,didAuthenticateResult.getResult().getResultMajor());
  byte[] plaintextBytes=plaintext.getBytes();
  for (int numOfDIDs=0; numOfDIDs < didListResponse.getDIDNameList().getDIDName().size(); numOfDIDs++) {
    String didName=didListResponse.getDIDNameList().getDIDName().get(numOfDIDs);
    DIDGet didGet=new DIDGet();
    didGet.setDIDName(didName);
    didGet.setDIDScope(DIDScopeType.LOCAL);
    didGet.setConnectionHandle(result.getConnectionHandle());
    didGet.getConnectionHandle().setCardApplication(cardApplication);
    DIDGetResponse didGetResponse=instance.didGet(didGet);
    org.openecard.common.sal.anytype.CryptoMarkerType cryptoMarker=new org.openecard.common.sal.anytype.CryptoMarkerType((CryptoMarkerType)didGetResponse.getDIDStructure().getDIDMarker());
    ByteArrayOutputStream ciphertext=new ByteArrayOutputStream();
    DSIRead dsiRead=new DSIRead();
    dsiRead.setConnectionHandle(result.getConnectionHandle());
    dsiRead.getConnectionHandle().setCardApplication(cardApplication);
    dsiRead.setDSIName(cryptoMarker.getCertificateRef().getDataSetName());
    DSIReadResponse dsiReadResponse=instance.dsiRead(dsiRead);
    assertEquals(ECardConstants.Major.OK,dsiReadResponse.getResult().getResultMajor());
    assertTrue(dsiReadResponse.getDSIContent().length > 0);
    Certificate cert=(X509Certificate)CertificateFactory.getInstance(""String_Node_Str"").generateCertificate(new ByteArrayInputStream(dsiReadResponse.getDSIContent()));
    Cipher cipher;
    int blocksize;
    String algorithmOID=cryptoMarker.getAlgorithmInfo().getAlgorithmIdentifier().getAlgorithm();
    if (algorithmOID.equals(GenericCryptoObjectIdentifier.rsaEncryption)) {
      cipher=Cipher.getInstance(""String_Node_Str"");
      cipher.init(Cipher.ENCRYPT_MODE,cert);
      blocksize=245;
    }
 else     if (algorithmOID.equals(GenericCryptoObjectIdentifier.id_RSAES_OAEP)) {
      cipher=Cipher.getInstance(""String_Node_Str"",new BouncyCastleProvider());
      cipher.init(Cipher.ENCRYPT_MODE,cert);
      blocksize=cipher.getBlockSize();
    }
 else {
      logger.warn(""String_Node_Str"",algorithmOID);
      continue;
    }
    int rest=plaintextBytes.length % blocksize;
    for (int offset=0; offset < plaintextBytes.length; offset+=blocksize) {
      if ((offset + blocksize) > plaintextBytes.length) {
        ciphertext.write(cipher.doFinal(plaintextBytes,offset,rest));
      }
 else {
        ciphertext.write(cipher.doFinal(plaintextBytes,offset,blocksize));
      }
    }
    Decipher decipher=new Decipher();
    decipher.setCipherText(ciphertext.toByteArray());
    decipher.setConnectionHandle(result.getConnectionHandle());
    decipher.getConnectionHandle().setCardApplication(cardApplication);
    decipher.setDIDName(didName);
    decipher.setDIDScope(DIDScopeType.LOCAL);
    DecipherResponse decipherResponse=instance.decipher(decipher);
    assertEquals(decipherResponse.getPlainText(),plaintextBytes);
    decipher=new Decipher();
    decipher.setCipherText(ByteUtils.concatenate((byte)0x00,ciphertext.toByteArray()));
    decipher.setConnectionHandle(result.getConnectionHandle());
    decipher.getConnectionHandle().setCardApplication(cardApplication);
    decipher.setDIDName(didName);
    decipher.setDIDScope(DIDScopeType.LOCAL);
    decipherResponse=instance.decipher(decipher);
    Result res=decipherResponse.getResult();
    assertEquals(res.getResultMajor(),ECardConstants.Major.ERROR);
    assertEquals(res.getResultMinor(),ECardConstants.Minor.App.INCORRECT_PARM);
  }
}","/** 
 * Test for the Decipher Step of the Generic Cryptography protocol. After we connected to the ESIGN application of the eGK, we use DIDList to get a List of DIDs that support the Decipher function. We then authenticate with PIN.home and read the contents of the DIDs certificate. With it's public key we encrypt the contents of plaintext.txt and finally let the card decrypt it through a call to Decipher. In the end we match the result with the original plaintext.
 * @throws Exception when something in this test went unexpectedly wrong
 */
@Test public void testDecipher() throws Exception {
  CardApplicationPath cardApplicationPath=new CardApplicationPath();
  CardApplicationPathType cardApplicationPathType=new CardApplicationPathType();
  cardApplicationPathType.setCardApplication(cardApplication);
  cardApplicationPath.setCardAppPathRequest(cardApplicationPathType);
  CardApplicationPathResponse cardApplicationPathResponse=instance.cardApplicationPath(cardApplicationPath);
  WSHelper.checkResult(cardApplicationPathResponse);
  CardApplicationConnect parameters=new CardApplicationConnect();
  CardAppPathResultSet cardAppPathResultSet=cardApplicationPathResponse.getCardAppPathResultSet();
  parameters.setCardApplicationPath(cardAppPathResultSet.getCardApplicationPathResult().get(0));
  CardApplicationConnectResponse result=instance.cardApplicationConnect(parameters);
  WSHelper.checkResult(result);
  assertEquals(ECardConstants.Major.OK,result.getResult().getResultMajor());
  DIDList didList=new DIDList();
  didList.setConnectionHandle(result.getConnectionHandle());
  DIDQualifierType didQualifier=new DIDQualifierType();
  didQualifier.setApplicationIdentifier(cardApplication);
  didQualifier.setObjectIdentifier(ECardConstants.Protocol.GENERIC_CRYPTO);
  didQualifier.setApplicationFunction(""String_Node_Str"");
  didList.setFilter(didQualifier);
  DIDListResponse didListResponse=instance.didList(didList);
  assertTrue(didListResponse.getDIDNameList().getDIDName().size() > 0);
  WSHelper.checkResult(didListResponse);
  DIDAuthenticate didAthenticate=new DIDAuthenticate();
  didAthenticate.setDIDName(""String_Node_Str"");
  PinCompareDIDAuthenticateInputType didAuthenticationData=new PinCompareDIDAuthenticateInputType();
  didAthenticate.setAuthenticationProtocolData(didAuthenticationData);
  didAthenticate.setConnectionHandle(result.getConnectionHandle());
  didAthenticate.getConnectionHandle().setCardApplication(cardApplication_ROOT);
  didAuthenticationData.setProtocol(ECardConstants.Protocol.PIN_COMPARE);
  didAthenticate.setAuthenticationProtocolData(didAuthenticationData);
  DIDAuthenticateResponse didAuthenticateResult=instance.didAuthenticate(didAthenticate);
  WSHelper.checkResult(didAuthenticateResult);
  assertEquals(didAuthenticateResult.getAuthenticationProtocolData().getProtocol(),ECardConstants.Protocol.PIN_COMPARE);
  assertEquals(didAuthenticateResult.getAuthenticationProtocolData().getAny().size(),0);
  assertEquals(ECardConstants.Major.OK,didAuthenticateResult.getResult().getResultMajor());
  byte[] plaintextBytes=plaintext.getBytes();
  for (int numOfDIDs=0; numOfDIDs < didListResponse.getDIDNameList().getDIDName().size(); numOfDIDs++) {
    String didName=didListResponse.getDIDNameList().getDIDName().get(numOfDIDs);
    DIDGet didGet=new DIDGet();
    didGet.setDIDName(didName);
    didGet.setDIDScope(DIDScopeType.LOCAL);
    didGet.setConnectionHandle(result.getConnectionHandle());
    didGet.getConnectionHandle().setCardApplication(cardApplication);
    DIDGetResponse didGetResponse=instance.didGet(didGet);
    org.openecard.crypto.common.sal.CryptoMarkerType cryptoMarker=new org.openecard.crypto.common.sal.CryptoMarkerType((CryptoMarkerType)didGetResponse.getDIDStructure().getDIDMarker());
    ByteArrayOutputStream ciphertext=new ByteArrayOutputStream();
    DSIRead dsiRead=new DSIRead();
    dsiRead.setConnectionHandle(result.getConnectionHandle());
    dsiRead.getConnectionHandle().setCardApplication(cardApplication);
    dsiRead.setDSIName(cryptoMarker.getCertificateRefs().get(0).getDataSetName());
    DSIReadResponse dsiReadResponse=instance.dsiRead(dsiRead);
    assertEquals(ECardConstants.Major.OK,dsiReadResponse.getResult().getResultMajor());
    assertTrue(dsiReadResponse.getDSIContent().length > 0);
    Certificate cert=(X509Certificate)CertificateFactory.getInstance(""String_Node_Str"").generateCertificate(new ByteArrayInputStream(dsiReadResponse.getDSIContent()));
    Cipher cipher;
    int blocksize;
    String algorithmOID=cryptoMarker.getAlgorithmInfo().getAlgorithmIdentifier().getAlgorithm();
    if (algorithmOID.equals(GenericCryptoObjectIdentifier.rsaEncryption)) {
      cipher=Cipher.getInstance(""String_Node_Str"");
      cipher.init(Cipher.ENCRYPT_MODE,cert);
      blocksize=245;
    }
 else     if (algorithmOID.equals(GenericCryptoObjectIdentifier.id_RSAES_OAEP)) {
      cipher=Cipher.getInstance(""String_Node_Str"",new BouncyCastleProvider());
      cipher.init(Cipher.ENCRYPT_MODE,cert);
      blocksize=cipher.getBlockSize();
    }
 else {
      logger.warn(""String_Node_Str"",algorithmOID);
      continue;
    }
    int rest=plaintextBytes.length % blocksize;
    for (int offset=0; offset < plaintextBytes.length; offset+=blocksize) {
      if ((offset + blocksize) > plaintextBytes.length) {
        ciphertext.write(cipher.doFinal(plaintextBytes,offset,rest));
      }
 else {
        ciphertext.write(cipher.doFinal(plaintextBytes,offset,blocksize));
      }
    }
    Decipher decipher=new Decipher();
    decipher.setCipherText(ciphertext.toByteArray());
    decipher.setConnectionHandle(result.getConnectionHandle());
    decipher.getConnectionHandle().setCardApplication(cardApplication);
    decipher.setDIDName(didName);
    decipher.setDIDScope(DIDScopeType.LOCAL);
    DecipherResponse decipherResponse=instance.decipher(decipher);
    assertEquals(decipherResponse.getPlainText(),plaintextBytes);
    decipher=new Decipher();
    decipher.setCipherText(ByteUtils.concatenate((byte)0x00,ciphertext.toByteArray()));
    decipher.setConnectionHandle(result.getConnectionHandle());
    decipher.getConnectionHandle().setCardApplication(cardApplication);
    decipher.setDIDName(didName);
    decipher.setDIDScope(DIDScopeType.LOCAL);
    decipherResponse=instance.decipher(decipher);
    Result res=decipherResponse.getResult();
    assertEquals(res.getResultMajor(),ECardConstants.Major.ERROR);
    assertEquals(res.getResultMinor(),ECardConstants.Minor.App.INCORRECT_PARM);
  }
}"
48146,"/** 
 * Test for the VerifySignature Step of the Generic Cryptography protocol. After we connected to the ESIGN application of the eGK, we use DIDList to get a List of DIDs that support the compute signature function. We then authenticate with PIN.home and let the card sign our message. Afterwards we call VerifySignature for that signature which should return OK.
 * @throws Exception when something in this test went unexpectedly wrong
 */
@Test public void testVerifySignature() throws Exception {
  CardApplicationPath cardApplicationPath=new CardApplicationPath();
  CardApplicationPathType cardApplicationPathType=new CardApplicationPathType();
  cardApplicationPathType.setCardApplication(cardApplication);
  cardApplicationPath.setCardAppPathRequest(cardApplicationPathType);
  CardApplicationPathResponse cardApplicationPathResponse=instance.cardApplicationPath(cardApplicationPath);
  WSHelper.checkResult(cardApplicationPathResponse);
  CardApplicationConnect parameters=new CardApplicationConnect();
  CardAppPathResultSet cardAppPathResultSet=cardApplicationPathResponse.getCardAppPathResultSet();
  parameters.setCardApplicationPath(cardAppPathResultSet.getCardApplicationPathResult().get(0));
  CardApplicationConnectResponse result=instance.cardApplicationConnect(parameters);
  WSHelper.checkResult(result);
  assertEquals(ECardConstants.Major.OK,result.getResult().getResultMajor());
  DIDList didList=new DIDList();
  didList.setConnectionHandle(result.getConnectionHandle());
  DIDQualifierType didQualifier=new DIDQualifierType();
  didQualifier.setApplicationIdentifier(cardApplication);
  didQualifier.setObjectIdentifier(ECardConstants.Protocol.GENERIC_CRYPTO);
  didQualifier.setApplicationFunction(""String_Node_Str"");
  didList.setFilter(didQualifier);
  DIDListResponse didListResponse=instance.didList(didList);
  assertTrue(didListResponse.getDIDNameList().getDIDName().size() > 0);
  WSHelper.checkResult(didListResponse);
  DIDAuthenticate didAthenticate=new DIDAuthenticate();
  didAthenticate.setDIDName(""String_Node_Str"");
  PinCompareDIDAuthenticateInputType didAuthenticationData=new PinCompareDIDAuthenticateInputType();
  didAthenticate.setAuthenticationProtocolData(didAuthenticationData);
  didAthenticate.setConnectionHandle(result.getConnectionHandle());
  didAthenticate.getConnectionHandle().setCardApplication(cardApplication_ROOT);
  didAuthenticationData.setProtocol(ECardConstants.Protocol.PIN_COMPARE);
  didAthenticate.setAuthenticationProtocolData(didAuthenticationData);
  DIDAuthenticateResponse didAuthenticateResult=instance.didAuthenticate(didAthenticate);
  WSHelper.checkResult(didAuthenticateResult);
  assertEquals(didAuthenticateResult.getAuthenticationProtocolData().getProtocol(),ECardConstants.Protocol.PIN_COMPARE);
  assertEquals(didAuthenticateResult.getAuthenticationProtocolData().getAny().size(),0);
  assertEquals(ECardConstants.Major.OK,didAuthenticateResult.getResult().getResultMajor());
  for (int numOfDIDs=0; numOfDIDs < didListResponse.getDIDNameList().getDIDName().size(); numOfDIDs++) {
    String didName=didListResponse.getDIDNameList().getDIDName().get(numOfDIDs);
    DIDGet didGet=new DIDGet();
    didGet.setDIDName(didName);
    didGet.setDIDScope(DIDScopeType.LOCAL);
    didGet.setConnectionHandle(result.getConnectionHandle());
    didGet.getConnectionHandle().setCardApplication(cardApplication);
    DIDGetResponse didGetResponse=instance.didGet(didGet);
    Sign sign=new Sign();
    byte[] message=new byte[]{0x01,0x02,0x03};
    org.openecard.common.sal.anytype.CryptoMarkerType cryptoMarker=new org.openecard.common.sal.anytype.CryptoMarkerType((CryptoMarkerType)didGetResponse.getDIDStructure().getDIDMarker());
    String algorithmIdentifier=cryptoMarker.getAlgorithmInfo().getAlgorithmIdentifier().getAlgorithm();
    if (algorithmIdentifier.equals(GenericCryptoObjectIdentifier.id_RSASSA_PSS)) {
      MessageDigest messageDigest=MessageDigest.getInstance(""String_Node_Str"");
      message=messageDigest.digest(message);
    }
 else     if (algorithmIdentifier.equals(GenericCryptoObjectIdentifier.pkcs_1)) {
    }
 else {
      logger.warn(""String_Node_Str"",algorithmIdentifier);
      continue;
    }
    sign.setMessage(message);
    sign.setConnectionHandle(result.getConnectionHandle());
    sign.getConnectionHandle().setCardApplication(cardApplication);
    sign.setDIDName(didName);
    sign.setDIDScope(DIDScopeType.LOCAL);
    SignResponse signResponse=instance.sign(sign);
    assertEquals(ECardConstants.Major.OK,signResponse.getResult().getResultMajor());
    WSHelper.checkResult(signResponse);
    byte[] signature=signResponse.getSignature();
    VerifySignature verifySignature=new VerifySignature();
    verifySignature.setConnectionHandle(sign.getConnectionHandle());
    verifySignature.setDIDName(didName);
    verifySignature.setDIDScope(DIDScopeType.LOCAL);
    verifySignature.setMessage(message);
    verifySignature.setSignature(signature);
    VerifySignatureResponse verifySignatureResponse=instance.verifySignature(verifySignature);
    WSHelper.checkResult(verifySignatureResponse);
  }
}","/** 
 * Test for the VerifySignature Step of the Generic Cryptography protocol. After we connected to the ESIGN application of the eGK, we use DIDList to get a List of DIDs that support the compute signature function. We then authenticate with PIN.home and let the card sign our message. Afterwards we call VerifySignature for that signature which should return OK.
 * @throws Exception when something in this test went unexpectedly wrong
 */
@Test public void testVerifySignature() throws Exception {
  CardApplicationPath cardApplicationPath=new CardApplicationPath();
  CardApplicationPathType cardApplicationPathType=new CardApplicationPathType();
  cardApplicationPathType.setCardApplication(cardApplication);
  cardApplicationPath.setCardAppPathRequest(cardApplicationPathType);
  CardApplicationPathResponse cardApplicationPathResponse=instance.cardApplicationPath(cardApplicationPath);
  WSHelper.checkResult(cardApplicationPathResponse);
  CardApplicationConnect parameters=new CardApplicationConnect();
  CardAppPathResultSet cardAppPathResultSet=cardApplicationPathResponse.getCardAppPathResultSet();
  parameters.setCardApplicationPath(cardAppPathResultSet.getCardApplicationPathResult().get(0));
  CardApplicationConnectResponse result=instance.cardApplicationConnect(parameters);
  WSHelper.checkResult(result);
  assertEquals(ECardConstants.Major.OK,result.getResult().getResultMajor());
  DIDList didList=new DIDList();
  didList.setConnectionHandle(result.getConnectionHandle());
  DIDQualifierType didQualifier=new DIDQualifierType();
  didQualifier.setApplicationIdentifier(cardApplication);
  didQualifier.setObjectIdentifier(ECardConstants.Protocol.GENERIC_CRYPTO);
  didQualifier.setApplicationFunction(""String_Node_Str"");
  didList.setFilter(didQualifier);
  DIDListResponse didListResponse=instance.didList(didList);
  assertTrue(didListResponse.getDIDNameList().getDIDName().size() > 0);
  WSHelper.checkResult(didListResponse);
  DIDAuthenticate didAthenticate=new DIDAuthenticate();
  didAthenticate.setDIDName(""String_Node_Str"");
  PinCompareDIDAuthenticateInputType didAuthenticationData=new PinCompareDIDAuthenticateInputType();
  didAthenticate.setAuthenticationProtocolData(didAuthenticationData);
  didAthenticate.setConnectionHandle(result.getConnectionHandle());
  didAthenticate.getConnectionHandle().setCardApplication(cardApplication_ROOT);
  didAuthenticationData.setProtocol(ECardConstants.Protocol.PIN_COMPARE);
  didAthenticate.setAuthenticationProtocolData(didAuthenticationData);
  DIDAuthenticateResponse didAuthenticateResult=instance.didAuthenticate(didAthenticate);
  WSHelper.checkResult(didAuthenticateResult);
  assertEquals(didAuthenticateResult.getAuthenticationProtocolData().getProtocol(),ECardConstants.Protocol.PIN_COMPARE);
  assertEquals(didAuthenticateResult.getAuthenticationProtocolData().getAny().size(),0);
  assertEquals(ECardConstants.Major.OK,didAuthenticateResult.getResult().getResultMajor());
  for (int numOfDIDs=0; numOfDIDs < didListResponse.getDIDNameList().getDIDName().size(); numOfDIDs++) {
    String didName=didListResponse.getDIDNameList().getDIDName().get(numOfDIDs);
    DIDGet didGet=new DIDGet();
    didGet.setDIDName(didName);
    didGet.setDIDScope(DIDScopeType.LOCAL);
    didGet.setConnectionHandle(result.getConnectionHandle());
    didGet.getConnectionHandle().setCardApplication(cardApplication);
    DIDGetResponse didGetResponse=instance.didGet(didGet);
    Sign sign=new Sign();
    byte[] message=new byte[]{0x01,0x02,0x03};
    org.openecard.crypto.common.sal.CryptoMarkerType cryptoMarker=new org.openecard.crypto.common.sal.CryptoMarkerType((CryptoMarkerType)didGetResponse.getDIDStructure().getDIDMarker());
    String algorithmIdentifier=cryptoMarker.getAlgorithmInfo().getAlgorithmIdentifier().getAlgorithm();
    if (algorithmIdentifier.equals(GenericCryptoObjectIdentifier.id_RSASSA_PSS)) {
      MessageDigest messageDigest=MessageDigest.getInstance(""String_Node_Str"");
      message=messageDigest.digest(message);
    }
 else     if (algorithmIdentifier.equals(GenericCryptoObjectIdentifier.pkcs_1)) {
    }
 else {
      logger.warn(""String_Node_Str"",algorithmIdentifier);
      continue;
    }
    sign.setMessage(message);
    sign.setConnectionHandle(result.getConnectionHandle());
    sign.getConnectionHandle().setCardApplication(cardApplication);
    sign.setDIDName(didName);
    sign.setDIDScope(DIDScopeType.LOCAL);
    SignResponse signResponse=instance.sign(sign);
    assertEquals(ECardConstants.Major.OK,signResponse.getResult().getResultMajor());
    WSHelper.checkResult(signResponse);
    byte[] signature=signResponse.getSignature();
    VerifySignature verifySignature=new VerifySignature();
    verifySignature.setConnectionHandle(sign.getConnectionHandle());
    verifySignature.setDIDName(didName);
    verifySignature.setDIDScope(DIDScopeType.LOCAL);
    verifySignature.setMessage(message);
    verifySignature.setSignature(signature);
    VerifySignatureResponse verifySignatureResponse=instance.verifySignature(verifySignature);
    WSHelper.checkResult(verifySignatureResponse);
  }
}"
48147,"/** 
 * Test of cardApplicationDelete method, of class TinySAL.
 */
@Test(enabled=false) public void testCardApplicationDelete(){
  System.out.println(""String_Node_Str"");
  List<ConnectionHandleType> cHandles=instance.getConnectionHandles();
  byte[] appName={(byte)0x74,(byte)0x65,(byte)0x73,(byte)0x74};
  CardApplicationDelete parameters=new CardApplicationDelete();
  parameters.setConnectionHandle(cHandles.get(0));
  parameters.setCardApplicationName(appName);
  CardApplicationDeleteResponse result=instance.cardApplicationDelete(parameters);
  assertEquals(ECardConstants.Major.OK,result.getResult().getResultMajor());
  CardApplicationPath cardApplicationPath=new CardApplicationPath();
  CardApplicationPathType cardApplicationPathType=new CardApplicationPathType();
  cardApplicationPathType.setCardApplication(appIdentifier_ESIGN);
  cardApplicationPath.setCardAppPathRequest(cardApplicationPathType);
  CardApplicationPathResponse cardApplicationPathResponse=instance.cardApplicationPath(cardApplicationPath);
  CardApplicationConnect cardApplicationConnect=new CardApplicationConnect();
  cardApplicationConnect.setCardApplicationPath(cardApplicationPathResponse.getCardAppPathResultSet().getCardApplicationPathResult().get(0));
  CardApplicationConnectResponse resultConnect=instance.cardApplicationConnect(cardApplicationConnect);
  assertEquals(ECardConstants.Major.OK,resultConnect.getResult().getResultMajor());
  CardApplicationList cardApplicationList=new CardApplicationList();
  cardApplicationList.setConnectionHandle(cHandles.get(0));
  CardApplicationListResponse cardApplicationListResponse=instance.cardApplicationList(cardApplicationList);
  Iterator<byte[]> it=cardApplicationListResponse.getCardApplicationNameList().getCardApplicationName().iterator();
  boolean appFound=false;
  try {
    while (it.hasNext()) {
      byte[] val=it.next();
      if (Arrays.equals(val,appName))       appFound=true;
    }
    assertTrue(!appFound);
  }
 catch (  Exception e) {
    assertTrue(appFound);
    System.out.println(e);
  }
}","/** 
 * Test of cardApplicationDelete method, of class TinySAL.
 */
@Test(enabled=false) public void testCardApplicationDelete(){
  System.out.println(""String_Node_Str"");
  List<ConnectionHandleType> cHandles=instance.getConnectionHandles();
  byte[] appName={(byte)0x74,(byte)0x65,(byte)0x73,(byte)0x74};
  CardApplicationDelete parameters=new CardApplicationDelete();
  parameters.setConnectionHandle(cHandles.get(0));
  parameters.setCardApplicationName(appName);
  CardApplicationDeleteResponse result=instance.cardApplicationDelete(parameters);
  assertEquals(ECardConstants.Major.OK,result.getResult().getResultMajor());
  CardApplicationPath cardApplicationPath=new CardApplicationPath();
  CardApplicationPathType cardApplicationPathType=new CardApplicationPathType();
  cardApplicationPathType.setCardApplication(appIdentifier_ESIGN);
  cardApplicationPath.setCardAppPathRequest(cardApplicationPathType);
  CardApplicationPathResponse cardApplicationPathResponse=instance.cardApplicationPath(cardApplicationPath);
  CardApplicationConnect cardApplicationConnect=new CardApplicationConnect();
  cardApplicationConnect.setCardApplicationPath(cardApplicationPathResponse.getCardAppPathResultSet().getCardApplicationPathResult().get(0));
  CardApplicationConnectResponse resultConnect=instance.cardApplicationConnect(cardApplicationConnect);
  assertEquals(ECardConstants.Major.OK,resultConnect.getResult().getResultMajor());
  CardApplicationList cardApplicationList=new CardApplicationList();
  cardApplicationList.setConnectionHandle(cHandles.get(0));
  CardApplicationListResponse cardApplicationListResponse=instance.cardApplicationList(cardApplicationList);
  Iterator<byte[]> it=cardApplicationListResponse.getCardApplicationNameList().getCardApplicationName().iterator();
  boolean appFound=false;
  try {
    while (it.hasNext()) {
      byte[] val=it.next();
      if (Arrays.equals(val,appName))       appFound=true;
    }
    assertTrue(!appFound);
  }
 catch (  Exception e) {
    assertTrue(!appFound);
    System.out.println(e);
  }
}"
48148,"/** 
 * A new card application is created on an eCard with the CardApplicationCreate function. See BSI-TR-03112-4, version 1.1.2, section 3.3.2.
 * @param request CardApplicationCreate
 * @return CardApplicationCreateResponse
 */
@Override public CardApplicationCreateResponse cardApplicationCreate(CardApplicationCreate request){
  CardApplicationCreateResponse response=WSHelper.makeResponse(CardApplicationCreateResponse.class,WSHelper.makeResultOK());
  try {
    ConnectionHandleType connectionHandle=SALUtils.getConnectionHandle(request);
    CardStateEntry cardStateEntry=states.getEntry(connectionHandle,false);
    SALUtils.getCardStateEntry(states,connectionHandle);
    byte[] cardApplicationName=request.getCardApplicationName();
    Assert.assertIncorrectParameter(cardApplicationName,""String_Node_Str"");
    AccessControlListType cardApplicationACL=request.getCardApplicationACL();
    Assert.assertIncorrectParameter(cardApplicationACL,""String_Node_Str"");
    CardApplicationType cardApplicationType=new CardApplicationType();
    cardApplicationType.setApplicationIdentifier(cardApplicationName);
    cardApplicationType.setCardApplicationACL(cardApplicationACL);
    CardInfoWrapper cardInfoWrapper=cardStateEntry.getInfo();
    cardInfoWrapper.getApplicationCapabilities().getCardApplication().add(cardApplicationType);
  }
 catch (  ECardException e) {
    response.setResult(e.getResult());
  }
catch (  Exception e) {
    logger.error(e.getMessage(),e);
    response.setResult(WSHelper.makeResult(e));
  }
  return response;
}","/** 
 * A new card application is created on an eCard with the CardApplicationCreate function. See BSI-TR-03112-4, version 1.1.2, section 3.3.2.
 * @param request CardApplicationCreate
 * @return CardApplicationCreateResponse
 */
@Override public CardApplicationCreateResponse cardApplicationCreate(CardApplicationCreate request){
  CardApplicationCreateResponse response=WSHelper.makeResponse(CardApplicationCreateResponse.class,WSHelper.makeResultOK());
  try {
    ConnectionHandleType connectionHandle=SALUtils.getConnectionHandle(request);
    CardStateEntry cardStateEntry=states.getEntry(connectionHandle,false);
    byte[] cardApplicationName=request.getCardApplicationName();
    Assert.assertIncorrectParameter(cardApplicationName,""String_Node_Str"");
    AccessControlListType cardApplicationACL=request.getCardApplicationACL();
    Assert.assertIncorrectParameter(cardApplicationACL,""String_Node_Str"");
    CardApplicationType cardApplicationType=new CardApplicationType();
    cardApplicationType.setApplicationIdentifier(cardApplicationName);
    cardApplicationType.setCardApplicationACL(cardApplicationACL);
    CardInfoWrapper cardInfoWrapper=cardStateEntry.getInfo();
    cardInfoWrapper.getApplicationCapabilities().getCardApplication().add(cardApplicationType);
  }
 catch (  ECardException e) {
    response.setResult(e.getResult());
  }
catch (  Exception e) {
    logger.error(e.getMessage(),e);
    response.setResult(WSHelper.makeResult(e));
  }
  return response;
}"
48149,"/** 
 * Gets the thread local instance of the context. If no instance exists yet, a new one is created possibly based on the one from the parent thread.
 * @return The DynamicContext instance of this thread.
 */
@Nonnull public static DynamicContext getInstance(@Nonnull String key){
  final Map<String,DynamicContext> local=localMap.get();
synchronized (local) {
    DynamicContext inst;
    if (local.containsKey(key)) {
      inst=local.get(key);
    }
 else {
      inst=new DynamicContext();
      local.put(key,inst);
    }
    return inst;
  }
}","/** 
 * Gets the thread local instance of the context. If no instance exists yet, a new one is created possibly based on the one from the parent thread.
 * @param key Lookup key for the desired variable.
 * @return The DynamicContext instance of this thread.
 */
@Nonnull public static DynamicContext getInstance(@Nonnull String key){
  final Map<String,DynamicContext> local=localMap.get();
synchronized (local) {
    DynamicContext inst;
    if (local.containsKey(key)) {
      inst=local.get(key);
    }
 else {
      inst=new DynamicContext();
      local.put(key,inst);
    }
    return inst;
  }
}"
48150,"/** 
 * Performs the actual PAOS procedure. Connects the given card, establishes the HTTP channel and talks to the server. Afterwards disconnects the card.
 * @param token The TCToken containing the connection parameters.
 * @param connectionHandle The handle of the card that will be used.
 * @return A TCTokenResponse indicating success or failure.
 * @throws DispatcherException If there was a problem dispatching a request from the server.
 * @throws PAOSException If there was a transport error.
 */
private TCTokenResponse processBinding(TCTokenRequest tokenRequest,ConnectionHandleType connectionHandle) throws PAOSException, DispatcherException {
  TCTokenType token=tokenRequest.getTCToken();
  try {
    connectionHandle=prepareHandle(connectionHandle);
    TCTokenResponse response=new TCTokenResponse();
    response.setRefreshAddress(new URL(token.getRefreshAddress()));
    response.setResult(WSHelper.makeResultOK());
    String binding=token.getBinding();
    if (""String_Node_Str"".equals(binding)) {
      PAOSTask task=new PAOSTask(dispatcher,connectionHandle,tokenRequest);
      FutureTask<StartPAOSResponse> paosTask=new FutureTask<StartPAOSResponse>(task);
      Thread paosThread=new Thread(paosTask,""String_Node_Str"");
      paosThread.start();
      if (!tokenRequest.isTokenFromObject()) {
        waitForTask(paosTask);
      }
      response.setBindingTask(paosTask);
    }
 else     if (binding == null) {
      HttpGetTask task=new HttpGetTask(dispatcher,connectionHandle,tokenRequest);
      FutureTask<StartPAOSResponse> tlsTask=new FutureTask<StartPAOSResponse>(task);
      waitForTask(tlsTask);
      response.setBindingTask(tlsTask);
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
    return response;
  }
 catch (  WSException ex) {
    String msg=""String_Node_Str"";
    logger.error(msg,ex);
    throw new DispatcherException(msg,ex);
  }
catch (  InvocationTargetException ex) {
    logger.error(ex.getMessage(),ex);
    throw new DispatcherException(ex);
  }
catch (  MalformedURLException ex) {
    logger.error(ex.getMessage(),ex);
    throw new PAOSException(ex);
  }
 finally {
    try {
      CardApplicationDisconnect appDis=new CardApplicationDisconnect();
      appDis.setConnectionHandle(connectionHandle);
      dispatcher.deliver(appDis);
    }
 catch (    InvocationTargetException ex) {
      logger.error(ex.getMessage(),ex);
      throw new DispatcherException(ex);
    }
  }
}","/** 
 * Performs the actual PAOS procedure. Connects the given card, establishes the HTTP channel and talks to the server. Afterwards disconnects the card.
 * @param token The TCToken containing the connection parameters.
 * @param connectionHandle The handle of the card that will be used.
 * @return A TCTokenResponse indicating success or failure.
 * @throws DispatcherException If there was a problem dispatching a request from the server.
 * @throws PAOSException If there was a transport error.
 */
private TCTokenResponse processBinding(TCTokenRequest tokenRequest,ConnectionHandleType connectionHandle) throws PAOSException, DispatcherException {
  TCTokenType token=tokenRequest.getTCToken();
  try {
    connectionHandle=prepareHandle(connectionHandle);
    TCTokenResponse response=new TCTokenResponse();
    response.setRefreshAddress(new URL(token.getRefreshAddress()));
    response.setResult(WSHelper.makeResultOK());
    String binding=token.getBinding();
    if (""String_Node_Str"".equals(binding)) {
      PAOSTask task=new PAOSTask(dispatcher,connectionHandle,tokenRequest);
      FutureTask<StartPAOSResponse> paosTask=new FutureTask<StartPAOSResponse>(task);
      Thread paosThread=new Thread(paosTask,""String_Node_Str"");
      paosThread.start();
      if (!tokenRequest.isTokenFromObject()) {
        waitForTask(paosTask);
      }
      response.setBindingTask(paosTask);
    }
 else     if (""String_Node_Str"".equals(binding)) {
      HttpGetTask task=new HttpGetTask(dispatcher,connectionHandle,tokenRequest);
      FutureTask<StartPAOSResponse> tlsTask=new FutureTask<StartPAOSResponse>(task);
      Thread tlsThread=new Thread(tlsTask,""String_Node_Str"");
      tlsThread.start();
      waitForTask(tlsTask);
      response.setBindingTask(tlsTask);
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
    return response;
  }
 catch (  WSException ex) {
    String msg=""String_Node_Str"";
    logger.error(msg,ex);
    throw new DispatcherException(msg,ex);
  }
catch (  InvocationTargetException ex) {
    logger.error(ex.getMessage(),ex);
    throw new DispatcherException(ex);
  }
catch (  MalformedURLException ex) {
    logger.error(ex.getMessage(),ex);
    throw new PAOSException(ex);
  }
 finally {
    try {
      CardApplicationDisconnect appDis=new CardApplicationDisconnect();
      appDis.setConnectionHandle(connectionHandle);
      dispatcher.deliver(appDis);
    }
 catch (    InvocationTargetException ex) {
      logger.error(ex.getMessage(),ex);
      throw new DispatcherException(ex);
    }
  }
}"
48151,"/** 
 * Verifies the PathSecurity-Parameter element of the TCToken.
 * @throws Exception
 */
public void verifyPathSecurityParameters() throws TCTokenException {
  try {
    if (token.getPathSecurityProtocol().equals(""String_Node_Str"") || token.getPathSecurityProtocol().equals(""String_Node_Str"")) {
      TCTokenType.PathSecurityParameters psp=token.getPathSecurityParameters();
      if (!checkEmpty(psp)) {
        assertRequired(psp.getPSK());
        checkPSKLength(ByteUtils.toHexString(psp.getPSK()));
      }
    }
  }
 catch (  TCTokenException e) {
    throw new TCTokenException(""String_Node_Str"");
  }
}","/** 
 * Verifies the PathSecurity-Parameter element of the TCToken.
 * @throws TCTokenException
 */
public void verifyPathSecurityParameters() throws TCTokenException {
  try {
    if (token.getPathSecurityProtocol().equals(""String_Node_Str"") || token.getPathSecurityProtocol().equals(""String_Node_Str"")) {
      TCTokenType.PathSecurityParameters psp=token.getPathSecurityParameters();
      if (!checkEmpty(psp)) {
        assertRequired(psp.getPSK());
        checkPSKLength(ByteUtils.toHexString(psp.getPSK()));
      }
    }
  }
 catch (  TCTokenException e) {
    throw new TCTokenException(""String_Node_Str"");
  }
}"
48152,"/** 
 * Verifies the Binding element of the TCToken.
 * @throws Exception
 */
public void verifyBinding() throws TCTokenException {
  try {
    String value=token.getBinding();
    assertRequired(value);
    checkEqual(value,""String_Node_Str"");
  }
 catch (  TCTokenException e) {
    throw new TCTokenException(""String_Node_Str"");
  }
}","/** 
 * Verifies the Binding element of the TCToken.
 * @throws TCTokenException
 */
public void verifyBinding() throws TCTokenException {
  try {
    String value=token.getBinding();
    assertRequired(value);
    checkEqualOR(value,""String_Node_Str"",""String_Node_Str"");
  }
 catch (  TCTokenException e) {
    throw new TCTokenException(""String_Node_Str"");
  }
}"
48153,"/** 
 * Verifies the SessionIdentifier element of the TCToken.
 * @throws Exception
 */
public void verifySessionIdentifier() throws TCTokenException {
  try {
    String value=token.getSessionIdentifier();
    assertRequired(value);
  }
 catch (  TCTokenException e) {
    throw new TCTokenException(""String_Node_Str"");
  }
}","/** 
 * Verifies the SessionIdentifier element of the TCToken.
 * @throws TCTokenException
 */
public void verifySessionIdentifier() throws TCTokenException {
  try {
    String value=token.getSessionIdentifier();
    assertRequired(value);
  }
 catch (  TCTokenException e) {
    throw new TCTokenException(""String_Node_Str"");
  }
}"
48154,"/** 
 * Verifies the ServerAddress element of the TCToken.
 * @throws Exception
 */
public void verifyServerAddress() throws TCTokenException {
  try {
    String value=token.getServerAddress();
    assertURL(value);
    assertRequired(value);
  }
 catch (  TCTokenException e) {
    throw new TCTokenException(""String_Node_Str"");
  }
}","/** 
 * Verifies the ServerAddress element of the TCToken.
 * @throws TCTokenException
 */
public void verifyServerAddress() throws TCTokenException {
  try {
    String value=token.getServerAddress();
    assertURL(value);
    assertRequired(value);
  }
 catch (  TCTokenException e) {
    throw new TCTokenException(""String_Node_Str"");
  }
}"
48155,"/** 
 * Verifies the PathSecurity-Protocol element of the TCToken.
 * @throws Exception
 */
public void verifyPathSecurityProtocol() throws TCTokenException {
  try {
    String value=token.getPathSecurityProtocol();
    if (!checkEmpty(value)) {
      checkEqualOR(value,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  TCTokenException e) {
    throw new TCTokenException(""String_Node_Str"");
  }
}","/** 
 * Verifies the PathSecurity-Protocol element of the TCToken.
 * @throws TCTokenException
 */
public void verifyPathSecurityProtocol() throws TCTokenException {
  try {
    String value=token.getPathSecurityProtocol();
    if (!checkEmpty(value)) {
      checkEqualOR(value,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    }
  }
 catch (  TCTokenException e) {
    throw new TCTokenException(""String_Node_Str"");
  }
}"
48156,"/** 
 * Verifies the RefreshAddress element of the TCToken.
 * @throws Exception
 */
public void verifyRefreshAddress() throws TCTokenException {
  try {
    String value=token.getRefreshAddress();
    assertURL(value);
    assertRequired(value);
  }
 catch (  TCTokenException e) {
    throw new TCTokenException(""String_Node_Str"");
  }
}","/** 
 * Verifies the RefreshAddress element of the TCToken.
 * @throws TCTokenException
 */
public void verifyRefreshAddress() throws TCTokenException {
  try {
    String value=token.getRefreshAddress();
    assertURL(value);
    assertRequired(value);
  }
 catch (  TCTokenException e) {
    throw new TCTokenException(""String_Node_Str"");
  }
}"
48157,"@Override public void init(Context aCtx) throws ActionInitializationException {
  this.dispatcher=aCtx.getDispatcher();
  this.gui=aCtx.getUserConsent();
  this.recognition=aCtx.getRecognition();
}","@Override public void init(Context ctx) throws ActionInitializationException {
  this.dispatcher=ctx.getDispatcher();
  this.gui=ctx.getUserConsent();
  this.recognition=ctx.getRecognition();
  this.cardStates=ctx.getCardStates();
}"
48158,"@Override public void init(Context aCtx) throws ActionInitializationException {
  this.dispatcher=aCtx.getDispatcher();
  this.gui=aCtx.getUserConsent();
  this.recognition=aCtx.getRecognition();
}","@Override public void init(Context aCtx) throws ActionInitializationException {
  this.dispatcher=aCtx.getDispatcher();
  this.gui=aCtx.getUserConsent();
  this.recognition=aCtx.getRecognition();
  this.cardStates=aCtx.getCardStates();
}"
48159,"@Override protected void saveProperties() throws IOException, SecurityException {
  String path=FileUtils.getHomeConfigDir().getAbsolutePath() + File.separatorChar + ""String_Node_Str""+ File.separatorChar+ desc.getId()+ ""String_Node_Str"";
  File config=new File(path);
  FileWriter writer=new FileWriter(config);
  properties.store(writer,null);
}","@Override protected void saveProperties() throws IOException, SecurityException {
  File home=FileUtils.getHomeConfigDir();
  File path=new File(home,""String_Node_Str"");
  path=new File(path,desc.getId());
  File config=new File(path,""String_Node_Str"" + ""String_Node_Str"");
  FileWriter writer=new FileWriter(config);
  properties.store(writer,null);
}"
48160,"DefaultSettingsGroup(String title,Properties properties,AddonSpecification desc){
  super(title,properties);
  this.desc=desc;
  for (  ConfigurationEntry entry : desc.getConfigDescription().getEntries()) {
    String name=entry.getLocalizedName(LANGUAGE_CODE);
    String description=entry.getLocalizedDescription(LANGUAGE_CODE);
    if (entry instanceof ScalarEntry) {
      ScalarEntry scalarEntry=(ScalarEntry)entry;
      if (scalarEntry.getType().equalsIgnoreCase(""String_Node_Str"")) {
        addInputItem(name,description,entry.getKey());
      }
 else       if (scalarEntry.getType().equalsIgnoreCase(""String_Node_Str"")) {
        addBoolItem(name,description,entry.getKey());
      }
 else {
        logger.error(""String_Node_Str"",scalarEntry.getType());
      }
    }
 else     if (entry instanceof ScalarListEntry) {
      addListInputItem(name,description,entry.getKey());
    }
 else {
      logger.error(""String_Node_Str"",entry.getClass().getName());
    }
  }
}","DefaultSettingsGroup(String title,Properties properties,AddonSpecification desc){
  super(title,properties);
  this.desc=desc;
  for (  ConfigurationEntry entry : desc.getConfigDescription().getEntries()) {
    String name=entry.getLocalizedName(LANGUAGE_CODE);
    String description=entry.getLocalizedDescription(LANGUAGE_CODE);
    if (ScalarEntry.class.equals(entry.getClass())) {
      ScalarEntry scalarEntry=(ScalarEntry)entry;
      if (scalarEntry.getType().equalsIgnoreCase(""String_Node_Str"")) {
        addInputItem(name,description,entry.getKey());
      }
 else       if (scalarEntry.getType().equalsIgnoreCase(""String_Node_Str"")) {
        addBoolItem(name,description,entry.getKey());
      }
 else {
        logger.error(""String_Node_Str"",scalarEntry.getType());
      }
    }
 else     if (ScalarListEntry.class.equals(entry.getClass())) {
      addListInputItem(name,description,entry.getKey());
    }
 else {
      logger.error(""String_Node_Str"",entry.getClass().getName());
    }
  }
}"
48161,"private void createCoreList(){
  JLabel label=new JLabel(lang.translationForKey(""String_Node_Str""));
  label.setFont(label.getFont().deriveFont(Font.BOLD));
  GridBagConstraints labelConstraints=new GridBagConstraints();
  labelConstraints.insets=new Insets(5,0,5,10);
  labelConstraints.anchor=GridBagConstraints.NORTH;
  labelConstraints.gridx=0;
  labelConstraints.gridy=1;
  selectionPanel.add(label,labelConstraints);
  coreList=new JList();
  coreList.setFont(coreList.getFont().deriveFont(Font.PLAIN));
  coreList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  GridBagConstraints coreListConstraints=new GridBagConstraints();
  coreListConstraints.fill=GridBagConstraints.HORIZONTAL;
  coreListConstraints.insets=new Insets(0,5,5,10);
  coreListConstraints.anchor=GridBagConstraints.NORTH;
  coreListConstraints.gridx=0;
  coreListConstraints.gridy=2;
  AddonSelectionModel model=new AddonSelectionModel(this,addonPanel);
  coreList.setModel(model);
  coreList.addListSelectionListener(model);
  addWindowListener(model);
  model.addElement(lang.translationForKey(""String_Node_Str""),new ConnectionSettingsAddon());
  for (  AddonSpecification desc : cpReg.listAddons()) {
    ArrayList<AppExtensionSpecification> applicationActions=desc.getApplicationActions();
    if (applicationActions.size() > 0) {
      String description=desc.getLocalizedDescription(LANGUAGE_CODE);
      String name=desc.getLocalizedName(LANGUAGE_CODE);
      Image logo=loadLogo(desc.getLogo());
      JPanel actionPanel=createActionPanel(desc);
      AddonPanel addonPanel=new AddonPanel(actionPanel,name,description,logo);
      model.addElement(name,addonPanel);
    }
  }
  selectionPanel.add(coreList,coreListConstraints);
}","private void createCoreList(){
  JLabel label=new JLabel(lang.translationForKey(""String_Node_Str""));
  label.setFont(label.getFont().deriveFont(Font.BOLD));
  GridBagConstraints labelConstraints=new GridBagConstraints();
  labelConstraints.insets=new Insets(5,0,5,10);
  labelConstraints.anchor=GridBagConstraints.NORTH;
  labelConstraints.gridx=0;
  labelConstraints.gridy=1;
  selectionPanel.add(label,labelConstraints);
  coreList=new JList();
  coreList.setFont(coreList.getFont().deriveFont(Font.PLAIN));
  coreList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  GridBagConstraints coreListConstraints=new GridBagConstraints();
  coreListConstraints.fill=GridBagConstraints.HORIZONTAL;
  coreListConstraints.insets=new Insets(0,5,5,10);
  coreListConstraints.anchor=GridBagConstraints.NORTH;
  coreListConstraints.gridx=0;
  coreListConstraints.gridy=2;
  AddonSelectionModel model=new AddonSelectionModel(this,addonPanel);
  coreList.setModel(model);
  coreList.addListSelectionListener(model);
  addWindowListener(model);
  model.addElement(lang.translationForKey(""String_Node_Str""),new ConnectionSettingsAddon());
  for (  AddonSpecification desc : cpReg.listAddons()) {
    ArrayList<AppExtensionSpecification> applicationActions=desc.getApplicationActions();
    if (applicationActions.size() > 0) {
      String description=desc.getLocalizedDescription(LANGUAGE_CODE);
      String name=desc.getLocalizedName(LANGUAGE_CODE);
      Image logo=loadLogo(desc.getLogo());
      JPanel actionPanel=createActionPanel(desc);
      AddonPanel nextPanel=new AddonPanel(actionPanel,name,description,logo);
      model.addElement(name,nextPanel);
    }
  }
  selectionPanel.add(coreList,coreListConstraints);
}"
48162,"private void createAddonList(){
  JLabel label=new JLabel(lang.translationForKey(""String_Node_Str""));
  label.setFont(label.getFont().deriveFont(Font.BOLD));
  GridBagConstraints labelConstraints=new GridBagConstraints();
  labelConstraints.insets=new Insets(5,0,5,10);
  labelConstraints.anchor=GridBagConstraints.NORTH;
  labelConstraints.gridx=0;
  labelConstraints.gridy=3;
  selectionPanel.add(label,labelConstraints);
  addonList=new JList();
  addonList.setFont(addonList.getFont().deriveFont(Font.PLAIN));
  addonList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  GridBagConstraints addonListConstraints=new GridBagConstraints();
  addonListConstraints.insets=new Insets(0,5,5,10);
  addonListConstraints.fill=GridBagConstraints.HORIZONTAL;
  addonListConstraints.anchor=GridBagConstraints.NORTH;
  addonListConstraints.gridx=0;
  addonListConstraints.gridy=4;
  AddonSelectionModel model=new AddonSelectionModel(this,addonPanel);
  addonList.setModel(model);
  addonList.addListSelectionListener(model);
  addWindowListener(model);
  for (  AddonSpecification desc : fileReg.listAddons()) {
    String description=desc.getLocalizedDescription(LANGUAGE_CODE);
    String name=desc.getLocalizedName(LANGUAGE_CODE);
    Image logo=loadLogo(desc.getLogo());
    Properties properties=new Properties();
    try {
      File config=new File(FileUtils.getHomeConfigDir().getAbsolutePath() + File.separatorChar + ""String_Node_Str""+ File.separatorChar+ desc.getId()+ ""String_Node_Str"");
      if (config.exists()) {
        properties.load(new FileReader(config));
      }
 else {
        logger.debug(""String_Node_Str"",desc.getId());
      }
    }
 catch (    SecurityException e) {
      logger.error(""String_Node_Str"" + desc.getId(),e);
    }
catch (    IOException e) {
      logger.error(""String_Node_Str"" + desc.getId(),e);
    }
    SettingsGroup settingsGroup=new DefaultSettingsGroup(""String_Node_Str"",properties,desc);
    AddonPanel addonPanel=new AddonPanel(new DefaultSettingsPanel(settingsGroup),name,description,logo);
    model.addElement(name,addonPanel);
  }
  selectionPanel.add(addonList,addonListConstraints);
}","private void createAddonList(){
  JLabel label=new JLabel(lang.translationForKey(""String_Node_Str""));
  label.setFont(label.getFont().deriveFont(Font.BOLD));
  GridBagConstraints labelConstraints=new GridBagConstraints();
  labelConstraints.insets=new Insets(5,0,5,10);
  labelConstraints.anchor=GridBagConstraints.NORTH;
  labelConstraints.gridx=0;
  labelConstraints.gridy=3;
  selectionPanel.add(label,labelConstraints);
  addonList=new JList();
  addonList.setFont(addonList.getFont().deriveFont(Font.PLAIN));
  addonList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  GridBagConstraints addonListConstraints=new GridBagConstraints();
  addonListConstraints.insets=new Insets(0,5,5,10);
  addonListConstraints.fill=GridBagConstraints.HORIZONTAL;
  addonListConstraints.anchor=GridBagConstraints.NORTH;
  addonListConstraints.gridx=0;
  addonListConstraints.gridy=4;
  AddonSelectionModel model=new AddonSelectionModel(this,addonPanel);
  addonList.setModel(model);
  addonList.addListSelectionListener(model);
  addWindowListener(model);
  for (  AddonSpecification desc : fileReg.listAddons()) {
    String description=desc.getLocalizedDescription(LANGUAGE_CODE);
    String name=desc.getLocalizedName(LANGUAGE_CODE);
    Image logo=loadLogo(desc.getLogo());
    Properties properties=new Properties();
    try {
      File config=new File(FileUtils.getHomeConfigDir().getAbsolutePath() + File.separatorChar + ""String_Node_Str""+ File.separatorChar+ desc.getId()+ ""String_Node_Str"");
      if (config.exists()) {
        properties.load(new FileReader(config));
      }
 else {
        logger.debug(""String_Node_Str"",desc.getId());
      }
    }
 catch (    SecurityException e) {
      logger.error(""String_Node_Str"" + desc.getId(),e);
    }
catch (    IOException e) {
      logger.error(""String_Node_Str"" + desc.getId(),e);
    }
    SettingsGroup settingsGroup=new DefaultSettingsGroup(""String_Node_Str"",properties,desc);
    AddonPanel nextPanel=new AddonPanel(new DefaultSettingsPanel(settingsGroup),name,description,logo);
    model.addElement(name,nextPanel);
  }
  selectionPanel.add(addonList,addonListConstraints);
}"
48163,"protected void addListInputItem(@Nonnull String name,@Nullable String description,final @Nonnull String property){
  JLabel label=addLabel(name,description);
  String values=properties.getProperty(property);
  String[] entries=values.split(""String_Node_Str"");
  Vector<Vector<String>> rowData=new Vector<Vector<String>>();
  Vector<String> columnData=new Vector<String>();
  columnData.add(""String_Node_Str"");
  columnData.add(""String_Node_Str"");
  final DefaultTableModel model=new DefaultTableModel(){
    @Override public void setValueAt(    Object aValue,    int row,    int column){
      super.setValueAt(aValue,row,column);
      if (!aValue.toString().trim().isEmpty()) {
        if (shouldAddRow(row,column)) {
          addRow(new Object[]{});
        }
      }
    }
    private boolean shouldAddRow(    int lastEditedRow,    int lastEditedColumn){
      return lastEditedRow == getRowCount() - 1;
    }
  }
;
  model.addTableModelListener(new TableModelListener(){
    @Override public void tableChanged(    TableModelEvent e){
      StringBuilder sb=new StringBuilder();
      for (int rowNumber=0; rowNumber < model.getRowCount(); rowNumber++) {
        for (int columnNumber=0; columnNumber < model.getColumnCount(); columnNumber++) {
          Object valueAt=model.getValueAt(rowNumber,columnNumber);
          if (valueAt != null && !valueAt.toString().trim().isEmpty()) {
            sb.append(valueAt.toString());
            if (columnNumber == model.getColumnCount() - 1) {
              sb.append(""String_Node_Str"");
            }
 else {
              sb.append(""String_Node_Str"");
            }
          }
        }
      }
      properties.setProperty(property,sb.toString());
    }
  }
);
  for (  String entry : entries) {
    if (entry.split(""String_Node_Str"").length < 2) {
      continue;
    }
    String key=entry.split(""String_Node_Str"")[0];
    String value=entry.split(""String_Node_Str"")[1];
    Vector<String> row=new Vector<String>();
    row.add(key);
    row.add(value);
    rowData.add(row);
  }
  JTable jTable=new JTable(model);
  model.setDataVector(rowData,columnData);
  model.addRow(new Object[]{});
  fieldLabels.put(jTable,label);
  addComponent(jTable);
  itemIdx++;
  return;
}","protected void addListInputItem(@Nonnull String name,@Nullable String description,final @Nonnull String property){
  JLabel label=addLabel(name,description);
  String values=properties.getProperty(property);
  String[] entries;
  if (values == null) {
    entries=new String[0];
  }
 else {
    entries=values.split(""String_Node_Str"");
  }
  Vector<Vector<String>> rowData=new Vector<Vector<String>>();
  Vector<String> columnData=new Vector<String>();
  columnData.add(""String_Node_Str"");
  columnData.add(""String_Node_Str"");
  final DefaultTableModel model=new DefaultTableModel(){
    @Override public void setValueAt(    Object aValue,    int row,    int column){
      super.setValueAt(aValue,row,column);
      if (!aValue.toString().trim().isEmpty()) {
        if (shouldAddRow(row,column)) {
          addRow(new Object[]{});
        }
      }
    }
    private boolean shouldAddRow(    int lastEditedRow,    int lastEditedColumn){
      return lastEditedRow == getRowCount() - 1;
    }
  }
;
  model.addTableModelListener(new TableModelListener(){
    @Override public void tableChanged(    TableModelEvent e){
      StringBuilder sb=new StringBuilder();
      for (int rowNumber=0; rowNumber < model.getRowCount(); rowNumber++) {
        for (int columnNumber=0; columnNumber < model.getColumnCount(); columnNumber++) {
          Object valueAt=model.getValueAt(rowNumber,columnNumber);
          if (valueAt != null && !valueAt.toString().trim().isEmpty()) {
            sb.append(valueAt.toString());
            if (columnNumber == model.getColumnCount() - 1) {
              sb.append(""String_Node_Str"");
            }
 else {
              sb.append(""String_Node_Str"");
            }
          }
        }
      }
      properties.setProperty(property,sb.toString());
    }
  }
);
  for (  String entry : entries) {
    if (entry.split(""String_Node_Str"").length < 2) {
      continue;
    }
    String key=entry.split(""String_Node_Str"")[0];
    String value=entry.split(""String_Node_Str"")[1];
    Vector<String> row=new Vector<String>();
    row.add(key);
    row.add(value);
    rowData.add(row);
  }
  JTable jTable=new JTable(model);
  model.setDataVector(rowData,columnData);
  model.addRow(new Object[]{});
  fieldLabels.put(jTable,label);
  addComponent(jTable);
  itemIdx++;
  return;
}"
48164,"public EstablishPACEResponse(byte[] response){
  int dataLen=response.length;
  int idx=4;
  statusBytes=new byte[]{response[0],response[1]};
  efCardAccessLength=(short)((response[2] & 0xFF) + ((response[3] & 0xFF) << 8));
  if (efCardAccessLength > 0) {
    efCardAccess=Arrays.copyOfRange(response,idx,idx + efCardAccessLength);
    idx+=efCardAccessLength;
  }
 else {
    efCardAccess=new byte[0];
  }
  if (dataLen > idx + 1) {
    currentCARLength=(byte)(response[idx] & 0xFF);
    idx++;
    if (currentCARLength > 0) {
      currentCAR=Arrays.copyOfRange(response,idx,idx + currentCARLength);
      idx+=currentCARLength;
    }
  }
  if (dataLen > idx + 1) {
    previousCARLength=(byte)(response[idx] & 0xFF);
    idx++;
    if (previousCARLength > 0) {
      previousCAR=Arrays.copyOfRange(response,idx,idx + previousCARLength);
      idx+=previousCARLength;
    }
  }
  if (dataLen > idx + 2) {
    idiccLength=(short)((response[idx] & 0xFF) + ((response[idx + 1] & 0xFF) << 8));
    idx+=2;
    if (idiccLength > 0) {
      idicc=Arrays.copyOfRange(response,idx,idx + idiccLength);
      idx+=idiccLength;
    }
  }
}","public EstablishPACEResponse(byte[] response){
  int dataLen=response.length;
  int idx=4;
  statusBytes=Arrays.copyOfRange(response,0,2);
  efCardAccessLength=(short)((response[2] & 0xFF) + ((response[3] & 0xFF) << 8));
  if (efCardAccessLength > 0) {
    efCardAccess=Arrays.copyOfRange(response,idx,idx + efCardAccessLength);
    idx+=efCardAccessLength;
  }
 else {
    efCardAccess=new byte[0];
  }
  if (dataLen > idx + 1) {
    currentCARLength=(byte)(response[idx] & 0xFF);
    idx++;
    if (currentCARLength > 0) {
      currentCAR=Arrays.copyOfRange(response,idx,idx + currentCARLength);
      idx+=currentCARLength;
    }
  }
  if (dataLen > idx + 1) {
    previousCARLength=(byte)(response[idx] & 0xFF);
    idx++;
    if (previousCARLength > 0) {
      previousCAR=Arrays.copyOfRange(response,idx,idx + previousCARLength);
      idx+=previousCARLength;
    }
  }
  if (dataLen > idx + 2) {
    idiccLength=(short)((response[idx] & 0xFF) + ((response[idx + 1] & 0xFF) << 8));
    idx+=2;
    if (idiccLength > 0) {
      idicc=Arrays.copyOfRange(response,idx,idx + idiccLength);
      idx+=idiccLength;
    }
  }
}"
48165,"public Result getResult(){
  if (result == 0x00000000)   return WSHelper.makeResultOK();
  if (result == 0xD0000001)   return WSHelper.makeResultUnknownError(""String_Node_Str"");
  if (result == 0xD0000002)   return WSHelper.makeResultUnknownError(""String_Node_Str"");
  if (result == 0xD0000003)   return WSHelper.makeResultUnknownError(""String_Node_Str"");
  if (result == 0xE0000001)   return WSHelper.makeResultUnknownError(""String_Node_Str"");
  if (result == 0xE0000002)   return WSHelper.makeResultUnknownError(""String_Node_Str"");
  if (result == 0xE0000003)   return WSHelper.makeResultUnknownError(""String_Node_Str"");
  if (result == 0xE0000006)   return WSHelper.makeResultUnknownError(""String_Node_Str"");
  if ((result & 0xFFFC0000) == 0xF0000000) {
    byte[] sw=new byte[]{(byte)((result >> 8) & 0xFF),(byte)(result & 0xFF)};
    String msg=CardCommandStatus.getMessage(sw);
    int type=(result >> 16) & 0xFFFF;
    if (type == 0xF000)     return WSHelper.makeResultUnknownError(""String_Node_Str"" + msg);
    if (type == 0xF001)     return WSHelper.makeResultUnknownError(""String_Node_Str"" + msg);
    if (type == 0xF002)     return WSHelper.makeResultUnknownError(""String_Node_Str"" + msg);
    if (type == 0xF003)     return WSHelper.makeResultUnknownError(""String_Node_Str"" + msg);
  }
  if (result == 0xF0100001)   return WSHelper.makeResultUnknownError(""String_Node_Str"");
  if (result == 0xF0100002)   return WSHelper.makeResultError(ECardConstants.Minor.IFD.NO_CARD,""String_Node_Str"");
  if (result == 0xF0200001)   return WSHelper.makeResultError(ECardConstants.Minor.IFD.CANCELLATION_BY_USER,""String_Node_Str"");
  if (result == 0xF0200002)   return WSHelper.makeResultError(ECardConstants.Minor.IFD.TIMEOUT_ERROR,""String_Node_Str"");
  String hexStringResult=ByteUtils.toHexString(IntegerUtils.toByteArray(result));
  logger.warn(""String_Node_Str"",hexStringResult);
  return WSHelper.makeResultUnknownError(null);
}","public Result getResult(){
switch (result) {
case 0x00000000:
    return WSHelper.makeResultOK();
case 0xD0000001:
  return WSHelper.makeResultUnknownError(""String_Node_Str"");
case 0xD0000002:
return WSHelper.makeResultUnknownError(""String_Node_Str"");
case 0xD0000003:
return WSHelper.makeResultUnknownError(""String_Node_Str"");
case 0xE0000001:
return WSHelper.makeResultUnknownError(""String_Node_Str"");
case 0xE0000002:
return WSHelper.makeResultUnknownError(""String_Node_Str"");
case 0xE0000003:
return WSHelper.makeResultUnknownError(""String_Node_Str"");
case 0xE0000006:
return WSHelper.makeResultUnknownError(""String_Node_Str"");
case 0xF0100001:
return WSHelper.makeResultUnknownError(""String_Node_Str"");
case 0xF0100002:
return WSHelper.makeResultError(ECardConstants.Minor.IFD.NO_CARD,""String_Node_Str"");
case 0xF0200001:
return WSHelper.makeResultError(ECardConstants.Minor.IFD.CANCELLATION_BY_USER,""String_Node_Str"");
case 0xF0200002:
return WSHelper.makeResultError(ECardConstants.Minor.IFD.TIMEOUT_ERROR,""String_Node_Str"");
default :
{
if ((result & 0xFFFC0000) == 0xF0000000) {
byte[] sw=new byte[]{(byte)((result >> 8) & 0xFF),(byte)(result & 0xFF)};
String msg=CardCommandStatus.getMessage(sw);
int type=(result >> 16) & 0xFFFF;
switch (type) {
case 0xF000:
return WSHelper.makeResultUnknownError(""String_Node_Str"" + msg);
case 0xF001:
return WSHelper.makeResultUnknownError(""String_Node_Str"" + msg);
case 0xF002:
return WSHelper.makeResultUnknownError(""String_Node_Str"" + msg);
case 0xF003:
return WSHelper.makeResultUnknownError(""String_Node_Str"" + msg);
}
}
String hexStringResult=ByteUtils.toHexString(IntegerUtils.toByteArray(result));
logger.warn(""String_Node_Str"",hexStringResult);
return WSHelper.makeResultUnknownError(null);
}
}
}"
48166,"public ExecutePACEResponse(byte[] response){
  result=ByteUtils.toInteger(Arrays.copyOfRange(response,0,4));
  length=ByteUtils.toShort(new byte[]{response[5],response[4]});
  data=Arrays.copyOfRange(response,6,6 + length);
}","public ExecutePACEResponse(byte[] response){
  result=ByteUtils.toInteger(Arrays.copyOfRange(response,0,4),false);
  length=ByteUtils.toShort(Arrays.copyOfRange(response,4,6),false);
  data=Arrays.copyOfRange(response,6,6 + length);
}"
48167,"@Override public EstablishChannelResponse establishChannel(EstablishChannel parameters){
  byte[] slotHandle=parameters.getSlotHandle();
  try {
    SCTerminal term=this.scwrapper.getTerminal(slotHandle);
    SCCard card=this.scwrapper.getCard(slotHandle);
    SCChannel channel=card.getChannel(slotHandle);
    DIDAuthenticationDataType protoParam=parameters.getAuthenticationProtocolData();
    String protocol=protoParam.getProtocol();
    List<PACECapabilities.PACECapability> paceCapabilities=term.getPACECapabilities();
    List<String> supportedProtos=buildPACEProtocolList(paceCapabilities);
    if (!supportedProtos.isEmpty() && supportedProtos.get(0).startsWith(protocol)) {
      PACEInputType paceParam=new PACEInputType(protoParam);
      byte pinID=paceParam.getPINID();
      byte[] chat=paceParam.getCHAT();
      String pin=paceParam.getPIN();
      byte[] certDesc=paceParam.getCertificateDescription();
      EstablishPACERequest estPaceReq=new EstablishPACERequest(pinID,chat,null,certDesc);
      ExecutePACERequest execPaceReq=new ExecutePACERequest(ExecutePACERequest.Function.EstablishPACEChannel,estPaceReq.toBytes());
      if (estPaceReq.isSupportedType(paceCapabilities)) {
        byte[] reqData=execPaceReq.toBytes();
        byte[] resData=term.executeCtrlCode(PCSCFeatures.EXECUTE_PACE,reqData);
        ExecutePACEResponse execPaceRes=new ExecutePACEResponse(resData);
        if (execPaceRes.isError()) {
          return WSHelper.makeResponse(EstablishChannelResponse.class,execPaceRes.getResult());
        }
        EstablishPACEResponse estPaceRes=new EstablishPACEResponse(execPaceRes.getData());
        PACEOutputType authDataResponse=paceParam.getOutputType();
        authDataResponse.setRetryCounter(estPaceRes.getRetryCounter());
        authDataResponse.setEFCardAccess(estPaceRes.getEFCardAccess());
        if (estPaceRes.hasCurrentCAR()) {
          authDataResponse.setCurrentCAR(estPaceRes.getCurrentCAR());
        }
        if (estPaceRes.hasPreviousCAR()) {
          authDataResponse.setPreviousCAR(estPaceRes.getPreviousCAR());
        }
        if (estPaceRes.hasIDICC()) {
          authDataResponse.setIDPICC(estPaceRes.getIDICC());
        }
        EstablishChannelResponse response=WSHelper.makeResponse(EstablishChannelResponse.class,WSHelper.makeResultOK());
        response.setAuthenticationProtocolData(authDataResponse.getAuthDataType());
        return response;
      }
    }
    if (this.protocolFactories.contains(protocol)) {
      ProtocolFactory factory=this.protocolFactories.get(protocol);
      Protocol protoImpl=factory.createInstance();
      EstablishChannelResponse response=protoImpl.establish(parameters,dispatcher,this.gui);
      if (response.getResult().getResultMajor().equals(ECardConstants.Major.OK)) {
        channel.addSecureMessaging(protoImpl);
      }
      return response;
    }
    return WSHelper.makeResponse(EstablishChannelResponse.class,WSHelper.makeResultUnknownError(""String_Node_Str""));
  }
 catch (  Throwable t) {
    return WSHelper.makeResponse(EstablishChannelResponse.class,WSHelper.makeResult(t));
  }
}","@Override public EstablishChannelResponse establishChannel(EstablishChannel parameters){
  byte[] slotHandle=parameters.getSlotHandle();
  try {
    SCTerminal term=this.scwrapper.getTerminal(slotHandle);
    SCCard card=this.scwrapper.getCard(slotHandle);
    SCChannel channel=card.getChannel(slotHandle);
    DIDAuthenticationDataType protoParam=parameters.getAuthenticationProtocolData();
    String protocol=protoParam.getProtocol();
    List<PACECapabilities.PACECapability> paceCapabilities=term.getPACECapabilities();
    List<String> supportedProtos=buildPACEProtocolList(paceCapabilities);
    if (!supportedProtos.isEmpty() && supportedProtos.get(0).startsWith(protocol)) {
      PACEInputType paceParam=new PACEInputType(protoParam);
      byte pinID=paceParam.getPINID();
      byte[] chat=paceParam.getCHAT();
      String pin=paceParam.getPIN();
      byte[] certDesc=paceParam.getCertificateDescription();
      EstablishPACERequest estPaceReq=new EstablishPACERequest(pinID,chat,null,certDesc);
      ExecutePACERequest execPaceReq=new ExecutePACERequest(ExecutePACERequest.Function.EstablishPACEChannel,estPaceReq.toBytes());
      if (estPaceReq.isSupportedType(paceCapabilities)) {
        byte[] reqData=execPaceReq.toBytes();
        _logger.debug(""String_Node_Str"",ByteUtils.toHexString(reqData));
        byte[] resData=term.executeCtrlCode(PCSCFeatures.EXECUTE_PACE,reqData);
        _logger.debug(""String_Node_Str"",ByteUtils.toHexString(resData));
        ExecutePACEResponse execPaceRes=new ExecutePACEResponse(resData);
        if (execPaceRes.isError()) {
          return WSHelper.makeResponse(EstablishChannelResponse.class,execPaceRes.getResult());
        }
        EstablishPACEResponse estPaceRes=new EstablishPACEResponse(execPaceRes.getData());
        PACEOutputType authDataResponse=paceParam.getOutputType();
        authDataResponse.setRetryCounter(estPaceRes.getRetryCounter());
        authDataResponse.setEFCardAccess(estPaceRes.getEFCardAccess());
        if (estPaceRes.hasCurrentCAR()) {
          authDataResponse.setCurrentCAR(estPaceRes.getCurrentCAR());
        }
        if (estPaceRes.hasPreviousCAR()) {
          authDataResponse.setPreviousCAR(estPaceRes.getPreviousCAR());
        }
        if (estPaceRes.hasIDICC()) {
          authDataResponse.setIDPICC(estPaceRes.getIDICC());
        }
        EstablishChannelResponse response=WSHelper.makeResponse(EstablishChannelResponse.class,WSHelper.makeResultOK());
        response.setAuthenticationProtocolData(authDataResponse.getAuthDataType());
        return response;
      }
    }
    if (this.protocolFactories.contains(protocol)) {
      ProtocolFactory factory=this.protocolFactories.get(protocol);
      Protocol protoImpl=factory.createInstance();
      EstablishChannelResponse response=protoImpl.establish(parameters,dispatcher,this.gui);
      if (response.getResult().getResultMajor().equals(ECardConstants.Major.OK)) {
        channel.addSecureMessaging(protoImpl);
      }
      return response;
    }
    return WSHelper.makeResponse(EstablishChannelResponse.class,WSHelper.makeResultUnknownError(""String_Node_Str""));
  }
 catch (  Throwable t) {
    return WSHelper.makeResponse(EstablishChannelResponse.class,WSHelper.makeResult(t));
  }
}"
48168,"public byte[] toBytes(){
  ByteArrayOutputStream o=new ByteArrayOutputStream();
  o.write(passwordType);
  if (chatLength > 0) {
    o.write(chatLength);
    if (chatLength > 0) {
      o.write(chat,0,chat.length);
    }
    o.write(passwordLength);
    if (passwordLength > 0) {
      o.write(password,0,password.length);
    }
    if (certDescLength > 0) {
      byte[] dataLength_bytes=ShortUtils.toByteArray(certDescLength);
      for (int i=dataLength_bytes.length - 1; i >= 0; i--) {
        o.write(dataLength_bytes[i]);
      }
      for (int i=dataLength_bytes.length; i < 2; i++) {
        o.write(0);
      }
      o.write(certDesc,0,certDesc.length);
    }
  }
  return o.toByteArray();
}","public byte[] toBytes(){
  ByteArrayOutputStream o=new ByteArrayOutputStream();
  o.write(passwordType);
  if (chatLength > 0) {
    o.write(chatLength);
    if (chatLength > 0) {
      o.write(chat,0,chat.length);
    }
    o.write(passwordLength);
    if (passwordLength > 0) {
      o.write(password,0,password.length);
    }
    if (certDescLength > 0) {
      byte[] dataLength_bytes=ShortUtils.toByteArray(certDescLength);
      for (int i=dataLength_bytes.length - 1; i >= 0; i--) {
        o.write(dataLength_bytes[i]);
      }
      for (int i=dataLength_bytes.length; i < 2; i++) {
        o.write(0);
      }
      o.write(certDesc,0,certDesc.length);
    }
  }
 else {
    o.write(0x00);
    o.write(0x00);
    o.write(0x00);
    o.write(0x00);
  }
  return o.toByteArray();
}"
48169,"public Result getResult(){
  if (result == 0x00000000)   return WSHelper.makeResultOK();
  if (result == 0xD0000001)   return WSHelper.makeResultUnknownError(""String_Node_Str"");
  if (result == 0xD0000002)   return WSHelper.makeResultUnknownError(""String_Node_Str"");
  if (result == 0xD0000003)   return WSHelper.makeResultUnknownError(""String_Node_Str"");
  if (result == 0xE0000001)   return WSHelper.makeResultUnknownError(""String_Node_Str"");
  if (result == 0xE0000002)   return WSHelper.makeResultUnknownError(""String_Node_Str"");
  if (result == 0xE0000003)   return WSHelper.makeResultUnknownError(""String_Node_Str"");
  if (result == 0xE0000006)   return WSHelper.makeResultUnknownError(""String_Node_Str"");
  if ((result & 0xFFFC0000) == 0xF0000000) {
    byte[] sw=new byte[]{(byte)((result >> 8) & 0xFF),(byte)(result & 0xFF)};
    String msg=CardCommandStatus.getMessage(sw);
    int type=(result >> 16) & 0xFFFF;
    if (type == 0xF000)     return WSHelper.makeResultUnknownError(""String_Node_Str"" + msg);
    if (type == 0xF001)     return WSHelper.makeResultUnknownError(""String_Node_Str"" + msg);
    if (type == 0xF002)     return WSHelper.makeResultUnknownError(""String_Node_Str"" + msg);
    if (type == 0xF003)     return WSHelper.makeResultUnknownError(""String_Node_Str"" + msg);
  }
  if (result == 0xF0100001)   return WSHelper.makeResultUnknownError(""String_Node_Str"");
  if (result == 0xF0100002)   return WSHelper.makeResultError(ECardConstants.Minor.IFD.NO_CARD,""String_Node_Str"");
  if (result == 0xF0200001)   return WSHelper.makeResultError(ECardConstants.Minor.IFD.CANCELLATION_BY_USER,""String_Node_Str"");
  if (result == 0xF0200002)   return WSHelper.makeResultError(ECardConstants.Minor.IFD.TIMEOUT_ERROR,""String_Node_Str"");
  return WSHelper.makeResultUnknownError(null);
}","public Result getResult(){
  if (result == 0x00000000)   return WSHelper.makeResultOK();
  if (result == 0xD0000001)   return WSHelper.makeResultUnknownError(""String_Node_Str"");
  if (result == 0xD0000002)   return WSHelper.makeResultUnknownError(""String_Node_Str"");
  if (result == 0xD0000003)   return WSHelper.makeResultUnknownError(""String_Node_Str"");
  if (result == 0xE0000001)   return WSHelper.makeResultUnknownError(""String_Node_Str"");
  if (result == 0xE0000002)   return WSHelper.makeResultUnknownError(""String_Node_Str"");
  if (result == 0xE0000003)   return WSHelper.makeResultUnknownError(""String_Node_Str"");
  if (result == 0xE0000006)   return WSHelper.makeResultUnknownError(""String_Node_Str"");
  if ((result & 0xFFFC0000) == 0xF0000000) {
    byte[] sw=new byte[]{(byte)((result >> 8) & 0xFF),(byte)(result & 0xFF)};
    String msg=CardCommandStatus.getMessage(sw);
    int type=(result >> 16) & 0xFFFF;
    if (type == 0xF000)     return WSHelper.makeResultUnknownError(""String_Node_Str"" + msg);
    if (type == 0xF001)     return WSHelper.makeResultUnknownError(""String_Node_Str"" + msg);
    if (type == 0xF002)     return WSHelper.makeResultUnknownError(""String_Node_Str"" + msg);
    if (type == 0xF003)     return WSHelper.makeResultUnknownError(""String_Node_Str"" + msg);
  }
  if (result == 0xF0100001)   return WSHelper.makeResultUnknownError(""String_Node_Str"");
  if (result == 0xF0100002)   return WSHelper.makeResultError(ECardConstants.Minor.IFD.NO_CARD,""String_Node_Str"");
  if (result == 0xF0200001)   return WSHelper.makeResultError(ECardConstants.Minor.IFD.CANCELLATION_BY_USER,""String_Node_Str"");
  if (result == 0xF0200002)   return WSHelper.makeResultError(ECardConstants.Minor.IFD.TIMEOUT_ERROR,""String_Node_Str"");
  String hexStringResult=ByteUtils.toHexString(IntegerUtils.toByteArray(result));
  logger.warn(""String_Node_Str"",hexStringResult);
  return WSHelper.makeResultUnknownError(null);
}"
48170,"/** 
 * Selects and reads a file.
 * @param dispatcher Dispatcher
 * @param slotHandle Slot handle
 * @param fileID File ID
 * @return File content
 * @throws APDUException
 */
public static byte[] readFile(Dispatcher dispatcher,byte[] slotHandle,byte[] fileID) throws APDUException {
  selectFile(dispatcher,slotHandle,fileID);
  return readFile(dispatcher,slotHandle);
}","/** 
 * Selects and reads a file.
 * @param dispatcher Dispatcher
 * @param slotHandle Slot handle
 * @param fileID File ID
 * @return File content
 * @throws APDUException
 */
public static byte[] readFile(Dispatcher dispatcher,byte[] slotHandle,byte[] fileID) throws APDUException {
  CardResponseAPDU selectResponse=selectFile(dispatcher,slotHandle,fileID);
  FCP fcp=null;
  try {
    fcp=new FCP(selectResponse.getData());
  }
 catch (  TLVException e) {
    logger.warn(""String_Node_Str"",e);
  }
  return readFile(fcp,dispatcher,slotHandle);
}"
48171,"/** 
 * Selects a File.
 * @param dispatcher Dispatcher
 * @param slotHandle Slot handle
 * @param fileID File ID
 * @throws APDUException
 */
public static void selectFile(Dispatcher dispatcher,byte[] slotHandle,byte[] fileID) throws APDUException {
  CardCommandAPDU selectFile=new Select.File(fileID);
  selectFile.transmit(dispatcher,slotHandle);
}","/** 
 * Selects a File.
 * @param dispatcher Dispatcher
 * @param slotHandle Slot handle
 * @param fileID File ID
 * @return CardREsponseAPDU containing the File Control Parameters
 * @throws APDUException
 */
public static CardResponseAPDU selectFile(Dispatcher dispatcher,byte[] slotHandle,byte[] fileID) throws APDUException {
  Select selectFile=new Select.File(fileID);
  selectFile.setFCP();
  return selectFile.transmit(dispatcher,slotHandle);
}"
48172,"/** 
 * Check if all components on the frame are valid. This can be used to see if a jump to the next frame can be made.
 * @return True if all components are valid, false otherwise.
 */
public boolean validateComponents(){
  for (  StepComponent next : components) {
    if (next.isValueType() && !next.validate()) {
      return false;
    }
  }
  return true;
}","/** 
 * Check if all components on the frame are valid. This can be used to see if a jump to the next frame can be made.
 * @return True if all components are valid, false otherwise.
 */
public boolean validateComponents(){
  for (  StepComponent next : components) {
    Component component=next.getComponent();
    if (next.isValueType() && !next.validate()) {
      component.setBackground(Color.RED);
      return false;
    }
    component.setBackground(null);
  }
  return true;
}"
48173,"@Override public void actionPerformed(ActionEvent e){
  logger.debug(""String_Node_Str"",e.getActionCommand());
  NavigationEvent event=NavigationEvent.fromEvent(e);
  if (event == null) {
    logger.error(""String_Node_Str"",e.getActionCommand());
    return;
  }
  if (action != null && !action.isDone()) {
    logger.debug(""String_Node_Str"");
    action.cancel(true);
    return;
  }
  StepFrame curStep=stepFrames.get(stepPointer);
  stepBar.enableLoaderImage();
  navBar.lockControls();
  curStep.lockControls();
  curStep.updateResult(event);
}","@Override public void actionPerformed(ActionEvent e){
  logger.debug(""String_Node_Str"",e.getActionCommand());
  NavigationEvent event=NavigationEvent.fromEvent(e);
  if (event == null) {
    logger.error(""String_Node_Str"",e.getActionCommand());
    return;
  }
  StepFrame curStep=stepFrames.get(stepPointer);
  if (event == NavigationEvent.NEXT && !curStep.validateComponents()) {
    logger.debug(""String_Node_Str"");
    return;
  }
  if (action != null && !action.isDone()) {
    logger.debug(""String_Node_Str"");
    action.cancel(true);
    return;
  }
  stepBar.enableLoaderImage();
  navBar.lockControls();
  curStep.lockControls();
  curStep.updateResult(event);
}"
48174,"private Image getTrayIconImage(String name){
  Dimension dim=tray.getTrayIconSize();
  if (isLinux()) {
    if (isKde()) {
      return getImageKde(name,dim);
    }
 else {
      return getImageLinux(name,dim);
    }
  }
 else {
    return getImageDefault(name,dim);
  }
}","private Image getTrayIconImage(String name){
  Dimension dim=tray.getTrayIconSize();
  if (isLinux()) {
    if (isKde()) {
      return getImageKde(name,dim);
    }
 else {
      return getImageLinux(name,dim);
    }
  }
 else   if (isMacOSX()) {
    return getImageMacOSX(name,dim);
  }
 else {
    return getImageDefault(name,dim);
  }
}"
48175,"@Override public DIDAuthenticateResponse perform(DIDAuthenticate request,Map<String,Object> internalData){
  DIDAuthenticate didAuthenticate=request;
  DIDAuthenticateResponse response=new DIDAuthenticateResponse();
  byte[] slotHandle=didAuthenticate.getConnectionHandle().getSlotHandle();
  try {
    EAC1InputType eac1Input=new EAC1InputType(didAuthenticate.getAuthenticationProtocolData());
    EAC1OutputType eac1Output=eac1Input.getOutputType();
    CardStateEntry cardState=(CardStateEntry)internalData.get(EACConstants.INTERNAL_DATA_CARD_STATE_ENTRY);
    boolean nativePace=genericPACESupport(cardState.handleCopy());
    CardVerifiableCertificateChain certChain=new CardVerifiableCertificateChain(eac1Input.getCertificates());
    byte[] rawCertificateDescription=eac1Input.getCertificateDescription();
    CertificateDescription certDescription=CertificateDescription.getInstance(rawCertificateDescription);
    CHAT requiredCHAT=new CHAT(eac1Input.getRequiredCHAT());
    CHAT optionalCHAT=new CHAT(eac1Input.getOptionalCHAT());
    byte pinID=PasswordID.valueOf(didAuthenticate.getDIDName()).getByte();
    String passwordType=PasswordID.parse(pinID).getString();
    CardVerifiableCertificate taCert=certChain.getTerminalCertificates().get(0);
    CardVerifiableCertificateVerifier.verify(taCert,certDescription);
    CHATVerifier.verfiy(taCert.getCHAT(),optionalCHAT);
    CHATVerifier.verfiy(taCert.getCHAT(),requiredCHAT);
    CHATVerifier.verfiy(taCert.getCHAT(),optionalCHAT);
    EACData eacData=new EACData();
    eacData.didRequest=didAuthenticate;
    eacData.certificate=certChain.getTerminalCertificates().get(0);
    eacData.certificateDescription=certDescription;
    eacData.rawCertificateDescription=rawCertificateDescription;
    eacData.requiredCHAT=requiredCHAT;
    eacData.optionalCHAT=optionalCHAT;
    eacData.selectedCHAT=requiredCHAT;
    eacData.pinID=pinID;
    eacData.passwordType=passwordType;
    UserConsentDescription uc=new UserConsentDescription(lang.translationForKey(TITLE));
    CVCStep cvcStep=new CVCStep(eacData);
    CHATStep chatStep=new CHATStep(eacData);
    PINStep pinStep=new PINStep(eacData,!nativePace);
    uc.getSteps().add(cvcStep);
    uc.getSteps().add(chatStep);
    uc.getSteps().add(pinStep);
    StepAction chatAction=new CHATStepAction(eacData,chatStep);
    chatStep.setAction(chatAction);
    StepAction pinAction=new PINStepAction(eacData,!nativePace,slotHandle,dispatcher,pinStep);
    pinStep.setAction(pinAction);
    UserConsentNavigator navigator=gui.obtainNavigator(uc);
    ExecutionEngine exec=new ExecutionEngine(navigator);
    ResultStatus guiResult=exec.process();
    if (guiResult == ResultStatus.CANCEL) {
      String msg=""String_Node_Str"";
      Result r=WSHelper.makeResultError(ECardConstants.Minor.SAL.CANCELLATION_BY_USER,msg);
      response.setResult(r);
      return response;
    }
    DIDAuthenticationDataType data=eacData.paceResponse.getAuthenticationProtocolData();
    AuthDataMap paceOutputMap=new AuthDataMap(data);
    int retryCounter=Integer.valueOf(paceOutputMap.getContentAsString(PACEOutputType.RETRY_COUNTER));
    byte[] efCardAccess=paceOutputMap.getContentAsBytes(PACEOutputType.EF_CARD_ACCESS);
    byte[] currentCAR=paceOutputMap.getContentAsBytes(PACEOutputType.CURRENT_CAR);
    byte[] previousCAR=paceOutputMap.getContentAsBytes(PACEOutputType.PREVIOUS_CAR);
    byte[] idpicc=paceOutputMap.getContentAsBytes(PACEOutputType.ID_PICC);
    SecurityInfos securityInfos=SecurityInfos.getInstance(efCardAccess);
    internalData.put(EACConstants.INTERNAL_DATA_SECURITY_INFOS,securityInfos);
    internalData.put(EACConstants.INTERNAL_DATA_AUTHENTICATED_AUXILIARY_DATA,eac1Input.getAuthenticatedAuxiliaryData());
    internalData.put(EACConstants.INTERNAL_DATA_CERTIFICATES,certChain);
    internalData.put(EACConstants.INTERNAL_DATA_CURRENT_CAR,currentCAR);
    eac1Output.setEFCardAccess(efCardAccess);
    eac1Output.setRetryCounter(retryCounter);
    eac1Output.setIDPICC(idpicc);
    eac1Output.setCHAT(eacData.selectedCHAT.toByteArray());
    eac1Output.setCAR(currentCAR);
    response.setResult(WSHelper.makeResultOK());
    response.setAuthenticationProtocolData(eac1Output.getAuthDataType());
  }
 catch (  WSHelper.WSException e) {
    logger.error(e.getMessage(),e);
    response.setResult(e.getResult());
  }
catch (  Exception e) {
    logger.error(e.getMessage(),e);
    response.setResult(WSHelper.makeResultUnknownError(e.getMessage()));
  }
  return response;
}","@Override public DIDAuthenticateResponse perform(DIDAuthenticate request,Map<String,Object> internalData){
  DIDAuthenticate didAuthenticate=request;
  DIDAuthenticateResponse response=new DIDAuthenticateResponse();
  byte[] slotHandle=didAuthenticate.getConnectionHandle().getSlotHandle();
  try {
    EAC1InputType eac1Input=new EAC1InputType(didAuthenticate.getAuthenticationProtocolData());
    EAC1OutputType eac1Output=eac1Input.getOutputType();
    CardStateEntry cardState=(CardStateEntry)internalData.get(EACConstants.INTERNAL_DATA_CARD_STATE_ENTRY);
    boolean nativePace=genericPACESupport(cardState.handleCopy());
    CardVerifiableCertificateChain certChain=new CardVerifiableCertificateChain(eac1Input.getCertificates());
    byte[] rawCertificateDescription=eac1Input.getCertificateDescription();
    CertificateDescription certDescription=CertificateDescription.getInstance(rawCertificateDescription);
    CHAT requiredCHAT=new CHAT(eac1Input.getRequiredCHAT());
    CHAT optionalCHAT=new CHAT(eac1Input.getOptionalCHAT());
    byte pinID=PasswordID.valueOf(didAuthenticate.getDIDName()).getByte();
    String passwordType=PasswordID.parse(pinID).getString();
    CardVerifiableCertificate taCert=certChain.getTerminalCertificates().get(0);
    CardVerifiableCertificateVerifier.verify(taCert,certDescription);
    CHATVerifier.verfiy(taCert.getCHAT(),optionalCHAT);
    CHATVerifier.verfiy(taCert.getCHAT(),requiredCHAT);
    CHATVerifier.verfiy(taCert.getCHAT(),optionalCHAT);
    EACData eacData=new EACData();
    eacData.didRequest=didAuthenticate;
    eacData.certificate=certChain.getTerminalCertificates().get(0);
    eacData.certificateDescription=certDescription;
    eacData.rawCertificateDescription=rawCertificateDescription;
    eacData.requiredCHAT=requiredCHAT;
    eacData.optionalCHAT=optionalCHAT;
    eacData.selectedCHAT=requiredCHAT;
    eacData.pinID=pinID;
    eacData.passwordType=passwordType;
    UserConsentDescription uc=new UserConsentDescription(lang.translationForKey(TITLE));
    CVCStep cvcStep=new CVCStep(eacData);
    CHATStep chatStep=new CHATStep(eacData);
    PINStep pinStep=new PINStep(eacData,!nativePace);
    uc.getSteps().add(cvcStep);
    uc.getSteps().add(chatStep);
    uc.getSteps().add(pinStep);
    StepAction chatAction=new CHATStepAction(eacData,chatStep);
    chatStep.setAction(chatAction);
    StepAction pinAction=new PINStepAction(eacData,!nativePace,slotHandle,dispatcher,pinStep);
    pinStep.setAction(pinAction);
    UserConsentNavigator navigator=gui.obtainNavigator(uc);
    ExecutionEngine exec=new ExecutionEngine(navigator);
    ResultStatus guiResult=exec.process();
    if (guiResult == ResultStatus.CANCEL) {
      String protocol=didAuthenticate.getAuthenticationProtocolData().getProtocol();
      cardState.removeProtocol(protocol);
      String msg=""String_Node_Str"";
      Result r=WSHelper.makeResultError(ECardConstants.Minor.SAL.CANCELLATION_BY_USER,msg);
      response.setResult(r);
      return response;
    }
    DIDAuthenticationDataType data=eacData.paceResponse.getAuthenticationProtocolData();
    AuthDataMap paceOutputMap=new AuthDataMap(data);
    int retryCounter=Integer.valueOf(paceOutputMap.getContentAsString(PACEOutputType.RETRY_COUNTER));
    byte[] efCardAccess=paceOutputMap.getContentAsBytes(PACEOutputType.EF_CARD_ACCESS);
    byte[] currentCAR=paceOutputMap.getContentAsBytes(PACEOutputType.CURRENT_CAR);
    byte[] previousCAR=paceOutputMap.getContentAsBytes(PACEOutputType.PREVIOUS_CAR);
    byte[] idpicc=paceOutputMap.getContentAsBytes(PACEOutputType.ID_PICC);
    SecurityInfos securityInfos=SecurityInfos.getInstance(efCardAccess);
    internalData.put(EACConstants.INTERNAL_DATA_SECURITY_INFOS,securityInfos);
    internalData.put(EACConstants.INTERNAL_DATA_AUTHENTICATED_AUXILIARY_DATA,eac1Input.getAuthenticatedAuxiliaryData());
    internalData.put(EACConstants.INTERNAL_DATA_CERTIFICATES,certChain);
    internalData.put(EACConstants.INTERNAL_DATA_CURRENT_CAR,currentCAR);
    eac1Output.setEFCardAccess(efCardAccess);
    eac1Output.setRetryCounter(retryCounter);
    eac1Output.setIDPICC(idpicc);
    eac1Output.setCHAT(eacData.selectedCHAT.toByteArray());
    eac1Output.setCAR(currentCAR);
    response.setResult(WSHelper.makeResultOK());
    response.setAuthenticationProtocolData(eac1Output.getAuthDataType());
  }
 catch (  WSHelper.WSException e) {
    logger.error(e.getMessage(),e);
    response.setResult(e.getResult());
  }
catch (  Exception e) {
    logger.error(e.getMessage(),e);
    response.setResult(WSHelper.makeResultUnknownError(e.getMessage()));
  }
  return response;
}"
48176,"/** 
 * The DIDAuthenticate function can be used to execute an authentication protocol using a DID addressed by DIDName. See BSI-TR-03112-4, version 1.1.2, section 3.6.6.
 * @param request DIDAuthenticate
 * @return DIDAuthenticateResponse
 */
@Override public DIDAuthenticateResponse didAuthenticate(DIDAuthenticate request){
  DIDAuthenticateResponse response=WSHelper.makeResponse(DIDAuthenticateResponse.class,WSHelper.makeResultOK());
  try {
    ConnectionHandleType connectionHandle=SALUtils.getConnectionHandle(request);
    DIDAuthenticationDataType didAuthenticationData=request.getAuthenticationProtocolData();
    Assert.assertIncorrectParameter(didAuthenticationData,""String_Node_Str"");
    String protocolURI=request.getAuthenticationProtocolData().getProtocol();
    if (protocolURI == null) {
      logger.warn(""String_Node_Str"");
      protocolURI=ECardConstants.Protocol.EAC_GENERIC;
    }
 else     if (protocolURI.equals(""String_Node_Str"")) {
      logger.warn(""String_Node_Str"");
      protocolURI=ECardConstants.Protocol.EAC_GENERIC;
    }
    Protocol protocol=getProtocol(connectionHandle,protocolURI);
    if (protocol.hasNextStep(FunctionType.DIDAuthenticate)) {
      response=protocol.didAuthenticate(request);
      removeFinishedProtocol(connectionHandle,protocolURI,protocol);
    }
 else {
      throw new InappropriateProtocolForActionException(""String_Node_Str"",protocol.toString());
    }
  }
 catch (  ECardException e) {
    response.setResult(e.getResult());
  }
catch (  Exception e) {
    logger.error(e.getMessage(),e);
    response.setResult(WSHelper.makeResult(e));
  }
  return response;
}","/** 
 * The DIDAuthenticate function can be used to execute an authentication protocol using a DID addressed by DIDName. See BSI-TR-03112-4, version 1.1.2, section 3.6.6.
 * @param request DIDAuthenticate
 * @return DIDAuthenticateResponse
 */
@Override public DIDAuthenticateResponse didAuthenticate(DIDAuthenticate request){
  DIDAuthenticateResponse response=WSHelper.makeResponse(DIDAuthenticateResponse.class,WSHelper.makeResultOK());
  try {
    ConnectionHandleType connectionHandle=SALUtils.getConnectionHandle(request);
    DIDAuthenticationDataType didAuthenticationData=request.getAuthenticationProtocolData();
    Assert.assertIncorrectParameter(didAuthenticationData,""String_Node_Str"");
    String protocolURI=didAuthenticationData.getProtocol();
    if (protocolURI == null) {
      logger.warn(""String_Node_Str"");
      protocolURI=ECardConstants.Protocol.EAC_GENERIC;
    }
 else     if (protocolURI.equals(""String_Node_Str"")) {
      logger.warn(""String_Node_Str"");
      protocolURI=ECardConstants.Protocol.EAC_GENERIC;
    }
    didAuthenticationData.setProtocol(protocolURI);
    Protocol protocol=getProtocol(connectionHandle,protocolURI);
    if (protocol.hasNextStep(FunctionType.DIDAuthenticate)) {
      response=protocol.didAuthenticate(request);
      removeFinishedProtocol(connectionHandle,protocolURI,protocol);
    }
 else {
      throw new InappropriateProtocolForActionException(""String_Node_Str"",protocol.toString());
    }
  }
 catch (  ECardException e) {
    response.setResult(e.getResult());
  }
catch (  Exception e) {
    logger.error(e.getMessage(),e);
    response.setResult(WSHelper.makeResult(e));
  }
  return response;
}"
48177,"/** 
 * Remove the entry reference in slotHandle index. <br/> This function is needed to update the index in CardApplicationDisconnect.
 * @param slotHandle SlotHandle for which the entry reference should be deleted.
 */
public synchronized void removeSlotHandleEntry(byte[] slotHandle){
  ConnectionHandleType handle=new ConnectionHandleType();
  handle.setSlotHandle(slotHandle);
  Set<CardStateEntry> entries=getMatchingEntries(handle);
  Iterator<CardStateEntry> it=entries.iterator();
  if (it.hasNext()) {
    CardStateEntry entry=it.next();
    removeMapEntry(handle.getSlotHandle(),slothandleMap,entry);
  }
}","/** 
 * Remove the entry reference in slotHandle index. <br/> This function is needed to update the index in CardApplicationDisconnect.
 * @param slotHandle SlotHandle for which the entry reference should be deleted.
 */
public synchronized void removeSlotHandleEntry(byte[] slotHandle){
  ConnectionHandleType handle=new ConnectionHandleType();
  handle.setSlotHandle(slotHandle);
  Set<CardStateEntry> entries=getMatchingEntries(handle);
  Iterator<CardStateEntry> it=entries.iterator();
  if (it.hasNext()) {
    CardStateEntry entry=it.next();
    removeMapEntry(handle.getSlotHandle(),slothandleMap,entry);
    clearProtocolsForEntry(entry);
  }
}"
48178,"/** 
 * Initialize the client by setting properties for Android and starting up each module.
 */
public void initialize(){
  if (initialized) {
    return;
  }
  notificationManager=(NotificationManager)getSystemService(NOTIFICATION_SERVICE);
  AndroidUtils.initLogging(this);
  SharedPreferences preferences=PreferenceManager.getDefaultSharedPreferences(this);
  String noFactory=""String_Node_Str"";
  String factoryImpl=preferences.getString(""String_Node_Str"",noFactory);
  if (factoryImpl.equals(noFactory)) {
    Intent i=new Intent(this,TerminalFactoryActivity.class);
    i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
    i.putExtra(""String_Node_Str"",true);
    this.startActivity(i);
    return;
  }
  IFDProperties.setProperty(""String_Node_Str"",factoryImpl);
  WsdefProperties.setProperty(""String_Node_Str"",""String_Node_Str"");
  try {
    terminalFactory=(AndroidTerminalFactory)IFDTerminalFactory.getInstance();
  }
 catch (  IFDException e) {
    System.exit(0);
  }
  usingNFC=terminalFactory instanceof NFCFactory;
  if (usingNFC) {
    NfcManager manager=(NfcManager)this.getSystemService(Context.NFC_SERVICE);
    NfcAdapter adapter=manager.getDefaultAdapter();
    if (adapter == null || !adapter.isEnabled()) {
      Intent i=new Intent(this,NFCErrorActivity.class);
      i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
      this.startActivity(i);
      return;
    }
  }
  terminalFactory.start(this);
  env=new ClientEnv();
  management=new TinyManagement(env);
  env.setManagement(management);
  dispatcher=new MessageDispatcher(env);
  env.setDispatcher(dispatcher);
  gui=new AndroidUserConsent(this);
  ifd=new IFD();
  ifd.setDispatcher(dispatcher);
  ifd.setGUI(gui);
  ifd.addProtocol(ECardConstants.Protocol.PACE,new PACEProtocolFactory());
  env.setIFD(ifd);
  EstablishContext establishContext=new EstablishContext();
  EstablishContextResponse establishContextResponse=ifd.establishContext(establishContext);
  if (establishContextResponse.getResult().getResultMajor().equals(ECardConstants.Major.OK)) {
    if (establishContextResponse.getContextHandle() != null) {
      contextHandle=establishContextResponse.getContextHandle();
    }
 else {
      logger.error(""String_Node_Str"");
      MessageDialog dialog=gui.obtainMessageDialog();
      String message=lang.translationForKey(""String_Node_Str"");
      String title=lang.translationForKey(""String_Node_Str"");
      dialog.showMessageDialog(message,title,DialogType.ERROR_MESSAGE);
      shutdown();
      System.exit(0);
    }
  }
 else {
    logger.error(""String_Node_Str"");
    MessageDialog dialog=gui.obtainMessageDialog();
    String message=lang.translationForKey(""String_Node_Str"");
    String title=lang.translationForKey(""String_Node_Str"");
    dialog.showMessageDialog(message,title,DialogType.ERROR_MESSAGE);
    shutdown();
    System.exit(0);
  }
  try {
    recognition=new CardRecognition(ifd,contextHandle);
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
    MessageDialog dialog=gui.obtainMessageDialog();
    String message=lang.translationForKey(""String_Node_Str"");
    String title=lang.translationForKey(""String_Node_Str"");
    dialog.showMessageDialog(message,title,DialogType.ERROR_MESSAGE);
    shutdown();
    System.exit(0);
  }
  em=new EventManager(recognition,env,contextHandle);
  env.setEventManager(em);
  this.cardStates=new CardStateMap();
  SALStateCallback salCallback=new SALStateCallback(recognition,cardStates);
  em.registerAllEvents(salCallback);
  em.registerAllEvents(this);
  sal=new TinySAL(env,cardStates);
  sal.setGUI(gui);
  sal.addProtocol(ECardConstants.Protocol.EAC2,new EAC2ProtocolFactory());
  sal.addProtocol(ECardConstants.Protocol.EAC_GENERIC,new EACGenericProtocolFactory());
  sal.addProtocol(ECardConstants.Protocol.PIN_COMPARE,new PINCompareProtocolFactory());
  sal.addProtocol(ECardConstants.Protocol.GENERIC_CRYPTO,new GenericCryptoProtocolFactory());
  env.setSAL(sal);
  em.initialize();
  try {
    IntentBinding binding=new IntentBinding();
    ControlHandlers handler=new ControlHandlers();
    GenericTCTokenHandler genericTCTokenHandler=new GenericTCTokenHandler(cardStates,dispatcher,gui,recognition);
    ControlHandler tcTokenHandler=new IntentTCTokenHandler(genericTCTokenHandler);
    handler.addControlHandler(tcTokenHandler);
    ControlInterface control=new ControlInterface(binding,handler);
    control.start();
    IntentHandlerActivity.setHandlers(binding.getHandlers());
  }
 catch (  Exception e) {
    System.exit(0);
  }
  PluginManager pm=new PluginManager(dispatcher,gui,recognition,cardStates,null);
  pm.addPlugin(new PINPlugin());
  initialized=true;
}","/** 
 * Initialize the client by setting properties for Android and starting up each module.
 */
public void initialize(){
  if (initialized) {
    return;
  }
  notificationManager=(NotificationManager)getSystemService(NOTIFICATION_SERVICE);
  AndroidUtils.initLogging(this);
  SharedPreferences preferences=PreferenceManager.getDefaultSharedPreferences(this);
  String noFactory=""String_Node_Str"";
  String factoryImpl=preferences.getString(""String_Node_Str"",noFactory);
  if (factoryImpl.equals(noFactory)) {
    Intent i=new Intent(this,TerminalFactoryActivity.class);
    i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
    i.putExtra(""String_Node_Str"",true);
    this.startActivity(i);
    return;
  }
  IFDProperties.setProperty(""String_Node_Str"",factoryImpl);
  WsdefProperties.setProperty(""String_Node_Str"",""String_Node_Str"");
  try {
    terminalFactory=(AndroidTerminalFactory)IFDTerminalFactory.getInstance();
  }
 catch (  IFDException e) {
    System.exit(0);
  }
  usingNFC=terminalFactory instanceof NFCFactory;
  if (usingNFC) {
    NfcManager manager=(NfcManager)this.getSystemService(Context.NFC_SERVICE);
    NfcAdapter adapter=manager.getDefaultAdapter();
    if (adapter == null || !adapter.isEnabled()) {
      Intent i=new Intent(this,NFCErrorActivity.class);
      i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
      this.startActivity(i);
      return;
    }
  }
  terminalFactory.start(this);
  env=new ClientEnv();
  management=new TinyManagement(env);
  env.setManagement(management);
  dispatcher=new MessageDispatcher(env);
  env.setDispatcher(dispatcher);
  gui=new AndroidUserConsent(this);
  ifd=new IFD();
  ifd.setDispatcher(dispatcher);
  ifd.setGUI(gui);
  ifd.addProtocol(ECardConstants.Protocol.PACE,new PACEProtocolFactory());
  env.setIFD(ifd);
  EstablishContext establishContext=new EstablishContext();
  EstablishContextResponse establishContextResponse=ifd.establishContext(establishContext);
  if (establishContextResponse.getResult().getResultMajor().equals(ECardConstants.Major.OK)) {
    if (establishContextResponse.getContextHandle() != null) {
      contextHandle=establishContextResponse.getContextHandle();
    }
 else {
      logger.error(""String_Node_Str"");
      MessageDialog dialog=gui.obtainMessageDialog();
      String message=lang.translationForKey(""String_Node_Str"");
      String title=lang.translationForKey(""String_Node_Str"");
      dialog.showMessageDialog(message,title,DialogType.ERROR_MESSAGE);
      shutdown();
      System.exit(0);
    }
  }
 else {
    logger.error(""String_Node_Str"");
    MessageDialog dialog=gui.obtainMessageDialog();
    String message=lang.translationForKey(""String_Node_Str"");
    String title=lang.translationForKey(""String_Node_Str"");
    dialog.showMessageDialog(message,title,DialogType.ERROR_MESSAGE);
    shutdown();
    System.exit(0);
  }
  try {
    recognition=new CardRecognition(ifd,contextHandle);
    recognition.setGUI(gui);
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
    MessageDialog dialog=gui.obtainMessageDialog();
    String message=lang.translationForKey(""String_Node_Str"");
    String title=lang.translationForKey(""String_Node_Str"");
    dialog.showMessageDialog(message,title,DialogType.ERROR_MESSAGE);
    shutdown();
    System.exit(0);
  }
  em=new EventManager(recognition,env,contextHandle);
  env.setEventManager(em);
  this.cardStates=new CardStateMap();
  SALStateCallback salCallback=new SALStateCallback(recognition,cardStates);
  em.registerAllEvents(salCallback);
  em.registerAllEvents(this);
  sal=new TinySAL(env,cardStates);
  sal.setGUI(gui);
  sal.addProtocol(ECardConstants.Protocol.EAC2,new EAC2ProtocolFactory());
  sal.addProtocol(ECardConstants.Protocol.EAC_GENERIC,new EACGenericProtocolFactory());
  sal.addProtocol(ECardConstants.Protocol.PIN_COMPARE,new PINCompareProtocolFactory());
  sal.addProtocol(ECardConstants.Protocol.GENERIC_CRYPTO,new GenericCryptoProtocolFactory());
  env.setSAL(sal);
  em.initialize();
  try {
    IntentBinding binding=new IntentBinding();
    ControlHandlers handler=new ControlHandlers();
    GenericTCTokenHandler genericTCTokenHandler=new GenericTCTokenHandler(cardStates,dispatcher,gui,recognition);
    ControlHandler tcTokenHandler=new IntentTCTokenHandler(genericTCTokenHandler);
    handler.addControlHandler(tcTokenHandler);
    ControlInterface control=new ControlInterface(binding,handler);
    control.start();
    IntentHandlerActivity.setHandlers(binding.getHandlers());
  }
 catch (  Exception e) {
    System.exit(0);
  }
  PluginManager pm=new PluginManager(dispatcher,gui,recognition,cardStates,null);
  pm.addPlugin(new PINPlugin());
  initialized=true;
}"
48179,"/** 
 * Initialization method that will be called after the applet is loaded into the browser.
 */
@Override public void init(){
  try {
    LogProperties.loadJavaUtilLogging();
  }
 catch (  IOException ex) {
    System.err.println(""String_Node_Str"");
  }
  env=new ClientEnv();
  management=new TinyManagement(env);
  env.setManagement(management);
  Dispatcher dispatcher=new MessageDispatcher(env);
  env.setDispatcher(dispatcher);
  SwingUserConsent gui=new SwingUserConsent(new SwingDialogWrapper());
  ifd=new IFD();
  ifd.setDispatcher(dispatcher);
  ifd.setGUI(gui);
  ifd.addProtocol(ECardConstants.Protocol.PACE,new PACEProtocolFactory());
  env.setIFD(ifd);
  EstablishContext establishContext=new EstablishContext();
  EstablishContextResponse establishContextResponse=ifd.establishContext(establishContext);
  if (establishContextResponse.getResult().getResultMajor().equals(ECardConstants.Major.OK)) {
    if (establishContextResponse.getContextHandle() != null) {
      contextHandle=establishContextResponse.getContextHandle();
    }
 else {
      logger.error(""String_Node_Str"");
      JOptionPane.showMessageDialog(null,lang.translationForKey(""String_Node_Str""),lang.translationForKey(""String_Node_Str""),JOptionPane.ERROR_MESSAGE,getLogo());
      destroy();
      return;
    }
  }
 else {
    logger.error(""String_Node_Str"");
    JOptionPane.showMessageDialog(null,lang.translationForKey(""String_Node_Str""),lang.translationForKey(""String_Node_Str""),JOptionPane.ERROR_MESSAGE,getLogo());
    destroy();
    return;
  }
  try {
    recognition=new CardRecognition(ifd,contextHandle);
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
    JOptionPane.showMessageDialog(null,lang.translationForKey(""String_Node_Str""),lang.translationForKey(""String_Node_Str""),JOptionPane.ERROR_MESSAGE,getLogo());
    destroy();
    return;
  }
  em=new EventManager(recognition,env,contextHandle);
  env.setEventManager(em);
  this.cardStates=new CardStateMap();
  SALStateCallback salCallback=new SALStateCallback(recognition,cardStates);
  em.registerAllEvents(salCallback);
  sal=new TinySAL(env,cardStates);
  sal.setGUI(gui);
  sal.addProtocol(ECardConstants.Protocol.EAC_GENERIC,new EACGenericProtocolFactory());
  sal.addProtocol(ECardConstants.Protocol.EAC2,new EAC2ProtocolFactory());
  env.setSAL(sal);
  EventHandler evt=new EventHandler(em);
  jsCallback=new JSEventCallback(this,cardStates,dispatcher,evt,gui,sal.getProtocolInfo(),recognition);
  em.initialize();
}","/** 
 * Initialization method that will be called after the applet is loaded into the browser.
 */
@Override public void init(){
  try {
    LogProperties.loadJavaUtilLogging();
  }
 catch (  IOException ex) {
    System.err.println(""String_Node_Str"");
  }
  env=new ClientEnv();
  management=new TinyManagement(env);
  env.setManagement(management);
  Dispatcher dispatcher=new MessageDispatcher(env);
  env.setDispatcher(dispatcher);
  SwingUserConsent gui=new SwingUserConsent(new SwingDialogWrapper());
  ifd=new IFD();
  ifd.setDispatcher(dispatcher);
  ifd.setGUI(gui);
  ifd.addProtocol(ECardConstants.Protocol.PACE,new PACEProtocolFactory());
  env.setIFD(ifd);
  EstablishContext establishContext=new EstablishContext();
  EstablishContextResponse establishContextResponse=ifd.establishContext(establishContext);
  if (establishContextResponse.getResult().getResultMajor().equals(ECardConstants.Major.OK)) {
    if (establishContextResponse.getContextHandle() != null) {
      contextHandle=establishContextResponse.getContextHandle();
    }
 else {
      logger.error(""String_Node_Str"");
      JOptionPane.showMessageDialog(null,lang.translationForKey(""String_Node_Str""),lang.translationForKey(""String_Node_Str""),JOptionPane.ERROR_MESSAGE,getLogo());
      destroy();
      return;
    }
  }
 else {
    logger.error(""String_Node_Str"");
    JOptionPane.showMessageDialog(null,lang.translationForKey(""String_Node_Str""),lang.translationForKey(""String_Node_Str""),JOptionPane.ERROR_MESSAGE,getLogo());
    destroy();
    return;
  }
  try {
    recognition=new CardRecognition(ifd,contextHandle);
    recognition.setGUI(gui);
  }
 catch (  Exception ex) {
    logger.error(ex.getMessage(),ex);
    JOptionPane.showMessageDialog(null,lang.translationForKey(""String_Node_Str""),lang.translationForKey(""String_Node_Str""),JOptionPane.ERROR_MESSAGE,getLogo());
    destroy();
    return;
  }
  em=new EventManager(recognition,env,contextHandle);
  env.setEventManager(em);
  this.cardStates=new CardStateMap();
  SALStateCallback salCallback=new SALStateCallback(recognition,cardStates);
  em.registerAllEvents(salCallback);
  sal=new TinySAL(env,cardStates);
  sal.setGUI(gui);
  sal.addProtocol(ECardConstants.Protocol.EAC_GENERIC,new EACGenericProtocolFactory());
  sal.addProtocol(ECardConstants.Protocol.EAC2,new EAC2ProtocolFactory());
  env.setSAL(sal);
  EventHandler evt=new EventHandler(em);
  jsCallback=new JSEventCallback(this,cardStates,dispatcher,evt,gui,sal.getProtocolInfo(),recognition);
  em.initialize();
}"
48180,"public void setup(){
  GUIDefaults.initialize();
  MessageDialog dialog=new MessageDialog();
  dialog.setHeadline(lang.translationForKey(""String_Node_Str""));
  try {
    tray=new AppTray(this);
    tray.beginSetup();
    env=new ClientEnv();
    TinyManagement management=new TinyManagement(env);
    env.setManagement(management);
    ifd=new IFD();
    ifd.addProtocol(ECardConstants.Protocol.PACE,new PACEProtocolFactory());
    env.setIFD(ifd);
    MessageDispatcher dispatcher=new MessageDispatcher(env);
    env.setDispatcher(dispatcher);
    ifd.setDispatcher(dispatcher);
    EstablishContext establishContext=new EstablishContext();
    EstablishContextResponse establishContextResponse=ifd.establishContext(establishContext);
    WSHelper.checkResult(establishContextResponse);
    contextHandle=ifd.establishContext(establishContext).getContextHandle();
    recognition=new CardRecognition(ifd,contextHandle);
    em=new EventManager(recognition,env,contextHandle);
    env.setEventManager(em);
    cardStates=new CardStateMap();
    SALStateCallback salCallback=new SALStateCallback(recognition,cardStates);
    em.registerAllEvents(salCallback);
    sal=new TinySAL(env,cardStates);
    sal.addProtocol(ECardConstants.Protocol.EAC_GENERIC,new EACGenericProtocolFactory());
    sal.addProtocol(ECardConstants.Protocol.EAC2,new EAC2ProtocolFactory());
    env.setSAL(sal);
    SwingUserConsent gui=new SwingUserConsent(new SwingDialogWrapper());
    sal.setGUI(gui);
    ifd.setGUI(gui);
    tray.endSetup(recognition);
    em.registerAllEvents(tray.status());
    em.initialize();
    try {
      HTTPBinding binding=new HTTPBinding(HTTPBinding.DEFAULT_PORT);
      ControlHandlers handler=new ControlHandlers();
      GenericTCTokenHandler genericTCTokenHandler=new GenericTCTokenHandler(cardStates,dispatcher,gui,recognition);
      EventHandler eventHandler=new EventHandler(em);
      ProtocolInfo pInfo=sal.getProtocolInfo();
      GenericStatusHandler genericStatusHandler=new GenericStatusHandler(cardStates,eventHandler,pInfo,recognition);
      GenericWaitForChangeHandler genericWaitHandler=new GenericWaitForChangeHandler(eventHandler);
      ControlHandler tcTokenHandler=new HttpTCTokenHandler(genericTCTokenHandler);
      ControlHandler statusHandler=new HttpStatusHandler(genericStatusHandler);
      ControlHandler waitHandler=new HttpWaitForChangeHandler(genericWaitHandler);
      handler.addControlHandler(tcTokenHandler);
      handler.addControlHandler(statusHandler);
      handler.addControlHandler(waitHandler);
      control=new ControlInterface(binding,handler);
      control.start();
    }
 catch (    BindException e) {
      dialog.setMessage(lang.translationForKey(""String_Node_Str""));
      throw e;
    }
    String pluginsPath=FileUtils.getHomeConfigDir() + File.separator + ""String_Node_Str""+ File.separator;
    Policy.setPolicy(new PluginPolicy(pluginsPath));
    System.setSecurityManager(new SecurityManager());
    pluginManager=new PluginManager(dispatcher,gui,recognition,cardStates,pluginsPath);
    pluginManager.addPlugin(new PINPlugin());
  }
 catch (  Exception e) {
    _logger.error(e.getMessage(),e);
    if (dialog.getMessage() == null || dialog.getMessage().isEmpty()) {
      dialog.setMessage(e.getMessage());
    }
    JOptionPane.showMessageDialog(null,dialog,""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
    teardown();
  }
}","public void setup(){
  GUIDefaults.initialize();
  MessageDialog dialog=new MessageDialog();
  dialog.setHeadline(lang.translationForKey(""String_Node_Str""));
  try {
    tray=new AppTray(this);
    tray.beginSetup();
    env=new ClientEnv();
    TinyManagement management=new TinyManagement(env);
    env.setManagement(management);
    ifd=new IFD();
    ifd.addProtocol(ECardConstants.Protocol.PACE,new PACEProtocolFactory());
    env.setIFD(ifd);
    MessageDispatcher dispatcher=new MessageDispatcher(env);
    env.setDispatcher(dispatcher);
    ifd.setDispatcher(dispatcher);
    EstablishContext establishContext=new EstablishContext();
    EstablishContextResponse establishContextResponse=ifd.establishContext(establishContext);
    WSHelper.checkResult(establishContextResponse);
    contextHandle=ifd.establishContext(establishContext).getContextHandle();
    recognition=new CardRecognition(ifd,contextHandle);
    em=new EventManager(recognition,env,contextHandle);
    env.setEventManager(em);
    cardStates=new CardStateMap();
    SALStateCallback salCallback=new SALStateCallback(recognition,cardStates);
    em.registerAllEvents(salCallback);
    sal=new TinySAL(env,cardStates);
    sal.addProtocol(ECardConstants.Protocol.EAC_GENERIC,new EACGenericProtocolFactory());
    sal.addProtocol(ECardConstants.Protocol.EAC2,new EAC2ProtocolFactory());
    env.setSAL(sal);
    SwingUserConsent gui=new SwingUserConsent(new SwingDialogWrapper());
    sal.setGUI(gui);
    ifd.setGUI(gui);
    recognition.setGUI(gui);
    tray.endSetup(recognition);
    em.registerAllEvents(tray.status());
    em.initialize();
    try {
      HTTPBinding binding=new HTTPBinding(HTTPBinding.DEFAULT_PORT);
      ControlHandlers handler=new ControlHandlers();
      GenericTCTokenHandler genericTCTokenHandler=new GenericTCTokenHandler(cardStates,dispatcher,gui,recognition);
      EventHandler eventHandler=new EventHandler(em);
      ProtocolInfo pInfo=sal.getProtocolInfo();
      GenericStatusHandler genericStatusHandler=new GenericStatusHandler(cardStates,eventHandler,pInfo,recognition);
      GenericWaitForChangeHandler genericWaitHandler=new GenericWaitForChangeHandler(eventHandler);
      ControlHandler tcTokenHandler=new HttpTCTokenHandler(genericTCTokenHandler);
      ControlHandler statusHandler=new HttpStatusHandler(genericStatusHandler);
      ControlHandler waitHandler=new HttpWaitForChangeHandler(genericWaitHandler);
      handler.addControlHandler(tcTokenHandler);
      handler.addControlHandler(statusHandler);
      handler.addControlHandler(waitHandler);
      control=new ControlInterface(binding,handler);
      control.start();
    }
 catch (    BindException e) {
      dialog.setMessage(lang.translationForKey(""String_Node_Str""));
      throw e;
    }
    String pluginsPath=FileUtils.getHomeConfigDir() + File.separator + ""String_Node_Str""+ File.separator;
    Policy.setPolicy(new PluginPolicy(pluginsPath));
    System.setSecurityManager(new SecurityManager());
    pluginManager=new PluginManager(dispatcher,gui,recognition,cardStates,pluginsPath);
    pluginManager.addPlugin(new PINPlugin());
  }
 catch (  Exception e) {
    _logger.error(e.getMessage(),e);
    if (dialog.getMessage() == null || dialog.getMessage().isEmpty()) {
      dialog.setMessage(e.getMessage());
    }
    JOptionPane.showMessageDialog(null,dialog,""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
    teardown();
  }
}"
48181,"public SwingFileDialog(){
  this.dialog=new JFileChooser();
  this.dialog.setPreferredSize(new Dimension(800,490));
}","public SwingFileDialog(){
  this.dialog=new JFileChooser(){
    @Override protected JDialog createDialog(    Component parent){
      JDialog dialog=super.createDialog(parent);
      dialog.setIconImage(GUIDefaults.getImage(""String_Node_Str"",45,45).getImage());
      return dialog;
    }
  }
;
  this.dialog.setPreferredSize(new Dimension(800,490));
}"
48182,"/** 
 * Activates the client according to the received TCToken.
 * @param request The activation request containing the TCToken.
 * @return The response containing the result of the activation process.
 */
public TCTokenResponse handleActivate(TCTokenRequest request){
  final DynamicContext dynCtx=DynamicContext.getInstance(TR03112Keys.INSTANCE_KEY);
  boolean performChecks=TCTokenHacks.isPerformTR03112Checks(request);
  if (!performChecks) {
    logger.warn(""String_Node_Str"");
  }
  boolean isObjectActivation=request.getTCTokenURL() == null;
  if (isObjectActivation) {
    logger.warn(""String_Node_Str"");
  }
  dynCtx.put(TR03112Keys.TCTOKEN_CHECKS,performChecks);
  dynCtx.put(TR03112Keys.OBJECT_ACTIVATION,isObjectActivation);
  dynCtx.put(TR03112Keys.TCTOKEN_SERVER_CERTIFICATES,request.getCertificates());
  dynCtx.put(TR03112Keys.TCTOKEN_URL,request.getTCTokenURL());
  ConnectionHandleType connectionHandle=null;
  TCTokenResponse response=new TCTokenResponse();
  byte[] requestedContextHandle=request.getContextHandle();
  String ifdName=request.getIFDName();
  BigInteger requestedSlotIndex=request.getSlotIndex();
  if (requestedContextHandle == null || ifdName == null || requestedSlotIndex == null) {
    connectionHandle=getFirstHandle(request.getCardType());
  }
 else {
    ConnectionHandleType requestedHandle=new ConnectionHandleType();
    requestedHandle.setContextHandle(requestedContextHandle);
    requestedHandle.setIFDName(ifdName);
    requestedHandle.setSlotIndex(requestedSlotIndex);
    Set<CardStateEntry> matchingHandles=cardStates.getMatchingEntries(requestedHandle);
    if (!matchingHandles.isEmpty()) {
      connectionHandle=matchingHandles.toArray(new CardStateEntry[]{})[0].handleCopy();
    }
  }
  if (connectionHandle == null) {
    String msg=""String_Node_Str"";
    logger.error(msg);
    response.setResult(WSHelper.makeResultError(ECardConstants.Minor.SAL.CANCELLATION_BY_USER,msg));
    return response;
  }
  try {
    response=doPAOS(request,connectionHandle);
    response=determineRefreshURL(request,response);
    waitForTask(response.getPAOSTask());
    return response;
  }
 catch (  IOException w) {
    logger.error(w.getMessage(),w);
    response.setResult(WSHelper.makeResultUnknownError(w.getMessage()));
    return response;
  }
catch (  DispatcherException w) {
    logger.error(w.getMessage(),w);
    response.setResult(WSHelper.makeResultError(ECardConstants.Minor.App.INCORRECT_PARM,w.getMessage()));
    return response;
  }
catch (  PAOSException w) {
    logger.error(w.getMessage(),w);
    Throwable innerException=w.getCause();
    if (innerException instanceof WSException) {
      response.setResult(((WSException)innerException).getResult());
    }
 else {
      response.setResult(WSHelper.makeResultError(ECardConstants.Minor.App.INCORRECT_PARM,w.getMessage()));
    }
    return response;
  }
}","/** 
 * Activates the client according to the received TCToken.
 * @param request The activation request containing the TCToken.
 * @return The response containing the result of the activation process.
 */
public TCTokenResponse handleActivate(TCTokenRequest request){
  final DynamicContext dynCtx=DynamicContext.getInstance(TR03112Keys.INSTANCE_KEY);
  boolean performChecks=TCTokenHacks.isPerformTR03112Checks(request);
  if (!performChecks) {
    logger.warn(""String_Node_Str"");
  }
  boolean isObjectActivation=request.getTCTokenURL() == null;
  if (isObjectActivation) {
    logger.warn(""String_Node_Str"");
  }
  dynCtx.put(TR03112Keys.TCTOKEN_CHECKS,performChecks);
  dynCtx.put(TR03112Keys.OBJECT_ACTIVATION,isObjectActivation);
  dynCtx.put(TR03112Keys.TCTOKEN_SERVER_CERTIFICATES,request.getCertificates());
  dynCtx.put(TR03112Keys.TCTOKEN_URL,request.getTCTokenURL());
  ConnectionHandleType connectionHandle=null;
  TCTokenResponse response=new TCTokenResponse();
  byte[] requestedContextHandle=request.getContextHandle();
  String ifdName=request.getIFDName();
  BigInteger requestedSlotIndex=request.getSlotIndex();
  if (requestedContextHandle == null || ifdName == null || requestedSlotIndex == null) {
    connectionHandle=getFirstHandle(request.getCardType());
  }
 else {
    ConnectionHandleType requestedHandle=new ConnectionHandleType();
    requestedHandle.setContextHandle(requestedContextHandle);
    requestedHandle.setIFDName(ifdName);
    requestedHandle.setSlotIndex(requestedSlotIndex);
    Set<CardStateEntry> matchingHandles=cardStates.getMatchingEntries(requestedHandle);
    if (!matchingHandles.isEmpty()) {
      connectionHandle=matchingHandles.toArray(new CardStateEntry[]{})[0].handleCopy();
    }
  }
  if (connectionHandle == null) {
    String msg=lang.translationForKey(""String_Node_Str"");
    logger.error(msg);
    response.setResult(WSHelper.makeResultError(ECardConstants.Minor.SAL.CANCELLATION_BY_USER,msg));
    return response;
  }
  try {
    response=doPAOS(request,connectionHandle);
    response=determineRefreshURL(request,response);
    waitForTask(response.getPAOSTask());
    return response;
  }
 catch (  IOException w) {
    logger.error(w.getMessage(),w);
    response.setResult(WSHelper.makeResultUnknownError(w.getMessage()));
    return response;
  }
catch (  DispatcherException w) {
    logger.error(w.getMessage(),w);
    response.setResult(WSHelper.makeResultError(ECardConstants.Minor.App.INCORRECT_PARM,w.getMessage()));
    return response;
  }
catch (  PAOSException w) {
    logger.error(w.getMessage(),w);
    Throwable innerException=w.getCause();
    if (innerException instanceof WSException) {
      response.setResult(((WSException)innerException).getResult());
    }
 else {
      response.setResult(WSHelper.makeResultError(ECardConstants.Minor.App.INCORRECT_PARM,w.getMessage()));
    }
    return response;
  }
}"
48183,"/** 
 * Shut down the whole client by shutting down components.
 */
public void shutdown(){
  try {
    if (em != null) {
      em.terminate();
    }
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
  }
 finally {
    em=null;
    recognition=null;
  }
  try {
    if (management != null) {
      TerminateFramework terminateFramework=new TerminateFramework();
      management.terminateFramework(terminateFramework);
    }
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
  }
 finally {
    management=null;
  }
  try {
    if (sal != null) {
      Terminate terminate=new Terminate();
      sal.terminate(terminate);
    }
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
  }
 finally {
    sal=null;
    cardStates=null;
  }
  try {
    if (ifd != null) {
      ReleaseContext releaseContext=new ReleaseContext();
      releaseContext.setContextHandle(contextHandle);
      ifd.releaseContext(releaseContext);
    }
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
  }
 finally {
    ifd=null;
    contextHandle=null;
  }
  try {
    if (terminalFactory != null) {
      terminalFactory.stop();
    }
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
  }
 finally {
    terminalFactory=null;
  }
  env=null;
  Intent intent=new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);
  File f=new File(SDCARD_OPENECARD);
  Uri uri=Uri.fromFile(f);
  intent.setData(uri);
  sendBroadcast(intent);
}","/** 
 * Shut down the whole client by shutting down components.
 */
public void shutdown(){
  try {
    if (em != null) {
      em.terminate();
    }
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
  }
 finally {
    em=null;
    recognition=null;
  }
  try {
    if (management != null) {
      TerminateFramework terminateFramework=new TerminateFramework();
      management.terminateFramework(terminateFramework);
    }
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
  }
 finally {
    management=null;
  }
  try {
    if (sal != null) {
      Terminate terminate=new Terminate();
      sal.terminate(terminate);
    }
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
  }
 finally {
    sal=null;
    cardStates=null;
  }
  try {
    if (ifd != null) {
      ReleaseContext releaseContext=new ReleaseContext();
      releaseContext.setContextHandle(contextHandle);
      ifd.releaseContext(releaseContext);
    }
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
  }
 finally {
    ifd=null;
    contextHandle=null;
  }
  try {
    if (terminalFactory != null) {
      terminalFactory.stop();
    }
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"",ex);
  }
 finally {
    terminalFactory=null;
  }
  env=null;
  Intent intent=new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);
  File f=new File(SDCARD_OPENECARD);
  Uri uri=Uri.fromFile(f);
  intent.setData(uri);
  sendBroadcast(intent);
  Intent i=new Intent(this,DeviceOpenActivity.class);
  i.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK);
  i.putExtra(AndroidUtils.EXIT,true);
  startActivity(i);
}"
48184,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  intent=getIntent();
  fdSocket=getFilesDir().getAbsolutePath() + ""String_Node_Str"";
  pathSocket=getFilesDir().getAbsolutePath() + ""String_Node_Str"";
  if (t == null) {
    t=new Thread(new SocketCommunicationRunnable());
    t.start();
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  intent=getIntent();
  if (intent.getBooleanExtra(AndroidUtils.EXIT,false)) {
    finish();
  }
  fdSocket=getFilesDir().getAbsolutePath() + ""String_Node_Str"";
  pathSocket=getFilesDir().getAbsolutePath() + ""String_Node_Str"";
  if (t == null) {
    t=new Thread(new SocketCommunicationRunnable());
    t.start();
  }
}"
48185,"/** 
 * Opens a stream to the given URL.
 * @param url URL pointing to the TCToken.
 * @return Resource as a stream.
 * @throws TCTokenException
 */
public static InputStream getStream(URL url) throws TCTokenException, MalformedURLException, KeyStoreException, IOException, GeneralSecurityException, HttpException, URISyntaxException {
  HttpEntity entity=null;
  boolean finished=false;
  while (!finished) {
    logger.info(""String_Node_Str"",url);
    String protocol=url.getProtocol();
    String hostname=url.getHost();
    int port=url.getPort();
    if (port == -1) {
      port=url.getDefaultPort();
    }
    String resource=url.getFile();
    if (!""String_Node_Str"".equals(protocol)) {
      throw new ControlException(""String_Node_Str"");
    }
    TlsAuthenticationCertSave tlsAuth=new TlsAuthenticationCertSave();
    tlsAuth.setHostname(hostname);
    ClientCertTlsClient tlsClient=new ClientCertDefaultTlsClient(hostname);
    tlsClient.setAuthentication(tlsAuth);
    tlsClient.setClientVersion(ProtocolVersion.TLSv11);
    Socket socket=ProxySettings.getDefault().getSocket(hostname,port);
    TlsProtocolHandler h=new TlsProtocolHandler(socket.getInputStream(),socket.getOutputStream());
    h.connect(tlsClient);
    StreamHttpClientConnection conn=new StreamHttpClientConnection(h.getInputStream(),h.getOutputStream());
    HttpContext ctx=new BasicHttpContext();
    HttpRequestExecutor httpexecutor=new HttpRequestExecutor();
    BasicHttpEntityEnclosingRequest req=new BasicHttpEntityEnclosingRequest(""String_Node_Str"",resource);
    req.setParams(conn.getParams());
    HttpRequestHelper.setDefaultHeader(req,hostname);
    req.setHeader(""String_Node_Str"",""String_Node_Str"");
    req.setHeader(""String_Node_Str"",""String_Node_Str"");
    HttpResponse response=httpexecutor.execute(req,conn,ctx);
    StatusLine status=response.getStatusLine();
    int statusCode=status.getStatusCode();
switch (statusCode) {
case 301:
case 302:
case 303:
case 307:
      Header[] headers=response.getHeaders(""String_Node_Str"");
    if (headers.length > 0) {
      String uri=headers[0].getValue();
      url=new URL(uri);
    }
 else {
      throw new TCTokenException(""String_Node_Str"");
    }
  break;
default :
conn.receiveResponseEntity(response);
entity=response.getEntity();
finished=true;
}
}
LimitedInputStream is=new LimitedInputStream(entity.getContent());
return is;
}","/** 
 * Opens a stream to the given URL.
 * @param url URL pointing to the TCToken.
 * @return Resource as a stream.
 * @throws TCTokenException
 */
public static InputStream getStream(URL url) throws TCTokenException, MalformedURLException, KeyStoreException, IOException, GeneralSecurityException, HttpException, URISyntaxException {
  HttpEntity entity=null;
  boolean finished=false;
  while (!finished) {
    logger.info(""String_Node_Str"",url);
    String protocol=url.getProtocol();
    String hostname=url.getHost();
    int port=url.getPort();
    if (port == -1) {
      port=url.getDefaultPort();
    }
    String resource=url.getFile();
    if (!""String_Node_Str"".equals(protocol)) {
      throw new ControlException(""String_Node_Str"");
    }
    TlsAuthenticationCertSave tlsAuth=new TlsAuthenticationCertSave();
    tlsAuth.setHostname(hostname);
    ClientCertTlsClient tlsClient=new ClientCertDefaultTlsClient(hostname);
    tlsClient.setAuthentication(tlsAuth);
    TlsProtocolHandler h;
    try {
      tlsClient.setClientVersion(ProtocolVersion.TLSv11);
      Socket socket=ProxySettings.getDefault().getSocket(hostname,port);
      h=new TlsProtocolHandler(socket.getInputStream(),socket.getOutputStream());
      h.connect(tlsClient);
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"");
      tlsClient.setClientVersion(ProtocolVersion.TLSv10);
      Socket socket=ProxySettings.getDefault().getSocket(hostname,port);
      h=new TlsProtocolHandler(socket.getInputStream(),socket.getOutputStream());
      h.connect(tlsClient);
    }
    StreamHttpClientConnection conn=new StreamHttpClientConnection(h.getInputStream(),h.getOutputStream());
    HttpContext ctx=new BasicHttpContext();
    HttpRequestExecutor httpexecutor=new HttpRequestExecutor();
    BasicHttpEntityEnclosingRequest req=new BasicHttpEntityEnclosingRequest(""String_Node_Str"",resource);
    req.setParams(conn.getParams());
    HttpRequestHelper.setDefaultHeader(req,hostname);
    req.setHeader(""String_Node_Str"",""String_Node_Str"");
    req.setHeader(""String_Node_Str"",""String_Node_Str"");
    HttpResponse response=httpexecutor.execute(req,conn,ctx);
    StatusLine status=response.getStatusLine();
    int statusCode=status.getStatusCode();
switch (statusCode) {
case 301:
case 302:
case 303:
case 307:
      Header[] headers=response.getHeaders(""String_Node_Str"");
    if (headers.length > 0) {
      String uri=headers[0].getValue();
      url=new URL(uri);
    }
 else {
      throw new TCTokenException(""String_Node_Str"");
    }
  break;
default :
conn.receiveResponseEntity(response);
entity=response.getEntity();
finished=true;
}
}
LimitedInputStream is=new LimitedInputStream(entity.getContent());
return is;
}"
48186,"/** 
 * Sends start PAOS and answers all successor messages to the server associated with this instance. Messages are exchanged until the server replies with a   {@code StartPAOSResponse} message.
 * @param message The StartPAOS message which is sent in the first message.
 * @return The {@code StartPAOSResponse} message from the server.
 * @throws DispatcherException In case there errors with the message conversion or the dispatcher.
 * @throws PAOSException In case there were errors in the transport layer.
 */
public StartPAOSResponse sendStartPAOS(StartPAOS message) throws DispatcherException, PAOSException {
  Object msg=message;
  String hostname=endpoint.getHost();
  int port=endpoint.getPort();
  if (port == -1) {
    port=endpoint.getDefaultPort();
  }
  String resource=endpoint.getFile();
  try {
    while (true) {
      Socket socket=ProxySettings.getDefault().getSocket(hostname,port);
      StreamHttpClientConnection conn;
      if (tlsClient != null) {
        InputStream sockIn=socket.getInputStream();
        OutputStream sockOut=socket.getOutputStream();
        TlsProtocolHandler handler=new TlsProtocolHandler(sockIn,sockOut);
        handler.connect(tlsClient);
        conn=new StreamHttpClientConnection(handler.getInputStream(),handler.getOutputStream());
      }
 else {
        conn=new StreamHttpClientConnection(socket.getInputStream(),socket.getOutputStream());
      }
      HttpContext ctx=new BasicHttpContext();
      HttpRequestExecutor httpexecutor=new HttpRequestExecutor();
      DefaultConnectionReuseStrategy reuse=new DefaultConnectionReuseStrategy();
      boolean isReusable;
      do {
        BasicHttpEntityEnclosingRequest req=new BasicHttpEntityEnclosingRequest(""String_Node_Str"",resource);
        req.setParams(conn.getParams());
        HttpRequestHelper.setDefaultHeader(req,hostname);
        String reqMsgStr=createPAOSResponse(msg);
        req.setHeader(ECardConstants.HEADER_KEY_PAOS,ECardConstants.HEADER_VALUE_PAOS);
        req.setHeader(""String_Node_Str"",""String_Node_Str"");
        ContentType reqContentType=ContentType.create(""String_Node_Str"",""String_Node_Str"");
        StringEntity reqMsg=new StringEntity(reqMsgStr,reqContentType);
        req.setEntity(reqMsg);
        req.setHeader(reqMsg.getContentType());
        req.setHeader(""String_Node_Str"",Long.toString(reqMsg.getContentLength()));
        HttpResponse response=httpexecutor.execute(req,conn,ctx);
        int statusCode=response.getStatusLine().getStatusCode();
        checkHTTPStatusCode(msg,statusCode);
        conn.receiveResponseEntity(response);
        HttpEntity entity=response.getEntity();
        Object requestObj=processPAOSRequest(entity.getContent());
        if (requestObj instanceof StartPAOSResponse) {
          StartPAOSResponse startPAOSResponse=(StartPAOSResponse)requestObj;
          WSHelper.checkResult(startPAOSResponse);
          return startPAOSResponse;
        }
        msg=dispatcher.deliver(requestObj);
        isReusable=reuse.keepAlive(response,ctx);
      }
 while (isReusable);
    }
  }
 catch (  HttpException ex) {
    throw new PAOSException(""String_Node_Str"",ex);
  }
catch (  IOException ex) {
    throw new PAOSException(ex);
  }
catch (  SOAPException ex) {
    throw new PAOSException(""String_Node_Str"",ex);
  }
catch (  URISyntaxException ex) {
    throw new PAOSException(""String_Node_Str"",ex);
  }
catch (  MarshallingTypeException ex) {
    throw new DispatcherException(""String_Node_Str"",ex);
  }
catch (  InvocationTargetException ex) {
    throw new DispatcherException(""String_Node_Str"",ex);
  }
catch (  TransformerException ex) {
    throw new DispatcherException(ex);
  }
catch (  WSException ex) {
    throw new PAOSException(ex);
  }
}","/** 
 * Sends start PAOS and answers all successor messages to the server associated with this instance. Messages are exchanged until the server replies with a   {@code StartPAOSResponse} message.
 * @param message The StartPAOS message which is sent in the first message.
 * @return The {@code StartPAOSResponse} message from the server.
 * @throws DispatcherException In case there errors with the message conversion or the dispatcher.
 * @throws PAOSException In case there were errors in the transport layer.
 */
public StartPAOSResponse sendStartPAOS(StartPAOS message) throws DispatcherException, PAOSException {
  Object msg=message;
  String hostname=endpoint.getHost();
  int port=endpoint.getPort();
  if (port == -1) {
    port=endpoint.getDefaultPort();
  }
  String resource=endpoint.getFile();
  try {
    while (true) {
      StreamHttpClientConnection conn;
      try {
        conn=createTlsConnection(hostname,port,ProtocolVersion.TLSv11);
      }
 catch (      IOException ex) {
        logger.error(""String_Node_Str"",ex);
        conn=createTlsConnection(hostname,port,ProtocolVersion.TLSv10);
      }
      HttpContext ctx=new BasicHttpContext();
      HttpRequestExecutor httpexecutor=new HttpRequestExecutor();
      DefaultConnectionReuseStrategy reuse=new DefaultConnectionReuseStrategy();
      boolean isReusable;
      do {
        BasicHttpEntityEnclosingRequest req=new BasicHttpEntityEnclosingRequest(""String_Node_Str"",resource);
        req.setParams(conn.getParams());
        HttpRequestHelper.setDefaultHeader(req,hostname);
        String reqMsgStr=createPAOSResponse(msg);
        req.setHeader(ECardConstants.HEADER_KEY_PAOS,ECardConstants.HEADER_VALUE_PAOS);
        req.setHeader(""String_Node_Str"",""String_Node_Str"");
        ContentType reqContentType=ContentType.create(""String_Node_Str"",""String_Node_Str"");
        StringEntity reqMsg=new StringEntity(reqMsgStr,reqContentType);
        req.setEntity(reqMsg);
        req.setHeader(reqMsg.getContentType());
        req.setHeader(""String_Node_Str"",Long.toString(reqMsg.getContentLength()));
        HttpResponse response=httpexecutor.execute(req,conn,ctx);
        int statusCode=response.getStatusLine().getStatusCode();
        checkHTTPStatusCode(msg,statusCode);
        conn.receiveResponseEntity(response);
        HttpEntity entity=response.getEntity();
        Object requestObj=processPAOSRequest(entity.getContent());
        if (requestObj instanceof StartPAOSResponse) {
          StartPAOSResponse startPAOSResponse=(StartPAOSResponse)requestObj;
          WSHelper.checkResult(startPAOSResponse);
          return startPAOSResponse;
        }
        msg=dispatcher.deliver(requestObj);
        isReusable=reuse.keepAlive(response,ctx);
      }
 while (isReusable);
    }
  }
 catch (  HttpException ex) {
    throw new PAOSException(""String_Node_Str"",ex);
  }
catch (  IOException ex) {
    throw new PAOSException(ex);
  }
catch (  SOAPException ex) {
    throw new PAOSException(""String_Node_Str"",ex);
  }
catch (  URISyntaxException ex) {
    throw new PAOSException(""String_Node_Str"",ex);
  }
catch (  MarshallingTypeException ex) {
    throw new DispatcherException(""String_Node_Str"",ex);
  }
catch (  InvocationTargetException ex) {
    throw new DispatcherException(""String_Node_Str"",ex);
  }
catch (  TransformerException ex) {
    throw new DispatcherException(ex);
  }
catch (  WSException ex) {
    throw new PAOSException(ex);
  }
}"
48187,"@Override public void perform() throws DispatcherException, InvocationTargetException {
  ConnectionHandleType cHandle=waitForCardType(GERMAN_IDENTITY_CARD);
  if (cHandle == null) {
    logger.debug(""String_Node_Str"");
    return;
  }
  cHandle=connectToRootApplication(cHandle);
  RecognizedState pinState=recognizeState(cHandle);
  boolean nativePace;
  try {
    nativePace=genericPACESupport(cHandle);
  }
 catch (  WSException e) {
    logger.error(""String_Node_Str"");
    return;
  }
  ChangePINDialog uc=new ChangePINDialog(gui,dispatcher,cHandle,pinState,!nativePace);
  uc.show();
}","@Override public void perform() throws DispatcherException, InvocationTargetException {
  ConnectionHandleType cHandle=waitForCardType(GERMAN_IDENTITY_CARD);
  if (cHandle == null) {
    logger.debug(""String_Node_Str"");
    return;
  }
  cHandle=connectToRootApplication(cHandle);
  RecognizedState pinState=recognizeState(cHandle);
  boolean nativePace;
  try {
    nativePace=genericPACESupport(cHandle);
  }
 catch (  WSException e) {
    logger.error(""String_Node_Str"");
    return;
  }
  ChangePINDialog uc=new ChangePINDialog(gui,dispatcher,cHandle,pinState,!nativePace);
  uc.show();
  Disconnect d=new Disconnect();
  d.setSlotHandle(cHandle.getSlotHandle());
  dispatcher.deliver(d);
}"
48188,"@Override public void perform() throws DispatcherException, InvocationTargetException {
  ConnectionHandleType cHandle=waitForCardType(GERMAN_IDENTITY_CARD);
  if (cHandle == null) {
    logger.debug(""String_Node_Str"");
    return;
  }
  cHandle=connectToRootApplication(cHandle);
  RecognizedState pinState=recognizeState(cHandle);
  boolean nativePace;
  try {
    nativePace=genericPACESupport(cHandle);
  }
 catch (  WSException e) {
    logger.error(""String_Node_Str"");
    return;
  }
  UnblockPINDialog uc=new UnblockPINDialog(gui,dispatcher,cHandle,pinState,!nativePace);
  uc.show();
}","@Override public void perform() throws DispatcherException, InvocationTargetException {
  ConnectionHandleType cHandle=waitForCardType(GERMAN_IDENTITY_CARD);
  if (cHandle == null) {
    logger.debug(""String_Node_Str"");
    return;
  }
  cHandle=connectToRootApplication(cHandle);
  RecognizedState pinState=recognizeState(cHandle);
  boolean nativePace;
  try {
    nativePace=genericPACESupport(cHandle);
  }
 catch (  WSException e) {
    logger.error(""String_Node_Str"");
    return;
  }
  UnblockPINDialog uc=new UnblockPINDialog(gui,dispatcher,cHandle,pinState,!nativePace);
  uc.show();
  Disconnect d=new Disconnect();
  d.setSlotHandle(cHandle.getSlotHandle());
  dispatcher.deliver(d);
}"
48189,"@Override public StepActionResult perform(Map<String,ExecutionResults> oldResults,StepResult result){
  if (result.isBack()) {
    return new StepActionResult(StepActionResultStatus.BACK);
  }
  DIDAuthenticationDataType paceInput=new DIDAuthenticationDataType();
  paceInput.setProtocol(ECardConstants.Protocol.PACE);
  AuthDataMap tmp;
  try {
    tmp=new AuthDataMap(paceInput);
  }
 catch (  ParserConfigurationException ex) {
    logger.error(""String_Node_Str"",ex);
    return new StepActionResult(StepActionResultStatus.CANCEL);
  }
  AuthDataResponse paceInputMap=tmp.createResponse(paceInput);
  if (capturePin) {
    ExecutionResults executionResults=oldResults.get(getStepID());
    if (!verifyUserInput(executionResults)) {
      return new StepActionResult(StepActionResultStatus.REPEAT,createPINReplacementStep(false,true));
    }
 else {
      paceInputMap.addElement(PACEInputType.PIN,oldPIN);
    }
  }
  paceInputMap.addElement(PACEInputType.PIN_ID,PIN_ID_PIN);
  EstablishChannel establishChannel=new EstablishChannel();
  establishChannel.setSlotHandle(conHandle.getSlotHandle());
  establishChannel.setAuthenticationProtocolData(paceInputMap.getResponse());
  establishChannel.getAuthenticationProtocolData().setProtocol(ECardConstants.Protocol.PACE);
  try {
    EstablishChannelResponse establishChannelResponse=(EstablishChannelResponse)dispatcher.deliver(establishChannel);
    WSHelper.checkResult(establishChannelResponse);
    if (capturePin) {
      sendResetRetryCounter();
    }
 else {
      sendModifyPIN();
    }
    Disconnect disconnect=new Disconnect();
    disconnect.setSlotHandle(conHandle.getSlotHandle());
    try {
      dispatcher.deliver(disconnect);
    }
 catch (    IllegalArgumentException ex) {
      logger.error(""String_Node_Str"",ex);
    }
catch (    InvocationTargetException ex) {
      logger.error(""String_Node_Str"",ex);
    }
catch (    DispatcherException ex) {
      logger.error(""String_Node_Str"",ex);
    }
    return new StepActionResult(StepActionResultStatus.NEXT);
  }
 catch (  WSException ex) {
    if (capturePin) {
      retryCounter--;
      logger.info(""String_Node_Str"",retryCounter);
      if (retryCounter == 1) {
        Step replacementStep=createCANReplacementStep();
        return new StepActionResult(StepActionResultStatus.BACK,replacementStep);
      }
 else {
        Step replacementStep=createPINReplacementStep(true,false);
        return new StepActionResult(StepActionResultStatus.REPEAT,replacementStep);
      }
    }
 else {
      logger.warn(""String_Node_Str"");
      return new StepActionResult(StepActionResultStatus.CANCEL);
    }
  }
catch (  InvocationTargetException ex) {
    logger.error(""String_Node_Str"",ex);
    return new StepActionResult(StepActionResultStatus.CANCEL);
  }
catch (  APDUException ex) {
    logger.error(""String_Node_Str"",ex);
    return new StepActionResult(StepActionResultStatus.CANCEL);
  }
catch (  IllegalArgumentException ex) {
    logger.error(""String_Node_Str"",ex);
    return new StepActionResult(StepActionResultStatus.CANCEL);
  }
catch (  IFDException ex) {
    logger.error(""String_Node_Str"",ex);
    return new StepActionResult(StepActionResultStatus.CANCEL);
  }
catch (  DispatcherException ex) {
    logger.error(""String_Node_Str"",ex);
    return new StepActionResult(StepActionResultStatus.CANCEL);
  }
}","@Override public StepActionResult perform(Map<String,ExecutionResults> oldResults,StepResult result){
  if (result.isBack()) {
    return new StepActionResult(StepActionResultStatus.BACK);
  }
  DIDAuthenticationDataType paceInput=new DIDAuthenticationDataType();
  paceInput.setProtocol(ECardConstants.Protocol.PACE);
  AuthDataMap tmp;
  try {
    tmp=new AuthDataMap(paceInput);
  }
 catch (  ParserConfigurationException ex) {
    logger.error(""String_Node_Str"",ex);
    return new StepActionResult(StepActionResultStatus.CANCEL);
  }
  AuthDataResponse paceInputMap=tmp.createResponse(paceInput);
  if (capturePin) {
    ExecutionResults executionResults=oldResults.get(getStepID());
    if (!verifyUserInput(executionResults)) {
      return new StepActionResult(StepActionResultStatus.REPEAT,createPINReplacementStep(false,true));
    }
 else {
      paceInputMap.addElement(PACEInputType.PIN,oldPIN);
    }
  }
  paceInputMap.addElement(PACEInputType.PIN_ID,PIN_ID_PIN);
  EstablishChannel establishChannel=new EstablishChannel();
  establishChannel.setSlotHandle(conHandle.getSlotHandle());
  establishChannel.setAuthenticationProtocolData(paceInputMap.getResponse());
  establishChannel.getAuthenticationProtocolData().setProtocol(ECardConstants.Protocol.PACE);
  try {
    EstablishChannelResponse establishChannelResponse=(EstablishChannelResponse)dispatcher.deliver(establishChannel);
    WSHelper.checkResult(establishChannelResponse);
    if (capturePin) {
      sendResetRetryCounter();
    }
 else {
      sendModifyPIN();
    }
    return new StepActionResult(StepActionResultStatus.NEXT);
  }
 catch (  WSException ex) {
    if (capturePin) {
      retryCounter--;
      logger.info(""String_Node_Str"",retryCounter);
      if (retryCounter == 1) {
        Step replacementStep=createCANReplacementStep();
        return new StepActionResult(StepActionResultStatus.BACK,replacementStep);
      }
 else {
        Step replacementStep=createPINReplacementStep(true,false);
        return new StepActionResult(StepActionResultStatus.REPEAT,replacementStep);
      }
    }
 else {
      logger.warn(""String_Node_Str"");
      return new StepActionResult(StepActionResultStatus.CANCEL);
    }
  }
catch (  InvocationTargetException ex) {
    logger.error(""String_Node_Str"",ex);
    return new StepActionResult(StepActionResultStatus.CANCEL);
  }
catch (  APDUException ex) {
    logger.error(""String_Node_Str"",ex);
    return new StepActionResult(StepActionResultStatus.CANCEL);
  }
catch (  IllegalArgumentException ex) {
    logger.error(""String_Node_Str"",ex);
    return new StepActionResult(StepActionResultStatus.CANCEL);
  }
catch (  IFDException ex) {
    logger.error(""String_Node_Str"",ex);
    return new StepActionResult(StepActionResultStatus.CANCEL);
  }
catch (  DispatcherException ex) {
    logger.error(""String_Node_Str"",ex);
    return new StepActionResult(StepActionResultStatus.CANCEL);
  }
}"
48190,"/** 
 * Returns the encoded APDU: CLA | INS | P1 | P2 | (EXT)LC | DATA | (EXT)LE
 * @return Encoded APDU
 */
public final byte[] toByteArray(){
  ByteArrayOutputStream baos=new ByteArrayOutputStream(data.length + 10);
  try {
    baos.write(header);
    if (lc > 255) {
      baos.write(x00);
      baos.write((byte)(lc >> 8));
      baos.write((byte)lc);
    }
 else     if (lc > 0) {
      baos.write((byte)lc);
    }
    baos.write(data);
    if (le > 256) {
      if (lc < 256) {
        baos.write(x00);
      }
      if (le == 65536) {
        baos.write(x00);
        baos.write(x00);
      }
      baos.write((byte)(le >> 8));
      baos.write((byte)le);
    }
 else     if (le == 256) {
      baos.write(x00);
    }
 else     if (le > 0) {
      baos.write((byte)le);
    }
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  return baos.toByteArray();
}","/** 
 * Returns the encoded APDU: CLA | INS | P1 | P2 | (EXT)LC | DATA | (EXT)LE
 * @return Encoded APDU
 */
public final byte[] toByteArray(){
  ByteArrayOutputStream baos=new ByteArrayOutputStream(data.length + 10);
  try {
    baos.write(header);
    if (lc > 255) {
      baos.write(x00);
      baos.write((byte)(lc >> 8));
      baos.write((byte)lc);
    }
 else     if (lc > 0) {
      baos.write((byte)lc);
    }
    baos.write(data);
    if (le > 256) {
      if (lc < 256) {
        baos.write(x00);
      }
      if (le == 65536) {
        baos.write(x00);
        baos.write(x00);
      }
      baos.write((byte)(le >> 8));
      baos.write((byte)le);
    }
 else     if (le > 0) {
      if (lc > 255) {
        baos.write((byte)(le >> 8));
        baos.write((byte)le);
      }
 else {
        baos.write((byte)le);
      }
    }
  }
 catch (  IOException ex) {
    logger.error(""String_Node_Str"",ex);
  }
  return baos.toByteArray();
}"
48191,"@Test public void testLengthExpected() throws IOException {
  CardCommandAPDU apdu=new ReadBinary();
  assertEquals(apdu.toByteArray(),new byte[]{(byte)0x00,(byte)0xB0,(byte)0x00,(byte)0xFF});
  apdu.setLE(1);
  assertEquals(apdu.toByteArray(),new byte[]{(byte)0x00,(byte)0xB0,(byte)0x00,(byte)0xFF,(byte)0x01});
  apdu.setLE(255);
  assertEquals(apdu.toByteArray(),new byte[]{(byte)0x00,(byte)0xB0,(byte)0x00,(byte)0xFF,(byte)0xFF});
  apdu.setLE(256);
  assertEquals(apdu.toByteArray(),new byte[]{(byte)0x00,(byte)0xB0,(byte)0x00,(byte)0xFF,(byte)0x00});
  apdu.setLE(257);
  assertEquals(apdu.toByteArray(),new byte[]{(byte)0x00,(byte)0xB0,(byte)0x00,(byte)0xFF,(byte)0x00,(byte)0x01,(byte)0x01});
  apdu.setLE(65535);
  assertEquals(apdu.toByteArray(),new byte[]{(byte)0x00,(byte)0xB0,(byte)0x00,(byte)0xFF,(byte)0x00,(byte)0xFF,(byte)0xFF});
  apdu=new CardCommandAPDU((byte)0x00,(byte)0xB0,(byte)0x00,(byte)0xFF,fillBytes(65535));
  apdu.setLE(65535);
  assertEquals(apdu.getLC(),65535);
  assertEquals(apdu.getLE(),65535);
}","@Test public void testLengthExpected() throws IOException {
  CardCommandAPDU apdu=new ReadBinary();
  assertEquals(apdu.toByteArray(),new byte[]{(byte)0x00,(byte)0xB0,(byte)0x00,(byte)0xFF});
  apdu.setLE(1);
  assertEquals(apdu.toByteArray(),new byte[]{(byte)0x00,(byte)0xB0,(byte)0x00,(byte)0xFF,(byte)0x01});
  apdu.setLE(255);
  assertEquals(apdu.toByteArray(),new byte[]{(byte)0x00,(byte)0xB0,(byte)0x00,(byte)0xFF,(byte)0xFF});
  apdu.setLE(256);
  assertEquals(apdu.toByteArray(),new byte[]{(byte)0x00,(byte)0xB0,(byte)0x00,(byte)0xFF,(byte)0x00});
  apdu.setLE(257);
  assertEquals(apdu.toByteArray(),new byte[]{(byte)0x00,(byte)0xB0,(byte)0x00,(byte)0xFF,(byte)0x00,(byte)0x01,(byte)0x01});
  apdu.setLE(65535);
  assertEquals(apdu.toByteArray(),new byte[]{(byte)0x00,(byte)0xB0,(byte)0x00,(byte)0xFF,(byte)0x00,(byte)0xFF,(byte)0xFF});
  apdu=new CardCommandAPDU((byte)0x00,(byte)0xB0,(byte)0x00,(byte)0xFF,fillBytes(65535));
  apdu.setLE(65535);
  assertEquals(apdu.getLC(),65535);
  assertEquals(apdu.getLE(),65535);
  apdu.setLE(256);
  int length=apdu.toByteArray().length;
  assertEquals(apdu.toByteArray()[length - 2],0x01);
  assertEquals(apdu.toByteArray()[length - 1],0x00);
}"
48192,"/** 
 * Opens a stream to the given URL.
 * @param url URL pointing to the TCToken.
 * @return Resource as a stream.
 * @throws TCTokenException
 */
public static InputStream getStream(URL url) throws TCTokenException, MalformedURLException, KeyStoreException, IOException, GeneralSecurityException, HttpException, URISyntaxException {
  HttpEntity entity=null;
  boolean finished=false;
  while (!finished) {
    logger.info(""String_Node_Str"",url);
    String protocol=url.getProtocol();
    String hostname=url.getHost();
    int port=url.getPort();
    if (port == -1) {
      port=url.getDefaultPort();
    }
    String resource=url.getFile();
    if (!""String_Node_Str"".equals(protocol)) {
      throw new ControlException(""String_Node_Str"");
    }
    TlsAuthenticationCertSave tlsAuth=new TlsAuthenticationCertSave();
    tlsAuth.setHostname(hostname);
    ClientCertTlsClient tlsClient=new ClientCertDefaultTlsClient(hostname);
    tlsClient.setAuthentication(tlsAuth);
    tlsClient.setClientVersion(ProtocolVersion.TLSv11);
    Socket socket=ProxySettings.getDefault().getSocket(hostname,port);
    TlsProtocolHandler h=new TlsProtocolHandler(socket.getInputStream(),socket.getOutputStream());
    h.connect(tlsClient);
    StreamHttpClientConnection conn=new StreamHttpClientConnection(h.getInputStream(),h.getOutputStream());
    HttpContext ctx=new BasicHttpContext();
    HttpRequestExecutor httpexecutor=new HttpRequestExecutor();
    BasicHttpEntityEnclosingRequest req=new BasicHttpEntityEnclosingRequest(""String_Node_Str"",resource);
    req.setParams(conn.getParams());
    HttpRequestHelper.setDefaultHeader(req,hostname);
    req.setHeader(""String_Node_Str"",""String_Node_Str"");
    req.setHeader(""String_Node_Str"",""String_Node_Str"");
    HttpResponse response=httpexecutor.execute(req,conn,ctx);
    StatusLine status=response.getStatusLine();
    int statusCode=status.getStatusCode();
switch (statusCode) {
case 301:
case 302:
case 303:
case 307:
      Header[] headers=response.getHeaders(""String_Node_Str"");
    if (headers.length > 0) {
      String uri=headers[0].getValue();
      url=new URL(uri);
    }
 else {
      throw new TCTokenException(""String_Node_Str"");
    }
  break;
default :
conn.receiveResponseEntity(response);
entity=response.getEntity();
finished=true;
}
}
LimitedInputStream is=new LimitedInputStream(entity.getContent());
return is;
}","/** 
 * Opens a stream to the given URL.
 * @param url URL pointing to the TCToken.
 * @return Resource as a stream.
 * @throws TCTokenException
 */
public static InputStream getStream(URL url) throws TCTokenException, MalformedURLException, KeyStoreException, IOException, GeneralSecurityException, HttpException, URISyntaxException {
  HttpEntity entity=null;
  boolean finished=false;
  while (!finished) {
    logger.info(""String_Node_Str"",url);
    String protocol=url.getProtocol();
    String hostname=url.getHost();
    int port=url.getPort();
    if (port == -1) {
      port=url.getDefaultPort();
    }
    String resource=url.getFile();
    if (!""String_Node_Str"".equals(protocol)) {
      throw new ControlException(""String_Node_Str"");
    }
    TlsAuthenticationCertSave tlsAuth=new TlsAuthenticationCertSave();
    tlsAuth.setHostname(hostname);
    ClientCertTlsClient tlsClient=new ClientCertDefaultTlsClient(hostname);
    tlsClient.setAuthentication(tlsAuth);
    TlsProtocolHandler h;
    try {
      tlsClient.setClientVersion(ProtocolVersion.TLSv11);
      Socket socket=ProxySettings.getDefault().getSocket(hostname,port);
      h=new TlsProtocolHandler(socket.getInputStream(),socket.getOutputStream());
      h.connect(tlsClient);
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"");
      tlsClient.setClientVersion(ProtocolVersion.TLSv10);
      Socket socket=ProxySettings.getDefault().getSocket(hostname,port);
      h=new TlsProtocolHandler(socket.getInputStream(),socket.getOutputStream());
      h.connect(tlsClient);
    }
    StreamHttpClientConnection conn=new StreamHttpClientConnection(h.getInputStream(),h.getOutputStream());
    HttpContext ctx=new BasicHttpContext();
    HttpRequestExecutor httpexecutor=new HttpRequestExecutor();
    BasicHttpEntityEnclosingRequest req=new BasicHttpEntityEnclosingRequest(""String_Node_Str"",resource);
    req.setParams(conn.getParams());
    HttpRequestHelper.setDefaultHeader(req,hostname);
    req.setHeader(""String_Node_Str"",""String_Node_Str"");
    req.setHeader(""String_Node_Str"",""String_Node_Str"");
    HttpResponse response=httpexecutor.execute(req,conn,ctx);
    StatusLine status=response.getStatusLine();
    int statusCode=status.getStatusCode();
switch (statusCode) {
case 301:
case 302:
case 303:
case 307:
      Header[] headers=response.getHeaders(""String_Node_Str"");
    if (headers.length > 0) {
      String uri=headers[0].getValue();
      url=new URL(uri);
    }
 else {
      throw new TCTokenException(""String_Node_Str"");
    }
  break;
default :
conn.receiveResponseEntity(response);
entity=response.getEntity();
finished=true;
}
}
LimitedInputStream is=new LimitedInputStream(entity.getContent());
return is;
}"
48193,"/** 
 * Sends start PAOS and answers all successor messages to the server associated with this instance. Messages are exchanged until the server replies with a   {@code StartPAOSResponse} message.
 * @param message The StartPAOS message which is sent in the first message.
 * @return The {@code StartPAOSResponse} message from the server.
 * @throws DispatcherException In case there errors with the message conversion or the dispatcher.
 * @throws PAOSException In case there were errors in the transport layer.
 */
public StartPAOSResponse sendStartPAOS(StartPAOS message) throws DispatcherException, PAOSException {
  Object msg=message;
  String hostname=endpoint.getHost();
  int port=endpoint.getPort();
  if (port == -1) {
    port=endpoint.getDefaultPort();
  }
  String resource=endpoint.getFile();
  try {
    while (true) {
      Socket socket=ProxySettings.getDefault().getSocket(hostname,port);
      StreamHttpClientConnection conn;
      if (tlsClient != null) {
        InputStream sockIn=socket.getInputStream();
        OutputStream sockOut=socket.getOutputStream();
        TlsProtocolHandler handler=new TlsProtocolHandler(sockIn,sockOut);
        handler.connect(tlsClient);
        conn=new StreamHttpClientConnection(handler.getInputStream(),handler.getOutputStream());
      }
 else {
        conn=new StreamHttpClientConnection(socket.getInputStream(),socket.getOutputStream());
      }
      HttpContext ctx=new BasicHttpContext();
      HttpRequestExecutor httpexecutor=new HttpRequestExecutor();
      DefaultConnectionReuseStrategy reuse=new DefaultConnectionReuseStrategy();
      boolean isReusable;
      do {
        BasicHttpEntityEnclosingRequest req=new BasicHttpEntityEnclosingRequest(""String_Node_Str"",resource);
        req.setParams(conn.getParams());
        HttpRequestHelper.setDefaultHeader(req,hostname);
        String reqMsgStr=createPAOSResponse(msg);
        req.setHeader(ECardConstants.HEADER_KEY_PAOS,ECardConstants.HEADER_VALUE_PAOS);
        req.setHeader(""String_Node_Str"",""String_Node_Str"");
        ContentType reqContentType=ContentType.create(""String_Node_Str"",""String_Node_Str"");
        StringEntity reqMsg=new StringEntity(reqMsgStr,reqContentType);
        req.setEntity(reqMsg);
        req.setHeader(reqMsg.getContentType());
        req.setHeader(""String_Node_Str"",Long.toString(reqMsg.getContentLength()));
        HttpResponse response=httpexecutor.execute(req,conn,ctx);
        int statusCode=response.getStatusLine().getStatusCode();
        checkHTTPStatusCode(msg,statusCode);
        conn.receiveResponseEntity(response);
        HttpEntity entity=response.getEntity();
        Object requestObj=processPAOSRequest(entity.getContent());
        if (requestObj instanceof StartPAOSResponse) {
          StartPAOSResponse startPAOSResponse=(StartPAOSResponse)requestObj;
          WSHelper.checkResult(startPAOSResponse);
          return startPAOSResponse;
        }
        msg=dispatcher.deliver(requestObj);
        isReusable=reuse.keepAlive(response,ctx);
      }
 while (isReusable);
    }
  }
 catch (  HttpException ex) {
    throw new PAOSException(""String_Node_Str"",ex);
  }
catch (  IOException ex) {
    throw new PAOSException(ex);
  }
catch (  SOAPException ex) {
    throw new PAOSException(""String_Node_Str"",ex);
  }
catch (  URISyntaxException ex) {
    throw new PAOSException(""String_Node_Str"",ex);
  }
catch (  MarshallingTypeException ex) {
    throw new DispatcherException(""String_Node_Str"",ex);
  }
catch (  InvocationTargetException ex) {
    throw new DispatcherException(""String_Node_Str"",ex);
  }
catch (  TransformerException ex) {
    throw new DispatcherException(ex);
  }
catch (  WSException ex) {
    throw new PAOSException(ex);
  }
}","/** 
 * Sends start PAOS and answers all successor messages to the server associated with this instance. Messages are exchanged until the server replies with a   {@code StartPAOSResponse} message.
 * @param message The StartPAOS message which is sent in the first message.
 * @return The {@code StartPAOSResponse} message from the server.
 * @throws DispatcherException In case there errors with the message conversion or the dispatcher.
 * @throws PAOSException In case there were errors in the transport layer.
 */
public StartPAOSResponse sendStartPAOS(StartPAOS message) throws DispatcherException, PAOSException {
  Object msg=message;
  String hostname=endpoint.getHost();
  int port=endpoint.getPort();
  if (port == -1) {
    port=endpoint.getDefaultPort();
  }
  String resource=endpoint.getFile();
  try {
    while (true) {
      StreamHttpClientConnection conn;
      try {
        conn=createTlsConnection(hostname,port,ProtocolVersion.TLSv11);
      }
 catch (      IOException ex) {
        logger.error(""String_Node_Str"",ex);
        conn=createTlsConnection(hostname,port,ProtocolVersion.TLSv10);
      }
      HttpContext ctx=new BasicHttpContext();
      HttpRequestExecutor httpexecutor=new HttpRequestExecutor();
      DefaultConnectionReuseStrategy reuse=new DefaultConnectionReuseStrategy();
      boolean isReusable;
      do {
        BasicHttpEntityEnclosingRequest req=new BasicHttpEntityEnclosingRequest(""String_Node_Str"",resource);
        req.setParams(conn.getParams());
        HttpRequestHelper.setDefaultHeader(req,hostname);
        String reqMsgStr=createPAOSResponse(msg);
        req.setHeader(ECardConstants.HEADER_KEY_PAOS,ECardConstants.HEADER_VALUE_PAOS);
        req.setHeader(""String_Node_Str"",""String_Node_Str"");
        ContentType reqContentType=ContentType.create(""String_Node_Str"",""String_Node_Str"");
        StringEntity reqMsg=new StringEntity(reqMsgStr,reqContentType);
        req.setEntity(reqMsg);
        req.setHeader(reqMsg.getContentType());
        req.setHeader(""String_Node_Str"",Long.toString(reqMsg.getContentLength()));
        HttpResponse response=httpexecutor.execute(req,conn,ctx);
        int statusCode=response.getStatusLine().getStatusCode();
        checkHTTPStatusCode(msg,statusCode);
        conn.receiveResponseEntity(response);
        HttpEntity entity=response.getEntity();
        Object requestObj=processPAOSRequest(entity.getContent());
        if (requestObj instanceof StartPAOSResponse) {
          StartPAOSResponse startPAOSResponse=(StartPAOSResponse)requestObj;
          WSHelper.checkResult(startPAOSResponse);
          return startPAOSResponse;
        }
        msg=dispatcher.deliver(requestObj);
        isReusable=reuse.keepAlive(response,ctx);
      }
 while (isReusable);
    }
  }
 catch (  HttpException ex) {
    throw new PAOSException(""String_Node_Str"",ex);
  }
catch (  IOException ex) {
    throw new PAOSException(ex);
  }
catch (  SOAPException ex) {
    throw new PAOSException(""String_Node_Str"",ex);
  }
catch (  URISyntaxException ex) {
    throw new PAOSException(""String_Node_Str"",ex);
  }
catch (  MarshallingTypeException ex) {
    throw new DispatcherException(""String_Node_Str"",ex);
  }
catch (  InvocationTargetException ex) {
    throw new DispatcherException(""String_Node_Str"",ex);
  }
catch (  TransformerException ex) {
    throw new DispatcherException(ex);
  }
catch (  WSException ex) {
    throw new PAOSException(ex);
  }
}"
48194,"private CardApplicationType parseCardApplication(XmlPullParser parser) throws XmlPullParserException, IOException {
  CardApplicationType cardApplication=new CardApplicationType();
  int eventType;
  do {
    parser.next();
    eventType=parser.getEventType();
    if (eventType == XmlPullParser.START_TAG) {
      if (parser.getName().equals(""String_Node_Str"")) {
        cardApplication.setApplicationIdentifier(StringUtils.toByteArray(parser.nextText()));
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        cardApplication.setApplicationName(parser.nextText());
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        cardApplication.setRequirementLevel(BasicRequirementsType.fromValue(parser.nextText()));
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        cardApplication.setCardApplicationACL(this.parseACL(parser,""String_Node_Str""));
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        cardApplication.getDIDInfo().add(this.parseDIDInfo(parser));
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        cardApplication.getDataSetInfo().add(this.parseDataSetInfo(parser));
      }
    }
  }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
  return cardApplication;
}","private CardApplicationType parseCardApplication(XmlPullParser parser) throws XmlPullParserException, IOException {
  CardApplicationType cardApplication=new CardApplicationType();
  int eventType;
  do {
    parser.next();
    eventType=parser.getEventType();
    if (eventType == XmlPullParser.START_TAG) {
      if (parser.getName().equals(""String_Node_Str"")) {
        cardApplication.setApplicationIdentifier(StringUtils.toByteArray(parser.nextText()));
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        cardApplication.setApplicationName(parser.nextText());
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        cardApplication.setRequirementLevel(BasicRequirementsType.fromValue(parser.nextText()));
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        cardApplication.setCardApplicationACL(this.parseACL(parser,""String_Node_Str""));
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        cardApplication.getDIDInfo().add(this.parseDIDInfo(parser));
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        cardApplication.getDataSetInfo().add(this.parseDataSetInfo(parser));
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        cardApplication.getInterfaceProtocol().add(parser.nextText());
      }
    }
  }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
  return cardApplication;
}"
48195,"private Collection<? extends Element> parseAnyTypes(XmlPullParser parser,String name,String ns,Document d,Boolean firstCall) throws XmlPullParserException, IOException {
  int eventType;
  List<Element> elements=new ArrayList<Element>();
  boolean terminalNode=false;
  do {
    parser.next();
    eventType=parser.getEventType();
    if (eventType == XmlPullParser.START_TAG) {
      elements.addAll(parseAnyTypes(parser,parser.getName(),parser.getNamespace(),d,true));
    }
 else     if (eventType == XmlPullParser.TEXT) {
      if (parser.getText().trim().length() > 0) {
        Element em=d.createElementNS(ns,name);
        em.setTextContent(parser.getText());
        elements.add(em);
        terminalNode=true;
      }
    }
  }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(name)));
  if (!terminalNode && firstCall) {
    Element test=d.createElementNS(ns,name);
    for (    Element e : elements) {
      test.appendChild(e);
    }
    List<Element> elements2=new ArrayList<Element>();
    elements2.add(test);
    return elements2;
  }
  return elements;
}","private Collection<? extends Element> parseAnyTypes(XmlPullParser parser,String name,String ns,Document d,Boolean firstCall,String[] attribNames,String[] attribValues) throws XmlPullParserException, IOException {
  int eventType;
  List<Element> elements=new ArrayList<Element>();
  boolean terminalNode=false;
  do {
    String[] attributeNames=new String[0];
    String[] attributeValues=new String[0];
    parser.next();
    eventType=parser.getEventType();
    if (eventType == XmlPullParser.START_TAG) {
      int attributeCount=parser.getAttributeCount();
      if (attributeCount > 0) {
        attributeNames=new String[attributeCount];
        attributeValues=new String[attributeCount];
        for (int i=0; i < attributeCount; i++) {
          attributeNames[i]=parser.getAttributeName(i);
          attributeValues[i]=parser.getAttributeValue(i);
        }
      }
      elements.addAll(parseAnyTypes(parser,parser.getName(),parser.getNamespace(),d,true,attributeNames,attributeValues));
    }
 else     if (eventType == XmlPullParser.TEXT) {
      if (parser.getText().trim().length() > 0) {
        Element em=d.createElementNS(ns,name);
        em.setTextContent(parser.getText());
        elements.add(em);
        terminalNode=true;
      }
    }
  }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(name)));
  if (!terminalNode && firstCall) {
    Element test=d.createElementNS(ns,name);
    for (    Element e : elements) {
      test.appendChild(e);
    }
    List<Element> elements2=new ArrayList<Element>();
    for (int i=0; i < attribNames.length; i++) {
      test.setAttribute(attribNames[i],attribValues[i]);
    }
    elements2.add(test);
    return elements2;
  }
  return elements;
}"
48196,"private synchronized Object parse(XmlPullParser parser) throws XmlPullParserException, IOException, ParserConfigurationException {
  if (parser.getName().equals(""String_Node_Str"")) {
    DestroyChannelResponse destroyChannelResponse=new DestroyChannelResponse();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          destroyChannelResponse.setResult(this.parseResult(parser));
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return destroyChannelResponse;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    EstablishChannelResponse establishChannelResponse=new EstablishChannelResponse();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          establishChannelResponse.setResult(this.parseResult(parser));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          establishChannelResponse.setAuthenticationProtocolData(this.parseDIDAuthenticationDataType(parser));
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return establishChannelResponse;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    DIDAuthenticate didAuthenticate=new DIDAuthenticate();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          didAuthenticate.setDIDName(parser.nextText());
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          ConnectionHandleType cht=new ConnectionHandleType();
          cht.setSlotHandle(StringUtils.toByteArray(parser.nextText()));
          didAuthenticate.setConnectionHandle(cht);
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          didAuthenticate.setAuthenticationProtocolData(this.parseDIDAuthenticationDataType(parser));
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return didAuthenticate;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    StartPAOSResponse startPAOSResponse=new StartPAOSResponse();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          startPAOSResponse.setResult(this.parseResult(parser));
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return startPAOSResponse;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    InitializeFramework initializeFramework=new InitializeFramework();
    return initializeFramework;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    return parseConclusion(parser);
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    WaitResponse waitResponse=new WaitResponse();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          waitResponse.setResult(this.parseResult(parser));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          waitResponse.getIFDEvent().add(parseIFDStatusType(parser,""String_Node_Str""));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          waitResponse.setSessionIdentifier(parser.nextText());
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return waitResponse;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    GetStatusResponse getStatusResponse=new GetStatusResponse();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          getStatusResponse.setResult(this.parseResult(parser));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          getStatusResponse.getIFDStatus().add(parseIFDStatusType(parser,""String_Node_Str""));
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return getStatusResponse;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    ListIFDs listIFDs=new ListIFDs();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          listIFDs.setContextHandle(StringUtils.toByteArray(parser.nextText()));
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return listIFDs;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    GetRecognitionTreeResponse resp=new GetRecognitionTreeResponse();
    RecognitionTree recTree=new RecognitionTree();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          resp.setResult(this.parseResult(parser));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          recTree.getCardCall().add(this.parseCardCall(parser));
        }
      }
 else       if (eventType == XmlPullParser.END_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    resp.setRecognitionTree(recTree);
    return resp;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    EstablishContext establishContext=new EstablishContext();
    return establishContext;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    EstablishContextResponse establishContextResponse=new EstablishContextResponse();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          establishContextResponse.setResult(this.parseResult(parser));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          establishContextResponse.setContextHandle(StringUtils.toByteArray(parser.nextText()));
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return establishContextResponse;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    ListIFDsResponse listIFDsResponse=new ListIFDsResponse();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          listIFDsResponse.setResult(this.parseResult(parser));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          listIFDsResponse.getIFDName().add(parser.nextText());
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return listIFDsResponse;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    ConnectResponse connectResponse=new ConnectResponse();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          connectResponse.setResult(this.parseResult(parser));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          connectResponse.setSlotHandle(StringUtils.toByteArray(parser.nextText()));
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return connectResponse;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    Connect c=new Connect();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          c.setIFDName(parser.nextText());
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          c.setContextHandle(StringUtils.toByteArray(parser.nextText()));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          c.setSlot(new BigInteger(parser.nextText()));
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return c;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    Disconnect d=new Disconnect();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          d.setSlotHandle(StringUtils.toByteArray(parser.nextText()));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          d.setAction(ActionType.fromValue(parser.nextText()));
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return d;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    Transmit t=new Transmit();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          t.getInputAPDUInfo().add(this.parseInputAPDUInfo(parser));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          t.setSlotHandle(StringUtils.toByteArray(parser.nextText()));
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return t;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    TransmitResponse transmitResponse=new TransmitResponse();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          transmitResponse.setResult(this.parseResult(parser));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          transmitResponse.getOutputAPDU().add(StringUtils.toByteArray(parser.nextText()));
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return transmitResponse;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    CardInfo cardInfo=new CardInfo();
    ApplicationCapabilitiesType applicationCapabilities=new ApplicationCapabilitiesType();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          CardTypeType cardType=new CardTypeType();
          cardType.setObjectIdentifier(parser.nextText());
          cardInfo.setCardType(cardType);
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          applicationCapabilities.setImplicitlySelectedApplication(StringUtils.toByteArray(parser.nextText()));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          applicationCapabilities.getCardApplication().add(this.parseCardApplication(parser));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          InternationalStringType internationalString=new InternationalStringType();
          internationalString.setLang(parser.getAttributeValue(""String_Node_Str"",""String_Node_Str""));
          internationalString.setValue(parser.nextText());
          cardInfo.getCardType().getCardTypeName().add(internationalString);
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    cardInfo.setApplicationCapabilities(applicationCapabilities);
    return cardInfo;
  }
 else {
    return null;
  }
}","private synchronized Object parse(XmlPullParser parser) throws XmlPullParserException, IOException, ParserConfigurationException, DatatypeConfigurationException {
  if (parser.getName().equals(""String_Node_Str"")) {
    DestroyChannelResponse destroyChannelResponse=new DestroyChannelResponse();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          destroyChannelResponse.setResult(this.parseResult(parser));
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return destroyChannelResponse;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    EstablishChannelResponse establishChannelResponse=new EstablishChannelResponse();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          establishChannelResponse.setResult(this.parseResult(parser));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          establishChannelResponse.setAuthenticationProtocolData(this.parseDIDAuthenticationDataType(parser));
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return establishChannelResponse;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    DIDAuthenticate didAuthenticate=new DIDAuthenticate();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          didAuthenticate.setDIDName(parser.nextText());
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          ConnectionHandleType cht=new ConnectionHandleType();
          cht.setSlotHandle(StringUtils.toByteArray(parser.nextText()));
          didAuthenticate.setConnectionHandle(cht);
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          didAuthenticate.setAuthenticationProtocolData(this.parseDIDAuthenticationDataType(parser));
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return didAuthenticate;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    StartPAOSResponse startPAOSResponse=new StartPAOSResponse();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          startPAOSResponse.setResult(this.parseResult(parser));
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return startPAOSResponse;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    InitializeFramework initializeFramework=new InitializeFramework();
    return initializeFramework;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    return parseConclusion(parser);
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    WaitResponse waitResponse=new WaitResponse();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          waitResponse.setResult(this.parseResult(parser));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          waitResponse.getIFDEvent().add(parseIFDStatusType(parser,""String_Node_Str""));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          waitResponse.setSessionIdentifier(parser.nextText());
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return waitResponse;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    GetStatusResponse getStatusResponse=new GetStatusResponse();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          getStatusResponse.setResult(this.parseResult(parser));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          getStatusResponse.getIFDStatus().add(parseIFDStatusType(parser,""String_Node_Str""));
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return getStatusResponse;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    ListIFDs listIFDs=new ListIFDs();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          listIFDs.setContextHandle(StringUtils.toByteArray(parser.nextText()));
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return listIFDs;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    GetRecognitionTreeResponse resp=new GetRecognitionTreeResponse();
    RecognitionTree recTree=new RecognitionTree();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          resp.setResult(this.parseResult(parser));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          recTree.getCardCall().add(this.parseCardCall(parser));
        }
      }
 else       if (eventType == XmlPullParser.END_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    resp.setRecognitionTree(recTree);
    return resp;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    EstablishContext establishContext=new EstablishContext();
    return establishContext;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    EstablishContextResponse establishContextResponse=new EstablishContextResponse();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          establishContextResponse.setResult(this.parseResult(parser));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          establishContextResponse.setContextHandle(StringUtils.toByteArray(parser.nextText()));
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return establishContextResponse;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    ListIFDsResponse listIFDsResponse=new ListIFDsResponse();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          listIFDsResponse.setResult(this.parseResult(parser));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          listIFDsResponse.getIFDName().add(parser.nextText());
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return listIFDsResponse;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    ConnectResponse connectResponse=new ConnectResponse();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          connectResponse.setResult(this.parseResult(parser));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          connectResponse.setSlotHandle(StringUtils.toByteArray(parser.nextText()));
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return connectResponse;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    Connect c=new Connect();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          c.setIFDName(parser.nextText());
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          c.setContextHandle(StringUtils.toByteArray(parser.nextText()));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          c.setSlot(new BigInteger(parser.nextText()));
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return c;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    Disconnect d=new Disconnect();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          d.setSlotHandle(StringUtils.toByteArray(parser.nextText()));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          d.setAction(ActionType.fromValue(parser.nextText()));
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return d;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    Transmit t=new Transmit();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          t.getInputAPDUInfo().add(this.parseInputAPDUInfo(parser));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          t.setSlotHandle(StringUtils.toByteArray(parser.nextText()));
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return t;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    TransmitResponse transmitResponse=new TransmitResponse();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          transmitResponse.setResult(this.parseResult(parser));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          transmitResponse.getOutputAPDU().add(StringUtils.toByteArray(parser.nextText()));
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    return transmitResponse;
  }
 else   if (parser.getName().equals(""String_Node_Str"")) {
    CardInfo cardInfo=new CardInfo();
    ApplicationCapabilitiesType applicationCapabilities=new ApplicationCapabilitiesType();
    int eventType;
    do {
      parser.next();
      eventType=parser.getEventType();
      if (eventType == XmlPullParser.START_TAG) {
        if (parser.getName().equals(""String_Node_Str"")) {
          CardTypeType cardType=new CardTypeType();
          cardType.setObjectIdentifier(parser.nextText());
          cardInfo.setCardType(cardType);
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          applicationCapabilities.setImplicitlySelectedApplication(StringUtils.toByteArray(parser.nextText()));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          applicationCapabilities.getCardApplication().add(this.parseCardApplication(parser));
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          InternationalStringType internationalString=new InternationalStringType();
          String lang=parser.getAttributeValue(""String_Node_Str"",""String_Node_Str"");
          internationalString.setLang(lang);
          internationalString.setValue(parser.nextText());
          cardInfo.getCardType().getCardTypeName().add(internationalString);
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          cardInfo.getCardType().setSpecificationBodyOrIssuer(parser.nextText());
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          cardInfo.getCardType().setStatus(parser.nextText());
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          String text=parser.nextText();
          XMLGregorianCalendar date=DatatypeFactory.newInstance().newXMLGregorianCalendar(text);
          cardInfo.getCardType().setDate(date);
        }
 else         if (parser.getName().equals(""String_Node_Str"")) {
          cardInfo.getCardType().setVersion(this.parseVersion(parser));
        }
      }
    }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
    cardInfo.setApplicationCapabilities(applicationCapabilities);
    return cardInfo;
  }
 else {
    return null;
  }
}"
48197,"private DIDMarkerType parseDIDMarkerType(XmlPullParser parser) throws XmlPullParserException, IOException {
  DIDMarkerType didMarker=new DIDMarkerType();
  int eventType;
  do {
    parser.next();
    eventType=parser.getEventType();
    if (eventType == XmlPullParser.START_TAG) {
      if (parser.getName().equals(""String_Node_Str"")) {
        didMarker.setPACEMarker(this.parsePACEMarker(parser));
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        didMarker.setTAMarker(this.parseTAMarker(parser));
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        didMarker.setCAMarker(this.parseCAMarker(parser));
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        didMarker.setRIMarker(this.parseRIMarker(parser));
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        didMarker.setCryptoMarker(this.parseCryptoMarker(parser));
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        didMarker.setPinCompareMarker(this.parsePINCompareMarker(parser));
      }
 else {
        throw new IOException(parser.getName() + ""String_Node_Str"");
      }
    }
  }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
  return didMarker;
}","private DIDMarkerType parseDIDMarkerType(XmlPullParser parser) throws XmlPullParserException, IOException {
  DIDMarkerType didMarker=new DIDMarkerType();
  int eventType;
  do {
    parser.next();
    eventType=parser.getEventType();
    if (eventType == XmlPullParser.START_TAG) {
      if (parser.getName().equals(""String_Node_Str"")) {
        didMarker.setPACEMarker((PACEMarkerType)this.parseMarker(parser,PACEMarkerType.class));
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        didMarker.setTAMarker((TAMarkerType)this.parseMarker(parser,TAMarkerType.class));
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        didMarker.setCAMarker((CAMarkerType)this.parseMarker(parser,CAMarkerType.class));
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        didMarker.setRIMarker((RIMarkerType)this.parseMarker(parser,RIMarkerType.class));
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        didMarker.setCryptoMarker((CryptoMarkerType)this.parseMarker(parser,CryptoMarkerType.class));
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        didMarker.setPinCompareMarker((PinCompareMarkerType)this.parseMarker(parser,PinCompareMarkerType.class));
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        didMarker.setRSAAuthMarker((RSAAuthMarkerType)this.parseMarker(parser,RSAAuthMarkerType.class));
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        didMarker.setMutualAuthMarker((MutualAuthMarkerType)this.parseMarker(parser,MutualAuthMarkerType.class));
      }
 else {
        throw new IOException(parser.getName() + ""String_Node_Str"");
      }
    }
  }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
  return didMarker;
}"
48198,"private Result parseResult(XmlPullParser parser) throws XmlPullParserException, IOException {
  Result r=new Result();
  int eventType;
  do {
    parser.next();
    eventType=parser.getEventType();
    if (eventType == XmlPullParser.START_TAG) {
      if (parser.getName().equals(""String_Node_Str"")) {
        r.setResultMajor(parser.nextText());
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        r.setResultMinor(parser.nextText());
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        InternationalStringType internationalStringType=new InternationalStringType();
        internationalStringType.setLang(parser.getAttributeValue(""String_Node_Str"",""String_Node_Str""));
        internationalStringType.setValue(parser.nextText());
        r.setResultMessage(internationalStringType);
      }
    }
  }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
  return r;
}","private Result parseResult(XmlPullParser parser) throws XmlPullParserException, IOException {
  Result r=new Result();
  int eventType;
  do {
    parser.next();
    eventType=parser.getEventType();
    if (eventType == XmlPullParser.START_TAG) {
      if (parser.getName().equals(""String_Node_Str"")) {
        r.setResultMajor(parser.nextText());
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        r.setResultMinor(parser.nextText());
      }
 else       if (parser.getName().equals(""String_Node_Str"")) {
        InternationalStringType internationalStringType=new InternationalStringType();
        String lang=parser.getAttributeValue(""String_Node_Str"",""String_Node_Str"");
        internationalStringType.setLang(lang);
        internationalStringType.setValue(parser.nextText());
        r.setResultMessage(internationalStringType);
      }
    }
  }
 while (!(eventType == XmlPullParser.END_TAG && parser.getName().equals(""String_Node_Str"")));
  return r;
}"
48199,"@Test public void testConversionOfCardInfo() throws Exception {
  WSMarshaller m=new AndroidMarshaller();
  Object o=m.unmarshal(m.str2doc(npaCif));
  if (!(o instanceof CardInfo)) {
    throw new Exception(""String_Node_Str"");
  }
  CardInfo cardInfo=(CardInfo)o;
  assertEquals(""String_Node_Str"",cardInfo.getCardType().getObjectIdentifier());
  assertEquals(new byte[]{0x3F,0x00},cardInfo.getApplicationCapabilities().getImplicitlySelectedApplication());
  assertEquals(cardInfo.getApplicationCapabilities().getCardApplication().size(),3);
  assertEquals(cardInfo.getApplicationCapabilities().getCardApplication().get(0).getApplicationName(),""String_Node_Str"");
  assertEquals(cardInfo.getApplicationCapabilities().getCardApplication().get(0).getRequirementLevel(),BasicRequirementsType.PERSONALIZATION_MANDATORY);
  assertEquals(cardInfo.getApplicationCapabilities().getCardApplication().get(0).getCardApplicationACL().getAccessRule().size(),40);
  assertEquals(cardInfo.getApplicationCapabilities().getCardApplication().get(0).getCardApplicationACL().getAccessRule().get(0).getCardApplicationServiceName(),""String_Node_Str"");
  assertEquals(cardInfo.getApplicationCapabilities().getCardApplication().get(0).getCardApplicationACL().getAccessRule().get(0).getAction().getAPIAccessEntryPoint(),APIAccessEntryPointName.INITIALIZE);
  assertTrue(cardInfo.getApplicationCapabilities().getCardApplication().get(0).getCardApplicationACL().getAccessRule().get(0).getSecurityCondition().isAlways());
  assertEquals(cardInfo.getApplicationCapabilities().getCardApplication().get(0).getCardApplicationACL().getAccessRule().get(39).getAction().getAuthorizationServiceAction(),AuthorizationServiceActionName.ACL_MODIFY);
  assertFalse(cardInfo.getApplicationCapabilities().getCardApplication().get(0).getCardApplicationACL().getAccessRule().get(39).getSecurityCondition().isNever());
  assertEquals(cardInfo.getApplicationCapabilities().getCardApplication().get(0).getDIDInfo().get(0).getRequirementLevel(),BasicRequirementsType.PERSONALIZATION_MANDATORY);
  assertEquals(cardInfo.getApplicationCapabilities().getCardApplication().get(0).getDIDInfo().get(0).getDIDACL().getAccessRule().get(0).getCardApplicationServiceName(),""String_Node_Str"");
  assertEquals(cardInfo.getApplicationCapabilities().getCardApplication().get(1).getDataSetInfo().get(0).getRequirementLevel(),BasicRequirementsType.PERSONALIZATION_MANDATORY);
  assertEquals(cardInfo.getApplicationCapabilities().getCardApplication().get(1).getDataSetInfo().get(0).getDataSetACL().getAccessRule().get(0).getCardApplicationServiceName(),""String_Node_Str"");
  for (  DataSetInfoType dataSetInfo : cardInfo.getApplicationCapabilities().getCardApplication().get(2).getDataSetInfo()) {
    if (dataSetInfo.getDataSetName().equals(""String_Node_Str"")) {
      assertEquals(dataSetInfo.getLocalDataSetName().get(0).getLang(),""String_Node_Str"");
      assertEquals(dataSetInfo.getLocalDataSetName().get(0).getValue(),""String_Node_Str"");
    }
  }
  o=m.unmarshal(m.str2doc(egkCif));
  if (!(o instanceof CardInfo)) {
    throw new Exception(""String_Node_Str"");
  }
  cardInfo=(CardInfo)o;
  assertEquals(""String_Node_Str"",cardInfo.getCardType().getObjectIdentifier());
  CardApplicationType cardApplicationESIGN=cardInfo.getApplicationCapabilities().getCardApplication().get(1);
  assertEquals(cardApplicationESIGN.getDIDInfo().get(0).getDifferentialIdentity().getDIDName(),""String_Node_Str"");
  assertEquals(cardApplicationESIGN.getDIDInfo().get(0).getDifferentialIdentity().getDIDProtocol(),""String_Node_Str"");
  CryptoMarkerType cryptoMarkerType=new CryptoMarkerType(cardApplicationESIGN.getDIDInfo().get(0).getDifferentialIdentity().getDIDMarker().getCryptoMarker());
  assertEquals(cryptoMarkerType.getProtocol(),""String_Node_Str"");
  assertEquals(cryptoMarkerType.getAlgorithmInfo().getSupportedOperations().get(0),""String_Node_Str"");
}","@Test public void testConversionOfCardInfo() throws Exception {
  WSMarshaller m=new AndroidMarshaller();
  Object o=m.unmarshal(m.str2doc(npaCif));
  if (!(o instanceof CardInfo)) {
    throw new Exception(""String_Node_Str"");
  }
  CardInfo cardInfo=(CardInfo)o;
  assertEquals(""String_Node_Str"",cardInfo.getCardType().getObjectIdentifier());
  assertEquals(new byte[]{0x3F,0x00},cardInfo.getApplicationCapabilities().getImplicitlySelectedApplication());
  assertEquals(cardInfo.getApplicationCapabilities().getCardApplication().size(),3);
  assertEquals(cardInfo.getApplicationCapabilities().getCardApplication().get(0).getApplicationName(),""String_Node_Str"");
  assertEquals(cardInfo.getApplicationCapabilities().getCardApplication().get(0).getRequirementLevel(),BasicRequirementsType.PERSONALIZATION_MANDATORY);
  assertEquals(cardInfo.getApplicationCapabilities().getCardApplication().get(0).getCardApplicationACL().getAccessRule().size(),40);
  assertEquals(cardInfo.getApplicationCapabilities().getCardApplication().get(0).getCardApplicationACL().getAccessRule().get(0).getCardApplicationServiceName(),""String_Node_Str"");
  assertEquals(cardInfo.getApplicationCapabilities().getCardApplication().get(0).getCardApplicationACL().getAccessRule().get(0).getAction().getAPIAccessEntryPoint(),APIAccessEntryPointName.INITIALIZE);
  assertTrue(cardInfo.getApplicationCapabilities().getCardApplication().get(0).getCardApplicationACL().getAccessRule().get(0).getSecurityCondition().isAlways());
  assertEquals(cardInfo.getApplicationCapabilities().getCardApplication().get(0).getCardApplicationACL().getAccessRule().get(39).getAction().getAuthorizationServiceAction(),AuthorizationServiceActionName.ACL_MODIFY);
  assertFalse(cardInfo.getApplicationCapabilities().getCardApplication().get(0).getCardApplicationACL().getAccessRule().get(39).getSecurityCondition().isNever());
  assertEquals(cardInfo.getApplicationCapabilities().getCardApplication().get(0).getDIDInfo().get(0).getRequirementLevel(),BasicRequirementsType.PERSONALIZATION_MANDATORY);
  assertEquals(cardInfo.getApplicationCapabilities().getCardApplication().get(0).getDIDInfo().get(0).getDIDACL().getAccessRule().get(0).getCardApplicationServiceName(),""String_Node_Str"");
  assertEquals(cardInfo.getApplicationCapabilities().getCardApplication().get(1).getDataSetInfo().get(0).getRequirementLevel(),BasicRequirementsType.PERSONALIZATION_MANDATORY);
  assertEquals(cardInfo.getApplicationCapabilities().getCardApplication().get(1).getDataSetInfo().get(0).getDataSetACL().getAccessRule().get(0).getCardApplicationServiceName(),""String_Node_Str"");
  for (  DataSetInfoType dataSetInfo : cardInfo.getApplicationCapabilities().getCardApplication().get(2).getDataSetInfo()) {
    if (dataSetInfo.getDataSetName().equals(""String_Node_Str"")) {
      assertEquals(dataSetInfo.getLocalDataSetName().get(0).getLang(),""String_Node_Str"");
      assertEquals(dataSetInfo.getLocalDataSetName().get(0).getValue(),""String_Node_Str"");
    }
  }
  o=m.unmarshal(m.str2doc(egkCif));
  if (!(o instanceof CardInfo)) {
    throw new Exception(""String_Node_Str"");
  }
  cardInfo=(CardInfo)o;
  assertEquals(""String_Node_Str"",cardInfo.getCardType().getObjectIdentifier());
  CardApplicationType cardApplicationESIGN=cardInfo.getApplicationCapabilities().getCardApplication().get(2);
  DIDInfoType didInfo=cardApplicationESIGN.getDIDInfo().get(2);
  DifferentialIdentityType differentialIdentity=didInfo.getDifferentialIdentity();
  assertEquals(differentialIdentity.getDIDName(),""String_Node_Str"");
  assertEquals(differentialIdentity.getDIDProtocol(),""String_Node_Str"");
  CryptoMarkerType cryptoMarkerType=new CryptoMarkerType(differentialIdentity.getDIDMarker().getCryptoMarker());
  assertEquals(cryptoMarkerType.getProtocol(),""String_Node_Str"");
  assertEquals(cryptoMarkerType.getAlgorithmInfo().getSupportedOperations().get(0),""String_Node_Str"");
}"
48200,"/** 
 * @param context application context
 * @param abstractBox abstractBox of type checkbox or radiobox
 * @param useCheckboxes true if checkboxes should be used, false for radioboxes
 */
public BoxItemAdapter(Context context,AbstractBox abstractBox,boolean useCheckboxes){
  this.useCheckboxes=useCheckboxes;
  this.context=context;
  this.id=abstractBox.getID();
  this.boxItems=abstractBox.getBoxItems();
}","/** 
 * @param context application context
 * @param abstractBox abstractBox of type checkbox or radiobox
 * @param useCheckboxes true if checkboxes should be used, false for radioboxes
 */
public BoxItemAdapter(Context context,AbstractBox abstractBox,boolean useCheckboxes){
  this.useCheckboxes=useCheckboxes;
  this.context=context;
  this.id=abstractBox.getID();
  this.boxItems=abstractBox.getBoxItems();
  itemViews=new CompoundButton[boxItems.size()];
}"
48201,"@Override public View getView(final int position,View convertView,ViewGroup parent){
  CompoundButton b=null;
  if (useCheckboxes) {
    b=new CheckBox(context);
  }
 else {
    b=new RadioButton(context);
  }
  b.setText(boxItems.get(position).getText() != null ? boxItems.get(position).getText() : boxItems.get(position).getName());
  b.setChecked(boxItems.get(position).isChecked());
  b.setEnabled(!boxItems.get(position).isDisabled());
  b.setOnCheckedChangeListener(new OnCheckedChangeListener(){
    public void onCheckedChanged(    CompoundButton buttonView,    boolean isChecked){
      boxItems.get(position).setChecked(isChecked);
    }
  }
);
  return b;
}","@Override public View getView(final int position,View convertView,ViewGroup parent){
  CompoundButton b;
  if (useCheckboxes) {
    b=new CheckBox(context);
    b.setOnCheckedChangeListener(new CheckboxChangeListener(boxItems.get(position)));
  }
 else {
    b=new RadioButton(context);
    b.setOnCheckedChangeListener(new RadioboxChangeListener(this,position));
  }
  String text=boxItems.get(position).getText();
  String name=boxItems.get(position).getName();
  b.setText(text != null ? text : name);
  b.setChecked(boxItems.get(position).isChecked());
  b.setEnabled(!boxItems.get(position).isDisabled());
  itemViews[position]=b;
  return b;
}"
48202,"private void initComponents(){
  headlineLabel.setFont(headlineLabel.getFont().deriveFont(Font.BOLD));
  messageLabel.setMargin(new Insets(0,0,0,0));
  messageLabel.setEditable(false);
  messageLabel.setLineWrap(true);
  messageLabel.setWrapStyleWord(true);
  messageLabel.setFont(new JButton().getFont());
  JScrollPane scrollPane=new JScrollPane(messageLabel);
  scrollPane.setBorder(BorderFactory.createEmptyBorder());
  Logo logo=new Logo();
  GroupLayout layout=new GroupLayout(this);
  setLayout(layout);
  layout.setAutoCreateGaps(true);
  layout.setAutoCreateContainerGaps(true);
  layout.setHorizontalGroup(layout.createSequentialGroup().addComponent(logo,50,50,50).addGap(20).addGroup(layout.createParallelGroup().addComponent(headlineLabel).addComponent(scrollPane)));
  layout.setVerticalGroup(layout.createParallelGroup(GroupLayout.Alignment.CENTER).addComponent(logo).addGroup(layout.createSequentialGroup().addComponent(headlineLabel).addComponent(scrollPane)));
}","private void initComponents(){
  headlineLabel.setFont(headlineLabel.getFont().deriveFont(Font.BOLD));
  messageLabel.setMargin(new Insets(0,0,0,0));
  messageLabel.setEditable(false);
  messageLabel.setLineWrap(true);
  messageLabel.setWrapStyleWord(true);
  messageLabel.setFont(new JButton().getFont());
  JScrollPane scrollPane=new JScrollPane(messageLabel);
  scrollPane.setBorder(BorderFactory.createEmptyBorder());
  Logo logo=new Logo();
  GroupLayout layout=new GroupLayout(this);
  setLayout(layout);
  layout.setAutoCreateGaps(true);
  layout.setAutoCreateContainerGaps(true);
  layout.setHorizontalGroup(layout.createSequentialGroup().addComponent(logo,60,60,60).addGap(20).addGroup(layout.createParallelGroup().addComponent(headlineLabel).addComponent(scrollPane)));
  layout.setVerticalGroup(layout.createParallelGroup(GroupLayout.Alignment.CENTER).addComponent(logo).addGroup(layout.createSequentialGroup().addComponent(headlineLabel).addComponent(scrollPane)));
}"
48203,"@Override public synchronized boolean createResource(final ResourceConfiguration resConfig){
  assertNotClosed();
  boolean returnVal=true;
  final Path path=mDBConfig.getFile().resolve(DatabaseConfiguration.DatabasePaths.DATA.getFile()).resolve(resConfig.mPath);
  if (Files.exists(path)) {
    return false;
  }
 else {
    try {
      Files.createDirectory(path);
    }
 catch (    UnsupportedOperationException|IOException|SecurityException e) {
      returnVal=false;
    }
    if (returnVal) {
      try {
        for (        final ResourceConfiguration.ResourcePaths resourcePath : ResourceConfiguration.ResourcePaths.values()) {
          final Path toCreate=path.resolve(resourcePath.getFile());
          if (resourcePath.isFolder()) {
            Files.createDirectory(toCreate);
          }
 else {
            Files.createFile(toCreate);
          }
          if (!returnVal)           break;
        }
      }
 catch (      UnsupportedOperationException|IOException|SecurityException e) {
        returnVal=false;
      }
    }
  }
  if (returnVal) {
    mResourceID.set(mDBConfig.getMaxResourceID());
    ResourceConfiguration.serialize(resConfig.setID(mResourceID.getAndIncrement()));
    mDBConfig.setMaximumResourceID(mResourceID.get());
    mResources.forcePut(mResourceID.get(),resConfig.getResource().getFileName().toString());
    try {
      try (final ResourceManager resourceTrxManager=this.getResourceManager(resConfig.getResource().getFileName().toString());final XdmNodeWriteTrx wtx=resourceTrxManager.beginNodeWriteTrx()){
        wtx.commit();
      }
     }
 catch (    final SirixException e) {
      LOGWRAPPER.error(e.getMessage(),e);
      returnVal=false;
    }
  }
  if (!returnVal) {
    SirixFiles.recursiveRemove(resConfig.mPath);
  }
  return returnVal;
}","@Override public synchronized boolean createResource(final ResourceConfiguration resConfig){
  assertNotClosed();
  boolean returnVal=true;
  final Path path=mDBConfig.getFile().resolve(DatabaseConfiguration.DatabasePaths.DATA.getFile()).resolve(resConfig.mPath);
  if (Files.exists(path)) {
    return false;
  }
 else {
    try {
      Files.createDirectory(path);
    }
 catch (    UnsupportedOperationException|IOException|SecurityException e) {
      returnVal=false;
    }
    if (returnVal) {
      try {
        for (        final ResourceConfiguration.ResourcePaths resourcePath : ResourceConfiguration.ResourcePaths.values()) {
          final Path toCreate=path.resolve(resourcePath.getPath());
          if (resourcePath.isFolder()) {
            Files.createDirectory(toCreate);
          }
 else {
            Files.createFile(toCreate);
          }
          if (!returnVal)           break;
        }
      }
 catch (      UnsupportedOperationException|IOException|SecurityException e) {
        returnVal=false;
      }
    }
  }
  if (returnVal) {
    mResourceID.set(mDBConfig.getMaxResourceID());
    ResourceConfiguration.serialize(resConfig.setID(mResourceID.getAndIncrement()));
    mDBConfig.setMaximumResourceID(mResourceID.get());
    mResources.forcePut(mResourceID.get(),resConfig.getResource().getFileName().toString());
    try {
      try (final ResourceManager resourceTrxManager=this.getResourceManager(resConfig.getResource().getFileName().toString());final XdmNodeWriteTrx wtx=resourceTrxManager.beginNodeWriteTrx()){
        wtx.commit();
      }
     }
 catch (    final SirixException e) {
      LOGWRAPPER.error(e.getMessage(),e);
      returnVal=false;
    }
  }
  if (!returnVal) {
    SirixFiles.recursiveRemove(resConfig.mPath);
  }
  return returnVal;
}"
48204,"@Override public synchronized Database removeResource(final String name){
  assertNotClosed();
  final Path resourceFile=mDBConfig.getFile().resolve(DatabaseConfiguration.DatabasePaths.DATA.getFile()).resolve(name);
  if (!Databases.hasOpenResourceManagers(resourceFile)) {
    if (Files.exists(resourceFile) && ResourceConfiguration.ResourcePaths.compareStructure(resourceFile) == 0) {
      SirixFiles.recursiveRemove(resourceFile);
      mBufferManagers.remove(resourceFile);
    }
  }
  return this;
}","@Override public synchronized Database removeResource(final String name){
  assertNotClosed();
  final Path resourceFile=mDBConfig.getFile().resolve(DatabaseConfiguration.DatabasePaths.DATA.getFile()).resolve(name);
  if (Databases.hasOpenResourceManagers(resourceFile)) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (Files.exists(resourceFile) && ResourceConfiguration.ResourcePaths.compareStructure(resourceFile) == 0) {
    SirixFiles.recursiveRemove(resourceFile);
    mBufferManagers.remove(resourceFile);
  }
  return this;
}"
48205,"/** 
 * Determines if there are any open resource managers.
 * @param file the resource file
 * @return {@code true}, if there are any open resource managers,   {@code false} otherwise.
 */
public static synchronized boolean hasOpenResourceManagers(Path file){
  final Set<ResourceManager> resourceManagers=RESOURCE_MANAGERS.get(file);
  if (resourceManagers == null || resourceManagers.isEmpty()) {
    return true;
  }
  return false;
}","/** 
 * Determines if there are any open resource managers.
 * @param file the resource file
 * @return {@code true}, if there are any open resource managers,   {@code false} otherwise.
 */
public static synchronized boolean hasOpenResourceManagers(Path file){
  final Set<ResourceManager> resourceManagers=RESOURCE_MANAGERS.get(file);
  if (resourceManagers == null || resourceManagers.isEmpty()) {
    return false;
  }
  return true;
}"
48206,"/** 
 * Constructor.
 * @param file the file
 * @param isFolder determines if the file denotes a filer or not
 */
private void ResourcePaths(final Path file,final boolean isFolder){
  mFile=file;
  mIsFolder=isFolder;
}","/** 
 * Constructor.
 * @param path the path
 * @param isFolder determines if the path denotes a filer or not
 */
private void ResourcePaths(final Path path,final boolean isFolder){
  mPath=path;
  mIsFolder=isFolder;
}"
48207,"/** 
 * Get the configuration file.
 * @return configuration file
 */
public Path getConfigFile(){
  return mPath.resolve(ResourcePaths.CONFIG_BINARY.getFile());
}","/** 
 * Get the configuration file.
 * @return configuration file
 */
public Path getConfigFile(){
  return mPath.resolve(ResourcePaths.CONFIG_BINARY.getPath());
}"
48208,"/** 
 * Check if file is denoted as folder or not.
 * @return boolean if file is folder
 */
public boolean isFolder(){
  return mIsFolder;
}","/** 
 * Check if file is denoted as folder or not.
 * @return {@code true} if file is a folder, {@code false} otherwise
 */
public boolean isFolder(){
  return mIsFolder;
}"
48209,"/** 
 * Checking a structure in a folder to be equal with the data in this enum.
 * @param file to be checked
 * @return -1 if less folders are there, 0 if the structure is equal to the one expected, 1 ifthe structure has more folders
 * @throws NullPointerException if {@code file} is {@code null}
 */
public static int compareStructure(final Path file){
  int existing=0;
  for (  final ResourcePaths paths : values()) {
    final Path currentFile=file.resolve(paths.getFile());
    if (Files.exists(currentFile)) {
      existing++;
    }
  }
  return existing - values().length + 1;
}","/** 
 * Checking a structure in a folder to be equal with the data in this enum.
 * @param file to be checked
 * @return -1 if less folders are there, 0 if the structure is equal to the one expected, 1 ifthe structure has more folders
 * @throws NullPointerException if {@code file} is {@code null}
 */
public static int compareStructure(final Path file){
  int existing=0;
  for (  final ResourcePaths paths : values()) {
    final Path currentFile=file.resolve(paths.getPath());
    if (Files.exists(currentFile)) {
      existing++;
    }
  }
  return existing - values().length;
}"
48210,"/** 
 * Determines if an index of the specified type is available.
 * @param type type of index to lookup
 * @param resourceManager the {@link ResourceManager} this index controller is bound to
 * @return {@code true} if an index of the specified type exists, {@code false} otherwise
 * @throws SirixIOException if an I/O exception occurs while deserializing the index configurationfor the specified  {@code revision}
 */
public static boolean containsIndex(final IndexType type,final ResourceManager resourceManager,final int revision) throws SirixIOException {
  final Indexes indexes=new Indexes();
  final java.nio.file.Path indexesFile=resourceManager.getResourceConfig().mPath.resolve(ResourceConfiguration.ResourcePaths.INDEXES.getFile()).resolve(String.valueOf(revision) + ""String_Node_Str"");
  try {
    if (Files.exists(indexesFile) && Files.size(indexesFile) > 0) {
      try (final InputStream in=new FileInputStream(indexesFile.toFile())){
        indexes.init(deserialize(in).getFirstChild());
      }
     }
  }
 catch (  IOException|DocumentException|SirixException e) {
    throw new SirixIOException(""String_Node_Str"",e);
  }
  for (  final IndexDef indexDef : indexes.getIndexDefs()) {
    if (indexDef.getType() == type)     return true;
  }
  return false;
}","/** 
 * Determines if an index of the specified type is available.
 * @param type type of index to lookup
 * @param resourceManager the {@link ResourceManager} this index controller is bound to
 * @return {@code true} if an index of the specified type exists, {@code false} otherwise
 * @throws SirixIOException if an I/O exception occurs while deserializing the index configurationfor the specified  {@code revision}
 */
public static boolean containsIndex(final IndexType type,final ResourceManager resourceManager,final int revision) throws SirixIOException {
  final Indexes indexes=new Indexes();
  final java.nio.file.Path indexesFile=resourceManager.getResourceConfig().mPath.resolve(ResourceConfiguration.ResourcePaths.INDEXES.getPath()).resolve(String.valueOf(revision) + ""String_Node_Str"");
  try {
    if (Files.exists(indexesFile) && Files.size(indexesFile) > 0) {
      try (final InputStream in=new FileInputStream(indexesFile.toFile())){
        indexes.init(deserialize(in).getFirstChild());
      }
     }
  }
 catch (  IOException|DocumentException|SirixException e) {
    throw new SirixIOException(""String_Node_Str"",e);
  }
  for (  final IndexDef indexDef : indexes.getIndexDefs()) {
    if (indexDef.getType() == type)     return true;
  }
  return false;
}"
48211,"/** 
 * A commit file which is used by a   {@link XdmNodeWriteTrx} to denote if it's currently commitingor not.
 */
public Path commitFile(){
  return mResourceConfig.mPath.resolve(ResourceConfiguration.ResourcePaths.TRANSACTION_INTENT_LOG.getFile()).resolve(""String_Node_Str"");
}","/** 
 * A commit file which is used by a   {@link XdmNodeWriteTrx} to denote if it's currently commitingor not.
 */
public Path commitFile(){
  return mResourceConfig.mPath.resolve(ResourceConfiguration.ResourcePaths.TRANSACTION_INTENT_LOG.getPath()).resolve(""String_Node_Str"");
}"
48212,"/** 
 * Create a page write trx.
 * @param resourceManager {@link XdmResourceManager} this page write trx is bound to
 * @param uberPage root of revision
 * @param writer writer where this transaction should write to
 * @param trxId the transaction ID
 * @param representRev revision represent
 * @param lastStoredRev last stored revision
 * @param bufferManager the page cache buffer
 */
public PageWriteTrx<Long,Record,UnorderedKeyValuePage> createPageWriteTrx(final XdmResourceManager resourceManager,final UberPage uberPage,final Writer writer,final @Nonnegative long trxId,final @Nonnegative int representRev,final @Nonnegative int lastStoredRev,final @Nonnegative int lastCommitedRev,final @Nonnull BufferManager bufferManager){
  final boolean usePathSummary=resourceManager.getResourceConfig().mPathSummary;
  final IndexController indexController=resourceManager.getWtxIndexController(representRev);
  final Path indexes=resourceManager.getResourceConfig().mPath.resolve(ResourceConfiguration.ResourcePaths.INDEXES.getFile()).resolve(String.valueOf(lastStoredRev) + ""String_Node_Str"");
  if (Files.exists(indexes)) {
    try (final InputStream in=new FileInputStream(indexes.toFile())){
      indexController.getIndexes().init(IndexController.deserialize(in).getFirstChild());
    }
 catch (    IOException|DocumentException|SirixException e) {
      throw new SirixIOException(""String_Node_Str"",e);
    }
  }
  final TreeModifierImpl treeModifier=new TreeModifierImpl();
  final TransactionIntentLogFactory logFactory=new TransactionIntentLogFactoryImpl();
  final TransactionIntentLog log=logFactory.createTrxIntentLog(resourceManager.getResourceConfig());
  if (uberPage.isBootstrap()) {
    uberPage.createRevisionTree(log);
  }
  final PageReadTrxImpl pageRtx=new PageReadTrxImpl(trxId,resourceManager,uberPage,representRev,writer,log,indexController,bufferManager);
  final RevisionRootPage lastCommitedRoot=pageRtx.loadRevRoot(lastCommitedRev);
  final RevisionRootPage newRevisionRootPage=treeModifier.preparePreviousRevisionRootPage(uberPage,pageRtx,log,representRev,lastStoredRev);
  newRevisionRootPage.setMaxNodeKey(lastCommitedRoot.getMaxNodeKey());
  newRevisionRootPage.createNodeTree(pageRtx,log);
  if (usePathSummary) {
    final PathSummaryPage page=pageRtx.getPathSummaryPage(newRevisionRootPage);
    page.createPathSummaryTree(pageRtx,0,log);
    if (PageContainer.emptyInstance().equals(log.get(newRevisionRootPage.getPathSummaryPageReference(),pageRtx)))     log.put(newRevisionRootPage.getPathSummaryPageReference(),new PageContainer(page,page));
  }
  if (!uberPage.isBootstrap()) {
    if (PageContainer.emptyInstance().equals(log.get(newRevisionRootPage.getNamePageReference(),pageRtx))) {
      final Page namePage=pageRtx.getNamePage(newRevisionRootPage);
      log.put(newRevisionRootPage.getNamePageReference(),new PageContainer(namePage,namePage));
    }
    if (PageContainer.emptyInstance().equals(log.get(newRevisionRootPage.getCASPageReference(),pageRtx))) {
      final Page casPage=pageRtx.getCASPage(newRevisionRootPage);
      log.put(newRevisionRootPage.getCASPageReference(),new PageContainer(casPage,casPage));
    }
    if (PageContainer.emptyInstance().equals(log.get(newRevisionRootPage.getPathPageReference(),pageRtx))) {
      final Page pathPage=pageRtx.getPathPage(newRevisionRootPage);
      log.put(newRevisionRootPage.getPathPageReference(),new PageContainer(pathPage,pathPage));
    }
    final Page indirectPage=pageRtx.dereferenceIndirectPageReference(newRevisionRootPage.getIndirectPageReference());
    log.put(newRevisionRootPage.getIndirectPageReference(),new PageContainer(indirectPage,indirectPage));
    final PageReference revisionRootPageReference=treeModifier.prepareLeafOfTree(pageRtx,log,uberPage.getPageCountExp(PageKind.UBERPAGE),uberPage.getIndirectPageReference(),uberPage.getRevisionNumber(),-1,PageKind.UBERPAGE);
    log.put(revisionRootPageReference,new PageContainer(newRevisionRootPage,newRevisionRootPage));
  }
  return new PageWriteTrxImpl(treeModifier,writer,log,newRevisionRootPage,pageRtx,indexController);
}","/** 
 * Create a page write trx.
 * @param resourceManager {@link XdmResourceManager} this page write trx is bound to
 * @param uberPage root of revision
 * @param writer writer where this transaction should write to
 * @param trxId the transaction ID
 * @param representRev revision represent
 * @param lastStoredRev last stored revision
 * @param bufferManager the page cache buffer
 */
public PageWriteTrx<Long,Record,UnorderedKeyValuePage> createPageWriteTrx(final XdmResourceManager resourceManager,final UberPage uberPage,final Writer writer,final @Nonnegative long trxId,final @Nonnegative int representRev,final @Nonnegative int lastStoredRev,final @Nonnegative int lastCommitedRev,final @Nonnull BufferManager bufferManager){
  final boolean usePathSummary=resourceManager.getResourceConfig().mPathSummary;
  final IndexController indexController=resourceManager.getWtxIndexController(representRev);
  final Path indexes=resourceManager.getResourceConfig().mPath.resolve(ResourceConfiguration.ResourcePaths.INDEXES.getPath()).resolve(String.valueOf(lastStoredRev) + ""String_Node_Str"");
  if (Files.exists(indexes)) {
    try (final InputStream in=new FileInputStream(indexes.toFile())){
      indexController.getIndexes().init(IndexController.deserialize(in).getFirstChild());
    }
 catch (    IOException|DocumentException|SirixException e) {
      throw new SirixIOException(""String_Node_Str"",e);
    }
  }
  final TreeModifierImpl treeModifier=new TreeModifierImpl();
  final TransactionIntentLogFactory logFactory=new TransactionIntentLogFactoryImpl();
  final TransactionIntentLog log=logFactory.createTrxIntentLog(resourceManager.getResourceConfig());
  if (uberPage.isBootstrap()) {
    uberPage.createRevisionTree(log);
  }
  final PageReadTrxImpl pageRtx=new PageReadTrxImpl(trxId,resourceManager,uberPage,representRev,writer,log,indexController,bufferManager);
  final RevisionRootPage lastCommitedRoot=pageRtx.loadRevRoot(lastCommitedRev);
  final RevisionRootPage newRevisionRootPage=treeModifier.preparePreviousRevisionRootPage(uberPage,pageRtx,log,representRev,lastStoredRev);
  newRevisionRootPage.setMaxNodeKey(lastCommitedRoot.getMaxNodeKey());
  newRevisionRootPage.createNodeTree(pageRtx,log);
  if (usePathSummary) {
    final PathSummaryPage page=pageRtx.getPathSummaryPage(newRevisionRootPage);
    page.createPathSummaryTree(pageRtx,0,log);
    if (PageContainer.emptyInstance().equals(log.get(newRevisionRootPage.getPathSummaryPageReference(),pageRtx)))     log.put(newRevisionRootPage.getPathSummaryPageReference(),new PageContainer(page,page));
  }
  if (!uberPage.isBootstrap()) {
    if (PageContainer.emptyInstance().equals(log.get(newRevisionRootPage.getNamePageReference(),pageRtx))) {
      final Page namePage=pageRtx.getNamePage(newRevisionRootPage);
      log.put(newRevisionRootPage.getNamePageReference(),new PageContainer(namePage,namePage));
    }
    if (PageContainer.emptyInstance().equals(log.get(newRevisionRootPage.getCASPageReference(),pageRtx))) {
      final Page casPage=pageRtx.getCASPage(newRevisionRootPage);
      log.put(newRevisionRootPage.getCASPageReference(),new PageContainer(casPage,casPage));
    }
    if (PageContainer.emptyInstance().equals(log.get(newRevisionRootPage.getPathPageReference(),pageRtx))) {
      final Page pathPage=pageRtx.getPathPage(newRevisionRootPage);
      log.put(newRevisionRootPage.getPathPageReference(),new PageContainer(pathPage,pathPage));
    }
    final Page indirectPage=pageRtx.dereferenceIndirectPageReference(newRevisionRootPage.getIndirectPageReference());
    log.put(newRevisionRootPage.getIndirectPageReference(),new PageContainer(indirectPage,indirectPage));
    final PageReference revisionRootPageReference=treeModifier.prepareLeafOfTree(pageRtx,log,uberPage.getPageCountExp(PageKind.UBERPAGE),uberPage.getIndirectPageReference(),uberPage.getRevisionNumber(),-1,PageKind.UBERPAGE);
    log.put(revisionRootPageReference,new PageContainer(newRevisionRootPage,newRevisionRootPage));
  }
  return new PageWriteTrxImpl(treeModifier,writer,log,newRevisionRootPage,pageRtx,indexController);
}"
48213,"@Override public TransactionIntentLog createTrxIntentLog(final ResourceConfiguration resourceConfig){
  final Path logFile=resourceConfig.getResource().resolve(ResourceConfiguration.ResourcePaths.TRANSACTION_INTENT_LOG.getFile()).resolve(""String_Node_Str"");
  try {
    if (Files.exists(logFile)) {
      Files.delete(logFile);
      Files.createFile(logFile);
    }
    final RandomAccessFile file=new RandomAccessFile(logFile.toFile(),""String_Node_Str"");
    final FileWriter fileWriter=new FileWriter(file,null,new ByteHandlePipeline(resourceConfig.mByteHandler),SerializationType.TRANSACTION_INTENT_LOG);
    final PersistentFileCache persistentFileCache=new PersistentFileCache(fileWriter);
    return new TransactionIntentLog(persistentFileCache);
  }
 catch (  final IOException e) {
    throw new UncheckedIOException(e);
  }
}","@Override public TransactionIntentLog createTrxIntentLog(final ResourceConfiguration resourceConfig){
  final Path logFile=resourceConfig.getResource().resolve(ResourceConfiguration.ResourcePaths.TRANSACTION_INTENT_LOG.getPath()).resolve(""String_Node_Str"");
  try {
    if (Files.exists(logFile)) {
      Files.delete(logFile);
      Files.createFile(logFile);
    }
    final RandomAccessFile file=new RandomAccessFile(logFile.toFile(),""String_Node_Str"");
    final FileWriter fileWriter=new FileWriter(file,null,new ByteHandlePipeline(resourceConfig.mByteHandler),SerializationType.TRANSACTION_INTENT_LOG);
    final PersistentFileCache persistentFileCache=new PersistentFileCache(fileWriter);
    return new TransactionIntentLog(persistentFileCache);
  }
 catch (  final IOException e) {
    throw new UncheckedIOException(e);
  }
}"
48214,"/** 
 * Getting concrete storage for this file.
 * @return the concrete storage for this database
 */
private Path getRevisionFilePath(){
  return mFile.resolve(ResourceConfiguration.ResourcePaths.DATA.getFile()).resolve(REVISIONS_FILENAME);
}","/** 
 * Getting concrete storage for this file.
 * @return the concrete storage for this database
 */
private Path getRevisionFilePath(){
  return mFile.resolve(ResourceConfiguration.ResourcePaths.DATA.getPath()).resolve(REVISIONS_FILENAME);
}"
48215,"/** 
 * Getting path for data file.
 * @return the path for this data file
 */
private Path getDataFilePath(){
  return mFile.resolve(ResourceConfiguration.ResourcePaths.DATA.getFile()).resolve(FILENAME);
}","/** 
 * Getting path for data file.
 * @return the path for this data file
 */
private Path getDataFilePath(){
  return mFile.resolve(ResourceConfiguration.ResourcePaths.DATA.getPath()).resolve(FILENAME);
}"
48216,"@Override protected void emitRevisionStartTag(final @Nonnull XdmNodeReadTrx rtx){
  try {
    final int length=(mRevisions.length == 1 && mRevisions[0] < 0) ? (int)mResMgr.getMostRecentRevisionNumber() : mRevisions.length;
    if (mSerializeRest || length > 1) {
      indent();
      if (mSerializeRest) {
        write(""String_Node_Str"");
      }
 else {
        write(""String_Node_Str"");
      }
      if (length > 1) {
        if (mSerializeRest) {
          write(""String_Node_Str"");
        }
 else {
          write(""String_Node_Str"");
        }
        write(Integer.toString(rtx.getRevisionNumber()));
        write(""String_Node_Str"");
        if (rtx.hasFirstChild())         mStack.push(Constants.NULL_ID_LONG);
      }
 else       if (mSerializeRest) {
        write(""String_Node_Str"");
        if (rtx.hasFirstChild())         mStack.push(Constants.NULL_ID_LONG);
      }
    }
  }
 catch (  final IOException e) {
    LOGWRAPPER.error(e.getMessage(),e);
  }
}","@Override protected void emitRevisionStartTag(final @Nonnull XdmNodeReadTrx rtx){
  try {
    final int length=(mRevisions.length == 1 && mRevisions[0] < 0) ? (int)mResMgr.getMostRecentRevisionNumber() : mRevisions.length;
    if (mSerializeRest || length > 1) {
      indent();
      if (mSerializeRest) {
        write(""String_Node_Str"");
      }
 else {
        write(""String_Node_Str"");
      }
      if (length > 1) {
        if (mSerializeRest) {
          write(""String_Node_Str"");
        }
 else {
          write(""String_Node_Str"");
        }
        write(Integer.toString(rtx.getRevisionNumber()));
        write(""String_Node_Str"");
      }
 else       if (mSerializeRest) {
        write(""String_Node_Str"");
      }
      if (rtx.hasFirstChild())       mStack.push(Constants.NULL_ID_LONG);
      if (mIndent) {
        mOut.write(CharsForSerializing.NEWLINE.getBytes());
      }
    }
  }
 catch (  final IOException e) {
    LOGWRAPPER.error(e.getMessage(),e);
  }
}"
48217,"@Override protected void emitRevisionEndTag(final @Nonnull XdmNodeReadTrx rtx){
  try {
    final int length=(mRevisions.length == 1 && mRevisions[0] < 0) ? (int)mResMgr.getMostRecentRevisionNumber() : mRevisions.length;
    if (mSerializeRest || length > 1) {
      if (rtx.hasFirstChild())       mStack.pop();
      indent();
      if (mSerializeRest) {
        write(""String_Node_Str"");
      }
 else {
        write(""String_Node_Str"");
      }
    }
    if (mIndent) {
      mOut.write(CharsForSerializing.NEWLINE.getBytes());
    }
  }
 catch (  final IOException e) {
    LOGWRAPPER.error(e.getMessage(),e);
  }
}","@Override protected void emitRevisionEndTag(final @Nonnull XdmNodeReadTrx rtx){
  try {
    final int length=(mRevisions.length == 1 && mRevisions[0] < 0) ? (int)mResMgr.getMostRecentRevisionNumber() : mRevisions.length;
    if (mSerializeRest || length > 1) {
      if (rtx.moveToDocumentRoot().get().hasFirstChild())       mStack.pop();
      indent();
      if (mSerializeRest) {
        write(""String_Node_Str"");
      }
 else {
        write(""String_Node_Str"");
      }
    }
    if (mIndent) {
      mOut.write(CharsForSerializing.NEWLINE.getBytes());
    }
  }
 catch (  final IOException e) {
    LOGWRAPPER.error(e.getMessage(),e);
  }
}"
48218,"/** 
 * Emit node (start element or characters).
 * @param rtx Sirix {@link XdmNodeReadTrx}
 */
@Override protected void emitNode(final XdmNodeReadTrx rtx){
  try {
switch (rtx.getKind()) {
case DOCUMENT:
      if (mIndent) {
        mOut.write(CharsForSerializing.NEWLINE.getBytes());
      }
    break;
case ELEMENT:
  indent();
mOut.write(CharsForSerializing.OPEN.getBytes());
writeQName(rtx);
final long key=rtx.getNodeKey();
for (int index=0, nspCount=rtx.getNamespaceCount(); index < nspCount; index++) {
rtx.moveToNamespace(index);
if (rtx.getPrefixKey() == -1) {
mOut.write(CharsForSerializing.XMLNS.getBytes());
write(rtx.nameForKey(rtx.getURIKey()));
mOut.write(CharsForSerializing.QUOTE.getBytes());
}
 else {
mOut.write(CharsForSerializing.XMLNS_COLON.getBytes());
write(rtx.nameForKey(rtx.getPrefixKey()));
mOut.write(CharsForSerializing.EQUAL_QUOTE.getBytes());
write(rtx.nameForKey(rtx.getURIKey()));
mOut.write(CharsForSerializing.QUOTE.getBytes());
}
rtx.moveTo(key);
}
if (mSerializeId) {
if (mSerializeRest) {
mOut.write(CharsForSerializing.REST_PREFIX.getBytes());
}
 else {
mOut.write(CharsForSerializing.SPACE.getBytes());
}
mOut.write(CharsForSerializing.ID.getBytes());
mOut.write(CharsForSerializing.EQUAL_QUOTE.getBytes());
write(rtx.getNodeKey());
mOut.write(CharsForSerializing.QUOTE.getBytes());
}
for (int index=0, attCount=rtx.getAttributeCount(); index < attCount; index++) {
rtx.moveToAttribute(index);
mOut.write(CharsForSerializing.SPACE.getBytes());
writeQName(rtx);
mOut.write(CharsForSerializing.EQUAL_QUOTE.getBytes());
mOut.write(XMLToken.escapeAttribute(rtx.getValue()).getBytes(Constants.DEFAULT_ENCODING));
mOut.write(CharsForSerializing.QUOTE.getBytes());
rtx.moveTo(key);
}
if (rtx.hasFirstChild()) {
mOut.write(CharsForSerializing.CLOSE.getBytes());
}
 else {
mOut.write(CharsForSerializing.SLASH_CLOSE.getBytes());
}
if (mIndent) {
mOut.write(CharsForSerializing.NEWLINE.getBytes());
}
break;
case COMMENT:
indent();
mOut.write(CharsForSerializing.OPENCOMMENT.getBytes());
mOut.write(XMLToken.escapeContent(rtx.getValue()).getBytes(Constants.DEFAULT_ENCODING));
if (mIndent) {
mOut.write(CharsForSerializing.NEWLINE.getBytes());
}
mOut.write(CharsForSerializing.CLOSECOMMENT.getBytes());
break;
case TEXT:
indent();
mOut.write(XMLToken.escapeContent(rtx.getValue()).getBytes(Constants.DEFAULT_ENCODING));
if (mIndent) {
mOut.write(CharsForSerializing.NEWLINE.getBytes());
}
break;
case PROCESSING_INSTRUCTION:
indent();
mOut.write(CharsForSerializing.OPENPI.getBytes());
writeQName(rtx);
mOut.write(CharsForSerializing.SPACE.getBytes());
mOut.write(XMLToken.escapeContent(rtx.getValue()).getBytes(Constants.DEFAULT_ENCODING));
if (mIndent) {
mOut.write(CharsForSerializing.NEWLINE.getBytes());
}
mOut.write(CharsForSerializing.CLOSEPI.getBytes());
break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
}
 catch (final IOException e) {
LOGWRAPPER.error(e.getMessage(),e);
}
}","/** 
 * Emit node (start element or characters).
 * @param rtx Sirix {@link XdmNodeReadTrx}
 */
@Override protected void emitNode(final XdmNodeReadTrx rtx){
  try {
switch (rtx.getKind()) {
case DOCUMENT:
      break;
case ELEMENT:
    indent();
  mOut.write(CharsForSerializing.OPEN.getBytes());
writeQName(rtx);
final long key=rtx.getNodeKey();
for (int index=0, nspCount=rtx.getNamespaceCount(); index < nspCount; index++) {
rtx.moveToNamespace(index);
if (rtx.getPrefixKey() == -1) {
mOut.write(CharsForSerializing.XMLNS.getBytes());
write(rtx.nameForKey(rtx.getURIKey()));
mOut.write(CharsForSerializing.QUOTE.getBytes());
}
 else {
mOut.write(CharsForSerializing.XMLNS_COLON.getBytes());
write(rtx.nameForKey(rtx.getPrefixKey()));
mOut.write(CharsForSerializing.EQUAL_QUOTE.getBytes());
write(rtx.nameForKey(rtx.getURIKey()));
mOut.write(CharsForSerializing.QUOTE.getBytes());
}
rtx.moveTo(key);
}
if (mSerializeId) {
if (mSerializeRest) {
mOut.write(CharsForSerializing.REST_PREFIX.getBytes());
}
 else {
mOut.write(CharsForSerializing.SPACE.getBytes());
}
mOut.write(CharsForSerializing.ID.getBytes());
mOut.write(CharsForSerializing.EQUAL_QUOTE.getBytes());
write(rtx.getNodeKey());
mOut.write(CharsForSerializing.QUOTE.getBytes());
}
for (int index=0, attCount=rtx.getAttributeCount(); index < attCount; index++) {
rtx.moveToAttribute(index);
mOut.write(CharsForSerializing.SPACE.getBytes());
writeQName(rtx);
mOut.write(CharsForSerializing.EQUAL_QUOTE.getBytes());
mOut.write(XMLToken.escapeAttribute(rtx.getValue()).getBytes(Constants.DEFAULT_ENCODING));
mOut.write(CharsForSerializing.QUOTE.getBytes());
rtx.moveTo(key);
}
if (rtx.hasFirstChild()) {
mOut.write(CharsForSerializing.CLOSE.getBytes());
}
 else {
mOut.write(CharsForSerializing.SLASH_CLOSE.getBytes());
}
if (mIndent) {
mOut.write(CharsForSerializing.NEWLINE.getBytes());
}
break;
case COMMENT:
indent();
mOut.write(CharsForSerializing.OPENCOMMENT.getBytes());
mOut.write(XMLToken.escapeContent(rtx.getValue()).getBytes(Constants.DEFAULT_ENCODING));
if (mIndent) {
mOut.write(CharsForSerializing.NEWLINE.getBytes());
}
mOut.write(CharsForSerializing.CLOSECOMMENT.getBytes());
break;
case TEXT:
indent();
mOut.write(XMLToken.escapeContent(rtx.getValue()).getBytes(Constants.DEFAULT_ENCODING));
if (mIndent) {
mOut.write(CharsForSerializing.NEWLINE.getBytes());
}
break;
case PROCESSING_INSTRUCTION:
indent();
mOut.write(CharsForSerializing.OPENPI.getBytes());
writeQName(rtx);
mOut.write(CharsForSerializing.SPACE.getBytes());
mOut.write(XMLToken.escapeContent(rtx.getValue()).getBytes(Constants.DEFAULT_ENCODING));
if (mIndent) {
mOut.write(CharsForSerializing.NEWLINE.getBytes());
}
mOut.write(CharsForSerializing.CLOSEPI.getBytes());
break;
default :
throw new IllegalStateException(""String_Node_Str"");
}
}
 catch (final IOException e) {
LOGWRAPPER.error(e.getMessage(),e);
}
}"
48219,"@Override protected void emitStartDocument(){
  try {
    if (mSerializeXMLDeclaration) {
      write(""String_Node_Str"");
      if (mIndent) {
        mOut.write(CharsForSerializing.NEWLINE.getBytes());
      }
    }
    final int length=(mRevisions.length == 1 && mRevisions[0] < 0) ? (int)mResMgr.getMostRecentRevisionNumber() : mRevisions.length;
    if (mSerializeRest || length > 1) {
      if (mSerializeRest) {
        write(""String_Node_Str"");
      }
 else {
        write(""String_Node_Str"");
      }
      if (mIndent) {
        mOut.write(CharsForSerializing.NEWLINE.getBytes());
        mStack.push(Constants.NULL_ID_LONG);
      }
      indent();
    }
  }
 catch (  final IOException e) {
    LOGWRAPPER.error(e.getMessage(),e);
  }
}","@Override protected void emitStartDocument(){
  try {
    if (mSerializeXMLDeclaration) {
      write(""String_Node_Str"");
      if (mIndent) {
        mOut.write(CharsForSerializing.NEWLINE.getBytes());
      }
    }
    final int length=(mRevisions.length == 1 && mRevisions[0] < 0) ? (int)mResMgr.getMostRecentRevisionNumber() : mRevisions.length;
    if (mSerializeRest || length > 1) {
      if (mSerializeRest) {
        write(""String_Node_Str"");
      }
 else {
        write(""String_Node_Str"");
      }
      if (mIndent) {
        mOut.write(CharsForSerializing.NEWLINE.getBytes());
        mStack.push(Constants.NULL_ID_LONG);
      }
    }
  }
 catch (  final IOException e) {
    LOGWRAPPER.error(e.getMessage(),e);
  }
}"
48220,"@BeforeClass public void setUp() throws SirixException, IOException {
  TestHelper.closeEverything();
  TestHelper.deleteEverything();
  Files.createDirectories(TestHelper.PATHS.PATH1.getFile());
  Files.createDirectories(TestHelper.PATHS.PATH1.getFile().resolve(ResourceConfiguration.ResourcePaths.DATA.getFile()));
  Files.createFile(TestHelper.PATHS.PATH1.getFile().resolve(ResourceConfiguration.ResourcePaths.DATA.getFile()).resolve(""String_Node_Str""));
  mResourceConfig=new ResourceConfiguration.Builder(""String_Node_Str"",new DatabaseConfiguration(TestHelper.PATHS.PATH1.getFile())).build();
}","@BeforeClass public void setUp() throws SirixException, IOException {
  TestHelper.closeEverything();
  TestHelper.deleteEverything();
  Files.createDirectories(TestHelper.PATHS.PATH1.getFile());
  Files.createDirectories(TestHelper.PATHS.PATH1.getFile().resolve(ResourceConfiguration.ResourcePaths.DATA.getPath()));
  Files.createFile(TestHelper.PATHS.PATH1.getFile().resolve(ResourceConfiguration.ResourcePaths.DATA.getPath()).resolve(""String_Node_Str""));
  mResourceConfig=new ResourceConfiguration.Builder(""String_Node_Str"",new DatabaseConfiguration(TestHelper.PATHS.PATH1.getFile())).build();
}"
48221,"private static String readString(final InputStream in) throws IOException {
  int r;
  final ByteArrayOutputStream payload=new ByteArrayOutputStream();
  while ((r=in.read()) != -1) {
    payload.write(r);
  }
  final String string=payload.toString(""String_Node_Str"");
  return string;
}","private static String readString(final InputStream in) throws IOException {
  int r;
  final ByteArrayOutputStream payload=new ByteArrayOutputStream();
  while ((r=in.read()) != -1) {
    payload.write(r);
  }
  final String string=payload.toString(StandardCharsets.UTF_8.toString());
  return string;
}"
48222,"public static void main(final String[] args){
  try {
    final Config config=parseParams(args);
    try (final DBStore store=DBStore.newBuilder().build()){
      final QueryContext ctx=new SirixQueryContext(store);
      final String file=config.getValue(""String_Node_Str"");
      if (file != null) {
        final URI uri=new URI(file);
        final InputStream in=URIHandler.getInputStream(uri);
        try {
          final SubtreeParser parser=new DocumentParser(in);
          final String name=uri.toURL().getFile();
          final TemporalCollection<?> coll=store.create(name,parser);
          final Node<?> doc=coll.getDocument();
          ctx.setContextItem(doc);
        }
  finally {
          in.close();
        }
      }
      String query;
      if (((config.isSet(""String_Node_Str"")) && (!""String_Node_Str"".equals(config.getValue(""String_Node_Str""))))) {
        query=readFile(config.getValue(""String_Node_Str""));
      }
 else {
        query=readString(System.in);
      }
      final XQuery xq=new XQuery(new SirixCompileChain(store),query);
      if (config.isSet(""String_Node_Str"")) {
        xq.prettyPrint();
      }
      xq.serialize(ctx,System.out);
    }
   }
 catch (  final QueryException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    System.exit(-2);
  }
catch (  final IOException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    System.exit(-3);
  }
catch (  final Throwable e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    System.exit(-4);
  }
}","public static void main(final String[] args){
  try {
    final Config config=parseParams(args);
    try (final DBStore store=DBStore.newBuilder().build()){
      final QueryContext ctx=new SirixQueryContext(store);
      final String file=config.getValue(""String_Node_Str"");
      if (file != null) {
        final URI uri=new URI(file);
        final InputStream in=URIHandler.getInputStream(uri);
        try {
          final SubtreeParser parser=new DocumentParser(in);
          final String name=uri.toURL().getFile();
          final TemporalCollection<?> coll=store.create(name,parser);
          final Node<?> doc=coll.getDocument();
          ctx.setContextItem(doc);
        }
  finally {
          in.close();
        }
      }
      String query;
      if (((config.isSet(""String_Node_Str"")) && (!""String_Node_Str"".equals(config.getValue(""String_Node_Str""))))) {
        query=readFile(config.getValue(""String_Node_Str""));
      }
 else {
        query=readStringFromScanner(System.in);
      }
      final XQuery xq=new XQuery(new SirixCompileChain(store),query);
      if (config.isSet(""String_Node_Str"")) {
        xq.prettyPrint();
      }
      xq.serialize(ctx,System.out);
    }
   }
 catch (  final QueryException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    System.exit(-2);
  }
catch (  final IOException e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    System.exit(-3);
  }
catch (  final Throwable e) {
    System.out.println(""String_Node_Str"" + e.getMessage());
    System.exit(-4);
  }
}"
48223,"private VisitResult process(final ImmutableNode node){
  try {
    if (node.getKind() == Kind.TEXT) {
      mRtx.moveTo(node.getParentKey());
    }
    final long PCR=mRtx.isDocumentRoot() ? 0 : mRtx.getNameNode().getPathNodeKey();
    if (mPaths.isEmpty() || mPathSummaryReader.getPCRsForPaths(mPaths).contains(PCR)) {
      final Str strValue=new Str(((ImmutableValueNode)node).getValue());
      boolean isOfType=false;
      try {
        if (mType != Type.STR)         AtomicUtil.toType(strValue,mType);
        isOfType=true;
      }
 catch (      final SirixRuntimeException e) {
      }
      if (isOfType) {
        final CASValue value=new CASValue(strValue,mType,PCR);
        final Optional<NodeReferences> textReferences=mAVLTreeWriter.get(value,SearchMode.EQUAL);
        if (textReferences.isPresent()) {
          setNodeReferences(node,textReferences.get(),value);
        }
 else {
          setNodeReferences(node,new NodeReferences(),value);
        }
      }
    }
    mRtx.moveTo(node.getNodeKey());
  }
 catch (  final PathException|SirixIOException e) {
    LOGGER.error(e.getMessage(),e);
  }
  return VisitResultType.CONTINUE;
}","private VisitResult process(final ImmutableNode node){
  try {
    if (node.getKind() == Kind.TEXT) {
      mRtx.moveTo(node.getParentKey());
    }
    final long PCR=mRtx.isDocumentRoot() ? 0 : mRtx.getNameNode().getPathNodeKey();
    if (mPaths.isEmpty() || mPathSummaryReader.getPCRsForPaths(mPaths,true).contains(PCR)) {
      final Str strValue=new Str(((ImmutableValueNode)node).getValue());
      boolean isOfType=false;
      try {
        if (mType != Type.STR)         AtomicUtil.toType(strValue,mType);
        isOfType=true;
      }
 catch (      final SirixRuntimeException e) {
      }
      if (isOfType) {
        final CASValue value=new CASValue(strValue,mType,PCR);
        final Optional<NodeReferences> textReferences=mAVLTreeWriter.get(value,SearchMode.EQUAL);
        if (textReferences.isPresent()) {
          setNodeReferences(node,textReferences.get(),value);
        }
 else {
          setNodeReferences(node,new NodeReferences(),value);
        }
      }
    }
    mRtx.moveTo(node.getNodeKey());
  }
 catch (  final PathException|SirixIOException e) {
    LOGGER.error(e.getMessage(),e);
  }
  return VisitResultType.CONTINUE;
}"
48224,"@Override public void listen(final ChangeType type,final ImmutableNode node,final long pathNodeKey) throws SirixIOException {
  if (node instanceof ValueNode) {
    final ValueNode valueNode=((ValueNode)node);
    mPathSummaryReader.moveTo(pathNodeKey);
    try {
switch (type) {
case INSERT:
        if (mPathSummaryReader.getPCRsForPaths(mPaths).contains(pathNodeKey)) {
          insert(valueNode,pathNodeKey);
        }
      break;
case DELETE:
    if (mPathSummaryReader.getPCRsForPaths(mPaths).contains(pathNodeKey)) {
      mAVLTreeWriter.remove(new CASValue(new Str(valueNode.getValue()),mType,pathNodeKey),node.getNodeKey());
    }
  break;
default :
}
}
 catch (final PathException e) {
throw new SirixIOException(e);
}
}
}","@Override public void listen(final ChangeType type,final ImmutableNode node,final long pathNodeKey) throws SirixIOException {
  if (node instanceof ValueNode) {
    final ValueNode valueNode=((ValueNode)node);
    mPathSummaryReader.moveTo(pathNodeKey);
    try {
switch (type) {
case INSERT:
        if (mPathSummaryReader.getPCRsForPaths(mPaths,false).contains(pathNodeKey)) {
          insert(valueNode,pathNodeKey);
        }
      break;
case DELETE:
    if (mPathSummaryReader.getPCRsForPaths(mPaths,false).contains(pathNodeKey)) {
      mAVLTreeWriter.remove(new CASValue(new Str(valueNode.getValue()),mType,pathNodeKey),node.getNodeKey());
    }
  break;
default :
}
}
 catch (final PathException e) {
throw new SirixIOException(e);
}
}
}"
48225,"@Override public PCRValue getPCRsForPaths(Set<Path<QNm>> paths){
  try (final PathSummaryReader reader=mRtx instanceof XdmNodeWriteTrx ? ((XdmNodeWriteTrx)mRtx).getPathSummary() : mRtx.getResourceManager().openPathSummary(mRtx.getRevisionNumber())){
    final long maxPCR=reader.getMaxNodeKey();
    final Set<Long> pathClassRecords=reader.getPCRsForPaths(paths);
    return PCRValue.getInstance(maxPCR,pathClassRecords);
  }
 catch (  final PathException e) {
    LOGGER.error(e.getMessage(),e);
  }
  return PCRValue.getEmptyInstance();
}","@Override public PCRValue getPCRsForPaths(Set<Path<QNm>> paths){
  try (final PathSummaryReader reader=mRtx instanceof XdmNodeWriteTrx ? ((XdmNodeWriteTrx)mRtx).getPathSummary() : mRtx.getResourceManager().openPathSummary(mRtx.getRevisionNumber())){
    final long maxPCR=reader.getMaxNodeKey();
    final Set<Long> pathClassRecords=reader.getPCRsForPaths(paths,false);
    return PCRValue.getInstance(maxPCR,pathClassRecords);
  }
 catch (  final PathException e) {
    LOGGER.error(e.getMessage(),e);
  }
  return PCRValue.getEmptyInstance();
}"
48226,"private VisitResult process(final ImmutableNameNode node){
  try {
    final long PCR=node.getPathNodeKey();
    if (mPathSummaryReader.getPCRsForPaths(mPaths).contains(PCR) || mPaths.isEmpty()) {
      final Optional<NodeReferences> textReferences=mAVLTreeWriter.get(PCR,SearchMode.EQUAL);
      if (textReferences.isPresent()) {
        setNodeReferences(node,textReferences.get(),PCR);
      }
 else {
        setNodeReferences(node,new NodeReferences(),PCR);
      }
    }
  }
 catch (  final PathException|SirixIOException e) {
    LOGGER.error(e.getMessage(),e);
  }
  return VisitResultType.CONTINUE;
}","private VisitResult process(final ImmutableNameNode node){
  try {
    final long PCR=node.getPathNodeKey();
    if (mPathSummaryReader.getPCRsForPaths(mPaths,true).contains(PCR) || mPaths.isEmpty()) {
      final Optional<NodeReferences> textReferences=mAVLTreeWriter.get(PCR,SearchMode.EQUAL);
      if (textReferences.isPresent()) {
        setNodeReferences(node,textReferences.get(),PCR);
      }
 else {
        setNodeReferences(node,new NodeReferences(),PCR);
      }
    }
  }
 catch (  final PathException|SirixIOException e) {
    LOGGER.error(e.getMessage(),e);
  }
  return VisitResultType.CONTINUE;
}"
48227,"@Override public void listen(final ChangeType type,final ImmutableNode node,final long pathNodeKey) throws SirixIOException {
  if (node instanceof NameNode) {
    mPathSummaryReader.moveTo(pathNodeKey);
    try {
switch (type) {
case INSERT:
        if (mPathSummaryReader.getPCRsForPaths(mPaths).contains(pathNodeKey)) {
          final Optional<NodeReferences> textReferences=mAVLTreeWriter.get(pathNodeKey,SearchMode.EQUAL);
          if (textReferences.isPresent()) {
            setNodeReferences(node,textReferences.get(),pathNodeKey);
          }
 else {
            setNodeReferences(node,new NodeReferences(),pathNodeKey);
          }
        }
      break;
case DELETE:
    if (mPathSummaryReader.getPCRsForPaths(mPaths).contains(pathNodeKey)) {
      mAVLTreeWriter.remove(pathNodeKey,node.getNodeKey());
    }
  break;
default :
}
}
 catch (final PathException e) {
throw new SirixIOException(e);
}
}
}","@Override public void listen(final ChangeType type,final ImmutableNode node,final long pathNodeKey) throws SirixIOException {
  if (node instanceof NameNode) {
    mPathSummaryReader.moveTo(pathNodeKey);
    try {
switch (type) {
case INSERT:
        if (mPathSummaryReader.getPCRsForPaths(mPaths,false).contains(pathNodeKey)) {
          final Optional<NodeReferences> textReferences=mAVLTreeWriter.get(pathNodeKey,SearchMode.EQUAL);
          if (textReferences.isPresent()) {
            setNodeReferences(node,textReferences.get(),pathNodeKey);
          }
 else {
            setNodeReferences(node,new NodeReferences(),pathNodeKey);
          }
        }
      break;
case DELETE:
    if (mPathSummaryReader.getPCRsForPaths(mPaths,false).contains(pathNodeKey)) {
      mAVLTreeWriter.remove(pathNodeKey,node.getNodeKey());
    }
  break;
default :
}
}
 catch (final PathException e) {
throw new SirixIOException(e);
}
}
}"
48228,"/** 
 * Get path class records (PCRs) for the specified path.
 * @param path the path for which to get a set of PCRs
 * @return set of PCRs belonging to the specified path
 * @throws SirixException if anything went wrong
 */
public Set<Long> getPCRsForPath(final Path<QNm> path) throws PathException {
  Set<Long> pcrSet=mPathCache.get(path);
  if (pcrSet != null) {
    return pcrSet;
  }
  pcrSet=new HashSet<Long>();
  final boolean isAttributePattern=path.isAttribute();
  final int pathLength=path.getLength();
  final long nodeKey=mCurrentNode.getNodeKey();
  moveToDocumentRoot();
  for (final Axis axis=new DescendantAxis(this); axis.hasNext(); ) {
    axis.next();
    final PathNode node=this.getPathNode();
    if (node == null) {
      continue;
    }
    if (node.getLevel() < pathLength) {
      continue;
    }
    if (isAttributePattern ^ (node.getPathKind() == Kind.ATTRIBUTE)) {
      continue;
    }
    if (path.matches(node.getPath(this))) {
      pcrSet.add(node.getNodeKey());
    }
  }
  moveTo(nodeKey);
  mPathCache.put(path,pcrSet);
  return pcrSet;
}","/** 
 * Get path class records (PCRs) for the specified path.
 * @param path the path for which to get a set of PCRs
 * @param usePathCache determines if the path cache can be used or not
 * @return set of PCRs belonging to the specified path
 * @throws SirixException if anything went wrong
 */
public Set<Long> getPCRsForPath(final Path<QNm> path,final boolean useCache) throws PathException {
  final Set<Long> pcrSet;
  if (useCache) {
    if (mPathCache.containsKey(path) && mPathCache.get(path) != null) {
      return mPathCache.get(path);
    }
 else {
      pcrSet=new HashSet<>();
    }
  }
 else {
    pcrSet=new HashSet<>();
  }
  final boolean isAttributePattern=path.isAttribute();
  final int pathLength=path.getLength();
  final long nodeKey=mCurrentNode.getNodeKey();
  moveToDocumentRoot();
  for (final Axis axis=new DescendantAxis(this); axis.hasNext(); ) {
    axis.next();
    final PathNode node=this.getPathNode();
    if (node == null) {
      continue;
    }
    if (node.getLevel() < pathLength) {
      continue;
    }
    if (isAttributePattern ^ (node.getPathKind() == Kind.ATTRIBUTE)) {
      continue;
    }
    if (path.matches(node.getPath(this))) {
      pcrSet.add(node.getNodeKey());
    }
  }
  moveTo(nodeKey);
  if (useCache)   mPathCache.put(path,pcrSet);
  return pcrSet;
}"
48229,"/** 
 * Get a set of PCRs matching the specified collection of paths
 * @param expressions the paths to lookup
 * @return a set of PCRs matching the specified collection of paths
 * @throws SirixException if parsing a path fails
 */
public Set<Long> getPCRsForPaths(final Collection<Path<QNm>> expressions) throws PathException {
  assertNotClosed();
  final Set<Long> pcrs=new HashSet<>();
  for (  final Path<QNm> path : expressions) {
    final Set<Long> pcrsForPath=getPCRsForPath(path);
    pcrs.addAll(pcrsForPath);
  }
  return pcrs;
}","/** 
 * Get a set of PCRs matching the specified collection of paths
 * @param expressions the paths to lookup
 * @param useCache determines if the cache can be used or not
 * @return a set of PCRs matching the specified collection of paths
 * @throws SirixException if parsing a path fails
 */
public Set<Long> getPCRsForPaths(final Collection<Path<QNm>> expressions,final boolean useCache) throws PathException {
  assertNotClosed();
  final Set<Long> pcrs=new HashSet<>();
  for (  final Path<QNm> path : expressions) {
    final Set<Long> pcrsForPath=getPCRsForPath(path,useCache);
    pcrs.addAll(pcrsForPath);
  }
  return pcrs;
}"
48230,"@Test public void testAttributeIndex() throws SirixException {
}","@Test public void testAttributeIndex() throws SirixException, PathException {
  final XdmNodeWriteTrx wtx=holder.getResourceManager().beginNodeWriteTrx();
  final IndexController indexController=holder.getResourceManager().getWtxIndexController(wtx.getRevisionNumber() - 1);
  final IndexDef idxDef=IndexDefs.createCASIdxDef(false,Optional.ofNullable(Type.STR),Collections.singleton(Path.parse(""String_Node_Str"")),0);
  indexController.createIndexes(ImmutableSet.of(idxDef),wtx);
  wtx.insertElementAsFirstChild(new QNm(""String_Node_Str""));
  wtx.insertAttribute(new QNm(""String_Node_Str""),""String_Node_Str"",Movement.TOPARENT);
  wtx.insertAttribute(new QNm(""String_Node_Str""),""String_Node_Str"",Movement.TOPARENT);
  wtx.insertElementAsFirstChild(new QNm(""String_Node_Str""));
  wtx.insertAttribute(new QNm(""String_Node_Str""),""String_Node_Str"",Movement.TOPARENT);
  wtx.insertAttribute(new QNm(""String_Node_Str""),""String_Node_Str"",Movement.TOPARENT);
  wtx.moveTo(1);
  wtx.insertElementAsFirstChild(new QNm(""String_Node_Str""));
  wtx.insertAttribute(new QNm(""String_Node_Str""),""String_Node_Str"",Movement.TOPARENT);
  wtx.commit();
  final IndexDef indexDef=indexController.getIndexes().getIndexDef(0,IndexType.CAS);
  final AVLTreeReader<CASValue,NodeReferences> reader=AVLTreeReader.getInstance(wtx.getPageTrx(),indexDef.getType(),indexDef.getID());
  final Optional<NodeReferences> fooRefs=reader.get(new CASValue(new Str(""String_Node_Str""),Type.STR,1),SearchMode.EQUAL);
  assertTrue(!fooRefs.isPresent());
  final Optional<NodeReferences> bazRefs1=reader.get(new CASValue(new Str(""String_Node_Str""),Type.STR,3),SearchMode.EQUAL);
  check(bazRefs1,ImmutableSet.of(3L));
  final Optional<NodeReferences> bazRefs2=reader.get(new CASValue(new Str(""String_Node_Str""),Type.STR,8),SearchMode.EQUAL);
  check(bazRefs2,ImmutableSet.of(8L));
}"
48231,"/** 
 * Providing different implementations of the   {@link ByteHandler} as Dataprovider to the testclass.
 * @return different classes of the {@link ByteHandler}
 * @throws SirixIOException if an I/O error occurs
 */
@DataProvider(name=""String_Node_Str"") public Object[][] instantiateStorages() throws SirixIOException {
  Object[][] returnVal={{Storage.class,new Storage[]{new FileStorage(mResourceConfig),new BerkeleyStorageFactory().createStorage(mResourceConfig),new RAMStorage(mResourceConfig)}}};
  return returnVal;
}","/** 
 * Providing different implementations of the   {@link ByteHandler} as Dataprovider to the testclass.
 * @return different classes of the {@link ByteHandler}
 * @throws SirixIOException if an I/O error occurs
 */
@DataProvider(name=""String_Node_Str"") public Object[][] instantiateStorages() throws SirixIOException {
  Object[][] returnVal={{Storage.class,new Storage[]{new FileStorage(mResourceConfig),BerkeleyStorageFactory.createStorage(mResourceConfig),new RAMStorage(mResourceConfig)}}};
  return returnVal;
}"
48232,"@Override public void objectToEntry(final Page page,final TupleOutput output){
  try {
    final DataOutputStream outputData=new DataOutputStream(output);
    PagePersistenter.serializePage(outputData,page);
    mByteHandler.serialize(outputData);
    output.close();
  }
 catch (  final IOException e) {
    LOGGER.error(e.getMessage(),e);
  }
}","@Override public void objectToEntry(final Page page,final TupleOutput output){
  try {
    final DataOutputStream dataOutput=new DataOutputStream(mByteHandler.serialize(output));
    PagePersistenter.serializePage(dataOutput,page);
    ByteStreams.copy(new ByteArrayInputStream(output.toByteArray()),dataOutput);
    dataOutput.close();
  }
 catch (  final IOException e) {
    LOGGER.error(e.getMessage(),e);
  }
}"
48233,"/** 
 * Test method for  {@link org.ByteHandler.io.bytepipe.IByteHandler#deserialize(byte[])} andfor  {@link org.ByteHandler.io.bytepipe.IByteHandler#serialize(byte[])}.
 * @throws SirixIOException
 */
@Test(dataProvider=""String_Node_Str"") public void testFirstRef(final Class<Storage> pClass,final Storage[] pStorages) throws SirixException {
  for (  final Storage handler : pStorages) {
    final PageReference pageRef1=new PageReference();
    final UberPage page1=new UberPage();
    pageRef1.setPage(page1);
    final Writer writer=handler.getWriter();
    writer.writeFirstReference(pageRef1);
    final PageReference pageRef2=writer.readFirstReference();
    assertEquals(new StringBuilder(""String_Node_Str"").append(handler.getClass()).append(""String_Node_Str"").toString(),pageRef1.getKeyValuePageKey(),pageRef2.getKeyValuePageKey());
    assertEquals(new StringBuilder(""String_Node_Str"").append(handler.getClass()).append(""String_Node_Str"").toString(),((UberPage)pageRef1.getPage()).getRevisionCount(),((UberPage)pageRef2.getPage()).getRevisionCount());
    writer.close();
    final Reader reader=handler.getReader();
    final PageReference pageRef3=reader.readFirstReference();
    assertEquals(new StringBuilder(""String_Node_Str"").append(handler.getClass()).append(""String_Node_Str"").toString(),pageRef1.getKeyValuePageKey(),pageRef3.getKeyValuePageKey());
    assertEquals(new StringBuilder(""String_Node_Str"").append(handler.getClass()).append(""String_Node_Str"").toString(),((UberPage)pageRef1.getPage()).getRevisionCount(),((UberPage)pageRef3.getPage()).getRevisionCount());
    reader.close();
    handler.close();
  }
}","/** 
 * Test method for  {@link org.ByteHandler.io.bytepipe.IByteHandler#deserialize(byte[])} andfor  {@link org.ByteHandler.io.bytepipe.IByteHandler#serialize(byte[])}.
 * @throws SirixIOException
 */
@Test(dataProvider=""String_Node_Str"") public void testFirstRef(final Class<Storage> clazz,final Storage[] storages) throws SirixException {
  for (  final Storage handler : storages) {
    final PageReference pageRef1=new PageReference();
    final UberPage page1=new UberPage();
    pageRef1.setPage(page1);
    final Writer writer=handler.getWriter();
    writer.writeFirstReference(pageRef1);
    final PageReference pageRef2=writer.readFirstReference();
    assertEquals(new StringBuilder(""String_Node_Str"").append(handler.getClass()).append(""String_Node_Str"").toString(),pageRef1.getKeyValuePageKey(),pageRef2.getKeyValuePageKey());
    assertEquals(new StringBuilder(""String_Node_Str"").append(handler.getClass()).append(""String_Node_Str"").toString(),((UberPage)pageRef1.getPage()).getRevisionCount(),((UberPage)pageRef2.getPage()).getRevisionCount());
    writer.close();
    final Reader reader=handler.getReader();
    final PageReference pageRef3=reader.readFirstReference();
    assertEquals(new StringBuilder(""String_Node_Str"").append(handler.getClass()).append(""String_Node_Str"").toString(),pageRef1.getKeyValuePageKey(),pageRef3.getKeyValuePageKey());
    assertEquals(new StringBuilder(""String_Node_Str"").append(handler.getClass()).append(""String_Node_Str"").toString(),((UberPage)pageRef1.getPage()).getRevisionCount(),((UberPage)pageRef3.getPage()).getRevisionCount());
    reader.close();
    handler.close();
  }
}"
48234,"/** 
 * Load a document and query it (temporal enhancements).
 */
private static void loadDocumentAndQueryTemporal() throws QueryException, IOException {
  File tmpDir=new File(System.getProperty(""String_Node_Str""));
  File doc=generateSampleDoc(tmpDir,""String_Node_Str"");
  doc.deleteOnExit();
  try (final DBStore store=DBStore.newBuilder().isUpdatable().build()){
    final QueryContext ctx=new QueryContext(store);
    System.out.println(""String_Node_Str"");
    final String xq1=String.format(""String_Node_Str"",doc);
    System.out.println(xq1);
    new XQuery(xq1).evaluate(ctx);
    final QueryContext ctx2=new QueryContext(store);
    System.out.println();
    System.out.println(""String_Node_Str"");
    final String xq2=""String_Node_Str"";
    System.out.println(xq2);
    final XQuery q=new XQuery(xq2);
    q.serialize(ctx2,System.out);
    store.commitAll();
    System.out.println();
  }
   try (final DBStore store=DBStore.newBuilder().build()){
    final QueryContext ctx3=new QueryContext(store);
    System.out.println();
    System.out.println(""String_Node_Str"");
    final String xq3=""String_Node_Str"";
    System.out.println(xq3);
    XQuery q=new XQuery(new SirixCompileChain(store),xq3);
    q.prettyPrint();
    q.serialize(ctx3,System.out);
    final QueryContext ctx4=new QueryContext(store);
    final String xq4=""String_Node_Str"";
    q=new XQuery(xq4);
    try (final PrintStream out=new PrintStream(new FileOutputStream(new File(new StringBuilder(LOCATION.getAbsolutePath()).append(File.separator).append(""String_Node_Str"").toString())))){
      q.prettyPrint().serialize(ctx4,out);
    }
     System.out.println();
    final QueryContext ctx5=new QueryContext(store);
    final String xq5=""String_Node_Str"";
    q=new XQuery(xq5);
    try (final PrintStream out=new PrintStream(new FileOutputStream(new File(new StringBuilder(LOCATION.getAbsolutePath()).append(File.separator).append(File.separator).append(""String_Node_Str"").toString())))){
      q.prettyPrint().serialize(ctx5,out);
    }
     System.out.println();
  }
 }","/** 
 * Load a document and query it (temporal enhancements).
 */
private static void loadDocumentAndQueryTemporal() throws QueryException, IOException {
  File tmpDir=new File(System.getProperty(""String_Node_Str""));
  try (final DBStore store=DBStore.newBuilder().isUpdatable().build()){
    final QueryContext ctx=new QueryContext(store);
    File doc1=generateSampleDoc(tmpDir,""String_Node_Str"");
    doc1.deleteOnExit();
    System.out.println(""String_Node_Str"");
    final String xq1=String.format(""String_Node_Str"",doc1);
    System.out.println(xq1);
    new XQuery(xq1).evaluate(ctx);
    final QueryContext ctx2=new QueryContext(store);
    System.out.println();
    System.out.println(""String_Node_Str"");
    final String xq2=""String_Node_Str"";
    System.out.println(xq2);
    final XQuery q=new XQuery(xq2);
    q.serialize(ctx2,System.out);
    store.commitAll();
    System.out.println();
    File doc2=generateSampleDoc(tmpDir,""String_Node_Str"");
    doc2.deleteOnExit();
    System.out.println(""String_Node_Str"");
    final String xq3=String.format(""String_Node_Str"",doc2);
    System.out.println(xq3);
    new XQuery(xq3).evaluate(ctx);
  }
   try (final DBStore store=DBStore.newBuilder().isUpdatable().build()){
    final QueryContext ctx3=new QueryContext(store);
    System.out.println();
    System.out.println(""String_Node_Str"");
    Sequence result=new XQuery(new SirixCompileChain(store),""String_Node_Str"").execute(ctx3);
  }
   try (final DBStore store=DBStore.newBuilder().build()){
    final QueryContext ctx3=new QueryContext(store);
    System.out.println();
    System.out.println(""String_Node_Str"");
    final String xq3=""String_Node_Str"";
    System.out.println(xq3);
    XQuery q=new XQuery(new SirixCompileChain(store),xq3);
    q.prettyPrint();
    q.serialize(ctx3,System.out);
    final QueryContext ctx4=new QueryContext(store);
    final String xq4=""String_Node_Str"";
    q=new XQuery(xq4);
    try (final PrintStream out=new PrintStream(new FileOutputStream(new File(new StringBuilder(LOCATION.getAbsolutePath()).append(File.separator).append(""String_Node_Str"").toString())))){
      q.prettyPrint().serialize(ctx4,out);
    }
     System.out.println();
    final QueryContext ctx5=new QueryContext(store);
    final String xq5=""String_Node_Str"";
    q=new XQuery(xq5);
    try (final PrintStream out=new PrintStream(new FileOutputStream(new File(new StringBuilder(LOCATION.getAbsolutePath()).append(File.separator).append(File.separator).append(""String_Node_Str"").toString())))){
      q.prettyPrint().serialize(ctx5,out);
    }
     System.out.println();
  }
 }"
48235,"@Override public AbstractTemporalNode<DBNode> add(SubtreeParser parser) throws OperationNotSupportedException, DocumentException {
  try {
    final String resource=""String_Node_Str"" + mResources++;
    mDatabase.createResource(ResourceConfiguration.newBuilder(resource,mDatabase.getDatabaseConfig()).useDeweyIDs().build());
    final Session session=mDatabase.getSession(SessionConfiguration.newBuilder(resource).build());
    final NodeWriteTrx wtx=session.beginNodeWriteTrx();
    final SubtreeHandler handler=new SubtreeBuilder(this,wtx,Insert.ASFIRSTCHILD,Collections.<SubtreeListener<? super AbstractTemporalNode<DBNode>>>emptyList());
    if (!(parser instanceof CollectionParser)) {
      parser=new CollectionParser(parser);
    }
    parser.parse(handler);
    return new DBNode(wtx,this);
  }
 catch (  final SirixException e) {
    LOGGER.error(e.getMessage(),e);
    return null;
  }
}","@Override public AbstractTemporalNode<DBNode> add(SubtreeParser parser) throws OperationNotSupportedException, DocumentException {
  try {
    final String resource=new StringBuilder(2).append(""String_Node_Str"").append(mDatabase.listResources().length + 1).toString();
    mDatabase.createResource(ResourceConfiguration.newBuilder(resource,mDatabase.getDatabaseConfig()).useDeweyIDs().build());
    final Session session=mDatabase.getSession(SessionConfiguration.newBuilder(resource).build());
    final NodeWriteTrx wtx=session.beginNodeWriteTrx();
    final SubtreeHandler handler=new SubtreeBuilder(this,wtx,Insert.ASFIRSTCHILD,Collections.<SubtreeListener<? super AbstractTemporalNode<DBNode>>>emptyList());
    if (!(parser instanceof CollectionParser)) {
      parser=new CollectionParser(parser);
    }
    parser.parse(handler);
    return new DBNode(wtx,this);
  }
 catch (  final SirixException e) {
    LOGGER.error(e.getMessage(),e);
    return null;
  }
}"
48236,"@Override public Collection<?> create(final String name,final @Nullable Stream<SubtreeParser> parsers) throws DocumentException {
  if (parsers != null) {
    final DatabaseConfiguration dbConf=new DatabaseConfiguration(new File(mLocation,name));
    try {
      Databases.truncateDatabase(dbConf);
      Databases.createDatabase(dbConf);
      final Database database=Databases.openDatabase(dbConf.getFile());
      mDatabases.add(database);
      final ExecutorService pool=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
      try {
        SubtreeParser parser=null;
        int i=0;
        while ((parser=parsers.next()) != null) {
          final SubtreeParser nextParser=parser;
          final String resource=new StringBuilder(""String_Node_Str"").append(String.valueOf(i)).toString();
          pool.submit(new Callable<Void>(){
            @Override public Void call() throws DocumentException, SirixException {
              database.createResource(ResourceConfiguration.newBuilder(resource,dbConf).storageType(mStorageType).useDeweyIDs().build());
              final Session session=database.getSession(new SessionConfiguration.Builder(resource).build());
              final NodeWriteTrx wtx=session.beginNodeWriteTrx();
              final DBCollection collection=new DBCollection(name,database,mUpdating);
              nextParser.parse(new SubtreeBuilder(collection,wtx,Insert.ASFIRSTCHILD,Collections.<SubtreeListener<? super AbstractTemporalNode<DBNode>>>emptyList()));
              wtx.commit();
              wtx.close();
              return null;
            }
          }
);
          i++;
        }
      }
  finally {
        parsers.close();
      }
      pool.shutdown();
      pool.awaitTermination(5,TimeUnit.MINUTES);
      return new DBCollection(name,database,mUpdating);
    }
 catch (    final SirixException|InterruptedException e) {
      throw new DocumentException(e.getCause());
    }
  }
  return null;
}","@Override public Collection<?> create(final String name,final @Nullable Stream<SubtreeParser> parsers) throws DocumentException {
  if (parsers != null) {
    final DatabaseConfiguration dbConf=new DatabaseConfiguration(new File(mLocation,name));
    try {
      Databases.truncateDatabase(dbConf);
      Databases.createDatabase(dbConf);
      final Database database=Databases.openDatabase(dbConf.getFile());
      mDatabases.add(database);
      final ExecutorService pool=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
      int i=database.listResources().length + 1;
      try {
        SubtreeParser parser=null;
        while ((parser=parsers.next()) != null) {
          final SubtreeParser nextParser=parser;
          final String resource=new StringBuilder(""String_Node_Str"").append(String.valueOf(i)).toString();
          pool.submit(new Callable<Void>(){
            @Override public Void call() throws DocumentException, SirixException {
              database.createResource(ResourceConfiguration.newBuilder(resource,dbConf).storageType(mStorageType).useDeweyIDs().build());
              final Session session=database.getSession(new SessionConfiguration.Builder(resource).build());
              final NodeWriteTrx wtx=session.beginNodeWriteTrx();
              final DBCollection collection=new DBCollection(name,database,mUpdating);
              nextParser.parse(new SubtreeBuilder(collection,wtx,Insert.ASFIRSTCHILD,Collections.<SubtreeListener<? super AbstractTemporalNode<DBNode>>>emptyList()));
              wtx.commit();
              wtx.close();
              return null;
            }
          }
);
          i++;
        }
      }
  finally {
        parsers.close();
      }
      pool.shutdown();
      pool.awaitTermination(5,TimeUnit.MINUTES);
      return new DBCollection(name,database,mUpdating);
    }
 catch (    final SirixException|InterruptedException e) {
      throw new DocumentException(e.getCause());
    }
  }
  return null;
}"
48237,"/** 
 * Constructor. Initializes the internal state.
 * @param rtx exclusive (immutable) trx to iterate with
 * @param childAxis producer axis
 */
public ConcurrentAxis(final @Nonnull NodeReadTrx rtx,final @Nonnull Axis childAxis){
  super(rtx);
  if (rtx.equals(childAxis.getTrx())) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  mResults=new ArrayBlockingQueue<>(M_CAPACITY);
  mFirst=true;
  mProducer=checkNotNull(childAxis);
  task=new ConcurrentAxisHelper(mProducer,mResults);
  mFinished=false;
}","/** 
 * Constructor. Initializes the internal state.
 * @param rtx exclusive (immutable) trx to iterate with
 * @param childAxis producer axis
 */
public ConcurrentAxis(final @Nonnull NodeReadTrx rtx,final @Nonnull Axis childAxis){
  super(rtx);
  if (!rtx.equals(childAxis.getTrx())) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  mResults=new ArrayBlockingQueue<>(M_CAPACITY);
  mFirst=true;
  mProducer=checkNotNull(childAxis);
  task=new ConcurrentAxisHelper(mProducer,mResults);
  mFinished=false;
}"
48238,"@Override public DBNode getFirst(){
  moveRtx();
  final AbstractTemporalAxis axis=new FirstAxisTest(mRtx.getSession(),mNodeKey);
  return axis.hasNext() ? new DBNode(axis.getTrx(),mCollection) : null;
}","@Override public DBNode getFirst(){
  moveRtx();
  final AbstractTemporalAxis axis=new FirstAxis(mRtx.getSession(),mNodeKey);
  return axis.hasNext() ? new DBNode(axis.getTrx(),mCollection) : null;
}"
48239,"@Override public <K extends Comparable<? super K>,V extends Record,S extends KeyValuePage<K,V>>RecordPageContainer<S> getRecordPageContainer(final @Nonnull @Nonnegative Long recordPageKey,final @Nonnull PageKind pageKind) throws SirixIOException {
  assertNotClosed();
  checkArgument(recordPageKey >= 0,""String_Node_Str"");
  @SuppressWarnings(""String_Node_Str"") final List<S> revs=(List<S>)getSnapshotPages(checkNotNull(recordPageKey),checkNotNull(pageKind));
  if (revs.size() == 0) {
    @SuppressWarnings(""String_Node_Str"") final RecordPageContainer<S> emptyInstance=(RecordPageContainer<S>)RecordPageContainer.EMPTY_INSTANCE;
    return emptyInstance;
  }
  final int mileStoneRevision=mResourceConfig.mRevisionsToRestore;
  final Revisioning revisioning=mResourceConfig.mRevisionKind;
  final S completePage=revisioning.combineRecordPages(revs,mileStoneRevision,this);
  return new RecordPageContainer<S>(completePage);
}","@Override public <K extends Comparable<? super K>,V extends Record,S extends KeyValuePage<K,V>>RecordPageContainer<S> getRecordPageContainer(final @Nonnull @Nonnegative Long recordPageKey,final @Nonnull PageKind pageKind) throws SirixIOException {
  assertNotClosed();
  checkArgument(recordPageKey >= 0,""String_Node_Str"");
  final List<S> revs=(List<S>)this.<K,V,S>getSnapshotPages(checkNotNull(recordPageKey),checkNotNull(pageKind));
  if (revs.size() == 0) {
    return RecordPageContainer.<S>emptyInstance();
  }
  final int mileStoneRevision=mResourceConfig.mRevisionsToRestore;
  final Revisioning revisioning=mResourceConfig.mRevisionKind;
  final S completePage=revisioning.combineRecordPages(revs,mileStoneRevision,this);
  return new RecordPageContainer<S>(completePage);
}"
48240,"@Override public Optional<Record> getRecord(final @Nonnegative long nodeKey,final @Nonnull PageKind page) throws SirixIOException {
  checkArgument(nodeKey >= Fixed.NULL_NODE_KEY.getStandardProperty());
  checkNotNull(page);
  final long nodePageKey=mPageRtx.nodePageKey(nodeKey);
  final RecordPageContainer<UnorderedKeyValuePage> pageCont=getPageContainer(page,nodePageKey);
  if (pageCont.equals(RecordPageContainer.EMPTY_INSTANCE)) {
    return mPageRtx.getRecord(nodeKey,page);
  }
 else {
    Record node=pageCont.getModified().getRecord(nodeKey);
    if (node == null) {
      node=pageCont.getComplete().getRecord(nodeKey);
    }
    return mPageRtx.checkItemIfDeleted(node);
  }
}","@Override public Optional<Record> getRecord(final @Nonnegative long nodeKey,final @Nonnull PageKind page) throws SirixIOException {
  checkArgument(nodeKey >= Fixed.NULL_NODE_KEY.getStandardProperty());
  checkNotNull(page);
  final long nodePageKey=mPageRtx.nodePageKey(nodeKey);
  final RecordPageContainer<UnorderedKeyValuePage> pageCont=getUnorderedRecordPageContainer(page,nodePageKey);
  if (pageCont.equals(RecordPageContainer.EMPTY_INSTANCE)) {
    return mPageRtx.getRecord(nodeKey,page);
  }
 else {
    Record node=pageCont.getModified().getRecord(nodeKey);
    if (node == null) {
      node=pageCont.getComplete().getRecord(nodeKey);
    }
    return mPageRtx.checkItemIfDeleted(node);
  }
}"
48241,"@SuppressWarnings(""String_Node_Str"") public static final <T extends KeyValuePage<?,?>>RecordPageContainer<T> emptyInstance(){
  return (RecordPageContainer<T>)EMPTY_INSTANCE;
}","/** 
 * Get the empty instance (parameterized).
 * @return the empty instance
 */
@SuppressWarnings(""String_Node_Str"") public static final <T extends KeyValuePage<?,?>>RecordPageContainer<T> emptyInstance(){
  return (RecordPageContainer<T>)EMPTY_INSTANCE;
}"
48242,"@SuppressWarnings(""String_Node_Str"") @Override public void propertyChange(final PropertyChangeEvent pEvent){
switch (pEvent.getPropertyName().toLowerCase()) {
case ""String_Node_Str"":
    mRevision=(long)pEvent.getNewValue();
  break;
case ""String_Node_Str"":
firePropertyChange(""String_Node_Str"",null,pEvent.getNewValue());
break;
case ""String_Node_Str"":
firePropertyChange(""String_Node_Str"",null,pEvent.getNewValue());
break;
case ""String_Node_Str"":
firePropertyChange(""String_Node_Str"",null,pEvent.getNewValue());
break;
case ""String_Node_Str"":
firePropertyChange(""String_Node_Str"",null,pEvent.getNewValue());
break;
case ""String_Node_Str"":
firePropertyChange(""String_Node_Str"",null,pEvent.getNewValue());
break;
case ""String_Node_Str"":
mLastOldMaxDepth=(Integer)pEvent.getNewValue();
if (mContainer.getCompare() == ECompare.HYBRID) {
if (ECompare.HYBRID.getValue()) {
firePropertyChange(""String_Node_Str"",null,mLastOldMaxDepth);
}
}
 else {
firePropertyChange(""String_Node_Str"",null,mLastOldMaxDepth);
}
break;
case ""String_Node_Str"":
mLastMaxDepth=(Integer)pEvent.getNewValue();
if (mContainer.getCompare() == ECompare.HYBRID) {
if (ECompare.HYBRID.getValue()) {
firePropertyChange(""String_Node_Str"",null,mLastMaxDepth);
}
}
 else {
firePropertyChange(""String_Node_Str"",null,mLastMaxDepth);
}
break;
case ""String_Node_Str"":
POOL.submit(new Callable<Void>(){
@Override public Void call() throws Exception {
processDone();
return null;
}
}
);
break;
case ""String_Node_Str"":
mItems=(List<SunburstItem>)pEvent.getNewValue();
break;
}
}","@SuppressWarnings(""String_Node_Str"") @Override public void propertyChange(final PropertyChangeEvent pEvent){
switch (pEvent.getPropertyName().toLowerCase()) {
case ""String_Node_Str"":
    mRevision=(int)pEvent.getNewValue();
  break;
case ""String_Node_Str"":
firePropertyChange(""String_Node_Str"",null,pEvent.getNewValue());
break;
case ""String_Node_Str"":
firePropertyChange(""String_Node_Str"",null,pEvent.getNewValue());
break;
case ""String_Node_Str"":
firePropertyChange(""String_Node_Str"",null,pEvent.getNewValue());
break;
case ""String_Node_Str"":
firePropertyChange(""String_Node_Str"",null,pEvent.getNewValue());
break;
case ""String_Node_Str"":
firePropertyChange(""String_Node_Str"",null,pEvent.getNewValue());
break;
case ""String_Node_Str"":
mLastOldMaxDepth=(Integer)pEvent.getNewValue();
if (mContainer.getCompare() == ECompare.HYBRID) {
if (ECompare.HYBRID.getValue()) {
firePropertyChange(""String_Node_Str"",null,mLastOldMaxDepth);
}
}
 else {
firePropertyChange(""String_Node_Str"",null,mLastOldMaxDepth);
}
break;
case ""String_Node_Str"":
mLastMaxDepth=(Integer)pEvent.getNewValue();
if (mContainer.getCompare() == ECompare.HYBRID) {
if (ECompare.HYBRID.getValue()) {
firePropertyChange(""String_Node_Str"",null,mLastMaxDepth);
}
}
 else {
firePropertyChange(""String_Node_Str"",null,mLastMaxDepth);
}
break;
case ""String_Node_Str"":
POOL.submit(new Callable<Void>(){
@Override public Void call() throws Exception {
processDone();
return null;
}
}
);
break;
case ""String_Node_Str"":
mItems=(List<SunburstItem>)pEvent.getNewValue();
break;
}
}"
48243,"/** 
 * Draws into an off-screen buffer.
 */
private void updateBuffer(){
  mBuffer.pushMatrix();
  mBuffer.colorMode(PConstants.HSB,360,100,100,100);
  mBuffer.background(0,0,getBackgroundBrightness());
  mBuffer.ellipseMode(PConstants.RADIUS);
  mBuffer.strokeCap(PConstants.SQUARE);
  mBuffer.smooth();
  mBuffer.translate((float)mBuffer.width / 2f,(float)mBuffer.height / 2f);
  mBuffer.rotate(PApplet.radians(mRad));
  mBuffer.textFont(mFont);
  mBuffer.stroke(0);
  mBuffer.strokeWeight(2f);
  mBuffer.line(0,0,mBuffer.width * 0.5f,0);
  mBuffer.textSize(15f);
  mBuffer.fill(0f);
  mBuffer.textAlign(PConstants.LEFT,PConstants.BOTTOM);
  mBuffer.text(""String_Node_Str"",mBuffer.width * 0.5f - 60f,-20f + mBuffer.textAscent() - 2f);
  mBuffer.text(""String_Node_Str"",mBuffer.width * 0.5f - 60f,20f);
  drawArrow(mBuffer,(int)Math.round(mBuffer.width * 0.5f - 80),0,30,PConstants.PI * 0.5f);
  mBuffer.noFill();
  drawItems(EDraw.UPDATEBUFFER);
  mBuffer.popMatrix();
}","/** 
 * Draws into an off-screen buffer.
 */
private void updateBuffer(){
  mBuffer.pushMatrix();
  mBuffer.colorMode(PConstants.HSB,360,100,100,100);
  mBuffer.background(0,0,getBackgroundBrightness());
  mBuffer.ellipseMode(PConstants.RADIUS);
  mBuffer.strokeCap(PConstants.SQUARE);
  mBuffer.smooth();
  mBuffer.translate((float)mBuffer.width / 2f,(float)mBuffer.height / 2f);
  mBuffer.rotate(PApplet.radians(mRad));
  mBuffer.textFont(mFont);
  mBuffer.noFill();
  drawItems(EDraw.UPDATEBUFFER);
  mBuffer.stroke(0);
  mBuffer.strokeWeight(2f);
  mBuffer.line(0,0,mBuffer.width * 0.5f,0);
  mBuffer.textSize(15f);
  mBuffer.fill(0f);
  mBuffer.textAlign(PConstants.LEFT,PConstants.BOTTOM);
  mBuffer.text(""String_Node_Str"",mBuffer.width * 0.5f - 60f,-20f + mBuffer.textAscent() - 2f);
  mBuffer.text(""String_Node_Str"",mBuffer.width * 0.5f - 60f,20f);
  drawArrow(mBuffer,(int)Math.round(mBuffer.width * 0.5f - 80),0,30,PConstants.PI * 0.5f);
  mBuffer.popMatrix();
}"
48244,"/** 
 * Undo operation. 
 */
public void undo(){
  mDone=false;
  mLock.acquireUninterruptibly();
  if (!mImages.isEmpty()) {
    mImg=mImages.pop();
  }
  mLock.release();
  mDone=true;
}","/** 
 * Undo operation. 
 */
public void undo(){
  mDone=false;
  mLock.acquireUninterruptibly();
  if (!mImages.isEmpty()) {
    resetZoom();
    if (mUseDiffView == EView.DIFF && EView.DIFF.getValue() && mControl.getModel().getItemsSize() < ANIMATION_THRESHOLD) {
      mInit=true;
    }
 else {
      mInit=false;
    }
    mImg=mImages.pop();
  }
  mLock.release();
  mDone=true;
}"
48245,"@Override protected long nextKey(){
  if (mNextKey == EFixed.NULL_NODE_KEY.getStandardProperty()) {
    return done();
  }
  getTrx().moveTo(mNextKey);
  if (getTrx().getLeftSiblingKey() == getStartKey()) {
    return getTrx().getLeftSiblingKey();
  }
  if (getTrx().hasFirstChild()) {
    mDescendantCount=(int)(getTrx().getDescendantCount() + 1);
    if (mDescendantCount == ITraverseModel.DESCENDANTS_DONE) {
      return done();
    }
 else {
      processMove();
      mChildExtension=mModel.createSunburstItem(mItem,mDepth,mIndex);
      if (mPruning == EPruning.DEPTH && mDepth + 1 >= ITraverseModel.DEPTH_TO_PRUNE) {
        return processPruned();
      }
 else {
        mNextKey=getTrx().getFirstChildKey();
        if (getTrx().hasRightSibling()) {
          mRightSiblingKeyStack.push(getTrx().getRightSiblingKey());
        }
        mAngleStack.push(mAngle);
        mExtensionStack.push(mChildExtension);
        mParentStack.push(mIndex);
        mDescendantsStack.push(mDescendantCount);
        mDepth++;
        mMoved=EMoved.CHILD;
      }
      return mNextKey;
    }
  }
  if (getTrx().hasRightSibling()) {
    mDescendantCount=(int)(getTrx().getDescendantCount() + 1);
    if (mDescendantCount == ITraverseModel.DESCENDANTS_DONE) {
      return done();
    }
 else {
      processMove();
      mChildExtension=mModel.createSunburstItem(mItem,mDepth,mIndex);
      nextRightSibling();
      return mNextKey;
    }
  }
  if (!mRightSiblingKeyStack.isEmpty()) {
    mDescendantCount=(int)(getTrx().getDescendantCount() + 1);
    if (mDescendantCount == ITraverseModel.DESCENDANTS_DONE) {
      return done();
    }
 else {
      processMove();
      mChildExtension=mModel.createSunburstItem(mItem,mDepth,mIndex);
      nextFollowing();
      return mNextKey;
    }
  }
  mDescendantCount=(int)(getTrx().getDescendantCount() + 1);
  if (mDescendantCount == ITraverseModel.DESCENDANTS_DONE) {
    return done();
  }
 else {
    processMove();
    mChildExtension=mModel.createSunburstItem(mItem,mDepth,mIndex);
    mNextKey=(Long)EFixed.NULL_NODE_KEY.getStandardProperty();
    return mNextKey;
  }
}","@Override protected long nextKey(){
  if (mNextKey == EFixed.NULL_NODE_KEY.getStandardProperty()) {
    return done();
  }
  getTrx().moveTo(mNextKey);
  if (getTrx().getLeftSiblingKey() == getStartKey()) {
    return EFixed.NULL_NODE_KEY.getStandardProperty();
  }
  if (getTrx().hasFirstChild()) {
    mDescendantCount=(int)(getTrx().getDescendantCount() + 1);
    if (mDescendantCount == ITraverseModel.DESCENDANTS_DONE) {
      return done();
    }
 else {
      processMove();
      mChildExtension=mModel.createSunburstItem(mItem,mDepth,mIndex);
      if (mPruning == EPruning.DEPTH && mDepth + 1 >= ITraverseModel.DEPTH_TO_PRUNE) {
        return processPruned();
      }
 else {
        mNextKey=getTrx().getFirstChildKey();
        if (getTrx().hasRightSibling()) {
          mRightSiblingKeyStack.push(getTrx().getRightSiblingKey());
        }
        mAngleStack.push(mAngle);
        mExtensionStack.push(mChildExtension);
        mParentStack.push(mIndex);
        mDescendantsStack.push(mDescendantCount);
        mDepth++;
        mMoved=EMoved.CHILD;
      }
      return mNextKey;
    }
  }
  if (getTrx().hasRightSibling()) {
    mDescendantCount=(int)(getTrx().getDescendantCount() + 1);
    if (mDescendantCount == ITraverseModel.DESCENDANTS_DONE) {
      return done();
    }
 else {
      processMove();
      mChildExtension=mModel.createSunburstItem(mItem,mDepth,mIndex);
      nextRightSibling();
      return mNextKey;
    }
  }
  if (!mRightSiblingKeyStack.isEmpty()) {
    mDescendantCount=(int)(getTrx().getDescendantCount() + 1);
    if (mDescendantCount == ITraverseModel.DESCENDANTS_DONE) {
      return done();
    }
 else {
      processMove();
      mChildExtension=mModel.createSunburstItem(mItem,mDepth,mIndex);
      nextFollowing();
      return mNextKey;
    }
  }
  mDescendantCount=(int)(getTrx().getDescendantCount() + 1);
  if (mDescendantCount == ITraverseModel.DESCENDANTS_DONE) {
    return done();
  }
 else {
    processMove();
    mChildExtension=mModel.createSunburstItem(mItem,mDepth,mIndex);
    mNextKey=(Long)EFixed.NULL_NODE_KEY.getStandardProperty();
    return mNextKey;
  }
}"
48246,"@Override public void update(@Nonnull final IContainer<SunburstContainer> pContainer){
  mLastItems.push(new ArrayList<>(mItems));
  mLastDepths.push(mLastMaxDepth);
  traverseTree(pContainer);
}","@Override public void update(@Nonnull final IContainer<SunburstContainer> pContainer){
  mLastItems.push(new ArrayList<>(mItems));
  mLastDepths.push(mLastMaxDepth);
}"
48247,"public static void testReadWriteFirstRef(final ResourceConfiguration resourceConf) throws AbsTTException {
  final IStorage fac=EStorage.getStorage(resourceConf);
  final PageReference pageRef1=new PageReference();
  final UberPage page1=new UberPage();
  pageRef1.setPage(page1);
  final IWriter writer=fac.getWriter();
  writer.writeFirstReference(pageRef1);
  final PageReference pageRef2=writer.readFirstReference();
  assertEquals(pageRef1.getNodePageKey(),pageRef2.getNodePageKey());
  assertEquals(((UberPage)pageRef1.getPage()).getRevisionCount(),((UberPage)pageRef2.getPage()).getRevisionCount());
  writer.close();
  final IReader reader=fac.getReader();
  final PageReference pageRef3=reader.readFirstReference();
  assertEquals(pageRef1.getNodePageKey(),pageRef3.getNodePageKey());
  assertEquals(((UberPage)pageRef1.getPage()).getRevisionCount(),((UberPage)pageRef3.getPage()).getRevisionCount());
  reader.close();
  fac.close();
}","/** 
 * Test reading/writing the first reference.
 * @param resourceConf {@link ResourceConfiguration} reference
 * @throws AbsTTException if something went wrong
 */
public static void testReadWriteFirstRef(final ResourceConfiguration resourceConf) throws AbsTTException {
  final IStorage fac=EStorage.getStorage(resourceConf);
  final PageReference pageRef1=new PageReference();
  final UberPage page1=new UberPage();
  pageRef1.setPage(page1);
  final IWriter writer=fac.getWriter();
  writer.writeFirstReference(pageRef1);
  final PageReference pageRef2=writer.readFirstReference();
  assertEquals(pageRef1.getNodePageKey(),pageRef2.getNodePageKey());
  assertEquals(((UberPage)pageRef1.getPage()).getRevisionCount(),((UberPage)pageRef2.getPage()).getRevisionCount());
  writer.close();
  final IReader reader=fac.getReader();
  final PageReference pageRef3=reader.readFirstReference();
  assertEquals(pageRef1.getNodePageKey(),pageRef3.getNodePageKey());
  assertEquals(((UberPage)pageRef1.getPage()).getRevisionCount(),((UberPage)pageRef3.getPage()).getRevisionCount());
  reader.close();
  fac.close();
}"
48248,"private IOTestHelper(){
}","/** 
 * Private constructor. 
 */
private IOTestHelper(){
}"
48249,"/** 
 * Close caches.
 */
void closeCaches(){
  if (mPathLog.isPresent()) {
    mPathLog.get().close();
  }
  if (mValueLog.isPresent()) {
    mValueLog.get().close();
  }
  if (mNodeLog.isPresent()) {
    mNodeLog.get().close();
  }
  if (mPageLog.isPresent()) {
    mPageLog.get().close();
  }
}","/** 
 * Close caches.
 */
void closeCaches(){
  if (mPathLog.isPresent()) {
    mPathLog.get().close();
  }
  if (mValueLog.isPresent()) {
    mValueLog.get().close();
  }
  if (mNodeLog.isPresent()) {
    mNodeLog.get().close();
  }
  if (mPageLog.isPresent()) {
    mPageLog.get().close();
  }
  clearCaches();
}"
48250,"@Override public final boolean moveTo(final long pNodeKey){
  assertNotClosed();
  if (pNodeKey == EFixed.NULL_NODE_KEY.getStandardProperty()) {
    return false;
  }
  final INode oldNode=mCurrentNode;
  Optional<? extends INode> newNode;
  try {
    if (pNodeKey < 0) {
      if (mItemList.size() > 0) {
        newNode=mItemList.getItem(pNodeKey);
      }
 else {
        newNode=Optional.absent();
      }
    }
 else {
      @SuppressWarnings(""String_Node_Str"") final Optional<? extends INode> node=(Optional<? extends INode>)mPageReadTrx.getNode(pNodeKey,EPage.NODEPAGE);
      newNode=node;
    }
  }
 catch (  final TTIOException e) {
    newNode=Optional.absent();
  }
  if (newNode.isPresent()) {
    mCurrentNode=newNode.get();
    return true;
  }
 else {
    mCurrentNode=oldNode;
    return false;
  }
}","@Override public final boolean moveTo(final long pNodeKey){
  assertNotClosed();
  if (pNodeKey == EFixed.NULL_NODE_KEY.getStandardProperty()) {
    return false;
  }
  final INode oldNode=mCurrentNode;
  Optional<? extends INodeBase> newNode;
  try {
    if (pNodeKey < 0) {
      if (mItemList.size() > 0) {
        newNode=mItemList.getItem(pNodeKey);
      }
 else {
        newNode=Optional.absent();
      }
    }
 else {
      @SuppressWarnings(""String_Node_Str"") final Optional<? extends INodeBase> node=mPageReadTrx.getNode(pNodeKey,EPage.NODEPAGE);
      newNode=node;
    }
  }
 catch (  final TTIOException e) {
    newNode=Optional.absent();
  }
  if (newNode.isPresent()) {
    mCurrentNode=(INode)newNode.get();
    return true;
  }
 else {
    mCurrentNode=oldNode;
    return false;
  }
}"
48251,"/** 
 * Get a node from persistent storage.
 * @param pKey the unique node-ID
 * @param pPage the page from which to fetch the node
 * @return an {@link Optional} reference usually containing the node reference
 * @throws TTIOException if an I/O error occured
 */
Optional<INodeBase> getNode(@Nonnegative final long pKey,@Nonnull final EPage pPage) throws TTIOException ;","/** 
 * Get a node from persistent storage.
 * @param pKey the unique node-ID
 * @param pPage the page from which to fetch the node
 * @return an {@link Optional} reference usually containing the node reference
 * @throws TTIOException if an I/O error occured
 */
Optional<? extends INodeBase> getNode(@Nonnegative final long pKey,@Nonnull final EPage pPage) throws TTIOException ;"
48252,"private PathSummary(@Nonnull final IPageReadTrx pPageReadTrx){
  mPageReadTrx=pPageReadTrx;
  mClosed=false;
  try {
    @SuppressWarnings(""String_Node_Str"") final Optional<? extends INode> node=(Optional<? extends INode>)mPageReadTrx.getNode(EFixed.DOCUMENT_NODE_KEY.getStandardProperty(),EPage.PATHSUMMARYPAGE);
    if (node.isPresent()) {
      mCurrentNode=node.get();
    }
 else {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
 catch (  final TTIOException e) {
    e.printStackTrace();
  }
}","private PathSummary(@Nonnull final IPageReadTrx pPageReadTrx){
  mPageReadTrx=pPageReadTrx;
  mClosed=false;
  try {
    final Optional<? extends INodeBase> node=mPageReadTrx.getNode(EFixed.DOCUMENT_NODE_KEY.getStandardProperty(),EPage.PATHSUMMARYPAGE);
    if (node.isPresent()) {
      mCurrentNode=(INode)node.get();
    }
 else {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
 catch (  final TTIOException e) {
    e.printStackTrace();
  }
}"
48253,"/** 
 * Private constructor.
 * @param pPageWriteTrx {@link IPageWriteTrx} for persistent storage
 */
private AVLTree(final @Nonnull IPageWriteTrx pPageWriteTrx){
  mPageWriteTrx=pPageWriteTrx;
  mClosed=false;
  try {
    @SuppressWarnings(""String_Node_Str"") Optional<? extends INode> node=(Optional<? extends INode>)mPageWriteTrx.getNode(EFixed.DOCUMENT_NODE_KEY.getStandardProperty(),EPage.VALUEPAGE);
    if (node.isPresent()) {
      mCurrentNode=node.get();
    }
 else {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
 catch (  final TTIOException e) {
    e.printStackTrace();
  }
}","/** 
 * Private constructor.
 * @param pPageWriteTrx {@link IPageWriteTrx} for persistent storage
 */
private AVLTree(final @Nonnull IPageWriteTrx pPageWriteTrx){
  mPageWriteTrx=pPageWriteTrx;
  mClosed=false;
  try {
    Optional<? extends INodeBase> node=mPageWriteTrx.getNode(EFixed.DOCUMENT_NODE_KEY.getStandardProperty(),EPage.VALUEPAGE);
    if (node.isPresent()) {
      mCurrentNode=(INode)node.get();
    }
 else {
      throw new IllegalStateException(""String_Node_Str"");
    }
  }
 catch (  final TTIOException e) {
    e.printStackTrace();
  }
}"
48254,"/** 
 * Closing a resource. This callback is necessary due to centralized handling of all sessions within a database.
 * @param pFile {@link File} to be closed
 * @return {@code true} if close successful, {@code false} otherwise
 */
protected boolean removeSession(@Nonnull final File pFile){
  return mSessions.remove(pFile) == null ? false : true;
}","/** 
 * Closing a resource. This callback is necessary due to centralized handling of all sessions within a database.
 * @param pFile {@link File} to be closed
 * @return {@code true} if close successful, {@code false} otherwise
 */
protected boolean removeSession(final @Nonnull File pFile){
  return mSessions.remove(pFile) == null ? false : true;
}"
48255,"/** 
 * Creating a database. This includes loading the database configuration, building up the structure and preparing everything for login.
 * @param pDBConfig which are used for the database, including storage location
 * @return true if creation is valid, false otherwise
 * @throws TTIOException if something odd happens within the creation process.
 */
public static synchronized boolean createDatabase(@Nonnull final DatabaseConfiguration pDBConfig) throws TTIOException {
  boolean returnVal=true;
  if (pDBConfig.getFile().exists()) {
    return false;
  }
 else {
    returnVal=pDBConfig.getFile().mkdirs();
    if (returnVal) {
      for (      DatabaseConfiguration.Paths paths : DatabaseConfiguration.Paths.values()) {
        final File toCreate=new File(pDBConfig.getFile().getAbsoluteFile(),paths.getFile().getName());
        if (paths.isFolder()) {
          returnVal=toCreate.mkdir();
        }
 else {
          try {
            returnVal=toCreate.createNewFile();
          }
 catch (          final IOException exc) {
            throw new TTIOException(exc);
          }
        }
        if (!returnVal) {
          break;
        }
      }
    }
    try {
      serializeConfiguration(pDBConfig);
    }
 catch (    final IOException exc) {
      throw new TTIOException(exc);
    }
    if (!returnVal) {
      pDBConfig.getFile().delete();
    }
    return returnVal;
  }
}","/** 
 * Creating a database. This includes loading the database configuration, building up the structure and preparing everything for login.
 * @param pDBConfig config which is used for the database, including storage location
 * @return true if creation is valid, false otherwise
 * @throws TTIOException if something odd happens within the creation process.
 */
public static synchronized boolean createDatabase(@Nonnull final DatabaseConfiguration pDBConfig) throws TTIOException {
  boolean returnVal=true;
  if (pDBConfig.getFile().exists()) {
    return false;
  }
 else {
    returnVal=pDBConfig.getFile().mkdirs();
    if (returnVal) {
      for (      DatabaseConfiguration.Paths paths : DatabaseConfiguration.Paths.values()) {
        final File toCreate=new File(pDBConfig.getFile().getAbsoluteFile(),paths.getFile().getName());
        if (paths.isFolder()) {
          returnVal=toCreate.mkdir();
        }
 else {
          try {
            returnVal=toCreate.createNewFile();
          }
 catch (          final IOException exc) {
            throw new TTIOException(exc);
          }
        }
        if (!returnVal) {
          break;
        }
      }
    }
    try {
      serializeConfiguration(pDBConfig);
    }
 catch (    final IOException exc) {
      throw new TTIOException(exc);
    }
    if (!returnVal) {
      pDBConfig.getFile().delete();
    }
    return returnVal;
  }
}"
48256,"/** 
 * Serializing any   {@link IConfigureSerializable} instance to a denotedfile.
 * @param pConf to be serializied, containing the file
 * @throws IOException if serialization fails
 */
private static void serializeConfiguration(@Nonnull final IConfigureSerializable pConf) throws IOException {
  try (final FileOutputStream os=new FileOutputStream(pConf.getConfigFile());final ObjectOutputStream en=new ObjectOutputStream(os)){
    en.writeObject(pConf);
  }
 }","/** 
 * Serializing any   {@link IConfigureSerializable} instance to a denotedfile.
 * @param pConf to be serializied, containing the file
 * @throws IOException if serialization fails
 */
private static void serializeConfiguration(final @Nonnull IConfigureSerializable pConf) throws IOException {
  try (final FileOutputStream os=new FileOutputStream(pConf.getConfigFile());final ObjectOutputStream en=new ObjectOutputStream(os)){
    en.writeObject(pConf);
  }
 }"
48257,"/** 
 * Open database. A database can be opened only once. Afterwards the singleton instance bound to the File is given back.
 * @param pFile determines where the database is located sessionConf a  {@link SessionConfiguration} object toset up the session
 * @return {@link IDatabase} instance.
 * @throws AbsTTException if something odd happens
 */
public static synchronized IDatabase openDatabase(@Nonnull final File pFile) throws AbsTTException {
  if (!pFile.exists()) {
    throw new TTUsageException(""String_Node_Str"",pFile.toString());
  }
  DatabaseConfiguration config=null;
  try (final FileInputStream is=new FileInputStream(new File(pFile.getAbsoluteFile(),DatabaseConfiguration.Paths.ConfigBinary.getFile().getName()));final ObjectInputStream de=new ObjectInputStream(is)){
    config=(DatabaseConfiguration)de.readObject();
  }
 catch (  final IOException exc) {
    throw new TTIOException(exc);
  }
catch (  final ClassNotFoundException exc) {
    throw new TTIOException(exc.toString());
  }
  if (config == null) {
    throw new IllegalStateException();
  }
  final Database database=new Database(config);
  final IDatabase returnVal=DATABASEMAP.putIfAbsent(pFile,database);
  if (returnVal == null) {
    return database;
  }
 else {
    return returnVal;
  }
}","/** 
 * Open database. A database can be opened only once. Afterwards a singleton instance bound to the   {@link File} is returned.
 * @param pFile determines where the database is located sessionConf a  {@link SessionConfiguration} object toset up the session
 * @return {@link IDatabase} instance.
 * @throws AbsTTException if something odd happens
 * @throws NullPointerException if  {@code pFile} is {@code null}
 */
public static synchronized IDatabase openDatabase(final @Nonnull File pFile) throws AbsTTException {
  if (!pFile.exists()) {
    throw new TTUsageException(""String_Node_Str"",pFile.toString());
  }
  DatabaseConfiguration config=null;
  try (final FileInputStream is=new FileInputStream(new File(pFile.getAbsoluteFile(),DatabaseConfiguration.Paths.ConfigBinary.getFile().getName()));final ObjectInputStream de=new ObjectInputStream(is)){
    config=(DatabaseConfiguration)de.readObject();
  }
 catch (  final IOException exc) {
    throw new TTIOException(exc);
  }
catch (  final ClassNotFoundException exc) {
    throw new TTIOException(exc.toString());
  }
  if (config == null) {
    throw new IllegalStateException();
  }
  final Database database=new Database(config);
  final IDatabase returnVal=DATABASEMAP.putIfAbsent(pFile,database);
  if (returnVal == null) {
    return database;
  }
 else {
    return returnVal;
  }
}"
48258,"@Override public synchronized ISession getSession(@Nonnull final SessionConfiguration pSessionConf) throws AbsTTException {
}","@Override public synchronized ISession getSession(final @Nonnull SessionConfiguration pSessionConf) throws AbsTTException {
}"
48259,"@Override public synchronized void remove() throws AbsTTException {
  checkAccessAndCommit();
  if (getNode().getKind() == EKind.DOCUMENT_ROOT) {
    throw new TTUsageException(""String_Node_Str"");
  }
 else   if (getNode() instanceof IStructNode) {
    final IStructNode node=(IStructNode)mNodeReadRtx.getNode();
    for (final IAxis axis=new DescendantAxis(this); axis.hasNext(); ) {
      axis.next();
      final IStructNode nodeToDelete=axis.getTransaction().getStructuralNode();
      if (nodeToDelete.getKind() == EKind.ELEMENT) {
        final ElementNode element=(ElementNode)nodeToDelete;
        removeName();
        final int attCount=element.getAttributeCount();
        for (int i=0; i < attCount; i++) {
          moveToAttribute(i);
          removeName();
          getPageTransaction().removeNode(mNodeReadRtx.getNode(),EPage.NODEPAGE);
          moveToParent();
        }
        final int nspCount=element.getNamespaceCount();
        for (int i=0; i < nspCount; i++) {
          moveToNamespace(i);
          removeName();
          getPageTransaction().removeNode(mNodeReadRtx.getNode(),EPage.NODEPAGE);
          moveToParent();
        }
      }
      getPageTransaction().removeNode(nodeToDelete,EPage.NODEPAGE);
    }
    mNodeReadRtx.setCurrentNode(node);
    adaptHashesWithRemove();
    adaptForRemove(node,EPage.NODEPAGE);
    mNodeReadRtx.setCurrentNode(node);
    if (node.getKind() == EKind.ELEMENT) {
      removeName();
    }
    if (node.hasRightSibling() && moveTo(node.getRightSiblingKey())) {
    }
 else     if (node.hasLeftSibling()) {
      moveTo(node.getLeftSiblingKey());
    }
 else {
      moveTo(node.getParentKey());
    }
  }
 else   if (getNode().getKind() == EKind.ATTRIBUTE) {
    final INode node=mNodeReadRtx.getNode();
    final ElementNode parent=(ElementNode)getPageTransaction().prepareNodeForModification(node.getParentKey(),EPage.NODEPAGE);
    parent.removeAttribute(node.getNodeKey());
    getPageTransaction().finishNodeModification(parent,EPage.NODEPAGE);
    adaptHashesWithRemove();
    getPageTransaction().removeNode(node,EPage.NODEPAGE);
    removeName();
    moveToParent();
  }
 else   if (getNode().getKind() == EKind.NAMESPACE) {
    final INode node=mNodeReadRtx.getNode();
    final ElementNode parent=(ElementNode)getPageTransaction().prepareNodeForModification(node.getParentKey(),EPage.NODEPAGE);
    parent.removeNamespace(node.getNodeKey());
    getPageTransaction().finishNodeModification(parent,EPage.NODEPAGE);
    adaptHashesWithRemove();
    getPageTransaction().removeNode(node,EPage.NODEPAGE);
    removeName();
    moveToParent();
  }
}","@Override public synchronized void remove() throws AbsTTException {
  checkAccessAndCommit();
  if (getNode().getKind() == EKind.DOCUMENT_ROOT) {
    throw new TTUsageException(""String_Node_Str"");
  }
 else   if (getNode() instanceof IStructNode) {
    final IStructNode node=(IStructNode)mNodeReadRtx.getNode();
    for (final IAxis axis=new DescendantAxis(this); axis.hasNext(); ) {
      axis.next();
      final IStructNode nodeToDelete=axis.getTransaction().getStructuralNode();
      if (nodeToDelete.getKind() == EKind.ELEMENT) {
        final ElementNode element=(ElementNode)nodeToDelete;
        removeNonStructural(element);
        removeName();
      }
      getPageTransaction().removeNode(nodeToDelete,EPage.NODEPAGE);
    }
    mNodeReadRtx.setCurrentNode(node);
    adaptHashesWithRemove();
    adaptForRemove(node,EPage.NODEPAGE);
    mNodeReadRtx.setCurrentNode(node);
    if (node.getKind() == EKind.ELEMENT) {
      removeName();
    }
    if (node.hasRightSibling() && moveTo(node.getRightSiblingKey())) {
    }
 else     if (node.hasLeftSibling()) {
      moveTo(node.getLeftSiblingKey());
    }
 else {
      moveTo(node.getParentKey());
    }
  }
 else   if (getNode().getKind() == EKind.ATTRIBUTE) {
    final INode node=mNodeReadRtx.getNode();
    final ElementNode parent=(ElementNode)getPageTransaction().prepareNodeForModification(node.getParentKey(),EPage.NODEPAGE);
    parent.removeAttribute(node.getNodeKey());
    getPageTransaction().finishNodeModification(parent,EPage.NODEPAGE);
    adaptHashesWithRemove();
    getPageTransaction().removeNode(node,EPage.NODEPAGE);
    removeName();
    moveToParent();
  }
 else   if (getNode().getKind() == EKind.NAMESPACE) {
    final INode node=mNodeReadRtx.getNode();
    final ElementNode parent=(ElementNode)getPageTransaction().prepareNodeForModification(node.getParentKey(),EPage.NODEPAGE);
    parent.removeNamespace(node.getNodeKey());
    getPageTransaction().finishNodeModification(parent,EPage.NODEPAGE);
    adaptHashesWithRemove();
    getPageTransaction().removeNode(node,EPage.NODEPAGE);
    removeName();
    moveToParent();
  }
}"
48260,"@Override public synchronized void setQName(@Nonnull final QName pQName) throws AbsTTException {
  checkNotNull(pQName);
  if (getNode() instanceof INameNode) {
    if (!getQNameOfCurrentNode().equals(pQName)) {
      checkAccessAndCommit();
      INameNode node=(INameNode)mNodeReadRtx.getNode();
      final long oldHash=node.hashCode();
      final EKind nodeKind=node.getKind();
      final int oldNameKey=node.getNameKey();
      final int oldUriKey=node.getURIKey();
      final NamePage page=((NamePage)getPageTransaction().getActualRevisionRootPage().getNamePageReference().getPage());
      page.removeName(oldNameKey,nodeKind);
      page.removeName(oldUriKey,EKind.NAMESPACE);
      final int nameKey=getPageTransaction().createNameKey(PageWriteTrx.buildName(pQName),node.getKind());
      final int uriKey=getPageTransaction().createNameKey(pQName.getNamespaceURI(),EKind.NAMESPACE);
      movePathSummary();
      if (((PathNode)mPathSummary.getNode()).getReferences() == 1) {
        final PathNode pathNode=(PathNode)getPageTransaction().prepareNodeForModification(mPathSummary.getNode().getNodeKey(),EPage.PATHSUMMARYPAGE);
        pathNode.setNameKey(nameKey);
        pathNode.setURIKey(uriKey);
        getPageTransaction().finishNodeModification(pathNode,EPage.PATHSUMMARYPAGE);
      }
 else {
        final PathNode pathNode=(PathNode)getPageTransaction().prepareNodeForModification(mPathSummary.getNode().getNodeKey(),EPage.PATHSUMMARYPAGE);
        pathNode.decrementReferenceCount();
        getPageTransaction().finishNodeModification(pathNode,EPage.PATHSUMMARYPAGE);
        moveToParent();
        int level=0;
        if (mNodeReadRtx.getNode().getKind() == EKind.DOCUMENT_ROOT) {
          mPathSummary.moveToDocumentRoot();
        }
 else {
          movePathSummary();
          level=mPathSummary.getPathNode().getLevel();
        }
        moveTo(node.getNodeKey());
        final IAxis axis=new FilterAxis(new ChildAxis(mPathSummary),new NameFilter(mPathSummary,pQName.getLocalPart()));
        if (axis.hasNext()) {
          axis.next();
          final PathNode path=(PathNode)getPageTransaction().prepareNodeForModification(mPathSummary.getNode().getNodeKey(),EPage.PATHSUMMARYPAGE);
          path.incrementReferenceCount();
          getPageTransaction().finishNodeModification(path,EPage.PATHSUMMARYPAGE);
        }
 else {
          for (final IAxis descendants=new DescendantAxis(this,EIncludeSelf.YES); descendants.hasNext(); ) {
            descendants.next();
            if (axis.getTransaction().getNode().getKind() == EKind.ELEMENT) {
              final ElementNode element=(ElementNode)axis.getTransaction().getNode();
              insertPathAsFirstChild(axis.getTransaction().getQNameOfCurrentNode(),nodeKind,level);
              for (int i=0, nsps=element.getNamespaceCount(); i < nsps; i++) {
                moveToNamespace(i);
                insertPathAsFirstChild(axis.getTransaction().getQNameOfCurrentNode(),nodeKind,level);
                moveToParent();
                mPathSummary.moveToParent();
              }
              for (int i=0, atts=element.getAttributeCount(); i < atts; i++) {
                moveToAttribute(i);
                insertPathAsFirstChild(axis.getTransaction().getQNameOfCurrentNode(),nodeKind,level);
                moveToParent();
                mPathSummary.moveToParent();
              }
            }
          }
        }
      }
      node=(INameNode)getPageTransaction().prepareNodeForModification(mNodeReadRtx.getNode().getNodeKey(),EPage.NODEPAGE);
      node.setNameKey(nameKey);
      node.setURIKey(uriKey);
      node.setPathNodeKey(mPathSummary.getNode().getNodeKey());
      getPageTransaction().finishNodeModification(node,EPage.NODEPAGE);
      mNodeReadRtx.setCurrentNode(node);
      adaptHashedWithUpdate(oldHash);
    }
  }
 else {
    throw new TTUsageException(""String_Node_Str"");
  }
}","@Override public synchronized void setQName(@Nonnull final QName pQName) throws AbsTTException {
  checkNotNull(pQName);
  if (getNode() instanceof INameNode) {
    if (!getQNameOfCurrentNode().equals(pQName)) {
      checkAccessAndCommit();
      INameNode node=(INameNode)mNodeReadRtx.getNode();
      final long oldHash=node.hashCode();
      final EKind nodeKind=node.getKind();
      final int oldNameKey=node.getNameKey();
      final int oldUriKey=node.getURIKey();
      final NamePage page=((NamePage)getPageTransaction().getActualRevisionRootPage().getNamePageReference().getPage());
      page.removeName(oldNameKey,nodeKind);
      page.removeName(oldUriKey,EKind.NAMESPACE);
      final int nameKey=getPageTransaction().createNameKey(PageWriteTrx.buildName(pQName),node.getKind());
      final int uriKey=getPageTransaction().createNameKey(pQName.getNamespaceURI(),EKind.NAMESPACE);
      movePathSummary();
      if (((PathNode)mPathSummary.getNode()).getReferences() == 1) {
        final PathNode pathNode=(PathNode)getPageTransaction().prepareNodeForModification(mPathSummary.getNode().getNodeKey(),EPage.PATHSUMMARYPAGE);
        pathNode.setNameKey(nameKey);
        pathNode.setURIKey(uriKey);
        getPageTransaction().finishNodeModification(pathNode,EPage.PATHSUMMARYPAGE);
      }
 else {
        final PathNode pathNode=(PathNode)getPageTransaction().prepareNodeForModification(mPathSummary.getNode().getNodeKey(),EPage.PATHSUMMARYPAGE);
        pathNode.decrementReferenceCount();
        getPageTransaction().finishNodeModification(pathNode,EPage.PATHSUMMARYPAGE);
        moveToParent();
        int level=0;
        if (mNodeReadRtx.getNode().getKind() == EKind.DOCUMENT_ROOT) {
          mPathSummary.moveToDocumentRoot();
        }
 else {
          movePathSummary();
          level=mPathSummary.getPathNode().getLevel();
        }
        moveTo(node.getNodeKey());
        final IAxis axis=new FilterAxis(new ChildAxis(mPathSummary),new NameFilter(mPathSummary,pQName.getLocalPart()));
        if (axis.hasNext()) {
          axis.next();
          final PathNode path=(PathNode)getPageTransaction().prepareNodeForModification(mPathSummary.getNode().getNodeKey(),EPage.PATHSUMMARYPAGE);
          path.incrementReferenceCount();
          getPageTransaction().finishNodeModification(path,EPage.PATHSUMMARYPAGE);
          adaptNode(node,nameKey,uriKey);
        }
 else {
          adaptNode(node,nameKey,uriKey);
          boolean firstRun=true;
          for (final IAxis descendants=new DescendantAxis(this,EIncludeSelf.YES); descendants.hasNext(); ) {
            descendants.next();
            if (descendants.getTransaction().getNode().getKind() == EKind.ELEMENT) {
              final ElementNode element=(ElementNode)descendants.getTransaction().getNode();
              insertPathAsFirstChild(descendants.getTransaction().getQNameOfCurrentNode(),EKind.ELEMENT,++level);
              for (int i=0, nsps=element.getNamespaceCount(); i < nsps; i++) {
                moveToNamespace(i);
                insertPathAsFirstChild(descendants.getTransaction().getQNameOfCurrentNode(),EKind.NAMESPACE,level);
                resetPathNodeKey(getNode().getNodeKey());
                moveToParent();
                mPathSummary.moveToParent();
              }
              for (int i=0, atts=element.getAttributeCount(); i < atts; i++) {
                moveToAttribute(i);
                insertPathAsFirstChild(descendants.getTransaction().getQNameOfCurrentNode(),EKind.ATTRIBUTE,level);
                resetPathNodeKey(getNode().getNodeKey());
                moveToParent();
                mPathSummary.moveToParent();
              }
              if (firstRun) {
                firstRun=false;
              }
 else {
                mPathSummary.moveToParent();
                level--;
              }
            }
          }
        }
      }
      mNodeReadRtx.setCurrentNode(node);
      adaptHashedWithUpdate(oldHash);
    }
  }
 else {
    throw new TTUsageException(""String_Node_Str"");
  }
}"
48261,"/** 
 * Insert a path node as first child.
 * @param pQName {@link QName} of the path node (not stored) twice
 * @return this {@link WriteTransaction} instance
 * @throws AbsTTException if an I/O error occurs
 */
private INodeWriteTrx insertPathAsFirstChild(@Nonnull final QName pQName,final EKind pKind,final int pLevel) throws AbsTTException {
  if (!XMLToken.isValidQName(checkNotNull(pQName))) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  checkAccessAndCommit();
  final long parentKey=mPathSummary.getNode().getNodeKey();
  final long leftSibKey=EFixed.NULL_NODE_KEY.getStandardProperty();
  final long rightSibKey=mPathSummary.getStructuralNode().getFirstChildKey();
  final PathNode node=createPathNode(parentKey,leftSibKey,rightSibKey,0,pQName,pKind,pLevel);
  mPathSummary.setCurrentNode(node);
  adaptForInsert(node,EInsertPos.ASFIRSTCHILD,EPage.PATHSUMMARYPAGE);
  mPathSummary.setCurrentNode(node);
  return this;
}","/** 
 * Insert a path node as first child.
 * @param pQName {@link QName} of the path node (not stored) twice
 * @param pKind kind of node to index
 * @param pLevel level in the path summary
 * @return this {@link WriteTransaction} instance
 * @throws AbsTTException if an I/O error occurs
 */
private INodeWriteTrx insertPathAsFirstChild(@Nonnull final QName pQName,final EKind pKind,final int pLevel) throws AbsTTException {
  if (!XMLToken.isValidQName(checkNotNull(pQName))) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  checkAccessAndCommit();
  final long parentKey=mPathSummary.getNode().getNodeKey();
  final long leftSibKey=EFixed.NULL_NODE_KEY.getStandardProperty();
  final long rightSibKey=mPathSummary.getStructuralNode().getFirstChildKey();
  final PathNode node=createPathNode(parentKey,leftSibKey,rightSibKey,0,pQName,pKind,pLevel);
  mPathSummary.setCurrentNode(node);
  adaptForInsert(node,EInsertPos.ASFIRSTCHILD,EPage.PATHSUMMARYPAGE);
  mPathSummary.setCurrentNode(node);
  return this;
}"
48262,"/** 
 * Checking a structure in a folder to be equal with the data in this enum.
 * @param pFile to be checked
 * @return -1 if less folders are there, 0 if the structure is equal tothe one expected, 1 if the structure has more folders
 */
public static int compareStructure(@Nonnull final File pFile){
  checkNotNull(pFile);
  int existing=0;
  for (  final Paths paths : values()) {
    final File currentFile=new File(pFile,paths.getFile().getName());
    if (currentFile.exists()) {
      existing++;
    }
  }
  return existing - values().length;
}","/** 
 * Checking a structure in a folder to be equal with the data in this enum.
 * @param pFile to be checked
 * @return -1 if less folders are there, 0 if the structure is equal tothe one expected, 1 if the structure has more folders
 */
public static int compareStructure(final @Nonnull File pFile){
  checkNotNull(pFile);
  int existing=0;
  for (  final Paths paths : values()) {
    final File currentFile=new File(pFile,paths.getFile().getName());
    if (currentFile.exists()) {
      existing++;
    }
  }
  return existing - values().length;
}"
48263,"/** 
 * Constructor with the path to be set.
 * @param pFile file to be set
 */
public DatabaseConfiguration(@Nonnull final File pFile){
  mBinaryVersion=BINARY;
  mFile=pFile.getAbsoluteFile();
}","/** 
 * Constructor with the path to be set.
 * @param pFile file to be set
 */
public DatabaseConfiguration(final @Nonnull File pFile){
  mBinaryVersion=BINARY;
  mFile=pFile.getAbsoluteFile();
}"
48264,"@Override public boolean equals(@Nullable final Object pObj){
  if (pObj instanceof DatabaseConfiguration) {
    final DatabaseConfiguration other=(DatabaseConfiguration)pObj;
    return Objects.equal(mFile,other.mFile) && Objects.equal(mBinaryVersion,other.mBinaryVersion);
  }
  return false;
}","@Override public boolean equals(final @Nullable Object pObj){
  if (pObj instanceof DatabaseConfiguration) {
    final DatabaseConfiguration other=(DatabaseConfiguration)pObj;
    return Objects.equal(mFile,other.mFile) && Objects.equal(mBinaryVersion,other.mBinaryVersion);
  }
  return false;
}"
48265,"/** 
 * Test concurrent.
 * @throws TTXPathException
 */
@Bench @Test public final void testPartConcurrentDescAxis1(){
  final int resultNumber=55;
  try {
    final INodeReadTrx firstConcurrRtx=holder.getSession().beginNodeReadTrx();
    final IAxis axis=new NestedAxis(new NestedAxis(new ConcurrentAxis(firstConcurrRtx,new FilterAxis(new DescendantAxis(holder.getRtx(),EIncludeSelf.YES),new NameFilter(holder.getRtx(),""String_Node_Str""))),new FilterAxis(new ChildAxis(holder.getRtx()),new NameFilter(holder.getRtx(),""String_Node_Str""))),new FilterAxis(new DescendantAxis(holder.getRtx(),EIncludeSelf.YES),new NameFilter(holder.getRtx(),""String_Node_Str"")));
    for (int i=0; i < resultNumber; i++) {
      assertEquals(true,axis.hasNext());
      axis.next();
    }
    assertEquals(false,axis.hasNext());
  }
 catch (  final AbsTTException e) {
    fail();
  }
}","/** 
 * Test concurrent.
 * @throws TTXPathException
 */
@Bench @Test public final void testPartConcurrentDescAxis1(){
  final int resultNumber=55;
  try {
    final INodeReadTrx firstConcurrRtx=holder.getSession().beginNodeReadTrx();
    final IAxis axis=new NestedAxis(new NestedAxis(new ConcurrentAxis(firstConcurrRtx,new FilterAxis(new DescendantAxis(holder.getRtx(),EIncludeSelf.YES),new NameFilter(holder.getRtx(),""String_Node_Str""))),new FilterAxis(new ChildAxis(firstConcurrRtx),new NameFilter(firstConcurrRtx,""String_Node_Str""))),new FilterAxis(new DescendantAxis(firstConcurrRtx,EIncludeSelf.YES),new NameFilter(firstConcurrRtx,""String_Node_Str"")));
    for (int i=0; i < resultNumber; i++) {
      assertEquals(true,axis.hasNext());
      axis.next();
    }
    assertEquals(false,axis.hasNext());
  }
 catch (  final AbsTTException e) {
    fail();
  }
}"
48266,"/** 
 * Test concurrent.
 * @throws TTXPathException
 */
@Bench @Test public final void testPartConcurrentDescAxis2(){
  final int resultNumber=55;
  try {
    final INodeReadTrx firstConcurrRtx=holder.getSession().beginNodeReadTrx();
    final IAxis axis=new NestedAxis(new NestedAxis(new FilterAxis(new DescendantAxis(holder.getRtx(),EIncludeSelf.YES),new NameFilter(holder.getRtx(),""String_Node_Str"")),new FilterAxis(new ChildAxis(holder.getRtx()),new NameFilter(holder.getRtx(),""String_Node_Str""))),new ConcurrentAxis(firstConcurrRtx,new FilterAxis(new DescendantAxis(holder.getRtx(),EIncludeSelf.YES),new NameFilter(holder.getRtx(),""String_Node_Str""))));
    for (int i=0; i < resultNumber; i++) {
      assertEquals(true,axis.hasNext());
      axis.next();
    }
    assertEquals(axis.hasNext(),false);
  }
 catch (  final AbsTTException e) {
    fail();
  }
}","/** 
 * Test concurrent.
 * @throws TTXPathException
 */
@Bench @Test public final void testPartConcurrentDescAxis2(){
  final int resultNumber=55;
  try {
    final INodeReadTrx firstConcurrRtx=holder.getSession().beginNodeReadTrx();
    final IAxis axis=new NestedAxis(new NestedAxis(new FilterAxis(new DescendantAxis(firstConcurrRtx,EIncludeSelf.YES),new NameFilter(firstConcurrRtx,""String_Node_Str"")),new FilterAxis(new ChildAxis(firstConcurrRtx),new NameFilter(firstConcurrRtx,""String_Node_Str""))),new ConcurrentAxis(firstConcurrRtx,new FilterAxis(new DescendantAxis(holder.getRtx(),EIncludeSelf.YES),new NameFilter(holder.getRtx(),""String_Node_Str""))));
    for (int i=0; i < resultNumber; i++) {
      assertEquals(true,axis.hasNext());
      axis.next();
    }
    assertEquals(axis.hasNext(),false);
  }
 catch (  final AbsTTException e) {
    fail();
  }
}"
48267,"public String getMgtIpAddress(){
  try {
    return ipConfigs.get(NetTrafficType.MGT_NETWORK).get(0).getIpAddress();
  }
 catch (  Exception e) {
    return null;
  }
}","public String getMgtIpAddress(){
  try {
    return ipConfigs.get(NetTrafficType.MGT_NETWORK).get(0).getIpAddress();
  }
 catch (  Exception e) {
    logger.warn(""String_Node_Str"" + name + ""String_Node_Str""+ e.getMessage());
    return null;
  }
}"
48268,"public String getHostname(){
  return hostname;
}","public String getHostname(){
  if (hostname == null || hostname.isEmpty() || ""String_Node_Str"".equalsIgnoreCase(hostname) || ""String_Node_Str"".equalsIgnoreCase(hostname)) {
    return getMgtFqdn();
  }
 else {
    return hostname;
  }
}"
48269,"public AmClusterDef(ClusterBlueprint blueprint,String privateKey,String ambariServerVersion){
  this.name=blueprint.getName();
  this.version=blueprint.getHadoopStack().getFullVersion();
  this.verbose=true;
  this.sshKey=privateKey;
  this.user=Constants.AMBARI_SSH_USER;
  this.currentReport=new ClusterReport(blueprint);
  this.ambariServerVersion=ambariServerVersion;
  this.rackTopology=blueprint.getRackTopology();
  HdfsVersion hdfs=getDefaultHdfsVersion(this.version);
  if (blueprint.hasTopologyPolicy() && !AmUtils.isAmbariServerGreaterOrEquals_2_1_0(ambariServerVersion)) {
    setRackTopologyFileName(blueprint);
  }
  setAdditionalConfigurations(blueprint,ambariServerVersion);
  this.configurations=AmUtils.toAmConfigurations(blueprint.getConfiguration());
  this.nodeGroups=new ArrayList<AmNodeGroupDef>();
  for (  NodeGroupInfo group : blueprint.getNodeGroups()) {
    AmNodeGroupDef nodeGroupDef=new AmNodeGroupDef();
    nodeGroupDef.setName(group.getName());
    nodeGroupDef.setInstanceNum(group.getInstanceNum());
    nodeGroupDef.setRoles(group.getRoles());
    nodeGroupDef.setConfigurations(AmUtils.toAmConfigurations(group.getConfiguration()));
    nodeGroupDef.setClusterName(this.name);
    nodeGroupDef.setAmbariServerVersion(ambariServerVersion);
    List<AmNodeDef> nodes=new ArrayList<AmNodeDef>();
    for (    NodeInfo node : group.getNodes()) {
      AmNodeDef nodeDef=new AmNodeDef();
      nodeDef.setName(node.getName());
      nodeDef.setIp(node.getMgtIpAddress());
      nodeDef.setFqdn(node.getHostname());
      nodeDef.setRackInfo(node.getRack());
      nodeDef.setConfigurations(AmUtils.toAmConfigurations(group.getConfiguration()));
      nodeDef.setComponents(group.getRoles());
      nodeDef.setVolumes(node.getVolumes());
      nodeDef.setDirsConfig(hdfs,ambariServerVersion);
      nodes.add(nodeDef);
    }
    nodeGroupDef.setNodes(nodes);
    this.nodeGroups.add(nodeGroupDef);
  }
  if (blueprint.getExternalNamenode() != null) {
    this.isComputeOnly=true;
    this.externalNamenode=blueprint.getExternalNamenode();
    this.externalSecondaryNamenode=blueprint.getExternalSecondaryNamenode();
    String externalNameNodeGroupName=""String_Node_Str"";
    AmNodeDef namenodeDef=new AmNodeDef();
    namenodeDef.setName(name + ""String_Node_Str"" + externalNameNodeGroupName+ ""String_Node_Str"");
    namenodeDef.setFqdn(externalNamenode);
    List<String> namenodeRoles=new ArrayList<String>();
    namenodeRoles.add(""String_Node_Str"");
    if (!isValidExternalSecondaryNamenode()) {
      namenodeRoles.add(""String_Node_Str"");
    }
    namenodeDef.setComponents(namenodeRoles);
    namenodeDef.setVolumes(new ArrayList<String>());
    namenodeDef.setConfigurations(AmUtils.toAmConfigurations(null));
    AmNodeGroupDef externalNameNodeGroup=new AmNodeGroupDef();
    externalNameNodeGroup.setName(externalNameNodeGroupName);
    externalNameNodeGroup.setConfigurations(AmUtils.toAmConfigurations(null));
    externalNameNodeGroup.setRoles(namenodeRoles);
    externalNameNodeGroup.setInstanceNum(1);
    externalNameNodeGroup.setAmbariServerVersion(ambariServerVersion);
    List<AmNodeDef> externalNameNodes=new ArrayList<AmNodeDef>();
    externalNameNodes.add(namenodeDef);
    externalNameNodeGroup.setNodes(externalNameNodes);
    this.nodeGroups.add(externalNameNodeGroup);
    if (isValidExternalSecondaryNamenode()) {
      String externalSecondaryNameNodeGroupName=""String_Node_Str"";
      AmNodeDef secondaryNamenodeDef=new AmNodeDef();
      secondaryNamenodeDef.setName(name + ""String_Node_Str"" + externalSecondaryNameNodeGroupName+ ""String_Node_Str"");
      secondaryNamenodeDef.setFqdn(externalSecondaryNamenode);
      List<String> secondaryNamenodeRoles=new ArrayList<String>();
      secondaryNamenodeRoles.add(""String_Node_Str"");
      secondaryNamenodeDef.setComponents(secondaryNamenodeRoles);
      secondaryNamenodeDef.setVolumes(new ArrayList<String>());
      secondaryNamenodeDef.setConfigurations(AmUtils.toAmConfigurations(null));
      AmNodeGroupDef externalSecondaryNameNodeGroup=new AmNodeGroupDef();
      externalSecondaryNameNodeGroup.setName(externalSecondaryNameNodeGroupName);
      externalSecondaryNameNodeGroup.setConfigurations(AmUtils.toAmConfigurations(null));
      externalSecondaryNameNodeGroup.setRoles(secondaryNamenodeRoles);
      externalSecondaryNameNodeGroup.setInstanceNum(1);
      List<AmNodeDef> externalSecondaryNameNodes=new ArrayList<AmNodeDef>();
      externalSecondaryNameNodes.add(secondaryNamenodeDef);
      externalSecondaryNameNodeGroup.setNodes(externalSecondaryNameNodes);
      this.nodeGroups.add(externalSecondaryNameNodeGroup);
    }
  }
  AmStackDef stackDef=new AmStackDef();
  stackDef.setName(blueprint.getHadoopStack().getVendor());
  stackDef.setVersion(blueprint.getHadoopStack().getFullVersion());
  this.amStack=stackDef;
}","public AmClusterDef(ClusterBlueprint blueprint,String privateKey,String ambariServerVersion){
  this.name=blueprint.getName();
  this.version=blueprint.getHadoopStack().getFullVersion();
  this.verbose=true;
  this.sshKey=privateKey;
  this.user=Constants.AMBARI_SSH_USER;
  this.currentReport=new ClusterReport(blueprint);
  this.ambariServerVersion=ambariServerVersion;
  this.rackTopology=blueprint.getRackTopology();
  HdfsVersion hdfs=getDefaultHdfsVersion(this.version);
  if (blueprint.hasTopologyPolicy() && !AmUtils.isAmbariServerGreaterOrEquals_2_1_0(ambariServerVersion)) {
    setRackTopologyFileName(blueprint);
  }
  setAdditionalConfigurations(blueprint,ambariServerVersion);
  this.configurations=AmUtils.toAmConfigurations(blueprint.getConfiguration());
  this.nodeGroups=new ArrayList<AmNodeGroupDef>();
  for (  NodeGroupInfo group : blueprint.getNodeGroups()) {
    AmNodeGroupDef nodeGroupDef=new AmNodeGroupDef();
    nodeGroupDef.setName(group.getName());
    nodeGroupDef.setInstanceNum(group.getInstanceNum());
    nodeGroupDef.setRoles(group.getRoles());
    nodeGroupDef.setConfigurations(AmUtils.toAmConfigurations(group.getConfiguration()));
    nodeGroupDef.setClusterName(this.name);
    nodeGroupDef.setAmbariServerVersion(ambariServerVersion);
    List<AmNodeDef> nodes=new ArrayList<AmNodeDef>();
    for (    NodeInfo node : group.getNodes()) {
      AmNodeDef nodeDef=new AmNodeDef();
      nodeDef.setName(node.getName());
      nodeDef.setIp(node.getMgtIpAddress());
      nodeDef.setFqdn(node.getMgtFqdn());
      nodeDef.setRackInfo(node.getRack());
      nodeDef.setConfigurations(AmUtils.toAmConfigurations(group.getConfiguration()));
      nodeDef.setComponents(group.getRoles());
      nodeDef.setVolumes(node.getVolumes());
      nodeDef.setDirsConfig(hdfs,ambariServerVersion);
      nodes.add(nodeDef);
    }
    nodeGroupDef.setNodes(nodes);
    this.nodeGroups.add(nodeGroupDef);
  }
  if (blueprint.getExternalNamenode() != null) {
    this.isComputeOnly=true;
    this.externalNamenode=blueprint.getExternalNamenode();
    this.externalSecondaryNamenode=blueprint.getExternalSecondaryNamenode();
    String externalNameNodeGroupName=""String_Node_Str"";
    AmNodeDef namenodeDef=new AmNodeDef();
    namenodeDef.setName(name + ""String_Node_Str"" + externalNameNodeGroupName+ ""String_Node_Str"");
    namenodeDef.setFqdn(externalNamenode);
    List<String> namenodeRoles=new ArrayList<String>();
    namenodeRoles.add(""String_Node_Str"");
    if (!isValidExternalSecondaryNamenode()) {
      namenodeRoles.add(""String_Node_Str"");
    }
    namenodeDef.setComponents(namenodeRoles);
    namenodeDef.setVolumes(new ArrayList<String>());
    namenodeDef.setConfigurations(AmUtils.toAmConfigurations(null));
    AmNodeGroupDef externalNameNodeGroup=new AmNodeGroupDef();
    externalNameNodeGroup.setName(externalNameNodeGroupName);
    externalNameNodeGroup.setConfigurations(AmUtils.toAmConfigurations(null));
    externalNameNodeGroup.setRoles(namenodeRoles);
    externalNameNodeGroup.setInstanceNum(1);
    externalNameNodeGroup.setAmbariServerVersion(ambariServerVersion);
    List<AmNodeDef> externalNameNodes=new ArrayList<AmNodeDef>();
    externalNameNodes.add(namenodeDef);
    externalNameNodeGroup.setNodes(externalNameNodes);
    this.nodeGroups.add(externalNameNodeGroup);
    if (isValidExternalSecondaryNamenode()) {
      String externalSecondaryNameNodeGroupName=""String_Node_Str"";
      AmNodeDef secondaryNamenodeDef=new AmNodeDef();
      secondaryNamenodeDef.setName(name + ""String_Node_Str"" + externalSecondaryNameNodeGroupName+ ""String_Node_Str"");
      secondaryNamenodeDef.setFqdn(externalSecondaryNamenode);
      List<String> secondaryNamenodeRoles=new ArrayList<String>();
      secondaryNamenodeRoles.add(""String_Node_Str"");
      secondaryNamenodeDef.setComponents(secondaryNamenodeRoles);
      secondaryNamenodeDef.setVolumes(new ArrayList<String>());
      secondaryNamenodeDef.setConfigurations(AmUtils.toAmConfigurations(null));
      AmNodeGroupDef externalSecondaryNameNodeGroup=new AmNodeGroupDef();
      externalSecondaryNameNodeGroup.setName(externalSecondaryNameNodeGroupName);
      externalSecondaryNameNodeGroup.setConfigurations(AmUtils.toAmConfigurations(null));
      externalSecondaryNameNodeGroup.setRoles(secondaryNamenodeRoles);
      externalSecondaryNameNodeGroup.setInstanceNum(1);
      List<AmNodeDef> externalSecondaryNameNodes=new ArrayList<AmNodeDef>();
      externalSecondaryNameNodes.add(secondaryNamenodeDef);
      externalSecondaryNameNodeGroup.setNodes(externalSecondaryNameNodes);
      this.nodeGroups.add(externalSecondaryNameNodeGroup);
    }
  }
  AmStackDef stackDef=new AmStackDef();
  stackDef.setName(blueprint.getHadoopStack().getVendor());
  stackDef.setVersion(blueprint.getHadoopStack().getFullVersion());
  this.amStack=stackDef;
}"
48270,"private List<String> getFqdnsWithRole(ClusterBlueprint blueprint,String role){
  List<String> fqdns=new ArrayList<String>();
  for (  NodeGroupInfo group : blueprint.getNodeGroups()) {
    if (group.getRoles().contains(role)) {
      for (      NodeInfo node : group.getNodes()) {
        fqdns.add(node.getHostname());
      }
    }
  }
  return fqdns;
}","private List<String> getFqdnsWithRole(ClusterBlueprint blueprint,String role){
  List<String> fqdns=new ArrayList<String>();
  for (  NodeGroupInfo group : blueprint.getNodeGroups()) {
    if (group.getRoles().contains(role)) {
      for (      NodeInfo node : group.getNodes()) {
        fqdns.add(node.getMgtFqdn());
      }
    }
  }
  return fqdns;
}"
48271,"public String getConfigurations(String appMgrName,String distroName){
  final String path=Constants.REST_PATH_APPMANAGER + ""String_Node_Str"" + appMgrName+ ""String_Node_Str""+ Constants.REST_PATH_DISTRO+ ""String_Node_Str""+ distroName+ ""String_Node_Str""+ Constants.REST_PATH_CONFIGURATIONS;
  final HttpMethod httpverb=HttpMethod.GET;
  return restClient.getAllObjects(String.class,path,httpverb,false);
}","public String getConfigurations(String appMgrName,String distroName){
  final String path=Constants.REST_PATH_APPMANAGER + ""String_Node_Str"" + appMgrName+ ""String_Node_Str""+ Constants.REST_PATH_DISTRO+ ""String_Node_Str""+ distroName+ ""String_Node_Str""+ Constants.REST_PATH_CONFIGURATIONS;
  return restClient.getContentAsString(Constants.HTTPS_CONNECTION_API + path);
}"
48272,"/** 
 * Disconnect the session
 */
public void disconnect(){
  try {
    checkConnection();
    logout(Constants.REST_PATH_LOGOUT,String.class);
  }
 catch (  CliRestException cliRestException) {
    if (cliRestException.getStatus() == HttpStatus.UNAUTHORIZED) {
      writeCookieInfo(""String_Node_Str"");
    }
  }
catch (  Exception e) {
    System.out.println(Constants.DISCONNECT_FAILURE + ""String_Node_Str"" + CommandsUtils.getExceptionMessage(e));
  }
}","/** 
 * Disconnect the session
 */
public void disconnect(){
  try {
    checkConnection();
    getContentAsString(Constants.REST_PATH_LOGOUT);
  }
 catch (  CliRestException cliRestException) {
    if (cliRestException.getStatus() == HttpStatus.UNAUTHORIZED) {
      writeCookieInfo(""String_Node_Str"");
    }
  }
catch (  Exception e) {
    System.out.println(Constants.DISCONNECT_FAILURE + ""String_Node_Str"" + CommandsUtils.getExceptionMessage(e));
  }
}"
48273,"public void handleError(ClientHttpResponse response) throws IOException {
  MediaType contentType=response.getHeaders().getContentType();
  String body=getResponseContent(response.getBody());
  if (MediaType.APPLICATION_JSON.includes(contentType)) {
    ObjectMapper objectMapper=new ObjectMapper();
    BddErrorMessage errorMessage=objectMapper.readValue(body,BddErrorMessage.class);
    if (errorMessage.getErrors() != null) {
      throw new ValidationException(errorMessage.getErrors());
    }
    if (errorMessage.getCertInfo() != null) {
      throw new UntrustedCertificateException(errorMessage.getCertInfo());
    }
    if (errorMessage.isWarning()) {
      throw new WarningMessageException(errorMessage.getMessage());
    }
    throw new CliRestException(errorMessage.getMessage());
  }
 else {
    HttpStatus statusCode=response.getStatusCode();
    String errorMsg=""String_Node_Str"";
    if (statusCode == HttpStatus.UNAUTHORIZED) {
      errorMsg=Constants.CONNECT_SESSION_TIME_OUT;
    }
 else     if (statusCode == HttpStatus.INTERNAL_SERVER_ERROR) {
      errorMsg=""String_Node_Str"" + getVCConnectErrorMsg(body);
    }
 else     if (statusCode == HttpStatus.METHOD_NOT_ALLOWED) {
      errorMsg=body;
      if (errorMsg.isEmpty()) {
        errorMsg=statusCode.getReasonPhrase();
      }
    }
 else {
      errorMsg=statusCode.getReasonPhrase();
    }
    throw new CliRestException(statusCode,errorMsg);
  }
}","public void handleError(ClientHttpResponse response) throws IOException {
  MediaType contentType=response.getHeaders().getContentType();
  String body=getResponseContent(response.getBody());
  if (MediaType.APPLICATION_JSON.includes(contentType)) {
    ObjectMapper objectMapper=new ObjectMapper();
    BddErrorMessage errorMessage=objectMapper.readValue(body,BddErrorMessage.class);
    if (errorMessage.getErrors() != null) {
      throw new ValidationException(errorMessage.getErrors());
    }
    if (errorMessage.getCertInfo() != null) {
      throw new UntrustedCertificateException(errorMessage.getCertInfo());
    }
    if (errorMessage.isWarning()) {
      throw new WarningMessageException(errorMessage.getMessage());
    }
    throw new CliRestException(errorMessage.getMessage());
  }
 else {
    HttpStatus statusCode=response.getStatusCode();
    handleHttpErrCode(statusCode,body);
  }
}"
48274,"private String getVCConnectErrorMsg(String content){
  return findErrorMsg(content,""String_Node_Str"");
}","private static String getVCConnectErrorMsg(String content){
  return findErrorMsg(content,""String_Node_Str"");
}"
48275,"@Override @Transactional public synchronized void refreshNodeTemplates(){
  long curTime=System.currentTimeMillis() / 1000;
  if (curTime - this.lastRefreshTimestamp < getRefreshNodeTemplateInterval()) {
    return;
  }
  logger.info(""String_Node_Str"");
  List<VcVirtualMachine> vms=VcResourceUtils.findAllNodeTemplates();
  HashSet<String> moids=new HashSet<String>();
  for (  VcVirtualMachine vm : vms) {
    String moid=vm.getId();
    moids.add(moid);
    long timestamp=System.currentTimeMillis();
    NodeTemplateEntity entity=nodeTemplateDAO.findByMoid(moid);
    if (entity == null) {
      entity=new NodeTemplateEntity();
      convertVirtualMachineToEntity(vm,entity,timestamp);
      nodeTemplateDAO.insert(entity);
    }
 else {
      convertVirtualMachineToEntity(vm,entity,timestamp);
      nodeTemplateDAO.update(entity);
    }
  }
  for (  NodeTemplateEntity entity : nodeTemplateDAO.findAll()) {
    if (!moids.contains(entity.getMoid())) {
      nodeTemplateDAO.delete(entity);
    }
  }
  logger.info(""String_Node_Str"");
  this.lastRefreshTimestamp=System.currentTimeMillis() / 1000;
}","@Override @Transactional public synchronized void refreshNodeTemplates(){
  long curTime=System.currentTimeMillis() / 1000;
  if (curTime - this.lastRefreshTimestamp < getRefreshNodeTemplateInterval()) {
    return;
  }
  logger.info(""String_Node_Str"");
  List<VcVirtualMachine> vms=VcResourceUtils.findAllNodeTemplates();
  HashSet<String> moids=new HashSet<String>();
  HashMap<String,String> nameToMoid=new HashMap<String,String>();
  for (  VcVirtualMachine vm : vms) {
    String moid=vm.getId();
    moids.add(moid);
    nameToMoid.put(vm.getName(),moid);
    long timestamp=System.currentTimeMillis();
    NodeTemplateEntity entity=nodeTemplateDAO.findByMoid(moid);
    if (entity == null) {
      entity=new NodeTemplateEntity();
      convertVirtualMachineToEntity(vm,entity,timestamp);
      nodeTemplateDAO.insert(entity);
    }
 else {
      convertVirtualMachineToEntity(vm,entity,timestamp);
      nodeTemplateDAO.update(entity);
    }
  }
  for (  NodeTemplateEntity entity : nodeTemplateDAO.findAll()) {
    if (!moids.contains(entity.getMoid())) {
      if (ConfigInfo.isJustRestored()) {
        logger.info(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
        String oldMoid=entity.getMoid();
        String newMoid=nameToMoid.get(entity.getName());
        if (null != newMoid) {
          templateMoidMap.put(oldMoid,newMoid);
        }
      }
      nodeTemplateDAO.delete(entity);
    }
  }
  logger.info(""String_Node_Str"");
  this.lastRefreshTimestamp=System.currentTimeMillis() / 1000;
}"
48276,"private Map<String,List<ApiRole>> configureNodeServices(final CmClusterDef cluster,final ClusterReportQueue reportQueue,final List<String> addedNodeNames) throws SoftwareManagementPluginException {
  Map<String,String> nodeRefToName=cluster.hostIdToName();
  Map<String,List<CmRoleDef>> serviceRolesMap=new HashMap<String,List<CmRoleDef>>();
  Set<String> addedNodeNameSet=new HashSet<String>();
  addedNodeNameSet.addAll(addedNodeNames);
  for (  CmServiceDef serviceDef : cluster.getServices()) {
    List<CmRoleDef> roles=serviceDef.getRoles();
    for (    CmRoleDef role : roles) {
      String nodeId=role.getNodeRef();
      String nodeName=nodeRefToName.get(nodeId);
      if (addedNodeNameSet.contains(nodeName)) {
        List<CmRoleDef> roleDefs=serviceRolesMap.get(serviceDef.getName());
        if (roleDefs == null) {
          roleDefs=new ArrayList<CmRoleDef>();
          serviceRolesMap.put(serviceDef.getName(),roleDefs);
        }
        roleDefs.add(role);
      }
    }
  }
  Map<String,List<ApiRole>> result=new HashMap<>();
  try {
    ApiServiceList apiServiceList=apiResourceRootV6.getClustersResource().getServicesResource(cluster.getName()).readServices(DataView.SUMMARY);
    for (    ApiService apiService : apiServiceList.getServices()) {
      if (!serviceRolesMap.containsKey(apiService.getName())) {
        continue;
      }
      result.put(apiService.getName(),new ArrayList<ApiRole>());
      List<CmRoleDef> roleDefs=serviceRolesMap.get(apiService.getName());
      List<ApiRole> apiRoles=apiResourceRootV6.getClustersResource().getServicesResource(cluster.getName()).getRolesResource(apiService.getName()).readRoles().getRoles();
      logger.debug(""String_Node_Str"" + apiRoles);
      for (      ApiRole apiRole : apiRoles) {
        for (Iterator<CmRoleDef> ite=roleDefs.iterator(); ite.hasNext(); ) {
          CmRoleDef roleDef=ite.next();
          if (apiRole.getHostRef().getHostId().equals(roleDef.getNodeRef())) {
            ite.remove();
            result.get(apiService.getName()).add(apiRole);
            break;
          }
        }
      }
      if (!roleDefs.isEmpty()) {
        List<ApiRole> newRoles=new ArrayList<>();
        for (        CmRoleDef roleDef : roleDefs) {
          ApiRole apiRole=createApiRole(roleDef);
          newRoles.add(apiRole);
        }
        String action=""String_Node_Str"" + apiService.getDisplayName();
        cluster.getCurrentReport().setNodesAction(action,addedNodeNames);
        reportQueue.addClusterReport(cluster.getCurrentReport().clone());
        logger.debug(""String_Node_Str"" + newRoles);
        ApiRoleList roleList=apiResourceRootV6.getClustersResource().getServicesResource(cluster.getName()).getRolesResource(apiService.getName()).createRoles(new ApiRoleList(newRoles));
        result.get(apiService.getName()).addAll(roleList.getRoles());
      }
    }
    logger.info(""String_Node_Str"");
    syncRolesId(cluster);
    preDeployConfig(cluster);
    for (    String serviceName : result.keySet()) {
      final ApiRoleNameList roleNameList=new ApiRoleNameList();
      final String sName=serviceName;
      List<String> roleNames=new ArrayList<>();
      for (      ApiRole apiRole : result.get(serviceName)) {
        roleNames.add(apiRole.getName());
      }
      roleNameList.setRoleNames(roleNames);
      retry(5,new Retriable(){
        @Override public void doWork() throws Exception {
          executeAndReport(""String_Node_Str"",addedNodeNames,apiResourceRootV6.getClustersResource().getServicesResource(cluster.getName()).deployClientConfigCommand(sName,roleNameList),ProgressSplit.CONFIGURE_SERVICES.getProgress(),cluster.getCurrentReport(),reportQueue,true);
        }
      }
);
    }
    return result;
  }
 catch (  Exception e) {
    String errMsg=""String_Node_Str"" + ((e.getMessage() == null) ? ""String_Node_Str"" : (""String_Node_Str"" + e.getMessage()));
    logger.error(errMsg);
    throw SoftwareManagementPluginException.CONFIGURE_SERVICE_FAILED(e);
  }
}","private Map<String,List<ApiRole>> configureNodeServices(final CmClusterDef cluster,final ClusterReportQueue reportQueue,final List<String> addedNodeNames) throws SoftwareManagementPluginException {
  Map<String,String> nodeRefToName=cluster.hostIdToName();
  Map<String,List<CmRoleDef>> serviceRolesMap=new HashMap<String,List<CmRoleDef>>();
  Set<String> addedNodeNameSet=new HashSet<String>();
  addedNodeNameSet.addAll(addedNodeNames);
  for (  CmServiceDef serviceDef : cluster.getServices()) {
    List<CmRoleDef> roles=serviceDef.getRoles();
    for (    CmRoleDef role : roles) {
      String nodeId=role.getNodeRef();
      String nodeName=nodeRefToName.get(nodeId);
      if (addedNodeNameSet.contains(nodeName)) {
        List<CmRoleDef> roleDefs=serviceRolesMap.get(serviceDef.getName());
        if (roleDefs == null) {
          roleDefs=new ArrayList<CmRoleDef>();
          serviceRolesMap.put(serviceDef.getName(),roleDefs);
        }
        roleDefs.add(role);
      }
    }
  }
  Map<String,List<ApiRole>> result=new HashMap<>();
  try {
    ApiServiceList apiServiceList=apiResourceRootV6.getClustersResource().getServicesResource(cluster.getName()).readServices(DataView.SUMMARY);
    for (    ApiService apiService : apiServiceList.getServices()) {
      if (!serviceRolesMap.containsKey(apiService.getName())) {
        continue;
      }
      result.put(apiService.getName(),new ArrayList<ApiRole>());
      List<CmRoleDef> roleDefs=serviceRolesMap.get(apiService.getName());
      List<ApiRole> apiRoles=apiResourceRootV6.getClustersResource().getServicesResource(cluster.getName()).getRolesResource(apiService.getName()).readRoles().getRoles();
      logger.debug(""String_Node_Str"" + apiRoles);
      for (      ApiRole apiRole : apiRoles) {
        for (Iterator<CmRoleDef> ite=roleDefs.iterator(); ite.hasNext(); ) {
          CmRoleDef roleDef=ite.next();
          if (apiRole.getHostRef().getHostId().equals(roleDef.getNodeRef())) {
            ite.remove();
            result.get(apiService.getName()).add(apiRole);
            break;
          }
        }
      }
      if (!roleDefs.isEmpty()) {
        List<ApiRole> newRoles=new ArrayList<>();
        for (        CmRoleDef roleDef : roleDefs) {
          ApiRole apiRole=createApiRole(roleDef);
          newRoles.add(apiRole);
        }
        String action=""String_Node_Str"" + apiService.getDisplayName();
        cluster.getCurrentReport().setNodesAction(action,addedNodeNames);
        reportQueue.addClusterReport(cluster.getCurrentReport().clone());
        logger.debug(""String_Node_Str"" + newRoles);
        ApiRoleList roleList=apiResourceRootV6.getClustersResource().getServicesResource(cluster.getName()).getRolesResource(apiService.getName()).createRoles(new ApiRoleList(newRoles));
        result.get(apiService.getName()).addAll(roleList.getRoles());
      }
    }
    logger.info(""String_Node_Str"");
    syncRolesId(cluster);
    preDeployConfig(cluster);
    for (    String serviceName : result.keySet()) {
      final ApiRoleNameList roleNameList=new ApiRoleNameList();
      final String sName=serviceName;
      List<String> roleNames=new ArrayList<>();
      for (      ApiRole apiRole : result.get(serviceName)) {
        roleNames.add(apiRole.getName());
      }
      roleNameList.setRoleNames(roleNames);
      int sleepTime=Configuration.getInt(""String_Node_Str"",60);
      retry(10,sleepTime,new Retriable(){
        @Override public void doWork() throws Exception {
          executeAndReport(""String_Node_Str"",addedNodeNames,apiResourceRootV6.getClustersResource().getServicesResource(cluster.getName()).deployClientConfigCommand(sName,roleNameList),ProgressSplit.CONFIGURE_SERVICES.getProgress(),cluster.getCurrentReport(),reportQueue,true);
        }
      }
);
    }
    return result;
  }
 catch (  Exception e) {
    String errMsg=""String_Node_Str"" + ((e.getMessage() == null) ? ""String_Node_Str"" : (""String_Node_Str"" + e.getMessage()));
    logger.error(errMsg);
    throw SoftwareManagementPluginException.CONFIGURE_SERVICE_FAILED(e);
  }
}"
48277,"private void retry(int retryTimes,Retriable operate) throws Exception {
  int i=0;
  while (true) {
    i+=1;
    try {
      operate.doWork();
      return;
    }
 catch (    Exception e) {
      if (i == retryTimes) {
        logger.info(""String_Node_Str"" + retryTimes + ""String_Node_Str"");
        throw e;
      }
 else {
        logger.info(""String_Node_Str"" + i + ""String_Node_Str""+ e.getMessage()+ ""String_Node_Str""+ (retryTimes - i)+ ""String_Node_Str"");
      }
    }
  }
}","private void retry(int retryTimes,int sleepTime,Retriable operate) throws Exception {
  int i=0;
  while (true) {
    i+=1;
    Thread.sleep(sleepTime * 1000);
    try {
      operate.doWork();
      return;
    }
 catch (    Exception e) {
      if (i == retryTimes) {
        logger.info(""String_Node_Str"" + retryTimes + ""String_Node_Str"");
        throw e;
      }
 else {
        logger.info(""String_Node_Str"" + i + ""String_Node_Str""+ e.getMessage()+ ""String_Node_Str""+ (retryTimes - i)+ ""String_Node_Str"");
      }
    }
  }
}"
48278,"@Override public List<BaseNode> getPlacementPlan(ClusterCreate clusterSpec,List<BaseNode> existedNodes){
  logger.info(""String_Node_Str"");
  logger.info(""String_Node_Str"");
  Container container=new Container();
  List<VcCluster> clusters=resMgr.getAvailableClusters();
  AuAssert.check(clusters != null && clusters.size() != 0);
  for (  VcCluster cl : clusters) {
    container.addResource(cl);
  }
  logger.info(""String_Node_Str"" + ContainerToStringHelper.convertToString(container));
  logger.info(""String_Node_Str"");
  int maxTimeDiffInSec=Constants.MAX_TIME_DIFF_IN_SEC;
  SoftwareManager softMgr=softwareManagerCollector.getSoftwareManager(clusterSpec.getAppManager());
  if (softMgr.hasHbase(clusterSpec.toBlueprint()))   maxTimeDiffInSec=Constants.MAX_TIME_DIFF_IN_SEC_HBASE;
  List<String> outOfSyncHosts=new ArrayList<String>();
  for (  AbstractHost host : container.getAllHosts()) {
    int hostTimeDiffInSec=VcResourceUtils.getHostTimeDiffInSec(host.getName());
    if (Math.abs(hostTimeDiffInSec) > maxTimeDiffInSec) {
      logger.info(""String_Node_Str"" + host.getName() + ""String_Node_Str""+ hostTimeDiffInSec+ ""String_Node_Str"");
      outOfSyncHosts.add(host.getName());
    }
  }
  for (  String host : outOfSyncHosts) {
    container.removeHost(host);
  }
  logger.info(""String_Node_Str"");
  List<com.vmware.bdd.spectypes.VcCluster> usedClusters=clusterSpec.getVcClusters();
  List<String> noNetworkHosts=new ArrayList<String>();
  noNetworkHosts=resMgr.filterHostsByNetwork(clusterSpec.getNetworkNames(),usedClusters);
  for (  String host : noNetworkHosts) {
    container.removeHost(host);
  }
  Map<String,List<String>> filteredHosts=new HashMap<String,List<String>>();
  if (!outOfSyncHosts.isEmpty())   filteredHosts.put(PlacementUtil.OUT_OF_SYNC_HOSTS,outOfSyncHosts);
  if (!noNetworkHosts.isEmpty()) {
    filteredHosts.put(PlacementUtil.NO_NETWORKS_HOSTS,noNetworkHosts);
    filteredHosts.put(PlacementUtil.NETWORK_NAMES,clusterSpec.getNetworkNames());
  }
  VcVirtualMachine templateVm=getTemplateVM(clusterSpec.getTemplateName());
  container.setTemplateNode(createBaseNodeFromTemplateVm(templateVm));
  if (clusterSpec.getHostToRackMap() != null && clusterSpec.getHostToRackMap().size() != 0) {
    container.addRackMap(clusterSpec.getHostToRackMap());
  }
  logger.info(""String_Node_Str"");
  Set<String> validRacks=new HashSet<String>();
  List<AbstractHost> hosts=container.getAllHosts();
  for (  AbstractHost host : hosts) {
    if (container.getRack(host) != null) {
      validRacks.add(container.getRack(host));
    }
  }
  for (  NodeGroupCreate nodeGroup : clusterSpec.getNodeGroups()) {
    if (nodeGroup.getPlacementPolicies() != null && nodeGroup.getPlacementPolicies().getGroupRacks() != null && validRacks.size() == 0) {
      throw PlacementException.INVALID_RACK_INFO(clusterSpec.getName(),nodeGroup.getName());
    }
  }
  if (null == existedNodes) {
    checkAndUpdateClusterCloneType(clusterSpec,container);
  }
  logger.info(""String_Node_Str"");
  String clusterCloneType=clusterSpec.getClusterCloneType();
  chooseClusterCloneService(clusterCloneType).preCalculatePlacements(container,clusterSpec,existedNodes);
  List<BaseNode> baseNodes=placementService.getPlacementPlan(container,clusterSpec,existedNodes,filteredHosts);
  for (  BaseNode baseNode : baseNodes) {
    baseNode.setNodeAction(Constants.NODE_ACTION_CLONING_VM);
  }
  for (  BaseNode current : baseNodes) {
    Float cpuRatio=current.getNodeGroup().getReservedCpuRatio();
    Float memRatio=current.getNodeGroup().getReservedMemRatio();
    if (cpuRatio != null && cpuRatio > 0 && cpuRatio <= 1) {
      if (current.getTargetHost() != null) {
        VcHost host=VcResourceUtils.findHost(current.getTargetHost());
        long nodeCpuMhz=host.getCpuHz() / (1024 * 1024) * current.getCpu();
        current.getVmSchema().resourceSchema.cpuReservationMHz=(long)Math.ceil(nodeCpuMhz * cpuRatio);
        logger.info(""String_Node_Str"" + current.getVmSchema().resourceSchema.cpuReservationMHz);
      }
    }
    if (memRatio != null && memRatio > 0 && memRatio <= 1) {
      if (current.getVmSchema().resourceSchema.latencySensitivity == LatencyPriority.HIGH)       current.getVmSchema().resourceSchema.memReservationSize=current.getMem();
 else {
        current.getVmSchema().resourceSchema.memReservationSize=(long)Math.ceil(current.getMem() * memRatio);
      }
      logger.info(""String_Node_Str"" + current.getVmSchema().resourceSchema.memReservationSize);
    }
  }
  logger.info(""String_Node_Str"");
  return baseNodes;
}","@Override public List<BaseNode> getPlacementPlan(ClusterCreate clusterSpec,List<BaseNode> existedNodes){
  try {
    Thread.sleep(Configuration.getInt(""String_Node_Str"",10) * 1000);
  }
 catch (  InterruptedException e1) {
    logger.error(""String_Node_Str"",e1);
  }
  List<String> dsNames=vcResourceManager.getDsNamesToBeUsed(clusterSpec.getDsNames());
  if (dsNames.isEmpty()) {
    throw ClusterConfigException.NO_DATASTORE_ADDED();
  }
  VcResourceFilters filters=vcResourceFilterBuilder.build(dsNames,vcResourceManager.getRpNames(clusterSpec.getRpNames()),clusterSpec.getNetworkNames());
  try {
    syncService.refreshInventory(filters);
  }
 catch (  InterruptedException e) {
    logger.error(""String_Node_Str"",e);
  }
  logger.info(""String_Node_Str"");
  logger.info(""String_Node_Str"");
  Container container=new Container();
  List<VcCluster> clusters=resMgr.getAvailableClusters();
  AuAssert.check(clusters != null && clusters.size() != 0);
  for (  VcCluster cl : clusters) {
    container.addResource(cl);
  }
  logger.info(""String_Node_Str"" + ContainerToStringHelper.convertToString(container));
  logger.info(""String_Node_Str"");
  int maxTimeDiffInSec=Constants.MAX_TIME_DIFF_IN_SEC;
  SoftwareManager softMgr=softwareManagerCollector.getSoftwareManager(clusterSpec.getAppManager());
  if (softMgr.hasHbase(clusterSpec.toBlueprint()))   maxTimeDiffInSec=Constants.MAX_TIME_DIFF_IN_SEC_HBASE;
  List<String> outOfSyncHosts=new ArrayList<String>();
  for (  AbstractHost host : container.getAllHosts()) {
    int hostTimeDiffInSec=VcResourceUtils.getHostTimeDiffInSec(host.getName());
    if (Math.abs(hostTimeDiffInSec) > maxTimeDiffInSec) {
      logger.info(""String_Node_Str"" + host.getName() + ""String_Node_Str""+ hostTimeDiffInSec+ ""String_Node_Str"");
      outOfSyncHosts.add(host.getName());
    }
  }
  for (  String host : outOfSyncHosts) {
    container.removeHost(host);
  }
  logger.info(""String_Node_Str"");
  List<com.vmware.bdd.spectypes.VcCluster> usedClusters=clusterSpec.getVcClusters();
  List<String> noNetworkHosts=new ArrayList<String>();
  noNetworkHosts=resMgr.filterHostsByNetwork(clusterSpec.getNetworkNames(),usedClusters);
  for (  String host : noNetworkHosts) {
    container.removeHost(host);
  }
  Map<String,List<String>> filteredHosts=new HashMap<String,List<String>>();
  if (!outOfSyncHosts.isEmpty())   filteredHosts.put(PlacementUtil.OUT_OF_SYNC_HOSTS,outOfSyncHosts);
  if (!noNetworkHosts.isEmpty()) {
    filteredHosts.put(PlacementUtil.NO_NETWORKS_HOSTS,noNetworkHosts);
    filteredHosts.put(PlacementUtil.NETWORK_NAMES,clusterSpec.getNetworkNames());
  }
  VcVirtualMachine templateVm=getTemplateVM(clusterSpec.getTemplateName());
  container.setTemplateNode(createBaseNodeFromTemplateVm(templateVm));
  if (clusterSpec.getHostToRackMap() != null && clusterSpec.getHostToRackMap().size() != 0) {
    container.addRackMap(clusterSpec.getHostToRackMap());
  }
  logger.info(""String_Node_Str"");
  Set<String> validRacks=new HashSet<String>();
  List<AbstractHost> hosts=container.getAllHosts();
  for (  AbstractHost host : hosts) {
    if (container.getRack(host) != null) {
      validRacks.add(container.getRack(host));
    }
  }
  for (  NodeGroupCreate nodeGroup : clusterSpec.getNodeGroups()) {
    if (nodeGroup.getPlacementPolicies() != null && nodeGroup.getPlacementPolicies().getGroupRacks() != null && validRacks.size() == 0) {
      throw PlacementException.INVALID_RACK_INFO(clusterSpec.getName(),nodeGroup.getName());
    }
  }
  if (null == existedNodes) {
    checkAndUpdateClusterCloneType(clusterSpec,container);
  }
  logger.info(""String_Node_Str"");
  String clusterCloneType=clusterSpec.getClusterCloneType();
  chooseClusterCloneService(clusterCloneType).preCalculatePlacements(container,clusterSpec,existedNodes);
  List<BaseNode> baseNodes=placementService.getPlacementPlan(container,clusterSpec,existedNodes,filteredHosts);
  for (  BaseNode baseNode : baseNodes) {
    baseNode.setNodeAction(Constants.NODE_ACTION_CLONING_VM);
  }
  for (  BaseNode current : baseNodes) {
    Float cpuRatio=current.getNodeGroup().getReservedCpuRatio();
    Float memRatio=current.getNodeGroup().getReservedMemRatio();
    if (cpuRatio != null && cpuRatio > 0 && cpuRatio <= 1) {
      if (current.getTargetHost() != null) {
        VcHost host=VcResourceUtils.findHost(current.getTargetHost());
        long nodeCpuMhz=host.getCpuHz() / (1024 * 1024) * current.getCpu();
        current.getVmSchema().resourceSchema.cpuReservationMHz=(long)Math.ceil(nodeCpuMhz * cpuRatio);
        logger.info(""String_Node_Str"" + current.getVmSchema().resourceSchema.cpuReservationMHz);
      }
    }
    if (memRatio != null && memRatio > 0 && memRatio <= 1) {
      if (current.getVmSchema().resourceSchema.latencySensitivity == LatencyPriority.HIGH)       current.getVmSchema().resourceSchema.memReservationSize=current.getMem();
 else {
        current.getVmSchema().resourceSchema.memReservationSize=(long)Math.ceil(current.getMem() * memRatio);
      }
      logger.info(""String_Node_Str"" + current.getVmSchema().resourceSchema.memReservationSize);
    }
  }
  logger.info(""String_Node_Str"");
  return baseNodes;
}"
48279,"/** 
 * @param vcResourceFilters refresh the vc inventory, some resource will be filtered from refreshing.
 */
public void refreshInventory(VcResourceFilters vcResourceFilters) throws InterruptedException {
  if (inProgress.get()) {
    if (LOGGER.isInfoEnabled()) {
      LOGGER.info(""String_Node_Str"");
    }
    waitForCompletion();
    if (LOGGER.isInfoEnabled()) {
      LOGGER.info(""String_Node_Str"");
    }
  }
 else {
    if (inProgress.compareAndSet(false,true)) {
      if (LOGGER.isInfoEnabled()) {
        LOGGER.info(""String_Node_Str"");
      }
      counters.setRefreshInProgress(true);
      counters.increaseInvRefresh();
      try {
        List<VcDatacenter> dcList=VcInventory.getDatacenters();
        refresh(dcList,vcResourceFilters);
      }
  finally {
        counters.setRefreshInProgress(false);
        inProgress.set(false);
        if (LOGGER.isInfoEnabled()) {
          LOGGER.info(""String_Node_Str"");
        }
      }
    }
 else {
      if (LOGGER.isInfoEnabled()) {
        LOGGER.info(""String_Node_Str"");
      }
      waitForCompletion();
      if (LOGGER.isInfoEnabled()) {
        LOGGER.info(""String_Node_Str"");
      }
    }
  }
}","/** 
 * @param vcResourceFilters refresh the vc inventory, some resource will be filtered from refreshing.
 */
public synchronized void refreshInventory(VcResourceFilters vcResourceFilters) throws InterruptedException {
  inProgress.set(true);
  if (LOGGER.isInfoEnabled()) {
    LOGGER.info(""String_Node_Str"");
  }
  counters.setRefreshInProgress(true);
  counters.increaseInvRefresh();
  try {
    List<VcDatacenter> dcList=VcInventory.getDatacenters();
    refresh(dcList,vcResourceFilters);
  }
  finally {
    counters.setRefreshInProgress(false);
    inProgress.set(false);
    if (LOGGER.isInfoEnabled()) {
      LOGGER.info(""String_Node_Str"");
    }
  }
}"
48280,"public UntrustedCertificateException(){
}","public UntrustedCertificateException(CertificateInfo certInfo1){
  super(null,""String_Node_Str"",""String_Node_Str"");
  certInfo=certInfo1;
}"
48281,"@Override public boolean deleteCluster(String name,List<BaseNode> vNodes,StatusUpdater statusUpdator){
  boolean deleted=syncDeleteVMs(vNodes,statusUpdator,true);
  if (vNodes.size() > 0) {
    try {
      deleteChildRps(name,vNodes);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
    }
    try {
      deleteFolders(vNodes.get(0));
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
    }
  }
  return deleted;
}","@Override public boolean deleteCluster(String name,List<BaseNode> vNodes,StatusUpdater statusUpdator){
  if (vNodes == null || vNodes.size() < 1) {
    logger.error(""String_Node_Str"");
    return true;
  }
  Folder folder=findFolder(vNodes.get(0));
  boolean deleted=syncDeleteVMs(vNodes,statusUpdator,true);
  try {
    deleteChildRps(name,vNodes);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  try {
    deleteFolders(folder);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  return deleted;
}"
48282,"/** 
 * this method will delete the cluster root folder, if there is any VM existed and powered on in the folder, the folder deletion will fail.
 * @param node
 * @throws BddException
 */
private void deleteFolders(BaseNode node) throws BddException {
  String path=node.getVmFolder();
  String[] folderNames=path.split(""String_Node_Str"");
  AuAssert.check(folderNames.length == 3);
  VcDatacenter dc=VcResourceUtils.findVM(node.getVmMobId()).getDatacenter();
  List<String> deletedFolders=new ArrayList<String>();
  deletedFolders.add(folderNames[0]);
  deletedFolders.add(folderNames[1]);
  Folder folder=null;
  try {
    folder=VcResourceUtils.findFolderByNameList(dc,deletedFolders);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
  if (folder == null) {
    logger.info(""String_Node_Str"");
    return;
  }
  String clusterFolderName=folderNames[0] + ""String_Node_Str"" + folderNames[1];
  logger.info(""String_Node_Str"" + clusterFolderName);
  List<Folder> folders=new ArrayList<Folder>();
  folders.add(folder);
  DeleteVMFolderSP sp=new DeleteVMFolderSP(folders,true,false);
  Callable<Void>[] storedProcedures=new Callable[1];
  storedProcedures[0]=sp;
  try {
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storedProcedures,callback);
    if (result == null || result.length == 0) {
      logger.error(""String_Node_Str"");
      return;
    }
    if (result[0].finished && result[0].throwable == null) {
      logger.info(""String_Node_Str"" + clusterFolderName + ""String_Node_Str"");
    }
 else {
      logger.info(""String_Node_Str"" + clusterFolderName,result[0].throwable);
    }
  }
 catch (  InterruptedException e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}","/** 
 * this method will delete the cluster root folder, if there is any VM existed and powered on in the folder, the folder deletion will fail.
 * @param folder
 * @throws BddException
 */
private void deleteFolders(Folder folder) throws BddException {
  if (folder == null) {
    logger.info(""String_Node_Str"");
    return;
  }
  List<Folder> folders=new ArrayList<Folder>();
  folders.add(folder);
  DeleteVMFolderSP sp=new DeleteVMFolderSP(folders,true,false);
  Callable<Void>[] storedProcedures=new Callable[1];
  storedProcedures[0]=sp;
  try {
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storedProcedures,callback);
    if (result == null || result.length == 0) {
      logger.error(""String_Node_Str"");
      return;
    }
    if (result[0].finished && result[0].throwable == null) {
      logger.info(""String_Node_Str"" + folder.getName() + ""String_Node_Str"");
    }
 else {
      logger.info(""String_Node_Str"" + folder.getName(),result[0].throwable);
    }
  }
 catch (  InterruptedException e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}"
48283,"@Override @ClusterEntityConcurrentWriteLock @Async(AsyncExecutors.CLUSTER_SYNC_EXEC) public void asyncSyncUp(String clusterName,boolean updateClusterStatus){
  clusterSyncService.syncUp(clusterName,updateClusterStatus);
}","@Override @ClusterEntityConcurrentWriteLock @Async(AsyncExecutors.CLUSTER_SYNC_EXEC) public void asyncSyncUp(String clusterName,boolean updateClusterStatus){
  logger.info(""String_Node_Str"" + clusterName);
  clusterSyncService.syncUp(clusterName,updateClusterStatus);
}"
48284,"@Override @ClusterEntityConcurrentWriteLock public void syncUp(String clusterName,boolean updateClusterStatus){
  clusterSyncService.syncUp(clusterName,updateClusterStatus);
}","@Override @ClusterEntityConcurrentWriteLock public void syncUp(String clusterName,boolean updateClusterStatus){
  logger.info(""String_Node_Str"" + clusterName);
  clusterSyncService.syncUp(clusterName,updateClusterStatus);
}"
48285,"@Override @ClusterEntityExclusiveWriteLock @Async(AsyncExecutors.CLUSTER_SYNC_EXEC) public void asyncSyncUp(String clusterName,boolean updateClusterStatus){
  clusterSyncService.syncUp(clusterName,updateClusterStatus);
}","@Override @ClusterEntityExclusiveWriteLock @Async(AsyncExecutors.CLUSTER_SYNC_EXEC) public void asyncSyncUp(String clusterName,boolean updateClusterStatus){
  logger.info(""String_Node_Str"" + clusterName);
  clusterSyncService.syncUp(clusterName,updateClusterStatus);
}"
48286,"@Override @ClusterEntityExclusiveWriteLock public void syncUp(String clusterName,boolean updateClusterStatus){
  clusterSyncService.syncUp(clusterName,updateClusterStatus);
}","@Override @ClusterEntityExclusiveWriteLock public void syncUp(String clusterName,boolean updateClusterStatus){
  logger.info(""String_Node_Str"" + clusterName);
  clusterSyncService.syncUp(clusterName,updateClusterStatus);
}"
48287,"public void syncUp(String clusterName,boolean updateClusterStatus){
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"" + clusterName);
  }
  List<NodeEntity> nodes=clusterEntityMgr.findAllNodes(clusterName);
  boolean allNodesDown=true;
  List<Future<NodeRead>> refreshedNodeList=new ArrayList<>();
  for (  NodeEntity node : nodes) {
    refreshedNodeList.add(nodeSyncService.asyncRefreshNodeStatus(node.getVmName()));
  }
  while (refreshedNodeList.size() > 0) {
    for (Iterator<Future<NodeRead>> futureItr=refreshedNodeList.iterator(); futureItr.hasNext(); ) {
      Future<NodeRead> refreshedNodeFuture=futureItr.next();
      if (refreshedNodeFuture.isDone()) {
        try {
          NodeRead refreshedNode=refreshedNodeFuture.get();
          if (logger.isDebugEnabled()) {
            logger.debug(""String_Node_Str"" + refreshedNode.getName());
          }
          if (NodeStatus.fromString(refreshedNode.getStatus()).ordinal() >= NodeStatus.POWERED_ON.ordinal()) {
            allNodesDown=false;
          }
        }
 catch (        InterruptedException e) {
          logger.error(""String_Node_Str"",e);
        }
catch (        ExecutionException e) {
          logger.error(""String_Node_Str"",e);
        }
 finally {
          futureItr.remove();
        }
      }
    }
    try {
      Thread.sleep(50);
    }
 catch (    InterruptedException e) {
    }
  }
  if (updateClusterStatus && allNodesDown) {
    ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
    if (cluster.getStatus() == ClusterStatus.RUNNING) {
      logger.info(""String_Node_Str"");
      cluster.setStatus(ClusterStatus.STOPPED);
    }
  }
}","public void syncUp(String clusterName,boolean updateClusterStatus){
  if (logger.isDebugEnabled()) {
    logger.debug(""String_Node_Str"" + clusterName);
  }
  List<NodeEntity> nodes=clusterEntityMgr.findAllNodes(clusterName);
  boolean allNodesDown=true;
  List<Future<NodeRead>> refreshedNodeList=new ArrayList<>();
  for (  NodeEntity node : nodes) {
    refreshedNodeList.add(nodeSyncService.asyncRefreshNodeStatus(node.getVmName()));
  }
  long elapsed=0l;
  while (CollectionUtils.isNotEmpty(refreshedNodeList)) {
    for (Iterator<Future<NodeRead>> futureItr=refreshedNodeList.iterator(); futureItr.hasNext(); ) {
      Future<NodeRead> refreshedNodeFuture=futureItr.next();
      if (refreshedNodeFuture.isDone()) {
        try {
          NodeRead refreshedNode=refreshedNodeFuture.get();
          if (logger.isDebugEnabled()) {
            logger.debug(""String_Node_Str"" + refreshedNode.getName());
          }
          if (NodeStatus.fromString(refreshedNode.getStatus()).ordinal() >= NodeStatus.POWERED_ON.ordinal()) {
            allNodesDown=false;
          }
        }
 catch (        InterruptedException e) {
          logger.error(""String_Node_Str"",e);
        }
catch (        ExecutionException e) {
          logger.error(""String_Node_Str"",e);
        }
 finally {
          futureItr.remove();
        }
      }
    }
    try {
      Thread.sleep(TIME_SLICE);
      elapsed+=TIME_SLICE;
      if (elapsed >= MAX_WAIT) {
        break;
      }
    }
 catch (    InterruptedException e) {
    }
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + clusterName);
    }
  }
  if (CollectionUtils.isNotEmpty(refreshedNodeList)) {
    logger.warn(""String_Node_Str"" + clusterName);
  }
 else {
    logger.info(String.format(""String_Node_Str"",clusterName,elapsed));
  }
  if (updateClusterStatus && allNodesDown) {
    ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
    if (cluster.getStatus() == ClusterStatus.RUNNING) {
      logger.info(""String_Node_Str"");
      cluster.setStatus(ClusterStatus.STOPPED);
    }
  }
}"
48288,"private Set<NodeGroupEntity> convertNodeGroupsToEntities(Gson gson,ClusterEntity clusterEntity,String distro,NodeGroupCreate[] groups,boolean validateWhiteList){
  Set<NodeGroupEntity> nodeGroups=new HashSet<NodeGroupEntity>();
  for (  NodeGroupCreate group : groups) {
    NodeGroupEntity groupEntity=convertGroup(gson,clusterEntity,group,distro,validateWhiteList);
    if (groupEntity != null) {
      nodeGroups.add(groupEntity);
    }
  }
  return nodeGroups;
}","private Set<NodeGroupEntity> convertNodeGroupsToEntities(Gson gson,ClusterEntity clusterEntity,String distro,NodeGroupCreate[] groups,boolean validateWhiteList){
  Set<NodeGroupEntity> nodeGroups=new LinkedHashSet<NodeGroupEntity>();
  for (  NodeGroupCreate group : groups) {
    NodeGroupEntity groupEntity=convertGroup(gson,clusterEntity,group,distro,validateWhiteList);
    if (groupEntity != null) {
      nodeGroups.add(groupEntity);
    }
  }
  return nodeGroups;
}"
48289,"@Override public ClusterRead findClusterWithNodes(String clusterName,boolean includeVolumes){
  ClusterEntity cluster=clusterDao.findWithNodes(clusterName,includeVolumes);
  ClusterRead clusterRead=RestObjectManager.clusterEntityToRead(cluster);
  SoftwareManager softMgr=null;
  try {
    softMgr=softwareManagerCollector.getSoftwareManager(cluster.getAppManager());
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"");
  }
  int clusterInstanceNum=0;
  List<NodeGroupRead> ngReads=new ArrayList<>();
  List<VcResourcePoolEntity> rps=new ArrayList<>();
  for (  NodeGroupEntity ng : cluster.getNodeGroups()) {
    NodeGroupRead ngRead=RestObjectManager.nodeGroupEntityToRead(ng);
    List<NodeRead> nodeReads=new ArrayList<>();
    for (    NodeEntity node : ng.getNodes()) {
      nodeReads.add(RestObjectManager.nodeEntityToRead(node,includeVolumes));
    }
    ngRead.setInstances(nodeReads);
    int instanceNum=this.nodeDao.getCountByNodeGroup(ng.getId());
    ngRead.setInstanceNum(instanceNum);
    clusterInstanceNum+=instanceNum;
    try {
      ngRead.setComputeOnly(softMgr.isComputeOnlyRoles(ngRead.getRoles()));
    }
 catch (    Exception e) {
    }
    ngReads.add(ngRead);
    List<VcResourcePoolEntity> rpsNg=this.rpDao.findUsedRpsByNodeGroup(ng.getId());
    if (rpsNg != null && !rpsNg.isEmpty()) {
      rps.addAll(rpsNg);
    }
    logger.debug(""String_Node_Str"" + rps.size());
  }
  clusterRead.setNodeGroups(ngReads);
  clusterRead.setInstanceNum(clusterInstanceNum);
  clusterRead.setTemplateName(this.nodeTemplateDAO.findByMoid(cluster.getTemplateId()).getName());
  List<ResourcePoolRead> rpReads=new ArrayList<ResourcePoolRead>();
  Set<Long> processedRpIds=new HashSet<>();
  for (  VcResourcePoolEntity rp : rps) {
    if (!processedRpIds.contains(rp.getId())) {
      ResourcePoolRead rpRead=RestObjectManager.vcResourcePoolEntityToRead(rp);
      rpRead.setNodes(null);
      rpReads.add(rpRead);
      processedRpIds.add(rp.getId());
    }
  }
  logger.debug(""String_Node_Str"" + rpReads.size());
  clusterRead.setResourcePools(rpReads);
  return clusterRead;
}","@Override public ClusterRead findClusterWithNodes(String clusterName,boolean includeVolumes){
  ClusterEntity cluster=clusterDao.findWithNodes(clusterName,includeVolumes);
  ClusterRead clusterRead=RestObjectManager.clusterEntityToRead(cluster);
  SoftwareManager softMgr=null;
  try {
    softMgr=softwareManagerCollector.getSoftwareManager(cluster.getAppManager());
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"");
  }
  int clusterInstanceNum=0;
  List<NodeGroupRead> ngReads=new ArrayList<>();
  List<VcResourcePoolEntity> rps=new ArrayList<>();
  for (  NodeGroupEntity ng : cluster.getNodeGroupsSortedById()) {
    NodeGroupRead ngRead=RestObjectManager.nodeGroupEntityToRead(ng);
    List<NodeRead> nodeReads=new ArrayList<>();
    for (    NodeEntity node : ng.getNodes()) {
      nodeReads.add(RestObjectManager.nodeEntityToRead(node,includeVolumes));
    }
    ngRead.setInstances(nodeReads);
    int instanceNum=this.nodeDao.getCountByNodeGroup(ng.getId());
    ngRead.setInstanceNum(instanceNum);
    clusterInstanceNum+=instanceNum;
    try {
      ngRead.setComputeOnly(softMgr.isComputeOnlyRoles(ngRead.getRoles()));
    }
 catch (    Exception e) {
    }
    ngReads.add(ngRead);
    List<VcResourcePoolEntity> rpsNg=this.rpDao.findUsedRpsByNodeGroup(ng.getId());
    if (rpsNg != null && !rpsNg.isEmpty()) {
      rps.addAll(rpsNg);
    }
    logger.debug(""String_Node_Str"" + rps.size());
  }
  clusterRead.setNodeGroups(ngReads);
  clusterRead.setInstanceNum(clusterInstanceNum);
  clusterRead.setTemplateName(this.nodeTemplateDAO.findByMoid(cluster.getTemplateId()).getName());
  List<ResourcePoolRead> rpReads=new ArrayList<ResourcePoolRead>();
  Set<Long> processedRpIds=new HashSet<>();
  for (  VcResourcePoolEntity rp : rps) {
    if (!processedRpIds.contains(rp.getId())) {
      ResourcePoolRead rpRead=RestObjectManager.vcResourcePoolEntityToRead(rp);
      rpRead.setNodes(null);
      rpReads.add(rpRead);
      processedRpIds.add(rp.getId());
    }
  }
  logger.debug(""String_Node_Str"" + rpReads.size());
  clusterRead.setResourcePools(rpReads);
  return clusterRead;
}"
48290,"@Override public ClusterRead findClusterWithNodeGroups(String clusterName){
  ClusterEntity cluster=clusterDao.findWithNodeGroups(clusterName);
  ClusterRead clusterRead=RestObjectManager.clusterEntityToRead(cluster);
  SoftwareManager softMgr=null;
  try {
    softMgr=softwareManagerCollector.getSoftwareManager(cluster.getAppManager());
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"");
  }
  int clusterInstanceNum=0;
  List<NodeGroupRead> ngReads=new ArrayList<>();
  for (  NodeGroupEntity ng : cluster.getNodeGroups()) {
    NodeGroupRead ngRead=RestObjectManager.nodeGroupEntityToRead(ng);
    int instanceNum=this.nodeDao.getCountByNodeGroup(ng.getId());
    ngRead.setInstanceNum(instanceNum);
    clusterInstanceNum+=instanceNum;
    ngRead.setComputeOnly(false);
    try {
      ngRead.setComputeOnly(softMgr.isComputeOnlyRoles(ngRead.getRoles()));
    }
 catch (    Exception e) {
    }
    ngReads.add(ngRead);
  }
  clusterRead.setNodeGroups(ngReads);
  clusterRead.setInstanceNum(clusterInstanceNum);
  clusterRead.setTemplateName(this.nodeTemplateDAO.findByMoid(cluster.getTemplateId()).getName());
  return clusterRead;
}","@Override public ClusterRead findClusterWithNodeGroups(String clusterName){
  ClusterEntity cluster=clusterDao.findWithNodeGroups(clusterName);
  ClusterRead clusterRead=RestObjectManager.clusterEntityToRead(cluster);
  SoftwareManager softMgr=null;
  try {
    softMgr=softwareManagerCollector.getSoftwareManager(cluster.getAppManager());
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"");
  }
  int clusterInstanceNum=0;
  List<NodeGroupRead> ngReads=new ArrayList<>();
  for (  NodeGroupEntity ng : cluster.getNodeGroupsSortedById()) {
    NodeGroupRead ngRead=RestObjectManager.nodeGroupEntityToRead(ng);
    int instanceNum=this.nodeDao.getCountByNodeGroup(ng.getId());
    ngRead.setInstanceNum(instanceNum);
    clusterInstanceNum+=instanceNum;
    ngRead.setComputeOnly(false);
    try {
      ngRead.setComputeOnly(softMgr.isComputeOnlyRoles(ngRead.getRoles()));
    }
 catch (    Exception e) {
    }
    ngReads.add(ngRead);
  }
  clusterRead.setNodeGroups(ngReads);
  clusterRead.setInstanceNum(clusterInstanceNum);
  clusterRead.setTemplateName(this.nodeTemplateDAO.findByMoid(cluster.getTemplateId()).getName());
  return clusterRead;
}"
48291,"@Override public ClusterReport queryClusterStatus(ClusterBlueprint blueprint){
  AmClusterDef clusterDef=new AmClusterDef(blueprint,privateKey,getVersion());
  try {
    ServiceStatus status=apiManager.getClusterStatus(blueprint.getName(),blueprint.getHadoopStack());
    clusterDef.getCurrentReport().setStatus(status);
    Map<String,ServiceStatus> hostStates=apiManager.getHostStatus(blueprint.getName());
    Map<String,NodeReport> nodeReports=clusterDef.getCurrentReport().getNodeReports();
    for (    AmNodeDef node : clusterDef.getNodes()) {
      String fqdn=node.getFqdn();
      nodeReports.get(node.getName()).setStatus(hostStates.get(fqdn));
    }
  }
 catch (  NotFoundException e) {
    logger.info(""String_Node_Str"" + blueprint.getName() + ""String_Node_Str"");
    return null;
  }
  return clusterDef.getCurrentReport().clone();
}","@Override public ClusterReport queryClusterStatus(ClusterBlueprint blueprint){
  AmClusterDef clusterDef=new AmClusterDef(blueprint,privateKey,getVersion());
  try {
    ServiceStatus status=apiManager.getClusterStatus(blueprint.getName(),blueprint.getHadoopStack());
    clusterDef.getCurrentReport().setStatus(status);
    Map<String,ServiceStatus> hostStates=apiManager.getHostStatus(blueprint.getName());
    Map<String,NodeReport> nodeReports=clusterDef.getCurrentReport().getNodeReports();
    for (    AmNodeDef node : clusterDef.getNodes()) {
      String fqdn=node.getFqdn();
      NodeReport nodeReport=nodeReports.get(node.getName());
      if (nodeReport != null) {
        nodeReport.setStatus(hostStates.get(fqdn));
      }
    }
  }
 catch (  NotFoundException e) {
    logger.info(""String_Node_Str"" + blueprint.getName() + ""String_Node_Str"");
    return null;
  }
  return clusterDef.getCurrentReport().clone();
}"
48292,"private void setNodeTemplateName(ClusterRead clusterRead,String templateId){
  NodeTemplateEntity template=this.nodeTemplateDAO.findByMoid(templateId);
  if (template != null) {
    clusterRead.setTemplateName(template.getName());
  }
 else {
    logger.warn(""String_Node_Str"" + templateId);
    String notFound=Messages.getString(""String_Node_Str"");
    clusterRead.setTemplateName(notFound);
  }
}","private void setNodeTemplateName(ClusterRead clusterRead,String templateId){
  NodeTemplateEntity template=null;
  if (templateId != null) {
    template=this.nodeTemplateDAO.findByMoid(templateId);
  }
  if (template != null) {
    clusterRead.setTemplateName(template.getName());
  }
 else {
    logger.warn(""String_Node_Str"" + templateId + ""String_Node_Str"");
    String notFound=Messages.getString(""String_Node_Str"");
    clusterRead.setTemplateName(notFound);
  }
}"
48293,"private void execChefClient(String specFilePath){
  CommandLine cmdLine=new CommandLine(sudoCmd).addArgument(""String_Node_Str"").addArgument(""String_Node_Str"").addArgument(""String_Node_Str"").addArgument(""String_Node_Str"" + specFilePath + ""String_Node_Str"");
  execCommand(cmdLine);
}","private void execChefClient(String specFilePath){
  CommandLine cmdLine=new CommandLine(sudoCmd).addArgument(""String_Node_Str"").addArgument(""String_Node_Str"").addArgument(""String_Node_Str"").addArgument(""String_Node_Str"" + specFilePath + ""String_Node_Str"").addArgument(""String_Node_Str"").addArgument(""String_Node_Str"");
  execCommand(cmdLine);
}"
48294,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void modifyNetwork(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String ip,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final String dnsType){
  NetworkAdd networkAdd=new NetworkAdd();
  networkAdd.setName(name);
  try {
    if (!CommandsUtils.isBlank(ip) && dnsType.equals(NetworkDnsType.DYNAMIC.toString())) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_NETWORK,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAMS_EXCLUSION_PAIR_NETWORK_ADD_STATIC_DDNS + Constants.PARAMS_EXCLUSION);
      return;
    }
    if (ip != null) {
      if (!validateIP(ip,Constants.OUTPUT_OP_MODIFY)) {
        return;
      }
      networkAdd.setIpBlocks(transferIpInfo(ip));
    }
    if (dnsType != null) {
      networkAdd.setDnsType(NetworkDnsType.valueOf(dnsType.toUpperCase()));
    }
    networkRestClient.update(networkAdd);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_NETWORK,Constants.OUTPUT_OP_RESULT_MODIFY);
  }
 catch (  IllegalArgumentException ex) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_NETWORK,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ dnsType);
  }
catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_NETWORK,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void modifyNetwork(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String ip,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final String dnsType){
  NetworkAdd networkAdd=new NetworkAdd();
  networkAdd.setName(name);
  try {
    if (!CommandsUtils.isBlank(ip) && dnsType.toUpperCase().equals(NetworkDnsType.DYNAMIC.toString())) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_NETWORK,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAMS_EXCLUSION_PAIR_NETWORK_ADD_STATIC_DDNS + Constants.PARAMS_EXCLUSION);
      return;
    }
    if (ip != null) {
      if (!validateIP(ip,Constants.OUTPUT_OP_MODIFY)) {
        return;
      }
      networkAdd.setIpBlocks(transferIpInfo(ip));
    }
    if (dnsType != null) {
      networkAdd.setDnsType(NetworkDnsType.valueOf(dnsType.toUpperCase()));
    }
    networkRestClient.update(networkAdd);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_NETWORK,Constants.OUTPUT_OP_RESULT_MODIFY);
  }
 catch (  IllegalArgumentException ex) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_NETWORK,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ dnsType);
  }
catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_NETWORK,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}"
48295,"public static long getHeapSizeMhz(long nodeMemMhz,int groupRoleNums){
  logger.info(""String_Node_Str"");
  long osMemMhz=1024;
  long hbaseHeapMhz=nodeMemMhz - 1024 * (groupRoleNums - 1) - osMemMhz;
  hbaseHeapMhz=(hbaseHeapMhz > 1024) ? hbaseHeapMhz : 1024;
  ;
  logger.info(""String_Node_Str"" + hbaseHeapMhz);
  return hbaseHeapMhz;
}","public static long getHeapSizeMhz(long nodeMemMhz,int groupRoleNums){
  logger.info(""String_Node_Str"");
  long osMemMhz=1024;
  long hbaseHeapMhz=nodeMemMhz - 1024 * (groupRoleNums - 1) - osMemMhz;
  hbaseHeapMhz=(hbaseHeapMhz > 1024) ? hbaseHeapMhz : 1024;
  logger.info(""String_Node_Str"" + hbaseHeapMhz);
  return hbaseHeapMhz;
}"
48296,"private void setDiskAttributes(DatastoreType storageType,StorageRead storage,List<String> storeNames){
  if (storageType == null) {
    Set<String> storePattern=datastoreMgr.getLocalDatastoresByNames(storeNames);
    if (storePattern != null && !storePattern.isEmpty()) {
      logger.info(""String_Node_Str"");
      storage.setControllerType(DiskScsiControllerType.PARA_VIRTUAL_CONTROLLER);
      storage.setAllocType(AllocationType.THICK.name());
    }
 else {
      storage.setControllerType(DiskScsiControllerType.LSI_CONTROLLER);
      storage.setAllocType(AllocationType.THIN.name());
    }
    return;
  }
  if (storageType != DatastoreType.LOCAL) {
    storage.setControllerType(DiskScsiControllerType.LSI_CONTROLLER);
    storage.setAllocType(AllocationType.THIN.name());
  }
 else {
    storage.setControllerType(DiskScsiControllerType.PARA_VIRTUAL_CONTROLLER);
    storage.setAllocType(AllocationType.THICK.name());
  }
}","private void setDiskAttributes(DatastoreType storageType,StorageRead storage,List<String> storeNames){
  if (storageType == null) {
    Set<String> storePattern=datastoreMgr.getLocalDatastoresByNames(storeNames);
    if (storePattern != null && !storePattern.isEmpty()) {
      logger.info(""String_Node_Str"");
      storage.setControllerType(DiskScsiControllerType.PARA_VIRTUAL_CONTROLLER);
      storage.setAllocType(AllocationType.THICK.name());
    }
 else {
      storage.setControllerType(DiskScsiControllerType.LSI_CONTROLLER);
      storage.setAllocType(AllocationType.THIN.name());
    }
    return;
  }
  DiskScsiControllerType systemSwapDiskControllerType=CommonUtil.getSystemAndSwapControllerType();
  DiskScsiControllerType dataDiskControllerType=CommonUtil.getDataDiskControllerType();
  if (systemSwapDiskControllerType == DiskScsiControllerType.PARA_VIRTUAL_CONTROLLER && dataDiskControllerType == DiskScsiControllerType.LSI_CONTROLLER) {
    logger.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    dataDiskControllerType=DiskScsiControllerType.PARA_VIRTUAL_CONTROLLER;
  }
  storage.setControllerType(dataDiskControllerType);
  storage.setAllocType(AllocationType.THICK.name());
  if (storageType == DatastoreType.SHARED) {
    storage.setAllocType(AllocationType.THIN.name());
  }
}"
48297,"/** 
 * populate the base node with placement attributes, cluster/rp/host/datastore, etc. make sure there are enough cpu/mem/storage inside the rp and vc host
 * @param vcClusterName
 * @param rpName
 * @param host
 */
public void place(String rack,String vcClusterName,String rpName,AbstractHost host){
  AuAssert.check(getDisks() != null && getDisks().size() != 0);
  setTargetVcCluster(vcClusterName);
  setTargetHost(host.getName());
  setTargetRp(rpName);
  setTargetRack(rack);
  ArrayList<Disk> tmDisks=new ArrayList<Disk>();
  int lsiScsiIndex=1;
  int paraVirtualScsiIndex=0;
  for (  DiskSpec disk : this.disks) {
    if (disk.isSystemDisk()) {
      setTargetDs(disk.getTargetDs());
    }
 else {
      Disk tmDisk=new Disk();
      tmDisk.name=disk.getName();
      tmDisk.initialSizeMB=disk.getSize() * 1024;
      tmDisk.datastore=disk.getTargetDs();
      tmDisk.mode=DiskMode.independent_persistent;
      if (DiskScsiControllerType.LSI_CONTROLLER.equals(disk.getController())) {
        if (lsiScsiIndex == PlacementUtil.CONTROLLER_RESERVED_CHANNEL) {
          lsiScsiIndex++;
        }
        tmDisk.externalAddress=PlacementUtil.LSI_CONTROLLER_EXTERNAL_ADDRESS_PREFIX + lsiScsiIndex;
        lsiScsiIndex++;
      }
 else {
        tmDisk.externalAddress=PlacementUtil.getParaVirtualAddress(paraVirtualScsiIndex);
        paraVirtualScsiIndex=PlacementUtil.getNextValidParaVirtualScsiIndex(paraVirtualScsiIndex);
      }
      tmDisk.allocationType=AllocationType.valueOf(disk.getAllocType());
      tmDisk.type=disk.getDiskType().getType();
      tmDisks.add(tmDisk);
    }
  }
  DiskSchema diskSchema=new DiskSchema();
  diskSchema.setName(""String_Node_Str"");
  diskSchema.setDisks(tmDisks);
  this.vmSchema.diskSchema=diskSchema;
}","/** 
 * populate the base node with placement attributes, cluster/rp/host/datastore, etc. make sure there are enough cpu/mem/storage inside the rp and vc host
 * @param vcClusterName
 * @param rpName
 * @param host
 */
public void place(String rack,String vcClusterName,String rpName,AbstractHost host){
  AuAssert.check(getDisks() != null && getDisks().size() != 0);
  setTargetVcCluster(vcClusterName);
  setTargetHost(host.getName());
  setTargetRp(rpName);
  setTargetRack(rack);
  ArrayList<Disk> tmDisks=new ArrayList<Disk>();
  int lsiScsiIndex=0;
  int paraVirtualScsiIndex=0;
  StorageRead.DiskScsiControllerType sysSwapCtrlType=CommonUtil.getSystemAndSwapControllerType();
  for (  DiskSpec disk : this.disks) {
    if (disk.isSystemDisk()) {
      setTargetDs(disk.getTargetDs());
    }
 else {
      Disk tmDisk=new Disk();
      tmDisk.name=disk.getName();
      tmDisk.initialSizeMB=disk.getSize() * 1024;
      tmDisk.datastore=disk.getTargetDs();
      tmDisk.mode=DiskMode.independent_persistent;
      if (disk.isSwapDisk()) {
        tmDisk.externalAddress=PlacementUtil.getSwapAddress(sysSwapCtrlType);
      }
 else {
        if (DiskScsiControllerType.LSI_CONTROLLER.equals(disk.getController())) {
          if (lsiScsiIndex == PlacementUtil.CONTROLLER_RESERVED_CHANNEL) {
            lsiScsiIndex++;
          }
          tmDisk.externalAddress=PlacementUtil.LSI_CONTROLLER_EXTERNAL_ADDRESS_PREFIX + lsiScsiIndex;
          lsiScsiIndex++;
        }
 else {
          tmDisk.externalAddress=PlacementUtil.getParaVirtualAddress(paraVirtualScsiIndex);
          paraVirtualScsiIndex=PlacementUtil.getNextValidParaVirtualScsiIndex(paraVirtualScsiIndex);
        }
      }
      tmDisk.allocationType=AllocationType.valueOf(disk.getAllocType());
      tmDisk.type=disk.getDiskType().getType();
      tmDisks.add(tmDisk);
    }
  }
  DiskSchema diskSchema=new DiskSchema();
  diskSchema.setName(""String_Node_Str"");
  diskSchema.setDisks(tmDisks);
  this.vmSchema.diskSchema=diskSchema;
}"
48298,"@Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
  JAXBContext jaxbContext;
  try {
    jaxbContext=JAXBContext.newInstance(Users.class);
    Unmarshaller jaxbUnmarshaller=jaxbContext.createUnmarshaller();
    Users users=(Users)jaxbUnmarshaller.unmarshal(FileUtils.getConfigurationFile(UserService.UsersFile,""String_Node_Str""));
    User userDTO=null;
    if (users != null) {
      for (      User user : users.getUsers()) {
        if (user.getName().equals(username)) {
          userDTO=user;
          break;
        }
 else         if (user.getName().trim().equals(""String_Node_Str"")) {
          userDTO=user;
          userDTO.setName(""String_Node_Str"");
        }
      }
    }
    if (null == userDTO) {
      throw new UsernameNotFoundException(""String_Node_Str"");
    }
    ArrayList<GrantedAuthority> roleList=new ArrayList<GrantedAuthority>();
    roleList.add(new SimpleGrantedAuthority(ADMIN_ROLE));
    return new org.springframework.security.core.userdetails.User(userDTO.getName(),""String_Node_Str"",roleList);
  }
 catch (  UsernameNotFoundException userNotFoundEx) {
    throw userNotFoundEx;
  }
catch (  Exception e) {
    logger.error(""String_Node_Str"" + e.getMessage());
    throw new UsernameNotFoundException(""String_Node_Str"");
  }
}","@Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
  JAXBContext jaxbContext;
  try {
    jaxbContext=JAXBContext.newInstance(Users.class);
    Unmarshaller jaxbUnmarshaller=jaxbContext.createUnmarshaller();
    XMLInputFactory xif=XMLInputFactory.newFactory();
    xif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES,false);
    XMLStreamReader xsr=xif.createXMLStreamReader(new StreamSource(FileUtils.getConfigurationFile(UserService.UsersFile,""String_Node_Str"")));
    Users users=(Users)jaxbUnmarshaller.unmarshal(xsr);
    User userDTO=null;
    if (users != null) {
      for (      User user : users.getUsers()) {
        if (user.getName().equals(username)) {
          userDTO=user;
          break;
        }
 else         if (user.getName().trim().equals(""String_Node_Str"")) {
          userDTO=user;
          userDTO.setName(""String_Node_Str"");
        }
      }
    }
    if (null == userDTO) {
      throw new UsernameNotFoundException(""String_Node_Str"");
    }
    ArrayList<GrantedAuthority> roleList=new ArrayList<GrantedAuthority>();
    roleList.add(new SimpleGrantedAuthority(ADMIN_ROLE));
    return new org.springframework.security.core.userdetails.User(userDTO.getName(),""String_Node_Str"",roleList);
  }
 catch (  UsernameNotFoundException userNotFoundEx) {
    throw userNotFoundEx;
  }
catch (  Exception e) {
    logger.error(""String_Node_Str"" + e.getMessage());
    throw new UsernameNotFoundException(""String_Node_Str"");
  }
}"
48299,"@Override public List<NodeTemplateEntity> findByName(String name){
  return this.findByCriteria(Restrictions.eq(""String_Node_Str"",name).ignoreCase());
}","@Override public List<NodeTemplateEntity> findByName(String name){
  return this.findByCriteria(Restrictions.eq(""String_Node_Str"",name));
}"
48300,"@Override public NodeTemplateEntity findByMoid(String vmMoid){
  return findUniqueByCriteria(Restrictions.eq(""String_Node_Str"",vmMoid).ignoreCase());
}","@Override public NodeTemplateEntity findByMoid(String vmMoid){
  return findUniqueByCriteria(Restrictions.eq(""String_Node_Str"",vmMoid));
}"
48301,"@Override public ClusterRead findClusterWithNodes(String clusterName,boolean includeVolumes){
  ClusterEntity cluster=clusterDao.findWithNodes(clusterName,includeVolumes);
  ClusterRead clusterRead=RestObjectManager.clusterEntityToRead(cluster);
  SoftwareManager softMgr=null;
  try {
    softMgr=softwareManagerCollector.getSoftwareManager(cluster.getAppManager());
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"");
  }
  int clusterInstanceNum=0;
  List<NodeGroupRead> ngReads=new ArrayList<>();
  List<VcResourcePoolEntity> rps=new ArrayList<>();
  for (  NodeGroupEntity ng : cluster.getNodeGroupsSortedById()) {
    NodeGroupRead ngRead=RestObjectManager.nodeGroupEntityToRead(ng);
    List<NodeRead> nodeReads=new ArrayList<>();
    for (    NodeEntity node : ng.getNodes()) {
      nodeReads.add(RestObjectManager.nodeEntityToRead(node,includeVolumes));
    }
    ngRead.setInstances(nodeReads);
    int instanceNum=this.nodeDao.getCountByNodeGroup(ng.getId());
    ngRead.setInstanceNum(instanceNum);
    clusterInstanceNum+=instanceNum;
    try {
      ngRead.setComputeOnly(softMgr.isComputeOnlyRoles(ngRead.getRoles()));
    }
 catch (    Exception e) {
    }
    ngReads.add(ngRead);
    List<VcResourcePoolEntity> rpsNg=this.rpDao.findUsedRpsByNodeGroup(ng.getId());
    if (rpsNg != null && !rpsNg.isEmpty()) {
      rps.addAll(rpsNg);
    }
    logger.debug(""String_Node_Str"" + rps.size());
  }
  clusterRead.setNodeGroups(ngReads);
  clusterRead.setInstanceNum(clusterInstanceNum);
  clusterRead.setTemplateName(this.nodeTemplateDAO.findByMoid(cluster.getTemplateId()).getName());
  List<ResourcePoolRead> rpReads=new ArrayList<ResourcePoolRead>();
  Set<Long> processedRpIds=new HashSet<>();
  for (  VcResourcePoolEntity rp : rps) {
    if (!processedRpIds.contains(rp.getId())) {
      ResourcePoolRead rpRead=RestObjectManager.vcResourcePoolEntityToRead(rp);
      rpRead.setNodes(null);
      rpReads.add(rpRead);
      processedRpIds.add(rp.getId());
    }
  }
  logger.debug(""String_Node_Str"" + rpReads.size());
  clusterRead.setResourcePools(rpReads);
  return clusterRead;
}","@Override public ClusterRead findClusterWithNodes(String clusterName,boolean includeVolumes){
  ClusterEntity cluster=clusterDao.findWithNodes(clusterName,includeVolumes);
  ClusterRead clusterRead=RestObjectManager.clusterEntityToRead(cluster);
  SoftwareManager softMgr=null;
  try {
    softMgr=softwareManagerCollector.getSoftwareManager(cluster.getAppManager());
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"");
  }
  int clusterInstanceNum=0;
  List<NodeGroupRead> ngReads=new ArrayList<>();
  List<VcResourcePoolEntity> rps=new ArrayList<>();
  for (  NodeGroupEntity ng : cluster.getNodeGroupsSortedById()) {
    NodeGroupRead ngRead=RestObjectManager.nodeGroupEntityToRead(ng);
    List<NodeRead> nodeReads=new ArrayList<>();
    for (    NodeEntity node : ng.getNodes()) {
      nodeReads.add(RestObjectManager.nodeEntityToRead(node,includeVolumes));
    }
    ngRead.setInstances(nodeReads);
    int instanceNum=this.nodeDao.getCountByNodeGroup(ng.getId());
    ngRead.setInstanceNum(instanceNum);
    clusterInstanceNum+=instanceNum;
    try {
      ngRead.setComputeOnly(softMgr.isComputeOnlyRoles(ngRead.getRoles()));
    }
 catch (    Exception e) {
    }
    ngReads.add(ngRead);
    List<VcResourcePoolEntity> rpsNg=this.rpDao.findUsedRpsByNodeGroup(ng.getId());
    if (rpsNg != null && !rpsNg.isEmpty()) {
      rps.addAll(rpsNg);
    }
    logger.debug(""String_Node_Str"" + rps.size());
  }
  clusterRead.setNodeGroups(ngReads);
  clusterRead.setInstanceNum(clusterInstanceNum);
  setNodeTemplateName(clusterRead,cluster.getTemplateId());
  List<ResourcePoolRead> rpReads=new ArrayList<ResourcePoolRead>();
  Set<Long> processedRpIds=new HashSet<>();
  for (  VcResourcePoolEntity rp : rps) {
    if (!processedRpIds.contains(rp.getId())) {
      ResourcePoolRead rpRead=RestObjectManager.vcResourcePoolEntityToRead(rp);
      rpRead.setNodes(null);
      rpReads.add(rpRead);
      processedRpIds.add(rp.getId());
    }
  }
  logger.debug(""String_Node_Str"" + rpReads.size());
  clusterRead.setResourcePools(rpReads);
  return clusterRead;
}"
48302,"@Override public ClusterRead findClusterWithNodeGroups(String clusterName){
  ClusterEntity cluster=clusterDao.findWithNodeGroups(clusterName);
  ClusterRead clusterRead=RestObjectManager.clusterEntityToRead(cluster);
  SoftwareManager softMgr=null;
  try {
    softMgr=softwareManagerCollector.getSoftwareManager(cluster.getAppManager());
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"");
  }
  int clusterInstanceNum=0;
  List<NodeGroupRead> ngReads=new ArrayList<>();
  for (  NodeGroupEntity ng : cluster.getNodeGroupsSortedById()) {
    NodeGroupRead ngRead=RestObjectManager.nodeGroupEntityToRead(ng);
    int instanceNum=this.nodeDao.getCountByNodeGroup(ng.getId());
    ngRead.setInstanceNum(instanceNum);
    clusterInstanceNum+=instanceNum;
    ngRead.setComputeOnly(false);
    try {
      ngRead.setComputeOnly(softMgr.isComputeOnlyRoles(ngRead.getRoles()));
    }
 catch (    Exception e) {
    }
    ngReads.add(ngRead);
  }
  clusterRead.setNodeGroups(ngReads);
  clusterRead.setInstanceNum(clusterInstanceNum);
  clusterRead.setTemplateName(this.nodeTemplateDAO.findByMoid(cluster.getTemplateId()).getName());
  return clusterRead;
}","@Override public ClusterRead findClusterWithNodeGroups(String clusterName){
  ClusterEntity cluster=clusterDao.findWithNodeGroups(clusterName);
  ClusterRead clusterRead=RestObjectManager.clusterEntityToRead(cluster);
  SoftwareManager softMgr=null;
  try {
    softMgr=softwareManagerCollector.getSoftwareManager(cluster.getAppManager());
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"");
  }
  int clusterInstanceNum=0;
  List<NodeGroupRead> ngReads=new ArrayList<>();
  for (  NodeGroupEntity ng : cluster.getNodeGroupsSortedById()) {
    NodeGroupRead ngRead=RestObjectManager.nodeGroupEntityToRead(ng);
    int instanceNum=this.nodeDao.getCountByNodeGroup(ng.getId());
    ngRead.setInstanceNum(instanceNum);
    clusterInstanceNum+=instanceNum;
    ngRead.setComputeOnly(false);
    try {
      ngRead.setComputeOnly(softMgr.isComputeOnlyRoles(ngRead.getRoles()));
    }
 catch (    Exception e) {
    }
    ngReads.add(ngRead);
  }
  clusterRead.setNodeGroups(ngReads);
  clusterRead.setInstanceNum(clusterInstanceNum);
  setNodeTemplateName(clusterRead,cluster.getTemplateId());
  return clusterRead;
}"
48303,"public ApiRequest startComponents(String clusterName,List<String> hostNames,List<String> components) throws AmbariApiException {
  ApiHostsRequest hostsRequest=new ApiHostsRequest();
  ApiHostComponentsRequest apiComponents=new ApiHostComponentsRequest();
  hostsRequest.setBody(apiComponents);
  ApiComponentInfo hostRoles=new ApiComponentInfo();
  hostRoles.setState(""String_Node_Str"");
  apiComponents.setHostRoles(hostRoles);
  ApiHostsRequestInfo requestInfo=new ApiHostsRequestInfo();
  hostsRequest.setRequestInfo(requestInfo);
  requestInfo.setContext(""String_Node_Str"");
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"");
  for (  String hostName : hostNames) {
    builder.append(hostName).append(""String_Node_Str"");
  }
  builder.deleteCharAt(builder.length() - 1);
  builder.append(""String_Node_Str"").append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  for (  String component : components) {
    builder.append(component).append(""String_Node_Str"");
  }
  builder.deleteCharAt(builder.length() - 1);
  builder.append(""String_Node_Str"");
  requestInfo.setQueryString(builder.toString());
  String startJson=ApiUtils.objectToJson(hostsRequest);
  logger.debug(""String_Node_Str"" + startJson);
  Response response=null;
  try {
    response=apiResourceRootV1.getClustersResource().getHostComponentsResource(clusterName).operationWithFilter(startJson);
  }
 catch (  Exception e) {
    throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
  }
  String responseJson=handleAmbariResponse(response);
  logger.debug(""String_Node_Str"" + responseJson);
  return ApiUtils.jsonToObject(ApiRequest.class,responseJson);
}","@Override public ApiRequest startComponents(String clusterName,List<String> hostNames,List<String> components) throws AmbariApiException {
  ApiHostsRequest hostsRequest=new ApiHostsRequest();
  ApiHostComponentsRequest apiComponents=new ApiHostComponentsRequest();
  hostsRequest.setBody(apiComponents);
  ApiComponentInfo hostRoles=new ApiComponentInfo();
  hostRoles.setState(""String_Node_Str"");
  apiComponents.setHostRoles(hostRoles);
  ApiHostsRequestInfo requestInfo=new ApiHostsRequestInfo();
  hostsRequest.setRequestInfo(requestInfo);
  requestInfo.setContext(""String_Node_Str"");
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"");
  for (  String hostName : hostNames) {
    builder.append(hostName).append(""String_Node_Str"");
  }
  builder.deleteCharAt(builder.length() - 1);
  builder.append(""String_Node_Str"").append(""String_Node_Str"");
  builder.append(""String_Node_Str"");
  for (  String component : components) {
    builder.append(component).append(""String_Node_Str"");
  }
  builder.deleteCharAt(builder.length() - 1);
  builder.append(""String_Node_Str"");
  requestInfo.setQueryString(builder.toString());
  String startJson=ApiUtils.objectToJson(hostsRequest);
  logger.debug(""String_Node_Str"" + startJson);
  Response response=null;
  try {
    response=apiResourceRootV1.getClustersResource().getHostComponentsResource(clusterName).operationWithFilter(startJson);
  }
 catch (  Exception e) {
    throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
  }
  String responseJson=handleAmbariResponse(response);
  logger.debug(""String_Node_Str"" + responseJson);
  return ApiUtils.jsonToObject(ApiRequest.class,responseJson);
}"
48304,"public void addHostsToCluster(String clusterName,List<String> hostNames) throws AmbariApiException {
  logger.debug(""String_Node_Str"" + hostNames + ""String_Node_Str""+ clusterName);
  for (  String hostName : hostNames) {
    Response response=null;
    try {
      response=apiResourceRootV1.getClustersResource().getHostsResource(clusterName).addHost(hostName);
    }
 catch (    Exception e) {
      throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
    }
    handleAmbariResponse(response);
  }
}","@Override public void addHostsToCluster(String clusterName,List<String> hostNames) throws AmbariApiException {
  logger.debug(""String_Node_Str"" + hostNames + ""String_Node_Str""+ clusterName);
  for (  String hostName : hostNames) {
    Response response=null;
    try {
      response=apiResourceRootV1.getClustersResource().getHostsResource(clusterName).addHost(hostName);
    }
 catch (    Exception e) {
      throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
    }
    handleAmbariResponse(response);
  }
}"
48305,"public List<String> getAssociatedConfigGroups(String clusterName,String hostName) throws AmbariApiException {
  String fields=""String_Node_Str"";
  Response response=null;
  try {
    response=apiResourceRootV1.getClustersResource().getConfigGroupsResource(clusterName).readConfigGroupsWithFields(fields);
  }
 catch (  Exception e) {
    throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
  }
  String strConfGroups=handleAmbariResponse(response);
  ApiConfigGroupList apiConfGroupList=ApiUtils.jsonToObject(ApiConfigGroupList.class,strConfGroups);
  List<String> result=new ArrayList<>();
  if (apiConfGroupList.getConfigGroups() == null) {
    return result;
  }
  for (  ApiConfigGroup group : apiConfGroupList.getConfigGroups()) {
    List<ApiHostInfo> apiHosts=group.getApiConfigGroupInfo().getHosts();
    if (apiHosts == null) {
      continue;
    }
    if (apiHosts.size() == 1) {
      if (hostName.equals(apiHosts.get(0).getHostName())) {
        result.add(group.getApiConfigGroupInfo().getId());
      }
    }
  }
  return result;
}","@Override public List<String> getAssociatedConfigGroups(String clusterName,String hostName) throws AmbariApiException {
  String fields=""String_Node_Str"";
  Response response=null;
  try {
    response=apiResourceRootV1.getClustersResource().getConfigGroupsResource(clusterName).readConfigGroupsWithFields(fields);
  }
 catch (  Exception e) {
    throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
  }
  String strConfGroups=handleAmbariResponse(response);
  ApiConfigGroupList apiConfGroupList=ApiUtils.jsonToObject(ApiConfigGroupList.class,strConfGroups);
  List<String> result=new ArrayList<>();
  if (apiConfGroupList.getConfigGroups() == null) {
    return result;
  }
  for (  ApiConfigGroup group : apiConfGroupList.getConfigGroups()) {
    List<ApiHostInfo> apiHosts=group.getApiConfigGroupInfo().getHosts();
    if (apiHosts == null) {
      continue;
    }
    if (apiHosts.size() == 1) {
      if (hostName.equals(apiHosts.get(0).getHostName())) {
        result.add(group.getApiConfigGroupInfo().getId());
      }
    }
  }
  return result;
}"
48306,"public List<String> getExistingHosts(String clusterName,List<String> hostNames) throws AmbariApiException {
  Response response=null;
  try {
    response=apiResourceRootV1.getClustersResource().getHostsResource(clusterName).readHosts();
  }
 catch (  Exception e) {
    throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
  }
  String hostList=handleAmbariResponse(response);
  ApiHostList apiHostList=ApiUtils.jsonToObject(ApiHostList.class,hostList);
  List<String> existingHosts=new ArrayList<>();
  if (apiHostList.getApiHosts() != null) {
    for (    ApiHost apiHost : apiHostList.getApiHosts()) {
      if (hostNames.contains(apiHost.getApiHostInfo().getHostName())) {
        existingHosts.add(apiHost.getApiHostInfo().getHostName());
      }
    }
  }
  return existingHosts;
}","@Override public List<String> getExistingHosts(String clusterName,List<String> hostNames) throws AmbariApiException {
  Response response=null;
  try {
    response=apiResourceRootV1.getClustersResource().getHostsResource(clusterName).readHosts();
  }
 catch (  Exception e) {
    throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
  }
  String hostList=handleAmbariResponse(response);
  ApiHostList apiHostList=ApiUtils.jsonToObject(ApiHostList.class,hostList);
  List<String> existingHosts=new ArrayList<>();
  if (apiHostList.getApiHosts() != null) {
    for (    ApiHost apiHost : apiHostList.getApiHosts()) {
      if (hostNames.contains(apiHost.getApiHostInfo().getHostName())) {
        existingHosts.add(apiHost.getApiHostInfo().getHostName());
      }
    }
  }
  return existingHosts;
}"
48307,"public void addComponents(String clusterName,List<String> hostNames,ApiHostComponentsRequest components) throws AmbariApiException {
  logger.info(""String_Node_Str"" + hostNames);
  ApiHostsRequest hostsRequest=new ApiHostsRequest();
  hostsRequest.setBody(components);
  ApiHostsRequestInfo requestInfo=new ApiHostsRequestInfo();
  hostsRequest.setRequestInfo(requestInfo);
  requestInfo.setContext(""String_Node_Str"");
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"");
  for (  String hostName : hostNames) {
    builder.append(hostName).append(""String_Node_Str"");
  }
  builder.deleteCharAt(builder.length() - 1);
  builder.append(""String_Node_Str"");
  requestInfo.setQueryString(builder.toString());
  String json=ApiUtils.objectToJson(hostsRequest);
  logger.debug(""String_Node_Str"" + json);
  Response response=null;
  try {
    response=apiResourceRootV1.getClustersResource().getHostsResource(clusterName).addComponentsToHosts(json);
  }
 catch (  Exception e) {
    throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
  }
  handleAmbariResponse(response);
}","@Override public void addComponents(String clusterName,List<String> hostNames,ApiHostComponentsRequest components) throws AmbariApiException {
  logger.info(""String_Node_Str"" + hostNames);
  ApiHostsRequest hostsRequest=new ApiHostsRequest();
  hostsRequest.setBody(components);
  ApiHostsRequestInfo requestInfo=new ApiHostsRequestInfo();
  hostsRequest.setRequestInfo(requestInfo);
  requestInfo.setContext(""String_Node_Str"");
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"");
  for (  String hostName : hostNames) {
    builder.append(hostName).append(""String_Node_Str"");
  }
  builder.deleteCharAt(builder.length() - 1);
  builder.append(""String_Node_Str"");
  requestInfo.setQueryString(builder.toString());
  String json=ApiUtils.objectToJson(hostsRequest);
  logger.debug(""String_Node_Str"" + json);
  Response response=null;
  try {
    response=apiResourceRootV1.getClustersResource().getHostsResource(clusterName).addComponentsToHosts(json);
  }
 catch (  Exception e) {
    throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
  }
  handleAmbariResponse(response);
}"
48308,"public ApiRequest installComponents(String clusterName) throws AmbariApiException {
  ApiHostsRequest hostsRequest=AmUtils.createInstallComponentsRequest();
  String json=ApiUtils.objectToJson(hostsRequest);
  logger.debug(""String_Node_Str"" + json);
  Response response=null;
  try {
    response=apiResourceRootV1.getClustersResource().getHostComponentsResource(clusterName).operationWithFilter(json);
  }
 catch (  Exception e) {
    throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
  }
  String installJson=handleAmbariResponse(response);
  logger.debug(""String_Node_Str"" + installJson);
  return ApiUtils.jsonToObject(ApiRequest.class,installJson);
}","@Override public ApiRequest installComponents(String clusterName) throws AmbariApiException {
  ApiHostsRequest hostsRequest=AmUtils.createInstallComponentsRequest();
  String json=ApiUtils.objectToJson(hostsRequest);
  logger.debug(""String_Node_Str"" + json);
  Response response=null;
  try {
    response=apiResourceRootV1.getClustersResource().getHostComponentsResource(clusterName).operationWithFilter(json);
  }
 catch (  Exception e) {
    throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
  }
  String installJson=handleAmbariResponse(response);
  logger.debug(""String_Node_Str"" + installJson);
  return ApiUtils.jsonToObject(ApiRequest.class,installJson);
}"
48309,"public void deleteAllComponents(String clusterName,String hostName) throws AmbariApiException {
  Response response=null;
  try {
    response=apiResourceRootV1.getClustersResource().getHostsResource(clusterName).deleteHostComponentsResource(hostName);
  }
 catch (  Exception e) {
    throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
  }
  handleAmbariResponse(response);
}","@Override public void deleteAllComponents(String clusterName,String hostName) throws AmbariApiException {
  Response response=null;
  try {
    response=apiResourceRootV1.getClustersResource().getHostsResource(clusterName).deleteHostComponentsResource(hostName);
  }
 catch (  Exception e) {
    throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
  }
  handleAmbariResponse(response);
}"
48310,"public void deleteConfigGroup(String clusterName,String groupId) throws AmbariApiException {
  Response response=null;
  try {
    response=apiResourceRootV1.getClustersResource().getConfigGroupsResource(clusterName).deleteConfigGroup(groupId);
  }
 catch (  Exception e) {
    throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
  }
  handleAmbariResponse(response);
}","@Override public void deleteConfigGroup(String clusterName,String groupId) throws AmbariApiException {
  Response response=null;
  try {
    response=apiResourceRootV1.getClustersResource().getConfigGroupsResource(clusterName).deleteConfigGroup(groupId);
  }
 catch (  Exception e) {
    throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
  }
  handleAmbariResponse(response);
}"
48311,"public ServiceStatus getClusterStatus(String clusterName,HadoopStack stack) throws AmbariApiException {
  return null;
}","@Override public ServiceStatus getClusterStatus(String clusterName,HadoopStack stack) throws AmbariApiException {
  return null;
}"
48312,"@Override public ApiRequest getRequest(String clusterName,Long requestId) throws AmbariApiException {
  Response response=null;
  try {
    response=apiResourceRootV1.getClustersResource().getRequestsResource(clusterName).readRequest(requestId);
  }
 catch (  Exception e) {
    throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
  }
  String requestJson=handleAmbariResponse(response);
  logger.debug(""String_Node_Str"");
  logger.debug(requestJson);
  ApiRequest apiRequest=ApiUtils.jsonToObject(ApiRequest.class,requestJson);
  return apiRequest;
}","@Override public ApiRequest getRequest(String clusterName,Long requestId) throws AmbariApiException {
  Response response=null;
  ApiRequest apiRequest=null;
  int retry_times=10;
  while (apiRequest == null && retry_times > 0) {
    try {
      response=apiResourceRootV1.getClustersResource().getRequestsResource(clusterName).readRequest(requestId);
    }
 catch (    Exception e) {
      throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
    }
    String requestJson=handleAmbariResponse(response);
    logger.debug(""String_Node_Str"");
    logger.debug(requestJson);
    apiRequest=ApiUtils.jsonToObject(ApiRequest.class,requestJson);
    retry_times-=1;
    try {
      Thread.sleep(3000);
    }
 catch (    InterruptedException e) {
      logger.error(e.getMessage());
    }
  }
  if (apiRequest == null) {
    throw AmbariApiException.CONNOT_FIND_REQUEST(requestId);
  }
  return apiRequest;
}"
48313,"public void createConfigGroups(String clusterName,List<ApiConfigGroup> configGroups) throws AmbariApiException {
  String confGroups=ApiUtils.objectToJson(configGroups);
  logger.debug(""String_Node_Str"" + confGroups);
  Response response=null;
  try {
    response=apiResourceRootV1.getClustersResource().getConfigGroupsResource(clusterName).createConfigGroups(confGroups);
  }
 catch (  Exception e) {
    throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
  }
  handleAmbariResponse(response);
}","@Override public void createConfigGroups(String clusterName,List<ApiConfigGroup> configGroups) throws AmbariApiException {
  String confGroups=ApiUtils.objectToJson(configGroups);
  logger.debug(""String_Node_Str"" + confGroups);
  Response response=null;
  try {
    response=apiResourceRootV1.getClustersResource().getConfigGroupsResource(clusterName).createConfigGroups(confGroups);
  }
 catch (  Exception e) {
    throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
  }
  handleAmbariResponse(response);
}"
48314,"public boolean deleteBlueprint(String blueprintName) throws AmbariApiException {
  logger.info(""String_Node_Str"" + blueprintName);
  Response response=null;
  try {
    response=apiResourceRootV1.getBlueprintsResource().deleteBlueprint(blueprintName);
  }
 catch (  Exception e) {
    throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
  }
  handleAmbariResponse(response);
  return true;
}","@Override public boolean deleteBlueprint(String blueprintName) throws AmbariApiException {
  logger.info(""String_Node_Str"" + blueprintName);
  Response response=null;
  try {
    response=apiResourceRootV1.getBlueprintsResource().deleteBlueprint(blueprintName);
  }
 catch (  Exception e) {
    throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
  }
  handleAmbariResponse(response);
  return true;
}"
48315,"public ApiRequest stopAllComponentsInHosts(String clusterName,List<String> hostNames) throws AmbariApiException {
  ApiHostsRequest hostsRequest=new ApiHostsRequest();
  ApiHostComponentsRequest apiComponents=new ApiHostComponentsRequest();
  hostsRequest.setBody(apiComponents);
  ApiComponentInfo hostRoles=new ApiComponentInfo();
  hostRoles.setState(""String_Node_Str"");
  apiComponents.setHostRoles(hostRoles);
  ApiHostsRequestInfo requestInfo=new ApiHostsRequestInfo();
  hostsRequest.setRequestInfo(requestInfo);
  requestInfo.setContext(""String_Node_Str"");
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"");
  for (  String hostName : hostNames) {
    builder.append(hostName).append(""String_Node_Str"");
  }
  builder.deleteCharAt(builder.length() - 1);
  builder.append(""String_Node_Str"");
  requestInfo.setQueryString(builder.toString());
  String startJson=ApiUtils.objectToJson(hostsRequest);
  logger.debug(""String_Node_Str"" + startJson);
  Response response=null;
  try {
    response=apiResourceRootV1.getClustersResource().getHostComponentsResource(clusterName).operationWithFilter(startJson);
  }
 catch (  Exception e) {
    throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
  }
  String responseJson=handleAmbariResponse(response);
  logger.debug(""String_Node_Str"" + responseJson);
  return ApiUtils.jsonToObject(ApiRequest.class,responseJson);
}","@Override public ApiRequest stopAllComponentsInHosts(String clusterName,List<String> hostNames) throws AmbariApiException {
  ApiHostsRequest hostsRequest=new ApiHostsRequest();
  ApiHostComponentsRequest apiComponents=new ApiHostComponentsRequest();
  hostsRequest.setBody(apiComponents);
  ApiComponentInfo hostRoles=new ApiComponentInfo();
  hostRoles.setState(""String_Node_Str"");
  apiComponents.setHostRoles(hostRoles);
  ApiHostsRequestInfo requestInfo=new ApiHostsRequestInfo();
  hostsRequest.setRequestInfo(requestInfo);
  requestInfo.setContext(""String_Node_Str"");
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"");
  for (  String hostName : hostNames) {
    builder.append(hostName).append(""String_Node_Str"");
  }
  builder.deleteCharAt(builder.length() - 1);
  builder.append(""String_Node_Str"");
  requestInfo.setQueryString(builder.toString());
  String startJson=ApiUtils.objectToJson(hostsRequest);
  logger.debug(""String_Node_Str"" + startJson);
  Response response=null;
  try {
    response=apiResourceRootV1.getClustersResource().getHostComponentsResource(clusterName).operationWithFilter(startJson);
  }
 catch (  Exception e) {
    throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
  }
  String responseJson=handleAmbariResponse(response);
  logger.debug(""String_Node_Str"" + responseJson);
  return ApiUtils.jsonToObject(ApiRequest.class,responseJson);
}"
48316,"public ApiStackServiceList getStackWithCompAndConfigs(String stackName,String stackVersion) throws AmbariApiException {
  return null;
}","@Override public ApiStackServiceList getStackWithCompAndConfigs(String stackName,String stackVersion) throws AmbariApiException {
  return null;
}"
48317,"public String healthCheck() throws AmbariApiException {
  Response response=null;
  try {
    response=apiResourceRootV1.getHealthCheckResource().check();
  }
 catch (  Exception e) {
    throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
  }
  String healthStatus=handleAmbariResponse(response);
  return healthStatus;
}","@Override public String healthCheck() throws AmbariApiException {
  Response response=null;
  try {
    response=apiResourceRootV1.getHealthCheckResource().check();
  }
 catch (  Exception e) {
    throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
  }
  String healthStatus=handleAmbariResponse(response);
  return healthStatus;
}"
48318,"public void validateRolesForShrink(NodeGroupInfo groupInfo) throws SoftwareManagementPluginException {
  ValidateRolesUtil.validateRolesForShrink(AmUtils.getConfDir(),groupInfo);
}","@Override public void validateRolesForShrink(NodeGroupInfo groupInfo) throws SoftwareManagementPluginException {
  ValidateRolesUtil.validateRolesForShrink(AmUtils.getConfDir(),groupInfo);
}"
48319,"@Override public boolean createCluster(ClusterBlueprint blueprint,ClusterReportQueue reportQueue) throws SoftwareManagementPluginException {
  boolean success=false;
  AmClusterDef clusterDef=null;
  try {
    logger.info(""String_Node_Str"");
    logger.info(ApiUtils.objectToJson(blueprint));
    logger.info(""String_Node_Str"" + blueprint.getName() + ""String_Node_Str"");
    setHaseRegionConfig(blueprint);
    logger.info(""String_Node_Str"");
    logger.info(ApiUtils.objectToJson(blueprint));
    String ambariServerVersion=getVersion();
    clusterDef=new AmClusterDef(blueprint,privateKey,ambariServerVersion);
    logger.info(""String_Node_Str"" + ApiUtils.objectToJson(clusterDef));
    ReflectionUtils.getPreStartServicesHook().preStartServices(clusterDef.getName());
    provisionCluster(clusterDef,reportQueue);
    success=true;
    Map<String,NodeReport> nodeReports=clusterDef.getCurrentReport().getNodeReports();
    for (    String nodeReportKey : nodeReports.keySet()) {
      nodeReports.get(nodeReportKey).setUseClusterMsg(true);
    }
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setProgress(ProgressSplit.PROVISION_SUCCESS.getProgress());
    clusterDef.getCurrentReport().setSuccess(success);
  }
 catch (  Exception e) {
    clusterDef.getCurrentReport().setSuccess(success);
    logger.error(""String_Node_Str"" + blueprint.getName(),e);
    throw SoftwareManagementPluginException.CREATE_CLUSTER_EXCEPTION(e,Constants.AMBARI_PLUGIN_NAME,blueprint.getName());
  }
 finally {
    clusterDef.getCurrentReport().setFinished(true);
    if (success) {
      clusterDef.getCurrentReport().setClusterAndNodesServiceStatus(ServiceStatus.STARTED);
    }
    reportStatus(clusterDef.getCurrentReport(),reportQueue);
  }
  return success;
}","@Override public boolean createCluster(ClusterBlueprint blueprint,ClusterReportQueue reportQueue) throws SoftwareManagementPluginException {
  boolean success=false;
  AmClusterDef clusterDef=null;
  try {
    logger.info(""String_Node_Str"");
    logger.info(ApiUtils.objectToJson(blueprint));
    logger.info(""String_Node_Str"" + blueprint.getName() + ""String_Node_Str"");
    setHaseRegionConfig(blueprint);
    logger.info(""String_Node_Str"");
    logger.info(ApiUtils.objectToJson(blueprint));
    String ambariServerVersion=getVersion();
    clusterDef=new AmClusterDef(blueprint,privateKey,ambariServerVersion);
    ReflectionUtils.getPreStartServicesHook().preStartServices(clusterDef.getName());
    provisionCluster(clusterDef,reportQueue);
    success=true;
    Map<String,NodeReport> nodeReports=clusterDef.getCurrentReport().getNodeReports();
    for (    String nodeReportKey : nodeReports.keySet()) {
      nodeReports.get(nodeReportKey).setUseClusterMsg(true);
    }
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setProgress(ProgressSplit.PROVISION_SUCCESS.getProgress());
    clusterDef.getCurrentReport().setSuccess(success);
  }
 catch (  Exception e) {
    clusterDef.getCurrentReport().setSuccess(success);
    logger.error(""String_Node_Str"" + blueprint.getName(),e);
    throw SoftwareManagementPluginException.CREATE_CLUSTER_EXCEPTION(e,Constants.AMBARI_PLUGIN_NAME,blueprint.getName());
  }
 finally {
    clusterDef.getCurrentReport().setFinished(true);
    if (success) {
      clusterDef.getCurrentReport().setClusterAndNodesServiceStatus(ServiceStatus.STARTED);
    }
    reportStatus(clusterDef.getCurrentReport(),reportQueue);
  }
  return success;
}"
48320,"/** 
 * Set HBASE_REGIONSERVER_OPTS for ambari hbase regionserver
 * @param configList
 * @param group
 */
private void setHbaseAmbariRegionServerOpts(List<ApiConfiguration> configList,NodeGroupInfo group){
  String configurationType=""String_Node_Str"";
  Map<String,Object> conf=group.getConfiguration();
  if (conf == null) {
    conf=new HashMap<String,Object>();
    group.setConfiguration(conf);
  }
  Map<String,Object> confHbaseEnv=(Map<String,Object>)conf.get(configurationType);
  if (confHbaseEnv == null) {
    confHbaseEnv=new HashMap<String,Object>();
    conf.put(configurationType,confHbaseEnv);
  }
  if (confHbaseEnv.get(""String_Node_Str"") == null) {
    long hbaseHeapsizeMhz=HbaseRegionServerOptsUtil.getHeapSizeMhz((long)group.getMemorySize(),group.getRoles().size());
    confHbaseEnv.put(""String_Node_Str"",String.valueOf(hbaseHeapsizeMhz) + ""String_Node_Str"");
  }
  if (confHbaseEnv.get(""String_Node_Str"") == null)   confHbaseEnv.put(""String_Node_Str"",""String_Node_Str"");
  if (confHbaseEnv.get(""String_Node_Str"") == null) {
    String hbase_env_template=null;
    for (    ApiConfiguration tmp : configList) {
      if (tmp.getApiConfigurationInfo().getType().contains(configurationType)) {
        hbase_env_template=tmp.getApiConfigurationInfo().getPropertyValue();
        hbase_env_template=hbase_env_template.replaceAll(""String_Node_Str"",""String_Node_Str"");
        hbase_env_template=hbase_env_template + HbaseRegionServerOptsUtil.getAmbariHbaseRegionServerStringParameter();
        break;
      }
    }
    confHbaseEnv.put(""String_Node_Str"",hbase_env_template);
    logger.info(""String_Node_Str"" + confHbaseEnv.get(""String_Node_Str""));
    logger.info(""String_Node_Str"" + confHbaseEnv.get(""String_Node_Str""));
    logger.info(""String_Node_Str"" + confHbaseEnv.get(""String_Node_Str""));
  }
}","/** 
 * Set HBASE_REGIONSERVER_OPTS for ambari hbase regionserver
 * @param configList
 * @param group
 */
private void setHbaseAmbariRegionServerOpts(List<ApiConfiguration> configList,NodeGroupInfo group){
  String configurationType=""String_Node_Str"";
  Map<String,Object> conf=group.getConfiguration();
  if (conf == null) {
    conf=new HashMap<String,Object>();
    group.setConfiguration(conf);
  }
  Map<String,Object> confHbaseEnv=(Map<String,Object>)conf.get(configurationType);
  if (confHbaseEnv == null) {
    confHbaseEnv=new HashMap<String,Object>();
    conf.put(configurationType,confHbaseEnv);
  }
  if (confHbaseEnv.get(""String_Node_Str"") == null) {
    long hbaseHeapsizeMhz=HbaseRegionServerOptsUtil.getHeapSizeMhz(group.getMemorySize(),group.getRoles().size());
    confHbaseEnv.put(""String_Node_Str"",String.valueOf(hbaseHeapsizeMhz) + ""String_Node_Str"");
  }
  if (confHbaseEnv.get(""String_Node_Str"") == null)   confHbaseEnv.put(""String_Node_Str"",""String_Node_Str"");
  if (confHbaseEnv.get(""String_Node_Str"") == null) {
    String hbase_env_template=null;
    for (    ApiConfiguration tmp : configList) {
      if (tmp.getApiConfigurationInfo().getType().contains(configurationType)) {
        hbase_env_template=tmp.getApiConfigurationInfo().getPropertyValue();
        hbase_env_template=hbase_env_template.replaceAll(""String_Node_Str"",""String_Node_Str"");
        hbase_env_template=hbase_env_template + HbaseRegionServerOptsUtil.getAmbariHbaseRegionServerStringParameter();
        break;
      }
    }
    confHbaseEnv.put(""String_Node_Str"",hbase_env_template);
    logger.info(""String_Node_Str"" + confHbaseEnv.get(""String_Node_Str""));
    logger.info(""String_Node_Str"" + confHbaseEnv.get(""String_Node_Str""));
    logger.info(""String_Node_Str"" + confHbaseEnv.get(""String_Node_Str""));
  }
}"
48321,"@Override @SuppressWarnings(""String_Node_Str"") public ClusterRead toClusterRead(String clusterName,boolean ignoreObsoleteNode){
  ClusterEntity cluster=findByName(clusterName);
  if (cluster == null) {
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ClusterStatus clusterStatus=cluster.getStatus();
  ClusterRead clusterRead=new ClusterRead();
  clusterRead.setInstanceNum(cluster.getRealInstanceNum(ignoreObsoleteNode));
  clusterRead.setName(cluster.getName());
  clusterRead.setStatus(clusterStatus);
  clusterRead.setAppManager(cluster.getAppManager());
  clusterRead.setDistro(cluster.getDistro());
  clusterRead.setDistroVendor(cluster.getDistroVendor());
  clusterRead.setTopologyPolicy(cluster.getTopologyPolicy());
  clusterRead.setTemplateName(nodeTemplateDAO.findByMoid(cluster.getTemplateId()).getName());
  clusterRead.setAutomationEnable(cluster.getAutomationEnable());
  clusterRead.setVhmMinNum(cluster.getVhmMinNum());
  clusterRead.setVhmMaxNum(cluster.getVhmMaxNum());
  clusterRead.setVhmTargetNum(cluster.getVhmTargetNum());
  clusterRead.setIoShares(cluster.getIoShares());
  clusterRead.setVersion(cluster.getVersion());
  if (!CommonUtil.isBlank(cluster.getAdvancedProperties())) {
    Gson gson=new Gson();
    Map<String,String> advancedProperties=gson.fromJson(cluster.getAdvancedProperties(),Map.class);
    clusterRead.setExternalHDFS(advancedProperties.get(""String_Node_Str""));
    clusterRead.setExternalMapReduce(advancedProperties.get(""String_Node_Str""));
    clusterRead.setLocalRepoURL(advancedProperties.get(""String_Node_Str""));
    clusterRead.setClusterCloneType(advancedProperties.get(""String_Node_Str""));
    clusterRead.setExternalNamenode(advancedProperties.get(""String_Node_Str""));
    clusterRead.setExternalSecondaryNamenode(advancedProperties.get(""String_Node_Str""));
    if (advancedProperties.get(""String_Node_Str"") != null) {
      clusterRead.setExternalDatanodes(gson.fromJson(gson.toJson(advancedProperties.get(""String_Node_Str"")),HashSet.class));
    }
  }
  String cloneType=clusterRead.getClusterCloneType();
  if (CommonUtil.isBlank(cloneType)) {
    clusterRead.setClusterCloneType(Constants.CLUSTER_CLONE_TYPE_FAST_CLONE);
  }
  SoftwareManager softMgr=null;
  try {
    softMgr=softwareManagerCollector.getSoftwareManager(cluster.getAppManager());
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"");
  }
  List<NodeGroupRead> groupList=new ArrayList<NodeGroupRead>();
  for (  NodeGroupEntity group : cluster.getNodeGroups()) {
    NodeGroupRead groupRead=group.toNodeGroupRead(ignoreObsoleteNode);
    groupRead.setComputeOnly(false);
    try {
      groupRead.setComputeOnly(softMgr.isComputeOnlyRoles(groupRead.getRoles()));
    }
 catch (    Exception e) {
    }
    groupList.add(groupRead);
  }
  clusterRead.setNodeGroups(groupList);
  Set<VcResourcePoolEntity> rps=cluster.getUsedRps();
  List<ResourcePoolRead> rpReads=new ArrayList<ResourcePoolRead>(rps.size());
  for (  VcResourcePoolEntity rp : rps) {
    ResourcePoolRead rpRead=rp.toRest();
    rpRead.setNodes(null);
    rpReads.add(rpRead);
  }
  clusterRead.setResourcePools(rpReads);
  if (clusterStatus.isActiveServiceStatus() || clusterStatus == ClusterStatus.STOPPED) {
    clusterRead.setDcSeperation(clusterRead.validateSetManualElasticity());
  }
  if (StringUtils.isNotBlank(cluster.getInfraConfig())) {
    clusterRead.setInfrastructure_config(InfrastructureConfigUtils.read(cluster.getInfraConfig()));
  }
  return clusterRead;
}","@Override @SuppressWarnings(""String_Node_Str"") public ClusterRead toClusterRead(String clusterName,boolean withNodesList,boolean ignoreObsoleteNode){
  ClusterEntity cluster=findByName(clusterName);
  if (cluster == null) {
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ClusterStatus clusterStatus=cluster.getStatus();
  ClusterRead clusterRead=new ClusterRead();
  clusterRead.setInstanceNum(cluster.getRealInstanceNum(ignoreObsoleteNode));
  clusterRead.setName(cluster.getName());
  clusterRead.setStatus(clusterStatus);
  clusterRead.setAppManager(cluster.getAppManager());
  clusterRead.setDistro(cluster.getDistro());
  clusterRead.setDistroVendor(cluster.getDistroVendor());
  clusterRead.setTopologyPolicy(cluster.getTopologyPolicy());
  clusterRead.setTemplateName(nodeTemplateDAO.findByMoid(cluster.getTemplateId()).getName());
  clusterRead.setAutomationEnable(cluster.getAutomationEnable());
  clusterRead.setVhmMinNum(cluster.getVhmMinNum());
  clusterRead.setVhmMaxNum(cluster.getVhmMaxNum());
  clusterRead.setVhmTargetNum(cluster.getVhmTargetNum());
  clusterRead.setIoShares(cluster.getIoShares());
  clusterRead.setVersion(cluster.getVersion());
  if (!CommonUtil.isBlank(cluster.getAdvancedProperties())) {
    Gson gson=new Gson();
    Map<String,String> advancedProperties=gson.fromJson(cluster.getAdvancedProperties(),Map.class);
    clusterRead.setExternalHDFS(advancedProperties.get(""String_Node_Str""));
    clusterRead.setExternalMapReduce(advancedProperties.get(""String_Node_Str""));
    clusterRead.setLocalRepoURL(advancedProperties.get(""String_Node_Str""));
    clusterRead.setClusterCloneType(advancedProperties.get(""String_Node_Str""));
    clusterRead.setExternalNamenode(advancedProperties.get(""String_Node_Str""));
    clusterRead.setExternalSecondaryNamenode(advancedProperties.get(""String_Node_Str""));
    if (advancedProperties.get(""String_Node_Str"") != null) {
      clusterRead.setExternalDatanodes(gson.fromJson(gson.toJson(advancedProperties.get(""String_Node_Str"")),HashSet.class));
    }
  }
  String cloneType=clusterRead.getClusterCloneType();
  if (CommonUtil.isBlank(cloneType)) {
    clusterRead.setClusterCloneType(Constants.CLUSTER_CLONE_TYPE_FAST_CLONE);
  }
  SoftwareManager softMgr=null;
  try {
    softMgr=softwareManagerCollector.getSoftwareManager(cluster.getAppManager());
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"");
  }
  List<NodeGroupRead> groupList=new ArrayList<NodeGroupRead>();
  for (  NodeGroupEntity group : cluster.getNodeGroups()) {
    NodeGroupRead groupRead=group.toNodeGroupRead(withNodesList,ignoreObsoleteNode);
    groupRead.setComputeOnly(false);
    try {
      groupRead.setComputeOnly(softMgr.isComputeOnlyRoles(groupRead.getRoles()));
    }
 catch (    Exception e) {
    }
    groupList.add(groupRead);
  }
  clusterRead.setNodeGroups(groupList);
  Set<VcResourcePoolEntity> rps=cluster.getUsedRps();
  List<ResourcePoolRead> rpReads=new ArrayList<ResourcePoolRead>(rps.size());
  for (  VcResourcePoolEntity rp : rps) {
    ResourcePoolRead rpRead=rp.toRest();
    rpRead.setNodes(null);
    rpReads.add(rpRead);
  }
  clusterRead.setResourcePools(rpReads);
  if (clusterStatus.isActiveServiceStatus() || clusterStatus == ClusterStatus.STOPPED) {
    clusterRead.setDcSeperation(clusterRead.validateSetManualElasticity());
  }
  if (StringUtils.isNotBlank(cluster.getInfraConfig())) {
    clusterRead.setInfrastructure_config(InfrastructureConfigUtils.read(cluster.getInfraConfig()));
  }
  return clusterRead;
}"
48322,"public Map<String,String> getRackTopology(String clusterName,String topology){
  ClusterRead cluster=clusterEntityMgr.toClusterRead(clusterName);
  Set<String> hosts=new HashSet<String>();
  List<NodeRead> nodes=new ArrayList<NodeRead>();
  for (  NodeGroupRead nodeGroup : cluster.getNodeGroups()) {
    for (    NodeRead node : nodeGroup.getInstances()) {
      if (node.getMoId() != null) {
        hosts.add(node.getHostName());
        nodes.add(node);
      }
    }
  }
  if (CommonUtil.isBlank(topology)) {
    topology=cluster.getTopologyPolicy().toString();
  }
  AuAssert.check(hosts.size() > 0);
  clusterConfigMgr.validateRackTopologyUploaded(hosts,topology);
  return clusterConfigMgr.buildTopology(nodes,topology);
}","public Map<String,String> getRackTopology(String clusterName,String topology){
  ClusterRead cluster=clusterEntityMgr.toClusterRead(clusterName,true);
  Set<String> hosts=new HashSet<String>();
  List<NodeRead> nodes=new ArrayList<NodeRead>();
  for (  NodeGroupRead nodeGroup : cluster.getNodeGroups()) {
    for (    NodeRead node : nodeGroup.getInstances()) {
      if (node.getMoId() != null) {
        hosts.add(node.getHostName());
        nodes.add(node);
      }
    }
  }
  if (CommonUtil.isBlank(topology)) {
    topology=cluster.getTopologyPolicy().toString();
  }
  AuAssert.check(hosts.size() > 0);
  clusterConfigMgr.validateRackTopologyUploaded(hosts,topology);
  return clusterConfigMgr.buildTopology(nodes,topology);
}"
48323,"public ClusterRead getClusterByName(String clusterName,boolean realTime){
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (realTime && cluster.getStatus().isSyncServiceStatus()) {
    refreshClusterStatus(clusterName);
  }
  return clusterEntityMgr.toClusterRead(clusterName);
}","public ClusterRead getClusterByName(String clusterName,boolean realTime){
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  java.util.Date startTime=new java.util.Date();
  if (realTime && cluster.getStatus().isSyncServiceStatus()) {
    refreshClusterStatus(clusterName);
  }
  logger.debug(""String_Node_Str"" + (new java.util.Date().getTime() - startTime.getTime()));
  return clusterEntityMgr.toClusterRead(clusterName,realTime);
}"
48324,"public List<ClusterRead> getClusters(Boolean realTime){
  List<ClusterRead> clusters=new ArrayList<ClusterRead>();
  List<ClusterEntity> clusterEntities=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity entity : clusterEntities) {
    clusters.add(getClusterByName(entity.getName(),realTime));
  }
  return clusters;
}","public List<ClusterRead> getClusters(Boolean realTime){
  java.util.Date startTime=new java.util.Date();
  List<ClusterRead> clusters=new ArrayList<ClusterRead>();
  List<ClusterEntity> clusterEntities=clusterEntityMgr.findAllClusters();
  logger.debug(""String_Node_Str"" + (new java.util.Date().getTime() - startTime.getTime()));
  for (  ClusterEntity entity : clusterEntities) {
    clusters.add(getClusterByName(entity.getName(),realTime));
  }
  logger.debug(""String_Node_Str"" + (new java.util.Date().getTime() - startTime.getTime()));
  return clusters;
}"
48325,"public ClusterRead toClusterRead(String clusterName,boolean ignoreObsoleteNode);","public ClusterRead toClusterRead(String clusterName,boolean withNodesList,boolean ignoreObsoleteNode);"
48326,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test(groups={""String_Node_Str""}) public void testClusterConfigWithExternalHDFS() throws Exception {
  String[] hdfsArray=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  spec.setNetworkConfig(createNetConfigs());
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  spec.setExternalHDFS(hdfsArray[0]);
  String clusterConfigJson=""String_Node_Str"" + hdfsArray[1] + ""String_Node_Str"";
  Map clusterConfig=(new Gson()).fromJson(clusterConfigJson,Map.class);
  spec.setConfiguration((Map<String,Object>)(clusterConfig.get(""String_Node_Str"")));
  NodeGroupCreate ng0=new NodeGroupCreate();
  List<String> computerMasterRoles=new ArrayList<String>();
  computerMasterRoles.add(""String_Node_Str"");
  ng0.setRoles(computerMasterRoles);
  ng0.setName(""String_Node_Str"");
  ng0.setInstanceNum(1);
  ng0.setInstanceType(InstanceType.LARGE);
  String ng0ConfigJson=""String_Node_Str"" + hdfsArray[2] + ""String_Node_Str"";
  Map ng0Config=(new Gson()).fromJson(ng0ConfigJson,Map.class);
  ng0.setConfiguration((Map<String,Object>)(ng0Config.get(""String_Node_Str"")));
  NodeGroupCreate ng1=new NodeGroupCreate();
  List<String> computeWorkerRoles=new ArrayList<String>();
  computeWorkerRoles.add(""String_Node_Str"");
  ng1.setRoles(computeWorkerRoles);
  ng1.setName(""String_Node_Str"");
  ng1.setInstanceNum(4);
  ng1.setInstanceType(InstanceType.MEDIUM);
  StorageRead storage=new StorageRead();
  storage.setType(""String_Node_Str"");
  storage.setSizeGB(10);
  ng1.setStorage(storage);
  String ng1ConfigJson=""String_Node_Str"" + hdfsArray[3] + ""String_Node_Str"";
  Map ng1Config=(new Gson()).fromJson(ng1ConfigJson,Map.class);
  ng1.setConfiguration((Map<String,Object>)(ng1Config.get(""String_Node_Str"")));
  NodeGroupCreate ng2=new NodeGroupCreate();
  ng2.setRoles(computeWorkerRoles);
  ng2.setName(""String_Node_Str"");
  ng2.setInstanceNum(2);
  ng2.setInstanceType(InstanceType.MEDIUM);
  StorageRead storageCompute=new StorageRead();
  storageCompute.setType(""String_Node_Str"");
  storageCompute.setSizeGB(10);
  ng2.setStorage(storageCompute);
  NodeGroupCreate[] ngs=new NodeGroupCreate[]{ng0,ng1,ng2};
  spec.setNodeGroups(ngs);
  spec=ClusterSpecFactory.getCustomizedSpec(spec,null);
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findClusterById(1l);
  List<ClusterEntity> cs=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity c : cs) {
    System.out.println(c.getId());
  }
  cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  Assert.assertEquals(cluster.getAdvancedProperties(),""String_Node_Str"");
  ClusterRead clusterRead=clusterEntityMgr.toClusterRead(""String_Node_Str"");
  Assert.assertEquals(clusterRead.getExternalHDFS(),""String_Node_Str"");
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(Pattern.compile(""String_Node_Str"" + hdfsArray[0] + ""String_Node_Str"").matcher(manifest).matches(),""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[1]) == -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[2]) == -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[3]) == -1,""String_Node_Str"");
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test(groups={""String_Node_Str""}) public void testClusterConfigWithExternalHDFS() throws Exception {
  String[] hdfsArray=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  spec.setNetworkConfig(createNetConfigs());
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  spec.setExternalHDFS(hdfsArray[0]);
  String clusterConfigJson=""String_Node_Str"" + hdfsArray[1] + ""String_Node_Str"";
  Map clusterConfig=(new Gson()).fromJson(clusterConfigJson,Map.class);
  spec.setConfiguration((Map<String,Object>)(clusterConfig.get(""String_Node_Str"")));
  NodeGroupCreate ng0=new NodeGroupCreate();
  List<String> computerMasterRoles=new ArrayList<String>();
  computerMasterRoles.add(""String_Node_Str"");
  ng0.setRoles(computerMasterRoles);
  ng0.setName(""String_Node_Str"");
  ng0.setInstanceNum(1);
  ng0.setInstanceType(InstanceType.LARGE);
  String ng0ConfigJson=""String_Node_Str"" + hdfsArray[2] + ""String_Node_Str"";
  Map ng0Config=(new Gson()).fromJson(ng0ConfigJson,Map.class);
  ng0.setConfiguration((Map<String,Object>)(ng0Config.get(""String_Node_Str"")));
  NodeGroupCreate ng1=new NodeGroupCreate();
  List<String> computeWorkerRoles=new ArrayList<String>();
  computeWorkerRoles.add(""String_Node_Str"");
  ng1.setRoles(computeWorkerRoles);
  ng1.setName(""String_Node_Str"");
  ng1.setInstanceNum(4);
  ng1.setInstanceType(InstanceType.MEDIUM);
  StorageRead storage=new StorageRead();
  storage.setType(""String_Node_Str"");
  storage.setSizeGB(10);
  ng1.setStorage(storage);
  String ng1ConfigJson=""String_Node_Str"" + hdfsArray[3] + ""String_Node_Str"";
  Map ng1Config=(new Gson()).fromJson(ng1ConfigJson,Map.class);
  ng1.setConfiguration((Map<String,Object>)(ng1Config.get(""String_Node_Str"")));
  NodeGroupCreate ng2=new NodeGroupCreate();
  ng2.setRoles(computeWorkerRoles);
  ng2.setName(""String_Node_Str"");
  ng2.setInstanceNum(2);
  ng2.setInstanceType(InstanceType.MEDIUM);
  StorageRead storageCompute=new StorageRead();
  storageCompute.setType(""String_Node_Str"");
  storageCompute.setSizeGB(10);
  ng2.setStorage(storageCompute);
  NodeGroupCreate[] ngs=new NodeGroupCreate[]{ng0,ng1,ng2};
  spec.setNodeGroups(ngs);
  spec=ClusterSpecFactory.getCustomizedSpec(spec,null);
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findClusterById(1l);
  List<ClusterEntity> cs=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity c : cs) {
    System.out.println(c.getId());
  }
  cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  Assert.assertEquals(cluster.getAdvancedProperties(),""String_Node_Str"");
  ClusterRead clusterRead=clusterEntityMgr.toClusterRead(""String_Node_Str"",true);
  Assert.assertEquals(clusterRead.getExternalHDFS(),""String_Node_Str"");
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(Pattern.compile(""String_Node_Str"" + hdfsArray[0] + ""String_Node_Str"").matcher(manifest).matches(),""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[1]) == -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[2]) == -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[3]) == -1,""String_Node_Str"");
}"
48327,"@Test(groups={""String_Node_Str""}) public void testClusterConfigWithExternalMapReduce() throws Exception {
  String externalMR=""String_Node_Str"";
  String externalHDFS=""String_Node_Str"";
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  spec.setNetworkConfig(createNetConfigs());
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  spec.setExternalMapReduce(externalMR);
  spec.setExternalHDFS(externalHDFS);
  String clusterConfigJson=""String_Node_Str"" + externalMR + ""String_Node_Str""+ externalHDFS+ ""String_Node_Str"";
  Map clusterConfig=(new Gson()).fromJson(clusterConfigJson,Map.class);
  spec.setConfiguration((Map<String,Object>)(clusterConfig.get(""String_Node_Str"")));
  NodeGroupCreate worker=new NodeGroupCreate();
  List<String> computeRoles=new ArrayList<String>();
  computeRoles.add(""String_Node_Str"");
  worker.setRoles(computeRoles);
  worker.setName(""String_Node_Str"");
  worker.setInstanceNum(2);
  worker.setInstanceType(InstanceType.MEDIUM);
  StorageRead storage=new StorageRead();
  storage.setType(""String_Node_Str"");
  storage.setSizeGB(10);
  worker.setStorage(storage);
  spec.setNodeGroups(new NodeGroupCreate[]{worker});
  spec=ClusterSpecFactory.getCustomizedSpec(spec,null);
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  Assert.assertEquals(cluster.getAdvancedProperties(),""String_Node_Str"");
  ClusterRead clusterRead=clusterEntityMgr.toClusterRead(""String_Node_Str"");
  Assert.assertEquals(clusterRead.getExternalHDFS(),""String_Node_Str"");
  Assert.assertEquals(clusterRead.getExternalMapReduce(),""String_Node_Str"");
}","@Test(groups={""String_Node_Str""}) public void testClusterConfigWithExternalMapReduce() throws Exception {
  String externalMR=""String_Node_Str"";
  String externalHDFS=""String_Node_Str"";
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  spec.setNetworkConfig(createNetConfigs());
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  spec.setExternalMapReduce(externalMR);
  spec.setExternalHDFS(externalHDFS);
  String clusterConfigJson=""String_Node_Str"" + externalMR + ""String_Node_Str""+ externalHDFS+ ""String_Node_Str"";
  Map clusterConfig=(new Gson()).fromJson(clusterConfigJson,Map.class);
  spec.setConfiguration((Map<String,Object>)(clusterConfig.get(""String_Node_Str"")));
  NodeGroupCreate worker=new NodeGroupCreate();
  List<String> computeRoles=new ArrayList<String>();
  computeRoles.add(""String_Node_Str"");
  worker.setRoles(computeRoles);
  worker.setName(""String_Node_Str"");
  worker.setInstanceNum(2);
  worker.setInstanceType(InstanceType.MEDIUM);
  StorageRead storage=new StorageRead();
  storage.setType(""String_Node_Str"");
  storage.setSizeGB(10);
  worker.setStorage(storage);
  spec.setNodeGroups(new NodeGroupCreate[]{worker});
  spec=ClusterSpecFactory.getCustomizedSpec(spec,null);
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  Assert.assertEquals(cluster.getAdvancedProperties(),""String_Node_Str"");
  ClusterRead clusterRead=clusterEntityMgr.toClusterRead(""String_Node_Str"",true);
  Assert.assertEquals(clusterRead.getExternalHDFS(),""String_Node_Str"");
  Assert.assertEquals(clusterRead.getExternalMapReduce(),""String_Node_Str"");
}"
48328,"public NodeGroupRead toNodeGroupRead(boolean ignoreObsoleteNode){
  NodeGroupRead nodeGroupRead=new NodeGroupRead();
  nodeGroupRead.setName(this.name);
  nodeGroupRead.setCpuNum(this.cpuNum);
  nodeGroupRead.setMemCapacityMB(this.memorySize);
  nodeGroupRead.setSwapRatio(this.swapRatio);
  nodeGroupRead.setInstanceNum(this.getRealInstanceNum(ignoreObsoleteNode));
  Gson gson=new Gson();
  @SuppressWarnings(""String_Node_Str"") List<String> groupRoles=gson.fromJson(roles,List.class);
  nodeGroupRead.setRoles(groupRoles);
  StorageRead storage=new StorageRead();
  storage.setType(this.storageType.toString());
  storage.setSizeGB(this.storageSize);
  storage.setDiskNum(this.diskNum);
  storage.setShareDatastore(this.shareDatastore);
  List<String> datastoreNameList=getVcDatastoreNameList();
  if (datastoreNameList != null && !datastoreNameList.isEmpty())   storage.setDsNames(datastoreNameList);
  if (getSdDatastoreNameList() != null && !getSdDatastoreNameList().isEmpty())   storage.setDsNames4System(getSdDatastoreNameList());
  if (getDdDatastoreNameList() != null && !getDdDatastoreNameList().isEmpty())   storage.setDsNames4Data(getDdDatastoreNameList());
  nodeGroupRead.setStorage(storage);
  List<NodeRead> nodeList=new ArrayList<NodeRead>();
  for (  NodeEntity node : this.nodes) {
    if (ignoreObsoleteNode && (node.isObsoleteNode() || node.isDisconnected())) {
      continue;
    }
    nodeList.add(node.toNodeRead(true));
  }
  nodeGroupRead.setInstances(nodeList);
  List<GroupAssociation> associations=new ArrayList<GroupAssociation>();
  for (  NodeGroupAssociation relation : groupAssociations) {
    GroupAssociation association=new GroupAssociation();
    association.setReference(relation.getReferencedGroup());
    association.setType(relation.getAssociationType());
    associations.add(association);
  }
  PlacementPolicy policy=new PlacementPolicy();
  policy.setInstancePerHost(instancePerHost);
  policy.setGroupAssociations(associations);
  policy.setGroupRacks(new Gson().fromJson(groupRacks,GroupRacks.class));
  nodeGroupRead.setPlacementPolicies(policy);
  return nodeGroupRead;
}","public NodeGroupRead toNodeGroupRead(boolean withNodesList,boolean ignoreObsoleteNode){
  NodeGroupRead nodeGroupRead=new NodeGroupRead();
  nodeGroupRead.setName(this.name);
  nodeGroupRead.setCpuNum(this.cpuNum);
  nodeGroupRead.setMemCapacityMB(this.memorySize);
  nodeGroupRead.setSwapRatio(this.swapRatio);
  nodeGroupRead.setInstanceNum(this.getRealInstanceNum(ignoreObsoleteNode));
  Gson gson=new Gson();
  @SuppressWarnings(""String_Node_Str"") List<String> groupRoles=gson.fromJson(roles,List.class);
  nodeGroupRead.setRoles(groupRoles);
  StorageRead storage=new StorageRead();
  storage.setType(this.storageType.toString());
  storage.setSizeGB(this.storageSize);
  storage.setDiskNum(this.diskNum);
  storage.setShareDatastore(this.shareDatastore);
  List<String> datastoreNameList=getVcDatastoreNameList();
  if (datastoreNameList != null && !datastoreNameList.isEmpty())   storage.setDsNames(datastoreNameList);
  if (getSdDatastoreNameList() != null && !getSdDatastoreNameList().isEmpty())   storage.setDsNames4System(getSdDatastoreNameList());
  if (getDdDatastoreNameList() != null && !getDdDatastoreNameList().isEmpty())   storage.setDsNames4Data(getDdDatastoreNameList());
  nodeGroupRead.setStorage(storage);
  if (withNodesList) {
    List<NodeRead> nodeList=new ArrayList<NodeRead>();
    for (    NodeEntity node : this.nodes) {
      if (ignoreObsoleteNode && (node.isObsoleteNode() || node.isDisconnected())) {
        continue;
      }
      nodeList.add(node.toNodeRead(true));
    }
    nodeGroupRead.setInstances(nodeList);
  }
  List<GroupAssociation> associations=new ArrayList<GroupAssociation>();
  for (  NodeGroupAssociation relation : groupAssociations) {
    GroupAssociation association=new GroupAssociation();
    association.setReference(relation.getReferencedGroup());
    association.setType(relation.getAssociationType());
    associations.add(association);
  }
  PlacementPolicy policy=new PlacementPolicy();
  policy.setInstancePerHost(instancePerHost);
  policy.setGroupAssociations(associations);
  policy.setGroupRacks(new Gson().fromJson(groupRacks,GroupRacks.class));
  nodeGroupRead.setPlacementPolicies(policy);
  return nodeGroupRead;
}"
48329,"private TaskRead processResponse(ResponseEntity<String> response,HttpMethod verb,PrettyOutput... prettyOutput) throws Exception {
  HttpStatus responseStatus=response.getStatusCode();
  if (responseStatus == HttpStatus.ACCEPTED) {
    HttpHeaders headers=response.getHeaders();
    URI taskURI=headers.getLocation();
    String[] taskURIs=taskURI.toString().split(""String_Node_Str"");
    String taskId=taskURIs[taskURIs.length - 1];
    TaskRead taskRead;
    int oldProgress=0;
    Status oldTaskStatus=null;
    Status taskStatus=null;
    int progress=0;
    do {
      ResponseEntity<TaskRead> taskResponse=restGetById(Constants.REST_PATH_TASK,taskId,TaskRead.class,false);
      taskRead=taskResponse.getBody();
      progress=(int)(taskRead.getProgress() * 100);
      taskStatus=taskRead.getStatus();
      Type taskType=taskRead.getType();
      if ((taskType == Type.DELETE) && (taskStatus == TaskRead.Status.COMPLETED)) {
        clearScreen();
        System.out.println(taskStatus + ""String_Node_Str"" + progress+ ""String_Node_Str"");
        break;
      }
      if (taskType == Type.SHRINK && !taskRead.getFailNodes().isEmpty()) {
        throw new CliRestException(taskRead.getFailNodes().get(0).getErrorMessage());
      }
      if ((prettyOutput != null && prettyOutput.length > 0 && (taskRead.getType() == Type.VHM ? prettyOutput[0].isRefresh(true) : prettyOutput[0].isRefresh(false))) || oldTaskStatus != taskStatus || oldProgress != progress) {
        clearScreen();
        if (prettyOutput != null && prettyOutput.length > 0 && prettyOutput[0].getCompletedTaskSummary() != null) {
          for (          String summary : prettyOutput[0].getCompletedTaskSummary()) {
            System.out.println(summary + ""String_Node_Str"");
          }
        }
        System.out.println(taskStatus + ""String_Node_Str"" + progress+ ""String_Node_Str"");
        if (prettyOutput != null && prettyOutput.length > 0) {
          prettyOutput[0].prettyOutput();
        }
        if (oldTaskStatus != taskStatus || oldProgress != progress) {
          oldTaskStatus=taskStatus;
          oldProgress=progress;
          if (taskRead.getProgressMessage() != null) {
            System.out.println(taskRead.getProgressMessage());
          }
        }
      }
      try {
        Thread.sleep(3 * 1000);
      }
 catch (      InterruptedException ex) {
      }
    }
 while (taskStatus != TaskRead.Status.COMPLETED && taskStatus != TaskRead.Status.FAILED && taskStatus != TaskRead.Status.ABANDONED && taskStatus != TaskRead.Status.STOPPED);
    String errorMsg=taskRead.getErrorMessage();
    if (!taskRead.getStatus().equals(TaskRead.Status.COMPLETED)) {
      throw new CliRestException(errorMsg);
    }
 else {
      if (taskRead.getType().equals(Type.VHM)) {
        logger.info(""String_Node_Str"");
        Thread.sleep(5 * 1000);
        if (prettyOutput != null && prettyOutput.length > 0 && prettyOutput[0].isRefresh(true)) {
          clearScreen();
          System.out.println(taskStatus + ""String_Node_Str"" + progress+ ""String_Node_Str"");
          if (prettyOutput != null && prettyOutput.length > 0) {
            prettyOutput[0].prettyOutput();
          }
        }
      }
 else {
        return taskRead;
      }
    }
  }
  return null;
}","private TaskRead processResponse(ResponseEntity<String> response,HttpMethod verb,PrettyOutput... prettyOutput) throws Exception {
  HttpStatus responseStatus=response.getStatusCode();
  if (responseStatus == HttpStatus.ACCEPTED) {
    HttpHeaders headers=response.getHeaders();
    URI taskURI=headers.getLocation();
    String[] taskURIs=taskURI.toString().split(""String_Node_Str"");
    String taskId=taskURIs[taskURIs.length - 1];
    TaskRead taskRead;
    int oldProgress=0;
    Status oldTaskStatus=null;
    Status taskStatus=null;
    int progress=0;
    do {
      ResponseEntity<TaskRead> taskResponse=restGetById(Constants.REST_PATH_TASK,taskId,TaskRead.class,false);
      taskRead=taskResponse.getBody();
      progress=(int)(taskRead.getProgress() * 100);
      taskStatus=taskRead.getStatus();
      Type taskType=taskRead.getType();
      if ((taskType == Type.DELETE) && (taskStatus == TaskRead.Status.COMPLETED)) {
        clearScreen();
        System.out.println(taskStatus + ""String_Node_Str"" + progress+ ""String_Node_Str"");
        break;
      }
      if (taskType == Type.SHRINK && !taskRead.getFailNodes().isEmpty()) {
        throw new CliRestException(taskRead.getFailNodes().get(0).getErrorMessage());
      }
      if ((prettyOutput != null && prettyOutput.length > 0 && prettyOutput[0].isRefresh(true)) || oldTaskStatus != taskStatus || oldProgress != progress) {
        clearScreen();
        if (prettyOutput != null && prettyOutput.length > 0 && prettyOutput[0].getCompletedTaskSummary() != null) {
          for (          String summary : prettyOutput[0].getCompletedTaskSummary()) {
            System.out.println(summary + ""String_Node_Str"");
          }
        }
        System.out.println(taskStatus + ""String_Node_Str"" + progress+ ""String_Node_Str"");
        if (prettyOutput != null && prettyOutput.length > 0) {
          prettyOutput[0].prettyOutput();
        }
        if (oldTaskStatus != taskStatus || oldProgress != progress) {
          oldTaskStatus=taskStatus;
          oldProgress=progress;
          if (taskRead.getProgressMessage() != null) {
            System.out.println(taskRead.getProgressMessage());
          }
        }
      }
      try {
        Thread.sleep(3 * 1000);
      }
 catch (      InterruptedException ex) {
      }
    }
 while (taskStatus != TaskRead.Status.COMPLETED && taskStatus != TaskRead.Status.FAILED && taskStatus != TaskRead.Status.ABANDONED && taskStatus != TaskRead.Status.STOPPED);
    String errorMsg=taskRead.getErrorMessage();
    if (!taskRead.getStatus().equals(TaskRead.Status.COMPLETED)) {
      throw new CliRestException(errorMsg);
    }
 else {
      if (taskRead.getType().equals(Type.VHM)) {
        logger.info(""String_Node_Str"");
        Thread.sleep(5 * 1000);
        if (prettyOutput != null && prettyOutput.length > 0 && prettyOutput[0].isRefresh(true)) {
          clearScreen();
          System.out.println(taskStatus + ""String_Node_Str"" + progress+ ""String_Node_Str"");
          if (prettyOutput != null && prettyOutput.length > 0) {
            prettyOutput[0].prettyOutput();
          }
        }
      }
 else {
        return taskRead;
      }
    }
  }
  return null;
}"
48330,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void addCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean nodeGroup,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume){
  try {
    if (resume) {
      resumeCreateCluster(name);
      CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_ADD + Constants.OUTPUT_OP_RESULT_SUCCEEDED);
      return;
    }
    if (!nodeGroup) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NOT_CONTAIN_SPECFILE);
      return;
    }
    if (specFilePath == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NOT_CONTAIN_SPECFILE);
      return;
    }
    ClusterRead cluster=restClient.get(name,false);
    if (cluster == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"" + name + ""String_Node_Str"");
      return;
    }
    NodeGroupAdd nodeGroupAdd=new NodeGroupAdd();
    NodeGroupAdd nodeGroupAddSpec=CommandsUtils.getObjectByJsonString(NodeGroupAdd.class,CommandsUtils.dataFromFile(specFilePath));
    nodeGroupAdd.setSpecFile(true);
    nodeGroupAdd.setNodeGroups(nodeGroupAddSpec.getNodeGroups());
    if (name.indexOf(""String_Node_Str"") != -1) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NODEGROUP + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
      return;
    }
 else     if (name.indexOf(""String_Node_Str"") != -1) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NODEGROUP + Constants.PARAM_NOT_CONTAIN_BLANK_SPACE);
      return;
    }
    restClient.addNodeGroups(name,nodeGroupAdd);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_ADD + Constants.OUTPUT_OP_RESULT_SUCCEEDED);
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void addCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=true,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean nodeGroup,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume){
  try {
    if (resume) {
      resumeCreateCluster(name);
      return;
    }
    if (!nodeGroup) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NOT_CONTAIN_SPECFILE);
      return;
    }
    if (specFilePath == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NOT_CONTAIN_SPECFILE);
      return;
    }
    ClusterRead cluster=restClient.get(name,false);
    if (cluster == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"" + name + ""String_Node_Str"");
      return;
    }
    NodeGroupAdd nodeGroupAdd=new NodeGroupAdd();
    NodeGroupAdd nodeGroupAddSpec=CommandsUtils.getObjectByJsonString(NodeGroupAdd.class,CommandsUtils.dataFromFile(specFilePath));
    nodeGroupAdd.setSpecFile(true);
    nodeGroupAdd.setNodeGroups(nodeGroupAddSpec.getNodeGroups());
    if (name.indexOf(""String_Node_Str"") != -1) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NODEGROUP + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
      return;
    }
 else     if (name.indexOf(""String_Node_Str"") != -1) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NODEGROUP + Constants.PARAM_NOT_CONTAIN_BLANK_SPACE);
      return;
    }
    restClient.addNodeGroups(name,nodeGroupAdd);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_RESULT_ADD);
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
}"
48331,"public static ClusterManagerException NODE_GROUP_CANNOT_BE_ZERO(String clusterName,String nodeGroupName){
  return new ClusterManagerException(null,""String_Node_Str"",clusterName,nodeGroupName);
}","public static ClusterManagerException NODE_GROUP_CANNOT_BE_ZERO(String clusterName){
  return new ClusterManagerException(null,""String_Node_Str"",clusterName);
}"
48332,"@ClusterManagerPointcut public Long addCluster(String clusterName,NodeGroupCreate[] nodeGroupsAdd) throws Exception {
  Long taskId=null;
  List<BaseNode> vNodes=new ArrayList<BaseNode>();
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  ClusterCreate clusterSpec=clusterConfigMgr.getClusterConfig(clusterName);
  clusterSpec.setNodeGroups(nodeGroupsAdd);
  for (  NodeGroupCreate ng : nodeGroupsAdd) {
    BaseNode node=new BaseNode();
    NodeGroupEntity group=clusterEntityMgr.findByName(clusterName,ng.getName());
    ClusterEntity clusterEntity=clusterEntityMgr.findByName(clusterName);
    if (clusterEntity == null) {
      throw ClusterConfigException.CLUSTER_CONFIG_NOT_FOUND(clusterName);
    }
    if (0 == ng.getInstanceNum()) {
      throw ClusterManagerException.NODE_GROUP_CANNOT_BE_ZERO(clusterName,ng.getName());
    }
    if (group == null) {
      NodeGroupEntity addNodeGroupEntity=new NodeGroupEntity();
      addNodeGroupEntity.setName(ng.getName());
      addNodeGroupEntity.setRoles((new Gson()).toJson(ng.getRoles()));
      addNodeGroupEntity.setNodeType(ng.getInstanceType());
      addNodeGroupEntity.setDefineInstanceNum(ng.getInstanceNum());
      addNodeGroupEntity.setCpuNum(ng.getCpuNum());
      addNodeGroupEntity.setMemorySize(ng.getMemCapacityMB());
      addNodeGroupEntity.setHaFlag(ng.getHaFlag());
      if (null != ng.getStorage()) {
        if (ng.getStorage().getType().equals(Datastore.DatastoreType.SHARED.toString())) {
          addNodeGroupEntity.setStorageType(Datastore.DatastoreType.SHARED);
        }
 else         if (ng.getStorage().getType().equals(Datastore.DatastoreType.LOCAL.toString())) {
          addNodeGroupEntity.setStorageType(Datastore.DatastoreType.LOCAL);
        }
        addNodeGroupEntity.setStorageSize(ng.getStorage().getSizeGB());
        addNodeGroupEntity.setVcDatastoreNameList(ng.getStorage().getDsNames());
        addNodeGroupEntity.setDdDatastoreNameList(ng.getStorage().getDsNames4Data());
        addNodeGroupEntity.setSdDatastoreNameList(ng.getStorage().getDsNames4System());
      }
      addNodeGroupEntity.setGroupRacks(ng.getReferredGroup());
      addNodeGroupEntity.setHadoopConfig((new Gson()).toJson(ng.getConfiguration()));
      addNodeGroupEntity.setCluster(clusterEntity);
      addNodeGroupEntity.setVmFolderPath(clusterEntity);
      ng.setVmFolderPath(clusterEntity.getRootFolder() + ""String_Node_Str"" + ng.getName());
      logger.info(""String_Node_Str"" + ng.getName() + ""String_Node_Str""+ clusterName+ ""String_Node_Str"");
      clusterEntityMgr.insert(addNodeGroupEntity);
    }
 else {
      logger.error(""String_Node_Str"" + ng.getName() + ""String_Node_Str""+ clusterName+ ""String_Node_Str"");
      throw ClusterManagerException.NODE_GROUP_HAS_EXISTED(clusterName,ng.getName());
    }
    node.setCluster(clusterSpec);
    node.setTargetVcCluster(clusterSpec.getVcClusters().get(0).getName());
    node.setNodeGroup(ng);
    vNodes.add(node);
  }
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.ADDING);
  if (clusteringService.addNodeGroups(clusterSpec,nodeGroupsAdd,vNodes)) {
    taskId=resumeClusterCreation(clusterName);
  }
 else {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.PROVISION_ERROR);
    throw ClusterManagerException.ADD_NODE_GROUP_FAILED(clusterName);
  }
  return taskId;
}","@ClusterManagerPointcut public Long addCluster(String clusterName,NodeGroupCreate[] nodeGroupsAdd) throws Exception {
  Long taskId=null;
  List<BaseNode> vNodes=new ArrayList<BaseNode>();
  String rpNames=null;
  ClusterCreate clusterSpec=clusterConfigMgr.getClusterConfig(clusterName);
  List<NodeEntity> nodes=clusterEntityMgr.findAllNodes(clusterName);
  for (  NodeEntity node : nodes) {
    rpNames=node.getVcRp().getVcResourcePool();
    if (null != rpNames)     break;
  }
  clusterSpec.setNodeGroups(nodeGroupsAdd);
  for (  NodeGroupCreate ng : nodeGroupsAdd) {
    BaseNode node=new BaseNode();
    NodeGroupEntity group=clusterEntityMgr.findByName(clusterName,ng.getName());
    ClusterEntity clusterEntity=clusterEntityMgr.findByName(clusterName);
    if (clusterEntity == null) {
      throw ClusterConfigException.CLUSTER_CONFIG_NOT_FOUND(clusterName);
    }
    if (0 == ng.getInstanceNum()) {
      throw ClusterManagerException.NODE_GROUP_CANNOT_BE_ZERO(clusterName);
    }
    if (group == null) {
      NodeGroupEntity addNodeGroupEntity=new NodeGroupEntity();
      addNodeGroupEntity.setName(ng.getName());
      addNodeGroupEntity.setRoles((new Gson()).toJson(ng.getRoles()));
      addNodeGroupEntity.setNodeType(ng.getInstanceType());
      addNodeGroupEntity.setDefineInstanceNum(ng.getInstanceNum());
      addNodeGroupEntity.setCpuNum(ng.getCpuNum());
      addNodeGroupEntity.setMemorySize(ng.getMemCapacityMB());
      addNodeGroupEntity.setHaFlag(ng.getHaFlag());
      if (null != ng.getStorage()) {
        if (ng.getStorage().getType().equals(Datastore.DatastoreType.SHARED.toString())) {
          addNodeGroupEntity.setStorageType(Datastore.DatastoreType.SHARED);
        }
 else         if (ng.getStorage().getType().equals(Datastore.DatastoreType.LOCAL.toString())) {
          addNodeGroupEntity.setStorageType(Datastore.DatastoreType.LOCAL);
        }
        addNodeGroupEntity.setStorageSize(ng.getStorage().getSizeGB());
        addNodeGroupEntity.setVcDatastoreNameList(ng.getStorage().getDsNames());
        addNodeGroupEntity.setDdDatastoreNameList(ng.getStorage().getDsNames4Data());
        addNodeGroupEntity.setSdDatastoreNameList(ng.getStorage().getDsNames4System());
      }
      addNodeGroupEntity.setGroupRacks(ng.getReferredGroup());
      addNodeGroupEntity.setHadoopConfig((new Gson()).toJson(ng.getConfiguration()));
      addNodeGroupEntity.setCluster(clusterEntity);
      addNodeGroupEntity.setVmFolderPath(clusterEntity);
      ng.setVmFolderPath(clusterEntity.getRootFolder() + ""String_Node_Str"" + ng.getName());
      logger.info(""String_Node_Str"" + ng.getName() + ""String_Node_Str""+ clusterName+ ""String_Node_Str"");
      clusterEntityMgr.insert(addNodeGroupEntity);
    }
 else {
      logger.error(""String_Node_Str"" + ng.getName() + ""String_Node_Str""+ clusterName+ ""String_Node_Str"");
      throw ClusterManagerException.NODE_GROUP_HAS_EXISTED(clusterName,ng.getName());
    }
    node.setCluster(clusterSpec);
    node.setTargetVcCluster(clusterSpec.getVcClusters().get(0).getName());
    node.setNodeGroup(ng);
    node.setTargetRp(rpNames);
    vNodes.add(node);
  }
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.ADDING);
  if (clusteringService.addNodeGroups(clusterSpec,nodeGroupsAdd,vNodes)) {
    taskId=resumeClusterCreation(clusterName);
  }
 else {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.PROVISION_ERROR);
    throw ClusterManagerException.ADD_NODE_GROUP_FAILED(clusterName);
  }
  return taskId;
}"
48333,"@Override public boolean addNodeGroups(ClusterCreate clusterSpec,NodeGroupCreate[] nodeGroupsAdd,List<BaseNode> vNodes){
  boolean success=false;
  List<NodeGroupCreate> newNodeGroups=new ArrayList<NodeGroupCreate>();
  if (clusterSpec != null && clusterSpec.getNodeGroups() != null) {
    for (    NodeGroupCreate ng : clusterSpec.getNodeGroups()) {
      newNodeGroups.add(ng);
    }
  }
  if (nodeGroupsAdd != null) {
    for (    NodeGroupCreate ng : nodeGroupsAdd) {
      newNodeGroups.add(ng);
    }
  }
  if (clusterSpec != null) {
    clusterSpec.setNodeGroups(newNodeGroups.toArray(new NodeGroupCreate[newNodeGroups.size()]));
  }
  createVcFolders(clusterSpec,true);
  createVcResourcePools(vNodes,true);
  success=true;
  return success;
}","@Override public boolean addNodeGroups(ClusterCreate clusterSpec,NodeGroupCreate[] nodeGroupsAdd,List<BaseNode> vNodes){
  boolean success=false;
  List<NodeGroupCreate> newNodeGroups=new ArrayList<NodeGroupCreate>();
  if (clusterSpec != null && clusterSpec.getNodeGroups() != null) {
    for (    NodeGroupCreate ng : clusterSpec.getNodeGroups()) {
      newNodeGroups.add(ng);
    }
  }
  if (nodeGroupsAdd != null) {
    for (    NodeGroupCreate ng : nodeGroupsAdd) {
      newNodeGroups.add(ng);
    }
  }
  if (clusterSpec != null) {
    clusterSpec.setNodeGroups(newNodeGroups.toArray(new NodeGroupCreate[newNodeGroups.size()]));
  }
  if (null != createVcFolders(clusterSpec,true)) {
    if (null != createVcResourcePools(vNodes,true)) {
      success=true;
    }
  }
  return success;
}"
48334,"@SuppressWarnings(""String_Node_Str"") private Map<String,Folder> createVcFolders(ClusterCreate cluster,boolean addNodeGroup){
  logger.info(""String_Node_Str"");
  VcVirtualMachine templateVm=getTemplateVM(cluster.getTemplateName());
  Callable<Void>[] storeProcedures=new Callable[1];
  Folder clusterFolder=null;
  if (!addNodeGroup) {
    if (cluster.getNodeGroups().length > 0) {
      NodeGroupCreate group=cluster.getNodeGroups()[0];
      String path=group.getVmFolderPath();
      String[] folderNames=path.split(""String_Node_Str"");
      List<String> folderList=new ArrayList<String>();
      for (int i=0; i < folderNames.length - 1; i++) {
        folderList.add(folderNames[i]);
      }
      CreateVMFolderSP sp=new CreateVMFolderSP(templateVm.getDatacenter(),null,folderList);
      storeProcedures[0]=sp;
      Map<String,Folder> folders=executeFolderCreationProcedures(cluster,storeProcedures);
      for (      String name : folders.keySet()) {
        clusterFolder=folders.get(name);
        break;
      }
    }
  }
  logger.info(""String_Node_Str"");
  storeProcedures=new Callable[cluster.getNodeGroups().length];
  int i=0;
  for (  NodeGroupCreate group : cluster.getNodeGroups()) {
    List<String> folderList=new ArrayList<String>();
    folderList.add(group.getName());
    CreateVMFolderSP sp=new CreateVMFolderSP(templateVm.getDatacenter(),clusterFolder,folderList);
    storeProcedures[i]=sp;
    i++;
  }
  return executeFolderCreationProcedures(cluster,storeProcedures);
}","@SuppressWarnings(""String_Node_Str"") private Map<String,Folder> createVcFolders(ClusterCreate cluster,boolean addNodeGroup){
  logger.info(""String_Node_Str"");
  VcVirtualMachine templateVm=getTemplateVM(cluster.getTemplateName());
  Callable<Void>[] storeProcedures=new Callable[1];
  Folder clusterFolder=null;
  if (!addNodeGroup) {
    if (cluster.getNodeGroups().length > 0) {
      NodeGroupCreate group=cluster.getNodeGroups()[0];
      String path=group.getVmFolderPath();
      logger.info(""String_Node_Str"" + path);
      String[] folderNames=path.split(""String_Node_Str"");
      List<String> folderList=new ArrayList<String>();
      for (int i=0; i < folderNames.length - 1; i++) {
        folderList.add(folderNames[i]);
      }
      CreateVMFolderSP sp=new CreateVMFolderSP(templateVm.getDatacenter(),null,folderList);
      storeProcedures[0]=sp;
      Map<String,Folder> folders=executeFolderCreationProcedures(cluster,storeProcedures);
      for (      String name : folders.keySet()) {
        clusterFolder=folders.get(name);
        break;
      }
    }
  }
  logger.info(""String_Node_Str"");
  storeProcedures=new Callable[cluster.getNodeGroups().length];
  int i=0;
  for (  NodeGroupCreate group : cluster.getNodeGroups()) {
    List<String> folderList=new ArrayList<String>();
    folderList.add(group.getName());
    CreateVMFolderSP sp=new CreateVMFolderSP(templateVm.getDatacenter(),clusterFolder,folderList);
    storeProcedures[i]=sp;
    i++;
  }
  return executeFolderCreationProcedures(cluster,storeProcedures);
}"
48335,"public Map<String,Set<String>> getRackHostsMap(List<String> addedNodeNames){
  if (!AmUtils.isAmbariServerGreaterOrEquals_2_1_0(ambariServerVersion)) {
    return null;
  }
  Map<String,Set<String>> rackHostsMap=new HashMap<String,Set<String>>();
  List<AmNodeDef> nodes=getNodes();
  for (  AmNodeDef node : nodes) {
    if (addedNodeNames != null && !addedNodeNames.contains(node.getName())) {
      continue;
    }
    String rack=this.rackTopology.get(node.getIp());
    if (rack != null) {
      Set<String> hosts=rackHostsMap.get(rack);
      if (hosts == null) {
        hosts=new HashSet<String>();
      }
      hosts.add(node.getFqdn());
      rackHostsMap.put(rack,hosts);
    }
  }
  return rackHostsMap;
}","public Map<String,Set<String>> getRackHostsMap(List<String> addedNodeNames){
  if (this.rackTopology == null || !AmUtils.isAmbariServerGreaterOrEquals_2_1_0(ambariServerVersion)) {
    return null;
  }
  Map<String,Set<String>> rackHostsMap=new HashMap<String,Set<String>>();
  List<AmNodeDef> nodes=getNodes();
  for (  AmNodeDef node : nodes) {
    if (addedNodeNames != null && !addedNodeNames.contains(node.getName())) {
      continue;
    }
    String rack=this.rackTopology.get(node.getIp());
    if (rack != null) {
      Set<String> hosts=rackHostsMap.get(rack);
      if (hosts == null) {
        hosts=new HashSet<String>();
      }
      hosts.add(node.getFqdn());
      rackHostsMap.put(rack,hosts);
    }
  }
  return rackHostsMap;
}"
48336,"@Override public ApiBootstrap createBootstrap(ApiBootstrap bootstrap) throws AmbariApiException {
  logger.info(""String_Node_Str"");
  logger.info(ApiUtils.objectToJson(bootstrap));
  Response response=null;
  try {
    response=apiResourceRootV1.getBootstrapResource().createBootstrap(ApiUtils.objectToJson(bootstrap));
  }
 catch (  Exception e) {
    throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
  }
  String bootstrapJson=handleAmbariResponse(response);
  logger.debug(""String_Node_Str"");
  logger.debug(bootstrapJson);
  ApiBootstrap apiBootstrap=ApiUtils.jsonToObject(ApiBootstrap.class,bootstrapJson);
  return apiBootstrap;
}","@Override public ApiBootstrap createBootstrap(ApiBootstrap bootstrap) throws AmbariApiException {
  logger.info(""String_Node_Str"");
  logger.info(ApiUtils.objectToJson(bootstrap.getHosts()));
  Response response=null;
  try {
    response=apiResourceRootV1.getBootstrapResource().createBootstrap(ApiUtils.objectToJson(bootstrap));
  }
 catch (  Exception e) {
    throw AmbariApiException.CANNOT_CONNECT_AMBARI_SERVER(e);
  }
  String bootstrapJson=handleAmbariResponse(response);
  logger.debug(""String_Node_Str"");
  logger.debug(bootstrapJson);
  ApiBootstrap apiBootstrap=ApiUtils.jsonToObject(ApiBootstrap.class,bootstrapJson);
  return apiBootstrap;
}"
48337,"private CreateVmSP getReplacementVmSp(ClusterCreate clusterSpec,String groupName,NodeEntity node,List<DiskSpec> fullDiskSet){
  VmSchema createSchema=VcVmUtil.getVmSchema(clusterSpec,groupName,fullDiskSet,node.getNodeGroup().getCluster().getTemplateId(),Constants.ROOT_SNAPSTHOT_NAME);
  Map<String,String> guestVariable=generateMachineId(clusterSpec,node);
  VcVmUtil.addBootupUUID(guestVariable);
  boolean ha=getHaFlag(clusterSpec,groupName);
  boolean ft=getFtFlag(clusterSpec,groupName);
  boolean isMapDistro=clusterEntityMgr.findByName(clusterSpec.getName()).getDistroVendor().equalsIgnoreCase(Constants.MAPR_VENDOR);
  ReplaceVmPrePowerOn prePowerOn=new ReplaceVmPrePowerOn(isMapDistro,node.getMoId(),node.getVmName(),clusterSpec.getNodeGroup(groupName).getStorage().getShares(),createSchema.networkSchema,createSchema.diskSchema,ha,ft);
  String newVmName=node.getVmName();
  if (node.getMoId() != null && !node.getMoId().isEmpty()) {
    newVmName=node.getVmName() + RECOVERY_VM_NAME_POSTFIX;
  }
  return new CreateVmSP(newVmName,createSchema,VcVmUtil.getTargetRp(clusterSpec.getName(),groupName,node),getTargetDatastore(fullDiskSet),prePowerOn,null,guestVariable,VcVmCloneType.FULL,true,getTargetFolder(node),getTargetHost(node));
}","private CreateVmSP getReplacementVmSp(ClusterCreate clusterSpec,String groupName,NodeEntity node,List<DiskSpec> fullDiskSet){
  VmSchema createSchema=VcVmUtil.getVmSchema(clusterSpec,groupName,fullDiskSet,node.getNodeGroup().getCluster().getTemplateId(),Constants.ROOT_SNAPSTHOT_NAME);
  Map<String,String> guestVariable=generateMachineId(clusterSpec,node);
  VcVmUtil.addBootupUUID(guestVariable);
  boolean ha=getHaFlag(clusterSpec,groupName);
  boolean ft=getFtFlag(clusterSpec,groupName);
  boolean isMapDistro=clusterEntityMgr.findByName(clusterSpec.getName()).getDistroVendor().equalsIgnoreCase(Constants.MAPR_VENDOR);
  ReplaceVmPrePowerOn prePowerOn=new ReplaceVmPrePowerOn(node.getMoId(),node.getVmName(),clusterSpec.getNodeGroup(groupName).getStorage().getShares(),createSchema.networkSchema,createSchema.diskSchema,ha,ft,isMapDistro);
  String newVmName=node.getVmName();
  if (node.getMoId() != null && !node.getMoId().isEmpty()) {
    newVmName=node.getVmName() + RECOVERY_VM_NAME_POSTFIX;
  }
  return new CreateVmSP(newVmName,createSchema,VcVmUtil.getTargetRp(clusterSpec.getName(),groupName,node),getTargetDatastore(fullDiskSet),prePowerOn,null,guestVariable,VcVmCloneType.FULL,true,getTargetFolder(node),getTargetHost(node));
}"
48338,"@Override @SuppressWarnings(""String_Node_Str"") public VcVirtualMachine replaceBadDisksExceptSystem(String clusterName,String groupName,String nodeName,List<DiskSpec> replacementDisks){
  ClusterCreate spec=configMgr.getClusterConfig(clusterName);
  NodeEntity node=clusterEntityMgr.findByName(spec.getName(),groupName,nodeName);
  List<DiskSpec> fullDiskList=getReplacedFullDisks(node.getVmName(),replacementDisks);
  VmSchema createSchema=VcVmUtil.getVmSchema(spec,groupName,fullDiskList,node.getNodeGroup().getCluster().getTemplateId(),Constants.ROOT_SNAPSTHOT_NAME);
  ReplaceVmBadDisksSP replaceVmDisksPrePowerOnSP=new ReplaceVmBadDisksSP(node.getMoId(),createSchema.diskSchema,VcVmUtil.getTargetRp(spec.getName(),groupName,node),getTargetDatastore(fullDiskList),getBadDataDiskEntities(node.getVmName()));
  try {
    Callable<Void>[] storeProceduresArray=new Callable[1];
    storeProceduresArray[0]=replaceVmDisksPrePowerOnSP;
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProceduresArray,null);
    if (result == null) {
      logger.error(""String_Node_Str"" + nodeName);
      return null;
    }
    Throwable replacedDataDisksVmSpException=result[0].throwable;
    if (result[0].finished && replacedDataDisksVmSpException == null) {
      ReplaceVmBadDisksSP sp=(ReplaceVmBadDisksSP)storeProceduresArray[0];
      VcVirtualMachine vm=sp.getVm();
      AuAssert.check(vm != null);
      return vm;
    }
 else {
      logger.error(""String_Node_Str"" + node.getVmName(),replacedDataDisksVmSpException);
      throw ClusterHealServiceException.FAILED_TO_REPLACE_BAD_DATA_DISKS(node.getVmName());
    }
  }
 catch (  InterruptedException e) {
    logger.error(""String_Node_Str"" + nodeName,e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}","@Override @SuppressWarnings(""String_Node_Str"") public VcVirtualMachine replaceBadDisksExceptSystem(String clusterName,String groupName,String nodeName,List<DiskSpec> replacementDisks){
  ClusterCreate spec=configMgr.getClusterConfig(clusterName);
  NodeEntity node=clusterEntityMgr.findByName(spec.getName(),groupName,nodeName);
  List<DiskSpec> fullDiskList=getReplacedFullDisks(node.getVmName(),replacementDisks);
  VmSchema createSchema=VcVmUtil.getVmSchema(spec,groupName,fullDiskList,clusteringService.getTemplateVmId(),Constants.ROOT_SNAPSTHOT_NAME);
  boolean isMapDistro=clusterEntityMgr.findByName(clusterName).getDistroVendor().equalsIgnoreCase(Constants.MAPR_VENDOR);
  ReplaceVmBadDisksSP replaceVmDisksPrePowerOnSP=new ReplaceVmBadDisksSP(node.getMoId(),createSchema.diskSchema,VcVmUtil.getTargetRp(spec.getName(),groupName,node),getTargetDatastore(fullDiskList),getBadDataDiskEntities(node.getVmName()),isMapDistro);
  try {
    Callable<Void>[] storeProceduresArray=new Callable[1];
    storeProceduresArray[0]=replaceVmDisksPrePowerOnSP;
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProceduresArray,null);
    if (result == null) {
      logger.error(""String_Node_Str"" + nodeName);
      return null;
    }
    Throwable replacedDataDisksVmSpException=result[0].throwable;
    if (result[0].finished && replacedDataDisksVmSpException == null) {
      ReplaceVmBadDisksSP sp=(ReplaceVmBadDisksSP)storeProceduresArray[0];
      VcVirtualMachine vm=sp.getVm();
      AuAssert.check(vm != null);
      return vm;
    }
 else {
      logger.error(""String_Node_Str"" + node.getVmName(),replacedDataDisksVmSpException);
      throw ClusterHealServiceException.FAILED_TO_REPLACE_BAD_DATA_DISKS(node.getVmName());
    }
  }
 catch (  InterruptedException e) {
    logger.error(""String_Node_Str"" + nodeName,e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}"
48339,"public ReplaceVmBadDisksSP(String vmId,DiskSchema diskSchema,VcResourcePool targetRp,VcDatastore targetDs,List<DiskEntity> badDataDiskEntities){
  this.vmId=vmId;
  this.diskSchema=diskSchema;
  this.targetRp=targetRp;
  this.targetDs=targetDs;
  this.badDataDiskEntities=badDataDiskEntities;
}","public ReplaceVmBadDisksSP(String vmId,DiskSchema diskSchema,VcResourcePool targetRp,VcDatastore targetDs,List<DiskEntity> badDataDiskEntities,boolean isMapDistro){
  this.isMapDistro=isMapDistro;
  this.vmId=vmId;
  this.diskSchema=diskSchema;
  this.targetRp=targetRp;
  this.targetDs=targetDs;
  this.badDataDiskEntities=badDataDiskEntities;
}"
48340,"private void replaceVmDataDisks(){
  VcContext.inVcSessionDo(new VcSession<Void>(){
    @Override protected Void body() throws Exception {
      List<VcHost> hostList=new ArrayList<VcHost>();
      HashMap<String,Disk.Operation> diskMap=new HashMap<String,Disk.Operation>();
      List<DiskCreateSpec> addDisks=DiskSchemaUtil.getDisksToAdd(hostList,targetRp,targetDs,diskSchema,diskMap);
      DiskCreateSpec[] tmpAddDisks=addDisks.toArray(new DiskCreateSpec[addDisks.size()]);
      if (hostList.size() > 0 && !hostList.contains(vm.getHost())) {
        vm.migrate(hostList.get(0));
      }
      vm.changeDisks(null,tmpAddDisks);
      VcVmUtil.enableDiskUUID(vm);
      Map<String,String> bootupConfigs=vm.getGuestConfigs();
      AuAssert.check(bootupConfigs != null);
      VcVmUtil.addBootupUUID(bootupConfigs);
      bootupConfigs.put(Constants.GUEST_VARIABLE_RESERVE_RAW_DISKS,String.valueOf(false));
      bootupConfigs.put(Constants.GUEST_VARIABLE_VOLUMES,VcVmUtil.getVolumes(vm.getId(),diskSchema.getDisks()));
      vm.setGuestConfigs(bootupConfigs);
      logger.info(""String_Node_Str"" + bootupConfigs + ""String_Node_Str""+ vm.getName());
      return null;
    }
    @Override protected boolean isTaskSession(){
      return true;
    }
  }
);
}","private void replaceVmDataDisks(){
  VcContext.inVcSessionDo(new VcSession<Void>(){
    @Override protected Void body() throws Exception {
      List<VcHost> hostList=new ArrayList<VcHost>();
      HashMap<String,Disk.Operation> diskMap=new HashMap<String,Disk.Operation>();
      List<DiskCreateSpec> addDisks=DiskSchemaUtil.getDisksToAdd(hostList,targetRp,targetDs,diskSchema,diskMap);
      DiskCreateSpec[] tmpAddDisks=addDisks.toArray(new DiskCreateSpec[addDisks.size()]);
      if (hostList.size() > 0 && !hostList.contains(vm.getHost())) {
        vm.migrate(hostList.get(0));
      }
      vm.changeDisks(null,tmpAddDisks);
      VcVmUtil.enableDiskUUID(vm);
      Map<String,String> bootupConfigs=vm.getGuestConfigs();
      AuAssert.check(bootupConfigs != null);
      VcVmUtil.addBootupUUID(bootupConfigs);
      bootupConfigs.put(Constants.GUEST_VARIABLE_RESERVE_RAW_DISKS,String.valueOf(isMapDistro));
      bootupConfigs.put(Constants.GUEST_VARIABLE_VOLUMES,VcVmUtil.getVolumes(vm.getId(),diskSchema.getDisks()));
      vm.setGuestConfigs(bootupConfigs);
      logger.info(""String_Node_Str"" + bootupConfigs + ""String_Node_Str""+ vm.getName());
      return null;
    }
    @Override protected boolean isTaskSession(){
      return true;
    }
  }
);
}"
48341,"@Override protected Void body() throws Exception {
  List<VcHost> hostList=new ArrayList<VcHost>();
  HashMap<String,Disk.Operation> diskMap=new HashMap<String,Disk.Operation>();
  List<DiskCreateSpec> addDisks=DiskSchemaUtil.getDisksToAdd(hostList,targetRp,targetDs,diskSchema,diskMap);
  DiskCreateSpec[] tmpAddDisks=addDisks.toArray(new DiskCreateSpec[addDisks.size()]);
  if (hostList.size() > 0 && !hostList.contains(vm.getHost())) {
    vm.migrate(hostList.get(0));
  }
  vm.changeDisks(null,tmpAddDisks);
  VcVmUtil.enableDiskUUID(vm);
  Map<String,String> bootupConfigs=vm.getGuestConfigs();
  AuAssert.check(bootupConfigs != null);
  VcVmUtil.addBootupUUID(bootupConfigs);
  bootupConfigs.put(Constants.GUEST_VARIABLE_RESERVE_RAW_DISKS,String.valueOf(false));
  bootupConfigs.put(Constants.GUEST_VARIABLE_VOLUMES,VcVmUtil.getVolumes(vm.getId(),diskSchema.getDisks()));
  vm.setGuestConfigs(bootupConfigs);
  logger.info(""String_Node_Str"" + bootupConfigs + ""String_Node_Str""+ vm.getName());
  return null;
}","@Override protected Void body() throws Exception {
  List<VcHost> hostList=new ArrayList<VcHost>();
  HashMap<String,Disk.Operation> diskMap=new HashMap<String,Disk.Operation>();
  List<DiskCreateSpec> addDisks=DiskSchemaUtil.getDisksToAdd(hostList,targetRp,targetDs,diskSchema,diskMap);
  DiskCreateSpec[] tmpAddDisks=addDisks.toArray(new DiskCreateSpec[addDisks.size()]);
  if (hostList.size() > 0 && !hostList.contains(vm.getHost())) {
    vm.migrate(hostList.get(0));
  }
  vm.changeDisks(null,tmpAddDisks);
  VcVmUtil.enableDiskUUID(vm);
  Map<String,String> bootupConfigs=vm.getGuestConfigs();
  AuAssert.check(bootupConfigs != null);
  VcVmUtil.addBootupUUID(bootupConfigs);
  bootupConfigs.put(Constants.GUEST_VARIABLE_RESERVE_RAW_DISKS,String.valueOf(isMapDistro));
  bootupConfigs.put(Constants.GUEST_VARIABLE_VOLUMES,VcVmUtil.getVolumes(vm.getId(),diskSchema.getDisks()));
  vm.setGuestConfigs(bootupConfigs);
  logger.info(""String_Node_Str"" + bootupConfigs + ""String_Node_Str""+ vm.getName());
  return null;
}"
48342,"public ReplaceVmPrePowerOn(boolean isMapDistro,String vmId,String newName,Priority ioShares,NetworkSchema networkSchema,DiskSchema diskSchema,boolean ha,boolean ft){
  this.oldVmId=vmId;
  this.newName=newName;
  this.ioShares=ioShares;
  this.networkSchema=networkSchema;
  this.diskSchema=diskSchema;
  this.ha=ha;
  this.ft=ft;
  this.isMapDistro=isMapDistro;
}","public ReplaceVmPrePowerOn(String vmId,String newName,Priority ioShares,NetworkSchema networkSchema,DiskSchema diskSchema,boolean ha,boolean ft,boolean isMapDistro){
  this.oldVmId=vmId;
  this.newName=newName;
  this.ioShares=ioShares;
  this.networkSchema=networkSchema;
  this.diskSchema=diskSchema;
  this.ha=ha;
  this.ft=ft;
  this.isMapDistro=isMapDistro;
}"
48343,"public AmClusterDef(ClusterBlueprint blueprint,String privateKey,String ambariServerVersion){
  this.name=blueprint.getName();
  this.version=blueprint.getHadoopStack().getFullVersion();
  this.verbose=true;
  this.sshKey=privateKey;
  this.user=Constants.AMBARI_SSH_USER;
  this.currentReport=new ClusterReport(blueprint);
  this.ambariServerVersion=ambariServerVersion;
  this.rackTopology=blueprint.getRackTopology();
  HdfsVersion hdfs=getDefaultHdfsVersion(this.version);
  if (blueprint.hasTopologyPolicy() && !AmUtils.isAmbariServerGreaterOrEquals_2_1_0(ambariServerVersion)) {
    setRackTopologyFileName(blueprint);
  }
  setAdditionalConfigurations(blueprint,ambariServerVersion);
  this.configurations=AmUtils.toAmConfigurations(blueprint.getConfiguration());
  this.nodeGroups=new ArrayList<AmNodeGroupDef>();
  for (  NodeGroupInfo group : blueprint.getNodeGroups()) {
    AmNodeGroupDef nodeGroupDef=new AmNodeGroupDef();
    nodeGroupDef.setName(group.getName());
    nodeGroupDef.setInstanceNum(group.getInstanceNum());
    nodeGroupDef.setRoles(group.getRoles());
    nodeGroupDef.setConfigurations(AmUtils.toAmConfigurations(group.getConfiguration()));
    nodeGroupDef.setClusterName(this.name);
    nodeGroupDef.setAmbariServerVersion(ambariServerVersion);
    List<AmNodeDef> nodes=new ArrayList<AmNodeDef>();
    for (    NodeInfo node : group.getNodes()) {
      AmNodeDef nodeDef=new AmNodeDef();
      nodeDef.setName(node.getName());
      nodeDef.setIp(node.getMgtIpAddress());
      nodeDef.setFqdn(node.getHostname());
      nodeDef.setRackInfo(node.getRack());
      nodeDef.setConfigurations(AmUtils.toAmConfigurations(group.getConfiguration()));
      nodeDef.setComponents(group.getRoles());
      nodeDef.setVolumes(node.getVolumes());
      nodeDef.setDirsConfig(hdfs,ambariServerVersion);
      nodes.add(nodeDef);
    }
    nodeGroupDef.setNodes(nodes);
    this.nodeGroups.add(nodeGroupDef);
  }
  if (blueprint.getExternalNamenode() != null) {
    this.isComputeOnly=true;
    this.externalNamenode=blueprint.getExternalNamenode();
    this.externalSecondaryNamenode=blueprint.getExternalSecondaryNamenode();
    String externalNameNodeGroupName=""String_Node_Str"";
    AmNodeDef namenodeDef=new AmNodeDef();
    namenodeDef.setName(name + ""String_Node_Str"" + externalNameNodeGroupName+ ""String_Node_Str"");
    namenodeDef.setFqdn(externalNamenode);
    List<String> namenodeRoles=new ArrayList<String>();
    namenodeRoles.add(""String_Node_Str"");
    if (!isValidExternalSecondaryNamenode()) {
      namenodeRoles.add(""String_Node_Str"");
    }
    namenodeDef.setComponents(namenodeRoles);
    namenodeDef.setVolumes(new ArrayList<String>());
    namenodeDef.setConfigurations(AmUtils.toAmConfigurations(null));
    AmNodeGroupDef externalNameNodeGroup=new AmNodeGroupDef();
    externalNameNodeGroup.setName(externalNameNodeGroupName);
    externalNameNodeGroup.setConfigurations(AmUtils.toAmConfigurations(null));
    externalNameNodeGroup.setRoles(namenodeRoles);
    externalNameNodeGroup.setInstanceNum(1);
    List<AmNodeDef> externalNameNodes=new ArrayList<AmNodeDef>();
    externalNameNodes.add(namenodeDef);
    externalNameNodeGroup.setNodes(externalNameNodes);
    this.nodeGroups.add(externalNameNodeGroup);
    if (isValidExternalSecondaryNamenode()) {
      String externalSecondaryNameNodeGroupName=""String_Node_Str"";
      AmNodeDef secondaryNamenodeDef=new AmNodeDef();
      secondaryNamenodeDef.setName(name + ""String_Node_Str"" + externalSecondaryNameNodeGroupName+ ""String_Node_Str"");
      secondaryNamenodeDef.setFqdn(externalSecondaryNamenode);
      List<String> secondaryNamenodeRoles=new ArrayList<String>();
      secondaryNamenodeRoles.add(""String_Node_Str"");
      secondaryNamenodeDef.setComponents(secondaryNamenodeRoles);
      secondaryNamenodeDef.setVolumes(new ArrayList<String>());
      secondaryNamenodeDef.setConfigurations(AmUtils.toAmConfigurations(null));
      AmNodeGroupDef externalSecondaryNameNodeGroup=new AmNodeGroupDef();
      externalSecondaryNameNodeGroup.setName(externalSecondaryNameNodeGroupName);
      externalSecondaryNameNodeGroup.setConfigurations(AmUtils.toAmConfigurations(null));
      externalSecondaryNameNodeGroup.setRoles(secondaryNamenodeRoles);
      externalSecondaryNameNodeGroup.setInstanceNum(1);
      List<AmNodeDef> externalSecondaryNameNodes=new ArrayList<AmNodeDef>();
      externalSecondaryNameNodes.add(secondaryNamenodeDef);
      externalSecondaryNameNodeGroup.setNodes(externalSecondaryNameNodes);
      this.nodeGroups.add(externalSecondaryNameNodeGroup);
    }
  }
  AmStackDef stackDef=new AmStackDef();
  stackDef.setName(blueprint.getHadoopStack().getVendor());
  stackDef.setVersion(blueprint.getHadoopStack().getFullVersion());
  this.amStack=stackDef;
}","public AmClusterDef(ClusterBlueprint blueprint,String privateKey,String ambariServerVersion){
  this.name=blueprint.getName();
  this.version=blueprint.getHadoopStack().getFullVersion();
  this.verbose=true;
  this.sshKey=privateKey;
  this.user=Constants.AMBARI_SSH_USER;
  this.currentReport=new ClusterReport(blueprint);
  this.ambariServerVersion=ambariServerVersion;
  this.rackTopology=blueprint.getRackTopology();
  HdfsVersion hdfs=getDefaultHdfsVersion(this.version);
  if (blueprint.hasTopologyPolicy() && !AmUtils.isAmbariServerGreaterOrEquals_2_1_0(ambariServerVersion)) {
    setRackTopologyFileName(blueprint);
  }
  setAdditionalConfigurations(blueprint,ambariServerVersion);
  this.configurations=AmUtils.toAmConfigurations(blueprint.getConfiguration());
  this.nodeGroups=new ArrayList<AmNodeGroupDef>();
  for (  NodeGroupInfo group : blueprint.getNodeGroups()) {
    AmNodeGroupDef nodeGroupDef=new AmNodeGroupDef();
    nodeGroupDef.setName(group.getName());
    nodeGroupDef.setInstanceNum(group.getInstanceNum());
    nodeGroupDef.setRoles(group.getRoles());
    nodeGroupDef.setConfigurations(AmUtils.toAmConfigurations(group.getConfiguration()));
    nodeGroupDef.setClusterName(this.name);
    nodeGroupDef.setAmbariServerVersion(ambariServerVersion);
    List<AmNodeDef> nodes=new ArrayList<AmNodeDef>();
    for (    NodeInfo node : group.getNodes()) {
      AmNodeDef nodeDef=new AmNodeDef();
      nodeDef.setName(node.getName());
      nodeDef.setIp(node.getMgtIpAddress());
      nodeDef.setFqdn(node.getHostname());
      nodeDef.setRackInfo(node.getRack());
      nodeDef.setConfigurations(AmUtils.toAmConfigurations(group.getConfiguration()));
      nodeDef.setComponents(group.getRoles());
      nodeDef.setVolumes(node.getVolumes());
      nodeDef.setDirsConfig(hdfs,ambariServerVersion);
      nodes.add(nodeDef);
    }
    nodeGroupDef.setNodes(nodes);
    this.nodeGroups.add(nodeGroupDef);
  }
  if (blueprint.getExternalNamenode() != null) {
    this.isComputeOnly=true;
    this.externalNamenode=blueprint.getExternalNamenode();
    this.externalSecondaryNamenode=blueprint.getExternalSecondaryNamenode();
    String externalNameNodeGroupName=""String_Node_Str"";
    AmNodeDef namenodeDef=new AmNodeDef();
    namenodeDef.setName(name + ""String_Node_Str"" + externalNameNodeGroupName+ ""String_Node_Str"");
    namenodeDef.setFqdn(externalNamenode);
    List<String> namenodeRoles=new ArrayList<String>();
    namenodeRoles.add(""String_Node_Str"");
    if (!isValidExternalSecondaryNamenode()) {
      namenodeRoles.add(""String_Node_Str"");
    }
    namenodeDef.setComponents(namenodeRoles);
    namenodeDef.setVolumes(new ArrayList<String>());
    namenodeDef.setConfigurations(AmUtils.toAmConfigurations(null));
    AmNodeGroupDef externalNameNodeGroup=new AmNodeGroupDef();
    externalNameNodeGroup.setName(externalNameNodeGroupName);
    externalNameNodeGroup.setConfigurations(AmUtils.toAmConfigurations(null));
    externalNameNodeGroup.setRoles(namenodeRoles);
    externalNameNodeGroup.setInstanceNum(1);
    externalNameNodeGroup.setAmbariServerVersion(ambariServerVersion);
    List<AmNodeDef> externalNameNodes=new ArrayList<AmNodeDef>();
    externalNameNodes.add(namenodeDef);
    externalNameNodeGroup.setNodes(externalNameNodes);
    this.nodeGroups.add(externalNameNodeGroup);
    if (isValidExternalSecondaryNamenode()) {
      String externalSecondaryNameNodeGroupName=""String_Node_Str"";
      AmNodeDef secondaryNamenodeDef=new AmNodeDef();
      secondaryNamenodeDef.setName(name + ""String_Node_Str"" + externalSecondaryNameNodeGroupName+ ""String_Node_Str"");
      secondaryNamenodeDef.setFqdn(externalSecondaryNamenode);
      List<String> secondaryNamenodeRoles=new ArrayList<String>();
      secondaryNamenodeRoles.add(""String_Node_Str"");
      secondaryNamenodeDef.setComponents(secondaryNamenodeRoles);
      secondaryNamenodeDef.setVolumes(new ArrayList<String>());
      secondaryNamenodeDef.setConfigurations(AmUtils.toAmConfigurations(null));
      AmNodeGroupDef externalSecondaryNameNodeGroup=new AmNodeGroupDef();
      externalSecondaryNameNodeGroup.setName(externalSecondaryNameNodeGroupName);
      externalSecondaryNameNodeGroup.setConfigurations(AmUtils.toAmConfigurations(null));
      externalSecondaryNameNodeGroup.setRoles(secondaryNamenodeRoles);
      externalSecondaryNameNodeGroup.setInstanceNum(1);
      List<AmNodeDef> externalSecondaryNameNodes=new ArrayList<AmNodeDef>();
      externalSecondaryNameNodes.add(secondaryNamenodeDef);
      externalSecondaryNameNodeGroup.setNodes(externalSecondaryNameNodes);
      this.nodeGroups.add(externalSecondaryNameNodeGroup);
    }
  }
  AmStackDef stackDef=new AmStackDef();
  stackDef.setName(blueprint.getHadoopStack().getVendor());
  stackDef.setVersion(blueprint.getHadoopStack().getFullVersion());
  this.amStack=stackDef;
}"
48344,"@Override protected List<NodeEntity> getNodesToBeSetLocalRepo(ChunkContext chunkContext,String clusterName) throws TaskException {
  List<NodeEntity> toBeSetLocalRepo=null;
  List<NodeEntity> nodesInGroup=null;
  List<String> nodeGroupNames=new ArrayList<String>();
  String nodeGroupNameList=TrackableTasklet.getJobParameters(chunkContext).getString(JobConstants.NEW_NODE_GROUP_LIST_JOB_PARAM);
  logger.info(""String_Node_Str"");
  for (  String nodeGroupName : nodeGroupNameList.split(""String_Node_Str"")) {
    nodeGroupNames.add(nodeGroupName);
  }
  for (  String nodeGroupName : nodeGroupNames) {
    nodesInGroup=clusterEntityMgr.findAllNodes(clusterName,nodeGroupName);
  }
  for (  NodeEntity node : nodesInGroup) {
    if (node.getStatus().ordinal() >= NodeStatus.VM_READY.ordinal()) {
      if (toBeSetLocalRepo == null) {
        toBeSetLocalRepo=new ArrayList<NodeEntity>();
      }
      toBeSetLocalRepo.add(node);
    }
  }
  return toBeSetLocalRepo;
}","@Override protected List<NodeEntity> getNodesToBeSetLocalRepo(ChunkContext chunkContext,String clusterName) throws TaskException {
  List<NodeEntity> toBeSetLocalRepo=null;
  List<NodeEntity> nodesInGroup=null;
  List<NodeEntity> addNodes=new ArrayList<NodeEntity>();
  List<String> nodeGroupNames=null;
  String nodeGroupNameList=TrackableTasklet.getJobParameters(chunkContext).getString(JobConstants.NEW_NODE_GROUP_LIST_JOB_PARAM);
  nodeGroupNames=ClusterUtil.getNodesFromNodeGroups(nodeGroupNameList);
  for (  String nodeGroupName : nodeGroupNames) {
    nodesInGroup=clusterEntityMgr.findAllNodes(clusterName,nodeGroupName);
    for (    NodeEntity ne : nodesInGroup) {
      addNodes.add(ne);
    }
  }
  toBeSetLocalRepo=ClusterUtil.getReadyVmFromNodeGroups(addNodes);
  return toBeSetLocalRepo;
}"
48345,"protected List<NodeEntity> findNodesToEnableLdap(ChunkContext chunkContext) throws TaskException {
  List<NodeEntity> foundNodeList=null;
  List<NodeEntity> nodesInGroup=null;
  List<String> nodeGroupNames=new ArrayList<String>();
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  String nodeGroupNameList=TrackableTasklet.getJobParameters(chunkContext).getString(JobConstants.NEW_NODE_GROUP_LIST_JOB_PARAM);
  for (  String nodeGroupName : nodeGroupNameList.split(""String_Node_Str"")) {
    nodeGroupNames.add(nodeGroupName);
  }
  for (  String nodeGroupName : nodeGroupNames) {
    nodesInGroup=clusterEntityMgr.findAllNodes(clusterName,nodeGroupName);
  }
  for (  NodeEntity node : nodesInGroup) {
    if (node.getStatus().ordinal() >= NodeStatus.VM_READY.ordinal()) {
      if (foundNodeList == null) {
        foundNodeList=new ArrayList<NodeEntity>();
      }
      foundNodeList.add(node);
    }
  }
  return foundNodeList;
}","protected List<NodeEntity> findNodesToEnableLdap(ChunkContext chunkContext) throws TaskException {
  List<NodeEntity> foundNodeList=null;
  List<NodeEntity> nodesInGroup=null;
  List<NodeEntity> addNodes=new ArrayList<NodeEntity>();
  List<String> nodeGroupNames=null;
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  String nodeGroupNameList=TrackableTasklet.getJobParameters(chunkContext).getString(JobConstants.NEW_NODE_GROUP_LIST_JOB_PARAM);
  nodeGroupNames=ClusterUtil.getNodesFromNodeGroups(nodeGroupNameList);
  for (  String nodeGroupName : nodeGroupNames) {
    nodesInGroup=clusterEntityMgr.findAllNodes(clusterName,nodeGroupName);
    for (    NodeEntity ne : nodesInGroup) {
      addNodes.add(ne);
    }
  }
  foundNodeList=ClusterUtil.getReadyVmFromNodeGroups(addNodes);
  return foundNodeList;
}"
48346,"@Override protected List<NodeEntity> getNodesToBeSetPassword(ChunkContext chunkContext) throws TaskException {
  List<NodeEntity> toBeSetPassword=null;
  List<NodeEntity> nodesInGroup=null;
  List<String> nodeGroupNames=new ArrayList<String>();
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  String nodeGroupNameList=TrackableTasklet.getJobParameters(chunkContext).getString(JobConstants.NEW_NODE_GROUP_LIST_JOB_PARAM);
  for (  String nodeGroupName : nodeGroupNameList.split(""String_Node_Str"")) {
    nodeGroupNames.add(nodeGroupName);
  }
  for (  String nodeGroupName : nodeGroupNames) {
    nodesInGroup=clusterEntityMgr.findAllNodes(clusterName,nodeGroupName);
  }
  for (  NodeEntity node : nodesInGroup) {
    if (node.getStatus().ordinal() >= NodeStatus.VM_READY.ordinal()) {
      if (toBeSetPassword == null) {
        toBeSetPassword=new ArrayList<NodeEntity>();
      }
      toBeSetPassword.add(node);
    }
  }
  return toBeSetPassword;
}","@Override protected List<NodeEntity> getNodesToBeSetPassword(ChunkContext chunkContext) throws TaskException {
  List<NodeEntity> toBeSetPassword=null;
  List<NodeEntity> nodesInGroup=null;
  List<NodeEntity> addNodes=new ArrayList<NodeEntity>();
  List<String> nodeGroupNames=null;
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  String nodeGroupNameList=TrackableTasklet.getJobParameters(chunkContext).getString(JobConstants.NEW_NODE_GROUP_LIST_JOB_PARAM);
  nodeGroupNames=ClusterUtil.getNodesFromNodeGroups(nodeGroupNameList);
  for (  String nodeGroupName : nodeGroupNames) {
    nodesInGroup=clusterEntityMgr.findAllNodes(clusterName,nodeGroupName);
    for (    NodeEntity ne : nodesInGroup) {
      addNodes.add(ne);
    }
  }
  toBeSetPassword=ClusterUtil.getReadyVmFromNodeGroups(addNodes);
  return toBeSetPassword;
}"
48347,"@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String targetName=getJobParameters(chunkContext).getString(JobConstants.TARGET_NAME_JOB_PARAM);
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  if (targetName == null) {
    targetName=clusterName;
  }
  String jobName=chunkContext.getStepContext().getJobName();
  logger.info(""String_Node_Str"" + targetName + ""String_Node_Str""+ managementOperation+ ""String_Node_Str""+ jobName);
  serviceSyncup.syncUp(clusterName);
  logger.debug(""String_Node_Str"" + clusterName);
  boolean vmPowerOn=false;
  String vmPowerOnStr=getJobParameters(chunkContext).getString(JobConstants.IS_VM_POWER_ON);
  if (vmPowerOnStr != null) {
    logger.info(""String_Node_Str"" + vmPowerOnStr);
    vmPowerOn=Boolean.parseBoolean(vmPowerOnStr);
  }
  if (checkVMStatus && targetName.split(""String_Node_Str"").length == 3 && !vmPowerOn) {
    return RepeatStatus.FINISHED;
  }
  SoftwareManager softwareMgr=null;
  try {
    softwareMgr=softwareMgrs.getSoftwareManagerByClusterName(clusterName);
  }
 catch (  SoftwareManagerCollectorException e) {
    if (ManagementOperation.PRE_DESTROY.equals(managementOperation) || ManagementOperation.DESTROY.equals(managementOperation)) {
      return RepeatStatus.FINISHED;
    }
    throw e;
  }
  if (ManagementOperation.CONFIGURE.equals(managementOperation) || ManagementOperation.START.equals(managementOperation) || ManagementOperation.EXPAND.equals(managementOperation)|| JobConstants.RESUME_CLUSTER_JOB_NAME.equals(jobName)) {
    logger.info(""String_Node_Str"");
    List<NodeEntity> nodes=lockClusterEntityMgr.getClusterEntityMgr().findAllNodes(clusterName);
    Set<String> hostnames=new HashSet<String>();
    for (    NodeEntity node : nodes) {
      boolean force=JobUtils.getJobParameterForceClusterOperation(chunkContext);
      if (force && (node.getStatus() != NodeStatus.VM_READY)) {
        continue;
      }
      hostnames.add(node.getHostName());
    }
    ClusterCreate clusterSpec=clusterManager.getClusterSpec(clusterName);
    SyncHostsUtils.SyncHosts(clusterSpec,hostnames,softwareMgr);
  }
  StatusUpdater statusUpdater=new DefaultStatusUpdater(jobExecutionStatusHolder,getJobExecutionId(chunkContext));
  ISoftwareManagementTask task=null;
  String appMgrName=softwareMgr.getName();
  validateUserExistense();
  if (!Constants.IRONFAN.equals(appMgrName)) {
    task=createExternalTask(chunkContext,targetName,clusterName,statusUpdater);
  }
 else {
    task=createThriftTask(chunkContext,targetName,statusUpdater);
  }
  if (task != null) {
    Map<String,Object> ret=task.call();
    if (!(Boolean)ret.get(""String_Node_Str"")) {
      String errorMessage=(String)ret.get(""String_Node_Str"");
      putIntoJobExecutionContext(chunkContext,JobConstants.CURRENT_ERROR_MESSAGE,errorMessage);
      putIntoJobExecutionContext(chunkContext,JobConstants.SOFTWARE_MANAGEMENT_STEP_FAILE,true);
      throw TaskException.EXECUTION_FAILED(errorMessage);
    }
  }
  return RepeatStatus.FINISHED;
}","@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String targetName=getJobParameters(chunkContext).getString(JobConstants.TARGET_NAME_JOB_PARAM);
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  if (targetName == null) {
    targetName=clusterName;
  }
  String jobName=chunkContext.getStepContext().getJobName();
  logger.info(""String_Node_Str"" + targetName + ""String_Node_Str""+ managementOperation+ ""String_Node_Str""+ jobName);
  serviceSyncup.syncUp(clusterName);
  logger.debug(""String_Node_Str"" + clusterName);
  boolean vmPowerOn=false;
  String vmPowerOnStr=getJobParameters(chunkContext).getString(JobConstants.IS_VM_POWER_ON);
  if (vmPowerOnStr != null) {
    logger.info(""String_Node_Str"" + vmPowerOnStr);
    vmPowerOn=Boolean.parseBoolean(vmPowerOnStr);
  }
  if (checkVMStatus && targetName.split(""String_Node_Str"").length == 3 && !vmPowerOn) {
    return RepeatStatus.FINISHED;
  }
  SoftwareManager softwareMgr=null;
  try {
    softwareMgr=softwareMgrs.getSoftwareManagerByClusterName(clusterName);
  }
 catch (  SoftwareManagerCollectorException e) {
    if (ManagementOperation.PRE_DESTROY.equals(managementOperation) || ManagementOperation.DESTROY.equals(managementOperation)) {
      return RepeatStatus.FINISHED;
    }
    throw e;
  }
  if (ManagementOperation.CONFIGURE.equals(managementOperation) || ManagementOperation.START.equals(managementOperation) || JobConstants.RESUME_CLUSTER_JOB_NAME.equals(jobName)) {
    logger.info(""String_Node_Str"");
    List<NodeEntity> nodes=lockClusterEntityMgr.getClusterEntityMgr().findAllNodes(clusterName);
    Set<String> hostnames=new HashSet<String>();
    for (    NodeEntity node : nodes) {
      boolean force=JobUtils.getJobParameterForceClusterOperation(chunkContext);
      if (force && (node.getStatus() != NodeStatus.VM_READY)) {
        continue;
      }
      hostnames.add(node.getHostName());
    }
    ClusterCreate clusterSpec=clusterManager.getClusterSpec(clusterName);
    SyncHostsUtils.SyncHosts(clusterSpec,hostnames,softwareMgr);
  }
  StatusUpdater statusUpdater=new DefaultStatusUpdater(jobExecutionStatusHolder,getJobExecutionId(chunkContext));
  ISoftwareManagementTask task=null;
  String appMgrName=softwareMgr.getName();
  validateUserExistense();
  if (!Constants.IRONFAN.equals(appMgrName)) {
    task=createExternalTask(chunkContext,targetName,clusterName,statusUpdater);
  }
 else {
    task=createThriftTask(chunkContext,targetName,statusUpdater);
  }
  if (task != null) {
    Map<String,Object> ret=task.call();
    if (!(Boolean)ret.get(""String_Node_Str"")) {
      String errorMessage=(String)ret.get(""String_Node_Str"");
      putIntoJobExecutionContext(chunkContext,JobConstants.CURRENT_ERROR_MESSAGE,errorMessage);
      putIntoJobExecutionContext(chunkContext,JobConstants.SOFTWARE_MANAGEMENT_STEP_FAILE,true);
      throw TaskException.EXECUTION_FAILED(errorMessage);
    }
  }
  return RepeatStatus.FINISHED;
}"
48348,"private List<String> getNewNodeGroupVmNames(ChunkContext chunkContext,ClusterBlueprint clusterBlueprint){
  List<String> nodeGroupNames=new ArrayList<String>();
  String nodeGroupNameList=TrackableTasklet.getJobParameters(chunkContext).getString(JobConstants.NEW_NODE_GROUP_LIST_JOB_PARAM);
  for (  String nodeGroupName : nodeGroupNameList.split(""String_Node_Str"")) {
    nodeGroupNames.add(nodeGroupName);
  }
  List<String> addedNodeNames=new ArrayList<String>();
  for (  String groupName : nodeGroupNames) {
    for (    NodeGroupInfo group : clusterBlueprint.getNodeGroups()) {
      if (group.getName().equals(groupName)) {
        for (        NodeInfo node : group.getNodes()) {
          if (JobUtils.getJobParameterForceClusterOperation(chunkContext)) {
            NodeStatus status=lockedClusterEntityManager.getClusterEntityMgr().findNodeByName(node.getName()).getStatus();
            logger.info(String.format(""String_Node_Str"",node.getName(),status.name()));
            if ((status != NodeStatus.VM_READY) && (status != NodeStatus.BOOTSTRAP_FAILED)) {
              continue;
            }
          }
          addedNodeNames.add(node.getName());
        }
      }
    }
  }
  return addedNodeNames;
}","private List<String> getNewNodeGroupVmNames(ChunkContext chunkContext,ClusterBlueprint clusterBlueprint){
  List<String> nodeGroupNames=new ArrayList<String>();
  String nodeGroupNameList=TrackableTasklet.getJobParameters(chunkContext).getString(JobConstants.NEW_NODE_GROUP_LIST_JOB_PARAM);
  for (  String nodeGroupName : nodeGroupNameList.split(""String_Node_Str"")) {
    nodeGroupNames.add(nodeGroupName);
  }
  logger.info(""String_Node_Str"" + nodeGroupNameList);
  for (  String nodeName : nodeGroupNames) {
    logger.info(""String_Node_Str"" + nodeName);
  }
  List<String> addedNodeNames=new ArrayList<String>();
  for (  String groupName : nodeGroupNames) {
    for (    NodeGroupInfo group : clusterBlueprint.getNodeGroups()) {
      if (group.getName().equals(groupName)) {
        for (        NodeInfo node : group.getNodes()) {
          if (JobUtils.getJobParameterForceClusterOperation(chunkContext)) {
            NodeStatus status=lockedClusterEntityManager.getClusterEntityMgr().findNodeByName(node.getName()).getStatus();
            logger.info(String.format(""String_Node_Str"",node.getName(),status.name()));
            if ((status != NodeStatus.VM_READY) && (status != NodeStatus.BOOTSTRAP_FAILED)) {
              continue;
            }
          }
          addedNodeNames.add(node.getName());
        }
      }
    }
  }
  for (  String nodeName : addedNodeNames) {
    logger.info(""String_Node_Str"" + nodeName);
  }
  return addedNodeNames;
}"
48349,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void addCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean nodeGroup,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume){
  try {
    if (resume) {
      resumeCreateCluster(name);
      return;
    }
    if (!nodeGroup) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NOT_CONTAIN_SPECFILE);
      return;
    }
    if (specFilePath == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NOT_CONTAIN_SPECFILE);
      return;
    }
    ClusterRead cluster=restClient.get(name,false);
    if (cluster == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"" + name + ""String_Node_Str"");
      return;
    }
    NodeGroupAdd nodeGroupAdd=new NodeGroupAdd();
    NodeGroupAdd nodeGroupAddSpec=CommandsUtils.getObjectByJsonString(NodeGroupAdd.class,CommandsUtils.dataFromFile(specFilePath));
    nodeGroupAdd.setSpecFile(true);
    nodeGroupAdd.setNodeGroups(nodeGroupAddSpec.getNodeGroups());
    if (name.indexOf(""String_Node_Str"") != -1) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NODEGROUP + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
      return;
    }
 else     if (name.indexOf(""String_Node_Str"") != -1) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NODEGROUP + Constants.PARAM_NOT_CONTAIN_BLANK_SPACE);
      return;
    }
    restClient.addNodeGroups(name,nodeGroupAdd);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_RESULT_ADD);
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void addCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume){
  try {
    if (resume) {
      resumeCreateCluster(name);
      return;
    }
    if (specFilePath == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NOT_CONTAIN_SPECFILE);
      return;
    }
    ClusterRead cluster=restClient.get(name,false);
    if (cluster == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"" + name + ""String_Node_Str"");
      return;
    }
    NodeGroupAdd nodeGroupAdd=new NodeGroupAdd();
    NodeGroupAdd nodeGroupAddSpec=CommandsUtils.getObjectByJsonString(NodeGroupAdd.class,CommandsUtils.dataFromFile(specFilePath));
    nodeGroupAdd.setSpecFile(true);
    nodeGroupAdd.setNodeGroups(nodeGroupAddSpec.getNodeGroups());
    if (name.indexOf(""String_Node_Str"") != -1) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NODEGROUP + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
      return;
    }
 else     if (name.indexOf(""String_Node_Str"") != -1) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NODEGROUP + Constants.PARAM_NOT_CONTAIN_BLANK_SPACE);
      return;
    }
    restClient.addNodeGroups(name,nodeGroupAdd);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_RESULT_ADD);
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
}"
48350,"@ClusterManagerPointcut public Long addCluster(String clusterName,NodeGroupCreate[] nodeGroupsAdd) throws Exception {
  Long taskId=null;
  List<BaseNode> vNodes=new ArrayList<BaseNode>();
  String rpNames=null;
  ClusterCreate clusterSpec=clusterConfigMgr.getClusterConfig(clusterName);
  List<NodeEntity> nodes=clusterEntityMgr.findAllNodes(clusterName);
  for (  NodeEntity node : nodes) {
    rpNames=node.getVcRp().getVcResourcePool();
    if (null != rpNames)     break;
  }
  clusterSpec.setNodeGroups(nodeGroupsAdd);
  for (  NodeGroupCreate ng : nodeGroupsAdd) {
    BaseNode node=new BaseNode();
    NodeGroupEntity group=clusterEntityMgr.findByName(clusterName,ng.getName());
    ClusterEntity clusterEntity=clusterEntityMgr.findByName(clusterName);
    if (clusterEntity == null) {
      throw ClusterConfigException.CLUSTER_CONFIG_NOT_FOUND(clusterName);
    }
    if (0 == ng.getInstanceNum()) {
      throw ClusterManagerException.NODE_GROUP_CANNOT_BE_ZERO(ng.getName());
    }
    if (group == null) {
      NodeGroupEntity addNodeGroupEntity=new NodeGroupEntity();
      addNodeGroupEntity.setName(ng.getName());
      addNodeGroupEntity.setRoles((new Gson()).toJson(ng.getRoles()));
      addNodeGroupEntity.setNodeType(ng.getInstanceType());
      addNodeGroupEntity.setDefineInstanceNum(ng.getInstanceNum());
      addNodeGroupEntity.setCpuNum(ng.getCpuNum());
      addNodeGroupEntity.setMemorySize(ng.getMemCapacityMB());
      addNodeGroupEntity.setHaFlag(ng.getHaFlag());
      if (null != ng.getStorage()) {
        if (ng.getStorage().getType().equals(Datastore.DatastoreType.SHARED.toString())) {
          addNodeGroupEntity.setStorageType(Datastore.DatastoreType.SHARED);
        }
 else         if (ng.getStorage().getType().equals(Datastore.DatastoreType.LOCAL.toString())) {
          addNodeGroupEntity.setStorageType(Datastore.DatastoreType.LOCAL);
        }
        addNodeGroupEntity.setStorageSize(ng.getStorage().getSizeGB());
        addNodeGroupEntity.setVcDatastoreNameList(ng.getStorage().getDsNames());
        addNodeGroupEntity.setDdDatastoreNameList(ng.getStorage().getDsNames4Data());
        addNodeGroupEntity.setSdDatastoreNameList(ng.getStorage().getDsNames4System());
      }
      addNodeGroupEntity.setGroupRacks(ng.getReferredGroup());
      addNodeGroupEntity.setHadoopConfig((new Gson()).toJson(ng.getConfiguration()));
      addNodeGroupEntity.setCluster(clusterEntity);
      addNodeGroupEntity.setVmFolderPath(clusterEntity);
      ng.setVmFolderPath(clusterEntity.getRootFolder() + ""String_Node_Str"" + ng.getName());
      logger.info(""String_Node_Str"" + ng.getName() + ""String_Node_Str""+ clusterName+ ""String_Node_Str"");
      clusterEntityMgr.insert(addNodeGroupEntity);
    }
 else {
      logger.error(""String_Node_Str"" + ng.getName() + ""String_Node_Str""+ clusterName+ ""String_Node_Str"");
      throw ClusterManagerException.NODE_GROUP_HAS_EXISTED(clusterName,ng.getName());
    }
    node.setCluster(clusterSpec);
    node.setTargetVcCluster(clusterSpec.getVcClusters().get(0).getName());
    node.setNodeGroup(ng);
    node.setTargetRp(rpNames);
    vNodes.add(node);
  }
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.ADDING);
  if (clusteringService.addNodeGroups(clusterSpec,nodeGroupsAdd,vNodes)) {
    taskId=resumeClusterCreation(clusterName);
  }
 else {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.PROVISION_ERROR);
    throw ClusterManagerException.ADD_NODE_GROUP_FAILED(clusterName);
  }
  return taskId;
}","@ClusterManagerPointcut public Long addCluster(String clusterName,NodeGroupCreate[] nodeGroupsAdd) throws Exception {
  Long taskId=null;
  List<BaseNode> vNodes=new ArrayList<BaseNode>();
  String rpNames=null;
  ClusterCreate clusterSpec=clusterConfigMgr.getClusterConfig(clusterName);
  List<NodeEntity> nodes=clusterEntityMgr.findAllNodes(clusterName);
  for (  NodeEntity node : nodes) {
    rpNames=node.getVcRp().getVcResourcePool();
    if (null != rpNames)     break;
  }
  clusterSpec.setNodeGroups(nodeGroupsAdd);
  for (  NodeGroupCreate ng : nodeGroupsAdd) {
    BaseNode node=new BaseNode();
    NodeGroupEntity group=clusterEntityMgr.findByName(clusterName,ng.getName());
    ClusterEntity clusterEntity=clusterEntityMgr.findByName(clusterName);
    if (clusterEntity == null) {
      throw ClusterConfigException.CLUSTER_CONFIG_NOT_FOUND(clusterName);
    }
    if (0 == ng.getInstanceNum()) {
      throw ClusterManagerException.NODE_GROUP_CANNOT_BE_ZERO(ng.getName());
    }
    if (group == null) {
      NodeGroupEntity addNodeGroupEntity=new NodeGroupEntity();
      addNodeGroupEntity.setName(ng.getName());
      addNodeGroupEntity.setRoles((new Gson()).toJson(ng.getRoles()));
      addNodeGroupEntity.setNodeType(ng.getInstanceType());
      addNodeGroupEntity.setDefineInstanceNum(ng.getInstanceNum());
      addNodeGroupEntity.setCpuNum(ng.getCpuNum());
      addNodeGroupEntity.setMemorySize(ng.getMemCapacityMB());
      addNodeGroupEntity.setHaFlag(ng.getHaFlag());
      if (null != ng.getStorage()) {
        if (ng.getStorage().getType().equals(Datastore.DatastoreType.SHARED.toString())) {
          addNodeGroupEntity.setStorageType(Datastore.DatastoreType.SHARED);
        }
 else         if (ng.getStorage().getType().equals(Datastore.DatastoreType.LOCAL.toString())) {
          addNodeGroupEntity.setStorageType(Datastore.DatastoreType.LOCAL);
        }
        addNodeGroupEntity.setStorageSize(ng.getStorage().getSizeGB());
        addNodeGroupEntity.setVcDatastoreNameList(ng.getStorage().getDsNames());
        addNodeGroupEntity.setDdDatastoreNameList(ng.getStorage().getDsNames4Data());
        addNodeGroupEntity.setSdDatastoreNameList(ng.getStorage().getDsNames4System());
      }
      addNodeGroupEntity.setGroupRacks(ng.getReferredGroup());
      addNodeGroupEntity.setHadoopConfig((new Gson()).toJson(ng.getConfiguration()));
      addNodeGroupEntity.setCluster(clusterEntity);
      addNodeGroupEntity.setVmFolderPath(clusterEntity);
      ng.setVmFolderPath(clusterEntity.getRootFolder() + ""String_Node_Str"" + ng.getName());
      logger.info(""String_Node_Str"" + ng.getName() + ""String_Node_Str""+ clusterName+ ""String_Node_Str"");
      clusterEntityMgr.insert(addNodeGroupEntity);
    }
 else {
      logger.error(""String_Node_Str"" + ng.getName() + ""String_Node_Str""+ clusterName+ ""String_Node_Str"");
      throw ClusterManagerException.NODE_GROUP_HAS_EXISTED(clusterName,ng.getName());
    }
    node.setCluster(clusterSpec);
    node.setTargetVcCluster(clusterSpec.getVcClusters().get(0).getName());
    node.setNodeGroup(ng);
    node.setTargetRp(rpNames);
    vNodes.add(node);
  }
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.ADDING);
  if (clusteringService.addNodeGroups(clusterSpec,nodeGroupsAdd,vNodes)) {
    taskId=clusterAddExecute(clusterName,nodeGroupsAdd);
  }
 else {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.PROVISION_ERROR);
    throw ClusterManagerException.ADD_NODE_GROUP_FAILED(clusterName);
  }
  return taskId;
}"
48351,"@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String targetName=getJobParameters(chunkContext).getString(JobConstants.TARGET_NAME_JOB_PARAM);
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  if (targetName == null) {
    targetName=clusterName;
  }
  String jobName=chunkContext.getStepContext().getJobName();
  logger.info(""String_Node_Str"" + targetName + ""String_Node_Str""+ managementOperation+ ""String_Node_Str""+ jobName);
  serviceSyncup.syncUp(clusterName);
  logger.debug(""String_Node_Str"" + clusterName);
  boolean vmPowerOn=false;
  String vmPowerOnStr=getJobParameters(chunkContext).getString(JobConstants.IS_VM_POWER_ON);
  if (vmPowerOnStr != null) {
    logger.info(""String_Node_Str"" + vmPowerOnStr);
    vmPowerOn=Boolean.parseBoolean(vmPowerOnStr);
  }
  if (checkVMStatus && targetName.split(""String_Node_Str"").length == 3 && !vmPowerOn) {
    return RepeatStatus.FINISHED;
  }
  SoftwareManager softwareMgr=null;
  try {
    softwareMgr=softwareMgrs.getSoftwareManagerByClusterName(clusterName);
  }
 catch (  SoftwareManagerCollectorException e) {
    if (ManagementOperation.PRE_DESTROY.equals(managementOperation) || ManagementOperation.DESTROY.equals(managementOperation)) {
      return RepeatStatus.FINISHED;
    }
    throw e;
  }
  if (ManagementOperation.CONFIGURE.equals(managementOperation) || ManagementOperation.START.equals(managementOperation) || JobConstants.RESUME_CLUSTER_JOB_NAME.equals(jobName)) {
    logger.info(""String_Node_Str"");
    List<NodeEntity> nodes=lockClusterEntityMgr.getClusterEntityMgr().findAllNodes(clusterName);
    Set<String> hostnames=new HashSet<String>();
    for (    NodeEntity node : nodes) {
      boolean force=JobUtils.getJobParameterForceClusterOperation(chunkContext);
      if (force && (node.getStatus() != NodeStatus.VM_READY)) {
        continue;
      }
      hostnames.add(node.getHostName());
    }
    ClusterCreate clusterSpec=clusterManager.getClusterSpec(clusterName);
    SyncHostsUtils.SyncHosts(clusterSpec,hostnames,softwareMgr);
  }
  StatusUpdater statusUpdater=new DefaultStatusUpdater(jobExecutionStatusHolder,getJobExecutionId(chunkContext));
  ISoftwareManagementTask task=null;
  String appMgrName=softwareMgr.getName();
  validateUserExistense();
  if (!Constants.IRONFAN.equals(appMgrName)) {
    task=createExternalTask(chunkContext,targetName,clusterName,statusUpdater);
  }
 else {
    task=createThriftTask(chunkContext,targetName,statusUpdater);
  }
  if (task != null) {
    Map<String,Object> ret=task.call();
    if (!(Boolean)ret.get(""String_Node_Str"")) {
      String errorMessage=(String)ret.get(""String_Node_Str"");
      putIntoJobExecutionContext(chunkContext,JobConstants.CURRENT_ERROR_MESSAGE,errorMessage);
      putIntoJobExecutionContext(chunkContext,JobConstants.SOFTWARE_MANAGEMENT_STEP_FAILE,true);
      throw TaskException.EXECUTION_FAILED(errorMessage);
    }
  }
  return RepeatStatus.FINISHED;
}","@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String targetName=getJobParameters(chunkContext).getString(JobConstants.TARGET_NAME_JOB_PARAM);
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  if (targetName == null) {
    targetName=clusterName;
  }
  String jobName=chunkContext.getStepContext().getJobName();
  logger.info(""String_Node_Str"" + targetName + ""String_Node_Str""+ managementOperation+ ""String_Node_Str""+ jobName);
  serviceSyncup.syncUp(clusterName);
  logger.debug(""String_Node_Str"" + clusterName);
  boolean vmPowerOn=false;
  String vmPowerOnStr=getJobParameters(chunkContext).getString(JobConstants.IS_VM_POWER_ON);
  if (vmPowerOnStr != null) {
    logger.info(""String_Node_Str"" + vmPowerOnStr);
    vmPowerOn=Boolean.parseBoolean(vmPowerOnStr);
  }
  if (checkVMStatus && targetName.split(""String_Node_Str"").length == 3 && !vmPowerOn) {
    return RepeatStatus.FINISHED;
  }
  SoftwareManager softwareMgr=null;
  try {
    softwareMgr=softwareMgrs.getSoftwareManagerByClusterName(clusterName);
  }
 catch (  SoftwareManagerCollectorException e) {
    if (ManagementOperation.PRE_DESTROY.equals(managementOperation) || ManagementOperation.DESTROY.equals(managementOperation)) {
      return RepeatStatus.FINISHED;
    }
    throw e;
  }
  if (ManagementOperation.CONFIGURE.equals(managementOperation) || ManagementOperation.START.equals(managementOperation) || ManagementOperation.ADD.equals(managementOperation)|| JobConstants.RESUME_CLUSTER_JOB_NAME.equals(jobName)) {
    logger.info(""String_Node_Str"");
    List<NodeEntity> nodes=lockClusterEntityMgr.getClusterEntityMgr().findAllNodes(clusterName);
    Set<String> hostnames=new HashSet<String>();
    for (    NodeEntity node : nodes) {
      boolean force=JobUtils.getJobParameterForceClusterOperation(chunkContext);
      if (force && (node.getStatus() != NodeStatus.VM_READY)) {
        continue;
      }
      hostnames.add(node.getHostName());
    }
    ClusterCreate clusterSpec=clusterManager.getClusterSpec(clusterName);
    SyncHostsUtils.SyncHosts(clusterSpec,hostnames,softwareMgr);
  }
  StatusUpdater statusUpdater=new DefaultStatusUpdater(jobExecutionStatusHolder,getJobExecutionId(chunkContext));
  ISoftwareManagementTask task=null;
  String appMgrName=softwareMgr.getName();
  validateUserExistense();
  if (!Constants.IRONFAN.equals(appMgrName)) {
    task=createExternalTask(chunkContext,targetName,clusterName,statusUpdater);
  }
 else {
    task=createThriftTask(chunkContext,targetName,statusUpdater);
  }
  if (task != null) {
    Map<String,Object> ret=task.call();
    if (!(Boolean)ret.get(""String_Node_Str"")) {
      String errorMessage=(String)ret.get(""String_Node_Str"");
      putIntoJobExecutionContext(chunkContext,JobConstants.CURRENT_ERROR_MESSAGE,errorMessage);
      putIntoJobExecutionContext(chunkContext,JobConstants.SOFTWARE_MANAGEMENT_STEP_FAILE,true);
      throw TaskException.EXECUTION_FAILED(errorMessage);
    }
  }
  return RepeatStatus.FINISHED;
}"
48352,"@Override public Map<String,Object> call() throws Exception {
  Map<String,Object> result=new HashMap<String,Object>();
  ClusterReportQueue queue=new ClusterReportQueue();
  Thread progressThread=null;
  ExternalProgressMonitor monitor=new ExternalProgressMonitor(targetName,queue,statusUpdater,lockedClusterEntityManager);
  progressThread=new Thread(monitor,""String_Node_Str"" + targetName);
  progressThread.setDaemon(true);
  progressThread.start();
  boolean success=false;
  boolean force=false;
  if (chunkContext != null) {
    force=JobUtils.getJobParameterForceClusterOperation(chunkContext);
  }
  try {
switch (managementOperation) {
case CREATE:
      success=softwareManager.createCluster(clusterBlueprint,queue);
    break;
case CONFIGURE:
  success=softwareManager.reconfigCluster(clusterBlueprint,queue);
break;
case PRE_DESTROY:
if (softwareManager == null) {
logger.warn(""String_Node_Str"" + clusterBlueprint.getName() + ""String_Node_Str"");
logger.warn(""String_Node_Str"");
success=true;
}
 else {
try {
  softwareManager.onDeleteCluster(clusterBlueprint,queue);
}
 catch (Exception e) {
  String errMsg=""String_Node_Str"" + softwareManager.getName() + ""String_Node_Str"";
  logger.error(errMsg,e);
}
success=true;
}
break;
case DESTROY:
success=softwareManager.deleteCluster(clusterBlueprint,queue);
break;
case START:
success=softwareManager.startCluster(clusterBlueprint,queue,force);
break;
case STOP:
success=softwareManager.onStopCluster(clusterBlueprint,queue);
break;
case START_NODES:
List<NodeInfo> nodes=new ArrayList<NodeInfo>();
for (NodeGroupInfo group : clusterBlueprint.getNodeGroups()) {
if (group != null) {
for (NodeInfo node : group.getNodes()) {
if (node.getName().equals(targetName)) {
nodes.add(node);
break;
}
}
if (!nodes.isEmpty()) {
break;
}
}
}
success=softwareManager.startNodes(clusterBlueprint.getName(),nodes,queue);
break;
case QUERY:
ClusterReport report=softwareManager.queryClusterStatus(clusterBlueprint);
queue.addClusterReport(report);
success=true;
break;
case RESIZE:
AuAssert.check(chunkContext != null);
List<String> addedNodes=getResizedVmNames(chunkContext,clusterBlueprint);
success=softwareManager.scaleOutCluster(clusterBlueprint,addedNodes,queue,force);
break;
default :
success=true;
}
}
 catch (Throwable t) {
logger.error(""String_Node_Str"" + managementOperation.name() + ""String_Node_Str""+ targetName,t);
result.put(""String_Node_Str"",t.getMessage());
}
 finally {
if (progressThread != null) {
monitor.setStop(true);
progressThread.interrupt();
progressThread.join();
}
}
result.put(""String_Node_Str"",success);
if (!success) {
logger.error(""String_Node_Str"" + result.get(""String_Node_Str""));
}
return result;
}","@Override public Map<String,Object> call() throws Exception {
  Map<String,Object> result=new HashMap<String,Object>();
  ClusterReportQueue queue=new ClusterReportQueue();
  Thread progressThread=null;
  ExternalProgressMonitor monitor=new ExternalProgressMonitor(targetName,queue,statusUpdater,lockedClusterEntityManager);
  progressThread=new Thread(monitor,""String_Node_Str"" + targetName);
  progressThread.setDaemon(true);
  progressThread.start();
  boolean success=false;
  boolean force=false;
  if (chunkContext != null) {
    force=JobUtils.getJobParameterForceClusterOperation(chunkContext);
  }
  try {
switch (managementOperation) {
case CREATE:
      success=softwareManager.createCluster(clusterBlueprint,queue);
    break;
case CONFIGURE:
  success=softwareManager.reconfigCluster(clusterBlueprint,queue);
break;
case PRE_DESTROY:
if (softwareManager == null) {
logger.warn(""String_Node_Str"" + clusterBlueprint.getName() + ""String_Node_Str"");
logger.warn(""String_Node_Str"");
success=true;
}
 else {
try {
  softwareManager.onDeleteCluster(clusterBlueprint,queue);
}
 catch (Exception e) {
  String errMsg=""String_Node_Str"" + softwareManager.getName() + ""String_Node_Str"";
  logger.error(errMsg,e);
}
success=true;
}
break;
case DESTROY:
success=softwareManager.deleteCluster(clusterBlueprint,queue);
break;
case START:
success=softwareManager.startCluster(clusterBlueprint,queue,force);
break;
case STOP:
success=softwareManager.onStopCluster(clusterBlueprint,queue);
break;
case START_NODES:
List<NodeInfo> nodes=new ArrayList<NodeInfo>();
for (NodeGroupInfo group : clusterBlueprint.getNodeGroups()) {
if (group != null) {
for (NodeInfo node : group.getNodes()) {
if (node.getName().equals(targetName)) {
nodes.add(node);
break;
}
}
if (!nodes.isEmpty()) {
break;
}
}
}
success=softwareManager.startNodes(clusterBlueprint.getName(),nodes,queue);
break;
case QUERY:
ClusterReport report=softwareManager.queryClusterStatus(clusterBlueprint);
queue.addClusterReport(report);
success=true;
break;
case RESIZE:
AuAssert.check(chunkContext != null);
List<String> addedNodes=getResizedVmNames(chunkContext,clusterBlueprint);
success=softwareManager.scaleOutCluster(clusterBlueprint,addedNodes,queue,force);
break;
case ADD:
List<String> addedNodeGroups=getNewNodeGroupVmNames(chunkContext,clusterBlueprint);
success=softwareManager.scaleOutCluster(clusterBlueprint,addedNodeGroups,queue,force);
default :
success=true;
}
}
 catch (Throwable t) {
logger.error(""String_Node_Str"" + managementOperation.name() + ""String_Node_Str""+ targetName,t);
result.put(""String_Node_Str"",t.getMessage());
}
 finally {
if (progressThread != null) {
monitor.setStop(true);
progressThread.interrupt();
progressThread.join();
}
}
result.put(""String_Node_Str"",success);
if (!success) {
logger.error(""String_Node_Str"" + result.get(""String_Node_Str""));
}
return result;
}"
48353,"private void validateMemorySize(List<NodeGroupEntity> nodeGroups,List<String> failedMsgList){
  boolean validated=true;
  StringBuilder invalidNodeGroupNames=new StringBuilder();
  for (  NodeGroupEntity nodeGroup : nodeGroups) {
    if (nodeGroup.getMemorySize() < Constants.MIN_MEM_SIZE) {
      validated=false;
      invalidNodeGroupNames.append(nodeGroup.getName()).append(""String_Node_Str"");
    }
  }
  if (!validated) {
    StringBuilder errorMsgBuff=new StringBuilder();
    invalidNodeGroupNames.delete(invalidNodeGroupNames.length() - 1,invalidNodeGroupNames.length());
    failedMsgList.add(errorMsgBuff.append(""String_Node_Str"" + Constants.MIN_MEM_SIZE + ""String_Node_Str"").append(invalidNodeGroupNames.toString()).append(""String_Node_Str"").toString());
  }
}","private void validateMemorySize(Set<NodeGroupEntity> nodeGroups,List<String> failedMsgList){
  boolean validated=true;
  StringBuilder invalidNodeGroupNames=new StringBuilder();
  for (  NodeGroupEntity nodeGroup : nodeGroups) {
    if (nodeGroup.getMemorySize() < Constants.MIN_MEM_SIZE) {
      validated=false;
      invalidNodeGroupNames.append(nodeGroup.getName()).append(""String_Node_Str"");
    }
  }
  if (!validated) {
    StringBuilder errorMsgBuff=new StringBuilder();
    invalidNodeGroupNames.delete(invalidNodeGroupNames.length() - 1,invalidNodeGroupNames.length());
    failedMsgList.add(errorMsgBuff.append(""String_Node_Str"" + Constants.MIN_MEM_SIZE + ""String_Node_Str"").append(invalidNodeGroupNames.toString()).append(""String_Node_Str"").toString());
  }
}"
48354,"@Transactional public ClusterEntity createClusterConfig(ClusterCreate cluster){
  String name=cluster.getName();
  if (name == null || name.isEmpty()) {
    throw ClusterConfigException.CLUSTER_NAME_MISSING();
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  String appManager=cluster.getAppManager();
  if (appManager == null) {
    appManager=Constants.IRONFAN;
  }
  SoftwareManager softwareManager=getSoftwareManager(appManager);
  HadoopStack stack=filterDistroFromAppManager(softwareManager,cluster.getDistro());
  if (cluster.getDistro() == null || stack == null) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",cluster.getDistro());
  }
  ClusterBlueprint blueprint=cluster.toBlueprint();
  try {
    softwareManager.validateBlueprint(cluster.toBlueprint());
    cluster.validateClusterCreate(failedMsgList,warningMsgList);
  }
 catch (  ValidationException e) {
    failedMsgList.addAll(e.getFailedMsgList());
    warningMsgList.addAll(e.getWarningMsgList());
  }
  if (!failedMsgList.isEmpty()) {
    throw ClusterConfigException.INVALID_SPEC(failedMsgList);
  }
  if (!validateRacksInfo(cluster,failedMsgList)) {
    throw ClusterConfigException.INVALID_PLACEMENT_POLICIES(failedMsgList);
  }
  String localRepoURL=cluster.getLocalRepoURL();
  if (!CommonUtil.isBlank(localRepoURL) && !validateLocalRepoURL(localRepoURL)) {
    throw ClusterConfigException.INVALID_LOCAL_REPO_URL(failedMsgList);
  }
  try {
    ClusterEntity entity=clusterEntityMgr.findByName(name);
    if (entity != null) {
      logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
      throw BddException.ALREADY_EXISTS(""String_Node_Str"",name);
    }
    updateInfrastructure(cluster,softwareManager,blueprint);
    logger.debug(""String_Node_Str"" + name);
    Gson gson=new Gson();
    ClusterEntity clusterEntity=new ClusterEntity(name);
    clusterEntity.setAppManager(cluster.getAppManager());
    clusterEntity.setDistro(cluster.getDistro());
    clusterEntity.setDistroVendor(cluster.getDistroVendor());
    clusterEntity.setDistroVersion(cluster.getDistroVersion());
    clusterEntity.setStartAfterDeploy(true);
    clusterEntity.setPassword(cluster.getPassword());
    clusterEntity.setTemplateId(this.nodeTemplateService.getNodeTemplateIdByName(cluster.getTemplateName()));
    clusterEntity.setVersion(clusterEntityMgr.getServerVersion());
    if (softwareManager.containsComputeOnlyNodeGroups(blueprint)) {
      clusterEntity.setAutomationEnable(automationEnable);
    }
 else {
      clusterEntity.setAutomationEnable(null);
    }
    clusterEntity.setVhmMinNum(-1);
    clusterEntity.setVhmMaxNum(-1);
    if (cluster.getRpNames() != null && cluster.getRpNames().size() > 0) {
      logger.debug(""String_Node_Str"" + cluster.getRpNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcRpNameList(cluster.getRpNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    if (cluster.getDsNames() != null && !cluster.getDsNames().isEmpty()) {
      logger.debug(""String_Node_Str"" + cluster.getDsNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcDatastoreNameList(cluster.getDsNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    clusterEntity.setNetworkConfig(validateAndConvertNetNamesToNetConfigs(cluster.getNetworkConfig(),cluster.getDistroVendor().equalsIgnoreCase(Constants.MAPR_VENDOR)));
    clusterEntity.setVhmJobTrackerPort(""String_Node_Str"");
    if (cluster.getConfiguration() != null && cluster.getConfiguration().size() > 0) {
      clusterEntity.setHadoopConfig((new Gson()).toJson(cluster.getConfiguration()));
      updateVhmJobTrackerPort(cluster,clusterEntity);
    }
    setInfraConfig(cluster,clusterEntity);
    setAdvancedProperties(cluster.getExternalHDFS(),cluster.getExternalMapReduce(),localRepoURL,cluster.getExternalNamenode(),cluster.getExternalSecondaryNamenode(),cluster.getExternalDatanodes(),cluster.getClusterCloneType(),clusterEntity);
    NodeGroupCreate[] groups=cluster.getNodeGroups();
    if (groups != null && groups.length > 0) {
      clusterEntity.setNodeGroups(convertNodeGroupsToEntities(gson,clusterEntity,cluster.getDistro(),groups,cluster.isValidateConfig()));
      validateMemorySize(clusterEntity.getNodeGroups(),failedMsgList);
      if (!failedMsgList.isEmpty()) {
        throw ClusterConfigException.INVALID_SPEC(failedMsgList);
      }
    }
    if (!CommonUtil.isBlank(cluster.getAppManager()) && Constants.IRONFAN.equals(cluster.getAppManager()))     for (int i=0; i < clusterEntity.getNodeGroups().size(); i++) {
      NodeGroupEntity group=clusterEntity.getNodeGroups().get(i);
      String groupRoles=group.getRoles();
      if ((group.getLatencySensitivity() == LatencyPriority.HIGH) && ((groupRoles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString())))) {
        setHbaseRegionServerOpts(cluster,group);
        if (cluster.getConfiguration() != null && cluster.getConfiguration().size() > 0) {
          clusterEntity.setHadoopConfig((new Gson()).toJson(cluster.getConfiguration()));
        }
        break;
      }
    }
    if (cluster.getTopologyPolicy() == null) {
      clusterEntity.setTopologyPolicy(TopologyType.NONE);
    }
 else {
      clusterEntity.setTopologyPolicy(cluster.getTopologyPolicy());
    }
    if (clusterEntity.getTopologyPolicy() == TopologyType.HVE) {
      boolean hveSupported=false;
      if (clusterEntity.getDistro() != null) {
        HadoopStack hadoopStack=filterDistroFromAppManager(softwareManager,clusterEntity.getDistro());
        if (hadoopStack != null) {
          hveSupported=hadoopStack.isHveSupported();
        }
      }
      if (!hveSupported) {
        throw ClusterConfigException.INVALID_TOPOLOGY_POLICY(clusterEntity.getTopologyPolicy(),""String_Node_Str"");
      }
    }
    clusterEntityMgr.insert(clusterEntity);
    logger.debug(""String_Node_Str"" + name);
    return clusterEntity;
  }
 catch (  UniqueConstraintViolationException ex) {
    logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
    throw BddException.ALREADY_EXISTS(ex,""String_Node_Str"",name);
  }
}","@Transactional public ClusterEntity createClusterConfig(ClusterCreate cluster){
  String name=cluster.getName();
  if (name == null || name.isEmpty()) {
    throw ClusterConfigException.CLUSTER_NAME_MISSING();
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  String appManager=cluster.getAppManager();
  if (appManager == null) {
    appManager=Constants.IRONFAN;
  }
  SoftwareManager softwareManager=getSoftwareManager(appManager);
  HadoopStack stack=filterDistroFromAppManager(softwareManager,cluster.getDistro());
  if (cluster.getDistro() == null || stack == null) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",cluster.getDistro());
  }
  ClusterBlueprint blueprint=cluster.toBlueprint();
  try {
    softwareManager.validateBlueprint(cluster.toBlueprint());
    cluster.validateClusterCreate(failedMsgList,warningMsgList);
  }
 catch (  ValidationException e) {
    failedMsgList.addAll(e.getFailedMsgList());
    warningMsgList.addAll(e.getWarningMsgList());
  }
  if (!failedMsgList.isEmpty()) {
    throw ClusterConfigException.INVALID_SPEC(failedMsgList);
  }
  if (!validateRacksInfo(cluster,failedMsgList)) {
    throw ClusterConfigException.INVALID_PLACEMENT_POLICIES(failedMsgList);
  }
  String localRepoURL=cluster.getLocalRepoURL();
  if (!CommonUtil.isBlank(localRepoURL) && !validateLocalRepoURL(localRepoURL)) {
    throw ClusterConfigException.INVALID_LOCAL_REPO_URL(failedMsgList);
  }
  try {
    ClusterEntity entity=clusterEntityMgr.findByName(name);
    if (entity != null) {
      logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
      throw BddException.ALREADY_EXISTS(""String_Node_Str"",name);
    }
    updateInfrastructure(cluster,softwareManager,blueprint);
    logger.debug(""String_Node_Str"" + name);
    Gson gson=new Gson();
    ClusterEntity clusterEntity=new ClusterEntity(name);
    clusterEntity.setAppManager(cluster.getAppManager());
    clusterEntity.setDistro(cluster.getDistro());
    clusterEntity.setDistroVendor(cluster.getDistroVendor());
    clusterEntity.setDistroVersion(cluster.getDistroVersion());
    clusterEntity.setStartAfterDeploy(true);
    clusterEntity.setPassword(cluster.getPassword());
    clusterEntity.setTemplateId(this.nodeTemplateService.getNodeTemplateIdByName(cluster.getTemplateName()));
    clusterEntity.setVersion(clusterEntityMgr.getServerVersion());
    if (softwareManager.containsComputeOnlyNodeGroups(blueprint)) {
      clusterEntity.setAutomationEnable(automationEnable);
    }
 else {
      clusterEntity.setAutomationEnable(null);
    }
    clusterEntity.setVhmMinNum(-1);
    clusterEntity.setVhmMaxNum(-1);
    if (cluster.getRpNames() != null && cluster.getRpNames().size() > 0) {
      logger.debug(""String_Node_Str"" + cluster.getRpNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcRpNameList(cluster.getRpNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    if (cluster.getDsNames() != null && !cluster.getDsNames().isEmpty()) {
      logger.debug(""String_Node_Str"" + cluster.getDsNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcDatastoreNameList(cluster.getDsNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    clusterEntity.setNetworkConfig(validateAndConvertNetNamesToNetConfigs(cluster.getNetworkConfig(),cluster.getDistroVendor().equalsIgnoreCase(Constants.MAPR_VENDOR)));
    clusterEntity.setVhmJobTrackerPort(""String_Node_Str"");
    if (cluster.getConfiguration() != null && cluster.getConfiguration().size() > 0) {
      clusterEntity.setHadoopConfig((new Gson()).toJson(cluster.getConfiguration()));
      updateVhmJobTrackerPort(cluster,clusterEntity);
    }
    setInfraConfig(cluster,clusterEntity);
    setAdvancedProperties(cluster.getExternalHDFS(),cluster.getExternalMapReduce(),localRepoURL,cluster.getExternalNamenode(),cluster.getExternalSecondaryNamenode(),cluster.getExternalDatanodes(),cluster.getClusterCloneType(),clusterEntity);
    NodeGroupCreate[] groups=cluster.getNodeGroups();
    if (groups != null && groups.length > 0) {
      clusterEntity.setNodeGroups(convertNodeGroupsToEntities(gson,clusterEntity,cluster.getDistro(),groups,cluster.isValidateConfig()));
      validateMemorySize(clusterEntity.getNodeGroups(),failedMsgList);
      if (!failedMsgList.isEmpty()) {
        throw ClusterConfigException.INVALID_SPEC(failedMsgList);
      }
    }
    if (!CommonUtil.isBlank(cluster.getAppManager()) && Constants.IRONFAN.equals(cluster.getAppManager()))     for (    NodeGroupEntity group : clusterEntity.getNodeGroups()) {
      String groupRoles=group.getRoles();
      if ((group.getLatencySensitivity() == LatencyPriority.HIGH) && ((groupRoles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString())))) {
        setHbaseRegionServerOpts(cluster,group);
        if (cluster.getConfiguration() != null && cluster.getConfiguration().size() > 0) {
          clusterEntity.setHadoopConfig((new Gson()).toJson(cluster.getConfiguration()));
        }
        break;
      }
    }
    if (cluster.getTopologyPolicy() == null) {
      clusterEntity.setTopologyPolicy(TopologyType.NONE);
    }
 else {
      clusterEntity.setTopologyPolicy(cluster.getTopologyPolicy());
    }
    if (clusterEntity.getTopologyPolicy() == TopologyType.HVE) {
      boolean hveSupported=false;
      if (clusterEntity.getDistro() != null) {
        HadoopStack hadoopStack=filterDistroFromAppManager(softwareManager,clusterEntity.getDistro());
        if (hadoopStack != null) {
          hveSupported=hadoopStack.isHveSupported();
        }
      }
      if (!hveSupported) {
        throw ClusterConfigException.INVALID_TOPOLOGY_POLICY(clusterEntity.getTopologyPolicy(),""String_Node_Str"");
      }
    }
    clusterEntityMgr.insert(clusterEntity);
    logger.debug(""String_Node_Str"" + name);
    return clusterEntity;
  }
 catch (  UniqueConstraintViolationException ex) {
    logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
    throw BddException.ALREADY_EXISTS(ex,""String_Node_Str"",name);
  }
}"
48355,"@SuppressWarnings(""String_Node_Str"") private void convertClusterConfig(ClusterEntity clusterEntity,ClusterCreate clusterConfig,boolean needAllocIp){
  logger.debug(""String_Node_Str"" + clusterEntity.getName());
  clusterConfig.setDistroVendor(clusterEntity.getDistroVendor());
  clusterConfig.setDistroVersion(clusterEntity.getDistroVersion());
  clusterConfig.setAppManager(clusterEntity.getAppManager());
  clusterConfig.setHttpProxy(httpProxy);
  clusterConfig.setNoProxy(noProxy);
  clusterConfig.setTopologyPolicy(clusterEntity.getTopologyPolicy());
  clusterConfig.setPassword(clusterEntity.getPassword());
  clusterConfig.setTemplateName(this.nodeTemplateService.getNodeTemplateNameByMoid(clusterEntity.getTemplateId()));
  Map<String,String> hostToRackMap=rackInfoMgr.exportHostRackMap();
  if ((clusterConfig.getTopologyPolicy() == TopologyType.RACK_AS_RACK || clusterConfig.getTopologyPolicy() == TopologyType.HVE) && hostToRackMap.isEmpty()) {
    logger.error(""String_Node_Str"");
    throw ClusterConfigException.INVALID_TOPOLOGY_POLICY(clusterConfig.getTopologyPolicy(),""String_Node_Str"");
  }
  clusterConfig.setHostToRackMap(hostToRackMap);
  if (clusterEntity.getVcRpNames() != null) {
    logger.debug(""String_Node_Str"");
    String[] rpNames=clusterEntity.getVcRpNameList().toArray(new String[clusterEntity.getVcRpNameList().size()]);
    List<VcCluster> vcClusters=rpMgr.getVcResourcePoolByNameList(rpNames);
    clusterConfig.setVcClusters(vcClusters);
    clusterConfig.setRpNames(clusterEntity.getVcRpNameList());
  }
 else {
    clusterConfig.setVcClusters(rpMgr.getAllVcResourcePool());
    logger.debug(""String_Node_Str"");
  }
  if (clusterEntity.getVcDatastoreNameList() != null) {
    logger.debug(""String_Node_Str"");
    Set<String> sharedPattern=datastoreMgr.getSharedDatastoresByNames(clusterEntity.getVcDatastoreNameList());
    clusterConfig.setSharedDatastorePattern(sharedPattern);
    Set<String> localPattern=datastoreMgr.getLocalDatastoresByNames(clusterEntity.getVcDatastoreNameList());
    clusterConfig.setLocalDatastorePattern(localPattern);
    clusterConfig.setDsNames(clusterEntity.getVcDatastoreNameList());
  }
 else {
    clusterConfig.setSharedDatastorePattern(datastoreMgr.getAllSharedDatastores());
    clusterConfig.setLocalDatastorePattern(datastoreMgr.getAllLocalDatastores());
    logger.debug(""String_Node_Str"");
  }
  List<NodeGroupCreate> nodeGroups=new ArrayList<NodeGroupCreate>();
  List<NodeGroupEntity> nodeGroupEntities=clusterEntity.getNodeGroups();
  long instanceNum=0;
  for (  NodeGroupEntity ngEntity : nodeGroupEntities) {
    NodeGroupCreate group=convertNodeGroups(clusterEntity,ngEntity,clusterEntity.getName());
    nodeGroups.add(group);
    instanceNum+=group.getInstanceNum();
  }
  clusterConfig.setNodeGroups(nodeGroups.toArray(new NodeGroupCreate[nodeGroups.size()]));
  List<String> networkNames=clusterEntity.fetchNetworkNameList();
  List<NetworkAdd> networkingAdds=allocatNetworkIp(networkNames,clusterEntity,instanceNum,needAllocIp);
  clusterConfig.setNetworkings(networkingAdds);
  clusterConfig.setNetworkConfig(convertNetConfigsToNetNames(clusterEntity.getNetworkConfigInfo()));
  if (clusterEntity.getHadoopConfig() != null) {
    Map<String,Object> hadoopConfig=(new Gson()).fromJson(clusterEntity.getHadoopConfig(),Map.class);
    clusterConfig.setConfiguration(hadoopConfig);
  }
  if (!CommonUtil.isBlank(clusterEntity.getAdvancedProperties())) {
    Gson gson=new Gson();
    Map<String,String> advancedProperties=gson.fromJson(clusterEntity.getAdvancedProperties(),Map.class);
    clusterConfig.setExternalHDFS(advancedProperties.get(""String_Node_Str""));
    clusterConfig.setExternalMapReduce(advancedProperties.get(""String_Node_Str""));
    clusterConfig.setLocalRepoURL(advancedProperties.get(""String_Node_Str""));
    clusterConfig.setClusterCloneType(advancedProperties.get(""String_Node_Str""));
    clusterConfig.setExternalNamenode(advancedProperties.get(""String_Node_Str""));
    clusterConfig.setExternalSecondaryNamenode(advancedProperties.get(""String_Node_Str""));
    if (advancedProperties.get(""String_Node_Str"") != null) {
      clusterConfig.setExternalDatanodes(gson.fromJson(gson.toJson(advancedProperties.get(""String_Node_Str"")),HashSet.class));
    }
  }
  setDefaultClusterCloneType(clusterConfig);
  if (!CommonUtil.isBlank(clusterEntity.getInfraConfig())) {
    clusterConfig.setInfrastructure_config(InfrastructureConfigUtils.read(clusterEntity.getInfraConfig()));
  }
}","@SuppressWarnings(""String_Node_Str"") private void convertClusterConfig(ClusterEntity clusterEntity,ClusterCreate clusterConfig,boolean needAllocIp){
  logger.debug(""String_Node_Str"" + clusterEntity.getName());
  clusterConfig.setDistroVendor(clusterEntity.getDistroVendor());
  clusterConfig.setDistroVersion(clusterEntity.getDistroVersion());
  clusterConfig.setAppManager(clusterEntity.getAppManager());
  clusterConfig.setHttpProxy(httpProxy);
  clusterConfig.setNoProxy(noProxy);
  clusterConfig.setTopologyPolicy(clusterEntity.getTopologyPolicy());
  clusterConfig.setPassword(clusterEntity.getPassword());
  clusterConfig.setTemplateName(this.nodeTemplateService.getNodeTemplateNameByMoid(clusterEntity.getTemplateId()));
  Map<String,String> hostToRackMap=rackInfoMgr.exportHostRackMap();
  if ((clusterConfig.getTopologyPolicy() == TopologyType.RACK_AS_RACK || clusterConfig.getTopologyPolicy() == TopologyType.HVE) && hostToRackMap.isEmpty()) {
    logger.error(""String_Node_Str"");
    throw ClusterConfigException.INVALID_TOPOLOGY_POLICY(clusterConfig.getTopologyPolicy(),""String_Node_Str"");
  }
  clusterConfig.setHostToRackMap(hostToRackMap);
  if (clusterEntity.getVcRpNames() != null) {
    logger.debug(""String_Node_Str"");
    String[] rpNames=clusterEntity.getVcRpNameList().toArray(new String[clusterEntity.getVcRpNameList().size()]);
    List<VcCluster> vcClusters=rpMgr.getVcResourcePoolByNameList(rpNames);
    clusterConfig.setVcClusters(vcClusters);
    clusterConfig.setRpNames(clusterEntity.getVcRpNameList());
  }
 else {
    clusterConfig.setVcClusters(rpMgr.getAllVcResourcePool());
    logger.debug(""String_Node_Str"");
  }
  if (clusterEntity.getVcDatastoreNameList() != null) {
    logger.debug(""String_Node_Str"");
    Set<String> sharedPattern=datastoreMgr.getSharedDatastoresByNames(clusterEntity.getVcDatastoreNameList());
    clusterConfig.setSharedDatastorePattern(sharedPattern);
    Set<String> localPattern=datastoreMgr.getLocalDatastoresByNames(clusterEntity.getVcDatastoreNameList());
    clusterConfig.setLocalDatastorePattern(localPattern);
    clusterConfig.setDsNames(clusterEntity.getVcDatastoreNameList());
  }
 else {
    clusterConfig.setSharedDatastorePattern(datastoreMgr.getAllSharedDatastores());
    clusterConfig.setLocalDatastorePattern(datastoreMgr.getAllLocalDatastores());
    logger.debug(""String_Node_Str"");
  }
  List<NodeGroupCreate> nodeGroups=new ArrayList<NodeGroupCreate>();
  Set<NodeGroupEntity> nodeGroupEntities=clusterEntity.getNodeGroups();
  long instanceNum=0;
  for (  NodeGroupEntity ngEntity : nodeGroupEntities) {
    NodeGroupCreate group=convertNodeGroups(clusterEntity,ngEntity,clusterEntity.getName());
    nodeGroups.add(group);
    instanceNum+=group.getInstanceNum();
  }
  clusterConfig.setNodeGroups(nodeGroups.toArray(new NodeGroupCreate[nodeGroups.size()]));
  List<String> networkNames=clusterEntity.fetchNetworkNameList();
  List<NetworkAdd> networkingAdds=allocatNetworkIp(networkNames,clusterEntity,instanceNum,needAllocIp);
  clusterConfig.setNetworkings(networkingAdds);
  clusterConfig.setNetworkConfig(convertNetConfigsToNetNames(clusterEntity.getNetworkConfigInfo()));
  if (clusterEntity.getHadoopConfig() != null) {
    Map<String,Object> hadoopConfig=(new Gson()).fromJson(clusterEntity.getHadoopConfig(),Map.class);
    clusterConfig.setConfiguration(hadoopConfig);
  }
  if (!CommonUtil.isBlank(clusterEntity.getAdvancedProperties())) {
    Gson gson=new Gson();
    Map<String,String> advancedProperties=gson.fromJson(clusterEntity.getAdvancedProperties(),Map.class);
    clusterConfig.setExternalHDFS(advancedProperties.get(""String_Node_Str""));
    clusterConfig.setExternalMapReduce(advancedProperties.get(""String_Node_Str""));
    clusterConfig.setLocalRepoURL(advancedProperties.get(""String_Node_Str""));
    clusterConfig.setClusterCloneType(advancedProperties.get(""String_Node_Str""));
    clusterConfig.setExternalNamenode(advancedProperties.get(""String_Node_Str""));
    clusterConfig.setExternalSecondaryNamenode(advancedProperties.get(""String_Node_Str""));
    if (advancedProperties.get(""String_Node_Str"") != null) {
      clusterConfig.setExternalDatanodes(gson.fromJson(gson.toJson(advancedProperties.get(""String_Node_Str"")),HashSet.class));
    }
  }
  setDefaultClusterCloneType(clusterConfig);
  if (!CommonUtil.isBlank(clusterEntity.getInfraConfig())) {
    clusterConfig.setInfrastructure_config(InfrastructureConfigUtils.read(clusterEntity.getInfraConfig()));
  }
}"
48356,"private List<NodeGroupEntity> convertNodeGroupsToEntities(Gson gson,ClusterEntity clusterEntity,String distro,NodeGroupCreate[] groups,boolean validateWhiteList){
  List<NodeGroupEntity> nodeGroups=new LinkedList<NodeGroupEntity>();
  for (  NodeGroupCreate group : groups) {
    NodeGroupEntity groupEntity=convertGroup(gson,clusterEntity,group,distro,validateWhiteList);
    if (groupEntity != null) {
      nodeGroups.add(groupEntity);
    }
  }
  return nodeGroups;
}","private Set<NodeGroupEntity> convertNodeGroupsToEntities(Gson gson,ClusterEntity clusterEntity,String distro,NodeGroupCreate[] groups,boolean validateWhiteList){
  Set<NodeGroupEntity> nodeGroups=new HashSet<NodeGroupEntity>();
  for (  NodeGroupCreate group : groups) {
    NodeGroupEntity groupEntity=convertGroup(gson,clusterEntity,group,distro,validateWhiteList);
    if (groupEntity != null) {
      nodeGroups.add(groupEntity);
    }
  }
  return nodeGroups;
}"
48357,"private void updateNodegroupAppConfig(ClusterCreate clusterCreate,ClusterEntity cluster,boolean validateWhiteList){
  Gson gson=new Gson();
  List<NodeGroupEntity> groupEntities=cluster.getNodeGroups();
  Map<String,NodeGroupEntity> groupMap=new HashMap<String,NodeGroupEntity>();
  for (  NodeGroupEntity entity : groupEntities) {
    groupMap.put(entity.getName(),entity);
  }
  Set<String> updatedGroups=new HashSet<String>();
  NodeGroupCreate[] groupCreates=clusterCreate.getNodeGroups();
  if (groupCreates == null) {
    return;
  }
  for (  NodeGroupCreate groupCreate : groupCreates) {
    Map<String,Object> groupConfig=groupCreate.getConfiguration();
    if (groupConfig != null && groupConfig.size() > 0) {
      NodeGroupEntity groupEntity=groupMap.get(groupCreate.getName());
      groupEntity.setHadoopConfig(gson.toJson(groupConfig));
      updatedGroups.add(groupCreate.getName());
    }
  }
  for (  NodeGroupEntity entity : groupEntities) {
    if (updatedGroups.contains(entity.getName())) {
      continue;
    }
    entity.setHadoopConfig(null);
  }
}","private void updateNodegroupAppConfig(ClusterCreate clusterCreate,ClusterEntity cluster,boolean validateWhiteList){
  Gson gson=new Gson();
  Set<NodeGroupEntity> groupEntities=cluster.getNodeGroups();
  Map<String,NodeGroupEntity> groupMap=new HashMap<String,NodeGroupEntity>();
  for (  NodeGroupEntity entity : groupEntities) {
    groupMap.put(entity.getName(),entity);
  }
  Set<String> updatedGroups=new HashSet<String>();
  NodeGroupCreate[] groupCreates=clusterCreate.getNodeGroups();
  if (groupCreates == null) {
    return;
  }
  for (  NodeGroupCreate groupCreate : groupCreates) {
    Map<String,Object> groupConfig=groupCreate.getConfiguration();
    if (groupConfig != null && groupConfig.size() > 0) {
      NodeGroupEntity groupEntity=groupMap.get(groupCreate.getName());
      groupEntity.setHadoopConfig(gson.toJson(groupConfig));
      updatedGroups.add(groupCreate.getName());
    }
  }
  for (  NodeGroupEntity entity : groupEntities) {
    if (updatedGroups.contains(entity.getName())) {
      continue;
    }
    entity.setHadoopConfig(null);
  }
}"
48358,"@Override @SuppressWarnings(""String_Node_Str"") public ClusterRead toClusterRead(String clusterName,boolean withNodesList,boolean ignoreObsoleteNode){
  ClusterEntity cluster=findByName(clusterName);
  if (cluster == null) {
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ClusterStatus clusterStatus=cluster.getStatus();
  ClusterRead clusterRead=new ClusterRead();
  clusterRead.setInstanceNum(cluster.getRealInstanceNum(ignoreObsoleteNode));
  clusterRead.setName(cluster.getName());
  clusterRead.setStatus(clusterStatus);
  clusterRead.setAppManager(cluster.getAppManager());
  clusterRead.setDistro(cluster.getDistro());
  clusterRead.setDistroVendor(cluster.getDistroVendor());
  clusterRead.setTopologyPolicy(cluster.getTopologyPolicy());
  clusterRead.setTemplateName(nodeTemplateDAO.findByMoid(cluster.getTemplateId()).getName());
  clusterRead.setAutomationEnable(cluster.getAutomationEnable());
  clusterRead.setVhmMinNum(cluster.getVhmMinNum());
  clusterRead.setVhmMaxNum(cluster.getVhmMaxNum());
  clusterRead.setVhmTargetNum(cluster.getVhmTargetNum());
  clusterRead.setIoShares(cluster.getIoShares());
  clusterRead.setVersion(cluster.getVersion());
  if (!CommonUtil.isBlank(cluster.getAdvancedProperties())) {
    Gson gson=new Gson();
    Map<String,String> advancedProperties=gson.fromJson(cluster.getAdvancedProperties(),Map.class);
    clusterRead.setExternalHDFS(advancedProperties.get(""String_Node_Str""));
    clusterRead.setExternalMapReduce(advancedProperties.get(""String_Node_Str""));
    clusterRead.setLocalRepoURL(advancedProperties.get(""String_Node_Str""));
    clusterRead.setClusterCloneType(advancedProperties.get(""String_Node_Str""));
    clusterRead.setExternalNamenode(advancedProperties.get(""String_Node_Str""));
    clusterRead.setExternalSecondaryNamenode(advancedProperties.get(""String_Node_Str""));
    if (advancedProperties.get(""String_Node_Str"") != null) {
      clusterRead.setExternalDatanodes(gson.fromJson(gson.toJson(advancedProperties.get(""String_Node_Str"")),HashSet.class));
    }
  }
  String cloneType=clusterRead.getClusterCloneType();
  if (CommonUtil.isBlank(cloneType)) {
    clusterRead.setClusterCloneType(Constants.CLUSTER_CLONE_TYPE_FAST_CLONE);
  }
  SoftwareManager softMgr=null;
  try {
    softMgr=softwareManagerCollector.getSoftwareManager(cluster.getAppManager());
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"");
  }
  List<NodeGroupRead> groupList=new ArrayList<NodeGroupRead>();
  for (  NodeGroupEntity group : cluster.getNodeGroups()) {
    NodeGroupRead groupRead=group.toNodeGroupRead(withNodesList,ignoreObsoleteNode);
    groupRead.setComputeOnly(false);
    try {
      groupRead.setComputeOnly(softMgr.isComputeOnlyRoles(groupRead.getRoles()));
    }
 catch (    Exception e) {
    }
    groupList.add(groupRead);
  }
  clusterRead.setNodeGroups(groupList);
  Set<VcResourcePoolEntity> rps=cluster.getUsedRps();
  List<ResourcePoolRead> rpReads=new ArrayList<ResourcePoolRead>(rps.size());
  for (  VcResourcePoolEntity rp : rps) {
    ResourcePoolRead rpRead=rp.toRest();
    rpRead.setNodes(null);
    rpReads.add(rpRead);
  }
  clusterRead.setResourcePools(rpReads);
  if (clusterStatus.isActiveServiceStatus() || clusterStatus == ClusterStatus.STOPPED) {
    clusterRead.setDcSeperation(clusterRead.validateSetManualElasticity());
  }
  if (StringUtils.isNotBlank(cluster.getInfraConfig())) {
    clusterRead.setInfrastructure_config(InfrastructureConfigUtils.read(cluster.getInfraConfig()));
  }
  return clusterRead;
}","@Deprecated @Override @SuppressWarnings(""String_Node_Str"") public ClusterRead toClusterRead(String clusterName,boolean withNodesList,boolean ignoreObsoleteNode){
  ClusterEntity cluster=findByName(clusterName);
  if (cluster == null) {
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ClusterStatus clusterStatus=cluster.getStatus();
  ClusterRead clusterRead=new ClusterRead();
  clusterRead.setInstanceNum(cluster.getRealInstanceNum(ignoreObsoleteNode));
  clusterRead.setName(cluster.getName());
  clusterRead.setStatus(clusterStatus);
  clusterRead.setAppManager(cluster.getAppManager());
  clusterRead.setDistro(cluster.getDistro());
  clusterRead.setDistroVendor(cluster.getDistroVendor());
  clusterRead.setTopologyPolicy(cluster.getTopologyPolicy());
  clusterRead.setTemplateName(nodeTemplateDAO.findByMoid(cluster.getTemplateId()).getName());
  clusterRead.setAutomationEnable(cluster.getAutomationEnable());
  clusterRead.setVhmMinNum(cluster.getVhmMinNum());
  clusterRead.setVhmMaxNum(cluster.getVhmMaxNum());
  clusterRead.setVhmTargetNum(cluster.getVhmTargetNum());
  clusterRead.setIoShares(cluster.getIoShares());
  clusterRead.setVersion(cluster.getVersion());
  if (!CommonUtil.isBlank(cluster.getAdvancedProperties())) {
    Gson gson=new Gson();
    Map<String,String> advancedProperties=gson.fromJson(cluster.getAdvancedProperties(),Map.class);
    clusterRead.setExternalHDFS(advancedProperties.get(""String_Node_Str""));
    clusterRead.setExternalMapReduce(advancedProperties.get(""String_Node_Str""));
    clusterRead.setLocalRepoURL(advancedProperties.get(""String_Node_Str""));
    clusterRead.setClusterCloneType(advancedProperties.get(""String_Node_Str""));
    clusterRead.setExternalNamenode(advancedProperties.get(""String_Node_Str""));
    clusterRead.setExternalSecondaryNamenode(advancedProperties.get(""String_Node_Str""));
    if (advancedProperties.get(""String_Node_Str"") != null) {
      clusterRead.setExternalDatanodes(gson.fromJson(gson.toJson(advancedProperties.get(""String_Node_Str"")),HashSet.class));
    }
  }
  String cloneType=clusterRead.getClusterCloneType();
  if (CommonUtil.isBlank(cloneType)) {
    clusterRead.setClusterCloneType(Constants.CLUSTER_CLONE_TYPE_FAST_CLONE);
  }
  SoftwareManager softMgr=null;
  try {
    softMgr=softwareManagerCollector.getSoftwareManager(cluster.getAppManager());
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"");
  }
  List<NodeGroupRead> groupList=new ArrayList<NodeGroupRead>();
  for (  NodeGroupEntity group : cluster.getNodeGroups()) {
    NodeGroupRead groupRead=group.toNodeGroupRead(withNodesList,ignoreObsoleteNode);
    groupRead.setComputeOnly(false);
    try {
      groupRead.setComputeOnly(softMgr.isComputeOnlyRoles(groupRead.getRoles()));
    }
 catch (    Exception e) {
    }
    groupList.add(groupRead);
  }
  clusterRead.setNodeGroups(groupList);
  Set<VcResourcePoolEntity> rps=cluster.getUsedRps();
  List<ResourcePoolRead> rpReads=new ArrayList<ResourcePoolRead>(rps.size());
  for (  VcResourcePoolEntity rp : rps) {
    ResourcePoolRead rpRead=rp.toRest();
    rpRead.setNodes(null);
    rpReads.add(rpRead);
  }
  clusterRead.setResourcePools(rpReads);
  if (clusterStatus.isActiveServiceStatus() || clusterStatus == ClusterStatus.STOPPED) {
    clusterRead.setDcSeperation(clusterRead.validateSetManualElasticity());
  }
  if (StringUtils.isNotBlank(cluster.getInfraConfig())) {
    clusterRead.setInfrastructure_config(InfrastructureConfigUtils.read(cluster.getInfraConfig()));
  }
  return clusterRead;
}"
48359,"public Map<String,String> getRackTopology(String clusterName,String topology){
  ClusterRead cluster=clusterEntityMgr.toClusterRead(clusterName,true);
  Set<String> hosts=new HashSet<String>();
  List<NodeRead> nodes=new ArrayList<NodeRead>();
  for (  NodeGroupRead nodeGroup : cluster.getNodeGroups()) {
    for (    NodeRead node : nodeGroup.getInstances()) {
      if (node.getMoId() != null) {
        hosts.add(node.getHostName());
        nodes.add(node);
      }
    }
  }
  if (CommonUtil.isBlank(topology)) {
    topology=cluster.getTopologyPolicy().toString();
  }
  AuAssert.check(hosts.size() > 0);
  clusterConfigMgr.validateRackTopologyUploaded(hosts,topology);
  return clusterConfigMgr.buildTopology(nodes,topology);
}","public Map<String,String> getRackTopology(String clusterName,String topology){
  ClusterRead cluster=clusterEntityMgr.findClusterWithNodes(clusterName,false);
  Set<String> hosts=new HashSet<String>();
  List<NodeRead> nodes=new ArrayList<NodeRead>();
  for (  NodeGroupRead nodeGroup : cluster.getNodeGroups()) {
    for (    NodeRead node : nodeGroup.getInstances()) {
      if (node.getMoId() != null) {
        hosts.add(node.getHostName());
        nodes.add(node);
      }
    }
  }
  if (CommonUtil.isBlank(topology)) {
    topology=cluster.getTopologyPolicy().toString();
  }
  AuAssert.check(hosts.size() > 0);
  clusterConfigMgr.validateRackTopologyUploaded(hosts,topology);
  return clusterConfigMgr.buildTopology(nodes,topology);
}"
48360,"public Map<String,Object> getClusterConfigManifest(String clusterName,List<String> targets,boolean needAllocIp){
  ClusterCreate clusterConfig=clusterConfigMgr.getClusterConfig(clusterName,needAllocIp);
  Map<String,String> cloudProvider=resMgr.getCloudProviderAttributes();
  ClusterRead read=clusterEntityMgr.toClusterRead(clusterName,true);
  Map<String,Object> attrs=new HashMap<String,Object>();
  if (Constants.IRONFAN.equalsIgnoreCase(clusterConfig.getAppManager())) {
    SoftwareManager softwareManager=clusterConfigMgr.getSoftwareManager(clusterConfig.getAppManager());
    IronfanStack stack=(IronfanStack)filterDistroFromAppManager(softwareManager,clusterConfig.getDistro());
    CommonClusterExpandPolicy.expandDistro(clusterConfig,stack);
    attrs.put(""String_Node_Str"",cloudProvider);
    attrs.put(""String_Node_Str"",clusterConfig);
  }
  if (read != null) {
    attrs.put(""String_Node_Str"",read);
  }
  if (targets != null && !targets.isEmpty()) {
    attrs.put(""String_Node_Str"",targets);
  }
  return attrs;
}","public Map<String,Object> getClusterConfigManifest(String clusterName,List<String> targets,boolean needAllocIp){
  ClusterCreate clusterConfig=clusterConfigMgr.getClusterConfig(clusterName,needAllocIp);
  Map<String,String> cloudProvider=resMgr.getCloudProviderAttributes();
  ClusterRead read=clusterEntityMgr.findClusterWithNodes(clusterName,true);
  Map<String,Object> attrs=new HashMap<String,Object>();
  if (Constants.IRONFAN.equalsIgnoreCase(clusterConfig.getAppManager())) {
    SoftwareManager softwareManager=clusterConfigMgr.getSoftwareManager(clusterConfig.getAppManager());
    IronfanStack stack=(IronfanStack)filterDistroFromAppManager(softwareManager,clusterConfig.getDistro());
    CommonClusterExpandPolicy.expandDistro(clusterConfig,stack);
    attrs.put(""String_Node_Str"",cloudProvider);
    attrs.put(""String_Node_Str"",clusterConfig);
  }
  if (read != null) {
    attrs.put(""String_Node_Str"",read);
  }
  if (targets != null && !targets.isEmpty()) {
    attrs.put(""String_Node_Str"",targets);
  }
  return attrs;
}"
48361,"public ClusterRead getClusterByName(String clusterName,boolean realTime){
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  java.util.Date startTime=new java.util.Date();
  if (realTime && cluster.getStatus().isSyncServiceStatus()) {
    refreshClusterStatus(clusterName);
  }
  logger.debug(""String_Node_Str"" + (new java.util.Date().getTime() - startTime.getTime()));
  return clusterEntityMgr.toClusterRead(clusterName,realTime);
}","public ClusterRead getClusterByName(String clusterName,boolean realTime){
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  java.util.Date startTime=new java.util.Date();
  if (realTime && cluster.getStatus().isSyncServiceStatus()) {
    refreshClusterStatus(clusterName);
  }
  logger.debug(""String_Node_Str"" + (new java.util.Date().getTime() - startTime.getTime()));
  return realTime ? clusterEntityMgr.findClusterWithNodes(clusterName,false) : clusterEntityMgr.findClusterWithNodeGroups(clusterName);
}"
48362,"public List<ClusterRead> getClusters(Boolean realTime){
  java.util.Date startTime=new java.util.Date();
  List<ClusterRead> clusters=new ArrayList<ClusterRead>();
  List<ClusterEntity> clusterEntities=clusterEntityMgr.findAllClusters();
  logger.debug(""String_Node_Str"" + (new java.util.Date().getTime() - startTime.getTime()));
  for (  ClusterEntity entity : clusterEntities) {
    clusters.add(getClusterByName(entity.getName(),realTime));
  }
  logger.debug(""String_Node_Str"" + (new java.util.Date().getTime() - startTime.getTime()));
  return clusters;
}","public List<ClusterRead> getClusters(Boolean realTime){
  java.util.Date startTime=new java.util.Date();
  List<ClusterRead> clusters=new ArrayList<ClusterRead>();
  List<String> clusterNames=clusterEntityMgr.findAllClusterNames();
  logger.debug(""String_Node_Str"" + (new java.util.Date().getTime() - startTime.getTime()));
  for (  String clusterName : clusterNames) {
    clusters.add(getClusterByName(clusterName,realTime));
  }
  logger.debug(""String_Node_Str"" + (new java.util.Date().getTime() - startTime.getTime()));
  return clusters;
}"
48363,"public static void setOwnerOnlyReadWrite(String filename) throws IOException {
  Set<PosixFilePermission> perms=new HashSet<PosixFilePermission>();
  perms.add(PosixFilePermission.OWNER_READ);
  perms.add(PosixFilePermission.OWNER_WRITE);
  Files.setPosixFilePermissions(Paths.get(filename),perms);
}","public static void setOwnerOnlyReadWrite(String filename) throws IOException {
  if (new File(filename).exists()) {
    Set<PosixFilePermission> perms=new HashSet<PosixFilePermission>();
    perms.add(PosixFilePermission.OWNER_READ);
    perms.add(PosixFilePermission.OWNER_WRITE);
    Files.setPosixFilePermissions(Paths.get(filename),perms);
  }
 else {
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"" + filename);
    }
  }
}"
48364,"private void configNodes(AmClusterDef clusterDef,Map<String,String> configTypeToService,List<AmNodeDef> targetNodeDefs) throws SoftwareManagementPluginException {
  Map<Integer,List<String>> newHostsMap=new HashMap<Integer,List<String>>();
  for (  AmNodeDef targetNodeDef : targetNodeDefs) {
    int volumesCount=targetNodeDef.getVolumesCount();
    String host=targetNodeDef.getFqdn();
    if (newHostsMap.isEmpty()) {
      newHostsMap.put(volumesCount,new ArrayList<String>(Arrays.asList(host)));
    }
 else {
      List<String> newHosts=newHostsMap.get(volumesCount);
      if (newHosts != null) {
        newHosts.add(host);
        newHostsMap.put(volumesCount,newHosts);
      }
 else {
        newHostsMap.put(volumesCount,new ArrayList<String>(Arrays.asList(host)));
      }
    }
  }
  List<AmNodeGroupDef> nodeGroups=clusterDef.getNodeGroupsByNodes(targetNodeDefs);
  List<AmHostGroupInfo> amHostGroupsInfo=clusterDef.getAmHostGroupsInfoByNodeGroups(nodeGroups);
  List<String> existedConfigGroupNames=new ArrayList<String>();
  ApiConfigGroupList apiConfigGroupList=apiManager.getConfigGroupsList(clusterDef.getName());
  for (  AmHostGroupInfo amHostGroupInfo : amHostGroupsInfo) {
    for (    ApiConfigGroup group : apiConfigGroupList.getConfigGroups()) {
      logger.info(""String_Node_Str"" + ApiUtils.objectToJson(group));
      ApiConfigGroupInfo apiConfigGroupInfo=group.getApiConfigGroupInfo();
      if (apiConfigGroupInfo != null && apiConfigGroupInfo.getDesiredConfigs() != null) {
        List<String> newHosts=newHostsMap.get(amHostGroupInfo.getVolumesCount());
        if (amHostGroupInfo.getName().equals(apiConfigGroupInfo.getGroupName())) {
          if (newHosts != null) {
            updateConfigGroup(apiConfigGroupInfo,clusterDef.getName(),amHostGroupInfo.toApiHostGroupForClusterBlueprint(),newHosts);
            existedConfigGroupNames.add(apiConfigGroupInfo.getGroupName());
            break;
          }
        }
        if (isTheSameConfigGroup(apiConfigGroupInfo,amHostGroupInfo)) {
          apiConfigGroupInfo.setGroupName(amHostGroupInfo.getName());
          updateConfigGroup(apiConfigGroupInfo,clusterDef.getName(),amHostGroupInfo.toApiHostGroupForClusterBlueprint(),newHosts);
          existedConfigGroupNames.add(apiConfigGroupInfo.getGroupName());
        }
      }
    }
  }
  createConfigGroups(clusterDef,nodeGroups,configTypeToService,existedConfigGroupNames);
}","private void configNodes(AmClusterDef clusterDef,Map<String,String> configTypeToService,List<AmNodeDef> targetNodeDefs) throws SoftwareManagementPluginException {
  Map<Integer,List<String>> newHostsMap=new HashMap<Integer,List<String>>();
  for (  AmNodeDef targetNodeDef : targetNodeDefs) {
    int volumesCount=targetNodeDef.getVolumesCount();
    String host=targetNodeDef.getFqdn();
    if (newHostsMap.isEmpty()) {
      newHostsMap.put(volumesCount,new ArrayList<String>(Arrays.asList(host)));
    }
 else {
      List<String> newHosts=newHostsMap.get(volumesCount);
      if (newHosts != null) {
        newHosts.add(host);
        newHostsMap.put(volumesCount,newHosts);
      }
 else {
        newHostsMap.put(volumesCount,new ArrayList<String>(Arrays.asList(host)));
      }
    }
  }
  List<AmNodeGroupDef> nodeGroups=clusterDef.getNodeGroupsByNodes(targetNodeDefs);
  List<AmHostGroupInfo> amHostGroupsInfo=clusterDef.getAmHostGroupsInfoByNodeGroups(nodeGroups);
  Map<String,Set<String>> existedConfigGroupMap=new HashMap<String,Set<String>>();
  ApiConfigGroupList apiConfigGroupList=apiManager.getConfigGroupsList(clusterDef.getName());
  for (  AmHostGroupInfo amHostGroupInfo : amHostGroupsInfo) {
    logger.info(""String_Node_Str"" + ApiUtils.objectToJson(amHostGroupInfo));
    for (    ApiConfigGroup group : apiConfigGroupList.getConfigGroups()) {
      logger.info(""String_Node_Str"" + ApiUtils.objectToJson(group));
      ApiConfigGroupInfo apiConfigGroupInfo=group.getApiConfigGroupInfo();
      if (apiConfigGroupInfo != null && apiConfigGroupInfo.getDesiredConfigs() != null) {
        List<String> newHosts=newHostsMap.get(amHostGroupInfo.getVolumesCount());
        logger.info(""String_Node_Str"" + ApiUtils.objectToJson(newHosts) + ""String_Node_Str""+ amHostGroupInfo.getVolumesCount()+ ""String_Node_Str"");
        List<Map<String,Object>> configs=amHostGroupInfo.getConfigurations();
        for (        Map<String,Object> map : configs) {
          for (          String type : map.keySet()) {
            String serviceName=configTypeToService.get(type + ""String_Node_Str"");
            String configGroupName=apiConfigGroupInfo.getGroupName();
            Set<String> existedConfigGroupTags=existedConfigGroupMap.get(configGroupName);
            if (existedConfigGroupTags == null) {
              existedConfigGroupTags=new HashSet<String>();
            }
            if (amHostGroupInfo.getName().equals(configGroupName) && apiConfigGroupInfo.getTag().equals(serviceName) && (newHosts != null)) {
              logger.info(""String_Node_Str"" + ApiUtils.objectToJson(newHosts) + ""String_Node_Str""+ configGroupName+ ""String_Node_Str""+ serviceName+ ""String_Node_Str"");
              updateConfigGroup(apiConfigGroupInfo,clusterDef.getName(),amHostGroupInfo.toApiHostGroupForClusterBlueprint(),newHosts);
              existedConfigGroupTags.add(serviceName);
              existedConfigGroupMap.put(configGroupName,existedConfigGroupTags);
              break;
            }
            if (apiConfigGroupInfo.getTag().equals(serviceName) && isTheSameConfigGroup(apiConfigGroupInfo,amHostGroupInfo)) {
              logger.info(""String_Node_Str"" + configGroupName + ""String_Node_Str""+ amHostGroupInfo.getName());
              apiConfigGroupInfo.setGroupName(amHostGroupInfo.getName());
              updateConfigGroup(apiConfigGroupInfo,clusterDef.getName(),amHostGroupInfo.toApiHostGroupForClusterBlueprint(),newHosts);
              existedConfigGroupTags.add(serviceName);
              existedConfigGroupMap.put(configGroupName,existedConfigGroupTags);
            }
          }
        }
      }
    }
  }
  createConfigGroups(clusterDef,nodeGroups,configTypeToService,existedConfigGroupMap);
}"
48365,"private boolean isTheSameConfigGroup(ApiConfigGroupInfo apiConfigGroupInfo,AmHostGroupInfo amHostGroupInfo){
  List<String> associatedHosts=new ArrayList<String>();
  for (  ApiHostInfo apiHostInfo : apiConfigGroupInfo.getHosts()) {
    associatedHosts.add(apiHostInfo.getHostName());
  }
  boolean isTheSameConfigGroup=true;
  for (  String host : associatedHosts) {
    if (!amHostGroupInfo.getHosts().contains(host)) {
      isTheSameConfigGroup=false;
      break;
    }
  }
  return isTheSameConfigGroup;
}","private boolean isTheSameConfigGroup(ApiConfigGroupInfo apiConfigGroupInfo,AmHostGroupInfo amHostGroupInfo){
  List<String> associatedHosts=new ArrayList<String>();
  for (  ApiHostInfo apiHostInfo : apiConfigGroupInfo.getHosts()) {
    associatedHosts.add(apiHostInfo.getHostName());
  }
  logger.info(""String_Node_Str"" + ApiUtils.objectToJson(associatedHosts));
  if (CollectionUtils.isEmpty(associatedHosts)) {
    return false;
  }
  boolean isTheSameConfigGroup=true;
  for (  String host : associatedHosts) {
    if (!amHostGroupInfo.getHosts().contains(host)) {
      logger.info(""String_Node_Str"" + host + ""String_Node_Str"");
      isTheSameConfigGroup=false;
      break;
    }
  }
  return isTheSameConfigGroup;
}"
48366,"private void createConfigGroups(AmClusterDef clusterDef,List<AmNodeGroupDef> nodeGroups,Map<String,String> configTypeToService,List<String> existedConfigGroupNames){
  List<ApiConfigGroup> configGroups=new ArrayList<>();
  Map<String,ApiConfigGroup> serviceToGroup=new HashMap<>();
  for (  AmNodeGroupDef nodeGroup : nodeGroups) {
    for (    AmHostGroupInfo amHostGroupInfo : nodeGroup.generateHostGroupsInfo()) {
      if (existedConfigGroupNames.contains(amHostGroupInfo.getName())) {
        continue;
      }
      serviceToGroup.clear();
      List<Map<String,Object>> configs=amHostGroupInfo.getConfigurations();
      int i=1;
      for (      Map<String,Object> map : configs) {
        for (        String type : map.keySet()) {
          String serviceName=configTypeToService.get(type + ""String_Node_Str"");
          ApiConfigGroup confGroup=serviceToGroup.get(serviceName);
          if (confGroup == null) {
            confGroup=createConfigGroup(clusterDef,amHostGroupInfo,serviceName);
            serviceToGroup.put(serviceName,confGroup);
          }
          ApiConfigGroupConfiguration sameType=null;
          for (          ApiConfigGroupConfiguration config : confGroup.getApiConfigGroupInfo().getDesiredConfigs()) {
            if (config.getType().equals(type)) {
              sameType=config;
              break;
            }
          }
          if (sameType == null) {
            sameType=createApiConfigGroupConf(i,type,serviceName,confGroup);
          }
          Map<String,String> property=(Map<String,String>)map.get(type);
          sameType.getProperties().putAll(property);
        }
      }
      configGroups.addAll(serviceToGroup.values());
    }
  }
  if (configGroups.isEmpty()) {
    return;
  }
  logger.info(""String_Node_Str"" + configGroups);
  apiManager.createConfigGroups(clusterDef.getName(),configGroups);
}","private void createConfigGroups(AmClusterDef clusterDef,List<AmNodeGroupDef> nodeGroups,Map<String,String> configTypeToService,Map<String,Set<String>> existedConfigGroupMap){
  List<ApiConfigGroup> configGroups=new ArrayList<>();
  Map<String,ApiConfigGroup> serviceToGroup=new HashMap<>();
  for (  AmNodeGroupDef nodeGroup : nodeGroups) {
    for (    AmHostGroupInfo amHostGroupInfo : nodeGroup.generateHostGroupsInfo()) {
      serviceToGroup.clear();
      List<Map<String,Object>> configs=amHostGroupInfo.getConfigurations();
      int i=1;
      for (      Map<String,Object> map : configs) {
        for (        String type : map.keySet()) {
          String serviceName=configTypeToService.get(type + ""String_Node_Str"");
          Set<String> existedConfigGroupTags=existedConfigGroupMap.get(amHostGroupInfo.getName());
          if (CollectionUtils.isNotEmpty(existedConfigGroupTags) && existedConfigGroupTags.contains(serviceName)) {
            continue;
          }
          ApiConfigGroup confGroup=serviceToGroup.get(serviceName);
          if (confGroup == null) {
            confGroup=createConfigGroup(clusterDef,amHostGroupInfo,serviceName);
            serviceToGroup.put(serviceName,confGroup);
          }
          ApiConfigGroupConfiguration sameType=null;
          for (          ApiConfigGroupConfiguration config : confGroup.getApiConfigGroupInfo().getDesiredConfigs()) {
            if (config.getType().equals(type)) {
              sameType=config;
              break;
            }
          }
          if (sameType == null) {
            sameType=createApiConfigGroupConf(i,type,serviceName,confGroup);
          }
          Map<String,String> property=(Map<String,String>)map.get(type);
          sameType.getProperties().putAll(property);
        }
      }
      configGroups.addAll(serviceToGroup.values());
    }
  }
  if (configGroups.isEmpty()) {
    return;
  }
  logger.info(""String_Node_Str"" + configGroups);
  apiManager.createConfigGroups(clusterDef.getName(),configGroups);
}"
48367,"public AmHostGroupInfo(AmNodeDef node,AmNodeGroupDef nodeGroup,Map<String,String> configTypeToService){
  this.ambariServerVersion=nodeGroup.getAmbariServerVersion();
  String configGroupName=nodeGroup.getName() + ""String_Node_Str"" + node.getVolumesCount();
  if (!AmUtils.isAmbariServerBelow_2_0_0(this.ambariServerVersion)) {
    configGroupName=nodeGroup.getClusterName() + ""String_Node_Str"" + nodeGroup.getName()+ ""String_Node_Str""+ node.getVolumesCount();
  }
  this.configGroupName=configGroupName;
  this.nodeGroupName=nodeGroup.getName();
  this.cardinality=1;
  this.roles=nodeGroup.getRoles();
  this.volumesCount=node.getVolumesCount();
  List<Map<String,Object>> configurations=new ArrayList<Map<String,Object>>();
  if (!nodeGroup.getConfigurations().isEmpty()) {
    configurations.addAll(nodeGroup.getConfigurations());
  }
  if (!node.getConfigurations().isEmpty()) {
    configurations.addAll(node.getConfigurations());
  }
  this.configurations=configurations;
  Set<String> hosts=new HashSet<String>();
  hosts.add(node.getFqdn());
  this.hosts=hosts;
  if (configTypeToService != null) {
    for (    String service : getServices(configTypeToService,configurations)) {
      this.tag2Hosts.put(service,hosts);
    }
  }
}","public AmHostGroupInfo(AmNodeDef node,AmNodeGroupDef nodeGroup,Map<String,String> configTypeToService){
  this.ambariServerVersion=nodeGroup.getAmbariServerVersion();
  this.configTypeToService=configTypeToService;
  String configGroupName=nodeGroup.getName() + ""String_Node_Str"" + node.getVolumesCount();
  if (!AmUtils.isAmbariServerBelow_2_0_0(this.ambariServerVersion) && this.configTypeToService != null) {
    configGroupName=nodeGroup.getClusterName() + ""String_Node_Str"" + nodeGroup.getName()+ ""String_Node_Str""+ node.getVolumesCount();
  }
  this.configGroupName=configGroupName;
  this.nodeGroupName=nodeGroup.getName();
  this.cardinality=1;
  this.roles=nodeGroup.getRoles();
  this.volumesCount=node.getVolumesCount();
  List<Map<String,Object>> configurations=new ArrayList<Map<String,Object>>();
  if (!nodeGroup.getConfigurations().isEmpty()) {
    configurations.addAll(nodeGroup.getConfigurations());
  }
  if (!node.getConfigurations().isEmpty()) {
    configurations.addAll(node.getConfigurations());
  }
  this.configurations=configurations;
  Set<String> hosts=new HashSet<String>();
  hosts.add(node.getFqdn());
  this.hosts=hosts;
  if (this.configTypeToService != null) {
    for (    String service : getServices(configTypeToService,configurations)) {
      this.tag2Hosts.put(service,hosts);
    }
  }
}"
48368,"public void updateConfigGroupName(AmNodeGroupDef nodeGroup){
  String configGroupName=nodeGroup.getName();
  if (!AmUtils.isAmbariServerBelow_2_0_0(this.ambariServerVersion)) {
    configGroupName=nodeGroup.getClusterName() + ""String_Node_Str"" + nodeGroup.getName();
  }
  this.configGroupName=configGroupName;
}","public void updateConfigGroupName(AmNodeGroupDef nodeGroup){
  String configGroupName=nodeGroup.getName();
  if (!AmUtils.isAmbariServerBelow_2_0_0(this.ambariServerVersion) && this.configTypeToService != null) {
    configGroupName=nodeGroup.getClusterName() + ""String_Node_Str"" + nodeGroup.getName();
  }
  this.configGroupName=configGroupName;
}"
48369,"private NodeGroupEntity convertGroup(Gson gson,ClusterEntity clusterEntity,NodeGroupCreate group,String distro,boolean validateWhiteList){
  NodeGroupEntity groupEntity=new NodeGroupEntity();
  if (group.getRoles() == null || group.getRoles().isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  groupEntity.setCluster(clusterEntity);
  String templateId=this.nodeTemplateService.getNodeTemplateNameByMoid(clusterEntity.getTemplateId());
  int cpuNum=group.getCpuNum() == null ? 0 : group.getCpuNum();
  if (!VcVmUtil.validateCPU(clusterEntity.getTemplateId(),cpuNum)) {
    throw VcProviderException.CPU_NUM_NOT_MULTIPLE_OF_CORES_PER_SOCKET(group.getName(),templateId);
  }
  groupEntity.setCpuNum(cpuNum);
  groupEntity.setDefineInstanceNum(group.getInstanceNum());
  groupEntity.setMemorySize(group.getMemCapacityMB() == null ? 0 : group.getMemCapacityMB());
  groupEntity.setSwapRatio(group.getSwapRatio());
  groupEntity.setName(group.getName());
  groupEntity.setNodeType(group.getInstanceType());
  PlacementPolicy policies=group.getPlacementPolicies();
  if (policies != null) {
    List<GroupAssociation> associons=policies.getGroupAssociations();
    if (associons != null) {
      Set<NodeGroupAssociation> associonEntities=new HashSet<NodeGroupAssociation>();
      for (      GroupAssociation a : associons) {
        NodeGroupAssociation ae=new NodeGroupAssociation();
        ae.setAssociationType(a.getType());
        ae.setNodeGroup(groupEntity);
        ae.setReferencedGroup(a.getReference());
        associonEntities.add(ae);
      }
      groupEntity.setGroupAssociations(associonEntities);
    }
    if (policies.getInstancePerHost() != null) {
      groupEntity.setInstancePerHost(policies.getInstancePerHost());
    }
    if (policies.getGroupRacks() != null) {
      groupEntity.setGroupRacks((new Gson()).toJson(policies.getGroupRacks()));
    }
  }
  if (group.getRpNames() != null && group.getRpNames().size() > 0) {
    groupEntity.setVcRpNameList(group.getRpNames());
  }
  Set<String> roles=new LinkedHashSet<String>();
  convertStorage(group,groupEntity,roles);
  roles.addAll(group.getRoles());
  groupEntity.setRoles(gson.toJson(roles));
  if (group.getInstanceNum() <= 0) {
    logger.warn(""String_Node_Str"" + group.getName() + ""String_Node_Str"");
    return null;
  }
  List<String> dsNames=groupEntity.getVcDatastoreNameList();
  if (dsNames == null) {
    dsNames=clusterEntity.getVcDatastoreNameList();
  }
  Set<String> sharedPattern;
  Set<String> localPattern;
  if (dsNames != null) {
    sharedPattern=datastoreMgr.getSharedDatastoresByNames(dsNames);
    localPattern=datastoreMgr.getLocalDatastoresByNames(dsNames);
  }
 else {
    sharedPattern=datastoreMgr.getAllSharedDatastores();
    localPattern=datastoreMgr.getAllLocalDatastores();
  }
  SoftwareManager softwareManager=getSoftwareManager(clusterEntity.getAppManager());
  CommonClusterExpandPolicy.expandGroupInstanceType(groupEntity,group,sharedPattern,localPattern,softwareManager);
  String haFlag=group.getHaFlag();
  if (haFlag == null) {
    groupEntity.setHaFlag(Constants.HA_FLAG_OFF);
  }
 else {
    groupEntity.setHaFlag(haFlag);
  }
  LatencyPriority latencySensitivity=group.getLatencySensitivity();
  if (latencySensitivity != null)   groupEntity.setLatencySensitivity(latencySensitivity);
 else   groupEntity.setLatencySensitivity(LatencyPriority.NORMAL);
  groupEntity.setReservedCpu_ratio(group.getReservedCpu_ratio());
  groupEntity.setReservedMem_ratio(group.getReservedMem_ratio());
  if (group.getConfiguration() != null && group.getConfiguration().size() > 0) {
    groupEntity.setHadoopConfig(gson.toJson(group.getConfiguration()));
  }
  groupEntity.setVmFolderPath(clusterEntity);
  logger.debug(""String_Node_Str"" + group.getName());
  return groupEntity;
}","private NodeGroupEntity convertGroup(Gson gson,ClusterEntity clusterEntity,NodeGroupCreate group,String distro,boolean validateWhiteList){
  NodeGroupEntity groupEntity=new NodeGroupEntity();
  if (group.getRoles() == null || group.getRoles().isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  groupEntity.setCluster(clusterEntity);
  String templateId=this.nodeTemplateService.getNodeTemplateNameByMoid(clusterEntity.getTemplateId());
  int cpuNum=group.getCpuNum() == null ? 0 : group.getCpuNum();
  if (!VcVmUtil.validateCPU(clusterEntity.getTemplateId(),cpuNum)) {
    throw VcProviderException.CPU_NUM_NOT_MULTIPLE_OF_CORES_PER_SOCKET(group.getName(),templateId);
  }
  groupEntity.setCpuNum(cpuNum);
  groupEntity.setDefineInstanceNum(group.getInstanceNum());
  groupEntity.setMemorySize(group.getMemCapacityMB() == null ? 0 : group.getMemCapacityMB());
  groupEntity.setSwapRatio(group.getSwapRatio());
  groupEntity.setName(group.getName());
  groupEntity.setNodeType(group.getInstanceType());
  groupEntity.setReservedCpu_ratio(group.getReservedCpu_ratio());
  groupEntity.setReservedMem_ratio(group.getReservedMem_ratio());
  PlacementPolicy policies=group.getPlacementPolicies();
  if (policies != null) {
    List<GroupAssociation> associons=policies.getGroupAssociations();
    if (associons != null) {
      Set<NodeGroupAssociation> associonEntities=new HashSet<NodeGroupAssociation>();
      for (      GroupAssociation a : associons) {
        NodeGroupAssociation ae=new NodeGroupAssociation();
        ae.setAssociationType(a.getType());
        ae.setNodeGroup(groupEntity);
        ae.setReferencedGroup(a.getReference());
        associonEntities.add(ae);
      }
      groupEntity.setGroupAssociations(associonEntities);
    }
    if (policies.getInstancePerHost() != null) {
      groupEntity.setInstancePerHost(policies.getInstancePerHost());
    }
    if (policies.getGroupRacks() != null) {
      groupEntity.setGroupRacks((new Gson()).toJson(policies.getGroupRacks()));
    }
  }
  if (group.getRpNames() != null && group.getRpNames().size() > 0) {
    groupEntity.setVcRpNameList(group.getRpNames());
  }
  Set<String> roles=new LinkedHashSet<String>();
  convertStorage(group,groupEntity,roles);
  roles.addAll(group.getRoles());
  groupEntity.setRoles(gson.toJson(roles));
  if (group.getInstanceNum() <= 0) {
    logger.warn(""String_Node_Str"" + group.getName() + ""String_Node_Str"");
    return null;
  }
  List<String> dsNames=groupEntity.getVcDatastoreNameList();
  if (dsNames == null) {
    dsNames=clusterEntity.getVcDatastoreNameList();
  }
  Set<String> sharedPattern;
  Set<String> localPattern;
  if (dsNames != null) {
    sharedPattern=datastoreMgr.getSharedDatastoresByNames(dsNames);
    localPattern=datastoreMgr.getLocalDatastoresByNames(dsNames);
  }
 else {
    sharedPattern=datastoreMgr.getAllSharedDatastores();
    localPattern=datastoreMgr.getAllLocalDatastores();
  }
  SoftwareManager softwareManager=getSoftwareManager(clusterEntity.getAppManager());
  CommonClusterExpandPolicy.expandGroupInstanceType(groupEntity,group,sharedPattern,localPattern,softwareManager);
  String haFlag=group.getHaFlag();
  if (haFlag == null) {
    groupEntity.setHaFlag(Constants.HA_FLAG_OFF);
  }
 else {
    groupEntity.setHaFlag(haFlag);
  }
  LatencyPriority latencySensitivity=group.getLatencySensitivity();
  if (latencySensitivity != null)   groupEntity.setLatencySensitivity(latencySensitivity);
 else   groupEntity.setLatencySensitivity(LatencyPriority.NORMAL);
  groupEntity.setReservedCpu_ratio(group.getReservedCpu_ratio());
  groupEntity.setReservedMem_ratio(group.getReservedMem_ratio());
  if (group.getConfiguration() != null && group.getConfiguration().size() > 0) {
    groupEntity.setHadoopConfig(gson.toJson(group.getConfiguration()));
  }
  groupEntity.setVmFolderPath(clusterEntity);
  logger.debug(""String_Node_Str"" + group.getName());
  return groupEntity;
}"
48370,"public AmClusterDef(ClusterBlueprint blueprint,String privateKey,String ambariServerVersion){
  this.name=blueprint.getName();
  this.version=blueprint.getHadoopStack().getFullVersion();
  this.verbose=true;
  this.sshKey=privateKey;
  this.user=Constants.AMBARI_SSH_USER;
  this.currentReport=new ClusterReport(blueprint);
  this.ambariServerVersion=ambariServerVersion;
  HdfsVersion hdfs=getDefaultHdfsVersion(this.version);
  if (blueprint.hasTopologyPolicy()) {
    setRackTopologyFileName(blueprint);
  }
  setAdditionalConfigurations(blueprint,ambariServerVersion);
  this.configurations=AmUtils.toAmConfigurations(blueprint.getConfiguration());
  this.nodeGroups=new ArrayList<AmNodeGroupDef>();
  for (  NodeGroupInfo group : blueprint.getNodeGroups()) {
    AmNodeGroupDef nodeGroupDef=new AmNodeGroupDef();
    nodeGroupDef.setName(group.getName());
    nodeGroupDef.setInstanceNum(group.getInstanceNum());
    nodeGroupDef.setRoles(group.getRoles());
    nodeGroupDef.setLatencySensitivity(group.getLatencySensitivity());
    nodeGroupDef.setMemSize(group.getMemorySize());
    nodeGroupDef.setConfigurations(AmUtils.toAmConfigurations(group.getConfiguration()));
    nodeGroupDef.setClusterName(this.name);
    nodeGroupDef.setAmbariServerVersion(ambariServerVersion);
    List<AmNodeDef> nodes=new ArrayList<AmNodeDef>();
    for (    NodeInfo node : group.getNodes()) {
      AmNodeDef nodeDef=new AmNodeDef();
      nodeDef.setName(node.getName());
      nodeDef.setIp(node.getMgtIpAddress());
      nodeDef.setFqdn(node.getHostname());
      nodeDef.setRackInfo(node.getRack());
      nodeDef.setConfigurations(AmUtils.toAmConfigurations(group.getConfiguration()));
      nodeDef.setComponents(group.getRoles());
      nodeDef.setVolumes(node.getVolumes());
      nodeDef.setDirsConfig(hdfs,ambariServerVersion);
      nodes.add(nodeDef);
    }
    nodeGroupDef.setNodes(nodes);
    this.nodeGroups.add(nodeGroupDef);
  }
  if (blueprint.getExternalNamenode() != null) {
    this.isComputeOnly=true;
    this.externalNamenode=blueprint.getExternalNamenode();
    this.externalSecondaryNamenode=blueprint.getExternalSecondaryNamenode();
    String externalNameNodeGroupName=""String_Node_Str"";
    AmNodeDef namenodeDef=new AmNodeDef();
    namenodeDef.setName(name + ""String_Node_Str"" + externalNameNodeGroupName+ ""String_Node_Str"");
    namenodeDef.setFqdn(externalNamenode);
    List<String> namenodeRoles=new ArrayList<String>();
    namenodeRoles.add(""String_Node_Str"");
    if (!isValidExternalSecondaryNamenode()) {
      namenodeRoles.add(""String_Node_Str"");
    }
    namenodeDef.setComponents(namenodeRoles);
    namenodeDef.setVolumes(new ArrayList<String>());
    namenodeDef.setConfigurations(AmUtils.toAmConfigurations(null));
    AmNodeGroupDef externalNameNodeGroup=new AmNodeGroupDef();
    externalNameNodeGroup.setName(externalNameNodeGroupName);
    externalNameNodeGroup.setConfigurations(AmUtils.toAmConfigurations(null));
    externalNameNodeGroup.setRoles(namenodeRoles);
    externalNameNodeGroup.setInstanceNum(1);
    List<AmNodeDef> externalNameNodes=new ArrayList<AmNodeDef>();
    externalNameNodes.add(namenodeDef);
    externalNameNodeGroup.setNodes(externalNameNodes);
    this.nodeGroups.add(externalNameNodeGroup);
    if (isValidExternalSecondaryNamenode()) {
      String externalSecondaryNameNodeGroupName=""String_Node_Str"";
      AmNodeDef secondaryNamenodeDef=new AmNodeDef();
      secondaryNamenodeDef.setName(name + ""String_Node_Str"" + externalSecondaryNameNodeGroupName+ ""String_Node_Str"");
      secondaryNamenodeDef.setFqdn(externalSecondaryNamenode);
      List<String> secondaryNamenodeRoles=new ArrayList<String>();
      secondaryNamenodeRoles.add(""String_Node_Str"");
      secondaryNamenodeDef.setComponents(secondaryNamenodeRoles);
      secondaryNamenodeDef.setVolumes(new ArrayList<String>());
      secondaryNamenodeDef.setConfigurations(AmUtils.toAmConfigurations(null));
      AmNodeGroupDef externalSecondaryNameNodeGroup=new AmNodeGroupDef();
      externalSecondaryNameNodeGroup.setName(externalSecondaryNameNodeGroupName);
      externalSecondaryNameNodeGroup.setConfigurations(AmUtils.toAmConfigurations(null));
      externalSecondaryNameNodeGroup.setRoles(secondaryNamenodeRoles);
      externalSecondaryNameNodeGroup.setInstanceNum(1);
      List<AmNodeDef> externalSecondaryNameNodes=new ArrayList<AmNodeDef>();
      externalSecondaryNameNodes.add(secondaryNamenodeDef);
      externalSecondaryNameNodeGroup.setNodes(externalSecondaryNameNodes);
      this.nodeGroups.add(externalSecondaryNameNodeGroup);
    }
  }
  AmStackDef stackDef=new AmStackDef();
  stackDef.setName(blueprint.getHadoopStack().getVendor());
  stackDef.setVersion(blueprint.getHadoopStack().getFullVersion());
  this.amStack=stackDef;
}","public AmClusterDef(ClusterBlueprint blueprint,String privateKey,String ambariServerVersion){
  this.name=blueprint.getName();
  this.version=blueprint.getHadoopStack().getFullVersion();
  this.verbose=true;
  this.sshKey=privateKey;
  this.user=Constants.AMBARI_SSH_USER;
  this.currentReport=new ClusterReport(blueprint);
  this.ambariServerVersion=ambariServerVersion;
  HdfsVersion hdfs=getDefaultHdfsVersion(this.version);
  if (blueprint.hasTopologyPolicy()) {
    setRackTopologyFileName(blueprint);
  }
  setAdditionalConfigurations(blueprint,ambariServerVersion);
  this.configurations=AmUtils.toAmConfigurations(blueprint.getConfiguration());
  this.nodeGroups=new ArrayList<AmNodeGroupDef>();
  for (  NodeGroupInfo group : blueprint.getNodeGroups()) {
    AmNodeGroupDef nodeGroupDef=new AmNodeGroupDef();
    nodeGroupDef.setName(group.getName());
    nodeGroupDef.setInstanceNum(group.getInstanceNum());
    nodeGroupDef.setRoles(group.getRoles());
    nodeGroupDef.setConfigurations(AmUtils.toAmConfigurations(group.getConfiguration()));
    nodeGroupDef.setClusterName(this.name);
    nodeGroupDef.setAmbariServerVersion(ambariServerVersion);
    List<AmNodeDef> nodes=new ArrayList<AmNodeDef>();
    for (    NodeInfo node : group.getNodes()) {
      AmNodeDef nodeDef=new AmNodeDef();
      nodeDef.setName(node.getName());
      nodeDef.setIp(node.getMgtIpAddress());
      nodeDef.setFqdn(node.getHostname());
      nodeDef.setRackInfo(node.getRack());
      nodeDef.setConfigurations(AmUtils.toAmConfigurations(group.getConfiguration()));
      nodeDef.setComponents(group.getRoles());
      nodeDef.setVolumes(node.getVolumes());
      nodeDef.setDirsConfig(hdfs,ambariServerVersion);
      nodes.add(nodeDef);
    }
    nodeGroupDef.setNodes(nodes);
    this.nodeGroups.add(nodeGroupDef);
  }
  if (blueprint.getExternalNamenode() != null) {
    this.isComputeOnly=true;
    this.externalNamenode=blueprint.getExternalNamenode();
    this.externalSecondaryNamenode=blueprint.getExternalSecondaryNamenode();
    String externalNameNodeGroupName=""String_Node_Str"";
    AmNodeDef namenodeDef=new AmNodeDef();
    namenodeDef.setName(name + ""String_Node_Str"" + externalNameNodeGroupName+ ""String_Node_Str"");
    namenodeDef.setFqdn(externalNamenode);
    List<String> namenodeRoles=new ArrayList<String>();
    namenodeRoles.add(""String_Node_Str"");
    if (!isValidExternalSecondaryNamenode()) {
      namenodeRoles.add(""String_Node_Str"");
    }
    namenodeDef.setComponents(namenodeRoles);
    namenodeDef.setVolumes(new ArrayList<String>());
    namenodeDef.setConfigurations(AmUtils.toAmConfigurations(null));
    AmNodeGroupDef externalNameNodeGroup=new AmNodeGroupDef();
    externalNameNodeGroup.setName(externalNameNodeGroupName);
    externalNameNodeGroup.setConfigurations(AmUtils.toAmConfigurations(null));
    externalNameNodeGroup.setRoles(namenodeRoles);
    externalNameNodeGroup.setInstanceNum(1);
    List<AmNodeDef> externalNameNodes=new ArrayList<AmNodeDef>();
    externalNameNodes.add(namenodeDef);
    externalNameNodeGroup.setNodes(externalNameNodes);
    this.nodeGroups.add(externalNameNodeGroup);
    if (isValidExternalSecondaryNamenode()) {
      String externalSecondaryNameNodeGroupName=""String_Node_Str"";
      AmNodeDef secondaryNamenodeDef=new AmNodeDef();
      secondaryNamenodeDef.setName(name + ""String_Node_Str"" + externalSecondaryNameNodeGroupName+ ""String_Node_Str"");
      secondaryNamenodeDef.setFqdn(externalSecondaryNamenode);
      List<String> secondaryNamenodeRoles=new ArrayList<String>();
      secondaryNamenodeRoles.add(""String_Node_Str"");
      secondaryNamenodeDef.setComponents(secondaryNamenodeRoles);
      secondaryNamenodeDef.setVolumes(new ArrayList<String>());
      secondaryNamenodeDef.setConfigurations(AmUtils.toAmConfigurations(null));
      AmNodeGroupDef externalSecondaryNameNodeGroup=new AmNodeGroupDef();
      externalSecondaryNameNodeGroup.setName(externalSecondaryNameNodeGroupName);
      externalSecondaryNameNodeGroup.setConfigurations(AmUtils.toAmConfigurations(null));
      externalSecondaryNameNodeGroup.setRoles(secondaryNamenodeRoles);
      externalSecondaryNameNodeGroup.setInstanceNum(1);
      List<AmNodeDef> externalSecondaryNameNodes=new ArrayList<AmNodeDef>();
      externalSecondaryNameNodes.add(secondaryNamenodeDef);
      externalSecondaryNameNodeGroup.setNodes(externalSecondaryNameNodes);
      this.nodeGroups.add(externalSecondaryNameNodeGroup);
    }
  }
  AmStackDef stackDef=new AmStackDef();
  stackDef.setName(blueprint.getHadoopStack().getVendor());
  stackDef.setVersion(blueprint.getHadoopStack().getFullVersion());
  this.amStack=stackDef;
}"
48371,"/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
public void validateClusterCreate(List<String> failedMsgList,List<String> warningMsgList){
  NodeGroupCreate[] nodeGroupCreates=getNodeGroups();
  AuAssert.check(nodeGroupCreates != null && nodeGroupCreates.length > 0);
  if (hasHDFSUrlConfigured() && !validateHDFSUrl()) {
    failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getExternalHDFS()).toString());
  }
  validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList);
  validateStorageType(failedMsgList);
  validateSwapRatio(nodeGroupCreates,failedMsgList);
  for (  NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
    checkInstanceNum(nodeGroupCreate,failedMsgList);
    checkCPUAndMemory(nodeGroupCreate,failedMsgList,warningMsgList);
  }
  if (!warningMsgList.isEmpty() && !warningMsgList.get(0).startsWith(""String_Node_Str"")) {
    warningMsgList.set(0,""String_Node_Str"" + warningMsgList.get(0));
  }
}","/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
public void validateClusterCreate(List<String> failedMsgList,List<String> warningMsgList){
  NodeGroupCreate[] nodeGroupCreates=getNodeGroups();
  AuAssert.check(nodeGroupCreates != null && nodeGroupCreates.length > 0);
  if (hasHDFSUrlConfigured() && !validateHDFSUrl()) {
    failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getExternalHDFS()).toString());
  }
  validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList);
  validateStorageType(failedMsgList);
  validateSwapRatio(nodeGroupCreates,failedMsgList);
  validateCpuRatio(nodeGroupCreates,failedMsgList);
  validateMemRatio(nodeGroupCreates,failedMsgList);
  for (  NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
    checkInstanceNum(nodeGroupCreate,failedMsgList);
    checkCPUAndMemory(nodeGroupCreate,failedMsgList,warningMsgList);
  }
  if (!warningMsgList.isEmpty() && !warningMsgList.get(0).startsWith(""String_Node_Str"")) {
    warningMsgList.set(0,""String_Node_Str"" + warningMsgList.get(0));
  }
}"
48372,"public NodeGroupInfo toNodeGroupInfo(){
  NodeGroupInfo nodeGroupInfo=new NodeGroupInfo();
  nodeGroupInfo.setName(name);
  nodeGroupInfo.setInstanceNum(instanceNum);
  nodeGroupInfo.setRoles(roles);
  nodeGroupInfo.setConfiguration(configuration);
  if (haFlag != null && (haFlag.equalsIgnoreCase(Constants.HA_FLAG_FT) || haFlag.equalsIgnoreCase(Constants.HA_FLAG_ON))) {
    nodeGroupInfo.setHaEnabled(true);
  }
  nodeGroupInfo.setInstanceType(instanceType);
  nodeGroupInfo.setPlacement(placementPolicies);
  if (storage != null) {
    nodeGroupInfo.setStorageSize(storage.getSizeGB());
    nodeGroupInfo.setStorageType(storage.getType());
  }
  nodeGroupInfo.setNodes(null);
  return nodeGroupInfo;
}","public NodeGroupInfo toNodeGroupInfo(){
  NodeGroupInfo nodeGroupInfo=new NodeGroupInfo();
  nodeGroupInfo.setName(name);
  nodeGroupInfo.setInstanceNum(instanceNum);
  nodeGroupInfo.setRoles(roles);
  nodeGroupInfo.setConfiguration(configuration);
  if (haFlag != null && (haFlag.equalsIgnoreCase(Constants.HA_FLAG_FT) || haFlag.equalsIgnoreCase(Constants.HA_FLAG_ON))) {
    nodeGroupInfo.setHaEnabled(true);
  }
  nodeGroupInfo.setInstanceType(instanceType);
  nodeGroupInfo.setPlacement(placementPolicies);
  if (storage != null) {
    nodeGroupInfo.setStorageSize(storage.getSizeGB());
    nodeGroupInfo.setStorageType(storage.getType());
  }
  if (latencySensitivity != null && !CommonUtil.isBlank(latencySensitivity.name())) {
    nodeGroupInfo.setLatencySensitivity(latencySensitivity);
  }
 else {
    nodeGroupInfo.setLatencySensitivity(LatencyPriority.NORMAL);
  }
  nodeGroupInfo.setReservedCpu_ratio(reservedCpu_ratio);
  nodeGroupInfo.setReservedMem_ratio(reservedMem_ratio);
  nodeGroupInfo.setNodes(null);
  return nodeGroupInfo;
}"
48373,"public NodeGroupCreate(NodeGroupCreate group){
  this.cpuNum=group.cpuNum;
  this.haFlag=group.haFlag;
  this.instanceNum=group.instanceNum;
  this.instanceType=group.instanceType;
  this.placementPolicies=group.placementPolicies;
  this.memCapacityMB=group.memCapacityMB;
  this.swapRatio=group.swapRatio;
  this.name=group.name;
  this.roles=group.roles;
  this.rpNames=group.rpNames;
  this.storage=group.storage;
  this.vcClusters=group.vcClusters;
  this.configuration=group.configuration;
  this.vmFolderPath=group.vmFolderPath;
}","public NodeGroupCreate(NodeGroupCreate group){
  this.cpuNum=group.cpuNum;
  this.haFlag=group.haFlag;
  this.instanceNum=group.instanceNum;
  this.instanceType=group.instanceType;
  this.placementPolicies=group.placementPolicies;
  this.memCapacityMB=group.memCapacityMB;
  this.swapRatio=group.swapRatio;
  this.latencySensitivity=group.latencySensitivity;
  this.reservedCpu_ratio=group.reservedCpu_ratio;
  this.reservedMem_ratio=group.reservedMem_ratio;
  this.name=group.name;
  this.roles=group.roles;
  this.rpNames=group.rpNames;
  this.storage=group.storage;
  this.vcClusters=group.vcClusters;
  this.configuration=group.configuration;
  this.vmFolderPath=group.vmFolderPath;
}"
48374,"@SuppressWarnings(""String_Node_Str"") private NodeGroupCreate convertNodeGroups(ClusterEntity clusterEntity,NodeGroupEntity ngEntity,String clusterName){
  Gson gson=new Gson();
  List<String> groupRoles=gson.fromJson(ngEntity.getRoles(),List.class);
  NodeGroupCreate group=new NodeGroupCreate();
  group.setName(ngEntity.getName());
  group.setRoles(groupRoles);
  int cpu=ngEntity.getCpuNum();
  if (cpu > 0) {
    group.setCpuNum(cpu);
  }
  int memory=ngEntity.getMemorySize();
  if (memory > 0) {
    group.setMemCapacityMB(memory);
  }
  Float swapRatio=ngEntity.getSwapRatio();
  if (swapRatio != null && swapRatio > 0) {
    group.setSwapRatio(swapRatio);
  }
  if (ngEntity.getNodeType() != null) {
    group.setInstanceType(ngEntity.getNodeType());
  }
  group.setInstanceNum(ngEntity.getDefineInstanceNum());
  Integer instancePerHost=ngEntity.getInstancePerHost();
  Set<NodeGroupAssociation> associonEntities=ngEntity.getGroupAssociations();
  String ngRacks=ngEntity.getGroupRacks();
  if (instancePerHost == null && (associonEntities == null || associonEntities.isEmpty()) && ngRacks == null) {
    group.setPlacementPolicies(null);
  }
 else {
    PlacementPolicy policies=new PlacementPolicy();
    policies.setInstancePerHost(instancePerHost);
    if (ngRacks != null) {
      policies.setGroupRacks((GroupRacks)new Gson().fromJson(ngRacks,GroupRacks.class));
    }
    if (associonEntities != null) {
      List<GroupAssociation> associons=new ArrayList<GroupAssociation>(associonEntities.size());
      for (      NodeGroupAssociation ae : associonEntities) {
        GroupAssociation a=new GroupAssociation();
        a.setReference(ae.getReferencedGroup());
        a.setType(ae.getAssociationType());
        associons.add(a);
      }
      policies.setGroupAssociations(associons);
    }
    group.setPlacementPolicies(policies);
  }
  String rps=ngEntity.getVcRpNames();
  if (rps != null && rps.length() > 0) {
    logger.debug(""String_Node_Str"" + ngEntity.getName());
    String[] rpNames=gson.fromJson(rps,String[].class);
    List<VcCluster> vcClusters=rpMgr.getVcResourcePoolByNameList(rpNames);
    group.setVcClusters(vcClusters);
    group.setRpNames(Arrays.asList(rpNames));
  }
  expandGroupStorage(ngEntity,group);
  group.setHaFlag(ngEntity.getHaFlag());
  if (ngEntity.getHadoopConfig() != null) {
    Map<String,Object> hadoopConfig=(new Gson()).fromJson(ngEntity.getHadoopConfig(),Map.class);
    group.setConfiguration(hadoopConfig);
  }
  group.setVmFolderPath(ngEntity.getVmFolderPath());
  return group;
}","@SuppressWarnings(""String_Node_Str"") private NodeGroupCreate convertNodeGroups(ClusterEntity clusterEntity,NodeGroupEntity ngEntity,String clusterName){
  Gson gson=new Gson();
  List<String> groupRoles=gson.fromJson(ngEntity.getRoles(),List.class);
  NodeGroupCreate group=new NodeGroupCreate();
  group.setName(ngEntity.getName());
  group.setRoles(groupRoles);
  int cpu=ngEntity.getCpuNum();
  if (cpu > 0) {
    group.setCpuNum(cpu);
  }
  int memory=ngEntity.getMemorySize();
  if (memory > 0) {
    group.setMemCapacityMB(memory);
  }
  Float swapRatio=ngEntity.getSwapRatio();
  if (swapRatio != null && swapRatio > 0) {
    group.setSwapRatio(swapRatio);
  }
  if (ngEntity.getNodeType() != null) {
    group.setInstanceType(ngEntity.getNodeType());
  }
  group.setInstanceNum(ngEntity.getDefineInstanceNum());
  Integer instancePerHost=ngEntity.getInstancePerHost();
  Set<NodeGroupAssociation> associonEntities=ngEntity.getGroupAssociations();
  String ngRacks=ngEntity.getGroupRacks();
  if (instancePerHost == null && (associonEntities == null || associonEntities.isEmpty()) && ngRacks == null) {
    group.setPlacementPolicies(null);
  }
 else {
    PlacementPolicy policies=new PlacementPolicy();
    policies.setInstancePerHost(instancePerHost);
    if (ngRacks != null) {
      policies.setGroupRacks((GroupRacks)new Gson().fromJson(ngRacks,GroupRacks.class));
    }
    if (associonEntities != null) {
      List<GroupAssociation> associons=new ArrayList<GroupAssociation>(associonEntities.size());
      for (      NodeGroupAssociation ae : associonEntities) {
        GroupAssociation a=new GroupAssociation();
        a.setReference(ae.getReferencedGroup());
        a.setType(ae.getAssociationType());
        associons.add(a);
      }
      policies.setGroupAssociations(associons);
    }
    group.setPlacementPolicies(policies);
  }
  String rps=ngEntity.getVcRpNames();
  if (rps != null && rps.length() > 0) {
    logger.debug(""String_Node_Str"" + ngEntity.getName());
    String[] rpNames=gson.fromJson(rps,String[].class);
    List<VcCluster> vcClusters=rpMgr.getVcResourcePoolByNameList(rpNames);
    group.setVcClusters(vcClusters);
    group.setRpNames(Arrays.asList(rpNames));
  }
  expandGroupStorage(ngEntity,group);
  group.setHaFlag(ngEntity.getHaFlag());
  group.setLatencySensitivity(ngEntity.getLatencySensitivity());
  group.setReservedCpu_ratio(ngEntity.getReservedCpu_ratio());
  group.setReservedMem_ratio(ngEntity.getReservedMem_ratio());
  if (ngEntity.getHadoopConfig() != null) {
    Map<String,Object> hadoopConfig=(new Gson()).fromJson(ngEntity.getHadoopConfig(),Map.class);
    group.setConfiguration(hadoopConfig);
  }
  group.setVmFolderPath(ngEntity.getVmFolderPath());
  return group;
}"
48375,"@Transactional public ClusterEntity createClusterConfig(ClusterCreate cluster){
  String name=cluster.getName();
  if (name == null || name.isEmpty()) {
    throw ClusterConfigException.CLUSTER_NAME_MISSING();
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  String appManager=cluster.getAppManager();
  if (appManager == null) {
    appManager=Constants.IRONFAN;
  }
  SoftwareManager softwareManager=getSoftwareManager(appManager);
  HadoopStack stack=filterDistroFromAppManager(softwareManager,cluster.getDistro());
  if (cluster.getDistro() == null || stack == null) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",cluster.getDistro());
  }
  ClusterBlueprint blueprint=cluster.toBlueprint();
  try {
    softwareManager.validateBlueprint(cluster.toBlueprint());
    cluster.validateClusterCreate(failedMsgList,warningMsgList);
  }
 catch (  ValidationException e) {
    failedMsgList.addAll(e.getFailedMsgList());
    warningMsgList.addAll(e.getWarningMsgList());
  }
  if (!failedMsgList.isEmpty()) {
    throw ClusterConfigException.INVALID_SPEC(failedMsgList);
  }
  if (!validateRacksInfo(cluster,failedMsgList)) {
    throw ClusterConfigException.INVALID_PLACEMENT_POLICIES(failedMsgList);
  }
  String localRepoURL=cluster.getLocalRepoURL();
  if (!CommonUtil.isBlank(localRepoURL) && !validateLocalRepoURL(localRepoURL)) {
    throw ClusterConfigException.INVALID_LOCAL_REPO_URL(failedMsgList);
  }
  try {
    ClusterEntity entity=clusterEntityMgr.findByName(name);
    if (entity != null) {
      logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
      throw BddException.ALREADY_EXISTS(""String_Node_Str"",name);
    }
    updateInfrastructure(cluster,softwareManager,blueprint);
    logger.debug(""String_Node_Str"" + name);
    Gson gson=new Gson();
    ClusterEntity clusterEntity=new ClusterEntity(name);
    clusterEntity.setAppManager(cluster.getAppManager());
    clusterEntity.setDistro(cluster.getDistro());
    clusterEntity.setDistroVendor(cluster.getDistroVendor());
    clusterEntity.setDistroVersion(cluster.getDistroVersion());
    clusterEntity.setStartAfterDeploy(true);
    clusterEntity.setPassword(cluster.getPassword());
    clusterEntity.setTemplateId(this.nodeTemplateService.getNodeTemplateIdByName(cluster.getTemplateName()));
    clusterEntity.setVersion(clusterEntityMgr.getServerVersion());
    if (softwareManager.containsComputeOnlyNodeGroups(blueprint)) {
      clusterEntity.setAutomationEnable(automationEnable);
    }
 else {
      clusterEntity.setAutomationEnable(null);
    }
    clusterEntity.setVhmMinNum(-1);
    clusterEntity.setVhmMaxNum(-1);
    if (cluster.getRpNames() != null && cluster.getRpNames().size() > 0) {
      logger.debug(""String_Node_Str"" + cluster.getRpNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcRpNameList(cluster.getRpNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    if (cluster.getDsNames() != null && !cluster.getDsNames().isEmpty()) {
      logger.debug(""String_Node_Str"" + cluster.getDsNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcDatastoreNameList(cluster.getDsNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    clusterEntity.setNetworkConfig(validateAndConvertNetNamesToNetConfigs(cluster.getNetworkConfig(),cluster.getDistroVendor().equalsIgnoreCase(Constants.MAPR_VENDOR)));
    clusterEntity.setVhmJobTrackerPort(""String_Node_Str"");
    if (cluster.getConfiguration() != null && cluster.getConfiguration().size() > 0) {
      clusterEntity.setHadoopConfig((new Gson()).toJson(cluster.getConfiguration()));
      updateVhmJobTrackerPort(cluster,clusterEntity);
    }
    setInfraConfig(cluster,clusterEntity);
    setAdvancedProperties(cluster.getExternalHDFS(),cluster.getExternalMapReduce(),localRepoURL,cluster.getExternalNamenode(),cluster.getExternalSecondaryNamenode(),cluster.getExternalDatanodes(),cluster.getClusterCloneType(),clusterEntity);
    NodeGroupCreate[] groups=cluster.getNodeGroups();
    if (groups != null && groups.length > 0) {
      clusterEntity.setNodeGroups(convertNodeGroupsToEntities(gson,clusterEntity,cluster.getDistro(),groups,cluster.isValidateConfig()));
      validateMemorySize(clusterEntity.getNodeGroups(),failedMsgList);
      if (!failedMsgList.isEmpty()) {
        throw ClusterConfigException.INVALID_SPEC(failedMsgList);
      }
    }
    if (cluster.getTopologyPolicy() == null) {
      clusterEntity.setTopologyPolicy(TopologyType.NONE);
    }
 else {
      clusterEntity.setTopologyPolicy(cluster.getTopologyPolicy());
    }
    if (clusterEntity.getTopologyPolicy() == TopologyType.HVE) {
      boolean hveSupported=false;
      if (clusterEntity.getDistro() != null) {
        HadoopStack hadoopStack=filterDistroFromAppManager(softwareManager,clusterEntity.getDistro());
        if (hadoopStack != null) {
          hveSupported=hadoopStack.isHveSupported();
        }
      }
      if (!hveSupported) {
        throw ClusterConfigException.INVALID_TOPOLOGY_POLICY(clusterEntity.getTopologyPolicy(),""String_Node_Str"");
      }
    }
    clusterEntityMgr.insert(clusterEntity);
    logger.debug(""String_Node_Str"" + name);
    return clusterEntity;
  }
 catch (  UniqueConstraintViolationException ex) {
    logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
    throw BddException.ALREADY_EXISTS(ex,""String_Node_Str"",name);
  }
}","@Transactional public ClusterEntity createClusterConfig(ClusterCreate cluster){
  String name=cluster.getName();
  if (name == null || name.isEmpty()) {
    throw ClusterConfigException.CLUSTER_NAME_MISSING();
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  String appManager=cluster.getAppManager();
  if (appManager == null) {
    appManager=Constants.IRONFAN;
  }
  SoftwareManager softwareManager=getSoftwareManager(appManager);
  HadoopStack stack=filterDistroFromAppManager(softwareManager,cluster.getDistro());
  if (cluster.getDistro() == null || stack == null) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",cluster.getDistro());
  }
  ClusterBlueprint blueprint=cluster.toBlueprint();
  try {
    softwareManager.validateBlueprint(cluster.toBlueprint());
    cluster.validateClusterCreate(failedMsgList,warningMsgList);
  }
 catch (  ValidationException e) {
    failedMsgList.addAll(e.getFailedMsgList());
    warningMsgList.addAll(e.getWarningMsgList());
  }
  if (!failedMsgList.isEmpty()) {
    throw ClusterConfigException.INVALID_SPEC(failedMsgList);
  }
  if (!validateRacksInfo(cluster,failedMsgList)) {
    throw ClusterConfigException.INVALID_PLACEMENT_POLICIES(failedMsgList);
  }
  String localRepoURL=cluster.getLocalRepoURL();
  if (!CommonUtil.isBlank(localRepoURL) && !validateLocalRepoURL(localRepoURL)) {
    throw ClusterConfigException.INVALID_LOCAL_REPO_URL(failedMsgList);
  }
  try {
    ClusterEntity entity=clusterEntityMgr.findByName(name);
    if (entity != null) {
      logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
      throw BddException.ALREADY_EXISTS(""String_Node_Str"",name);
    }
    updateInfrastructure(cluster,softwareManager,blueprint);
    logger.debug(""String_Node_Str"" + name);
    Gson gson=new Gson();
    ClusterEntity clusterEntity=new ClusterEntity(name);
    clusterEntity.setAppManager(cluster.getAppManager());
    clusterEntity.setDistro(cluster.getDistro());
    clusterEntity.setDistroVendor(cluster.getDistroVendor());
    clusterEntity.setDistroVersion(cluster.getDistroVersion());
    clusterEntity.setStartAfterDeploy(true);
    clusterEntity.setPassword(cluster.getPassword());
    clusterEntity.setTemplateId(this.nodeTemplateService.getNodeTemplateIdByName(cluster.getTemplateName()));
    clusterEntity.setVersion(clusterEntityMgr.getServerVersion());
    if (softwareManager.containsComputeOnlyNodeGroups(blueprint)) {
      clusterEntity.setAutomationEnable(automationEnable);
    }
 else {
      clusterEntity.setAutomationEnable(null);
    }
    clusterEntity.setVhmMinNum(-1);
    clusterEntity.setVhmMaxNum(-1);
    if (cluster.getRpNames() != null && cluster.getRpNames().size() > 0) {
      logger.debug(""String_Node_Str"" + cluster.getRpNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcRpNameList(cluster.getRpNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    if (cluster.getDsNames() != null && !cluster.getDsNames().isEmpty()) {
      logger.debug(""String_Node_Str"" + cluster.getDsNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcDatastoreNameList(cluster.getDsNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    clusterEntity.setNetworkConfig(validateAndConvertNetNamesToNetConfigs(cluster.getNetworkConfig(),cluster.getDistroVendor().equalsIgnoreCase(Constants.MAPR_VENDOR)));
    clusterEntity.setVhmJobTrackerPort(""String_Node_Str"");
    if (cluster.getConfiguration() != null && cluster.getConfiguration().size() > 0) {
      clusterEntity.setHadoopConfig((new Gson()).toJson(cluster.getConfiguration()));
      updateVhmJobTrackerPort(cluster,clusterEntity);
    }
    setInfraConfig(cluster,clusterEntity);
    setAdvancedProperties(cluster.getExternalHDFS(),cluster.getExternalMapReduce(),localRepoURL,cluster.getExternalNamenode(),cluster.getExternalSecondaryNamenode(),cluster.getExternalDatanodes(),cluster.getClusterCloneType(),clusterEntity);
    NodeGroupCreate[] groups=cluster.getNodeGroups();
    if (groups != null && groups.length > 0) {
      clusterEntity.setNodeGroups(convertNodeGroupsToEntities(gson,clusterEntity,cluster.getDistro(),groups,cluster.isValidateConfig()));
      validateMemorySize(clusterEntity.getNodeGroups(),failedMsgList);
      if (!failedMsgList.isEmpty()) {
        throw ClusterConfigException.INVALID_SPEC(failedMsgList);
      }
    }
    if (!CommonUtil.isBlank(cluster.getAppManager()) && Constants.IRONFAN.equals(cluster.getAppManager()))     for (int i=0; i < clusterEntity.getNodeGroups().size(); i++) {
      NodeGroupEntity group=clusterEntity.getNodeGroups().get(i);
      String groupRoles=group.getRoles();
      if ((group.getLatencySensitivity() == LatencyPriority.HIGH) && ((groupRoles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString())))) {
        setHbase_RegionServer_Opts(cluster,group);
        if (cluster.getConfiguration() != null && cluster.getConfiguration().size() > 0) {
          clusterEntity.setHadoopConfig((new Gson()).toJson(cluster.getConfiguration()));
        }
        break;
      }
    }
    if (cluster.getTopologyPolicy() == null) {
      clusterEntity.setTopologyPolicy(TopologyType.NONE);
    }
 else {
      clusterEntity.setTopologyPolicy(cluster.getTopologyPolicy());
    }
    if (clusterEntity.getTopologyPolicy() == TopologyType.HVE) {
      boolean hveSupported=false;
      if (clusterEntity.getDistro() != null) {
        HadoopStack hadoopStack=filterDistroFromAppManager(softwareManager,clusterEntity.getDistro());
        if (hadoopStack != null) {
          hveSupported=hadoopStack.isHveSupported();
        }
      }
      if (!hveSupported) {
        throw ClusterConfigException.INVALID_TOPOLOGY_POLICY(clusterEntity.getTopologyPolicy(),""String_Node_Str"");
      }
    }
    clusterEntityMgr.insert(clusterEntity);
    logger.debug(""String_Node_Str"" + name);
    return clusterEntity;
  }
 catch (  UniqueConstraintViolationException ex) {
    logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
    throw BddException.ALREADY_EXISTS(ex,""String_Node_Str"",name);
  }
}"
48376,"private NodeGroupEntity convertGroup(Gson gson,ClusterEntity clusterEntity,NodeGroupCreate group,String distro,boolean validateWhiteList){
  NodeGroupEntity groupEntity=new NodeGroupEntity();
  if (group.getRoles() == null || group.getRoles().isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  groupEntity.setCluster(clusterEntity);
  String templateId=this.nodeTemplateService.getNodeTemplateNameByMoid(clusterEntity.getTemplateId());
  int cpuNum=group.getCpuNum() == null ? 0 : group.getCpuNum();
  if (!VcVmUtil.validateCPU(clusterEntity.getTemplateId(),cpuNum)) {
    throw VcProviderException.CPU_NUM_NOT_MULTIPLE_OF_CORES_PER_SOCKET(group.getName(),templateId);
  }
  groupEntity.setCpuNum(cpuNum);
  groupEntity.setDefineInstanceNum(group.getInstanceNum());
  groupEntity.setMemorySize(group.getMemCapacityMB() == null ? 0 : group.getMemCapacityMB());
  groupEntity.setSwapRatio(group.getSwapRatio());
  groupEntity.setName(group.getName());
  groupEntity.setNodeType(group.getInstanceType());
  PlacementPolicy policies=group.getPlacementPolicies();
  if (policies != null) {
    List<GroupAssociation> associons=policies.getGroupAssociations();
    if (associons != null) {
      Set<NodeGroupAssociation> associonEntities=new HashSet<NodeGroupAssociation>();
      for (      GroupAssociation a : associons) {
        NodeGroupAssociation ae=new NodeGroupAssociation();
        ae.setAssociationType(a.getType());
        ae.setNodeGroup(groupEntity);
        ae.setReferencedGroup(a.getReference());
        associonEntities.add(ae);
      }
      groupEntity.setGroupAssociations(associonEntities);
    }
    if (policies.getInstancePerHost() != null) {
      groupEntity.setInstancePerHost(policies.getInstancePerHost());
    }
    if (policies.getGroupRacks() != null) {
      groupEntity.setGroupRacks((new Gson()).toJson(policies.getGroupRacks()));
    }
  }
  if (group.getRpNames() != null && group.getRpNames().size() > 0) {
    groupEntity.setVcRpNameList(group.getRpNames());
  }
  Set<String> roles=new LinkedHashSet<String>();
  convertStorage(group,groupEntity,roles);
  roles.addAll(group.getRoles());
  groupEntity.setRoles(gson.toJson(roles));
  if (group.getInstanceNum() <= 0) {
    logger.warn(""String_Node_Str"" + group.getName() + ""String_Node_Str"");
    return null;
  }
  List<String> dsNames=groupEntity.getVcDatastoreNameList();
  if (dsNames == null) {
    dsNames=clusterEntity.getVcDatastoreNameList();
  }
  Set<String> sharedPattern;
  Set<String> localPattern;
  if (dsNames != null) {
    sharedPattern=datastoreMgr.getSharedDatastoresByNames(dsNames);
    localPattern=datastoreMgr.getLocalDatastoresByNames(dsNames);
  }
 else {
    sharedPattern=datastoreMgr.getAllSharedDatastores();
    localPattern=datastoreMgr.getAllLocalDatastores();
  }
  SoftwareManager softwareManager=getSoftwareManager(clusterEntity.getAppManager());
  CommonClusterExpandPolicy.expandGroupInstanceType(groupEntity,group,sharedPattern,localPattern,softwareManager);
  String haFlag=group.getHaFlag();
  if (haFlag == null) {
    groupEntity.setHaFlag(Constants.HA_FLAG_OFF);
  }
 else {
    groupEntity.setHaFlag(haFlag);
  }
  if (group.getConfiguration() != null && group.getConfiguration().size() > 0) {
    groupEntity.setHadoopConfig(gson.toJson(group.getConfiguration()));
  }
  groupEntity.setVmFolderPath(clusterEntity);
  logger.debug(""String_Node_Str"" + group.getName());
  return groupEntity;
}","private NodeGroupEntity convertGroup(Gson gson,ClusterEntity clusterEntity,NodeGroupCreate group,String distro,boolean validateWhiteList){
  NodeGroupEntity groupEntity=new NodeGroupEntity();
  if (group.getRoles() == null || group.getRoles().isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  groupEntity.setCluster(clusterEntity);
  String templateId=this.nodeTemplateService.getNodeTemplateNameByMoid(clusterEntity.getTemplateId());
  int cpuNum=group.getCpuNum() == null ? 0 : group.getCpuNum();
  if (!VcVmUtil.validateCPU(clusterEntity.getTemplateId(),cpuNum)) {
    throw VcProviderException.CPU_NUM_NOT_MULTIPLE_OF_CORES_PER_SOCKET(group.getName(),templateId);
  }
  groupEntity.setCpuNum(cpuNum);
  groupEntity.setDefineInstanceNum(group.getInstanceNum());
  groupEntity.setMemorySize(group.getMemCapacityMB() == null ? 0 : group.getMemCapacityMB());
  groupEntity.setSwapRatio(group.getSwapRatio());
  groupEntity.setName(group.getName());
  groupEntity.setNodeType(group.getInstanceType());
  groupEntity.setReservedCpu_ratio(group.getReservedCpu_ratio());
  groupEntity.setReservedMem_ratio(group.getReservedMem_ratio());
  PlacementPolicy policies=group.getPlacementPolicies();
  if (policies != null) {
    List<GroupAssociation> associons=policies.getGroupAssociations();
    if (associons != null) {
      Set<NodeGroupAssociation> associonEntities=new HashSet<NodeGroupAssociation>();
      for (      GroupAssociation a : associons) {
        NodeGroupAssociation ae=new NodeGroupAssociation();
        ae.setAssociationType(a.getType());
        ae.setNodeGroup(groupEntity);
        ae.setReferencedGroup(a.getReference());
        associonEntities.add(ae);
      }
      groupEntity.setGroupAssociations(associonEntities);
    }
    if (policies.getInstancePerHost() != null) {
      groupEntity.setInstancePerHost(policies.getInstancePerHost());
    }
    if (policies.getGroupRacks() != null) {
      groupEntity.setGroupRacks((new Gson()).toJson(policies.getGroupRacks()));
    }
  }
  if (group.getRpNames() != null && group.getRpNames().size() > 0) {
    groupEntity.setVcRpNameList(group.getRpNames());
  }
  Set<String> roles=new LinkedHashSet<String>();
  convertStorage(group,groupEntity,roles);
  roles.addAll(group.getRoles());
  groupEntity.setRoles(gson.toJson(roles));
  if (group.getInstanceNum() <= 0) {
    logger.warn(""String_Node_Str"" + group.getName() + ""String_Node_Str"");
    return null;
  }
  List<String> dsNames=groupEntity.getVcDatastoreNameList();
  if (dsNames == null) {
    dsNames=clusterEntity.getVcDatastoreNameList();
  }
  Set<String> sharedPattern;
  Set<String> localPattern;
  if (dsNames != null) {
    sharedPattern=datastoreMgr.getSharedDatastoresByNames(dsNames);
    localPattern=datastoreMgr.getLocalDatastoresByNames(dsNames);
  }
 else {
    sharedPattern=datastoreMgr.getAllSharedDatastores();
    localPattern=datastoreMgr.getAllLocalDatastores();
  }
  SoftwareManager softwareManager=getSoftwareManager(clusterEntity.getAppManager());
  CommonClusterExpandPolicy.expandGroupInstanceType(groupEntity,group,sharedPattern,localPattern,softwareManager);
  String haFlag=group.getHaFlag();
  if (haFlag == null) {
    groupEntity.setHaFlag(Constants.HA_FLAG_OFF);
  }
 else {
    groupEntity.setHaFlag(haFlag);
  }
  LatencyPriority latencySensitivity=group.getLatencySensitivity();
  if (latencySensitivity != null)   groupEntity.setLatencySensitivity(latencySensitivity);
 else   groupEntity.setLatencySensitivity(LatencyPriority.NORMAL);
  groupEntity.setReservedCpu_ratio(group.getReservedCpu_ratio());
  groupEntity.setReservedMem_ratio(group.getReservedMem_ratio());
  if (group.getConfiguration() != null && group.getConfiguration().size() > 0) {
    groupEntity.setHadoopConfig(gson.toJson(group.getConfiguration()));
  }
  groupEntity.setVmFolderPath(clusterEntity);
  logger.debug(""String_Node_Str"" + group.getName());
  return groupEntity;
}"
48377,"public AmClusterDef(ClusterBlueprint blueprint,String privateKey,String ambariServerVersion){
  this.name=blueprint.getName();
  this.version=blueprint.getHadoopStack().getFullVersion();
  this.verbose=true;
  this.sshKey=privateKey;
  this.user=Constants.AMBARI_SSH_USER;
  this.currentReport=new ClusterReport(blueprint);
  this.ambariServerVersion=ambariServerVersion;
  this.nodes=new ArrayList<AmNodeDef>();
  HdfsVersion hdfs=getDefaultHdfsVersion(this.version);
  if (blueprint.hasTopologyPolicy()) {
    setRackTopologyFileName(blueprint);
  }
  this.configurations=AmUtils.toAmConfigurations(blueprint.getConfiguration());
  for (  NodeGroupInfo group : blueprint.getNodeGroups()) {
    for (    NodeInfo node : group.getNodes()) {
      AmNodeDef nodeDef=new AmNodeDef();
      nodeDef.setName(node.getName());
      nodeDef.setIp(node.getMgtIpAddress());
      nodeDef.setFqdn(node.getHostname());
      nodeDef.setRackInfo(node.getRack());
      nodeDef.setConfigurations(AmUtils.toAmConfigurations(group.getConfiguration()));
      nodeDef.setComponents(group.getRoles());
      nodeDef.setVolumns(node.getVolumes(),hdfs,ambariServerVersion);
      this.nodes.add(nodeDef);
    }
  }
  if (blueprint.getExternalNamenode() != null) {
    this.isComputeOnly=true;
    this.externalNamenode=blueprint.getExternalNamenode();
    this.externalSecondaryNamenode=blueprint.getExternalSecondaryNamenode();
    AmNodeDef namenodeDef=new AmNodeDef();
    namenodeDef.setName(name + ""String_Node_Str"");
    namenodeDef.setFqdn(externalNamenode);
    List<String> namenodeRoles=new ArrayList<String>();
    namenodeRoles.add(""String_Node_Str"");
    if (!isValidExternalSecondaryNamenode()) {
      namenodeRoles.add(""String_Node_Str"");
    }
    namenodeDef.setComponents(namenodeRoles);
    this.nodes.add(namenodeDef);
    if (isValidExternalSecondaryNamenode()) {
      AmNodeDef secondaryNamenodeDef=new AmNodeDef();
      secondaryNamenodeDef.setName(name + ""String_Node_Str"");
      secondaryNamenodeDef.setFqdn(externalSecondaryNamenode);
      List<String> secondaryNamenodeRoles=new ArrayList<String>();
      secondaryNamenodeRoles.add(""String_Node_Str"");
      secondaryNamenodeDef.setComponents(secondaryNamenodeRoles);
      this.nodes.add(secondaryNamenodeDef);
    }
  }
  AmStackDef stackDef=new AmStackDef();
  stackDef.setName(blueprint.getHadoopStack().getVendor());
  stackDef.setVersion(blueprint.getHadoopStack().getFullVersion());
  this.amStack=stackDef;
}","public AmClusterDef(ClusterBlueprint blueprint,String privateKey,String ambariServerVersion){
  this.name=blueprint.getName();
  this.version=blueprint.getHadoopStack().getFullVersion();
  this.verbose=true;
  this.sshKey=privateKey;
  this.user=Constants.AMBARI_SSH_USER;
  this.currentReport=new ClusterReport(blueprint);
  this.ambariServerVersion=ambariServerVersion;
  this.nodes=new ArrayList<AmNodeDef>();
  HdfsVersion hdfs=getDefaultHdfsVersion(this.version);
  if (blueprint.hasTopologyPolicy()) {
    setRackTopologyFileName(blueprint);
  }
  setAdditionalConfigurations(blueprint,ambariServerVersion);
  this.configurations=AmUtils.toAmConfigurations(blueprint.getConfiguration());
  for (  NodeGroupInfo group : blueprint.getNodeGroups()) {
    for (    NodeInfo node : group.getNodes()) {
      AmNodeDef nodeDef=new AmNodeDef();
      nodeDef.setName(node.getName());
      nodeDef.setIp(node.getMgtIpAddress());
      nodeDef.setFqdn(node.getHostname());
      nodeDef.setRackInfo(node.getRack());
      nodeDef.setConfigurations(AmUtils.toAmConfigurations(group.getConfiguration()));
      nodeDef.setComponents(group.getRoles());
      nodeDef.setVolumns(node.getVolumes(),hdfs,ambariServerVersion);
      this.nodes.add(nodeDef);
    }
  }
  if (blueprint.getExternalNamenode() != null) {
    this.isComputeOnly=true;
    this.externalNamenode=blueprint.getExternalNamenode();
    this.externalSecondaryNamenode=blueprint.getExternalSecondaryNamenode();
    AmNodeDef namenodeDef=new AmNodeDef();
    namenodeDef.setName(name + ""String_Node_Str"");
    namenodeDef.setFqdn(externalNamenode);
    List<String> namenodeRoles=new ArrayList<String>();
    namenodeRoles.add(""String_Node_Str"");
    if (!isValidExternalSecondaryNamenode()) {
      namenodeRoles.add(""String_Node_Str"");
    }
    namenodeDef.setComponents(namenodeRoles);
    this.nodes.add(namenodeDef);
    if (isValidExternalSecondaryNamenode()) {
      AmNodeDef secondaryNamenodeDef=new AmNodeDef();
      secondaryNamenodeDef.setName(name + ""String_Node_Str"");
      secondaryNamenodeDef.setFqdn(externalSecondaryNamenode);
      List<String> secondaryNamenodeRoles=new ArrayList<String>();
      secondaryNamenodeRoles.add(""String_Node_Str"");
      secondaryNamenodeDef.setComponents(secondaryNamenodeRoles);
      this.nodes.add(secondaryNamenodeDef);
    }
  }
  AmStackDef stackDef=new AmStackDef();
  stackDef.setName(blueprint.getHadoopStack().getVendor());
  stackDef.setVersion(blueprint.getHadoopStack().getFullVersion());
  this.amStack=stackDef;
}"
48378,"/** 
 * Add a VC network into BDE
 * @param na
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST,consumes=""String_Node_Str"") @ResponseStatus(HttpStatus.OK) @RestCallPointcut public void addNetworks(@RequestBody final NetworkAdd na){
  verifyInitialized();
  List<String> missingParameters=new ArrayList<String>();
  if (CommonUtil.isBlank(na.getName())) {
    missingParameters.add(""String_Node_Str"");
  }
  if (CommonUtil.isBlank(na.getPortGroup())) {
    missingParameters.add(""String_Node_Str"");
  }
  if (na.getDnsType() == null) {
    missingParameters.add(""String_Node_Str"");
  }
  if (na.getIsGenerateHostname() == null) {
    missingParameters.add(""String_Node_Str"");
  }
  if (!missingParameters.isEmpty()) {
    throw BddException.MISSING_PARAMETER(missingParameters);
  }
  if (!CommonUtil.validateResourceName(na.getName())) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",na.getName());
  }
  if (!CommonUtil.validateVcResourceName(na.getPortGroup())) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",na.getPortGroup());
  }
  if (!CommonUtil.validateDnsType(na.getDnsType())) {
    throw BddException.INVALID_DNS_TYPE(na.getDnsType());
  }
  if (na.getIsDhcp()) {
    networkSvc.addDhcpNetwork(na.getName(),na.getPortGroup(),na.getDnsType(),na.getIsGenerateHostname());
  }
 else {
    if (!IpAddressUtil.isValidNetmask(na.getNetmask())) {
      throw BddException.INVALID_PARAMETER(""String_Node_Str"",na.getNetmask());
    }
    long netmask=IpAddressUtil.getAddressAsLong(na.getNetmask());
    if (na.getGateway() != null && !IpAddressUtil.isValidIp(netmask,IpAddressUtil.getAddressAsLong(na.getGateway()))) {
      throw BddException.INVALID_PARAMETER(""String_Node_Str"",na.getGateway());
    }
    if (na.getDns1() != null && !IpAddressUtil.isValidIp(na.getDns1())) {
      throw BddException.INVALID_PARAMETER(""String_Node_Str"",na.getDns1());
    }
    if (na.getDns2() != null && !IpAddressUtil.isValidIp(na.getDns2())) {
      throw BddException.INVALID_PARAMETER(""String_Node_Str"",na.getDns2());
    }
    IpAddressUtil.verifyIPBlocks(na.getIpBlocks(),netmask);
    networkSvc.addIpPoolNetwork(na.getName(),na.getPortGroup(),na.getNetmask(),na.getGateway(),na.getDns1(),na.getDns2(),na.getIpBlocks(),na.getDnsType(),na.getIsGenerateHostname());
  }
}","/** 
 * Add a VC network into BDE
 * @param na
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST,consumes=""String_Node_Str"") @ResponseStatus(HttpStatus.OK) @RestCallPointcut public void addNetworks(@RequestBody final NetworkAdd na){
  verifyInitialized();
  List<String> missingParameters=new ArrayList<String>();
  if (CommonUtil.isBlank(na.getName())) {
    missingParameters.add(""String_Node_Str"");
  }
  if (CommonUtil.isBlank(na.getPortGroup())) {
    missingParameters.add(""String_Node_Str"");
  }
  if (na.getDnsType() == null) {
    missingParameters.add(""String_Node_Str"");
  }
  if (na.getIsGenerateHostname() == null) {
    missingParameters.add(""String_Node_Str"");
  }
  if (!missingParameters.isEmpty()) {
    throw BddException.MISSING_PARAMETER(missingParameters);
  }
  if (!CommonUtil.validateResourceName(na.getName())) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",na.getName());
  }
  if (!CommonUtil.validateDnsType(na.getDnsType())) {
    throw BddException.INVALID_DNS_TYPE(na.getDnsType());
  }
  if (na.getIsDhcp()) {
    networkSvc.addDhcpNetwork(na.getName(),na.getPortGroup(),na.getDnsType(),na.getIsGenerateHostname());
  }
 else {
    if (!IpAddressUtil.isValidNetmask(na.getNetmask())) {
      throw BddException.INVALID_PARAMETER(""String_Node_Str"",na.getNetmask());
    }
    long netmask=IpAddressUtil.getAddressAsLong(na.getNetmask());
    if (na.getGateway() != null && !IpAddressUtil.isValidIp(netmask,IpAddressUtil.getAddressAsLong(na.getGateway()))) {
      throw BddException.INVALID_PARAMETER(""String_Node_Str"",na.getGateway());
    }
    if (na.getDns1() != null && !IpAddressUtil.isValidIp(na.getDns1())) {
      throw BddException.INVALID_PARAMETER(""String_Node_Str"",na.getDns1());
    }
    if (na.getDns2() != null && !IpAddressUtil.isValidIp(na.getDns2())) {
      throw BddException.INVALID_PARAMETER(""String_Node_Str"",na.getDns2());
    }
    IpAddressUtil.verifyIPBlocks(na.getIpBlocks(),netmask);
    networkSvc.addIpPoolNetwork(na.getName(),na.getPortGroup(),na.getNetmask(),na.getGateway(),na.getDns1(),na.getDns2(),na.getIpBlocks(),na.getDnsType(),na.getIsGenerateHostname());
  }
}"
48379,"private void createBlueprint(final AmClusterDef clusterDef,final ClusterReportQueue reportQueue) throws SoftwareManagementPluginException {
  String clusterName=clusterDef.getName();
  try {
    logger.info(""String_Node_Str"" + clusterName);
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setProgress(ProgressSplit.CREATE_BLUEPRINT.getProgress());
    reportStatus(clusterDef.getCurrentReport(),reportQueue);
    if (!isBlueprintCreated(clusterDef)) {
      apiManager.createBlueprint(clusterName,clusterDef.toApiBlueprint());
    }
 else {
      if (isBlueprintCreatedByBDE(clusterDef)) {
        if (isBlueprintCreatedByBDE(clusterDef)) {
          apiManager.deleteBlueprint(clusterName);
        }
        apiManager.createBlueprint(clusterName,clusterDef.toApiBlueprint());
      }
    }
  }
 catch (  Exception e) {
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    String errorMessage=errorMessage(""String_Node_Str"" + clusterName,e);
    logger.error(errorMessage);
    throw AmException.CREATE_BLUEPRINT_FAILED(e,clusterName);
  }
 finally {
    reportStatus(clusterDef.getCurrentReport(),reportQueue);
  }
}","private void createBlueprint(final AmClusterDef clusterDef,final ClusterReportQueue reportQueue) throws SoftwareManagementPluginException {
  String clusterName=clusterDef.getName();
  try {
    logger.info(""String_Node_Str"" + clusterName);
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setProgress(ProgressSplit.CREATE_BLUEPRINT.getProgress());
    reportStatus(clusterDef.getCurrentReport(),reportQueue);
    ApiBlueprint apiBlueprint=clusterDef.toApiBlueprint();
    if (!isBlueprintCreated(clusterDef)) {
      apiManager.createBlueprint(clusterName,apiBlueprint);
    }
 else {
      if (isBlueprintCreatedByBDE(clusterDef)) {
        apiManager.deleteBlueprint(clusterName);
      }
      apiManager.createBlueprint(clusterName,apiBlueprint);
    }
  }
 catch (  Exception e) {
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    String errorMessage=errorMessage(""String_Node_Str"" + clusterName,e);
    logger.error(errorMessage);
    throw AmException.CREATE_BLUEPRINT_FAILED(e,clusterName);
  }
 finally {
    reportStatus(clusterDef.getCurrentReport(),reportQueue);
  }
}"
48380,"private boolean isBlueprintCreatedByBDE(final AmClusterDef clusterDef) throws SoftwareManagementPluginException {
  String clusterName=clusterDef.getName();
  ApiBlueprint apiBlueprint=apiManager.getBlueprint(clusterName);
  Map<String,Set> groupNamesWithComponents=new HashMap<String,Set>();
  for (  AmNodeDef node : clusterDef.getNodes()) {
    HashSet<String> components=new HashSet<String>();
    groupNamesWithComponents.put(node.getName(),components);
  }
  for (  ApiHostGroup apiHostGroup : apiBlueprint.getApiHostGroups()) {
    String groupName=apiHostGroup.getName();
    if (!groupNamesWithComponents.containsKey(groupName)) {
      throw AmException.BLUEPRINT_ALREADY_EXIST(clusterName);
    }
    @SuppressWarnings(""String_Node_Str"") Set<String> components=groupNamesWithComponents.get(groupName);
    if (components != null && !components.isEmpty()) {
      for (      ApiComponentInfo apiComponent : apiHostGroup.getApiComponents()) {
        if (!components.contains(apiComponent.getName())) {
          throw AmException.BLUEPRINT_ALREADY_EXIST(clusterName);
        }
      }
    }
  }
  return true;
}","private boolean isBlueprintCreatedByBDE(final AmClusterDef clusterDef) throws SoftwareManagementPluginException {
  ApiBlueprint apiBlueprint=clusterDef.toApiBlueprint();
  String clusterName=clusterDef.getName();
  ApiBlueprint apiBlueprintFromAm=apiManager.getBlueprint(clusterName);
  Map<String,Set> groupNamesWithComponents=new HashMap<String,Set>();
  for (  ApiHostGroup hostGroup : apiBlueprint.getApiHostGroups()) {
    HashSet<String> components=new HashSet<String>();
    groupNamesWithComponents.put(hostGroup.getName(),components);
  }
  for (  ApiHostGroup apiHostGroup : apiBlueprintFromAm.getApiHostGroups()) {
    String groupName=apiHostGroup.getName();
    if (!groupNamesWithComponents.containsKey(groupName)) {
      throw AmException.BLUEPRINT_ALREADY_EXIST(clusterName);
    }
    @SuppressWarnings(""String_Node_Str"") Set<String> components=groupNamesWithComponents.get(groupName);
    if (components != null && !components.isEmpty()) {
      for (      ApiComponentInfo apiComponent : apiHostGroup.getApiComponents()) {
        if (!components.contains(apiComponent.getName())) {
          throw AmException.BLUEPRINT_ALREADY_EXIST(clusterName);
        }
      }
    }
  }
  return true;
}"
48381,"public static void printCmdFailure(String objectType,String name,String opName,String result,String message){
  if (isJansiAvailable() && !isBlank(name)) {
    try {
      name=transferEncoding(name);
    }
 catch (    UnsupportedEncodingException|CliException e) {
      logger.warn(""String_Node_Str"" + e.getMessage());
    }
  }
  if (!isBlank(name)) {
    System.out.println(objectType + ""String_Node_Str"" + name+ ""String_Node_Str""+ opName+ ""String_Node_Str""+ result+ ""String_Node_Str""+ message);
  }
 else   if (!isBlank(opName)) {
    System.out.println(objectType + ""String_Node_Str"" + opName+ ""String_Node_Str""+ result+ ""String_Node_Str""+ message);
  }
 else {
    System.out.println(objectType + ""String_Node_Str"" + result+ ""String_Node_Str""+ message);
  }
}","public static void printCmdFailure(String objectType,String name,String opName,String result,String message){
  if (isJansiAvailable() && !isBlank(name)) {
    try {
      name=transferEncoding(name);
      message=transferEncoding(message);
    }
 catch (    UnsupportedEncodingException|CliException e) {
      logger.warn(""String_Node_Str"" + e.getMessage());
    }
  }
  if (!isBlank(name)) {
    System.out.println(objectType + ""String_Node_Str"" + name+ ""String_Node_Str""+ opName+ ""String_Node_Str""+ result+ ""String_Node_Str""+ message);
  }
 else   if (!isBlank(opName)) {
    System.out.println(objectType + ""String_Node_Str"" + opName+ ""String_Node_Str""+ result+ ""String_Node_Str""+ message);
  }
 else {
    System.out.println(objectType + ""String_Node_Str"" + result+ ""String_Node_Str""+ message);
  }
}"
48382,"private void startService(CmClusterDef cluster,CmServiceDef serviceDef,int toProgress,final ClusterReportQueue reportQueue) throws Exception {
  if (apiResourceRootV6.getClustersResource().getServicesResource(cluster.getName()).readService(serviceDef.getName()).getServiceState().equals(ApiServiceState.STARTED)) {
    return;
  }
  executeAndReport(""String_Node_Str"" + serviceDef.getType().getDisplayName(),apiResourceRootV6.getClustersResource().getServicesResource(cluster.getName()).startCommand(serviceDef.getName()),toProgress,cluster.getCurrentReport(),reportQueue,true);
}","private void startService(CmClusterDef cluster,CmServiceDef serviceDef,int toProgress,final ClusterReportQueue reportQueue) throws Exception {
  if (apiResourceRootV6.getClustersResource().getServicesResource(cluster.getName()).readService(serviceDef.getName()).getServiceState().equals(ApiServiceState.STARTED)) {
    return;
  }
  String serviceDisplayName=serviceDef.getType().getDisplayName();
  if (serviceDisplayName.equalsIgnoreCase(""String_Node_Str"")) {
    return;
  }
  logger.info(""String_Node_Str"" + serviceDisplayName);
  executeAndReport(""String_Node_Str"" + serviceDisplayName,apiResourceRootV6.getClustersResource().getServicesResource(cluster.getName()).startCommand(serviceDef.getName()),toProgress,cluster.getCurrentReport(),reportQueue,true);
}"
48383,"private Map<String,Map<String,Object>> packagingOperationData(Map<String,Map<String,Object>> data,Map<String,Object> rawdata){
  Map<String,Object> modifydata=new HashMap<>();
  modifydata.putAll(rawdata);
  modifydata.remove(CollectionConstants.TASK_ID);
  modifydata.put(CollectionConstants.OBJECT_ID,CommonUtil.getUUID());
  List<Object> operationParameters=(List<Object>)rawdata.get(CollectionConstants.OPERATION_PARAMETERS);
  if (!operationParameters.isEmpty()) {
    MethodParameter methodParameter=new MethodParameter();
    int index=0;
    for (    Object parameter : operationParameters) {
      if (parameter != null) {
        methodParameter.setParameter(""String_Node_Str"" + index,parameter);
        index++;
      }
    }
    modifydata.put(CollectionConstants.OPERATION_PARAMETERS,methodParameter);
  }
 else {
    modifydata.put(CollectionConstants.OPERATION_PARAMETERS,""String_Node_Str"");
  }
  data.put(DataObjectType.OPERATION.getName(),modifydata);
  return data;
}","private Map<String,Map<String,Object>> packagingOperationData(Map<String,Map<String,Object>> data,Map<String,Object> rawdata){
  Map<String,Object> modifydata=new HashMap<>();
  modifydata.putAll(rawdata);
  modifydata.remove(CollectionConstants.TASK_ID);
  modifydata.put(CollectionConstants.OBJECT_ID,CommonUtil.getUUID());
  List<Object> operationParameters=(List<Object>)rawdata.get(CollectionConstants.OPERATION_PARAMETERS);
  if (!operationParameters.isEmpty()) {
    MethodParameter methodParameter=new MethodParameter();
    int index=0;
    for (    Object parameter : operationParameters) {
      if (parameter != null) {
        filterSensitiveData(parameter);
        methodParameter.setParameter(""String_Node_Str"" + index,parameter);
        index++;
      }
    }
    modifydata.put(CollectionConstants.OPERATION_PARAMETERS,methodParameter);
  }
 else {
    modifydata.put(CollectionConstants.OPERATION_PARAMETERS,""String_Node_Str"");
  }
  data.put(DataObjectType.OPERATION.getName(),modifydata);
  return data;
}"
48384,"@Test public void testCreateClusterWithDistroName() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[3];
  distros[0]=new DistroRead();
  distros[0].setName(Constants.DEFAULT_DISTRO + 0);
  distros[1]=new DistroRead();
  distros[1].setName(Constants.DEFAULT_DISTRO);
  distros[2]=new DistroRead();
  distros[2].setName(Constants.DEFAULT_DISTRO + 2);
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.createCluster(""String_Node_Str"",null,""String_Node_Str"",Constants.DEFAULT_DISTRO,null,null,null,null,null,null,null,false,false,true,false,""String_Node_Str"",null,null,null);
  CookieCache.clear();
}","@Test public void testCreateClusterWithDistroName() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[3];
  distros[0]=new DistroRead();
  distros[0].setName(Constants.DEFAULT_DISTRO + 0);
  distros[1]=new DistroRead();
  distros[1].setName(Constants.DEFAULT_DISTRO);
  distros[2]=new DistroRead();
  distros[2].setName(Constants.DEFAULT_DISTRO + 2);
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(getClusterResponseForCreate()));
  clusterCommands.createCluster(""String_Node_Str"",null,""String_Node_Str"",Constants.DEFAULT_DISTRO,null,null,null,null,null,null,null,false,false,true,false,""String_Node_Str"",null,null,null);
  CookieCache.clear();
}"
48385,"@Test public void testCreateClusterFailure() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[1];
  DistroRead distro=new DistroRead();
  distro.setName(Constants.DEFAULT_DISTRO);
  distros[0]=distro;
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros[0]));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  BddErrorMessage errorMsg=new BddErrorMessage();
  errorMsg.setMessage(""String_Node_Str"");
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.BAD_REQUEST,mapper.writeValueAsString(errorMsg));
  clusterCommands.createCluster(""String_Node_Str"",null,""String_Node_Str"",null,null,null,null,null,null,null,null,false,false,true,false,""String_Node_Str"",null,null,null);
  CookieCache.clear();
}","@Test public void testCreateClusterFailure() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[1];
  DistroRead distro=new DistroRead();
  distro.setName(Constants.DEFAULT_DISTRO);
  distros[0]=distro;
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros[0]));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  BddErrorMessage errorMsg=new BddErrorMessage();
  errorMsg.setMessage(""String_Node_Str"");
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.BAD_REQUEST,mapper.writeValueAsString(errorMsg));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(getClusterResponseForCreate()));
  clusterCommands.createCluster(""String_Node_Str"",null,""String_Node_Str"",null,null,null,null,null,null,null,null,false,false,true,false,""String_Node_Str"",null,null,null);
  CookieCache.clear();
}"
48386,"@Test public void testCreateClusterBySpecFile() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[1];
  DistroRead distro=new DistroRead();
  distro.setName(Constants.DEFAULT_DISTRO);
  List<String> roles=new ArrayList<String>();
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  distro.setRoles(roles);
  distros[0]=distro;
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ValidateResult vr=new ValidateResult();
  vr.setValidated(true);
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros[0]));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.OK,mapper.writeValueAsString(vr));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.createCluster(""String_Node_Str"",null,null,null,""String_Node_Str"",null,null,null,null,null,null,false,false,true,false,""String_Node_Str"",null,null,null);
  setup();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros[0]));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.OK,mapper.writeValueAsString(vr));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.createCluster(""String_Node_Str"",null,null,null,""String_Node_Str"",null,null,null,null,null,null,false,false,true,false,""String_Node_Str"",null,null,null);
  setup();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros[0]));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.OK,mapper.writeValueAsString(vr));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.createCluster(""String_Node_Str"",null,null,null,""String_Node_Str"",null,null,null,null,null,null,false,false,true,false,""String_Node_Str"",null,null,null);
  setup();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros[0]));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.OK,mapper.writeValueAsString(vr));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.createCluster(""String_Node_Str"",null,null,null,""String_Node_Str"",null,null,null,null,null,null,false,false,true,false,""String_Node_Str"",null,null,null);
  CookieCache.clear();
}","@Test public void testCreateClusterBySpecFile() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[1];
  DistroRead distro=new DistroRead();
  distro.setName(Constants.DEFAULT_DISTRO);
  List<String> roles=new ArrayList<String>();
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  distro.setRoles(roles);
  distros[0]=distro;
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ValidateResult vr=new ValidateResult();
  vr.setValidated(true);
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros[0]));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.OK,mapper.writeValueAsString(vr));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(getClusterResponseForCreate()));
  clusterCommands.createCluster(""String_Node_Str"",null,null,null,""String_Node_Str"",null,null,null,null,null,null,false,false,true,false,""String_Node_Str"",null,null,null);
  setup();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros[0]));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.OK,mapper.writeValueAsString(vr));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(getClusterResponseForCreate()));
  clusterCommands.createCluster(""String_Node_Str"",null,null,null,""String_Node_Str"",null,null,null,null,null,null,false,false,true,false,""String_Node_Str"",null,null,null);
  setup();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros[0]));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.OK,mapper.writeValueAsString(vr));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(getClusterResponseForCreate()));
  clusterCommands.createCluster(""String_Node_Str"",null,null,null,""String_Node_Str"",null,null,null,null,null,null,false,false,true,false,""String_Node_Str"",null,null,null);
  setup();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros[0]));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.OK,mapper.writeValueAsString(vr));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(getClusterResponseForCreate()));
  clusterCommands.createCluster(""String_Node_Str"",null,null,null,""String_Node_Str"",null,null,null,null,null,null,false,false,true,false,""String_Node_Str"",null,null,null);
  CookieCache.clear();
}"
48387,"@Test public void testClusterCreateOutput() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[1];
  DistroRead distro=new DistroRead();
  distro.setName(Constants.DEFAULT_DISTRO);
  distros[0]=distro;
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros[0]));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.ACCEPTED,""String_Node_Str"",""String_Node_Str"");
  TaskRead task=new TaskRead();
  task.setId(12l);
  task.setType(Type.INNER);
  task.setProgress(0.8);
  task.setProgressMessage(""String_Node_Str"");
  task.setStatus(Status.STARTED);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(task));
  ClusterRead cluster=new ClusterRead();
  List<NodeGroupRead> nodeGroups=new ArrayList<NodeGroupRead>();
  NodeGroupRead workerGroup=new NodeGroupRead();
  workerGroup.setName(""String_Node_Str"");
  workerGroup.setInstanceNum(1);
  List<NodeRead> instances=new ArrayList<NodeRead>();
  NodeRead instance1=new NodeRead();
  instance1.setName(""String_Node_Str"");
  instance1.setStatus(""String_Node_Str"");
  instance1.setAction(""String_Node_Str"");
  instances.add(instance1);
  workerGroup.setInstances(instances);
  nodeGroups.add(workerGroup);
  cluster.setNodeGroups(nodeGroups);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cluster));
  task.setProgress(1.0);
  task.setStatus(Status.COMPLETED);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(task));
  instance1.setStatus(""String_Node_Str"");
  instance1.setIpConfigs(createIpConfigs(""String_Node_Str""));
  instance1.setAction(null);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cluster));
  clusterCommands.createCluster(""String_Node_Str"",null,""String_Node_Str"",null,null,null,null,null,null,null,null,false,false,true,false,""String_Node_Str"",null,null,null);
  CookieCache.clear();
}","@Test public void testClusterCreateOutput() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[1];
  DistroRead distro=new DistroRead();
  distro.setName(Constants.DEFAULT_DISTRO);
  distros[0]=distro;
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros[0]));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.ACCEPTED,""String_Node_Str"");
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(getClusterResponseForCreate()),""String_Node_Str"");
  TaskRead task=new TaskRead();
  task.setId(12l);
  task.setType(Type.INNER);
  task.setProgress(0.8);
  task.setProgressMessage(""String_Node_Str"");
  task.setStatus(Status.STARTED);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(task));
  ClusterRead cluster=new ClusterRead();
  List<NodeGroupRead> nodeGroups=new ArrayList<NodeGroupRead>();
  NodeGroupRead workerGroup=new NodeGroupRead();
  workerGroup.setName(""String_Node_Str"");
  workerGroup.setInstanceNum(1);
  List<NodeRead> instances=new ArrayList<NodeRead>();
  NodeRead instance1=new NodeRead();
  instance1.setName(""String_Node_Str"");
  instance1.setStatus(""String_Node_Str"");
  instance1.setAction(""String_Node_Str"");
  instances.add(instance1);
  workerGroup.setInstances(instances);
  nodeGroups.add(workerGroup);
  cluster.setNodeGroups(nodeGroups);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cluster));
  task.setProgress(1.0);
  task.setStatus(Status.COMPLETED);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(task));
  instance1.setStatus(""String_Node_Str"");
  instance1.setIpConfigs(createIpConfigs(""String_Node_Str""));
  instance1.setAction(null);
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(cluster));
  clusterCommands.createCluster(""String_Node_Str"",null,""String_Node_Str"",null,null,null,null,null,null,null,null,false,false,true,false,""String_Node_Str"",null,null,null);
  CookieCache.clear();
}"
48388,"@Test public void testCreateCluster() throws Exception {
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[1];
  DistroRead distro=new DistroRead();
  distro.setName(Constants.DEFAULT_DISTRO);
  distros[0]=distro;
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  ObjectMapper mapper=new ObjectMapper();
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros[0]));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  clusterCommands.createCluster(""String_Node_Str"",null,""String_Node_Str"",null,null,null,null,null,null,null,null,false,false,true,false,""String_Node_Str"",null,null,null);
  CookieCache.clear();
}","@Test public void testCreateCluster() throws Exception {
  ObjectMapper mapper=new ObjectMapper();
  CookieCache.put(""String_Node_Str"",""String_Node_Str"");
  DistroRead[] distros=new DistroRead[1];
  DistroRead distro=new DistroRead();
  distro.setName(Constants.DEFAULT_DISTRO);
  distros[0]=distro;
  NetworkRead[] networks=new NetworkRead[1];
  NetworkRead network=new NetworkRead();
  network.setName(""String_Node_Str"");
  network.setDhcp(true);
  network.setPortGroup(""String_Node_Str"");
  networks[0]=network;
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(distros[0]));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(networks));
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.POST,HttpStatus.NO_CONTENT,""String_Node_Str"");
  buildReqRespWithoutReqBody(""String_Node_Str"",HttpMethod.GET,HttpStatus.OK,mapper.writeValueAsString(getClusterResponseForCreate()));
  clusterCommands.createCluster(""String_Node_Str"",null,""String_Node_Str"",null,null,null,null,null,null,null,null,false,false,true,false,""String_Node_Str"",null,null,null);
  CookieCache.clear();
}"
48389,"@BeforeMethod(groups={""String_Node_Str""}) public void setMockup(){
  Mockit.setUpMock(MockVcVmUtil.class);
  Mockit.setUpMock(MockVcResourceUtilsForHeal.class);
}","@BeforeMethod(groups={""String_Node_Str""}) public void setMockup(){
  Mockit.setUpMock(MockVcVmUtil.class);
  Mockit.setUpMock(MockVcResourceUtilsForHeal.class);
  Mockit.setUpMock(MockClusterHealService.class);
}"
48390,"@BeforeClass(groups={""String_Node_Str""}) public static void setUp() throws Exception {
  service=new ClusterHealService();
  IClusterEntityManager entityMgr=Mockito.mock(IClusterEntityManager.class);
  List<DiskEntity> disks=new ArrayList<DiskEntity>();
  for (int i=0; i < 3; i++) {
    DiskEntity disk=new DiskEntity(DATA_DISK_NAME_PREFIX + i);
    disk.setVmdkPath(LOCAL_DS_MOID_PREFIX + i + ""String_Node_Str""+ disk.getName());
    disk.setDatastoreName(LOCAL_DS_NAME_PREFIX + i);
    disk.setDatastoreMoId(LOCAL_DS_MOID_PREFIX + i);
    disk.setSizeInMB(20 * 1024);
    disk.setDiskType(DiskType.SYSTEM_DISK.type);
    DiskEntity spy=Mockito.spy(disk);
    Mockito.when(spy.getId()).thenReturn(new Long(1));
    disks.add(spy);
  }
  Mockito.when(entityMgr.getDisks(""String_Node_Str"")).thenReturn(disks);
  NodeEntity node=new NodeEntity();
  node.setVmName(NODE_1_NAME);
  node.setHostName(HOST_NAME);
  Mockito.when(entityMgr.findByName(CLUSTER_NAME,NODE_GROUP_NAME,NODE_1_NAME)).thenReturn(node);
  service.setClusterEntityMgr(entityMgr);
  ClusterConfigManager configMgr=Mockito.mock(ClusterConfigManager.class);
  NodeGroupCreate nodeGroup=new NodeGroupCreate();
  nodeGroup.setName(NODE_GROUP_NAME);
  nodeGroup.setStorage(new StorageRead());
  NodeGroupCreate[] nodeGroups=new NodeGroupCreate[]{nodeGroup};
  ClusterCreate spec=new ClusterCreate();
  spec.setName(CLUSTER_NAME);
  spec.setNodeGroups(nodeGroups);
  Set<String> patterns=new HashSet<String>();
  patterns.add(LOCAL_STORE_PATTERN);
  spec.setLocalDatastorePattern(patterns);
  Mockito.when(configMgr.getClusterConfig(CLUSTER_NAME)).thenReturn(spec);
  service.setConfigMgr(configMgr);
}","@BeforeClass(groups={""String_Node_Str""}) public static void setUp() throws Exception {
  service=new ClusterHealService();
  IClusterEntityManager entityMgr=Mockito.mock(IClusterEntityManager.class);
  NodeEntity node=new NodeEntity();
  node.setVmName(NODE_1_NAME);
  node.setHostName(HOST_NAME);
  node.setStatus(NodeStatus.VM_READY);
  Mockito.when(entityMgr.findByName(CLUSTER_NAME,NODE_GROUP_NAME,NODE_1_NAME)).thenReturn(node);
  service.setClusterEntityMgr(entityMgr);
  List<DiskEntity> disks=new ArrayList<DiskEntity>();
  for (int i=0; i < 3; i++) {
    DiskEntity disk=new DiskEntity(DATA_DISK_NAME_PREFIX + i);
    disk.setVmdkPath(LOCAL_DS_MOID_PREFIX + i + ""String_Node_Str""+ disk.getName());
    disk.setDatastoreName(LOCAL_DS_NAME_PREFIX + i);
    disk.setDatastoreMoId(LOCAL_DS_MOID_PREFIX + i);
    disk.setSizeInMB(20 * 1024);
    disk.setDiskType(DiskType.SYSTEM_DISK.type);
    disk.setNodeEntity(node);
    DiskEntity spy=Mockito.spy(disk);
    Mockito.when(spy.getId()).thenReturn(new Long(1));
    disks.add(spy);
  }
  Mockito.when(entityMgr.getDisks(NODE_1_NAME)).thenReturn(disks);
  ClusterConfigManager configMgr=Mockito.mock(ClusterConfigManager.class);
  NodeGroupCreate nodeGroup=new NodeGroupCreate();
  nodeGroup.setName(NODE_GROUP_NAME);
  nodeGroup.setStorage(new StorageRead());
  NodeGroupCreate[] nodeGroups=new NodeGroupCreate[]{nodeGroup};
  ClusterCreate spec=new ClusterCreate();
  spec.setName(CLUSTER_NAME);
  spec.setNodeGroups(nodeGroups);
  Set<String> patterns=new HashSet<String>();
  patterns.add(LOCAL_STORE_PATTERN);
  spec.setLocalDatastorePattern(patterns);
  Mockito.when(configMgr.getClusterConfig(CLUSTER_NAME)).thenReturn(spec);
  service.setConfigMgr(configMgr);
}"
48391,"@Test(groups={""String_Node_Str""}) public void testGetBadDisks(){
  logger.info(""String_Node_Str"");
  List<DiskSpec> badDisks=service.getBadDisks(NODE_1_NAME);
  Assert.assertTrue(badDisks.size() == 1,""String_Node_Str"");
}","@Test(groups={""String_Node_Str""}) public void testGetBadDisks(){
  logger.info(""String_Node_Str"");
  List<DiskSpec> badDisks=service.getBadDisks(NODE_1_NAME);
  Assert.assertEquals(badDisks.size(),1,""String_Node_Str"");
}"
48392,"@BeforeMethod public void setUp(){
  Mockit.setUpMock(MockVcContext.class);
  Mockit.setUpMock(MockVcCache.class);
  ClusterEntity cluster=clusterEntityMgr.findByName(TEST_CLUSTER_NAME);
  if (cluster != null) {
    clusterEntityMgr.delete(cluster);
  }
  cluster=TestClusterEntityManager.assembleClusterEntity(TEST_CLUSTER_NAME);
  int i=0;
  for (  NodeGroupEntity group : cluster.getNodeGroups()) {
    for (    NodeEntity node : group.getNodes()) {
      node.setMoId(VM_MOB_PREFIX + i++);
    }
  }
  nodeNum=i;
  clusterEntityMgr.insert(cluster);
}","@BeforeMethod public void setUp(){
  Mockit.setUpMock(MockVcContext.class);
  Mockit.setUpMock(MockVcCache.class);
  new MockUp<VcVmUtil>(){
    @Mock public String getMgtHostName(    VcVirtualMachine vcVm,    String primaryMgtIpV4){
      return vcVm.getName();
    }
  }
;
  ClusterEntity cluster=clusterEntityMgr.findByName(TEST_CLUSTER_NAME);
  if (cluster != null) {
    clusterEntityMgr.delete(cluster);
  }
  cluster=TestClusterEntityManager.assembleClusterEntity(TEST_CLUSTER_NAME);
  int i=0;
  for (  NodeGroupEntity group : cluster.getNodeGroups()) {
    for (    NodeEntity node : group.getNodes()) {
      node.setMoId(VM_MOB_PREFIX + i++);
    }
  }
  nodeNum=i;
  clusterEntityMgr.insert(cluster);
}"
48393,"public void run(){
  try {
    this.sleep(2000);
  }
 catch (  InterruptedException e) {
    logger.error(""String_Node_Str"");
    return;
  }
  for (int j=0; j < nodeNum; j++) {
    VcVirtualMachine vm=MockVcCache.getIgnoreMissing(VM_MOB_PREFIX + j);
    Map<String,String> map=new HashMap<String,String>();
switch (settings) {
case 0:
      if (flag) {
        map.put(Constants.VM_DISK_FORMAT_STATUS_KEY,""String_Node_Str"");
      }
    break;
case 1:
  if (flag) {
    map.put(Constants.VM_DISK_FORMAT_STATUS_KEY,""String_Node_Str"");
  }
 else {
    map.put(Constants.VM_DISK_FORMAT_STATUS_KEY,""String_Node_Str"");
  }
break;
default :
break;
}
Mockito.when(vm.getGuestVariables()).thenReturn(map);
}
}","public void run(){
  try {
    this.sleep(2000);
  }
 catch (  InterruptedException e) {
    logger.error(""String_Node_Str"");
    return;
  }
  for (int j=0; j < nodeNum; j++) {
    VcVirtualMachine vm=MockVcCache.getIgnoreMissing(VM_MOB_PREFIX + j);
    Map<String,String> map=new HashMap<String,String>();
switch (settings) {
case 0:
      if (flag) {
        map.put(Constants.VM_DISK_FORMAT_STATUS_KEY,""String_Node_Str"");
        map.put(Constants.VM_FQDN_REGISTER_STATUS_KEY,""String_Node_Str"");
      }
    break;
case 1:
  if (flag) {
    map.put(Constants.VM_DISK_FORMAT_STATUS_KEY,""String_Node_Str"");
    map.put(Constants.VM_FQDN_REGISTER_STATUS_KEY,""String_Node_Str"");
    map.put(""String_Node_Str"",""String_Node_Str"");
  }
 else {
    map.put(Constants.VM_DISK_FORMAT_STATUS_KEY,""String_Node_Str"");
    map.put(Constants.VM_FQDN_REGISTER_STATUS_KEY,""String_Node_Str"");
  }
break;
default :
break;
}
Mockito.when(vm.getGuestVariables()).thenReturn(map);
}
}"
48394,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String appManager,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String hdfsNetworkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String mapredNetworkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String topology,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean alwaysAnswerYes,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean setClusterPassword,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String localRepoURL,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String adminGroupName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String userGroupName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final Boolean disableLocalUsersFlag){
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
 else   if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_BLANK_SPACE);
    return;
  }
  if (resume && setClusterPassword) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.RESUME_DONOT_NEED_SET_PASSWORD);
    return;
  }
 else   if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (!CommandsUtils.isBlank(appManager) && !Constants.IRONFAN.equalsIgnoreCase(appManager)) {
    AppManagerRead appManagerRead=appManagerRestClient.get(appManager);
    if (appManagerRead == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,appManager + ""String_Node_Str"");
      return;
    }
  }
  if (CommandsUtils.isBlank(appManager)) {
    clusterCreate.setAppManager(Constants.IRONFAN);
  }
 else {
    clusterCreate.setAppManager(appManager);
    if (!CommandsUtils.isBlank(localRepoURL)) {
      clusterCreate.setLocalRepoURL(localRepoURL);
    }
  }
  if (setClusterPassword) {
    String password=getPassword();
    if (password == null) {
      return;
    }
 else {
      clusterCreate.setPassword(password);
    }
  }
  if (type != null) {
    ClusterType clusterType=ClusterType.getByDescription(type);
    if (clusterType == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ type);
      return;
    }
    clusterCreate.setType(clusterType);
  }
 else   if (specFilePath == null) {
    clusterCreate.setType(ClusterType.HDFS_MAPRED);
  }
  TopologyType policy=null;
  if (topology != null) {
    policy=validateTopologyValue(name,topology);
    if (policy == null) {
      return;
    }
  }
 else {
    policy=TopologyType.NONE;
  }
  clusterCreate.setTopologyPolicy(policy);
  DistroRead distroRead4Create;
  try {
    if (distro != null) {
      DistroRead[] distroReads=appManagerRestClient.getDistros(clusterCreate.getAppManager());
      distroRead4Create=getDistroByName(distroReads,distro);
      if (distroRead4Create == null) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + getDistroNames(distroReads));
        return;
      }
    }
 else {
      distroRead4Create=appManagerRestClient.getDefaultDistro(clusterCreate.getAppManager());
      if (distroRead4Create == null || CommandsUtils.isBlank(distroRead4Create.getName())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NO_DEFAULT_DISTRO);
        return;
      }
    }
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  Map<String,Map<String,String>> infraConfigs=new HashMap<String,Map<String,String>>();
  if (StringUtils.isBlank(adminGroupName) && StringUtils.isBlank(userGroupName)) {
  }
 else   if (!StringUtils.isBlank(adminGroupName) && !StringUtils.isBlank(userGroupName)) {
    if (MapUtils.isEmpty(infraConfigs.get(UserMgmtConstants.LDAP_USER_MANAGEMENT))) {
      initInfraConfigs(infraConfigs,disableLocalUsersFlag);
    }
    Map<String,String> userMgmtConfig=infraConfigs.get(UserMgmtConstants.LDAP_USER_MANAGEMENT);
    userMgmtConfig.put(UserMgmtConstants.ADMIN_GROUP_NAME,adminGroupName);
    userMgmtConfig.put(UserMgmtConstants.USER_GROUP_NAME,userGroupName);
    clusterCreate.setInfrastructure_config(infraConfigs);
  }
 else {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
    return;
  }
  clusterCreate.setDistro(distroRead4Create.getName());
  clusterCreate.setDistroVendor(distroRead4Create.getVendor());
  clusterCreate.setDistroVersion(distroRead4Create.getVersion());
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  Set<String> allNetworkNames=new HashSet<String>();
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setSpecFile(true);
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setExternalMapReduce(clusterSpec.getExternalMapReduce());
      clusterCreate.setExternalNamenode(clusterSpec.getExternalNamenode());
      clusterCreate.setExternalSecondaryNamenode(clusterSpec.getExternalSecondaryNamenode());
      clusterCreate.setExternalDatanodes(clusterSpec.getExternalDatanodes());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      if (CommandsUtils.isBlank(appManager) || Constants.IRONFAN.equalsIgnoreCase(appManager)) {
        validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList,failedMsgList);
      }
      clusterCreate.validateNodeGroupNames();
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
      Map<String,Map<String,String>> specInfraConfigs=clusterSpec.getInfrastructure_config();
      if (!MapUtils.isEmpty(specInfraConfigs)) {
        if (MapUtils.isNotEmpty(infraConfigs)) {
          System.out.println(""String_Node_Str"");
        }
 else {
          clusterCreate.setInfrastructure_config(specInfraConfigs);
        }
      }
      Map<String,Object> configuration=clusterSpec.getConfiguration();
      if (MapUtils.isNotEmpty(configuration)) {
        Map<String,Map<String,String>> serviceUserConfig=(Map<String,Map<String,String>>)configuration.get(UserMgmtConstants.SERVICE_USER_CONFIG_IN_SPEC_FILE);
        if (MapUtils.isNotEmpty(serviceUserConfig)) {
          if (hasLdapServiceUser(serviceUserConfig) && (clusterCreate.getInfrastructure_config() == null)) {
            Map<String,Map<String,String>> infraConfig=new HashMap<>();
            initInfraConfigs(infraConfig,disableLocalUsersFlag);
            clusterCreate.setInfrastructure_config(infraConfig);
          }
          validateServiceUserConfigs(appManager,clusterSpec,failedMsgList);
        }
      }
    }
    allNetworkNames=getAllNetworkNames();
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  if (allNetworkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CANNOT_FIND_NETWORK);
    return;
  }
  Map<NetTrafficType,List<String>> networkConfig=new HashMap<NetTrafficType,List<String>>();
  if (networkName == null) {
    if (allNetworkNames.size() == 1) {
      networkConfig.put(NetTrafficType.MGT_NETWORK,new ArrayList<String>());
      networkConfig.get(NetTrafficType.MGT_NETWORK).addAll(allNetworkNames);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
      return;
    }
  }
 else {
    if (!allNetworkNames.contains(networkName) || (hdfsNetworkName != null && !allNetworkNames.contains(hdfsNetworkName)) || (mapredNetworkName != null && !allNetworkNames.contains(mapredNetworkName))) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + allNetworkNames.toString());
      return;
    }
    networkConfig.put(NetTrafficType.MGT_NETWORK,new ArrayList<String>());
    networkConfig.get(NetTrafficType.MGT_NETWORK).add(networkName);
    if (hdfsNetworkName != null) {
      networkConfig.put(NetTrafficType.HDFS_NETWORK,new ArrayList<String>());
      networkConfig.get(NetTrafficType.HDFS_NETWORK).add(hdfsNetworkName);
    }
    if (mapredNetworkName != null) {
      networkConfig.put(NetTrafficType.MAPRED_NETWORK,new ArrayList<String>());
      networkConfig.get(NetTrafficType.MAPRED_NETWORK).add(mapredNetworkName);
    }
  }
  notifyNetsUsage(networkConfig,warningMsgList);
  clusterCreate.setNetworkConfig(networkConfig);
  clusterCreate.validateCDHVersion(warningMsgList);
  if (specFilePath != null) {
    validateClusterSpec(clusterCreate,failedMsgList,warningMsgList);
  }
  if (type != null && specFilePath != null) {
    warningMsgList.add(Constants.TYPE_SPECFILE_CONFLICT);
  }
  if (!failedMsgList.isEmpty()) {
    showFailedMsg(clusterCreate.getName(),Constants.OUTPUT_OP_CREATE,failedMsgList);
    return;
  }
  try {
    if (!CommandsUtils.showWarningMsg(clusterCreate.getName(),Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,warningMsgList,alwaysAnswerYes,null)) {
      return;
    }
    restClient.create(clusterCreate);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,CommandsUtils.getExceptionMessage(e));
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String appManager,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String hdfsNetworkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String mapredNetworkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String topology,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean alwaysAnswerYes,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean setClusterPassword,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String localRepoURL,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String adminGroupName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String userGroupName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final Boolean disableLocalUsersFlag){
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
 else   if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_BLANK_SPACE);
    return;
  }
  if (resume && setClusterPassword) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.RESUME_DONOT_NEED_SET_PASSWORD);
    return;
  }
 else   if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (!CommandsUtils.isBlank(appManager) && !Constants.IRONFAN.equalsIgnoreCase(appManager)) {
    AppManagerRead appManagerRead=appManagerRestClient.get(appManager);
    if (appManagerRead == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,appManager + ""String_Node_Str"");
      return;
    }
  }
  if (CommandsUtils.isBlank(appManager)) {
    clusterCreate.setAppManager(Constants.IRONFAN);
  }
 else {
    clusterCreate.setAppManager(appManager);
    if (!CommandsUtils.isBlank(localRepoURL)) {
      clusterCreate.setLocalRepoURL(localRepoURL);
    }
  }
  if (setClusterPassword) {
    String password=getPassword();
    if (password == null) {
      return;
    }
 else {
      clusterCreate.setPassword(password);
    }
  }
  if (type != null) {
    ClusterType clusterType=ClusterType.getByDescription(type);
    if (clusterType == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ type);
      return;
    }
    clusterCreate.setType(clusterType);
  }
 else   if (specFilePath == null) {
    clusterCreate.setType(ClusterType.HDFS_MAPRED);
  }
  TopologyType policy=null;
  if (topology != null) {
    policy=validateTopologyValue(name,topology);
    if (policy == null) {
      return;
    }
  }
 else {
    policy=TopologyType.NONE;
  }
  clusterCreate.setTopologyPolicy(policy);
  DistroRead distroRead4Create;
  try {
    if (distro != null) {
      DistroRead[] distroReads=appManagerRestClient.getDistros(clusterCreate.getAppManager());
      distroRead4Create=getDistroByName(distroReads,distro);
      if (distroRead4Create == null) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + getDistroNames(distroReads));
        return;
      }
    }
 else {
      distroRead4Create=appManagerRestClient.getDefaultDistro(clusterCreate.getAppManager());
      if (distroRead4Create == null || CommandsUtils.isBlank(distroRead4Create.getName())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NO_DEFAULT_DISTRO);
        return;
      }
    }
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  Map<String,Map<String,String>> infraConfigs=new HashMap<String,Map<String,String>>();
  if (StringUtils.isBlank(adminGroupName) && StringUtils.isBlank(userGroupName)) {
  }
 else   if (!StringUtils.isBlank(adminGroupName) && !StringUtils.isBlank(userGroupName)) {
    if (MapUtils.isEmpty(infraConfigs.get(UserMgmtConstants.LDAP_USER_MANAGEMENT))) {
      initInfraConfigs(infraConfigs,disableLocalUsersFlag);
    }
    Map<String,String> userMgmtConfig=infraConfigs.get(UserMgmtConstants.LDAP_USER_MANAGEMENT);
    userMgmtConfig.put(UserMgmtConstants.ADMIN_GROUP_NAME,adminGroupName);
    userMgmtConfig.put(UserMgmtConstants.USER_GROUP_NAME,userGroupName);
    clusterCreate.setInfrastructure_config(infraConfigs);
  }
 else {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
    return;
  }
  clusterCreate.setDistro(distroRead4Create.getName());
  clusterCreate.setDistroVendor(distroRead4Create.getVendor());
  clusterCreate.setDistroVersion(distroRead4Create.getVersion());
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  Set<String> allNetworkNames=new HashSet<String>();
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setSpecFile(true);
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setExternalMapReduce(clusterSpec.getExternalMapReduce());
      clusterCreate.setExternalNamenode(clusterSpec.getExternalNamenode());
      clusterCreate.setExternalSecondaryNamenode(clusterSpec.getExternalSecondaryNamenode());
      clusterCreate.setExternalDatanodes(clusterSpec.getExternalDatanodes());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      if (CommandsUtils.isBlank(appManager) || Constants.IRONFAN.equalsIgnoreCase(appManager)) {
        validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList,failedMsgList);
      }
      clusterCreate.validateNodeGroupNames();
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
      Map<String,Map<String,String>> specInfraConfigs=clusterSpec.getInfrastructure_config();
      if (!MapUtils.isEmpty(specInfraConfigs)) {
        if (MapUtils.isNotEmpty(infraConfigs)) {
          System.out.println(""String_Node_Str"");
        }
 else {
          clusterCreate.setInfrastructure_config(specInfraConfigs);
        }
      }
      Map<String,Object> configuration=clusterSpec.getConfiguration();
      if (MapUtils.isNotEmpty(configuration)) {
        Map<String,Map<String,String>> serviceUserConfig=(Map<String,Map<String,String>>)configuration.get(UserMgmtConstants.SERVICE_USER_CONFIG_IN_SPEC_FILE);
        if (MapUtils.isNotEmpty(serviceUserConfig)) {
          if (hasLdapServiceUser(serviceUserConfig) && (clusterCreate.getInfrastructure_config() == null)) {
            Map<String,Map<String,String>> infraConfig=new HashMap<>();
            initInfraConfigs(infraConfig,disableLocalUsersFlag);
            clusterCreate.setInfrastructure_config(infraConfig);
          }
          validateServiceUserConfigs(appManager,clusterSpec,failedMsgList);
        }
      }
    }
    allNetworkNames=getAllNetworkNames();
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  if (allNetworkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CANNOT_FIND_NETWORK);
    return;
  }
  Map<NetTrafficType,List<String>> networkConfig=new HashMap<NetTrafficType,List<String>>();
  if (networkName == null) {
    if (allNetworkNames.size() == 1) {
      networkConfig.put(NetTrafficType.MGT_NETWORK,new ArrayList<String>());
      networkConfig.get(NetTrafficType.MGT_NETWORK).addAll(allNetworkNames);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
      return;
    }
  }
 else {
    if (!allNetworkNames.contains(networkName) || (hdfsNetworkName != null && !allNetworkNames.contains(hdfsNetworkName)) || (mapredNetworkName != null && !allNetworkNames.contains(mapredNetworkName))) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + allNetworkNames.toString());
      return;
    }
    networkConfig.put(NetTrafficType.MGT_NETWORK,new ArrayList<String>());
    networkConfig.get(NetTrafficType.MGT_NETWORK).add(networkName);
    if (hdfsNetworkName != null) {
      networkConfig.put(NetTrafficType.HDFS_NETWORK,new ArrayList<String>());
      networkConfig.get(NetTrafficType.HDFS_NETWORK).add(hdfsNetworkName);
    }
    if (mapredNetworkName != null) {
      networkConfig.put(NetTrafficType.MAPRED_NETWORK,new ArrayList<String>());
      networkConfig.get(NetTrafficType.MAPRED_NETWORK).add(mapredNetworkName);
    }
  }
  notifyNetsUsage(networkConfig,warningMsgList);
  clusterCreate.setNetworkConfig(networkConfig);
  clusterCreate.validateCDHVersion(warningMsgList);
  if (specFilePath != null) {
    validateClusterSpec(clusterCreate,failedMsgList,warningMsgList);
  }
  if (type != null && specFilePath != null) {
    warningMsgList.add(Constants.TYPE_SPECFILE_CONFLICT);
  }
  if (!failedMsgList.isEmpty()) {
    showFailedMsg(clusterCreate.getName(),Constants.OUTPUT_OP_CREATE,failedMsgList);
    return;
  }
  try {
    if (!CommandsUtils.showWarningMsg(clusterCreate.getName(),Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,warningMsgList,alwaysAnswerYes,null)) {
      return;
    }
    restClient.create(clusterCreate);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,CommandsUtils.getExceptionMessage(e));
  }
  ClusterRead cluster=restClient.get(name,false);
  if (cluster != null) {
    String cloneType=cluster.getClusterCloneType();
    String INSTANT_CLONE=com.vmware.bdd.utils.Constants.CLUSTER_CLONE_TYPE_INSTANT_CLONE;
    if (null != cloneType && cloneType.equals(INSTANT_CLONE)) {
      String warningMsg=validateInstantCloneWithHA(specFilePath,clusterCreate);
      if (!CommonUtil.isBlank(warningMsg)) {
        System.out.println(warningMsg);
      }
    }
  }
}"
48395,"@Override public boolean createCluster(ClusterBlueprint blueprint,ClusterReportQueue reportQueue) throws SoftwareManagementPluginException {
  boolean success=false;
  CmClusterDef clusterDef=null;
  try {
    ReflectionUtils.getPreStartServicesHook().preStartServices(blueprint.getName());
    clusterDef=new CmClusterDef(blueprint);
    validateBlueprint(blueprint);
    provisionCluster(clusterDef,null,reportQueue);
    provisionParcels(clusterDef,null,reportQueue);
    configureServices(clusterDef,reportQueue,true);
    startServices(clusterDef,reportQueue,true);
    success=true;
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setProgress(100);
    clusterDef.getCurrentReport().setSuccess(true);
  }
 catch (  SoftwareManagementPluginException ex) {
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setSuccess(false);
    throw ex;
  }
catch (  Exception e) {
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setSuccess(false);
    logger.error(e.getMessage());
    throw SoftwareManagementPluginException.CREATE_CLUSTER_EXCEPTION(e,Constants.CDH_PLUGIN_NAME,clusterDef.getName());
  }
 finally {
    clusterDef.getCurrentReport().setFinished(true);
    if (success) {
      clusterDef.getCurrentReport().setClusterAndNodesServiceStatus(ServiceStatus.STARTED);
    }
    reportQueue.addClusterReport(clusterDef.getCurrentReport().clone());
  }
  return success;
}","@Override public boolean createCluster(ClusterBlueprint blueprint,ClusterReportQueue reportQueue) throws SoftwareManagementPluginException {
  boolean success=false;
  CmClusterDef clusterDef=null;
  try {
    clusterDef=new CmClusterDef(blueprint);
    ReflectionUtils.getPreStartServicesHook().preStartServices(blueprint.getName());
    validateBlueprint(blueprint);
    provisionCluster(clusterDef,null,reportQueue);
    provisionParcels(clusterDef,null,reportQueue);
    configureServices(clusterDef,reportQueue,true);
    startServices(clusterDef,reportQueue,true);
    success=true;
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setProgress(100);
    clusterDef.getCurrentReport().setSuccess(true);
  }
 catch (  SoftwareManagementPluginException ex) {
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setSuccess(false);
    throw ex;
  }
catch (  Exception e) {
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setSuccess(false);
    logger.error(e.getMessage());
    throw SoftwareManagementPluginException.CREATE_CLUSTER_EXCEPTION(e,Constants.CDH_PLUGIN_NAME,clusterDef.getName());
  }
 finally {
    clusterDef.getCurrentReport().setFinished(true);
    if (success) {
      clusterDef.getCurrentReport().setClusterAndNodesServiceStatus(ServiceStatus.STARTED);
    }
    reportQueue.addClusterReport(clusterDef.getCurrentReport().clone());
  }
  return success;
}"
48396,"@Override public boolean scaleOutCluster(ClusterBlueprint blueprint,List<String> addedNodeNames,ClusterReportQueue reportQueue) throws SoftwareManagementPluginException {
  boolean success=false;
  CmClusterDef clusterDef=null;
  try {
    ReflectionUtils.getPreStartServicesHook().preStartServices(blueprint.getName());
    clusterDef=new CmClusterDef(blueprint);
    provisionCluster(clusterDef,addedNodeNames,reportQueue,true);
    provisionParcels(clusterDef,addedNodeNames,reportQueue);
    Map<String,List<ApiRole>> roles=configureNodeServices(clusterDef,reportQueue,addedNodeNames);
    startNodeServices(clusterDef,addedNodeNames,roles,reportQueue);
    success=true;
    clusterDef.getCurrentReport().setProgress(100);
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setClusterAndNodesServiceStatus(ServiceStatus.STARTED);
  }
 catch (  SoftwareManagementPluginException ex) {
    if (ex instanceof CommandExecFailException) {
      String hostId=((CommandExecFailException)ex).getRefHostId();
      CmNodeDef nodeDef=clusterDef.idToHosts().get(hostId);
      String errMsg=null;
      if (nodeDef != null) {
        errMsg=""String_Node_Str"" + nodeDef.getName() + ""String_Node_Str""+ ((ex.getMessage() == null) ? ""String_Node_Str"" : (""String_Node_Str"" + ex.getMessage()));
        clusterDef.getCurrentReport().setNodesAction(""String_Node_Str"",addedNodeNames);
        clusterDef.getCurrentReport().setNodesStatus(ServiceStatus.STOPPED,addedNodeNames);
        clusterDef.getCurrentReport().getNodeReports().get(nodeDef.getName()).setErrMsg(errMsg);
        throw SoftwareManagementPluginException.START_SERVICE_FAILED(ex,Constants.CDH_PLUGIN_NAME,clusterDef.getName());
      }
    }
    clusterDef.getCurrentReport().setNodesError(ex.getMessage(),addedNodeNames);
    clusterDef.getCurrentReport().setNodesStatus(ServiceStatus.FAILED,addedNodeNames);
    throw ex;
  }
catch (  Exception e) {
    clusterDef.getCurrentReport().setNodesError(""String_Node_Str"" + e.getMessage(),addedNodeNames);
    clusterDef.getCurrentReport().setNodesStatus(ServiceStatus.FAILED,addedNodeNames);
    logger.error(e.getMessage());
    throw SoftwareManagementPluginException.SCALE_OUT_CLUSTER_FAILED(e,Constants.CDH_PLUGIN_NAME,clusterDef.getName());
  }
 finally {
    clusterDef.getCurrentReport().setSuccess(success);
    clusterDef.getCurrentReport().setFinished(true);
    reportQueue.addClusterReport(clusterDef.getCurrentReport().clone());
  }
  return success;
}","@Override public boolean scaleOutCluster(ClusterBlueprint blueprint,List<String> addedNodeNames,ClusterReportQueue reportQueue) throws SoftwareManagementPluginException {
  boolean success=false;
  CmClusterDef clusterDef=null;
  try {
    clusterDef=new CmClusterDef(blueprint);
    ReflectionUtils.getPreStartServicesHook().preStartServices(blueprint.getName());
    provisionCluster(clusterDef,addedNodeNames,reportQueue,true);
    provisionParcels(clusterDef,addedNodeNames,reportQueue);
    Map<String,List<ApiRole>> roles=configureNodeServices(clusterDef,reportQueue,addedNodeNames);
    startNodeServices(clusterDef,addedNodeNames,roles,reportQueue);
    success=true;
    clusterDef.getCurrentReport().setProgress(100);
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setClusterAndNodesServiceStatus(ServiceStatus.STARTED);
  }
 catch (  SoftwareManagementPluginException ex) {
    if (ex instanceof CommandExecFailException) {
      String hostId=((CommandExecFailException)ex).getRefHostId();
      CmNodeDef nodeDef=clusterDef.idToHosts().get(hostId);
      String errMsg=null;
      if (nodeDef != null) {
        errMsg=""String_Node_Str"" + nodeDef.getName() + ""String_Node_Str""+ ((ex.getMessage() == null) ? ""String_Node_Str"" : (""String_Node_Str"" + ex.getMessage()));
        clusterDef.getCurrentReport().setNodesAction(""String_Node_Str"",addedNodeNames);
        clusterDef.getCurrentReport().setNodesStatus(ServiceStatus.STOPPED,addedNodeNames);
        clusterDef.getCurrentReport().getNodeReports().get(nodeDef.getName()).setErrMsg(errMsg);
        throw SoftwareManagementPluginException.START_SERVICE_FAILED(ex,Constants.CDH_PLUGIN_NAME,clusterDef.getName());
      }
    }
    clusterDef.getCurrentReport().setNodesError(ex.getMessage(),addedNodeNames);
    clusterDef.getCurrentReport().setNodesStatus(ServiceStatus.FAILED,addedNodeNames);
    throw ex;
  }
catch (  Exception e) {
    clusterDef.getCurrentReport().setNodesError(""String_Node_Str"" + e.getMessage(),addedNodeNames);
    clusterDef.getCurrentReport().setNodesStatus(ServiceStatus.FAILED,addedNodeNames);
    logger.error(e.getMessage());
    throw SoftwareManagementPluginException.SCALE_OUT_CLUSTER_FAILED(e,Constants.CDH_PLUGIN_NAME,clusterDef.getName());
  }
 finally {
    clusterDef.getCurrentReport().setSuccess(success);
    clusterDef.getCurrentReport().setFinished(true);
    reportQueue.addClusterReport(clusterDef.getCurrentReport().clone());
  }
  return success;
}"
48397,"private void updateConfigGroup(ApiConfigGroupInfo apiConfigGroupInfo,String clusterName,ApiHostGroup apiHostGroupFromClusterSpec){
  try {
    boolean needUpdate=false;
    ApiConfigGroup newApiConfigGroup=new ApiConfigGroup();
    ApiConfigGroupInfo newApiConfigGroupInfo=new ApiConfigGroupInfo();
    newApiConfigGroupInfo.setId(apiConfigGroupInfo.getId());
    newApiConfigGroupInfo.setClusterName(apiConfigGroupInfo.getClusterName());
    newApiConfigGroupInfo.setGroupName(apiConfigGroupInfo.getGroupName());
    newApiConfigGroupInfo.setTag(apiConfigGroupInfo.getTag());
    newApiConfigGroupInfo.setDescription(apiConfigGroupInfo.getDescription());
    List<ApiHostInfo> hosts=new ArrayList<ApiHostInfo>();
    for (    ApiHostInfo apiHostInfo : apiConfigGroupInfo.getHosts()) {
      ApiHostInfo newApiHostInfo=new ApiHostInfo();
      newApiHostInfo.setHostName(apiHostInfo.getHostName());
      hosts.add(newApiHostInfo);
    }
    newApiConfigGroupInfo.setHosts(hosts);
    List<ApiConfigGroupConfiguration> desiredConfigs=new ArrayList<ApiConfigGroupConfiguration>();
    logger.info(""String_Node_Str"" + ApiUtils.objectToJson(apiConfigGroupInfo.getDesiredConfigs()));
    logger.info(""String_Node_Str"" + ApiUtils.objectToJson(apiHostGroupFromClusterSpec));
    String tag=""String_Node_Str"" + Calendar.getInstance().getTimeInMillis();
    for (    ApiConfigGroupConfiguration apiConfigGroupConfiguration : apiConfigGroupInfo.getDesiredConfigs()) {
      ApiConfigGroupConfiguration desiredConfig=new ApiConfigGroupConfiguration();
      desiredConfig.setType(apiConfigGroupConfiguration.getType());
      desiredConfig.setTag(tag);
      Map<String,String> properties=new HashMap<String,String>();
      ApiClusterConfigurations apiClusterConfigurations=apiManager.getClusterConfigurationsWithTypeAndTag(clusterName,apiConfigGroupConfiguration.getType(),apiConfigGroupConfiguration.getTag());
      logger.info(""String_Node_Str"" + ApiUtils.objectToJson(apiClusterConfigurations));
      for (      ApiClusterConfigurationInfo apiClusterConfigurationInfo : apiClusterConfigurations.getConfigurations()) {
        Map<String,String> propertiesFromClusterSpec=new HashMap<String,String>();
        for (        Map<String,Object> configurationFromClusterSpec : apiHostGroupFromClusterSpec.getConfigurations()) {
          propertiesFromClusterSpec=(Map<String,String>)configurationFromClusterSpec.get(apiClusterConfigurationInfo.getType());
          if (propertiesFromClusterSpec != null) {
            break;
          }
        }
        logger.info(""String_Node_Str"" + ApiUtils.objectToJson(propertiesFromClusterSpec));
        if (propertiesFromClusterSpec.isEmpty()) {
          continue;
        }
        Map<String,String> propertiesFromAmbariServer=apiClusterConfigurationInfo.getProperties();
        for (        String propertyKey : propertiesFromAmbariServer.keySet()) {
          String valueOfPropertyFromClusterSpec=propertiesFromClusterSpec.get(propertyKey);
          String valueOfPropertyFromAmbariServer=propertiesFromAmbariServer.get(propertyKey);
          logger.info(""String_Node_Str"" + valueOfPropertyFromClusterSpec);
          logger.info(""String_Node_Str"" + valueOfPropertyFromAmbariServer);
          if (valueOfPropertyFromClusterSpec == null) {
            continue;
          }
          if (valueOfPropertyFromClusterSpec.contains(""String_Node_Str"")) {
            properties.put(propertyKey,valueOfPropertyFromClusterSpec);
            needUpdate=true;
          }
 else {
            properties.put(propertyKey,valueOfPropertyFromAmbariServer);
          }
        }
      }
      desiredConfig.setProperties(properties);
      desiredConfigs.add(desiredConfig);
    }
    newApiConfigGroupInfo.setDesiredConfigs(desiredConfigs);
    newApiConfigGroup.setApiConfigGroupInfo(newApiConfigGroupInfo);
    logger.info(""String_Node_Str"" + ApiUtils.objectToJson(newApiConfigGroup));
    if (needUpdate) {
      apiManager.updateConfigGroup(clusterName,apiConfigGroupInfo.getId(),newApiConfigGroup);
    }
  }
 catch (  Exception e) {
    String errMsg=""String_Node_Str"" + apiConfigGroupInfo.getId() + ((e.getMessage() == null) ? ""String_Node_Str"" : (""String_Node_Str"" + e.getMessage()));
    logger.error(errMsg);
    throw SoftwareManagementPluginException.CONFIGURE_SERVICE_FAILED(e);
  }
}","private void updateConfigGroup(ApiConfigGroupInfo apiConfigGroupInfo,String clusterName,ApiHostGroup apiHostGroupFromClusterSpec){
  try {
    boolean needUpdate=false;
    ApiConfigGroup newApiConfigGroup=new ApiConfigGroup();
    ApiConfigGroupInfo newApiConfigGroupInfo=new ApiConfigGroupInfo();
    newApiConfigGroupInfo.setId(apiConfigGroupInfo.getId());
    newApiConfigGroupInfo.setClusterName(apiConfigGroupInfo.getClusterName());
    newApiConfigGroupInfo.setGroupName(apiConfigGroupInfo.getGroupName());
    newApiConfigGroupInfo.setTag(apiConfigGroupInfo.getTag());
    newApiConfigGroupInfo.setDescription(apiConfigGroupInfo.getDescription());
    List<ApiHostInfo> hosts=new ArrayList<ApiHostInfo>();
    for (    ApiHostInfo apiHostInfo : apiConfigGroupInfo.getHosts()) {
      ApiHostInfo newApiHostInfo=new ApiHostInfo();
      newApiHostInfo.setHostName(apiHostInfo.getHostName());
      hosts.add(newApiHostInfo);
    }
    newApiConfigGroupInfo.setHosts(hosts);
    List<ApiConfigGroupConfiguration> desiredConfigs=new ArrayList<ApiConfigGroupConfiguration>();
    logger.info(""String_Node_Str"" + ApiUtils.objectToJson(apiConfigGroupInfo.getDesiredConfigs()));
    logger.info(""String_Node_Str"" + ApiUtils.objectToJson(apiHostGroupFromClusterSpec));
    String tag=""String_Node_Str"" + Calendar.getInstance().getTimeInMillis();
    for (    ApiConfigGroupConfiguration apiConfigGroupConfiguration : apiConfigGroupInfo.getDesiredConfigs()) {
      ApiConfigGroupConfiguration desiredConfig=new ApiConfigGroupConfiguration();
      desiredConfig.setType(apiConfigGroupConfiguration.getType());
      desiredConfig.setTag(tag);
      Map<String,String> properties=new HashMap<String,String>();
      ApiClusterConfigurations apiClusterConfigurations=apiManager.getClusterConfigurationsWithTypeAndTag(clusterName,apiConfigGroupConfiguration.getType(),apiConfigGroupConfiguration.getTag());
      logger.info(""String_Node_Str"" + ApiUtils.objectToJson(apiClusterConfigurations));
      for (      ApiClusterConfigurationInfo apiClusterConfigurationInfo : apiClusterConfigurations.getConfigurations()) {
        Map<String,String> propertiesFromClusterSpec=new HashMap<String,String>();
        for (        Map<String,Object> configurationFromClusterSpec : apiHostGroupFromClusterSpec.getConfigurations()) {
          propertiesFromClusterSpec=(Map<String,String>)configurationFromClusterSpec.get(apiClusterConfigurationInfo.getType());
          if (propertiesFromClusterSpec != null) {
            break;
          }
        }
        logger.info(""String_Node_Str"" + ApiUtils.objectToJson(propertiesFromClusterSpec));
        Map<String,String> propertiesFromAmbariServer=apiClusterConfigurationInfo.getProperties();
        for (        String propertyKey : propertiesFromAmbariServer.keySet()) {
          String valueOfPropertyFromClusterSpec=null;
          if (propertiesFromClusterSpec != null) {
            valueOfPropertyFromClusterSpec=propertiesFromClusterSpec.get(propertyKey);
          }
          String valueOfPropertyFromAmbariServer=propertiesFromAmbariServer.get(propertyKey);
          logger.info(""String_Node_Str"" + valueOfPropertyFromClusterSpec);
          logger.info(""String_Node_Str"" + valueOfPropertyFromAmbariServer);
          if (valueOfPropertyFromClusterSpec != null && valueOfPropertyFromClusterSpec.contains(""String_Node_Str"")) {
            properties.put(propertyKey,valueOfPropertyFromClusterSpec);
            needUpdate=true;
          }
 else {
            properties.put(propertyKey,valueOfPropertyFromAmbariServer);
          }
        }
      }
      desiredConfig.setProperties(properties);
      desiredConfigs.add(desiredConfig);
    }
    newApiConfigGroupInfo.setDesiredConfigs(desiredConfigs);
    newApiConfigGroup.setApiConfigGroupInfo(newApiConfigGroupInfo);
    logger.info(""String_Node_Str"" + ApiUtils.objectToJson(newApiConfigGroup));
    if (needUpdate) {
      apiManager.updateConfigGroup(clusterName,apiConfigGroupInfo.getId(),newApiConfigGroup);
    }
  }
 catch (  Exception e) {
    String errMsg=""String_Node_Str"" + apiConfigGroupInfo.getId() + ((e.getMessage() == null) ? ""String_Node_Str"" : (""String_Node_Str"" + e.getMessage()));
    logger.error(errMsg);
    throw SoftwareManagementPluginException.CONFIGURE_SERVICE_FAILED(e);
  }
}"
48398,"@Override protected Extension generateNgcExtension(){
  try {
    String pluginUrl=NgcConstants.NGC_PLUGIN_URL_PREFIX + getVmIpAddress() + NgcConstants.NGC_PLUGIN_URL_SUFFIX;
    Extension extension=new ExtensionImpl();
    extension.setKey(NgcConstants.NGC_KEY);
    extension.setVersion(NgcConstants.NGC_VERSION);
    extension.setCompany(NgcConstants.NGC_COMPANY);
    Description description=new DescriptionImpl();
    description.setLabel(NgcConstants.NGC_LABEL);
    description.setSummary(NgcConstants.NGC_SUMMARY);
    extension.setDescription(description);
    ClientInfo clientInfo=new ClientInfoImpl();
    clientInfo.setCompany(NgcConstants.NGC_COMPANY);
    clientInfo.setDescription(description);
    clientInfo.setType(NgcConstants.NGC_CLIENT_TYPE);
    clientInfo.setUrl(pluginUrl);
    clientInfo.setVersion(NgcConstants.NGC_VERSION);
    ClientInfo[] clientList={clientInfo};
    extension.setClient(clientList);
    ServerInfo serverInfo=new ServerInfoImpl();
    String[] adminEmailList={NgcConstants.NGC_ADMIN_EMAIL};
    serverInfo.setAdminEmail(adminEmailList);
    serverInfo.setCompany(NgcConstants.NGC_COMPANY);
    serverInfo.setDescription(description);
    String thumbPrint=Configuration.getString(""String_Node_Str"",null);
    serverInfo.setServerThumbprint(thumbPrint);
    serverInfo.setType(NgcConstants.NGC_SERVER_TYPE);
    serverInfo.setUrl(pluginUrl);
    ServerInfo serverInfoMgmt=null;
    String mgmtMoref=Configuration.getString(Constants.BDE_SERVER_VM_MOBID);
    if (mgmtMoref.length() > 0) {
      serverInfoMgmt=new ServerInfoImpl();
      serverInfoMgmt.setAdminEmail(adminEmailList);
      serverInfoMgmt.setCompany(NgcConstants.NGC_COMPANY);
      serverInfoMgmt.setDescription(description);
      serverInfoMgmt.setType(mgmtMoref);
      serverInfoMgmt.setUrl(pluginUrl);
    }
    if (serverInfoMgmt == null) {
      ServerInfo[] serverList={serverInfo};
      extension.setServer(serverList);
    }
 else {
      ServerInfo[] serverList={serverInfo,serverInfoMgmt};
      extension.setServer(serverList);
    }
    GregorianCalendar calendar=(GregorianCalendar)Calendar.getInstance();
    extension.setLastHeartbeatTime(calendar);
    return extension;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","@Override protected Extension generateNgcExtension(){
  try {
    String pluginUrl=NgcConstants.NGC_PLUGIN_URL_PREFIX + getVmIpAddress() + NgcConstants.NGC_PLUGIN_URL_SUFFIX;
    Extension extension=new ExtensionImpl();
    extension.setKey(NgcConstants.NGC_KEY);
    extension.setVersion(NgcConstants.NGC_VERSION);
    extension.setCompany(NgcConstants.NGC_COMPANY);
    Description description=new DescriptionImpl();
    description.setLabel(NgcConstants.NGC_LABEL);
    description.setSummary(NgcConstants.NGC_SUMMARY);
    extension.setDescription(description);
    ClientInfo clientInfo=new ClientInfoImpl();
    clientInfo.setCompany(NgcConstants.NGC_COMPANY);
    clientInfo.setDescription(description);
    clientInfo.setType(NgcConstants.NGC_CLIENT_TYPE);
    clientInfo.setUrl(pluginUrl);
    clientInfo.setVersion(NgcConstants.NGC_VERSION);
    ClientInfo[] clientList={clientInfo};
    extension.setClient(clientList);
    ServerInfo serverInfo=new ServerInfoImpl();
    String[] adminEmailList={NgcConstants.NGC_ADMIN_EMAIL};
    serverInfo.setAdminEmail(adminEmailList);
    serverInfo.setCompany(NgcConstants.NGC_COMPANY);
    serverInfo.setDescription(description);
    String thumbPrint=getCertThumbPrint();
    serverInfo.setServerThumbprint(thumbPrint);
    serverInfo.setType(NgcConstants.NGC_SERVER_TYPE);
    serverInfo.setUrl(pluginUrl);
    ServerInfo serverInfoMgmt=null;
    String mgmtMoref=Configuration.getString(Constants.BDE_SERVER_VM_MOBID);
    if (mgmtMoref.length() > 0) {
      serverInfoMgmt=new ServerInfoImpl();
      serverInfoMgmt.setAdminEmail(adminEmailList);
      serverInfoMgmt.setCompany(NgcConstants.NGC_COMPANY);
      serverInfoMgmt.setDescription(description);
      serverInfoMgmt.setType(mgmtMoref);
      serverInfoMgmt.setUrl(pluginUrl);
    }
    if (serverInfoMgmt == null) {
      ServerInfo[] serverList={serverInfo};
      extension.setServer(serverList);
    }
 else {
      ServerInfo[] serverList={serverInfo,serverInfoMgmt};
      extension.setServer(serverList);
    }
    GregorianCalendar calendar=(GregorianCalendar)Calendar.getInstance();
    extension.setLastHeartbeatTime(calendar);
    return extension;
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}"
48399,"public NicDeviceConfigSpec(NetworkAdd networkAdd,Map<String,String> ipInfo,NodeEntity node,INetworkService networkMgr){
  this(networkAdd,ipInfo);
  NetworkEntity networkEntity=networkMgr.getNetworkEntityByName(networkAdd.getName());
  this.dhcpHostname=HostnameManager.generateHostname(networkEntity,node);
  this.dnsType=NetworkDnsType.DYNAMIC;
}","public NicDeviceConfigSpec(NetworkAdd networkAdd,Map<String,String> ipInfo,NodeEntity node,INetworkService networkMgr){
  this(networkAdd,ipInfo);
  NetworkEntity networkEntity=networkMgr.getNetworkEntityByName(networkAdd.getName());
  this.dhcpHostname=HostnameManager.generateHostname(networkEntity,node);
  this.dnsType=networkEntity.getDnsType();
}"
48400,"@Transactional private Void updateNodes(final String clusterName){
  return VcContext.inVcSessionDo(new VcSession<Void>(){
    @Override protected Void body() throws Exception {
      List<NodeEntity> nodes=clusterEntityMgr.findAllNodes(clusterName);
      for (      NodeEntity node : nodes) {
        node=clusterEntityMgr.getNodeWithNicsByMobId(node.getMoId());
        VcVirtualMachine vm=VcCache.getIgnoreMissing(node.getMoId());
        String hostname=VcVmUtil.getMgtHostName(vm,node.getPrimaryMgtIpV4());
        if (hostname != null && !hostname.isEmpty() && !hostname.equals(node.getGuestHostName())) {
          node.setGuestHostName(hostname);
          clusterEntityMgr.update(node);
          logger.info(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ node.getGuestHostName());
        }
      }
      return null;
    }
  }
);
}","@Transactional private Void updateNodes(final String clusterName){
  return VcContext.inVcSessionDo(new VcSession<Void>(){
    @Override protected Void body() throws Exception {
      List<NodeEntity> nodes=clusterEntityMgr.findAllNodes(clusterName);
      for (      NodeEntity node : nodes) {
        if (node.getMoId() == null || node.getMoId().isEmpty()) {
          continue;
        }
        node=clusterEntityMgr.getNodeWithNicsByMobId(node.getMoId());
        VcVirtualMachine vm=VcCache.getIgnoreMissing(node.getMoId());
        String hostname=VcVmUtil.getMgtHostName(vm,node.getPrimaryMgtIpV4());
        if (hostname != null && !hostname.isEmpty() && !hostname.equals(node.getGuestHostName())) {
          node.setGuestHostName(hostname);
          clusterEntityMgr.update(node);
          logger.info(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ node.getGuestHostName());
        }
      }
      return null;
    }
  }
);
}"
48401,"@Override protected Void body() throws Exception {
  List<NodeEntity> nodes=clusterEntityMgr.findAllNodes(clusterName);
  for (  NodeEntity node : nodes) {
    node=clusterEntityMgr.getNodeWithNicsByMobId(node.getMoId());
    VcVirtualMachine vm=VcCache.getIgnoreMissing(node.getMoId());
    String hostname=VcVmUtil.getMgtHostName(vm,node.getPrimaryMgtIpV4());
    if (hostname != null && !hostname.isEmpty() && !hostname.equals(node.getGuestHostName())) {
      node.setGuestHostName(hostname);
      clusterEntityMgr.update(node);
      logger.info(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ node.getGuestHostName());
    }
  }
  return null;
}","@Override protected Void body() throws Exception {
  List<NodeEntity> nodes=clusterEntityMgr.findAllNodes(clusterName);
  for (  NodeEntity node : nodes) {
    if (node.getMoId() == null || node.getMoId().isEmpty()) {
      continue;
    }
    node=clusterEntityMgr.getNodeWithNicsByMobId(node.getMoId());
    VcVirtualMachine vm=VcCache.getIgnoreMissing(node.getMoId());
    String hostname=VcVmUtil.getMgtHostName(vm,node.getPrimaryMgtIpV4());
    if (hostname != null && !hostname.isEmpty() && !hostname.equals(node.getGuestHostName())) {
      node.setGuestHostName(hostname);
      clusterEntityMgr.update(node);
      logger.info(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ node.getGuestHostName());
    }
  }
  return null;
}"
48402,"public static String getHostNameFromIpV4(VcVirtualMachine vcVm,String ipV4){
  VcVmNetworkInfo vcVmNetworkInfo=null;
  String guestNetworkInfo=vcVm.getGuestVariables().get(""String_Node_Str"");
  if (guestNetworkInfo != null && !guestNetworkInfo.isEmpty()) {
    Gson gson=new Gson();
    vcVmNetworkInfo=gson.fromJson(guestNetworkInfo,VcVmNetworkInfo.class);
  }
  if (vcVmNetworkInfo == null || ipV4 == null) {
    return null;
  }
  String hostName=null;
  for (  VcVmNicInfo vcVmNicInfo : vcVmNetworkInfo.getNics()) {
    if (ipV4.equals(vcVmNicInfo.getIpAddress())) {
      hostName=vcVmNicInfo.getFqdn();
      break;
    }
  }
  return hostName;
}","public static String getHostNameFromIpV4(VcVirtualMachine vcVm,String ipV4){
  VcVmNetworkInfo vcVmNetworkInfo=null;
  if (vcVm == null) {
    return null;
  }
  String guestNetworkInfo=vcVm.getGuestVariables().get(""String_Node_Str"");
  if (guestNetworkInfo != null && !guestNetworkInfo.isEmpty()) {
    Gson gson=new Gson();
    vcVmNetworkInfo=gson.fromJson(guestNetworkInfo,VcVmNetworkInfo.class);
  }
  if (vcVmNetworkInfo == null || ipV4 == null || Constants.NULL_IPV4_ADDRESS.equals(ipV4)) {
    return null;
  }
  String hostName=null;
  for (  VcVmNicInfo vcVmNicInfo : vcVmNetworkInfo.getNics()) {
    if (ipV4.equals(vcVmNicInfo.getIpAddress())) {
      hostName=vcVmNicInfo.getFqdn();
      break;
    }
  }
  return hostName;
}"
48403,"@Override public void initResource(){
  final String serverMobId=Configuration.getString(Constants.SERENGETI_SERVER_VM_MOBID);
  logger.info(""String_Node_Str"" + serverMobId);
  final VcVirtualMachine serverVm=VcResourceUtils.findVM(serverMobId);
  VcResourcePool vcRP=VcResourceUtils.getVmRp(serverVm);
  String dcName=vcRP.getVcCluster().getDatacenter().getName();
  String clusterName=vcRP.getVcCluster().getName();
  String vcRPName=vcRP.getName();
  logger.info(""String_Node_Str"" + vcRPName + ""String_Node_Str""+ clusterName+ ""String_Node_Str""+ dcName);
  String networkName=VcResourceUtils.getVMNetwork(serverVm);
  Map<DatastoreType,List<String>> dsNames=VcResourceUtils.getVmDatastore(serverVm);
  if (rpSvc.isDeployedUnderCluster(clusterName,vcRPName)) {
    vcRPName=""String_Node_Str"";
  }
  addResourceIntoDB(clusterName,vcRPName,networkName,dsNames);
}","@Override public void initResource(){
  final String serverMobId=Configuration.getString(Constants.SERENGETI_SERVER_VM_MOBID);
  logger.info(""String_Node_Str"" + serverMobId);
  final VcVirtualMachine serverVm=VcResourceUtils.findVM(serverMobId);
  final VcResourcePool vcRP=VcResourceUtils.getVmRp(serverVm);
  String clusterName=VcResourceUtils.getRpCluster(vcRP).getName();
  String vcRPName=vcRP.getName();
  logger.info(""String_Node_Str"" + vcRPName + ""String_Node_Str""+ clusterName);
  String networkName=VcResourceUtils.getVMNetwork(serverVm);
  Map<DatastoreType,List<String>> dsNames=VcResourceUtils.getVmDatastore(serverVm);
  if (rpSvc.isDeployedUnderCluster(clusterName,vcRPName)) {
    vcRPName=""String_Node_Str"";
  }
  addResourceIntoDB(clusterName,vcRPName,networkName,dsNames);
}"
48404,"@Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
  JAXBContext jaxbContext;
  try {
    jaxbContext=JAXBContext.newInstance(Users.class);
    Unmarshaller jaxbUnmarshaller=jaxbContext.createUnmarshaller();
    Users users=(Users)jaxbUnmarshaller.unmarshal(FileUtils.getConfigurationFile(UserService.UsersFile,""String_Node_Str""));
    User userDTO=null;
    boolean exsiting=false;
    boolean anonymous=false;
    if (users != null) {
      for (      User user : users.getUsers()) {
        if (user.getName().equals(username)) {
          exsiting=true;
          userDTO=user;
          break;
        }
 else         if (user.getName().trim().equals(""String_Node_Str"")) {
          anonymous=true;
          userDTO=user;
          userDTO.setName(""String_Node_Str"");
        }
      }
    }
    if (!exsiting && !anonymous) {
      throw new UsernameNotFoundException(""String_Node_Str"");
    }
    ArrayList<GrantedAuthority> roleList=new ArrayList<GrantedAuthority>();
    roleList.add(new SimpleGrantedAuthority(ADMIN_ROLE));
    return new org.springframework.security.core.userdetails.User(userDTO.getName(),""String_Node_Str"",roleList);
  }
 catch (  UsernameNotFoundException userNotFoundEx) {
    throw userNotFoundEx;
  }
catch (  Exception e) {
    logger.error(""String_Node_Str"" + e.getMessage());
    throw new UsernameNotFoundException(""String_Node_Str"");
  }
}","@Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
  JAXBContext jaxbContext;
  try {
    jaxbContext=JAXBContext.newInstance(Users.class);
    Unmarshaller jaxbUnmarshaller=jaxbContext.createUnmarshaller();
    Users users=(Users)jaxbUnmarshaller.unmarshal(FileUtils.getConfigurationFile(UserService.UsersFile,""String_Node_Str""));
    User userDTO=null;
    if (users != null) {
      for (      User user : users.getUsers()) {
        if (user.getName().equals(username)) {
          userDTO=user;
          break;
        }
 else         if (user.getName().trim().equals(""String_Node_Str"")) {
          userDTO=user;
          userDTO.setName(""String_Node_Str"");
        }
      }
    }
    if (null == userDTO) {
      throw new UsernameNotFoundException(""String_Node_Str"");
    }
    ArrayList<GrantedAuthority> roleList=new ArrayList<GrantedAuthority>();
    roleList.add(new SimpleGrantedAuthority(ADMIN_ROLE));
    return new org.springframework.security.core.userdetails.User(userDTO.getName(),""String_Node_Str"",roleList);
  }
 catch (  UsernameNotFoundException userNotFoundEx) {
    throw userNotFoundEx;
  }
catch (  Exception e) {
    logger.error(""String_Node_Str"" + e.getMessage());
    throw new UsernameNotFoundException(""String_Node_Str"");
  }
}"
48405,"private List<String> getDatastoreNamePattern(DatastoreType storageType,List<String> storeNames){
  if (storageType == null && (storeNames == null || storeNames.isEmpty())) {
    return null;
  }
  Set<String> storePattern=null;
  if (storageType == null) {
    logger.debug(""String_Node_Str"");
    storePattern=datastoreMgr.getDatastoresByNames(storeNames);
  }
  if (storageType == DatastoreType.LOCAL) {
    storePattern=datastoreMgr.getLocalDatastoresByNames(storeNames);
  }
 else {
    storePattern=datastoreMgr.getSharedDatastoresByNames(storeNames);
  }
  if (storePattern == null || storePattern.isEmpty()) {
    logger.warn(""String_Node_Str"" + storeNames + ""String_Node_Str""+ storageType+ ""String_Node_Str"");
    return null;
  }
  return new ArrayList<String>(storePattern);
}","private List<String> getDatastoreNamePattern(List<String> storeNames){
  if (storeNames == null || storeNames.isEmpty()) {
    return null;
  }
  Set<String> storePattern=null;
  storePattern=datastoreMgr.getDatastoresByNames(storeNames);
  if (storePattern == null || storePattern.isEmpty()) {
    String datastoreNames=new Gson().toJson(storeNames);
    logger.error(""String_Node_Str"" + datastoreNames + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",datastoreNames);
  }
  return new ArrayList<>(storePattern);
}"
48406,"private void expandGroupStorage(NodeGroupEntity ngEntity,NodeGroupCreate group){
  int storageSize=ngEntity.getStorageSize();
  DatastoreType storageType=ngEntity.getStorageType();
  List<String> storeNames=ngEntity.getVcDatastoreNameList();
  List<String> dataDiskStoreNames=ngEntity.getDdDatastoreNameList();
  List<String> systemDiskStoreNames=ngEntity.getSdDatastoreNameList();
  if (storageSize <= 0 && storageType == null && (storeNames == null || storeNames.isEmpty())) {
    logger.debug(""String_Node_Str"" + ngEntity.getName());
  }
  logger.debug(""String_Node_Str"" + storageSize + ""String_Node_Str""+ ngEntity.getName());
  logger.debug(""String_Node_Str"" + storageType + ""String_Node_Str""+ ngEntity.getName());
  logger.debug(""String_Node_Str"" + storeNames + ""String_Node_Str""+ ngEntity.getName());
  logger.debug(""String_Node_Str"" + systemDiskStoreNames + ""String_Node_Str""+ ngEntity.getName());
  logger.debug(""String_Node_Str"" + dataDiskStoreNames + ""String_Node_Str""+ ngEntity.getName());
  StorageRead storage=new StorageRead();
  group.setStorage(storage);
  storage.setSizeGB(storageSize);
  if (storageType != null) {
    storage.setType(storageType.toString().toLowerCase());
  }
  if (systemDiskStoreNames != null && !systemDiskStoreNames.isEmpty())   storage.setImagestoreNamePattern(getDatastoreNamePattern(storageType,systemDiskStoreNames));
 else   storage.setImagestoreNamePattern(getDatastoreNamePattern(storageType,storeNames));
  if (dataDiskStoreNames != null && !dataDiskStoreNames.isEmpty())   storage.setDiskstoreNamePattern(getDatastoreNamePattern(storageType,dataDiskStoreNames));
 else   storage.setDiskstoreNamePattern(getDatastoreNamePattern(storageType,storeNames));
  storage.setShares(ngEntity.getCluster().getIoShares());
  SoftwareManager softwareManager=getSoftwareManager(ngEntity.getCluster().getAppManager());
  if (softwareManager.twoDataDisksRequired(group.toNodeGroupInfo())) {
    logger.debug(""String_Node_Str"");
    storage.setSplitPolicy(DiskSplitPolicy.BI_SECTOR);
  }
 else {
    if (storage.getType().equalsIgnoreCase(DatastoreType.LOCAL.toString())) {
      logger.debug(""String_Node_Str"");
      storage.setSplitPolicy(DiskSplitPolicy.EVEN_SPLIT);
    }
 else {
      logger.debug(""String_Node_Str"");
      storage.setSplitPolicy(DiskSplitPolicy.AGGREGATE);
    }
  }
  setDiskAttributes(storageType,storage,storeNames);
}","private void expandGroupStorage(NodeGroupEntity ngEntity,NodeGroupCreate group){
  int storageSize=ngEntity.getStorageSize();
  DatastoreType storageType=ngEntity.getStorageType();
  List<String> storeNames=ngEntity.getVcDatastoreNameList();
  List<String> dataDiskStoreNames=ngEntity.getDdDatastoreNameList();
  List<String> systemDiskStoreNames=ngEntity.getSdDatastoreNameList();
  if (storageSize <= 0 && storageType == null && (storeNames == null || storeNames.isEmpty())) {
    logger.debug(""String_Node_Str"" + ngEntity.getName());
  }
  logger.debug(""String_Node_Str"" + storageSize + ""String_Node_Str""+ ngEntity.getName());
  logger.debug(""String_Node_Str"" + storageType + ""String_Node_Str""+ ngEntity.getName());
  logger.debug(""String_Node_Str"" + storeNames + ""String_Node_Str""+ ngEntity.getName());
  logger.debug(""String_Node_Str"" + systemDiskStoreNames + ""String_Node_Str""+ ngEntity.getName());
  logger.debug(""String_Node_Str"" + dataDiskStoreNames + ""String_Node_Str""+ ngEntity.getName());
  StorageRead storage=new StorageRead();
  group.setStorage(storage);
  storage.setSizeGB(storageSize);
  if (storageType != null) {
    storage.setType(storageType.toString().toLowerCase());
  }
  if (systemDiskStoreNames != null && !systemDiskStoreNames.isEmpty()) {
    storage.setImagestoreNamePattern(getDatastoreNamePattern(systemDiskStoreNames));
    storage.setDsNames4System(systemDiskStoreNames);
  }
 else {
    storage.setImagestoreNamePattern(getDatastoreNamePattern(storeNames));
  }
  if (dataDiskStoreNames != null && !dataDiskStoreNames.isEmpty()) {
    storage.setDiskstoreNamePattern(getDatastoreNamePattern(dataDiskStoreNames));
    storage.setDsNames4Data(dataDiskStoreNames);
  }
 else {
    storage.setDiskstoreNamePattern(getDatastoreNamePattern(storeNames));
  }
  storage.setShares(ngEntity.getCluster().getIoShares());
  SoftwareManager softwareManager=getSoftwareManager(ngEntity.getCluster().getAppManager());
  if (softwareManager.twoDataDisksRequired(group.toNodeGroupInfo())) {
    logger.debug(""String_Node_Str"");
    storage.setSplitPolicy(DiskSplitPolicy.BI_SECTOR);
  }
 else {
    if (storage.getType().equalsIgnoreCase(DatastoreType.LOCAL.toString())) {
      logger.debug(""String_Node_Str"");
      storage.setSplitPolicy(DiskSplitPolicy.EVEN_SPLIT);
    }
 else {
      logger.debug(""String_Node_Str"");
      storage.setSplitPolicy(DiskSplitPolicy.AGGREGATE);
    }
  }
  setDiskAttributes(storageType,storage,storeNames);
}"
48407,"private boolean placeDisk(VirtualNode vNode,AbstractHost host){
  AbstractHost clonedHost=AbstractHost.clone(host);
  Map<BaseNode,List<DiskSpec>> result=new HashMap<BaseNode,List<DiskSpec>>();
  for (  BaseNode node : vNode.getBaseNodes()) {
    List<DiskSpec> disks;
    List<AbstractDatastore> imagestores=clonedHost.getDatastores(node.getImagestoreNamePattern());
    List<AbstractDatastore> diskstores=clonedHost.getDatastores(node.getDiskstoreNamePattern());
    List<DiskSpec> systemDisks=new ArrayList<DiskSpec>();
    List<DiskSpec> unseparable=new ArrayList<DiskSpec>();
    List<DiskSpec> separable=new ArrayList<DiskSpec>();
    List<DiskSpec> removed=new ArrayList<DiskSpec>();
    for (    DiskSpec disk : node.getDisks()) {
      if (disk.getSplitPolicy() != null && DiskSplitPolicy.BI_SECTOR.equals(disk.getSplitPolicy())) {
        int half=disk.getSize() / 2;
        unseparable.add(new DiskSpec(disk.getName().split(""String_Node_Str"")[0] + ""String_Node_Str"",half,node.getVmName(),false,disk.getDiskType(),disk.getController(),null,disk.getAllocType(),null,null,null));
        unseparable.add(new DiskSpec(disk.getName().split(""String_Node_Str"")[0] + ""String_Node_Str"",disk.getSize() - half,node.getVmName(),false,disk.getDiskType(),disk.getController(),null,disk.getAllocType(),null,null,null));
        removed.add(disk);
      }
    }
    node.getDisks().removeAll(removed);
    for (    DiskSpec disk : node.getDisks()) {
      if (DiskType.DATA_DISK == disk.getDiskType()) {
        if (disk.isSeparable()) {
          separable.add(disk);
        }
 else {
          unseparable.add(disk);
        }
      }
 else {
        systemDisks.add(disk);
      }
    }
    disks=placeUnSeparableDisks(systemDisks,imagestores);
    if (disks == null) {
      logger.info(""String_Node_Str"" + getDiskSize(systemDisks) + ""String_Node_Str""+ getDsFree(imagestores)+ ""String_Node_Str"");
      return false;
    }
    List<DiskSpec> subDisks=null;
    if (unseparable != null && unseparable.size() != 0) {
      subDisks=placeUnSeparableDisks(unseparable,diskstores);
      if (subDisks == null) {
        logger.info(""String_Node_Str"" + getDiskSize(unseparable) + ""String_Node_Str""+ getDsFree(diskstores)+ ""String_Node_Str"");
        return false;
      }
 else {
        disks.addAll(subDisks);
      }
    }
    if (separable != null && separable.size() != 0) {
      subDisks=placeSeparableDisks(separable,diskstores);
      if (subDisks == null) {
        logger.info(""String_Node_Str"" + getDiskSize(separable) + ""String_Node_Str""+ getDsFree(diskstores)+ ""String_Node_Str"");
        return false;
      }
 else {
        disks.addAll(subDisks);
      }
    }
    result.put(node,disks);
  }
  for (  BaseNode node : vNode.getBaseNodes()) {
    AuAssert.check(result.get(node) != null);
    node.setDisks(result.get(node));
  }
  return true;
}","private boolean placeDisk(VirtualNode vNode,AbstractHost host){
  AbstractHost clonedHost=AbstractHost.clone(host);
  Map<BaseNode,List<DiskSpec>> result=new HashMap<BaseNode,List<DiskSpec>>();
  for (  BaseNode node : vNode.getBaseNodes()) {
    List<DiskSpec> disks;
    List<AbstractDatastore> imagestores=clonedHost.getDatastores(node.getImagestoreNamePattern());
    List<AbstractDatastore> diskstores=clonedHost.getDatastores(node.getDiskstoreNamePattern());
    List<DiskSpec> systemDisks=new ArrayList<DiskSpec>();
    List<DiskSpec> unseparable=new ArrayList<DiskSpec>();
    List<DiskSpec> separable=new ArrayList<DiskSpec>();
    List<DiskSpec> removed=new ArrayList<DiskSpec>();
    for (    DiskSpec disk : node.getDisks()) {
      if (disk.getSplitPolicy() != null && DiskSplitPolicy.BI_SECTOR.equals(disk.getSplitPolicy())) {
        int half=disk.getSize() / 2;
        unseparable.add(new DiskSpec(disk.getName().split(""String_Node_Str"")[0] + ""String_Node_Str"",half,node.getVmName(),false,disk.getDiskType(),disk.getController(),null,disk.getAllocType(),null,null,null));
        unseparable.add(new DiskSpec(disk.getName().split(""String_Node_Str"")[0] + ""String_Node_Str"",disk.getSize() - half,node.getVmName(),false,disk.getDiskType(),disk.getController(),null,disk.getAllocType(),null,null,null));
        removed.add(disk);
      }
    }
    node.getDisks().removeAll(removed);
    for (    DiskSpec disk : node.getDisks()) {
      if (DiskType.DATA_DISK == disk.getDiskType()) {
        if (disk.isSeparable()) {
          separable.add(disk);
        }
 else {
          unseparable.add(disk);
        }
      }
 else {
        systemDisks.add(disk);
      }
    }
    disks=placeUnSeparableDisks(systemDisks,imagestores);
    logger.info(""String_Node_Str"" + new Gson().toJson(imagestores));
    if (disks == null) {
      logger.info(""String_Node_Str"" + getDiskSize(systemDisks) + ""String_Node_Str""+ getDsFree(imagestores)+ ""String_Node_Str"");
      return false;
    }
    List<DiskSpec> subDisks=null;
    if (unseparable != null && unseparable.size() != 0) {
      subDisks=placeUnSeparableDisks(unseparable,diskstores);
      if (subDisks == null) {
        logger.info(""String_Node_Str"" + getDiskSize(unseparable) + ""String_Node_Str""+ getDsFree(diskstores)+ ""String_Node_Str"");
        return false;
      }
 else {
        disks.addAll(subDisks);
      }
    }
    if (separable != null && separable.size() != 0) {
      subDisks=placeSeparableDisks(separable,diskstores);
      if (subDisks == null) {
        logger.info(""String_Node_Str"" + getDiskSize(separable) + ""String_Node_Str""+ getDsFree(diskstores)+ ""String_Node_Str"");
        return false;
      }
 else {
        disks.addAll(subDisks);
      }
    }
    result.put(node,disks);
  }
  for (  BaseNode node : vNode.getBaseNodes()) {
    AuAssert.check(result.get(node) != null);
    node.setDisks(result.get(node));
  }
  return true;
}"
48408,"private void placeVirtualGroup(IContainer container,ClusterCreate cluster,IPlacementPlanner planner,VirtualGroup vGroup,List<BaseNode> placedNodes,Map<String,List<String>> filteredHosts){
  String targetRack=null;
  if (vGroup.getGroupRacks() != null && GroupRacksType.SAMERACK.equals(vGroup.getGroupRacks().getType())) {
    AuAssert.check(vGroup.getGroupRacks().getRacks() != null && vGroup.getGroupRacks().getRacks().length == 1);
    targetRack=vGroup.getGroupRacks().getRacks()[0];
  }
  if (filteredHosts.containsKey(PlacementUtil.NO_DATASTORE_HOSTS)) {
    filteredHosts.remove(PlacementUtil.NO_DATASTORE_HOSTS);
    filteredHosts.remove(PlacementUtil.NO_DATASTORE_HOSTS_NODE_GROUP);
  }
  List<String> dsFilteredOutHosts=new ArrayList<String>();
  if (vGroup.getvNodes().size() != 0) {
    List<String> noDatastoreHosts=container.getDsFilteredOutHosts(vGroup);
    if (null != noDatastoreHosts && !noDatastoreHosts.isEmpty()) {
      filteredHosts.put(PlacementUtil.NO_DATASTORE_HOSTS,noDatastoreHosts);
      filteredHosts.put(PlacementUtil.NO_DATASTORE_HOSTS_NODE_GROUP,vGroup.getNodeGroupNames());
    }
  }
  for (  VirtualNode vNode : vGroup.getvNodes()) {
    logger.info(""String_Node_Str"" + vNode.getBaseNodeNames());
    List<AbstractHost> candidates=container.getValidHosts(vNode,targetRack);
    if (candidates == null || candidates.size() == 0) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"" + vNode.getBaseNodeNames());
      throw PlacementException.OUT_OF_VC_HOST(PlacementUtil.getBaseNodeNames(vNode));
    }
    AbstractHost host=planner.selectHost(vNode,candidates);
    if (host == null) {
      logger.error(""String_Node_Str"" + candidates + ""String_Node_Str""+ vNode.getBaseNodeNames());
      throw PlacementException.OUT_OF_VC_HOST(PlacementUtil.getBaseNodeNames(vNode));
    }
    for (    BaseNode baseNode : vNode.getBaseNodes()) {
      Pair<String,String> rpClusterPair=planner.selectVcRp(baseNode,host);
      String rack=container.getRack(host);
      baseNode.place(rack,rpClusterPair.first,rpClusterPair.second,host);
    }
    container.allocate(vNode,host);
    logger.info(""String_Node_Str"" + host);
    logger.info(""String_Node_Str"" + vNode);
    placedNodes.addAll(vNode.getBaseNodes());
  }
}","private void placeVirtualGroup(IContainer container,ClusterCreate cluster,IPlacementPlanner planner,VirtualGroup vGroup,List<BaseNode> placedNodes,Map<String,List<String>> filteredHosts){
  String targetRack=null;
  if (vGroup.getGroupRacks() != null && GroupRacksType.SAMERACK.equals(vGroup.getGroupRacks().getType())) {
    AuAssert.check(vGroup.getGroupRacks().getRacks() != null && vGroup.getGroupRacks().getRacks().length == 1);
    targetRack=vGroup.getGroupRacks().getRacks()[0];
  }
  if (filteredHosts.containsKey(PlacementUtil.NO_DATASTORE_HOSTS)) {
    filteredHosts.remove(PlacementUtil.NO_DATASTORE_HOSTS);
    filteredHosts.remove(PlacementUtil.NO_DATASTORE_HOSTS_NODE_GROUP);
  }
  if (vGroup.getvNodes().size() != 0) {
    List<String> noDatastoreHosts=container.getDsFilteredOutHosts(vGroup);
    if (null != noDatastoreHosts && !noDatastoreHosts.isEmpty()) {
      filteredHosts.put(PlacementUtil.NO_DATASTORE_HOSTS,noDatastoreHosts);
      filteredHosts.put(PlacementUtil.NO_DATASTORE_HOSTS_NODE_GROUP,vGroup.getNodeGroupNames());
    }
  }
  for (  VirtualNode vNode : vGroup.getvNodes()) {
    logger.info(""String_Node_Str"" + vNode.getBaseNodeNames());
    List<AbstractHost> candidates=container.getValidHosts(vNode,targetRack);
    if (candidates == null || candidates.size() == 0) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"" + vNode.getBaseNodeNames());
      throw PlacementException.OUT_OF_VC_HOST(PlacementUtil.getBaseNodeNames(vNode));
    }
    AbstractHost host=planner.selectHost(vNode,candidates);
    if (host == null) {
      logger.error(""String_Node_Str"" + candidates + ""String_Node_Str""+ vNode.getBaseNodeNames());
      throw PlacementException.OUT_OF_VC_HOST(PlacementUtil.getBaseNodeNames(vNode));
    }
    for (    BaseNode baseNode : vNode.getBaseNodes()) {
      Pair<String,String> rpClusterPair=planner.selectVcRp(baseNode,host);
      String rack=container.getRack(host);
      baseNode.place(rack,rpClusterPair.first,rpClusterPair.second,host);
    }
    container.allocate(vNode,host);
    logger.info(""String_Node_Str"" + host);
    logger.info(""String_Node_Str"" + vNode);
    placedNodes.addAll(vNode.getBaseNodes());
  }
}"
48409,"private String getInputedPassword(String promptMsg){
  try {
    ConsoleReader reader=new ConsoleReader();
    reader.setPrompt(promptMsg);
    String password=null;
    try {
      password=reader.readLine(Character.valueOf('*'));
    }
 catch (    IllegalArgumentException e) {
      if (e.getMessage().contains(""String_Node_Str"")) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,null,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,com.vmware.bdd.utils.Constants.PASSWORD_REQUIREMENT);
        return null;
      }
 else {
        throw e;
      }
    }
    if (isValidPassword(password)) {
      return password;
    }
 else {
      return null;
    }
  }
 catch (  IOException e) {
    return null;
  }
}","private String getInputedPassword(String promptMsg){
  try {
    ConsoleReader reader=CommandsUtils.getConsoleReader();
    reader.setPrompt(promptMsg);
    String password=null;
    password=reader.readLine(Character.valueOf('*'));
    if (isValidPassword(password)) {
      return password;
    }
 else {
      return null;
    }
  }
 catch (  IOException e) {
    return null;
  }
}"
48410,"private static String readEnter(String msg,PromptType promptType) throws Exception {
  String enter=""String_Node_Str"";
  ConsoleReader reader=new ConsoleReader();
  reader.setPrompt(msg);
  if (promptType == PromptType.USER_NAME) {
    enter=reader.readLine();
  }
 else   if (promptType == PromptType.PASSWORD) {
    enter=reader.readLine(Character.valueOf('*'));
  }
  return enter;
}","private static String readEnter(String msg,PromptType promptType) throws Exception {
  String enter=""String_Node_Str"";
  ConsoleReader reader=getConsoleReader();
  reader.setPrompt(msg);
  if (promptType == PromptType.USER_NAME) {
    enter=reader.readLine();
  }
 else   if (promptType == PromptType.PASSWORD) {
    enter=reader.readLine(Character.valueOf('*'));
  }
  return enter;
}"
48411,"public List<AbstractHost> getAllHosts(){
  List<AbstractHost> hosts=new ArrayList<AbstractHost>();
  for (  AbstractCluster cluster : this.clusters) {
    hosts.addAll(cluster.getHosts());
  }
  return hosts;
}","public List<AbstractHost> getAllHosts(){
  List<AbstractHost> hosts=new ArrayList<AbstractHost>();
  for (  AbstractCluster cluster : this.clusters) {
    List<AbstractHost> clusterHosts=cluster.getHosts();
    if ((clusterHosts != null) && (!clusterHosts.isEmpty())) {
      hosts.addAll(clusterHosts);
    }
  }
  return hosts;
}"
48412,"public void configureUserMgmt(String clusterName,NodeEntity node){
}","public void configureUserMgmt(String clusterName,NodeEntity node){
  configureUserMgmt(clusterName,Arrays.asList(node));
}"
48413,"@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder){
  clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  List<NodeEntity> nodes=findNodesToEnableLdap(chunkContext);
  clusterLdapUserMgmtCfgService.configureUserMgmt(clusterName,nodes);
  putIntoJobExecutionContext(chunkContext,JobConstants.SET_PASSWORD_SUCCEED_JOB_PARAM,false);
  return RepeatStatus.FINISHED;
}","@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder){
  clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  List<NodeEntity> nodes=findNodesToEnableLdap(chunkContext);
  clusterLdapUserMgmtCfgService.configureUserMgmt(clusterName,nodes);
  putIntoJobExecutionContext(chunkContext,""String_Node_Str"",false);
  return RepeatStatus.FINISHED;
}"
48414,"private List<NodeEntity> findNodesToEnableLdap(ChunkContext chunkContext) throws TaskException {
  List<NodeEntity> foundNodeList=null;
  if ((managementOperation == ManagementOperation.CREATE) || (managementOperation == ManagementOperation.RESUME)) {
    foundNodeList=getClusterEntityMgr().findAllNodes(clusterName);
    return foundNodeList;
  }
 else   if (managementOperation == ManagementOperation.RESIZE) {
    String groupName=getJobParameters(chunkContext).getString(JobConstants.GROUP_NAME_JOB_PARAM);
    List<NodeEntity> nodesInGroup=clusterEntityMgr.findAllNodes(clusterName,groupName);
    long oldInstanceNum=getJobParameters(chunkContext).getLong(JobConstants.GROUP_INSTANCE_OLD_NUMBER_JOB_PARAM);
    for (    NodeEntity node : nodesInGroup) {
      long index=CommonUtil.getVmIndex(node.getVmName());
      if (index < oldInstanceNum) {
        continue;
      }
      if (node.getStatus().ordinal() >= NodeStatus.VM_READY.ordinal()) {
        if (foundNodeList == null) {
          foundNodeList=new ArrayList<NodeEntity>();
        }
        foundNodeList.add(node);
      }
    }
    return foundNodeList;
  }
 else {
    throw TaskException.EXECUTION_FAILED(""String_Node_Str"");
  }
}","private List<NodeEntity> findNodesToEnableLdap(ChunkContext chunkContext) throws TaskException {
  List<NodeEntity> foundNodeList=null;
  if ((managementOperation == ManagementOperation.CREATE) || (managementOperation == ManagementOperation.RESUME)) {
    foundNodeList=getClusterEntityMgr().findAllNodes(clusterName);
    return foundNodeList;
  }
 else   if (managementOperation == ManagementOperation.RESIZE) {
    String groupName=getJobParameters(chunkContext).getString(JobConstants.GROUP_NAME_JOB_PARAM);
    List<NodeEntity> nodesInGroup=clusterEntityMgr.findAllNodes(clusterName,groupName);
    long oldInstanceNum=getJobParameters(chunkContext).getLong(JobConstants.GROUP_INSTANCE_OLD_NUMBER_JOB_PARAM);
    for (    NodeEntity node : nodesInGroup) {
      long index=CommonUtil.getVmIndex(node.getVmName());
      if (index < oldInstanceNum) {
        continue;
      }
      if (node.getStatus().ordinal() >= NodeStatus.VM_READY.ordinal()) {
        if (foundNodeList == null) {
          foundNodeList=new ArrayList<>();
        }
        foundNodeList.add(node);
      }
    }
    return foundNodeList;
  }
 else {
    throw TaskException.EXECUTION_FAILED(""String_Node_Str"");
  }
}"
48415,"private static File locateSpecFile(String filename,String appManagerType){
  File specFile=new File(filename);
  if (specFile.exists()) {
    return specFile;
  }
  String homeDir=System.getProperties().getProperty(""String_Node_Str"");
  if (homeDir != null && !homeDir.trim().isEmpty()) {
    StringBuilder builder=new StringBuilder();
    builder.append(homeDir).append(File.separator).append(""String_Node_Str"").append(File.separator).append(appManagerType).append(File.separator).append(""String_Node_Str"").append(File.separator).append(filename);
    specFile=new File(builder.toString());
    if (!specFile.exists()) {
      logger.warn(""String_Node_Str"" + builder);
    }
 else {
      return specFile;
    }
  }
  URL filePath=ConfigurationUtils.locate(filename);
  if (filePath != null) {
    specFile=ConfigurationUtils.fileFromURL(filePath);
  }
  AuAssert.check(specFile.exists());
  return specFile;
}","private static File locateSpecFile(String filename,String appManagerType){
  File specFile=new File(filename);
  if (specFile.exists()) {
    return specFile;
  }
  String homeDir=System.getProperties().getProperty(""String_Node_Str"");
  if (homeDir != null && !homeDir.trim().isEmpty()) {
    StringBuilder builder=new StringBuilder();
    builder.append(homeDir).append(File.separator).append(""String_Node_Str"").append(File.separator).append(appManagerType).append(File.separator).append(""String_Node_Str"").append(File.separator).append(filename);
    specFile=new File(builder.toString());
    if (!specFile.exists()) {
      logger.warn(""String_Node_Str"" + builder);
    }
 else {
      return specFile;
    }
  }
  URL filePath=ConfigurationUtils.locate(filename);
  if (filePath != null) {
    specFile=ConfigurationUtils.fileFromURL(filePath);
  }
  AuAssert.check(specFile.exists(),""String_Node_Str"" + specFile.getAbsolutePath());
  return specFile;
}"
48416,"public static int compare(String[] srcVersionArray,String[] destVersionArray,int type){
  for (int j=srcVersionArray.length; j < destVersionArray.length; j++) {
    if (Integer.parseInt(destVersionArray[j]) > 0) {
      return type;
    }
  }
  return 0;
}","public static int compare(int[] srcVersionArray,int[] destVersionArray,int type){
  for (int j=srcVersionArray.length; j < destVersionArray.length; j++) {
    if (destVersionArray[j] > 0) {
      return type;
    }
  }
  return 0;
}"
48417,"@Test public void testCompare(){
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") > 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") > 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") > 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") > 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") > 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") > 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") == 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") == 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") == 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") == 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") == 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") == 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") < 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") < 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") < 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") < 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") < 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") < 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") < 0);
}","@Test public void testCompare(){
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") > 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") > 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") > 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") > 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") > 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") > 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") > 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") == 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") == 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") == 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") == 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") == 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") == 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") < 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") < 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") < 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") < 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") < 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") < 0);
  Assert.assertTrue(Version.compare(""String_Node_Str"",""String_Node_Str"") < 0);
}"
48418,"@Transactional(readOnly=true) public ClusterCreate getClusterConfig(String clusterName,boolean needAllocIp){
  ClusterEntity clusterEntity=clusterEntityMgr.findByName(clusterName);
  if (clusterEntity == null) {
    throw ClusterConfigException.CLUSTER_CONFIG_NOT_FOUND(clusterName);
  }
  ClusterCreate clusterConfig=new ClusterCreate();
  clusterConfig.setName(clusterEntity.getName());
  clusterConfig.setAppManager(clusterEntity.getAppManager());
  clusterConfig.setDistro(clusterEntity.getDistro());
  convertClusterConfig(clusterEntity,clusterConfig,needAllocIp);
  Gson gson=new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create();
  String manifest=gson.toJson(clusterConfig);
  logger.debug(""String_Node_Str"" + manifest);
  return clusterConfig;
}","@Transactional(readOnly=true) public ClusterCreate getClusterConfig(String clusterName,boolean needAllocIp){
  ClusterEntity clusterEntity=clusterEntityMgr.findByName(clusterName);
  if (clusterEntity == null) {
    throw ClusterConfigException.CLUSTER_CONFIG_NOT_FOUND(clusterName);
  }
  ClusterCreate clusterConfig=new ClusterCreate();
  clusterConfig.setName(clusterEntity.getName());
  clusterConfig.setAppManager(clusterEntity.getAppManager());
  clusterConfig.setDistro(clusterEntity.getDistro());
  Map<NetTrafficType,List<ClusterNetConfigInfo>> networkConfigInfo=clusterEntity.getNetworkConfigInfo();
  if (networkConfigInfo != null && !networkConfigInfo.isEmpty()) {
    for (    NetTrafficType trafficType : networkConfigInfo.keySet()) {
      clusterConfig.setHostnamePrefix(networkConfigInfo.get(trafficType).get(0).getHostnamePrefix());
      break;
    }
  }
  convertClusterConfig(clusterEntity,clusterConfig,needAllocIp);
  Gson gson=new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create();
  String manifest=gson.toJson(clusterConfig);
  logger.debug(""String_Node_Str"" + manifest);
  return clusterConfig;
}"
48419,"private static String generateHostnameWithTrafficType(NetTrafficType netTrafficType,String vNodeName) throws BddException {
  String prefix=getHostnamePrefix();
  String hdfsSuffix=getHostnameHdfsSuffix();
  String mapredSuffix=getHostnameMapredSuffix();
  String hostname=""String_Node_Str"";
  String suffix=""String_Node_Str"";
switch (netTrafficType) {
case MGT_NETWORK:
    suffix=vNodeName;
  break;
case HDFS_NETWORK:
suffix=vNodeName + hdfsSuffix;
break;
case MAPRED_NETWORK:
suffix=vNodeName + mapredSuffix;
break;
default :
suffix=vNodeName;
break;
}
hostname=(prefix + suffix).replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
return hostname;
}","private static String generateHostnameWithTrafficType(NetTrafficType netTrafficType,String vNodeName,String hostnamePrefix) throws BddException {
  String prefix=getHostnamePrefix();
  if (hostnamePrefix != null) {
    prefix=hostnamePrefix;
  }
  String hdfsSuffix=getHostnameHdfsSuffix();
  String mapredSuffix=getHostnameMapredSuffix();
  String hostname=""String_Node_Str"";
  String suffix=""String_Node_Str"";
switch (netTrafficType) {
case MGT_NETWORK:
    suffix=vNodeName;
  break;
case HDFS_NETWORK:
suffix=vNodeName + hdfsSuffix;
break;
case MAPRED_NETWORK:
suffix=vNodeName + mapredSuffix;
break;
default :
suffix=vNodeName;
break;
}
hostname=(prefix + suffix).replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
return hostname;
}"
48420,"public static String generateHostname(NetworkEntity networkEntity,BaseNode vNode) throws BddException {
  String vNodeName=vNode.getVmName();
  Map<NetTrafficType,List<String>> networkConfig=vNode.getCluster().getNetworkConfig();
  String hostname=""String_Node_Str"";
  for (  Map.Entry<NetTrafficType,List<String>> networkConfigEntry : networkConfig.entrySet()) {
    if (networkConfigEntry.getValue().contains(networkEntity.getName()) && networkEntity.getIsGenerateHostname()) {
      hostname=generateHostnameWithTrafficType(networkConfigEntry.getKey(),vNodeName);
      break;
    }
  }
  return hostname;
}","public static String generateHostname(NetworkEntity networkEntity,BaseNode vNode) throws BddException {
  String vNodeName=vNode.getVmName();
  Map<NetTrafficType,List<String>> networkConfig=vNode.getCluster().getNetworkConfig();
  String hostname=""String_Node_Str"";
  for (  Map.Entry<NetTrafficType,List<String>> networkConfigEntry : networkConfig.entrySet()) {
    if (networkConfigEntry.getValue().contains(networkEntity.getName()) && networkEntity.getIsGenerateHostname()) {
      hostname=generateHostnameWithTrafficType(networkConfigEntry.getKey(),vNodeName,vNode.getCluster().getHostnamePrefix());
      break;
    }
  }
  return hostname;
}"
48421,"public static void prettyOutputClusterIp2FqdnMapping(ClusterRead cluster,String filename,String delimeter) throws Exception {
  List<Object> list=new ArrayList<Object>();
  for (  NodeGroupRead nodegroup : cluster.getNodeGroups()) {
    List<NodeRead> nodes=nodegroup.getInstances();
    if (nodes != null && !nodes.isEmpty()) {
      for (      NodeRead node : nodes) {
        if (node.getIpConfigs() != null) {
          for (          NetTrafficType trafficType : node.getIpConfigs().keySet()) {
            list.add(String.format(""String_Node_Str"",node.fetchIpOf(trafficType)) + ""String_Node_Str"" + node.fetchFqdnOf(trafficType));
          }
        }
      }
    }
  }
  CommandsUtils.prettyOutputStrings(list,filename,delimeter);
}","public static void prettyOutputClusterIp2FqdnMapping(ClusterRead cluster,String filename,String delimeter) throws Exception {
  List<Object> list=new ArrayList<Object>();
  for (  NodeGroupRead nodegroup : cluster.getNodeGroups()) {
    List<NodeRead> nodes=nodegroup.getInstances();
    if (nodes != null && !nodes.isEmpty()) {
      for (      NodeRead node : nodes) {
        if (node.getIpConfigs() != null) {
          for (          NetTrafficType trafficType : node.getIpConfigs().keySet()) {
            String ip2Fqdn=String.format(""String_Node_Str"",node.fetchIpOf(trafficType)) + ""String_Node_Str"" + node.fetchFqdnOf(trafficType);
            if (!list.contains(ip2Fqdn)) {
              list.add(ip2Fqdn);
            }
          }
        }
      }
    }
  }
  CommandsUtils.prettyOutputStrings(list,filename,delimeter);
}"
48422,"public void modify(UserMgmtServer userMgtServer,boolean testOnly,boolean forceTrustCert){
  serverEao.checkServerChanged(userMgtServer);
  serverValidService.validateServerInfo(userMgtServer,forceTrustCert);
  if (!testOnly) {
    serverEao.modify(userMgtServer);
    modificationHandler.onModification(userMgtServer);
  }
}","public void modify(UserMgmtServer userMgtServer,boolean testOnly,boolean forceTrustCert){
  serverEao.checkServerChanged(userMgtServer);
  serverValidService.validateServerInfo(userMgtServer,forceTrustCert);
  if (!testOnly) {
    modificationHandler.onModification(userMgtServer);
    serverEao.modify(userMgtServer);
  }
}"
48423,"/** 
 * Gets a property of type double. <br>
 * @param defaultValue The default value.
 * @param key The key of property.
 * @return The property value.
 */
public static Double getDouble(String key,Double defaultValue){
  return config.getDouble(key,defaultValue);
}","/** 
 * Gets a property of type double. <br>
 * @param defaultValue The default value.
 * @param key The key of property.
 * @return The property value.
 */
public static Double getDouble(String key,Double defaultValue){
  try {
    return config.getDouble(key,defaultValue);
  }
 catch (  ConversionException ce) {
    logger.error(key + ""String_Node_Str"");
  }
  return defaultValue;
}"
48424,"/** 
 * Gets a property of type Long. <br>
 * @param key The key of property.
 * @param defaultValue The default value.
 * @return The property value.
 */
public static long getLong(String key,long defaultValue){
  return config.getLong(key,defaultValue);
}","/** 
 * Gets a property of type Long. <br>
 * @param key The key of property.
 * @param defaultValue The default value.
 * @return The property value.
 */
public static long getLong(String key,long defaultValue){
  try {
    return config.getLong(key,defaultValue);
  }
 catch (  ConversionException ce) {
    logger.error(key + ""String_Node_Str"");
  }
  return defaultValue;
}"
48425,"/** 
 * Gets a property of type int. <br>
 * @param defaultValue The default value.
 * @param key The key of property.
 * @return The property value.
 */
public static int getInt(String key,int defaultValue){
  return config.getInt(key,defaultValue);
}","/** 
 * Gets a property of type int. <br>
 * @param defaultValue The default value.
 * @param key The key of property.
 * @return The property value.
 */
public static int getInt(String key,int defaultValue){
  try {
    return config.getInt(key,defaultValue);
  }
 catch (  ConversionException ce) {
    logger.error(key + ""String_Node_Str"");
  }
  return defaultValue;
}"
48426,"/** 
 * Gets a property of type bool. <br>
 * @param defaultValue The default value.
 * @param key The key of property.
 * @return The property value.
 */
public static Boolean getBoolean(String key,Boolean defaultValue){
  return config.getBoolean(key,defaultValue);
}","/** 
 * Gets a property of type bool. <br>
 * @param defaultValue The default value.
 * @param key The key of property.
 * @return The property value.
 */
public static Boolean getBoolean(String key,Boolean defaultValue){
  try {
    return config.getBoolean(key,defaultValue);
  }
 catch (  ConversionException ce) {
    logger.error(key + ""String_Node_Str"");
  }
  return defaultValue;
}"
48427,"/** 
 * This sends a URL POST request to the Extension vService guest API to register a new extension. Upon success, set vcExtensionRegistered to true. Note that the extension will not be fully configured until we log in to VC as this extension and make some VMODL calls to finish the job. Note also that we only need to do this once per CMS install, not once per CMS startup, but it doesn't seem to hurt to do it every time.
 * @synchronized for preventing concurrent call to register EVS.
 */
private static synchronized void registerExtensionVService(){
  if (vcExtensionRegistered) {
    return;
  }
  logger.debug(""String_Node_Str"" + evsURL + ""String_Node_Str""+ evsToken);
  Writer output=null;
  BufferedReader input=null;
  try {
    Certificate cert=CmsKeyStore.getCertificate(CmsKeyStore.VC_EXT_KEY);
    URL url=new URL(evsURL);
    URLConnection connection=url.openConnection();
    connection.setRequestProperty(""String_Node_Str"",evsToken);
    connection.setDoInput(true);
    connection.setDoOutput(true);
    connection.setUseCaches(false);
    output=new OutputStreamWriter(connection.getOutputStream());
    String evsSchema=""String_Node_Str"";
    String payload=""String_Node_Str"" + evsSchema + ""String_Node_Str""+ ""String_Node_Str""+ extKey+ ""String_Node_Str""+ ""String_Node_Str""+ CertificateToPem(cert)+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    output.write(payload);
    output.flush();
    connection.connect();
    Map<String,List<String>> headers=connection.getHeaderFields();
    for (    Map.Entry<String,List<String>> e : headers.entrySet()) {
      for (      String val : e.getValue()) {
        logger.info(""String_Node_Str"" + e.getKey() + ""String_Node_Str""+ val);
      }
    }
    input=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    for (String str=input.readLine(); str != null; str=input.readLine()) {
      logger.debug(""String_Node_Str"" + str);
    }
    vcExtensionRegistered=true;
    logger.debug(""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + evsURL,e);
  }
 finally {
    Configuration.setBoolean(SERENGETI_EXTENSION_REGISTERED,true);
    Configuration.save();
    if (output != null) {
      try {
        output.close();
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"",e);
      }
    }
    if (input != null) {
      try {
        input.close();
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"",e);
      }
    }
  }
}","/** 
 * This sends a URL POST request to the Extension vService guest API to register a new extension. Upon success, set vcExtensionRegistered to true. Note that the extension will not be fully configured until we log in to VC as this extension and make some VMODL calls to finish the job. Note also that we only need to do this once per CMS install, not once per CMS startup, but it doesn't seem to hurt to do it every time.
 * @synchronized for preventing concurrent call to register EVS.
 */
private static synchronized void registerExtensionVService(){
  if (vcExtensionRegistered) {
    return;
  }
  logger.debug(""String_Node_Str"" + evsURL + ""String_Node_Str""+ evsToken);
  Writer output=null;
  BufferedReader input=null;
  try {
    ThumbprintTrustManager thumbprintTrustManager=new ThumbprintTrustManager();
    thumbprintTrustManager.add(vcThumbprint);
    TrustManager[] trustManagers=new TrustManager[]{thumbprintTrustManager};
    HttpClient httpClient=new HttpClient();
    TlsSocketFactory tlsSocketFactory=new TlsSocketFactory(trustManagers);
    Protocol.registerProtocol(""String_Node_Str"",new Protocol(""String_Node_Str"",(ProtocolSocketFactory)tlsSocketFactory,443));
    PostMethod method=new PostMethod(evsURL);
    method.setRequestHeader(""String_Node_Str"",evsToken);
    Certificate cert=CmsKeyStore.getCertificate(CmsKeyStore.VC_EXT_KEY);
    String evsSchema=""String_Node_Str"";
    String payload=""String_Node_Str"" + evsSchema + ""String_Node_Str""+ ""String_Node_Str""+ extKey+ ""String_Node_Str""+ ""String_Node_Str""+ CertificateToPem(cert)+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    RequestEntity requestEntity=new StringRequestEntity(payload,""String_Node_Str"",""String_Node_Str"");
    method.setRequestEntity(requestEntity);
    int statusCode=httpClient.executeMethod(method);
    logger.info(""String_Node_Str"" + statusCode);
    for (    Header e : method.getResponseHeaders()) {
      logger.debug(""String_Node_Str"" + e.getName() + ""String_Node_Str""+ e.getValue());
    }
    input=new BufferedReader(new InputStreamReader(method.getResponseBodyAsStream()));
    for (String str=input.readLine(); str != null; str=input.readLine()) {
      logger.debug(""String_Node_Str"" + str);
    }
    if (statusCode == 200) {
      vcExtensionRegistered=true;
      logger.info(""String_Node_Str"");
    }
 else {
      logger.error(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + evsURL,e);
  }
 finally {
    Configuration.setBoolean(SERENGETI_EXTENSION_REGISTERED,true);
    Configuration.save();
    if (output != null) {
      try {
        output.close();
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"",e);
      }
    }
    if (input != null) {
      try {
        input.close();
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"",e);
      }
    }
  }
}"
48428,"/** 
 * @param clusterName
 * @param vcRPName
 * @param networkName
 * @param dsNames
 */
@Override @Transactional @RetryTransaction(2) public void addResourceIntoDB(String clusterName,String vcRPName,String networkName,Map<DatastoreType,List<String>> dsNames){
  rpSvc.addResourcePool(DEFAULT_RP,clusterName,vcRPName);
  logger.info(""String_Node_Str"" + vcRPName);
  if (!dsNames.get(DatastoreType.SHARED).isEmpty()) {
    dsSvc.addDatastores(DEFAULT_DS_SHARED,DatastoreType.SHARED,dsNames.get(DatastoreType.SHARED),false);
  }
 else   if (!dsNames.get(DatastoreType.LOCAL).isEmpty()) {
    dsSvc.addDatastores(DEFAULT_DS_LOCAL,DatastoreType.LOCAL,dsNames.get(DatastoreType.LOCAL),false);
  }
  logger.info(""String_Node_Str"" + dsNames);
  if (networkName != null) {
    networkSvc.addDhcpNetwork(DEFAULT_NETWORK,networkName,null,false);
    logger.info(""String_Node_Str"" + networkName);
  }
}","/** 
 * @param clusterName
 * @param vcRPName
 * @param networkName
 * @param dsNames
 */
@Override @Transactional @RetryTransaction(2) public void addResourceIntoDB(String clusterName,String vcRPName,String networkName,Map<DatastoreType,List<String>> dsNames){
  rpSvc.addResourcePool(DEFAULT_RP,clusterName,vcRPName);
  logger.info(""String_Node_Str"" + vcRPName);
  if (!dsNames.get(DatastoreType.SHARED).isEmpty()) {
    dsSvc.addDatastores(DEFAULT_DS_SHARED,DatastoreType.SHARED,dsNames.get(DatastoreType.SHARED),false);
  }
 else   if (!dsNames.get(DatastoreType.LOCAL).isEmpty()) {
    dsSvc.addDatastores(DEFAULT_DS_LOCAL,DatastoreType.LOCAL,dsNames.get(DatastoreType.LOCAL),false);
  }
  logger.info(""String_Node_Str"" + dsNames);
  if (networkName != null) {
    networkSvc.addDhcpNetwork(DEFAULT_NETWORK,networkName,NetworkDnsType.NORMAL,false);
    logger.info(""String_Node_Str"" + networkName);
  }
}"
48429,"/** 
 * Add an appmanager to BDE
 * @param appManagerAdd
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST,consumes=""String_Node_Str"") @ResponseStatus(HttpStatus.OK) public void addAppManager(@RequestBody final AppManagerAdd appManagerAdd){
  if (appManagerAdd == null) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",null);
  }
  if (CommonUtil.isBlank(appManagerAdd.getName())) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",appManagerAdd.getName());
  }
  softwareManagerCollector.createSoftwareManager(appManagerAdd);
}","/** 
 * Add an appmanager to BDE
 * @param appManagerAdd
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST,consumes=""String_Node_Str"") @ResponseStatus(HttpStatus.OK) public void addAppManager(@RequestBody final AppManagerAdd appManagerAdd){
  if (appManagerAdd == null) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",null);
  }
  if (CommonUtil.isBlank(appManagerAdd.getName()) || !CommonUtil.validateResourceName(appManagerAdd.getName())) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",appManagerAdd.getName());
  }
  softwareManagerCollector.createSoftwareManager(appManagerAdd);
}"
48430,"public String getBanner(){
  StringBuffer buf=new StringBuffer();
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + this.getVersion());
  return buf.toString();
}","public String getBanner(){
  StringBuilder buf=new StringBuilder();
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + this.getVersion());
  return buf.toString();
}"
48431,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void exportClusterData(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFileName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String topology,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String delimeter,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String output){
  String path=null;
  if (!CommandsUtils.isBlank(specFileName)) {
    if (!CommandsUtils.isBlank(type)) {
      System.out.println(Constants.TYPE_SPECFILE_CONFLICT);
      return;
    }
    path=specFileName;
  }
 else   if (!CommandsUtils.isBlank((type))) {
    if (!CommandsUtils.isBlank(output)) {
      path=output;
    }
  }
  if (topology != null && validateTopologyValue(name,topology) == null) {
    return;
  }
  try {
    if ((CommandsUtils.isBlank(specFileName) && CommandsUtils.isBlank(type)) || !CommandsUtils.isBlank(specFileName) || type.equalsIgnoreCase(Constants.EXPORT_TYPE_SPEC)) {
      ClusterCreate cluster=restClient.getSpec(name);
      CommandsUtils.prettyJsonOutput(cluster,path);
    }
 else     if (type.equalsIgnoreCase(Constants.EXPORT_TYPE_RACK)) {
      Map<String,String> rackTopology=restClient.getRackTopology(name,topology);
      CommandsUtils.gracefulRackTopologyOutput(rackTopology,path,delimeter);
    }
 else     if (type.equalsIgnoreCase(Constants.EXPORT_TYPE_IP)) {
      ClusterRead cluster=restClient.get(name,true);
      prettyOutputClusterIPs(cluster,path,delimeter);
    }
 else {
      System.out.println(Constants.UNKNOWN_EXPORT_TYPE);
    }
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_EXPORT,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void exportClusterData(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFileName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String topology,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String delimeter,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String output){
  String path=null;
  if (!CommandsUtils.isBlank(specFileName)) {
    if (!CommandsUtils.isBlank(type)) {
      System.out.println(Constants.TYPE_SPECFILE_CONFLICT);
      return;
    }
    path=specFileName;
  }
 else   if (!CommandsUtils.isBlank((type))) {
    if (!CommandsUtils.isBlank(output)) {
      path=output;
    }
  }
  if (topology != null && validateTopologyValue(name,topology) == null) {
    return;
  }
  try {
    if ((CommandsUtils.isBlank(specFileName) && CommandsUtils.isBlank(type)) || !CommandsUtils.isBlank(specFileName) || Constants.EXPORT_TYPE_SPEC.equalsIgnoreCase(type)) {
      ClusterCreate cluster=restClient.getSpec(name);
      CommandsUtils.prettyJsonOutput(cluster,path);
    }
 else     if (Constants.EXPORT_TYPE_RACK.equalsIgnoreCase(type)) {
      Map<String,String> rackTopology=restClient.getRackTopology(name,topology);
      CommandsUtils.gracefulRackTopologyOutput(rackTopology,path,delimeter);
    }
 else     if (Constants.EXPORT_TYPE_IP.equalsIgnoreCase(type)) {
      ClusterRead cluster=restClient.get(name,true);
      prettyOutputClusterIPs(cluster,path,delimeter);
    }
 else {
      System.out.println(Constants.UNKNOWN_EXPORT_TYPE);
    }
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_EXPORT,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}"
48432,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void targetCluster(@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean info){
  ClusterRead cluster=null;
  boolean noCluster=false;
  try {
    if (info) {
      if (name != null) {
        System.out.println(""String_Node_Str"");
        return;
      }
      String fsUrl=hadoopConfiguration.get(""String_Node_Str"");
      String jtUrl=hadoopConfiguration.get(""String_Node_Str"");
      if ((fsUrl == null || fsUrl.length() == 0) && (jtUrl == null || jtUrl.length() == 0)) {
        System.out.println(""String_Node_Str"");
        return;
      }
      if (targetClusterName != null && targetClusterName.length() > 0) {
        System.out.println(""String_Node_Str"" + targetClusterName);
      }
      if (fsUrl != null && fsUrl.length() > 0) {
        System.out.println(""String_Node_Str"" + fsUrl);
      }
      if (jtUrl != null && jtUrl.length() > 0) {
        System.out.println(""String_Node_Str"" + jtUrl);
      }
      if (hiveServerUrl != null && hiveServerUrl.length() > 0) {
        System.out.println(""String_Node_Str"" + hiveServerUrl);
      }
    }
 else {
      if (name == null) {
        ClusterRead[] clusters=restClient.getAll(false);
        if (clusters != null && clusters.length > 0) {
          cluster=clusters[0];
        }
 else {
          noCluster=true;
        }
      }
 else {
        cluster=restClient.get(name,false);
      }
      if (cluster == null) {
        if (noCluster) {
          System.out.println(""String_Node_Str"");
        }
 else {
          System.out.println(""String_Node_Str"" + name + ""String_Node_Str"");
        }
        setFsURL(""String_Node_Str"");
        setJobTrackerURL(""String_Node_Str"");
        this.setHiveServerUrl(""String_Node_Str"");
      }
 else {
        targetClusterName=cluster.getName();
        boolean hasHDFS=false;
        boolean hasHiveServer=false;
        for (        NodeGroupRead nodeGroup : cluster.getNodeGroups()) {
          for (          String role : nodeGroup.getRoles()) {
            if (role.equals(""String_Node_Str"")) {
              List<NodeRead> nodes=nodeGroup.getInstances();
              if (nodes != null && nodes.size() > 0) {
                String nameNodeIP=nodes.get(0).fetchMgtIp();
                setNameNode(nameNodeIP);
                hasHDFS=true;
              }
 else {
                throw new CliRestException(""String_Node_Str"");
              }
            }
            if (role.equals(""String_Node_Str"")) {
              List<NodeRead> nodes=nodeGroup.getInstances();
              if (nodes != null && nodes.size() > 0) {
                String jobTrackerIP=nodes.get(0).fetchMgtIp();
                setJobTracker(jobTrackerIP);
              }
 else {
                throw new CliRestException(""String_Node_Str"");
              }
            }
            if (role.equals(""String_Node_Str"")) {
              List<NodeRead> nodes=nodeGroup.getInstances();
              if (nodes != null && nodes.size() > 0) {
                String hiveServerIP=nodes.get(0).fetchMgtIp();
                setHiveServerAddress(hiveServerIP);
                hasHiveServer=true;
              }
 else {
                throw new CliRestException(""String_Node_Str"");
              }
            }
          }
        }
        if (cluster.getExternalHDFS() != null && !cluster.getExternalHDFS().isEmpty()) {
          setFsURL(cluster.getExternalHDFS());
          hasHDFS=true;
        }
        if (!hasHDFS) {
          setFsURL(""String_Node_Str"");
        }
        if (!hasHiveServer) {
          this.setHiveServerUrl(""String_Node_Str"");
        }
      }
    }
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_TARGET,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    setFsURL(""String_Node_Str"");
    setJobTrackerURL(""String_Node_Str"");
    this.setHiveServerUrl(""String_Node_Str"");
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void targetCluster(@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean info){
  ClusterRead cluster=null;
  boolean noCluster=false;
  try {
    if (info) {
      if (name != null) {
        System.out.println(""String_Node_Str"");
        return;
      }
      String fsUrl=hadoopConfiguration.get(""String_Node_Str"");
      String jtUrl=hadoopConfiguration.get(""String_Node_Str"");
      if ((fsUrl == null || fsUrl.length() == 0) && (jtUrl == null || jtUrl.length() == 0)) {
        System.out.println(""String_Node_Str"");
        return;
      }
      if (targetClusterName != null && targetClusterName.length() > 0) {
        System.out.println(""String_Node_Str"" + targetClusterName);
      }
      if (fsUrl != null && fsUrl.length() > 0) {
        System.out.println(""String_Node_Str"" + fsUrl);
      }
      if (jtUrl != null && jtUrl.length() > 0) {
        System.out.println(""String_Node_Str"" + jtUrl);
      }
      if (hiveServerUrl != null && hiveServerUrl.length() > 0) {
        System.out.println(""String_Node_Str"" + hiveServerUrl);
      }
    }
 else {
      if (name == null) {
        ClusterRead[] clusters=restClient.getAll(false);
        if (clusters != null && clusters.length > 0) {
          cluster=clusters[0];
        }
 else {
          noCluster=true;
        }
      }
 else {
        cluster=restClient.get(name,false);
      }
      if (cluster == null) {
        if (noCluster) {
          System.out.println(""String_Node_Str"");
        }
 else {
          System.out.println(""String_Node_Str"" + name + ""String_Node_Str"");
        }
        setFsURL(""String_Node_Str"");
        setJobTrackerURL(""String_Node_Str"");
        this.setHiveServerUrl(""String_Node_Str"");
      }
 else {
        targetClusterName=cluster.getName();
        boolean hasHDFS=false;
        boolean hasHiveServer=false;
        for (        NodeGroupRead nodeGroup : cluster.getNodeGroups()) {
          for (          String role : nodeGroup.getRoles()) {
            if (""String_Node_Str"".equals(role)) {
              List<NodeRead> nodes=nodeGroup.getInstances();
              if (nodes != null && nodes.size() > 0) {
                String nameNodeIP=nodes.get(0).fetchMgtIp();
                setNameNode(nameNodeIP);
                hasHDFS=true;
              }
 else {
                throw new CliRestException(""String_Node_Str"");
              }
            }
            if (""String_Node_Str"".equals(role)) {
              List<NodeRead> nodes=nodeGroup.getInstances();
              if (nodes != null && nodes.size() > 0) {
                String jobTrackerIP=nodes.get(0).fetchMgtIp();
                setJobTracker(jobTrackerIP);
              }
 else {
                throw new CliRestException(""String_Node_Str"");
              }
            }
            if (""String_Node_Str"".equals(role)) {
              List<NodeRead> nodes=nodeGroup.getInstances();
              if (nodes != null && nodes.size() > 0) {
                String hiveServerIP=nodes.get(0).fetchMgtIp();
                setHiveServerAddress(hiveServerIP);
                hasHiveServer=true;
              }
 else {
                throw new CliRestException(""String_Node_Str"");
              }
            }
          }
        }
        if (cluster.getExternalHDFS() != null && !cluster.getExternalHDFS().isEmpty()) {
          setFsURL(cluster.getExternalHDFS());
          hasHDFS=true;
        }
        if (!hasHDFS) {
          setFsURL(""String_Node_Str"");
        }
        if (!hasHiveServer) {
          this.setHiveServerUrl(""String_Node_Str"");
        }
      }
    }
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_TARGET,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    setFsURL(""String_Node_Str"");
    setJobTrackerURL(""String_Node_Str"");
    this.setHiveServerUrl(""String_Node_Str"");
  }
}"
48433,"public static void gracefulRackTopologyOutput(Map<String,String> racksTopology,String filename,String delimeter) throws Exception {
  List<Object> list=new ArrayList<Object>();
  if (racksTopology != null && racksTopology.size() > 0) {
    Iterator<Entry<String,String>> it=racksTopology.entrySet().iterator();
    Map.Entry<String,String> entry=null;
    String vmIP=""String_Node_Str"";
    String rackPath=""String_Node_Str"";
    while (it.hasNext()) {
      entry=(Map.Entry<String,String>)it.next();
      vmIP=entry.getKey();
      rackPath=entry.getValue();
      StringBuffer buff=new StringBuffer();
      list.add(buff.append(vmIP).append(""String_Node_Str"").append(rackPath).toString());
    }
  }
  prettyOutputStrings(list,filename,delimeter);
}","public static void gracefulRackTopologyOutput(Map<String,String> racksTopology,String filename,String delimeter) throws Exception {
  List<Object> list=new ArrayList<Object>();
  if (racksTopology != null && racksTopology.size() > 0) {
    Iterator<Entry<String,String>> it=racksTopology.entrySet().iterator();
    Map.Entry<String,String> entry=null;
    String vmIP=""String_Node_Str"";
    String rackPath=""String_Node_Str"";
    while (it.hasNext()) {
      entry=(Map.Entry<String,String>)it.next();
      vmIP=entry.getKey();
      rackPath=entry.getValue();
      StringBuilder buff=new StringBuilder();
      list.add(buff.append(vmIP).append(""String_Node_Str"").append(rackPath).toString());
    }
  }
  prettyOutputStrings(list,filename,delimeter);
}"
48434,"private static boolean isContinue(final String name,final String targetObject,final String operateType,final String promptMsg,final boolean alwaysAnswerYes){
  if (alwaysAnswerYes) {
    return true;
  }
  boolean continueCreate=true;
  boolean continueLoop=true;
  String readMsg=""String_Node_Str"";
  try {
    ConsoleReader reader=new ConsoleReader();
    reader.setPrompt(promptMsg);
    int k=0;
    while (continueLoop) {
      if (k >= 3) {
        continueCreate=false;
        break;
      }
      readMsg=reader.readLine();
      if (readMsg.trim().equalsIgnoreCase(""String_Node_Str"") || readMsg.trim().equalsIgnoreCase(""String_Node_Str"")) {
        continueLoop=false;
      }
 else       if (readMsg.trim().equalsIgnoreCase(""String_Node_Str"") || readMsg.trim().equalsIgnoreCase(""String_Node_Str"")) {
        continueLoop=false;
        continueCreate=false;
      }
 else {
        k++;
      }
    }
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(targetObject,name,operateType,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    continueCreate=false;
  }
  return continueCreate;
}","private static boolean isContinue(final String name,final String targetObject,final String operateType,final String promptMsg,final boolean alwaysAnswerYes){
  if (alwaysAnswerYes) {
    return true;
  }
  boolean continueCreate=true;
  boolean continueLoop=true;
  String readMsg=""String_Node_Str"";
  try {
    ConsoleReader reader=new ConsoleReader();
    reader.setPrompt(promptMsg);
    int k=0;
    while (continueLoop) {
      if (k >= 3) {
        continueCreate=false;
        break;
      }
      readMsg=reader.readLine();
      if (""String_Node_Str"".equalsIgnoreCase(readMsg.trim()) || ""String_Node_Str"".equalsIgnoreCase(readMsg.trim())) {
        continueLoop=false;
      }
 else       if (""String_Node_Str"".equalsIgnoreCase(readMsg.trim()) || ""String_Node_Str"".equalsIgnoreCase(readMsg.trim())) {
        continueLoop=false;
        continueCreate=false;
      }
 else {
        k++;
      }
    }
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(targetObject,name,operateType,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    continueCreate=false;
  }
  return continueCreate;
}"
48435,"public static void prettyOutputStrings(List<Object> objs,String fileName,String delimeter) throws Exception {
  StringBuffer buff=new StringBuffer();
  if (CommonUtil.isBlank(delimeter)) {
    delimeter=""String_Node_Str"";
  }
  for (  Object obj : objs) {
    if (obj != null) {
      String str=obj.toString();
      if (!CommandsUtils.isBlank(str)) {
        buff.append(str).append(delimeter);
      }
    }
  }
  if (buff.length() > 0) {
    buff.delete(buff.length() - delimeter.length(),buff.length());
  }
  OutputStream out=null;
  BufferedWriter bw=null;
  try {
    if (!isBlank(fileName)) {
      out=new FileOutputStream(fileName);
    }
 else {
      out=System.out;
    }
    bw=new BufferedWriter(new OutputStreamWriter(out,""String_Node_Str""));
    bw.write(buff.toString());
    bw.flush();
    writeEndingMsgToScreen(fileName);
  }
  finally {
    if (bw != null && out != null && !(out instanceof PrintStream)) {
      bw.close();
      out.close();
    }
  }
}","public static void prettyOutputStrings(List<Object> objs,String fileName,String delimeter) throws Exception {
  StringBuilder buff=new StringBuilder();
  if (CommonUtil.isBlank(delimeter)) {
    delimeter=""String_Node_Str"";
  }
  for (  Object obj : objs) {
    if (obj != null) {
      String str=obj.toString();
      if (!CommandsUtils.isBlank(str)) {
        buff.append(str).append(delimeter);
      }
    }
  }
  if (buff.length() > 0) {
    buff.delete(buff.length() - delimeter.length(),buff.length());
  }
  OutputStream out=null;
  BufferedWriter bw=null;
  try {
    if (!isBlank(fileName)) {
      out=new FileOutputStream(fileName);
    }
 else {
      out=System.out;
    }
    bw=new BufferedWriter(new OutputStreamWriter(out,""String_Node_Str""));
    bw.write(buff.toString());
    bw.flush();
    writeEndingMsgToScreen(fileName);
  }
  finally {
    if (bw != null && out != null && !(out instanceof PrintStream)) {
      bw.close();
      out.close();
    }
  }
}"
48436,"public static String dataFromFile(String filePath) throws IOException, FileNotFoundException {
  StringBuffer dataStringBuffer=new StringBuffer();
  FileInputStream fis=null;
  InputStreamReader inputStreamReader=null;
  BufferedReader bufferedReader=null;
  try {
    fis=new FileInputStream(filePath);
    inputStreamReader=new InputStreamReader(fis,""String_Node_Str"");
    bufferedReader=new BufferedReader(inputStreamReader);
    String line=""String_Node_Str"";
    while ((line=bufferedReader.readLine()) != null) {
      dataStringBuffer.append(line);
      dataStringBuffer.append(""String_Node_Str"");
    }
  }
  finally {
    if (fis != null) {
      fis.close();
    }
    if (inputStreamReader != null) {
      inputStreamReader.close();
    }
    if (bufferedReader != null) {
      bufferedReader.close();
    }
  }
  return dataStringBuffer.toString();
}","public static String dataFromFile(String filePath) throws IOException, FileNotFoundException {
  StringBuilder dataStringBuffer=new StringBuilder();
  FileInputStream fis=null;
  InputStreamReader inputStreamReader=null;
  BufferedReader bufferedReader=null;
  try {
    fis=new FileInputStream(filePath);
    inputStreamReader=new InputStreamReader(fis,""String_Node_Str"");
    bufferedReader=new BufferedReader(inputStreamReader);
    String line=""String_Node_Str"";
    while ((line=bufferedReader.readLine()) != null) {
      dataStringBuffer.append(line);
      dataStringBuffer.append(""String_Node_Str"");
    }
  }
  finally {
    if (fis != null) {
      fis.close();
    }
    if (inputStreamReader != null) {
      inputStreamReader.close();
    }
    if (bufferedReader != null) {
      bufferedReader.close();
    }
  }
  return dataStringBuffer.toString();
}"
48437,"@Override public void checkServerTrusted(X509Certificate[] chain,String authType) throws CertificateException {
  String errorMsg=""String_Node_Str"";
  char[] pwd=""String_Node_Str"".toCharArray();
  InputStream in=null;
  OutputStream out=null;
  try {
    File file=new File(""String_Node_Str"");
    if (file.isFile() == false) {
      char SEP=File.separatorChar;
      File dir=new File(System.getProperty(""String_Node_Str"") + SEP + ""String_Node_Str""+ SEP+ ""String_Node_Str"");
      file=new File(dir,""String_Node_Str"");
      if (file.isFile() == false) {
        file=new File(dir,""String_Node_Str"");
      }
    }
    in=new FileInputStream(file);
    keyStore.load(in,pwd);
    MessageDigest sha1=MessageDigest.getInstance(""String_Node_Str"");
    MessageDigest md5=MessageDigest.getInstance(""String_Node_Str"");
    String md5Fingerprint=""String_Node_Str"";
    String sha1Fingerprint=""String_Node_Str"";
    SimpleDateFormat dateFormate=new SimpleDateFormat(""String_Node_Str"");
    for (int i=0; i < chain.length; i++) {
      X509Certificate cert=chain[i];
      sha1.update(cert.getEncoded());
      md5.update(cert.getEncoded());
      md5Fingerprint=toHexString(md5.digest());
      sha1Fingerprint=toHexString(sha1.digest());
      if (keyStore.getCertificate(md5Fingerprint) != null) {
        if (i == chain.length - 1) {
          return;
        }
 else {
          continue;
        }
      }
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"" + cert.getSubjectDN());
      System.out.println(""String_Node_Str"" + cert.getIssuerDN());
      System.out.println(""String_Node_Str"" + sha1Fingerprint);
      System.out.println(""String_Node_Str"" + md5Fingerprint);
      System.out.println(""String_Node_Str"" + dateFormate.format(cert.getNotBefore()));
      System.out.println(""String_Node_Str"" + dateFormate.format(cert.getNotAfter()));
      System.out.println(""String_Node_Str"" + cert.getSignature());
      System.out.println();
      ConsoleReader reader=new ConsoleReader();
      reader.setPrompt(Constants.PARAM_PROMPT_ADD_CERTIFICATE_MESSAGE);
      String readMsg=""String_Node_Str"";
      if (RunWayConfig.getRunType().equals(RunType.MANUAL)) {
        readMsg=reader.readLine();
      }
 else {
        readMsg=""String_Node_Str"";
      }
      if (!readMsg.trim().equalsIgnoreCase(""String_Node_Str"") && !readMsg.trim().equalsIgnoreCase(""String_Node_Str"")) {
        if (i == chain.length - 1) {
          throw new CertificateException(""String_Node_Str"");
        }
 else {
          continue;
        }
      }
      keyStore.setCertificateEntry(md5Fingerprint,cert);
      out=new FileOutputStream(""String_Node_Str"");
      keyStore.store(out,pwd);
    }
  }
 catch (  FileNotFoundException e) {
    errorMsg=""String_Node_Str"" + e.getMessage();
  }
catch (  NoSuchAlgorithmException e) {
    errorMsg=""String_Node_Str"" + e.getMessage();
  }
catch (  IOException e) {
    errorMsg=""String_Node_Str"" + e.getMessage();
  }
catch (  KeyStoreException e) {
    errorMsg=""String_Node_Str"" + e.getMessage();
  }
 finally {
    if (!CommandsUtils.isBlank(errorMsg)) {
      System.out.println(errorMsg);
      logger.error(errorMsg);
    }
    if (in != null) {
      try {
        in.close();
      }
 catch (      IOException e) {
        logger.warn(""String_Node_Str"");
      }
    }
    if (out != null) {
      try {
        out.close();
      }
 catch (      IOException e) {
        logger.warn(""String_Node_Str"");
      }
    }
  }
}","@Override public void checkServerTrusted(X509Certificate[] chain,String authType) throws CertificateException {
  String errorMsg=""String_Node_Str"";
  char[] pwd=""String_Node_Str"".toCharArray();
  InputStream in=null;
  OutputStream out=null;
  try {
    File file=new File(""String_Node_Str"");
    if (file.isFile() == false) {
      char SEP=File.separatorChar;
      File dir=new File(System.getProperty(""String_Node_Str"") + SEP + ""String_Node_Str""+ SEP+ ""String_Node_Str"");
      file=new File(dir,""String_Node_Str"");
      if (file.isFile() == false) {
        file=new File(dir,""String_Node_Str"");
      }
    }
    in=new FileInputStream(file);
    keyStore.load(in,pwd);
    MessageDigest sha1=MessageDigest.getInstance(""String_Node_Str"");
    MessageDigest md5=MessageDigest.getInstance(""String_Node_Str"");
    String md5Fingerprint=""String_Node_Str"";
    String sha1Fingerprint=""String_Node_Str"";
    SimpleDateFormat dateFormate=new SimpleDateFormat(""String_Node_Str"");
    for (int i=0; i < chain.length; i++) {
      X509Certificate cert=chain[i];
      sha1.update(cert.getEncoded());
      md5.update(cert.getEncoded());
      md5Fingerprint=toHexString(md5.digest());
      sha1Fingerprint=toHexString(sha1.digest());
      if (keyStore.getCertificate(md5Fingerprint) != null) {
        if (i == chain.length - 1) {
          return;
        }
 else {
          continue;
        }
      }
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"" + cert.getSubjectDN());
      System.out.println(""String_Node_Str"" + cert.getIssuerDN());
      System.out.println(""String_Node_Str"" + sha1Fingerprint);
      System.out.println(""String_Node_Str"" + md5Fingerprint);
      System.out.println(""String_Node_Str"" + dateFormate.format(cert.getNotBefore()));
      System.out.println(""String_Node_Str"" + dateFormate.format(cert.getNotAfter()));
      System.out.println(""String_Node_Str"" + cert.getSignature());
      System.out.println();
      ConsoleReader reader=new ConsoleReader();
      reader.setPrompt(Constants.PARAM_PROMPT_ADD_CERTIFICATE_MESSAGE);
      String readMsg=""String_Node_Str"";
      if (RunWayConfig.getRunType().equals(RunType.MANUAL)) {
        readMsg=reader.readLine();
      }
 else {
        readMsg=""String_Node_Str"";
      }
      if (!""String_Node_Str"".equalsIgnoreCase(readMsg.trim()) && !""String_Node_Str"".equalsIgnoreCase(readMsg.trim())) {
        if (i == chain.length - 1) {
          throw new CertificateException(""String_Node_Str"");
        }
 else {
          continue;
        }
      }
      keyStore.setCertificateEntry(md5Fingerprint,cert);
      out=new FileOutputStream(""String_Node_Str"");
      keyStore.store(out,pwd);
    }
  }
 catch (  FileNotFoundException e) {
    errorMsg=""String_Node_Str"" + e.getMessage();
  }
catch (  NoSuchAlgorithmException e) {
    errorMsg=""String_Node_Str"" + e.getMessage();
  }
catch (  IOException e) {
    errorMsg=""String_Node_Str"" + e.getMessage();
  }
catch (  KeyStoreException e) {
    errorMsg=""String_Node_Str"" + e.getMessage();
  }
 finally {
    if (!CommandsUtils.isBlank(errorMsg)) {
      System.out.println(errorMsg);
      logger.error(errorMsg);
    }
    if (in != null) {
      try {
        in.close();
      }
 catch (      IOException e) {
        logger.warn(""String_Node_Str"");
      }
    }
    if (out != null) {
      try {
        out.close();
      }
 catch (      IOException e) {
        logger.warn(""String_Node_Str"");
      }
    }
  }
}"
48438,"private String getVCConnectErrorMsg(InputStream is){
  StringBuffer buffer=new StringBuffer();
  InputStreamReader inputStreamReader=null;
  BufferedReader bufferedReader=null;
  try {
    inputStreamReader=new InputStreamReader(is);
    bufferedReader=new BufferedReader(inputStreamReader);
    String line=""String_Node_Str"";
    while ((line=bufferedReader.readLine()) != null) {
      buffer.append(line);
      buffer.append(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + e.getMessage());
  }
 finally {
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"" + e.getMessage());
      }
    }
    if (inputStreamReader != null) {
      try {
        inputStreamReader.close();
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"" + e.getMessage());
      }
    }
    if (bufferedReader != null) {
      try {
        bufferedReader.close();
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  return findErrorMsg(buffer.toString(),""String_Node_Str"");
}","private String getVCConnectErrorMsg(InputStream is){
  StringBuilder buffer=new StringBuilder();
  InputStreamReader inputStreamReader=null;
  BufferedReader bufferedReader=null;
  try {
    inputStreamReader=new InputStreamReader(is);
    bufferedReader=new BufferedReader(inputStreamReader);
    String line=""String_Node_Str"";
    while ((line=bufferedReader.readLine()) != null) {
      buffer.append(line);
      buffer.append(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    logger.error(""String_Node_Str"" + e.getMessage());
  }
 finally {
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"" + e.getMessage());
      }
    }
    if (inputStreamReader != null) {
      try {
        inputStreamReader.close();
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"" + e.getMessage());
      }
    }
    if (bufferedReader != null) {
      try {
        bufferedReader.close();
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"" + e.getMessage());
      }
    }
  }
  return findErrorMsg(buffer.toString(),""String_Node_Str"");
}"
48439,"public void setPassword(String password){
  if (password == ""String_Node_Str"") {
    this.password=""String_Node_Str"";
    return;
  }
  try {
    this.password=EncryptionGuard.encode(password);
  }
 catch (  UnsupportedEncodingException e) {
    logger.warn(""String_Node_Str"",e);
  }
catch (  GeneralSecurityException e) {
    logger.warn(""String_Node_Str"",e);
  }
}","public void setPassword(String password){
  if (""String_Node_Str"".equals(password)) {
    this.password=""String_Node_Str"";
    return;
  }
  try {
    this.password=EncryptionGuard.encode(password);
  }
 catch (  UnsupportedEncodingException e) {
    logger.warn(""String_Node_Str"",e);
  }
catch (  GeneralSecurityException e) {
    logger.warn(""String_Node_Str"",e);
  }
}"
48440,"public boolean isReady(){
  return (connected && ipv4Address != null && !ipv4Address.equals(Constants.NULL_IPV4_ADDRESS));
}","public boolean isReady(){
  return (connected && ipv4Address != null && !Constants.NULL_IPV4_ADDRESS.equals(ipv4Address));
}"
48441,"public void setAction(String action){
  if (this.action != action) {
    logger.debug(""String_Node_Str"" + getVmName() + ""String_Node_Str""+ action);
    this.action=action;
  }
}","public void setAction(String action){
  if ((this.action == null && action != null) || !this.action.equals(action)) {
    logger.debug(""String_Node_Str"" + getVmName() + ""String_Node_Str""+ action);
    this.action=action;
  }
}"
48442,"public NodeGroupRead toNodeGroupRead(boolean ignoreObsoleteNode){
  NodeGroupRead nodeGroupRead=new NodeGroupRead();
  nodeGroupRead.setName(this.name);
  nodeGroupRead.setCpuNum(this.cpuNum);
  nodeGroupRead.setMemCapacityMB(this.memorySize);
  nodeGroupRead.setSwapRatio(this.swapRatio);
  nodeGroupRead.setInstanceNum(this.getRealInstanceNum(ignoreObsoleteNode));
  Gson gson=new Gson();
  @SuppressWarnings(""String_Node_Str"") List<String> groupRoles=gson.fromJson(roles,List.class);
  nodeGroupRead.setRoles(groupRoles);
  StorageRead storage=new StorageRead();
  storage.setType(this.storageType.toString());
  storage.setSizeGB(this.storageSize);
  if (getVcDatastoreNameList() != null && !getVcDatastoreNameList().isEmpty())   storage.setDsNames(getVcDatastoreNameList());
  if (getSdDatastoreNameList() != null && !getSdDatastoreNameList().isEmpty())   storage.setDsNames4System(getSdDatastoreNameList());
  if (getDdDatastoreNameList() != null && !getDdDatastoreNameList().isEmpty())   storage.setDsNames4Data(getDdDatastoreNameList());
  nodeGroupRead.setStorage(storage);
  List<NodeRead> nodeList=new ArrayList<NodeRead>();
  for (  NodeEntity node : this.nodes) {
    if (ignoreObsoleteNode && (node.isObsoleteNode() || node.isDisconnected())) {
      continue;
    }
    nodeList.add(node.toNodeRead(true));
  }
  nodeGroupRead.setInstances(nodeList);
  List<GroupAssociation> associations=new ArrayList<GroupAssociation>();
  for (  NodeGroupAssociation relation : groupAssociations) {
    GroupAssociation association=new GroupAssociation();
    association.setReference(relation.getReferencedGroup());
    association.setType(relation.getAssociationType());
    associations.add(association);
  }
  PlacementPolicy policy=new PlacementPolicy();
  policy.setInstancePerHost(instancePerHost);
  policy.setGroupAssociations(associations);
  policy.setGroupRacks(new Gson().fromJson(groupRacks,GroupRacks.class));
  nodeGroupRead.setPlacementPolicies(policy);
  return nodeGroupRead;
}","public NodeGroupRead toNodeGroupRead(boolean ignoreObsoleteNode){
  NodeGroupRead nodeGroupRead=new NodeGroupRead();
  nodeGroupRead.setName(this.name);
  nodeGroupRead.setCpuNum(this.cpuNum);
  nodeGroupRead.setMemCapacityMB(this.memorySize);
  nodeGroupRead.setSwapRatio(this.swapRatio);
  nodeGroupRead.setInstanceNum(this.getRealInstanceNum(ignoreObsoleteNode));
  Gson gson=new Gson();
  @SuppressWarnings(""String_Node_Str"") List<String> groupRoles=gson.fromJson(roles,List.class);
  nodeGroupRead.setRoles(groupRoles);
  StorageRead storage=new StorageRead();
  storage.setType(this.storageType.toString());
  storage.setSizeGB(this.storageSize);
  List<String> datastoreNameList=getVcDatastoreNameList();
  if (datastoreNameList != null && !datastoreNameList.isEmpty())   storage.setDsNames(datastoreNameList);
  if (getSdDatastoreNameList() != null && !getSdDatastoreNameList().isEmpty())   storage.setDsNames4System(getSdDatastoreNameList());
  if (getDdDatastoreNameList() != null && !getDdDatastoreNameList().isEmpty())   storage.setDsNames4Data(getDdDatastoreNameList());
  nodeGroupRead.setStorage(storage);
  List<NodeRead> nodeList=new ArrayList<NodeRead>();
  for (  NodeEntity node : this.nodes) {
    if (ignoreObsoleteNode && (node.isObsoleteNode() || node.isDisconnected())) {
      continue;
    }
    nodeList.add(node.toNodeRead(true));
  }
  nodeGroupRead.setInstances(nodeList);
  List<GroupAssociation> associations=new ArrayList<GroupAssociation>();
  for (  NodeGroupAssociation relation : groupAssociations) {
    GroupAssociation association=new GroupAssociation();
    association.setReference(relation.getReferencedGroup());
    association.setType(relation.getAssociationType());
    associations.add(association);
  }
  PlacementPolicy policy=new PlacementPolicy();
  policy.setInstancePerHost(instancePerHost);
  policy.setGroupAssociations(associations);
  policy.setGroupRacks(new Gson().fromJson(groupRacks,GroupRacks.class));
  nodeGroupRead.setPlacementPolicies(policy);
  return nodeGroupRead;
}"
48443,"public static File getConfigFile(final String filename,final String typeName){
  File specFile=new File(filename);
  if (specFile.exists()) {
    return specFile;
  }
  String homeDir=System.getProperties().getProperty(""String_Node_Str"");
  if (homeDir != null && !homeDir.trim().isEmpty()) {
    StringBuilder builder=new StringBuilder();
    builder.append(homeDir).append(File.separator).append(""String_Node_Str"").append(File.separator).append(filename);
    specFile=new File(builder.toString());
    if (!specFile.exists()) {
      logger.warn(typeName + ""String_Node_Str"" + builder);
    }
 else {
      return specFile;
    }
  }
  URL filePath=ConfigurationUtils.locate(filename);
  if (filePath != null) {
    specFile=ConfigurationUtils.fileFromURL(filePath);
  }
  if (!specFile.exists()) {
    String errorMsg=""String_Node_Str"" + filename;
    logger.fatal(errorMsg);
    new RuntimeException(errorMsg);
  }
  return specFile;
}","public static File getConfigFile(final String filename,final String typeName){
  File specFile=new File(filename);
  if (specFile.exists()) {
    return specFile;
  }
  String homeDir=System.getProperties().getProperty(""String_Node_Str"");
  if (homeDir != null && !homeDir.trim().isEmpty()) {
    StringBuilder builder=new StringBuilder();
    builder.append(homeDir).append(File.separator).append(""String_Node_Str"").append(File.separator).append(filename);
    specFile=new File(builder.toString());
    if (!specFile.exists()) {
      logger.warn(typeName + ""String_Node_Str"" + builder);
    }
 else {
      return specFile;
    }
  }
  URL filePath=ConfigurationUtils.locate(filename);
  if (filePath != null) {
    specFile=ConfigurationUtils.fileFromURL(filePath);
  }
  if (!specFile.exists()) {
    String errorMsg=""String_Node_Str"" + filename;
    logger.fatal(errorMsg);
    throw new RuntimeException(errorMsg);
  }
  return specFile;
}"
48444,"@Test public void testLoadUserByUsername() throws JAXBException {
  UserDetails userDetails1=null;
  UserDetailsService accountService=new UserService();
  Users users1=new Users();
  User user1=new User();
  user1.setName(""String_Node_Str"");
  users1.setUsers(Arrays.asList(user1));
  TestFileUtils.createXMLFile(users1,FileUtils.getConfigFile(UsersFile,""String_Node_Str""));
  try {
    userDetails1=accountService.loadUserByUsername(""String_Node_Str"");
  }
 catch (  UsernameNotFoundException e) {
  }
  Assert.assertNull(userDetails1);
  UserDetails userDetails2=accountService.loadUserByUsername(""String_Node_Str"");
  assertNotNull(userDetails2);
  TestFileUtils.deleteXMLFile(FileUtils.getConfigFile(UsersFile,""String_Node_Str""));
  Users users2=new Users();
  User user2=new User();
  user2.setName(""String_Node_Str"");
  users2.setUsers(Arrays.asList(user2));
  TestFileUtils.createXMLFile(users2,FileUtils.getConfigFile(UsersFile,""String_Node_Str""));
  userDetails1=accountService.loadUserByUsername(""String_Node_Str"");
  assertNotNull(userDetails1);
  assertEquals(userDetails1.getUsername(),""String_Node_Str"");
  TestFileUtils.deleteXMLFile(FileUtils.getConfigFile(UsersFile,""String_Node_Str""));
  Users users3=new Users();
  users3.setUsers(Arrays.asList(user2,user1));
  TestFileUtils.createXMLFile(users3,FileUtils.getConfigFile(UsersFile,""String_Node_Str""));
  userDetails1=accountService.loadUserByUsername(""String_Node_Str"");
  assertNotNull(userDetails1);
  assertEquals(userDetails1.getUsername(),""String_Node_Str"");
  TestFileUtils.deleteXMLFile(FileUtils.getConfigFile(UsersFile,""String_Node_Str""));
}","@Test public void testLoadUserByUsername() throws JAXBException {
  UserDetails userDetails1=null;
  UserDetailsService accountService=new UserService();
  Users users1=new Users();
  User user1=new User();
  user1.setName(""String_Node_Str"");
  users1.setUsers(Arrays.asList(user1));
  String confPath=System.getProperties().get(""String_Node_Str"") + File.separator + ""String_Node_Str"";
  new File(confPath).mkdir();
  String userXmlPath=confPath + File.separator + UsersFile;
  File usrXmlFile=new File(userXmlPath);
  TestFileUtils.createXMLFile(users1,usrXmlFile);
  try {
    userDetails1=accountService.loadUserByUsername(""String_Node_Str"");
  }
 catch (  UsernameNotFoundException e) {
  }
  Assert.assertNull(userDetails1);
  UserDetails userDetails2=accountService.loadUserByUsername(""String_Node_Str"");
  assertNotNull(userDetails2);
  TestFileUtils.deleteXMLFile(usrXmlFile);
  Users users2=new Users();
  User user2=new User();
  user2.setName(""String_Node_Str"");
  users2.setUsers(Arrays.asList(user2));
  TestFileUtils.createXMLFile(users2,usrXmlFile);
  userDetails1=accountService.loadUserByUsername(""String_Node_Str"");
  assertNotNull(userDetails1);
  assertEquals(userDetails1.getUsername(),""String_Node_Str"");
  TestFileUtils.deleteXMLFile(usrXmlFile);
  Users users3=new Users();
  users3.setUsers(Arrays.asList(user2,user1));
  TestFileUtils.createXMLFile(users3,usrXmlFile);
  userDetails1=accountService.loadUserByUsername(""String_Node_Str"");
  assertNotNull(userDetails1);
  assertEquals(userDetails1.getUsername(),""String_Node_Str"");
  TestFileUtils.deleteXMLFile(usrXmlFile);
}"
48445,"@Test public void testAuthenticate() throws Exception {
  Authentication authentication=new MockUp<Authentication>(){
    @Mock Object getPrincipal(){
      return ""String_Node_Str"";
    }
    @Mock Object getCredentials(){
      return ""String_Node_Str"";
    }
    @Mock public String getName(){
      return ""String_Node_Str"";
    }
  }
.getMockInstance();
  new NonStrictExpectations(){
    @SuppressWarnings(""String_Node_Str"") Configuration configuration;
{
      Configuration.getString(""String_Node_Str"");
      returns(""String_Node_Str"");
    }
{
      Configuration.getString(""String_Node_Str"");
      returns(""String_Node_Str"");
    }
{
      Configuration.getInt(""String_Node_Str"",110);
      returns(110);
    }
  }
;
  new MockUp<AuthenticateVcUser>(){
    @Mock public void authenticateUser(    String name,    String password) throws Exception {
      return;
    }
  }
;
  Users users=new Users();
  User user=new User();
  user.setName(""String_Node_Str"");
  users.setUsers(Arrays.asList(user));
  TestFileUtils.createXMLFile(users,FileUtils.getConfigFile(UsersFile,""String_Node_Str""));
  UserAuthenticationProvider provider=new UserAuthenticationProvider();
  provider.setUserService(new UserService());
  provider.authenticate(authentication);
  TestFileUtils.deleteXMLFile(FileUtils.getConfigFile(UsersFile,""String_Node_Str""));
}","@Test public void testAuthenticate() throws Exception {
  Authentication authentication=new MockUp<Authentication>(){
    @Mock Object getPrincipal(){
      return ""String_Node_Str"";
    }
    @Mock Object getCredentials(){
      return ""String_Node_Str"";
    }
    @Mock public String getName(){
      return ""String_Node_Str"";
    }
  }
.getMockInstance();
  new NonStrictExpectations(){
    @SuppressWarnings(""String_Node_Str"") Configuration configuration;
{
      Configuration.getString(""String_Node_Str"");
      returns(""String_Node_Str"");
    }
{
      Configuration.getString(""String_Node_Str"");
      returns(""String_Node_Str"");
    }
{
      Configuration.getInt(""String_Node_Str"",110);
      returns(110);
    }
  }
;
  new MockUp<AuthenticateVcUser>(){
    @Mock public void authenticateUser(    String name,    String password) throws Exception {
      return;
    }
  }
;
  Users users=new Users();
  User user=new User();
  user.setName(""String_Node_Str"");
  users.setUsers(Arrays.asList(user));
  String confPath=System.getProperties().get(""String_Node_Str"") + File.separator + ""String_Node_Str"";
  new File(confPath).mkdir();
  String userXmlPath=confPath + File.separator + UsersFile;
  File usrXmlFile=new File(userXmlPath);
  TestFileUtils.createXMLFile(users,usrXmlFile);
  UserAuthenticationProvider provider=new UserAuthenticationProvider();
  provider.setUserService(new UserService());
  provider.authenticate(authentication);
  TestFileUtils.deleteXMLFile(usrXmlFile);
}"
48446,"private boolean validateLocalRepoURL(String localRepoURL){
  boolean succ=true;
  HttpClientBuilder builder=HttpClientBuilder.create();
  CloseableHttpClient httpClient=builder.build();
  HttpGet httpGet=new HttpGet(localRepoURL);
  try {
    HttpResponse resp=httpClient.execute(httpGet);
    StatusLine status=resp.getStatusLine();
    if (status.getStatusCode() >= 400) {
      succ=false;
    }
  }
 catch (  Exception e) {
    succ=false;
    logger.error(e.getMessage());
  }
 finally {
    if (null != httpClient) {
      try {
        httpClient.close();
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"");
      }
    }
  }
  return succ;
}","private boolean validateLocalRepoURL(String localRepoURL){
  boolean succ=true;
  HttpClientBuilder builder=HttpClientBuilder.create();
  CloseableHttpClient httpClient=builder.build();
  try {
    HttpGet httpGet=new HttpGet(localRepoURL);
    HttpResponse resp=httpClient.execute(httpGet);
    StatusLine status=resp.getStatusLine();
    if (status.getStatusCode() >= 400) {
      succ=false;
    }
  }
 catch (  Exception e) {
    succ=false;
    logger.error(e.getMessage());
  }
 finally {
    if (null != httpClient) {
      try {
        httpClient.close();
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"");
      }
    }
  }
  return succ;
}"
48447,"/** 
 * Get software manager instance
 * @param name
 * @return null if the name does not exist
 */
public SoftwareManager getSoftwareManager(String name){
  if (CommonUtil.isBlank(name)) {
    return cache.get(Constants.IRONFAN);
  }
  AppManagerEntity appManagerEntity=appManagerService.findAppManagerByName(name);
  if (appManagerEntity == null) {
    logger.error(""String_Node_Str"" + name);
    throw SoftwareManagerCollectorException.APPMANAGER_NOT_FOUND(name);
  }
 else {
    String appMgrType=appManagerEntity.getType();
    if (!appMgrType.equals(Constants.IRONFAN)) {
      checkServerConnection(name,appManagerEntity.getUrl());
    }
    if (cache.containsKey(name)) {
      return cache.get(name);
    }
    return loadSoftwareManager(appManagerEntity);
  }
}","/** 
 * Get software manager instance
 * @param name
 * @return null if the name does not exist
 */
public SoftwareManager getSoftwareManager(String name){
  if (CommonUtil.isBlank(name) || Constants.IRONFAN.equals(name)) {
    return cache.get(Constants.IRONFAN);
  }
  AppManagerEntity appManagerEntity=appManagerService.findAppManagerByName(name);
  if (appManagerEntity == null) {
    logger.error(""String_Node_Str"" + name);
    throw SoftwareManagerCollectorException.APPMANAGER_NOT_FOUND(name);
  }
 else {
    if (cache.containsKey(name)) {
      String appMgrType=appManagerEntity.getType();
      if (!appMgrType.equals(Constants.IRONFAN)) {
        checkServerConnection(name,appManagerEntity.getUrl());
      }
      return cache.get(name);
    }
    return loadSoftwareManager(appManagerEntity);
  }
}"
48448,"@BeforeMethod public void setUp(){
  softwareManagerCollector=new SoftwareManagerCollector();
  appManagerService=Mockito.mock(IAppManagerService.class);
  clusterEntityManager=Mockito.mock(IClusterEntityManager.class);
  softwareManagerCollector.setAppManagerService(appManagerService);
  softwareManagerCollector.setClusterEntityManager(clusterEntityManager);
  Configuration.setString(SoftwareManagerCollector.configurationPrefix + Constants.IRONFAN,""String_Node_Str"");
  Configuration.setString(SoftwareManagerCollector.configurationPrefix + FooSWMgrFactory.FOO_APP_MGR,""String_Node_Str"");
}","@BeforeMethod public void setUp(){
  softwareManagerCollector=new SoftwareManagerCollector();
  appManagerService=Mockito.mock(IAppManagerService.class);
  clusterEntityManager=Mockito.mock(IClusterEntityManager.class);
  softwareManagerCollector.setAppManagerService(appManagerService);
  softwareManagerCollector.setClusterEntityManager(clusterEntityManager);
  Configuration.setString(SoftwareManagerCollector.configurationPrefix + Constants.IRONFAN,""String_Node_Str"");
  Configuration.setString(SoftwareManagerCollector.configurationPrefix + FooSWMgrFactory.FOO_APP_MGR,""String_Node_Str"");
  Mockit.setUpMock(MockCommonUtil.class);
}"
48449,"@Test public void testCreateAppManager_Success(){
  Mockito.when(appManagerService.findAll()).thenReturn(new ArrayList<AppManagerEntity>());
  Configuration.setString(SoftwareManagerCollector.configurationPrefix + defaultAppManagerAdd.getType(),""String_Node_Str"");
  softwareManagerCollector.setPrivateKey(""String_Node_Str"");
  softwareManagerCollector.createSoftwareManager(defaultAppManagerAdd);
  TestSWMgrCollector_LoadAppManager.assertSoftwareManagers(softwareManagerCollector.getSoftwareManager(Constants.IRONFAN),defaultAppManagerAdd);
}","@Test public void testCreateAppManager_Success(){
  Mockito.when(appManagerService.findAll()).thenReturn(new ArrayList<AppManagerEntity>());
  Configuration.setString(SoftwareManagerCollector.configurationPrefix + defaultAppManagerAdd.getType(),""String_Node_Str"");
  softwareManagerCollector.setPrivateKey(""String_Node_Str"");
  softwareManagerCollector.createSoftwareManager(defaultAppManagerAdd);
  Mockito.when(appManagerService.findAppManagerByName(Matchers.anyString())).thenReturn(defaultAppManagerEntity);
  TestSWMgrCollector_LoadAppManager.assertSoftwareManagers(softwareManagerCollector.getSoftwareManager(Constants.IRONFAN),defaultAppManagerAdd);
}"
48450,"@Test public void testGetAppMgrRead_Success(){
  Mockito.when(appManagerService.findAll()).thenReturn(Arrays.asList(defaultAppManagerEntity));
  softwareManagerCollector.loadSoftwareManagers();
  Mockito.when(appManagerService.getAppManagerRead(Matchers.anyString())).thenReturn(defaultAppManagerRead);
  AppManagerRead appManagerRead=softwareManagerCollector.getAppManagerRead(defaultAppManagerAdd.getName());
  Assert.assertEquals(defaultAppManagerRead.getName(),appManagerRead.getName());
  Assert.assertEquals(defaultAppManagerRead.getType(),appManagerRead.getType());
}","@Test public void testGetAppMgrRead_Success(){
  Mockito.when(appManagerService.findAll()).thenReturn(Arrays.asList(defaultAppManagerEntity));
  Mockito.when(appManagerService.findAppManagerByName(Matchers.anyString())).thenReturn(defaultAppManagerEntity);
  softwareManagerCollector.loadSoftwareManagers();
  Mockito.when(appManagerService.getAppManagerRead(Matchers.anyString())).thenReturn(defaultAppManagerRead);
  AppManagerRead appManagerRead=softwareManagerCollector.getAppManagerRead(defaultAppManagerAdd.getName());
  Assert.assertEquals(defaultAppManagerRead.getName(),appManagerRead.getName());
  Assert.assertEquals(defaultAppManagerRead.getType(),appManagerRead.getType());
}"
48451,"@Test public void testLoadAppManagers_Default(){
  Mockito.when(appManagerService.findAll()).thenReturn(Arrays.asList(defaultAppManagerEntity));
  softwareManagerCollector.loadSoftwareManagers();
  assertSoftwareManagers(softwareManagerCollector.getSoftwareManager(Constants.IRONFAN),defaultAppManagerAdd);
}","@Test public void testLoadAppManagers_Default(){
  Mockito.when(appManagerService.findAll()).thenReturn(Arrays.asList(defaultAppManagerEntity));
  Mockito.when(appManagerService.findAppManagerByName(Matchers.anyString())).thenReturn(defaultAppManagerEntity);
  softwareManagerCollector.loadSoftwareManagers();
  assertSoftwareManagers(softwareManagerCollector.getSoftwareManager(Constants.IRONFAN),defaultAppManagerAdd);
}"
48452,"@Test public void testLoadAppManager_Success(){
  Mockito.when(appManagerService.findAll()).thenReturn(new ArrayList<AppManagerEntity>());
  Configuration.setString(SoftwareManagerCollector.configurationPrefix + defaultAppManagerAdd.getType(),""String_Node_Str"");
  softwareManagerCollector.setPrivateKey(""String_Node_Str"");
  softwareManagerCollector.loadSoftwareManager(defaultAppManagerAdd);
  assertSoftwareManagers(softwareManagerCollector.getSoftwareManager(Constants.IRONFAN),defaultAppManagerAdd);
}","@Test public void testLoadAppManager_Success(){
  Mockito.when(appManagerService.findAll()).thenReturn(new ArrayList<AppManagerEntity>());
  Mockito.when(appManagerService.findAppManagerByName(Matchers.anyString())).thenReturn(defaultAppManagerEntity);
  Configuration.setString(SoftwareManagerCollector.configurationPrefix + defaultAppManagerAdd.getType(),""String_Node_Str"");
  softwareManagerCollector.setPrivateKey(""String_Node_Str"");
  softwareManagerCollector.loadSoftwareManager(defaultAppManagerAdd);
  assertSoftwareManagers(softwareManagerCollector.getSoftwareManager(Constants.IRONFAN),defaultAppManagerAdd);
}"
48453,"@Test public void testLoadAppManagers_Upgrade(){
  Mockito.when(appManagerService.findAll()).thenReturn(new ArrayList<AppManagerEntity>());
  softwareManagerCollector.loadSoftwareManagers();
  assertSoftwareManagers(softwareManagerCollector.getSoftwareManager(Constants.IRONFAN),defaultAppManagerAdd);
}","@Test public void testLoadAppManagers_Upgrade(){
  Mockito.when(appManagerService.findAll()).thenReturn(new ArrayList<AppManagerEntity>());
  Mockito.when(appManagerService.findAppManagerByName(Matchers.anyString())).thenReturn(defaultAppManagerEntity);
  softwareManagerCollector.loadSoftwareManagers();
  assertSoftwareManagers(softwareManagerCollector.getSoftwareManager(Constants.IRONFAN),defaultAppManagerAdd);
}"
48454,"public static boolean validateUrl(String url,List<String> errorMsgs){
  if (errorMsgs == null) {
    errorMsgs=new ArrayList<String>();
  }
  boolean result=true;
  try {
    URI uri=new URI(url);
    String schema=uri.getScheme();
    if (!""String_Node_Str"".equalsIgnoreCase(schema) && !""String_Node_Str"".equalsIgnoreCase(schema)) {
      errorMsgs.add(""String_Node_Str"");
      result=false;
    }
  }
 catch (  URISyntaxException e) {
    logger.error(""String_Node_Str"",e);
    errorMsgs.add(""String_Node_Str"");
    return false;
  }
  return result;
}","public static boolean validateUrl(String url,List<String> errorMsgs){
  if (errorMsgs == null) {
    errorMsgs=new ArrayList<String>();
  }
  boolean result=true;
  try {
    URI uri=new URI(url);
    String schema=uri.getScheme();
    if (!""String_Node_Str"".equalsIgnoreCase(schema) && !""String_Node_Str"".equalsIgnoreCase(schema)) {
      errorMsgs.add(""String_Node_Str"");
      result=false;
    }
    if (""String_Node_Str"".equalsIgnoreCase(schema) && uri.getHost().matches(Constants.IP_PATTERN)) {
      errorMsgs.add(""String_Node_Str"");
      result=false;
    }
  }
 catch (  URISyntaxException e) {
    logger.error(""String_Node_Str"",e);
    errorMsgs.add(""String_Node_Str"");
    return false;
  }
  return result;
}"
48455,"@Override public List<String> validateScaling(NodeGroupInfo group){
  return new ArrayList<String>();
}","@Override public List<String> validateScaling(NodeGroupInfo group){
  List<String> roles=group.getRoles();
  List<String> unsupportedRoles=new ArrayList<String>();
  if (roles.isEmpty()) {
    return new ArrayList<String>();
  }
  if (roles.contains(HadoopRole.HADOOP_NAMENODE_ROLE.toString())) {
    unsupportedRoles.add(HadoopRole.HADOOP_NAMENODE_ROLE.toString());
  }
  if (roles.contains(HadoopRole.HADOOP_SECONDARY_NAMENODE_ROLE.toString())) {
    unsupportedRoles.add(HadoopRole.HADOOP_SECONDARY_NAMENODE_ROLE.toString());
  }
  if (roles.contains(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString())) {
    unsupportedRoles.add(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString());
  }
  if (roles.contains(HadoopRole.HADOOP_RESOURCEMANAGER_ROLE.toString())) {
    unsupportedRoles.add(HadoopRole.HADOOP_RESOURCEMANAGER_ROLE.toString());
  }
  if (roles.contains(HadoopRole.ZOOKEEPER_SERVER_ROLE.toString())) {
    unsupportedRoles.add(HadoopRole.ZOOKEEPER_SERVER_ROLE.toString());
  }
  return unsupportedRoles;
}"
48456,"@Override public List<String> validateScaling(NodeGroupInfo group){
  return new ArrayList<String>();
}","@Override public List<String> validateScaling(NodeGroupInfo group){
  List<String> roles=group.getRoles();
  List<String> unsupportedRoles=new ArrayList<String>();
  if (roles.isEmpty()) {
    return new ArrayList<String>();
  }
  if (roles.contains(HadoopRole.HADOOP_NAMENODE_ROLE.toString())) {
    unsupportedRoles.add(HadoopRole.HADOOP_NAMENODE_ROLE.toString());
  }
  if (roles.contains(HadoopRole.HADOOP_SECONDARY_NAMENODE_ROLE.toString())) {
    unsupportedRoles.add(HadoopRole.HADOOP_SECONDARY_NAMENODE_ROLE.toString());
  }
  if (roles.contains(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString())) {
    unsupportedRoles.add(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString());
  }
  if (roles.contains(HadoopRole.HADOOP_RESOURCEMANAGER_ROLE.toString())) {
    unsupportedRoles.add(HadoopRole.HADOOP_RESOURCEMANAGER_ROLE.toString());
  }
  if (roles.contains(HadoopRole.ZOOKEEPER_SERVER_ROLE.toString())) {
    unsupportedRoles.add(HadoopRole.ZOOKEEPER_SERVER_ROLE.toString());
  }
  return unsupportedRoles;
}"
48457,"@Override public List<String> validateScaling(NodeGroupInfo group) throws SoftwareManagementPluginException {
  List<String> roles=group.getRoles();
  List<String> unsupportedRoles=new ArrayList<String>();
  if (roles.isEmpty()) {
    return new ArrayList<String>();
  }
  if (roles.contains(HadoopRole.HADOOP_NAMENODE_ROLE.toString())) {
    unsupportedRoles.add(HadoopRole.HADOOP_NAMENODE_ROLE.toString());
  }
  if (roles.contains(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString())) {
    unsupportedRoles.add(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString());
  }
  if (roles.contains(HadoopRole.ZOOKEEPER_ROLE.toString())) {
    unsupportedRoles.add(HadoopRole.ZOOKEEPER_ROLE.toString());
  }
  return unsupportedRoles;
}","@Override public List<String> validateScaling(NodeGroupInfo group) throws SoftwareManagementPluginException {
  List<String> roles=group.getRoles();
  List<String> unsupportedRoles=new ArrayList<String>();
  if (roles.isEmpty()) {
    return new ArrayList<String>();
  }
  if (roles.contains(HadoopRole.HADOOP_NAMENODE_ROLE.toString())) {
    unsupportedRoles.add(HadoopRole.HADOOP_NAMENODE_ROLE.toString());
  }
  if (roles.contains(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString())) {
    unsupportedRoles.add(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString());
  }
  if (roles.contains(HadoopRole.HADOOP_RESOURCEMANAGER_ROLE.toString())) {
    unsupportedRoles.add(HadoopRole.HADOOP_RESOURCEMANAGER_ROLE.toString());
  }
  if (roles.contains(HadoopRole.ZOOKEEPER_ROLE.toString())) {
    unsupportedRoles.add(HadoopRole.ZOOKEEPER_ROLE.toString());
  }
  return unsupportedRoles;
}"
48458,"public static BddException EXTRA_PACKAGES_NOT_FOUND(){
  return new BddException(null,""String_Node_Str"",""String_Node_Str"");
}","public static BddException EXTRA_PACKAGES_NOT_FOUND(String extraPackages){
  return new BddException(null,""String_Node_Str"",""String_Node_Str"",extraPackages);
}"
48459,"private void writeJsonFile(Map<String,Object> clusterConfig,File file){
  Gson gson=new GsonBuilder().excludeFieldsWithoutExposeAnnotation().setPrettyPrinting().create();
  String jsonStr=gson.toJson(clusterConfig);
  AuAssert.check(jsonStr != null);
  logger.info(""String_Node_Str"" + jsonStr + ""String_Node_Str""+ file);
  BufferedWriter out=null;
  try {
    out=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file),""String_Node_Str""));
    out.write(jsonStr);
  }
 catch (  IOException ex) {
    logger.error(ex.getMessage() + ""String_Node_Str"" + file);
    throw BddException.INTERNAL(ex,""String_Node_Str"");
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"" + out,e);
      }
    }
  }
}","private void writeJsonFile(Map<String,Object> clusterConfig,File file){
  Gson gson=new GsonBuilder().excludeFieldsWithoutExposeAnnotation().setPrettyPrinting().create();
  String jsonStr=gson.toJson(clusterConfig);
  AuAssert.check(jsonStr != null);
  logger.debug(""String_Node_Str"" + jsonStr + ""String_Node_Str""+ file);
  BufferedWriter out=null;
  try {
    out=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file),""String_Node_Str""));
    out.write(jsonStr);
  }
 catch (  IOException ex) {
    logger.error(ex.getMessage() + ""String_Node_Str"" + file);
    throw BddException.INTERNAL(ex,""String_Node_Str"");
  }
 finally {
    if (out != null) {
      try {
        out.close();
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"" + out,e);
      }
    }
  }
}"
48460,"private void updateVersion(AppManagerRead appManagerRead){
  String softMgrVersion=""String_Node_Str"";
  final SoftwareManager softwareManager=this.getSoftwareManager(appManagerRead.getName());
  ExecutorService exec=Executors.newFixedThreadPool(1);
  Future<String> futureResult=exec.submit(new Callable<String>(){
    @Override public String call() throws Exception {
      return softwareManager.getVersion();
    }
  }
);
  String result=(String)waitForThreadResult(futureResult);
  if (null != result) {
    softMgrVersion=result;
  }
  exec.shutdown();
  appManagerRead.setVersion(softMgrVersion);
}","private void updateVersion(AppManagerRead appManagerRead){
  String softMgrVersion=""String_Node_Str"";
  final SoftwareManager softwareManager=this.getSoftwareManager(appManagerRead.getName());
  ExecutorService exec=Executors.newFixedThreadPool(1);
  Future<String> futureResult=exec.submit(new Callable<String>(){
    @Override public String call() throws Exception {
      return softwareManager.getVersion();
    }
  }
);
  String result=(String)CommonUtil.waitForThreadResult(futureResult,waitTimeForAppMgrConn);
  if (null != result) {
    softMgrVersion=result;
  }
  exec.shutdown();
  appManagerRead.setVersion(softMgrVersion);
}"
48461,"/** 
 * Get software manager instance
 * @param name
 * @return null if the name does not exist
 */
public SoftwareManager getSoftwareManager(String name){
  if (CommonUtil.isBlank(name)) {
    return cache.get(Constants.IRONFAN);
  }
  if (cache.containsKey(name)) {
    return cache.get(name);
  }
  AppManagerEntity appManagerEntity=appManagerService.findAppManagerByName(name);
  if (appManagerEntity == null) {
    logger.error(""String_Node_Str"" + name);
    throw SoftwareManagerCollectorException.APPMANAGER_NOT_FOUND(name);
  }
 else {
    return loadSoftwareManager(appManagerEntity);
  }
}","/** 
 * Get software manager instance
 * @param name
 * @return null if the name does not exist
 */
public SoftwareManager getSoftwareManager(String name){
  if (CommonUtil.isBlank(name)) {
    return cache.get(Constants.IRONFAN);
  }
  AppManagerEntity appManagerEntity=appManagerService.findAppManagerByName(name);
  if (appManagerEntity == null) {
    logger.error(""String_Node_Str"" + name);
    throw SoftwareManagerCollectorException.APPMANAGER_NOT_FOUND(name);
  }
 else {
    String appMgrType=appManagerEntity.getType();
    if (!appMgrType.equals(Constants.IRONFAN)) {
      checkServerConnection(name,appManagerEntity.getUrl());
    }
    if (cache.containsKey(name)) {
      return cache.get(name);
    }
    return loadSoftwareManager(appManagerEntity);
  }
}"
48462,"/** 
 * wrap cache hit, instantiate, connection check and cache add together to simplify currency issue
 * @param appManagerAdd
 * @return
 */
protected synchronized SoftwareManager loadSoftwareManager(AppManagerAdd appManagerAdd){
  if (cache.containsKey(appManagerAdd.getName())) {
    return cache.get(appManagerAdd);
  }
  String factoryClassName=Configuration.getString(configurationPrefix + appManagerAdd.getType());
  if (CommonUtil.isBlank(factoryClassName)) {
    String errMsg=String.format(Messages.getString(""String_Node_Str""),appManagerAdd.getType());
    logger.error(errMsg);
    throw new SWMgrCollectorInternalException(null,errMsg);
  }
  logger.info(""String_Node_Str"" + factoryClassName);
  SoftwareManagerFactory softwareManagerFactory=null;
  try {
    Class<? extends SoftwareManagerFactory> clazz=ReflectionUtils.getClass(factoryClassName,SoftwareManagerFactory.class);
    logger.info(""String_Node_Str"");
    softwareManagerFactory=ReflectionUtils.newInstance(clazz);
  }
 catch (  Exception e) {
    String errMsg=String.format(Messages.getString(""String_Node_Str""),factoryClassName);
    logger.error(errMsg,e);
    throw new SWMgrCollectorInternalException(e,errMsg);
  }
  checkServerConnection(appManagerAdd.getName(),appManagerAdd.getUrl());
  logger.info(""String_Node_Str"");
  SoftwareManager softwareManager=null;
  try {
    softwareManager=softwareManagerFactory.getSoftwareManager(appManagerAdd.getUrl(),appManagerAdd.getUsername(),appManagerAdd.getPassword().toCharArray(),getPrivateKey());
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"" + ex.getMessage(),ex);
    throw SoftwareManagerCollectorException.CONNECT_FAILURE(appManagerAdd.getName(),ExceptionUtils.getRootCauseMessage(ex));
  }
  validateSoftwareManager(appManagerAdd.getName(),softwareManager);
  logger.info(""String_Node_Str"" + appManagerAdd.getName() + ""String_Node_Str"");
  cache.put(appManagerAdd.getName(),softwareManager);
  return softwareManager;
}","/** 
 * wrap cache hit, instantiate, connection check and cache add together to simplify currency issue
 * @param appManagerAdd
 * @return
 */
protected synchronized SoftwareManager loadSoftwareManager(AppManagerAdd appManagerAdd){
  String appMgrType=appManagerAdd.getType();
  String name=appManagerAdd.getName();
  if (!appMgrType.equals(Constants.IRONFAN)) {
    checkServerConnection(name,appManagerAdd.getUrl());
  }
  if (cache.containsKey(appManagerAdd.getName())) {
    return cache.get(appManagerAdd);
  }
  String factoryClassName=Configuration.getString(configurationPrefix + appManagerAdd.getType());
  if (CommonUtil.isBlank(factoryClassName)) {
    String errMsg=String.format(Messages.getString(""String_Node_Str""),appManagerAdd.getType());
    logger.error(errMsg);
    throw new SWMgrCollectorInternalException(null,errMsg);
  }
  logger.info(""String_Node_Str"" + factoryClassName);
  SoftwareManagerFactory softwareManagerFactory=null;
  try {
    Class<? extends SoftwareManagerFactory> clazz=ReflectionUtils.getClass(factoryClassName,SoftwareManagerFactory.class);
    logger.info(""String_Node_Str"");
    softwareManagerFactory=ReflectionUtils.newInstance(clazz);
  }
 catch (  Exception e) {
    String errMsg=String.format(Messages.getString(""String_Node_Str""),factoryClassName);
    logger.error(errMsg,e);
    throw new SWMgrCollectorInternalException(e,errMsg);
  }
  logger.info(""String_Node_Str"");
  SoftwareManager softwareManager=null;
  try {
    softwareManager=softwareManagerFactory.getSoftwareManager(appManagerAdd.getUrl(),appManagerAdd.getUsername(),appManagerAdd.getPassword().toCharArray(),getPrivateKey());
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"" + ex.getMessage(),ex);
    throw SoftwareManagerCollectorException.CONNECT_FAILURE(appManagerAdd.getName(),ExceptionUtils.getRootCauseMessage(ex));
  }
  validateSoftwareManager(appManagerAdd.getName(),softwareManager);
  logger.info(""String_Node_Str"" + appManagerAdd.getName() + ""String_Node_Str"");
  cache.put(appManagerAdd.getName(),softwareManager);
  return softwareManager;
}"
48463,"@Override public Boolean call() throws Exception {
  try {
    new Socket(host,port);
    return true;
  }
 catch (  UnknownHostException e) {
    throw e;
  }
catch (  IOException e) {
    throw e;
  }
}","@Override public String call() throws Exception {
  return softwareManager.getVersion();
}"
48464,"/** 
 * @param name
 * @param urlStr
 */
private void checkServerConnection(String name,String urlStr){
  URL url=null;
  try {
    url=new URL(urlStr);
  }
 catch (  MalformedURLException e) {
    logger.error(""String_Node_Str"" + e.getMessage());
    throw SoftwareManagerCollectorException.CONNECT_FAILURE(name,e.getMessage());
  }
  final String host=url.getHost();
  final int port=url.getPort();
  logger.info(""String_Node_Str"");
  try {
    ExecutorService exec=Executors.newFixedThreadPool(1);
    Future<Boolean> futureResult=exec.submit(new Callable<Boolean>(){
      @Override public Boolean call() throws Exception {
        try {
          new Socket(host,port);
          return true;
        }
 catch (        UnknownHostException e) {
          throw e;
        }
catch (        IOException e) {
          throw e;
        }
      }
    }
);
    waitForThreadResult(futureResult);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + name + ""String_Node_Str"",e);
    throw SoftwareManagerCollectorException.CONNECT_FAILURE(name,e.getMessage());
  }
}","/** 
 * @param appMgrName
 * @param urlStr
 */
private void checkServerConnection(String appMgrName,String urlStr){
  URL url=null;
  try {
    url=new URL(urlStr);
  }
 catch (  MalformedURLException e) {
    logger.error(""String_Node_Str"" + e.getMessage());
    throw SoftwareManagerCollectorException.CONNECT_FAILURE(appMgrName,e.getMessage());
  }
  final String host=url.getHost();
  final int port=url.getPort();
  logger.info(""String_Node_Str"");
  boolean connectOK=CommonUtil.checkServerConnection(host,port,waitTimeForAppMgrConn);
  if (!connectOK) {
    logger.error(""String_Node_Str"" + appMgrName + ""String_Node_Str"");
    throw SoftwareManagerCollectorException.CONNECT_FAILURE(appMgrName,""String_Node_Str"");
  }
}"
48465,"@Transactional @RetryTransaction public void updateNodeAction(NodeEntity node,String action){
  if (node.needUpgrade(getServerVersion()) && node.canBeUpgrade()) {
    nodeDao.updateAction(node.getMoId(),action);
  }
}","@Transactional @RetryTransaction public void updateNodeAction(NodeEntity node,String action){
  node=getNodeWithNicsByMobId(node.getMoId());
  node.setAction(action);
  node.setActionFailed(false);
  node.setErrMessage(null);
  update(node);
}"
48466,"public Long upgradeClusterByName(String clusterName) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (!clusterEntityMgr.needUpgrade(clusterName)) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw ClusterManagerException.ALREADY_LATEST_VERSION_ERROR(clusterName);
  }
  if (!cluster.getStatus().isStableStatus()) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.UPGRADE_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.UPGRADE_ERROR.name()));
  JobParameters jobParameters=new JobParameters(param);
  clusterEntityMgr.storeClusterLastStatus(clusterName);
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.UPGRADING);
  clusterEntityMgr.updateNodesAction(clusterName,Constants.NODE_ACTION_UPGRADING);
  clusterEntityMgr.cleanupErrorForClusterUpgrade(clusterName);
  try {
    return jobManager.runJob(JobConstants.UPGRADE_CLUSTER_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    cluster=clusterEntityMgr.findByName(clusterName);
    if (cluster != null) {
      clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.UPGRADE_ERROR);
    }
    throw e;
  }
}","public Long upgradeClusterByName(String clusterName) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (!clusterEntityMgr.needUpgrade(clusterName)) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw ClusterManagerException.ALREADY_LATEST_VERSION_ERROR(clusterName);
  }
  if (!cluster.getStatus().isStableStatus()) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.UPGRADE_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.UPGRADE_ERROR.name()));
  JobParameters jobParameters=new JobParameters(param);
  clusterEntityMgr.storeClusterLastStatus(clusterName);
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.UPGRADING);
  clusterEntityMgr.updateNodesActionForUpgrade(clusterName,Constants.NODE_ACTION_UPGRADING);
  clusterEntityMgr.cleanupErrorForClusterUpgrade(clusterName);
  try {
    return jobManager.runJob(JobConstants.UPGRADE_CLUSTER_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    cluster=clusterEntityMgr.findByName(clusterName);
    if (cluster != null) {
      clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.UPGRADE_ERROR);
    }
    throw e;
  }
}"
48467,"public boolean setPasswordForNodes(String clusterName,List<NodeEntity> nodes,String password){
  AuAssert.check(!nodes.isEmpty());
  logger.info(""String_Node_Str"" + clusterName);
  ArrayList<String> ipsOfNodes=VcVmUtil.getNodePrimaryMgtIPV4sFromEntitys(nodes);
  logger.info(""String_Node_Str"" + ipsOfNodes.toString());
  boolean succeed=true;
  List<Callable<Void>> storeProcedures=new ArrayList<Callable<Void>>();
  for (  NodeEntity node : nodes) {
    SetVMPasswordSP setVMPasswordSP=new SetVMPasswordSP(node,password);
    storeProcedures.add(setVMPasswordSP);
  }
  AuAssert.check(!storeProcedures.isEmpty());
  try {
    Callable<Void>[] storeProceduresArray=storeProcedures.toArray(new Callable[0]);
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProceduresArray,callback);
    for (int i=0; i < storeProceduresArray.length; i++) {
      SetVMPasswordSP sp=(SetVMPasswordSP)storeProceduresArray[i];
      NodeEntity node=sp.getNodeEntity();
      String vmNameWithIP=node.getVmNameWithIP();
      if (result[i].finished && result[i].throwable == null) {
        updateNodeData(node,true,null,null);
        logger.info(""String_Node_Str"" + vmNameWithIP);
      }
      if (!result[i].finished || result[i].throwable != null) {
        succeed=false;
        if (result[i].throwable != null) {
          String errMsg=result[i].throwable.getMessage();
          updateNodeData(node,false,errMsg,CommonUtil.getCurrentTimestamp());
          logger.error(""String_Node_Str"" + vmNameWithIP + ""String_Node_Str""+ errMsg);
        }
      }
    }
  }
 catch (  Exception e) {
    String errMsg=""String_Node_Str"" + e.getMessage();
    logger.error(""String_Node_Str"" + clusterName,e);
    throw SetPasswordException.FAIL_TO_SET_PASSWORD(""String_Node_Str"" + clusterName,errMsg);
  }
  return succeed;
}","public boolean setPasswordForNodes(String clusterName,List<NodeEntity> nodes,String password){
  AuAssert.check(!nodes.isEmpty());
  logger.info(""String_Node_Str"" + clusterName);
  ArrayList<String> ipsOfNodes=VcVmUtil.getNodePrimaryMgtIPV4sFromEntitys(nodes);
  logger.info(""String_Node_Str"" + ipsOfNodes.toString());
  boolean succeed=true;
  List<Callable<Void>> storeProcedures=new ArrayList<Callable<Void>>();
  for (  NodeEntity node : nodes) {
    SetVMPasswordSP setVMPasswordSP=new SetVMPasswordSP(node,password);
    storeProcedures.add(setVMPasswordSP);
    clusterEntityMgr.updateNodeAction(node,Constants.NODE_ACTION_SETTING_PASSWORD);
  }
  AuAssert.check(!storeProcedures.isEmpty());
  try {
    Callable<Void>[] storeProceduresArray=storeProcedures.toArray(new Callable[0]);
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProceduresArray,callback);
    for (int i=0; i < storeProceduresArray.length; i++) {
      SetVMPasswordSP sp=(SetVMPasswordSP)storeProceduresArray[i];
      NodeEntity node=sp.getNodeEntity();
      String vmNameWithIP=node.getVmNameWithIP();
      if (result[i].finished && result[i].throwable == null) {
        updateNodeData(node,true,null,null);
        logger.info(""String_Node_Str"" + vmNameWithIP);
      }
      if (!result[i].finished || result[i].throwable != null) {
        succeed=false;
        if (result[i].throwable != null) {
          String errMsg=result[i].throwable.getMessage();
          updateNodeData(node,false,errMsg,CommonUtil.getCurrentTimestamp());
          logger.error(""String_Node_Str"" + vmNameWithIP + ""String_Node_Str""+ errMsg);
        }
      }
    }
  }
 catch (  Exception e) {
    String errMsg=""String_Node_Str"" + e.getMessage();
    logger.error(""String_Node_Str"" + clusterName,e);
    throw SetPasswordException.FAIL_TO_SET_PASSWORD(""String_Node_Str"" + clusterName,errMsg);
  }
  return succeed;
}"
48468,"@Override public boolean setPasswordForNode(String clusterName,NodeEntity node,String password){
  AuAssert.check(clusterName != null && node != null);
  SetVMPasswordSP setVMPasswordSP=new SetVMPasswordSP(node,password);
  String vmNameWithIP=node.getVmNameWithIP();
  try {
    if (setVMPasswordSP.setPasswordForNode()) {
      updateNodeData(node,true,null,null);
      logger.info(""String_Node_Str"" + vmNameWithIP + ""String_Node_Str"");
      return true;
    }
    logger.error(""String_Node_Str"");
    return false;
  }
 catch (  Exception e) {
    String errMsg=(e.getCause() == null ? e.getMessage() : e.getCause().getMessage());
    updateNodeData(node,false,errMsg,CommonUtil.getCurrentTimestamp());
    logger.error(""String_Node_Str"" + vmNameWithIP + ""String_Node_Str"",e);
    return false;
  }
}","@Override public boolean setPasswordForNode(String clusterName,NodeEntity node,String password){
  AuAssert.check(clusterName != null && node != null);
  SetVMPasswordSP setVMPasswordSP=new SetVMPasswordSP(node,password);
  String vmNameWithIP=node.getVmNameWithIP();
  try {
    clusterEntityMgr.updateNodeAction(node,Constants.NODE_ACTION_SETTING_PASSWORD);
    if (setVMPasswordSP.setPasswordForNode()) {
      updateNodeData(node,true,null,null);
      logger.info(""String_Node_Str"" + vmNameWithIP + ""String_Node_Str"");
      return true;
    }
    logger.error(""String_Node_Str"");
    return false;
  }
 catch (  Exception e) {
    String errMsg=(e.getCause() == null ? e.getMessage() : e.getCause().getMessage());
    updateNodeData(node,false,errMsg,CommonUtil.getCurrentTimestamp());
    logger.error(""String_Node_Str"" + vmNameWithIP + ""String_Node_Str"",e);
    return false;
  }
}"
48469,"private void upgradeNode(NodeEntity node){
  ClusterUpgradeService upgradeService=new ClusterUpgradeService();
  upgradeService.setClusterEntityMgr(clusterEntityMgr);
  String serverVersion=clusterEntityMgr.getServerVersion();
  String vmName=node.getVmName();
  if (node.needUpgrade(serverVersion) && node.canBeUpgrade()) {
    logger.debug(""String_Node_Str"" + vmName + ""String_Node_Str"");
    clusterEntityMgr.updateNodeAction(node,Constants.NODE_ACTION_UPGRADING);
    NodeUpgradeSP nodeUpgrade=new NodeUpgradeSP(node,serverVersion);
    try {
      nodeUpgrade.call();
      updateNodeData(node);
    }
 catch (    Exception e) {
      updateNodeData(node,false,e.getMessage());
      throw BddException.UPGRADE(e,e.getMessage());
    }
  }
}","private void upgradeNode(NodeEntity node){
  ClusterUpgradeService upgradeService=new ClusterUpgradeService();
  upgradeService.setClusterEntityMgr(clusterEntityMgr);
  String serverVersion=clusterEntityMgr.getServerVersion();
  String vmName=node.getVmName();
  if (node.needUpgrade(serverVersion) && node.canBeUpgrade()) {
    logger.debug(""String_Node_Str"" + vmName + ""String_Node_Str"");
    clusterEntityMgr.updateNodeActionForUpgrade(node,Constants.NODE_ACTION_UPGRADING);
    NodeUpgradeSP nodeUpgrade=new NodeUpgradeSP(node,serverVersion);
    try {
      nodeUpgrade.call();
      updateNodeData(node);
    }
 catch (    Exception e) {
      updateNodeData(node,false,e.getMessage());
      throw BddException.UPGRADE(e,e.getMessage());
    }
  }
}"
48470,"public CmClusterDef(ClusterBlueprint blueprint) throws IOException {
  this.name=blueprint.getName();
  this.displayName=blueprint.getName();
  try {
    String[] distroInfo=blueprint.getHadoopStack().getDistro().split(""String_Node_Str"");
    this.version=distroInfo[0] + (new DefaultArtifactVersion(distroInfo[1])).getMajorVersion();
    this.fullVersion=distroInfo[1];
  }
 catch (  Exception e) {
    this.version=ApiClusterVersion.CDH5.toString();
    this.fullVersion=null;
  }
  this.nodes=new ArrayList<CmNodeDef>();
  this.services=new ArrayList<CmServiceDef>();
  this.currentReport=new ClusterReport(blueprint);
  this.failoverEnabled=isFailoverEnabled(blueprint);
  Integer zkIdIndex=1;
  Integer nameServiceIndex=0;
  boolean hasImpala=false;
  for (  NodeGroupInfo group : blueprint.getNodeGroups()) {
    boolean alreadyHasActive=false;
    for (    NodeInfo node : group.getNodes()) {
      CmNodeDef nodeDef=new CmNodeDef();
      nodeDef.setIpAddress(node.getMgtIpAddress());
      nodeDef.setFqdn(node.getMgtIpAddress());
      nodeDef.setName(node.getName());
      nodeDef.setRackId(node.getRack());
      nodeDef.setNodeId(node.getName());
      nodeDef.setConfigs(null);
      this.nodes.add(nodeDef);
      for (      String type : group.getRoles()) {
        AvailableServiceRole roleType=AvailableServiceRoleContainer.load(type);
        AvailableServiceRole serviceType=roleType.getParent();
        if (serviceType.getDisplayName().equals(""String_Node_Str"")) {
          hasImpala=true;
        }
        CmServiceDef service=serviceDefOfType(serviceType,blueprint.getConfiguration());
        CmRoleDef roleDef=new CmRoleDef();
        roleDef.setName(node.getName() + NAME_SEPARATOR + service.getType().getName()+ NAME_SEPARATOR+ roleType.getName());
        roleDef.setDisplayName(roleDef.getName());
        roleDef.setType(roleType);
        roleDef.setNodeRef(nodeDef.getNodeId());
switch (roleType.getDisplayName()) {
case ""String_Node_Str"":
          roleDef.addConfig(Constants.CONFIG_DFS_NAME_DIR_LIST,dataDirs(node.getVolumes(),""String_Node_Str""));
        if (failoverEnabled) {
          if (!alreadyHasActive) {
            nameServiceIndex++;
          }
          roleDef.addConfig(Constants.CONFIG_AUTO_FAILOVER_ENABLED,""String_Node_Str"");
          roleDef.addConfig(Constants.CONFIG_DFS_FEDERATION_NAMESERVICE,""String_Node_Str"" + nameServiceIndex.toString());
          roleDef.addConfig(Constants.CONFIG_DFS_NAMENODE_QUORUM_JOURNAL_NAME,""String_Node_Str"" + nameServiceIndex.toString());
          roleDef.setActive(!alreadyHasActive);
          if (!group.getRoles().contains(""String_Node_Str"")) {
            CmRoleDef failoverRole=new CmRoleDef();
            AvailableServiceRole failoverRoleType=AvailableServiceRoleContainer.load(""String_Node_Str"");
            failoverRole.setName(node.getName() + NAME_SEPARATOR + service.getType().getName()+ NAME_SEPARATOR+ failoverRoleType.getName());
            failoverRole.setType(failoverRoleType);
            failoverRole.setNodeRef(nodeDef.getNodeId());
            failoverRole.addConfigs(blueprint.getConfiguration());
            failoverRole.addConfigs(group.getConfiguration());
            failoverRole.setActive(!alreadyHasActive);
            service.addRole(failoverRole);
          }
          alreadyHasActive=true;
        }
      break;
case ""String_Node_Str"":
    roleDef.setActive(!alreadyHasActive);
  break;
case ""String_Node_Str"":
roleDef.addConfig(Constants.CONFIG_DFS_DATA_DIR_LIST,dataDirs(node.getVolumes(),""String_Node_Str""));
break;
case ""String_Node_Str"":
roleDef.addConfig(Constants.CONFIG_DFS_JOURNALNODE_EDITS_DIR,node.getVolumes().get(0) + ""String_Node_Str"");
break;
case ""String_Node_Str"":
roleDef.addConfig(Constants.CONFIG_FS_CHECKPOINT_DIR_LIST,dataDirs(node.getVolumes(),""String_Node_Str""));
break;
case ""String_Node_Str"":
roleDef.addConfig(Constants.CONFIG_NM_LOCAL_DIRS,dataDirs(node.getVolumes(),""String_Node_Str""));
break;
case ""String_Node_Str"":
roleDef.addConfig(Constants.CONFIG_MAPRED_JT_LOCAL_DIR_LIST,dataDirs(node.getVolumes(),""String_Node_Str""));
break;
case ""String_Node_Str"":
roleDef.addConfig(Constants.CONFIG_MAPRED_TT_LOCAL_DIR_LIST,dataDirs(node.getVolumes(),""String_Node_Str""));
break;
case ""String_Node_Str"":
roleDef.addConfig(Constants.CONFIG_ZOOKEEPER_SERVER_ID,zkIdIndex.toString());
zkIdIndex+=1;
break;
case ""String_Node_Str"":
roleDef.addConfig(Constants.CONFIG_SQOOP_METASTORE_DATA_DIR,node.getVolumes().get(0) + ""String_Node_Str"");
break;
default :
break;
}
roleDef.addConfigs(blueprint.getConfiguration());
roleDef.addConfigs(group.getConfiguration());
service.addRole(roleDef);
}
}
if (hasImpala) {
for (CmServiceDef serviceDef : services) {
if (serviceDef.getType().getDisplayName().equals(""String_Node_Str"")) {
serviceDef.addConfig(""String_Node_Str"",""String_Node_Str"");
for (CmRoleDef roleDef : serviceDef.getRoles()) {
if (roleDef.getType().getDisplayName().equals(""String_Node_Str"")) {
roleDef.addConfig(""String_Node_Str"",""String_Node_Str"");
}
}
break;
}
}
}
}
}","public CmClusterDef(ClusterBlueprint blueprint) throws IOException {
  this.name=blueprint.getName();
  this.displayName=blueprint.getName();
  try {
    String[] distroInfo=blueprint.getHadoopStack().getDistro().split(""String_Node_Str"");
    this.version=distroInfo[0] + (new DefaultArtifactVersion(distroInfo[1])).getMajorVersion();
    this.fullVersion=distroInfo[1];
  }
 catch (  Exception e) {
    this.version=ApiClusterVersion.CDH5.toString();
    this.fullVersion=null;
  }
  this.nodes=new ArrayList<CmNodeDef>();
  this.services=new ArrayList<CmServiceDef>();
  this.currentReport=new ClusterReport(blueprint);
  this.failoverEnabled=isFailoverEnabled(blueprint);
  Integer zkIdIndex=1;
  Integer nameServiceIndex=0;
  boolean hasImpala=false;
  for (  NodeGroupInfo group : blueprint.getNodeGroups()) {
    boolean alreadyHasActive=false;
    for (    NodeInfo node : group.getNodes()) {
      CmNodeDef nodeDef=new CmNodeDef();
      nodeDef.setIpAddress(node.getMgtIpAddress());
      nodeDef.setFqdn(node.getMgtIpAddress());
      nodeDef.setName(node.getName());
      nodeDef.setRackId(node.getRack());
      nodeDef.setNodeId(node.getName());
      nodeDef.setConfigs(null);
      this.nodes.add(nodeDef);
      for (      String type : group.getRoles()) {
        AvailableServiceRole roleType=AvailableServiceRoleContainer.load(type);
        AvailableServiceRole serviceType=roleType.getParent();
        if (serviceType.getDisplayName().equals(""String_Node_Str"")) {
          hasImpala=true;
        }
        CmServiceDef service=serviceDefOfType(serviceType,blueprint.getConfiguration());
        CmRoleDef roleDef=new CmRoleDef();
        roleDef.setName(node.getName() + NAME_SEPARATOR + service.getType().getName()+ NAME_SEPARATOR+ roleType.getName());
        roleDef.setDisplayName(roleDef.getName());
        roleDef.setType(roleType);
        roleDef.setNodeRef(nodeDef.getNodeId());
switch (roleType.getDisplayName()) {
case ""String_Node_Str"":
          roleDef.addConfig(Constants.CONFIG_DFS_NAME_DIR_LIST,dataDirs(node.getVolumes(),""String_Node_Str""));
        if (failoverEnabled) {
          if (!alreadyHasActive) {
            nameServiceIndex++;
          }
          roleDef.addConfig(Constants.CONFIG_AUTO_FAILOVER_ENABLED,""String_Node_Str"");
          roleDef.addConfig(Constants.CONFIG_DFS_FEDERATION_NAMESERVICE,""String_Node_Str"" + nameServiceIndex.toString());
          roleDef.addConfig(Constants.CONFIG_DFS_NAMENODE_QUORUM_JOURNAL_NAME,""String_Node_Str"" + nameServiceIndex.toString());
          roleDef.setActive(!alreadyHasActive);
          if (!group.getRoles().contains(""String_Node_Str"")) {
            CmRoleDef failoverRole=new CmRoleDef();
            AvailableServiceRole failoverRoleType=AvailableServiceRoleContainer.load(""String_Node_Str"");
            failoverRole.setName(node.getName() + NAME_SEPARATOR + service.getType().getName()+ NAME_SEPARATOR+ failoverRoleType.getName());
            failoverRole.setType(failoverRoleType);
            failoverRole.setNodeRef(nodeDef.getNodeId());
            failoverRole.addConfigs(blueprint.getConfiguration());
            failoverRole.addConfigs(group.getConfiguration());
            failoverRole.setActive(!alreadyHasActive);
            service.addRole(failoverRole);
          }
          alreadyHasActive=true;
        }
      break;
case ""String_Node_Str"":
    roleDef.setActive(!alreadyHasActive);
  break;
case ""String_Node_Str"":
roleDef.addConfig(Constants.CONFIG_DFS_DATA_DIR_LIST,dataDirs(node.getVolumes(),""String_Node_Str""));
break;
case ""String_Node_Str"":
if (!node.getVolumes().isEmpty()) {
roleDef.addConfig(Constants.CONFIG_DFS_JOURNALNODE_EDITS_DIR,node.getVolumes().get(0) + ""String_Node_Str"");
}
 else {
logger.warn(""String_Node_Str"" + node.getName());
}
break;
case ""String_Node_Str"":
roleDef.addConfig(Constants.CONFIG_FS_CHECKPOINT_DIR_LIST,dataDirs(node.getVolumes(),""String_Node_Str""));
break;
case ""String_Node_Str"":
roleDef.addConfig(Constants.CONFIG_NM_LOCAL_DIRS,dataDirs(node.getVolumes(),""String_Node_Str""));
break;
case ""String_Node_Str"":
roleDef.addConfig(Constants.CONFIG_MAPRED_JT_LOCAL_DIR_LIST,dataDirs(node.getVolumes(),""String_Node_Str""));
break;
case ""String_Node_Str"":
roleDef.addConfig(Constants.CONFIG_MAPRED_TT_LOCAL_DIR_LIST,dataDirs(node.getVolumes(),""String_Node_Str""));
break;
case ""String_Node_Str"":
roleDef.addConfig(Constants.CONFIG_ZOOKEEPER_SERVER_ID,zkIdIndex.toString());
zkIdIndex+=1;
break;
case ""String_Node_Str"":
roleDef.addConfig(Constants.CONFIG_SQOOP_METASTORE_DATA_DIR,node.getVolumes().get(0) + ""String_Node_Str"");
break;
default :
break;
}
roleDef.addConfigs(blueprint.getConfiguration());
roleDef.addConfigs(group.getConfiguration());
service.addRole(roleDef);
}
}
if (hasImpala) {
for (CmServiceDef serviceDef : services) {
if (serviceDef.getType().getDisplayName().equals(""String_Node_Str"")) {
serviceDef.addConfig(""String_Node_Str"",""String_Node_Str"");
for (CmRoleDef roleDef : serviceDef.getRoles()) {
if (roleDef.getType().getDisplayName().equals(""String_Node_Str"")) {
roleDef.addConfig(""String_Node_Str"",""String_Node_Str"");
}
}
break;
}
}
}
}
}"
48471,"private boolean stopServices(ClusterBlueprint clusterBlueprint,ClusterReportQueue reportQueue) throws SoftwareManagementPluginException {
  assert(clusterBlueprint != null && clusterBlueprint.getName() != null && !clusterBlueprint.getName().isEmpty());
  String clusterName=clusterBlueprint.getName();
  CmClusterDef clusterDef=null;
  ClusterReport report=null;
  boolean succeed=false;
  try {
    clusterDef=new CmClusterDef(clusterBlueprint);
    report=clusterDef.getCurrentReport();
    if (isStopped(clusterName) || !needStop(clusterName)) {
      succeed=true;
      return true;
    }
    executeAndReport(""String_Node_Str"",apiResourceRootV6.getClustersResource().stopCommand(clusterName),ProgressSplit.STOP_SERVICES.getProgress(),report,reportQueue,true);
    succeed=true;
    return true;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    report.setClusterAndNodesServiceStatus(ServiceStatus.STOP_FAILED);
    HashMap<String,Set<String>> unstoppedRoles=getFailedRoles(clusterName,ApiRoleState.STOPPED);
    setRolesErrorMsg(report,unstoppedRoles,""String_Node_Str"");
    throw SoftwareManagementPluginException.STOP_CLUSTER_EXCEPTION(e,Constants.CDH_PLUGIN_NAME,clusterBlueprint.getName());
  }
 finally {
    if (clusterDef != null) {
      if (succeed) {
        report.setClusterAndNodesServiceStatus(ServiceStatus.STOPPED);
        report.setProgress(ProgressSplit.STOP_SERVICES.getProgress());
        logger.info(""String_Node_Str"");
      }
      report.setClusterAndNodesAction(""String_Node_Str"");
      report.setFinished(true);
      report.setSuccess(succeed);
      reportQueue.addClusterReport(report.clone());
    }
  }
}","private boolean stopServices(ClusterBlueprint clusterBlueprint,ClusterReportQueue reportQueue) throws SoftwareManagementPluginException {
  assert(clusterBlueprint != null && clusterBlueprint.getName() != null && !clusterBlueprint.getName().isEmpty());
  String clusterName=clusterBlueprint.getName();
  CmClusterDef clusterDef=null;
  ClusterReport report=null;
  boolean succeed=false;
  try {
    if (!isProvisioned(clusterName)) {
      return true;
    }
    clusterDef=new CmClusterDef(clusterBlueprint);
    report=clusterDef.getCurrentReport();
    if (isStopped(clusterName) || !needStop(clusterName)) {
      succeed=true;
      return true;
    }
    executeAndReport(""String_Node_Str"",apiResourceRootV6.getClustersResource().stopCommand(clusterName),ProgressSplit.STOP_SERVICES.getProgress(),report,reportQueue,true);
    succeed=true;
    return true;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    report.setClusterAndNodesServiceStatus(ServiceStatus.STOP_FAILED);
    HashMap<String,Set<String>> unstoppedRoles=getFailedRoles(clusterName,ApiRoleState.STOPPED);
    setRolesErrorMsg(report,unstoppedRoles,""String_Node_Str"");
    throw SoftwareManagementPluginException.STOP_CLUSTER_EXCEPTION(e,Constants.CDH_PLUGIN_NAME,clusterBlueprint.getName());
  }
 finally {
    if (clusterDef != null) {
      if (succeed) {
        report.setClusterAndNodesServiceStatus(ServiceStatus.STOPPED);
        report.setProgress(ProgressSplit.STOP_SERVICES.getProgress());
        logger.info(""String_Node_Str"");
      }
      report.setClusterAndNodesAction(""String_Node_Str"");
      report.setFinished(true);
      report.setSuccess(succeed);
      reportQueue.addClusterReport(report.clone());
    }
  }
}"
48472,"/** 
 * @param name
 * @param softwareManager
 */
private void validateSoftwareManager(String name,final SoftwareManager softwareManager){
  logger.info(""String_Node_Str"");
  try {
    ExecutorService exec=Executors.newFixedThreadPool(1);
    Future<Boolean> futureResult=exec.submit(new Callable<Boolean>(){
      @Override public Boolean call() throws Exception {
        return softwareManager.echo();
      }
    }
);
    boolean gotEcho=false;
    Boolean result=(Boolean)waitForThreadResult(futureResult);
    if (null != result) {
      gotEcho=result;
    }
    exec.shutdown();
    if (!gotEcho) {
      logger.error(""String_Node_Str"" + name + ""String_Node_Str"");
      throw SoftwareManagerCollectorException.ECHO_FAILURE(name);
    }
  }
 catch (  SoftwareManagementPluginException e) {
    logger.error(""String_Node_Str"" + name + ""String_Node_Str"",e);
    throw SoftwareManagerCollectorException.CONNECT_FAILURE(name,e.getMessage());
  }
  validateSoftwareManagerVersion(softwareManager);
}","/** 
 * @param name
 * @param softwareManager
 */
private void validateSoftwareManager(String name,final SoftwareManager softwareManager){
  logger.info(""String_Node_Str"");
  try {
    if (!softwareManager.echo()) {
      logger.error(""String_Node_Str"" + name + ""String_Node_Str"");
      throw SoftwareManagerCollectorException.ECHO_FAILURE(name);
    }
  }
 catch (  SoftwareManagementPluginException e) {
    logger.error(""String_Node_Str"" + name + ""String_Node_Str"",e);
    throw SoftwareManagerCollectorException.CONNECT_FAILURE(name,e.getMessage());
  }
  validateSoftwareManagerVersion(softwareManager);
}"
48473,"/** 
 * wrap cache hit, instantiate, connection check and cache add together to simplify currency issue
 * @param appManagerAdd
 * @return
 */
protected synchronized SoftwareManager loadSoftwareManager(AppManagerAdd appManagerAdd){
  if (cache.containsKey(appManagerAdd.getName())) {
    return cache.get(appManagerAdd);
  }
  String factoryClassName=Configuration.getString(configurationPrefix + appManagerAdd.getType());
  if (CommonUtil.isBlank(factoryClassName)) {
    String errMsg=String.format(Messages.getString(""String_Node_Str""),appManagerAdd.getType());
    logger.error(errMsg);
    throw new SWMgrCollectorInternalException(null,errMsg);
  }
  logger.info(""String_Node_Str"" + factoryClassName);
  SoftwareManagerFactory softwareManagerFactory=null;
  try {
    Class<? extends SoftwareManagerFactory> clazz=ReflectionUtils.getClass(factoryClassName,SoftwareManagerFactory.class);
    logger.info(""String_Node_Str"");
    softwareManagerFactory=ReflectionUtils.newInstance(clazz);
  }
 catch (  Exception e) {
    String errMsg=String.format(Messages.getString(""String_Node_Str""),factoryClassName);
    logger.error(errMsg,e);
    throw new SWMgrCollectorInternalException(e,errMsg);
  }
  logger.info(""String_Node_Str"");
  SoftwareManager softwareManager=null;
  try {
    softwareManager=softwareManagerFactory.getSoftwareManager(appManagerAdd.getUrl(),appManagerAdd.getUsername(),appManagerAdd.getPassword().toCharArray(),getPrivateKey());
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"" + ex.getMessage(),ex);
    throw SoftwareManagerCollectorException.CONNECT_FAILURE(appManagerAdd.getName(),ExceptionUtils.getRootCauseMessage(ex));
  }
  validateSoftwareManager(appManagerAdd.getName(),softwareManager);
  logger.info(""String_Node_Str"" + appManagerAdd.getName() + ""String_Node_Str"");
  cache.put(appManagerAdd.getName(),softwareManager);
  return softwareManager;
}","/** 
 * wrap cache hit, instantiate, connection check and cache add together to simplify currency issue
 * @param appManagerAdd
 * @return
 */
protected synchronized SoftwareManager loadSoftwareManager(AppManagerAdd appManagerAdd){
  if (cache.containsKey(appManagerAdd.getName())) {
    return cache.get(appManagerAdd);
  }
  String factoryClassName=Configuration.getString(configurationPrefix + appManagerAdd.getType());
  if (CommonUtil.isBlank(factoryClassName)) {
    String errMsg=String.format(Messages.getString(""String_Node_Str""),appManagerAdd.getType());
    logger.error(errMsg);
    throw new SWMgrCollectorInternalException(null,errMsg);
  }
  logger.info(""String_Node_Str"" + factoryClassName);
  SoftwareManagerFactory softwareManagerFactory=null;
  try {
    Class<? extends SoftwareManagerFactory> clazz=ReflectionUtils.getClass(factoryClassName,SoftwareManagerFactory.class);
    logger.info(""String_Node_Str"");
    softwareManagerFactory=ReflectionUtils.newInstance(clazz);
  }
 catch (  Exception e) {
    String errMsg=String.format(Messages.getString(""String_Node_Str""),factoryClassName);
    logger.error(errMsg,e);
    throw new SWMgrCollectorInternalException(e,errMsg);
  }
  checkServerConnection(appManagerAdd.getName(),appManagerAdd.getUrl());
  logger.info(""String_Node_Str"");
  SoftwareManager softwareManager=null;
  try {
    softwareManager=softwareManagerFactory.getSoftwareManager(appManagerAdd.getUrl(),appManagerAdd.getUsername(),appManagerAdd.getPassword().toCharArray(),getPrivateKey());
  }
 catch (  Exception ex) {
    logger.error(""String_Node_Str"" + ex.getMessage(),ex);
    throw SoftwareManagerCollectorException.CONNECT_FAILURE(appManagerAdd.getName(),ExceptionUtils.getRootCauseMessage(ex));
  }
  validateSoftwareManager(appManagerAdd.getName(),softwareManager);
  logger.info(""String_Node_Str"" + appManagerAdd.getName() + ""String_Node_Str"");
  cache.put(appManagerAdd.getName(),softwareManager);
  return softwareManager;
}"
48474,"@Override public String call() throws Exception {
  return softwareManager.getVersion();
}","@Override public Boolean call() throws Exception {
  try {
    new Socket(host,port);
    return true;
  }
 catch (  UnknownHostException e) {
    throw e;
  }
catch (  IOException e) {
    throw e;
  }
}"
48475,"private String loginAndGetSessionTicket(){
  URI sdkUri=null;
  if (!vcExtensionRegistered) {
    return null;
  }
  try {
    sdkUri=new URI(""String_Node_Str"");
  }
 catch (  URISyntaxException e) {
    logger.error(e);
    return null;
  }
  HttpConfigurationImpl httpConfig=new HttpConfigurationImpl();
  httpConfig.setTimeoutMs(SESSION_TIME_OUT);
  httpConfig.setKeyStore(CmsKeyStore.getKeyStore());
  httpConfig.setDefaultProxy(vcHost,80,""String_Node_Str"");
  httpConfig.getKeyStoreConfig().setKeyAlias(CmsKeyStore.VC_EXT_KEY);
  httpConfig.getKeyStoreConfig().setKeyPassword(CmsKeyStore.getVCExtPassword());
  httpConfig.setThumbprintVerifier(getThumbprintVerifier());
  HttpClientConfiguration clientConfig=HttpClientConfiguration.Factory.newInstance();
  clientConfig.setHttpConfiguration(httpConfig);
  Client client=Client.Factory.createClient(sdkUri,version,clientConfig);
  SessionManager sm=null;
  try {
    ManagedObjectReference svcRef=new ManagedObjectReference();
    svcRef.setType(""String_Node_Str"");
    svcRef.setValue(""String_Node_Str"");
    ServiceInstance si=client.createStub(ServiceInstance.class,svcRef);
    sm=client.createStub(SessionManager.class,si.getContent().getSessionManager());
    sm.loginExtensionByCertificate(extKey,""String_Node_Str"");
    String ticket=sm.acquireSessionTicket(null);
    logger.info(""String_Node_Str"");
    return ticket;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    return null;
  }
 finally {
    VcContext.getVcCleaner().logout(""String_Node_Str"",client,sm,executor,httpConfig);
  }
}","private String loginAndGetSessionTicket(){
  URI sdkUri=null;
  if (!vcExtensionRegistered) {
    return null;
  }
  try {
    sdkUri=new URI(""String_Node_Str"");
  }
 catch (  URISyntaxException e) {
    logger.error(e);
    return null;
  }
  HttpConfigurationImpl httpConfig=new HttpConfigurationImpl();
  httpConfig.setTimeoutMs(SESSION_TIME_OUT);
  httpConfig.setKeyStore(CmsKeyStore.getKeyStore());
  httpConfig.setDefaultProxy(vcHost,80,""String_Node_Str"");
  httpConfig.getKeyStoreConfig().setKeyAlias(CmsKeyStore.VC_EXT_KEY);
  httpConfig.getKeyStoreConfig().setKeyPassword(CmsKeyStore.getVCExtPassword());
  httpConfig.setThumbprintVerifier(getThumbprintVerifier());
  HttpClientConfiguration clientConfig=HttpClientConfiguration.Factory.newInstance();
  clientConfig.setHttpConfiguration(httpConfig);
  Client client=Client.Factory.createClient(sdkUri,version,clientConfig);
  SessionManager sm=null;
  try {
    ManagedObjectReference svcRef=new ManagedObjectReference();
    svcRef.setType(""String_Node_Str"");
    svcRef.setValue(""String_Node_Str"");
    ServiceInstance si=client.createStub(ServiceInstance.class,svcRef);
    sm=client.createStub(SessionManager.class,si.getContent().getSessionManager());
    sm.loginExtensionByCertificate(extKey,""String_Node_Str"");
    String ticket=sm.acquireSessionTicket(null);
    logger.info(""String_Node_Str"");
    return ticket;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    return null;
  }
 finally {
    VcContext.getVcCleaner().logout(""String_Node_Str"",client,sm,null,httpConfig);
  }
}"
48476,"/** 
 * This sends a URL POST request to the Extension vService guest API to register a new extension. Upon success, set vcExtensionRegistered to true. Note that the extension will not be fully configured until we log in to VC as this extension and make some VMODL calls to finish the job. Note also that we only need to do this once per CMS install, not once per CMS startup, but it doesn't seem to hurt to do it every time.
 * @synchronized for preventing concurrent call to register EVS.
 */
private static synchronized void registerExtensionVService(){
  if (vcExtensionRegistered) {
    return;
  }
  logger.debug(""String_Node_Str"" + evsURL + ""String_Node_Str""+ evsToken);
  Writer output=null;
  BufferedReader input=null;
  try {
    Certificate cert=CmsKeyStore.getCertificate(CmsKeyStore.VC_EXT_KEY);
    URL url=new URL(evsURL);
    URLConnection connection=url.openConnection();
    connection.setRequestProperty(""String_Node_Str"",evsToken);
    connection.setDoInput(true);
    connection.setDoOutput(true);
    connection.setUseCaches(false);
    output=new OutputStreamWriter(connection.getOutputStream());
    String evsSchema=""String_Node_Str"";
    String payload=""String_Node_Str"" + evsSchema + ""String_Node_Str""+ ""String_Node_Str""+ extKey+ ""String_Node_Str""+ ""String_Node_Str""+ CertificateToPem(cert)+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    output.write(payload);
    output.flush();
    connection.connect();
    Map<String,List<String>> headers=connection.getHeaderFields();
    for (    Map.Entry<String,List<String>> e : headers.entrySet()) {
      for (      String val : e.getValue()) {
        logger.info(""String_Node_Str"" + e.getKey() + ""String_Node_Str""+ val);
      }
    }
    input=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    for (String str=input.readLine(); str != null; str=input.readLine()) {
      logger.debug(""String_Node_Str"" + str);
    }
    vcExtensionRegistered=true;
    Configuration.setBoolean(SERENGETI_EXTENSION_REGISTERED,true);
    Configuration.save();
    logger.debug(""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + evsURL,e);
  }
 finally {
    if (output != null) {
      try {
        output.close();
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"",e);
      }
    }
    if (input != null) {
      try {
        input.close();
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"",e);
      }
    }
  }
}","/** 
 * This sends a URL POST request to the Extension vService guest API to register a new extension. Upon success, set vcExtensionRegistered to true. Note that the extension will not be fully configured until we log in to VC as this extension and make some VMODL calls to finish the job. Note also that we only need to do this once per CMS install, not once per CMS startup, but it doesn't seem to hurt to do it every time.
 * @synchronized for preventing concurrent call to register EVS.
 */
private static synchronized void registerExtensionVService(){
  if (vcExtensionRegistered) {
    return;
  }
  logger.debug(""String_Node_Str"" + evsURL + ""String_Node_Str""+ evsToken);
  Writer output=null;
  BufferedReader input=null;
  try {
    Certificate cert=CmsKeyStore.getCertificate(CmsKeyStore.VC_EXT_KEY);
    URL url=new URL(evsURL);
    URLConnection connection=url.openConnection();
    connection.setRequestProperty(""String_Node_Str"",evsToken);
    connection.setDoInput(true);
    connection.setDoOutput(true);
    connection.setUseCaches(false);
    output=new OutputStreamWriter(connection.getOutputStream());
    String evsSchema=""String_Node_Str"";
    String payload=""String_Node_Str"" + evsSchema + ""String_Node_Str""+ ""String_Node_Str""+ extKey+ ""String_Node_Str""+ ""String_Node_Str""+ CertificateToPem(cert)+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    output.write(payload);
    output.flush();
    connection.connect();
    Map<String,List<String>> headers=connection.getHeaderFields();
    for (    Map.Entry<String,List<String>> e : headers.entrySet()) {
      for (      String val : e.getValue()) {
        logger.info(""String_Node_Str"" + e.getKey() + ""String_Node_Str""+ val);
      }
    }
    input=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    for (String str=input.readLine(); str != null; str=input.readLine()) {
      logger.debug(""String_Node_Str"" + str);
    }
    vcExtensionRegistered=true;
    logger.debug(""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + evsURL,e);
  }
 finally {
    Configuration.setBoolean(SERENGETI_EXTENSION_REGISTERED,true);
    Configuration.save();
    if (output != null) {
      try {
        output.close();
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"",e);
      }
    }
    if (input != null) {
      try {
        input.close();
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"",e);
      }
    }
  }
}"
48477,"/** 
 * Initializes the VC session. Each session gets a separate vmomi client (http session cookie is kept in vmomi client). Result: _serviceInstance & other fields initialized if no exception is thrown.
 */
private void initVcSession() throws VcException {
  try {
    boolean justRegistered=false;
    if (!vcExtensionRegistered) {
      registerExtensionVService();
      justRegistered=true;
    }
    setService(new ServiceContents(++curGenCount),VcConnectionStatusChangeEvent.VC_SESSION_CREATED);
    VcContext.serviceReset(this);
    if (vcExtensionRegistered && justRegistered) {
      configureExtensionVService();
    }
  }
 catch (  Exception ex) {
    if (service != null) {
      service.cleanup();
    }
    setService(null,VcConnectionStatusChangeEvent.VC_SESSION_CREATION_FAILURE);
    if (ex instanceof VcException) {
      throw (VcException)ex;
    }
 else     if (ex instanceof UndeclaredThrowableException) {
      UndeclaredThrowableException e=(UndeclaredThrowableException)ex;
      if (e.getUndeclaredThrowable() instanceof CertificateValidationException) {
        throw VcException.LOGIN_ERROR(e.getUndeclaredThrowable());
      }
    }
 else     if (ex instanceof InternalException) {
      InternalException e=(InternalException)ex;
      if (e.getCause() instanceof CertificateValidationException) {
        throw VcException.LOGIN_ERROR(e.getCause());
      }
    }
    throw VcException.LOGIN_ERROR(ex);
  }
}","/** 
 * Initializes the VC session. Each session gets a separate vmomi client (http session cookie is kept in vmomi client). Result: _serviceInstance & other fields initialized if no exception is thrown.
 */
private void initVcSession() throws VcException {
  try {
    boolean justRegistered=false;
    if (!vcExtensionRegistered) {
      registerExtensionVService();
      justRegistered=true;
    }
    if (vcExtensionRegistered) {
      String ticket=null;
      try {
        ticket=loginAndGetSessionTicket();
      }
 catch (      Exception e) {
        logger.debug(""String_Node_Str"");
      }
      if (ticket == null) {
        logger.info(""String_Node_Str"");
        vcExtensionRegistered=false;
      }
    }
    if (!vcExtensionRegistered) {
      registerExtensionVService();
      justRegistered=true;
    }
    setService(new ServiceContents(++curGenCount),VcConnectionStatusChangeEvent.VC_SESSION_CREATED);
    VcContext.serviceReset(this);
    if (vcExtensionRegistered && justRegistered) {
      configureExtensionVService();
    }
  }
 catch (  Exception ex) {
    if (service != null) {
      service.cleanup();
    }
    setService(null,VcConnectionStatusChangeEvent.VC_SESSION_CREATION_FAILURE);
    if (ex instanceof VcException) {
      throw (VcException)ex;
    }
 else     if (ex instanceof UndeclaredThrowableException) {
      UndeclaredThrowableException e=(UndeclaredThrowableException)ex;
      if (e.getUndeclaredThrowable() instanceof CertificateValidationException) {
        throw VcException.LOGIN_ERROR(e.getUndeclaredThrowable());
      }
    }
 else     if (ex instanceof InternalException) {
      InternalException e=(InternalException)ex;
      if (e.getCause() instanceof CertificateValidationException) {
        throw VcException.LOGIN_ERROR(e.getCause());
      }
    }
    throw VcException.LOGIN_ERROR(ex);
  }
}"
48478,"public AmClusterDef(ClusterBlueprint blueprint,String privateKey){
  this.name=blueprint.getName();
  this.version=blueprint.getHadoopStack().getFullVersion();
  this.verbose=true;
  this.sshKey=privateKey;
  this.user=Constants.AMBARI_SSH_USER;
  this.currentReport=new ClusterReport(blueprint);
  this.configurations=AmUtils.toAmConfigurations(blueprint.getConfiguration());
  this.nodes=new ArrayList<AmNodeDef>();
  HdfsVersion hdfs=getDefaultHdfsVersion(this.version);
  for (  NodeGroupInfo group : blueprint.getNodeGroups()) {
    for (    NodeInfo node : group.getNodes()) {
      AmNodeDef nodeDef=new AmNodeDef();
      nodeDef.setName(node.getName());
      nodeDef.setIp(node.getMgtIpAddress());
      nodeDef.setFqdn(node.getHostname());
      nodeDef.setRackInfo(node.getRack());
      nodeDef.setConfigurations(AmUtils.toAmConfigurations(group.getConfiguration()));
      nodeDef.setComponents(group.getRoles());
      nodeDef.setVolumns(node.getVolumes(),hdfs);
      this.nodes.add(nodeDef);
    }
  }
  AmStackDef stackDef=new AmStackDef();
  stackDef.setName(blueprint.getHadoopStack().getVendor());
  stackDef.setVersion(blueprint.getHadoopStack().getFullVersion());
  this.amStack=stackDef;
}","public AmClusterDef(ClusterBlueprint blueprint,String privateKey,String ambariServerVersion){
  this.name=blueprint.getName();
  this.version=blueprint.getHadoopStack().getFullVersion();
  this.verbose=true;
  this.sshKey=privateKey;
  this.user=Constants.AMBARI_SSH_USER;
  this.currentReport=new ClusterReport(blueprint);
  this.configurations=AmUtils.toAmConfigurations(blueprint.getConfiguration());
  this.nodes=new ArrayList<AmNodeDef>();
  HdfsVersion hdfs=getDefaultHdfsVersion(this.version);
  for (  NodeGroupInfo group : blueprint.getNodeGroups()) {
    for (    NodeInfo node : group.getNodes()) {
      AmNodeDef nodeDef=new AmNodeDef();
      nodeDef.setName(node.getName());
      nodeDef.setIp(node.getMgtIpAddress());
      nodeDef.setFqdn(node.getHostname());
      nodeDef.setRackInfo(node.getRack());
      nodeDef.setConfigurations(AmUtils.toAmConfigurations(group.getConfiguration()));
      nodeDef.setComponents(group.getRoles());
      nodeDef.setVolumns(node.getVolumes(),hdfs,ambariServerVersion);
      this.nodes.add(nodeDef);
    }
  }
  AmStackDef stackDef=new AmStackDef();
  stackDef.setName(blueprint.getHadoopStack().getVendor());
  stackDef.setVersion(blueprint.getHadoopStack().getFullVersion());
  this.amStack=stackDef;
}"
48479,"public void setVolumns(List<String> volumns,HdfsVersion hdfsVersion){
  if (volumns.isEmpty()) {
    return;
  }
  for (  String component : components) {
switch (component) {
case ""String_Node_Str"":
      String dfsNameDir=Constants.CONFIG_DFS_NAMENODE_NAME_DIR;
    if (hdfsVersion.isHdfsV1()) {
      dfsNameDir=Constants.CONFIG_DFS_NAME_DIR;
    }
  addConfiguration(Constants.CONFIG_HDFS_SITE,dfsNameDir,dataDirs(volumns,""String_Node_Str""));
break;
case ""String_Node_Str"":
String dfsCheckpointDir=Constants.CONFIG_DFS_NAMENODE_CHECKPOINT_DIR;
if (hdfsVersion.isHdfsV1()) {
dfsCheckpointDir=Constants.CONFIG_DFS_CHECKPOINT_DIR;
}
addConfiguration(Constants.CONFIG_HDFS_SITE,dfsCheckpointDir,volumns.get(0) + ""String_Node_Str"");
break;
case ""String_Node_Str"":
String dfsDataDir=Constants.CONFIG_DFS_DATANODE_DATA_DIR;
if (hdfsVersion.isHdfsV1()) {
dfsDataDir=Constants.CONFIG_DFS_DATA_DIR;
}
addConfiguration(Constants.CONFIG_HDFS_SITE,dfsDataDir,dataDirs(volumns,""String_Node_Str""));
break;
case ""String_Node_Str"":
addConfiguration(Constants.CONFIG_YARN_SITE,Constants.CONFIG_YARN_NODEMANAGER_LOCAL_DIRS,dataDirs(volumns,""String_Node_Str""));
break;
case ""String_Node_Str"":
addConfiguration(Constants.CONFIG_HDFS_SITE,Constants.CONFIG_JOURNALNODE_EDITS_DIR,volumns.get(0) + ""String_Node_Str"");
break;
case ""String_Node_Str"":
addConfiguration(Constants.CONFIG_MAPRED_SITE,Constants.CONFIG_MAPRED_LOCAL_DIR,dataDirs(volumns,""String_Node_Str""));
break;
default :
break;
}
}
}","public void setVolumns(List<String> volumns,HdfsVersion hdfsVersion,String ambariServerVersion){
  if (volumns.isEmpty()) {
    return;
  }
  for (  String component : components) {
switch (component) {
case ""String_Node_Str"":
      String dfsNameDir=Constants.CONFIG_DFS_NAMENODE_NAME_DIR;
    if (hdfsVersion.isHdfsV1()) {
      dfsNameDir=Constants.CONFIG_DFS_NAME_DIR;
    }
  addConfiguration(Constants.CONFIG_HDFS_SITE,dfsNameDir,dataDirs(volumns,""String_Node_Str""));
break;
case ""String_Node_Str"":
String dfsCheckpointDir=Constants.CONFIG_DFS_NAMENODE_CHECKPOINT_DIR;
if (hdfsVersion.isHdfsV1()) {
dfsCheckpointDir=Constants.CONFIG_DFS_CHECKPOINT_DIR;
}
addConfiguration(Constants.CONFIG_HDFS_SITE,dfsCheckpointDir,volumns.get(0) + ""String_Node_Str"");
break;
case ""String_Node_Str"":
if (ambariServerVersion != null && !ambariServerVersion.equals(Constants.AMBARI_SERVER_VERSION_1_6_0)) {
String timelineStorePath=Constants.CONFIG_LEVELDB_TIMELINE_STORE_PATH;
addConfiguration(Constants.CONFIG_YARN_SITE,timelineStorePath,volumns.get(0) + ""String_Node_Str"");
}
break;
case ""String_Node_Str"":
String dfsDataDir=Constants.CONFIG_DFS_DATANODE_DATA_DIR;
if (hdfsVersion.isHdfsV1()) {
dfsDataDir=Constants.CONFIG_DFS_DATA_DIR;
}
addConfiguration(Constants.CONFIG_HDFS_SITE,dfsDataDir,dataDirs(volumns,""String_Node_Str""));
break;
case ""String_Node_Str"":
addConfiguration(Constants.CONFIG_YARN_SITE,Constants.CONFIG_YARN_NODEMANAGER_LOCAL_DIRS,dataDirs(volumns,""String_Node_Str""));
break;
case ""String_Node_Str"":
addConfiguration(Constants.CONFIG_HDFS_SITE,Constants.CONFIG_JOURNALNODE_EDITS_DIR,volumns.get(0) + ""String_Node_Str"");
break;
case ""String_Node_Str"":
addConfiguration(Constants.CONFIG_MAPRED_SITE,Constants.CONFIG_MAPRED_LOCAL_DIR,dataDirs(volumns,""String_Node_Str""));
break;
default :
break;
}
}
}"
48480,"@Override public boolean createCluster(ClusterBlueprint blueprint,ClusterReportQueue reportQueue) throws SoftwareManagementPluginException {
  boolean success=false;
  AmClusterDef clusterDef=null;
  try {
    logger.info(""String_Node_Str"");
    logger.info(ApiUtils.objectToJson(blueprint));
    logger.info(""String_Node_Str"" + blueprint.getName() + ""String_Node_Str"");
    clusterDef=new AmClusterDef(blueprint,privateKey);
    provisionCluster(clusterDef,reportQueue);
    success=true;
    Map<String,NodeReport> nodeReports=clusterDef.getCurrentReport().getNodeReports();
    for (    String nodeReportKey : nodeReports.keySet()) {
      nodeReports.get(nodeReportKey).setUseClusterMsg(true);
    }
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setProgress(ProgressSplit.PROVISION_SUCCESS.getProgress());
    clusterDef.getCurrentReport().setSuccess(success);
  }
 catch (  Exception e) {
    clusterDef.getCurrentReport().setSuccess(success);
    String errorMessage=errorMessage(""String_Node_Str"" + blueprint.getName(),e);
    logger.error(errorMessage);
    throw SoftwareManagementPluginException.CREATE_CLUSTER_EXCEPTION(e,Constants.AMBARI_PLUGIN_NAME,blueprint.getName());
  }
 finally {
    clusterDef.getCurrentReport().setFinished(true);
    if (success) {
      clusterDef.getCurrentReport().setClusterAndNodesServiceStatus(ServiceStatus.STARTED);
    }
    reportStatus(clusterDef.getCurrentReport(),reportQueue);
  }
  return success;
}","@Override public boolean createCluster(ClusterBlueprint blueprint,ClusterReportQueue reportQueue) throws SoftwareManagementPluginException {
  boolean success=false;
  AmClusterDef clusterDef=null;
  try {
    logger.info(""String_Node_Str"");
    logger.info(ApiUtils.objectToJson(blueprint));
    logger.info(""String_Node_Str"" + blueprint.getName() + ""String_Node_Str"");
    String ambariServerVersion=getVersion();
    clusterDef=new AmClusterDef(blueprint,privateKey,ambariServerVersion);
    provisionCluster(clusterDef,reportQueue);
    success=true;
    Map<String,NodeReport> nodeReports=clusterDef.getCurrentReport().getNodeReports();
    for (    String nodeReportKey : nodeReports.keySet()) {
      nodeReports.get(nodeReportKey).setUseClusterMsg(true);
    }
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setProgress(ProgressSplit.PROVISION_SUCCESS.getProgress());
    clusterDef.getCurrentReport().setSuccess(success);
  }
 catch (  Exception e) {
    clusterDef.getCurrentReport().setSuccess(success);
    String errorMessage=errorMessage(""String_Node_Str"" + blueprint.getName(),e);
    logger.error(errorMessage);
    throw SoftwareManagementPluginException.CREATE_CLUSTER_EXCEPTION(e,Constants.AMBARI_PLUGIN_NAME,blueprint.getName());
  }
 finally {
    clusterDef.getCurrentReport().setFinished(true);
    if (success) {
      clusterDef.getCurrentReport().setClusterAndNodesServiceStatus(ServiceStatus.STARTED);
    }
    reportStatus(clusterDef.getCurrentReport(),reportQueue);
  }
  return success;
}"
48481,"public static KeyStore loadAppMgrKeyStore(){
  File file=new File(Constants.APPMANAGER_KEYSTORE_PATH + Constants.APPMANAGER_KEYSTORE_FILE);
  if (file.isFile() == false) {
    char SEP=File.separatorChar;
    File dir=new File(System.getProperty(""String_Node_Str"") + SEP + ""String_Node_Str""+ SEP+ ""String_Node_Str"");
    file=new File(dir,Constants.APPMANAGER_KEYSTORE_FILE);
    if (file.isFile() == false) {
      file=new File(dir,""String_Node_Str"");
    }
  }
  KeyStore keyStore=null;
  try {
    keyStore=KeyStore.getInstance(KeyStore.getDefaultType());
  }
 catch (  KeyStoreException e) {
    logger.error(""String_Node_Str"",e);
    return null;
  }
  InputStream in=null;
  try {
    in=new FileInputStream(file);
    keyStore.load(in,Constants.APPMANAGER_KEYSTORE_PASSWORD);
  }
 catch (  FileNotFoundException e) {
    logger.error(""String_Node_Str"" + file.getAbsolutePath(),e);
    return null;
  }
catch (  NoSuchAlgorithmException e) {
    logger.error(""String_Node_Str"",e);
    return null;
  }
catch (  CertificateException e) {
    logger.error(""String_Node_Str"",e);
    return null;
  }
catch (  IOException e) {
    logger.error(""String_Node_Str"",e);
    return null;
  }
 finally {
    if (in != null) {
      try {
        in.close();
      }
 catch (      IOException e) {
        logger.warn(""String_Node_Str"");
      }
    }
  }
  return keyStore;
}","public static KeyStore loadAppMgrKeyStore(String keystorePath){
  File file=new File(keystorePath + Constants.APPMANAGER_KEYSTORE_FILE);
  if (file.isFile() == false) {
    char SEP=File.separatorChar;
    File dir=new File(System.getProperty(""String_Node_Str"") + SEP + ""String_Node_Str""+ SEP+ ""String_Node_Str"");
    file=new File(dir,Constants.APPMANAGER_KEYSTORE_FILE);
    if (file.isFile() == false) {
      file=new File(dir,""String_Node_Str"");
    }
  }
  KeyStore keyStore=null;
  try {
    keyStore=KeyStore.getInstance(KeyStore.getDefaultType());
  }
 catch (  KeyStoreException e) {
    logger.error(""String_Node_Str"",e);
    return null;
  }
  InputStream in=null;
  try {
    in=new FileInputStream(file);
    keyStore.load(in,Constants.APPMANAGER_KEYSTORE_PASSWORD);
  }
 catch (  FileNotFoundException e) {
    logger.error(""String_Node_Str"" + file.getAbsolutePath(),e);
    return null;
  }
catch (  NoSuchAlgorithmException e) {
    logger.error(""String_Node_Str"",e);
    return null;
  }
catch (  CertificateException e) {
    logger.error(""String_Node_Str"",e);
    return null;
  }
catch (  IOException e) {
    logger.error(""String_Node_Str"",e);
    return null;
  }
 finally {
    if (in != null) {
      try {
        in.close();
      }
 catch (      IOException e) {
        logger.warn(""String_Node_Str"");
      }
    }
  }
  return keyStore;
}"
48482,"@Override public void checkServerTrusted(X509Certificate[] chain,String authType) throws CertificateException {
  logger.info(""String_Node_Str"");
  try {
    KeyStore keyStore=CommonUtil.loadAppMgrKeyStore();
    if (keyStore == null) {
      logger.error(""String_Node_Str"");
      return;
    }
    MessageDigest md5=MessageDigest.getInstance(""String_Node_Str"");
    String md5Fingerprint=""String_Node_Str"";
    for (int i=0; i < chain.length; i++) {
      X509Certificate cert=chain[i];
      md5.update(cert.getEncoded());
      md5Fingerprint=CommonUtil.toHexString(md5.digest());
      logger.debug(""String_Node_Str"" + i + ""String_Node_Str""+ cert);
      if (keyStore.getCertificate(md5Fingerprint) != null) {
        if (i == chain.length - 1) {
          return;
        }
 else {
          continue;
        }
      }
      logger.error(""String_Node_Str"" + md5Fingerprint);
      logger.error(""String_Node_Str"" + cert);
      throw SoftwareManagementPluginException.UNKNOWN_CERTIFICATE(cert.getSubjectDN().toString());
    }
  }
 catch (  NoSuchAlgorithmException e) {
    logger.error(""String_Node_Str"" + e.getMessage(),e);
  }
catch (  KeyStoreException e) {
    logger.error(""String_Node_Str"" + e.getMessage(),e);
  }
}","@Override public void checkServerTrusted(X509Certificate[] chain,String authType) throws CertificateException {
  logger.info(""String_Node_Str"");
  try {
    KeyStore keyStore=CommonUtil.loadAppMgrKeyStore(Constants.APPMANAGER_KEYSTORE_PATH);
    if (keyStore == null) {
      logger.error(""String_Node_Str"");
      return;
    }
    MessageDigest md5=MessageDigest.getInstance(""String_Node_Str"");
    String md5Fingerprint=""String_Node_Str"";
    for (int i=0; i < chain.length; i++) {
      X509Certificate cert=chain[i];
      md5.update(cert.getEncoded());
      md5Fingerprint=CommonUtil.toHexString(md5.digest());
      logger.debug(""String_Node_Str"" + i + ""String_Node_Str""+ cert);
      if (keyStore.getCertificate(md5Fingerprint) != null) {
        if (i == chain.length - 1) {
          return;
        }
 else {
          continue;
        }
      }
      logger.error(""String_Node_Str"" + md5Fingerprint);
      logger.error(""String_Node_Str"" + cert);
      throw SoftwareManagementPluginException.UNKNOWN_CERTIFICATE(cert.getSubjectDN().toString());
    }
  }
 catch (  NoSuchAlgorithmException e) {
    logger.error(""String_Node_Str"" + e.getMessage(),e);
  }
catch (  KeyStoreException e) {
    logger.error(""String_Node_Str"" + e.getMessage(),e);
  }
}"
48483,"private void provisionWithBlueprint(final AmClusterDef clusterDef,final ClusterReportQueue reportQueue) throws SoftwareManagementPluginException {
  try {
    logger.info(""String_Node_Str"" + clusterDef.getName() + ""String_Node_Str""+ clusterDef.getName());
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setProgress(ProgressSplit.PROVISION_CLUSTER.getProgress());
    reportStatus(clusterDef.getCurrentReport(),reportQueue);
    String clusterName=clusterDef.getName();
    ReflectionUtils.getPreStartServicesHook().preStartServices(clusterName,120);
    if (isProvisioned(clusterName) && isClusterProvisionedByBDE(clusterDef)) {
      try {
        if (hasHosts(clusterName)) {
          ApiRequest apiRequestSummary=apiManager.stopAllServicesInCluster(clusterName);
          doSoftwareOperation(clusterName,apiRequestSummary,clusterDef.getCurrentReport(),reportQueue);
        }
      }
 catch (      Exception e) {
        String errMsg=getErrorMsg(""String_Node_Str"",e);
        logger.error(errMsg,e);
        throw SoftwareManagementPluginException.STOP_CLUSTER_EXCEPTION(e,Constants.AMBARI_PLUGIN_NAME,clusterName);
      }
      apiManager.deleteCluster(clusterName);
    }
    ApiRequest apiRequestSummary=apiManager.provisionCluster(clusterDef.getName(),clusterDef.toApiClusterBlueprint());
    ClusterOperationPoller poller=new ClusterOperationPoller(apiManager,apiRequestSummary,clusterName,clusterDef.getCurrentReport(),reportQueue,ProgressSplit.PROVISION_SUCCESS.getProgress());
    poller.waitForComplete();
    boolean success=false;
    ApiRequest apiRequest=apiManager.getRequest(clusterName,apiRequestSummary.getApiRequestInfo().getRequestId());
    ClusterRequestStatus clusterRequestStatus=ClusterRequestStatus.valueOf(apiRequest.getApiRequestInfo().getRequestStatus());
    if (!clusterRequestStatus.isFailedState()) {
      success=true;
    }
    if (!success) {
      throw SoftwareManagementPluginException.CREATE_CLUSTER_FAIL(Constants.AMBARI_PLUGIN_NAME,clusterDef.getName());
    }
  }
 catch (  Exception e) {
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    String errorMessage=errorMessage(""String_Node_Str"" + clusterDef.getName() + ""String_Node_Str"",e);
    logger.error(errorMessage);
    throw AmException.PROVISION_WITH_BLUEPRINT_FAILED(e,clusterDef.getName());
  }
 finally {
    reportQueue.addClusterReport(clusterDef.getCurrentReport().clone());
  }
}","private void provisionWithBlueprint(final AmClusterDef clusterDef,final ClusterReportQueue reportQueue) throws SoftwareManagementPluginException {
  try {
    logger.info(""String_Node_Str"" + clusterDef.getName() + ""String_Node_Str""+ clusterDef.getName());
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setProgress(ProgressSplit.PROVISION_CLUSTER.getProgress());
    reportStatus(clusterDef.getCurrentReport(),reportQueue);
    String clusterName=clusterDef.getName();
    ReflectionUtils.getPreStartServicesHook().preStartServices(clusterName,120);
    if (isProvisioned(clusterName) && isClusterProvisionedByBDE(clusterDef)) {
      try {
        if (hasHosts(clusterName)) {
          ApiRequest apiRequestSummary=apiManager.stopAllServicesInCluster(clusterName);
          doSoftwareOperation(clusterName,apiRequestSummary,clusterDef.getCurrentReport(),reportQueue);
        }
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        throw SoftwareManagementPluginException.STOP_CLUSTER_EXCEPTION(e,Constants.AMBARI_PLUGIN_NAME,clusterName);
      }
      apiManager.deleteCluster(clusterName);
    }
    ApiRequest apiRequestSummary=apiManager.provisionCluster(clusterDef.getName(),clusterDef.toApiClusterBlueprint());
    ClusterOperationPoller poller=new ClusterOperationPoller(apiManager,apiRequestSummary,clusterName,clusterDef.getCurrentReport(),reportQueue,ProgressSplit.PROVISION_SUCCESS.getProgress());
    poller.waitForComplete();
    boolean success=false;
    ApiRequest apiRequest=apiManager.getRequest(clusterName,apiRequestSummary.getApiRequestInfo().getRequestId());
    ClusterRequestStatus clusterRequestStatus=ClusterRequestStatus.valueOf(apiRequest.getApiRequestInfo().getRequestStatus());
    if (!clusterRequestStatus.isFailedState()) {
      success=true;
    }
    if (!success) {
      throw SoftwareManagementPluginException.CREATE_CLUSTER_FAIL(Constants.AMBARI_PLUGIN_NAME,clusterDef.getName());
    }
  }
 catch (  Exception e) {
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    String errorMessage=errorMessage(""String_Node_Str"" + clusterDef.getName() + ""String_Node_Str"",e);
    logger.error(errorMessage);
    throw AmException.PROVISION_WITH_BLUEPRINT_FAILED(e,clusterDef.getName());
  }
 finally {
    reportQueue.addClusterReport(clusterDef.getCurrentReport().clone());
  }
}"
48484,"@Override public boolean onStopCluster(ClusterBlueprint clusterBlueprint,ClusterReportQueue reports) throws SoftwareManagementPluginException {
  String clusterName=clusterBlueprint.getName();
  AmClusterDef clusterDef=new AmClusterDef(clusterBlueprint,null);
  ClusterReport clusterReport=clusterDef.getCurrentReport();
  boolean success=false;
  try {
    if (!isProvisioned(clusterName)) {
      return true;
    }
    if (!isClusterProvisionedByBDE(clusterDef)) {
      throw SoftwareManagementPluginException.STOP_CLUSTER_FAILED(Constants.AMBARI_PLUGIN_NAME,clusterName,""String_Node_Str"");
    }
    clusterReport.setAction(""String_Node_Str"");
    clusterReport.setProgress(ProgressSplit.OPERATION_BEGIN.getProgress());
    reportStatus(clusterReport,reports);
    ApiRequest apiRequestSummary=apiManager.stopAllServicesInCluster(clusterName);
    if (apiRequestSummary == null || apiRequestSummary.getApiRequestInfo() == null) {
      logger.info(""String_Node_Str"" + clusterName);
      return true;
    }
    doSoftwareOperation(clusterName,apiRequestSummary,clusterReport,reports);
    clusterReport.setClusterAndNodesAction(""String_Node_Str"");
    clusterReport.clearAllNodesErrorMsg();
    clusterReport.setClusterAndNodesServiceStatus(ServiceStatus.STOPPED);
    reportStatus(clusterReport.clone(),reports);
    return true;
  }
 catch (  Exception e) {
    String errMsg=getErrorMsg(""String_Node_Str"",e);
    logger.error(errMsg,e);
    throw SoftwareManagementPluginException.STOP_CLUSTER_EXCEPTION(e,Constants.AMBARI_PLUGIN_NAME,clusterName);
  }
}","@Override public boolean onStopCluster(ClusterBlueprint clusterBlueprint,ClusterReportQueue reports) throws SoftwareManagementPluginException {
  String clusterName=clusterBlueprint.getName();
  AmClusterDef clusterDef=new AmClusterDef(clusterBlueprint,null);
  ClusterReport clusterReport=clusterDef.getCurrentReport();
  boolean success=false;
  try {
    if (!isProvisioned(clusterName)) {
      return true;
    }
    if (!isClusterProvisionedByBDE(clusterDef)) {
      throw SoftwareManagementPluginException.STOP_CLUSTER_FAILED(Constants.AMBARI_PLUGIN_NAME,clusterName,""String_Node_Str"");
    }
    clusterReport.setAction(""String_Node_Str"");
    clusterReport.setProgress(ProgressSplit.OPERATION_BEGIN.getProgress());
    reportStatus(clusterReport,reports);
    ApiRequest apiRequestSummary=apiManager.stopAllServicesInCluster(clusterName);
    if (apiRequestSummary == null || apiRequestSummary.getApiRequestInfo() == null) {
      logger.info(""String_Node_Str"" + clusterName);
      return true;
    }
    doSoftwareOperation(clusterName,apiRequestSummary,clusterReport,reports);
    clusterReport.setClusterAndNodesAction(""String_Node_Str"");
    clusterReport.clearAllNodesErrorMsg();
    clusterReport.setClusterAndNodesServiceStatus(ServiceStatus.STOPPED);
    reportStatus(clusterReport.clone(),reports);
    return true;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw SoftwareManagementPluginException.STOP_CLUSTER_EXCEPTION(e,Constants.AMBARI_PLUGIN_NAME,clusterName);
  }
}"
48485,"@Override public boolean startCluster(ClusterBlueprint clusterBlueprint,ClusterReportQueue reports) throws SoftwareManagementPluginException {
  AmClusterDef clusterDef=new AmClusterDef(clusterBlueprint,null);
  String clusterName=clusterDef.getName();
  if (!isProvisioned(clusterName)) {
    throw AmException.CLUSTER_NOT_PROVISIONED(clusterName);
  }
  if (!isClusterProvisionedByBDE(clusterDef)) {
    throw SoftwareManagementPluginException.START_CLUSTER_FAILED_NOT_PROV_BY_BDE(clusterName);
  }
  ClusterReport clusterReport=clusterDef.getCurrentReport();
  clusterReport.setAction(""String_Node_Str"");
  clusterReport.setProgress(ProgressSplit.OPERATION_BEGIN.getProgress());
  reportStatus(clusterReport,reports);
  boolean success=false;
  Exception resultException=null;
  try {
    ReflectionUtils.getPreStartServicesHook().preStartServices(clusterName,120);
    for (int i=0; i < REQUEST_MAX_RETRY_TIMES; i++) {
      ApiRequest apiRequestSummary;
      try {
        apiRequestSummary=apiManager.startAllServicesInCluster(clusterName);
        if (apiRequestSummary == null || apiRequestSummary.getApiRequestInfo() == null) {
          success=true;
          return true;
        }
        success=doSoftwareOperation(clusterBlueprint.getName(),apiRequestSummary,clusterReport,reports);
      }
 catch (      Exception e) {
        resultException=e;
        logger.warn(""String_Node_Str"",e);
        try {
          Thread.sleep(5000);
        }
 catch (        InterruptedException interrupt) {
          logger.info(""String_Node_Str"");
        }
      }
    }
  }
  finally {
    if (!success) {
      String errMsg=getErrorMsg(""String_Node_Str"",resultException);
      logger.error(errMsg,resultException);
      throw SoftwareManagementPluginException.START_CLUSTER_FAILED(null,Constants.AMBARI_PLUGIN_NAME,clusterName);
    }
    clusterReport.setClusterAndNodesServiceStatus(ServiceStatus.STARTED);
    clusterReport.setClusterAndNodesAction(""String_Node_Str"");
    clusterReport.clearAllNodesErrorMsg();
    reportStatus(clusterReport.clone(),reports);
    return true;
  }
}","@Override public boolean startCluster(ClusterBlueprint clusterBlueprint,ClusterReportQueue reports) throws SoftwareManagementPluginException {
  AmClusterDef clusterDef=new AmClusterDef(clusterBlueprint,null);
  String clusterName=clusterDef.getName();
  if (!isProvisioned(clusterName)) {
    throw AmException.CLUSTER_NOT_PROVISIONED(clusterName);
  }
  if (!isClusterProvisionedByBDE(clusterDef)) {
    throw SoftwareManagementPluginException.START_CLUSTER_FAILED_NOT_PROV_BY_BDE(clusterName);
  }
  ClusterReport clusterReport=clusterDef.getCurrentReport();
  clusterReport.setAction(""String_Node_Str"");
  clusterReport.setProgress(ProgressSplit.OPERATION_BEGIN.getProgress());
  reportStatus(clusterReport,reports);
  boolean success=false;
  Exception resultException=null;
  try {
    ReflectionUtils.getPreStartServicesHook().preStartServices(clusterName,120);
    for (int i=0; i < getRequestMaxRetryTimes(); i++) {
      ApiRequest apiRequestSummary;
      try {
        apiRequestSummary=apiManager.startAllServicesInCluster(clusterName);
        if (apiRequestSummary == null || apiRequestSummary.getApiRequestInfo() == null) {
          success=true;
          return true;
        }
        success=doSoftwareOperation(clusterBlueprint.getName(),apiRequestSummary,clusterReport,reports);
      }
 catch (      Exception e) {
        resultException=e;
        logger.warn(""String_Node_Str"",e);
        try {
          Thread.sleep(5000);
        }
 catch (        InterruptedException interrupt) {
          logger.info(""String_Node_Str"");
        }
      }
    }
  }
  finally {
    if (!success) {
      logger.error(""String_Node_Str"",resultException);
      throw SoftwareManagementPluginException.START_CLUSTER_FAILED(resultException,Constants.AMBARI_PLUGIN_NAME,clusterName);
    }
    clusterReport.setClusterAndNodesServiceStatus(ServiceStatus.STARTED);
    clusterReport.setClusterAndNodesAction(""String_Node_Str"");
    clusterReport.clearAllNodesErrorMsg();
    reportStatus(clusterReport.clone(),reports);
    return true;
  }
}"
48486,"@Test(groups={""String_Node_Str""}) public void testForceDeleteClusterWhenStopFailed(){
  AmbariImpl spy=Mockito.spy(provider);
  Mockito.when(spy.echo()).thenReturn(false);
  Mockito.when(spy.isProvisioned(Mockito.anyString())).thenReturn(true);
  Mockito.doReturn(false).when(spy).onStopCluster(Mockito.<ClusterBlueprint>any(),Mockito.<ClusterReportQueue>any());
  Assert.assertTrue(spy.onDeleteCluster(blueprint,reportQueue));
}","@Test(groups={""String_Node_Str""}) public void testForceDeleteClusterWhenStopFailed(){
  AmbariImpl spy=Mockito.spy(provider);
  Mockito.when(spy.echo()).thenReturn(true);
  Mockito.when(spy.isProvisioned(Mockito.anyString())).thenReturn(true);
  Mockito.doReturn(true).when(spy).isClusterProvisionedByBDE(Mockito.<AmClusterDef>any());
  Mockito.doReturn(false).when(spy).onStopCluster(Mockito.<ClusterBlueprint>any(),Mockito.<ClusterReportQueue>any());
  ApiManager apiManager=new FakeApiManager(makeClientBuilder());
  ApiManager backup=spy.getApiManager();
  spy.setApiManager(apiManager);
  Assert.assertTrue(spy.onDeleteCluster(blueprint,reportQueue));
  spy.setApiManager(backup);
}"
48487,"@Test(groups={""String_Node_Str""}) public void testForceDeleteClusterWhenStopSucceed(){
  AmbariImpl spy=Mockito.spy(provider);
  Mockito.when(spy.echo()).thenReturn(false);
  Mockito.when(spy.isProvisioned(Mockito.anyString())).thenReturn(true);
  Mockito.doReturn(true).when(spy).onStopCluster(Mockito.<ClusterBlueprint>any(),Mockito.<ClusterReportQueue>any());
  Assert.assertTrue(spy.onDeleteCluster(blueprint,reportQueue));
}","@Test public void testForceDeleteClusterWhenStopSucceed(){
  AmbariImpl spy=Mockito.spy(provider);
  Mockito.when(spy.echo()).thenReturn(true);
  Mockito.when(spy.isProvisioned(Mockito.anyString())).thenReturn(true);
  Mockito.doReturn(true).when(spy).isClusterProvisionedByBDE(Mockito.<AmClusterDef>any());
  Mockito.doReturn(true).when(spy).onStopCluster(Mockito.<ClusterBlueprint>any(),Mockito.<ClusterReportQueue>any());
  ApiManager apiManager=new FakeApiManager(makeClientBuilder());
  ApiManager backup=spy.getApiManager();
  spy.setApiManager(apiManager);
  Assert.assertTrue(spy.onDeleteCluster(blueprint,reportQueue));
  spy.setApiManager(backup);
}"
48488,"@Test(groups={""String_Node_Str""}) public void testDeleteClusterNotProvisionedByBDE(){
  AmbariImpl spy=Mockito.spy(provider);
  Mockito.when(spy.echo()).thenReturn(false);
  Mockito.when(spy.isProvisioned(Mockito.anyString())).thenReturn(true);
  Assert.assertTrue(spy.onDeleteCluster(blueprint,reportQueue));
}","@Test(groups={""String_Node_Str""}) public void testDeleteClusterNotProvisionedByBDE(){
  AmbariImpl spy=Mockito.spy(provider);
  Mockito.when(spy.echo()).thenReturn(true);
  Mockito.when(spy.isProvisioned(Mockito.anyString())).thenReturn(true);
  Mockito.doReturn(false).when(spy).isClusterProvisionedByBDE(Mockito.<AmClusterDef>any());
  Assert.assertTrue(spy.onDeleteCluster(blueprint,reportQueue));
}"
48489,"@Test(groups={""String_Node_Str""}) public void testStopStartedCluster(){
  AmbariImpl spy=Mockito.spy(provider);
  AmbariManagerClientbuilder clientbuilder=makeClientBuilder();
  ApiManager apiManager=new FakeApiManager(clientbuilder){
    @Override public ApiRequest stopAllServicesInCluster(    String clusterName) throws AmbariApiException {
      ApiRequest apiRequest=new ApiRequest();
      apiRequest.setApiRequestInfo(new ApiRequestInfo());
      return apiRequest;
    }
  }
;
  Mockito.when(spy.isProvisioned(blueprint.getName())).thenReturn(true);
  Mockito.doReturn(true).when(spy).isClusterProvisionedByBDE(Mockito.<AmClusterDef>any());
  ApiManager backup=spy.getApiManager();
  spy.setApiManager(apiManager);
  Assert.assertTrue(spy.onStopCluster(blueprint,reportQueue));
  spy.setApiManager(backup);
}","@Test(groups={""String_Node_Str""}) public void testStopStartedCluster(){
  AmbariImpl spy=Mockito.spy(provider);
  AmbariManagerClientbuilder clientbuilder=makeClientBuilder();
  ApiManager apiManager=new FakeApiManager(clientbuilder){
    @Override public ApiRequest stopAllServicesInCluster(    String clusterName) throws AmbariApiException {
      ApiRequest apiRequest=new ApiRequest();
      apiRequest.setApiRequestInfo(new ApiRequestInfo());
      return apiRequest;
    }
  }
;
  Mockito.when(spy.isProvisioned(blueprint.getName())).thenReturn(true);
  Mockito.doReturn(true).when(spy).isClusterProvisionedByBDE(Mockito.<AmClusterDef>any());
  try {
    Mockito.when(spy.doSoftwareOperation(Mockito.anyString(),Mockito.<ApiRequest>any(),Mockito.<ClusterReport>any(),Mockito.<ClusterReportQueue>any())).thenReturn(true);
  }
 catch (  Exception e) {
  }
  ApiManager backup=spy.getApiManager();
  spy.setApiManager(apiManager);
  Assert.assertTrue(spy.onStopCluster(blueprint,reportQueue));
  spy.setApiManager(backup);
}"
48490,"@Test(groups={""String_Node_Str""}) public void testStartStoppedCluster(){
  AmbariImpl spy=Mockito.spy(provider);
  AmbariManagerClientbuilder clientbuilder=makeClientBuilder();
  ApiManager apiManager=new FakeApiManager(clientbuilder){
    @Override public ApiRequest startAllServicesInCluster(    String clusterName) throws AmbariApiException {
      ApiRequest apiRequest=new ApiRequest();
      apiRequest.setApiRequestInfo(new ApiRequestInfo());
      return apiRequest;
    }
  }
;
  Mockito.when(spy.isProvisioned(blueprint.getName())).thenReturn(true);
  Mockito.doReturn(true).when(spy).isClusterProvisionedByBDE(Mockito.<AmClusterDef>any());
  ApiManager backup=spy.getApiManager();
  spy.setApiManager(apiManager);
  Assert.assertTrue(spy.startCluster(blueprint,reportQueue));
  spy.setApiManager(backup);
}","@Test(groups={""String_Node_Str""}) public void testStartStoppedCluster(){
  AmbariImpl spy=Mockito.spy(provider);
  AmbariManagerClientbuilder clientbuilder=makeClientBuilder();
  ApiManager apiManager=new FakeApiManager(clientbuilder){
    @Override public ApiRequest startAllServicesInCluster(    String clusterName) throws AmbariApiException {
      ApiRequest apiRequest=new ApiRequest();
      apiRequest.setApiRequestInfo(new ApiRequestInfo());
      return apiRequest;
    }
  }
;
  try {
    Mockito.when(spy.doSoftwareOperation(Mockito.anyString(),Mockito.<ApiRequest>any(),Mockito.<ClusterReport>any(),Mockito.<ClusterReportQueue>any())).thenReturn(true);
  }
 catch (  Exception e) {
  }
  Mockito.when(spy.isProvisioned(blueprint.getName())).thenReturn(true);
  Mockito.doReturn(true).when(spy).isClusterProvisionedByBDE(Mockito.<AmClusterDef>any());
  Mockito.doReturn(1).when(spy).getRequestMaxRetryTimes();
  ApiManager backup=spy.getApiManager();
  spy.setApiManager(apiManager);
  Assert.assertTrue(spy.startCluster(blueprint,reportQueue));
  spy.setApiManager(backup);
}"
48491,"@Test(groups={""String_Node_Str""}) public void testStopAlreadyStoppedCluster(){
  AmbariImpl spy=Mockito.spy(provider);
  AmbariManagerClientbuilder clientbuilder=makeClientBuilder();
  ApiManager apiManager=new FakeApiManager(clientbuilder);
  Mockito.when(spy.isProvisioned(blueprint.getName())).thenReturn(true);
  provider.isProvisioned(blueprint.getName());
  Mockito.doReturn(true).when(spy).isClusterProvisionedByBDE(Mockito.<AmClusterDef>any());
  ApiManager backup=spy.getApiManager();
  spy.setApiManager(apiManager);
  Assert.assertTrue(spy.onStopCluster(blueprint,reportQueue));
  spy.setApiManager(backup);
}","@Test(groups={""String_Node_Str""}) public void testStopAlreadyStoppedCluster(){
  AmbariImpl spy=Mockito.spy(provider);
  AmbariManagerClientbuilder clientbuilder=makeClientBuilder();
  ApiManager apiManager=new FakeApiManager(clientbuilder);
  Mockito.when(spy.isProvisioned(blueprint.getName())).thenReturn(true);
  Mockito.doReturn(true).when(spy).isClusterProvisionedByBDE(Mockito.<AmClusterDef>any());
  ApiManager backup=spy.getApiManager();
  spy.setApiManager(apiManager);
  Assert.assertTrue(spy.onStopCluster(blueprint,reportQueue));
  spy.setApiManager(backup);
}"
48492,"public List<String> getNetworkNames(){
  List<String> networks=new ArrayList<String>();
  if (getNetworkConfig() != null && !getNetworkConfig().isEmpty()) {
    for (    List<String> nets : getNetworkConfig().values()) {
      for (      String netName : nets) {
        networks.add(netName);
      }
    }
  }
  return networks;
}","@JsonIgnore public List<String> getNetworkNames(){
  List<String> networks=new ArrayList<String>();
  if (getNetworkConfig() != null && !getNetworkConfig().isEmpty()) {
    for (    List<String> nets : getNetworkConfig().values()) {
      for (      String netName : nets) {
        networks.add(netName);
      }
    }
  }
  return networks;
}"
48493,"public static ClusterConfigException NETWORK_IS_NOT_SPECIFIED(String clusterName,int size){
  return new ClusterConfigException(null,""String_Node_Str"",clusterName,size);
}","public static ClusterConfigException NETWORK_IS_NOT_SPECIFIED(String clusterName){
  return new ClusterConfigException(null,""String_Node_Str"",clusterName);
}"
48494,"public synchronized void loadSoftwareManagers(){
  if (appManagerService.findAppManagerByName(Constants.IRONFAN) == null) {
    AppManagerAdd appManagerAdd=new AppManagerAdd();
    appManagerAdd.setName(Constants.IRONFAN);
    appManagerAdd.setDescription(Constants.IRONFAN_DESCRIPTION);
    appManagerAdd.setType(Constants.IRONFAN);
    appManagerAdd.setUrl(""String_Node_Str"");
    appManagerAdd.setUsername(""String_Node_Str"");
    appManagerAdd.setPassword(""String_Node_Str"");
    appManagerAdd.setSslCertificate(""String_Node_Str"");
    appManagerService.addAppManager(appManagerAdd);
  }
  List<AppManagerEntity> appManagers=appManagerService.findAll();
  for (  AppManagerEntity appManager : appManagers) {
    loadSoftwareManager(appManager);
  }
}","public synchronized void loadSoftwareManagers(){
  if (appManagerService.findAppManagerByName(Constants.IRONFAN) == null) {
    AppManagerAdd appManagerAdd=new AppManagerAdd();
    appManagerAdd.setName(Constants.IRONFAN);
    appManagerAdd.setDescription(Constants.IRONFAN_DESCRIPTION);
    appManagerAdd.setType(Constants.IRONFAN);
    appManagerAdd.setUrl(""String_Node_Str"");
    appManagerAdd.setUsername(""String_Node_Str"");
    appManagerAdd.setPassword(""String_Node_Str"");
    appManagerAdd.setSslCertificate(""String_Node_Str"");
    appManagerService.addAppManager(appManagerAdd);
  }
  List<AppManagerEntity> appManagers=appManagerService.findAll();
  for (  AppManagerEntity appManager : appManagers) {
    try {
      loadSoftwareManager(appManager);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"" + appManager.getName());
      logger.error(e.getMessage());
    }
  }
}"
48495,"public Long stopCluster(String clusterName) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ValidationUtils.validateVersion(clusterEntityMgr,clusterName);
  if (ClusterStatus.STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw ClusterManagerException.ALREADY_STOPPED_ERROR(clusterName);
  }
  if (!cluster.getStatus().isActiveServiceStatus() && !ClusterStatus.SERVICE_STOPPED.equals(cluster.getStatus()) && !ClusterStatus.ERROR.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.STOP_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.STOPPED.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.ERROR.name()));
  JobParameters jobParameters=new JobParameters(param);
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.STOPPING);
  clusterEntityMgr.cleanupActionError(clusterName);
  try {
    return jobManager.runJob(JobConstants.STOP_CLUSTER_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.ERROR);
    throw e;
  }
}","public Long stopCluster(String clusterName) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ValidationUtils.validateVersion(clusterEntityMgr,clusterName);
  if (ClusterStatus.STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw ClusterManagerException.ALREADY_STOPPED_ERROR(clusterName);
  }
  if (!cluster.getStatus().isActiveServiceStatus() && !ClusterStatus.SERVICE_STOPPED.equals(cluster.getStatus()) && !ClusterStatus.ERROR.equals(cluster.getStatus())&& !ClusterStatus.SERVICE_WARNING.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.STOP_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.STOPPED.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.ERROR.name()));
  JobParameters jobParameters=new JobParameters(param);
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.STOPPING);
  clusterEntityMgr.cleanupActionError(clusterName);
  try {
    return jobManager.runJob(JobConstants.STOP_CLUSTER_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.ERROR);
    throw e;
  }
}"
48496,"@Override public boolean createCluster(ClusterBlueprint blueprint,ClusterReportQueue reportQueue) throws SoftwareManagementPluginException {
  boolean success=false;
  AmClusterDef clusterDef=null;
  try {
    logger.info(""String_Node_Str"");
    logger.info(ApiUtils.objectToJson(blueprint));
    logger.info(""String_Node_Str"" + blueprint.getName() + ""String_Node_Str"");
    clusterDef=new AmClusterDef(blueprint,privateKey);
    provisionCluster(clusterDef,reportQueue);
    success=true;
    Map<String,NodeReport> nodeReports=clusterDef.getCurrentReport().getNodeReports();
    for (    String nodeReportKey : nodeReports.keySet()) {
      nodeReports.get(nodeReportKey).setUseClusterMsg(true);
    }
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setProgress(ProgressSplit.PROVISION_SUCCESS.getProgress());
    clusterDef.getCurrentReport().setSuccess(true);
  }
 catch (  Exception e) {
    clusterDef.getCurrentReport().setSuccess(false);
    String errorMessage=errorMessage(""String_Node_Str"" + blueprint.getName(),e);
    logger.error(errorMessage);
    throw SoftwareManagementPluginException.CREATE_CLUSTER_EXCEPTION(e,AMBARI,blueprint.getName());
  }
 finally {
    clusterDef.getCurrentReport().setFinished(true);
    reportStatus(clusterDef.getCurrentReport(),reportQueue);
  }
  return success;
}","@Override public boolean createCluster(ClusterBlueprint blueprint,ClusterReportQueue reportQueue) throws SoftwareManagementPluginException {
  boolean success=false;
  AmClusterDef clusterDef=null;
  try {
    logger.info(""String_Node_Str"");
    logger.info(ApiUtils.objectToJson(blueprint));
    logger.info(""String_Node_Str"" + blueprint.getName() + ""String_Node_Str"");
    clusterDef=new AmClusterDef(blueprint,privateKey);
    provisionCluster(clusterDef,reportQueue);
    success=true;
    Map<String,NodeReport> nodeReports=clusterDef.getCurrentReport().getNodeReports();
    for (    String nodeReportKey : nodeReports.keySet()) {
      nodeReports.get(nodeReportKey).setUseClusterMsg(true);
    }
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setProgress(ProgressSplit.PROVISION_SUCCESS.getProgress());
    clusterDef.getCurrentReport().setSuccess(success);
  }
 catch (  Exception e) {
    clusterDef.getCurrentReport().setSuccess(success);
    String errorMessage=errorMessage(""String_Node_Str"" + blueprint.getName(),e);
    logger.error(errorMessage);
    throw SoftwareManagementPluginException.CREATE_CLUSTER_EXCEPTION(e,AMBARI,blueprint.getName());
  }
 finally {
    clusterDef.getCurrentReport().setFinished(true);
    if (success) {
      clusterDef.getCurrentReport().setClusterAndNodesServiceStatus(ServiceStatus.STARTED);
    }
    reportStatus(clusterDef.getCurrentReport(),reportQueue);
  }
  return success;
}"
48497,"/** 
 * There are two approach to create a cluster: 1) specify a cluster type and optionally overwriting the parameters 2) specify a customized spec with cluster type not specified
 * @param spec spec with customized field
 * @return customized cluster spec
 * @throws FileNotFoundException
 */
public static ClusterCreate getCustomizedSpec(ClusterCreate spec,String appManagerType) throws FileNotFoundException {
  if ((spec.getType() == null) || (spec.getType() != null && spec.isSpecFile())) {
    return spec;
  }
  ClusterCreate newSpec=createDefaultSpec(spec.getType(),spec.getDistroVendor(),spec.getDistroVersion(),appManagerType);
  if (spec.getName() != null) {
    newSpec.setName(spec.getName());
  }
  newSpec.setPassword(spec.getPassword());
  if (!CommonUtil.isBlank(spec.getAppManager())) {
    newSpec.setAppManager(spec.getAppManager());
  }
  if (spec.getDistro() != null) {
    newSpec.setDistro(spec.getDistro());
  }
  if (spec.getDistroVendor() != null) {
    newSpec.setDistroVendor(spec.getDistroVendor());
  }
  if (spec.getDistroVersion() != null) {
    newSpec.setDistroVersion(spec.getDistroVersion());
  }
  if (spec.getDsNames() != null) {
    newSpec.setDsNames(spec.getDsNames());
  }
  if (spec.getRpNames() != null) {
    newSpec.setRpNames(spec.getRpNames());
  }
  if (spec.getNetworkConfig() != null) {
    newSpec.setNetworkConfig(spec.getNetworkConfig());
  }
  if (spec.getTopologyPolicy() != null) {
    newSpec.setTopologyPolicy(spec.getTopologyPolicy());
  }
  return newSpec;
}","/** 
 * There are two approach to create a cluster: 1) specify a cluster type and optionally overwriting the parameters 2) specify a customized spec with cluster type not specified
 * @param spec spec with customized field
 * @return customized cluster spec
 * @throws FileNotFoundException
 */
public static ClusterCreate getCustomizedSpec(ClusterCreate spec,String appManagerType) throws FileNotFoundException {
  if ((spec.getType() == null) || (spec.getType() != null && spec.isSpecFile())) {
    return spec;
  }
  ClusterCreate newSpec=createDefaultSpec(spec.getType(),spec.getDistroVendor(),spec.getDistroVersion(),appManagerType);
  if (spec.getName() != null) {
    newSpec.setName(spec.getName());
  }
  newSpec.setPassword(spec.getPassword());
  if (!CommonUtil.isBlank(spec.getAppManager())) {
    newSpec.setAppManager(spec.getAppManager());
  }
  if (!CommonUtil.isBlank(spec.getLocalRepoURL())) {
    newSpec.setLocalRepoURL(spec.getLocalRepoURL());
  }
  if (spec.getDistro() != null) {
    newSpec.setDistro(spec.getDistro());
  }
  if (spec.getDistroVendor() != null) {
    newSpec.setDistroVendor(spec.getDistroVendor());
  }
  if (spec.getDistroVersion() != null) {
    newSpec.setDistroVersion(spec.getDistroVersion());
  }
  if (spec.getDsNames() != null) {
    newSpec.setDsNames(spec.getDsNames());
  }
  if (spec.getRpNames() != null) {
    newSpec.setRpNames(spec.getRpNames());
  }
  if (spec.getNetworkConfig() != null) {
    newSpec.setNetworkConfig(spec.getNetworkConfig());
  }
  if (spec.getTopologyPolicy() != null) {
    newSpec.setTopologyPolicy(spec.getTopologyPolicy());
  }
  return newSpec;
}"
48498,"public AmbariApiException(String errCode,String message,Throwable cause){
  super(message,cause);
  this.errCode=errCode;
}","public AmbariApiException(){
}"
48499,"public static AmbariApiException RESPONSE_EXCEPTION(int errCode,String message){
  return new AmbariApiException(String.valueOf(errCode),message,null);
}","public static AmbariApiException RESPONSE_EXCEPTION(int errCode,String message){
  return new AmbariApiException(""String_Node_Str"",null,message);
}"
48500,"private void bootstrap(final AmClusterDef clusterDef,final List<String> addedHosts,final ClusterReportQueue reportQueue) throws SoftwareManagementPluginException {
  try {
    if (addedHosts != null) {
      logger.info(""String_Node_Str"" + addedHosts);
      clusterDef.getCurrentReport().setNodesAction(""String_Node_Str"",addedHosts);
      clusterDef.getCurrentReport().setProgress(ProgressSplit.BOOTSTRAP_HOSTS.getProgress());
    }
 else {
      logger.info(""String_Node_Str"" + clusterDef.getName());
      clusterDef.getCurrentReport().setAction(""String_Node_Str"");
      clusterDef.getCurrentReport().setProgress(ProgressSplit.BOOTSTRAP_HOSTS.getProgress());
    }
    reportStatus(clusterDef.getCurrentReport(),reportQueue);
    ApiBootstrap apiBootstrapRequest=apiManager.createBootstrap(clusterDef.toApiBootStrap(addedHosts));
    HostBootstrapPoller poller=new HostBootstrapPoller(apiManager,apiBootstrapRequest,clusterDef.getCurrentReport(),reportQueue,ProgressSplit.CREATE_BLUEPRINT.getProgress());
    poller.waitForComplete();
    logger.debug(""String_Node_Str"" + apiBootstrapRequest.getRequestId());
    boolean success=false;
    boolean allHostsBootstrapped=true;
    ApiBootstrapStatus apiBootstrapStatus=apiManager.getBootstrapStatus(apiBootstrapRequest.getRequestId());
    BootstrapStatus bootstrapStatus=BootstrapStatus.valueOf(apiBootstrapStatus.getStatus());
    logger.debug(""String_Node_Str"" + bootstrapStatus);
    if (!bootstrapStatus.isFailedState()) {
      success=true;
    }
    int bootstrapedHostCount=apiBootstrapStatus.getApiBootstrapHostStatus().size();
    int needBootstrapHostCount=-1;
    if (addedHosts == null) {
      needBootstrapHostCount=clusterDef.getNodes().size();
    }
 else {
      needBootstrapHostCount=addedHosts.size();
    }
    logger.debug(""String_Node_Str"" + needBootstrapHostCount);
    logger.debug(""String_Node_Str"" + bootstrapedHostCount);
    if (needBootstrapHostCount != bootstrapedHostCount) {
      success=false;
      allHostsBootstrapped=false;
    }
    if (!success) {
      List<String> notBootstrapNodes=new ArrayList<String>();
      if (!allHostsBootstrapped) {
        for (        AmNodeDef node : clusterDef.getNodes()) {
          boolean nodeBootstrapped=false;
          for (          ApiBootstrapHostStatus apiBootstrapHostStatus : apiBootstrapStatus.getApiBootstrapHostStatus()) {
            if (node.getFqdn().equals(apiBootstrapHostStatus.getHostName())) {
              nodeBootstrapped=true;
              break;
            }
          }
          if (!nodeBootstrapped) {
            notBootstrapNodes.add(node.getFqdn());
          }
        }
      }
      String actionFailure=Constants.HOST_BOOTSTRAP_MSG;
      if (addedHosts != null) {
        clusterDef.getCurrentReport().setNodesError(actionFailure,addedHosts);
      }
 else {
        clusterDef.getCurrentReport().setErrMsg(actionFailure);
      }
      throw AmException.BOOTSTRAP_FAILED(notBootstrapNodes != null ? notBootstrapNodes.toArray() : null);
    }
  }
 catch (  Exception e) {
    clusterDef.getCurrentReport().setAction(Constants.HOST_BOOTSTRAP_MSG);
    String errorMessage=errorMessage(""String_Node_Str"" + clusterDef.getName(),e);
    logger.error(errorMessage);
    throw AmException.BOOTSTRAP_FAILED_EXCEPTION(e,clusterDef.getName());
  }
 finally {
    reportQueue.addClusterReport(clusterDef.getCurrentReport().clone());
  }
}","private void bootstrap(final AmClusterDef clusterDef,final List<String> addedHosts,final ClusterReportQueue reportQueue) throws SoftwareManagementPluginException {
  try {
    if (addedHosts != null) {
      logger.info(""String_Node_Str"" + addedHosts);
      clusterDef.getCurrentReport().setNodesAction(""String_Node_Str"",addedHosts);
      clusterDef.getCurrentReport().setProgress(ProgressSplit.BOOTSTRAP_HOSTS.getProgress());
    }
 else {
      logger.info(""String_Node_Str"" + clusterDef.getName());
      clusterDef.getCurrentReport().setAction(""String_Node_Str"");
      clusterDef.getCurrentReport().setProgress(ProgressSplit.BOOTSTRAP_HOSTS.getProgress());
    }
    reportStatus(clusterDef.getCurrentReport(),reportQueue);
    ApiBootstrap apiBootstrapRequest=apiManager.createBootstrap(clusterDef.toApiBootStrap(addedHosts));
    HostBootstrapPoller poller=new HostBootstrapPoller(apiManager,apiBootstrapRequest,clusterDef.getCurrentReport(),reportQueue,ProgressSplit.CREATE_BLUEPRINT.getProgress());
    poller.waitForComplete();
    logger.debug(""String_Node_Str"" + apiBootstrapRequest.getRequestId());
    boolean success=false;
    boolean allHostsBootstrapped=true;
    ApiBootstrapStatus apiBootstrapStatus=apiManager.getBootstrapStatus(apiBootstrapRequest.getRequestId());
    BootstrapStatus bootstrapStatus=BootstrapStatus.valueOf(apiBootstrapStatus.getStatus());
    logger.debug(""String_Node_Str"" + bootstrapStatus);
    if (!bootstrapStatus.isFailedState()) {
      success=true;
    }
    int bootstrapedHostCount=apiBootstrapStatus.getApiBootstrapHostStatus().size();
    int needBootstrapHostCount=-1;
    if (addedHosts == null) {
      needBootstrapHostCount=clusterDef.getNodes().size();
    }
 else {
      needBootstrapHostCount=addedHosts.size();
    }
    logger.debug(""String_Node_Str"" + needBootstrapHostCount);
    logger.debug(""String_Node_Str"" + bootstrapedHostCount);
    if (needBootstrapHostCount != bootstrapedHostCount) {
      success=false;
      allHostsBootstrapped=false;
    }
    if (!success) {
      List<String> notBootstrapNodes=new ArrayList<String>();
      if (!allHostsBootstrapped) {
        for (        AmNodeDef node : clusterDef.getNodes()) {
          boolean nodeBootstrapped=false;
          for (          ApiBootstrapHostStatus apiBootstrapHostStatus : apiBootstrapStatus.getApiBootstrapHostStatus()) {
            if (node.getFqdn().equals(apiBootstrapHostStatus.getHostName())) {
              nodeBootstrapped=true;
              break;
            }
          }
          if (!nodeBootstrapped) {
            notBootstrapNodes.add(node.getFqdn());
          }
        }
      }
      setBootstrapNodeError(clusterDef,addedHosts);
      throw AmException.BOOTSTRAP_FAILED(notBootstrapNodes != null ? notBootstrapNodes.toArray() : null);
    }
  }
 catch (  Exception e) {
    setBootstrapNodeError(clusterDef,addedHosts);
    String errorMessage=errorMessage(""String_Node_Str"" + clusterDef.getName(),e);
    logger.error(errorMessage);
    throw AmException.BOOTSTRAP_FAILED_EXCEPTION(e,clusterDef.getName());
  }
 finally {
    reportQueue.addClusterReport(clusterDef.getCurrentReport().clone());
  }
}"
48501,"@Override public boolean scaleOutCluster(ClusterBlueprint blueprint,List<String> addedNodeNames,ClusterReportQueue reports) throws SoftwareManagementPluginException {
  boolean success=false;
  AmClusterDef clusterDef=null;
  try {
    logger.info(""String_Node_Str"");
    logger.info(ApiUtils.objectToJson(blueprint));
    logger.info(""String_Node_Str"" + blueprint.getName() + ""String_Node_Str"");
    clusterDef=new AmClusterDef(blueprint,privateKey);
    bootstrap(clusterDef,addedNodeNames,reports);
    provisionComponents(clusterDef,addedNodeNames,reports);
    success=true;
    clusterDef.getCurrentReport().setNodesAction(""String_Node_Str"",addedNodeNames);
    clusterDef.getCurrentReport().setNodesStatus(ServiceStatus.STARTED,addedNodeNames);
    clusterDef.getCurrentReport().setProgress(ProgressSplit.PROVISION_SUCCESS.getProgress());
    clusterDef.getCurrentReport().setSuccess(true);
  }
 catch (  Exception e) {
    clusterDef.getCurrentReport().setNodesError(""String_Node_Str"" + e.getMessage(),addedNodeNames);
    clusterDef.getCurrentReport().setSuccess(false);
    String errorMessage=errorMessage(""String_Node_Str"" + blueprint.getName(),e);
    logger.error(errorMessage,e);
    throw SoftwareManagementPluginException.SCALE_OUT_CLUSTER_FAILED(e,Constants.AMBARI_PLUGIN_NAME,blueprint.getName());
  }
 finally {
    clusterDef.getCurrentReport().setFinished(true);
    reportStatus(clusterDef.getCurrentReport(),reports);
  }
  return success;
}","@Override public boolean scaleOutCluster(ClusterBlueprint blueprint,List<String> addedNodeNames,ClusterReportQueue reports) throws SoftwareManagementPluginException {
  boolean success=false;
  AmClusterDef clusterDef=null;
  try {
    logger.info(""String_Node_Str"");
    logger.info(ApiUtils.objectToJson(blueprint));
    logger.info(""String_Node_Str"" + blueprint.getName() + ""String_Node_Str"");
    clusterDef=new AmClusterDef(blueprint,privateKey);
    bootstrap(clusterDef,addedNodeNames,reports);
    provisionComponents(clusterDef,addedNodeNames,reports);
    success=true;
    clusterDef.getCurrentReport().setNodesAction(""String_Node_Str"",addedNodeNames);
    clusterDef.getCurrentReport().setNodesStatus(ServiceStatus.STARTED,addedNodeNames);
    clusterDef.getCurrentReport().setProgress(ProgressSplit.PROVISION_SUCCESS.getProgress());
    clusterDef.getCurrentReport().setSuccess(true);
  }
 catch (  Exception e) {
    clusterDef.getCurrentReport().clearAllNodesErrorMsg();
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setNodesError(""String_Node_Str"" + e.getMessage(),addedNodeNames);
    clusterDef.getCurrentReport().setSuccess(false);
    String errorMessage=errorMessage(""String_Node_Str"" + blueprint.getName(),e);
    logger.error(errorMessage,e);
    throw SoftwareManagementPluginException.SCALE_OUT_CLUSTER_FAILED(e,Constants.AMBARI_PLUGIN_NAME,blueprint.getName());
  }
 finally {
    clusterDef.getCurrentReport().setFinished(true);
    reportStatus(clusterDef.getCurrentReport(),reports);
  }
  return success;
}"
48502,"/** 
 * connect to a Serengeti server
 * @param host host url with optional port
 * @param username serengeti login user name
 * @param password serengeti password
 */
public Connect.ConnectType connect(final String host,final String username,final String password){
  String oldHostUri=hostUri;
  hostUri=Constants.HTTPS_CONNECTION_PREFIX + host + Constants.HTTPS_CONNECTION_LOGIN_SUFFIX;
  Connect.ConnectType connectType=null;
  try {
    LoginResponse response=loginClient.login(hostUri,username,password);
    if (response.getResponseCode() == HttpStatus.OK.value()) {
      if (CommonUtil.isBlank(response.getSessionId())) {
        System.out.println(Constants.CONNECT_FAILURE_NO_SESSION_ID);
        connectType=Connect.ConnectType.ERROR;
      }
 else {
        updateHostProperty(host);
        writeCookieInfo(response.getSessionId());
        System.out.println(Constants.CONNECT_SUCCESS);
        connectType=Connect.ConnectType.SUCCESS;
      }
    }
 else     if (response.getResponseCode() == HttpStatus.UNAUTHORIZED.value()) {
      System.out.println(Constants.CONNECT_UNAUTHORIZATION_CONNECT);
      hostUri=oldHostUri;
      connectType=Connect.ConnectType.UNAUTHORIZATION;
    }
 else     if (response.getResponseCode() == HttpStatus.INTERNAL_SERVER_ERROR.value()) {
      System.out.println(HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase());
      connectType=Connect.ConnectType.ERROR;
    }
 else {
      System.out.println(String.format(Constants.UNSUPPORTED_HTTP_RESPONSE_CODE,response.getResponseCode()));
      hostUri=oldHostUri;
      connectType=Connect.ConnectType.ERROR;
    }
  }
 catch (  Exception e) {
    System.out.println(Constants.CONNECT_FAILURE + ""String_Node_Str"" + (CommandsUtils.getExceptionMessage(e)));
    connectType=Connect.ConnectType.ERROR;
  }
  return connectType;
}","/** 
 * connect to a Serengeti server
 * @param host host url with optional port
 * @param username serengeti login user name
 * @param password serengeti password
 */
public Connect.ConnectType connect(final String host,final String username,final String password){
  String oldHostUri=hostUri;
  hostUri=Constants.HTTPS_CONNECTION_PREFIX + host + Constants.HTTPS_CONNECTION_LOGIN_SUFFIX;
  Connect.ConnectType connectType=null;
  try {
    LoginResponse response=loginClient.login(hostUri,username,password);
    if (response.getResponseCode() == HttpStatus.OK.value()) {
      if (CommonUtil.isBlank(response.getSessionId())) {
        if (isConnected()) {
          System.out.println(Constants.CONNECTION_ALREADY_ESTABLISHED);
          connectType=Connect.ConnectType.SUCCESS;
        }
 else {
          System.out.println(Constants.CONNECT_FAILURE_NO_SESSION_ID);
          connectType=Connect.ConnectType.ERROR;
        }
      }
 else {
        updateHostProperty(host);
        writeCookieInfo(response.getSessionId());
        System.out.println(Constants.CONNECT_SUCCESS);
        connectType=Connect.ConnectType.SUCCESS;
      }
    }
 else     if (response.getResponseCode() == HttpStatus.UNAUTHORIZED.value()) {
      System.out.println(Constants.CONNECT_UNAUTHORIZATION_CONNECT);
      hostUri=oldHostUri;
      connectType=Connect.ConnectType.UNAUTHORIZATION;
    }
 else     if (response.getResponseCode() == HttpStatus.INTERNAL_SERVER_ERROR.value()) {
      System.out.println(HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase());
      connectType=Connect.ConnectType.ERROR;
    }
 else {
      System.out.println(String.format(Constants.UNSUPPORTED_HTTP_RESPONSE_CODE,response.getResponseCode()));
      hostUri=oldHostUri;
      connectType=Connect.ConnectType.ERROR;
    }
  }
 catch (  Exception e) {
    System.out.println(Constants.CONNECT_FAILURE + ""String_Node_Str"" + (CommandsUtils.getExceptionMessage(e)));
    connectType=Connect.ConnectType.ERROR;
  }
  return connectType;
}"
48503,"private void createConfigGroups(AmClusterDef clusterDef,Map<String,String> configTypeToService,List<AmNodeDef> targetNodeDefs) throws SoftwareManagementPluginException {
  List<ApiConfigGroup> configGroups=new ArrayList<>();
  Map<String,ApiConfigGroup> serviceToGroup=new HashMap<>();
  for (  AmNodeDef nodeDef : targetNodeDefs) {
    serviceToGroup.clear();
    List<Map<String,Object>> configs=nodeDef.getConfigurations();
    int i=1;
    for (    Map<String,Object> map : configs) {
      for (      String type : map.keySet()) {
        String serviceName=configTypeToService.get(type + ""String_Node_Str"");
        ApiConfigGroup confGroup=serviceToGroup.get(serviceName);
        if (confGroup == null) {
          confGroup=createConfigGroup(clusterDef,nodeDef,serviceName);
          serviceToGroup.put(serviceName,confGroup);
        }
        ApiConfigGroupConfiguration sameType=null;
        for (        ApiConfigGroupConfiguration config : confGroup.getApiConfigGroupInfo().getDesiredConfigs()) {
          if (config.getType().equals(type)) {
            sameType=config;
            break;
          }
        }
        if (sameType == null) {
          sameType=createApiConfigGroupConf(i,type,serviceName,confGroup);
        }
        Map<String,String> property=(Map<String,String>)map.get(type);
        sameType.getProperties().putAll(property);
      }
    }
    configGroups.addAll(serviceToGroup.values());
  }
  apiManager.createConfigGroups(clusterDef.getName(),configGroups);
}","private void createConfigGroups(AmClusterDef clusterDef,Map<String,String> configTypeToService,List<AmNodeDef> targetNodeDefs) throws SoftwareManagementPluginException {
  List<ApiConfigGroup> configGroups=new ArrayList<>();
  Map<String,ApiConfigGroup> serviceToGroup=new HashMap<>();
  for (  AmNodeDef nodeDef : targetNodeDefs) {
    serviceToGroup.clear();
    List<Map<String,Object>> configs=nodeDef.getConfigurations();
    int i=1;
    for (    Map<String,Object> map : configs) {
      for (      String type : map.keySet()) {
        String serviceName=configTypeToService.get(type + ""String_Node_Str"");
        ApiConfigGroup confGroup=serviceToGroup.get(serviceName);
        if (confGroup == null) {
          confGroup=createConfigGroup(clusterDef,nodeDef,serviceName);
          serviceToGroup.put(serviceName,confGroup);
        }
        ApiConfigGroupConfiguration sameType=null;
        for (        ApiConfigGroupConfiguration config : confGroup.getApiConfigGroupInfo().getDesiredConfigs()) {
          if (config.getType().equals(type)) {
            sameType=config;
            break;
          }
        }
        if (sameType == null) {
          sameType=createApiConfigGroupConf(i,type,serviceName,confGroup);
        }
        Map<String,String> property=(Map<String,String>)map.get(type);
        sameType.getProperties().putAll(property);
      }
    }
    configGroups.addAll(serviceToGroup.values());
  }
  if (configGroups.isEmpty()) {
    return;
  }
  logger.debug(""String_Node_Str"" + configGroups);
  apiManager.createConfigGroups(clusterDef.getName(),configGroups);
}"
48504,"private void stopAllComponents(AmClusterDef clusterDef,List<String> existingHosts,ClusterReportQueue reports) throws Exception {
  ApiRequest apiRequestSummary=apiManager.stopAllComponentsInHosts(clusterDef.getName(),existingHosts);
  if (apiRequestSummary.getApiRequestInfo() == null) {
    logger.debug(""String_Node_Str"");
    return;
  }
  ClusterOperationPoller poller=new ClusterOperationPoller(apiManager,apiRequestSummary,clusterDef.getName(),clusterDef.getCurrentReport(),reports,ProgressSplit.PROVISION_SUCCESS.getProgress());
  poller.waitForComplete();
  boolean success=false;
  ApiRequest apiRequest=apiManager.getRequest(clusterDef.getName(),apiRequestSummary.getApiRequestInfo().getRequestId());
  ClusterRequestStatus clusterRequestStatus=ClusterRequestStatus.valueOf(apiRequest.getApiRequestInfo().getRequestStatus());
  if (!clusterRequestStatus.isFailedState()) {
    success=true;
  }
  if (!success) {
    throw SoftwareManagementPluginException.STOP_CLUSTER_FAILED(AMBARI,clusterDef.getName());
  }
}","private void stopAllComponents(AmClusterDef clusterDef,List<String> existingHosts,ClusterReportQueue reports) throws Exception {
  ApiRequest apiRequestSummary=apiManager.stopAllComponentsInHosts(clusterDef.getName(),existingHosts);
  if (apiRequestSummary == null || apiRequestSummary.getApiRequestInfo() == null) {
    logger.debug(""String_Node_Str"");
    return;
  }
  ClusterOperationPoller poller=new ClusterOperationPoller(apiManager,apiRequestSummary,clusterDef.getName(),clusterDef.getCurrentReport(),reports,ProgressSplit.PROVISION_SUCCESS.getProgress());
  poller.waitForComplete();
  boolean success=false;
  ApiRequest apiRequest=apiManager.getRequest(clusterDef.getName(),apiRequestSummary.getApiRequestInfo().getRequestId());
  ClusterRequestStatus clusterRequestStatus=ClusterRequestStatus.valueOf(apiRequest.getApiRequestInfo().getRequestStatus());
  if (!clusterRequestStatus.isFailedState()) {
    success=true;
  }
  if (!success) {
    throw SoftwareManagementPluginException.STOP_CLUSTER_FAILED(AMBARI,clusterDef.getName());
  }
}"
48505,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void addAppManager(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String description,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String url){
  AppManagerAdd appManagerAdd=new AppManagerAdd();
  appManagerAdd.setName(name);
  appManagerAdd.setDescription(description);
  String[] types=restClient.getTypes();
  boolean found=false;
  for (  String t : types) {
    if (type.equals(t)) {
      found=true;
      break;
    }
  }
  if (found) {
    appManagerAdd.setType(type);
  }
 else {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"" + type + ""String_Node_Str""+ Arrays.asList(types)+ ""String_Node_Str"");
    return;
  }
  appManagerAdd.setUrl(url);
  Map<String,String> loginInfo=getAccount();
  if (null == loginInfo) {
    return;
  }
  appManagerAdd.setUsername(loginInfo.get(Constants.LOGIN_USERNAME));
  appManagerAdd.setPassword(loginInfo.get(Constants.LOGIN_PASSWORD));
  if (url.toLowerCase().startsWith(""String_Node_Str"")) {
    String sslCertificate=getSslCertificate();
    if (null != sslCertificate) {
      appManagerAdd.setSslCertificate(sslCertificate);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
      return;
    }
  }
  try {
    restClient.add(appManagerAdd);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_RESULT_ADD);
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void addAppManager(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String description,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String url){
  AppManagerAdd appManagerAdd=new AppManagerAdd();
  appManagerAdd.setName(name);
  appManagerAdd.setDescription(description);
  String[] types=restClient.getTypes();
  boolean found=false;
  for (  String t : types) {
    if (type.equals(t)) {
      found=true;
      break;
    }
  }
  if (found) {
    appManagerAdd.setType(type);
  }
 else {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"" + type + ""String_Node_Str""+ Arrays.asList(types)+ ""String_Node_Str"");
    return;
  }
  List<String> errorMsgs=new ArrayList<String>();
  if (!CommonUtil.validateUrl(url,errorMsgs)) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"" + CommonUtil.mergeErrorMsgList(errorMsgs) + ""String_Node_Str"");
    return;
  }
  appManagerAdd.setUrl(url);
  Map<String,String> loginInfo=getAccount();
  if (null == loginInfo) {
    return;
  }
  appManagerAdd.setUsername(loginInfo.get(Constants.LOGIN_USERNAME));
  appManagerAdd.setPassword(loginInfo.get(Constants.LOGIN_PASSWORD));
  if (url.toLowerCase().startsWith(""String_Node_Str"")) {
    String sslCertificate=getSslCertificate();
    if (null != sslCertificate) {
      appManagerAdd.setSslCertificate(sslCertificate);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
      return;
    }
  }
  try {
    restClient.add(appManagerAdd);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_RESULT_ADD);
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}"
48506,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void modifyAppManager(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String url,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean changeAccount,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean changeCertificate){
  if (url == null && !changeAccount && !changeCertificate) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
    return;
  }
  try {
    AppManagerRead appManagerRead=restClient.get(name);
    AppManagerAdd appManagerAdd=new AppManagerAdd();
    appManagerAdd.setName(name);
    appManagerAdd.setDescription(appManagerRead.getDescription());
    appManagerAdd.setType(appManagerRead.getType());
    if (url == null) {
      appManagerAdd.setUrl(appManagerRead.getUrl());
    }
 else {
      appManagerAdd.setUrl(url);
    }
    if (changeAccount) {
      Map<String,String> loginInfo=getAccount();
      if (null == loginInfo) {
        return;
      }
      appManagerAdd.setUsername(loginInfo.get(Constants.LOGIN_USERNAME));
      appManagerAdd.setPassword(loginInfo.get(Constants.LOGIN_PASSWORD));
    }
 else {
      appManagerAdd.setUsername(appManagerRead.getUsername());
      appManagerAdd.setPassword(appManagerRead.getPassword());
    }
    if ((url != null && url.toLowerCase().startsWith(""String_Node_Str"")) || (url == null && changeCertificate && appManagerAdd.getUrl().toLowerCase().startsWith(""String_Node_Str""))) {
      String sslCertificate=getSslCertificate();
      if (null == sslCertificate) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
        return;
      }
      appManagerAdd.setSslCertificate(sslCertificate);
    }
 else     if (url == null && changeCertificate && !appManagerAdd.getUrl().toLowerCase().startsWith(""String_Node_Str"")) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
      return;
    }
 else     if (url != null && !url.toLowerCase().startsWith(""String_Node_Str"")) {
      appManagerAdd.setSslCertificate(null);
    }
 else {
      appManagerAdd.setSslCertificate(appManagerRead.getSslCertificate());
    }
    restClient.modify(appManagerAdd);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_RESULT_MODIFY);
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void modifyAppManager(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String url,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean changeAccount,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean changeCertificate){
  if (url == null && !changeAccount && !changeCertificate) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
    return;
  }
  try {
    AppManagerRead appManagerRead=restClient.get(name);
    AppManagerAdd appManagerAdd=new AppManagerAdd();
    appManagerAdd.setName(name);
    appManagerAdd.setDescription(appManagerRead.getDescription());
    appManagerAdd.setType(appManagerRead.getType());
    if (url == null) {
      appManagerAdd.setUrl(appManagerRead.getUrl());
    }
 else {
      List<String> errorMsgs=new ArrayList<String>();
      if (!CommonUtil.validateUrl(url,errorMsgs)) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"" + CommonUtil.mergeErrorMsgList(errorMsgs) + ""String_Node_Str"");
        return;
      }
      appManagerAdd.setUrl(url);
    }
    if (changeAccount) {
      Map<String,String> loginInfo=getAccount();
      if (null == loginInfo) {
        return;
      }
      appManagerAdd.setUsername(loginInfo.get(Constants.LOGIN_USERNAME));
      appManagerAdd.setPassword(loginInfo.get(Constants.LOGIN_PASSWORD));
    }
 else {
      appManagerAdd.setUsername(appManagerRead.getUsername());
      appManagerAdd.setPassword(appManagerRead.getPassword());
    }
    if ((url != null && url.toLowerCase().startsWith(""String_Node_Str"")) || (url == null && changeCertificate && appManagerAdd.getUrl().toLowerCase().startsWith(""String_Node_Str""))) {
      String sslCertificate=getSslCertificate();
      if (null == sslCertificate) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
        return;
      }
      appManagerAdd.setSslCertificate(sslCertificate);
    }
 else     if (url == null && changeCertificate && !appManagerAdd.getUrl().toLowerCase().startsWith(""String_Node_Str"")) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
      return;
    }
 else     if (url != null && !url.toLowerCase().startsWith(""String_Node_Str"")) {
      appManagerAdd.setSslCertificate(null);
    }
 else {
      appManagerAdd.setSslCertificate(appManagerRead.getSslCertificate());
    }
    restClient.modify(appManagerAdd);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_RESULT_MODIFY);
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}"
48507,"@SuppressWarnings(""String_Node_Str"") public ClusterRead toClusterRead(String clusterName,boolean ignoreObsoleteNode){
  ClusterEntity cluster=findByName(clusterName);
  ClusterStatus clusterStatus=cluster.getStatus();
  ClusterRead clusterRead=new ClusterRead();
  clusterRead.setInstanceNum(cluster.getRealInstanceNum(ignoreObsoleteNode));
  clusterRead.setName(cluster.getName());
  clusterRead.setStatus(clusterStatus);
  clusterRead.setAppManager(cluster.getAppManager());
  clusterRead.setDistro(cluster.getDistro());
  clusterRead.setDistroVendor(cluster.getDistroVendor());
  clusterRead.setTopologyPolicy(cluster.getTopologyPolicy());
  clusterRead.setAutomationEnable(cluster.getAutomationEnable());
  clusterRead.setVhmMinNum(cluster.getVhmMinNum());
  clusterRead.setVhmMaxNum(cluster.getVhmMaxNum());
  clusterRead.setVhmTargetNum(cluster.getVhmTargetNum());
  clusterRead.setIoShares(cluster.getIoShares());
  clusterRead.setVersion(cluster.getVersion());
  if (!CommonUtil.isBlank(cluster.getAdvancedProperties())) {
    Gson gson=new Gson();
    Map<String,String> advancedProperties=gson.fromJson(cluster.getAdvancedProperties(),Map.class);
    clusterRead.setExternalHDFS(advancedProperties.get(""String_Node_Str""));
    clusterRead.setExternalMapReduce(advancedProperties.get(""String_Node_Str""));
  }
  SoftwareManager softMgr=softwareManagerCollector.getSoftwareManager(cluster.getAppManager());
  if (softMgr == null) {
    logger.error(""String_Node_Str"");
    throw ClusterConfigException.FAILED_TO_GET_SOFTWARE_MANAGER(cluster.getAppManager());
  }
  List<NodeGroupRead> groupList=new ArrayList<NodeGroupRead>();
  for (  NodeGroupEntity group : cluster.getNodeGroups()) {
    NodeGroupRead groupRead=group.toNodeGroupRead(ignoreObsoleteNode);
    groupRead.setComputeOnly(softMgr.isComputeOnlyRoles(groupRead.getRoles()));
    groupList.add(groupRead);
  }
  clusterRead.setNodeGroups(groupList);
  Set<VcResourcePoolEntity> rps=cluster.getUsedRps();
  List<ResourcePoolRead> rpReads=new ArrayList<ResourcePoolRead>(rps.size());
  for (  VcResourcePoolEntity rp : rps) {
    ResourcePoolRead rpRead=rp.toRest();
    rpRead.setNodes(null);
    rpReads.add(rpRead);
  }
  clusterRead.setResourcePools(rpReads);
  if (clusterStatus.isActiveServiceStatus() || clusterStatus == ClusterStatus.STOPPED) {
    clusterRead.setDcSeperation(clusterRead.validateSetManualElasticity());
  }
  return clusterRead;
}","@SuppressWarnings(""String_Node_Str"") public ClusterRead toClusterRead(String clusterName,boolean ignoreObsoleteNode){
  ClusterEntity cluster=findByName(clusterName);
  if (cluster == null) {
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ClusterStatus clusterStatus=cluster.getStatus();
  ClusterRead clusterRead=new ClusterRead();
  clusterRead.setInstanceNum(cluster.getRealInstanceNum(ignoreObsoleteNode));
  clusterRead.setName(cluster.getName());
  clusterRead.setStatus(clusterStatus);
  clusterRead.setAppManager(cluster.getAppManager());
  clusterRead.setDistro(cluster.getDistro());
  clusterRead.setDistroVendor(cluster.getDistroVendor());
  clusterRead.setTopologyPolicy(cluster.getTopologyPolicy());
  clusterRead.setAutomationEnable(cluster.getAutomationEnable());
  clusterRead.setVhmMinNum(cluster.getVhmMinNum());
  clusterRead.setVhmMaxNum(cluster.getVhmMaxNum());
  clusterRead.setVhmTargetNum(cluster.getVhmTargetNum());
  clusterRead.setIoShares(cluster.getIoShares());
  clusterRead.setVersion(cluster.getVersion());
  if (!CommonUtil.isBlank(cluster.getAdvancedProperties())) {
    Gson gson=new Gson();
    Map<String,String> advancedProperties=gson.fromJson(cluster.getAdvancedProperties(),Map.class);
    clusterRead.setExternalHDFS(advancedProperties.get(""String_Node_Str""));
    clusterRead.setExternalMapReduce(advancedProperties.get(""String_Node_Str""));
  }
  SoftwareManager softMgr=softwareManagerCollector.getSoftwareManager(cluster.getAppManager());
  if (softMgr == null) {
    logger.error(""String_Node_Str"");
    throw ClusterConfigException.FAILED_TO_GET_SOFTWARE_MANAGER(cluster.getAppManager());
  }
  List<NodeGroupRead> groupList=new ArrayList<NodeGroupRead>();
  for (  NodeGroupEntity group : cluster.getNodeGroups()) {
    NodeGroupRead groupRead=group.toNodeGroupRead(ignoreObsoleteNode);
    groupRead.setComputeOnly(softMgr.isComputeOnlyRoles(groupRead.getRoles()));
    groupList.add(groupRead);
  }
  clusterRead.setNodeGroups(groupList);
  Set<VcResourcePoolEntity> rps=cluster.getUsedRps();
  List<ResourcePoolRead> rpReads=new ArrayList<ResourcePoolRead>(rps.size());
  for (  VcResourcePoolEntity rp : rps) {
    ResourcePoolRead rpRead=rp.toRest();
    rpRead.setNodes(null);
    rpReads.add(rpRead);
  }
  clusterRead.setResourcePools(rpReads);
  if (clusterStatus.isActiveServiceStatus() || clusterStatus == ClusterStatus.STOPPED) {
    clusterRead.setDcSeperation(clusterRead.validateSetManualElasticity());
  }
  return clusterRead;
}"
48508,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void modifyAppManager(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String url,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean changeAccount,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean changeCertificate){
  if (url == null && !changeAccount && !changeCertificate) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
    return;
  }
  try {
    AppManagerRead appManagerRead=restClient.get(name);
    AppManagerAdd appManagerAdd=new AppManagerAdd();
    appManagerAdd.setName(name);
    appManagerAdd.setDescription(appManagerRead.getDescription());
    appManagerAdd.setType(appManagerRead.getType());
    if (url == null) {
      appManagerAdd.setUrl(appManagerRead.getUrl());
    }
 else {
      List<String> errorMsgs=new ArrayList<String>();
      if (!CommonUtil.validateUrl(url,errorMsgs)) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"" + CommonUtil.mergeErrorMsgList(errorMsgs) + ""String_Node_Str"");
        return;
      }
      appManagerAdd.setUrl(url);
    }
    if (changeAccount) {
      Map<String,String> loginInfo=getAccount();
      if (null == loginInfo) {
        return;
      }
      appManagerAdd.setUsername(loginInfo.get(Constants.LOGIN_USERNAME));
      appManagerAdd.setPassword(loginInfo.get(Constants.LOGIN_PASSWORD));
    }
 else {
      appManagerAdd.setUsername(appManagerRead.getUsername());
      appManagerAdd.setPassword(appManagerRead.getPassword());
    }
    if ((url != null && url.toLowerCase().startsWith(""String_Node_Str"")) || (url == null && changeCertificate && appManagerAdd.getUrl().toLowerCase().startsWith(""String_Node_Str""))) {
      String sslCertificate=getSslCertificate();
      if (null == sslCertificate) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
        return;
      }
      appManagerAdd.setSslCertificate(sslCertificate);
    }
 else     if (url == null && changeCertificate && !appManagerAdd.getUrl().toLowerCase().startsWith(""String_Node_Str"")) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
      return;
    }
 else     if (url != null && !url.toLowerCase().startsWith(""String_Node_Str"")) {
      appManagerAdd.setSslCertificate(null);
    }
 else {
      appManagerAdd.setSslCertificate(appManagerRead.getSslCertificate());
    }
    restClient.modify(appManagerAdd);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_RESULT_MODIFY);
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void modifyAppManager(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String url,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean changeAccount,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean changeCertificate){
  if (url == null && !changeAccount && !changeCertificate) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
    return;
  }
  if (Constants.IRONFAN.equals(name)) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
    return;
  }
  try {
    AppManagerRead appManagerRead=restClient.get(name);
    List<String> clusters=appManagerRead.getManagedClusters();
    if (clusters != null && clusters.size() > 0) {
      List<String> warningMsgList=new ArrayList<String>(1);
      warningMsgList.add(""String_Node_Str"" + name + ""String_Node_Str""+ clusters+ ""String_Node_Str"");
      if (!CommandsUtils.showWarningMsg(name,Constants.OUTPUT_OBJECT_APPMANAGER,Constants.OUTPUT_OP_MODIFY,warningMsgList,false)) {
        return;
      }
    }
    AppManagerAdd appManagerAdd=new AppManagerAdd();
    appManagerAdd.setName(name);
    appManagerAdd.setDescription(appManagerRead.getDescription());
    appManagerAdd.setType(appManagerRead.getType());
    if (url == null) {
      appManagerAdd.setUrl(appManagerRead.getUrl());
    }
 else {
      List<String> errorMsgs=new ArrayList<String>();
      if (!CommonUtil.validateUrl(url,errorMsgs)) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"" + CommonUtil.mergeErrorMsgList(errorMsgs) + ""String_Node_Str"");
        return;
      }
      appManagerAdd.setUrl(url);
    }
    if (changeAccount) {
      Map<String,String> loginInfo=getAccount();
      if (null == loginInfo) {
        return;
      }
      appManagerAdd.setUsername(loginInfo.get(Constants.LOGIN_USERNAME));
      appManagerAdd.setPassword(loginInfo.get(Constants.LOGIN_PASSWORD));
    }
 else {
      appManagerAdd.setUsername(appManagerRead.getUsername());
      appManagerAdd.setPassword(appManagerRead.getPassword());
    }
    if ((url != null && url.toLowerCase().startsWith(""String_Node_Str"")) || (url == null && changeCertificate && appManagerAdd.getUrl().toLowerCase().startsWith(""String_Node_Str""))) {
      String sslCertificate=getSslCertificate();
      if (null == sslCertificate) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
        return;
      }
      appManagerAdd.setSslCertificate(sslCertificate);
    }
 else     if (url == null && changeCertificate && !appManagerAdd.getUrl().toLowerCase().startsWith(""String_Node_Str"")) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
      return;
    }
 else     if (url != null && !url.toLowerCase().startsWith(""String_Node_Str"")) {
      appManagerAdd.setSslCertificate(null);
    }
 else {
      appManagerAdd.setSslCertificate(appManagerRead.getSslCertificate());
    }
    restClient.modify(appManagerAdd);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_RESULT_MODIFY);
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}"
48509,"public List<AppManagerRead> getAllAppManagerReads(){
  logger.debug(""String_Node_Str"");
  List<AppManagerRead> appManagerReads=appManagerService.getAllAppManagerReads();
  logger.debug(""String_Node_Str"");
  return appManagerReads;
}","public List<AppManagerRead> getAllAppManagerReads(){
  logger.debug(""String_Node_Str"");
  List<AppManagerRead> appManagerReads=appManagerService.getAllAppManagerReads();
  for (  AppManagerRead appManagerRead : appManagerReads) {
    updateManagedClusters(appManagerRead);
  }
  logger.debug(""String_Node_Str"");
  return appManagerReads;
}"
48510,"/** 
 * @param appManagerRead
 */
private void setAppManagerReadDynamicProperties(AppManagerRead appManagerRead){
  appManagerRead.setManagedClusters(clusterEntityManager.findByAppManager(appManagerRead.getName()));
  String softMgrVersion=""String_Node_Str"";
  final SoftwareManager softwareManager=this.getSoftwareManager(appManagerRead.getName());
  if (softwareManager != null) {
    ExecutorService exec=Executors.newFixedThreadPool(1);
    Future<String> futureResult=exec.submit(new Callable<String>(){
      @Override public String call() throws Exception {
        return softwareManager.getVersion();
      }
    }
);
    String result=(String)waitForThreadResult(futureResult);
    if (null != result) {
      softMgrVersion=result;
    }
    exec.shutdown();
    appManagerRead.setVersion(softMgrVersion);
  }
}","/** 
 * @param appManagerRead
 */
private void setAppManagerReadDynamicProperties(AppManagerRead appManagerRead){
  updateManagedClusters(appManagerRead);
  updateVersion(appManagerRead);
}"
48511,"@Override @Transactional(readOnly=true) public List<AppManagerRead> getAllAppManagerReads(){
  List<AppManagerEntity> entities=appManagerDAO.findAllSortByName();
  List<AppManagerRead> reads=new ArrayList<AppManagerRead>();
  AppManagerRead read;
  for (  AppManagerEntity entity : entities) {
    reads.add(toAppManagerRead(entity));
  }
  return reads;
}","@Override @Transactional(readOnly=true) public List<AppManagerRead> getAllAppManagerReads(){
  List<AppManagerEntity> entities=appManagerDAO.findAllSortByName();
  List<AppManagerRead> reads=new ArrayList<AppManagerRead>();
  for (  AppManagerEntity entity : entities) {
    reads.add(toAppManagerRead(entity));
  }
  return reads;
}"
48512,"@Override public boolean poll(){
  Long requestId=apiBootstrap.getRequestId();
  logger.info(""String_Node_Str"" + requestId + ""String_Node_Str"");
  ApiBootstrapStatus apiBootstrapStatus=apiManager.getBootstrapStatus(requestId);
  int registeredHostsCount=0;
  ApiHostList apiHostList=apiManager.getRegisteredHosts();
  for (  ApiBootstrapHostStatus apiBootstrapHostStatus : apiBootstrapStatus.getApiBootstrapHostStatus()) {
    for (    ApiHost apiHost : apiHostList.getApiHosts()) {
      if (apiHost.getApiHostInfo().getHostName().equals(apiBootstrapHostStatus.getHostName())) {
        registeredHostsCount++;
      }
    }
  }
  int bootstrapedHostCount=apiBootstrapStatus.getApiBootstrapHostStatus().size();
  BootstrapStatus bootstrapStatus=BootstrapStatus.valueOf(apiBootstrapStatus.getStatus());
  if (bootstrapStatus.isCompletedState() && bootstrapedHostCount == registeredHostsCount) {
    currentReport.setProgress(endProgress);
    reportQueue.addClusterReport(currentReport.clone());
    return true;
  }
  return false;
}","@Override public boolean poll(){
  Long requestId=apiBootstrap.getRequestId();
  logger.info(""String_Node_Str"" + requestId + ""String_Node_Str"");
  ApiBootstrapStatus apiBootstrapStatus=apiManager.getBootstrapStatus(requestId);
  if (apiBootstrapStatus.getApiBootstrapHostStatus() == null) {
    return false;
  }
  int registeredHostsCount=0;
  ApiHostList apiHostList=apiManager.getRegisteredHosts();
  for (  ApiBootstrapHostStatus apiBootstrapHostStatus : apiBootstrapStatus.getApiBootstrapHostStatus()) {
    for (    ApiHost apiHost : apiHostList.getApiHosts()) {
      if (apiHost.getApiHostInfo().getHostName().equals(apiBootstrapHostStatus.getHostName())) {
        registeredHostsCount++;
      }
    }
  }
  int bootstrapedHostCount=apiBootstrapStatus.getApiBootstrapHostStatus().size();
  BootstrapStatus bootstrapStatus=BootstrapStatus.valueOf(apiBootstrapStatus.getStatus());
  if (bootstrapStatus.isFailedState() || (bootstrapStatus.isSucceedState() && bootstrapedHostCount == registeredHostsCount)) {
    if (bootstrapStatus.isFailedState()) {
      Map<String,NodeReport> nodeReports=currentReport.getNodeReports();
      for (      String nodeReportKey : nodeReports.keySet()) {
        for (        ApiBootstrapHostStatus apiBootstrapHostStatus : apiBootstrapStatus.getApiBootstrapHostStatus()) {
          if (Constants.HOST_BOOTSTRAP_FAILED.equals(apiBootstrapHostStatus.getStatus())) {
            NodeReport nodeReport=nodeReports.get(nodeReportKey);
            nodeReport.setUseClusterMsg(false);
            nodeReport.setAction(""String_Node_Str"");
            if (nodeReport.getHostname().equals(apiBootstrapHostStatus.getHostName())) {
              nodeReport.setErrMsg(apiBootstrapHostStatus.getLog());
            }
          }
        }
      }
    }
    currentReport.setProgress(endProgress);
    reportQueue.addClusterReport(currentReport.clone());
    return true;
  }
  return false;
}"
48513,"@Override public boolean createCluster(ClusterBlueprint blueprint,ClusterReportQueue reportQueue) throws SoftwareManagementPluginException {
  boolean success=false;
  AmClusterDef clusterDef=null;
  try {
    logger.info(""String_Node_Str"");
    logger.info(ApiUtils.objectToJson(blueprint));
    logger.info(""String_Node_Str"" + blueprint.getName() + ""String_Node_Str"");
    clusterDef=new AmClusterDef(blueprint,privateKey);
    provisionCluster(clusterDef,reportQueue);
    success=true;
    Map<String,NodeReport> nodeReports=clusterDef.getCurrentReport().getNodeReports();
    for (    String nodeReportKey : nodeReports.keySet()) {
      nodeReports.get(nodeReportKey).setUseClusterMsg(true);
    }
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setProgress(ProgressSplit.PROVISION_SUCCESS.getProgress());
    clusterDef.getCurrentReport().setSuccess(true);
  }
 catch (  Exception e) {
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setSuccess(false);
    String errorMessage=errorMessage(""String_Node_Str"" + blueprint.getName(),e);
    logger.error(errorMessage);
    throw SoftwareManagementPluginException.CREATE_CLUSTER_EXCEPTION(e,AMBARI,blueprint.getName());
  }
 finally {
    clusterDef.getCurrentReport().setFinished(true);
    reportStatus(clusterDef.getCurrentReport(),reportQueue);
  }
  return success;
}","@Override public boolean createCluster(ClusterBlueprint blueprint,ClusterReportQueue reportQueue) throws SoftwareManagementPluginException {
  boolean success=false;
  AmClusterDef clusterDef=null;
  try {
    logger.info(""String_Node_Str"");
    logger.info(ApiUtils.objectToJson(blueprint));
    logger.info(""String_Node_Str"" + blueprint.getName() + ""String_Node_Str"");
    clusterDef=new AmClusterDef(blueprint,privateKey);
    provisionCluster(clusterDef,reportQueue);
    success=true;
    Map<String,NodeReport> nodeReports=clusterDef.getCurrentReport().getNodeReports();
    for (    String nodeReportKey : nodeReports.keySet()) {
      nodeReports.get(nodeReportKey).setUseClusterMsg(true);
    }
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setProgress(ProgressSplit.PROVISION_SUCCESS.getProgress());
    clusterDef.getCurrentReport().setSuccess(true);
  }
 catch (  Exception e) {
    clusterDef.getCurrentReport().setSuccess(false);
    String errorMessage=errorMessage(""String_Node_Str"" + blueprint.getName(),e);
    logger.error(errorMessage);
    throw SoftwareManagementPluginException.CREATE_CLUSTER_EXCEPTION(e,AMBARI,blueprint.getName());
  }
 finally {
    clusterDef.getCurrentReport().setFinished(true);
    reportStatus(clusterDef.getCurrentReport(),reportQueue);
  }
  return success;
}"
48514,"private void bootstrap(final AmClusterDef clusterDef,final List<String> addedHosts,final ClusterReportQueue reportQueue) throws SoftwareManagementPluginException {
  try {
    if (addedHosts != null) {
      logger.info(""String_Node_Str"" + addedHosts);
      clusterDef.getCurrentReport().setNodesAction(""String_Node_Str"",addedHosts);
      clusterDef.getCurrentReport().setProgress(ProgressSplit.BOOTSTRAP_HOSTS.getProgress());
    }
 else {
      logger.info(""String_Node_Str"" + clusterDef.getName());
      clusterDef.getCurrentReport().setAction(""String_Node_Str"");
      clusterDef.getCurrentReport().setProgress(ProgressSplit.BOOTSTRAP_HOSTS.getProgress());
    }
    reportStatus(clusterDef.getCurrentReport(),reportQueue);
    ApiBootstrap apiBootstrapRequest=apiManager.createBootstrap(clusterDef.toApiBootStrap(addedHosts));
    HostBootstrapPoller poller=new HostBootstrapPoller(apiManager,apiBootstrapRequest,clusterDef.getCurrentReport(),reportQueue,ProgressSplit.CREATE_BLUEPRINT.getProgress());
    poller.waitForComplete();
    logger.debug(""String_Node_Str"" + apiBootstrapRequest.getRequestId());
    boolean success=false;
    boolean allHostsBootstrapped=true;
    ApiBootstrapStatus apiBootstrapStatus=apiManager.getBootstrapStatus(apiBootstrapRequest.getRequestId());
    BootstrapStatus bootstrapStatus=BootstrapStatus.valueOf(apiBootstrapStatus.getStatus());
    logger.debug(""String_Node_Str"" + bootstrapStatus);
    if (!bootstrapStatus.isFailedState()) {
      success=true;
    }
    int bootstrapedHostCount=apiBootstrapStatus.getApiBootstrapHostStatus().size();
    int needBootstrapHostCount=-1;
    if (addedHosts == null) {
      needBootstrapHostCount=clusterDef.getNodes().size();
    }
 else {
      needBootstrapHostCount=addedHosts.size();
    }
    logger.debug(""String_Node_Str"" + needBootstrapHostCount);
    logger.debug(""String_Node_Str"" + bootstrapedHostCount);
    if (needBootstrapHostCount != bootstrapedHostCount) {
      success=false;
      allHostsBootstrapped=false;
    }
    if (!success) {
      List<String> notBootstrapNodes=new ArrayList<String>();
      if (!allHostsBootstrapped) {
        for (        AmNodeDef node : clusterDef.getNodes()) {
          boolean nodeBootstrapped=false;
          for (          ApiBootstrapHostStatus apiBootstrapHostStatus : apiBootstrapStatus.getApiBootstrapHostStatus()) {
            if (node.getFqdn().equals(apiBootstrapHostStatus.getHostName())) {
              nodeBootstrapped=true;
              break;
            }
          }
          if (!nodeBootstrapped) {
            notBootstrapNodes.add(node.getFqdn());
          }
        }
      }
      String actionFailure=""String_Node_Str"";
      if (addedHosts != null) {
        clusterDef.getCurrentReport().setNodesError(actionFailure,addedHosts);
      }
 else {
        clusterDef.getCurrentReport().setErrMsg(actionFailure);
      }
      throw AmException.BOOTSTRAP_FAILED(notBootstrapNodes != null ? notBootstrapNodes.toArray() : null);
    }
  }
 catch (  Exception e) {
    clusterDef.getCurrentReport().setErrMsg(""String_Node_Str"");
    String errorMessage=errorMessage(""String_Node_Str"" + clusterDef.getName(),e);
    logger.error(errorMessage);
    throw AmException.BOOTSTRAP_FAILED_EXCEPTION(e,clusterDef.getName());
  }
 finally {
    reportQueue.addClusterReport(clusterDef.getCurrentReport().clone());
  }
}","private void bootstrap(final AmClusterDef clusterDef,final List<String> addedHosts,final ClusterReportQueue reportQueue) throws SoftwareManagementPluginException {
  try {
    if (addedHosts != null) {
      logger.info(""String_Node_Str"" + addedHosts);
      clusterDef.getCurrentReport().setNodesAction(""String_Node_Str"",addedHosts);
      clusterDef.getCurrentReport().setProgress(ProgressSplit.BOOTSTRAP_HOSTS.getProgress());
    }
 else {
      logger.info(""String_Node_Str"" + clusterDef.getName());
      clusterDef.getCurrentReport().setAction(""String_Node_Str"");
      clusterDef.getCurrentReport().setProgress(ProgressSplit.BOOTSTRAP_HOSTS.getProgress());
    }
    reportStatus(clusterDef.getCurrentReport(),reportQueue);
    ApiBootstrap apiBootstrapRequest=apiManager.createBootstrap(clusterDef.toApiBootStrap(addedHosts));
    HostBootstrapPoller poller=new HostBootstrapPoller(apiManager,apiBootstrapRequest,clusterDef.getCurrentReport(),reportQueue,ProgressSplit.CREATE_BLUEPRINT.getProgress());
    poller.waitForComplete();
    logger.debug(""String_Node_Str"" + apiBootstrapRequest.getRequestId());
    boolean success=false;
    boolean allHostsBootstrapped=true;
    ApiBootstrapStatus apiBootstrapStatus=apiManager.getBootstrapStatus(apiBootstrapRequest.getRequestId());
    BootstrapStatus bootstrapStatus=BootstrapStatus.valueOf(apiBootstrapStatus.getStatus());
    logger.debug(""String_Node_Str"" + bootstrapStatus);
    if (!bootstrapStatus.isFailedState()) {
      success=true;
    }
    int bootstrapedHostCount=apiBootstrapStatus.getApiBootstrapHostStatus().size();
    int needBootstrapHostCount=-1;
    if (addedHosts == null) {
      needBootstrapHostCount=clusterDef.getNodes().size();
    }
 else {
      needBootstrapHostCount=addedHosts.size();
    }
    logger.debug(""String_Node_Str"" + needBootstrapHostCount);
    logger.debug(""String_Node_Str"" + bootstrapedHostCount);
    if (needBootstrapHostCount != bootstrapedHostCount) {
      success=false;
      allHostsBootstrapped=false;
    }
    if (!success) {
      List<String> notBootstrapNodes=new ArrayList<String>();
      if (!allHostsBootstrapped) {
        for (        AmNodeDef node : clusterDef.getNodes()) {
          boolean nodeBootstrapped=false;
          for (          ApiBootstrapHostStatus apiBootstrapHostStatus : apiBootstrapStatus.getApiBootstrapHostStatus()) {
            if (node.getFqdn().equals(apiBootstrapHostStatus.getHostName())) {
              nodeBootstrapped=true;
              break;
            }
          }
          if (!nodeBootstrapped) {
            notBootstrapNodes.add(node.getFqdn());
          }
        }
      }
      String actionFailure=Constants.HOST_BOOTSTRAP_MSG;
      if (addedHosts != null) {
        clusterDef.getCurrentReport().setNodesError(actionFailure,addedHosts);
      }
 else {
        clusterDef.getCurrentReport().setErrMsg(actionFailure);
      }
      throw AmException.BOOTSTRAP_FAILED(notBootstrapNodes != null ? notBootstrapNodes.toArray() : null);
    }
  }
 catch (  Exception e) {
    clusterDef.getCurrentReport().setAction(Constants.HOST_BOOTSTRAP_MSG);
    String errorMessage=errorMessage(""String_Node_Str"" + clusterDef.getName(),e);
    logger.error(errorMessage);
    throw AmException.BOOTSTRAP_FAILED_EXCEPTION(e,clusterDef.getName());
  }
 finally {
    reportQueue.addClusterReport(clusterDef.getCurrentReport().clone());
  }
}"
48515,"@Override public boolean poll(){
  Long requestId=apiBootstrap.getRequestId();
  logger.info(""String_Node_Str"" + requestId + ""String_Node_Str"");
  ApiBootstrapStatus apiBootstrapStatus=apiManager.getBootstrapStatus(requestId);
  BootstrapStatus bootstrapStatus=BootstrapStatus.valueOf(apiBootstrapStatus.getStatus());
  if (bootstrapStatus.isCompletedState()) {
    currentReport.setProgress(endProgress);
    reportQueue.addClusterReport(currentReport.clone());
    return true;
  }
  return false;
}","@Override public boolean poll(){
  Long requestId=apiBootstrap.getRequestId();
  logger.info(""String_Node_Str"" + requestId + ""String_Node_Str"");
  ApiBootstrapStatus apiBootstrapStatus=apiManager.getBootstrapStatus(requestId);
  int registeredHostsCount=0;
  ApiHostList apiHostList=apiManager.getRegisteredHosts();
  for (  ApiBootstrapHostStatus apiBootstrapHostStatus : apiBootstrapStatus.getApiBootstrapHostStatus()) {
    for (    ApiHost apiHost : apiHostList.getApiHosts()) {
      if (apiHost.getApiHostInfo().getHostName().equals(apiBootstrapHostStatus.getHostName())) {
        registeredHostsCount++;
      }
    }
  }
  int bootstrapedHostCount=apiBootstrapStatus.getApiBootstrapHostStatus().size();
  BootstrapStatus bootstrapStatus=BootstrapStatus.valueOf(apiBootstrapStatus.getStatus());
  if (bootstrapStatus.isCompletedState() && bootstrapedHostCount == registeredHostsCount) {
    currentReport.setProgress(endProgress);
    reportQueue.addClusterReport(currentReport.clone());
    return true;
  }
  return false;
}"
48516,"/** 
 * Create default cluster spec.
 * @param type cluster type
 * @return default cluster spec
 * @throws FileNotFoundException
 */
public static ClusterCreate createDefaultSpec(ClusterType type,String vendor,String distroVersion,String appManagerType) throws FileNotFoundException {
  if (vendor.trim().equalsIgnoreCase(Constants.MAPR_VENDOR)) {
switch (type) {
case HDFS_MAPRED:
      return loadFromFile(locateSpecFile(HDFS_MAPRED_MAPR_TEMPLATE_SPEC));
case HDFS_HBASE:
    return loadFromFile(locateSpecFile(HDFS_HBASE_MAPR_TEMPLATE_SPEC));
default :
  throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
 else if (vendor.trim().equalsIgnoreCase(Constants.GPHD_VENDOR)) {
switch (type) {
case HDFS:
return loadFromFile(locateSpecFile(HDFS_GPHD_TEMPLATE_SPEC));
case HDFS_MAPRED:
return loadFromFile(locateSpecFile(HDFS_MAPRED_GPHD_TEMPLATE_SPEC));
case HDFS_HBASE:
return loadFromFile(locateSpecFile(HDFS_HBASE_GPHD_TEMPLATE_SPEC));
default :
throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
 else if (Constants.AMBARI_PLUGIN_TYPE.equals(appManagerType) && vendor.trim().equalsIgnoreCase(Constants.HDP_VENDOR)) {
MAPREDUCE_VERSION mr=getDefaultMapReduceVersion(vendor,distroVersion);
if (type == null) {
if (mr == MAPREDUCE_VERSION.V1) {
return loadFromFile(locateSpecFile(AM_HDFS_MAPRED_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(AM_HDFS_YARN_TEMPLATE_SPEC));
}
}
HDFS_VERSION hdfs=getDefaultHdfsVersion(vendor,distroVersion);
switch (type) {
case HDFS:
if (hdfs == HDFS_VERSION.V1) {
return loadFromFile(locateSpecFile(AM_HDFS_V1_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(AM_HDFS_V2_TEMPLATE_SPEC));
}
case HDFS_MAPRED:
if (mr == MAPREDUCE_VERSION.V1) {
return loadFromFile(locateSpecFile(AM_HDFS_MAPRED_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(AM_HDFS_YARN_TEMPLATE_SPEC));
}
case HDFS_HBASE:
if (Configuration.getBoolean(Constants.AMBARI_HBASE_DEPEND_ON_MAPREDUCE)) {
if (hdfs == HDFS_VERSION.V1) {
return loadFromFile(locateSpecFile(AM_HDFS_V1_HBASE_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(AM_HDFS_V2_HBASE_TEMPLATE_SPEC));
}
}
 else {
return loadFromFile(locateSpecFile(AM_HDFS_PURE_HBASE_TEMPLATE_SPEC));
}
default :
throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
 else {
MAPREDUCE_VERSION mr=getDefaultMapReduceVersion(vendor,distroVersion);
if (Constants.CLOUDERA_MANAGER_PLUGIN_TYPE.equals(appManagerType)) {
if (mr == MAPREDUCE_VERSION.V1) {
return loadFromFile(locateSpecFile(CM_HDFS_MAPRED_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(CM_HDFS_YARN_TEMPLATE_SPEC));
}
}
switch (type) {
case HDFS:
return loadFromFile(locateSpecFile(HDFS_TEMPLATE_SPEC));
case HDFS_MAPRED:
if (mr == MAPREDUCE_VERSION.V1) {
return loadFromFile(locateSpecFile(HDFS_MAPRED_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(HDFS_YARN_TEMPLATE_SPEC));
}
case HDFS_HBASE:
return loadFromFile(locateSpecFile(HDFS_HBASE_TEMPLATE_SPEC));
default :
throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
}","/** 
 * Create default cluster spec.
 * @param type cluster type
 * @return default cluster spec
 * @throws FileNotFoundException
 */
public static ClusterCreate createDefaultSpec(ClusterType type,String vendor,String distroVersion,String appManagerType) throws FileNotFoundException {
  if (vendor.trim().equalsIgnoreCase(Constants.MAPR_VENDOR)) {
switch (type) {
case HDFS_MAPRED:
      return loadFromFile(locateSpecFile(HDFS_MAPRED_MAPR_TEMPLATE_SPEC));
case HDFS_HBASE:
    return loadFromFile(locateSpecFile(HDFS_HBASE_MAPR_TEMPLATE_SPEC));
default :
  throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
 else if (vendor.trim().equalsIgnoreCase(Constants.GPHD_VENDOR)) {
switch (type) {
case HDFS:
return loadFromFile(locateSpecFile(HDFS_GPHD_TEMPLATE_SPEC));
case HDFS_MAPRED:
return loadFromFile(locateSpecFile(HDFS_MAPRED_GPHD_TEMPLATE_SPEC));
case HDFS_HBASE:
return loadFromFile(locateSpecFile(HDFS_HBASE_GPHD_TEMPLATE_SPEC));
default :
throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
 else if (Constants.AMBARI_PLUGIN_TYPE.equals(appManagerType) && vendor.trim().equalsIgnoreCase(Constants.HDP_VENDOR)) {
MAPREDUCE_VERSION mr=getDefaultMapReduceVersion(vendor,distroVersion);
HDP_VERSION hdpVersion=getDefaultHdfsVersion(vendor,distroVersion);
if (type == null) {
if (mr == MAPREDUCE_VERSION.V1) {
return loadFromFile(locateSpecFile(AM_HDFS_MAPRED_TEMPLATE_SPEC));
}
 else {
if (hdpVersion == HDP_VERSION.V2_0) {
return loadFromFile(locateSpecFile(AM_HDP_2_0_HDFS_YARN_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(AM_HDP_2_1_HDFS_YARN_TEMPLATE_SPEC));
}
}
}
switch (type) {
case HDFS:
if (hdpVersion == HDP_VERSION.V1) {
return loadFromFile(locateSpecFile(AM_HDFS_V1_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(AM_HDFS_V2_TEMPLATE_SPEC));
}
case HDFS_MAPRED:
if (mr == MAPREDUCE_VERSION.V1) {
return loadFromFile(locateSpecFile(AM_HDFS_MAPRED_TEMPLATE_SPEC));
}
 else {
if (hdpVersion == HDP_VERSION.V2_0) {
return loadFromFile(locateSpecFile(AM_HDP_2_0_HDFS_YARN_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(AM_HDP_2_1_HDFS_YARN_TEMPLATE_SPEC));
}
}
case HDFS_HBASE:
if (Configuration.getBoolean(Constants.AMBARI_HBASE_DEPEND_ON_MAPREDUCE)) {
if (hdpVersion == HDP_VERSION.V1) {
return loadFromFile(locateSpecFile(AM_HDFS_V1_HBASE_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(AM_HDFS_V2_HBASE_TEMPLATE_SPEC));
}
}
 else {
return loadFromFile(locateSpecFile(AM_HDFS_PURE_HBASE_TEMPLATE_SPEC));
}
default :
throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
 else {
MAPREDUCE_VERSION mr=getDefaultMapReduceVersion(vendor,distroVersion);
if (Constants.CLOUDERA_MANAGER_PLUGIN_TYPE.equals(appManagerType)) {
if (mr == MAPREDUCE_VERSION.V1) {
return loadFromFile(locateSpecFile(CM_HDFS_MAPRED_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(CM_HDFS_YARN_TEMPLATE_SPEC));
}
}
switch (type) {
case HDFS:
return loadFromFile(locateSpecFile(HDFS_TEMPLATE_SPEC));
case HDFS_MAPRED:
if (mr == MAPREDUCE_VERSION.V1) {
return loadFromFile(locateSpecFile(HDFS_MAPRED_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(HDFS_YARN_TEMPLATE_SPEC));
}
case HDFS_HBASE:
return loadFromFile(locateSpecFile(HDFS_HBASE_TEMPLATE_SPEC));
default :
throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
}"
48517,"private static HDFS_VERSION getDefaultHdfsVersion(String vendor,String distroVersion){
  if (vendor.trim().equalsIgnoreCase(Constants.HDP_VENDOR)) {
    if (distroVersion.startsWith(""String_Node_Str"")) {
      return HDFS_VERSION.V2;
    }
 else {
      return HDFS_VERSION.V1;
    }
  }
  logger.error(""String_Node_Str"");
  return HDFS_VERSION.V2;
}","private static HDP_VERSION getDefaultHdfsVersion(String vendor,String distroVersion){
  if (vendor.trim().equalsIgnoreCase(Constants.HDP_VENDOR)) {
    if (distroVersion.startsWith(""String_Node_Str"")) {
      return HDP_VERSION.V2_1;
    }
 else     if (distroVersion.startsWith(""String_Node_Str"")) {
      return HDP_VERSION.V2_0;
    }
 else {
      return HDP_VERSION.V1;
    }
  }
  logger.error(""String_Node_Str"");
  return HDP_VERSION.V2_1;
}"
48518,"private void validateRoleDependencies(List<NodeGroupInfo> nodeGroups,List<ApiStackComponent> apiStackComponents,Map<String,Integer> definedRoles){
  if (nodeGroups == null || nodeGroups.isEmpty()) {
    return;
  }
  Set<String> allRoles=new HashSet<String>();
  for (  NodeGroupInfo group : nodeGroups) {
    allRoles.addAll(group.getRoles());
  }
  for (  String role : allRoles) {
    List<String> NotExistDenpendencyNames=new ArrayList<String>();
    for (    ApiStackComponent apiStackComponent : apiStackComponents) {
      List<ApiComponentDependency> apiComponentDependencies=apiStackComponent.getApiComponentDependencies();
      if (apiComponentDependencies != null && !apiComponentDependencies.isEmpty()) {
        for (        ApiComponentDependency dependency : apiComponentDependencies) {
          ApiComponentDependencyInfo dependencyInfo=dependency.getApiComponentDependencyInfo();
          if (role.equals(dependencyInfo.getDependentComponentName())) {
            String denpendencyName=dependencyInfo.getComponentName();
            if (!allRoles.contains(denpendencyName)) {
              NotExistDenpendencyNames.add(denpendencyName);
            }
          }
        }
      }
      ApiComponentInfo apiComponentInfo=apiStackComponent.getApiComponent();
      if (role.equals(apiComponentInfo.getComponentName())) {
        Set<String> roleCategoryDependencies=validateRoleCategoryDependencies(apiComponentInfo,allRoles);
        if (roleCategoryDependencies != null && !roleCategoryDependencies.isEmpty()) {
          NotExistDenpendencyNames.addAll(roleCategoryDependencies);
        }
      }
    }
    if (!NotExistDenpendencyNames.isEmpty()) {
      warningMsgList.add(""String_Node_Str"" + role + ""String_Node_Str""+ NotExistDenpendencyNames.toString());
    }
  }
}","private void validateRoleDependencies(List<NodeGroupInfo> nodeGroups,List<ApiStackComponent> apiStackComponents,List<String> unRecogRoles){
  if (nodeGroups == null || nodeGroups.isEmpty()) {
    return;
  }
  Set<String> allRoles=new HashSet<String>();
  for (  NodeGroupInfo group : nodeGroups) {
    allRoles.addAll(group.getRoles());
  }
  for (  String role : allRoles) {
    List<String> NotExistDenpendencyNames=new ArrayList<String>();
    for (    ApiStackComponent apiStackComponent : apiStackComponents) {
      List<ApiComponentDependency> apiComponentDependencies=apiStackComponent.getApiComponentDependencies();
      if (apiComponentDependencies != null && !apiComponentDependencies.isEmpty()) {
        for (        ApiComponentDependency dependency : apiComponentDependencies) {
          ApiComponentDependencyInfo dependencyInfo=dependency.getApiComponentDependencyInfo();
          if (role.equals(dependencyInfo.getDependentComponentName())) {
            String denpendencyName=dependencyInfo.getComponentName();
            if (!allRoles.contains(denpendencyName)) {
              NotExistDenpendencyNames.add(denpendencyName);
            }
          }
        }
      }
      ApiComponentInfo apiComponentInfo=apiStackComponent.getApiComponent();
      if (role.equals(apiComponentInfo.getComponentName())) {
        Set<String> roleCategoryDependencies=validateRoleCategoryDependencies(apiComponentInfo,allRoles,unRecogRoles);
        if (roleCategoryDependencies != null && !roleCategoryDependencies.isEmpty()) {
          NotExistDenpendencyNames.addAll(roleCategoryDependencies);
        }
      }
    }
    if (!NotExistDenpendencyNames.isEmpty()) {
      warningMsgList.add(""String_Node_Str"" + role + ""String_Node_Str""+ NotExistDenpendencyNames.toString());
    }
  }
}"
48519,"private void validateRoles(ClusterBlueprint blueprint,List<String> unRecogConfigTypes,List<String> unRecogConfigKeys,String stackVendor,String stackVersion,String distro){
  Map<String,Integer> definedRoles=new HashMap<String,Integer>();
  List<String> unRecogRoles=null;
  List<NodeGroupInfo> nodeGroups=blueprint.getNodeGroups();
  if (nodeGroups == null || nodeGroups.isEmpty()) {
    return;
  }
  ApiStackServiceList servicesList=apiManager.getStackServiceListWithComponents(stackVendor,stackVersion);
  List<ApiStackComponent> apiStackComponents=new ArrayList<ApiStackComponent>();
  for (  ApiStackService apiStackService : servicesList.getApiStackServices()) {
    for (    ApiStackComponent apiStackComponent : apiStackService.getServiceComponents()) {
      apiStackComponents.add(apiStackComponent);
    }
  }
  for (  NodeGroupInfo group : nodeGroups) {
    validateConfigs(group.getConfiguration(),unRecogConfigTypes,unRecogConfigKeys,stackVendor,stackVersion);
    for (    String roleName : group.getRoles()) {
      boolean isSupported=false;
      for (      ApiStackComponent apiStackComponent : apiStackComponents) {
        if (roleName.equals(apiStackComponent.getApiComponent().getComponentName())) {
          isSupported=true;
          if (isSupported) {
            continue;
          }
        }
      }
      if (!isSupported) {
        if (unRecogRoles == null) {
          unRecogRoles=new ArrayList<String>();
        }
        unRecogRoles.add(roleName);
        continue;
      }
 else {
        if (!definedRoles.containsKey(roleName)) {
          definedRoles.put(roleName,group.getInstanceNum());
        }
 else {
          Integer instanceNum=definedRoles.get(roleName) + group.getInstanceNum();
          definedRoles.put(roleName,instanceNum);
        }
      }
    }
  }
  if (unRecogRoles != null && !unRecogRoles.isEmpty()) {
    errorMsgList.add(""String_Node_Str"" + unRecogRoles.toString() + ""String_Node_Str""+ distro);
  }
  validateRoleDependencies(nodeGroups,apiStackComponents,definedRoles);
}","private void validateRoles(ClusterBlueprint blueprint,List<String> unRecogConfigTypes,List<String> unRecogConfigKeys,String stackVendor,String stackVersion,String distro){
  Map<String,Integer> definedRoles=new HashMap<String,Integer>();
  List<String> unRecogRoles=null;
  List<NodeGroupInfo> nodeGroups=blueprint.getNodeGroups();
  if (nodeGroups == null || nodeGroups.isEmpty()) {
    return;
  }
  ApiStackServiceList servicesList=apiManager.getStackServiceListWithComponents(stackVendor,stackVersion);
  List<ApiStackComponent> apiStackComponents=new ArrayList<ApiStackComponent>();
  for (  ApiStackService apiStackService : servicesList.getApiStackServices()) {
    for (    ApiStackComponent apiStackComponent : apiStackService.getServiceComponents()) {
      apiStackComponents.add(apiStackComponent);
    }
  }
  for (  NodeGroupInfo group : nodeGroups) {
    validateConfigs(group.getConfiguration(),unRecogConfigTypes,unRecogConfigKeys,stackVendor,stackVersion);
    for (    String roleName : group.getRoles()) {
      boolean isSupported=false;
      for (      ApiStackComponent apiStackComponent : apiStackComponents) {
        if (roleName.equals(apiStackComponent.getApiComponent().getComponentName())) {
          isSupported=true;
          if (isSupported) {
            continue;
          }
        }
      }
      if (!isSupported) {
        if (unRecogRoles == null) {
          unRecogRoles=new ArrayList<String>();
        }
        unRecogRoles.add(roleName);
        continue;
      }
 else {
        if (!definedRoles.containsKey(roleName)) {
          definedRoles.put(roleName,group.getInstanceNum());
        }
 else {
          Integer instanceNum=definedRoles.get(roleName) + group.getInstanceNum();
          definedRoles.put(roleName,instanceNum);
        }
      }
    }
  }
  if (unRecogRoles != null && !unRecogRoles.isEmpty()) {
    errorMsgList.add(""String_Node_Str"" + unRecogRoles.toString() + ""String_Node_Str""+ distro);
  }
  validateRoleDependencies(nodeGroups,apiStackComponents,unRecogRoles);
}"
48520,"private Set<String> validateRoleCategoryDependencies(ApiComponentInfo apiOriginComponentInfo,Set<String> allRoles){
  List<String> masterRoles=new ArrayList<String>();
  List<String> slaveRoles=new ArrayList<String>();
  Set<String> NotExistDenpendencies=new HashSet<String>();
  ComponentCategory componentCategory=ComponentCategory.valueOf(apiOriginComponentInfo.getComponentCategory());
  if (componentCategory.isMaster()) {
    return NotExistDenpendencies;
  }
  ApiStackService apiTargetService=apiManager.getStackServiceWithComponents(apiOriginComponentInfo.getStackName(),apiOriginComponentInfo.getStackVersion(),apiOriginComponentInfo.getServiceName());
  for (  ApiStackComponent apiTargetComponent : apiTargetService.getServiceComponents()) {
    ApiComponentInfo apiTargetComponentInfo=apiTargetComponent.getApiComponent();
    ComponentCategory targetComponentCategory=ComponentCategory.valueOf(apiTargetComponentInfo.getComponentCategory());
    ComponentName componentName=ComponentName.valueOf(apiTargetComponentInfo.getComponentName());
    if (isNamenodeHa(allRoles)) {
      if (componentName.isSecondaryNamenode()) {
        continue;
      }
    }
 else {
      if (componentName.isJournalnode() || componentName.isZkfc()) {
        continue;
      }
    }
    if (targetComponentCategory.isMaster()) {
      masterRoles.add(componentName.toString());
    }
    if (targetComponentCategory.isSlave()) {
      slaveRoles.add(componentName.toString());
    }
  }
  if (componentCategory.isSlave()) {
    for (    String masterRole : masterRoles) {
      if (!allRoles.contains(masterRole)) {
        NotExistDenpendencies.add(masterRole);
      }
    }
  }
  if (componentCategory.isClient()) {
    for (    String masterRole : masterRoles) {
      if (!allRoles.contains(masterRole)) {
        NotExistDenpendencies.add(masterRole);
      }
    }
    for (    String slaveRole : slaveRoles) {
      if (!allRoles.contains(slaveRole)) {
        NotExistDenpendencies.add(slaveRole);
      }
    }
  }
  return NotExistDenpendencies;
}","private Set<String> validateRoleCategoryDependencies(ApiComponentInfo apiOriginComponentInfo,Set<String> allRoles,List<String> unRecogRoles){
  List<String> masterRoles=new ArrayList<String>();
  List<String> slaveRoles=new ArrayList<String>();
  Set<String> NotExistDenpendencies=new HashSet<String>();
  ComponentCategory componentCategory=ComponentCategory.valueOf(apiOriginComponentInfo.getComponentCategory());
  if (componentCategory.isMaster()) {
    return NotExistDenpendencies;
  }
  ApiStackService apiTargetService=apiManager.getStackServiceWithComponents(apiOriginComponentInfo.getStackName(),apiOriginComponentInfo.getStackVersion(),apiOriginComponentInfo.getServiceName());
  for (  ApiStackComponent apiTargetComponent : apiTargetService.getServiceComponents()) {
    ApiComponentInfo apiTargetComponentInfo=apiTargetComponent.getApiComponent();
    ComponentCategory targetComponentCategory=ComponentCategory.valueOf(apiTargetComponentInfo.getComponentCategory());
    ComponentName componentName=ComponentName.valueOf(apiTargetComponentInfo.getComponentName());
    if (isNamenodeHa(allRoles,unRecogRoles)) {
      if (componentName.isSecondaryNamenode()) {
        continue;
      }
    }
 else {
      if (componentName.isJournalnode() || componentName.isZkfc()) {
        continue;
      }
    }
    if (targetComponentCategory.isMaster()) {
      masterRoles.add(componentName.toString());
    }
    if (targetComponentCategory.isSlave()) {
      slaveRoles.add(componentName.toString());
    }
  }
  if (componentCategory.isSlave()) {
    for (    String masterRole : masterRoles) {
      if (!allRoles.contains(masterRole)) {
        NotExistDenpendencies.add(masterRole);
      }
    }
  }
  if (componentCategory.isClient()) {
    for (    String masterRole : masterRoles) {
      if (!allRoles.contains(masterRole)) {
        NotExistDenpendencies.add(masterRole);
      }
    }
    for (    String slaveRole : slaveRoles) {
      if (!allRoles.contains(slaveRole)) {
        NotExistDenpendencies.add(slaveRole);
      }
    }
  }
  return NotExistDenpendencies;
}"
48521,"private boolean isNamenodeHa(Set<String> allRoles){
  boolean isNamenodeHa=false;
  int nameNodesCount=0;
  for (  String role : allRoles) {
    ComponentName componentName=ComponentName.valueOf(role);
    if (componentName.isNamenode()) {
      nameNodesCount++;
    }
  }
  if (nameNodesCount > 1) {
    isNamenodeHa=true;
  }
  return isNamenodeHa;
}","private boolean isNamenodeHa(Set<String> allRoles,List<String> unRecogRoles){
  boolean isNamenodeHa=false;
  int nameNodesCount=0;
  for (  String role : allRoles) {
    if (unRecogRoles != null && unRecogRoles.contains(role)) {
      continue;
    }
    ComponentName componentName=ComponentName.valueOf(role);
    if (componentName.isNamenode()) {
      nameNodesCount++;
    }
  }
  if (nameNodesCount > 1) {
    isNamenodeHa=true;
  }
  return isNamenodeHa;
}"
48522,"@Override public boolean startCluster(ClusterBlueprint clusterBlueprint,ClusterReportQueue reports) throws SoftwareManagementPluginException {
  AmClusterDef clusterDef=new AmClusterDef(clusterBlueprint,null);
  String clusterName=clusterDef.getName();
  if (!isProvisioned(clusterName)) {
    throw AmException.CLUSTER_NOT_PROVISIONED(clusterName);
  }
  if (!isClusterProvisionedByBDE(clusterDef)) {
    throw SoftwareManagementPluginException.START_CLUSTER_FAILED_NOT_PROV_BY_BDE(clusterName);
  }
  ClusterReport clusterReport=clusterDef.getCurrentReport();
  clusterReport.setAction(""String_Node_Str"");
  clusterReport.setProgress(ProgressSplit.OPERATION_BEGIN.getProgress());
  reportStatus(clusterReport,reports);
  boolean success=false;
  Exception resultException=null;
  try {
    for (int i=0; i < REQUEST_MAX_RETRY_TIMES; i++) {
      ApiRequest apiRequestSummary;
      try {
        apiRequestSummary=apiManager.startAllServicesInCluster(clusterName);
        if (apiRequestSummary.getApiRequestInfo() == null) {
          success=true;
          return true;
        }
        success=doSoftwareOperation(clusterBlueprint.getName(),apiRequestSummary,clusterReport,reports);
      }
 catch (      Exception e) {
        resultException=e;
        logger.warn(""String_Node_Str"",e);
        try {
          Thread.sleep(5000);
        }
 catch (        InterruptedException interrupt) {
          logger.info(""String_Node_Str"");
        }
      }
    }
  }
  finally {
    if (!success) {
      String errMsg=getErrorMsg(""String_Node_Str"",resultException);
      logger.error(errMsg,resultException);
      throw SoftwareManagementPluginException.START_CLUSTER_FAILED(null,AMBARI,clusterName);
    }
    clusterReport.setClusterAndNodesServiceStatus(ServiceStatus.STARTED);
    clusterReport.setClusterAndNodesAction(""String_Node_Str"");
    clusterReport.clearAllNodesErrorMsg();
    reportStatus(clusterReport.clone(),reports);
    return true;
  }
}","@Override public boolean startCluster(ClusterBlueprint clusterBlueprint,ClusterReportQueue reports) throws SoftwareManagementPluginException {
  AmClusterDef clusterDef=new AmClusterDef(clusterBlueprint,null);
  String clusterName=clusterDef.getName();
  if (!isProvisioned(clusterName)) {
    throw AmException.CLUSTER_NOT_PROVISIONED(clusterName);
  }
  if (!isClusterProvisionedByBDE(clusterDef)) {
    throw SoftwareManagementPluginException.START_CLUSTER_FAILED_NOT_PROV_BY_BDE(clusterName);
  }
  ClusterReport clusterReport=clusterDef.getCurrentReport();
  clusterReport.setAction(""String_Node_Str"");
  clusterReport.setProgress(ProgressSplit.OPERATION_BEGIN.getProgress());
  reportStatus(clusterReport,reports);
  boolean success=false;
  Exception resultException=null;
  try {
    ReflectionUtils.getPreStartServicesHook().preStartServices(clusterName,120);
    for (int i=0; i < REQUEST_MAX_RETRY_TIMES; i++) {
      ApiRequest apiRequestSummary;
      try {
        apiRequestSummary=apiManager.startAllServicesInCluster(clusterName);
        if (apiRequestSummary.getApiRequestInfo() == null) {
          success=true;
          return true;
        }
        success=doSoftwareOperation(clusterBlueprint.getName(),apiRequestSummary,clusterReport,reports);
      }
 catch (      Exception e) {
        resultException=e;
        logger.warn(""String_Node_Str"",e);
        try {
          Thread.sleep(5000);
        }
 catch (        InterruptedException interrupt) {
          logger.info(""String_Node_Str"");
        }
      }
    }
  }
  finally {
    if (!success) {
      String errMsg=getErrorMsg(""String_Node_Str"",resultException);
      logger.error(errMsg,resultException);
      throw SoftwareManagementPluginException.START_CLUSTER_FAILED(null,AMBARI,clusterName);
    }
    clusterReport.setClusterAndNodesServiceStatus(ServiceStatus.STARTED);
    clusterReport.setClusterAndNodesAction(""String_Node_Str"");
    clusterReport.clearAllNodesErrorMsg();
    reportStatus(clusterReport.clone(),reports);
    return true;
  }
}"
48523,"@Override public boolean createCluster(ClusterBlueprint blueprint,ClusterReportQueue reportQueue) throws SoftwareManagementPluginException {
  boolean success=false;
  CmClusterDef clusterDef=null;
  try {
    clusterDef=new CmClusterDef(blueprint);
    provisionCluster(clusterDef,null,reportQueue);
    provisionParcels(clusterDef,null,reportQueue);
    configureServices(clusterDef,reportQueue,true);
    startServices(clusterDef,reportQueue,true);
    success=true;
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setProgress(100);
    clusterDef.getCurrentReport().setSuccess(true);
  }
 catch (  SoftwareManagementPluginException ex) {
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setSuccess(false);
    throw ex;
  }
catch (  Exception e) {
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setSuccess(false);
    logger.error(e.getMessage());
    throw SoftwareManagementPluginException.CREATE_CLUSTER_EXCEPTION(e,CLOUDERA_MANAGER,clusterDef.getName());
  }
 finally {
    clusterDef.getCurrentReport().setFinished(true);
    reportQueue.addClusterReport(clusterDef.getCurrentReport().clone());
  }
  return success;
}","@Override public boolean createCluster(ClusterBlueprint blueprint,ClusterReportQueue reportQueue) throws SoftwareManagementPluginException {
  boolean success=false;
  CmClusterDef clusterDef=null;
  try {
    clusterDef=new CmClusterDef(blueprint);
    validateBlueprint(blueprint);
    provisionCluster(clusterDef,null,reportQueue);
    provisionParcels(clusterDef,null,reportQueue);
    configureServices(clusterDef,reportQueue,true);
    startServices(clusterDef,reportQueue,true);
    success=true;
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setProgress(100);
    clusterDef.getCurrentReport().setSuccess(true);
  }
 catch (  SoftwareManagementPluginException ex) {
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setSuccess(false);
    throw ex;
  }
catch (  Exception e) {
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setSuccess(false);
    logger.error(e.getMessage());
    throw SoftwareManagementPluginException.CREATE_CLUSTER_EXCEPTION(e,CLOUDERA_MANAGER,clusterDef.getName());
  }
 finally {
    clusterDef.getCurrentReport().setFinished(true);
    reportQueue.addClusterReport(clusterDef.getCurrentReport().clone());
  }
  return success;
}"
48524,"@Override public boolean onDeleteCluster(ClusterBlueprint clusterBlueprint,ClusterReportQueue reports) throws SoftwareManagementPluginException {
  try {
    String clusterName=clusterBlueprint.getName();
    AmClusterDef clusterDef=new AmClusterDef(clusterBlueprint,null);
    if (isProvisioned(clusterName) && isClusterProvisionedByBDE(clusterDef)) {
      if (!onStopCluster(clusterBlueprint,reports)) {
        logger.error(""String_Node_Str"");
      }
      List<String> serviceNames=apiManager.getClusterServicesNames(clusterName);
      if (serviceNames != null && !serviceNames.isEmpty()) {
        for (        String serviceName : serviceNames) {
          apiManager.deleteService(clusterName,serviceName);
        }
      }
      if (apiManager.getHostsSummaryInfo(clusterName) != null) {
        List<ApiHost> hosts=apiManager.getHostsSummaryInfo(clusterName).getApiHosts();
        if (hosts != null && !hosts.isEmpty()) {
          for (          ApiHost host : hosts) {
            assert(host.getApiHostInfo() != null);
            String hostName=host.getApiHostInfo().getHostName();
            apiManager.deleteHost(clusterName,hostName);
          }
        }
      }
      apiManager.deleteCluster(clusterName);
    }
    if (isBlueprintCreated(clusterDef) && isBlueprintCreatedByBDE(clusterDef)) {
      apiManager.deleteBlueprint(clusterName);
    }
    ApiPersist persist=new ApiPersist(""String_Node_Str"");
    apiManager.updatePersist(persist);
    return true;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw SoftwareManagementPluginException.DELETE_CLUSTER_FAILED(e,AMBARI,clusterBlueprint.getName());
  }
}","@Override public boolean onDeleteCluster(ClusterBlueprint clusterBlueprint,ClusterReportQueue reports) throws SoftwareManagementPluginException {
  try {
    String clusterName=clusterBlueprint.getName();
    if (!isProvisioned(clusterName)) {
      return true;
    }
    AmClusterDef clusterDef=new AmClusterDef(clusterBlueprint,null);
    if (!isClusterProvisionedByBDE(clusterDef)) {
      return true;
    }
    if (!onStopCluster(clusterBlueprint,reports)) {
      logger.error(""String_Node_Str"");
    }
    List<String> serviceNames=apiManager.getClusterServicesNames(clusterName);
    if (serviceNames != null && !serviceNames.isEmpty()) {
      for (      String serviceName : serviceNames) {
        apiManager.deleteService(clusterName,serviceName);
      }
    }
    if (apiManager.getHostsSummaryInfo(clusterName) != null) {
      List<ApiHost> hosts=apiManager.getHostsSummaryInfo(clusterName).getApiHosts();
      if (hosts != null && !hosts.isEmpty()) {
        for (        ApiHost host : hosts) {
          assert(host.getApiHostInfo() != null);
          String hostName=host.getApiHostInfo().getHostName();
          apiManager.deleteHost(clusterName,hostName);
        }
      }
    }
    apiManager.deleteCluster(clusterName);
    if (isBlueprintCreated(clusterDef) && isBlueprintCreatedByBDE(clusterDef)) {
      apiManager.deleteBlueprint(clusterName);
    }
    ApiPersist persist=new ApiPersist(""String_Node_Str"");
    apiManager.updatePersist(persist);
    return true;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw SoftwareManagementPluginException.DELETE_CLUSTER_FAILED(e,AMBARI,clusterBlueprint.getName());
  }
}"
48525,"@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String targetName=getJobParameters(chunkContext).getString(JobConstants.TARGET_NAME_JOB_PARAM);
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  if (targetName == null) {
    targetName=clusterName;
  }
  String jobName=chunkContext.getStepContext().getJobName();
  logger.info(""String_Node_Str"" + targetName + ""String_Node_Str""+ managementOperation+ ""String_Node_Str""+ jobName);
  serviceSyncup.syncUp(clusterName);
  logger.debug(""String_Node_Str"" + clusterName);
  boolean vmPowerOn=false;
  String vmPowerOnStr=getJobParameters(chunkContext).getString(JobConstants.IS_VM_POWER_ON);
  if (vmPowerOnStr != null) {
    logger.info(""String_Node_Str"" + vmPowerOnStr);
    vmPowerOn=Boolean.parseBoolean(vmPowerOnStr);
  }
  if (checkVMStatus && targetName.split(""String_Node_Str"").length == 3 && !vmPowerOn) {
    return RepeatStatus.FINISHED;
  }
  SoftwareManager softwareMgr=softwareMgrs.getSoftwareManagerByClusterName(clusterName);
  if (ManagementOperation.CONFIGURE.equals(managementOperation) || JobConstants.RESUME_CLUSTER_JOB_NAME.equals(jobName)) {
    logger.info(""String_Node_Str"");
    List<NodeEntity> nodes=lockClusterEntityMgr.getClusterEntityMgr().findAllNodes(clusterName);
    Set<String> hostnames=new HashSet<String>();
    for (    NodeEntity node : nodes) {
      hostnames.add(node.getHostName());
    }
    ClusterCreate clusterSpec=clusterManager.getClusterSpec(clusterName);
    SyncHostsUtils.SyncHosts(clusterSpec,hostnames,softwareMgr);
  }
  StatusUpdater statusUpdater=new DefaultStatusUpdater(jobExecutionStatusHolder,getJobExecutionId(chunkContext));
  ISoftwareManagementTask task=null;
  if (!Constants.IRONFAN.equals(softwareMgr.getName())) {
    task=createExternalTask(chunkContext,targetName,clusterName,statusUpdater);
  }
 else {
    task=createThriftTask(chunkContext,targetName,statusUpdater);
  }
  if (task != null) {
    Map<String,Object> ret=task.call();
    if (!(Boolean)ret.get(""String_Node_Str"")) {
      String errorMessage=(String)ret.get(""String_Node_Str"");
      putIntoJobExecutionContext(chunkContext,JobConstants.CURRENT_ERROR_MESSAGE,errorMessage);
      putIntoJobExecutionContext(chunkContext,JobConstants.SOFTWARE_MANAGEMENT_STEP_FAILE,true);
      throw TaskException.EXECUTION_FAILED(errorMessage);
    }
  }
  return RepeatStatus.FINISHED;
}","@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String targetName=getJobParameters(chunkContext).getString(JobConstants.TARGET_NAME_JOB_PARAM);
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  if (targetName == null) {
    targetName=clusterName;
  }
  String jobName=chunkContext.getStepContext().getJobName();
  logger.info(""String_Node_Str"" + targetName + ""String_Node_Str""+ managementOperation+ ""String_Node_Str""+ jobName);
  serviceSyncup.syncUp(clusterName);
  logger.debug(""String_Node_Str"" + clusterName);
  boolean vmPowerOn=false;
  String vmPowerOnStr=getJobParameters(chunkContext).getString(JobConstants.IS_VM_POWER_ON);
  if (vmPowerOnStr != null) {
    logger.info(""String_Node_Str"" + vmPowerOnStr);
    vmPowerOn=Boolean.parseBoolean(vmPowerOnStr);
  }
  if (checkVMStatus && targetName.split(""String_Node_Str"").length == 3 && !vmPowerOn) {
    return RepeatStatus.FINISHED;
  }
  SoftwareManager softwareMgr=softwareMgrs.getSoftwareManagerByClusterName(clusterName);
  if (ManagementOperation.CONFIGURE.equals(managementOperation) || ManagementOperation.START.equals(managementOperation) || JobConstants.RESUME_CLUSTER_JOB_NAME.equals(jobName)) {
    logger.info(""String_Node_Str"");
    List<NodeEntity> nodes=lockClusterEntityMgr.getClusterEntityMgr().findAllNodes(clusterName);
    Set<String> hostnames=new HashSet<String>();
    for (    NodeEntity node : nodes) {
      hostnames.add(node.getHostName());
    }
    ClusterCreate clusterSpec=clusterManager.getClusterSpec(clusterName);
    SyncHostsUtils.SyncHosts(clusterSpec,hostnames,softwareMgr);
  }
  StatusUpdater statusUpdater=new DefaultStatusUpdater(jobExecutionStatusHolder,getJobExecutionId(chunkContext));
  ISoftwareManagementTask task=null;
  if (!Constants.IRONFAN.equals(softwareMgr.getName())) {
    task=createExternalTask(chunkContext,targetName,clusterName,statusUpdater);
  }
 else {
    task=createThriftTask(chunkContext,targetName,statusUpdater);
  }
  if (task != null) {
    Map<String,Object> ret=task.call();
    if (!(Boolean)ret.get(""String_Node_Str"")) {
      String errorMessage=(String)ret.get(""String_Node_Str"");
      putIntoJobExecutionContext(chunkContext,JobConstants.CURRENT_ERROR_MESSAGE,errorMessage);
      putIntoJobExecutionContext(chunkContext,JobConstants.SOFTWARE_MANAGEMENT_STEP_FAILE,true);
      throw TaskException.EXECUTION_FAILED(errorMessage);
    }
  }
  return RepeatStatus.FINISHED;
}"
48526,"@Override public Map<String,Object> call() throws Exception {
  Map<String,Object> result=new HashMap<String,Object>();
  ClusterReportQueue queue=new ClusterReportQueue();
  Thread progressThread=null;
  ExternalProgressMonitor monitor=new ExternalProgressMonitor(targetName,queue,statusUpdater,lockedClusterEntityManager);
  progressThread=new Thread(monitor,""String_Node_Str"" + targetName);
  progressThread.setDaemon(true);
  progressThread.start();
  boolean success=false;
  try {
switch (managementOperation) {
case CREATE:
      success=softwareManager.createCluster(clusterBlueprint,queue);
    break;
case CONFIGURE:
  success=softwareManager.reconfigCluster(clusterBlueprint,queue);
break;
case PRE_DESTROY:
success=softwareManager.onDeleteCluster(clusterBlueprint,queue);
break;
case DESTROY:
success=softwareManager.deleteCluster(clusterBlueprint,queue);
case START:
success=softwareManager.startCluster(clusterBlueprint,queue);
break;
case STOP:
success=softwareManager.onStopCluster(clusterBlueprint,queue);
break;
case START_NODES:
List<NodeInfo> nodes=new ArrayList<NodeInfo>();
for (NodeGroupInfo group : clusterBlueprint.getNodeGroups()) {
if (group != null) {
for (NodeInfo node : group.getNodes()) {
if (node.getName().equals(targetName)) {
nodes.add(node);
break;
}
}
if (!nodes.isEmpty()) {
break;
}
}
}
success=softwareManager.startNodes(clusterBlueprint.getName(),nodes,queue);
break;
case QUERY:
ClusterReport report=softwareManager.queryClusterStatus(clusterBlueprint);
queue.addClusterReport(report);
success=true;
break;
case RESIZE:
AuAssert.check(chunkContext != null);
List<String> addedNodes=getResizedVmNames(chunkContext,clusterBlueprint);
success=softwareManager.scaleOutCluster(clusterBlueprint,addedNodes,queue);
break;
default :
success=true;
}
}
 catch (Throwable t) {
logger.error(""String_Node_Str"" + managementOperation.name() + ""String_Node_Str""+ targetName,t);
result.put(""String_Node_Str"",t.getMessage());
}
 finally {
if (progressThread != null) {
monitor.setStop(true);
progressThread.interrupt();
progressThread.join();
}
}
result.put(""String_Node_Str"",success);
if (!success) {
logger.error(""String_Node_Str"" + result.get(""String_Node_Str""));
}
return result;
}","@Override public Map<String,Object> call() throws Exception {
  Map<String,Object> result=new HashMap<String,Object>();
  ClusterReportQueue queue=new ClusterReportQueue();
  Thread progressThread=null;
  ExternalProgressMonitor monitor=new ExternalProgressMonitor(targetName,queue,statusUpdater,lockedClusterEntityManager);
  progressThread=new Thread(monitor,""String_Node_Str"" + targetName);
  progressThread.setDaemon(true);
  progressThread.start();
  boolean success=false;
  try {
switch (managementOperation) {
case CREATE:
      success=softwareManager.createCluster(clusterBlueprint,queue);
    break;
case CONFIGURE:
  success=softwareManager.reconfigCluster(clusterBlueprint,queue);
break;
case PRE_DESTROY:
if (softwareManager == null) {
logger.warn(""String_Node_Str"" + clusterBlueprint.getName() + ""String_Node_Str"");
logger.warn(""String_Node_Str"");
success=true;
}
 else {
success=softwareManager.onDeleteCluster(clusterBlueprint,queue);
}
break;
case DESTROY:
success=softwareManager.deleteCluster(clusterBlueprint,queue);
case START:
success=softwareManager.startCluster(clusterBlueprint,queue);
break;
case STOP:
success=softwareManager.onStopCluster(clusterBlueprint,queue);
break;
case START_NODES:
List<NodeInfo> nodes=new ArrayList<NodeInfo>();
for (NodeGroupInfo group : clusterBlueprint.getNodeGroups()) {
if (group != null) {
for (NodeInfo node : group.getNodes()) {
if (node.getName().equals(targetName)) {
nodes.add(node);
break;
}
}
if (!nodes.isEmpty()) {
break;
}
}
}
success=softwareManager.startNodes(clusterBlueprint.getName(),nodes,queue);
break;
case QUERY:
ClusterReport report=softwareManager.queryClusterStatus(clusterBlueprint);
queue.addClusterReport(report);
success=true;
break;
case RESIZE:
AuAssert.check(chunkContext != null);
List<String> addedNodes=getResizedVmNames(chunkContext,clusterBlueprint);
success=softwareManager.scaleOutCluster(clusterBlueprint,addedNodes,queue);
break;
default :
success=true;
}
}
 catch (Throwable t) {
logger.error(""String_Node_Str"" + managementOperation.name() + ""String_Node_Str""+ targetName,t);
result.put(""String_Node_Str"",t.getMessage());
}
 finally {
if (progressThread != null) {
monitor.setStop(true);
progressThread.interrupt();
progressThread.join();
}
}
result.put(""String_Node_Str"",success);
if (!success) {
logger.error(""String_Node_Str"" + result.get(""String_Node_Str""));
}
return result;
}"
48527,"@Override public boolean echo(){
switch (apiManager.healthCheck()) {
case Constants.HEALTH_STATUS:
    return true;
default :
  return false;
}
}","@Override public boolean echo(){
  try {
switch (apiManager.healthCheck()) {
case Constants.HEALTH_STATUS:
      return true;
default :
    return false;
}
}
 catch (Exception e) {
return false;
}
}"
48528,"@Override public boolean onDeleteCluster(ClusterBlueprint clusterBlueprint,ClusterReportQueue reports) throws SoftwareManagementPluginException {
  try {
    String clusterName=clusterBlueprint.getName();
    if (!isProvisioned(clusterName)) {
      return true;
    }
    AmClusterDef clusterDef=new AmClusterDef(clusterBlueprint,null);
    if (!isClusterProvisionedByBDE(clusterDef)) {
      return true;
    }
    if (!onStopCluster(clusterBlueprint,reports)) {
      logger.error(""String_Node_Str"");
    }
    List<String> serviceNames=apiManager.getClusterServicesNames(clusterName);
    if (serviceNames != null && !serviceNames.isEmpty()) {
      for (      String serviceName : serviceNames) {
        apiManager.deleteService(clusterName,serviceName);
      }
    }
    if (apiManager.getHostsSummaryInfo(clusterName) != null) {
      List<ApiHost> hosts=apiManager.getHostsSummaryInfo(clusterName).getApiHosts();
      if (hosts != null && !hosts.isEmpty()) {
        for (        ApiHost host : hosts) {
          assert(host.getApiHostInfo() != null);
          String hostName=host.getApiHostInfo().getHostName();
          apiManager.deleteHost(clusterName,hostName);
        }
      }
    }
    apiManager.deleteCluster(clusterName);
    if (isBlueprintCreated(clusterDef) && isBlueprintCreatedByBDE(clusterDef)) {
      apiManager.deleteBlueprint(clusterName);
    }
    ApiPersist persist=new ApiPersist(""String_Node_Str"");
    apiManager.updatePersist(persist);
    return true;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw SoftwareManagementPluginException.DELETE_CLUSTER_FAILED(e,AMBARI,clusterBlueprint.getName());
  }
}","@Override public boolean onDeleteCluster(ClusterBlueprint clusterBlueprint,ClusterReportQueue reports) throws SoftwareManagementPluginException {
  try {
    String clusterName=clusterBlueprint.getName();
    if (!echo()) {
      logger.warn(""String_Node_Str"" + clusterName + ""String_Node_Str"");
      logger.warn(""String_Node_Str"");
      return true;
    }
    if (!isProvisioned(clusterName)) {
      return true;
    }
    AmClusterDef clusterDef=new AmClusterDef(clusterBlueprint,null);
    if (!isClusterProvisionedByBDE(clusterDef)) {
      return true;
    }
    if (!onStopCluster(clusterBlueprint,reports)) {
      logger.error(""String_Node_Str"");
    }
    List<String> serviceNames=apiManager.getClusterServicesNames(clusterName);
    if (serviceNames != null && !serviceNames.isEmpty()) {
      for (      String serviceName : serviceNames) {
        apiManager.deleteService(clusterName,serviceName);
      }
    }
    if (apiManager.getHostsSummaryInfo(clusterName) != null) {
      List<ApiHost> hosts=apiManager.getHostsSummaryInfo(clusterName).getApiHosts();
      if (hosts != null && !hosts.isEmpty()) {
        for (        ApiHost host : hosts) {
          assert(host.getApiHostInfo() != null);
          String hostName=host.getApiHostInfo().getHostName();
          apiManager.deleteHost(clusterName,hostName);
        }
      }
    }
    apiManager.deleteCluster(clusterName);
    if (isBlueprintCreated(clusterDef) && isBlueprintCreatedByBDE(clusterDef)) {
      apiManager.deleteBlueprint(clusterName);
    }
    ApiPersist persist=new ApiPersist(""String_Node_Str"");
    apiManager.updatePersist(persist);
    return true;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw SoftwareManagementPluginException.DELETE_CLUSTER_FAILED(e,AMBARI,clusterBlueprint.getName());
  }
}"
48529,"@Override public boolean deleteCluster(ClusterBlueprint clusterBlueprint,ClusterReportQueue reports) throws SoftwareManagementPluginException {
  String clusterName=clusterBlueprint.getName();
  try {
    if (!isProvisioned(clusterName)) {
      return true;
    }
    ApiHostRefList hosts=apiResourceRootV6.getClustersResource().listHosts(clusterName);
    apiResourceRootV6.getClustersResource().deleteCluster(clusterName);
    for (    ApiHostRef host : hosts.getHosts()) {
      apiResourceRootV6.getHostsResource().deleteHost(host.getHostId());
    }
  }
 catch (  Exception e) {
    throw SoftwareManagementPluginException.DELETE_CLUSTER_FAILED(e,CLOUDERA_MANAGER,clusterName);
  }
  return true;
}","@Override public boolean deleteCluster(ClusterBlueprint clusterBlueprint,ClusterReportQueue reports) throws SoftwareManagementPluginException {
  String clusterName=clusterBlueprint.getName();
  try {
    if (!echo()) {
      logWarningWhenForceDeleteCluster(clusterName);
      return true;
    }
    if (!isProvisioned(clusterName)) {
      return true;
    }
    ApiHostRefList hosts=apiResourceRootV6.getClustersResource().listHosts(clusterName);
    apiResourceRootV6.getClustersResource().deleteCluster(clusterName);
    for (    ApiHostRef host : hosts.getHosts()) {
      apiResourceRootV6.getHostsResource().deleteHost(host.getHostId());
    }
  }
 catch (  Exception e) {
    throw SoftwareManagementPluginException.DELETE_CLUSTER_FAILED(e,CLOUDERA_MANAGER,clusterName);
  }
  return true;
}"
48530,"@Override public boolean onDeleteCluster(ClusterBlueprint clusterBlueprint,ClusterReportQueue reports) throws SoftwareManagementPluginException {
  return onStopCluster(clusterBlueprint,reports);
}","@Override public boolean onDeleteCluster(ClusterBlueprint clusterBlueprint,ClusterReportQueue reports) throws SoftwareManagementPluginException {
  if (!echo()) {
    logWarningWhenForceDeleteCluster(clusterBlueprint.getName());
    return true;
  }
  return onStopCluster(clusterBlueprint,reports);
}"
48531,"@Override public boolean onDeleteCluster(ClusterBlueprint clusterBlueprint,ClusterReportQueue reports) throws SoftwareManagementPluginException {
  return false;
}","@Override public boolean onDeleteCluster(ClusterBlueprint clusterBlueprint,ClusterReportQueue reports) throws SoftwareManagementPluginException {
  return true;
}"
48532,"public ServiceStatus getClusterStatus(String clusterName) throws AmbariApiException {
  ApiServiceAlertList serviceList=getServicesWithAlert(clusterName);
  if (serviceList.getApiServiceAlerts() != null) {
    boolean allStopped=true;
    boolean hasStartedAlert=false;
    for (    ApiServiceAlert service : serviceList.getApiServiceAlerts()) {
      ApiServiceInfo info=service.getApiServiceInfo();
      ApiAlert alert=service.getApiAlert();
      if (ApiServiceStatus.STARTED.name().equalsIgnoreCase(info.getState())) {
        allStopped=false;
        if (alert != null && alert.getSummary() != null && alert.getSummary().getCritical() > 0) {
          hasStartedAlert=true;
        }
      }
    }
    if (allStopped) {
      return ServiceStatus.STOPPED;
    }
    if (hasStartedAlert) {
      return ServiceStatus.ALERT;
    }
  }
  return ServiceStatus.STARTED;
}","public ServiceStatus getClusterStatus(String clusterName,HadoopStack stack) throws AmbariApiException {
  ApiServiceAlertList serviceList=getServicesWithAlert(clusterName);
  if (serviceList.getApiServiceAlerts() != null) {
    boolean allStopped=true;
    boolean hasStartedAlert=false;
    List<String> notStartedServiceNames=new ArrayList<>();
    for (    ApiServiceAlert service : serviceList.getApiServiceAlerts()) {
      ApiServiceInfo info=service.getApiServiceInfo();
      ApiAlert alert=service.getApiAlert();
      if (ApiServiceStatus.STARTED.name().equalsIgnoreCase(info.getState())) {
        allStopped=false;
        if (alert != null && alert.getSummary() != null && alert.getSummary().getCritical() > 0) {
          hasStartedAlert=true;
        }
      }
 else {
        notStartedServiceNames.add(service.getApiServiceInfo().getServiceName());
      }
    }
    if (allStopped) {
      return ServiceStatus.STOPPED;
    }
    if (notStartedServiceNames.isEmpty()) {
      if (hasStartedAlert) {
        return ServiceStatus.ALERT;
      }
 else {
        return ServiceStatus.STARTED;
      }
    }
    boolean hasStoppedService=hasNonClientServices(stack,notStartedServiceNames);
    if (hasStoppedService) {
      return ServiceStatus.ALERT;
    }
 else {
      return ServiceStatus.STARTED;
    }
  }
  return ServiceStatus.UNKONWN;
}"
48533,public ServiceStatus getClusterStatus(String clusterName) throws AmbariApiException ;,"public ServiceStatus getClusterStatus(String clusterName,HadoopStack stack) throws AmbariApiException ;"
48534,"@Override public ClusterReport queryClusterStatus(ClusterBlueprint blueprint){
  AmClusterDef clusterDef=new AmClusterDef(blueprint,privateKey);
  try {
    ServiceStatus status=apiManager.getClusterStatus(blueprint.getName());
    clusterDef.getCurrentReport().setStatus(status);
    Map<String,ServiceStatus> hostStates=apiManager.getHostStatus(blueprint.getName());
    Map<String,NodeReport> nodeReports=clusterDef.getCurrentReport().getNodeReports();
    for (    AmNodeDef node : clusterDef.getNodes()) {
      String fqdn=node.getFqdn();
      nodeReports.get(node.getName()).setStatus(hostStates.get(fqdn));
    }
  }
 catch (  NotFoundException e) {
    logger.info(""String_Node_Str"" + blueprint.getName() + ""String_Node_Str"");
    return null;
  }
  return clusterDef.getCurrentReport().clone();
}","@Override public ClusterReport queryClusterStatus(ClusterBlueprint blueprint){
  AmClusterDef clusterDef=new AmClusterDef(blueprint,privateKey);
  try {
    ServiceStatus status=apiManager.getClusterStatus(blueprint.getName(),blueprint.getHadoopStack());
    clusterDef.getCurrentReport().setStatus(status);
    Map<String,ServiceStatus> hostStates=apiManager.getHostStatus(blueprint.getName());
    Map<String,NodeReport> nodeReports=clusterDef.getCurrentReport().getNodeReports();
    for (    AmNodeDef node : clusterDef.getNodes()) {
      String fqdn=node.getFqdn();
      nodeReports.get(node.getName()).setStatus(hostStates.get(fqdn));
    }
  }
 catch (  NotFoundException e) {
    logger.info(""String_Node_Str"" + blueprint.getName() + ""String_Node_Str"");
    return null;
  }
  return clusterDef.getCurrentReport().clone();
}"
48535,"private void testStatusQuery(){
  provider=new AmbariImpl(""String_Node_Str"",8080,""String_Node_Str"",""String_Node_Str"",null);
  ClusterBlueprint blueprint=new ClusterBlueprint();
  blueprint.setHadoopStack(new HadoopStack());
  blueprint.setName(""String_Node_Str"");
  List<NodeGroupInfo> nodeGroups=new ArrayList<NodeGroupInfo>();
  NodeGroupInfo group=new NodeGroupInfo();
  nodeGroups.add(group);
  blueprint.setNodeGroups(nodeGroups);
  group.setInstanceNum(5);
  List<NodeInfo> nodes=new ArrayList<NodeInfo>();
  group.setNodes(nodes);
  List<String> roles=new ArrayList<String>();
  group.setRoles(roles);
  NodeInfo node=new NodeInfo();
  node.setHostname(""String_Node_Str"");
  node.setName(""String_Node_Str"");
  nodes.add(node);
  node=new NodeInfo();
  node.setHostname(""String_Node_Str"");
  node.setName(""String_Node_Str"");
  nodes.add(node);
  node=new NodeInfo();
  node.setHostname(""String_Node_Str"");
  node.setName(""String_Node_Str"");
  node=new NodeInfo();
  node.setHostname(""String_Node_Str"");
  node.setName(""String_Node_Str"");
  nodes.add(node);
  node=new NodeInfo();
  node.setHostname(""String_Node_Str"");
  node.setName(""String_Node_Str"");
  nodes.add(node);
  ClusterReport report=provider.queryClusterStatus(blueprint);
  Assert.assertTrue(report.getStatus() == ServiceStatus.STARTED);
  report.getNodeReports();
  for (  NodeReport nodeReport : report.getNodeReports().values()) {
    Assert.assertTrue(nodeReport.getStatus() == ServiceStatus.STARTED);
  }
}","private void testStatusQuery(){
  provider=new AmbariImpl(""String_Node_Str"",8080,""String_Node_Str"",""String_Node_Str"",null);
  ClusterBlueprint blueprint=new ClusterBlueprint();
  blueprint.setHadoopStack(new HadoopStack());
  blueprint.getHadoopStack().setVendor(""String_Node_Str"");
  blueprint.getHadoopStack().setFullVersion(""String_Node_Str"");
  blueprint.setName(""String_Node_Str"");
  List<NodeGroupInfo> nodeGroups=new ArrayList<NodeGroupInfo>();
  NodeGroupInfo group=new NodeGroupInfo();
  nodeGroups.add(group);
  blueprint.setNodeGroups(nodeGroups);
  group.setInstanceNum(5);
  List<NodeInfo> nodes=new ArrayList<NodeInfo>();
  group.setNodes(nodes);
  List<String> roles=new ArrayList<String>();
  group.setRoles(roles);
  NodeInfo node=new NodeInfo();
  node.setHostname(""String_Node_Str"");
  node.setName(""String_Node_Str"");
  node.setVolumes(new ArrayList<String>());
  nodes.add(node);
  node=new NodeInfo();
  node.setHostname(""String_Node_Str"");
  node.setName(""String_Node_Str"");
  node.setVolumes(new ArrayList<String>());
  nodes.add(node);
  node=new NodeInfo();
  node.setHostname(""String_Node_Str"");
  node.setName(""String_Node_Str"");
  node.setVolumes(new ArrayList<String>());
  nodes.add(node);
  node=new NodeInfo();
  node.setHostname(""String_Node_Str"");
  node.setName(""String_Node_Str"");
  node.setVolumes(new ArrayList<String>());
  nodes.add(node);
  node=new NodeInfo();
  node.setHostname(""String_Node_Str"");
  node.setName(""String_Node_Str"");
  node.setVolumes(new ArrayList<String>());
  nodes.add(node);
  ClusterReport report=provider.queryClusterStatus(blueprint);
  Assert.assertTrue(report.getStatus() == ServiceStatus.STARTED);
  report.getNodeReports();
  for (  NodeReport nodeReport : report.getNodeReports().values()) {
    Assert.assertTrue(nodeReport.getStatus() == ServiceStatus.STARTED);
  }
}"
48536,"private void handleClusterStatus(String clusterName,ClusterReport report){
  ClusterEntity cluster=findByName(clusterName);
  ClusterStatus oldState=cluster.getStatus();
switch (oldState) {
case RUNNING:
case SERVICE_ERROR:
case SERVICE_WARNING:
switch (report.getStatus()) {
case STARTED:
      cluster.setStatus(ClusterStatus.RUNNING);
    break;
case ALERT:
  cluster.setStatus(ClusterStatus.SERVICE_WARNING);
break;
case STOPPED:
cluster.setStatus(ClusterStatus.SERVICE_ERROR);
break;
default :
break;
}
logger.info(""String_Node_Str"" + report.getStatus() + ""String_Node_Str""+ oldState+ ""String_Node_Str""+ cluster.getStatus());
break;
default :
logger.debug(""String_Node_Str"" + cluster.getStatus() + ""String_Node_Str"");
break;
}
}","private void handleClusterStatus(String clusterName,ClusterReport report){
  ClusterEntity cluster=findByName(clusterName);
  ClusterStatus oldState=cluster.getStatus();
switch (oldState) {
case RUNNING:
case SERVICE_STOPPED:
case SERVICE_WARNING:
switch (report.getStatus()) {
case STARTED:
      cluster.setStatus(ClusterStatus.RUNNING);
    break;
case ALERT:
  cluster.setStatus(ClusterStatus.SERVICE_WARNING);
break;
case STOPPED:
cluster.setStatus(ClusterStatus.SERVICE_STOPPED);
break;
default :
break;
}
logger.info(""String_Node_Str"" + report.getStatus() + ""String_Node_Str""+ oldState+ ""String_Node_Str""+ cluster.getStatus());
break;
default :
logger.debug(""String_Node_Str"" + cluster.getStatus() + ""String_Node_Str"");
break;
}
}"
48537,"public Long configCluster(String clusterName,ClusterCreate createSpec) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster;
  if ((cluster=clusterEntityMgr.findByName(clusterName)) == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ValidationUtils.validateVersion(clusterEntityMgr,clusterName);
  if (!cluster.getStatus().isActiveServiceStatus() && !ClusterStatus.CONFIGURE_ERROR.equals(cluster.getStatus()) && !ClusterStatus.SERVICE_ERROR.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus());
    throw ClusterManagerException.UPDATE_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  clusterConfigMgr.updateAppConfig(clusterName,createSpec);
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.CONFIGURE_ERROR.name()));
  JobParameters jobParameters=new JobParameters(param);
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.CONFIGURING);
  clusterEntityMgr.cleanupActionError(clusterName);
  try {
    return jobManager.runJob(JobConstants.CONFIG_CLUSTER_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.CONFIGURE_ERROR);
    throw e;
  }
}","public Long configCluster(String clusterName,ClusterCreate createSpec) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster;
  if ((cluster=clusterEntityMgr.findByName(clusterName)) == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ValidationUtils.validateVersion(clusterEntityMgr,clusterName);
  if (!cluster.getStatus().isActiveServiceStatus() && !ClusterStatus.CONFIGURE_ERROR.equals(cluster.getStatus()) && !ClusterStatus.SERVICE_STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus());
    throw ClusterManagerException.UPDATE_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  clusterConfigMgr.updateAppConfig(clusterName,createSpec);
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.CONFIGURE_ERROR.name()));
  JobParameters jobParameters=new JobParameters(param);
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.CONFIGURING);
  clusterEntityMgr.cleanupActionError(clusterName);
  try {
    return jobManager.runJob(JobConstants.CONFIG_CLUSTER_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.CONFIGURE_ERROR);
    throw e;
  }
}"
48538,"/** 
 * set cluster parameters synchronously
 * @param clusterName
 * @param activeComputeNodeNum
 * @param minComputeNodeNum
 * @param maxComputeNodeNum
 * @param enableAuto
 * @param ioPriority
 * @return
 * @throws Exception
 */
@SuppressWarnings(""String_Node_Str"") public List<String> syncSetParam(String clusterName,Integer activeComputeNodeNum,Integer minComputeNodeNum,Integer maxComputeNodeNum,Boolean enableAuto,Priority ioPriority) throws Exception {
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  ClusterRead clusterRead=getClusterByName(clusterName,false);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ValidationUtils.validateVersion(clusterEntityMgr,clusterName);
  clusterEntityMgr.cleanupActionError(clusterName);
  if (ioPriority != null) {
    prioritizeCluster(clusterName,ioPriority);
  }
  cluster=clusterEntityMgr.findByName(clusterName);
  if (enableAuto != null && enableAuto != cluster.getAutomationEnable()) {
    if (enableAuto && cluster.getDistroVendor().equalsIgnoreCase(Constants.MAPR_VENDOR)) {
      logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
      throw BddException.NOT_ALLOWED_SCALING(""String_Node_Str"",clusterName);
    }
    cluster.setAutomationEnable(enableAuto);
  }
  if (minComputeNodeNum != null && minComputeNodeNum != cluster.getVhmMinNum()) {
    cluster.setVhmMinNum(minComputeNodeNum);
  }
  if (maxComputeNodeNum != null && maxComputeNodeNum != cluster.getVhmMaxNum()) {
    cluster.setVhmMaxNum(maxComputeNodeNum);
  }
  List<String> nodeGroupNames=new ArrayList<String>();
  if ((enableAuto != null || minComputeNodeNum != null || maxComputeNodeNum != null || activeComputeNodeNum != null) && !clusterRead.validateSetManualElasticity(nodeGroupNames)) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
  }
  if (activeComputeNodeNum != null) {
    if (!activeComputeNodeNum.equals(cluster.getVhmTargetNum())) {
      cluster.setVhmTargetNum(activeComputeNodeNum);
    }
  }
  if ((enableAuto != null) && !cluster.getStatus().isActiveServiceStatus()) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  if (!cluster.getStatus().isActiveServiceStatus() && !ClusterStatus.SERVICE_ERROR.equals(cluster.getStatus()) && !ClusterStatus.STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  clusterEntityMgr.update(cluster);
  if (enableAuto != null || minComputeNodeNum != null || maxComputeNodeNum != null) {
    boolean success=clusteringService.setAutoElasticity(clusterName,false);
    if (!success) {
      throw ClusterManagerException.FAILED_TO_SET_AUTO_ELASTICITY_ERROR(clusterName,""String_Node_Str"");
    }
  }
  if (enableAuto != null && !enableAuto && cluster.getVhmTargetNum() == null) {
    JobUtils.waitForManual(clusterName,executionService);
  }
  return nodeGroupNames;
}","/** 
 * set cluster parameters synchronously
 * @param clusterName
 * @param activeComputeNodeNum
 * @param minComputeNodeNum
 * @param maxComputeNodeNum
 * @param enableAuto
 * @param ioPriority
 * @return
 * @throws Exception
 */
@SuppressWarnings(""String_Node_Str"") public List<String> syncSetParam(String clusterName,Integer activeComputeNodeNum,Integer minComputeNodeNum,Integer maxComputeNodeNum,Boolean enableAuto,Priority ioPriority) throws Exception {
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  ClusterRead clusterRead=getClusterByName(clusterName,false);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ValidationUtils.validateVersion(clusterEntityMgr,clusterName);
  clusterEntityMgr.cleanupActionError(clusterName);
  if (ioPriority != null) {
    prioritizeCluster(clusterName,ioPriority);
  }
  cluster=clusterEntityMgr.findByName(clusterName);
  if (enableAuto != null && enableAuto != cluster.getAutomationEnable()) {
    if (enableAuto && cluster.getDistroVendor().equalsIgnoreCase(Constants.MAPR_VENDOR)) {
      logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
      throw BddException.NOT_ALLOWED_SCALING(""String_Node_Str"",clusterName);
    }
    cluster.setAutomationEnable(enableAuto);
  }
  if (minComputeNodeNum != null && minComputeNodeNum != cluster.getVhmMinNum()) {
    cluster.setVhmMinNum(minComputeNodeNum);
  }
  if (maxComputeNodeNum != null && maxComputeNodeNum != cluster.getVhmMaxNum()) {
    cluster.setVhmMaxNum(maxComputeNodeNum);
  }
  List<String> nodeGroupNames=new ArrayList<String>();
  if ((enableAuto != null || minComputeNodeNum != null || maxComputeNodeNum != null || activeComputeNodeNum != null) && !clusterRead.validateSetManualElasticity(nodeGroupNames)) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
  }
  if (activeComputeNodeNum != null) {
    if (!activeComputeNodeNum.equals(cluster.getVhmTargetNum())) {
      cluster.setVhmTargetNum(activeComputeNodeNum);
    }
  }
  if ((enableAuto != null) && !cluster.getStatus().isActiveServiceStatus()) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  if (!cluster.getStatus().isActiveServiceStatus() && !ClusterStatus.SERVICE_STOPPED.equals(cluster.getStatus()) && !ClusterStatus.STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  clusterEntityMgr.update(cluster);
  if (enableAuto != null || minComputeNodeNum != null || maxComputeNodeNum != null) {
    boolean success=clusteringService.setAutoElasticity(clusterName,false);
    if (!success) {
      throw ClusterManagerException.FAILED_TO_SET_AUTO_ELASTICITY_ERROR(clusterName,""String_Node_Str"");
    }
  }
  if (enableAuto != null && !enableAuto && cluster.getVhmTargetNum() == null) {
    JobUtils.waitForManual(clusterName,executionService);
  }
  return nodeGroupNames;
}"
48539,"public Long stopCluster(String clusterName) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ValidationUtils.validateVersion(clusterEntityMgr,clusterName);
  if (ClusterStatus.STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw ClusterManagerException.ALREADY_STOPPED_ERROR(clusterName);
  }
  if (!cluster.getStatus().isActiveServiceStatus() && !ClusterStatus.SERVICE_ERROR.equals(cluster.getStatus()) && !ClusterStatus.ERROR.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.STOP_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.STOPPED.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.ERROR.name()));
  JobParameters jobParameters=new JobParameters(param);
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.STOPPING);
  clusterEntityMgr.cleanupActionError(clusterName);
  try {
    return jobManager.runJob(JobConstants.STOP_CLUSTER_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.ERROR);
    throw e;
  }
}","public Long stopCluster(String clusterName) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ValidationUtils.validateVersion(clusterEntityMgr,clusterName);
  if (ClusterStatus.STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw ClusterManagerException.ALREADY_STOPPED_ERROR(clusterName);
  }
  if (!cluster.getStatus().isActiveServiceStatus() && !ClusterStatus.SERVICE_STOPPED.equals(cluster.getStatus()) && !ClusterStatus.ERROR.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.STOP_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.STOPPED.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.ERROR.name()));
  JobParameters jobParameters=new JobParameters(param);
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.STOPPING);
  clusterEntityMgr.cleanupActionError(clusterName);
  try {
    return jobManager.runJob(JobConstants.STOP_CLUSTER_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.ERROR);
    throw e;
  }
}"
48540,"@Override public ClusterReport queryClusterStatus(ClusterBlueprint blueprint) throws SoftwareManagementPluginException {
  if (blueprint == null) {
    logger.info(""String_Node_Str"");
    return null;
  }
  try {
    CmClusterDef cluster=new CmClusterDef(blueprint);
    syncHostsId(cluster);
    if (isExistingServiceStarted(cluster.getName())) {
      ApiHealthSummary summary=getExistingServiceHealthStatus(cluster.getName());
      if (summary.ordinal() >= ApiHealthSummary.GOOD.ordinal()) {
        if (summary.ordinal() == ApiHealthSummary.GOOD.ordinal()) {
          cluster.getCurrentReport().setStatus(ServiceStatus.STARTED);
          logger.debug(""String_Node_Str"" + blueprint.getName() + ""String_Node_Str"");
        }
 else {
          cluster.getCurrentReport().setStatus(ServiceStatus.ALERT);
          logger.debug(""String_Node_Str"" + blueprint.getName() + ""String_Node_Str"");
        }
      }
 else {
        cluster.getCurrentReport().setStatus(ServiceStatus.STARTED);
        logger.debug(""String_Node_Str"" + blueprint.getName() + ""String_Node_Str"");
      }
    }
 else {
      logger.debug(""String_Node_Str"" + blueprint.getName() + ""String_Node_Str"");
      cluster.getCurrentReport().setStatus(ServiceStatus.STOPPED);
    }
    queryNodesStatus(cluster);
    return cluster.getCurrentReport().clone();
  }
 catch (  Exception e) {
    throw SoftwareManagementPluginException.QUERY_CLUSTER_STATUS_FAILED(blueprint.getName(),e);
  }
}","@Override public ClusterReport queryClusterStatus(ClusterBlueprint blueprint) throws SoftwareManagementPluginException {
  if (blueprint == null) {
    logger.info(""String_Node_Str"");
    return null;
  }
  try {
    CmClusterDef cluster=new CmClusterDef(blueprint);
    syncHostsId(cluster);
    boolean allStarted=true;
    boolean allStopped=true;
    for (    ApiService apiService : apiResourceRootV6.getClustersResource().getServicesResource(cluster.getName()).readServices(DataView.SUMMARY)) {
      ApiServiceState serviceState=apiService.getServiceState();
      if (!ApiServiceState.STARTED.equals(serviceState)) {
        allStarted=false;
      }
 else {
        allStopped=false;
      }
    }
    if (allStopped) {
      logger.debug(""String_Node_Str"" + blueprint.getName() + ""String_Node_Str"");
      cluster.getCurrentReport().setStatus(ServiceStatus.STOPPED);
    }
 else     if (allStarted) {
      ApiHealthSummary summary=getExistingServiceHealthStatus(cluster.getName());
switch (summary) {
case GOOD:
        cluster.getCurrentReport().setStatus(ServiceStatus.STARTED);
      logger.debug(""String_Node_Str"" + blueprint.getName() + ""String_Node_Str"");
    break;
case BAD:
case CONCERNING:
  cluster.getCurrentReport().setStatus(ServiceStatus.ALERT);
logger.debug(""String_Node_Str"" + blueprint.getName() + ""String_Node_Str"");
break;
default :
cluster.getCurrentReport().setStatus(ServiceStatus.STARTED);
logger.debug(""String_Node_Str"" + blueprint.getName() + ""String_Node_Str"");
break;
}
}
 else {
cluster.getCurrentReport().setStatus(ServiceStatus.ALERT);
logger.debug(""String_Node_Str"" + blueprint.getName() + ""String_Node_Str"");
}
queryNodesStatus(cluster);
return cluster.getCurrentReport().clone();
}
 catch (Exception e) {
throw SoftwareManagementPluginException.QUERY_CLUSTER_STATUS_FAILED(blueprint.getName(),e);
}
}"
48541,"public void setVolumns(List<String> volumns,HdfsVersion hdfsVersion){
  for (  String component : components) {
switch (component) {
case ""String_Node_Str"":
      String dfsNameDir=Constants.CONFIG_DFS_NAMENODE_NAME_DIR;
    if (hdfsVersion.isHdfsV1()) {
      dfsNameDir=Constants.CONFIG_DFS_NAME_DIR;
    }
  addConfiguration(Constants.CONFIG_HDFS_SITE,dfsNameDir,dataDirs(volumns,""String_Node_Str""));
break;
case ""String_Node_Str"":
String dfsCheckpointDir=Constants.CONFIG_DFS_NAMENODE_CHECKPOINT_DIR;
if (hdfsVersion.isHdfsV1()) {
dfsCheckpointDir=Constants.CONFIG_DFS_CHECKPOINT_DIR;
}
addConfiguration(Constants.CONFIG_HDFS_SITE,dfsCheckpointDir,volumns.get(0) + ""String_Node_Str"");
break;
case ""String_Node_Str"":
String dfsDataDir=Constants.CONFIG_DFS_DATANODE_DATA_DIR;
if (hdfsVersion.isHdfsV1()) {
dfsDataDir=Constants.CONFIG_DFS_DATA_DIR;
}
addConfiguration(Constants.CONFIG_HDFS_SITE,dfsDataDir,dataDirs(volumns,""String_Node_Str""));
break;
case ""String_Node_Str"":
addConfiguration(Constants.CONFIG_YARN_SITE,Constants.CONFIG_YARN_NODEMANAGER_LOCAL_DIRS,dataDirs(volumns,""String_Node_Str""));
break;
case ""String_Node_Str"":
addConfiguration(Constants.CONFIG_HDFS_SITE,Constants.CONFIG_JOURNALNODE_EDITS_DIR,volumns.get(0) + ""String_Node_Str"");
break;
case ""String_Node_Str"":
addConfiguration(Constants.CONFIG_MAPRED_SITE,Constants.CONFIG_MAPRED_LOCAL_DIR,dataDirs(volumns,""String_Node_Str""));
break;
default :
break;
}
}
}","public void setVolumns(List<String> volumns,HdfsVersion hdfsVersion){
  if (volumns.isEmpty()) {
    return;
  }
  for (  String component : components) {
switch (component) {
case ""String_Node_Str"":
      String dfsNameDir=Constants.CONFIG_DFS_NAMENODE_NAME_DIR;
    if (hdfsVersion.isHdfsV1()) {
      dfsNameDir=Constants.CONFIG_DFS_NAME_DIR;
    }
  addConfiguration(Constants.CONFIG_HDFS_SITE,dfsNameDir,dataDirs(volumns,""String_Node_Str""));
break;
case ""String_Node_Str"":
String dfsCheckpointDir=Constants.CONFIG_DFS_NAMENODE_CHECKPOINT_DIR;
if (hdfsVersion.isHdfsV1()) {
dfsCheckpointDir=Constants.CONFIG_DFS_CHECKPOINT_DIR;
}
addConfiguration(Constants.CONFIG_HDFS_SITE,dfsCheckpointDir,volumns.get(0) + ""String_Node_Str"");
break;
case ""String_Node_Str"":
String dfsDataDir=Constants.CONFIG_DFS_DATANODE_DATA_DIR;
if (hdfsVersion.isHdfsV1()) {
dfsDataDir=Constants.CONFIG_DFS_DATA_DIR;
}
addConfiguration(Constants.CONFIG_HDFS_SITE,dfsDataDir,dataDirs(volumns,""String_Node_Str""));
break;
case ""String_Node_Str"":
addConfiguration(Constants.CONFIG_YARN_SITE,Constants.CONFIG_YARN_NODEMANAGER_LOCAL_DIRS,dataDirs(volumns,""String_Node_Str""));
break;
case ""String_Node_Str"":
addConfiguration(Constants.CONFIG_HDFS_SITE,Constants.CONFIG_JOURNALNODE_EDITS_DIR,volumns.get(0) + ""String_Node_Str"");
break;
case ""String_Node_Str"":
addConfiguration(Constants.CONFIG_MAPRED_SITE,Constants.CONFIG_MAPRED_LOCAL_DIR,dataDirs(volumns,""String_Node_Str""));
break;
default :
break;
}
}
}"
48542,"@Override public boolean poll(){
  Long requestId=apiRequestSummary.getApiRequestInfo().getRequestId();
  ApiRequest apiRequest=apiManager.getRequestWithTasks(clusterName,requestId);
  ClusterRequestStatus clusterRequestStatus=ClusterRequestStatus.valueOf(apiRequest.getApiRequestInfo().getRequestStatus());
  Map<String,NodeReport> nodeReports=currentReport.getNodeReports();
  for (  String nodeReportKey : nodeReports.keySet()) {
    for (    ApiTask apiTask : apiRequest.getApiTasks()) {
      NodeReport nodeReport=nodeReports.get(nodeReportKey);
      nodeReport.setUseClusterMsg(false);
      ApiTaskInfo apiTaskInfo=apiTask.getApiTaskInfo();
      if (nodeReport.getHostname().equals(apiTaskInfo.getHostName())) {
        TaskStatus taskStatus=TaskStatus.valueOf(apiTask.getApiTaskInfo().getStatus());
        if (taskStatus.isRunningState()) {
          if (clusterRequestStatus.isFailedState() && apiTaskInfo.getStderr() != null && !apiTaskInfo.getStderr().isEmpty()) {
            nodeReport.setAction(apiTaskInfo.getCommandDetail() + ""String_Node_Str"" + apiTaskInfo.getStderr());
          }
 else {
            nodeReport.setAction(apiTaskInfo.getCommandDetail());
          }
          nodeReports.put(nodeReportKey,nodeReport);
        }
      }
    }
  }
  currentReport.setNodeReports(nodeReports);
  int provisionPercent=(int)apiRequest.getApiRequestInfo().getProgressPercent();
  if (provisionPercent != 0) {
    int currentProgress=currentReport.getProgress();
    int toProgress=beginProgress + provisionPercent / 2;
    if (toProgress >= endProgress) {
      toProgress=endProgress;
    }
    boolean isCompletedState=clusterRequestStatus.isCompletedState();
    if ((toProgress != currentProgress) && (provisionPercent % 10 == 0) || isCompletedState) {
      if (isCompletedState) {
        logger.info(""String_Node_Str"" + requestId + ""String_Node_Str"");
      }
 else {
        logger.info(""String_Node_Str"" + requestId + ""String_Node_Str"");
      }
      currentReport.setProgress(toProgress);
      if (reportQueue != null) {
        reportQueue.addClusterReport(currentReport.clone());
      }
    }
  }
  if (clusterRequestStatus.isCompletedState()) {
    return true;
  }
  return false;
}","@Override public boolean poll(){
  if (apiRequestSummary == null) {
    return true;
  }
  Long requestId=apiRequestSummary.getApiRequestInfo().getRequestId();
  ApiRequest apiRequest=apiManager.getRequestWithTasks(clusterName,requestId);
  ClusterRequestStatus clusterRequestStatus=ClusterRequestStatus.valueOf(apiRequest.getApiRequestInfo().getRequestStatus());
  Map<String,NodeReport> nodeReports=currentReport.getNodeReports();
  for (  String nodeReportKey : nodeReports.keySet()) {
    for (    ApiTask apiTask : apiRequest.getApiTasks()) {
      NodeReport nodeReport=nodeReports.get(nodeReportKey);
      nodeReport.setUseClusterMsg(false);
      ApiTaskInfo apiTaskInfo=apiTask.getApiTaskInfo();
      if (nodeReport.getHostname().equals(apiTaskInfo.getHostName())) {
        TaskStatus taskStatus=TaskStatus.valueOf(apiTask.getApiTaskInfo().getStatus());
        if (taskStatus.isRunningState()) {
          if (clusterRequestStatus.isFailedState() && apiTaskInfo.getStderr() != null && !apiTaskInfo.getStderr().isEmpty()) {
            nodeReport.setAction(apiTaskInfo.getCommandDetail() + ""String_Node_Str"" + apiTaskInfo.getStderr());
          }
 else {
            nodeReport.setAction(apiTaskInfo.getCommandDetail());
          }
          nodeReports.put(nodeReportKey,nodeReport);
        }
      }
    }
  }
  currentReport.setNodeReports(nodeReports);
  int provisionPercent=(int)apiRequest.getApiRequestInfo().getProgressPercent();
  if (provisionPercent != 0) {
    int currentProgress=currentReport.getProgress();
    int toProgress=beginProgress + provisionPercent / 2;
    if (toProgress >= endProgress) {
      toProgress=endProgress;
    }
    boolean isCompletedState=clusterRequestStatus.isCompletedState();
    if ((toProgress != currentProgress) && (provisionPercent % 10 == 0) || isCompletedState) {
      if (isCompletedState) {
        logger.info(""String_Node_Str"" + requestId + ""String_Node_Str"");
      }
 else {
        logger.info(""String_Node_Str"" + requestId + ""String_Node_Str"");
      }
      currentReport.setProgress(toProgress);
      if (reportQueue != null) {
        reportQueue.addClusterReport(currentReport.clone());
      }
    }
  }
  if (clusterRequestStatus.isCompletedState()) {
    return true;
  }
  return false;
}"
48543,"private boolean doSoftwareOperation(String clusterName,ApiRequest apiRequestSummary,ClusterReport clusterReport,ClusterReportQueue reports) throws Exception {
  ClusterOperationPoller poller=new ClusterOperationPoller(apiManager,apiRequestSummary,clusterName,clusterReport,reports,ProgressSplit.OPERATION_FINISHED.getProgress());
  poller.waitForComplete();
  boolean success=false;
  ApiRequest apiRequest=apiManager.getRequestWithTasks(clusterName,apiRequestSummary.getApiRequestInfo().getRequestId());
  ClusterRequestStatus clusterRequestStatus=ClusterRequestStatus.valueOf(apiRequest.getApiRequestInfo().getRequestStatus());
  if (!clusterRequestStatus.isFailedState()) {
    success=true;
  }
 else {
    logger.error(""String_Node_Str"" + ApiUtils.objectToJson(apiRequest.getApiRequestInfo()));
    List<ApiTask> apiTasks=apiRequest.getApiTasks();
    Map<String,NodeReport> nodeReports=clusterReport.getNodeReports();
    HashMap<String,List<String>> errMsg=new HashMap<>();
    for (    ApiTask apiTask : apiTasks) {
      ApiTaskInfo taskInfo=apiTask.getApiTaskInfo();
      if (TaskStatus.valueOf(taskInfo.getStatus()).isFailedState()) {
        if (!errMsg.containsKey(taskInfo.getHostName())) {
          List<String> errs=new ArrayList<>();
          errMsg.put(taskInfo.getHostName(),errs);
        }
        String taskErrMsg=taskInfo.getCommandDetail() + ""String_Node_Str"" + taskInfo.getStatus();
        errMsg.get(taskInfo.getHostName()).add(taskErrMsg);
        logger.error(""String_Node_Str"" + taskInfo.getCommandDetail() + ""String_Node_Str""+ taskInfo.getRole()+ ""String_Node_Str""+ taskInfo.getStructuredOut()+ ""String_Node_Str""+ taskInfo.getStderr()+ ""String_Node_Str""+ taskInfo.getStatus());
      }
    }
    for (    NodeReport nodeReport : nodeReports.values()) {
      if (errMsg.containsKey(nodeReport.getHostname())) {
        nodeReport.setErrMsg(errMsg.get(nodeReport.getHostname()).toString());
      }
    }
    String requestErrorMsg=""String_Node_Str"" + apiRequest.getApiRequestInfo().getRequestStatus() + ""String_Node_Str"";
    clusterReport.setErrMsg(requestErrorMsg);
    reportStatus(clusterReport.clone(),reports);
    throw new RuntimeException(requestErrorMsg);
  }
  return success;
}","private boolean doSoftwareOperation(String clusterName,ApiRequest apiRequestSummary,ClusterReport clusterReport,ClusterReportQueue reports) throws Exception {
  if (apiRequestSummary == null) {
    return true;
  }
  ClusterOperationPoller poller=new ClusterOperationPoller(apiManager,apiRequestSummary,clusterName,clusterReport,reports,ProgressSplit.OPERATION_FINISHED.getProgress());
  poller.waitForComplete();
  boolean success=false;
  ApiRequest apiRequest=apiManager.getRequestWithTasks(clusterName,apiRequestSummary.getApiRequestInfo().getRequestId());
  ClusterRequestStatus clusterRequestStatus=ClusterRequestStatus.valueOf(apiRequest.getApiRequestInfo().getRequestStatus());
  if (!clusterRequestStatus.isFailedState()) {
    success=true;
  }
 else {
    logger.error(""String_Node_Str"" + ApiUtils.objectToJson(apiRequest.getApiRequestInfo()));
    List<ApiTask> apiTasks=apiRequest.getApiTasks();
    Map<String,NodeReport> nodeReports=clusterReport.getNodeReports();
    HashMap<String,List<String>> errMsg=new HashMap<>();
    for (    ApiTask apiTask : apiTasks) {
      ApiTaskInfo taskInfo=apiTask.getApiTaskInfo();
      if (TaskStatus.valueOf(taskInfo.getStatus()).isFailedState()) {
        if (!errMsg.containsKey(taskInfo.getHostName())) {
          List<String> errs=new ArrayList<>();
          errMsg.put(taskInfo.getHostName(),errs);
        }
        String taskErrMsg=taskInfo.getCommandDetail() + ""String_Node_Str"" + taskInfo.getStatus();
        errMsg.get(taskInfo.getHostName()).add(taskErrMsg);
        logger.error(""String_Node_Str"" + taskInfo.getCommandDetail() + ""String_Node_Str""+ taskInfo.getRole()+ ""String_Node_Str""+ taskInfo.getStderr()+ ""String_Node_Str""+ taskInfo.getStatus());
      }
    }
    for (    NodeReport nodeReport : nodeReports.values()) {
      if (errMsg.containsKey(nodeReport.getHostname())) {
        nodeReport.setErrMsg(errMsg.get(nodeReport.getHostname()).toString());
      }
    }
    String requestErrorMsg=""String_Node_Str"" + apiRequest.getApiRequestInfo().getRequestStatus() + ""String_Node_Str"";
    clusterReport.setErrMsg(requestErrorMsg);
    reportStatus(clusterReport.clone(),reports);
    throw new RuntimeException(requestErrorMsg);
  }
  return success;
}"
48544,"private boolean handleNodeStatus(ClusterReport report,boolean lastUpdate){
  boolean finished=report.isFinished();
  ClusterEntity cluster=findByName(report.getName());
  Map<String,NodeReport> nodeReportMap=report.getNodeReports();
  for (  NodeGroupEntity group : cluster.getNodeGroups()) {
    for (    NodeEntity node : group.getNodes()) {
      NodeReport nodeReport=nodeReportMap.get(node.getVmName());
      if (nodeReport == null) {
        continue;
      }
      if (nodeReport.getStatus() != null) {
        if (!node.isDisconnected() && node.getStatus().ordinal() >= NodeStatus.VM_READY.ordinal()) {
          logger.debug(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ nodeReport.getStatus().toString());
          NodeStatus oldStatus=node.getStatus();
switch (nodeReport.getStatus()) {
case STARTED:
            node.setStatus(NodeStatus.SERVICE_READY,false);
          break;
case UNHEALTHY:
        node.setStatus(NodeStatus.SERVICE_UNHEALTHY,false);
      break;
case ALERT:
    node.setStatus(NodeStatus.SERVICE_ALERT,false);
  break;
case UNKONWN:
node.setStatus(NodeStatus.UNKNOWN,false);
break;
case PROVISIONING:
case STOPPED:
node.setStatus(NodeStatus.VM_READY,false);
break;
default :
node.setStatus(NodeStatus.BOOTSTRAP_FAILED,false);
}
logger.debug(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ oldStatus+ ""String_Node_Str""+ node.getStatus());
}
}
if (nodeReport.isUseClusterMsg() && report.getAction() != null) {
logger.debug(""String_Node_Str"" + report.getAction());
node.setAction(report.getAction());
}
 else if (nodeReport.getAction() != null) {
node.setAction(nodeReport.getAction());
}
if (lastUpdate) {
if (nodeReport.getErrMsg() != null) {
logger.debug(""String_Node_Str"" + report.getAction());
node.setErrMessage(nodeReport.getErrMsg());
node.setActionFailed(true);
}
 else {
logger.debug(""String_Node_Str"" + node.getHostName());
node.setErrMessage(null);
node.setActionFailed(false);
}
}
}
}
return finished;
}","private boolean handleNodeStatus(ClusterReport report,boolean lastUpdate){
  boolean finished=report.isFinished();
  ClusterEntity cluster=findByName(report.getName());
  Map<String,NodeReport> nodeReportMap=report.getNodeReports();
  for (  NodeGroupEntity group : cluster.getNodeGroups()) {
    for (    NodeEntity node : group.getNodes()) {
      NodeReport nodeReport=nodeReportMap.get(node.getVmName());
      if (nodeReport == null) {
        continue;
      }
      if (nodeReport.getStatus() != null) {
        if (!node.isDisconnected() && node.getStatus().ordinal() >= NodeStatus.VM_READY.ordinal()) {
          logger.debug(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ nodeReport.getStatus().toString());
          NodeStatus oldStatus=node.getStatus();
switch (nodeReport.getStatus()) {
case STARTED:
            node.setStatus(NodeStatus.SERVICE_READY,false);
          break;
case UNHEALTHY:
        node.setStatus(NodeStatus.SERVICE_UNHEALTHY,false);
      break;
case ALERT:
    if (node.getStatus() != NodeStatus.BOOTSTRAP_FAILED) {
      node.setStatus(NodeStatus.SERVICE_ALERT,false);
    }
  break;
case UNKONWN:
node.setStatus(NodeStatus.UNKNOWN,false);
break;
case PROVISIONING:
case STOPPED:
if (node.getStatus() != NodeStatus.BOOTSTRAP_FAILED) {
node.setStatus(NodeStatus.VM_READY,false);
}
break;
default :
node.setStatus(NodeStatus.BOOTSTRAP_FAILED,false);
}
logger.debug(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ oldStatus+ ""String_Node_Str""+ node.getStatus());
}
}
if (nodeReport.isUseClusterMsg() && report.getAction() != null) {
logger.debug(""String_Node_Str"" + report.getAction());
node.setAction(report.getAction());
}
 else if (nodeReport.getAction() != null) {
node.setAction(nodeReport.getAction());
}
if (lastUpdate) {
if (nodeReport.getErrMsg() != null) {
logger.debug(""String_Node_Str"" + report.getAction());
node.setErrMessage(nodeReport.getErrMsg());
node.setActionFailed(true);
}
 else {
logger.debug(""String_Node_Str"" + node.getHostName());
node.setErrMessage(null);
node.setActionFailed(false);
}
}
}
}
return finished;
}"
48545,"public Long resumeClusterCreation(String clusterName) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ValidationUtils.validateVersion(clusterEntityMgr,clusterName);
  if (cluster.getStatus() != ClusterStatus.PROVISION_ERROR && cluster.getStatus() != ClusterStatus.SERVICE_ERROR) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus());
    throw ClusterManagerException.UPDATE_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  List<String> dsNames=getUsedDS(cluster.getVcDatastoreNameList());
  if (dsNames.isEmpty()) {
    throw ClusterConfigException.NO_RESOURCE_POOL_ADDED();
  }
  List<VcCluster> vcClusters=getUsedVcClusters(cluster.getVcRpNameList());
  if (vcClusters.isEmpty()) {
    throw ClusterConfigException.NO_DATASTORE_ADDED();
  }
  validateDatastore(dsNames,vcClusters);
  validateNetworkAccessibility(cluster.fetchNetworkNameList(),vcClusters);
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.PROVISION_ERROR.name()));
  JobParameters jobParameters=new JobParameters(param);
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.PROVISIONING);
  clusterEntityMgr.cleanupActionError(clusterName);
  try {
    return jobManager.runJob(JobConstants.RESUME_CLUSTER_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.PROVISION_ERROR);
    throw e;
  }
}","public Long resumeClusterCreation(String clusterName) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ValidationUtils.validateVersion(clusterEntityMgr,clusterName);
  if (cluster.getStatus() != ClusterStatus.PROVISION_ERROR) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus());
    throw ClusterManagerException.UPDATE_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  List<String> dsNames=getUsedDS(cluster.getVcDatastoreNameList());
  if (dsNames.isEmpty()) {
    throw ClusterConfigException.NO_RESOURCE_POOL_ADDED();
  }
  List<VcCluster> vcClusters=getUsedVcClusters(cluster.getVcRpNameList());
  if (vcClusters.isEmpty()) {
    throw ClusterConfigException.NO_DATASTORE_ADDED();
  }
  validateDatastore(dsNames,vcClusters);
  validateNetworkAccessibility(cluster.fetchNetworkNameList(),vcClusters);
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.PROVISION_ERROR.name()));
  JobParameters jobParameters=new JobParameters(param);
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.PROVISIONING);
  clusterEntityMgr.cleanupActionError(clusterName);
  try {
    return jobManager.runJob(JobConstants.RESUME_CLUSTER_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.PROVISION_ERROR);
    throw e;
  }
}"
48546,"private void queryNodesStatus(CmClusterDef cluster){
  for (  CmNodeDef node : cluster.getNodes()) {
    Map<String,NodeReport> nodeReports=cluster.getCurrentReport().getNodeReports();
    NodeReport nodeReport=nodeReports.get(node.getName());
    try {
      ApiHost host=apiResourceRootV6.getHostsResource().readHost(node.getNodeId());
      ApiHealthSummary health=host.getHealthSummary();
switch (health) {
case GOOD:
        nodeReport.setStatus(ServiceStatus.STARTED);
      logger.debug(""String_Node_Str"" + nodeReport.getName() + ""String_Node_Str"");
    break;
case CONCERNING:
  nodeReport.setStatus(ServiceStatus.UNHEALTHY);
logger.debug(""String_Node_Str"" + nodeReport.getName() + ""String_Node_Str"");
break;
case BAD:
logger.debug(""String_Node_Str"" + nodeReport.getName() + ""String_Node_Str"");
nodeReport.setStatus(ServiceStatus.ALERT);
break;
default :
logger.debug(""String_Node_Str"" + nodeReport.getName() + ""String_Node_Str"");
nodeReport.setStatus(ServiceStatus.UNKONWN);
break;
}
}
 catch (NotFoundException e) {
logger.debug(""String_Node_Str"" + node.getName() + ""String_Node_Str"");
nodeReport.setStatus(ServiceStatus.FAILED);
}
}
}","private void queryNodesStatus(CmClusterDef cluster){
  for (  CmNodeDef node : cluster.getNodes()) {
    Map<String,NodeReport> nodeReports=cluster.getCurrentReport().getNodeReports();
    NodeReport nodeReport=nodeReports.get(node.getName());
    try {
      ApiHost host=apiResourceRootV6.getHostsResource().readHost(node.getNodeId());
      ApiHealthSummary health=host.getHealthSummary();
switch (health) {
case GOOD:
        List<ApiRoleRef> roleRefs=host.getRoleRefs();
      boolean hasStarted=false;
    boolean hasStopped=false;
  for (  ApiRoleRef roleRef : roleRefs) {
    if (isRoleStarted(roleRef.getClusterName(),roleRef.getServiceName(),roleRef.getRoleName())) {
      hasStarted=true;
    }
 else {
      hasStopped=true;
    }
  }
if (hasStopped && !hasStarted) {
  nodeReport.setStatus(ServiceStatus.STOPPED);
}
 else if (hasStopped && hasStarted) {
  nodeReport.setStatus(ServiceStatus.ALERT);
}
 else if (!hasStopped && hasStarted) {
  nodeReport.setStatus(ServiceStatus.STARTED);
}
 else {
  nodeReport.setStatus(ServiceStatus.STOPPED);
}
logger.debug(""String_Node_Str"" + nodeReport.getName() + ""String_Node_Str"");
break;
case CONCERNING:
nodeReport.setStatus(ServiceStatus.UNHEALTHY);
logger.debug(""String_Node_Str"" + nodeReport.getName() + ""String_Node_Str"");
break;
case BAD:
logger.debug(""String_Node_Str"" + nodeReport.getName() + ""String_Node_Str"");
nodeReport.setStatus(ServiceStatus.ALERT);
break;
default :
logger.debug(""String_Node_Str"" + nodeReport.getName() + ""String_Node_Str"");
nodeReport.setStatus(ServiceStatus.UNKONWN);
break;
}
}
 catch (NotFoundException e) {
logger.debug(""String_Node_Str"" + node.getName() + ""String_Node_Str"");
nodeReport.setStatus(ServiceStatus.FAILED);
}
}
}"
48547,"@Override public boolean scaleOutCluster(ClusterBlueprint blueprint,List<String> addedNodeNames,ClusterReportQueue reportQueue) throws SoftwareManagementPluginException {
  boolean success=false;
  CmClusterDef clusterDef=null;
  try {
    clusterDef=new CmClusterDef(blueprint);
    provisionCluster(clusterDef,addedNodeNames,reportQueue,true);
    provisionParcels(clusterDef,addedNodeNames,reportQueue);
    Map<String,List<ApiRole>> roles=configureNodeServices(clusterDef,reportQueue,addedNodeNames);
    startNodeServices(clusterDef,addedNodeNames,roles,reportQueue);
    success=true;
    clusterDef.getCurrentReport().setProgress(100);
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setClusterAndNodesServiceStatus(ServiceStatus.STARTED);
  }
 catch (  SoftwareManagementPluginException ex) {
    if (ex instanceof CommandExecFailException) {
      String hostId=((CommandExecFailException)ex).getRefHostId();
      CmNodeDef nodeDef=clusterDef.idToHosts().get(hostId);
      String errMsg=null;
      if (nodeDef != null) {
        errMsg=""String_Node_Str"" + nodeDef.getName() + ""String_Node_Str""+ ((ex.getMessage() == null) ? ""String_Node_Str"" : (""String_Node_Str"" + ex.getMessage()));
        clusterDef.getCurrentReport().setNodesAction(""String_Node_Str"",addedNodeNames);
        clusterDef.getCurrentReport().setNodesStatus(ServiceStatus.STOPPED,addedNodeNames);
        clusterDef.getCurrentReport().getNodeReports().get(nodeDef.getName()).setErrMsg(errMsg);
        throw SoftwareManagementPluginException.START_SERVICE_FAILED(ex,CLOUDERA_MANAGER,clusterDef.getName());
      }
    }
    clusterDef.getCurrentReport().setNodesError(ex.getMessage(),addedNodeNames);
    clusterDef.getCurrentReport().setNodesStatus(ServiceStatus.STOPPED,addedNodeNames);
    throw ex;
  }
catch (  Exception e) {
    clusterDef.getCurrentReport().setNodesError(""String_Node_Str"" + e.getMessage(),addedNodeNames);
    logger.error(e.getMessage());
    throw SoftwareManagementPluginException.SCALE_OUT_CLUSTER_FAILED(e,CLOUDERA_MANAGER,clusterDef.getName());
  }
 finally {
    clusterDef.getCurrentReport().setSuccess(success);
    clusterDef.getCurrentReport().setFinished(true);
    reportQueue.addClusterReport(clusterDef.getCurrentReport().clone());
  }
  return success;
}","@Override public boolean scaleOutCluster(ClusterBlueprint blueprint,List<String> addedNodeNames,ClusterReportQueue reportQueue) throws SoftwareManagementPluginException {
  boolean success=false;
  CmClusterDef clusterDef=null;
  try {
    clusterDef=new CmClusterDef(blueprint);
    provisionCluster(clusterDef,addedNodeNames,reportQueue,true);
    provisionParcels(clusterDef,addedNodeNames,reportQueue);
    Map<String,List<ApiRole>> roles=configureNodeServices(clusterDef,reportQueue,addedNodeNames);
    startNodeServices(clusterDef,addedNodeNames,roles,reportQueue);
    success=true;
    clusterDef.getCurrentReport().setProgress(100);
    clusterDef.getCurrentReport().setAction(""String_Node_Str"");
    clusterDef.getCurrentReport().setClusterAndNodesServiceStatus(ServiceStatus.STARTED);
  }
 catch (  SoftwareManagementPluginException ex) {
    if (ex instanceof CommandExecFailException) {
      String hostId=((CommandExecFailException)ex).getRefHostId();
      CmNodeDef nodeDef=clusterDef.idToHosts().get(hostId);
      String errMsg=null;
      if (nodeDef != null) {
        errMsg=""String_Node_Str"" + nodeDef.getName() + ""String_Node_Str""+ ((ex.getMessage() == null) ? ""String_Node_Str"" : (""String_Node_Str"" + ex.getMessage()));
        clusterDef.getCurrentReport().setNodesAction(""String_Node_Str"",addedNodeNames);
        clusterDef.getCurrentReport().setNodesStatus(ServiceStatus.STOPPED,addedNodeNames);
        clusterDef.getCurrentReport().getNodeReports().get(nodeDef.getName()).setErrMsg(errMsg);
        throw SoftwareManagementPluginException.START_SERVICE_FAILED(ex,CLOUDERA_MANAGER,clusterDef.getName());
      }
    }
    clusterDef.getCurrentReport().setNodesError(ex.getMessage(),addedNodeNames);
    clusterDef.getCurrentReport().setNodesStatus(ServiceStatus.FAILED,addedNodeNames);
    throw ex;
  }
catch (  Exception e) {
    clusterDef.getCurrentReport().setNodesError(""String_Node_Str"" + e.getMessage(),addedNodeNames);
    clusterDef.getCurrentReport().setNodesStatus(ServiceStatus.FAILED,addedNodeNames);
    logger.error(e.getMessage());
    throw SoftwareManagementPluginException.SCALE_OUT_CLUSTER_FAILED(e,CLOUDERA_MANAGER,clusterDef.getName());
  }
 finally {
    clusterDef.getCurrentReport().setSuccess(success);
    clusterDef.getCurrentReport().setFinished(true);
    reportQueue.addClusterReport(clusterDef.getCurrentReport().clone());
  }
  return success;
}"
48548,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void addAppManager(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String description,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String url){
  AppManagerAdd appManagerAdd=new AppManagerAdd();
  appManagerAdd.setName(name);
  appManagerAdd.setDescription(description);
  appManagerAdd.setType(type);
  appManagerAdd.setUrl(url);
  Map<String,String> loginInfo=getAccount();
  if (null == loginInfo) {
    return;
  }
  appManagerAdd.setUsername(loginInfo.get(Constants.LOGIN_USERNAME));
  appManagerAdd.setPassword(loginInfo.get(Constants.LOGIN_PASSWORD));
  if (url.toLowerCase().startsWith(""String_Node_Str"")) {
    String sslCertificate=getSslCertificate();
    if (null != sslCertificate) {
      appManagerAdd.setSslCertificate(sslCertificate);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
      return;
    }
  }
  try {
    restClient.add(appManagerAdd);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_RESULT_ADD);
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void addAppManager(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String description,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String url){
  AppManagerAdd appManagerAdd=new AppManagerAdd();
  appManagerAdd.setName(name);
  appManagerAdd.setDescription(description);
  String[] types=restClient.getTypes();
  boolean found=false;
  for (  String t : types) {
    if (type.equals(t)) {
      found=true;
      break;
    }
  }
  if (found) {
    appManagerAdd.setType(type);
  }
 else {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"" + type + ""String_Node_Str""+ Arrays.asList(types)+ ""String_Node_Str"");
    return;
  }
  appManagerAdd.setUrl(url);
  Map<String,String> loginInfo=getAccount();
  if (null == loginInfo) {
    return;
  }
  appManagerAdd.setUsername(loginInfo.get(Constants.LOGIN_USERNAME));
  appManagerAdd.setPassword(loginInfo.get(Constants.LOGIN_PASSWORD));
  if (url.toLowerCase().startsWith(""String_Node_Str"")) {
    String sslCertificate=getSslCertificate();
    if (null != sslCertificate) {
      appManagerAdd.setSslCertificate(sslCertificate);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
      return;
    }
  }
  try {
    restClient.add(appManagerAdd);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_RESULT_ADD);
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}"
48549,"private boolean setupPasswordLessLogin(String hostIP) throws Exception {
  String scriptName=Configuration.getString(Constants.PASSWORDLESS_LOGIN_SCRIPT,Constants.DEFAULT_PASSWORDLESS_LOGIN_SCRIPT);
  String script=getScriptName(scriptName);
  String user=Configuration.getString(Constants.SSH_USER_CONFIG_NAME,Constants.DEFAULT_SSH_USER_NAME);
  String password=Configuration.getString(Constants.SERENGETI_DEFAULT_PASSWORD);
  String cmd=script + ""String_Node_Str"" + hostIP+ ""String_Node_Str""+ user+ ""String_Node_Str""+ password;
  int timeoutCount=0;
  for (int i=0; i < Constants.SET_PASSWORD_MAX_RETRY_TIMES; i++) {
    try {
      ShellCommandExecutor.execCmd(cmd,null,null,this.setupPasswordLessLoginTimeout,Constants.MSG_SETTING_UP_PASSWORDLESS_LOGIN + hostIP + ""String_Node_Str"");
      logger.info(""String_Node_Str"" + hostIP);
      return true;
    }
 catch (    Exception e) {
      if (e.getMessage().contains(Constants.EXEC_COMMAND_TIMEOUT)) {
        timeoutCount++;
      }
      logger.warn(""String_Node_Str"" + i + ""String_Node_Str""+ e.getMessage(),e);
      try {
        Thread.sleep(3000);
      }
 catch (      InterruptedException ie) {
        logger.warn(""String_Node_Str"",ie);
      }
    }
  }
  logger.error(""String_Node_Str"" + hostIP);
  if (timeoutCount == Constants.SET_PASSWORD_MAX_RETRY_TIMES) {
    throw SetPasswordException.SETUP_PASSWORDLESS_LOGIN_TIMEOUT(null,hostIP);
  }
  throw SetPasswordException.FAIL_TO_SETUP_PASSWORDLESS_LOGIN(hostIP);
}","private boolean setupPasswordLessLogin(String hostIP) throws Exception {
  String scriptName=Configuration.getString(Constants.PASSWORDLESS_LOGIN_SCRIPT,Constants.DEFAULT_PASSWORDLESS_LOGIN_SCRIPT);
  String script=getScriptName(scriptName);
  String user=Configuration.getString(Constants.SSH_USER_CONFIG_NAME,Constants.DEFAULT_SSH_USER_NAME);
  String password=Configuration.getString(Constants.SERENGETI_DEFAULT_PASSWORD);
  String cmd=script + ""String_Node_Str"" + hostIP+ ""String_Node_Str""+ user+ ""String_Node_Str""+ password;
  int sleepTime=Configuration.getInt(Constants.SSH_SLEEP_TIME_BEFORE_RETRY,Constants.DEFAULT_SSH_SLEEP_TIME_BEFORE_RETRY);
  int timeoutCount=0;
  for (int i=0; i < Constants.SET_PASSWORD_MAX_RETRY_TIMES; i++) {
    try {
      ShellCommandExecutor.execCmd(cmd,null,null,this.setupPasswordLessLoginTimeout,Constants.MSG_SETTING_UP_PASSWORDLESS_LOGIN + hostIP + ""String_Node_Str"");
      logger.info(""String_Node_Str"" + hostIP);
      return true;
    }
 catch (    Exception e) {
      if (e.getMessage().contains(Constants.EXEC_COMMAND_TIMEOUT)) {
        timeoutCount++;
      }
      logger.warn(""String_Node_Str"" + i + ""String_Node_Str""+ e.getMessage(),e);
      try {
        Thread.sleep(sleepTime);
      }
 catch (      InterruptedException ie) {
        logger.warn(""String_Node_Str"",ie);
      }
    }
  }
  logger.error(""String_Node_Str"" + hostIP);
  if (timeoutCount == Constants.SET_PASSWORD_MAX_RETRY_TIMES) {
    throw SetPasswordException.SETUP_PASSWORDLESS_LOGIN_TIMEOUT(null,hostIP);
  }
  throw SetPasswordException.FAIL_TO_SETUP_PASSWORDLESS_LOGIN(hostIP);
}"
48550,"@Override public boolean onDeleteCluster(ClusterBlueprint clusterBlueprint,ClusterReportQueue reports) throws SoftwareManagementPluginException {
  try {
    String clusterName=clusterBlueprint.getName();
    if (!echo()) {
      logger.warn(""String_Node_Str"" + clusterName + ""String_Node_Str"");
      logger.warn(""String_Node_Str"");
      return true;
    }
    if (!isProvisioned(clusterName)) {
      return true;
    }
    AmClusterDef clusterDef=new AmClusterDef(clusterBlueprint,null);
    if (!isClusterProvisionedByBDE(clusterDef)) {
      return true;
    }
    if (!onStopCluster(clusterBlueprint,reports)) {
      logger.error(""String_Node_Str"");
    }
    List<String> serviceNames=apiManager.getClusterServicesNames(clusterName);
    if (serviceNames != null && !serviceNames.isEmpty()) {
      for (      String serviceName : serviceNames) {
        apiManager.deleteService(clusterName,serviceName);
      }
    }
    if (apiManager.getHostsSummaryInfo(clusterName) != null) {
      List<ApiHost> hosts=apiManager.getHostsSummaryInfo(clusterName).getApiHosts();
      if (hosts != null && !hosts.isEmpty()) {
        for (        ApiHost host : hosts) {
          assert(host.getApiHostInfo() != null);
          String hostName=host.getApiHostInfo().getHostName();
          apiManager.deleteHost(clusterName,hostName);
        }
      }
    }
    apiManager.deleteCluster(clusterName);
    if (isBlueprintCreated(clusterDef) && isBlueprintCreatedByBDE(clusterDef)) {
      apiManager.deleteBlueprint(clusterName);
    }
    ApiPersist persist=new ApiPersist(""String_Node_Str"");
    apiManager.updatePersist(persist);
    return true;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw SoftwareManagementPluginException.DELETE_CLUSTER_FAILED(e,AMBARI,clusterBlueprint.getName());
  }
}","@Override public boolean onDeleteCluster(ClusterBlueprint clusterBlueprint,ClusterReportQueue reports) throws SoftwareManagementPluginException {
  try {
    String clusterName=clusterBlueprint.getName();
    if (!echo()) {
      logger.warn(""String_Node_Str"" + clusterName + ""String_Node_Str"");
      logger.warn(""String_Node_Str"");
      return true;
    }
    if (!isProvisioned(clusterName)) {
      return true;
    }
    AmClusterDef clusterDef=new AmClusterDef(clusterBlueprint,null);
    if (!isClusterProvisionedByBDE(clusterDef)) {
      return true;
    }
    try {
      if (!onStopCluster(clusterBlueprint,reports)) {
        logger.error(""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
    }
    List<String> serviceNames=apiManager.getClusterServicesNames(clusterName);
    if (serviceNames != null && !serviceNames.isEmpty()) {
      for (      String serviceName : serviceNames) {
        apiManager.deleteService(clusterName,serviceName);
      }
    }
    if (apiManager.getHostsSummaryInfo(clusterName) != null) {
      List<ApiHost> hosts=apiManager.getHostsSummaryInfo(clusterName).getApiHosts();
      if (hosts != null && !hosts.isEmpty()) {
        for (        ApiHost host : hosts) {
          assert(host.getApiHostInfo() != null);
          String hostName=host.getApiHostInfo().getHostName();
          apiManager.deleteHost(clusterName,hostName);
        }
      }
    }
    apiManager.deleteCluster(clusterName);
    if (isBlueprintCreated(clusterDef) && isBlueprintCreatedByBDE(clusterDef)) {
      apiManager.deleteBlueprint(clusterName);
    }
    ApiPersist persist=new ApiPersist(""String_Node_Str"");
    apiManager.updatePersist(persist);
    return true;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw SoftwareManagementPluginException.DELETE_CLUSTER_FAILED(e,AMBARI,clusterBlueprint.getName());
  }
}"
48551,"private void queryNodesStatus(CmClusterDef cluster){
  for (  CmNodeDef node : cluster.getNodes()) {
    Map<String,NodeReport> nodeReports=cluster.getCurrentReport().getNodeReports();
    NodeReport nodeReport=nodeReports.get(node.getName());
    try {
      ApiHost host=apiResourceRootV6.getHostsResource().readHost(node.getNodeId());
      ApiHealthSummary health=host.getHealthSummary();
switch (health) {
case GOOD:
        nodeReport.setStatus(ServiceStatus.STARTED);
      logger.debug(""String_Node_Str"" + nodeReport.getName() + ""String_Node_Str"");
    break;
case CONCERNING:
  nodeReport.setStatus(ServiceStatus.UNHEALTHY);
logger.debug(""String_Node_Str"" + nodeReport.getName() + ""String_Node_Str"");
break;
case BAD:
logger.debug(""String_Node_Str"" + nodeReport.getName() + ""String_Node_Str"");
nodeReport.setStatus(ServiceStatus.FAILED);
break;
default :
logger.debug(""String_Node_Str"" + nodeReport.getName() + ""String_Node_Str"");
nodeReport.setStatus(ServiceStatus.UNKONWN);
break;
}
}
 catch (NotFoundException e) {
logger.debug(""String_Node_Str"" + node.getName() + ""String_Node_Str"");
nodeReport.setStatus(ServiceStatus.FAILED);
}
}
}","private void queryNodesStatus(CmClusterDef cluster){
  for (  CmNodeDef node : cluster.getNodes()) {
    Map<String,NodeReport> nodeReports=cluster.getCurrentReport().getNodeReports();
    NodeReport nodeReport=nodeReports.get(node.getName());
    try {
      ApiHost host=apiResourceRootV6.getHostsResource().readHost(node.getNodeId());
      ApiHealthSummary health=host.getHealthSummary();
switch (health) {
case GOOD:
        nodeReport.setStatus(ServiceStatus.STARTED);
      logger.debug(""String_Node_Str"" + nodeReport.getName() + ""String_Node_Str"");
    break;
case CONCERNING:
  nodeReport.setStatus(ServiceStatus.UNHEALTHY);
logger.debug(""String_Node_Str"" + nodeReport.getName() + ""String_Node_Str"");
break;
case BAD:
logger.debug(""String_Node_Str"" + nodeReport.getName() + ""String_Node_Str"");
nodeReport.setStatus(ServiceStatus.ALERT);
break;
default :
logger.debug(""String_Node_Str"" + nodeReport.getName() + ""String_Node_Str"");
nodeReport.setStatus(ServiceStatus.UNKONWN);
break;
}
}
 catch (NotFoundException e) {
logger.debug(""String_Node_Str"" + node.getName() + ""String_Node_Str"");
nodeReport.setStatus(ServiceStatus.FAILED);
}
}
}"
48552,"private Map<String,List<ApiRole>> configureNodeServices(final CmClusterDef cluster,final ClusterReportQueue reportQueue,List<String> addedNodeNames) throws SoftwareManagementPluginException {
  Map<String,String> nodeRefToName=cluster.hostIdToName();
  Map<String,List<CmRoleDef>> serviceRolesMap=new HashMap<String,List<CmRoleDef>>();
  Set<String> addedNodeNameSet=new HashSet<String>();
  addedNodeNameSet.addAll(addedNodeNames);
  for (  CmServiceDef serviceDef : cluster.getServices()) {
    List<CmRoleDef> roles=serviceDef.getRoles();
    for (    CmRoleDef role : roles) {
      String nodeId=role.getNodeRef();
      String nodeName=nodeRefToName.get(nodeId);
      if (addedNodeNameSet.contains(nodeName)) {
        List<CmRoleDef> roleDefs=serviceRolesMap.get(serviceDef.getName());
        if (roleDefs == null) {
          roleDefs=new ArrayList<CmRoleDef>();
          serviceRolesMap.put(serviceDef.getName(),roleDefs);
        }
        roleDefs.add(role);
      }
    }
  }
  Map<String,List<ApiRole>> result=new HashMap<>();
  try {
    ApiServiceList apiServiceList=apiResourceRootV6.getClustersResource().getServicesResource(cluster.getName()).readServices(DataView.SUMMARY);
    for (    ApiService apiService : apiServiceList.getServices()) {
      if (!serviceRolesMap.containsKey(apiService.getName())) {
        continue;
      }
      result.put(apiService.getName(),new ArrayList<ApiRole>());
      List<CmRoleDef> roleDefs=serviceRolesMap.get(apiService.getName());
      List<ApiRole> apiRoles=apiResourceRootV6.getClustersResource().getServicesResource(cluster.getName()).getRolesResource(apiService.getName()).readRoles().getRoles();
      logger.debug(""String_Node_Str"" + apiRoles);
      for (      ApiRole apiRole : apiRoles) {
        for (Iterator<CmRoleDef> ite=roleDefs.iterator(); ite.hasNext(); ) {
          CmRoleDef roleDef=ite.next();
          if (apiRole.getHostRef().getHostId().equals(roleDef.getNodeRef())) {
            ite.remove();
            result.get(apiService.getName()).add(apiRole);
            break;
          }
        }
      }
      if (!roleDefs.isEmpty()) {
        List<ApiRole> newRoles=new ArrayList<>();
        for (        CmRoleDef roleDef : roleDefs) {
          ApiRole apiRole=createApiRole(roleDef);
          newRoles.add(apiRole);
        }
        String action=""String_Node_Str"" + apiService.getDisplayName();
        cluster.getCurrentReport().setNodesAction(action,addedNodeNames);
        reportQueue.addClusterReport(cluster.getCurrentReport().clone());
        logger.debug(""String_Node_Str"" + newRoles);
        ApiRoleList roleList=apiResourceRootV6.getClustersResource().getServicesResource(cluster.getName()).getRolesResource(apiService.getName()).createRoles(new ApiRoleList(newRoles));
        result.get(apiService.getName()).addAll(roleList.getRoles());
      }
    }
    logger.info(""String_Node_Str"");
    syncRolesId(cluster);
    preDeployConfig(cluster);
    executeAndReport(""String_Node_Str"",addedNodeNames,apiResourceRootV6.getClustersResource().deployClientConfig(cluster.getName()),ProgressSplit.CONFIGURE_SERVICES.getProgress(),cluster.getCurrentReport(),reportQueue,true);
    return result;
  }
 catch (  Exception e) {
    String errMsg=""String_Node_Str"" + ((e.getMessage() == null) ? ""String_Node_Str"" : (""String_Node_Str"" + e.getMessage()));
    logger.error(errMsg);
    throw SoftwareManagementPluginException.CONFIGURE_SERVICE_FAILED(e);
  }
}","private Map<String,List<ApiRole>> configureNodeServices(final CmClusterDef cluster,final ClusterReportQueue reportQueue,final List<String> addedNodeNames) throws SoftwareManagementPluginException {
  Map<String,String> nodeRefToName=cluster.hostIdToName();
  Map<String,List<CmRoleDef>> serviceRolesMap=new HashMap<String,List<CmRoleDef>>();
  Set<String> addedNodeNameSet=new HashSet<String>();
  addedNodeNameSet.addAll(addedNodeNames);
  for (  CmServiceDef serviceDef : cluster.getServices()) {
    List<CmRoleDef> roles=serviceDef.getRoles();
    for (    CmRoleDef role : roles) {
      String nodeId=role.getNodeRef();
      String nodeName=nodeRefToName.get(nodeId);
      if (addedNodeNameSet.contains(nodeName)) {
        List<CmRoleDef> roleDefs=serviceRolesMap.get(serviceDef.getName());
        if (roleDefs == null) {
          roleDefs=new ArrayList<CmRoleDef>();
          serviceRolesMap.put(serviceDef.getName(),roleDefs);
        }
        roleDefs.add(role);
      }
    }
  }
  Map<String,List<ApiRole>> result=new HashMap<>();
  try {
    ApiServiceList apiServiceList=apiResourceRootV6.getClustersResource().getServicesResource(cluster.getName()).readServices(DataView.SUMMARY);
    for (    ApiService apiService : apiServiceList.getServices()) {
      if (!serviceRolesMap.containsKey(apiService.getName())) {
        continue;
      }
      result.put(apiService.getName(),new ArrayList<ApiRole>());
      List<CmRoleDef> roleDefs=serviceRolesMap.get(apiService.getName());
      List<ApiRole> apiRoles=apiResourceRootV6.getClustersResource().getServicesResource(cluster.getName()).getRolesResource(apiService.getName()).readRoles().getRoles();
      logger.debug(""String_Node_Str"" + apiRoles);
      for (      ApiRole apiRole : apiRoles) {
        for (Iterator<CmRoleDef> ite=roleDefs.iterator(); ite.hasNext(); ) {
          CmRoleDef roleDef=ite.next();
          if (apiRole.getHostRef().getHostId().equals(roleDef.getNodeRef())) {
            ite.remove();
            result.get(apiService.getName()).add(apiRole);
            break;
          }
        }
      }
      if (!roleDefs.isEmpty()) {
        List<ApiRole> newRoles=new ArrayList<>();
        for (        CmRoleDef roleDef : roleDefs) {
          ApiRole apiRole=createApiRole(roleDef);
          newRoles.add(apiRole);
        }
        String action=""String_Node_Str"" + apiService.getDisplayName();
        cluster.getCurrentReport().setNodesAction(action,addedNodeNames);
        reportQueue.addClusterReport(cluster.getCurrentReport().clone());
        logger.debug(""String_Node_Str"" + newRoles);
        ApiRoleList roleList=apiResourceRootV6.getClustersResource().getServicesResource(cluster.getName()).getRolesResource(apiService.getName()).createRoles(new ApiRoleList(newRoles));
        result.get(apiService.getName()).addAll(roleList.getRoles());
      }
    }
    logger.info(""String_Node_Str"");
    syncRolesId(cluster);
    preDeployConfig(cluster);
    for (    String serviceName : result.keySet()) {
      final ApiRoleNameList roleNameList=new ApiRoleNameList();
      final String sName=serviceName;
      List<String> roleNames=new ArrayList<>();
      for (      ApiRole apiRole : result.get(serviceName)) {
        roleNames.add(apiRole.getName());
      }
      roleNameList.setRoleNames(roleNames);
      retry(5,new Retriable(){
        @Override public void doWork() throws Exception {
          executeAndReport(""String_Node_Str"",addedNodeNames,apiResourceRootV6.getClustersResource().getServicesResource(cluster.getName()).deployClientConfigCommand(sName,roleNameList),ProgressSplit.CONFIGURE_SERVICES.getProgress(),cluster.getCurrentReport(),reportQueue,true);
        }
      }
);
    }
    return result;
  }
 catch (  Exception e) {
    String errMsg=""String_Node_Str"" + ((e.getMessage() == null) ? ""String_Node_Str"" : (""String_Node_Str"" + e.getMessage()));
    logger.error(errMsg);
    throw SoftwareManagementPluginException.CONFIGURE_SERVICE_FAILED(e);
  }
}"
48553,"@Override @Transactional public synchronized void addAppManager(AppManagerAdd appManagerAdd){
  logger.info((new Gson()).toJson(appManagerAdd));
  AppManagerEntity appManagerEntity=new AppManagerEntity(appManagerAdd);
  appManagerDAO.insert(appManagerEntity);
}","@Override @Transactional public synchronized void addAppManager(AppManagerAdd appManagerAdd){
  logger.debug(""String_Node_Str"" + appManagerAdd);
  AppManagerEntity appManagerEntity=new AppManagerEntity(appManagerAdd);
  appManagerDAO.insert(appManagerEntity);
  logger.debug(""String_Node_Str"" + appManagerAdd);
}"
48554,"@Override public void modifyAppManager(AppManagerAdd appManagerAdd){
  logger.debug(""String_Node_Str"" + appManagerAdd);
  String name=appManagerAdd.getName();
  AppManagerEntity entity=appManagerDAO.findByName(name);
  entity.setDescription(appManagerAdd.getDescription());
  entity.setType(appManagerAdd.getType());
  entity.setUrl(appManagerAdd.getUrl());
  entity.setUsername(appManagerAdd.getUsername());
  entity.setPassword(appManagerAdd.getPassword());
  entity.setSslCertificate(appManagerAdd.getSslCertificate());
  appManagerDAO.update(entity);
  logger.debug(""String_Node_Str"" + appManagerAdd);
}","@Override @Transactional public void modifyAppManager(AppManagerAdd appManagerAdd){
  logger.debug(""String_Node_Str"" + appManagerAdd);
  String name=appManagerAdd.getName();
  AppManagerEntity entity=appManagerDAO.findByName(name);
  entity.setDescription(appManagerAdd.getDescription());
  entity.setType(appManagerAdd.getType());
  entity.setUrl(appManagerAdd.getUrl());
  entity.setUsername(appManagerAdd.getUsername());
  entity.setPassword(appManagerAdd.getPassword());
  entity.setSslCertificate(appManagerAdd.getSslCertificate());
  appManagerDAO.update(entity);
  logger.debug(""String_Node_Str"" + appManagerAdd);
}"
48555,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void modifyAppManager(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String url,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean changeAccount,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean changeCertificate){
  if (url == null && !changeAccount && !changeCertificate) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
    return;
  }
  try {
    AppManagerRead appManagerRead=restClient.get(name);
    AppManagerAdd appManagerAdd=new AppManagerAdd();
    appManagerAdd.setName(name);
    appManagerAdd.setDescription(appManagerRead.getDescription());
    appManagerAdd.setType(appManagerRead.getType());
    if (url == null) {
      appManagerAdd.setUrl(appManagerRead.getUrl());
    }
 else {
      appManagerAdd.setUrl(url);
    }
    if (changeAccount) {
      Map<String,String> loginInfo=getAccount();
      if (null == loginInfo) {
        return;
      }
      appManagerAdd.setUsername(loginInfo.get(Constants.LOGIN_USERNAME));
      appManagerAdd.setPassword(loginInfo.get(Constants.LOGIN_PASSWORD));
    }
 else {
      appManagerAdd.setUsername(appManagerRead.getUsername());
      appManagerAdd.setPassword(appManagerRead.getPassword());
    }
    if ((url != null && url.toLowerCase().startsWith(""String_Node_Str"")) || (url == null && changeCertificate && appManagerAdd.getSslCertificate().toLowerCase().startsWith(""String_Node_Str""))) {
      String sslCertificate=getSslCertificate();
      if (null == sslCertificate) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
        return;
      }
      appManagerAdd.setSslCertificate(sslCertificate);
    }
 else     if (url == null && changeCertificate && !appManagerAdd.getSslCertificate().toLowerCase().startsWith(""String_Node_Str"")) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
      return;
    }
 else     if (url != null && !url.toLowerCase().startsWith(""String_Node_Str"")) {
      appManagerAdd.setSslCertificate(null);
    }
 else {
      appManagerAdd.setSslCertificate(appManagerRead.getSslCertificate());
    }
    restClient.modify(appManagerAdd);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_RESULT_MODIFY);
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void modifyAppManager(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String url,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean changeAccount,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean changeCertificate){
  if (url == null && !changeAccount && !changeCertificate) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
    return;
  }
  try {
    AppManagerRead appManagerRead=restClient.get(name);
    AppManagerAdd appManagerAdd=new AppManagerAdd();
    appManagerAdd.setName(name);
    appManagerAdd.setDescription(appManagerRead.getDescription());
    appManagerAdd.setType(appManagerRead.getType());
    if (url == null) {
      appManagerAdd.setUrl(appManagerRead.getUrl());
    }
 else {
      appManagerAdd.setUrl(url);
    }
    if (changeAccount) {
      Map<String,String> loginInfo=getAccount();
      if (null == loginInfo) {
        return;
      }
      appManagerAdd.setUsername(loginInfo.get(Constants.LOGIN_USERNAME));
      appManagerAdd.setPassword(loginInfo.get(Constants.LOGIN_PASSWORD));
    }
 else {
      appManagerAdd.setUsername(appManagerRead.getUsername());
      appManagerAdd.setPassword(appManagerRead.getPassword());
    }
    if ((url != null && url.toLowerCase().startsWith(""String_Node_Str"")) || (url == null && changeCertificate && appManagerAdd.getUrl().toLowerCase().startsWith(""String_Node_Str""))) {
      String sslCertificate=getSslCertificate();
      if (null == sslCertificate) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
        return;
      }
      appManagerAdd.setSslCertificate(sslCertificate);
    }
 else     if (url == null && changeCertificate && !appManagerAdd.getUrl().toLowerCase().startsWith(""String_Node_Str"")) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
      return;
    }
 else     if (url != null && !url.toLowerCase().startsWith(""String_Node_Str"")) {
      appManagerAdd.setSslCertificate(null);
    }
 else {
      appManagerAdd.setSslCertificate(appManagerRead.getSslCertificate());
    }
    restClient.modify(appManagerAdd);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_RESULT_MODIFY);
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}"
48556,"public List<String> getDataVolumnsMountPoint(){
  List<String> mountPoints=new ArrayList<String>();
  for (  DiskEntity disk : disks) {
    if (DiskType.DATA_DISK.getType().equals(disk.getDiskType())) {
      mountPoints.add(""String_Node_Str"" + disk.getHardwareUUID().toLowerCase().replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
    }
  }
  return mountPoints;
}","public List<String> getDataVolumnsMountPoint(){
  List<String> mountPoints=new ArrayList<String>();
  for (  DiskEntity disk : disks) {
    if (DiskType.DATA_DISK.getType().equals(disk.getDiskType())) {
      if (disk.getHardwareUUID() == null) {
        continue;
      }
      mountPoints.add(""String_Node_Str"" + disk.getHardwareUUID().toLowerCase().replace(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
    }
  }
  return mountPoints;
}"
48557,"@Test public void testSubtractBasic(){
  NetworkEntity network=new NetworkEntity(""String_Node_Str"",""String_Node_Str"",AllocType.IP_POOL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null);
  ;
  List<IpBlockEntity> setA=new ArrayList<IpBlockEntity>();
  setA.add(new IpBlockEntity(network,1L,BlockType.ASSIGNED,1L,10L));
  List<IpBlockEntity> setB1=new ArrayList<IpBlockEntity>();
  setB1.add(new IpBlockEntity(network,1L,BlockType.ASSIGNED,1L,3L));
  List<IpBlockEntity> setB2=new ArrayList<IpBlockEntity>();
  setB2.add(new IpBlockEntity(network,1L,BlockType.ASSIGNED,4L,6L));
  List<IpBlockEntity> setB3=new ArrayList<IpBlockEntity>();
  setB3.add(new IpBlockEntity(network,1L,BlockType.ASSIGNED,5L,10L));
  List<IpBlockEntity> setDiff=setA;
  setDiff=IpBlockEntity.subtract(setDiff,setB1);
  setDiff=IpBlockEntity.subtract(setDiff,setB2);
  setDiff=IpBlockEntity.subtract(setDiff,setB3);
  assertTrue(setDiff.isEmpty());
}","@Test public void testSubtractBasic(){
  NetworkEntity network=new NetworkEntity(""String_Node_Str"",""String_Node_Str"",AllocType.IP_POOL,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null);
  ;
  List<IpBlockEntity> setA=new ArrayList<IpBlockEntity>();
  setA.add(new IpBlockEntity(network,1L,BlockType.ASSIGNED,1L,10L));
  List<IpBlockEntity> setB1=new ArrayList<IpBlockEntity>();
  setB1.add(new IpBlockEntity(network,1L,BlockType.ASSIGNED,1L,3L));
  List<IpBlockEntity> setB2=new ArrayList<IpBlockEntity>();
  setB2.add(new IpBlockEntity(network,1L,BlockType.ASSIGNED,4L,6L));
  List<IpBlockEntity> setB3=new ArrayList<IpBlockEntity>();
  setB3.add(new IpBlockEntity(network,1L,BlockType.ASSIGNED,5L,10L));
  List<IpBlockEntity> setDiff=setA;
  setDiff=IpBlockEntity.subtract(setDiff,setB1);
  setDiff=IpBlockEntity.subtract(setDiff,setB2);
  setDiff=IpBlockEntity.subtract(setDiff,setB3);
  assertTrue(setDiff.isEmpty());
  List<IpBlockEntity> setC=new ArrayList<IpBlockEntity>();
  setC.add(new IpBlockEntity(network,1L,BlockType.ASSIGNED,3337306476L,3337306480L));
  List<IpBlockEntity> setD=new ArrayList<IpBlockEntity>();
  setD.add(new IpBlockEntity(network,1L,BlockType.ASSIGNED,3337306476L,3337306480L));
  setD.add(new IpBlockEntity(network,1L,BlockType.ASSIGNED,3337306476L,3337306476L));
  setDiff=setC;
  setD=ipBlockDao.merge(setD,true,true,true);
  setDiff=IpBlockEntity.subtract(setDiff,setD);
  assertTrue(setDiff.isEmpty());
  setDiff=setC;
  setD=ipBlockDao.merge(setD,true,true,true);
  setDiff=IpBlockEntity.subtract(setD,setDiff);
  assertTrue(setDiff.isEmpty());
}"
48558,"public Long startCluster(String clusterName) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ValidationUtils.validateVersion(clusterEntityMgr,clusterName);
  if (cluster.getStatus().isActiveServiceStatus() || cluster.getStatus() == ClusterStatus.SERVICE_ERROR) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw ClusterManagerException.ALREADY_STARTED_ERROR(clusterName);
  }
  if (!ClusterStatus.STOPPED.equals(cluster.getStatus()) && !ClusterStatus.ERROR.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.START_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  cluster.setVhmTargetNum(-1);
  clusterEntityMgr.update(cluster);
  clusterEntityMgr.cleanupActionError(clusterName);
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.ERROR.name()));
  JobParameters jobParameters=new JobParameters(param);
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.STARTING);
  try {
    return jobManager.runJob(JobConstants.START_CLUSTER_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.ERROR);
    throw e;
  }
}","public Long startCluster(String clusterName) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ValidationUtils.validateVersion(clusterEntityMgr,clusterName);
  if (cluster.getStatus().isActiveServiceStatus()) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw ClusterManagerException.ALREADY_STARTED_ERROR(clusterName);
  }
  if (!ClusterStatus.STOPPED.equals(cluster.getStatus()) && !ClusterStatus.ERROR.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.START_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  cluster.setVhmTargetNum(-1);
  clusterEntityMgr.update(cluster);
  clusterEntityMgr.cleanupActionError(clusterName);
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.ERROR.name()));
  JobParameters jobParameters=new JobParameters(param);
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.STARTING);
  try {
    return jobManager.runJob(JobConstants.START_CLUSTER_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.ERROR);
    throw e;
  }
}"
48559,"private boolean supportedWithHdfs2(ClusterBlueprint blueprint){
  String vendor=blueprint.getHadoopStack().getVendor();
  if (vendor != null && (vendor.equalsIgnoreCase(Constants.DEFAULT_VENDOR) || vendor.equalsIgnoreCase(Constants.MAPR_VENDOR) || vendor.equalsIgnoreCase(Constants.GPHD_VENDOR))) {
    return false;
  }
  return true;
}","private boolean supportedWithHdfs2(ClusterBlueprint blueprint){
  String vendor=blueprint.getHadoopStack().getVendor();
  if (vendor != null && (vendor.equalsIgnoreCase(Constants.APACHE_VENDOR) || vendor.equalsIgnoreCase(Constants.MAPR_VENDOR) || vendor.equalsIgnoreCase(Constants.GPHD_VENDOR))) {
    return false;
  }
  return true;
}"
48560,"@Override public ApiRequest deleteService(String clusterName,String serviceName){
  logger.info(""String_Node_Str"" + serviceName + ""String_Node_Str""+ clusterName);
  Response response=apiResourceRootV1.getClustersResource().getServicesResource(clusterName).deleteService(serviceName);
  String deleteServiceJson=handleAmbariResponse(response);
  return ApiUtils.jsonToObject(ApiRequest.class,deleteServiceJson);
}","@Override public boolean deleteService(String clusterName,String serviceName){
  logger.info(""String_Node_Str"" + serviceName + ""String_Node_Str""+ clusterName);
  Response response=apiResourceRootV1.getClustersResource().getServicesResource(clusterName).deleteService(serviceName);
  handleAmbariResponse(response);
  return true;
}"
48561,"@Override public ApiRequest deleteCluster(String clusterName) throws AmbariApiException {
  Response response=apiResourceRootV1.getClustersResource().deleteCluster(clusterName);
  String deleteClusterJson=handleAmbariResponse(response);
  logger.debug(""String_Node_Str"" + deleteClusterJson);
  return ApiUtils.jsonToObject(ApiRequest.class,deleteClusterJson);
}","@Override public boolean deleteCluster(String clusterName) throws AmbariApiException {
  logger.info(""String_Node_Str"" + clusterName);
  Response response=apiResourceRootV1.getClustersResource().deleteCluster(clusterName);
  handleAmbariResponse(response);
  return HttpStatus.isSuccess(response.getStatus());
}"
48562,"@Override public ApiRequest deleteHost(String clusterName,String fqdn){
  logger.info(""String_Node_Str"" + fqdn + ""String_Node_Str""+ clusterName);
  Response response=apiResourceRootV1.getClustersResource().getHostsResource(clusterName).deleteHost(fqdn);
  String deleteHostJson=handleAmbariResponse(response);
  return ApiUtils.jsonToObject(ApiRequest.class,deleteHostJson);
}","@Override public ApiRequest deleteHost(String clusterName,String fqdn) throws AmbariApiException {
  logger.info(""String_Node_Str"" + fqdn + ""String_Node_Str""+ clusterName);
  Response response=apiResourceRootV1.getClustersResource().getHostsResource(clusterName).deleteHost(fqdn);
  String deleteHostJson=handleAmbariResponse(response);
  return ApiUtils.jsonToObject(ApiRequest.class,deleteHostJson);
}"
48563,"public ApiRequest deleteBlueprint(String blueprintName) throws AmbariApiException {
  logger.info(""String_Node_Str"" + blueprintName);
  Response response=apiResourceRootV1.getBlueprintsResource().deleteBlueprint(blueprintName);
  String deleteBlueprintJson=handleAmbariResponse(response);
  return ApiUtils.jsonToObject(ApiRequest.class,deleteBlueprintJson);
}","public boolean deleteBlueprint(String blueprintName) throws AmbariApiException {
  logger.info(""String_Node_Str"" + blueprintName);
  Response response=apiResourceRootV1.getBlueprintsResource().deleteBlueprint(blueprintName);
  handleAmbariResponse(response);
  return true;
}"
48564,"public ApiRequest deleteService(String clusterName,String serviceName);","public boolean deleteService(String clusterName,String serviceName);"
48565,public ApiRequest deleteCluster(String clusterName) throws AmbariApiException ;,public boolean deleteCluster(String clusterName) throws AmbariApiException ;
48566,public ApiRequest deleteBlueprint(String blueprintName) throws AmbariApiException ;,public boolean deleteBlueprint(String blueprintName) throws AmbariApiException ;
48567,"@Override public boolean onStopCluster(ClusterBlueprint clusterBlueprint,ClusterReportQueue reports) throws SoftwareManagementPluginException {
  String clusterName=clusterBlueprint.getName();
  AmClusterDef clusterDef=new AmClusterDef(clusterBlueprint,null);
  ClusterReport clusterReport=clusterDef.getCurrentReport();
  try {
    clusterReport.setAction(""String_Node_Str"");
    clusterReport.setProgress(ProgressSplit.OPERATION_BEGIN.getProgress());
    ApiRequest apiRequestSummary=apiManager.stopAllServicesInCluster(clusterName);
    if (apiRequestSummary == null || apiRequestSummary.getApiRequestInfo() == null) {
      return false;
    }
    boolean success=doSoftwareOperation(clusterName,apiRequestSummary,clusterReport,reports);
    if (!success) {
      logger.error(""String_Node_Str"");
      throw SoftwareManagementPluginException.STOP_CLUSTER_FAILED(clusterName,null);
    }
    return true;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw SoftwareManagementPluginException.STOP_CLUSTER_FAILED(clusterName,e);
  }
}","@Override public boolean onStopCluster(ClusterBlueprint clusterBlueprint,ClusterReportQueue reports) throws SoftwareManagementPluginException {
  String clusterName=clusterBlueprint.getName();
  AmClusterDef clusterDef=new AmClusterDef(clusterBlueprint,null);
  ClusterReport clusterReport=clusterDef.getCurrentReport();
  try {
    if (!isProvisioned(clusterName)) {
      return true;
    }
    clusterReport.setAction(""String_Node_Str"");
    clusterReport.setProgress(ProgressSplit.OPERATION_BEGIN.getProgress());
    ApiRequest apiRequestSummary=apiManager.stopAllServicesInCluster(clusterName);
    boolean success=doSoftwareOperation(clusterName,apiRequestSummary,clusterReport,reports);
    if (!success) {
      logger.error(""String_Node_Str"");
      throw SoftwareManagementPluginException.STOP_CLUSTER_FAILED(clusterName,null);
    }
    return true;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw SoftwareManagementPluginException.STOP_CLUSTER_FAILED(clusterName,e);
  }
}"
48568,"@Override public boolean startCluster(ClusterBlueprint clusterBlueprint,ClusterReportQueue reports) throws SoftwareManagementPluginException {
  AmClusterDef clusterDef=new AmClusterDef(clusterBlueprint,null);
  String clusterName=clusterDef.getName();
  try {
    ClusterReport clusterReport=clusterDef.getCurrentReport();
    clusterReport.setAction(""String_Node_Str"");
    clusterReport.setProgress(ProgressSplit.OPERATION_BEGIN.getProgress());
    boolean success=false;
    for (int i=0; i < REQUEST_MAX_RETRY_TIMES; i++) {
      try {
        ApiRequest apiRequestSummary=apiManager.startAllServicesInCluster(clusterName);
        success=doSoftwareOperation(clusterBlueprint.getName(),apiRequestSummary,clusterReport,reports);
        if (!success) {
          logger.warn(""String_Node_Str"");
          try {
            Thread.sleep(5000);
          }
 catch (          Exception e) {
            logger.info(""String_Node_Str"");
          }
        }
 else {
          break;
        }
      }
 catch (      Exception e) {
        logger.warn(""String_Node_Str"",e);
      }
    }
    if (!success) {
      logger.error(""String_Node_Str"");
      throw SoftwareManagementPluginException.START_CLUSTER_FAILED(clusterName,null);
    }
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw SoftwareManagementPluginException.START_CLUSTER_FAILED(clusterName,e);
  }
  return true;
}","@Override public boolean startCluster(ClusterBlueprint clusterBlueprint,ClusterReportQueue reports) throws SoftwareManagementPluginException {
  AmClusterDef clusterDef=new AmClusterDef(clusterBlueprint,null);
  String clusterName=clusterDef.getName();
  if (!isProvisioned(clusterName)) {
    throw SoftwareManagementPluginException.START_CLUSTER_FAILED(""String_Node_Str"",null);
  }
  try {
    ClusterReport clusterReport=clusterDef.getCurrentReport();
    clusterReport.setAction(""String_Node_Str"");
    clusterReport.setProgress(ProgressSplit.OPERATION_BEGIN.getProgress());
    boolean success=false;
    for (int i=0; i < REQUEST_MAX_RETRY_TIMES; i++) {
      try {
        ApiRequest apiRequestSummary=apiManager.startAllServicesInCluster(clusterName);
        success=doSoftwareOperation(clusterBlueprint.getName(),apiRequestSummary,clusterReport,reports);
        if (!success) {
          logger.warn(""String_Node_Str"");
          try {
            Thread.sleep(5000);
          }
 catch (          Exception e) {
            logger.info(""String_Node_Str"");
          }
        }
 else {
          break;
        }
      }
 catch (      Exception e) {
        logger.warn(""String_Node_Str"",e);
      }
    }
    if (!success) {
      logger.error(""String_Node_Str"");
      throw SoftwareManagementPluginException.START_CLUSTER_FAILED(clusterName,null);
    }
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw SoftwareManagementPluginException.START_CLUSTER_FAILED(clusterName,e);
  }
  return true;
}"
48569,"@Override public boolean onDeleteCluster(ClusterBlueprint clusterBlueprint,ClusterReportQueue reports) throws SoftwareManagementPluginException {
  try {
    String clusterName=clusterBlueprint.getName();
    if (!onStopCluster(clusterBlueprint,reports)) {
      logger.error(""String_Node_Str"");
    }
    List<String> serviceNames=apiManager.getClusterServicesNames(clusterName);
    if (serviceNames != null && !serviceNames.isEmpty()) {
      for (      String serviceName : serviceNames) {
        ApiRequest deleteService=apiManager.deleteService(clusterName,serviceName);
      }
    }
    List<ApiHost> hosts=apiManager.getHostsSummaryInfo(clusterName).getApiHosts();
    if (hosts != null && !hosts.isEmpty()) {
      for (      ApiHost host : hosts) {
        String hostName=host.getApiHostInfo().getHostName();
        ApiRequest deleteHost=apiManager.deleteHost(clusterName,hostName);
      }
    }
    ApiRequest deleteCluster=apiManager.deleteCluster(clusterBlueprint.getName());
    ApiRequest deleteBlueprint=apiManager.deleteBlueprint(clusterBlueprint.getName());
    return true;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw SoftwareManagementPluginException.DELETE_CLUSTER_FAILED(clusterBlueprint.getName(),e);
  }
}","@Override public boolean onDeleteCluster(ClusterBlueprint clusterBlueprint,ClusterReportQueue reports) throws SoftwareManagementPluginException {
  try {
    String clusterName=clusterBlueprint.getName();
    AmClusterDef clusterDef=new AmClusterDef(clusterBlueprint,null);
    if (isProvisioned(clusterName) && isClusterProvisionedByBDE(clusterDef)) {
      if (!onStopCluster(clusterBlueprint,reports)) {
        logger.error(""String_Node_Str"");
      }
      List<String> serviceNames=apiManager.getClusterServicesNames(clusterName);
      if (serviceNames != null && !serviceNames.isEmpty()) {
        for (        String serviceName : serviceNames) {
          apiManager.deleteService(clusterName,serviceName);
        }
      }
      if (apiManager.getHostsSummaryInfo(clusterName) != null) {
        List<ApiHost> hosts=apiManager.getHostsSummaryInfo(clusterName).getApiHosts();
        if (hosts != null && !hosts.isEmpty()) {
          for (          ApiHost host : hosts) {
            assert(host.getApiHostInfo() != null);
            String hostName=host.getApiHostInfo().getHostName();
            apiManager.deleteHost(clusterName,hostName);
          }
        }
      }
      apiManager.deleteCluster(clusterName);
    }
    if (isBlueprintCreated(clusterDef) && isBlueprintCreatedByBDE(clusterDef)) {
      apiManager.deleteBlueprint(clusterName);
    }
    ApiPersist persist=new ApiPersist(""String_Node_Str"");
    apiManager.updatePersist(persist);
    return true;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw SoftwareManagementPluginException.DELETE_CLUSTER_FAILED(clusterBlueprint.getName(),e);
  }
}"
48570,"public String getPassword(){
  if (this.password == ""String_Node_Str"") {
    return ""String_Node_Str"";
  }
  String password=null;
  try {
    password=EncryptionGuard.decode(this.password);
  }
 catch (  UnsupportedEncodingException e) {
    logger.warn(""String_Node_Str"",e);
  }
catch (  GeneralSecurityException e) {
    logger.warn(""String_Node_Str"",e);
  }
  return password;
}","public String getPassword(){
  if (this.password == null || this.password.isEmpty()) {
    return ""String_Node_Str"";
  }
  String password=null;
  try {
    password=EncryptionGuard.decode(this.password);
  }
 catch (  UnsupportedEncodingException e) {
    logger.warn(""String_Node_Str"",e);
  }
catch (  GeneralSecurityException e) {
    logger.warn(""String_Node_Str"",e);
  }
  return password;
}"
48571,"public void modifySoftwareManager(AppManagerAdd appManagerAdd){
  logger.debug(""String_Node_Str"" + appManagerAdd);
  String name=appManagerAdd.getName();
  if (Constants.IRONFAN.equals(name)) {
    logger.error(""String_Node_Str"");
    throw SoftwareManagerCollectorException.CAN_NOT_MODIFY_DEFAULT();
  }
  AppManagerEntity appManager=appManagerService.findAppManagerByName(name);
  if (null == appManager) {
    logger.error(""String_Node_Str"" + name);
    throw SoftwareManagerCollectorException.APPMANAGER_NOT_FOUND(name);
  }
  String sslCertificate=appManagerAdd.getSslCertificate();
  if (!CommonUtil.isBlank(sslCertificate)) {
    saveSslCertificate(sslCertificate);
  }
  logger.info(""String_Node_Str"" + appManagerAdd);
  SoftwareManager softwareManager=loadSoftwareManager(appManagerAdd);
  logger.info(""String_Node_Str"");
  validateSoftwareManager(name,softwareManager);
  logger.info(""String_Node_Str"");
  appManagerService.modifyAppManager(appManagerAdd);
  logger.info(""String_Node_Str"");
  cache.remove(name);
  logger.info(""String_Node_Str"");
  cache.put(name,softwareManager);
  logger.debug(""String_Node_Str"" + appManagerAdd);
}","public synchronized void modifySoftwareManager(AppManagerAdd appManagerAdd){
  logger.debug(""String_Node_Str"" + appManagerAdd);
  String name=appManagerAdd.getName();
  if (Constants.IRONFAN.equals(name)) {
    logger.error(""String_Node_Str"");
    throw SoftwareManagerCollectorException.CAN_NOT_MODIFY_DEFAULT();
  }
  AppManagerEntity appManager=appManagerService.findAppManagerByName(name);
  if (null == appManager) {
    logger.error(""String_Node_Str"" + name);
    throw SoftwareManagerCollectorException.APPMANAGER_NOT_FOUND(name);
  }
  String sslCertificate=appManagerAdd.getSslCertificate();
  if (!CommonUtil.isBlank(sslCertificate)) {
    saveSslCertificate(sslCertificate);
  }
  logger.info(""String_Node_Str"" + appManagerAdd);
  SoftwareManager softwareManager=loadSoftwareManager(appManagerAdd);
  logger.info(""String_Node_Str"");
  validateSoftwareManager(name,softwareManager);
  logger.info(""String_Node_Str"");
  appManagerService.modifyAppManager(appManagerAdd);
  logger.info(""String_Node_Str"");
  cache.remove(name);
  logger.info(""String_Node_Str"");
  cache.put(name,softwareManager);
  logger.debug(""String_Node_Str"" + appManagerAdd);
}"
48572,"/** 
 * Get software manager instance
 * @param name
 * @return null if the name does not exist
 */
public synchronized SoftwareManager getSoftwareManager(String name){
  if (CommonUtil.isBlank(name)) {
    return cache.get(Constants.IRONFAN);
  }
  if (cache.containsKey(name)) {
    return cache.get(name);
  }
  return null;
}","/** 
 * Get software manager instance
 * @param name
 * @return null if the name does not exist
 */
public SoftwareManager getSoftwareManager(String name){
  if (CommonUtil.isBlank(name)) {
    return cache.get(Constants.IRONFAN);
  }
  if (cache.containsKey(name)) {
    return cache.get(name);
  }
  return null;
}"
48573,"/** 
 * Software manager name will be unique inside of BDE. Otherwise, creation will fail. The appmanager information should be persisted in meta-db
 * @param appManagerAdd
 */
public synchronized void createSoftwareManager(AppManagerAdd appManagerAdd){
  logger.info(""String_Node_Str"" + appManagerAdd.getName());
  if (appManagerService.findAppManagerByName(appManagerAdd.getName()) != null) {
    logger.error(""String_Node_Str"" + appManagerAdd.getName() + ""String_Node_Str"");
    throw SoftwareManagerCollectorException.DUPLICATE_NAME(appManagerAdd.getName());
  }
  String sslCertificate=appManagerAdd.getSslCertificate();
  if (!CommonUtil.isBlank(sslCertificate)) {
    saveSslCertificate(sslCertificate);
  }
  SoftwareManager softwareManager=loadSoftwareManager(appManagerAdd);
  validateSoftwareManager(appManagerAdd.getName(),softwareManager);
  cache.put(appManagerAdd.getName(),softwareManager);
  logger.info(""String_Node_Str"");
  appManagerService.addAppManager(appManagerAdd);
}","/** 
 * Software manager name will be unique inside of BDE. Otherwise, creation will fail. The appmanager information should be persisted in meta-db
 * @param appManagerAdd
 */
public void createSoftwareManager(AppManagerAdd appManagerAdd){
  logger.info(""String_Node_Str"");
  String sslCertificate=appManagerAdd.getSslCertificate();
  if (!CommonUtil.isBlank(sslCertificate)) {
    saveSslCertificate(sslCertificate);
  }
  SoftwareManager softwareManager=loadSoftwareManager(appManagerAdd);
  validateSoftwareManager(appManagerAdd.getName(),softwareManager);
  logger.info(""String_Node_Str"");
  createSoftwareManagerInternal(appManagerAdd,softwareManager);
}"
48574,"public void deleteSoftwareManager(String appManagerName){
  logger.debug(""String_Node_Str"" + appManagerName);
  if (Constants.IRONFAN.equals(appManagerName)) {
    logger.error(""String_Node_Str"");
    throw SoftwareManagerCollectorException.CAN_NOT_DELETE_DEFAULT();
  }
  appManagerService.deleteAppManager(appManagerName);
  logger.debug(""String_Node_Str"" + appManagerName);
  cache.remove(appManagerName);
  logger.debug(""String_Node_Str"" + appManagerName + ""String_Node_Str"");
}","public synchronized void deleteSoftwareManager(String appManagerName){
  logger.debug(""String_Node_Str"" + appManagerName);
  if (Constants.IRONFAN.equals(appManagerName)) {
    logger.error(""String_Node_Str"");
    throw SoftwareManagerCollectorException.CAN_NOT_DELETE_DEFAULT();
  }
  appManagerService.deleteAppManager(appManagerName);
  logger.debug(""String_Node_Str"" + appManagerName);
  cache.remove(appManagerName);
  logger.debug(""String_Node_Str"" + appManagerName + ""String_Node_Str"");
}"
48575,"/** 
 * @param name
 * @param softwareManager
 */
private void validateSoftwareManager(String name,SoftwareManager softwareManager){
  logger.info(""String_Node_Str"");
  try {
    if (!softwareManager.echo()) {
      logger.error(""String_Node_Str"" + name + ""String_Node_Str"");
      throw SoftwareManagerCollectorException.ECHO_FAILURE(name);
    }
  }
 catch (  SoftwareManagementPluginException e) {
    logger.error(""String_Node_Str"" + name + ""String_Node_Str"",e);
    throw SoftwareManagerCollectorException.CONNECT_FAILURE(name,e.getMessage());
  }
}","/** 
 * @param name
 * @param softwareManager
 */
private void validateSoftwareManager(String name,final SoftwareManager softwareManager){
  logger.info(""String_Node_Str"");
  try {
    ExecutorService exec=Executors.newFixedThreadPool(1);
    Future<Boolean> futureResult=exec.submit(new Callable<Boolean>(){
      @Override public Boolean call() throws Exception {
        return softwareManager.echo();
      }
    }
);
    boolean gotEcho=false;
    Boolean result=(Boolean)waitForThreadResult(futureResult);
    if (null != result) {
      gotEcho=result;
    }
    exec.shutdown();
    if (!gotEcho) {
      logger.error(""String_Node_Str"" + name + ""String_Node_Str"");
      throw SoftwareManagerCollectorException.ECHO_FAILURE(name);
    }
  }
 catch (  SoftwareManagementPluginException e) {
    logger.error(""String_Node_Str"" + name + ""String_Node_Str"",e);
    throw SoftwareManagerCollectorException.CONNECT_FAILURE(name,e.getMessage());
  }
}"
48576,"private static <T>void validateConfigType(Map<String,Object> config,List<Map<String,Map<String,List<T>>>> list,List<String> warningMsgList){
  if (warningMsgList != null) {
    String configType=""String_Node_Str"";
    List<String> grayList=new ArrayList<String>();
    boolean found=false;
    for (    Entry<String,Object> configTypeEntry : config.entrySet()) {
      configType=configTypeEntry.getKey();
      found=false;
      for (      Map<String,Map<String,List<T>>> listTypeMap : list) {
        if (listTypeMap.containsKey(configType)) {
          found=true;
        }
      }
      if (!found) {
        grayList.add(configType);
      }
    }
    if (!found) {
      StringBuffer errorMsg=new StringBuffer();
      String be=""String_Node_Str"";
      errorMsg.append(Constants.CLUSTER_CONFIG_TYPE_NOT_RAGULARLY_BEFORE);
      for (      String grayConfigType : grayList) {
        errorMsg.append(grayConfigType);
        errorMsg.append(""String_Node_Str"");
      }
      if (grayList.size() > 1) {
        be=""String_Node_Str"";
      }
      errorMsg.replace(errorMsg.length() - 2,errorMsg.length(),be + Constants.CLUSTER_CONFIG_TYPE_NOT_RAGULARLY_AFTER);
      warningMsgList.add(errorMsg.toString());
    }
  }
}","private static <T>void validateConfigType(Map<String,Object> config,List<Map<String,Map<String,List<T>>>> list,List<String> warningMsgList){
  if ((config.size() > 0) && (warningMsgList != null)) {
    String configType=""String_Node_Str"";
    List<String> grayList=new ArrayList<String>();
    boolean found=false;
    for (    Entry<String,Object> configTypeEntry : config.entrySet()) {
      configType=configTypeEntry.getKey();
      found=false;
      for (      Map<String,Map<String,List<T>>> listTypeMap : list) {
        if (listTypeMap.containsKey(configType)) {
          found=true;
        }
      }
      if (!found) {
        grayList.add(configType);
      }
    }
    if (!found) {
      StringBuffer errorMsg=new StringBuffer();
      String be=""String_Node_Str"";
      errorMsg.append(Constants.CLUSTER_CONFIG_TYPE_NOT_RAGULARLY_BEFORE);
      for (      String grayConfigType : grayList) {
        errorMsg.append(grayConfigType);
        errorMsg.append(""String_Node_Str"");
      }
      if (grayList.size() > 1) {
        be=""String_Node_Str"";
      }
      errorMsg.replace(errorMsg.length() - 2,errorMsg.length(),be + Constants.CLUSTER_CONFIG_TYPE_NOT_RAGULARLY_AFTER);
      warningMsgList.add(errorMsg.toString());
    }
  }
}"
48577,"/** 
 * Validate role's existence
 * @param blueprint
 * @param distroRoles
 * @return
 * @throws SoftwareManagementPluginException
 */
private boolean validateRoles(ClusterBlueprint blueprint,List<String> distroRoles) throws ValidationException {
  assert(blueprint != null && distroRoles != null);
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  checkUnsupportedRoles(blueprint,distroRoles,failedMsgList);
  boolean result=validateRoleDependency(failedMsgList,blueprint);
  validateGroupConfig(blueprint,failedMsgList,warningMsgList);
  if (!failedMsgList.isEmpty() || !warningMsgList.isEmpty()) {
    throw ValidationException.VALIDATION_FAIL(""String_Node_Str"",failedMsgList,warningMsgList);
  }
  return result;
}","/** 
 * Validate role's existence
 * @param blueprint
 * @param distroRoles
 * @return
 * @throws SoftwareManagementPluginException
 */
private boolean validateRoles(ClusterBlueprint blueprint,List<String> distroRoles) throws ValidationException {
  assert(blueprint != null && distroRoles != null);
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  checkUnsupportedRoles(blueprint,distroRoles,failedMsgList);
  boolean result=validateRoleDependency(failedMsgList,blueprint);
  if (!Constants.MAPR_VENDOR.equalsIgnoreCase(blueprint.getHadoopStack().getVendor())) {
    validateGroupConfig(blueprint,failedMsgList,warningMsgList);
  }
  if (!failedMsgList.isEmpty() || !warningMsgList.isEmpty()) {
    throw ValidationException.VALIDATION_FAIL(""String_Node_Str"",failedMsgList,warningMsgList);
  }
  return result;
}"
48578,"public boolean validateBlueprint(ClusterBlueprint blueprint,List<String> distroRoles) throws ValidationException {
  logger.info(""String_Node_Str"" + blueprint.getName());
  if (Constants.MAPR_VENDOR.equalsIgnoreCase(blueprint.getHadoopStack().getVendor())) {
    return true;
  }
  return validateNoneMaprDistros(blueprint,distroRoles);
}","public boolean validateBlueprint(ClusterBlueprint blueprint,List<String> distroRoles) throws ValidationException {
  logger.info(""String_Node_Str"" + blueprint.getName());
  return validateDistros(blueprint,distroRoles);
}"
48579,"/** 
 * Create default cluster spec.
 * @param type cluster type
 * @return default cluster spec
 * @throws FileNotFoundException
 */
public static ClusterCreate createDefaultSpec(ClusterType type,String vendor,String distroVersion,String appManagerType) throws FileNotFoundException {
  if (vendor.trim().equalsIgnoreCase(Constants.MAPR_VENDOR)) {
switch (type) {
case HDFS_MAPRED:
      return loadFromFile(locateSpecFile(HDFS_MAPRED_MAPR_TEMPLATE_SPEC));
case HDFS_HBASE:
    return loadFromFile(locateSpecFile(HDFS_HBASE_MAPR_TEMPLATE_SPEC));
default :
  throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
 else if (vendor.trim().equalsIgnoreCase(Constants.GPHD_VENDOR)) {
switch (type) {
case HDFS:
return loadFromFile(locateSpecFile(HDFS_GPHD_TEMPLATE_SPEC));
case HDFS_MAPRED:
return loadFromFile(locateSpecFile(HDFS_MAPRED_GPHD_TEMPLATE_SPEC));
case HDFS_HBASE:
return loadFromFile(locateSpecFile(HDFS_HBASE_GPHD_TEMPLATE_SPEC));
default :
throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
 else if (Constants.AMBARI_PLUGIN_TYPE.equals(appManagerType) && vendor.trim().equalsIgnoreCase(Constants.HDP_VENDOR)) {
MAPREDUCE_VERSION mr=getDefaultMapReduceVersion(vendor,distroVersion);
if (type == null) {
if (mr == MAPREDUCE_VERSION.V1) {
return loadFromFile(locateSpecFile(AM_HDFS_MAPRED_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(AM_HDFS_YARN_TEMPLATE_SPEC));
}
}
HDFS_VERSION hdfs=getDefaultHdfsVersion(vendor,distroVersion);
switch (type) {
case HDFS:
if (hdfs == HDFS_VERSION.V1) {
return loadFromFile(locateSpecFile(AM_HDFS_V1_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(AM_HDFS_V2_TEMPLATE_SPEC));
}
case HDFS_MAPRED:
if (mr == MAPREDUCE_VERSION.V1) {
return loadFromFile(locateSpecFile(AM_HDFS_MAPRED_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(AM_HDFS_YARN_TEMPLATE_SPEC));
}
case HDFS_HBASE:
if (Configuration.getBoolean(Constants.AMBARI_HBASE_DEPEND_ON_MAPREDUCE)) {
if (hdfs == HDFS_VERSION.V1) {
return loadFromFile(locateSpecFile(AM_HDFS_V1_HBASE_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(AM_HDFS_V2_HBASE_TEMPLATE_SPEC));
}
}
 else {
return loadFromFile(locateSpecFile(AM_HDFS_PURE_HBASE_TEMPLATE_SPEC));
}
default :
throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
 else {
MAPREDUCE_VERSION mr=getDefaultMapReduceVersion(vendor,distroVersion);
if (Constants.CLOUDERA_MANAGER_PLUGIN_TYPE.equals(appManagerType) && type == null) {
if (mr == MAPREDUCE_VERSION.V1) {
return loadFromFile(locateSpecFile(CM_HDFS_MAPRED_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(CM_HDFS_YARN_TEMPLATE_SPEC));
}
}
switch (type) {
case HDFS:
return loadFromFile(locateSpecFile(HDFS_TEMPLATE_SPEC));
case HDFS_MAPRED:
if (mr == MAPREDUCE_VERSION.V1) {
return loadFromFile(locateSpecFile(HDFS_MAPRED_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(HDFS_YARN_TEMPLATE_SPEC));
}
case HDFS_HBASE:
return loadFromFile(locateSpecFile(HDFS_HBASE_TEMPLATE_SPEC));
default :
throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
}","/** 
 * Create default cluster spec.
 * @param type cluster type
 * @return default cluster spec
 * @throws FileNotFoundException
 */
public static ClusterCreate createDefaultSpec(ClusterType type,String vendor,String distroVersion,String appManagerType) throws FileNotFoundException {
  if (vendor.trim().equalsIgnoreCase(Constants.MAPR_VENDOR)) {
switch (type) {
case HDFS_MAPRED:
      return loadFromFile(locateSpecFile(HDFS_MAPRED_MAPR_TEMPLATE_SPEC));
case HDFS_HBASE:
    return loadFromFile(locateSpecFile(HDFS_HBASE_MAPR_TEMPLATE_SPEC));
default :
  throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
 else if (vendor.trim().equalsIgnoreCase(Constants.GPHD_VENDOR)) {
switch (type) {
case HDFS:
return loadFromFile(locateSpecFile(HDFS_GPHD_TEMPLATE_SPEC));
case HDFS_MAPRED:
return loadFromFile(locateSpecFile(HDFS_MAPRED_GPHD_TEMPLATE_SPEC));
case HDFS_HBASE:
return loadFromFile(locateSpecFile(HDFS_HBASE_GPHD_TEMPLATE_SPEC));
default :
throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
 else if (Constants.AMBARI_PLUGIN_TYPE.equals(appManagerType) && vendor.trim().equalsIgnoreCase(Constants.HDP_VENDOR)) {
MAPREDUCE_VERSION mr=getDefaultMapReduceVersion(vendor,distroVersion);
if (type == null) {
if (mr == MAPREDUCE_VERSION.V1) {
return loadFromFile(locateSpecFile(AM_HDFS_MAPRED_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(AM_HDFS_YARN_TEMPLATE_SPEC));
}
}
HDFS_VERSION hdfs=getDefaultHdfsVersion(vendor,distroVersion);
switch (type) {
case HDFS:
if (hdfs == HDFS_VERSION.V1) {
return loadFromFile(locateSpecFile(AM_HDFS_V1_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(AM_HDFS_V2_TEMPLATE_SPEC));
}
case HDFS_MAPRED:
if (mr == MAPREDUCE_VERSION.V1) {
return loadFromFile(locateSpecFile(AM_HDFS_MAPRED_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(AM_HDFS_YARN_TEMPLATE_SPEC));
}
case HDFS_HBASE:
if (Configuration.getBoolean(Constants.AMBARI_HBASE_DEPEND_ON_MAPREDUCE)) {
if (hdfs == HDFS_VERSION.V1) {
return loadFromFile(locateSpecFile(AM_HDFS_V1_HBASE_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(AM_HDFS_V2_HBASE_TEMPLATE_SPEC));
}
}
 else {
return loadFromFile(locateSpecFile(AM_HDFS_PURE_HBASE_TEMPLATE_SPEC));
}
default :
throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
 else {
MAPREDUCE_VERSION mr=getDefaultMapReduceVersion(vendor,distroVersion);
if (Constants.CLOUDERA_MANAGER_PLUGIN_TYPE.equals(appManagerType)) {
if (mr == MAPREDUCE_VERSION.V1) {
return loadFromFile(locateSpecFile(CM_HDFS_MAPRED_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(CM_HDFS_YARN_TEMPLATE_SPEC));
}
}
switch (type) {
case HDFS:
return loadFromFile(locateSpecFile(HDFS_TEMPLATE_SPEC));
case HDFS_MAPRED:
if (mr == MAPREDUCE_VERSION.V1) {
return loadFromFile(locateSpecFile(HDFS_MAPRED_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(HDFS_YARN_TEMPLATE_SPEC));
}
case HDFS_HBASE:
return loadFromFile(locateSpecFile(HDFS_HBASE_TEMPLATE_SPEC));
default :
throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
}"
48580,"@Transactional public void updateAppConfig(String clusterName,ClusterCreate clusterCreate){
  logger.debug(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  SoftwareManager softwareManager=getSoftwareManager(cluster.getAppManager());
  clusterCreate.setDistro(cluster.getDistro());
  clusterCreate.setDistroVersion(cluster.getDistroVersion());
  if (!CommonUtil.isBlank(cluster.getAdvancedProperties())) {
    Gson gson=new Gson();
    Map<String,String> advancedProperties=gson.fromJson(cluster.getAdvancedProperties(),Map.class);
    clusterCreate.setExternalHDFS(advancedProperties.get(""String_Node_Str""));
    clusterCreate.setExternalMapReduce(advancedProperties.get(""String_Node_Str""));
  }
  ClusterBlueprint blueprint=clusterCreate.toBlueprint();
  try {
    softwareManager.validateBlueprint(blueprint);
  }
 catch (  ValidationException e) {
    throw new ClusterConfigException(e,e.getMessage() + e.getFailedMsgList().toString());
  }
  updateInfrastructure(clusterCreate,softwareManager,blueprint);
  Map<String,Object> clusterLevelConfig=clusterCreate.getConfiguration();
  if (clusterLevelConfig != null && clusterLevelConfig.size() > 0) {
    logger.debug(""String_Node_Str"");
    cluster.setHadoopConfig((new Gson()).toJson(clusterLevelConfig));
    updateVhmJobTrackerPort(clusterCreate,cluster);
  }
 else {
    logger.debug(""String_Node_Str"");
    cluster.setHadoopConfig(null);
  }
  setAdvancedProperties(clusterCreate.getExternalHDFS(),clusterCreate.getExternalMapReduce(),cluster);
  updateNodegroupAppConfig(clusterCreate,cluster,clusterCreate.isValidateConfig());
}","@Transactional public void updateAppConfig(String clusterName,ClusterCreate clusterCreate){
  logger.debug(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  SoftwareManager softwareManager=getSoftwareManager(cluster.getAppManager());
  clusterCreate.setDistro(cluster.getDistro());
  clusterCreate.setDistroVersion(cluster.getDistroVersion());
  if (!CommonUtil.isBlank(cluster.getAdvancedProperties())) {
    Gson gson=new Gson();
    Map<String,String> advancedProperties=gson.fromJson(cluster.getAdvancedProperties(),Map.class);
    clusterCreate.setExternalHDFS(advancedProperties.get(""String_Node_Str""));
    clusterCreate.setExternalMapReduce(advancedProperties.get(""String_Node_Str""));
  }
  ClusterBlueprint blueprint=clusterCreate.toBlueprint();
  try {
    softwareManager.validateBlueprint(blueprint);
  }
 catch (  ValidationException e) {
    throw ClusterConfigException.INVALID_SPEC(e.getFailedMsgList());
  }
  updateInfrastructure(clusterCreate,softwareManager,blueprint);
  Map<String,Object> clusterLevelConfig=clusterCreate.getConfiguration();
  if (clusterLevelConfig != null && clusterLevelConfig.size() > 0) {
    logger.debug(""String_Node_Str"");
    cluster.setHadoopConfig((new Gson()).toJson(clusterLevelConfig));
    updateVhmJobTrackerPort(clusterCreate,cluster);
  }
 else {
    logger.debug(""String_Node_Str"");
    cluster.setHadoopConfig(null);
  }
  setAdvancedProperties(clusterCreate.getExternalHDFS(),clusterCreate.getExternalMapReduce(),cluster);
  updateNodegroupAppConfig(clusterCreate,cluster,clusterCreate.isValidateConfig());
}"
48581,"@Transactional public void updateAppConfig(String clusterName,ClusterCreate clusterCreate){
  logger.debug(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  SoftwareManager softwareManager=getSoftwareManager(cluster.getAppManager());
  clusterCreate.setDistro(cluster.getDistro());
  clusterCreate.setDistroVersion(cluster.getDistroVersion());
  if (!CommonUtil.isBlank(cluster.getAdvancedProperties())) {
    Gson gson=new Gson();
    Map<String,String> advancedProperties=gson.fromJson(cluster.getAdvancedProperties(),Map.class);
    clusterCreate.setExternalHDFS(advancedProperties.get(""String_Node_Str""));
    clusterCreate.setExternalMapReduce(advancedProperties.get(""String_Node_Str""));
  }
  ClusterBlueprint blueprint=clusterCreate.toBlueprint();
  try {
    softwareManager.validateBlueprint(blueprint);
  }
 catch (  ValidationException e) {
    throw ClusterConfigException.INVALID_SPEC(e.getFailedMsgList());
  }
  updateInfrastructure(clusterCreate,softwareManager,blueprint);
  Map<String,Object> clusterLevelConfig=clusterCreate.getConfiguration();
  if (clusterLevelConfig != null && clusterLevelConfig.size() > 0) {
    logger.debug(""String_Node_Str"");
    cluster.setHadoopConfig((new Gson()).toJson(clusterLevelConfig));
    updateVhmJobTrackerPort(clusterCreate,cluster);
  }
 else {
    logger.debug(""String_Node_Str"");
    cluster.setHadoopConfig(null);
  }
  setAdvancedProperties(clusterCreate.getExternalHDFS(),clusterCreate.getExternalMapReduce(),cluster);
  updateNodegroupAppConfig(clusterCreate,cluster,clusterCreate.isValidateConfig());
}","@Transactional public void updateAppConfig(String clusterName,ClusterCreate clusterCreate){
  logger.debug(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  SoftwareManager softwareManager=getSoftwareManager(cluster.getAppManager());
  clusterCreate.setDistro(cluster.getDistro());
  clusterCreate.setDistroVersion(cluster.getDistroVersion());
  if (!CommonUtil.isBlank(cluster.getAdvancedProperties())) {
    Gson gson=new Gson();
    Map<String,String> advancedProperties=gson.fromJson(cluster.getAdvancedProperties(),Map.class);
    clusterCreate.setExternalHDFS(advancedProperties.get(""String_Node_Str""));
    clusterCreate.setExternalMapReduce(advancedProperties.get(""String_Node_Str""));
  }
  ClusterBlueprint blueprint=clusterCreate.toBlueprint();
  try {
    softwareManager.validateBlueprint(blueprint);
  }
 catch (  ValidationException e) {
    throw new ClusterConfigException(e,e.getMessage() + e.getFailedMsgList().toString());
  }
  updateInfrastructure(clusterCreate,softwareManager,blueprint);
  Map<String,Object> clusterLevelConfig=clusterCreate.getConfiguration();
  if (clusterLevelConfig != null && clusterLevelConfig.size() > 0) {
    logger.debug(""String_Node_Str"");
    cluster.setHadoopConfig((new Gson()).toJson(clusterLevelConfig));
    updateVhmJobTrackerPort(clusterCreate,cluster);
  }
 else {
    logger.debug(""String_Node_Str"");
    cluster.setHadoopConfig(null);
  }
  setAdvancedProperties(clusterCreate.getExternalHDFS(),clusterCreate.getExternalMapReduce(),cluster);
  updateNodegroupAppConfig(clusterCreate,cluster,clusterCreate.isValidateConfig());
}"
48582,"@Transactional public void updateAppConfig(String clusterName,ClusterCreate clusterCreate){
  logger.debug(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  SoftwareManager softwareManager=getSoftwareManager(cluster.getAppManager());
  clusterCreate.setDistro(cluster.getDistro());
  clusterCreate.setDistroVersion(cluster.getDistroVersion());
  if (!CommonUtil.isBlank(cluster.getAdvancedProperties())) {
    Gson gson=new Gson();
    Map<String,String> advancedProperties=gson.fromJson(cluster.getAdvancedProperties(),Map.class);
    clusterCreate.setExternalHDFS(advancedProperties.get(""String_Node_Str""));
    clusterCreate.setExternalMapReduce(advancedProperties.get(""String_Node_Str""));
  }
  ClusterBlueprint blueprint=clusterCreate.toBlueprint();
  try {
    softwareManager.validateBlueprint(blueprint);
  }
 catch (  ValidationException e) {
    throw new ClusterConfigException(e,e.getMessage() + e.getFailedMsgList().toString());
  }
  updateInfrastructure(clusterCreate,softwareManager,blueprint);
  Map<String,Object> clusterLevelConfig=clusterCreate.getConfiguration();
  if (clusterLevelConfig != null && clusterLevelConfig.size() > 0) {
    logger.debug(""String_Node_Str"");
    cluster.setHadoopConfig((new Gson()).toJson(clusterLevelConfig));
    updateVhmJobTrackerPort(clusterCreate,cluster);
  }
 else {
    logger.debug(""String_Node_Str"");
    cluster.setHadoopConfig(null);
  }
  setAdvancedProperties(clusterCreate.getExternalHDFS(),clusterCreate.getExternalMapReduce(),cluster);
  updateNodegroupAppConfig(clusterCreate,cluster,clusterCreate.isValidateConfig());
}","@Transactional public void updateAppConfig(String clusterName,ClusterCreate clusterCreate){
  logger.debug(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  SoftwareManager softwareManager=getSoftwareManager(cluster.getAppManager());
  clusterCreate.setDistro(cluster.getDistro());
  clusterCreate.setDistroVersion(cluster.getDistroVersion());
  if (!CommonUtil.isBlank(cluster.getAdvancedProperties())) {
    Gson gson=new Gson();
    Map<String,String> advancedProperties=gson.fromJson(cluster.getAdvancedProperties(),Map.class);
    clusterCreate.setExternalHDFS(advancedProperties.get(""String_Node_Str""));
    clusterCreate.setExternalMapReduce(advancedProperties.get(""String_Node_Str""));
  }
  ClusterBlueprint blueprint=clusterCreate.toBlueprint();
  try {
    softwareManager.validateBlueprint(blueprint);
  }
 catch (  ValidationException e) {
    throw ClusterConfigException.INVALID_SPEC(e.getFailedMsgList());
  }
  updateInfrastructure(clusterCreate,softwareManager,blueprint);
  Map<String,Object> clusterLevelConfig=clusterCreate.getConfiguration();
  if (clusterLevelConfig != null && clusterLevelConfig.size() > 0) {
    logger.debug(""String_Node_Str"");
    cluster.setHadoopConfig((new Gson()).toJson(clusterLevelConfig));
    updateVhmJobTrackerPort(clusterCreate,cluster);
  }
 else {
    logger.debug(""String_Node_Str"");
    cluster.setHadoopConfig(null);
  }
  setAdvancedProperties(clusterCreate.getExternalHDFS(),clusterCreate.getExternalMapReduce(),cluster);
  updateNodegroupAppConfig(clusterCreate,cluster,clusterCreate.isValidateConfig());
}"
48583,"private void validateConfigs(Map<String,Object> config,List<String> unRecogConfigTypes,List<String> unRecogConfigKeys,String stackVendor,String stackVersion){
  if (config == null || config.isEmpty()) {
    return;
  }
  ApiStackServiceList servicesList=apiManager.getStackServiceListWithConfigurations(stackVendor,stackVersion);
  Map<String,Object> supportedConfigs=new HashMap<String,Object>();
  for (  ApiStackService apiStackService : servicesList.getApiStackServices()) {
    for (    ApiConfiguration apiConfiguration : apiStackService.getApiConfigurations()) {
      ApiConfigurationInfo apiConfigurationInfo=apiConfiguration.getApiConfigurationInfo();
      String configType=apiConfigurationInfo.getType();
      String propertyName=apiConfigurationInfo.getPropertyName();
      List<String> propertyNames=new ArrayList<String>();
      if (supportedConfigs.isEmpty()) {
        propertyNames.add(propertyName);
      }
 else {
        if (supportedConfigs.containsKey(configType)) {
          propertyNames=(List<String>)supportedConfigs.get(configType);
          propertyNames.add(propertyName);
        }
 else {
          propertyNames.add(propertyName);
        }
      }
      supportedConfigs.put(configType,propertyNames);
    }
  }
  for (  String key : config.keySet()) {
    boolean isSupportedType=false;
    for (    String configType : supportedConfigs.keySet()) {
      if (configType.equals(key + ""String_Node_Str"")) {
        isSupportedType=true;
        if (isSupportedType) {
          continue;
        }
      }
    }
    if (!isSupportedType) {
      unRecogConfigTypes.add(key);
    }
    Map<String,String> items=(Map<String,String>)config.get(key);
    for (    String subKey : items.keySet()) {
      boolean isSupportedPropety=false;
      for (      String propertyName : (List<String>)supportedConfigs.get(key + ""String_Node_Str"")) {
        if (propertyName.equals(subKey)) {
          isSupportedPropety=true;
          if (isSupportedPropety) {
            continue;
          }
        }
      }
      if (!isSupportedPropety) {
        unRecogConfigKeys.add(subKey);
      }
    }
  }
}","private void validateConfigs(Map<String,Object> config,List<String> unRecogConfigTypes,List<String> unRecogConfigKeys,String stackVendor,String stackVersion){
  if (config == null || config.isEmpty()) {
    return;
  }
  ApiStackServiceList servicesList=apiManager.getStackServiceListWithConfigurations(stackVendor,stackVersion);
  Map<String,Object> supportedConfigs=new HashMap<String,Object>();
  for (  ApiStackService apiStackService : servicesList.getApiStackServices()) {
    for (    ApiConfiguration apiConfiguration : apiStackService.getApiConfigurations()) {
      ApiConfigurationInfo apiConfigurationInfo=apiConfiguration.getApiConfigurationInfo();
      String configType=apiConfigurationInfo.getType();
      String propertyName=apiConfigurationInfo.getPropertyName();
      List<String> propertyNames=new ArrayList<String>();
      if (supportedConfigs.isEmpty()) {
        propertyNames.add(propertyName);
      }
 else {
        if (supportedConfigs.containsKey(configType)) {
          propertyNames=(List<String>)supportedConfigs.get(configType);
          propertyNames.add(propertyName);
        }
 else {
          propertyNames.add(propertyName);
        }
      }
      supportedConfigs.put(configType,propertyNames);
    }
  }
  Map<String,Object> notAvailableConfig=new HashMap<String,Object>();
  for (  String key : config.keySet()) {
    boolean isSupportedType=false;
    for (    String configType : supportedConfigs.keySet()) {
      if (configType.equals(key + ""String_Node_Str"")) {
        isSupportedType=true;
        if (isSupportedType) {
          continue;
        }
      }
    }
    if (!isSupportedType) {
      unRecogConfigTypes.add(key);
    }
    try {
      Map<String,String> items=(Map<String,String>)config.get(key);
      for (      String subKey : items.keySet()) {
        boolean isSupportedPropety=false;
        for (        String propertyName : (List<String>)supportedConfigs.get(key + ""String_Node_Str"")) {
          if (propertyName.equals(subKey)) {
            isSupportedPropety=true;
            if (isSupportedPropety) {
              continue;
            }
          }
        }
        if (!isSupportedPropety) {
          unRecogConfigKeys.add(subKey);
        }
      }
    }
 catch (    Exception e) {
      notAvailableConfig.put(key,config.get(key));
      errorMsgList.add(""String_Node_Str"" + notAvailableConfig.toString() + ""String_Node_Str"");
    }
  }
}"
48584,"public Long resumeClusterCreation(String clusterName) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ValidationUtils.validateVersion(clusterEntityMgr,clusterName);
  if (cluster.getStatus() != ClusterStatus.PROVISION_ERROR || cluster.getStatus() != ClusterStatus.SERVICE_ERROR) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus());
    throw ClusterManagerException.UPDATE_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  List<String> dsNames=getUsedDS(cluster.getVcDatastoreNameList());
  if (dsNames.isEmpty()) {
    throw ClusterConfigException.NO_RESOURCE_POOL_ADDED();
  }
  List<VcCluster> vcClusters=getUsedVcClusters(cluster.getVcRpNameList());
  if (vcClusters.isEmpty()) {
    throw ClusterConfigException.NO_DATASTORE_ADDED();
  }
  validateDatastore(dsNames,vcClusters);
  validateNetworkAccessibility(cluster.fetchNetworkNameList(),vcClusters);
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.PROVISION_ERROR.name()));
  JobParameters jobParameters=new JobParameters(param);
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.PROVISIONING);
  clusterEntityMgr.cleanupActionError(clusterName);
  try {
    return jobManager.runJob(JobConstants.RESUME_CLUSTER_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.PROVISION_ERROR);
    throw e;
  }
}","public Long resumeClusterCreation(String clusterName) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ValidationUtils.validateVersion(clusterEntityMgr,clusterName);
  if (cluster.getStatus() != ClusterStatus.PROVISION_ERROR && cluster.getStatus() != ClusterStatus.SERVICE_ERROR) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus());
    throw ClusterManagerException.UPDATE_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  List<String> dsNames=getUsedDS(cluster.getVcDatastoreNameList());
  if (dsNames.isEmpty()) {
    throw ClusterConfigException.NO_RESOURCE_POOL_ADDED();
  }
  List<VcCluster> vcClusters=getUsedVcClusters(cluster.getVcRpNameList());
  if (vcClusters.isEmpty()) {
    throw ClusterConfigException.NO_DATASTORE_ADDED();
  }
  validateDatastore(dsNames,vcClusters);
  validateNetworkAccessibility(cluster.fetchNetworkNameList(),vcClusters);
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.PROVISION_ERROR.name()));
  JobParameters jobParameters=new JobParameters(param);
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.PROVISIONING);
  clusterEntityMgr.cleanupActionError(clusterName);
  try {
    return jobManager.runJob(JobConstants.RESUME_CLUSTER_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.PROVISION_ERROR);
    throw e;
  }
}"
48585,"private NodeGroupEntity convertGroup(Gson gson,ClusterEntity clusterEntity,NodeGroupCreate group,String distro,boolean validateWhiteList){
  NodeGroupEntity groupEntity=new NodeGroupEntity();
  if (group.getRoles() == null || group.getRoles().isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  groupEntity.setCluster(clusterEntity);
  int cpuNum=group.getCpuNum() == null ? 0 : group.getCpuNum();
  if (!VcVmUtil.validateCPU(clusteringService.getTemplateVmId(),cpuNum)) {
    throw VcProviderException.CPU_NUM_NOT_MULTIPLE_OF_CORES_PER_SOCKET(group.getName(),clusteringService.getTemplateVmName());
  }
  groupEntity.setCpuNum(cpuNum);
  groupEntity.setDefineInstanceNum(group.getInstanceNum());
  groupEntity.setMemorySize(group.getMemCapacityMB() == null ? 0 : group.getMemCapacityMB());
  groupEntity.setSwapRatio(group.getSwapRatio());
  groupEntity.setName(group.getName());
  groupEntity.setNodeType(group.getInstanceType());
  PlacementPolicy policies=group.getPlacementPolicies();
  if (policies != null) {
    List<GroupAssociation> associons=policies.getGroupAssociations();
    if (associons != null) {
      Set<NodeGroupAssociation> associonEntities=new HashSet<NodeGroupAssociation>();
      for (      GroupAssociation a : associons) {
        NodeGroupAssociation ae=new NodeGroupAssociation();
        ae.setAssociationType(a.getType());
        ae.setNodeGroup(groupEntity);
        ae.setReferencedGroup(a.getReference());
        associonEntities.add(ae);
      }
      groupEntity.setGroupAssociations(associonEntities);
    }
    if (policies.getInstancePerHost() != null) {
      groupEntity.setInstancePerHost(policies.getInstancePerHost());
    }
    if (policies.getGroupRacks() != null) {
      groupEntity.setGroupRacks((new Gson()).toJson(policies.getGroupRacks()));
    }
  }
  if (group.getRpNames() != null && group.getRpNames().size() > 0) {
    groupEntity.setVcRpNameList(group.getRpNames());
  }
  Set<String> roles=new LinkedHashSet<String>();
  convertStorage(group,groupEntity,roles);
  roles.addAll(group.getRoles());
  groupEntity.setRoles(gson.toJson(roles));
  if (group.getInstanceNum() <= 0) {
    logger.warn(""String_Node_Str"" + group.getName() + ""String_Node_Str"");
    return null;
  }
  List<String> dsNames=groupEntity.getVcDatastoreNameList();
  if (dsNames == null) {
    dsNames=clusterEntity.getVcDatastoreNameList();
  }
  Set<String> sharedPattern;
  Set<String> localPattern;
  if (dsNames != null) {
    sharedPattern=datastoreMgr.getSharedDatastoresByNames(dsNames);
    localPattern=datastoreMgr.getLocalDatastoresByNames(dsNames);
  }
 else {
    sharedPattern=datastoreMgr.getAllSharedDatastores();
    localPattern=datastoreMgr.getAllLocalDatastores();
  }
  SoftwareManager softwareManager=getSoftwareManager(clusterEntity.getAppManager());
  CommonClusterExpandPolicy.expandGroupInstanceType(groupEntity,group,sharedPattern,localPattern,softwareManager);
  groupEntity.setHaFlag(group.getHaFlag());
  if (group.getConfiguration() != null && group.getConfiguration().size() > 0) {
    groupEntity.setHadoopConfig(gson.toJson(group.getConfiguration()));
  }
  groupEntity.setVmFolderPath(clusterEntity);
  logger.debug(""String_Node_Str"" + group.getName());
  return groupEntity;
}","private NodeGroupEntity convertGroup(Gson gson,ClusterEntity clusterEntity,NodeGroupCreate group,String distro,boolean validateWhiteList){
  NodeGroupEntity groupEntity=new NodeGroupEntity();
  if (group.getRoles() == null || group.getRoles().isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  groupEntity.setCluster(clusterEntity);
  int cpuNum=group.getCpuNum() == null ? 0 : group.getCpuNum();
  if (!VcVmUtil.validateCPU(clusteringService.getTemplateVmId(),cpuNum)) {
    throw VcProviderException.CPU_NUM_NOT_MULTIPLE_OF_CORES_PER_SOCKET(group.getName(),clusteringService.getTemplateVmName());
  }
  groupEntity.setCpuNum(cpuNum);
  groupEntity.setDefineInstanceNum(group.getInstanceNum());
  groupEntity.setMemorySize(group.getMemCapacityMB() == null ? 0 : group.getMemCapacityMB());
  groupEntity.setSwapRatio(group.getSwapRatio());
  groupEntity.setName(group.getName());
  groupEntity.setNodeType(group.getInstanceType());
  PlacementPolicy policies=group.getPlacementPolicies();
  if (policies != null) {
    List<GroupAssociation> associons=policies.getGroupAssociations();
    if (associons != null) {
      Set<NodeGroupAssociation> associonEntities=new HashSet<NodeGroupAssociation>();
      for (      GroupAssociation a : associons) {
        NodeGroupAssociation ae=new NodeGroupAssociation();
        ae.setAssociationType(a.getType());
        ae.setNodeGroup(groupEntity);
        ae.setReferencedGroup(a.getReference());
        associonEntities.add(ae);
      }
      groupEntity.setGroupAssociations(associonEntities);
    }
    if (policies.getInstancePerHost() != null) {
      groupEntity.setInstancePerHost(policies.getInstancePerHost());
    }
    if (policies.getGroupRacks() != null) {
      groupEntity.setGroupRacks((new Gson()).toJson(policies.getGroupRacks()));
    }
  }
  if (group.getRpNames() != null && group.getRpNames().size() > 0) {
    groupEntity.setVcRpNameList(group.getRpNames());
  }
  Set<String> roles=new LinkedHashSet<String>();
  convertStorage(group,groupEntity,roles);
  roles.addAll(group.getRoles());
  groupEntity.setRoles(gson.toJson(roles));
  if (group.getInstanceNum() <= 0) {
    logger.warn(""String_Node_Str"" + group.getName() + ""String_Node_Str"");
    return null;
  }
  List<String> dsNames=groupEntity.getVcDatastoreNameList();
  if (dsNames == null) {
    dsNames=clusterEntity.getVcDatastoreNameList();
  }
  Set<String> sharedPattern;
  Set<String> localPattern;
  if (dsNames != null) {
    sharedPattern=datastoreMgr.getSharedDatastoresByNames(dsNames);
    localPattern=datastoreMgr.getLocalDatastoresByNames(dsNames);
  }
 else {
    sharedPattern=datastoreMgr.getAllSharedDatastores();
    localPattern=datastoreMgr.getAllLocalDatastores();
  }
  SoftwareManager softwareManager=getSoftwareManager(clusterEntity.getAppManager());
  CommonClusterExpandPolicy.expandGroupInstanceType(groupEntity,group,sharedPattern,localPattern,softwareManager);
  String haFlag=group.getHaFlag();
  if (haFlag == null) {
    groupEntity.setHaFlag(Constants.HA_FLAG_OFF);
  }
 else {
    groupEntity.setHaFlag(haFlag);
  }
  if (group.getConfiguration() != null && group.getConfiguration().size() > 0) {
    groupEntity.setHadoopConfig(gson.toJson(group.getConfiguration()));
  }
  groupEntity.setVmFolderPath(clusterEntity);
  logger.debug(""String_Node_Str"" + group.getName());
  return groupEntity;
}"
48586,"private void applyInfraChanges(ClusterCreate cluster,ClusterBlueprint blueprint){
  cluster.setConfiguration(blueprint.getConfiguration());
  sortNodeGroups(cluster,blueprint);
  for (int i=0; i < blueprint.getNodeGroups().size(); i++) {
    NodeGroupInfo group=blueprint.getNodeGroups().get(i);
    NodeGroupCreate groupCreate=cluster.getNodeGroups()[i];
    groupCreate.setConfiguration(group.getConfiguration());
    groupCreate.setRoles(group.getRoles());
    groupCreate.setInstanceType(group.getInstanceType());
    groupCreate.setPlacementPolicies(group.getPlacement());
    if (groupCreate.getStorage() == null) {
      groupCreate.setStorage(new StorageRead());
    }
    groupCreate.getStorage().setSizeGB(group.getStorageSize());
    groupCreate.getStorage().setExpectedTypeFromRoles(group.getStorageExpectedType());
  }
  cluster.setExternalHDFS(blueprint.getExternalHDFS());
  cluster.setExternalMapReduce(blueprint.getExternalMapReduce());
}","private void applyInfraChanges(ClusterCreate cluster,ClusterBlueprint blueprint){
  cluster.setConfiguration(blueprint.getConfiguration());
  sortNodeGroups(cluster,blueprint);
  for (int i=0; i < blueprint.getNodeGroups().size(); i++) {
    NodeGroupInfo group=blueprint.getNodeGroups().get(i);
    NodeGroupCreate groupCreate=cluster.getNodeGroups()[i];
    groupCreate.setConfiguration(group.getConfiguration());
    groupCreate.setRoles(group.getRoles());
    groupCreate.setInstanceType(group.getInstanceType());
    groupCreate.setPlacementPolicies(group.getPlacement());
    if (groupCreate.getStorage() == null) {
      groupCreate.setStorage(new StorageRead());
    }
    groupCreate.getStorage().setSizeGB(group.getStorageSize());
  }
  cluster.setExternalHDFS(blueprint.getExternalHDFS());
  cluster.setExternalMapReduce(blueprint.getExternalMapReduce());
}"
48587,"private NodeGroupEntity convertGroup(Gson gson,ClusterEntity clusterEntity,NodeGroupCreate group,String distro,boolean validateWhiteList){
  NodeGroupEntity groupEntity=new NodeGroupEntity();
  if (group.getRoles() == null || group.getRoles().isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  groupEntity.setCluster(clusterEntity);
  int cpuNum=group.getCpuNum() == null ? 0 : group.getCpuNum();
  if (!VcVmUtil.validateCPU(clusteringService.getTemplateVmId(),cpuNum)) {
    throw VcProviderException.CPU_NUM_NOT_MULTIPLE_OF_CORES_PER_SOCKET(group.getName(),clusteringService.getTemplateVmName());
  }
  groupEntity.setCpuNum(cpuNum);
  groupEntity.setDefineInstanceNum(group.getInstanceNum());
  groupEntity.setMemorySize(group.getMemCapacityMB() == null ? 0 : group.getMemCapacityMB());
  groupEntity.setSwapRatio(group.getSwapRatio());
  groupEntity.setName(group.getName());
  groupEntity.setNodeType(group.getInstanceType());
  PlacementPolicy policies=group.getPlacementPolicies();
  if (policies != null) {
    List<GroupAssociation> associons=policies.getGroupAssociations();
    if (associons != null) {
      Set<NodeGroupAssociation> associonEntities=new HashSet<NodeGroupAssociation>();
      for (      GroupAssociation a : associons) {
        NodeGroupAssociation ae=new NodeGroupAssociation();
        ae.setAssociationType(a.getType());
        ae.setNodeGroup(groupEntity);
        ae.setReferencedGroup(a.getReference());
        associonEntities.add(ae);
      }
      groupEntity.setGroupAssociations(associonEntities);
    }
    if (policies.getInstancePerHost() != null) {
      groupEntity.setInstancePerHost(policies.getInstancePerHost());
    }
    if (policies.getGroupRacks() != null) {
      groupEntity.setGroupRacks((new Gson()).toJson(policies.getGroupRacks()));
    }
  }
  if (group.getRpNames() != null && group.getRpNames().size() > 0) {
    groupEntity.setVcRpNameList(group.getRpNames());
  }
  Set<String> roles=new LinkedHashSet<String>();
  convertStorage(group,groupEntity,roles);
  roles.addAll(group.getRoles());
  groupEntity.setRoles(gson.toJson(roles));
  if (group.getInstanceNum() <= 0) {
    logger.warn(""String_Node_Str"" + group.getName() + ""String_Node_Str"");
    return null;
  }
  List<String> dsNames=groupEntity.getVcDatastoreNameList();
  if (dsNames == null) {
    dsNames=clusterEntity.getVcDatastoreNameList();
  }
  Set<String> sharedPattern;
  Set<String> localPattern;
  if (dsNames != null) {
    sharedPattern=datastoreMgr.getSharedDatastoresByNames(dsNames);
    localPattern=datastoreMgr.getLocalDatastoresByNames(dsNames);
  }
 else {
    sharedPattern=datastoreMgr.getAllSharedDatastores();
    localPattern=datastoreMgr.getAllLocalDatastores();
  }
  CommonClusterExpandPolicy.expandGroupInstanceType(groupEntity,group,sharedPattern,localPattern);
  groupEntity.setHaFlag(group.getHaFlag());
  if (group.getConfiguration() != null && group.getConfiguration().size() > 0) {
    groupEntity.setHadoopConfig(gson.toJson(group.getConfiguration()));
  }
  groupEntity.setVmFolderPath(clusterEntity);
  logger.debug(""String_Node_Str"" + group.getName());
  return groupEntity;
}","private NodeGroupEntity convertGroup(Gson gson,ClusterEntity clusterEntity,NodeGroupCreate group,String distro,boolean validateWhiteList){
  NodeGroupEntity groupEntity=new NodeGroupEntity();
  if (group.getRoles() == null || group.getRoles().isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  groupEntity.setCluster(clusterEntity);
  int cpuNum=group.getCpuNum() == null ? 0 : group.getCpuNum();
  if (!VcVmUtil.validateCPU(clusteringService.getTemplateVmId(),cpuNum)) {
    throw VcProviderException.CPU_NUM_NOT_MULTIPLE_OF_CORES_PER_SOCKET(group.getName(),clusteringService.getTemplateVmName());
  }
  groupEntity.setCpuNum(cpuNum);
  groupEntity.setDefineInstanceNum(group.getInstanceNum());
  groupEntity.setMemorySize(group.getMemCapacityMB() == null ? 0 : group.getMemCapacityMB());
  groupEntity.setSwapRatio(group.getSwapRatio());
  groupEntity.setName(group.getName());
  groupEntity.setNodeType(group.getInstanceType());
  PlacementPolicy policies=group.getPlacementPolicies();
  if (policies != null) {
    List<GroupAssociation> associons=policies.getGroupAssociations();
    if (associons != null) {
      Set<NodeGroupAssociation> associonEntities=new HashSet<NodeGroupAssociation>();
      for (      GroupAssociation a : associons) {
        NodeGroupAssociation ae=new NodeGroupAssociation();
        ae.setAssociationType(a.getType());
        ae.setNodeGroup(groupEntity);
        ae.setReferencedGroup(a.getReference());
        associonEntities.add(ae);
      }
      groupEntity.setGroupAssociations(associonEntities);
    }
    if (policies.getInstancePerHost() != null) {
      groupEntity.setInstancePerHost(policies.getInstancePerHost());
    }
    if (policies.getGroupRacks() != null) {
      groupEntity.setGroupRacks((new Gson()).toJson(policies.getGroupRacks()));
    }
  }
  if (group.getRpNames() != null && group.getRpNames().size() > 0) {
    groupEntity.setVcRpNameList(group.getRpNames());
  }
  Set<String> roles=new LinkedHashSet<String>();
  convertStorage(group,groupEntity,roles);
  roles.addAll(group.getRoles());
  groupEntity.setRoles(gson.toJson(roles));
  if (group.getInstanceNum() <= 0) {
    logger.warn(""String_Node_Str"" + group.getName() + ""String_Node_Str"");
    return null;
  }
  List<String> dsNames=groupEntity.getVcDatastoreNameList();
  if (dsNames == null) {
    dsNames=clusterEntity.getVcDatastoreNameList();
  }
  Set<String> sharedPattern;
  Set<String> localPattern;
  if (dsNames != null) {
    sharedPattern=datastoreMgr.getSharedDatastoresByNames(dsNames);
    localPattern=datastoreMgr.getLocalDatastoresByNames(dsNames);
  }
 else {
    sharedPattern=datastoreMgr.getAllSharedDatastores();
    localPattern=datastoreMgr.getAllLocalDatastores();
  }
  SoftwareManager softwareManager=getSoftwareManager(clusterEntity.getAppManager());
  CommonClusterExpandPolicy.expandGroupInstanceType(groupEntity,group,sharedPattern,localPattern,softwareManager);
  groupEntity.setHaFlag(group.getHaFlag());
  if (group.getConfiguration() != null && group.getConfiguration().size() > 0) {
    groupEntity.setHadoopConfig(gson.toJson(group.getConfiguration()));
  }
  groupEntity.setVmFolderPath(clusterEntity);
  logger.debug(""String_Node_Str"" + group.getName());
  return groupEntity;
}"
48588,"public static void expandGroupInstanceType(NodeGroupEntity ngEntity,NodeGroupCreate group,Set<String> sharedPattern,Set<String> localPattern){
  logger.debug(""String_Node_Str"" + ngEntity.getName());
  InstanceType instanceType=ngEntity.getNodeType();
  int memory=ngEntity.getMemorySize();
  int cpu=ngEntity.getCpuNum();
  if (instanceType == null && (cpu == 0 || memory == 0)) {
    throw ClusterConfigException.INSTANCE_SIZE_NOT_SET(group.getName());
  }
  if (instanceType == null) {
    logger.debug(""String_Node_Str"");
  }
 else {
    logger.debug(""String_Node_Str"" + instanceType.toString());
  }
  if (memory == 0) {
    ngEntity.setMemorySize(instanceType.getMemoryMB());
  }
  if (cpu == 0) {
    ngEntity.setCpuNum(instanceType.getCpuNum());
  }
  logger.debug(""String_Node_Str"" + ngEntity.getStorageSize());
  if (ngEntity.getStorageType() == null) {
    String expectedType=group.getStorage().getExpectedTypeFromRoles();
    DatastoreType storeType=DatastoreType.valueOf(expectedType);
    if ((sharedPattern == null || sharedPattern.isEmpty()) && DatastoreType.SHARED == storeType) {
      storeType=DatastoreType.LOCAL;
    }
    if ((localPattern == null || localPattern.isEmpty()) && DatastoreType.LOCAL == storeType) {
      storeType=DatastoreType.SHARED;
    }
    ngEntity.setStorageType(storeType);
  }
 else {
    if ((sharedPattern == null || sharedPattern.isEmpty()) && (ngEntity.getStorageType().equals(DatastoreType.SHARED))) {
      String msg=""String_Node_Str"" + ngEntity.getName() + ""String_Node_Str"";
      logger.error(msg);
      throw ClusterConfigException.CLUSTER_CONFIG_DATASTORE_TYPE_NONEXISTENT(msg);
    }
    if ((localPattern == null || localPattern.isEmpty()) && (ngEntity.getStorageType().equals(DatastoreType.LOCAL))) {
      String msg=""String_Node_Str"" + ngEntity.getName() + ""String_Node_Str"";
      logger.error(msg);
      throw ClusterConfigException.CLUSTER_CONFIG_DATASTORE_TYPE_NONEXISTENT(msg);
    }
  }
}","public static void expandGroupInstanceType(NodeGroupEntity ngEntity,NodeGroupCreate group,Set<String> sharedPattern,Set<String> localPattern,SoftwareManager softwareManager){
  logger.debug(""String_Node_Str"" + ngEntity.getName());
  InstanceType instanceType=ngEntity.getNodeType();
  int memory=ngEntity.getMemorySize();
  int cpu=ngEntity.getCpuNum();
  if (instanceType == null && (cpu == 0 || memory == 0)) {
    throw ClusterConfigException.INSTANCE_SIZE_NOT_SET(group.getName());
  }
  if (instanceType == null) {
    logger.debug(""String_Node_Str"");
    if (softwareManager.hasMgmtRole(group.getRoles())) {
      instanceType=InstanceType.MEDIUM;
    }
 else {
      instanceType=InstanceType.SMALL;
    }
    ngEntity.setNodeType(instanceType);
  }
 else {
    logger.debug(""String_Node_Str"" + instanceType.toString());
  }
  if (group.getStorage().getSizeGB() <= 0) {
    GroupType groupType=null;
    if (softwareManager.hasMgmtRole(group.getRoles())) {
      groupType=GroupType.MANAGEMENTGROUP;
    }
 else {
      groupType=GroupType.WORKGROUP;
    }
    ngEntity.setStorageSize(ExpandUtils.getStorage(instanceType,groupType));
    logger.debug(""String_Node_Str"" + ngEntity.getStorageSize());
  }
 else {
    ngEntity.setStorageSize(group.getStorage().getSizeGB());
  }
  if (memory == 0) {
    ngEntity.setMemorySize(instanceType.getMemoryMB());
  }
  if (cpu == 0) {
    ngEntity.setCpuNum(instanceType.getCpuNum());
  }
  logger.debug(""String_Node_Str"" + ngEntity.getStorageSize());
  if (ngEntity.getStorageType() == null) {
    DatastoreType storeType=null;
    if (softwareManager.hasMgmtRole(group.getRoles())) {
      storeType=DatastoreType.SHARED;
    }
 else {
      storeType=DatastoreType.LOCAL;
    }
    if ((sharedPattern == null || sharedPattern.isEmpty()) && DatastoreType.SHARED == storeType) {
      storeType=DatastoreType.LOCAL;
    }
    if ((localPattern == null || localPattern.isEmpty()) && DatastoreType.LOCAL == storeType) {
      storeType=DatastoreType.SHARED;
    }
    ngEntity.setStorageType(storeType);
  }
 else {
    if ((sharedPattern == null || sharedPattern.isEmpty()) && (ngEntity.getStorageType().equals(DatastoreType.SHARED))) {
      String msg=""String_Node_Str"" + ngEntity.getName() + ""String_Node_Str"";
      logger.error(msg);
      throw ClusterConfigException.CLUSTER_CONFIG_DATASTORE_TYPE_NONEXISTENT(msg);
    }
    if ((localPattern == null || localPattern.isEmpty()) && (ngEntity.getStorageType().equals(DatastoreType.LOCAL))) {
      String msg=""String_Node_Str"" + ngEntity.getName() + ""String_Node_Str"";
      logger.error(msg);
      throw ClusterConfigException.CLUSTER_CONFIG_DATASTORE_TYPE_NONEXISTENT(msg);
    }
  }
}"
48589,"public void updateInfrastructure(ClusterBlueprint blueprint){
  expandDefaultCluster(blueprint);
  updateExternalConfig(blueprint);
  addTempFSServerRole(blueprint);
  sortNodeGroupRoles(blueprint);
  sortGroups(blueprint);
}","public void updateInfrastructure(ClusterBlueprint blueprint){
  updateExternalConfig(blueprint);
  addTempFSServerRole(blueprint);
  sortNodeGroupRoles(blueprint);
  sortGroups(blueprint);
}"
48590,"public Long createCluster(ClusterCreate createSpec) throws Exception {
  SoftwareManager softMgr=softwareManagerCollector.getSoftwareManager(createSpec.getAppManager());
  HadoopStack stack=clusterConfigMgr.filterDistroFromAppManager(softMgr,createSpec.getDistro());
  createSpec.setDistroVendor(stack.getVendor());
  createSpec.setDistroVersion(stack.getFullVersion());
  createAutoRps(createSpec);
  ClusterCreate clusterSpec=ClusterSpecFactory.getCustomizedSpec(createSpec);
  createSpec.verifyClusterNameLength();
  clusterSpec.validateNodeGroupNames();
  if (clusterSpec != null && clusterSpec.getNodeGroups() != null) {
    for (    NodeGroupCreate ng : clusterSpec.getNodeGroups()) {
      String templateVmId=clusteringService.getTemplateVmId();
      if (templateVmId != null) {
        VcResourceUtils.checkVmMaxConfiguration(templateVmId,ng.getCpuNum() == null ? 0 : ng.getCpuNum(),ng.getMemCapacityMB() == null ? 0 : ng.getMemCapacityMB());
      }
    }
  }
  String name=clusterSpec.getName();
  logger.info(""String_Node_Str"" + name);
  List<String> dsNames=getUsedDS(clusterSpec.getDsNames());
  if (dsNames.isEmpty()) {
    throw ClusterConfigException.NO_DATASTORE_ADDED();
  }
  List<VcCluster> vcClusters=getUsedVcClusters(clusterSpec.getRpNames());
  if (vcClusters == null || vcClusters.isEmpty()) {
    throw ClusterConfigException.NO_RESOURCE_POOL_ADDED();
  }
  validateDatastore(dsNames,vcClusters);
  validateNetworkAccessibility(createSpec.getNetworkNames(),vcClusters);
  clusterConfigMgr.createClusterConfig(clusterSpec);
  clusterEntityMgr.updateClusterStatus(name,ClusterStatus.PROVISIONING);
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.PROVISION_ERROR.name()));
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(createSpec.getName()));
  param.put(JobConstants.VERIFY_NODE_STATUS_SCOPE_PARAM,new JobParameter(JobConstants.CLUSTER_NODE_SCOPE_VALUE));
  JobParameters jobParameters=new JobParameters(param);
  return jobManager.runJob(JobConstants.CREATE_CLUSTER_JOB_NAME,jobParameters);
}","public Long createCluster(ClusterCreate createSpec) throws Exception {
  SoftwareManager softMgr=softwareManagerCollector.getSoftwareManager(createSpec.getAppManager());
  HadoopStack stack=clusterConfigMgr.filterDistroFromAppManager(softMgr,createSpec.getDistro());
  createSpec.setDistroVendor(stack.getVendor());
  createSpec.setDistroVersion(stack.getFullVersion());
  createAutoRps(createSpec);
  ClusterCreate clusterSpec=ClusterSpecFactory.getCustomizedSpec(createSpec,softMgr.getType());
  createSpec.verifyClusterNameLength();
  clusterSpec.validateNodeGroupNames();
  if (clusterSpec != null && clusterSpec.getNodeGroups() != null) {
    for (    NodeGroupCreate ng : clusterSpec.getNodeGroups()) {
      String templateVmId=clusteringService.getTemplateVmId();
      if (templateVmId != null) {
        VcResourceUtils.checkVmMaxConfiguration(templateVmId,ng.getCpuNum() == null ? 0 : ng.getCpuNum(),ng.getMemCapacityMB() == null ? 0 : ng.getMemCapacityMB());
      }
    }
  }
  String name=clusterSpec.getName();
  logger.info(""String_Node_Str"" + name);
  List<String> dsNames=getUsedDS(clusterSpec.getDsNames());
  if (dsNames.isEmpty()) {
    throw ClusterConfigException.NO_DATASTORE_ADDED();
  }
  List<VcCluster> vcClusters=getUsedVcClusters(clusterSpec.getRpNames());
  if (vcClusters == null || vcClusters.isEmpty()) {
    throw ClusterConfigException.NO_RESOURCE_POOL_ADDED();
  }
  validateDatastore(dsNames,vcClusters);
  validateNetworkAccessibility(createSpec.getNetworkNames(),vcClusters);
  clusterConfigMgr.createClusterConfig(clusterSpec);
  clusterEntityMgr.updateClusterStatus(name,ClusterStatus.PROVISIONING);
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.PROVISION_ERROR.name()));
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(createSpec.getName()));
  param.put(JobConstants.VERIFY_NODE_STATUS_SCOPE_PARAM,new JobParameter(JobConstants.CLUSTER_NODE_SCOPE_VALUE));
  JobParameters jobParameters=new JobParameters(param);
  return jobManager.runJob(JobConstants.CREATE_CLUSTER_JOB_NAME,jobParameters);
}"
48591,"/** 
 * Create default cluster spec.
 * @param type cluster type
 * @return default cluster spec
 * @throws FileNotFoundException
 */
public static ClusterCreate createDefaultSpec(ClusterType type,String vendor,String distroVersion) throws FileNotFoundException {
  if (vendor.trim().equalsIgnoreCase(Constants.MAPR_VENDOR)) {
switch (type) {
case HDFS_MAPRED:
      return loadFromFile(locateSpecFile(HDFS_MAPRED_MAPR_TEMPLATE_SPEC));
case HDFS_HBASE:
    return loadFromFile(locateSpecFile(HDFS_HBASE_MAPR_TEMPLATE_SPEC));
default :
  throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
 else if (vendor.trim().equalsIgnoreCase(Constants.GPHD_VENDOR)) {
switch (type) {
case HDFS:
return loadFromFile(locateSpecFile(HDFS_GPHD_TEMPLATE_SPEC));
case HDFS_MAPRED:
return loadFromFile(locateSpecFile(HDFS_MAPRED_GPHD_TEMPLATE_SPEC));
case HDFS_HBASE:
return loadFromFile(locateSpecFile(HDFS_HBASE_GPHD_TEMPLATE_SPEC));
default :
throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
 else {
MAPREDUCE_VERSION mr=getDefaultMapReduceVersion(vendor,distroVersion);
switch (type) {
case HDFS:
return loadFromFile(locateSpecFile(HDFS_TEMPLATE_SPEC));
case HDFS_MAPRED:
if (mr == MAPREDUCE_VERSION.V1) {
return loadFromFile(locateSpecFile(HDFS_MAPRED_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(HDFS_YARN_TEMPLATE_SPEC));
}
case HDFS_HBASE:
return loadFromFile(locateSpecFile(HDFS_HBASE_TEMPLATE_SPEC));
default :
throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
}","/** 
 * Create default cluster spec.
 * @param type cluster type
 * @return default cluster spec
 * @throws FileNotFoundException
 */
public static ClusterCreate createDefaultSpec(ClusterType type,String vendor,String distroVersion,String appManagerType) throws FileNotFoundException {
  if (vendor.trim().equalsIgnoreCase(Constants.MAPR_VENDOR)) {
switch (type) {
case HDFS_MAPRED:
      return loadFromFile(locateSpecFile(HDFS_MAPRED_MAPR_TEMPLATE_SPEC));
case HDFS_HBASE:
    return loadFromFile(locateSpecFile(HDFS_HBASE_MAPR_TEMPLATE_SPEC));
default :
  throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
 else if (vendor.trim().equalsIgnoreCase(Constants.GPHD_VENDOR)) {
switch (type) {
case HDFS:
return loadFromFile(locateSpecFile(HDFS_GPHD_TEMPLATE_SPEC));
case HDFS_MAPRED:
return loadFromFile(locateSpecFile(HDFS_MAPRED_GPHD_TEMPLATE_SPEC));
case HDFS_HBASE:
return loadFromFile(locateSpecFile(HDFS_HBASE_GPHD_TEMPLATE_SPEC));
default :
throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
 else {
MAPREDUCE_VERSION mr=getDefaultMapReduceVersion(vendor,distroVersion);
if (appManagerType.equals(Constants.CLOUDERA_MANAGER_PLUGIN_TYPE)) {
if (mr == MAPREDUCE_VERSION.V1) {
return loadFromFile(locateSpecFile(CM_HDFS_MAPRED_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(CM_HDFS_YARN_TEMPLATE_SPEC));
}
}
switch (type) {
case HDFS:
return loadFromFile(locateSpecFile(HDFS_TEMPLATE_SPEC));
case HDFS_MAPRED:
if (mr == MAPREDUCE_VERSION.V1) {
return loadFromFile(locateSpecFile(HDFS_MAPRED_TEMPLATE_SPEC));
}
 else {
return loadFromFile(locateSpecFile(HDFS_YARN_TEMPLATE_SPEC));
}
case HDFS_HBASE:
return loadFromFile(locateSpecFile(HDFS_HBASE_TEMPLATE_SPEC));
default :
throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
}"
48592,"/** 
 * There are two approach to create a cluster: 1) specify a cluster type and optionally overwriting the parameters 2) specify a customized spec with cluster type not specified
 * @param spec spec with customized field
 * @return customized cluster spec
 * @throws FileNotFoundException
 */
public static ClusterCreate getCustomizedSpec(ClusterCreate spec) throws FileNotFoundException {
  if ((spec.getType() == null) || (spec.getType() != null && spec.isSpecFile())) {
    return spec;
  }
  ClusterCreate newSpec=createDefaultSpec(spec.getType(),spec.getDistroVendor(),spec.getDistroVersion());
  if (spec.getName() != null) {
    newSpec.setName(spec.getName());
  }
  newSpec.setPassword(spec.getPassword());
  if (!CommonUtil.isBlank(spec.getAppManager())) {
    newSpec.setAppManager(spec.getAppManager());
  }
  if (spec.getDistro() != null) {
    newSpec.setDistro(spec.getDistro());
  }
  if (spec.getDistroVendor() != null) {
    newSpec.setDistroVendor(spec.getDistroVendor());
  }
  if (spec.getDistroVersion() != null) {
    newSpec.setDistroVersion(spec.getDistroVersion());
  }
  if (spec.getDsNames() != null) {
    newSpec.setDsNames(spec.getDsNames());
  }
  if (spec.getRpNames() != null) {
    newSpec.setRpNames(spec.getRpNames());
  }
  if (spec.getNetworkConfig() != null) {
    newSpec.setNetworkConfig(spec.getNetworkConfig());
  }
  if (spec.getTopologyPolicy() != null) {
    newSpec.setTopologyPolicy(spec.getTopologyPolicy());
  }
  return newSpec;
}","/** 
 * There are two approach to create a cluster: 1) specify a cluster type and optionally overwriting the parameters 2) specify a customized spec with cluster type not specified
 * @param spec spec with customized field
 * @return customized cluster spec
 * @throws FileNotFoundException
 */
public static ClusterCreate getCustomizedSpec(ClusterCreate spec,String appManagerType) throws FileNotFoundException {
  if ((spec.getType() == null) || (spec.getType() != null && spec.isSpecFile())) {
    return spec;
  }
  ClusterCreate newSpec=createDefaultSpec(spec.getType(),spec.getDistroVendor(),spec.getDistroVersion(),appManagerType);
  if (spec.getName() != null) {
    newSpec.setName(spec.getName());
  }
  newSpec.setPassword(spec.getPassword());
  if (!CommonUtil.isBlank(spec.getAppManager())) {
    newSpec.setAppManager(spec.getAppManager());
  }
  if (spec.getDistro() != null) {
    newSpec.setDistro(spec.getDistro());
  }
  if (spec.getDistroVendor() != null) {
    newSpec.setDistroVendor(spec.getDistroVendor());
  }
  if (spec.getDistroVersion() != null) {
    newSpec.setDistroVersion(spec.getDistroVersion());
  }
  if (spec.getDsNames() != null) {
    newSpec.setDsNames(spec.getDsNames());
  }
  if (spec.getRpNames() != null) {
    newSpec.setRpNames(spec.getRpNames());
  }
  if (spec.getNetworkConfig() != null) {
    newSpec.setNetworkConfig(spec.getNetworkConfig());
  }
  if (spec.getTopologyPolicy() != null) {
    newSpec.setTopologyPolicy(spec.getTopologyPolicy());
  }
  return newSpec;
}"
48593,"public NodeGroupInfo toNodeGroupInfo(){
  NodeGroupInfo nodeGroupInfo=new NodeGroupInfo();
  nodeGroupInfo.setName(name);
  nodeGroupInfo.setInstanceNum(instanceNum);
  nodeGroupInfo.setRoles(roles);
  nodeGroupInfo.setConfiguration(configuration);
  if (haFlag.equalsIgnoreCase(Constants.HA_FLAG_FT) || haFlag.equalsIgnoreCase(Constants.HA_FLAG_ON)) {
    nodeGroupInfo.setHaEnabled(true);
  }
  nodeGroupInfo.setInstanceType(instanceType);
  nodeGroupInfo.setPlacement(placementPolicies);
  if (storage != null) {
    nodeGroupInfo.setStorageSize(storage.getSizeGB());
    nodeGroupInfo.setStorageType(storage.getType());
  }
  nodeGroupInfo.setNodes(null);
  return nodeGroupInfo;
}","public NodeGroupInfo toNodeGroupInfo(){
  NodeGroupInfo nodeGroupInfo=new NodeGroupInfo();
  nodeGroupInfo.setName(name);
  nodeGroupInfo.setInstanceNum(instanceNum);
  nodeGroupInfo.setRoles(roles);
  nodeGroupInfo.setConfiguration(configuration);
  if (haFlag != null && (haFlag.equalsIgnoreCase(Constants.HA_FLAG_FT) || haFlag.equalsIgnoreCase(Constants.HA_FLAG_ON))) {
    nodeGroupInfo.setHaEnabled(true);
  }
  nodeGroupInfo.setInstanceType(instanceType);
  nodeGroupInfo.setPlacement(placementPolicies);
  if (storage != null) {
    nodeGroupInfo.setStorageSize(storage.getSizeGB());
    nodeGroupInfo.setStorageType(storage.getType());
  }
  nodeGroupInfo.setNodes(null);
  return nodeGroupInfo;
}"
48594,"@Override public void afterPropertiesSet() throws Exception {
  List<ClusterEntity> clusters=lockedEntityManager.getClusterEntityMgr().findAllClusters();
  for (  ClusterEntity cluster : clusters) {
    requestQueue.add(cluster.getName());
    logger.info(""String_Node_Str"" + cluster.getName());
  }
  syncupTimer=new Timer(SERVICE_SYNCUP_THREAD_NAME,true);
  StatusSyncUpTask task=new StatusSyncUpTask(lockedEntityManager,softwareManagerCollector,requestQueue);
  syncupTimer.schedule(task,SYNCUP_INTERVAL_MILLISECONDS);
}","@Override public void afterPropertiesSet() throws Exception {
  List<ClusterEntity> clusters=lockedEntityManager.getClusterEntityMgr().findAllClusters();
  for (  ClusterEntity cluster : clusters) {
    requestQueue.add(cluster.getName());
    logger.info(""String_Node_Str"" + cluster.getName());
  }
  syncupTimer=new Timer(SERVICE_SYNCUP_THREAD_NAME,true);
  StatusSyncUpTask task=new StatusSyncUpTask(lockedEntityManager,softwareManagerCollector,requestQueue);
  syncupTimer.scheduleAtFixedRate(task,new Date(),SYNCUP_INTERVAL_MILLISECONDS);
}"
48595,"@Override public void run(){
  Set<String> clusterList=new HashSet<String>();
  requestQueue.drainTo(clusterList);
  if (clusterList.isEmpty()) {
    logger.debug(""String_Node_Str"");
    return;
  }
  Iterator<String> ite=clusterList.iterator();
  for (String clusterName=ite.next(); ite.hasNext(); clusterName=ite.next()) {
    try {
      ClusterEntity cluster=lockedEntityManager.getClusterEntityMgr().findByName(clusterName);
      if (cluster == null) {
        logger.info(""String_Node_Str"" + clusterName + ""String_Node_Str"");
        ite.remove();
        continue;
      }
      if (!cluster.inStableStatus()) {
        logger.debug(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.inStableStatus());
        logger.debug(""String_Node_Str"");
        continue;
      }
      ClusterBlueprint blueprint=lockedEntityManager.getClusterEntityMgr().toClusterBluePrint(clusterName);
      SoftwareManager softMgr=softwareManagerCollector.getSoftwareManagerByClusterName(clusterName);
      if (softMgr == null) {
        logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
        continue;
      }
      ClusterReport report=softMgr.queryClusterStatus(blueprint);
      if (report == null) {
        logger.debug(""String_Node_Str"");
        continue;
      }
      lockedEntityManager.getClusterEntityMgr().setClusterStatus(clusterName,report);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ e.getMessage(),e);
    }
  }
  requestQueue.addAll(clusterList);
}","@Override public void run(){
  Set<String> clusterList=new HashSet<String>();
  requestQueue.drainTo(clusterList);
  if (clusterList.isEmpty()) {
    logger.debug(""String_Node_Str"");
    return;
  }
  Iterator<String> ite=clusterList.iterator();
  for (String clusterName=ite.next(); ite.hasNext(); clusterName=ite.next()) {
    try {
      ClusterEntity cluster=lockedEntityManager.getClusterEntityMgr().findByName(clusterName);
      if (cluster == null) {
        logger.info(""String_Node_Str"" + clusterName + ""String_Node_Str"");
        ite.remove();
        continue;
      }
      if (!cluster.inStableStatus()) {
        logger.debug(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.inStableStatus());
        logger.debug(""String_Node_Str"");
        continue;
      }
      ClusterBlueprint blueprint=lockedEntityManager.getClusterEntityMgr().toClusterBluePrint(clusterName);
      SoftwareManager softMgr=softwareManagerCollector.getSoftwareManagerByClusterName(clusterName);
      if (softMgr == null) {
        logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
        continue;
      }
      ClusterReport report=softMgr.queryClusterStatus(blueprint);
      if (report == null) {
        logger.debug(""String_Node_Str"");
        continue;
      }
      logger.debug(""String_Node_Str"" + report.getStatus());
      lockedEntityManager.getClusterEntityMgr().setClusterStatus(clusterName,report);
    }
 catch (    Throwable e) {
      logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ e.getMessage(),e);
    }
  }
  requestQueue.addAll(clusterList);
  logger.debug(""String_Node_Str"" + requestQueue);
}"
48596,"@Override public Void call() throws Exception {
  vcVm=VcCache.getIgnoreMissing(vmId);
  if (vcVm == null) {
    logger.info(""String_Node_Str"" + vmId + ""String_Node_Str"");
    return null;
  }
  VcContext.inVcSessionDo(new VcSession<Void>(){
    @Override protected Void body() throws Exception {
      try {
        FaultToleranceConfigInfo info=vcVm.getConfig().getFtInfo();
        if (info != null && info.getRole() == 1) {
          logger.info(""String_Node_Str"" + vcVm.getName() + ""String_Node_Str"");
          vcVm.turnOffFT();
        }
        if (vcVm.isPoweredOn()) {
          vcVm.powerOff();
        }
        vcVm.destroy();
        return null;
      }
 catch (      ManagedObjectNotFound e) {
        VcUtil.processNotFoundException(e,vmId,logger);
        return null;
      }
catch (      Exception e) {
        if (vcVm.getConnectionState() == ConnectionState.inaccessible) {
          logger.error(""String_Node_Str"" + vcVm.getName(),e);
          logger.info(""String_Node_Str"" + vcVm.getName());
          vcVm.unregister();
          return null;
        }
 else {
          throw e;
        }
      }
    }
    protected boolean isTaskSession(){
      return true;
    }
  }
);
  return null;
}","@Override public Void call() throws Exception {
  vcVm=VcCache.getIgnoreMissing(vmId);
  if (vcVm == null) {
    logger.info(""String_Node_Str"" + vmId + ""String_Node_Str"");
    return null;
  }
  VcContext.inVcSessionDo(new VcSession<Void>(){
    @Override protected Void body() throws Exception {
      try {
        FaultToleranceConfigInfo info=vcVm.getConfig().getFtInfo();
        if (info != null && info.getRole() == 1) {
          logger.info(""String_Node_Str"" + vcVm.getName() + ""String_Node_Str"");
          vcVm.turnOffFT();
        }
        if (vcVm.isPoweredOn()) {
          vcVm.powerOff();
        }
        vcVm.destroy();
        return null;
      }
 catch (      ManagedObjectNotFound e) {
        VcUtil.processNotFoundException(e,vmId,logger);
        return null;
      }
catch (      Exception e) {
        if (e.getCause() != null && e.getCause() instanceof ManagedObjectNotFound) {
          VcUtil.processNotFoundException((ManagedObjectNotFound)e.getCause(),vmId,logger);
          return null;
        }
        if (vcVm.getConnectionState() == ConnectionState.inaccessible) {
          logger.error(""String_Node_Str"" + vcVm.getName(),e);
          logger.info(""String_Node_Str"" + vcVm.getName());
          vcVm.unregister();
          return null;
        }
 else {
          throw e;
        }
      }
    }
    protected boolean isTaskSession(){
      return true;
    }
  }
);
  return null;
}"
48597,"@Override protected Void body() throws Exception {
  try {
    FaultToleranceConfigInfo info=vcVm.getConfig().getFtInfo();
    if (info != null && info.getRole() == 1) {
      logger.info(""String_Node_Str"" + vcVm.getName() + ""String_Node_Str"");
      vcVm.turnOffFT();
    }
    if (vcVm.isPoweredOn()) {
      vcVm.powerOff();
    }
    vcVm.destroy();
    return null;
  }
 catch (  ManagedObjectNotFound e) {
    VcUtil.processNotFoundException(e,vmId,logger);
    return null;
  }
catch (  Exception e) {
    if (vcVm.getConnectionState() == ConnectionState.inaccessible) {
      logger.error(""String_Node_Str"" + vcVm.getName(),e);
      logger.info(""String_Node_Str"" + vcVm.getName());
      vcVm.unregister();
      return null;
    }
 else {
      throw e;
    }
  }
}","@Override protected Void body() throws Exception {
  try {
    FaultToleranceConfigInfo info=vcVm.getConfig().getFtInfo();
    if (info != null && info.getRole() == 1) {
      logger.info(""String_Node_Str"" + vcVm.getName() + ""String_Node_Str"");
      vcVm.turnOffFT();
    }
    if (vcVm.isPoweredOn()) {
      vcVm.powerOff();
    }
    vcVm.destroy();
    return null;
  }
 catch (  ManagedObjectNotFound e) {
    VcUtil.processNotFoundException(e,vmId,logger);
    return null;
  }
catch (  Exception e) {
    if (e.getCause() != null && e.getCause() instanceof ManagedObjectNotFound) {
      VcUtil.processNotFoundException((ManagedObjectNotFound)e.getCause(),vmId,logger);
      return null;
    }
    if (vcVm.getConnectionState() == ConnectionState.inaccessible) {
      logger.error(""String_Node_Str"" + vcVm.getName(),e);
      logger.info(""String_Node_Str"" + vcVm.getName());
      vcVm.unregister();
      return null;
    }
 else {
      throw e;
    }
  }
}"
48598,"public boolean inStableStatus(){
  ClusterStatus[] stableStatus=new ClusterStatus[]{ClusterStatus.RUNNING,ClusterStatus.STOPPED,ClusterStatus.CONFIGURE_ERROR,ClusterStatus.ERROR,ClusterStatus.PROVISION_ERROR};
  return Arrays.asList(stableStatus).contains(this.status);
}","public boolean inStableStatus(){
  ClusterStatus[] stableStatus=new ClusterStatus[]{ClusterStatus.RUNNING,ClusterStatus.STOPPED,ClusterStatus.CONFIGURE_ERROR,ClusterStatus.ERROR,ClusterStatus.PROVISION_ERROR,ClusterStatus.SERVICE_ERROR};
  return Arrays.asList(stableStatus).contains(this.status);
}"
48599,"@Transactional @RetryTransaction public boolean handleOperationStatus(String clusterName,ClusterReport report,boolean lastUpdate){
  boolean finished=report.isFinished();
  ClusterEntity cluster=findByName(report.getName());
  Map<String,NodeReport> nodeReportMap=report.getNodeReports();
  for (  NodeGroupEntity group : cluster.getNodeGroups()) {
    for (    NodeEntity node : group.getNodes()) {
      NodeReport nodeReport=nodeReportMap.get(node.getVmName());
      if (nodeReport == null) {
        continue;
      }
      if (nodeReport.getStatus() != null) {
        logger.debug(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ node.getStatus()+ ""String_Node_Str""+ nodeReport.getStatus().toString());
        if (!node.isDisconnected()) {
          if (nodeReport.getStatus() == ServiceStatus.RUNNING) {
            node.setStatus(NodeStatus.SERVICE_READY);
          }
 else {
            node.setStatus(NodeStatus.BOOTSTRAP_FAILED);
          }
        }
      }
      if (nodeReport.isUseClusterMsg() && report.getAction() != null) {
        logger.debug(""String_Node_Str"" + report.getAction());
        node.setAction(report.getAction());
      }
 else       if (nodeReport.getAction() != null) {
        node.setAction(nodeReport.getAction());
      }
      if (nodeReport.getErrMsg() != null) {
        logger.debug(""String_Node_Str"" + report.getAction());
        node.setErrMessage(nodeReport.getErrMsg());
      }
    }
  }
  return finished;
}","@Transactional @RetryTransaction public boolean handleOperationStatus(String clusterName,ClusterReport report,boolean lastUpdate){
  boolean finished=report.isFinished();
  ClusterEntity cluster=findByName(report.getName());
  Map<String,NodeReport> nodeReportMap=report.getNodeReports();
  for (  NodeGroupEntity group : cluster.getNodeGroups()) {
    for (    NodeEntity node : group.getNodes()) {
      NodeReport nodeReport=nodeReportMap.get(node.getVmName());
      if (nodeReport == null) {
        continue;
      }
      if (nodeReport.getStatus() != null) {
        logger.debug(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ node.getStatus()+ ""String_Node_Str""+ nodeReport.getStatus().toString());
        if (!node.isDisconnected()) {
          if (nodeReport.getStatus() == ServiceStatus.RUNNING) {
            node.setStatus(NodeStatus.SERVICE_READY);
          }
 else {
            node.setStatus(NodeStatus.BOOTSTRAP_FAILED);
          }
        }
      }
      if (nodeReport.isUseClusterMsg() && report.getAction() != null) {
        logger.debug(""String_Node_Str"" + report.getAction());
        node.setAction(report.getAction());
      }
 else       if (nodeReport.getAction() != null) {
        node.setAction(nodeReport.getAction());
      }
      if (lastUpdate && nodeReport.getErrMsg() != null) {
        logger.debug(""String_Node_Str"" + report.getAction());
        node.setErrMessage(nodeReport.getErrMsg());
      }
    }
  }
  return finished;
}"
48600,"@Override public void run(){
  Set<String> clusterList=new HashSet<String>();
  requestQueue.drainTo(clusterList);
  if (clusterList.isEmpty()) {
    logger.debug(""String_Node_Str"");
    return;
  }
  try {
    Iterator<String> ite=clusterList.iterator();
    for (String clusterName=ite.next(); ite.hasNext(); ) {
      ClusterEntity cluster=lockedEntityManager.getClusterEntityMgr().findByName(clusterName);
      if (cluster == null) {
        logger.info(""String_Node_Str"" + clusterName + ""String_Node_Str"");
        ite.remove();
        continue;
      }
      if (!cluster.inStableStatus()) {
        logger.debug(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.inStableStatus());
        logger.debug(""String_Node_Str"");
        continue;
      }
      ClusterBlueprint blueprint=lockedEntityManager.getClusterEntityMgr().toClusterBluePrint(clusterName);
      SoftwareManager softMgr=softwareManagerCollector.getSoftwareManagerByClusterName(clusterName);
      if (softMgr == null) {
        logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
        continue;
      }
      ClusterReport report=softMgr.queryClusterStatus(blueprint);
      if (report == null) {
        logger.debug(""String_Node_Str"");
        continue;
      }
      setClusterStatus(clusterName,report);
    }
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + e.getMessage(),e);
  }
  requestQueue.addAll(clusterList);
}","@Override public void run(){
  Set<String> clusterList=new HashSet<String>();
  requestQueue.drainTo(clusterList);
  if (clusterList.isEmpty()) {
    logger.debug(""String_Node_Str"");
    return;
  }
  Iterator<String> ite=clusterList.iterator();
  for (String clusterName=ite.next(); ite.hasNext(); clusterName=ite.next()) {
    try {
      ClusterEntity cluster=lockedEntityManager.getClusterEntityMgr().findByName(clusterName);
      if (cluster == null) {
        logger.info(""String_Node_Str"" + clusterName + ""String_Node_Str"");
        ite.remove();
        continue;
      }
      if (!cluster.inStableStatus()) {
        logger.debug(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.inStableStatus());
        logger.debug(""String_Node_Str"");
        continue;
      }
      ClusterBlueprint blueprint=lockedEntityManager.getClusterEntityMgr().toClusterBluePrint(clusterName);
      SoftwareManager softMgr=softwareManagerCollector.getSoftwareManagerByClusterName(clusterName);
      if (softMgr == null) {
        logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
        continue;
      }
      ClusterReport report=softMgr.queryClusterStatus(blueprint);
      if (report == null) {
        logger.debug(""String_Node_Str"");
        continue;
      }
      lockedEntityManager.getClusterEntityMgr().setClusterStatus(clusterName,report);
    }
 catch (    Exception e) {
      logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ e.getMessage(),e);
    }
  }
  requestQueue.addAll(clusterList);
}"
48601,"@Override public AmHealthState getClusterStatus(String clusterName){
  String fields=""String_Node_Str"";
  String servicesWithState=apiResourceRootV1.getClustersResource().getComponentsResource(clusterName).readComponentsWithFilter(fields);
  ApiComponentList componentList=ApiUtils.jsonToObject(ApiComponentList.class,servicesWithState);
  AmHealthState state=AmHealthState.HEALTHY;
  if (componentList.getApiComponents() != null) {
    for (    ApiServiceComponent component : componentList.getApiComponents()) {
      ApiServiceComponentInfo info=component.getApiServiceComponent();
      if (info.getCategory().equalsIgnoreCase(""String_Node_Str"") && (!ComponentStatus.INSTALLED.toString().equalsIgnoreCase(info.getState()))) {
        state=AmHealthState.UNHEALTHY;
      }
 else       if ((!info.getCategory().equalsIgnoreCase(""String_Node_Str"")) && (!ComponentStatus.STARTED.toString().equalsIgnoreCase(info.getState()))) {
        state=AmHealthState.UNHEALTHY;
      }
    }
  }
  return state;
}","@Override public AmHealthState getClusterStatus(String clusterName){
  String fields=""String_Node_Str"";
  String servicesWithState=null;
  servicesWithState=apiResourceRootV1.getClustersResource().getComponentsResource(clusterName).readComponentsWithFilter(fields);
  ApiComponentList componentList=ApiUtils.jsonToObject(ApiComponentList.class,servicesWithState);
  AmHealthState state=AmHealthState.HEALTHY;
  if (componentList.getApiComponents() != null) {
    for (    ApiServiceComponent component : componentList.getApiComponents()) {
      ApiServiceComponentInfo info=component.getApiServiceComponent();
      if (info.getCategory().equalsIgnoreCase(""String_Node_Str"") && (!ComponentStatus.INSTALLED.toString().equalsIgnoreCase(info.getState()))) {
        state=AmHealthState.UNHEALTHY;
      }
 else       if ((!info.getCategory().equalsIgnoreCase(""String_Node_Str"")) && (!ComponentStatus.STARTED.toString().equalsIgnoreCase(info.getState()))) {
        state=AmHealthState.UNHEALTHY;
      }
    }
  }
  return state;
}"
48602,"@Override public ClusterReport queryClusterStatus(ClusterBlueprint blueprint){
  AmClusterDef clusterDef=new AmClusterDef(blueprint,privateKey);
  AmHealthState state=apiManager.getClusterStatus(blueprint.getName());
  if (AmHealthState.HEALTHY == state) {
    clusterDef.getCurrentReport().setStatus(ServiceStatus.RUNNING);
  }
 else {
    clusterDef.getCurrentReport().setStatus(ServiceStatus.FAILED);
  }
  Map<String,AmHealthState> hostStates=apiManager.getHostStatus(blueprint.getName());
  Map<String,NodeReport> nodeReports=clusterDef.getCurrentReport().getNodeReports();
  for (  AmNodeDef node : clusterDef.getNodes()) {
    String fqdn=node.getFqdn();
    AmHealthState health=hostStates.get(fqdn);
    if (AmHealthState.HEALTHY == health) {
      nodeReports.get(node.getName()).setStatus(ServiceStatus.RUNNING);
    }
 else {
      nodeReports.get(node.getName()).setStatus(ServiceStatus.FAILED);
    }
  }
  return clusterDef.getCurrentReport().clone();
}","@Override public ClusterReport queryClusterStatus(ClusterBlueprint blueprint){
  AmClusterDef clusterDef=new AmClusterDef(blueprint,privateKey);
  try {
    AmHealthState state=apiManager.getClusterStatus(blueprint.getName());
    if (AmHealthState.HEALTHY == state) {
      clusterDef.getCurrentReport().setStatus(ServiceStatus.RUNNING);
    }
 else {
      clusterDef.getCurrentReport().setStatus(ServiceStatus.FAILED);
    }
    Map<String,AmHealthState> hostStates=apiManager.getHostStatus(blueprint.getName());
    Map<String,NodeReport> nodeReports=clusterDef.getCurrentReport().getNodeReports();
    for (    AmNodeDef node : clusterDef.getNodes()) {
      String fqdn=node.getFqdn();
      AmHealthState health=hostStates.get(fqdn);
      if (AmHealthState.HEALTHY == health) {
        nodeReports.get(node.getName()).setStatus(ServiceStatus.RUNNING);
      }
 else {
        nodeReports.get(node.getName()).setStatus(ServiceStatus.FAILED);
      }
    }
  }
 catch (  NotFoundException e) {
    logger.info(""String_Node_Str"" + blueprint.getName() + ""String_Node_Str"");
    return null;
  }
  return clusterDef.getCurrentReport().clone();
}"
48603,"public synchronized void loadSoftwareManagers(){
  AppManagerAdd appManagerAdd;
  if (appManagerService.findAppManagerByName(Constants.IRONFAN) == null) {
    appManagerAdd=new AppManagerAdd();
    appManagerAdd.setName(Constants.IRONFAN);
    appManagerAdd.setDescription(Constants.IRONFAN_DESCRIPTION);
    appManagerAdd.setType(Constants.IRONFAN);
    appManagerAdd.setUrl(""String_Node_Str"");
    appManagerAdd.setUsername(""String_Node_Str"");
    appManagerAdd.setPassword(""String_Node_Str"");
    appManagerAdd.setSslCertificate(""String_Node_Str"");
    appManagerService.addAppManager(appManagerAdd);
  }
  SoftwareManager ironfanSoftwareManager=new DefaultSoftwareManagerImpl();
  cache.put(Constants.IRONFAN,ironfanSoftwareManager);
  List<AppManagerEntity> appManagers=appManagerService.findAll();
  for (  AppManagerEntity appManager : appManagers) {
    if (!appManager.getName().equals(Constants.IRONFAN)) {
      appManagerAdd=new AppManagerAdd();
      appManagerAdd.setName(appManager.getName());
      appManagerAdd.setDescription(appManager.getDescription());
      appManagerAdd.setType(appManager.getType());
      appManagerAdd.setUrl(appManager.getUrl());
      appManagerAdd.setUsername(appManager.getUsername());
      appManagerAdd.setPassword(appManager.getPassword());
      appManagerAdd.setSslCertificate(appManager.getSslCertificate());
      try {
        loadSoftwareManager(appManagerAdd);
      }
 catch (      SoftwareManagerCollectorException e) {
        logger.error(""String_Node_Str"" + appManagerAdd,e);
      }
    }
  }
}","public synchronized void loadSoftwareManagers(){
  AppManagerAdd appManagerAdd;
  if (appManagerService.findAppManagerByName(Constants.IRONFAN) == null) {
    appManagerAdd=new AppManagerAdd();
    appManagerAdd.setName(Constants.IRONFAN);
    appManagerAdd.setDescription(Constants.IRONFAN_DESCRIPTION);
    appManagerAdd.setType(Constants.IRONFAN);
    appManagerAdd.setUrl(""String_Node_Str"");
    appManagerAdd.setUsername(""String_Node_Str"");
    appManagerAdd.setPassword(""String_Node_Str"");
    appManagerAdd.setSslCertificate(""String_Node_Str"");
    appManagerService.addAppManager(appManagerAdd);
  }
  SoftwareManager ironfanSoftwareManager=new DefaultSoftwareManagerImpl();
  cache.put(Constants.IRONFAN,ironfanSoftwareManager);
  List<AppManagerEntity> appManagers=appManagerService.findAll();
  for (  AppManagerEntity appManager : appManagers) {
    if (!appManager.getName().equals(Constants.IRONFAN)) {
      appManagerAdd=new AppManagerAdd();
      appManagerAdd.setName(appManager.getName());
      appManagerAdd.setDescription(appManager.getDescription());
      appManagerAdd.setType(appManager.getType());
      appManagerAdd.setUrl(appManager.getUrl());
      appManagerAdd.setUsername(appManager.getUsername());
      appManagerAdd.setPassword(appManager.getPassword());
      appManagerAdd.setSslCertificate(appManager.getSslCertificate());
      try {
        SoftwareManager softwareManager=loadSoftwareManager(appManagerAdd);
        cache.put(appManager.getName(),softwareManager);
      }
 catch (      SoftwareManagerCollectorException e) {
        logger.error(""String_Node_Str"" + appManagerAdd,e);
      }
    }
  }
}"
48604,"@Override public boolean poll(){
  ClusterReport toReport=null;
synchronized (currentReport) {
    if (!reported) {
      int currentProgress=currentReport.getProgress();
      int toProgress=currentProgress + (endProgress - currentProgress) / leftStepsNum;
      currentReport.setProgress(toProgress > endProgress ? endProgress : toProgress);
      leftStepsNum-=1;
      toReport=currentReport.clone();
      reported=true;
    }
  }
  if (toReport != null) {
    logger.info(""String_Node_Str"" + toReport.getProgress() + ""String_Node_Str""+ toReport.getAction());
    reportQueue.addClusterReport(toReport);
  }
  if (rootResource.getCommandsResource().readCommand(parentCmdId).getEndTime() != null) {
    running=false;
    executor.shutdown();
    return true;
  }
  return false;
}","@Override public boolean poll(){
  ClusterReport toReport=null;
synchronized (currentReport) {
    if (!reported) {
      if (leftStepsNum == 0) {
        currentReport.setProgress(endProgress);
      }
 else {
        int currentProgress=currentReport.getProgress();
        int toProgress=currentProgress + (endProgress - currentProgress) / leftStepsNum;
        currentReport.setProgress(toProgress > endProgress ? endProgress : toProgress);
        leftStepsNum-=1;
      }
      toReport=currentReport.clone();
      reported=true;
    }
  }
  if (toReport != null) {
    logger.info(""String_Node_Str"" + toReport.getProgress() + ""String_Node_Str""+ toReport.getAction());
    reportQueue.addClusterReport(toReport);
  }
  if (rootResource.getCommandsResource().readCommand(parentCmdId).getEndTime() != null) {
    running=false;
    executor.shutdown();
    return true;
  }
  return false;
}"
48605,"public void validateGroupConfig(ClusterBlueprint blueprint,List<String> failedMsgList,List<String> warningMsgList){
  List<NodeGroupInfo> nodeGroups=blueprint.getNodeGroups();
  boolean namenodeHACheck=false;
  int masterCount=0, jobtrackerCount=0, resourcemanagerCount=0, hbasemasterCount=0, zookeeperCount=0, workerCount=0, numOfJournalNode=0;
  for (  NodeGroupInfo nodeGroup : nodeGroups) {
    List<NodeGroupRole> groupRoles=getNodeGroupRoles(nodeGroup);
    if (groupRoles != null) {
      for (      NodeGroupRole role : groupRoles) {
switch (role) {
case MASTER:
          masterCount++;
        int numOfInstance=nodeGroup.getInstanceNum();
      if (numOfInstance >= 0 && numOfInstance != 1) {
        if (numOfInstance != 2) {
          collectInstanceNumInvalidateMsg(nodeGroup,failedMsgList);
        }
 else {
          namenodeHACheck=true;
        }
      }
    break;
case JOB_TRACKER:
  jobtrackerCount++;
if (nodeGroup.getInstanceNum() >= 0 && nodeGroup.getInstanceNum() != 1) {
  failedMsgList.add(Constants.WRONG_NUM_OF_JOBTRACKER);
}
break;
case RESOURCEMANAGER:
resourcemanagerCount++;
if (nodeGroup.getInstanceNum() >= 0 && nodeGroup.getInstanceNum() != 1) {
failedMsgList.add(Constants.WRONG_NUM_OF_RESOURCEMANAGER);
}
break;
case HBASE_MASTER:
hbasemasterCount++;
if (nodeGroup.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroup,failedMsgList);
}
break;
case ZOOKEEPER:
zookeeperCount++;
if (nodeGroup.getInstanceNum() > 0 && nodeGroup.getInstanceNum() < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_ZOOKEEPER);
}
 else if (nodeGroup.getInstanceNum() > 0 && nodeGroup.getInstanceNum() % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_ZOOKEEPER);
}
break;
case JOURNAL_NODE:
numOfJournalNode+=nodeGroup.getInstanceNum();
if (nodeGroup.getRoles().contains(HadoopRole.HADOOP_DATANODE.toString()) || nodeGroup.getRoles().contains(HadoopRole.HADOOP_CLIENT_ROLE.toString())) {
failedMsgList.add(Constants.DATA_CLIENT_NODE_JOURNALNODE_COEXIST);
}
break;
case WORKER:
workerCount++;
if (nodeGroup.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroup,failedMsgList);
}
 else if (nodeGroup.isHaEnabled()) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
List<String> roles=nodeGroup.getRoles();
if (roles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString()) && !roles.contains(HadoopRole.HADOOP_DATANODE.toString())) {
warningMsgList.add(Constants.REGISONSERVER_DATANODE_SEPERATION);
}
break;
case CLIENT:
if (nodeGroup.isHaEnabled()) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
break;
case NONE:
break;
default :
break;
}
}
}
if (!supportedWithHdfs2(blueprint)) {
if (namenodeHACheck || masterCount > 1) {
failedMsgList.add(Constants.CURRENT_DISTRO_CAN_NOT_SUPPORT_HDFS2);
}
}
 else if (namenodeHACheck) {
if (numOfJournalNode >= 0 && numOfJournalNode < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_JOURNALNODE);
}
 else if (numOfJournalNode > 0 && numOfJournalNode % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_JOURNALNODE);
}
if (zookeeperCount == 0) {
failedMsgList.add(Constants.NAMENODE_AUTO_FAILOVER_ZOOKEEPER);
}
}
if ((jobtrackerCount > 1) || (resourcemanagerCount > 1) || (zookeeperCount > 1)|| (hbasemasterCount > 1)) {
failedMsgList.add(Constants.WRONG_NUM_OF_NODEGROUPS);
}
if (numOfJournalNode > 0 && !namenodeHACheck) {
failedMsgList.add(Constants.NO_NAMENODE_HA);
}
}
if (!warningMsgList.isEmpty() && !warningMsgList.get(0).startsWith(""String_Node_Str"")) {
warningMsgList.set(0,""String_Node_Str"" + warningMsgList.get(0));
}
}","public void validateGroupConfig(ClusterBlueprint blueprint,List<String> failedMsgList,List<String> warningMsgList){
  List<NodeGroupInfo> nodeGroups=blueprint.getNodeGroups();
  boolean namenodeHACheck=false;
  int masterCount=0, jobtrackerCount=0, resourcemanagerCount=0, hbasemasterCount=0, zookeeperCount=0, workerCount=0, numOfJournalNode=0;
  for (  NodeGroupInfo nodeGroup : nodeGroups) {
    List<NodeGroupRole> groupRoles=getNodeGroupRoles(nodeGroup);
    if (groupRoles != null) {
      for (      NodeGroupRole role : groupRoles) {
switch (role) {
case MASTER:
          masterCount++;
        int numOfInstance=nodeGroup.getInstanceNum();
      if (numOfInstance >= 0 && numOfInstance != 1) {
        if (numOfInstance != 2) {
          collectInstanceNumInvalidateMsg(nodeGroup,failedMsgList);
        }
 else {
          namenodeHACheck=true;
        }
      }
    break;
case JOB_TRACKER:
  jobtrackerCount++;
if (nodeGroup.getInstanceNum() >= 0 && nodeGroup.getInstanceNum() != 1) {
  failedMsgList.add(Constants.WRONG_NUM_OF_JOBTRACKER);
}
break;
case RESOURCEMANAGER:
resourcemanagerCount++;
if (nodeGroup.getInstanceNum() >= 0 && nodeGroup.getInstanceNum() != 1) {
failedMsgList.add(Constants.WRONG_NUM_OF_RESOURCEMANAGER);
}
break;
case HBASE_MASTER:
hbasemasterCount++;
if (nodeGroup.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroup,failedMsgList);
}
break;
case ZOOKEEPER:
zookeeperCount++;
if (nodeGroup.getInstanceNum() > 0 && nodeGroup.getInstanceNum() < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_ZOOKEEPER);
}
 else if (nodeGroup.getInstanceNum() > 0 && nodeGroup.getInstanceNum() % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_ZOOKEEPER);
}
break;
case JOURNAL_NODE:
numOfJournalNode+=nodeGroup.getInstanceNum();
if (nodeGroup.getRoles().contains(HadoopRole.HADOOP_DATANODE.toString()) || nodeGroup.getRoles().contains(HadoopRole.HADOOP_CLIENT_ROLE.toString())) {
failedMsgList.add(Constants.DATA_CLIENT_NODE_JOURNALNODE_COEXIST);
}
break;
case WORKER:
workerCount++;
if (nodeGroup.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroup,failedMsgList);
}
 else if (nodeGroup.isHaEnabled()) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
List<String> roles=nodeGroup.getRoles();
if (roles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString()) && !roles.contains(HadoopRole.HADOOP_DATANODE.toString())) {
warningMsgList.add(Constants.REGISONSERVER_DATANODE_SEPERATION);
}
break;
case CLIENT:
if (nodeGroup.isHaEnabled()) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
break;
case NONE:
break;
default :
break;
}
}
}
}
if (!supportedWithHdfs2(blueprint)) {
if (namenodeHACheck || masterCount > 1) {
failedMsgList.add(Constants.CURRENT_DISTRO_CAN_NOT_SUPPORT_HDFS2);
}
}
 else if (namenodeHACheck) {
if (numOfJournalNode >= 0 && numOfJournalNode < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_JOURNALNODE);
}
 else if (numOfJournalNode > 0 && numOfJournalNode % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_JOURNALNODE);
}
if (zookeeperCount == 0) {
failedMsgList.add(Constants.NAMENODE_AUTO_FAILOVER_ZOOKEEPER);
}
}
if ((jobtrackerCount > 1) || (resourcemanagerCount > 1) || (zookeeperCount > 1)|| (hbasemasterCount > 1)) {
failedMsgList.add(Constants.WRONG_NUM_OF_NODEGROUPS);
}
if (numOfJournalNode > 0 && !namenodeHACheck) {
failedMsgList.add(Constants.NO_NAMENODE_HA);
}
if (!warningMsgList.isEmpty() && !warningMsgList.get(0).startsWith(""String_Node_Str"")) {
warningMsgList.set(0,""String_Node_Str"" + warningMsgList.get(0));
}
}"
48606,"@Transactional public void updateAppConfig(String clusterName,ClusterCreate clusterCreate){
  logger.debug(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  SoftwareManager softwareManager=softwareManagerCollector.getSoftwareManager(cluster.getAppManager());
  if (softwareManager == null) {
    logger.error(""String_Node_Str"");
    throw new ClusterConfigException(null,""String_Node_Str"");
  }
  ClusterBlueprint blueprint=clusterCreate.toBlueprint();
  DistroRead distro=null;
  if (Constants.IRONFAN.equalsIgnoreCase(clusterCreate.getAppManager())) {
    distro=distroMgr.getDistroByName(cluster.getDistro());
  }
 else {
    distro=distroMgr.getDistroByName(clusterCreate.getAppManager(),cluster.getDistro());
  }
  try {
    softwareManager.validateBlueprint(blueprint,distro.getRoles());
  }
 catch (  ValidationException e) {
    throw new ClusterConfigException(e,e.getMessage() + e.getFailedMsgList().toString());
  }
  updateInfrastructure(clusterCreate,softwareManager,blueprint);
  Map<String,Object> clusterLevelConfig=clusterCreate.getConfiguration();
  if (clusterLevelConfig != null && clusterLevelConfig.size() > 0) {
    logger.debug(""String_Node_Str"");
    cluster.setHadoopConfig((new Gson()).toJson(clusterLevelConfig));
    updateVhmJobTrackerPort(clusterCreate,cluster);
  }
 else {
    logger.debug(""String_Node_Str"");
    cluster.setHadoopConfig(null);
  }
  updateNodegroupAppConfig(clusterCreate,cluster,clusterCreate.isValidateConfig());
}","@Transactional public void updateAppConfig(String clusterName,ClusterCreate clusterCreate){
  logger.debug(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  SoftwareManager softwareManager=softwareManagerCollector.getSoftwareManager(cluster.getAppManager());
  if (softwareManager == null) {
    logger.error(""String_Node_Str"");
    throw new ClusterConfigException(null,""String_Node_Str"");
  }
  clusterCreate.setDistro(cluster.getDistro());
  clusterCreate.setDistroVersion(cluster.getDistroVersion());
  ClusterBlueprint blueprint=clusterCreate.toBlueprint();
  DistroRead distro=null;
  if (Constants.IRONFAN.equalsIgnoreCase(cluster.getAppManager())) {
    distro=distroMgr.getDistroByName(cluster.getDistro());
  }
 else {
    distro=distroMgr.getDistroByName(cluster.getAppManager(),cluster.getDistro());
  }
  try {
    softwareManager.validateBlueprint(blueprint,distro.getRoles());
  }
 catch (  ValidationException e) {
    throw new ClusterConfigException(e,e.getMessage() + e.getFailedMsgList().toString());
  }
  updateInfrastructure(clusterCreate,softwareManager,blueprint);
  Map<String,Object> clusterLevelConfig=clusterCreate.getConfiguration();
  if (clusterLevelConfig != null && clusterLevelConfig.size() > 0) {
    logger.debug(""String_Node_Str"");
    cluster.setHadoopConfig((new Gson()).toJson(clusterLevelConfig));
    updateVhmJobTrackerPort(clusterCreate,cluster);
  }
 else {
    logger.debug(""String_Node_Str"");
    cluster.setHadoopConfig(null);
  }
  updateNodegroupAppConfig(clusterCreate,cluster,clusterCreate.isValidateConfig());
}"
48607,"@Override public void syncUp(String clusterName){
  StatusSyncUpRequest request=new StatusSyncUpRequest(clusterName,lockedEntityManager,softwareManagerCollector,this,WorkQueue.CUSTOM_FIVE_MIN_SYNC_DELAY);
  CmsWorker.addPeriodic(request);
  inQueueCluster.add(clusterName);
}","@Override public void syncUp(String clusterName){
  requestQueue.add(clusterName);
}"
48608,"@Override public void afterPropertiesSet() throws Exception {
  List<ClusterEntity> clusters=lockedEntityManager.getClusterEntityMgr().findAllClusters();
  for (  ClusterEntity cluster : clusters) {
    syncUp(cluster.getName());
    logger.info(""String_Node_Str"" + cluster.getName());
  }
}","@Override public void afterPropertiesSet() throws Exception {
  List<ClusterEntity> clusters=lockedEntityManager.getClusterEntityMgr().findAllClusters();
  for (  ClusterEntity cluster : clusters) {
    requestQueue.add(cluster.getName());
    logger.info(""String_Node_Str"" + cluster.getName());
  }
  syncupTimer=new Timer(SERVICE_SYNCUP_THREAD_NAME,true);
  StatusSyncUpTask task=new StatusSyncUpTask(lockedEntityManager,softwareManagerCollector,requestQueue);
  syncupTimer.schedule(task,SYNCUP_INTERVAL_MILLISECONDS);
}"
48609,"@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String targetName=getJobParameters(chunkContext).getString(JobConstants.TARGET_NAME_JOB_PARAM);
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  if (targetName == null) {
    targetName=clusterName;
  }
  String jobName=chunkContext.getStepContext().getJobName();
  logger.info(""String_Node_Str"" + targetName + ""String_Node_Str""+ managementOperation+ ""String_Node_Str""+ jobName);
  if (!serviceSyncup.isClusterInQueue(clusterName)) {
    serviceSyncup.syncUp(clusterName);
    logger.info(""String_Node_Str"" + clusterName);
  }
  boolean vmPowerOn=false;
  String vmPowerOnStr=getJobParameters(chunkContext).getString(JobConstants.IS_VM_POWER_ON);
  if (vmPowerOnStr != null) {
    logger.info(""String_Node_Str"" + vmPowerOnStr);
    vmPowerOn=Boolean.parseBoolean(vmPowerOnStr);
  }
  if (checkVMStatus && targetName.split(""String_Node_Str"").length == 3 && !vmPowerOn) {
    return RepeatStatus.FINISHED;
  }
  SoftwareManager softwareMgr=softwareMgrs.getSoftwareManagerByClusterName(clusterName);
  if (ManagementOperation.CONFIGURE.equals(managementOperation) || JobConstants.RESUME_CLUSTER_JOB_NAME.equals(jobName)) {
    logger.info(""String_Node_Str"");
    List<NodeEntity> nodes=lockClusterEntityMgr.getClusterEntityMgr().findAllNodes(clusterName);
    Set<String> hostnames=new HashSet<String>();
    for (    NodeEntity node : nodes) {
      hostnames.add(node.getHostName());
    }
    ClusterCreate clusterSpec=clusterManager.getClusterSpec(clusterName);
    SyncHostsUtils.SyncHosts(clusterSpec,hostnames,softwareMgr);
  }
  StatusUpdater statusUpdater=new DefaultStatusUpdater(jobExecutionStatusHolder,getJobExecutionId(chunkContext));
  ISoftwareManagementTask task=null;
  if (!Constants.IRONFAN.equals(softwareMgr.getName())) {
    task=createExternalTask(chunkContext,targetName,clusterName,statusUpdater);
  }
 else {
    task=createThriftTask(chunkContext,targetName,statusUpdater);
  }
  if (task != null) {
    Map<String,Object> ret=task.call();
    if (!(Boolean)ret.get(""String_Node_Str"")) {
      String errorMessage=(String)ret.get(""String_Node_Str"");
      putIntoJobExecutionContext(chunkContext,JobConstants.CURRENT_ERROR_MESSAGE,errorMessage);
      throw TaskException.EXECUTION_FAILED(errorMessage);
    }
  }
  return RepeatStatus.FINISHED;
}","@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String targetName=getJobParameters(chunkContext).getString(JobConstants.TARGET_NAME_JOB_PARAM);
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  if (targetName == null) {
    targetName=clusterName;
  }
  String jobName=chunkContext.getStepContext().getJobName();
  logger.info(""String_Node_Str"" + targetName + ""String_Node_Str""+ managementOperation+ ""String_Node_Str""+ jobName);
  serviceSyncup.syncUp(clusterName);
  logger.debug(""String_Node_Str"" + clusterName);
  boolean vmPowerOn=false;
  String vmPowerOnStr=getJobParameters(chunkContext).getString(JobConstants.IS_VM_POWER_ON);
  if (vmPowerOnStr != null) {
    logger.info(""String_Node_Str"" + vmPowerOnStr);
    vmPowerOn=Boolean.parseBoolean(vmPowerOnStr);
  }
  if (checkVMStatus && targetName.split(""String_Node_Str"").length == 3 && !vmPowerOn) {
    return RepeatStatus.FINISHED;
  }
  SoftwareManager softwareMgr=softwareMgrs.getSoftwareManagerByClusterName(clusterName);
  if (ManagementOperation.CONFIGURE.equals(managementOperation) || JobConstants.RESUME_CLUSTER_JOB_NAME.equals(jobName)) {
    logger.info(""String_Node_Str"");
    List<NodeEntity> nodes=lockClusterEntityMgr.getClusterEntityMgr().findAllNodes(clusterName);
    Set<String> hostnames=new HashSet<String>();
    for (    NodeEntity node : nodes) {
      hostnames.add(node.getHostName());
    }
    ClusterCreate clusterSpec=clusterManager.getClusterSpec(clusterName);
    SyncHostsUtils.SyncHosts(clusterSpec,hostnames,softwareMgr);
  }
  StatusUpdater statusUpdater=new DefaultStatusUpdater(jobExecutionStatusHolder,getJobExecutionId(chunkContext));
  ISoftwareManagementTask task=null;
  if (!Constants.IRONFAN.equals(softwareMgr.getName())) {
    task=createExternalTask(chunkContext,targetName,clusterName,statusUpdater);
  }
 else {
    task=createThriftTask(chunkContext,targetName,statusUpdater);
  }
  if (task != null) {
    Map<String,Object> ret=task.call();
    if (!(Boolean)ret.get(""String_Node_Str"")) {
      String errorMessage=(String)ret.get(""String_Node_Str"");
      putIntoJobExecutionContext(chunkContext,JobConstants.CURRENT_ERROR_MESSAGE,errorMessage);
      throw TaskException.EXECUTION_FAILED(errorMessage);
    }
  }
  return RepeatStatus.FINISHED;
}"
48610,"@Override public Set<String> getSupportedRoles() throws SoftwareManagementPluginException {
  return null;
}","@Override public Set<String> getSupportedRoles(HadoopStack hadoopStack) throws SoftwareManagementPluginException {
  return null;
}"
48611,"@Override public List<HadoopStack> getSupportedStacks() throws SoftwareManagementPluginException {
  List<HadoopStack> hadoopStacks=new ArrayList<HadoopStack>();
  ApiStackList stackList=apiManager.stackList();
  for (  ApiStack apiStack : stackList.getApiStacks()) {
    for (    ApiStackVersion apiStackVersionSummary : apiManager.stackVersionList(apiStack.getApiStackName().getStackName()).getApiStackVersions()) {
      ApiStackVersionInfo apiStackVersionInfoSummary=apiStackVersionSummary.getApiStackVersionInfo();
      ApiStackVersion apiStackVersion=apiManager.stackVersion(apiStackVersionInfoSummary.getStackName(),apiStackVersionInfoSummary.getStackVersion());
      ApiStackVersionInfo apiStackVersionInfo=apiStackVersion.getApiStackVersionInfo();
      if (apiStackVersionInfo.isActive()) {
        HadoopStack hadoopStack=new HadoopStack();
        hadoopStack.setDistroName(apiStackVersionInfo.getStackName(),apiStackVersionInfo.getStackVersion());
        hadoopStack.setFullVersion(apiStackVersionInfo.getStackVersion());
        hadoopStack.setVendor(apiStackVersionInfo.getStackName());
        hadoopStacks.add(hadoopStack);
      }
    }
  }
  return hadoopStacks;
}","@Override public List<HadoopStack> getSupportedStacks() throws SoftwareManagementPluginException {
  List<HadoopStack> hadoopStacks=new ArrayList<HadoopStack>();
  ApiStackList stackList=apiManager.stackList();
  for (  ApiStack apiStack : stackList.getApiStacks()) {
    for (    ApiStackVersion apiStackVersionSummary : apiManager.stackVersionList(apiStack.getApiStackName().getStackName()).getApiStackVersions()) {
      ApiStackVersionInfo apiStackVersionInfoSummary=apiStackVersionSummary.getApiStackVersionInfo();
      ApiStackVersion apiStackVersion=apiManager.stackVersion(apiStackVersionInfoSummary.getStackName(),apiStackVersionInfoSummary.getStackVersion());
      ApiStackVersionInfo apiStackVersionInfo=apiStackVersion.getApiStackVersionInfo();
      if (apiStackVersionInfo.isActive()) {
        HadoopStack hadoopStack=new HadoopStack();
        hadoopStack.setDistro(apiStackVersionInfo.getStackName(),apiStackVersionInfo.getStackVersion());
        hadoopStack.setFullVersion(apiStackVersionInfo.getStackVersion());
        hadoopStack.setVendor(apiStackVersionInfo.getStackName());
        hadoopStacks.add(hadoopStack);
      }
    }
  }
  return hadoopStacks;
}"
48612,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void addAppManager(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String description,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String url,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String username,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String password,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String path){
  try {
    AppManagerAdd appManagerAdd=new AppManagerAdd();
    appManagerAdd.setName(name);
    appManagerAdd.setDescription(description);
    appManagerAdd.setType(type);
    appManagerAdd.setUrl(url);
    appManagerAdd.setUsername(username);
    appManagerAdd.setPassword(password);
    appManagerAdd.setSslCertificate(CommandsUtils.dataFromFile(path));
    restClient.add(appManagerAdd);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_RESULT_ADD);
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void addAppManager(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String description,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String url,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String username,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String password,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String path){
  try {
    AppManagerAdd appManagerAdd=new AppManagerAdd();
    appManagerAdd.setName(name);
    appManagerAdd.setDescription(description);
    appManagerAdd.setType(type);
    appManagerAdd.setUrl(url);
    appManagerAdd.setUsername(username);
    appManagerAdd.setPassword(password);
    appManagerAdd.setSslCertificate(CommandsUtils.dataFromFile(path));
    restClient.add(appManagerAdd);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_RESULT_ADD);
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_APPMANAGER,name,Constants.OUTPUT_OP_ADD,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}"
48613,"@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String targetName=getJobParameters(chunkContext).getString(JobConstants.TARGET_NAME_JOB_PARAM);
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  if (targetName == null) {
    targetName=clusterName;
  }
  String jobName=chunkContext.getStepContext().getJobName();
  logger.info(""String_Node_Str"" + targetName + ""String_Node_Str""+ managementOperation+ ""String_Node_Str""+ jobName);
  boolean vmPowerOn=false;
  String vmPowerOnStr=getJobParameters(chunkContext).getString(JobConstants.IS_VM_POWER_ON);
  if (vmPowerOnStr != null) {
    logger.info(""String_Node_Str"" + vmPowerOnStr);
    vmPowerOn=Boolean.parseBoolean(vmPowerOnStr);
  }
  if (checkVMStatus && targetName.split(""String_Node_Str"").length == 3 && !vmPowerOn) {
    return RepeatStatus.FINISHED;
  }
  SoftwareManager softwareMgr=softwareMgrs.getSoftwareManagerByClusterName(clusterName);
  if (ManagementOperation.CONFIGURE.equals(managementOperation) || JobConstants.RESUME_CLUSTER_JOB_NAME.equals(jobName)) {
    logger.info(""String_Node_Str"");
    List<NodeEntity> nodes=lockClusterEntityMgr.getClusterEntityMgr().findAllNodes(clusterName);
    Set<String> hostnames=new HashSet<String>();
    for (    NodeEntity node : nodes) {
      hostnames.add(node.getHostName());
    }
    ClusterCreate clusterSpec=clusterManager.getClusterSpec(clusterName);
    SyncHostsUtils.SyncHosts(clusterSpec,hostnames,softwareMgr);
  }
  StatusUpdater statusUpdater=new DefaultStatusUpdater(jobExecutionStatusHolder,getJobExecutionId(chunkContext));
  ISoftwareManagementTask task=null;
  if (!softwareMgr.getName().equals(Constants.IRONFAN)) {
    task=createExternalTask(chunkContext,targetName,clusterName,statusUpdater);
  }
 else {
    task=createThriftTask(chunkContext,targetName,statusUpdater);
  }
  if (task != null) {
    Map<String,Object> ret=task.call();
    if (!(Boolean)ret.get(""String_Node_Str"")) {
      String errorMessage=(String)ret.get(""String_Node_Str"");
      putIntoJobExecutionContext(chunkContext,JobConstants.CURRENT_ERROR_MESSAGE,errorMessage);
      throw TaskException.EXECUTION_FAILED(errorMessage);
    }
  }
  return RepeatStatus.FINISHED;
}","@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String targetName=getJobParameters(chunkContext).getString(JobConstants.TARGET_NAME_JOB_PARAM);
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  if (targetName == null) {
    targetName=clusterName;
  }
  String jobName=chunkContext.getStepContext().getJobName();
  logger.info(""String_Node_Str"" + targetName + ""String_Node_Str""+ managementOperation+ ""String_Node_Str""+ jobName);
  boolean vmPowerOn=false;
  String vmPowerOnStr=getJobParameters(chunkContext).getString(JobConstants.IS_VM_POWER_ON);
  if (vmPowerOnStr != null) {
    logger.info(""String_Node_Str"" + vmPowerOnStr);
    vmPowerOn=Boolean.parseBoolean(vmPowerOnStr);
  }
  if (checkVMStatus && targetName.split(""String_Node_Str"").length == 3 && !vmPowerOn) {
    return RepeatStatus.FINISHED;
  }
  SoftwareManager softwareMgr=softwareMgrs.getSoftwareManagerByClusterName(clusterName);
  if (ManagementOperation.CONFIGURE.equals(managementOperation) || JobConstants.RESUME_CLUSTER_JOB_NAME.equals(jobName)) {
    logger.info(""String_Node_Str"");
    List<NodeEntity> nodes=lockClusterEntityMgr.getClusterEntityMgr().findAllNodes(clusterName);
    Set<String> hostnames=new HashSet<String>();
    for (    NodeEntity node : nodes) {
      hostnames.add(node.getHostName());
    }
    ClusterCreate clusterSpec=clusterManager.getClusterSpec(clusterName);
    SyncHostsUtils.SyncHosts(clusterSpec,hostnames,softwareMgr);
  }
  StatusUpdater statusUpdater=new DefaultStatusUpdater(jobExecutionStatusHolder,getJobExecutionId(chunkContext));
  ISoftwareManagementTask task=null;
  if (!Constants.IRONFAN.equals(softwareMgr.getName())) {
    task=createExternalTask(chunkContext,targetName,clusterName,statusUpdater);
  }
 else {
    task=createThriftTask(chunkContext,targetName,statusUpdater);
  }
  if (task != null) {
    Map<String,Object> ret=task.call();
    if (!(Boolean)ret.get(""String_Node_Str"")) {
      String errorMessage=(String)ret.get(""String_Node_Str"");
      putIntoJobExecutionContext(chunkContext,JobConstants.CURRENT_ERROR_MESSAGE,errorMessage);
      throw TaskException.EXECUTION_FAILED(errorMessage);
    }
  }
  return RepeatStatus.FINISHED;
}"
48614,"@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String targetName=getJobParameters(chunkContext).getString(JobConstants.TARGET_NAME_JOB_PARAM);
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  if (targetName == null) {
    targetName=clusterName;
  }
  String jobName=chunkContext.getStepContext().getJobName();
  logger.info(""String_Node_Str"" + targetName + ""String_Node_Str""+ managementOperation+ ""String_Node_Str""+ jobName);
  boolean vmPowerOn=false;
  String vmPowerOnStr=getJobParameters(chunkContext).getString(JobConstants.IS_VM_POWER_ON);
  if (vmPowerOnStr != null) {
    logger.info(""String_Node_Str"" + vmPowerOnStr);
    vmPowerOn=Boolean.parseBoolean(vmPowerOnStr);
  }
  if (checkVMStatus && targetName.split(""String_Node_Str"").length == 3 && !vmPowerOn) {
    return RepeatStatus.FINISHED;
  }
  ClusterCreate clusterSpec=clusterManager.getClusterSpec(clusterName);
  if (ManagementOperation.CONFIGURE.equals(managementOperation) || JobConstants.RESUME_CLUSTER_JOB_NAME.equals(jobName)) {
    logger.info(""String_Node_Str"");
    List<NodeEntity> nodes=lockClusterEntityMgr.getClusterEntityMgr().findAllNodes(clusterName);
    Set<String> hostnames=new HashSet<String>();
    for (    NodeEntity node : nodes) {
      hostnames.add(node.getHostName());
    }
    SyncHostsUtils.SyncHosts(clusterSpec,hostnames);
  }
  StatusUpdater statusUpdater=new DefaultStatusUpdater(jobExecutionStatusHolder,getJobExecutionId(chunkContext));
  ISoftwareManagementTask task=null;
  if (!CommonUtil.isBlank(clusterSpec.getAppManager())) {
    SoftwareManager softwareMgr=softwareMgrs.getSoftwareManager(clusterSpec.getAppManager());
    ClusterBlueprint clusterBlueprint=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_BLUEPRINT_JOB_PARAM,ClusterBlueprint.class);
    if (clusterBlueprint == null) {
      clusterBlueprint=lockClusterEntityMgr.getClusterEntityMgr().toClusterBluePrint(clusterName);
      putIntoJobExecutionContext(chunkContext,JobConstants.CLUSTER_BLUEPRINT_JOB_PARAM,clusterBlueprint);
    }
    task=SoftwareManagementTaskFactory.createExternalMgtTask(targetName,managementOperation,clusterBlueprint,statusUpdater,lockClusterEntityMgr,softwareMgr);
  }
 else {
    File workDir=CommandUtil.createWorkDir(getJobExecutionId(chunkContext));
    putIntoJobExecutionContext(chunkContext,JobConstants.CURRENT_COMMAND_WORK_DIR,workDir.getAbsolutePath());
    boolean needAllocIp=true;
    if (ManagementOperation.DESTROY.equals(managementOperation)) {
      needAllocIp=false;
    }
    String specFilePath=null;
    if (managementOperation.ordinal() != ManagementOperation.DESTROY.ordinal()) {
      File specFile=clusterManager.writeClusterSpecFile(targetName,workDir,needAllocIp);
      specFilePath=specFile.getAbsolutePath();
    }
    task=SoftwareManagementTaskFactory.createThriftTask(targetName,specFilePath,statusUpdater,managementOperation,lockClusterEntityMgr);
  }
  if (task != null) {
    Map<String,Object> ret=task.call();
    if (!(Boolean)ret.get(""String_Node_Str"")) {
      String errorMessage=(String)ret.get(""String_Node_Str"");
      putIntoJobExecutionContext(chunkContext,JobConstants.CURRENT_ERROR_MESSAGE,errorMessage);
      throw TaskException.EXECUTION_FAILED(errorMessage);
    }
  }
  return RepeatStatus.FINISHED;
}","@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String targetName=getJobParameters(chunkContext).getString(JobConstants.TARGET_NAME_JOB_PARAM);
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  if (targetName == null) {
    targetName=clusterName;
  }
  String jobName=chunkContext.getStepContext().getJobName();
  logger.info(""String_Node_Str"" + targetName + ""String_Node_Str""+ managementOperation+ ""String_Node_Str""+ jobName);
  boolean vmPowerOn=false;
  String vmPowerOnStr=getJobParameters(chunkContext).getString(JobConstants.IS_VM_POWER_ON);
  if (vmPowerOnStr != null) {
    logger.info(""String_Node_Str"" + vmPowerOnStr);
    vmPowerOn=Boolean.parseBoolean(vmPowerOnStr);
  }
  if (checkVMStatus && targetName.split(""String_Node_Str"").length == 3 && !vmPowerOn) {
    return RepeatStatus.FINISHED;
  }
  ClusterCreate clusterSpec=clusterManager.getClusterSpec(clusterName);
  if (ManagementOperation.CONFIGURE.equals(managementOperation) || JobConstants.RESUME_CLUSTER_JOB_NAME.equals(jobName)) {
    logger.info(""String_Node_Str"");
    List<NodeEntity> nodes=lockClusterEntityMgr.getClusterEntityMgr().findAllNodes(clusterName);
    Set<String> hostnames=new HashSet<String>();
    for (    NodeEntity node : nodes) {
      hostnames.add(node.getHostName());
    }
    SyncHostsUtils.SyncHosts(clusterSpec,hostnames);
  }
  StatusUpdater statusUpdater=new DefaultStatusUpdater(jobExecutionStatusHolder,getJobExecutionId(chunkContext));
  ISoftwareManagementTask task=null;
  if (!CommonUtil.isBlank(clusterSpec.getAppManager()) && !Constants.IRONFAN.equalsIgnoreCase(clusterSpec.getAppManager())) {
    SoftwareManager softwareMgr=softwareMgrs.getSoftwareManager(clusterSpec.getAppManager());
    ClusterBlueprint clusterBlueprint=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_BLUEPRINT_JOB_PARAM,ClusterBlueprint.class);
    if (clusterBlueprint == null) {
      clusterBlueprint=lockClusterEntityMgr.getClusterEntityMgr().toClusterBluePrint(clusterName);
      putIntoJobExecutionContext(chunkContext,JobConstants.CLUSTER_BLUEPRINT_JOB_PARAM,clusterBlueprint);
    }
    task=SoftwareManagementTaskFactory.createExternalMgtTask(targetName,managementOperation,clusterBlueprint,statusUpdater,lockClusterEntityMgr,softwareMgr);
  }
 else {
    File workDir=CommandUtil.createWorkDir(getJobExecutionId(chunkContext));
    putIntoJobExecutionContext(chunkContext,JobConstants.CURRENT_COMMAND_WORK_DIR,workDir.getAbsolutePath());
    boolean needAllocIp=true;
    if (ManagementOperation.DESTROY.equals(managementOperation)) {
      needAllocIp=false;
    }
    String specFilePath=null;
    if (managementOperation.ordinal() != ManagementOperation.DESTROY.ordinal()) {
      File specFile=clusterManager.writeClusterSpecFile(targetName,workDir,needAllocIp);
      specFilePath=specFile.getAbsolutePath();
    }
    task=SoftwareManagementTaskFactory.createThriftTask(targetName,specFilePath,statusUpdater,managementOperation,lockClusterEntityMgr);
  }
  if (task != null) {
    Map<String,Object> ret=task.call();
    if (!(Boolean)ret.get(""String_Node_Str"")) {
      String errorMessage=(String)ret.get(""String_Node_Str"");
      putIntoJobExecutionContext(chunkContext,JobConstants.CURRENT_ERROR_MESSAGE,errorMessage);
      throw TaskException.EXECUTION_FAILED(errorMessage);
    }
  }
  return RepeatStatus.FINISHED;
}"
48615,"@SuppressWarnings(""String_Node_Str"") private NodeGroupCreate convertNodeGroups(ClusterEntity clusterEntity,NodeGroupEntity ngEntity,String clusterName){
  Gson gson=new Gson();
  List<String> groupRoles=gson.fromJson(ngEntity.getRoles(),List.class);
  String distro=clusterEntity.getDistro();
  NodeGroupCreate group=new NodeGroupCreate();
  group.setName(ngEntity.getName());
  EnumSet<HadoopRole> enumRoles=null;
  if (clusterEntity.getAppManager() == null) {
    enumRoles=getEnumRoles(groupRoles,distro);
    if (enumRoles.isEmpty()) {
      throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(ngEntity.getName());
    }
    GroupType groupType=GroupType.fromHadoopRole(enumRoles);
    AuAssert.check(groupType != null);
    group.setGroupType(groupType);
  }
  group.setRoles(groupRoles);
  int cpu=ngEntity.getCpuNum();
  if (cpu > 0) {
    group.setCpuNum(cpu);
  }
  int memory=ngEntity.getMemorySize();
  if (memory > 0) {
    group.setMemCapacityMB(memory);
  }
  Float swapRatio=ngEntity.getSwapRatio();
  if (swapRatio != null && swapRatio > 0) {
    group.setSwapRatio(swapRatio);
  }
  if (ngEntity.getNodeType() != null) {
    group.setInstanceType(ngEntity.getNodeType());
  }
  group.setInstanceNum(ngEntity.getDefineInstanceNum());
  Integer instancePerHost=ngEntity.getInstancePerHost();
  Set<NodeGroupAssociation> associonEntities=ngEntity.getGroupAssociations();
  String ngRacks=ngEntity.getGroupRacks();
  if (instancePerHost == null && (associonEntities == null || associonEntities.isEmpty()) && ngRacks == null) {
    group.setPlacementPolicies(null);
  }
 else {
    PlacementPolicy policies=new PlacementPolicy();
    policies.setInstancePerHost(instancePerHost);
    if (ngRacks != null) {
      policies.setGroupRacks((GroupRacks)new Gson().fromJson(ngRacks,GroupRacks.class));
    }
    if (associonEntities != null) {
      List<GroupAssociation> associons=new ArrayList<GroupAssociation>(associonEntities.size());
      for (      NodeGroupAssociation ae : associonEntities) {
        GroupAssociation a=new GroupAssociation();
        a.setReference(ae.getReferencedGroup());
        a.setType(ae.getAssociationType());
        associons.add(a);
      }
      policies.setGroupAssociations(associons);
    }
    group.setPlacementPolicies(policies);
  }
  String rps=ngEntity.getVcRpNames();
  if (rps != null && rps.length() > 0) {
    logger.debug(""String_Node_Str"" + ngEntity.getName());
    String[] rpNames=gson.fromJson(rps,String[].class);
    List<VcCluster> vcClusters=rpMgr.getVcResourcePoolByNameList(rpNames);
    group.setVcClusters(vcClusters);
    group.setRpNames(Arrays.asList(rpNames));
  }
  expandGroupStorage(ngEntity,group,enumRoles);
  group.setHaFlag(ngEntity.getHaFlag());
  if (ngEntity.getHadoopConfig() != null) {
    Map<String,Object> hadoopConfig=(new Gson()).fromJson(ngEntity.getHadoopConfig(),Map.class);
    group.setConfiguration(hadoopConfig);
  }
  group.setVmFolderPath(ngEntity.getVmFolderPath());
  return group;
}","@SuppressWarnings(""String_Node_Str"") private NodeGroupCreate convertNodeGroups(ClusterEntity clusterEntity,NodeGroupEntity ngEntity,String clusterName){
  Gson gson=new Gson();
  List<String> groupRoles=gson.fromJson(ngEntity.getRoles(),List.class);
  String distro=clusterEntity.getDistro();
  NodeGroupCreate group=new NodeGroupCreate();
  group.setName(ngEntity.getName());
  EnumSet<HadoopRole> enumRoles=null;
  if (clusterEntity.getAppManager() == null || Constants.IRONFAN.equalsIgnoreCase(clusterEntity.getAppManager())) {
    enumRoles=getEnumRoles(groupRoles,distro);
    if (enumRoles.isEmpty()) {
      throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(ngEntity.getName());
    }
    GroupType groupType=GroupType.fromHadoopRole(enumRoles);
    AuAssert.check(groupType != null);
    group.setGroupType(groupType);
  }
  group.setRoles(groupRoles);
  int cpu=ngEntity.getCpuNum();
  if (cpu > 0) {
    group.setCpuNum(cpu);
  }
  int memory=ngEntity.getMemorySize();
  if (memory > 0) {
    group.setMemCapacityMB(memory);
  }
  Float swapRatio=ngEntity.getSwapRatio();
  if (swapRatio != null && swapRatio > 0) {
    group.setSwapRatio(swapRatio);
  }
  if (ngEntity.getNodeType() != null) {
    group.setInstanceType(ngEntity.getNodeType());
  }
  group.setInstanceNum(ngEntity.getDefineInstanceNum());
  Integer instancePerHost=ngEntity.getInstancePerHost();
  Set<NodeGroupAssociation> associonEntities=ngEntity.getGroupAssociations();
  String ngRacks=ngEntity.getGroupRacks();
  if (instancePerHost == null && (associonEntities == null || associonEntities.isEmpty()) && ngRacks == null) {
    group.setPlacementPolicies(null);
  }
 else {
    PlacementPolicy policies=new PlacementPolicy();
    policies.setInstancePerHost(instancePerHost);
    if (ngRacks != null) {
      policies.setGroupRacks((GroupRacks)new Gson().fromJson(ngRacks,GroupRacks.class));
    }
    if (associonEntities != null) {
      List<GroupAssociation> associons=new ArrayList<GroupAssociation>(associonEntities.size());
      for (      NodeGroupAssociation ae : associonEntities) {
        GroupAssociation a=new GroupAssociation();
        a.setReference(ae.getReferencedGroup());
        a.setType(ae.getAssociationType());
        associons.add(a);
      }
      policies.setGroupAssociations(associons);
    }
    group.setPlacementPolicies(policies);
  }
  String rps=ngEntity.getVcRpNames();
  if (rps != null && rps.length() > 0) {
    logger.debug(""String_Node_Str"" + ngEntity.getName());
    String[] rpNames=gson.fromJson(rps,String[].class);
    List<VcCluster> vcClusters=rpMgr.getVcResourcePoolByNameList(rpNames);
    group.setVcClusters(vcClusters);
    group.setRpNames(Arrays.asList(rpNames));
  }
  expandGroupStorage(ngEntity,group,enumRoles);
  group.setHaFlag(ngEntity.getHaFlag());
  if (ngEntity.getHadoopConfig() != null) {
    Map<String,Object> hadoopConfig=(new Gson()).fromJson(ngEntity.getHadoopConfig(),Map.class);
    group.setConfiguration(hadoopConfig);
  }
  group.setVmFolderPath(ngEntity.getVmFolderPath());
  return group;
}"
48616,"@Transactional public ClusterEntity createClusterConfig(ClusterCreate cluster){
  String name=cluster.getName();
  if (name == null || name.isEmpty()) {
    throw ClusterConfigException.CLUSTER_NAME_MISSING();
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  DistroRead distro=distroMgr.getDistroByName(cluster.getDistro());
  if (cluster.getDistro() == null || distro == null) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",cluster.getDistro());
  }
  String appManager=cluster.getAppManager();
  if (appManager == null) {
    appManager=new String(""String_Node_Str"");
  }
  SoftwareManager softwareManager=softwareManagerCollector.getSoftwareManager(appManager);
  if (softwareManager == null) {
    logger.error(""String_Node_Str"");
    throw new ClusterConfigException(null,""String_Node_Str"");
  }
  try {
    softwareManager.validateRoles(cluster.toBlueprint(),distro.getRoles());
    cluster.validateClusterCreate(failedMsgList,warningMsgList);
  }
 catch (  SoftwareManagementPluginException e) {
    failedMsgList.add(e.getFailedMsgList().toString());
  }
  if (!failedMsgList.isEmpty()) {
    throw ClusterConfigException.INVALID_SPEC(failedMsgList);
  }
  if (!validateRacksInfo(cluster,failedMsgList)) {
    throw ClusterConfigException.INVALID_PLACEMENT_POLICIES(failedMsgList);
  }
  transformHDFSUrl(cluster);
  try {
    ClusterEntity entity=clusterEntityMgr.findByName(name);
    if (entity != null) {
      logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
      throw BddException.ALREADY_EXISTS(""String_Node_Str"",name);
    }
    logger.debug(""String_Node_Str"" + name);
    Gson gson=new Gson();
    ClusterEntity clusterEntity=new ClusterEntity(name);
    clusterEntity.setAppManager(cluster.getAppManager());
    clusterEntity.setDistro(cluster.getDistro());
    clusterEntity.setDistroVendor(cluster.getDistroVendor());
    clusterEntity.setDistroVersion(cluster.getDistroVersion());
    clusterEntity.setAppManager(cluster.getAppManager());
    clusterEntity.setStartAfterDeploy(true);
    clusterEntity.setPassword(cluster.getPassword());
    clusterEntity.setVersion(clusterEntityMgr.getServerVersion());
    if (cluster.containsComputeOnlyNodeGroups()) {
      clusterEntity.setAutomationEnable(automationEnable);
    }
 else {
      clusterEntity.setAutomationEnable(null);
    }
    clusterEntity.setVhmMinNum(-1);
    clusterEntity.setVhmMaxNum(-1);
    if (cluster.getRpNames() != null && cluster.getRpNames().size() > 0) {
      logger.debug(""String_Node_Str"" + cluster.getRpNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcRpNameList(cluster.getRpNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    if (cluster.getDsNames() != null && !cluster.getDsNames().isEmpty()) {
      logger.debug(""String_Node_Str"" + cluster.getDsNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcDatastoreNameList(cluster.getDsNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    clusterEntity.setNetworkConfig(validateAndConvertNetNamesToNetConfigs(cluster.getNetworkConfig(),cluster.getDistroVendor().equalsIgnoreCase(Constants.MAPR_VENDOR)));
    clusterEntity.setVhmJobTrackerPort(""String_Node_Str"");
    if (cluster.getConfiguration() != null && cluster.getConfiguration().size() > 0) {
      CommonClusterExpandPolicy.validateAppConfig(cluster.getConfiguration(),cluster.isValidateConfig());
      clusterEntity.setHadoopConfig((new Gson()).toJson(cluster.getConfiguration()));
      updateVhmJobTrackerPort(cluster,clusterEntity);
    }
    NodeGroupCreate[] groups=cluster.getNodeGroups();
    if (groups != null && groups.length > 0) {
      clusterEntity.setNodeGroups(convertNodeGroupsToEntities(gson,clusterEntity,cluster.getDistro(),groups,cluster.isValidateConfig()));
      validateMemorySize(clusterEntity.getNodeGroups(),failedMsgList);
      if (!failedMsgList.isEmpty()) {
        throw ClusterConfigException.INVALID_SPEC(failedMsgList);
      }
    }
    if (cluster.getTopologyPolicy() == null) {
      clusterEntity.setTopologyPolicy(TopologyType.NONE);
    }
 else {
      clusterEntity.setTopologyPolicy(cluster.getTopologyPolicy());
    }
    if (clusterEntity.getTopologyPolicy() == TopologyType.HVE) {
      boolean hveSupported=false;
      if (clusterEntity.getDistro() != null) {
        DistroRead dr=distroMgr.getDistroByName(clusterEntity.getDistro());
        if (dr != null) {
          hveSupported=dr.isHveSupported();
        }
      }
      if (!hveSupported) {
        throw ClusterConfigException.INVALID_TOPOLOGY_POLICY(clusterEntity.getTopologyPolicy(),""String_Node_Str"");
      }
    }
    clusterEntityMgr.insert(clusterEntity);
    logger.debug(""String_Node_Str"" + name);
    return clusterEntity;
  }
 catch (  UniqueConstraintViolationException ex) {
    logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
    throw BddException.ALREADY_EXISTS(ex,""String_Node_Str"",name);
  }
}","@Transactional public ClusterEntity createClusterConfig(ClusterCreate cluster){
  String name=cluster.getName();
  if (name == null || name.isEmpty()) {
    throw ClusterConfigException.CLUSTER_NAME_MISSING();
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  DistroRead distro=distroMgr.getDistroByName(cluster.getDistro());
  if (cluster.getDistro() == null || distro == null) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",cluster.getDistro());
  }
  String appManager=cluster.getAppManager();
  if (appManager == null) {
    appManager=new String(""String_Node_Str"");
  }
  SoftwareManager softwareManager=softwareManagerCollector.getSoftwareManager(appManager);
  if (softwareManager == null) {
    logger.error(""String_Node_Str"");
    throw new ClusterConfigException(null,""String_Node_Str"");
  }
  try {
    softwareManager.validateRoles(cluster.toBlueprint(),distro.getRoles());
    cluster.validateClusterCreate(failedMsgList,warningMsgList);
  }
 catch (  SoftwareManagementPluginException e) {
    failedMsgList.add(e.getFailedMsgList().toString());
  }
  if (!failedMsgList.isEmpty()) {
    throw ClusterConfigException.INVALID_SPEC(failedMsgList);
  }
  if (!validateRacksInfo(cluster,failedMsgList)) {
    throw ClusterConfigException.INVALID_PLACEMENT_POLICIES(failedMsgList);
  }
  transformHDFSUrl(cluster);
  try {
    ClusterEntity entity=clusterEntityMgr.findByName(name);
    if (entity != null) {
      logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
      throw BddException.ALREADY_EXISTS(""String_Node_Str"",name);
    }
    logger.debug(""String_Node_Str"" + name);
    Gson gson=new Gson();
    ClusterEntity clusterEntity=new ClusterEntity(name);
    clusterEntity.setAppManager(cluster.getAppManager());
    clusterEntity.setDistro(cluster.getDistro());
    clusterEntity.setDistroVendor(cluster.getDistroVendor());
    clusterEntity.setDistroVersion(cluster.getDistroVersion());
    clusterEntity.setStartAfterDeploy(true);
    clusterEntity.setPassword(cluster.getPassword());
    clusterEntity.setVersion(clusterEntityMgr.getServerVersion());
    if (cluster.containsComputeOnlyNodeGroups()) {
      clusterEntity.setAutomationEnable(automationEnable);
    }
 else {
      clusterEntity.setAutomationEnable(null);
    }
    clusterEntity.setVhmMinNum(-1);
    clusterEntity.setVhmMaxNum(-1);
    if (cluster.getRpNames() != null && cluster.getRpNames().size() > 0) {
      logger.debug(""String_Node_Str"" + cluster.getRpNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcRpNameList(cluster.getRpNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    if (cluster.getDsNames() != null && !cluster.getDsNames().isEmpty()) {
      logger.debug(""String_Node_Str"" + cluster.getDsNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcDatastoreNameList(cluster.getDsNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    clusterEntity.setNetworkConfig(validateAndConvertNetNamesToNetConfigs(cluster.getNetworkConfig(),cluster.getDistroVendor().equalsIgnoreCase(Constants.MAPR_VENDOR)));
    clusterEntity.setVhmJobTrackerPort(""String_Node_Str"");
    if (cluster.getConfiguration() != null && cluster.getConfiguration().size() > 0) {
      CommonClusterExpandPolicy.validateAppConfig(cluster.getConfiguration(),cluster.isValidateConfig());
      clusterEntity.setHadoopConfig((new Gson()).toJson(cluster.getConfiguration()));
      updateVhmJobTrackerPort(cluster,clusterEntity);
    }
    NodeGroupCreate[] groups=cluster.getNodeGroups();
    if (groups != null && groups.length > 0) {
      clusterEntity.setNodeGroups(convertNodeGroupsToEntities(gson,clusterEntity,cluster.getDistro(),groups,cluster.isValidateConfig()));
      validateMemorySize(clusterEntity.getNodeGroups(),failedMsgList);
      if (!failedMsgList.isEmpty()) {
        throw ClusterConfigException.INVALID_SPEC(failedMsgList);
      }
    }
    if (cluster.getTopologyPolicy() == null) {
      clusterEntity.setTopologyPolicy(TopologyType.NONE);
    }
 else {
      clusterEntity.setTopologyPolicy(cluster.getTopologyPolicy());
    }
    if (clusterEntity.getTopologyPolicy() == TopologyType.HVE) {
      boolean hveSupported=false;
      if (clusterEntity.getDistro() != null) {
        DistroRead dr=distroMgr.getDistroByName(clusterEntity.getDistro());
        if (dr != null) {
          hveSupported=dr.isHveSupported();
        }
      }
      if (!hveSupported) {
        throw ClusterConfigException.INVALID_TOPOLOGY_POLICY(clusterEntity.getTopologyPolicy(),""String_Node_Str"");
      }
    }
    clusterEntityMgr.insert(clusterEntity);
    logger.debug(""String_Node_Str"" + name);
    return clusterEntity;
  }
 catch (  UniqueConstraintViolationException ex) {
    logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
    throw BddException.ALREADY_EXISTS(ex,""String_Node_Str"",name);
  }
}"
48617,"@SuppressWarnings(""String_Node_Str"") private void convertClusterConfig(ClusterEntity clusterEntity,ClusterCreate clusterConfig,boolean needAllocIp){
  logger.debug(""String_Node_Str"" + clusterEntity.getName());
  CommonClusterExpandPolicy.expandDistro(clusterEntity,clusterConfig,distroMgr);
  clusterConfig.setDistroVendor(clusterEntity.getDistroVendor());
  clusterConfig.setDistroVersion(clusterEntity.getDistroVersion());
  clusterConfig.setAppManager(clusterEntity.getAppManager());
  clusterConfig.setHttpProxy(httpProxy);
  clusterConfig.setNoProxy(noProxy);
  clusterConfig.setTopologyPolicy(clusterEntity.getTopologyPolicy());
  clusterConfig.setPassword(clusterEntity.getPassword());
  Map<String,String> hostToRackMap=rackInfoMgr.exportHostRackMap();
  if ((clusterConfig.getTopologyPolicy() == TopologyType.RACK_AS_RACK || clusterConfig.getTopologyPolicy() == TopologyType.HVE) && hostToRackMap.isEmpty()) {
    logger.error(""String_Node_Str"");
    throw ClusterConfigException.INVALID_TOPOLOGY_POLICY(clusterConfig.getTopologyPolicy(),""String_Node_Str"");
  }
  clusterConfig.setHostToRackMap(hostToRackMap);
  clusterConfig.setTemplateId(templateId);
  if (clusterEntity.getVcRpNames() != null) {
    logger.debug(""String_Node_Str"");
    String[] rpNames=clusterEntity.getVcRpNameList().toArray(new String[clusterEntity.getVcRpNameList().size()]);
    List<VcCluster> vcClusters=rpMgr.getVcResourcePoolByNameList(rpNames);
    clusterConfig.setVcClusters(vcClusters);
    clusterConfig.setRpNames(clusterEntity.getVcRpNameList());
  }
 else {
    clusterConfig.setVcClusters(rpMgr.getAllVcResourcePool());
    logger.debug(""String_Node_Str"");
  }
  if (clusterEntity.getVcDatastoreNameList() != null) {
    logger.debug(""String_Node_Str"");
    Set<String> sharedPattern=datastoreMgr.getSharedDatastoresByNames(clusterEntity.getVcDatastoreNameList());
    clusterConfig.setSharedDatastorePattern(sharedPattern);
    Set<String> localPattern=datastoreMgr.getLocalDatastoresByNames(clusterEntity.getVcDatastoreNameList());
    clusterConfig.setLocalDatastorePattern(localPattern);
    clusterConfig.setDsNames(clusterEntity.getVcDatastoreNameList());
  }
 else {
    clusterConfig.setSharedDatastorePattern(datastoreMgr.getAllSharedDatastores());
    clusterConfig.setLocalDatastorePattern(datastoreMgr.getAllLocalDatastores());
    logger.debug(""String_Node_Str"");
  }
  List<NodeGroupCreate> nodeGroups=new ArrayList<NodeGroupCreate>();
  Set<NodeGroupEntity> nodeGroupEntities=clusterEntity.getNodeGroups();
  long instanceNum=0;
  for (  NodeGroupEntity ngEntity : nodeGroupEntities) {
    NodeGroupCreate group=convertNodeGroups(clusterEntity,ngEntity,clusterEntity.getName());
    nodeGroups.add(group);
    instanceNum+=group.getInstanceNum();
  }
  if (clusterEntity.getAppManager() == null) {
    sortGroups(nodeGroups);
  }
  clusterConfig.setNodeGroups(nodeGroups.toArray(new NodeGroupCreate[nodeGroups.size()]));
  List<String> networkNames=clusterEntity.fetchNetworkNameList();
  List<NetworkAdd> networkingAdds=allocatNetworkIp(networkNames,clusterEntity,instanceNum,needAllocIp);
  clusterConfig.setNetworkings(networkingAdds);
  clusterConfig.setNetworkConfig(convertNetConfigsToNetNames(clusterEntity.getNetworkConfigInfo()));
  if (clusterEntity.getHadoopConfig() != null) {
    Map<String,Object> hadoopConfig=(new Gson()).fromJson(clusterEntity.getHadoopConfig(),Map.class);
    clusterConfig.setConfiguration(hadoopConfig);
  }
}","@SuppressWarnings(""String_Node_Str"") private void convertClusterConfig(ClusterEntity clusterEntity,ClusterCreate clusterConfig,boolean needAllocIp){
  logger.debug(""String_Node_Str"" + clusterEntity.getName());
  CommonClusterExpandPolicy.expandDistro(clusterEntity,clusterConfig,distroMgr);
  clusterConfig.setDistroVendor(clusterEntity.getDistroVendor());
  clusterConfig.setDistroVersion(clusterEntity.getDistroVersion());
  clusterConfig.setAppManager(clusterEntity.getAppManager());
  clusterConfig.setHttpProxy(httpProxy);
  clusterConfig.setNoProxy(noProxy);
  clusterConfig.setTopologyPolicy(clusterEntity.getTopologyPolicy());
  clusterConfig.setPassword(clusterEntity.getPassword());
  Map<String,String> hostToRackMap=rackInfoMgr.exportHostRackMap();
  if ((clusterConfig.getTopologyPolicy() == TopologyType.RACK_AS_RACK || clusterConfig.getTopologyPolicy() == TopologyType.HVE) && hostToRackMap.isEmpty()) {
    logger.error(""String_Node_Str"");
    throw ClusterConfigException.INVALID_TOPOLOGY_POLICY(clusterConfig.getTopologyPolicy(),""String_Node_Str"");
  }
  clusterConfig.setHostToRackMap(hostToRackMap);
  clusterConfig.setTemplateId(templateId);
  if (clusterEntity.getVcRpNames() != null) {
    logger.debug(""String_Node_Str"");
    String[] rpNames=clusterEntity.getVcRpNameList().toArray(new String[clusterEntity.getVcRpNameList().size()]);
    List<VcCluster> vcClusters=rpMgr.getVcResourcePoolByNameList(rpNames);
    clusterConfig.setVcClusters(vcClusters);
    clusterConfig.setRpNames(clusterEntity.getVcRpNameList());
  }
 else {
    clusterConfig.setVcClusters(rpMgr.getAllVcResourcePool());
    logger.debug(""String_Node_Str"");
  }
  if (clusterEntity.getVcDatastoreNameList() != null) {
    logger.debug(""String_Node_Str"");
    Set<String> sharedPattern=datastoreMgr.getSharedDatastoresByNames(clusterEntity.getVcDatastoreNameList());
    clusterConfig.setSharedDatastorePattern(sharedPattern);
    Set<String> localPattern=datastoreMgr.getLocalDatastoresByNames(clusterEntity.getVcDatastoreNameList());
    clusterConfig.setLocalDatastorePattern(localPattern);
    clusterConfig.setDsNames(clusterEntity.getVcDatastoreNameList());
  }
 else {
    clusterConfig.setSharedDatastorePattern(datastoreMgr.getAllSharedDatastores());
    clusterConfig.setLocalDatastorePattern(datastoreMgr.getAllLocalDatastores());
    logger.debug(""String_Node_Str"");
  }
  List<NodeGroupCreate> nodeGroups=new ArrayList<NodeGroupCreate>();
  Set<NodeGroupEntity> nodeGroupEntities=clusterEntity.getNodeGroups();
  long instanceNum=0;
  for (  NodeGroupEntity ngEntity : nodeGroupEntities) {
    NodeGroupCreate group=convertNodeGroups(clusterEntity,ngEntity,clusterEntity.getName());
    nodeGroups.add(group);
    instanceNum+=group.getInstanceNum();
  }
  if (clusterEntity.getAppManager() == null || Constants.IRONFAN.equalsIgnoreCase(clusterEntity.getAppManager())) {
    sortGroups(nodeGroups);
  }
  clusterConfig.setNodeGroups(nodeGroups.toArray(new NodeGroupCreate[nodeGroups.size()]));
  List<String> networkNames=clusterEntity.fetchNetworkNameList();
  List<NetworkAdd> networkingAdds=allocatNetworkIp(networkNames,clusterEntity,instanceNum,needAllocIp);
  clusterConfig.setNetworkings(networkingAdds);
  clusterConfig.setNetworkConfig(convertNetConfigsToNetNames(clusterEntity.getNetworkConfigInfo()));
  if (clusterEntity.getHadoopConfig() != null) {
    Map<String,Object> hadoopConfig=(new Gson()).fromJson(clusterEntity.getHadoopConfig(),Map.class);
    clusterConfig.setConfiguration(hadoopConfig);
  }
}"
48618,"private Set<NodeGroupEntity> convertNodeGroupsToEntities(Gson gson,ClusterEntity clusterEntity,String distro,NodeGroupCreate[] groups,boolean validateWhiteList){
  Set<NodeGroupEntity> nodeGroups;
  nodeGroups=new HashSet<NodeGroupEntity>();
  Set<String> referencedNodeGroups=new HashSet<String>();
  for (  NodeGroupCreate group : groups) {
    NodeGroupEntity groupEntity=convertGroup(gson,clusterEntity,group,distro,validateWhiteList);
    if (groupEntity != null) {
      nodeGroups.add(groupEntity);
      if (groupEntity.getStorageType() == DatastoreType.TEMPFS) {
        for (        NodeGroupAssociation associate : groupEntity.getGroupAssociations()) {
          referencedNodeGroups.add(associate.getReferencedGroup());
        }
      }
    }
  }
  if (clusterEntity.getAppManager() == null) {
    for (    String nodeGroupName : referencedNodeGroups) {
      for (      NodeGroupEntity groupEntity : nodeGroups) {
        if (groupEntity.getName().equals(nodeGroupName)) {
          @SuppressWarnings(""String_Node_Str"") List<String> sortedRoles=gson.fromJson(groupEntity.getRoles(),List.class);
          sortedRoles.add(0,HadoopRole.TEMPFS_SERVER_ROLE.toString());
          groupEntity.setRoles(gson.toJson(sortedRoles));
        }
      }
    }
  }
  return nodeGroups;
}","private Set<NodeGroupEntity> convertNodeGroupsToEntities(Gson gson,ClusterEntity clusterEntity,String distro,NodeGroupCreate[] groups,boolean validateWhiteList){
  Set<NodeGroupEntity> nodeGroups;
  nodeGroups=new HashSet<NodeGroupEntity>();
  Set<String> referencedNodeGroups=new HashSet<String>();
  for (  NodeGroupCreate group : groups) {
    NodeGroupEntity groupEntity=convertGroup(gson,clusterEntity,group,distro,validateWhiteList);
    if (groupEntity != null) {
      nodeGroups.add(groupEntity);
      if (groupEntity.getStorageType() == DatastoreType.TEMPFS) {
        for (        NodeGroupAssociation associate : groupEntity.getGroupAssociations()) {
          referencedNodeGroups.add(associate.getReferencedGroup());
        }
      }
    }
  }
  if (clusterEntity.getAppManager() == null || Constants.IRONFAN.equalsIgnoreCase(clusterEntity.getAppManager())) {
    for (    String nodeGroupName : referencedNodeGroups) {
      for (      NodeGroupEntity groupEntity : nodeGroups) {
        if (groupEntity.getName().equals(nodeGroupName)) {
          @SuppressWarnings(""String_Node_Str"") List<String> sortedRoles=gson.fromJson(groupEntity.getRoles(),List.class);
          sortedRoles.add(0,HadoopRole.TEMPFS_SERVER_ROLE.toString());
          groupEntity.setRoles(gson.toJson(sortedRoles));
        }
      }
    }
  }
  return nodeGroups;
}"
48619,"private NodeGroupEntity convertGroup(Gson gson,ClusterEntity clusterEntity,NodeGroupCreate group,String distro,boolean validateWhiteList){
  NodeGroupEntity groupEntity=new NodeGroupEntity();
  if (group.getRoles() == null || group.getRoles().isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  groupEntity.setCluster(clusterEntity);
  int cpuNum=group.getCpuNum() == null ? 0 : group.getCpuNum();
  if (!VcVmUtil.validateCPU(clusteringService.getTemplateVmId(),cpuNum)) {
    throw VcProviderException.CPU_NUM_NOT_MULTIPLE_OF_CORES_PER_SOCKET(group.getName(),clusteringService.getTemplateVmName());
  }
  groupEntity.setCpuNum(cpuNum);
  groupEntity.setDefineInstanceNum(group.getInstanceNum());
  groupEntity.setMemorySize(group.getMemCapacityMB() == null ? 0 : group.getMemCapacityMB());
  groupEntity.setSwapRatio(group.getSwapRatio());
  groupEntity.setName(group.getName());
  groupEntity.setNodeType(group.getInstanceType());
  PlacementPolicy policies=group.getPlacementPolicies();
  if (policies != null) {
    List<GroupAssociation> associons=policies.getGroupAssociations();
    if (associons != null) {
      Set<NodeGroupAssociation> associonEntities=new HashSet<NodeGroupAssociation>();
      for (      GroupAssociation a : associons) {
        NodeGroupAssociation ae=new NodeGroupAssociation();
        ae.setAssociationType(a.getType());
        ae.setNodeGroup(groupEntity);
        ae.setReferencedGroup(a.getReference());
        associonEntities.add(ae);
      }
      groupEntity.setGroupAssociations(associonEntities);
    }
    if (policies.getInstancePerHost() != null) {
      groupEntity.setInstancePerHost(policies.getInstancePerHost());
    }
    if (policies.getGroupRacks() != null) {
      groupEntity.setGroupRacks((new Gson()).toJson(policies.getGroupRacks()));
    }
  }
  if (group.getRpNames() != null && group.getRpNames().size() > 0) {
    groupEntity.setVcRpNameList(group.getRpNames());
  }
  Set<String> roles=new LinkedHashSet<String>();
  convertStorage(group,groupEntity,roles);
  roles.addAll(group.getRoles());
  EnumSet<HadoopRole> enumRoles=null;
  if (clusterEntity.getAppManager() == null) {
    enumRoles=getEnumRoles(group.getRoles(),distro);
    if (enumRoles.isEmpty()) {
      throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
    }
    if (enumRoles.contains(HadoopRole.CUSTOMIZED_ROLE)) {
      groupEntity.setRoles(gson.toJson(roles));
    }
 else {
      List<String> sortedRolesByDependency=new ArrayList<String>();
      sortedRolesByDependency.addAll(roles);
      Collections.sort(sortedRolesByDependency,new RoleComparactor());
      groupEntity.setRoles(gson.toJson(sortedRolesByDependency));
    }
  }
 else {
    groupEntity.setRoles(gson.toJson(roles));
  }
  if (group.getInstanceNum() <= 0) {
    logger.warn(""String_Node_Str"" + group.getName() + ""String_Node_Str"");
    return null;
  }
  List<String> dsNames=groupEntity.getVcDatastoreNameList();
  if (dsNames == null) {
    dsNames=clusterEntity.getVcDatastoreNameList();
  }
  Set<String> sharedPattern;
  Set<String> localPattern;
  if (dsNames != null) {
    sharedPattern=datastoreMgr.getSharedDatastoresByNames(dsNames);
    localPattern=datastoreMgr.getLocalDatastoresByNames(dsNames);
  }
 else {
    sharedPattern=datastoreMgr.getAllSharedDatastores();
    localPattern=datastoreMgr.getAllLocalDatastores();
  }
  if (clusterEntity.getAppManager() == null) {
    GroupType groupType=GroupType.fromHadoopRole(enumRoles);
    CommonClusterExpandPolicy.expandGroupInstanceType(groupEntity,groupType,sharedPattern,localPattern);
  }
  groupEntity.setHaFlag(group.getHaFlag());
  if (group.getConfiguration() != null && group.getConfiguration().size() > 0) {
    if (clusterEntity.getAppManager() == null) {
      CommonClusterExpandPolicy.validateAppConfig(group.getConfiguration(),validateWhiteList);
    }
    groupEntity.setHadoopConfig(gson.toJson(group.getConfiguration()));
  }
  groupEntity.setVmFolderPath(clusterEntity);
  logger.debug(""String_Node_Str"" + group.getName());
  return groupEntity;
}","private NodeGroupEntity convertGroup(Gson gson,ClusterEntity clusterEntity,NodeGroupCreate group,String distro,boolean validateWhiteList){
  NodeGroupEntity groupEntity=new NodeGroupEntity();
  if (group.getRoles() == null || group.getRoles().isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  groupEntity.setCluster(clusterEntity);
  int cpuNum=group.getCpuNum() == null ? 0 : group.getCpuNum();
  if (!VcVmUtil.validateCPU(clusteringService.getTemplateVmId(),cpuNum)) {
    throw VcProviderException.CPU_NUM_NOT_MULTIPLE_OF_CORES_PER_SOCKET(group.getName(),clusteringService.getTemplateVmName());
  }
  groupEntity.setCpuNum(cpuNum);
  groupEntity.setDefineInstanceNum(group.getInstanceNum());
  groupEntity.setMemorySize(group.getMemCapacityMB() == null ? 0 : group.getMemCapacityMB());
  groupEntity.setSwapRatio(group.getSwapRatio());
  groupEntity.setName(group.getName());
  groupEntity.setNodeType(group.getInstanceType());
  PlacementPolicy policies=group.getPlacementPolicies();
  if (policies != null) {
    List<GroupAssociation> associons=policies.getGroupAssociations();
    if (associons != null) {
      Set<NodeGroupAssociation> associonEntities=new HashSet<NodeGroupAssociation>();
      for (      GroupAssociation a : associons) {
        NodeGroupAssociation ae=new NodeGroupAssociation();
        ae.setAssociationType(a.getType());
        ae.setNodeGroup(groupEntity);
        ae.setReferencedGroup(a.getReference());
        associonEntities.add(ae);
      }
      groupEntity.setGroupAssociations(associonEntities);
    }
    if (policies.getInstancePerHost() != null) {
      groupEntity.setInstancePerHost(policies.getInstancePerHost());
    }
    if (policies.getGroupRacks() != null) {
      groupEntity.setGroupRacks((new Gson()).toJson(policies.getGroupRacks()));
    }
  }
  if (group.getRpNames() != null && group.getRpNames().size() > 0) {
    groupEntity.setVcRpNameList(group.getRpNames());
  }
  Set<String> roles=new LinkedHashSet<String>();
  convertStorage(group,groupEntity,roles);
  roles.addAll(group.getRoles());
  EnumSet<HadoopRole> enumRoles=null;
  if (clusterEntity.getAppManager() == null || Constants.IRONFAN.equalsIgnoreCase(clusterEntity.getAppManager())) {
    enumRoles=getEnumRoles(group.getRoles(),distro);
    if (enumRoles.isEmpty()) {
      throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
    }
    if (enumRoles.contains(HadoopRole.CUSTOMIZED_ROLE)) {
      groupEntity.setRoles(gson.toJson(roles));
    }
 else {
      List<String> sortedRolesByDependency=new ArrayList<String>();
      sortedRolesByDependency.addAll(roles);
      Collections.sort(sortedRolesByDependency,new RoleComparactor());
      groupEntity.setRoles(gson.toJson(sortedRolesByDependency));
    }
  }
 else {
    groupEntity.setRoles(gson.toJson(roles));
  }
  if (group.getInstanceNum() <= 0) {
    logger.warn(""String_Node_Str"" + group.getName() + ""String_Node_Str"");
    return null;
  }
  List<String> dsNames=groupEntity.getVcDatastoreNameList();
  if (dsNames == null) {
    dsNames=clusterEntity.getVcDatastoreNameList();
  }
  Set<String> sharedPattern;
  Set<String> localPattern;
  if (dsNames != null) {
    sharedPattern=datastoreMgr.getSharedDatastoresByNames(dsNames);
    localPattern=datastoreMgr.getLocalDatastoresByNames(dsNames);
  }
 else {
    sharedPattern=datastoreMgr.getAllSharedDatastores();
    localPattern=datastoreMgr.getAllLocalDatastores();
  }
  if (clusterEntity.getAppManager() == null || Constants.IRONFAN.equalsIgnoreCase(clusterEntity.getAppManager())) {
    GroupType groupType=GroupType.fromHadoopRole(enumRoles);
    CommonClusterExpandPolicy.expandGroupInstanceType(groupEntity,groupType,sharedPattern,localPattern);
  }
  groupEntity.setHaFlag(group.getHaFlag());
  if (group.getConfiguration() != null && group.getConfiguration().size() > 0) {
    if (clusterEntity.getAppManager() == null || Constants.IRONFAN.equalsIgnoreCase(clusterEntity.getAppManager())) {
      CommonClusterExpandPolicy.validateAppConfig(group.getConfiguration(),validateWhiteList);
    }
    groupEntity.setHadoopConfig(gson.toJson(group.getConfiguration()));
  }
  groupEntity.setVmFolderPath(clusterEntity);
  logger.debug(""String_Node_Str"" + group.getName());
  return groupEntity;
}"
48620,"private void expandGroupStorage(NodeGroupEntity ngEntity,NodeGroupCreate group,EnumSet<HadoopRole> enumRoles){
  int storageSize=ngEntity.getStorageSize();
  DatastoreType storageType=ngEntity.getStorageType();
  List<String> storeNames=ngEntity.getVcDatastoreNameList();
  List<String> dataDiskStoreNames=ngEntity.getDdDatastoreNameList();
  List<String> systemDiskStoreNames=ngEntity.getSdDatastoreNameList();
  if (storageSize <= 0 && storageType == null && (storeNames == null || storeNames.isEmpty())) {
    logger.debug(""String_Node_Str"" + ngEntity.getName());
  }
  logger.debug(""String_Node_Str"" + storageSize + ""String_Node_Str""+ ngEntity.getName());
  logger.debug(""String_Node_Str"" + storageType + ""String_Node_Str""+ ngEntity.getName());
  logger.debug(""String_Node_Str"" + storeNames + ""String_Node_Str""+ ngEntity.getName());
  logger.debug(""String_Node_Str"" + systemDiskStoreNames + ""String_Node_Str""+ ngEntity.getName());
  logger.debug(""String_Node_Str"" + dataDiskStoreNames + ""String_Node_Str""+ ngEntity.getName());
  StorageRead storage=new StorageRead();
  group.setStorage(storage);
  storage.setSizeGB(storageSize);
  if (storageType != null) {
    storage.setType(storageType.toString().toLowerCase());
  }
  if (systemDiskStoreNames != null && !systemDiskStoreNames.isEmpty())   storage.setImagestoreNamePattern(getDatastoreNamePattern(storageType,systemDiskStoreNames));
 else   storage.setImagestoreNamePattern(getDatastoreNamePattern(storageType,storeNames));
  if (dataDiskStoreNames != null && !dataDiskStoreNames.isEmpty())   storage.setDiskstoreNamePattern(getDatastoreNamePattern(storageType,dataDiskStoreNames));
 else   storage.setDiskstoreNamePattern(getDatastoreNamePattern(storageType,storeNames));
  storage.setShares(ngEntity.getCluster().getIoShares());
  if ((ngEntity.getCluster().getAppManager() == null) && (enumRoles.size() == 1 || (enumRoles.size() == 2 && enumRoles.contains(HadoopRole.HADOOP_JOURNALNODE_ROLE))) && (enumRoles.contains(HadoopRole.ZOOKEEPER_ROLE) || enumRoles.contains(HadoopRole.MAPR_ZOOKEEPER_ROLE))) {
    logger.debug(""String_Node_Str"");
    storage.setSplitPolicy(DiskSplitPolicy.BI_SECTOR);
  }
 else {
    if (storage.getType().equalsIgnoreCase(DatastoreType.LOCAL.toString())) {
      logger.debug(""String_Node_Str"");
      storage.setSplitPolicy(DiskSplitPolicy.EVEN_SPLIT);
    }
 else {
      logger.debug(""String_Node_Str"");
      storage.setSplitPolicy(DiskSplitPolicy.AGGREGATE);
    }
  }
  setDiskAttributes(storageType,storage,storeNames);
}","private void expandGroupStorage(NodeGroupEntity ngEntity,NodeGroupCreate group,EnumSet<HadoopRole> enumRoles){
  int storageSize=ngEntity.getStorageSize();
  DatastoreType storageType=ngEntity.getStorageType();
  List<String> storeNames=ngEntity.getVcDatastoreNameList();
  List<String> dataDiskStoreNames=ngEntity.getDdDatastoreNameList();
  List<String> systemDiskStoreNames=ngEntity.getSdDatastoreNameList();
  if (storageSize <= 0 && storageType == null && (storeNames == null || storeNames.isEmpty())) {
    logger.debug(""String_Node_Str"" + ngEntity.getName());
  }
  logger.debug(""String_Node_Str"" + storageSize + ""String_Node_Str""+ ngEntity.getName());
  logger.debug(""String_Node_Str"" + storageType + ""String_Node_Str""+ ngEntity.getName());
  logger.debug(""String_Node_Str"" + storeNames + ""String_Node_Str""+ ngEntity.getName());
  logger.debug(""String_Node_Str"" + systemDiskStoreNames + ""String_Node_Str""+ ngEntity.getName());
  logger.debug(""String_Node_Str"" + dataDiskStoreNames + ""String_Node_Str""+ ngEntity.getName());
  StorageRead storage=new StorageRead();
  group.setStorage(storage);
  storage.setSizeGB(storageSize);
  if (storageType != null) {
    storage.setType(storageType.toString().toLowerCase());
  }
  if (systemDiskStoreNames != null && !systemDiskStoreNames.isEmpty())   storage.setImagestoreNamePattern(getDatastoreNamePattern(storageType,systemDiskStoreNames));
 else   storage.setImagestoreNamePattern(getDatastoreNamePattern(storageType,storeNames));
  if (dataDiskStoreNames != null && !dataDiskStoreNames.isEmpty())   storage.setDiskstoreNamePattern(getDatastoreNamePattern(storageType,dataDiskStoreNames));
 else   storage.setDiskstoreNamePattern(getDatastoreNamePattern(storageType,storeNames));
  storage.setShares(ngEntity.getCluster().getIoShares());
  if ((ngEntity.getCluster().getAppManager() == null || Constants.IRONFAN.equalsIgnoreCase(ngEntity.getCluster().getAppManager())) && (enumRoles.size() == 1 || (enumRoles.size() == 2 && enumRoles.contains(HadoopRole.HADOOP_JOURNALNODE_ROLE))) && (enumRoles.contains(HadoopRole.ZOOKEEPER_ROLE) || enumRoles.contains(HadoopRole.MAPR_ZOOKEEPER_ROLE))) {
    logger.debug(""String_Node_Str"");
    storage.setSplitPolicy(DiskSplitPolicy.BI_SECTOR);
  }
 else {
    if (storage.getType().equalsIgnoreCase(DatastoreType.LOCAL.toString())) {
      logger.debug(""String_Node_Str"");
      storage.setSplitPolicy(DiskSplitPolicy.EVEN_SPLIT);
    }
 else {
      logger.debug(""String_Node_Str"");
      storage.setSplitPolicy(DiskSplitPolicy.AGGREGATE);
    }
  }
  setDiskAttributes(storageType,storage,storeNames);
}"
48621,"private ISoftwareManagementTask createThriftTask(ChunkContext chunkContext,String targetName,StatusUpdater statusUpdater){
  ISoftwareManagementTask task;
  File workDir=CommandUtil.createWorkDir(getJobExecutionId(chunkContext));
  putIntoJobExecutionContext(chunkContext,JobConstants.CURRENT_COMMAND_WORK_DIR,workDir.getAbsolutePath());
  boolean needAllocIp=true;
  if (ManagementOperation.DESTROY.equals(managementOperation)) {
    needAllocIp=false;
  }
  String specFilePath=null;
  if (managementOperation.ordinal() != ManagementOperation.DESTROY.ordinal()) {
    File specFile=clusterManager.writeClusterSpecFile(targetName,workDir,needAllocIp);
    specFilePath=specFile.getAbsolutePath();
  }
  task=SoftwareManagementTaskFactory.createThriftTask(targetName,specFilePath,statusUpdater,managementOperation,lockClusterEntityMgr);
  return task;
}","private ISoftwareManagementTask createThriftTask(ChunkContext chunkContext,String targetName,StatusUpdater statusUpdater){
  ISoftwareManagementTask task;
  File workDir=CommandUtil.createWorkDir(getJobExecutionId(chunkContext));
  putIntoJobExecutionContext(chunkContext,JobConstants.CURRENT_COMMAND_WORK_DIR,workDir.getAbsolutePath());
  boolean needAllocIp=true;
  if (ManagementOperation.DESTROY.equals(managementOperation) || ManagementOperation.PRE_DESTROY.equals(managementOperation)) {
    needAllocIp=false;
  }
  String specFilePath=null;
  if (!(ManagementOperation.DESTROY.equals(managementOperation) || ManagementOperation.PRE_DESTROY.equals(managementOperation))) {
    File specFile=clusterManager.writeClusterSpecFile(targetName,workDir,needAllocIp);
    specFilePath=specFile.getAbsolutePath();
  }
  task=SoftwareManagementTaskFactory.createThriftTask(targetName,specFilePath,statusUpdater,managementOperation,lockClusterEntityMgr);
  return task;
}"
48622,"private ISoftwareManagementTask createExternalTask(ChunkContext chunkContext,String targetName,String clusterName,ClusterCreate clusterSpec,StatusUpdater statusUpdater){
  ISoftwareManagementTask task;
  SoftwareManager softwareMgr=softwareMgrs.getSoftwareManager(clusterSpec.getAppManager());
  ClusterBlueprint clusterBlueprint=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_BLUEPRINT_JOB_PARAM,ClusterBlueprint.class);
  if (clusterBlueprint == null) {
    clusterBlueprint=lockClusterEntityMgr.getClusterEntityMgr().toClusterBluePrint(clusterName);
    putIntoJobExecutionContext(chunkContext,JobConstants.CLUSTER_BLUEPRINT_JOB_PARAM,clusterBlueprint);
  }
  task=SoftwareManagementTaskFactory.createExternalMgtTask(targetName,managementOperation,clusterBlueprint,statusUpdater,lockClusterEntityMgr,softwareMgr);
  return task;
}","private ISoftwareManagementTask createExternalTask(ChunkContext chunkContext,String targetName,String clusterName,StatusUpdater statusUpdater){
  ISoftwareManagementTask task;
  SoftwareManager softwareMgr=softwareMgrs.getSoftwareManagerByClusterName(clusterName);
  ClusterBlueprint clusterBlueprint=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_BLUEPRINT_JOB_PARAM,ClusterBlueprint.class);
  if (clusterBlueprint == null) {
    clusterBlueprint=lockClusterEntityMgr.getClusterEntityMgr().toClusterBluePrint(clusterName);
    putIntoJobExecutionContext(chunkContext,JobConstants.CLUSTER_BLUEPRINT_JOB_PARAM,clusterBlueprint);
  }
  task=SoftwareManagementTaskFactory.createExternalMgtTask(targetName,managementOperation,clusterBlueprint,statusUpdater,lockClusterEntityMgr,softwareMgr);
  return task;
}"
48623,"@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String targetName=getJobParameters(chunkContext).getString(JobConstants.TARGET_NAME_JOB_PARAM);
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  if (targetName == null) {
    targetName=clusterName;
  }
  String jobName=chunkContext.getStepContext().getJobName();
  logger.info(""String_Node_Str"" + targetName + ""String_Node_Str""+ managementOperation+ ""String_Node_Str""+ jobName);
  boolean vmPowerOn=false;
  String vmPowerOnStr=getJobParameters(chunkContext).getString(JobConstants.IS_VM_POWER_ON);
  if (vmPowerOnStr != null) {
    logger.info(""String_Node_Str"" + vmPowerOnStr);
    vmPowerOn=Boolean.parseBoolean(vmPowerOnStr);
  }
  if (checkVMStatus && targetName.split(""String_Node_Str"").length == 3 && !vmPowerOn) {
    return RepeatStatus.FINISHED;
  }
  ClusterCreate clusterSpec=clusterManager.getClusterSpec(clusterName);
  SoftwareManager softwareMgr=softwareMgrs.getSoftwareManager(clusterSpec.getAppManager());
  if (ManagementOperation.CONFIGURE.equals(managementOperation) || JobConstants.RESUME_CLUSTER_JOB_NAME.equals(jobName)) {
    logger.info(""String_Node_Str"");
    List<NodeEntity> nodes=lockClusterEntityMgr.getClusterEntityMgr().findAllNodes(clusterName);
    Set<String> hostnames=new HashSet<String>();
    for (    NodeEntity node : nodes) {
      hostnames.add(node.getHostName());
    }
    SyncHostsUtils.SyncHosts(clusterSpec,hostnames,softwareMgr);
  }
  StatusUpdater statusUpdater=new DefaultStatusUpdater(jobExecutionStatusHolder,getJobExecutionId(chunkContext));
  ISoftwareManagementTask task=null;
  if (!CommonUtil.isBlank(clusterSpec.getAppManager()) && !Constants.IRONFAN.equalsIgnoreCase(clusterSpec.getAppManager())) {
    task=createExternalTask(chunkContext,targetName,clusterName,clusterSpec,statusUpdater);
  }
 else {
    task=createThriftTask(chunkContext,targetName,statusUpdater);
  }
  if (task != null) {
    Map<String,Object> ret=task.call();
    if (!(Boolean)ret.get(""String_Node_Str"")) {
      String errorMessage=(String)ret.get(""String_Node_Str"");
      putIntoJobExecutionContext(chunkContext,JobConstants.CURRENT_ERROR_MESSAGE,errorMessage);
      throw TaskException.EXECUTION_FAILED(errorMessage);
    }
  }
  return RepeatStatus.FINISHED;
}","@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String targetName=getJobParameters(chunkContext).getString(JobConstants.TARGET_NAME_JOB_PARAM);
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  if (targetName == null) {
    targetName=clusterName;
  }
  String jobName=chunkContext.getStepContext().getJobName();
  logger.info(""String_Node_Str"" + targetName + ""String_Node_Str""+ managementOperation+ ""String_Node_Str""+ jobName);
  boolean vmPowerOn=false;
  String vmPowerOnStr=getJobParameters(chunkContext).getString(JobConstants.IS_VM_POWER_ON);
  if (vmPowerOnStr != null) {
    logger.info(""String_Node_Str"" + vmPowerOnStr);
    vmPowerOn=Boolean.parseBoolean(vmPowerOnStr);
  }
  if (checkVMStatus && targetName.split(""String_Node_Str"").length == 3 && !vmPowerOn) {
    return RepeatStatus.FINISHED;
  }
  SoftwareManager softwareMgr=softwareMgrs.getSoftwareManagerByClusterName(clusterName);
  if (ManagementOperation.CONFIGURE.equals(managementOperation) || JobConstants.RESUME_CLUSTER_JOB_NAME.equals(jobName)) {
    logger.info(""String_Node_Str"");
    List<NodeEntity> nodes=lockClusterEntityMgr.getClusterEntityMgr().findAllNodes(clusterName);
    Set<String> hostnames=new HashSet<String>();
    for (    NodeEntity node : nodes) {
      hostnames.add(node.getHostName());
    }
    ClusterCreate clusterSpec=clusterManager.getClusterSpec(clusterName);
    SyncHostsUtils.SyncHosts(clusterSpec,hostnames,softwareMgr);
  }
  StatusUpdater statusUpdater=new DefaultStatusUpdater(jobExecutionStatusHolder,getJobExecutionId(chunkContext));
  ISoftwareManagementTask task=null;
  if (!softwareMgr.getName().equals(Constants.IRONFAN)) {
    task=createExternalTask(chunkContext,targetName,clusterName,statusUpdater);
  }
 else {
    task=createThriftTask(chunkContext,targetName,statusUpdater);
  }
  if (task != null) {
    Map<String,Object> ret=task.call();
    if (!(Boolean)ret.get(""String_Node_Str"")) {
      String errorMessage=(String)ret.get(""String_Node_Str"");
      putIntoJobExecutionContext(chunkContext,JobConstants.CURRENT_ERROR_MESSAGE,errorMessage);
      throw TaskException.EXECUTION_FAILED(errorMessage);
    }
  }
  return RepeatStatus.FINISHED;
}"
48624,"@Override public String getName(){
  return ""String_Node_Str"";
}","@Override public String getName(){
  return Constants.IRONFAN;
}"
48625,"/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
public void validateClusterCreate(List<String> failedMsgList,List<String> warningMsgList){
  boolean namenodeHACheck=false;
  int masterCount=0, jobtrackerCount=0, resourcemanagerCount=0, hbasemasterCount=0, zookeeperCount=0, workerCount=0, numOfJournalNode=0;
  boolean appendWarningStr=false;
  if (warningMsgList != null && warningMsgList.isEmpty()) {
    appendWarningStr=true;
  }
  NodeGroupCreate[] nodeGroupCreates=getNodeGroups();
  AuAssert.check(nodeGroupCreates != null && nodeGroupCreates.length > 0);
  if (hasHDFSUrlConfigured() && !validateHDFSUrl()) {
    failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getExternalHDFS()).toString());
  }
  validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList);
  validateStorageType(failedMsgList);
  validateSwapRatio(nodeGroupCreates,failedMsgList);
  for (  NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
    checkInstanceNum(nodeGroupCreate,failedMsgList);
    checkCPUAndMemory(nodeGroupCreate,failedMsgList,warningMsgList);
    List<NodeGroupRole> groupRoles=getNodeGroupRoles(nodeGroupCreate);
    if (groupRoles != null) {
      for (      NodeGroupRole role : groupRoles) {
switch (role) {
case MASTER:
          masterCount++;
        int numOfInstance=nodeGroupCreate.getInstanceNum();
      if (numOfInstance >= 0 && numOfInstance != 1) {
        if (numOfInstance != 2) {
          collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
        }
 else {
          namenodeHACheck=true;
        }
      }
    break;
case JOB_TRACKER:
  jobtrackerCount++;
if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
  failedMsgList.add(Constants.WRONG_NUM_OF_JOBTRACKER);
}
break;
case RESOURCEMANAGER:
resourcemanagerCount++;
if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
failedMsgList.add(Constants.WRONG_NUM_OF_RESOURCEMANAGER);
}
break;
case HBASE_MASTER:
hbasemasterCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
break;
case ZOOKEEPER:
zookeeperCount++;
if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_ZOOKEEPER);
}
 else if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_ZOOKEEPER);
}
break;
case JOURNAL_NODE:
numOfJournalNode+=nodeGroupCreate.getInstanceNum();
if (nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_DATANODE.toString()) || nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_CLIENT_ROLE.toString())) {
failedMsgList.add(Constants.DATA_CLIENT_NODE_JOURNALNODE_COEXIST);
}
break;
case WORKER:
workerCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
 else if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
List<String> roles=nodeGroupCreate.getRoles();
if (roles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString()) && !roles.contains(HadoopRole.HADOOP_DATANODE.toString())) {
warningMsgList.add(Constants.REGISONSERVER_DATANODE_SEPERATION);
}
break;
case CLIENT:
if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
break;
case NONE:
break;
default :
break;
}
}
}
}
if (!supportedWithHdfs2()) {
if (namenodeHACheck || masterCount > 1) {
failedMsgList.add(Constants.CURRENT_DISTRO_CAN_NOT_SUPPORT_HDFS2);
}
}
 else if (namenodeHACheck) {
if (numOfJournalNode >= 0 && numOfJournalNode < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_JOURNALNODE);
}
 else if (numOfJournalNode > 0 && numOfJournalNode % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_JOURNALNODE);
}
if (zookeeperCount == 0) {
failedMsgList.add(Constants.NAMENODE_AUTO_FAILOVER_ZOOKEEPER);
}
}
if ((jobtrackerCount > 1) || (resourcemanagerCount > 1) || (zookeeperCount > 1)|| (hbasemasterCount > 1)) {
failedMsgList.add(Constants.WRONG_NUM_OF_NODEGROUPS);
}
if (numOfJournalNode > 0 && !namenodeHACheck) {
failedMsgList.add(Constants.NO_NAMENODE_HA);
}
if (!warningMsgList.isEmpty() && appendWarningStr) {
warningMsgList.set(0,""String_Node_Str"" + warningMsgList.get(0));
}
}","/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
public void validateClusterCreate(List<String> failedMsgList,List<String> warningMsgList){
  NodeGroupCreate[] nodeGroupCreates=getNodeGroups();
  AuAssert.check(nodeGroupCreates != null && nodeGroupCreates.length > 0);
  if (hasHDFSUrlConfigured() && !validateHDFSUrl()) {
    failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getExternalHDFS()).toString());
  }
  validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList);
  validateStorageType(failedMsgList);
  validateSwapRatio(nodeGroupCreates,failedMsgList);
  for (  NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
    checkInstanceNum(nodeGroupCreate,failedMsgList);
    checkCPUAndMemory(nodeGroupCreate,failedMsgList,warningMsgList);
  }
  validateRoleWithWarning(failedMsgList,warningMsgList);
}"
48626,"public NodeGroupInfo toNodeGroupInfo(NodeGroupEntity group){
  Gson gson=new Gson();
  NodeGroupInfo nodeGroupInfo=new NodeGroupInfo();
  nodeGroupInfo.setName(group.getName());
  nodeGroupInfo.setInstanceNum(group.getRealInstanceNum(true));
  nodeGroupInfo.setRoles(gson.fromJson(group.getRoles(),List.class));
  if (group.getHadoopConfig() != null) {
    Map<String,Object> groupConfigs=gson.fromJson(group.getHadoopConfig(),Map.class);
    nodeGroupInfo.setConfiguration(groupConfigs);
  }
  List<NodeInfo> nodeInfos=new ArrayList<NodeInfo>();
  for (  NodeEntity node : group.getNodes()) {
    NodeInfo nodeInfo=new NodeInfo();
    nodeInfo.setName(node.getVmName());
    nodeInfo.setIpConfigs(node.convertToIpConfigInfo());
    nodeInfo.setRack(node.getRack());
    nodeInfo.setVolumes(node.getDataVolumnsMountPoint());
    nodeInfos.add(nodeInfo);
  }
  nodeGroupInfo.setNodes(nodeInfos);
  return nodeGroupInfo;
}","public NodeGroupInfo toNodeGroupInfo(String clusterName,String groupName){
  NodeGroupEntity group=findByName(clusterName,groupName);
  return toNodeGroupInfo(group);
}"
48627,"public Long resizeCluster(String clusterName,String nodeGroupName,int instanceNum) throws Exception {
  logger.info(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ clusterName+ ""String_Node_Str""+ instanceNum);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ValidationUtils.validateVersion(clusterEntityMgr,clusterName);
  List<String> dsNames=getUsedDS(cluster.getVcDatastoreNameList());
  if (dsNames.isEmpty()) {
    throw ClusterConfigException.NO_RESOURCE_POOL_ADDED();
  }
  List<VcCluster> vcClusters=getUsedVcClusters(cluster.getVcRpNameList());
  if (vcClusters.isEmpty()) {
    throw ClusterConfigException.NO_DATASTORE_ADDED();
  }
  validateDatastore(dsNames,vcClusters);
  validateNetworkAccessibility(cluster.fetchNetworkNameList(),vcClusters);
  NodeGroupEntity group=clusterEntityMgr.findByName(cluster,nodeGroupName);
  if (group == null) {
    logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ clusterName+ ""String_Node_Str"");
    throw ClusterManagerException.NODEGROUP_NOT_FOUND_ERROR(nodeGroupName);
  }
  AuAssert.check(!group.getRoleNameList().isEmpty(),""String_Node_Str"");
  SoftwareManager softMgr=softwareManagerCollector.getSoftwareManager(cluster.getAppManager());
  List<String> unsupportedRoles=softMgr.isNodeGroupExtensible(clusterEntityMgr.toNodeGroupInfo(group));
  if (!unsupportedRoles.isEmpty()) {
    logger.info(""String_Node_Str"" + unsupportedRoles);
    throw ClusterManagerException.ROLES_NOT_SUPPORTED(unsupportedRoles);
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.UPDATE_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  if (instanceNum <= group.getDefineInstanceNum()) {
    logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ group.getDefineInstanceNum()+ ""String_Node_Str""+ instanceNum+ ""String_Node_Str"");
    throw ClusterManagerException.SHRINK_OP_NOT_SUPPORTED(nodeGroupName,instanceNum,group.getDefineInstanceNum());
  }
  Integer instancePerHost=group.getInstancePerHost();
  if (instancePerHost != null && instanceNum % instancePerHost != 0) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",new StringBuilder(100).append(instanceNum).append(""String_Node_Str"").toString());
  }
  ValidationUtils.validHostNumber(clusterEntityMgr,group,instanceNum);
  ValidationUtils.hasEnoughHost(rackInfoMgr,clusterEntityMgr,group,instanceNum);
  int oldInstanceNum=group.getDefineInstanceNum();
  group.setDefineInstanceNum(instanceNum);
  clusterEntityMgr.update(group);
  clusterEntityMgr.cleanupActionError(clusterName);
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  param.put(JobConstants.GROUP_NAME_JOB_PARAM,new JobParameter(nodeGroupName));
  param.put(JobConstants.GROUP_INSTANCE_NEW_NUMBER_JOB_PARAM,new JobParameter(Long.valueOf(instanceNum)));
  param.put(JobConstants.GROUP_INSTANCE_OLD_NUMBER_JOB_PARAM,new JobParameter(Long.valueOf(oldInstanceNum)));
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.VERIFY_NODE_STATUS_SCOPE_PARAM,new JobParameter(JobConstants.GROUP_NODE_SCOPE_VALUE));
  JobParameters jobParameters=new JobParameters(param);
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.UPDATING);
  try {
    return jobManager.runJob(JobConstants.RESIZE_CLUSTER_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.RUNNING);
    group.setDefineInstanceNum(oldInstanceNum);
    clusterEntityMgr.update(group);
    throw e;
  }
}","public Long resizeCluster(String clusterName,String nodeGroupName,int instanceNum) throws Exception {
  logger.info(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ clusterName+ ""String_Node_Str""+ instanceNum);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ValidationUtils.validateVersion(clusterEntityMgr,clusterName);
  List<String> dsNames=getUsedDS(cluster.getVcDatastoreNameList());
  if (dsNames.isEmpty()) {
    throw ClusterConfigException.NO_RESOURCE_POOL_ADDED();
  }
  List<VcCluster> vcClusters=getUsedVcClusters(cluster.getVcRpNameList());
  if (vcClusters.isEmpty()) {
    throw ClusterConfigException.NO_DATASTORE_ADDED();
  }
  validateDatastore(dsNames,vcClusters);
  validateNetworkAccessibility(cluster.fetchNetworkNameList(),vcClusters);
  NodeGroupEntity group=clusterEntityMgr.findByName(cluster,nodeGroupName);
  if (group == null) {
    logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ clusterName+ ""String_Node_Str"");
    throw ClusterManagerException.NODEGROUP_NOT_FOUND_ERROR(nodeGroupName);
  }
  AuAssert.check(!group.getRoleNameList().isEmpty(),""String_Node_Str"");
  SoftwareManager softMgr=softwareManagerCollector.getSoftwareManager(cluster.getAppManager());
  List<String> unsupportedRoles=softMgr.validateScaling(clusterEntityMgr.toNodeGroupInfo(clusterName,nodeGroupName));
  if (!unsupportedRoles.isEmpty()) {
    logger.info(""String_Node_Str"" + unsupportedRoles);
    throw ClusterManagerException.ROLES_NOT_SUPPORTED(unsupportedRoles);
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.UPDATE_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  if (instanceNum <= group.getDefineInstanceNum()) {
    logger.error(""String_Node_Str"" + nodeGroupName + ""String_Node_Str""+ group.getDefineInstanceNum()+ ""String_Node_Str""+ instanceNum+ ""String_Node_Str"");
    throw ClusterManagerException.SHRINK_OP_NOT_SUPPORTED(nodeGroupName,instanceNum,group.getDefineInstanceNum());
  }
  Integer instancePerHost=group.getInstancePerHost();
  if (instancePerHost != null && instanceNum % instancePerHost != 0) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",new StringBuilder(100).append(instanceNum).append(""String_Node_Str"").toString());
  }
  ValidationUtils.validHostNumber(clusterEntityMgr,group,instanceNum);
  ValidationUtils.hasEnoughHost(rackInfoMgr,clusterEntityMgr,group,instanceNum);
  int oldInstanceNum=group.getDefineInstanceNum();
  group.setDefineInstanceNum(instanceNum);
  clusterEntityMgr.update(group);
  clusterEntityMgr.cleanupActionError(clusterName);
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  param.put(JobConstants.GROUP_NAME_JOB_PARAM,new JobParameter(nodeGroupName));
  param.put(JobConstants.GROUP_INSTANCE_NEW_NUMBER_JOB_PARAM,new JobParameter(Long.valueOf(instanceNum)));
  param.put(JobConstants.GROUP_INSTANCE_OLD_NUMBER_JOB_PARAM,new JobParameter(Long.valueOf(oldInstanceNum)));
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.VERIFY_NODE_STATUS_SCOPE_PARAM,new JobParameter(JobConstants.GROUP_NODE_SCOPE_VALUE));
  JobParameters jobParameters=new JobParameters(param);
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.UPDATING);
  try {
    return jobManager.runJob(JobConstants.RESIZE_CLUSTER_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.RUNNING);
    group.setDefineInstanceNum(oldInstanceNum);
    clusterEntityMgr.update(group);
    throw e;
  }
}"
48628,public NodeGroupInfo toNodeGroupInfo(NodeGroupEntity group);,"public NodeGroupInfo toNodeGroupInfo(String clusterName,String groupName);"
48629,"@BeforeClass(groups={""String_Node_Str""},dependsOnGroups={""String_Node_Str""}) public static void setup(){
  Mockit.setUpMock(MockResourceManager.class);
  ApplicationContext context=new FileSystemXmlApplicationContext(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  clusterConfigMgr=context.getBean(ClusterConfigManager.class);
  DistroManager distroMgr=Mockito.mock(DistroManager.class);
  ClusteringService clusteringService=Mockito.mock(ClusteringService.class);
  mockChefServerRoles();
  clusterConfigMgr.setDistroMgr(distroMgr);
  clusterConfigMgr.setClusteringService(clusteringService);
  clusterEntityMgr=context.getBean(""String_Node_Str"",IClusterEntityManager.class);
  DistroRead distro=new DistroRead();
  List<String> roles=new ArrayList<String>();
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  distro.setRoles(roles);
  Mockito.when(clusteringService.getTemplateVmId()).thenReturn(""String_Node_Str"");
  Mockito.when(clusteringService.getTemplateVmName()).thenReturn(""String_Node_Str"");
  Mockito.when(distroMgr.getDistroByName(""String_Node_Str"")).thenReturn(distro);
  Mockito.when(distroMgr.checkPackagesExistStatus(""String_Node_Str"")).thenReturn(PackagesExistStatus.TARBALL);
  Mockito.when(distroMgr.getPackageUrlByDistroRole(""String_Node_Str"",HadoopRole.HADOOP_NAMENODE_ROLE.toString())).thenReturn(""String_Node_Str"");
  Mockito.when(distroMgr.getPackageUrlByDistroRole(""String_Node_Str"",HadoopRole.HIVE_ROLE.toString())).thenReturn(""String_Node_Str"");
  Mockito.when(distroMgr.getPackageUrlByDistroRole(""String_Node_Str"",HadoopRole.PIG_ROLE.toString())).thenReturn(""String_Node_Str"");
  Mockito.when(distroMgr.getPackageUrlByDistroRole(""String_Node_Str"",HadoopRole.HBASE_MASTER_ROLE.toString())).thenReturn(""String_Node_Str"");
  Mockito.when(distroMgr.getPackageUrlByDistroRole(""String_Node_Str"",HadoopRole.ZOOKEEPER_ROLE.toString())).thenReturn(""String_Node_Str"");
  IResourcePoolService resPoolSvc=context.getBean(""String_Node_Str"",IResourcePoolService.class);
  IDatastoreService dsSvc=context.getBean(""String_Node_Str"",IDatastoreService.class);
  INetworkService netSvc=context.getBean(""String_Node_Str"",INetworkService.class);
  cleanUpUtils=new TestResourceCleanupUtils();
  cleanUpUtils.setDsSvc(dsSvc);
  cleanUpUtils.setNetSvc(netSvc);
  cleanUpUtils.setResPoolSvc(resPoolSvc);
  cleanupResources();
  try {
    Set<String> rpNames=resPoolSvc.getAllRPNames();
    logger.info(""String_Node_Str"" + rpNames);
    resPoolSvc.addResourcePool(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  try {
    resPoolSvc.addResourcePool(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  try {
    resPoolSvc.addResourcePool(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  try {
    resPoolSvc.addResourcePool(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  try {
    resPoolSvc.addResourcePool(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  try {
    resPoolSvc.addResourcePool(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  try {
    netSvc.addDhcpNetwork(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  List<String> sharedStores=new ArrayList<String>();
  sharedStores.add(""String_Node_Str"");
  sharedStores.add(""String_Node_Str"");
  try {
    clusterConfigMgr.getDatastoreMgr().addDatastores(""String_Node_Str"",DatastoreType.SHARED,sharedStores,false);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  List<String> localStores=new ArrayList<String>();
  localStores.add(""String_Node_Str"");
  localStores.add(""String_Node_Str"");
  try {
    clusterConfigMgr.getDatastoreMgr().addDatastores(""String_Node_Str"",DatastoreType.LOCAL,localStores,false);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  List<IpBlock> ipBlocks=new ArrayList<IpBlock>();
  IpBlock ip1=new IpBlock();
  ip1.setBeginIp(""String_Node_Str"");
  ip1.setEndIp(""String_Node_Str"");
  ipBlocks.add(ip1);
  IpBlock ip2=new IpBlock();
  ip2.setBeginIp(""String_Node_Str"");
  ip2.setEndIp(""String_Node_Str"");
  ipBlocks.add(ip2);
  IpBlock ip3=new IpBlock();
  ip3.setBeginIp(""String_Node_Str"");
  ip3.setEndIp(""String_Node_Str"");
  ipBlocks.add(ip3);
  try {
    netSvc.addIpPoolNetwork(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,ipBlocks);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
}","@BeforeClass(groups={""String_Node_Str""},dependsOnGroups={""String_Node_Str""}) public static void setup(){
  Mockit.setUpMock(MockResourceManager.class);
  ApplicationContext context=new FileSystemXmlApplicationContext(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  context.getBean(SoftwareManagerCollector.class).loadSoftwareManagers();
  clusterConfigMgr=context.getBean(ClusterConfigManager.class);
  DistroManager distroMgr=Mockito.mock(DistroManager.class);
  ClusteringService clusteringService=Mockito.mock(ClusteringService.class);
  mockChefServerRoles();
  clusterConfigMgr.setDistroMgr(distroMgr);
  clusterConfigMgr.setClusteringService(clusteringService);
  clusterEntityMgr=context.getBean(""String_Node_Str"",IClusterEntityManager.class);
  DistroRead distro=new DistroRead();
  List<String> roles=new ArrayList<String>();
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  roles.add(""String_Node_Str"");
  distro.setRoles(roles);
  Mockito.when(clusteringService.getTemplateVmId()).thenReturn(""String_Node_Str"");
  Mockito.when(clusteringService.getTemplateVmName()).thenReturn(""String_Node_Str"");
  Mockito.when(distroMgr.getDistroByName(""String_Node_Str"")).thenReturn(distro);
  Mockito.when(distroMgr.checkPackagesExistStatus(""String_Node_Str"")).thenReturn(PackagesExistStatus.TARBALL);
  Mockito.when(distroMgr.getPackageUrlByDistroRole(""String_Node_Str"",HadoopRole.HADOOP_NAMENODE_ROLE.toString())).thenReturn(""String_Node_Str"");
  Mockito.when(distroMgr.getPackageUrlByDistroRole(""String_Node_Str"",HadoopRole.HIVE_ROLE.toString())).thenReturn(""String_Node_Str"");
  Mockito.when(distroMgr.getPackageUrlByDistroRole(""String_Node_Str"",HadoopRole.PIG_ROLE.toString())).thenReturn(""String_Node_Str"");
  Mockito.when(distroMgr.getPackageUrlByDistroRole(""String_Node_Str"",HadoopRole.HBASE_MASTER_ROLE.toString())).thenReturn(""String_Node_Str"");
  Mockito.when(distroMgr.getPackageUrlByDistroRole(""String_Node_Str"",HadoopRole.ZOOKEEPER_ROLE.toString())).thenReturn(""String_Node_Str"");
  IResourcePoolService resPoolSvc=context.getBean(""String_Node_Str"",IResourcePoolService.class);
  IDatastoreService dsSvc=context.getBean(""String_Node_Str"",IDatastoreService.class);
  INetworkService netSvc=context.getBean(""String_Node_Str"",INetworkService.class);
  cleanUpUtils=new TestResourceCleanupUtils();
  cleanUpUtils.setDsSvc(dsSvc);
  cleanUpUtils.setNetSvc(netSvc);
  cleanUpUtils.setResPoolSvc(resPoolSvc);
  cleanupResources();
  try {
    Set<String> rpNames=resPoolSvc.getAllRPNames();
    logger.info(""String_Node_Str"" + rpNames);
    resPoolSvc.addResourcePool(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  try {
    resPoolSvc.addResourcePool(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  try {
    resPoolSvc.addResourcePool(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  try {
    resPoolSvc.addResourcePool(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  try {
    resPoolSvc.addResourcePool(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  try {
    resPoolSvc.addResourcePool(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  try {
    netSvc.addDhcpNetwork(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  List<String> sharedStores=new ArrayList<String>();
  sharedStores.add(""String_Node_Str"");
  sharedStores.add(""String_Node_Str"");
  try {
    clusterConfigMgr.getDatastoreMgr().addDatastores(""String_Node_Str"",DatastoreType.SHARED,sharedStores,false);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  List<String> localStores=new ArrayList<String>();
  localStores.add(""String_Node_Str"");
  localStores.add(""String_Node_Str"");
  try {
    clusterConfigMgr.getDatastoreMgr().addDatastores(""String_Node_Str"",DatastoreType.LOCAL,localStores,false);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
  List<IpBlock> ipBlocks=new ArrayList<IpBlock>();
  IpBlock ip1=new IpBlock();
  ip1.setBeginIp(""String_Node_Str"");
  ip1.setEndIp(""String_Node_Str"");
  ipBlocks.add(ip1);
  IpBlock ip2=new IpBlock();
  ip2.setBeginIp(""String_Node_Str"");
  ip2.setEndIp(""String_Node_Str"");
  ipBlocks.add(ip2);
  IpBlock ip3=new IpBlock();
  ip3.setBeginIp(""String_Node_Str"");
  ip3.setEndIp(""String_Node_Str"");
  ipBlocks.add(ip3);
  try {
    netSvc.addIpPoolNetwork(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",null,ipBlocks);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
  }
}"
48630,"public String toString(){
  return null;
}","public String toString(){
  return (new Gson()).toJson(this);
}"
48631,"public static SoftwareManagerCollectorException ILLEGAL_ACCESS(Exception ex,String name){
  return new SoftwareManagerCollectorException(ex,""String_Node_Str"");
}","public static SoftwareManagerCollectorException ILLEGAL_ACCESS(Exception ex,String name){
  return new SoftwareManagerCollectorException(ex,""String_Node_Str"",name);
}"
48632,"public static SoftwareManagerCollectorException CAN_NOT_INSTANTIATE(Exception ex,String name){
  return new SoftwareManagerCollectorException(ex,""String_Node_Str"");
}","public static SoftwareManagerCollectorException CAN_NOT_INSTANTIATE(Exception ex,String name){
  return new SoftwareManagerCollectorException(ex,""String_Node_Str"",name);
}"
48633,"public static SoftwareManagerCollectorException ECHO_FAILURE(String name){
  return new SoftwareManagerCollectorException(null,""String_Node_Str"");
}","public static SoftwareManagerCollectorException ECHO_FAILURE(String name){
  return new SoftwareManagerCollectorException(null,""String_Node_Str"",name);
}"
48634,"public static SoftwareManagerCollectorException DUPLICATE_NAME(String name){
  return new SoftwareManagerCollectorException(null,""String_Node_Str"");
}","public static SoftwareManagerCollectorException DUPLICATE_NAME(String name){
  return new SoftwareManagerCollectorException(null,""String_Node_Str"",name);
}"
48635,"public static SoftwareManagerCollectorException CLASS_NOT_DEFINED(String name){
  return new SoftwareManagerCollectorException(null,""String_Node_Str"");
}","public static SoftwareManagerCollectorException CLASS_NOT_DEFINED(String name){
  return new SoftwareManagerCollectorException(null,""String_Node_Str"",name);
}"
48636,"@Transactional public ClusterEntity createClusterConfig(ClusterCreate cluster){
  String name=cluster.getName();
  if (name == null || name.isEmpty()) {
    throw ClusterConfigException.CLUSTER_NAME_MISSING();
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  DistroRead distro=distroMgr.getDistroByName(cluster.getDistro());
  if (cluster.getDistro() == null || distro == null) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",cluster.getDistro());
  }
  String appManager=cluster.getAppManager();
  if (appManager == null) {
    appManager=new String(""String_Node_Str"");
  }
  SoftwareManager softwareManager=softwareManagerCollector.getSoftwareManager(appManager);
  if (softwareManager == null) {
    logger.error(""String_Node_Str"");
    throw new ClusterConfigException(null,""String_Node_Str"");
  }
  try {
    softwareManager.validateRoles(cluster.toBlueprint(),distro.getRoles());
    cluster.validateClusterCreate(failedMsgList,warningMsgList);
  }
 catch (  SoftwareManagementPluginException e) {
    failedMsgList.add(e.getFailedMsgList().toString());
  }
  if (!failedMsgList.isEmpty()) {
    throw ClusterConfigException.INVALID_SPEC(failedMsgList);
  }
  if (!validateRacksInfo(cluster,failedMsgList)) {
    throw ClusterConfigException.INVALID_PLACEMENT_POLICIES(failedMsgList);
  }
  transformHDFSUrl(cluster);
  try {
    ClusterEntity entity=clusterEntityMgr.findByName(name);
    if (entity != null) {
      logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
      throw BddException.ALREADY_EXISTS(""String_Node_Str"",name);
    }
    logger.debug(""String_Node_Str"" + name);
    Gson gson=new Gson();
    ClusterEntity clusterEntity=new ClusterEntity(name);
    clusterEntity.setAppManagerName(cluster.getAppManager());
    clusterEntity.setDistro(cluster.getDistro());
    clusterEntity.setDistroVendor(cluster.getDistroVendor());
    clusterEntity.setDistroVersion(cluster.getDistroVersion());
    clusterEntity.setAppManager(cluster.getAppManager());
    clusterEntity.setStartAfterDeploy(true);
    clusterEntity.setPassword(cluster.getPassword());
    clusterEntity.setVersion(clusterEntityMgr.getServerVersion());
    if (cluster.containsComputeOnlyNodeGroups()) {
      clusterEntity.setAutomationEnable(automationEnable);
    }
 else {
      clusterEntity.setAutomationEnable(null);
    }
    clusterEntity.setVhmMinNum(-1);
    clusterEntity.setVhmMaxNum(-1);
    if (cluster.getRpNames() != null && cluster.getRpNames().size() > 0) {
      logger.debug(""String_Node_Str"" + cluster.getRpNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcRpNameList(cluster.getRpNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    if (cluster.getDsNames() != null && !cluster.getDsNames().isEmpty()) {
      logger.debug(""String_Node_Str"" + cluster.getDsNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcDatastoreNameList(cluster.getDsNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    clusterEntity.setNetworkConfig(validateAndConvertNetNamesToNetConfigs(cluster.getNetworkConfig(),cluster.getDistroVendor().equalsIgnoreCase(Constants.MAPR_VENDOR)));
    clusterEntity.setVhmJobTrackerPort(""String_Node_Str"");
    if (cluster.getConfiguration() != null && cluster.getConfiguration().size() > 0) {
      CommonClusterExpandPolicy.validateAppConfig(cluster.getConfiguration(),cluster.isValidateConfig());
      clusterEntity.setHadoopConfig((new Gson()).toJson(cluster.getConfiguration()));
      updateVhmJobTrackerPort(cluster,clusterEntity);
    }
    NodeGroupCreate[] groups=cluster.getNodeGroups();
    if (groups != null && groups.length > 0) {
      clusterEntity.setNodeGroups(convertNodeGroupsToEntities(gson,clusterEntity,cluster.getDistro(),groups,cluster.isValidateConfig()));
      validateMemorySize(clusterEntity.getNodeGroups(),failedMsgList);
      if (!failedMsgList.isEmpty()) {
        throw ClusterConfigException.INVALID_SPEC(failedMsgList);
      }
    }
    if (cluster.getTopologyPolicy() == null) {
      clusterEntity.setTopologyPolicy(TopologyType.NONE);
    }
 else {
      clusterEntity.setTopologyPolicy(cluster.getTopologyPolicy());
    }
    if (clusterEntity.getTopologyPolicy() == TopologyType.HVE) {
      boolean hveSupported=false;
      if (clusterEntity.getDistro() != null) {
        DistroRead dr=distroMgr.getDistroByName(clusterEntity.getDistro());
        if (dr != null) {
          hveSupported=dr.isHveSupported();
        }
      }
      if (!hveSupported) {
        throw ClusterConfigException.INVALID_TOPOLOGY_POLICY(clusterEntity.getTopologyPolicy(),""String_Node_Str"");
      }
    }
    clusterEntityMgr.insert(clusterEntity);
    logger.debug(""String_Node_Str"" + name);
    return clusterEntity;
  }
 catch (  UniqueConstraintViolationException ex) {
    logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
    throw BddException.ALREADY_EXISTS(ex,""String_Node_Str"",name);
  }
}","@Transactional public ClusterEntity createClusterConfig(ClusterCreate cluster){
  String name=cluster.getName();
  if (name == null || name.isEmpty()) {
    throw ClusterConfigException.CLUSTER_NAME_MISSING();
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  DistroRead distro=distroMgr.getDistroByName(cluster.getDistro());
  if (cluster.getDistro() == null || distro == null) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",cluster.getDistro());
  }
  String appManager=cluster.getAppManager();
  if (appManager == null) {
    appManager=new String(""String_Node_Str"");
  }
  SoftwareManager softwareManager=softwareManagerCollector.getSoftwareManager(appManager);
  if (softwareManager == null) {
    logger.error(""String_Node_Str"");
    throw new ClusterConfigException(null,""String_Node_Str"");
  }
  try {
    softwareManager.validateRoles(cluster.toBlueprint(),distro.getRoles());
    cluster.validateClusterCreate(failedMsgList,warningMsgList);
  }
 catch (  SoftwareManagementPluginException e) {
    failedMsgList.add(e.getFailedMsgList().toString());
  }
  if (!failedMsgList.isEmpty()) {
    throw ClusterConfigException.INVALID_SPEC(failedMsgList);
  }
  if (!validateRacksInfo(cluster,failedMsgList)) {
    throw ClusterConfigException.INVALID_PLACEMENT_POLICIES(failedMsgList);
  }
  transformHDFSUrl(cluster);
  try {
    ClusterEntity entity=clusterEntityMgr.findByName(name);
    if (entity != null) {
      logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
      throw BddException.ALREADY_EXISTS(""String_Node_Str"",name);
    }
    logger.debug(""String_Node_Str"" + name);
    Gson gson=new Gson();
    ClusterEntity clusterEntity=new ClusterEntity(name);
    clusterEntity.setAppManager(cluster.getAppManager());
    clusterEntity.setDistro(cluster.getDistro());
    clusterEntity.setDistroVendor(cluster.getDistroVendor());
    clusterEntity.setDistroVersion(cluster.getDistroVersion());
    clusterEntity.setAppManager(cluster.getAppManager());
    clusterEntity.setStartAfterDeploy(true);
    clusterEntity.setPassword(cluster.getPassword());
    clusterEntity.setVersion(clusterEntityMgr.getServerVersion());
    if (cluster.containsComputeOnlyNodeGroups()) {
      clusterEntity.setAutomationEnable(automationEnable);
    }
 else {
      clusterEntity.setAutomationEnable(null);
    }
    clusterEntity.setVhmMinNum(-1);
    clusterEntity.setVhmMaxNum(-1);
    if (cluster.getRpNames() != null && cluster.getRpNames().size() > 0) {
      logger.debug(""String_Node_Str"" + cluster.getRpNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcRpNameList(cluster.getRpNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    if (cluster.getDsNames() != null && !cluster.getDsNames().isEmpty()) {
      logger.debug(""String_Node_Str"" + cluster.getDsNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcDatastoreNameList(cluster.getDsNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    clusterEntity.setNetworkConfig(validateAndConvertNetNamesToNetConfigs(cluster.getNetworkConfig(),cluster.getDistroVendor().equalsIgnoreCase(Constants.MAPR_VENDOR)));
    clusterEntity.setVhmJobTrackerPort(""String_Node_Str"");
    if (cluster.getConfiguration() != null && cluster.getConfiguration().size() > 0) {
      CommonClusterExpandPolicy.validateAppConfig(cluster.getConfiguration(),cluster.isValidateConfig());
      clusterEntity.setHadoopConfig((new Gson()).toJson(cluster.getConfiguration()));
      updateVhmJobTrackerPort(cluster,clusterEntity);
    }
    NodeGroupCreate[] groups=cluster.getNodeGroups();
    if (groups != null && groups.length > 0) {
      clusterEntity.setNodeGroups(convertNodeGroupsToEntities(gson,clusterEntity,cluster.getDistro(),groups,cluster.isValidateConfig()));
      validateMemorySize(clusterEntity.getNodeGroups(),failedMsgList);
      if (!failedMsgList.isEmpty()) {
        throw ClusterConfigException.INVALID_SPEC(failedMsgList);
      }
    }
    if (cluster.getTopologyPolicy() == null) {
      clusterEntity.setTopologyPolicy(TopologyType.NONE);
    }
 else {
      clusterEntity.setTopologyPolicy(cluster.getTopologyPolicy());
    }
    if (clusterEntity.getTopologyPolicy() == TopologyType.HVE) {
      boolean hveSupported=false;
      if (clusterEntity.getDistro() != null) {
        DistroRead dr=distroMgr.getDistroByName(clusterEntity.getDistro());
        if (dr != null) {
          hveSupported=dr.isHveSupported();
        }
      }
      if (!hveSupported) {
        throw ClusterConfigException.INVALID_TOPOLOGY_POLICY(clusterEntity.getTopologyPolicy(),""String_Node_Str"");
      }
    }
    clusterEntityMgr.insert(clusterEntity);
    logger.debug(""String_Node_Str"" + name);
    return clusterEntity;
  }
 catch (  UniqueConstraintViolationException ex) {
    logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
    throw BddException.ALREADY_EXISTS(ex,""String_Node_Str"",name);
  }
}"
48637,"public static ClusteringServiceException CREATE_RESOURCE_POOL_FAILED(String clusterName){
  return new ClusteringServiceException(null,""String_Node_Str"",clusterName);
}","public static ClusteringServiceException CREATE_RESOURCE_POOL_FAILED(String errMessage){
  return new ClusteringServiceException(null,""String_Node_Str"",errMessage);
}"
48638,"@Override public void doWithRequest(ClientHttpRequest request) throws IOException {
  request.getBody().write((""String_Node_Str"" + username + ""String_Node_Str""+ password+ ""String_Node_Str"").getBytes());
}","@Override public void doWithRequest(ClientHttpRequest request) throws IOException {
  Base64 base64=new Base64();
  String encodeUserName=new String(base64.encode(username.getBytes(""String_Node_Str"")));
  request.getBody().write((""String_Node_Str"" + encodeUserName + ""String_Node_Str""+ password+ ""String_Node_Str"").getBytes());
}"
48639,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private <T>ResponseEntity<T> exchange(final String url,final String username,final String password,HttpMethod method,Class<T> responseType){
  return client.execute(url,HttpMethod.POST,new RequestCallback(){
    @Override public void doWithRequest(    ClientHttpRequest request) throws IOException {
      request.getBody().write((""String_Node_Str"" + username + ""String_Node_Str""+ password+ ""String_Node_Str"").getBytes());
    }
  }
,new ResponseEntityResponseExtractor<T>(responseType));
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private <T>ResponseEntity<T> exchange(final String url,final String username,final String password,HttpMethod method,Class<T> responseType){
  return client.execute(url,HttpMethod.POST,new RequestCallback(){
    @Override public void doWithRequest(    ClientHttpRequest request) throws IOException {
      Base64 base64=new Base64();
      String encodeUserName=new String(base64.encode(username.getBytes(""String_Node_Str"")));
      request.getBody().write((""String_Node_Str"" + encodeUserName + ""String_Node_Str""+ password+ ""String_Node_Str"").getBytes());
    }
  }
,new ResponseEntityResponseExtractor<T>(responseType));
}"
48640,"public void authenticateUser(String name,String password) throws Exception {
  Client vmomiClient=null;
  try {
    URI uri=new URI(serviceUrl);
    HttpConfiguration httpConfig=new HttpConfigurationImpl();
    httpConfig.setThumbprintVerifier(getThumbprintVerifier());
    HttpClientConfiguration clientConfig=HttpClientConfiguration.Factory.newInstance();
    clientConfig.setHttpConfiguration(httpConfig);
    vmomiClient=Client.Factory.createClient(uri,version,clientConfig);
    ManagedObjectReference svcRef=new ManagedObjectReference();
    svcRef.setType(""String_Node_Str"");
    svcRef.setValue(""String_Node_Str"");
    ServiceInstance instance=vmomiClient.createStub(ServiceInstance.class,svcRef);
    ServiceInstanceContent instanceContent=instance.retrieveContent();
    SessionManager sessionManager=vmomiClient.createStub(SessionManager.class,instanceContent.getSessionManager());
    sessionManager.login(name,password,sessionManager.getDefaultLocale());
    sessionManager.logout();
  }
  finally {
    if (vmomiClient != null) {
      vmomiClient.shutdown();
    }
  }
}","public void authenticateUser(String name,String password) throws Exception {
  Client vmomiClient=null;
  try {
    URI uri=new URI(serviceUrl);
    HttpConfiguration httpConfig=new HttpConfigurationImpl();
    httpConfig.setThumbprintVerifier(getThumbprintVerifier());
    HttpClientConfiguration clientConfig=HttpClientConfiguration.Factory.newInstance();
    clientConfig.setHttpConfiguration(httpConfig);
    vmomiClient=Client.Factory.createClient(uri,version,clientConfig);
    ManagedObjectReference svcRef=new ManagedObjectReference();
    svcRef.setType(""String_Node_Str"");
    svcRef.setValue(""String_Node_Str"");
    ServiceInstance instance=vmomiClient.createStub(ServiceInstance.class,svcRef);
    ServiceInstanceContent instanceContent=instance.retrieveContent();
    SessionManager sessionManager=vmomiClient.createStub(SessionManager.class,instanceContent.getSessionManager());
    Base64 base64=new Base64();
    name=name.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
    name=new String(base64.decode(name.getBytes()),""String_Node_Str"");
    sessionManager.login(name,password,sessionManager.getDefaultLocale());
    sessionManager.logout();
  }
  finally {
    if (vmomiClient != null) {
      vmomiClient.shutdown();
    }
  }
}"
48641,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST,consumes=""String_Node_Str"") @ResponseStatus(HttpStatus.OK) public void addPlugin(@RequestBody final PluginAdd pluginAdd){
  networkSvc.addIpPoolNetwork(na.getName(),na.getPortGroup(),na.getNetmask(),na.getGateway(),na.getDns1(),na.getDns2(),na.getIpBlocks());
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST,consumes=""String_Node_Str"") @ResponseStatus(HttpStatus.OK) public void addPlugin(@RequestBody final PluginAdd pluginAdd){
  pluginService.addPlugin(pluginAdd);
}"
48642,"public static void printCmdFailure(String objectType,String name,String opName,String result,String message){
  if (isJansiAvailable() && !isBlank(name)) {
    try {
      name=transferEncoding(name);
    }
 catch (    UnsupportedEncodingException e) {
      logger.warn(""String_Node_Str"" + e.getMessage());
    }
  }
  if (!isBlank(name)) {
    System.out.println(objectType + ""String_Node_Str"" + name+ ""String_Node_Str""+ opName+ ""String_Node_Str""+ result+ ""String_Node_Str""+ message);
  }
 else   if (!isBlank(opName)) {
    System.out.println(objectType + ""String_Node_Str"" + opName+ ""String_Node_Str""+ result+ ""String_Node_Str""+ message);
  }
 else {
    System.out.println(objectType + ""String_Node_Str"" + result+ ""String_Node_Str""+ message);
  }
}","public static void printCmdFailure(String objectType,String name,String opName,String result,String message){
  if (isJansiAvailable() && !isBlank(name)) {
    try {
      name=transferEncoding(name);
    }
 catch (    UnsupportedEncodingException|CliException e) {
      logger.warn(""String_Node_Str"" + e.getMessage());
    }
  }
  if (!isBlank(name)) {
    System.out.println(objectType + ""String_Node_Str"" + name+ ""String_Node_Str""+ opName+ ""String_Node_Str""+ result+ ""String_Node_Str""+ message);
  }
 else   if (!isBlank(opName)) {
    System.out.println(objectType + ""String_Node_Str"" + opName+ ""String_Node_Str""+ result+ ""String_Node_Str""+ message);
  }
 else {
    System.out.println(objectType + ""String_Node_Str"" + result+ ""String_Node_Str""+ message);
  }
}"
48643,"public static void printCmdSuccess(String objectType,String name,String result){
  if (isJansiAvailable() && !isBlank(name)) {
    try {
      name=transferEncoding(name);
    }
 catch (    UnsupportedEncodingException e) {
      logger.warn(""String_Node_Str"" + e.getMessage());
    }
  }
  if (!isBlank(name)) {
    System.out.println(objectType + ""String_Node_Str"" + name+ ""String_Node_Str""+ result);
  }
 else {
    System.out.println(objectType + ""String_Node_Str"" + result);
  }
}","public static void printCmdSuccess(String objectType,String name,String result){
  if (isJansiAvailable() && !isBlank(name)) {
    try {
      name=transferEncoding(name);
    }
 catch (    UnsupportedEncodingException|CliException e) {
      logger.warn(""String_Node_Str"" + e.getMessage());
    }
  }
  if (!isBlank(name)) {
    System.out.println(objectType + ""String_Node_Str"" + name+ ""String_Node_Str""+ result);
  }
 else {
    System.out.println(objectType + ""String_Node_Str"" + result);
  }
}"
48644,"public static String transferEncoding(final String src) throws UnsupportedEncodingException {
  int codePage=Kernel32.GetConsoleOutputCP();
  String outputEncoding=""String_Node_Str"";
  if (codePage == 932) {
    outputEncoding=""String_Node_Str"";
  }
 else {
    outputEncoding=""String_Node_Str"" + codePage;
  }
  return new String(src.getBytes(outputEncoding),Configuration.getEncoding());
}","public static String transferEncoding(final String src) throws UnsupportedEncodingException, CliException {
  int codePage=Kernel32.GetConsoleOutputCP();
  String outputEncoding=""String_Node_Str"" + codePage;
  if (!java.nio.charset.Charset.isSupported(outputEncoding)) {
    outputEncoding=""String_Node_Str"" + codePage;
    if (!java.nio.charset.Charset.isSupported(outputEncoding)) {
      String errorMsg=""String_Node_Str"" + codePage + ""String_Node_Str"";
      logger.error(""String_Node_Str"" + errorMsg);
      throw new CliException(errorMsg);
    }
  }
  return new String(src.getBytes(outputEncoding),Configuration.getEncoding());
}"
48645,"private String getInputedPassword(String promptMsg){
  try {
    ConsoleReader reader=new ConsoleReader();
    reader.setPrompt(promptMsg);
    String password=null;
    password=reader.readLine(Character.valueOf('*'));
    if (isValidPassword(password)) {
      return password;
    }
 else {
      return null;
    }
  }
 catch (  IOException e) {
    return null;
  }
}","private String getInputedPassword(String promptMsg){
  try {
    ConsoleReader reader=new ConsoleReader();
    reader.setPrompt(promptMsg);
    String password=null;
    try {
      password=reader.readLine(Character.valueOf('*'));
    }
 catch (    IllegalArgumentException e) {
      if (e.getMessage().contains(""String_Node_Str"")) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,null,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PASSWORD_CHARACTER_REQUIREMENT);
        return null;
      }
 else {
        throw e;
      }
    }
    if (isValidPassword(password)) {
      return password;
    }
 else {
      return null;
    }
  }
 catch (  IOException e) {
    return null;
  }
}"
48646,"public static void printCmdFailure(String objectType,String name,String opName,String result,String message){
  if (!isBlank(name)) {
    System.out.println(objectType + ""String_Node_Str"" + name+ ""String_Node_Str""+ opName+ ""String_Node_Str""+ result+ ""String_Node_Str""+ message);
  }
 else   if (!isBlank(opName)) {
    System.out.println(objectType + ""String_Node_Str"" + opName+ ""String_Node_Str""+ result+ ""String_Node_Str""+ message);
  }
 else {
    System.out.println(objectType + ""String_Node_Str"" + result+ ""String_Node_Str""+ message);
  }
}","public static void printCmdFailure(String objectType,String name,String opName,String result,String message){
  if (isJansiAvailable()) {
    try {
      name=transcoding(name);
    }
 catch (    UnsupportedEncodingException e) {
      logger.warn(""String_Node_Str"" + e.getMessage());
    }
  }
  if (!isBlank(name)) {
    System.out.println(objectType + ""String_Node_Str"" + name+ ""String_Node_Str""+ opName+ ""String_Node_Str""+ result+ ""String_Node_Str""+ message);
  }
 else   if (!isBlank(opName)) {
    System.out.println(objectType + ""String_Node_Str"" + opName+ ""String_Node_Str""+ result+ ""String_Node_Str""+ message);
  }
 else {
    System.out.println(objectType + ""String_Node_Str"" + result+ ""String_Node_Str""+ message);
  }
}"
48647,"public static void printCmdSuccess(String objectType,String name,String result){
  if (!isBlank(name)) {
    System.out.println(objectType + ""String_Node_Str"" + name+ ""String_Node_Str""+ result);
  }
 else {
    System.out.println(objectType + ""String_Node_Str"" + result);
  }
}","public static void printCmdSuccess(String objectType,String name,String result){
  if (isJansiAvailable()) {
    try {
      name=transcoding(name);
    }
 catch (    UnsupportedEncodingException e) {
      logger.warn(""String_Node_Str"" + e.getMessage());
    }
  }
  if (!isBlank(name)) {
    System.out.println(objectType + ""String_Node_Str"" + name+ ""String_Node_Str""+ result);
  }
 else {
    System.out.println(objectType + ""String_Node_Str"" + result);
  }
}"
48648,"public static void prettyJsonOutput(Object object,String fileName) throws Exception {
  OutputStream out=null;
  try {
    if (fileName != null) {
      out=new FileOutputStream(fileName);
    }
 else {
      out=System.out;
    }
    JsonFactory factory=new JsonFactory();
    JsonGenerator generator=factory.createJsonGenerator(out);
    ObjectMapper mapper=getMapper();
    mapper.setSerializationInclusion(Inclusion.NON_NULL);
    generator.setCodec(mapper);
    DefaultPrettyPrinter prettyPrinter=new DefaultPrettyPrinter();
    Indenter indenter=new Lf2SpacesIndenter();
    prettyPrinter.indentArraysWith(indenter);
    generator.setPrettyPrinter(prettyPrinter);
    generator.writeObject(object);
    if (fileName == null) {
      System.out.println();
    }
 else {
      File file=new File(fileName);
      String filePath=file.getAbsolutePath();
      if (isJansiAvailable()) {
        WindowsTerminal ansiTerminal=new WindowsTerminal(){
          @Override public synchronized boolean isAnsiSupported(){
            return true;
          }
        }
;
        ansiTerminal.init();
        String outEncoding=ansiTerminal.getOutputEncoding() != null ? ansiTerminal.getOutputEncoding() : Configuration.getEncoding();
        filePath=new String(filePath.getBytes(outEncoding),Configuration.getEncoding());
      }
      System.out.println(""String_Node_Str"" + filePath);
    }
  }
  finally {
    if (out != null && !(out instanceof PrintStream)) {
      out.close();
    }
  }
}","public static void prettyJsonOutput(Object object,String fileName) throws Exception {
  OutputStream out=null;
  try {
    if (fileName != null) {
      out=new FileOutputStream(fileName);
    }
 else {
      out=System.out;
    }
    JsonFactory factory=new JsonFactory();
    JsonGenerator generator=factory.createJsonGenerator(out);
    ObjectMapper mapper=getMapper();
    mapper.setSerializationInclusion(Inclusion.NON_NULL);
    generator.setCodec(mapper);
    DefaultPrettyPrinter prettyPrinter=new DefaultPrettyPrinter();
    Indenter indenter=new Lf2SpacesIndenter();
    prettyPrinter.indentArraysWith(indenter);
    generator.setPrettyPrinter(prettyPrinter);
    generator.writeObject(object);
    if (fileName == null) {
      System.out.println();
    }
 else {
      File file=new File(fileName);
      String filePath=file.getAbsolutePath();
      if (isJansiAvailable()) {
        filePath=transcoding(filePath);
      }
      System.out.println(""String_Node_Str"" + filePath);
    }
  }
  finally {
    if (out != null && !(out instanceof PrintStream)) {
      out.close();
    }
  }
}"
48649,"private static boolean isJansiAvailable(){
  return ClassUtils.isPresent(""String_Node_Str"",JLineShell.class.getClassLoader()) && OsUtils.isWindows() && System.getProperty(""String_Node_Str"") == null;
}","public static boolean isJansiAvailable(){
  return ClassUtils.isPresent(""String_Node_Str"",JLineShell.class.getClassLoader()) && OsUtils.isWindows() && System.getProperty(""String_Node_Str"") == null;
}"
48650,"/** 
 * Show a table(include table column names and table contents) by left justifying. More specifically, the   {@code columnNamesWithGetMethodNames}argument is a map struct, the key is table column name and value is method name list which it will be invoked by reflection. The   {@code entities}argument is traversed entity array.It is source of table data. In addition,the method name must be each of the   {@code entities} argument 'smember. The  {@code spacesBeforeStart} argument is whitespace in the frontof the row. <p>
 * @param columnNamesWithGetMethodNames the container of table column name and invoked method name.
 * @param entities the traversed entity array.
 * @param spacesBeforeStart the whitespace in the front of the row.
 * @throws Exception
 */
public static void printInTableFormat(LinkedHashMap<String,List<String>> columnNamesWithGetMethodNames,Object[] entities,String spacesBeforeStart) throws Exception {
  if (entities != null && entities.length > 0) {
    int columnNum=columnNamesWithGetMethodNames.size();
    String[][] table=new String[entities.length + 1][columnNum];
    String[] tableHeader=new String[columnNum];
    Set<String> columnNames=columnNamesWithGetMethodNames.keySet();
    columnNames.toArray(tableHeader);
    table[0]=tableHeader;
    Collection<List<String>> getMethodNamesCollect=columnNamesWithGetMethodNames.values();
    int i=1;
    for (    Object entity : entities) {
      int j=0;
      for (      List<String> getMethodNames : getMethodNamesCollect) {
        Object tempValue=null;
        int k=0;
        for (        String methodName : getMethodNames) {
          if (tempValue == null)           tempValue=entity;
          Object value=tempValue.getClass().getMethod(methodName).invoke(tempValue);
          if (k == getMethodNames.size() - 1) {
            table[i][j]=value == null ? ""String_Node_Str"" : ((value instanceof Double) ? String.valueOf(round(((Double)value).doubleValue(),2,BigDecimal.ROUND_FLOOR)) : value.toString());
            j++;
          }
 else {
            tempValue=value;
            k++;
          }
        }
      }
      i++;
    }
    printTable(table,spacesBeforeStart);
  }
}","/** 
 * Show a table(include table column names and table contents) by left justifying. More specifically, the   {@code columnNamesWithGetMethodNames}argument is a map struct, the key is table column name and value is method name list which it will be invoked by reflection. The   {@code entities}argument is traversed entity array.It is source of table data. In addition,the method name must be each of the   {@code entities} argument 'smember. The  {@code spacesBeforeStart} argument is whitespace in the frontof the row. <p>
 * @param columnNamesWithGetMethodNames the container of table column name and invoked method name.
 * @param entities the traversed entity array.
 * @param spacesBeforeStart the whitespace in the front of the row.
 * @throws Exception
 */
public static void printInTableFormat(LinkedHashMap<String,List<String>> columnNamesWithGetMethodNames,Object[] entities,String spacesBeforeStart) throws Exception {
  if (entities != null && entities.length > 0) {
    int columnNum=columnNamesWithGetMethodNames.size();
    String[][] table=new String[entities.length + 1][columnNum];
    String[] tableHeader=new String[columnNum];
    Set<String> columnNames=columnNamesWithGetMethodNames.keySet();
    columnNames.toArray(tableHeader);
    table[0]=tableHeader;
    Collection<List<String>> getMethodNamesCollect=columnNamesWithGetMethodNames.values();
    int i=1;
    for (    Object entity : entities) {
      int j=0;
      for (      List<String> getMethodNames : getMethodNamesCollect) {
        Object tempValue=null;
        int k=0;
        for (        String methodName : getMethodNames) {
          if (tempValue == null)           tempValue=entity;
          Object value=tempValue.getClass().getMethod(methodName).invoke(tempValue);
          if (k == getMethodNames.size() - 1) {
            table[i][j]=value == null ? ""String_Node_Str"" : ((value instanceof Double) ? String.valueOf(round(((Double)value).doubleValue(),2,BigDecimal.ROUND_FLOOR)) : value.toString());
            if (isJansiAvailable()) {
              table[i][j]=transcoding(table[i][j]);
            }
            j++;
          }
 else {
            tempValue=value;
            k++;
          }
        }
      }
      i++;
    }
    printTable(table,spacesBeforeStart);
  }
}"
48651,"@Transactional @RetryTransaction public boolean needUpgrade(String clusterName){
  String serverVersion=getServerVersion();
  String clusterVersion=findByName(clusterName).getVersion();
  return !serverVersion.equals(clusterVersion);
}","@Transactional @RetryTransaction public boolean needUpgrade(String clusterName){
  String serverVersion=getServerVersion();
  String clusterVersion=findByName(clusterName).getVersion();
  List<NodeEntity> nodes=findAllNodes(clusterName);
  boolean allNodesUpgraded=true;
  for (  NodeEntity node : nodes) {
    if (node.canBeUpgrade() && node.needUpgrade(serverVersion)) {
      allNodesUpgraded=false;
      break;
    }
  }
  return !serverVersion.equals(clusterVersion) || !allNodesUpgraded;
}"
48652,"public ArrayList<String> setPasswordForNodes(String clusterName,ArrayList<String> ipsOfNodes,String password){
  AuAssert.check(!ipsOfNodes.isEmpty());
  logger.info(""String_Node_Str"" + clusterName);
  logger.info(""String_Node_Str"" + ipsOfNodes.toString());
  ArrayList<String> failedIPs=null;
  List<Callable<Void>> storeProcedures=new ArrayList<Callable<Void>>();
  for (  String nodeIP : ipsOfNodes) {
    SetVMPasswordSP setVMPasswordSP=new SetVMPasswordSP(nodeIP,password);
    storeProcedures.add(setVMPasswordSP);
  }
  AuAssert.check(!storeProcedures.isEmpty());
  try {
    Callable<Void>[] storeProceduresArray=storeProcedures.toArray(new Callable[0]);
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProceduresArray,callback);
    for (int i=0; i < storeProceduresArray.length; i++) {
      if (!result[i].finished || result[i].throwable != null) {
        SetVMPasswordSP sp=(SetVMPasswordSP)storeProceduresArray[i];
        String failedNodeIP=sp.getNodeIP();
        if (failedIPs == null) {
          failedIPs=new ArrayList<String>();
        }
        failedIPs.add(failedNodeIP);
      }
    }
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName);
    throw BddException.INTERNAL(e,""String_Node_Str"" + clusterName);
  }
  return failedIPs;
}","public ArrayList<String> setPasswordForNodes(String clusterName,ArrayList<String> ipsOfNodes,String password){
  AuAssert.check(!ipsOfNodes.isEmpty());
  logger.info(""String_Node_Str"" + clusterName);
  logger.info(""String_Node_Str"" + ipsOfNodes.toString());
  ArrayList<String> failedIPs=null;
  List<Callable<Void>> storeProcedures=new ArrayList<Callable<Void>>();
  for (  String nodeIP : ipsOfNodes) {
    SetVMPasswordSP setVMPasswordSP=new SetVMPasswordSP(nodeIP,password);
    storeProcedures.add(setVMPasswordSP);
  }
  AuAssert.check(!storeProcedures.isEmpty());
  try {
    Callable<Void>[] storeProceduresArray=storeProcedures.toArray(new Callable[0]);
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProceduresArray,callback);
    for (int i=0; i < storeProceduresArray.length; i++) {
      if (!result[i].finished || result[i].throwable != null) {
        SetVMPasswordSP sp=(SetVMPasswordSP)storeProceduresArray[i];
        String failedNodeIP=sp.getNodeIP();
        if (failedIPs == null) {
          failedIPs=new ArrayList<String>();
        }
        failedIPs.add(failedNodeIP);
      }
    }
  }
 catch (  Exception e) {
    String errMsg=""String_Node_Str"" + e.getMessage();
    logger.error(""String_Node_Str"" + clusterName + errMsg);
    throw BddException.INTERNAL(e,""String_Node_Str"" + clusterName + errMsg);
  }
  return failedIPs;
}"
48653,"@Override public boolean setPasswordForNode(String clusterName,String nodeIP,String password) throws Exception {
  AuAssert.check(clusterName != null && nodeIP != null && password != null);
  List<Callable<Void>> storeProcedures=new ArrayList<Callable<Void>>();
  SetVMPasswordSP setVMPasswordSP=new SetVMPasswordSP(nodeIP,password);
  storeProcedures.add(setVMPasswordSP);
  AuAssert.check(!storeProcedures.isEmpty());
  try {
    Callable<Void>[] storeProceduresArray=storeProcedures.toArray(new Callable[0]);
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProceduresArray,callback);
    if (result[0].finished && result[0].throwable == null) {
      return true;
    }
    return false;
  }
 catch (  Exception e) {
    throw BddException.INTERNAL(e,""String_Node_Str"" + nodeIP + ""String_Node_Str""+ clusterName);
  }
}","@Override public boolean setPasswordForNode(String clusterName,String nodeIP,String password) throws Exception {
  AuAssert.check(clusterName != null && nodeIP != null && password != null);
  List<Callable<Void>> storeProcedures=new ArrayList<Callable<Void>>();
  SetVMPasswordSP setVMPasswordSP=new SetVMPasswordSP(nodeIP,password);
  storeProcedures.add(setVMPasswordSP);
  AuAssert.check(!storeProcedures.isEmpty());
  try {
    Callable<Void>[] storeProceduresArray=storeProcedures.toArray(new Callable[0]);
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProceduresArray,callback);
    if (result[0].finished && result[0].throwable == null) {
      return true;
    }
    return false;
  }
 catch (  Exception e) {
    throw BddException.INTERNAL(e,""String_Node_Str"" + nodeIP + ""String_Node_Str""+ clusterName+ ""String_Node_Str""+ e.getMessage());
  }
}"
48654,"/** 
 * @param vcVm
 * @param portGroup
 * @param nicEntity update nicEntity if it is not null
 * @return IPv4 address this nic
 * @throws Exception
 */
private static String inspectNicInfoWithoutSession(final VcVirtualMachine vcVm,final String portGroup,final NicEntity nicEntity) throws Exception {
  GuestInfo guestInfo=vcVm.queryGuest();
  NicInfo[] nicInfos=guestInfo.getNet();
  String ipaddress=Constants.NULL_IPV4_ADDRESS;
  if (nicInfos == null || nicInfos.length == 0) {
    return ipaddress;
  }
  for (  NicInfo nicInfo : nicInfos) {
    if (nicInfo.getNetwork() == null || !nicInfo.getNetwork().equals(portGroup)) {
      continue;
    }
    if (nicInfo.getIpConfig() == null || nicInfo.getIpConfig().getIpAddress() == null || nicInfo.getIpConfig().getIpAddress().length == 0) {
      continue;
    }
    if (nicEntity != null) {
      nicEntity.setMacAddress(nicInfo.getMacAddress());
      nicEntity.setConnected(nicInfo.isConnected());
    }
    for (    IpAddress info : nicInfo.getIpConfig().getIpAddress()) {
      if (info.getIpAddress() != null && sun.net.util.IPAddressUtil.isIPv4LiteralAddress(info.getIpAddress())) {
        ipaddress=info.getIpAddress();
        if (nicEntity != null) {
          nicEntity.setIpv4Address(ipaddress);
        }
      }
      if (info.getIpAddress() != null && sun.net.util.IPAddressUtil.isIPv6LiteralAddress(info.getIpAddress())) {
        if (nicEntity != null) {
          nicEntity.setIpv6Address(info.getIpAddress());
        }
      }
    }
  }
  return ipaddress;
}","/** 
 * @param vcVm
 * @param portGroup
 * @param nicEntity update nicEntity if it is not null
 * @return IPv4 address this nic
 * @throws Exception
 */
private static String inspectNicInfoWithoutSession(final VcVirtualMachine vcVm,final String portGroup,final NicEntity nicEntity) throws Exception {
  GuestInfo guestInfo=vcVm.queryGuest();
  NicInfo[] nicInfos=guestInfo.getNet();
  String ipaddress=Constants.NULL_IPV4_ADDRESS;
  if (nicInfos == null || nicInfos.length == 0) {
    return ipaddress;
  }
  for (  NicInfo nicInfo : nicInfos) {
    if (nicInfo.getNetwork() == null || !nicInfo.getNetwork().equals(portGroup)) {
      continue;
    }
    if (nicEntity != null) {
      nicEntity.setMacAddress(nicInfo.getMacAddress());
      nicEntity.setConnected(nicInfo.isConnected());
    }
    if (nicInfo.getIpConfig() == null) {
      if (nicInfo.getIpAddress() == null || nicInfo.getIpAddress().length == 0) {
        continue;
      }
      for (      String addr : nicInfo.getIpAddress()) {
        if (sun.net.util.IPAddressUtil.isIPv4LiteralAddress(addr)) {
          nicEntity.setIpv4Address(addr);
        }
 else         if (sun.net.util.IPAddressUtil.isIPv6LiteralAddress(addr)) {
          nicEntity.setIpv6Address(addr);
        }
      }
      continue;
    }
    if (nicInfo.getIpConfig().getIpAddress() == null || nicInfo.getIpConfig().getIpAddress().length == 0) {
      continue;
    }
    for (    IpAddress info : nicInfo.getIpConfig().getIpAddress()) {
      if (info.getIpAddress() != null && sun.net.util.IPAddressUtil.isIPv4LiteralAddress(info.getIpAddress())) {
        ipaddress=info.getIpAddress();
        if (nicEntity != null) {
          nicEntity.setIpv4Address(ipaddress);
        }
      }
      if (info.getIpAddress() != null && sun.net.util.IPAddressUtil.isIPv6LiteralAddress(info.getIpAddress())) {
        if (nicEntity != null) {
          nicEntity.setIpv6Address(info.getIpAddress());
        }
      }
    }
  }
  return ipaddress;
}"
48655,"@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder){
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  ClusterCreate clusterSpec=configMgr.getClusterConfig(clusterName);
  String newPassword=clusterSpec.getPassword();
  ArrayList<String> nodeIPs=null;
  if (managementOperation == ManagementOperation.CREATE || managementOperation == ManagementOperation.RESIZE) {
    List<BaseNode> addedNodes=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_ADDED_NODES_JOB_PARAM,new TypeToken<List<BaseNode>>(){
    }
.getType());
    nodeIPs=getAddedNodeIPs(addedNodes);
  }
 else   if (managementOperation == ManagementOperation.RESUME) {
    nodeIPs=getAllNodeIPsFromEntitys(getClusterEntityMgr().findAllNodes(clusterName));
  }
 else {
    throw TaskException.EXECUTION_FAILED(""String_Node_Str"");
  }
  if (nodeIPs == null) {
    throw TaskException.EXECUTION_FAILED(""String_Node_Str"");
  }
  ArrayList<String> failedNodes=setPasswordService.setPasswordForNodes(clusterName,nodeIPs,newPassword);
  boolean success=false;
  if (failedNodes == null) {
    success=true;
  }
 else {
    logger.info(""String_Node_Str"" + failedNodes.toString());
  }
  putIntoJobExecutionContext(chunkContext,JobConstants.CLUSTER_EXISTING_NODES_JOB_PARAM,success);
  if (!success) {
    throw TaskException.EXECUTION_FAILED(""String_Node_Str"" + failedNodes.toString());
  }
  return RepeatStatus.FINISHED;
}","@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder){
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  ClusterCreate clusterSpec=configMgr.getClusterConfig(clusterName);
  String newPassword=clusterSpec.getPassword();
  ArrayList<String> nodeIPs=null;
  if (managementOperation == ManagementOperation.CREATE || managementOperation == ManagementOperation.RESIZE) {
    List<BaseNode> addedNodes=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_ADDED_NODES_JOB_PARAM,new TypeToken<List<BaseNode>>(){
    }
.getType());
    nodeIPs=getAddedNodeIPs(addedNodes);
  }
 else   if (managementOperation == ManagementOperation.RESUME) {
    nodeIPs=getAllNodeIPsFromEntitys(getClusterEntityMgr().findAllNodes(clusterName));
  }
 else {
    throw TaskException.EXECUTION_FAILED(""String_Node_Str"");
  }
  if (nodeIPs == null || nodeIPs.isEmpty()) {
    throw TaskException.EXECUTION_FAILED(""String_Node_Str"");
  }
  ArrayList<String> failedNodes=setPasswordService.setPasswordForNodes(clusterName,nodeIPs,newPassword);
  boolean success=false;
  if (failedNodes == null) {
    success=true;
  }
 else {
    logger.info(""String_Node_Str"" + failedNodes.toString());
  }
  putIntoJobExecutionContext(chunkContext,JobConstants.CLUSTER_EXISTING_NODES_JOB_PARAM,success);
  if (!success) {
    throw TaskException.EXECUTION_FAILED(""String_Node_Str"" + failedNodes.toString());
  }
  return RepeatStatus.FINISHED;
}"
48656,"@SuppressWarnings(""String_Node_Str"") @Override public boolean createVcVms(List<NetworkAdd> networkAdds,List<BaseNode> vNodes,Map<String,Set<String>> occupiedIpSets,boolean reserveRawDisks,StatusUpdater statusUpdator){
  if (vNodes.isEmpty()) {
    logger.info(""String_Node_Str"");
    return true;
  }
  updateNicLabels(vNodes);
  allocateStaticIp(vNodes,networkAdds,occupiedIpSets);
  Map<String,Folder> folders=createVcFolders(vNodes.get(0).getCluster());
  String clusterRpName=createVcResourcePools(vNodes);
  logger.info(""String_Node_Str"");
  VcVmUtil.updateVm(templateVm.getId());
  VmCreateSpec sourceSpec=new VmCreateSpec();
  sourceSpec.setVmId(templateVm.getId());
  sourceSpec.setVmName(templateVm.getName());
  sourceSpec.setTargetHost(templateVm.getHost());
  List<VmCreateSpec> specs=new ArrayList<VmCreateSpec>();
  Map<String,BaseNode> nodeMap=new HashMap<String,BaseNode>();
  for (  BaseNode vNode : vNodes) {
    nodeMap.put(vNode.getVmName(),vNode);
    vNode.setSuccess(false);
    vNode.setFinished(false);
    VmCreateSpec spec=new VmCreateSpec();
    VmSchema createSchema=getVmSchema(vNode);
    spec.setSchema(createSchema);
    String defaultPgName=null;
    GuestMachineIdSpec machineIdSpec=new GuestMachineIdSpec(networkAdds,vNode.fetchPortGroupToIpV4Map(),vNode.getPrimaryMgtPgName());
    logger.info(""String_Node_Str"" + vNode.getVmName() + ""String_Node_Str""+ machineIdSpec.toString());
    spec.setBootupConfigs(machineIdSpec.toGuestVariable());
    StartVmPostPowerOn query=new StartVmPostPowerOn(vNode.getNics().keySet(),Constants.VM_POWER_ON_WAITING_SEC);
    spec.setPostPowerOn(query);
    spec.setPrePowerOn(getPrePowerOnFunc(vNode,reserveRawDisks));
    spec.setLinkedClone(false);
    spec.setTargetDs(getVcDatastore(vNode));
    spec.setTargetFolder(folders.get(vNode.getGroupName()));
    spec.setTargetHost(VcResourceUtils.findHost(vNode.getTargetHost()));
    spec.setTargetRp(getVcResourcePool(vNode,clusterRpName));
    spec.setVmName(vNode.getVmName());
    specs.add(spec);
  }
  UpdateVmProgressCallback callback=new UpdateVmProgressCallback(getLockClusterEntityMgr(),statusUpdator,vNodes.get(0).getClusterName());
  logger.info(""String_Node_Str"");
  AuAssert.check(specs.size() > 0);
  VmSchema vmSchema=specs.get(0).getSchema();
  VcVmUtil.checkAndCreateSnapshot(vmSchema);
  List<VmCreateResult<?>> results=cloneService.createCopies(sourceSpec,cloneConcurrency,specs,callback);
  if (results == null || results.isEmpty()) {
    for (    VmCreateSpec spec : specs) {
      BaseNode node=nodeMap.get(spec.getVmName());
      node.setFinished(true);
      node.setSuccess(false);
    }
    return false;
  }
  boolean success=true;
  int total=0;
  for (  VmCreateResult<?> result : results) {
    VmCreateSpec spec=(VmCreateSpec)result.getSpec();
    BaseNode node=nodeMap.get(spec.getVmName());
    node.setVmMobId(spec.getVmId());
    node.setSuccess(true);
    node.setFinished(true);
    boolean vmSucc=VcVmUtil.setBaseNodeForVm(node,spec.getVmId());
    if (!vmSucc || !result.isSuccess()) {
      success=false;
      node.setSuccess(false);
      if (result.getErrMessage() != null) {
        node.setErrMessage(result.getErrTimestamp() + ""String_Node_Str"" + result.getErrMessage());
      }
 else {
        node.setErrMessage(result.getErrTimestamp() + ""String_Node_Str"" + node.getNodeAction());
      }
    }
 else {
      total++;
    }
  }
  logger.info(total + ""String_Node_Str"");
  return success;
}","@SuppressWarnings(""String_Node_Str"") @Override public boolean createVcVms(List<NetworkAdd> networkAdds,List<BaseNode> vNodes,Map<String,Set<String>> occupiedIpSets,boolean reserveRawDisks,StatusUpdater statusUpdator){
  if (vNodes.isEmpty()) {
    logger.info(""String_Node_Str"");
    return true;
  }
  updateNicLabels(vNodes);
  allocateStaticIp(vNodes,networkAdds,occupiedIpSets);
  Map<String,Folder> folders=createVcFolders(vNodes.get(0).getCluster());
  String clusterRpName=createVcResourcePools(vNodes);
  logger.info(""String_Node_Str"");
  VcVmUtil.updateVm(templateVm.getId());
  VmCreateSpec sourceSpec=new VmCreateSpec();
  sourceSpec.setVmId(templateVm.getId());
  sourceSpec.setVmName(templateVm.getName());
  sourceSpec.setTargetHost(templateVm.getHost());
  List<VmCreateSpec> specs=new ArrayList<VmCreateSpec>();
  Map<String,BaseNode> nodeMap=new HashMap<String,BaseNode>();
  for (  BaseNode vNode : vNodes) {
    nodeMap.put(vNode.getVmName(),vNode);
    vNode.setSuccess(false);
    vNode.setFinished(false);
    VmCreateSpec spec=new VmCreateSpec();
    VmSchema createSchema=getVmSchema(vNode);
    spec.setSchema(createSchema);
    String defaultPgName=null;
    GuestMachineIdSpec machineIdSpec=new GuestMachineIdSpec(networkAdds,vNode.fetchPortGroupToIpV4Map(),vNode.getPrimaryMgtPgName());
    logger.info(""String_Node_Str"" + vNode.getVmName() + ""String_Node_Str""+ machineIdSpec.toString());
    spec.setBootupConfigs(machineIdSpec.toGuestVariable());
    StartVmPostPowerOn query=new StartVmPostPowerOn(vNode.getNics().keySet(),Constants.VM_POWER_ON_WAITING_SEC);
    spec.setPostPowerOn(query);
    spec.setPrePowerOn(getPrePowerOnFunc(vNode,reserveRawDisks));
    spec.setLinkedClone(false);
    spec.setTargetDs(getVcDatastore(vNode));
    spec.setTargetFolder(folders.get(vNode.getGroupName()));
    spec.setTargetHost(VcResourceUtils.findHost(vNode.getTargetHost()));
    spec.setTargetRp(getVcResourcePool(vNode,clusterRpName));
    spec.setVmName(vNode.getVmName());
    specs.add(spec);
  }
  UpdateVmProgressCallback callback=new UpdateVmProgressCallback(getLockClusterEntityMgr(),statusUpdator,vNodes.get(0).getClusterName());
  logger.info(""String_Node_Str"");
  AuAssert.check(specs.size() > 0);
  VmSchema vmSchema=specs.get(0).getSchema();
  VcVmUtil.checkAndCreateSnapshot(vmSchema);
  List<VmCreateResult<?>> results=cloneService.createCopies(sourceSpec,cloneConcurrency,specs,callback);
  if (results == null || results.isEmpty()) {
    for (    VmCreateSpec spec : specs) {
      BaseNode node=nodeMap.get(spec.getVmName());
      node.setFinished(true);
      node.setSuccess(false);
    }
    return false;
  }
  boolean success=true;
  int total=0;
  for (  VmCreateResult<?> result : results) {
    VmCreateSpec spec=(VmCreateSpec)result.getSpec();
    BaseNode node=nodeMap.get(spec.getVmName());
    node.setVmMobId(spec.getVmId());
    node.setSuccess(true);
    node.setFinished(true);
    boolean vmSucc=VcVmUtil.setBaseNodeForVm(node,spec.getVmId());
    if (!vmSucc || !result.isSuccess()) {
      success=false;
      node.setSuccess(false);
      if (result.getErrMessage() != null) {
        node.setErrMessage(result.getErrTimestamp() + ""String_Node_Str"" + result.getErrMessage());
      }
 else       if (!node.getErrMessage().isEmpty()) {
        node.setErrMessage(CommonUtil.getCurrentTimestamp() + ""String_Node_Str"" + node.getNodeAction());
      }
    }
 else {
      total++;
    }
  }
  logger.info(total + ""String_Node_Str"");
  return success;
}"
48657,"public static boolean setBaseNodeForVm(BaseNode vNode,String vmId){
  if (vmId == null) {
    vNode.setNodeAction(Constants.NODE_ACTION_CLONING_FAILED);
    return false;
  }
  VcVirtualMachine vm=VcCache.getIgnoreMissing(vmId);
  if (vm == null) {
    logger.info(""String_Node_Str"" + vmId + ""String_Node_Str"");
    vNode.setNodeAction(Constants.NODE_ACTION_CLONING_FAILED);
    return false;
  }
  boolean success=true;
  for (  String portGroup : vNode.getNics().keySet()) {
    String ipv4Address=VcVmUtil.getIpAddressOfPortGroup(vm,portGroup,false);
    vNode.updateNicOfPortGroup(portGroup,ipv4Address,null,null);
  }
  if (vNode.ipsReadyV4()) {
    vNode.setSuccess(true);
    vNode.setGuestHostName(VcVmUtil.getGuestHostName(vm,false));
    vNode.setTargetHost(vm.getHost().getName());
    vNode.setVmMobId(vm.getId());
    if (vm.isPoweredOn()) {
      vNode.setNodeStatus(NodeStatus.VM_READY);
      vNode.setNodeAction(null);
    }
 else {
      vNode.setNodeStatus(NodeStatus.POWERED_OFF);
      vNode.setNodeAction(Constants.NODE_ACTION_CREATION_FAILED);
    }
  }
 else {
    vNode.setSuccess(false);
    vNode.resetIpsV4();
    if (vm != null) {
      vNode.setVmMobId(vm.getId());
      if (vm.isPoweredOn()) {
        vNode.setNodeStatus(NodeStatus.POWERED_ON);
        vNode.setNodeAction(Constants.NODE_ACTION_GET_IP_FAILED);
      }
 else {
        vNode.setNodeStatus(NodeStatus.POWERED_OFF);
        vNode.setNodeAction(Constants.NODE_ACTION_CREATION_FAILED);
      }
    }
    success=false;
    logger.error(""String_Node_Str"" + vNode.getVmName());
  }
  if (success) {
    String haFlag=vNode.getNodeGroup().getHaFlag();
    if (haFlag != null && Constants.HA_FLAG_FT.equals(haFlag.toLowerCase()) && !verifyFTState(vm)) {
      logger.error(""String_Node_Str"" + vm.getName() + ""String_Node_Str""+ ""String_Node_Str""+ vm.getFTState()+ ""String_Node_Str"");
      vNode.setNodeAction(Constants.NODE_ACTION_WRONG_FT_STATUS);
      return false;
    }
  }
  return success;
}","public static boolean setBaseNodeForVm(BaseNode vNode,String vmId){
  if (vmId == null) {
    vNode.setNodeAction(Constants.NODE_ACTION_CLONING_FAILED);
    vNode.setErrMessage(CommonUtil.getCurrentTimestamp() + ""String_Node_Str"" + vNode.getNodeAction());
    return false;
  }
  VcVirtualMachine vm=VcCache.getIgnoreMissing(vmId);
  if (vm == null) {
    logger.info(""String_Node_Str"" + vmId + ""String_Node_Str"");
    vNode.setNodeAction(Constants.NODE_ACTION_CLONING_FAILED);
    vNode.setErrMessage(CommonUtil.getCurrentTimestamp() + ""String_Node_Str"" + vNode.getNodeAction());
    return false;
  }
  boolean success=true;
  for (  String portGroup : vNode.getNics().keySet()) {
    String ipv4Address=VcVmUtil.getIpAddressOfPortGroup(vm,portGroup,false);
    vNode.updateNicOfPortGroup(portGroup,ipv4Address,null,null);
  }
  if (vNode.ipsReadyV4()) {
    vNode.setSuccess(true);
    vNode.setGuestHostName(VcVmUtil.getGuestHostName(vm,false));
    vNode.setTargetHost(vm.getHost().getName());
    vNode.setVmMobId(vm.getId());
    if (vm.isPoweredOn()) {
      vNode.setNodeStatus(NodeStatus.VM_READY);
      vNode.setNodeAction(null);
    }
 else {
      vNode.setNodeStatus(NodeStatus.POWERED_OFF);
      vNode.setNodeAction(Constants.NODE_ACTION_CREATION_FAILED);
      vNode.setErrMessage(CommonUtil.getCurrentTimestamp() + ""String_Node_Str"" + vNode.getNodeAction());
    }
  }
 else {
    vNode.setSuccess(false);
    vNode.resetIpsV4();
    if (vm != null) {
      vNode.setVmMobId(vm.getId());
      if (vm.isPoweredOn()) {
        vNode.setNodeStatus(NodeStatus.POWERED_ON);
        vNode.setNodeAction(Constants.NODE_ACTION_GET_IP_FAILED);
        vNode.setErrMessage(CommonUtil.getCurrentTimestamp() + ""String_Node_Str"" + vNode.getNodeAction());
      }
 else {
        vNode.setNodeStatus(NodeStatus.POWERED_OFF);
        vNode.setNodeAction(Constants.NODE_ACTION_CREATION_FAILED);
        vNode.setErrMessage(CommonUtil.getCurrentTimestamp() + ""String_Node_Str"" + vNode.getNodeAction());
      }
    }
    success=false;
    logger.error(""String_Node_Str"" + vNode.getVmName());
  }
  if (success) {
    String haFlag=vNode.getNodeGroup().getHaFlag();
    if (haFlag != null && Constants.HA_FLAG_FT.equals(haFlag.toLowerCase()) && !verifyFTState(vm)) {
      logger.error(""String_Node_Str"" + vm.getName() + ""String_Node_Str""+ ""String_Node_Str""+ vm.getFTState()+ ""String_Node_Str"");
      vNode.setNodeAction(Constants.NODE_ACTION_WRONG_FT_STATUS);
      vNode.setErrMessage(CommonUtil.getCurrentTimestamp() + ""String_Node_Str"" + vNode.getNodeAction());
      return false;
    }
  }
  return success;
}"
48658,"private void placeVirtualGroup(IContainer container,ClusterCreate cluster,IPlacementPlanner planner,VirtualGroup vGroup,List<BaseNode> placedNodes,Map<String,List<String>> filteredHosts){
  String targetRack=null;
  if (vGroup.getGroupRacks() != null && GroupRacksType.SAMERACK.equals(vGroup.getGroupRacks().getType())) {
    AuAssert.check(vGroup.getGroupRacks().getRacks() != null && vGroup.getGroupRacks().getRacks().length == 1);
    targetRack=vGroup.getGroupRacks().getRacks()[0];
  }
  if (filteredHosts.containsKey(PlacementUtil.NO_DATASTORE_HOSTS)) {
    filteredHosts.remove(PlacementUtil.NO_DATASTORE_HOSTS);
    filteredHosts.remove(PlacementUtil.NO_DATASTORE_HOSTS_NODE_GROUP);
  }
  List<String> dsFilteredOutHosts=new ArrayList<String>();
  if (vGroup.getvNodes().size() != 0) {
    List<String> noDatastoreHosts=container.getDsFilteredOutHosts(vGroup);
    filteredHosts.put(PlacementUtil.NO_DATASTORE_HOSTS,noDatastoreHosts);
    filteredHosts.put(PlacementUtil.NO_DATASTORE_HOSTS_NODE_GROUP,vGroup.getNodeGroupNames());
  }
  for (  VirtualNode vNode : vGroup.getvNodes()) {
    logger.info(""String_Node_Str"" + vNode.getBaseNodeNames());
    List<AbstractHost> candidates=container.getValidHosts(vNode,targetRack);
    if (candidates == null || candidates.size() == 0) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"" + vNode.getBaseNodeNames());
      throw PlacementException.OUT_OF_VC_HOST(PlacementUtil.getBaseNodeNames(vNode));
    }
    AbstractHost host=planner.selectHost(vNode,candidates);
    if (host == null) {
      logger.error(""String_Node_Str"" + candidates + ""String_Node_Str""+ vNode.getBaseNodeNames());
      throw PlacementException.OUT_OF_VC_HOST(PlacementUtil.getBaseNodeNames(vNode));
    }
    for (    BaseNode baseNode : vNode.getBaseNodes()) {
      Pair<String,String> rpClusterPair=planner.selectVcRp(baseNode,host);
      String rack=container.getRack(host);
      baseNode.place(rack,rpClusterPair.first,rpClusterPair.second,host);
    }
    container.allocate(vNode,host);
    logger.info(""String_Node_Str"" + host);
    logger.info(""String_Node_Str"" + vNode);
    placedNodes.addAll(vNode.getBaseNodes());
  }
}","private void placeVirtualGroup(IContainer container,ClusterCreate cluster,IPlacementPlanner planner,VirtualGroup vGroup,List<BaseNode> placedNodes,Map<String,List<String>> filteredHosts){
  String targetRack=null;
  if (vGroup.getGroupRacks() != null && GroupRacksType.SAMERACK.equals(vGroup.getGroupRacks().getType())) {
    AuAssert.check(vGroup.getGroupRacks().getRacks() != null && vGroup.getGroupRacks().getRacks().length == 1);
    targetRack=vGroup.getGroupRacks().getRacks()[0];
  }
  if (filteredHosts.containsKey(PlacementUtil.NO_DATASTORE_HOSTS)) {
    filteredHosts.remove(PlacementUtil.NO_DATASTORE_HOSTS);
    filteredHosts.remove(PlacementUtil.NO_DATASTORE_HOSTS_NODE_GROUP);
  }
  List<String> dsFilteredOutHosts=new ArrayList<String>();
  if (vGroup.getvNodes().size() != 0) {
    List<String> noDatastoreHosts=container.getDsFilteredOutHosts(vGroup);
    if (null != noDatastoreHosts && !noDatastoreHosts.isEmpty()) {
      filteredHosts.put(PlacementUtil.NO_DATASTORE_HOSTS,noDatastoreHosts);
      filteredHosts.put(PlacementUtil.NO_DATASTORE_HOSTS_NODE_GROUP,vGroup.getNodeGroupNames());
    }
  }
  for (  VirtualNode vNode : vGroup.getvNodes()) {
    logger.info(""String_Node_Str"" + vNode.getBaseNodeNames());
    List<AbstractHost> candidates=container.getValidHosts(vNode,targetRack);
    if (candidates == null || candidates.size() == 0) {
      logger.error(""String_Node_Str"" + ""String_Node_Str"" + vNode.getBaseNodeNames());
      throw PlacementException.OUT_OF_VC_HOST(PlacementUtil.getBaseNodeNames(vNode));
    }
    AbstractHost host=planner.selectHost(vNode,candidates);
    if (host == null) {
      logger.error(""String_Node_Str"" + candidates + ""String_Node_Str""+ vNode.getBaseNodeNames());
      throw PlacementException.OUT_OF_VC_HOST(PlacementUtil.getBaseNodeNames(vNode));
    }
    for (    BaseNode baseNode : vNode.getBaseNodes()) {
      Pair<String,String> rpClusterPair=planner.selectVcRp(baseNode,host);
      String rack=container.getRack(host);
      baseNode.place(rack,rpClusterPair.first,rpClusterPair.second,host);
    }
    container.allocate(vNode,host);
    logger.info(""String_Node_Str"" + host);
    logger.info(""String_Node_Str"" + vNode);
    placedNodes.addAll(vNode.getBaseNodes());
  }
}"
48659,"/** 
 * set cluster parameters synchronously
 * @param clusterName
 * @param activeComputeNodeNum
 * @param minComputeNodeNum
 * @param maxComputeNodeNum
 * @param enableAuto
 * @param ioPriority
 * @return
 * @throws Exception
 */
@SuppressWarnings(""String_Node_Str"") public List<String> syncSetParam(String clusterName,Integer activeComputeNodeNum,Integer minComputeNodeNum,Integer maxComputeNodeNum,Boolean enableAuto,Priority ioPriority) throws Exception {
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  ClusterRead clusterRead=getClusterByName(clusterName,false);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ValidationUtils.validateVersion(clusterEntityMgr,clusterName);
  clusterEntityMgr.cleanupActionError(clusterName);
  if (ioPriority != null) {
    prioritizeCluster(clusterName,ioPriority);
  }
  cluster=clusterEntityMgr.findByName(clusterName);
  if (enableAuto != null && enableAuto != cluster.getAutomationEnable()) {
    if (enableAuto && cluster.getDistro().equalsIgnoreCase(Constants.MAPR_VENDOR)) {
      logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
      throw BddException.NOT_ALLOWED_SCALING(""String_Node_Str"",clusterName);
    }
    cluster.setAutomationEnable(enableAuto);
  }
  if (minComputeNodeNum != null && minComputeNodeNum != cluster.getVhmMinNum()) {
    cluster.setVhmMinNum(minComputeNodeNum);
  }
  if (maxComputeNodeNum != null && maxComputeNodeNum != cluster.getVhmMaxNum()) {
    cluster.setVhmMaxNum(maxComputeNodeNum);
  }
  List<String> nodeGroupNames=new ArrayList<String>();
  if ((enableAuto != null || minComputeNodeNum != null || maxComputeNodeNum != null || activeComputeNodeNum != null) && !clusterRead.validateSetManualElasticity(nodeGroupNames)) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
  }
  if (activeComputeNodeNum != null) {
    if (!activeComputeNodeNum.equals(cluster.getVhmTargetNum())) {
      cluster.setVhmTargetNum(activeComputeNodeNum);
    }
  }
  if ((enableAuto != null) && !ClusterStatus.RUNNING.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus()) && !ClusterStatus.STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  clusterEntityMgr.update(cluster);
  if (enableAuto != null || minComputeNodeNum != null || maxComputeNodeNum != null) {
    boolean success=clusteringService.setAutoElasticity(clusterName,false);
    if (!success) {
      throw ClusterManagerException.FAILED_TO_SET_AUTO_ELASTICITY_ERROR(clusterName,""String_Node_Str"");
    }
  }
  if (enableAuto != null && !enableAuto && cluster.getVhmTargetNum() == null) {
    JobUtils.waitForManual(clusterName,executionService);
  }
  return nodeGroupNames;
}","/** 
 * set cluster parameters synchronously
 * @param clusterName
 * @param activeComputeNodeNum
 * @param minComputeNodeNum
 * @param maxComputeNodeNum
 * @param enableAuto
 * @param ioPriority
 * @return
 * @throws Exception
 */
@SuppressWarnings(""String_Node_Str"") public List<String> syncSetParam(String clusterName,Integer activeComputeNodeNum,Integer minComputeNodeNum,Integer maxComputeNodeNum,Boolean enableAuto,Priority ioPriority) throws Exception {
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  ClusterRead clusterRead=getClusterByName(clusterName,false);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ValidationUtils.validateVersion(clusterEntityMgr,clusterName);
  clusterEntityMgr.cleanupActionError(clusterName);
  if (ioPriority != null) {
    prioritizeCluster(clusterName,ioPriority);
  }
  cluster=clusterEntityMgr.findByName(clusterName);
  if (enableAuto != null && enableAuto != cluster.getAutomationEnable()) {
    if (enableAuto && cluster.getDistroVendor().equalsIgnoreCase(Constants.MAPR_VENDOR)) {
      logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
      throw BddException.NOT_ALLOWED_SCALING(""String_Node_Str"",clusterName);
    }
    cluster.setAutomationEnable(enableAuto);
  }
  if (minComputeNodeNum != null && minComputeNodeNum != cluster.getVhmMinNum()) {
    cluster.setVhmMinNum(minComputeNodeNum);
  }
  if (maxComputeNodeNum != null && maxComputeNodeNum != cluster.getVhmMaxNum()) {
    cluster.setVhmMaxNum(maxComputeNodeNum);
  }
  List<String> nodeGroupNames=new ArrayList<String>();
  if ((enableAuto != null || minComputeNodeNum != null || maxComputeNodeNum != null || activeComputeNodeNum != null) && !clusterRead.validateSetManualElasticity(nodeGroupNames)) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
  }
  if (activeComputeNodeNum != null) {
    if (!activeComputeNodeNum.equals(cluster.getVhmTargetNum())) {
      cluster.setVhmTargetNum(activeComputeNodeNum);
    }
  }
  if ((enableAuto != null) && !ClusterStatus.RUNNING.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus()) && !ClusterStatus.STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  clusterEntityMgr.update(cluster);
  if (enableAuto != null || minComputeNodeNum != null || maxComputeNodeNum != null) {
    boolean success=clusteringService.setAutoElasticity(clusterName,false);
    if (!success) {
      throw ClusterManagerException.FAILED_TO_SET_AUTO_ELASTICITY_ERROR(clusterName,""String_Node_Str"");
    }
  }
  if (enableAuto != null && !enableAuto && cluster.getVhmTargetNum() == null) {
    JobUtils.waitForManual(clusterName,executionService);
  }
  return nodeGroupNames;
}"
48660,"private void updateVhmMasterMoid(String clusterName){
  ClusterEntity cluster=getClusterEntityMgr().findByName(clusterName);
  if (cluster.getVhmMasterMoid() == null) {
    List<NodeEntity> nodes=getClusterEntityMgr().findAllNodes(clusterName);
    for (    NodeEntity node : nodes) {
      if (node.getMoId() != null && node.getNodeGroup().getRoles() != null) {
        @SuppressWarnings(""String_Node_Str"") List<String> roles=new Gson().fromJson(node.getNodeGroup().getRoles(),List.class);
        if (cluster.getDistro().equalsIgnoreCase(Constants.MAPR_VENDOR)) {
          if (roles.contains(HadoopRole.MAPR_JOBTRACKER_ROLE.toString())) {
            String thisJtIp=node.getPrimaryMgtIpV4();
            String activeJtIp;
            try {
              activeJtIp=getMaprActiveJobTrackerIp(thisJtIp,clusterName);
              logger.info(""String_Node_Str"" + activeJtIp);
            }
 catch (            Exception e) {
              continue;
            }
            AuAssert.check(!CommonUtil.isBlank(thisJtIp),""String_Node_Str"");
            for (            NodeEntity jt : nodes) {
              boolean isActiveJt=false;
              for (              NicEntity nicEntity : jt.getNics()) {
                if (nicEntity.getIpv4Address() != null && activeJtIp.equals(nicEntity.getIpv4Address())) {
                  isActiveJt=true;
                  break;
                }
              }
              if (isActiveJt) {
                cluster.setVhmMasterMoid(jt.getMoId());
                break;
              }
            }
            break;
          }
        }
 else {
          if (roles.contains(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString())) {
            cluster.setVhmMasterMoid(node.getMoId());
            break;
          }
        }
      }
    }
  }
  getClusterEntityMgr().update(cluster);
}","private void updateVhmMasterMoid(String clusterName){
  ClusterEntity cluster=getClusterEntityMgr().findByName(clusterName);
  if (cluster.getVhmMasterMoid() == null) {
    List<NodeEntity> nodes=getClusterEntityMgr().findAllNodes(clusterName);
    for (    NodeEntity node : nodes) {
      if (node.getMoId() != null && node.getNodeGroup().getRoles() != null) {
        @SuppressWarnings(""String_Node_Str"") List<String> roles=new Gson().fromJson(node.getNodeGroup().getRoles(),List.class);
        if (cluster.getDistroVendor().equalsIgnoreCase(Constants.MAPR_VENDOR)) {
          if (roles.contains(HadoopRole.MAPR_JOBTRACKER_ROLE.toString())) {
            String thisJtIp=node.getPrimaryMgtIpV4();
            String activeJtIp;
            try {
              activeJtIp=getMaprActiveJobTrackerIp(thisJtIp,clusterName);
              logger.info(""String_Node_Str"" + activeJtIp);
            }
 catch (            Exception e) {
              continue;
            }
            AuAssert.check(!CommonUtil.isBlank(thisJtIp),""String_Node_Str"");
            for (            NodeEntity jt : nodes) {
              boolean isActiveJt=false;
              for (              NicEntity nicEntity : jt.getNics()) {
                if (nicEntity.getIpv4Address() != null && activeJtIp.equals(nicEntity.getIpv4Address())) {
                  isActiveJt=true;
                  break;
                }
              }
              if (isActiveJt) {
                cluster.setVhmMasterMoid(jt.getMoId());
                break;
              }
            }
            break;
          }
        }
 else {
          if (roles.contains(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString())) {
            cluster.setVhmMasterMoid(node.getMoId());
            break;
          }
        }
      }
    }
  }
  getClusterEntityMgr().update(cluster);
}"
48661,"public void actionOps(String id,Map<String,String> queryStrings){
  actionOps(id,id,queryStrings);
}","public void actionOps(String id,Map<String,String> queryStrings){
  id=CommonUtil.encode(id);
  actionOps(id,id,queryStrings);
}"
48662,"public void delete(String id){
  final String path=Constants.REST_PATH_CLUSTER;
  final HttpMethod httpverb=HttpMethod.DELETE;
  PrettyOutput outputCallBack=getClusterPrettyOutputCallBack(this,id);
  restClient.deleteObject(id,path,httpverb,outputCallBack);
}","public void delete(String id){
  final String path=Constants.REST_PATH_CLUSTER;
  final HttpMethod httpverb=HttpMethod.DELETE;
  id=CommonUtil.encode(id);
  PrettyOutput outputCallBack=getClusterPrettyOutputCallBack(this,id);
  restClient.deleteObject(id,path,httpverb,outputCallBack);
}"
48663,"/** 
 * Delete a cluster
 * @param clusterName
 * @param request
 * @return Return a response with Accepted status and put task uri in the Location of header that can be used to monitor the progress
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.DELETE) @ResponseStatus(HttpStatus.ACCEPTED) public void deleteCluster(@PathVariable(""String_Node_Str"") String clusterName,HttpServletRequest request,HttpServletResponse response) throws Exception {
  verifyInitialized();
  if (!CommonUtil.validateClusterName(clusterName)) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
  }
  Long taskId=clusterMgr.deleteClusterByName(clusterName);
  redirectRequest(taskId,request,response);
}","/** 
 * Delete a cluster
 * @param clusterName
 * @param request
 * @return Return a response with Accepted status and put task uri in the Location of header that can be used to monitor the progress
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.DELETE) @ResponseStatus(HttpStatus.ACCEPTED) public void deleteCluster(@PathVariable(""String_Node_Str"") String clusterName,HttpServletRequest request,HttpServletResponse response) throws Exception {
  verifyInitialized();
  clusterName=CommonUtil.decode(clusterName);
  if (!CommonUtil.validateClusterName(clusterName)) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
  }
  Long taskId=clusterMgr.deleteClusterByName(clusterName);
  redirectRequest(taskId,request,response);
}"
48664,"/** 
 * Start or stop a normal cluster, or resume a failed cluster after adjusting the resources allocated to this cluster
 * @param clusterName
 * @param state Can be start, stop, or resume
 * @param request
 * @return Return a response with Accepted status and put task uri in the Location of header that can be used to monitor the progress
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.PUT) @ResponseStatus(HttpStatus.ACCEPTED) public void startStopResumeCluster(@PathVariable(""String_Node_Str"") String clusterName,@RequestParam(value=""String_Node_Str"",required=true) String state,HttpServletRequest request,HttpServletResponse response) throws Exception {
  verifyInitialized();
  if (CommonUtil.isBlank(clusterName) || !CommonUtil.validateClusterName(clusterName)) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
  }
  Long taskId;
  if (state.equals(""String_Node_Str"")) {
    taskId=clusterMgr.stopCluster(clusterName);
    redirectRequest(taskId,request,response);
  }
 else   if (state.equals(""String_Node_Str"")) {
    taskId=clusterMgr.startCluster(clusterName);
    redirectRequest(taskId,request,response);
  }
 else   if (state.equals(""String_Node_Str"")) {
    taskId=clusterMgr.resumeClusterCreation(clusterName);
    redirectRequest(taskId,request,response);
  }
 else {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",state);
  }
}","/** 
 * Start or stop a normal cluster, or resume a failed cluster after adjusting the resources allocated to this cluster
 * @param clusterName
 * @param state Can be start, stop, or resume
 * @param request
 * @return Return a response with Accepted status and put task uri in the Location of header that can be used to monitor the progress
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.PUT) @ResponseStatus(HttpStatus.ACCEPTED) public void startStopResumeCluster(@PathVariable(""String_Node_Str"") String clusterName,@RequestParam(value=""String_Node_Str"",required=true) String state,HttpServletRequest request,HttpServletResponse response) throws Exception {
  verifyInitialized();
  clusterName=CommonUtil.decode(clusterName);
  if (CommonUtil.isBlank(clusterName) || !CommonUtil.validateClusterName(clusterName)) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
  }
  Long taskId;
  if (state.equals(""String_Node_Str"")) {
    taskId=clusterMgr.stopCluster(clusterName);
    redirectRequest(taskId,request,response);
  }
 else   if (state.equals(""String_Node_Str"")) {
    taskId=clusterMgr.startCluster(clusterName);
    redirectRequest(taskId,request,response);
  }
 else   if (state.equals(""String_Node_Str"")) {
    taskId=clusterMgr.resumeClusterCreation(clusterName);
    redirectRequest(taskId,request,response);
  }
 else {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",state);
  }
}"
48665,"@Transactional private void updateNodeData(NodeEntity node,boolean upgraded,String errorMessage){
  node=clusterEntityMgr.getNodeWithNicsByMobId(node.getMoId());
  String nodeVmName=node.getVmName();
  if (upgraded) {
    if (node.canBeUpgrade()) {
      logger.info(""String_Node_Str"" + nodeVmName);
      node.setVersion(serverVersion);
      node.setAction(Constants.NODE_ACTION_UPGRADE_SUCCESS);
      node.setActionFailed(false);
      node.setErrMessage(null);
      clusterEntityMgr.update(node);
    }
  }
 else {
    logger.error(""String_Node_Str"" + nodeVmName);
    node.setAction(Constants.NODE_ACTION_UPGRADE_FAILED);
    node.setActionFailed(true);
    String[] messages=errorMessage.split(""String_Node_Str"");
    if (messages != null && messages.length > 0) {
      node.setErrMessage(messages[messages.length - 1]);
    }
 else {
      node.setErrMessage(""String_Node_Str"" + nodeVmName + ""String_Node_Str"");
    }
    clusterEntityMgr.update(node);
  }
}","@Transactional private void updateNodeData(NodeEntity node,boolean upgraded,String errorMessage,String errorTimestamp){
  node=clusterEntityMgr.getNodeWithNicsByMobId(node.getMoId());
  String nodeVmName=node.getVmName();
  if (upgraded) {
    if (node.canBeUpgrade()) {
      logger.info(""String_Node_Str"" + nodeVmName);
      node.setVersion(serverVersion);
      node.setAction(Constants.NODE_ACTION_UPGRADE_SUCCESS);
      node.setActionFailed(false);
      node.setErrMessage(null);
      clusterEntityMgr.update(node);
    }
  }
 else {
    logger.error(""String_Node_Str"" + nodeVmName);
    node.setAction(Constants.NODE_ACTION_UPGRADE_FAILED);
    node.setActionFailed(true);
    String[] messages=errorMessage.split(""String_Node_Str"");
    if (messages != null && messages.length > 0) {
      node.setErrMessage(errorTimestamp + ""String_Node_Str"" + messages[messages.length - 1]);
    }
 else {
      node.setErrMessage(errorTimestamp + ""String_Node_Str"" + ""String_Node_Str""+ nodeVmName+ ""String_Node_Str"");
    }
    clusterEntityMgr.update(node);
  }
}"
48666,"@Override public boolean upgrade(final String clusterName,StatusUpdater statusUpdator){
  logger.info(""String_Node_Str"" + clusterName + ""String_Node_Str"");
  this.serverVersion=clusterEntityMgr.getServerVersion();
  List<NodeEntity> nodes=getNodes(clusterName);
  List<Callable<Void>> storeNodeProcedures=new ArrayList<Callable<Void>>();
  try {
    for (    NodeEntity node : nodes) {
      if (node.needUpgrade(serverVersion)) {
        NodeUpgradeSP nodeUpgradeSP=new NodeUpgradeSP(node,serverVersion);
        storeNodeProcedures.add(nodeUpgradeSP);
      }
    }
    if (storeNodeProcedures.isEmpty()) {
      logger.info(""String_Node_Str"");
      return true;
    }
    Callable<Void>[] storeNodeProceduresArray=storeNodeProcedures.toArray(new Callable[0]);
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeNodeProceduresArray,callback);
    if (result == null || result.length == 0) {
      logger.error(""String_Node_Str"");
      return false;
    }
    boolean success=true;
    int total=0;
    for (int i=0; i < storeNodeProceduresArray.length; i++) {
      Throwable nodeUpgradeSPException=result[i].throwable;
      NodeUpgradeSP sp=(NodeUpgradeSP)storeNodeProceduresArray[i];
      NodeEntity node=sp.getNode();
      if (result[i].finished && nodeUpgradeSPException == null) {
        updateNodeData(node);
        ++total;
      }
 else       if (nodeUpgradeSPException != null) {
        updateNodeData(node,false,nodeUpgradeSPException.getMessage());
        logger.error(""String_Node_Str"" + node.getVmName(),nodeUpgradeSPException);
        success=false;
      }
    }
    logger.info(total + ""String_Node_Str"");
    return success;
  }
 catch (  InterruptedException e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.UPGRADE(e,e.getMessage());
  }
}","@Override public boolean upgrade(final String clusterName,StatusUpdater statusUpdator){
  logger.info(""String_Node_Str"" + clusterName + ""String_Node_Str"");
  this.serverVersion=clusterEntityMgr.getServerVersion();
  List<NodeEntity> nodes=getNodes(clusterName);
  List<Callable<Void>> storeNodeProcedures=new ArrayList<Callable<Void>>();
  try {
    for (    NodeEntity node : nodes) {
      if (node.needUpgrade(serverVersion)) {
        NodeUpgradeSP nodeUpgradeSP=new NodeUpgradeSP(node,serverVersion);
        storeNodeProcedures.add(nodeUpgradeSP);
      }
    }
    if (storeNodeProcedures.isEmpty()) {
      logger.info(""String_Node_Str"");
      return true;
    }
    Callable<Void>[] storeNodeProceduresArray=storeNodeProcedures.toArray(new Callable[0]);
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeNodeProceduresArray,callback);
    if (result == null || result.length == 0) {
      logger.error(""String_Node_Str"");
      return false;
    }
    boolean success=true;
    int total=0;
    for (int i=0; i < storeNodeProceduresArray.length; i++) {
      Throwable nodeUpgradeSPException=result[i].throwable;
      NodeUpgradeSP sp=(NodeUpgradeSP)storeNodeProceduresArray[i];
      NodeEntity node=sp.getNode();
      if (result[i].finished && nodeUpgradeSPException == null) {
        updateNodeData(node);
        ++total;
      }
 else       if (nodeUpgradeSPException != null) {
        updateNodeData(node,false,nodeUpgradeSPException.getMessage(),CommonUtil.getCurrentTimestamp());
        logger.error(""String_Node_Str"" + node.getVmName(),nodeUpgradeSPException);
        success=false;
      }
    }
    logger.info(total + ""String_Node_Str"");
    return success;
  }
 catch (  InterruptedException e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.UPGRADE(e,e.getMessage());
  }
}"
48667,"@Override public Map<String,String> configIOShares(String clusterName,List<NodeEntity> targetNodes,Priority ioShares){
  AuAssert.check(clusterName != null && targetNodes != null && !targetNodes.isEmpty());
  Callable<Void>[] storeProcedures=new Callable[targetNodes.size()];
  int i=0;
  for (  NodeEntity node : targetNodes) {
    ConfigIOShareSP ioShareSP=new ConfigIOShareSP(node.getMoId(),ioShares);
    storeProcedures[i]=ioShareSP;
    i++;
  }
  try {
    logger.info(""String_Node_Str"");
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProcedures,callback);
    if (result == null) {
      logger.error(""String_Node_Str"");
      throw ClusteringServiceException.RECONFIGURE_IO_SHARE_FAILED(clusterName);
    }
    int total=0;
    Map<String,String> failedNodes=new HashMap<String,String>();
    for (i=0; i < storeProcedures.length; i++) {
      if (result[i].finished && result[i].throwable == null) {
        ++total;
      }
 else       if (result[i].throwable != null) {
        logger.error(""String_Node_Str"",result[i].throwable);
        String nodeName=targetNodes.get(i).getVmName();
        String message=result[i].throwable.getMessage();
        failedNodes.put(nodeName,message);
      }
    }
    logger.info(total + ""String_Node_Str"");
    return failedNodes;
  }
 catch (  InterruptedException e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}","@Override public Map<String,String> configIOShares(String clusterName,List<NodeEntity> targetNodes,Priority ioShares){
  AuAssert.check(clusterName != null && targetNodes != null && !targetNodes.isEmpty());
  Callable<Void>[] storeProcedures=new Callable[targetNodes.size()];
  int i=0;
  for (  NodeEntity node : targetNodes) {
    ConfigIOShareSP ioShareSP=new ConfigIOShareSP(node.getMoId(),ioShares);
    storeProcedures[i]=ioShareSP;
    i++;
  }
  try {
    logger.info(""String_Node_Str"");
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProcedures,callback);
    if (result == null) {
      logger.error(""String_Node_Str"");
      throw ClusteringServiceException.RECONFIGURE_IO_SHARE_FAILED(clusterName);
    }
    int total=0;
    Map<String,String> failedNodes=new HashMap<String,String>();
    for (i=0; i < storeProcedures.length; i++) {
      if (result[i].finished && result[i].throwable == null) {
        ++total;
      }
 else       if (result[i].throwable != null) {
        logger.error(""String_Node_Str"",result[i].throwable);
        String nodeName=targetNodes.get(i).getVmName();
        String message=CommonUtil.getCurrentTimestamp() + ""String_Node_Str"" + result[i].throwable.getMessage();
        failedNodes.put(nodeName,message);
      }
    }
    logger.info(total + ""String_Node_Str"");
    return failedNodes;
  }
 catch (  InterruptedException e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}"
48668,"@SuppressWarnings(""String_Node_Str"") @Override public boolean createVcVms(List<NetworkAdd> networkAdds,List<BaseNode> vNodes,Map<String,Set<String>> occupiedIpSets,boolean reserveRawDisks,StatusUpdater statusUpdator){
  if (vNodes.isEmpty()) {
    logger.info(""String_Node_Str"");
    return true;
  }
  updateNicLabels(vNodes);
  allocateStaticIp(vNodes,networkAdds,occupiedIpSets);
  Map<String,Folder> folders=createVcFolders(vNodes.get(0).getCluster());
  String clusterRpName=createVcResourcePools(vNodes);
  logger.info(""String_Node_Str"");
  VcVmUtil.updateVm(templateVm.getId());
  VmCreateSpec sourceSpec=new VmCreateSpec();
  sourceSpec.setVmId(templateVm.getId());
  sourceSpec.setVmName(templateVm.getName());
  sourceSpec.setTargetHost(templateVm.getHost());
  List<VmCreateSpec> specs=new ArrayList<VmCreateSpec>();
  Map<String,BaseNode> nodeMap=new HashMap<String,BaseNode>();
  for (  BaseNode vNode : vNodes) {
    nodeMap.put(vNode.getVmName(),vNode);
    vNode.setSuccess(false);
    vNode.setFinished(false);
    VmCreateSpec spec=new VmCreateSpec();
    VmSchema createSchema=getVmSchema(vNode);
    spec.setSchema(createSchema);
    String defaultPgName=null;
    GuestMachineIdSpec machineIdSpec=new GuestMachineIdSpec(networkAdds,vNode.fetchPortGroupToIpV4Map(),vNode.getPrimaryMgtPgName());
    logger.info(""String_Node_Str"" + vNode.getVmName() + ""String_Node_Str""+ machineIdSpec.toString());
    spec.setBootupConfigs(machineIdSpec.toGuestVariable());
    QueryIpAddress query=new QueryIpAddress(vNode.getNics().keySet(),Constants.VM_POWER_ON_WAITING_SEC);
    spec.setPostPowerOn(query);
    spec.setPrePowerOn(getPrePowerOnFunc(vNode,reserveRawDisks));
    spec.setLinkedClone(false);
    spec.setTargetDs(getVcDatastore(vNode));
    spec.setTargetFolder(folders.get(vNode.getGroupName()));
    spec.setTargetHost(VcResourceUtils.findHost(vNode.getTargetHost()));
    spec.setTargetRp(getVcResourcePool(vNode,clusterRpName));
    spec.setVmName(vNode.getVmName());
    specs.add(spec);
  }
  UpdateVmProgressCallback callback=new UpdateVmProgressCallback(getLockClusterEntityMgr(),statusUpdator,vNodes.get(0).getClusterName());
  logger.info(""String_Node_Str"");
  AuAssert.check(specs.size() > 0);
  VmSchema vmSchema=specs.get(0).getSchema();
  VcVmUtil.checkAndCreateSnapshot(vmSchema);
  List<VmCreateResult<?>> results=cloneService.createCopies(sourceSpec,cloneConcurrency,specs,callback);
  if (results == null || results.isEmpty()) {
    for (    VmCreateSpec spec : specs) {
      BaseNode node=nodeMap.get(spec.getVmName());
      node.setFinished(true);
      node.setSuccess(false);
    }
    return false;
  }
  boolean success=true;
  int total=0;
  for (  VmCreateResult<?> result : results) {
    VmCreateSpec spec=(VmCreateSpec)result.getSpec();
    BaseNode node=nodeMap.get(spec.getVmName());
    node.setVmMobId(spec.getVmId());
    node.setSuccess(true);
    node.setFinished(true);
    boolean vmSucc=VcVmUtil.setBaseNodeForVm(node,spec.getVmId());
    if (!vmSucc || !result.isSuccess()) {
      success=false;
      node.setSuccess(false);
      if (result.getErrMessage() != null) {
        node.setErrMessage(result.getErrMessage());
      }
 else {
        node.setErrMessage(node.getNodeAction());
      }
    }
 else {
      total++;
    }
  }
  logger.info(total + ""String_Node_Str"");
  return success;
}","@SuppressWarnings(""String_Node_Str"") @Override public boolean createVcVms(List<NetworkAdd> networkAdds,List<BaseNode> vNodes,Map<String,Set<String>> occupiedIpSets,boolean reserveRawDisks,StatusUpdater statusUpdator){
  if (vNodes.isEmpty()) {
    logger.info(""String_Node_Str"");
    return true;
  }
  updateNicLabels(vNodes);
  allocateStaticIp(vNodes,networkAdds,occupiedIpSets);
  Map<String,Folder> folders=createVcFolders(vNodes.get(0).getCluster());
  String clusterRpName=createVcResourcePools(vNodes);
  logger.info(""String_Node_Str"");
  VcVmUtil.updateVm(templateVm.getId());
  VmCreateSpec sourceSpec=new VmCreateSpec();
  sourceSpec.setVmId(templateVm.getId());
  sourceSpec.setVmName(templateVm.getName());
  sourceSpec.setTargetHost(templateVm.getHost());
  List<VmCreateSpec> specs=new ArrayList<VmCreateSpec>();
  Map<String,BaseNode> nodeMap=new HashMap<String,BaseNode>();
  for (  BaseNode vNode : vNodes) {
    nodeMap.put(vNode.getVmName(),vNode);
    vNode.setSuccess(false);
    vNode.setFinished(false);
    VmCreateSpec spec=new VmCreateSpec();
    VmSchema createSchema=getVmSchema(vNode);
    spec.setSchema(createSchema);
    String defaultPgName=null;
    GuestMachineIdSpec machineIdSpec=new GuestMachineIdSpec(networkAdds,vNode.fetchPortGroupToIpV4Map(),vNode.getPrimaryMgtPgName());
    logger.info(""String_Node_Str"" + vNode.getVmName() + ""String_Node_Str""+ machineIdSpec.toString());
    spec.setBootupConfigs(machineIdSpec.toGuestVariable());
    QueryIpAddress query=new QueryIpAddress(vNode.getNics().keySet(),Constants.VM_POWER_ON_WAITING_SEC);
    spec.setPostPowerOn(query);
    spec.setPrePowerOn(getPrePowerOnFunc(vNode,reserveRawDisks));
    spec.setLinkedClone(false);
    spec.setTargetDs(getVcDatastore(vNode));
    spec.setTargetFolder(folders.get(vNode.getGroupName()));
    spec.setTargetHost(VcResourceUtils.findHost(vNode.getTargetHost()));
    spec.setTargetRp(getVcResourcePool(vNode,clusterRpName));
    spec.setVmName(vNode.getVmName());
    specs.add(spec);
  }
  UpdateVmProgressCallback callback=new UpdateVmProgressCallback(getLockClusterEntityMgr(),statusUpdator,vNodes.get(0).getClusterName());
  logger.info(""String_Node_Str"");
  AuAssert.check(specs.size() > 0);
  VmSchema vmSchema=specs.get(0).getSchema();
  VcVmUtil.checkAndCreateSnapshot(vmSchema);
  List<VmCreateResult<?>> results=cloneService.createCopies(sourceSpec,cloneConcurrency,specs,callback);
  if (results == null || results.isEmpty()) {
    for (    VmCreateSpec spec : specs) {
      BaseNode node=nodeMap.get(spec.getVmName());
      node.setFinished(true);
      node.setSuccess(false);
    }
    return false;
  }
  boolean success=true;
  int total=0;
  for (  VmCreateResult<?> result : results) {
    VmCreateSpec spec=(VmCreateSpec)result.getSpec();
    BaseNode node=nodeMap.get(spec.getVmName());
    node.setVmMobId(spec.getVmId());
    node.setSuccess(true);
    node.setFinished(true);
    boolean vmSucc=VcVmUtil.setBaseNodeForVm(node,spec.getVmId());
    if (!vmSucc || !result.isSuccess()) {
      success=false;
      node.setSuccess(false);
      if (result.getErrMessage() != null) {
        node.setErrMessage(result.getErrTimestamp() + ""String_Node_Str"" + result.getErrMessage());
      }
 else {
        node.setErrMessage(result.getErrTimestamp() + ""String_Node_Str"" + node.getNodeAction());
      }
    }
 else {
      total++;
    }
  }
  logger.info(total + ""String_Node_Str"");
  return success;
}"
48669,"private String getErrorMessage(Throwable throwable){
  if (throwable == null) {
    return null;
  }
  return throwable.getMessage();
}","private String getErrorMessage(Throwable throwable){
  if (throwable == null) {
    return null;
  }
  return CommonUtil.getCurrentTimestamp() + ""String_Node_Str"" + throwable.getMessage();
}"
48670,"public static boolean verifyNodesStatus(List<NodeEntity> nodes,NodeStatus expectedStatus,boolean ignoreMissing){
  boolean success=true;
  for (  NodeEntity node : nodes) {
    try {
      verifyNodeStatus(node,expectedStatus,ignoreMissing);
    }
 catch (    Exception e) {
      node.setActionFailed(true);
      logger.debug(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ e.getMessage());
      if (node.getErrMessage() == null || node.getErrMessage().isEmpty()) {
        node.setErrMessage(e.getMessage());
        logger.debug(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ e.getMessage());
      }
      success=false;
    }
  }
  return success;
}","public static boolean verifyNodesStatus(List<NodeEntity> nodes,NodeStatus expectedStatus,boolean ignoreMissing){
  boolean success=true;
  for (  NodeEntity node : nodes) {
    try {
      verifyNodeStatus(node,expectedStatus,ignoreMissing);
    }
 catch (    Exception e) {
      node.setActionFailed(true);
      logger.debug(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ e.getMessage());
      if (node.getErrMessage() == null || node.getErrMessage().isEmpty()) {
        node.setErrMessage(CommonUtil.getCurrentTimestamp() + ""String_Node_Str"" + e.getMessage());
        logger.debug(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ e.getMessage());
      }
      success=false;
    }
  }
  return success;
}"
48671,"private void processEvent(VcEventType type,Event e,String moId,boolean external) throws Exception {
  try {
switch (type) {
case VmRemoved:
{
        logger.debug(""String_Node_Str"" + moId);
        NodeEntity node=clusterEntityMgr.getNodeByMobId(moId);
        if (node != null) {
          String clusterName=CommonUtil.getClusterName(node.getVmName());
          lockMgr.refreshNodeByMobId(clusterName,moId,null,true);
        }
        break;
      }
case VmDisconnected:
{
      VcVirtualMachine vm=VcCache.getIgnoreMissing(moId);
      if (vm == null) {
        NodeEntity node=clusterEntityMgr.getNodeByMobId(moId);
        if (node != null) {
          String clusterName=CommonUtil.getClusterName(node.getVmName());
          logger.debug(""String_Node_Str"" + moId + ""String_Node_Str"");
          lockMgr.removeVmReference(clusterName,moId);
        }
        break;
      }
      if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
        vm.updateRuntime();
        if ((!vm.isConnected()) || vm.getHost().isUnavailbleForManagement()) {
          String clusterName=CommonUtil.getClusterName(vm.getName());
          lockMgr.setNodeConnectionState(clusterName,vm.getName());
          logConnectionChangeEvent(vm.getName());
        }
      }
      break;
    }
case VmPoweredOn:
{
    logger.debug(""String_Node_Str"");
    refreshNodeWithAction(moId,true,Constants.NODE_ACTION_WAITING_IP,""String_Node_Str"");
    if (external) {
      NodePowerOnRequest request=new NodePowerOnRequest(lockMgr,moId);
      CmsWorker.addRequest(WorkQueue.VC_TASK_NO_DELAY,request);
    }
    break;
  }
case VmCloned:
{
  refreshNodeWithAction(moId,true,Constants.NODE_ACTION_RECONFIGURE,""String_Node_Str"");
  break;
}
case VmSuspended:
{
refreshNodeWithAction(moId,true,null,""String_Node_Str"");
break;
}
case VmPoweredOff:
{
refreshNodeWithAction(moId,true,null,""String_Node_Str"");
break;
}
case VmConnected:
{
try {
refreshNodeWithAction(moId,false,null,type.name());
}
 catch (AuroraException ex) {
logger.warn(""String_Node_Str"" + ex.getMessage() + ""String_Node_Str"");
}
break;
}
case VmMigrated:
{
refreshNodeWithAction(moId,false,null,type.name());
break;
}
case VhmError:
case VhmWarning:
{
EventEx event=(EventEx)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
break;
}
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + event.getEventTypeId() + ""String_Node_Str""+ vm.getName()+ ""String_Node_Str""+ event.getMessage());
vm.updateRuntime();
String clusterName=CommonUtil.getClusterName(vm.getName());
lockMgr.refreshNodeByVmName(clusterName,moId,vm.getName(),event.getMessage(),true);
}
break;
}
case VhmInfo:
{
EventEx event=(EventEx)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
break;
}
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + event.getEventTypeId() + ""String_Node_Str""+ vm.getName()+ ""String_Node_Str""+ event.getMessage());
vm.updateRuntime();
String clusterName=CommonUtil.getClusterName(vm.getName());
lockMgr.refreshNodeByVmName(clusterName,moId,vm.getName(),""String_Node_Str"",true);
}
break;
}
default :
{
if (external) {
VcVirtualMachine vm=VcCache.getIgnoreMissing(moId);
if (vm == null) {
break;
}
String clusterName=CommonUtil.getClusterName(vm.getName());
lockMgr.refreshNodeByVmName(clusterName,moId,vm.getName(),true);
}
break;
}
}
}
 catch (ManagedObjectNotFound exp) {
VcUtil.processNotFoundException(exp,moId,logger);
}
}","private void processEvent(VcEventType type,Event e,String moId,boolean external) throws Exception {
  try {
switch (type) {
case VmRemoved:
{
        logger.debug(""String_Node_Str"" + moId);
        NodeEntity node=clusterEntityMgr.getNodeByMobId(moId);
        if (node != null) {
          String clusterName=CommonUtil.getClusterName(node.getVmName());
          lockMgr.refreshNodeByMobId(clusterName,moId,null,true);
        }
        break;
      }
case VmDisconnected:
{
      VcVirtualMachine vm=VcCache.getIgnoreMissing(moId);
      if (vm == null) {
        NodeEntity node=clusterEntityMgr.getNodeByMobId(moId);
        if (node != null) {
          String clusterName=CommonUtil.getClusterName(node.getVmName());
          logger.debug(""String_Node_Str"" + moId + ""String_Node_Str"");
          lockMgr.removeVmReference(clusterName,moId);
        }
        break;
      }
      if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
        vm.updateRuntime();
        if ((!vm.isConnected()) || vm.getHost().isUnavailbleForManagement()) {
          String clusterName=CommonUtil.getClusterName(vm.getName());
          lockMgr.setNodeConnectionState(clusterName,vm.getName());
          logConnectionChangeEvent(vm.getName());
        }
      }
      break;
    }
case VmPoweredOn:
{
    logger.debug(""String_Node_Str"");
    if (waitForPowerState(moId,PowerState.poweredOn)) {
      refreshNodeWithAction(moId,true,Constants.NODE_ACTION_WAITING_IP,""String_Node_Str"");
      if (external) {
        NodePowerOnRequest request=new NodePowerOnRequest(lockMgr,moId);
        CmsWorker.addRequest(WorkQueue.VC_TASK_NO_DELAY,request);
      }
    }
    break;
  }
case VmCloned:
{
  refreshNodeWithAction(moId,true,Constants.NODE_ACTION_RECONFIGURE,""String_Node_Str"");
  break;
}
case VmSuspended:
{
refreshNodeWithAction(moId,true,null,""String_Node_Str"");
break;
}
case VmPoweredOff:
{
if (waitForPowerState(moId,PowerState.poweredOff)) {
refreshNodeWithAction(moId,true,null,""String_Node_Str"");
}
break;
}
case VmConnected:
{
try {
refreshNodeWithAction(moId,false,null,type.name());
}
 catch (AuroraException ex) {
logger.warn(""String_Node_Str"" + ex.getMessage() + ""String_Node_Str"");
}
break;
}
case VmMigrated:
{
refreshNodeWithAction(moId,false,null,type.name());
break;
}
case VhmError:
case VhmWarning:
{
EventEx event=(EventEx)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
break;
}
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + event.getEventTypeId() + ""String_Node_Str""+ vm.getName()+ ""String_Node_Str""+ event.getMessage());
vm.updateRuntime();
String clusterName=CommonUtil.getClusterName(vm.getName());
lockMgr.refreshNodeByVmName(clusterName,moId,vm.getName(),event.getMessage(),true);
}
break;
}
case VhmInfo:
{
EventEx event=(EventEx)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
break;
}
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + event.getEventTypeId() + ""String_Node_Str""+ vm.getName()+ ""String_Node_Str""+ event.getMessage());
vm.updateRuntime();
String clusterName=CommonUtil.getClusterName(vm.getName());
lockMgr.refreshNodeByVmName(clusterName,moId,vm.getName(),""String_Node_Str"",true);
}
break;
}
default :
{
if (external) {
VcVirtualMachine vm=VcCache.getIgnoreMissing(moId);
if (vm == null) {
break;
}
String clusterName=CommonUtil.getClusterName(vm.getName());
lockMgr.refreshNodeByVmName(clusterName,moId,vm.getName(),true);
}
break;
}
}
}
 catch (ManagedObjectNotFound exp) {
VcUtil.processNotFoundException(exp,moId,logger);
}
}"
48672,"public Long upgradeClusterByName(String clusterName) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (!clusterEntityMgr.isNeedToUpgrade(clusterName)) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw ClusterManagerException.ALREADY_LATEST_VERSION_ERROR(clusterName);
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus()) && !ClusterStatus.STOPPED.equals(cluster.getStatus()) && !ClusterStatus.ERROR.equals(cluster.getStatus())&& !ClusterStatus.CONFIGURE_ERROR.equals(cluster.getStatus())&& !ClusterStatus.UPGRADE_ERROR.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.UPGRADE_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.UPGRADE_ERROR.name()));
  JobParameters jobParameters=new JobParameters(param);
  clusterEntityMgr.storeClusterLastStatus(clusterName);
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.UPGRADING);
  try {
    return jobManager.runJob(JobConstants.UPGRADE_CLUSTER_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    cluster=clusterEntityMgr.findByName(clusterName);
    if (cluster != null) {
      clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.UPGRADE_ERROR);
    }
    throw e;
  }
}","public Long upgradeClusterByName(String clusterName) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (!clusterEntityMgr.needUpgrade(clusterName)) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw ClusterManagerException.ALREADY_LATEST_VERSION_ERROR(clusterName);
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus()) && !ClusterStatus.STOPPED.equals(cluster.getStatus()) && !ClusterStatus.ERROR.equals(cluster.getStatus())&& !ClusterStatus.CONFIGURE_ERROR.equals(cluster.getStatus())&& !ClusterStatus.UPGRADE_ERROR.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.UPGRADE_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.UPGRADE_ERROR.name()));
  JobParameters jobParameters=new JobParameters(param);
  clusterEntityMgr.storeClusterLastStatus(clusterName);
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.UPGRADING);
  clusterEntityMgr.updateNodesAction(clusterName,Constants.NODE_ACTION_UPGRADING);
  clusterEntityMgr.cleanupErrorForClusterUpgrade(clusterName);
  try {
    return jobManager.runJob(JobConstants.UPGRADE_CLUSTER_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    cluster=clusterEntityMgr.findByName(clusterName);
    if (cluster != null) {
      clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.UPGRADE_ERROR);
    }
    throw e;
  }
}"
48673,"public Long stopCluster(String clusterName) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (ClusterStatus.STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw ClusterManagerException.ALREADY_STOPPED_ERROR(clusterName);
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus()) && !ClusterStatus.ERROR.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.STOP_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.STOPPED.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.ERROR.name()));
  JobParameters jobParameters=new JobParameters(param);
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.STOPPING);
  clusterEntityMgr.cleanupActionError(clusterName);
  try {
    return jobManager.runJob(JobConstants.STOP_CLUSTER_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.ERROR);
    throw e;
  }
}","public Long stopCluster(String clusterName) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ValidationUtils.validateVersion(clusterEntityMgr,clusterName);
  if (ClusterStatus.STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw ClusterManagerException.ALREADY_STOPPED_ERROR(clusterName);
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus()) && !ClusterStatus.ERROR.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.STOP_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.STOPPED.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.ERROR.name()));
  JobParameters jobParameters=new JobParameters(param);
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.STOPPING);
  clusterEntityMgr.cleanupActionError(clusterName);
  try {
    return jobManager.runJob(JobConstants.STOP_CLUSTER_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.ERROR);
    throw e;
  }
}"
48674,"@Transactional private void updateNodeData(NodeEntity node,boolean upgraded,String errorMessage){
  node=clusterEntityMgr.getNodeWithNicsByMobId(node.getMoId());
  String nodeVmName=node.getVmName();
  String nodeIp=node.getPrimaryMgtIpV4();
  if (upgraded) {
    if (nodeIp != null && !Constants.NULL_IPV4_ADDRESS.equals(nodeIp)) {
      logger.info(""String_Node_Str"" + nodeVmName);
      node.setVersion(serverVersion);
      node.setAction(Constants.NODE_ACTION_UPGRADE_SUCCESS);
      node.setActionFailed(false);
      node.setErrMessage(null);
      clusterEntityMgr.update(node);
    }
  }
 else {
    logger.error(""String_Node_Str"" + nodeVmName);
    node.setAction(Constants.NODE_ACTION_UPGRADE_FAILED);
    node.setActionFailed(true);
    String[] messages=errorMessage.split(""String_Node_Str"");
    if (messages != null && messages.length > 0) {
      node.setErrMessage(messages[messages.length - 1]);
    }
 else {
      node.setErrMessage(""String_Node_Str"" + nodeVmName + ""String_Node_Str"");
    }
    clusterEntityMgr.update(node);
  }
}","@Transactional private void updateNodeData(NodeEntity node,boolean upgraded,String errorMessage){
  node=clusterEntityMgr.getNodeWithNicsByMobId(node.getMoId());
  String nodeVmName=node.getVmName();
  if (upgraded) {
    if (node.canBeUpgrade()) {
      logger.info(""String_Node_Str"" + nodeVmName);
      node.setVersion(serverVersion);
      node.setAction(Constants.NODE_ACTION_UPGRADE_SUCCESS);
      node.setActionFailed(false);
      node.setErrMessage(null);
      clusterEntityMgr.update(node);
    }
  }
 else {
    logger.error(""String_Node_Str"" + nodeVmName);
    node.setAction(Constants.NODE_ACTION_UPGRADE_FAILED);
    node.setActionFailed(true);
    String[] messages=errorMessage.split(""String_Node_Str"");
    if (messages != null && messages.length > 0) {
      node.setErrMessage(messages[messages.length - 1]);
    }
 else {
      node.setErrMessage(""String_Node_Str"" + nodeVmName + ""String_Node_Str"");
    }
    clusterEntityMgr.update(node);
  }
}"
48675,"@Override public boolean upgrade(final String clusterName,StatusUpdater statusUpdator){
  logger.info(""String_Node_Str"" + clusterName + ""String_Node_Str"");
  this.serverVersion=clusterEntityMgr.getServerVersion();
  List<NodeEntity> nodes=getNodes(clusterName);
  List<Callable<Void>> storeNodeProcedures=new ArrayList<Callable<Void>>();
  try {
    for (    NodeEntity node : nodes) {
      if (NeedUpgrade(node)) {
        setActionToUpgrading(node);
        NodeUpgradeSP nodeUpgradeSP=new NodeUpgradeSP(node,serverVersion);
        storeNodeProcedures.add(nodeUpgradeSP);
      }
    }
    if (storeNodeProcedures.isEmpty()) {
      logger.info(""String_Node_Str"");
      return true;
    }
    Callable<Void>[] storeNodeProceduresArray=storeNodeProcedures.toArray(new Callable[0]);
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeNodeProceduresArray,callback);
    if (result == null || result.length == 0) {
      logger.error(""String_Node_Str"");
      return false;
    }
    boolean success=true;
    int total=0;
    for (int i=0; i < storeNodeProceduresArray.length; i++) {
      Throwable nodeUpgradeSPException=result[i].throwable;
      NodeUpgradeSP sp=(NodeUpgradeSP)storeNodeProceduresArray[i];
      NodeEntity node=sp.getNode();
      if (result[i].finished && nodeUpgradeSPException == null) {
        updateNodeData(node);
        ++total;
      }
 else       if (nodeUpgradeSPException != null) {
        updateNodeData(node,false,nodeUpgradeSPException.getMessage());
        logger.error(""String_Node_Str"" + node.getVmName(),nodeUpgradeSPException);
        success=false;
      }
    }
    logger.info(total + ""String_Node_Str"");
    return success;
  }
 catch (  InterruptedException e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.UPGRADE(e,e.getMessage());
  }
}","@Override public boolean upgrade(final String clusterName,StatusUpdater statusUpdator){
  logger.info(""String_Node_Str"" + clusterName + ""String_Node_Str"");
  this.serverVersion=clusterEntityMgr.getServerVersion();
  List<NodeEntity> nodes=getNodes(clusterName);
  List<Callable<Void>> storeNodeProcedures=new ArrayList<Callable<Void>>();
  try {
    for (    NodeEntity node : nodes) {
      if (node.needUpgrade(serverVersion)) {
        NodeUpgradeSP nodeUpgradeSP=new NodeUpgradeSP(node,serverVersion);
        storeNodeProcedures.add(nodeUpgradeSP);
      }
    }
    if (storeNodeProcedures.isEmpty()) {
      logger.info(""String_Node_Str"");
      return true;
    }
    Callable<Void>[] storeNodeProceduresArray=storeNodeProcedures.toArray(new Callable[0]);
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeNodeProceduresArray,callback);
    if (result == null || result.length == 0) {
      logger.error(""String_Node_Str"");
      return false;
    }
    boolean success=true;
    int total=0;
    for (int i=0; i < storeNodeProceduresArray.length; i++) {
      Throwable nodeUpgradeSPException=result[i].throwable;
      NodeUpgradeSP sp=(NodeUpgradeSP)storeNodeProceduresArray[i];
      NodeEntity node=sp.getNode();
      if (result[i].finished && nodeUpgradeSPException == null) {
        updateNodeData(node);
        ++total;
      }
 else       if (nodeUpgradeSPException != null) {
        updateNodeData(node,false,nodeUpgradeSPException.getMessage());
        logger.error(""String_Node_Str"" + node.getVmName(),nodeUpgradeSPException);
        success=false;
      }
    }
    logger.info(total + ""String_Node_Str"");
    return success;
  }
 catch (  InterruptedException e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.UPGRADE(e,e.getMessage());
  }
}"
48676,"@Override public boolean upgradeNode(NodeEntity node){
  node=clusterEntityMgr.getNodeWithNicsByMobId(node.getMoId());
  String nodeIP=node.getPrimaryMgtNic().getIpv4Address();
  logger.info(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ nodeIP+ ""String_Node_Str"");
  this.serverVersion=clusterEntityMgr.getServerVersion();
  List<Callable<Void>> storeNodeProcedures=new ArrayList<Callable<Void>>();
  try {
    if (NeedUpgrade(node)) {
      setActionToUpgrading(node);
      NodeUpgradeSP nodeUpgradeSP=new NodeUpgradeSP(node,serverVersion);
      storeNodeProcedures.add(nodeUpgradeSP);
    }
    if (storeNodeProcedures.isEmpty()) {
      logger.info(node.getVmName() + ""String_Node_Str"");
      return true;
    }
    Callable<Void>[] storeNodeProceduresArray=storeNodeProcedures.toArray(new Callable[0]);
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeNodeProceduresArray,callback);
    if (result == null || result.length == 0) {
      logger.warn(""String_Node_Str"");
      return false;
    }
    if (result[0].finished && result[0].throwable == null) {
      updateNodeData(node);
      logger.info(""String_Node_Str"" + node.getVmName() + ""String_Node_Str"");
      return true;
    }
    logger.error(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ nodeIP+ ""String_Node_Str"");
    return false;
  }
 catch (  InterruptedException e) {
    logger.error(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ nodeIP+ ""String_Node_Str"",e);
    throw BddException.UPGRADE(e,e.getMessage());
  }
}","@Override public boolean upgradeNode(NodeEntity node){
  node=clusterEntityMgr.getNodeWithNicsByMobId(node.getMoId());
  String nodeIP=node.getPrimaryMgtNic().getIpv4Address();
  logger.info(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ nodeIP+ ""String_Node_Str"");
  this.serverVersion=clusterEntityMgr.getServerVersion();
  List<Callable<Void>> storeNodeProcedures=new ArrayList<Callable<Void>>();
  try {
    if (node.needUpgrade(serverVersion)) {
      NodeUpgradeSP nodeUpgradeSP=new NodeUpgradeSP(node,serverVersion);
      storeNodeProcedures.add(nodeUpgradeSP);
    }
    if (storeNodeProcedures.isEmpty()) {
      logger.info(node.getVmName() + ""String_Node_Str"");
      return true;
    }
    Callable<Void>[] storeNodeProceduresArray=storeNodeProcedures.toArray(new Callable[0]);
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeNodeProceduresArray,callback);
    if (result == null || result.length == 0) {
      logger.warn(""String_Node_Str"");
      return false;
    }
    if (result[0].finished && result[0].throwable == null) {
      updateNodeData(node);
      logger.info(""String_Node_Str"" + node.getVmName() + ""String_Node_Str"");
      return true;
    }
    logger.error(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ nodeIP+ ""String_Node_Str"");
    return false;
  }
 catch (  InterruptedException e) {
    logger.error(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ nodeIP+ ""String_Node_Str"",e);
    throw BddException.UPGRADE(e,e.getMessage());
  }
}"
48677,"@Override protected boolean execute(){
  logger.info(""String_Node_Str"" + vmId + ""String_Node_Str"");
  NodeEntity nodeEntity=lockClusterEntityMgr.getClusterEntityMgr().getNodeWithNicsByMobId(vmId);
  if (nodeEntity == null) {
    logger.info(""String_Node_Str"" + nodeEntity.getVmName() + ""String_Node_Str"");
  }
  QueryIpAddress query=new QueryIpAddress(nodeEntity.fetchAllPortGroups(),Constants.VM_POWER_ON_WAITING_SEC);
  query.setVmId(vmId);
  try {
    query.call();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + vmId,e);
  }
  String clusterName=CommonUtil.getClusterName(nodeEntity.getVmName());
  lockClusterEntityMgr.refreshNodeByMobId(clusterName,vmId,false);
  ClusterUpgradeService upgradeService=new ClusterUpgradeService();
  IClusterEntityManager clusterEntityMgr=lockClusterEntityMgr.getClusterEntityMgr();
  upgradeService.setClusterEntityMgr(clusterEntityMgr);
  logger.debug(""String_Node_Str"" + nodeEntity.getVmName() + ""String_Node_Str"");
  upgradeService.upgradeNode(nodeEntity);
  return true;
}","@Override protected boolean execute(){
  logger.info(""String_Node_Str"" + vmId + ""String_Node_Str"");
  NodeEntity nodeEntity=lockClusterEntityMgr.getClusterEntityMgr().getNodeWithNicsByMobId(vmId);
  if (nodeEntity == null) {
    logger.info(""String_Node_Str"" + nodeEntity.getVmName() + ""String_Node_Str"");
  }
  QueryIpAddress query=new QueryIpAddress(nodeEntity.fetchAllPortGroups(),Constants.VM_POWER_ON_WAITING_SEC);
  query.setVmId(vmId);
  try {
    query.call();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + vmId,e);
  }
  String clusterName=CommonUtil.getClusterName(nodeEntity.getVmName());
  lockClusterEntityMgr.refreshNodeByMobId(clusterName,vmId,false);
  ClusterUpgradeService upgradeService=new ClusterUpgradeService();
  IClusterEntityManager clusterEntityMgr=lockClusterEntityMgr.getClusterEntityMgr();
  upgradeService.setClusterEntityMgr(clusterEntityMgr);
  logger.debug(""String_Node_Str"" + nodeEntity.getVmName() + ""String_Node_Str"");
  clusterEntityMgr.updateNodeAction(nodeEntity,Constants.NODE_ACTION_UPGRADING);
  upgradeService.upgradeNode(nodeEntity);
  return true;
}"
48678,"private void prettyOutputDetailNodegroups(TopologyType topology,LinkedHashMap<String,List<String>> ngColumnNamesWithGetMethodNames,List<NodeGroupRead> nodegroups) throws Exception {
  LinkedHashMap<String,List<String>> nColumnNamesWithGetMethodNames=new LinkedHashMap<String,List<String>>();
  nColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_NODE_NAME,Arrays.asList(""String_Node_Str""));
  nColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_NODE_VERSION,Arrays.asList(""String_Node_Str""));
  nColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_HOST,Arrays.asList(""String_Node_Str""));
  if (topology == TopologyType.RACK_AS_RACK || topology == TopologyType.HVE) {
    nColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_RACK,Arrays.asList(""String_Node_Str""));
  }
  nColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_IP,Arrays.asList(""String_Node_Str""));
  nColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_HDFS_IP,Arrays.asList(""String_Node_Str""));
  nColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_MAPRED_IP,Arrays.asList(""String_Node_Str""));
  nColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_STATUS,Arrays.asList(""String_Node_Str""));
  nColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_TASK,Arrays.asList(""String_Node_Str""));
  for (  NodeGroupRead nodegroup : nodegroups) {
    CommandsUtils.printInTableFormat(ngColumnNamesWithGetMethodNames,new NodeGroupRead[]{nodegroup},Constants.OUTPUT_INDENT);
    List<NodeRead> nodes=nodegroup.getInstances();
    if (nodes != null) {
      LinkedHashMap<String,List<String>> nColumnNamesWithGetMethodNamesClone=(LinkedHashMap<String,List<String>>)nColumnNamesWithGetMethodNames.clone();
      if (!nodes.isEmpty() && (nodes.get(0).getIpConfigs() == null || (!nodes.get(0).getIpConfigs().containsKey(NetTrafficType.HDFS_NETWORK) && !nodes.get(0).getIpConfigs().containsKey(NetTrafficType.MAPRED_NETWORK)))) {
        nColumnNamesWithGetMethodNamesClone.remove(Constants.FORMAT_TABLE_COLUMN_HDFS_IP);
        nColumnNamesWithGetMethodNamesClone.remove(Constants.FORMAT_TABLE_COLUMN_MAPRED_IP);
      }
      System.out.println();
      CommandsUtils.printInTableFormat(nColumnNamesWithGetMethodNamesClone,nodes.toArray(),new StringBuilder().append(Constants.OUTPUT_INDENT).append(Constants.OUTPUT_INDENT).toString());
    }
    System.out.println();
  }
  prettyOutputErrorNode(nodegroups);
}","private void prettyOutputDetailNodegroups(TopologyType topology,LinkedHashMap<String,List<String>> ngColumnNamesWithGetMethodNames,List<NodeGroupRead> nodegroups) throws Exception {
  LinkedHashMap<String,List<String>> nColumnNamesWithGetMethodNames=new LinkedHashMap<String,List<String>>();
  nColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_NODE_NAME,Arrays.asList(""String_Node_Str""));
  nColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_NODE_VERSION,Arrays.asList(""String_Node_Str""));
  nColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_HOST,Arrays.asList(""String_Node_Str""));
  if (topology == TopologyType.RACK_AS_RACK || topology == TopologyType.HVE) {
    nColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_RACK,Arrays.asList(""String_Node_Str""));
  }
  nColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_IP,Arrays.asList(""String_Node_Str""));
  nColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_HDFS_IP,Arrays.asList(""String_Node_Str""));
  nColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_MAPRED_IP,Arrays.asList(""String_Node_Str""));
  nColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_STATUS,Arrays.asList(""String_Node_Str""));
  nColumnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_TASK,Arrays.asList(""String_Node_Str""));
  for (  NodeGroupRead nodegroup : nodegroups) {
    CommandsUtils.printInTableFormat(ngColumnNamesWithGetMethodNames,new NodeGroupRead[]{nodegroup},Constants.OUTPUT_INDENT);
    List<NodeRead> nodes=nodegroup.getInstances();
    if (nodes != null) {
      LinkedHashMap<String,List<String>> nColumnNamesWithGetMethodNamesClone=(LinkedHashMap<String,List<String>>)nColumnNamesWithGetMethodNames.clone();
      if (!nodes.isEmpty() && (nodes.get(0).getIpConfigs() == null || (!nodes.get(0).getIpConfigs().containsKey(NetTrafficType.HDFS_NETWORK) && !nodes.get(0).getIpConfigs().containsKey(NetTrafficType.MAPRED_NETWORK)))) {
        nColumnNamesWithGetMethodNamesClone.remove(Constants.FORMAT_TABLE_COLUMN_HDFS_IP);
        nColumnNamesWithGetMethodNamesClone.remove(Constants.FORMAT_TABLE_COLUMN_MAPRED_IP);
      }
      System.out.println();
      CommandsUtils.printInTableFormat(nColumnNamesWithGetMethodNamesClone,nodes.toArray(),new StringBuilder().append(Constants.OUTPUT_INDENT).append(Constants.OUTPUT_INDENT).toString());
    }
    System.out.println();
  }
  CommandsUtils.prettyOutputErrorNode(nodegroups);
}"
48679,"public void prettyOutput() throws Exception {
  try {
    if (cluster != null) {
      List<NodeGroupRead> nodeGroups=cluster.getNodeGroups();
      if (nodeGroups != null) {
        for (        NodeGroupRead nodeGroup : nodeGroups) {
          System.out.printf(""String_Node_Str"",nodeGroup.getName(),nodeGroup.getInstanceNum());
          System.out.printf(""String_Node_Str"",nodeGroup.getRoles());
          printNodesInfo(nodeGroup.getInstances());
        }
        prettyOutputErrorNode(nodeGroups);
      }
    }
  }
 catch (  Exception e) {
    throw e;
  }
}","public void prettyOutput() throws Exception {
  try {
    if (cluster != null) {
      List<NodeGroupRead> nodeGroups=cluster.getNodeGroups();
      if (nodeGroups != null) {
        for (        NodeGroupRead nodeGroup : nodeGroups) {
          System.out.printf(""String_Node_Str"",nodeGroup.getName(),nodeGroup.getInstanceNum());
          System.out.printf(""String_Node_Str"",nodeGroup.getRoles());
          printNodesInfo(nodeGroup.getInstances());
        }
        CommandsUtils.prettyOutputErrorNode(nodeGroups);
      }
    }
  }
 catch (  Exception e) {
    throw e;
  }
}"
48680,"private PrettyOutput getClusterPrettyOutputCallBack(final ClusterRestClient clusterRestClient,final String id,final String... completedTaskSummary){
  return new PrettyOutput(){
    private String ngSnapshotInJson=null;
    private boolean needUpdate=true;
    private ClusterRead cluster=null;
    public void prettyOutput() throws Exception {
      try {
        if (cluster != null) {
          List<NodeGroupRead> nodeGroups=cluster.getNodeGroups();
          if (nodeGroups != null) {
            for (            NodeGroupRead nodeGroup : nodeGroups) {
              System.out.printf(""String_Node_Str"",nodeGroup.getName(),nodeGroup.getInstanceNum());
              System.out.printf(""String_Node_Str"",nodeGroup.getRoles());
              printNodesInfo(nodeGroup.getInstances());
            }
            prettyOutputErrorNode(nodeGroups);
          }
        }
      }
 catch (      Exception e) {
        throw e;
      }
    }
    private void prettyOutputErrorNode(    List<NodeGroupRead> nodegroups) throws Exception {
      List<NodeRead> failedNodes=new ArrayList<NodeRead>();
      for (      NodeGroupRead nodegroup : nodegroups) {
        List<NodeRead> nodes=nodegroup.getInstances();
        if (nodes != null) {
          for (          NodeRead node : nodes) {
            if (node.isActionFailed()) {
              failedNodes.add(node);
            }
          }
        }
      }
      if (!failedNodes.isEmpty()) {
        System.out.println();
        System.out.println(Constants.FAILED_NODES_MESSAGE + failedNodes.size());
        LinkedHashMap<String,List<String>> columnNamesWithGetMethodNames=new LinkedHashMap<String,List<String>>();
        columnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_NODE_NAME,Arrays.asList(""String_Node_Str""));
        columnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_STATUS,Arrays.asList(""String_Node_Str""));
        columnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_ERROR,Arrays.asList(""String_Node_Str""));
        CommandsUtils.printInTableFormat(columnNamesWithGetMethodNames,failedNodes.toArray(),Constants.OUTPUT_INDENT);
      }
    }
    public boolean isRefresh(    boolean realTime) throws Exception {
      try {
        cluster=clusterRestClient.get(id,realTime);
        if (cluster != null) {
          List<NodeGroupRead> nodeGroups=cluster.getNodeGroups();
          if (nodeGroups != null) {
            return checkOutputUpdate(nodeGroups);
          }
        }
        return false;
      }
 catch (      CliRestException expectedException) {
        cluster=null;
        return false;
      }
catch (      Exception e) {
        throw e;
      }
    }
    private void printNodesInfo(    List<NodeRead> nodes) throws Exception {
      if (nodes != null && nodes.size() > 0) {
        LinkedHashMap<String,List<String>> columnNamesWithGetMethodNames=new LinkedHashMap<String,List<String>>();
        columnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_NAME,Arrays.asList(""String_Node_Str""));
        columnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_IP,Arrays.asList(""String_Node_Str""));
        if (nodes.get(0).getIpConfigs() != null && (nodes.get(0).getIpConfigs().containsKey(NetConfigInfo.NetTrafficType.HDFS_NETWORK) || nodes.get(0).getIpConfigs().containsKey(NetConfigInfo.NetTrafficType.MAPRED_NETWORK))) {
          columnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_HDFS_IP,Arrays.asList(""String_Node_Str""));
          columnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_MAPRED_IP,Arrays.asList(""String_Node_Str""));
        }
        columnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_STATUS,Arrays.asList(""String_Node_Str""));
        columnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_TASK,Arrays.asList(""String_Node_Str""));
        CommandsUtils.printInTableFormat(columnNamesWithGetMethodNames,nodes.toArray(),Constants.OUTPUT_INDENT);
      }
 else {
        System.out.println();
      }
    }
    private boolean checkOutputUpdate(    List<NodeGroupRead> nodeGroups) throws JsonGenerationException, IOException {
      ObjectMapper mapper=new ObjectMapper();
      String ngCurrentInJson=mapper.writeValueAsString(nodeGroups);
      if (ngSnapshotInJson != null && ngSnapshotInJson.equals(ngCurrentInJson)) {
        needUpdate=false;
      }
 else {
        ngSnapshotInJson=ngCurrentInJson;
        needUpdate=true;
      }
      return needUpdate;
    }
    public String[] getCompletedTaskSummary(){
      return completedTaskSummary;
    }
  }
;
}","private PrettyOutput getClusterPrettyOutputCallBack(final ClusterRestClient clusterRestClient,final String id,final String... completedTaskSummary){
  return new PrettyOutput(){
    private String ngSnapshotInJson=null;
    private boolean needUpdate=true;
    private ClusterRead cluster=null;
    public void prettyOutput() throws Exception {
      try {
        if (cluster != null) {
          List<NodeGroupRead> nodeGroups=cluster.getNodeGroups();
          if (nodeGroups != null) {
            for (            NodeGroupRead nodeGroup : nodeGroups) {
              System.out.printf(""String_Node_Str"",nodeGroup.getName(),nodeGroup.getInstanceNum());
              System.out.printf(""String_Node_Str"",nodeGroup.getRoles());
              printNodesInfo(nodeGroup.getInstances());
            }
            CommandsUtils.prettyOutputErrorNode(nodeGroups);
          }
        }
      }
 catch (      Exception e) {
        throw e;
      }
    }
    public boolean isRefresh(    boolean realTime) throws Exception {
      try {
        cluster=clusterRestClient.get(id,realTime);
        if (cluster != null) {
          List<NodeGroupRead> nodeGroups=cluster.getNodeGroups();
          if (nodeGroups != null) {
            return checkOutputUpdate(nodeGroups);
          }
        }
        return false;
      }
 catch (      CliRestException expectedException) {
        cluster=null;
        return false;
      }
catch (      Exception e) {
        throw e;
      }
    }
    private void printNodesInfo(    List<NodeRead> nodes) throws Exception {
      if (nodes != null && nodes.size() > 0) {
        LinkedHashMap<String,List<String>> columnNamesWithGetMethodNames=new LinkedHashMap<String,List<String>>();
        columnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_NAME,Arrays.asList(""String_Node_Str""));
        columnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_IP,Arrays.asList(""String_Node_Str""));
        if (nodes.get(0).getIpConfigs() != null && (nodes.get(0).getIpConfigs().containsKey(NetConfigInfo.NetTrafficType.HDFS_NETWORK) || nodes.get(0).getIpConfigs().containsKey(NetConfigInfo.NetTrafficType.MAPRED_NETWORK))) {
          columnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_HDFS_IP,Arrays.asList(""String_Node_Str""));
          columnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_MAPRED_IP,Arrays.asList(""String_Node_Str""));
        }
        columnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_STATUS,Arrays.asList(""String_Node_Str""));
        columnNamesWithGetMethodNames.put(Constants.FORMAT_TABLE_COLUMN_TASK,Arrays.asList(""String_Node_Str""));
        CommandsUtils.printInTableFormat(columnNamesWithGetMethodNames,nodes.toArray(),Constants.OUTPUT_INDENT);
      }
 else {
        System.out.println();
      }
    }
    private boolean checkOutputUpdate(    List<NodeGroupRead> nodeGroups) throws JsonGenerationException, IOException {
      ObjectMapper mapper=new ObjectMapper();
      String ngCurrentInJson=mapper.writeValueAsString(nodeGroups);
      if (ngSnapshotInJson != null && ngSnapshotInJson.equals(ngCurrentInJson)) {
        needUpdate=false;
      }
 else {
        ngSnapshotInJson=ngCurrentInJson;
        needUpdate=true;
      }
      return needUpdate;
    }
    public String[] getCompletedTaskSummary(){
      return completedTaskSummary;
    }
  }
;
}"
48681,"private <T>ResponseEntity<T> login(final String path,final Class<T> respEntityType,final String username,final String password){
  StringBuilder uriBuff=new StringBuilder();
  uriBuff.append(hostUri).append(path);
  if (!CommandsUtils.isBlank(username) && !CommandsUtils.isBlank(password)) {
    uriBuff.append(""String_Node_Str"").append(""String_Node_Str"").append(username).append(""String_Node_Str"").append(password);
  }
  return restPostByUri(uriBuff.toString(),respEntityType,false);
}","private <T>ResponseEntity<T> login(final String path,final Class<T> respEntityType,final String username,final String password){
  StringBuilder uriBuff=new StringBuilder();
  uriBuff.append(hostUri).append(path);
  return restPostByUri(uriBuff.toString(),username,password,respEntityType,false);
}"
48682,"private <T>ResponseEntity<T> restPostByUri(String uri,Class<T> respEntityType,boolean withCookie){
  HttpHeaders headers=buildHeaders(withCookie);
  HttpEntity<String> entity=new HttpEntity<String>(headers);
  return client.exchange(uri,HttpMethod.POST,entity,respEntityType);
}","private <T>ResponseEntity<T> restPostByUri(String uri,final String username,final String password,Class<T> respEntityType,boolean withCookie){
  HttpHeaders headers=buildHeaders(withCookie);
  HttpEntity<String> entity=new HttpEntity<String>(headers);
  return exchange(uri,username,password,HttpMethod.POST,entity,respEntityType);
}"
48683,"@Test public void testAsyncSetParamIoPriorityFailed() throws Exception {
  ClusterEntity cluster=TestClusterEntityManager.assembleClusterEntity(TEST_CLUSTER_NAME);
  cluster.setStatus(ClusterStatus.RUNNING);
  clusterEntityMgr.insert(cluster);
  MockTmScheduler.setFlag(VmOperation.RECONFIGURE_VM,false);
  try {
    clusterMgr.asyncSetParam(TEST_CLUSTER_NAME,3,1,4,true,Priority.HIGH);
    assertTrue(false,""String_Node_Str"");
  }
 catch (  ClusterManagerException e) {
    List<NodeEntity> nodes=clusterEntityMgr.findAllNodes(TEST_CLUSTER_NAME);
    assertTrue(nodes.get(0).isActionFailed(),""String_Node_Str"" + nodes.get(0).isActionFailed());
    assertTrue(""String_Node_Str"".equals(nodes.get(0).getErrMessage()),""String_Node_Str"" + nodes.get(0).getErrMessage());
  }
}","@Test public void testAsyncSetParamIoPriorityFailed() throws Exception {
  ClusterEntity cluster=TestClusterEntityManager.assembleClusterEntity(TEST_CLUSTER_NAME);
  cluster.setStatus(ClusterStatus.RUNNING);
  clusterEntityMgr.insert(cluster);
  MockTmScheduler.setFlag(VmOperation.RECONFIGURE_VM,false);
  try {
    clusterMgr.asyncSetParam(TEST_CLUSTER_NAME,3,1,4,true,Priority.HIGH);
    assertTrue(false,""String_Node_Str"");
  }
 catch (  ClusterManagerException e) {
    List<NodeEntity> nodes=clusterEntityMgr.findAllNodes(TEST_CLUSTER_NAME);
    assertTrue(nodes.get(0).isActionFailed(),""String_Node_Str"" + nodes.get(0).isActionFailed());
    assertTrue(nodes.get(0).getErrMessage().endsWith(""String_Node_Str""),""String_Node_Str"" + nodes.get(0).getErrMessage());
  }
}"
48684,"private String getInputedPassword(String promptMsg){
  try {
    ConsoleReader reader=new ConsoleReader();
    reader.setPrompt(promptMsg);
    String password=""String_Node_Str"";
    password=reader.readLine(Character.valueOf('*'));
    if (isValidPassword(password)) {
      return password;
    }
 else {
      return null;
    }
  }
 catch (  IOException e) {
    return null;
  }
}","private String getInputedPassword(String promptMsg){
  try {
    ConsoleReader reader=new ConsoleReader();
    reader.setPrompt(promptMsg);
    String password=null;
    password=reader.readLine(Character.valueOf('*'));
    if (isValidPassword(password)) {
      return password;
    }
 else {
      return null;
    }
  }
 catch (  IOException e) {
    return null;
  }
}"
48685,"private boolean containInvalidCharacter(String password){
  if (password.contains(Constants.ESCAPE_CHAR)) {
    return true;
  }
  return false;
}","private boolean containInvalidCharacter(String password){
  Pattern pattern=Pattern.compile(""String_Node_Str"");
  if (!pattern.matcher(password).matches()) {
    return true;
  }
  return false;
}"
48686,"public ClusterCreate getSpec(String id){
  final String path=Constants.REST_PATH_CLUSTER + ""String_Node_Str"" + id+ ""String_Node_Str""+ Constants.REST_PATH_SPEC;
  final HttpMethod httpverb=HttpMethod.GET;
  return restClient.getObjectByPath(ClusterCreate.class,path,httpverb,false);
}","public ClusterCreate getSpec(String id){
  id=CommonUtil.encode(id);
  final String path=Constants.REST_PATH_CLUSTER + ""String_Node_Str"" + id+ ""String_Node_Str""+ Constants.REST_PATH_SPEC;
  final HttpMethod httpverb=HttpMethod.GET;
  return restClient.getObjectByPath(ClusterCreate.class,path,httpverb,false);
}"
48687,"public ClusterRead get(String id,Boolean detail){
  final String path=Constants.REST_PATH_CLUSTER;
  final HttpMethod httpverb=HttpMethod.GET;
  return restClient.getObject(id,ClusterRead.class,path,httpverb,detail);
}","public ClusterRead get(String id,Boolean detail){
  id=CommonUtil.encode(id);
  final String path=Constants.REST_PATH_CLUSTER;
  final HttpMethod httpverb=HttpMethod.GET;
  return restClient.getObject(id,ClusterRead.class,path,httpverb,detail);
}"
48688,"/** 
 * Retrieve a cluster information by it name
 * @param clusterName
 * @param details not used by this version
 * @return The cluster information
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET,produces=""String_Node_Str"") @ResponseBody public ClusterRead getCluster(@PathVariable(""String_Node_Str"") final String clusterName,@RequestParam(value=""String_Node_Str"",required=false) Boolean details){
  if (CommonUtil.isBlank(clusterName) || !CommonUtil.validateClusterName(clusterName)) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
  }
  return clusterMgr.getClusterByName(clusterName,(details == null) ? false : details);
}","/** 
 * Retrieve a cluster information by it name
 * @param clusterName
 * @param details not used by this version
 * @return The cluster information
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET,produces=""String_Node_Str"") @ResponseBody public ClusterRead getCluster(@PathVariable(""String_Node_Str"") String clusterName,@RequestParam(value=""String_Node_Str"",required=false) Boolean details){
  clusterName=CommonUtil.decode(clusterName);
  if (CommonUtil.isBlank(clusterName) || !CommonUtil.validateClusterName(clusterName)) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
  }
  return clusterMgr.getClusterByName(clusterName,(details == null) ? false : details);
}"
48689,"/** 
 * Retrieve a cluster's specification by its name
 * @param clusterName
 * @return The cluster specification
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET,produces=""String_Node_Str"") @ResponseBody public ClusterCreate getClusterSpec(@PathVariable(""String_Node_Str"") final String clusterName){
  if (CommonUtil.isBlank(clusterName) || !CommonUtil.validateClusterName(clusterName)) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
  }
  return clusterMgr.getClusterSpec(clusterName);
}","/** 
 * Retrieve a cluster's specification by its name
 * @param clusterName
 * @return The cluster specification
 */
@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET,produces=""String_Node_Str"") @ResponseBody public ClusterCreate getClusterSpec(@PathVariable(""String_Node_Str"") String clusterName){
  clusterName=CommonUtil.decode(clusterName);
  if (CommonUtil.isBlank(clusterName) || !CommonUtil.validateClusterName(clusterName)) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
  }
  return clusterMgr.getClusterSpec(clusterName);
}"
48690,"public boolean execCmd(String user,String privateKeyFile,String hostIP,int sshPort,String command,InputStream in,OutputStream out){
  AuAssert.check(command != null);
  connect(user,privateKeyFile,hostIP,sshPort);
  ChannelExec channel=null;
  logger.info(""String_Node_Str"");
  try {
    channel=(ChannelExec)session.openChannel(""String_Node_Str"");
    if (channel != null) {
      logger.debug(""String_Node_Str"");
      channel.setPty(true);
      channel.setCommand(command);
      channel.setInputStream(in);
      channel.setOutputStream(out);
      channel.connect();
      if (!channel.isConnected()) {
        logger.error(""String_Node_Str"");
      }
      while (true) {
        if (channel.isClosed()) {
          int exitStatus=channel.getExitStatus();
          logger.debug(""String_Node_Str"" + exitStatus);
          if (exitStatus == 0) {
            return true;
          }
          return false;
        }
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException e) {
        }
      }
    }
 else {
      logger.error(""String_Node_Str"" + hostIP + ""String_Node_Str"");
      return false;
    }
  }
 catch (  JSchException e) {
    e.printStackTrace();
  }
 finally {
    if (channel != null && channel.isConnected()) {
      channel.disconnect();
    }
    if (session != null && channel.isConnected()) {
      session.disconnect();
    }
  }
  return false;
}","public boolean execCmd(String user,String privateKeyFile,String hostIP,int sshPort,String command,InputStream in,OutputStream out){
  AuAssert.check(command != null);
  connect(user,privateKeyFile,hostIP,sshPort);
  ChannelExec channel=null;
  logger.info(""String_Node_Str"");
  try {
    channel=(ChannelExec)session.openChannel(""String_Node_Str"");
    if (channel != null) {
      logger.debug(""String_Node_Str"");
      channel.setPty(true);
      channel.setCommand(command);
      channel.setInputStream(in);
      channel.setOutputStream(out);
      channel.connect();
      if (!channel.isConnected()) {
        logger.error(""String_Node_Str"");
      }
      while (true) {
        if (channel.isClosed()) {
          int exitStatus=channel.getExitStatus();
          logger.debug(""String_Node_Str"" + exitStatus);
          if (exitStatus == 0) {
            return true;
          }
          return false;
        }
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException e) {
        }
      }
    }
 else {
      logger.error(""String_Node_Str"" + hostIP + ""String_Node_Str"");
      return false;
    }
  }
 catch (  JSchException e) {
    e.printStackTrace();
  }
 finally {
    if (channel != null && channel.isConnected()) {
      channel.disconnect();
    }
    if (session != null && session.isConnected()) {
      session.disconnect();
    }
  }
  return false;
}"
48691,"public void forbidSystemExitCall(){
  final SecurityManager securityManager=new SecurityManager(){
    @Override public void checkPermission(    Permission permission){
      if (permission.getName().startsWith(""String_Node_Str"")) {
        throw new ExitTrappedException();
      }
    }
  }
;
  System.setSecurityManager(securityManager);
}","final public void forbidSystemExitCall(){
  final SecurityManager securityManager=new SecurityManager(){
    @Override public void checkPermission(    Permission permission){
      if (permission.getName().startsWith(""String_Node_Str"")) {
        throw new ExitTrappedException();
      }
    }
  }
;
  System.setSecurityManager(securityManager);
}"
48692,"/** 
 * Find or create a matching STATS entry. Note that the STATS source is retrieved from the thread local variable that was previous set by StatsEntry.start() or StatsEntry.push().
 * @param type current STATS type
 * @param objs objects for identifying the STATS entry
 * @return the STATS entry
 */
public static StatsEntry getStatsEntry(StatsType type,Object... objs){
  String key=StatsEntry.getKey(getStatsSrc(),type,objs);
  StatsEntry val=countMap.get(key);
  if (val == null) {
synchronized (countMap) {
      val=countMap.get(key);
      if (val == null) {
        val=new StatsEntry(getStatsSrc(),type,objs);
        countMap.put(key,val);
        sortedSet.add(val);
      }
    }
  }
  return val;
}","/** 
 * Find or create a matching STATS entry. Note that the STATS source is retrieved from the thread local variable that was previous set by StatsEntry.start() or StatsEntry.push().
 * @param type current STATS type
 * @param objs objects for identifying the STATS entry
 * @return the STATS entry
 */
public static StatsEntry getStatsEntry(StatsType type,Object... objs){
  String key=StatsEntry.getKey(getStatsSrc(),type,objs);
synchronized (countMap) {
    StatsEntry val=countMap.get(key);
    if (val == null) {
      val=new StatsEntry(getStatsSrc(),type,objs);
      countMap.put(key,val);
      sortedSet.add(val);
    }
    return val;
  }
}"
48693,"@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String targetName=getJobParameters(chunkContext).getString(JobConstants.TARGET_NAME_JOB_PARAM);
  if (targetName == null) {
    targetName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  }
  String jobName=chunkContext.getStepContext().getJobName();
  logger.info(""String_Node_Str"" + targetName + ""String_Node_Str""+ managementOperation+ ""String_Node_Str""+ jobName);
  if (ManagementOperation.CONFIGURE.equals(managementOperation) || JobConstants.RESUME_CLUSTER_JOB_NAME.equals(jobName)) {
    List<NodeEntity> nodes=lockClusterEntityMgr.getClusterEntityMgr().findAllNodes(targetName);
    Set<String> hostnames=new HashSet<String>();
    for (    NodeEntity node : nodes) {
      hostnames.add(node.getHostName());
    }
    ClusterCreate clusterSpec=clusterManager.getClusterSpec(targetName);
    int maxTimeDiffInSec=Constants.MAX_TIME_DIFF_IN_SEC;
    if (clusterSpec.checkHBase())     maxTimeDiffInSec=Constants.MAX_TIME_DIFF_IN_SEC_HBASE;
    List<String> outOfSyncHosts=new ArrayList<String>();
    for (    String hostname : hostnames) {
      int hostTimeDiffInSec=VcResourceUtils.getHostTimeDiffInSec(hostname);
      if (Math.abs(hostTimeDiffInSec) > maxTimeDiffInSec) {
        logger.info(""String_Node_Str"" + hostname + ""String_Node_Str""+ hostTimeDiffInSec+ ""String_Node_Str"");
        outOfSyncHosts.add(hostname);
      }
    }
    if (!outOfSyncHosts.isEmpty()) {
      logger.error(""String_Node_Str"" + outOfSyncHosts + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      throw TaskException.HOST_TIME_OUT_OF_SYNC(outOfSyncHosts);
    }
  }
  StatusUpdater statusUpdater=new DefaultStatusUpdater(jobExecutionStatusHolder,getJobExecutionId(chunkContext));
  File workDir=CommandUtil.createWorkDir(getJobExecutionId(chunkContext));
  putIntoJobExecutionContext(chunkContext,JobConstants.CURRENT_COMMAND_WORK_DIR,workDir.getAbsolutePath());
  boolean needAllocIp=true;
  if (ManagementOperation.DESTROY.equals(managementOperation)) {
    needAllocIp=false;
  }
  String specFilePath=null;
  if (managementOperation.ordinal() != ManagementOperation.DESTROY.ordinal()) {
    File specFile=clusterManager.writeClusterSpecFile(targetName,workDir,needAllocIp);
    specFilePath=specFile.getAbsolutePath();
  }
  ISoftwareManagementTask task=createCommandTask(targetName,specFilePath,statusUpdater);
  Map<String,Object> ret=task.call();
  if (!(Boolean)ret.get(""String_Node_Str"")) {
    String errorMessage=(String)ret.get(""String_Node_Str"");
    putIntoJobExecutionContext(chunkContext,JobConstants.CURRENT_ERROR_MESSAGE,errorMessage);
    throw TaskException.EXECUTION_FAILED(errorMessage);
  }
  return RepeatStatus.FINISHED;
}","@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String targetName=getJobParameters(chunkContext).getString(JobConstants.TARGET_NAME_JOB_PARAM);
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  if (targetName == null) {
    targetName=clusterName;
  }
  String jobName=chunkContext.getStepContext().getJobName();
  logger.info(""String_Node_Str"" + targetName + ""String_Node_Str""+ managementOperation+ ""String_Node_Str""+ jobName);
  if (ManagementOperation.CONFIGURE.equals(managementOperation) || JobConstants.RESUME_CLUSTER_JOB_NAME.equals(jobName)) {
    List<NodeEntity> nodes=lockClusterEntityMgr.getClusterEntityMgr().findAllNodes(clusterName);
    Set<String> hostnames=new HashSet<String>();
    for (    NodeEntity node : nodes) {
      hostnames.add(node.getHostName());
    }
    ClusterCreate clusterSpec=clusterManager.getClusterSpec(clusterName);
    int maxTimeDiffInSec=Constants.MAX_TIME_DIFF_IN_SEC;
    if (clusterSpec.checkHBase())     maxTimeDiffInSec=Constants.MAX_TIME_DIFF_IN_SEC_HBASE;
    List<String> outOfSyncHosts=new ArrayList<String>();
    for (    String hostname : hostnames) {
      int hostTimeDiffInSec=VcResourceUtils.getHostTimeDiffInSec(hostname);
      if (Math.abs(hostTimeDiffInSec) > maxTimeDiffInSec) {
        logger.info(""String_Node_Str"" + hostname + ""String_Node_Str""+ hostTimeDiffInSec+ ""String_Node_Str"");
        outOfSyncHosts.add(hostname);
      }
    }
    if (!outOfSyncHosts.isEmpty()) {
      logger.error(""String_Node_Str"" + outOfSyncHosts + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      throw TaskException.HOST_TIME_OUT_OF_SYNC(outOfSyncHosts);
    }
  }
  StatusUpdater statusUpdater=new DefaultStatusUpdater(jobExecutionStatusHolder,getJobExecutionId(chunkContext));
  File workDir=CommandUtil.createWorkDir(getJobExecutionId(chunkContext));
  putIntoJobExecutionContext(chunkContext,JobConstants.CURRENT_COMMAND_WORK_DIR,workDir.getAbsolutePath());
  boolean needAllocIp=true;
  if (ManagementOperation.DESTROY.equals(managementOperation)) {
    needAllocIp=false;
  }
  String specFilePath=null;
  if (managementOperation.ordinal() != ManagementOperation.DESTROY.ordinal()) {
    File specFile=clusterManager.writeClusterSpecFile(targetName,workDir,needAllocIp);
    specFilePath=specFile.getAbsolutePath();
  }
  ISoftwareManagementTask task=createCommandTask(targetName,specFilePath,statusUpdater);
  Map<String,Object> ret=task.call();
  if (!(Boolean)ret.get(""String_Node_Str"")) {
    String errorMessage=(String)ret.get(""String_Node_Str"");
    putIntoJobExecutionContext(chunkContext,JobConstants.CURRENT_ERROR_MESSAGE,errorMessage);
    throw TaskException.EXECUTION_FAILED(errorMessage);
  }
  return RepeatStatus.FINISHED;
}"
48694,"/** 
 * set cluster parameters synchronously
 * @param clusterName
 * @param activeComputeNodeNum
 * @param minComputeNodeNum
 * @param maxComputeNodeNum
 * @param enableAuto
 * @param ioPriority
 * @return
 * @throws Exception
 */
@SuppressWarnings(""String_Node_Str"") public List<String> syncSetParam(String clusterName,Integer activeComputeNodeNum,Integer minComputeNodeNum,Integer maxComputeNodeNum,Boolean enableAuto,Priority ioPriority) throws Exception {
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  ClusterRead clusterRead=getClusterByName(clusterName,false);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (ioPriority != null) {
    prioritizeCluster(clusterName,ioPriority);
  }
  cluster=clusterEntityMgr.findByName(clusterName);
  if (enableAuto != null && enableAuto != cluster.getAutomationEnable()) {
    if (enableAuto && cluster.getDistro().equalsIgnoreCase(Constants.MAPR_VENDOR)) {
      logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
      throw BddException.NOT_ALLOWED_SCALING(""String_Node_Str"",clusterName);
    }
    cluster.setAutomationEnable(enableAuto);
  }
  if (minComputeNodeNum != null && minComputeNodeNum != cluster.getVhmMinNum()) {
    cluster.setVhmMinNum(minComputeNodeNum);
  }
  if (maxComputeNodeNum != null && maxComputeNodeNum != cluster.getVhmMaxNum()) {
    cluster.setVhmMaxNum(maxComputeNodeNum);
  }
  List<String> nodeGroupNames=new ArrayList<String>();
  if ((enableAuto != null || minComputeNodeNum != null || maxComputeNodeNum != null || activeComputeNodeNum != null) && !clusterRead.validateSetManualElasticity(nodeGroupNames)) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
  }
  if (activeComputeNodeNum != null) {
    if (!activeComputeNodeNum.equals(cluster.getVhmTargetNum())) {
      cluster.setVhmTargetNum(activeComputeNodeNum);
    }
  }
  if ((enableAuto != null) && !ClusterStatus.RUNNING.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus()) && !ClusterStatus.STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  clusterEntityMgr.update(cluster);
  if (enableAuto != null || minComputeNodeNum != null || maxComputeNodeNum != null) {
    boolean success=clusteringService.setAutoElasticity(clusterName,false);
    if (!success) {
      throw ClusterManagerException.FAILED_TO_SET_AUTO_ELASTICITY_ERROR(clusterName,""String_Node_Str"");
    }
  }
  if (enableAuto != null && !enableAuto && cluster.getVhmTargetNum() == null) {
    JobUtils.waitForManual(clusterName,executionService);
  }
  return nodeGroupNames;
}","/** 
 * set cluster parameters synchronously
 * @param clusterName
 * @param activeComputeNodeNum
 * @param minComputeNodeNum
 * @param maxComputeNodeNum
 * @param enableAuto
 * @param ioPriority
 * @return
 * @throws Exception
 */
@SuppressWarnings(""String_Node_Str"") public List<String> syncSetParam(String clusterName,Integer activeComputeNodeNum,Integer minComputeNodeNum,Integer maxComputeNodeNum,Boolean enableAuto,Priority ioPriority) throws Exception {
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  ClusterRead clusterRead=getClusterByName(clusterName,false);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  clusterEntityMgr.cleanupActionError(clusterName);
  if (ioPriority != null) {
    prioritizeCluster(clusterName,ioPriority);
  }
  cluster=clusterEntityMgr.findByName(clusterName);
  if (enableAuto != null && enableAuto != cluster.getAutomationEnable()) {
    if (enableAuto && cluster.getDistro().equalsIgnoreCase(Constants.MAPR_VENDOR)) {
      logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
      throw BddException.NOT_ALLOWED_SCALING(""String_Node_Str"",clusterName);
    }
    cluster.setAutomationEnable(enableAuto);
  }
  if (minComputeNodeNum != null && minComputeNodeNum != cluster.getVhmMinNum()) {
    cluster.setVhmMinNum(minComputeNodeNum);
  }
  if (maxComputeNodeNum != null && maxComputeNodeNum != cluster.getVhmMaxNum()) {
    cluster.setVhmMaxNum(maxComputeNodeNum);
  }
  List<String> nodeGroupNames=new ArrayList<String>();
  if ((enableAuto != null || minComputeNodeNum != null || maxComputeNodeNum != null || activeComputeNodeNum != null) && !clusterRead.validateSetManualElasticity(nodeGroupNames)) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
  }
  if (activeComputeNodeNum != null) {
    if (!activeComputeNodeNum.equals(cluster.getVhmTargetNum())) {
      cluster.setVhmTargetNum(activeComputeNodeNum);
    }
  }
  if ((enableAuto != null) && !ClusterStatus.RUNNING.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus()) && !ClusterStatus.STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  clusterEntityMgr.update(cluster);
  if (enableAuto != null || minComputeNodeNum != null || maxComputeNodeNum != null) {
    boolean success=clusteringService.setAutoElasticity(clusterName,false);
    if (!success) {
      throw ClusterManagerException.FAILED_TO_SET_AUTO_ELASTICITY_ERROR(clusterName,""String_Node_Str"");
    }
  }
  if (enableAuto != null && !enableAuto && cluster.getVhmTargetNum() == null) {
    JobUtils.waitForManual(clusterName,executionService);
  }
  return nodeGroupNames;
}"
48695,"public Long fixDiskFailures(String clusterName,String groupName) throws Exception {
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ClusterStatus oldStatus=cluster.getStatus();
  if (ClusterStatus.RUNNING != oldStatus) {
    throw ClusterHealServiceException.NOT_SUPPORTED(clusterName,""String_Node_Str"");
  }
  List<NodeGroupEntity> nodeGroups;
  if (groupName != null) {
    NodeGroupEntity nodeGroup=clusterEntityMgr.findByName(clusterName,groupName);
    if (nodeGroup == null) {
      logger.error(""String_Node_Str"" + groupName + ""String_Node_Str"");
      throw BddException.NOT_FOUND(""String_Node_Str"",groupName);
    }
    nodeGroups=new ArrayList<NodeGroupEntity>(1);
    nodeGroups.add(nodeGroup);
  }
 else {
    nodeGroups=clusterEntityMgr.findAllGroups(clusterName);
  }
  boolean workerNodesFound=false;
  JobParametersBuilder parametersBuilder=new JobParametersBuilder();
  List<JobParameters> jobParameterList=new ArrayList<JobParameters>();
  for (  NodeGroupEntity nodeGroup : nodeGroups) {
    List<String> roles=nodeGroup.getRoleNameList();
    if (HadoopRole.hasMgmtRole(roles)) {
      logger.info(""String_Node_Str"" + nodeGroup.getName() + ""String_Node_Str"");
      continue;
    }
    workerNodesFound=true;
    for (    NodeEntity node : clusterEntityMgr.findAllNodes(clusterName,nodeGroup.getName())) {
      if (node.isObsoleteNode()) {
        logger.info(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ ""String_Node_Str"");
        continue;
      }
      if (clusterHealService.hasBadDisks(node.getVmName())) {
        logger.warn(""String_Node_Str"" + node.getVmName() + ""String_Node_Str"");
        boolean vmPowerOn=(node.getStatus().ordinal() != NodeStatus.POWERED_OFF.ordinal());
        JobParameters nodeParameters=parametersBuilder.addString(JobConstants.CLUSTER_NAME_JOB_PARAM,clusterName).addString(JobConstants.TARGET_NAME_JOB_PARAM,node.getVmName()).addString(JobConstants.GROUP_NAME_JOB_PARAM,nodeGroup.getName()).addString(JobConstants.SUB_JOB_NODE_NAME,node.getVmName()).addString(JobConstants.IS_VM_POWER_ON,String.valueOf(vmPowerOn)).toJobParameters();
        jobParameterList.add(nodeParameters);
      }
    }
  }
  if (!workerNodesFound) {
    throw ClusterHealServiceException.NOT_SUPPORTED(clusterName,""String_Node_Str"");
  }
  if (jobParameterList.isEmpty()) {
    logger.info(""String_Node_Str"");
    throw ClusterHealServiceException.NOT_NEEDED(clusterName);
  }
  try {
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.MAINTENANCE);
    return jobManager.runSubJobForNodes(JobConstants.FIX_NODE_DISK_FAILURE_JOB_NAME,jobParameterList,clusterName,oldStatus,oldStatus);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + e.getMessage());
    throw e;
  }
}","public Long fixDiskFailures(String clusterName,String groupName) throws Exception {
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ClusterStatus oldStatus=cluster.getStatus();
  if (ClusterStatus.RUNNING != oldStatus) {
    throw ClusterHealServiceException.NOT_SUPPORTED(clusterName,""String_Node_Str"");
  }
  List<NodeGroupEntity> nodeGroups;
  if (groupName != null) {
    NodeGroupEntity nodeGroup=clusterEntityMgr.findByName(clusterName,groupName);
    if (nodeGroup == null) {
      logger.error(""String_Node_Str"" + groupName + ""String_Node_Str"");
      throw BddException.NOT_FOUND(""String_Node_Str"",groupName);
    }
    nodeGroups=new ArrayList<NodeGroupEntity>(1);
    nodeGroups.add(nodeGroup);
  }
 else {
    nodeGroups=clusterEntityMgr.findAllGroups(clusterName);
  }
  boolean workerNodesFound=false;
  JobParametersBuilder parametersBuilder=new JobParametersBuilder();
  List<JobParameters> jobParameterList=new ArrayList<JobParameters>();
  for (  NodeGroupEntity nodeGroup : nodeGroups) {
    List<String> roles=nodeGroup.getRoleNameList();
    if (HadoopRole.hasMgmtRole(roles)) {
      logger.info(""String_Node_Str"" + nodeGroup.getName() + ""String_Node_Str"");
      continue;
    }
    workerNodesFound=true;
    for (    NodeEntity node : clusterEntityMgr.findAllNodes(clusterName,nodeGroup.getName())) {
      if (node.isObsoleteNode()) {
        logger.info(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ ""String_Node_Str"");
        continue;
      }
      if (clusterHealService.hasBadDisks(node.getVmName())) {
        logger.warn(""String_Node_Str"" + node.getVmName() + ""String_Node_Str"");
        boolean vmPowerOn=(node.getStatus().ordinal() != NodeStatus.POWERED_OFF.ordinal());
        JobParameters nodeParameters=parametersBuilder.addString(JobConstants.CLUSTER_NAME_JOB_PARAM,clusterName).addString(JobConstants.TARGET_NAME_JOB_PARAM,node.getVmName()).addString(JobConstants.GROUP_NAME_JOB_PARAM,nodeGroup.getName()).addString(JobConstants.SUB_JOB_NODE_NAME,node.getVmName()).addString(JobConstants.IS_VM_POWER_ON,String.valueOf(vmPowerOn)).toJobParameters();
        jobParameterList.add(nodeParameters);
      }
    }
  }
  if (!workerNodesFound) {
    throw ClusterHealServiceException.NOT_SUPPORTED(clusterName,""String_Node_Str"");
  }
  if (jobParameterList.isEmpty()) {
    logger.info(""String_Node_Str"");
    throw ClusterHealServiceException.NOT_NEEDED(clusterName);
  }
  try {
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.MAINTENANCE);
    clusterEntityMgr.cleanupActionError(clusterName);
    return jobManager.runSubJobForNodes(JobConstants.FIX_NODE_DISK_FAILURE_JOB_NAME,jobParameterList,clusterName,oldStatus,oldStatus);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + e.getMessage());
    throw e;
  }
}"
48696,"/** 
 * update sub job status into main job's execution context for reporting
 * @param subJobExecution sub job execution
 * @param nodeName node name of sub job
 * @param mainJobExecutionContext main job execution context
 */
private void updateExecutionStatus(JobExecution subJobExecution,String nodeName,ExecutionContext mainJobExecutionContext){
  String rollbackStr=(String)subJobExecution.getExecutionContext().get(JobConstants.SUB_JOB_FAIL_FLAG);
  boolean rollback=false;
  if (rollbackStr != null) {
    rollback=Boolean.parseBoolean(rollbackStr);
  }
  if (subJobExecution.getStatus().isUnsuccessful() || rollback) {
    String errorMessage=subJobExecution.getExecutionContext().getString(JobConstants.CURRENT_ERROR_MESSAGE);
    Object failedObj=mainJobExecutionContext.get(JobConstants.SUB_JOB_NODES_FAIL);
    List<NodeOperationStatus> failedNodes=null;
    if (failedObj == null) {
      failedNodes=new ArrayList<NodeOperationStatus>();
    }
 else {
      failedNodes=(ArrayList<NodeOperationStatus>)failedObj;
    }
    NodeOperationStatus failedSubJob=new NodeOperationStatus(nodeName,false,errorMessage);
    failedNodes.add(failedSubJob);
    mainJobExecutionContext.put(JobConstants.SUB_JOB_NODES_FAIL,failedNodes);
  }
 else {
    Object succeededObj=mainJobExecutionContext.get(JobConstants.SUB_JOB_NODES_SUCCEED);
    List<NodeOperationStatus> succeededNodes=null;
    if (succeededObj == null) {
      succeededNodes=new ArrayList<NodeOperationStatus>();
    }
 else {
      succeededNodes=(ArrayList<NodeOperationStatus>)succeededObj;
    }
    NodeOperationStatus succeededSubJob=new NodeOperationStatus(nodeName);
    succeededNodes.add(succeededSubJob);
    mainJobExecutionContext.put(JobConstants.SUB_JOB_NODES_SUCCEED,succeededNodes);
  }
}","/** 
 * update sub job status into main job's execution context for reporting
 * @param subJobExecution sub job execution
 * @param nodeName node name of sub job
 * @param mainJobExecutionContext main job execution context
 */
private void updateExecutionStatus(JobExecution subJobExecution,String nodeName,ExecutionContext mainJobExecutionContext){
  String rollbackStr=(String)subJobExecution.getExecutionContext().get(JobConstants.SUB_JOB_FAIL_FLAG);
  boolean rollback=false;
  if (rollbackStr != null) {
    rollback=Boolean.parseBoolean(rollbackStr);
  }
  if (subJobExecution.getStatus().isUnsuccessful() || rollback) {
    Object errorMessageO=subJobExecution.getExecutionContext().get(JobConstants.CURRENT_ERROR_MESSAGE);
    String errorMessage=null;
    if (errorMessageO != null) {
      errorMessage=(String)errorMessageO;
    }
    Object failedObj=mainJobExecutionContext.get(JobConstants.SUB_JOB_NODES_FAIL);
    List<NodeOperationStatus> failedNodes=null;
    if (failedObj == null) {
      failedNodes=new ArrayList<NodeOperationStatus>();
    }
 else {
      failedNodes=(ArrayList<NodeOperationStatus>)failedObj;
    }
    NodeOperationStatus failedSubJob=new NodeOperationStatus(nodeName,false,errorMessage);
    failedNodes.add(failedSubJob);
    mainJobExecutionContext.put(JobConstants.SUB_JOB_NODES_FAIL,failedNodes);
  }
 else {
    Object succeededObj=mainJobExecutionContext.get(JobConstants.SUB_JOB_NODES_SUCCEED);
    List<NodeOperationStatus> succeededNodes=null;
    if (succeededObj == null) {
      succeededNodes=new ArrayList<NodeOperationStatus>();
    }
 else {
      succeededNodes=(ArrayList<NodeOperationStatus>)succeededObj;
    }
    NodeOperationStatus succeededSubJob=new NodeOperationStatus(nodeName);
    succeededNodes.add(succeededSubJob);
    mainJobExecutionContext.put(JobConstants.SUB_JOB_NODES_SUCCEED,succeededNodes);
  }
}"
48697,"private List<DiskSpec> evenSpliter(DiskSpec separable,List<AbstractDatastore> datastores){
  Collections.sort(datastores);
  int length=datastores.size() + 1;
  int[] free=new int[length];
  int[] partSum=new int[length];
  int iter=0;
  for (int i=0; i < length; i++) {
    if (i == 0) {
      free[0]=0;
      partSum[0]=0;
    }
 else {
      free[i]=datastores.get(i - 1).getFreeSpace();
      partSum[i]=iter + (free[i] - free[i - 1]) * (length - i);
      iter=partSum[i];
    }
  }
  if (partSum[length - 1] < separable.getSize()) {
    logger.error(""String_Node_Str"" + separable.toString());
    return null;
  }
  int index=Arrays.binarySearch(partSum,separable.getSize());
  if (index < 0)   index=-1 * (index + 1);
  index--;
  int remain=(index == 0) ? separable.getSize() : (separable.getSize() - partSum[index]);
  int ave=(remain + length - index - 2) / (length - index - 1);
  int[] allocation=new int[length - 1];
  for (int i=0; i < length - 1; i++) {
    if (i < index) {
      allocation[i]=free[i + 1];
    }
 else     if (remain > 0) {
      if (remain >= ave) {
        allocation[i]=free[index] + ave;
      }
 else {
        allocation[i]=free[index] + remain;
      }
      remain-=ave;
    }
 else {
      allocation[i]=free[index];
    }
  }
  index=0;
  List<DiskSpec> disks=new ArrayList<DiskSpec>();
  for (int i=0; i < length - 1; i++) {
    if (allocation[i] != 0) {
      DiskSpec subDisk=new DiskSpec(separable);
      subDisk.setSize(allocation[i]);
      subDisk.setSeparable(false);
      subDisk.setTargetDs(datastores.get(i).getName());
      subDisk.setName(separable.getName().split(""String_Node_Str"")[0] + index + ""String_Node_Str"");
      disks.add(subDisk);
      datastores.get(i).allocate(allocation[i]);
      index++;
    }
  }
  return disks;
}","private List<DiskSpec> evenSpliter(DiskSpec separable,List<AbstractDatastore> originDatastores){
  int minDiskSize=2;
  int maxNumDatastores=(separable.getSize() + minDiskSize - 1) / minDiskSize;
  Collections.sort(originDatastores);
  List<AbstractDatastore> datastores=new ArrayList<AbstractDatastore>();
  int numDatastores=0;
  for (  AbstractDatastore datastore : originDatastores) {
    if (datastore.getFreeSpace() < minDiskSize)     continue;
    datastores.add(datastore);
    numDatastores++;
    if (numDatastores == maxNumDatastores)     break;
  }
  int length=datastores.size() + 1;
  int[] free=new int[length];
  int[] partSum=new int[length];
  int iter=0;
  for (int i=0; i < length; i++) {
    if (i == 0) {
      free[0]=0;
      partSum[0]=0;
    }
 else {
      free[i]=datastores.get(i - 1).getFreeSpace();
      partSum[i]=iter + (free[i] - free[i - 1]) * (length - i);
      iter=partSum[i];
    }
  }
  if (partSum[length - 1] < separable.getSize()) {
    logger.error(""String_Node_Str"" + separable.toString());
    return null;
  }
  int index=Arrays.binarySearch(partSum,separable.getSize());
  if (index < 0)   index=-1 * (index + 1);
  index--;
  int remain=(index == 0) ? separable.getSize() : (separable.getSize() - partSum[index]);
  int ave=(remain + length - index - 2) / (length - index - 1);
  int[] allocation=new int[length - 1];
  for (int i=0; i < length - 1; i++) {
    if (i < index) {
      allocation[i]=free[i + 1];
    }
 else     if (remain > 0) {
      if (remain >= ave) {
        allocation[i]=free[index] + ave;
      }
 else {
        allocation[i]=free[index] + remain;
      }
      remain-=ave;
    }
 else {
      allocation[i]=free[index];
    }
  }
  index=0;
  List<DiskSpec> disks=new ArrayList<DiskSpec>();
  for (int i=0; i < length - 1; i++) {
    if (allocation[i] != 0) {
      DiskSpec subDisk=new DiskSpec(separable);
      subDisk.setSize(allocation[i]);
      subDisk.setSeparable(false);
      subDisk.setTargetDs(datastores.get(i).getName());
      subDisk.setName(separable.getName().split(""String_Node_Str"")[0] + index + ""String_Node_Str"");
      disks.add(subDisk);
      datastores.get(i).allocate(allocation[i]);
      index++;
    }
  }
  return disks;
}"
48698,"@SuppressWarnings(""String_Node_Str"") public boolean syncDeleteVMs(List<BaseNode> badNodes,StatusUpdater statusUpdator,boolean ignoreUnavailableNodes){
  logger.info(""String_Node_Str"");
  List<Callable<Void>> storeProcedures=new ArrayList<Callable<Void>>();
  List<BaseNode> toBeDeleted=new ArrayList<BaseNode>();
  for (int i=0; i < badNodes.size(); i++) {
    BaseNode node=badNodes.get(i);
    if (node.getVmMobId() == null) {
      continue;
    }
    DeleteVmByIdSP deleteSp=new DeleteVmByIdSP(node.getVmMobId());
    storeProcedures.add(deleteSp);
    toBeDeleted.add(node);
  }
  try {
    if (storeProcedures.isEmpty()) {
      logger.info(""String_Node_Str"");
      return true;
    }
    Callable<Void>[] storeProceduresArray=storeProcedures.toArray(new Callable[0]);
    logger.info(""String_Node_Str"");
    BaseProgressCallback callback=new BaseProgressCallback(statusUpdator,0,50);
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProceduresArray,callback);
    if (result == null) {
      logger.error(""String_Node_Str"");
      return false;
    }
    int total=0;
    boolean failed=false;
    for (int i=0; i < storeProceduresArray.length; i++) {
      BaseNode vNode=toBeDeleted.get(i);
      vNode.setFinished(true);
      if (result[i].finished && result[i].throwable == null) {
        vNode.setSuccess(true);
        vNode.setVmMobId(null);
        ++total;
      }
 else       if (result[i].throwable != null) {
        vNode.setSuccess(false);
        vNode.setErrMessage(getErrorMessage(result[i].throwable));
        if (ignoreUnavailableNodes) {
          DeleteVmByIdSP sp=(DeleteVmByIdSP)storeProceduresArray[i];
          VcVirtualMachine vcVm=sp.getVcVm();
          if (!vcVm.isConnected() || vcVm.getHost().isUnavailbleForManagement()) {
            logger.error(""String_Node_Str"" + vcVm.getName() + ""String_Node_Str""+ vcVm.getConnectionState()+ ""String_Node_Str"");
            logger.error(""String_Node_Str"");
            continue;
          }
        }
        logger.error(""String_Node_Str"" + vNode.getVmName(),result[i].throwable);
        failed=true;
      }
      vNode.setFinished(true);
    }
    logger.info(total + ""String_Node_Str"");
    return !failed;
  }
 catch (  InterruptedException e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}","@SuppressWarnings(""String_Node_Str"") public boolean syncDeleteVMs(List<BaseNode> badNodes,StatusUpdater statusUpdator,boolean ignoreUnavailableNodes){
  logger.info(""String_Node_Str"");
  List<Callable<Void>> storeProcedures=new ArrayList<Callable<Void>>();
  List<BaseNode> toBeDeleted=new ArrayList<BaseNode>();
  for (int i=0; i < badNodes.size(); i++) {
    BaseNode node=badNodes.get(i);
    if (node.getVmMobId() == null) {
      node.setSuccess(true);
      continue;
    }
    DeleteVmByIdSP deleteSp=new DeleteVmByIdSP(node.getVmMobId());
    storeProcedures.add(deleteSp);
    toBeDeleted.add(node);
  }
  try {
    if (storeProcedures.isEmpty()) {
      logger.info(""String_Node_Str"");
      return true;
    }
    Callable<Void>[] storeProceduresArray=storeProcedures.toArray(new Callable[0]);
    logger.info(""String_Node_Str"");
    BaseProgressCallback callback=new BaseProgressCallback(statusUpdator,0,50);
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProceduresArray,callback);
    if (result == null) {
      logger.error(""String_Node_Str"");
      return false;
    }
    int total=0;
    boolean failed=false;
    for (int i=0; i < storeProceduresArray.length; i++) {
      BaseNode vNode=toBeDeleted.get(i);
      vNode.setFinished(true);
      if (result[i].finished && result[i].throwable == null) {
        vNode.setSuccess(true);
        vNode.setVmMobId(null);
        ++total;
      }
 else       if (result[i].throwable != null) {
        vNode.setSuccess(false);
        vNode.setErrMessage(getErrorMessage(result[i].throwable));
        if (ignoreUnavailableNodes) {
          DeleteVmByIdSP sp=(DeleteVmByIdSP)storeProceduresArray[i];
          VcVirtualMachine vcVm=sp.getVcVm();
          if (!vcVm.isConnected() || vcVm.getHost().isUnavailbleForManagement()) {
            logger.error(""String_Node_Str"" + vcVm.getName() + ""String_Node_Str""+ vcVm.getConnectionState()+ ""String_Node_Str"");
            logger.error(""String_Node_Str"");
            continue;
          }
        }
        logger.error(""String_Node_Str"" + vNode.getVmName(),result[i].throwable);
        failed=true;
      }
      vNode.setFinished(true);
    }
    logger.info(total + ""String_Node_Str"");
    return !failed;
  }
 catch (  InterruptedException e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}"
48699,"public boolean removeBadNodes(ClusterCreate cluster,List<BaseNode> existingNodes,List<BaseNode> deletedNodes,Map<String,Set<String>> occupiedIpSets,StatusUpdater statusUpdator){
  logger.info(""String_Node_Str"" + ""String_Node_Str"" + cluster.getName());
  List<BaseNode> badNodes=placementService.getBadNodes(cluster,existingNodes);
  if (badNodes == null) {
    badNodes=new ArrayList<BaseNode>();
  }
  for (  BaseNode node : deletedNodes) {
    if (node.getVmMobId() != null) {
      badNodes.add(node);
    }
  }
  if (badNodes != null && badNodes.size() > 0) {
    boolean deleted=syncDeleteVMs(badNodes,statusUpdator,false);
    afterBadVcVmDelete(existingNodes,deletedNodes,badNodes,occupiedIpSets);
    return deleted;
  }
  return true;
}","public boolean removeBadNodes(ClusterCreate cluster,List<BaseNode> existingNodes,List<BaseNode> deletedNodes,Map<String,Set<String>> occupiedIpSets,StatusUpdater statusUpdator){
  logger.info(""String_Node_Str"" + ""String_Node_Str"" + cluster.getName());
  List<BaseNode> badNodes=placementService.getBadNodes(cluster,existingNodes);
  if (badNodes == null) {
    badNodes=new ArrayList<BaseNode>();
  }
  for (  BaseNode node : deletedNodes) {
    if (node.getVmMobId() != null) {
      badNodes.add(node);
    }
 else {
      node.setSuccess(true);
    }
  }
  if (badNodes != null && badNodes.size() > 0) {
    boolean deleted=syncDeleteVMs(badNodes,statusUpdator,false);
    afterBadVcVmDelete(existingNodes,deletedNodes,badNodes,occupiedIpSets);
    return deleted;
  }
  return true;
}"
48700,"public static TaskException HOST_TIME_OUT_OF_SYNC(List<String> outOfSyncHosts){
  return new TaskException(null,""String_Node_Str"",outOfSyncHosts.toString());
}","public static TaskException HOST_TIME_OUT_OF_SYNC(List<String> outOfSyncHosts,String managementServerHost){
  return new TaskException(null,""String_Node_Str"",outOfSyncHosts.toString(),managementServerHost);
}"
48701,"/** 
 * Create default cluster spec.
 * @param type cluster type
 * @return default cluster spec
 * @throws FileNotFoundException
 */
public static ClusterCreate createDefaultSpec(ClusterType type,final String vendor) throws FileNotFoundException {
  if (vendor.trim().equalsIgnoreCase(Constants.MAPR_VENDOR)) {
switch (type) {
case HDFS_MAPRED:
      return loadFromFile(locateSpecFile(HDFS_MAPRED_MAPR_TEMPLATE_SPEC));
default :
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
 else if (vendor.trim().equalsIgnoreCase(Constants.GPHD_VENDOR)) {
switch (type) {
case HDFS:
  return loadFromFile(locateSpecFile(HDFS_GPHD_TEMPLATE_SPEC));
case HDFS_MAPRED:
return loadFromFile(locateSpecFile(HDFS_MAPRED_GPHD_TEMPLATE_SPEC));
case HDFS_HBASE:
return loadFromFile(locateSpecFile(HDFS_HBASE_GPHD_TEMPLATE_SPEC));
default :
throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
 else {
switch (type) {
case HDFS:
return loadFromFile(locateSpecFile(HDFS_TEMPLATE_SPEC));
case HDFS_MAPRED:
return loadFromFile(locateSpecFile(HDFS_MAPRED_TEMPLATE_SPEC));
case HDFS_HBASE:
return loadFromFile(locateSpecFile(HDFS_HBASE_TEMPLATE_SPEC));
default :
throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
}","/** 
 * Create default cluster spec.
 * @param type cluster type
 * @return default cluster spec
 * @throws FileNotFoundException
 */
public static ClusterCreate createDefaultSpec(ClusterType type,final String vendor) throws FileNotFoundException {
  if (vendor.trim().equalsIgnoreCase(Constants.MAPR_VENDOR)) {
switch (type) {
case HDFS_MAPRED:
      return loadFromFile(locateSpecFile(HDFS_MAPRED_MAPR_TEMPLATE_SPEC));
case HDFS_HBASE:
    return loadFromFile(locateSpecFile(HDFS_HBASE_MAPR_TEMPLATE_SPEC));
default :
  throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
 else if (vendor.trim().equalsIgnoreCase(Constants.GPHD_VENDOR)) {
switch (type) {
case HDFS:
return loadFromFile(locateSpecFile(HDFS_GPHD_TEMPLATE_SPEC));
case HDFS_MAPRED:
return loadFromFile(locateSpecFile(HDFS_MAPRED_GPHD_TEMPLATE_SPEC));
case HDFS_HBASE:
return loadFromFile(locateSpecFile(HDFS_HBASE_GPHD_TEMPLATE_SPEC));
default :
throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
 else {
switch (type) {
case HDFS:
return loadFromFile(locateSpecFile(HDFS_TEMPLATE_SPEC));
case HDFS_MAPRED:
return loadFromFile(locateSpecFile(HDFS_MAPRED_TEMPLATE_SPEC));
case HDFS_HBASE:
return loadFromFile(locateSpecFile(HDFS_HBASE_TEMPLATE_SPEC));
default :
throw BddException.INVALID_PARAMETER(""String_Node_Str"",type);
}
}
}"
48702,"private void processEvent(VcEventType type,Event e,String moId,boolean external) throws Exception {
  try {
switch (type) {
case VmRemoved:
{
        logger.debug(""String_Node_Str"" + moId);
        NodeEntity node=clusterEntityMgr.getNodeByMobId(moId);
        if (node != null) {
          String clusterName=CommonUtil.getClusterName(node.getVmName());
          lockMgr.refreshNodeByMobId(clusterName,moId,null,true);
        }
        break;
      }
case VmDisconnected:
{
      VcVirtualMachine vm=VcCache.getIgnoreMissing(moId);
      if (vm == null) {
        NodeEntity node=clusterEntityMgr.getNodeByMobId(moId);
        if (node != null) {
          String clusterName=CommonUtil.getClusterName(node.getVmName());
          logger.debug(""String_Node_Str"" + moId + ""String_Node_Str"");
          lockMgr.removeVmReference(clusterName,moId);
        }
        break;
      }
      if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
        vm.updateRuntime();
        if ((!vm.isConnected()) || vm.getHost().isUnavailbleForManagement()) {
          String clusterName=CommonUtil.getClusterName(vm.getName());
          lockMgr.setNodeConnectionState(clusterName,vm.getName());
          logConnectionChangeEvent(vm.getName());
        }
      }
      break;
    }
case VmPoweredOn:
{
    refreshNodeWithAction(moId,true,Constants.NODE_ACTION_WAITING_IP,""String_Node_Str"");
    if (external) {
      NodePowerOnRequest request=new NodePowerOnRequest(lockMgr,moId);
      CmsWorker.addRequest(WorkQueue.VC_TASK_NO_DELAY,request);
    }
    break;
  }
case VmCloned:
{
  refreshNodeWithAction(moId,true,Constants.NODE_ACTION_RECONFIGURE,""String_Node_Str"");
  break;
}
case VmSuspended:
{
refreshNodeWithAction(moId,true,null,""String_Node_Str"");
break;
}
case VmPoweredOff:
{
refreshNodeWithAction(moId,true,null,""String_Node_Str"");
break;
}
case VmConnected:
{
try {
refreshNodeWithAction(moId,false,null,type.name());
}
 catch (AuroraException ex) {
logger.error(""String_Node_Str"" + ex.getMessage() + ""String_Node_Str"");
}
break;
}
case VmMigrated:
{
refreshNodeWithAction(moId,false,null,type.name());
break;
}
case VhmError:
case VhmWarning:
{
EventEx event=(EventEx)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
break;
}
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + event.getEventTypeId() + ""String_Node_Str""+ vm.getName()+ ""String_Node_Str""+ event.getMessage());
vm.updateRuntime();
String clusterName=CommonUtil.getClusterName(vm.getName());
lockMgr.refreshNodeByVmName(clusterName,moId,vm.getName(),event.getMessage(),true);
}
break;
}
case VhmInfo:
{
EventEx event=(EventEx)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
break;
}
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + event.getEventTypeId() + ""String_Node_Str""+ vm.getName()+ ""String_Node_Str""+ event.getMessage());
vm.updateRuntime();
String clusterName=CommonUtil.getClusterName(vm.getName());
lockMgr.refreshNodeByVmName(clusterName,moId,vm.getName(),""String_Node_Str"",true);
}
break;
}
default :
{
if (external) {
VcVirtualMachine vm=VcCache.getIgnoreMissing(moId);
if (vm == null) {
break;
}
String clusterName=CommonUtil.getClusterName(vm.getName());
lockMgr.refreshNodeByVmName(clusterName,moId,vm.getName(),true);
}
break;
}
}
}
 catch (ManagedObjectNotFound exp) {
VcUtil.processNotFoundException(exp,moId,logger);
}
}","private void processEvent(VcEventType type,Event e,String moId,boolean external) throws Exception {
  try {
switch (type) {
case VmRemoved:
{
        logger.debug(""String_Node_Str"" + moId);
        NodeEntity node=clusterEntityMgr.getNodeByMobId(moId);
        if (node != null) {
          String clusterName=CommonUtil.getClusterName(node.getVmName());
          lockMgr.refreshNodeByMobId(clusterName,moId,null,true);
        }
        break;
      }
case VmDisconnected:
{
      VcVirtualMachine vm=VcCache.getIgnoreMissing(moId);
      if (vm == null) {
        NodeEntity node=clusterEntityMgr.getNodeByMobId(moId);
        if (node != null) {
          String clusterName=CommonUtil.getClusterName(node.getVmName());
          logger.debug(""String_Node_Str"" + moId + ""String_Node_Str"");
          lockMgr.removeVmReference(clusterName,moId);
        }
        break;
      }
      if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
        vm.updateRuntime();
        if ((!vm.isConnected()) || vm.getHost().isUnavailbleForManagement()) {
          String clusterName=CommonUtil.getClusterName(vm.getName());
          lockMgr.setNodeConnectionState(clusterName,vm.getName());
          logConnectionChangeEvent(vm.getName());
        }
      }
      break;
    }
case VmPoweredOn:
{
    refreshNodeWithAction(moId,true,Constants.NODE_ACTION_WAITING_IP,""String_Node_Str"");
    if (external) {
      NodePowerOnRequest request=new NodePowerOnRequest(lockMgr,moId);
      CmsWorker.addRequest(WorkQueue.VC_TASK_NO_DELAY,request);
    }
    break;
  }
case VmCloned:
{
  refreshNodeWithAction(moId,true,Constants.NODE_ACTION_RECONFIGURE,""String_Node_Str"");
  break;
}
case VmSuspended:
{
refreshNodeWithAction(moId,true,null,""String_Node_Str"");
break;
}
case VmPoweredOff:
{
refreshNodeWithAction(moId,true,null,""String_Node_Str"");
break;
}
case VmConnected:
{
try {
refreshNodeWithAction(moId,false,null,type.name());
}
 catch (AuroraException ex) {
logger.warn(""String_Node_Str"" + ex.getMessage() + ""String_Node_Str"");
}
break;
}
case VmMigrated:
{
refreshNodeWithAction(moId,false,null,type.name());
break;
}
case VhmError:
case VhmWarning:
{
EventEx event=(EventEx)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
break;
}
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + event.getEventTypeId() + ""String_Node_Str""+ vm.getName()+ ""String_Node_Str""+ event.getMessage());
vm.updateRuntime();
String clusterName=CommonUtil.getClusterName(vm.getName());
lockMgr.refreshNodeByVmName(clusterName,moId,vm.getName(),event.getMessage(),true);
}
break;
}
case VhmInfo:
{
EventEx event=(EventEx)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
break;
}
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + event.getEventTypeId() + ""String_Node_Str""+ vm.getName()+ ""String_Node_Str""+ event.getMessage());
vm.updateRuntime();
String clusterName=CommonUtil.getClusterName(vm.getName());
lockMgr.refreshNodeByVmName(clusterName,moId,vm.getName(),""String_Node_Str"",true);
}
break;
}
default :
{
if (external) {
VcVirtualMachine vm=VcCache.getIgnoreMissing(moId);
if (vm == null) {
break;
}
String clusterName=CommonUtil.getClusterName(vm.getName());
lockMgr.refreshNodeByVmName(clusterName,moId,vm.getName(),true);
}
break;
}
}
}
 catch (ManagedObjectNotFound exp) {
VcUtil.processNotFoundException(exp,moId,logger);
}
}"
48703,"@Override public synchronized void addResourcePool(String rpName,String vcClusterName,String vcResourcePool){
  boolean existed=rpDao.isRPAdded(vcClusterName,vcResourcePool);
  if (existed) {
    logger.debug(""String_Node_Str"" + vcResourcePool + ""String_Node_Str""+ vcClusterName+ ""String_Node_Str"");
    throw VcProviderException.VC_RESOURCE_POOL_ALREADY_ADDED(vcResourcePool);
  }
  if (!resService.isRPExistInVc(vcClusterName,vcResourcePool)) {
    throw VcProviderException.RESOURCE_POOL_NOT_FOUND(vcResourcePool);
  }
  rpDao.addResourcePoolEntity(rpName,vcClusterName,vcResourcePool);
}","@Override public synchronized void addResourcePool(String rpName,String vcClusterName,String vcResourcePool){
  boolean existed=rpDao.isRPAdded(vcClusterName,vcResourcePool);
  if (existed) {
    logger.debug(""String_Node_Str"" + vcResourcePool + ""String_Node_Str""+ vcClusterName+ ""String_Node_Str"");
    throw VcProviderException.VC_RESOURCE_POOL_ALREADY_ADDED(vcResourcePool);
  }
  resService.refreshResourcePool();
  if (!resService.isRPExistInVc(vcClusterName,vcResourcePool)) {
    throw VcProviderException.RESOURCE_POOL_NOT_FOUND(vcResourcePool);
  }
  rpDao.addResourcePoolEntity(rpName,vcClusterName,vcResourcePool);
}"
48704,"@Test(groups={""String_Node_Str""}) public void testAddResourcePool(){
  new Expectations(){
{
      rpDao.isRPAdded(anyString,anyString);
      result=false;
      resService.isRPExistInVc(anyString,anyString);
      result=true;
    }
  }
;
  rpSvc.setRpDao(rpDao);
  rpSvc.setResService(resService);
  rpSvc.addResourcePool(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  new Verifications(){
{
      rpDao.addResourcePoolEntity(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    }
  }
;
}","@Test(groups={""String_Node_Str""}) public void testAddResourcePool(){
  new Expectations(){
{
      rpDao.isRPAdded(anyString,anyString);
      result=false;
      resService.refreshResourcePool();
      resService.isRPExistInVc(anyString,anyString);
      result=true;
    }
  }
;
  rpSvc.setRpDao(rpDao);
  rpSvc.setResService(resService);
  rpSvc.addResourcePool(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  new Verifications(){
{
      rpDao.addResourcePoolEntity(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    }
  }
;
}"
48705,"@Test(groups={""String_Node_Str""},expectedExceptions=VcProviderException.class) public void testAddNonExistResourcePool(){
  new Expectations(){
{
      rpDao.isRPAdded(anyString,anyString);
      result=false;
      resService.isRPExistInVc(anyString,anyString);
      result=false;
    }
  }
;
  rpSvc.setRpDao(rpDao);
  rpSvc.setResService(resService);
  rpSvc.addResourcePool(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","@Test(groups={""String_Node_Str""},expectedExceptions=VcProviderException.class) public void testAddNonExistResourcePool(){
  new Expectations(){
{
      rpDao.isRPAdded(anyString,anyString);
      result=false;
      resService.refreshResourcePool();
      resService.isRPExistInVc(anyString,anyString);
      result=false;
    }
  }
;
  rpSvc.setRpDao(rpDao);
  rpSvc.setResService(resService);
  rpSvc.addResourcePool(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}"
48706,"@Test public void testExclusiveCompetitiveInTwoThread() throws Exception {
  setThreadStarted(false);
  LockTestThread t=new LockTestThread(exclusiveLockedMgr);
  t.start();
  while (!isThreadStarted()) {
    Thread.sleep(10);
  }
  Thread.sleep(40);
  long start=System.currentTimeMillis();
  exclusiveLockedMgr.removeVmReference(LOCKED_CLUSTER_NAME,""String_Node_Str"");
  long end=System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  Assert.assertTrue((end - start) >= 150);
  t.join();
}","@Test public void testExclusiveCompetitiveInTwoThread() throws Exception {
  setThreadStarted(false);
  LockTestThread t=new LockTestThread(exclusiveLockedMgr);
  t.start();
  while (!isThreadStarted()) {
    Thread.sleep(10);
  }
  Thread.sleep(40);
  long start=System.currentTimeMillis();
  exclusiveLockedMgr.removeVmReference(LOCKED_CLUSTER_NAME,""String_Node_Str"");
  long end=System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  Assert.assertTrue((end - start) >= 100,""String_Node_Str"" + (end - start));
  t.join();
}"
48707,"@SuppressWarnings(""String_Node_Str"") public boolean syncDeleteVMs(List<BaseNode> badNodes,StatusUpdater statusUpdator,boolean ignoreUnavailableNodes){
  logger.info(""String_Node_Str"");
  List<Callable<Void>> storeProcedures=new ArrayList<Callable<Void>>();
  for (int i=0; i < badNodes.size(); i++) {
    BaseNode node=badNodes.get(i);
    if (node.getVmMobId() == null) {
      continue;
    }
    DeleteVmByIdSP deleteSp=new DeleteVmByIdSP(node.getVmMobId());
    storeProcedures.add(deleteSp);
  }
  try {
    if (storeProcedures.isEmpty()) {
      logger.info(""String_Node_Str"");
      return true;
    }
    Callable<Void>[] storeProceduresArray=storeProcedures.toArray(new Callable[0]);
    logger.info(""String_Node_Str"");
    BaseProgressCallback callback=new BaseProgressCallback(statusUpdator,0,50);
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProceduresArray,callback);
    if (result == null) {
      logger.error(""String_Node_Str"");
      return false;
    }
    int total=0;
    boolean failed=false;
    for (int i=0; i < storeProceduresArray.length; i++) {
      BaseNode vNode=badNodes.get(i);
      vNode.setFinished(true);
      if (result[i].finished && result[i].throwable == null) {
        vNode.setSuccess(true);
        vNode.setVmMobId(null);
        ++total;
      }
 else       if (result[i].throwable != null) {
        vNode.setSuccess(false);
        vNode.setErrMessage(getErrorMessage(result[i].throwable));
        if (ignoreUnavailableNodes) {
          DeleteVmByIdSP sp=(DeleteVmByIdSP)storeProceduresArray[i];
          VcVirtualMachine vcVm=sp.getVcVm();
          if (!vcVm.isConnected() || vcVm.getHost().isUnavailbleForManagement()) {
            logger.error(""String_Node_Str"" + vcVm.getName() + ""String_Node_Str""+ vcVm.getConnectionState()+ ""String_Node_Str"");
            logger.error(""String_Node_Str"");
            continue;
          }
        }
        logger.error(""String_Node_Str"" + vNode.getVmName(),result[i].throwable);
        failed=true;
      }
      vNode.setFinished(true);
    }
    logger.info(total + ""String_Node_Str"");
    return !failed;
  }
 catch (  InterruptedException e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}","@SuppressWarnings(""String_Node_Str"") public boolean syncDeleteVMs(List<BaseNode> badNodes,StatusUpdater statusUpdator,boolean ignoreUnavailableNodes){
  logger.info(""String_Node_Str"");
  List<Callable<Void>> storeProcedures=new ArrayList<Callable<Void>>();
  List<BaseNode> toBeDeleted=new ArrayList<BaseNode>();
  for (int i=0; i < badNodes.size(); i++) {
    BaseNode node=badNodes.get(i);
    if (node.getVmMobId() == null) {
      continue;
    }
    DeleteVmByIdSP deleteSp=new DeleteVmByIdSP(node.getVmMobId());
    storeProcedures.add(deleteSp);
    toBeDeleted.add(node);
  }
  try {
    if (storeProcedures.isEmpty()) {
      logger.info(""String_Node_Str"");
      return true;
    }
    Callable<Void>[] storeProceduresArray=storeProcedures.toArray(new Callable[0]);
    logger.info(""String_Node_Str"");
    BaseProgressCallback callback=new BaseProgressCallback(statusUpdator,0,50);
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProceduresArray,callback);
    if (result == null) {
      logger.error(""String_Node_Str"");
      return false;
    }
    int total=0;
    boolean failed=false;
    for (int i=0; i < storeProceduresArray.length; i++) {
      BaseNode vNode=toBeDeleted.get(i);
      vNode.setFinished(true);
      if (result[i].finished && result[i].throwable == null) {
        vNode.setSuccess(true);
        vNode.setVmMobId(null);
        ++total;
      }
 else       if (result[i].throwable != null) {
        vNode.setSuccess(false);
        vNode.setErrMessage(getErrorMessage(result[i].throwable));
        if (ignoreUnavailableNodes) {
          DeleteVmByIdSP sp=(DeleteVmByIdSP)storeProceduresArray[i];
          VcVirtualMachine vcVm=sp.getVcVm();
          if (!vcVm.isConnected() || vcVm.getHost().isUnavailbleForManagement()) {
            logger.error(""String_Node_Str"" + vcVm.getName() + ""String_Node_Str""+ vcVm.getConnectionState()+ ""String_Node_Str"");
            logger.error(""String_Node_Str"");
            continue;
          }
        }
        logger.error(""String_Node_Str"" + vNode.getVmName(),result[i].throwable);
        failed=true;
      }
      vNode.setFinished(true);
    }
    logger.info(total + ""String_Node_Str"");
    return !failed;
  }
 catch (  InterruptedException e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}"
48708,"@Override public boolean startCluster(final String name,List<NodeOperationStatus> failedNodes,StatusUpdater statusUpdator){
  logger.info(""String_Node_Str"");
  List<NodeEntity> nodes=clusterEntityMgr.findAllNodes(name);
  logger.info(""String_Node_Str"");
  List<Callable<Void>> storeProcedures=new ArrayList<Callable<Void>>();
  Map<String,NodeOperationStatus> nodesStatus=new HashMap<String,NodeOperationStatus>();
  for (int i=0; i < nodes.size(); i++) {
    NodeEntity node=nodes.get(i);
    if (node.getMoId() == null) {
      logger.info(""String_Node_Str"" + node.getVmName());
      continue;
    }
    VcVirtualMachine vcVm=VcCache.getIgnoreMissing(node.getMoId());
    if (vcVm == null) {
      logger.info(""String_Node_Str"" + node.getVmName());
      continue;
    }
    QueryIpAddress query=new QueryIpAddress(node.fetchAllPortGroups(),Constants.VM_POWER_ON_WAITING_SEC);
    VcHost host=null;
    if (node.getHostName() != null) {
      host=VcResourceUtils.findHost(node.getHostName());
    }
    StartVmSP startSp=new StartVmSP(vcVm,query,host);
    storeProcedures.add(startSp);
    nodesStatus.put(node.getVmName(),new NodeOperationStatus(node.getVmName()));
  }
  try {
    if (storeProcedures.isEmpty()) {
      logger.info(""String_Node_Str"");
      return true;
    }
    Callable<Void>[] storeProceduresArray=storeProcedures.toArray(new Callable[0]);
    logger.info(""String_Node_Str"");
    UpdateVmProgressCallback callback=new UpdateVmProgressCallback(lockClusterEntityMgr,statusUpdator,name);
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProceduresArray,callback);
    if (result == null) {
      for (      NodeOperationStatus status : nodesStatus.values()) {
        status.setSucceed(false);
      }
      logger.error(""String_Node_Str"");
      failedNodes.addAll(nodesStatus.values());
      return false;
    }
    boolean success=true;
    int total=0;
    for (int i=0; i < storeProceduresArray.length; i++) {
      StartVmSP sp=(StartVmSP)storeProceduresArray[i];
      NodeOperationStatus status=nodesStatus.get(sp.getVmName());
      if (result[i].finished && result[i].throwable == null) {
        ++total;
        nodesStatus.remove(status.getNodeName());
      }
 else       if (result[i].throwable != null) {
        status.setSucceed(false);
        status.setErrorMessage(getErrorMessage(result[i].throwable));
        VcVirtualMachine vm=sp.getVcVm();
        if (vm != null && VcVmUtil.checkIpAddresses(vm)) {
          ++total;
          nodesStatus.remove(status.getNodeName());
        }
 else {
          if (!vm.isConnected() || vm.getHost().isUnavailbleForManagement()) {
            logger.error(""String_Node_Str"" + vm.getName() + ""String_Node_Str""+ vm.getConnectionState()+ ""String_Node_Str""+ ""String_Node_Str"");
            continue;
          }
          logger.error(""String_Node_Str"" + nodes.get(i).getVmName(),result[i].throwable);
          success=false;
        }
      }
    }
    logger.info(total + ""String_Node_Str"");
    failedNodes.addAll(nodesStatus.values());
    return success;
  }
 catch (  InterruptedException e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}","@Override public boolean startCluster(final String name,List<NodeOperationStatus> failedNodes,StatusUpdater statusUpdator){
  logger.info(""String_Node_Str"");
  List<NodeEntity> nodes=clusterEntityMgr.findAllNodes(name);
  logger.info(""String_Node_Str"");
  List<Callable<Void>> storeProcedures=new ArrayList<Callable<Void>>();
  Map<String,NodeOperationStatus> nodesStatus=new HashMap<String,NodeOperationStatus>();
  for (int i=0; i < nodes.size(); i++) {
    NodeEntity node=nodes.get(i);
    if (node.getMoId() == null) {
      logger.info(""String_Node_Str"" + node.getVmName());
      continue;
    }
    VcVirtualMachine vcVm=VcCache.getIgnoreMissing(node.getMoId());
    if (vcVm == null) {
      logger.info(""String_Node_Str"" + node.getVmName());
      continue;
    }
    QueryIpAddress query=new QueryIpAddress(node.fetchAllPortGroups(),Constants.VM_POWER_ON_WAITING_SEC);
    VcHost host=null;
    if (node.getHostName() != null) {
      host=VcResourceUtils.findHost(node.getHostName());
    }
    StartVmSP startSp=new StartVmSP(vcVm,query,host);
    storeProcedures.add(startSp);
    nodesStatus.put(node.getVmName(),new NodeOperationStatus(node.getVmName()));
  }
  try {
    if (storeProcedures.isEmpty()) {
      logger.info(""String_Node_Str"");
      return true;
    }
    Callable<Void>[] storeProceduresArray=storeProcedures.toArray(new Callable[0]);
    logger.info(""String_Node_Str"");
    UpdateVmProgressCallback callback=new UpdateVmProgressCallback(lockClusterEntityMgr,statusUpdator,name);
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProceduresArray,callback);
    if (result == null) {
      for (      NodeOperationStatus status : nodesStatus.values()) {
        status.setSucceed(false);
      }
      logger.error(""String_Node_Str"");
      failedNodes.addAll(nodesStatus.values());
      return false;
    }
    boolean success=true;
    int total=0;
    for (int i=0; i < storeProceduresArray.length; i++) {
      StartVmSP sp=(StartVmSP)storeProceduresArray[i];
      NodeOperationStatus status=nodesStatus.get(sp.getVmName());
      VcVirtualMachine vm=sp.getVcVm();
      if (result[i].finished && result[i].throwable == null) {
        ++total;
        nodesStatus.remove(status.getNodeName());
      }
 else       if (result[i].throwable != null) {
        status.setSucceed(false);
        status.setErrorMessage(getErrorMessage(result[i].throwable));
        if (vm != null && vm.isPoweredOn() && VcVmUtil.checkIpAddresses(vm)) {
          ++total;
          nodesStatus.remove(status.getNodeName());
        }
 else {
          if (!vm.isConnected() || vm.getHost().isUnavailbleForManagement()) {
            logger.error(""String_Node_Str"" + vm.getName() + ""String_Node_Str""+ vm.getConnectionState()+ ""String_Node_Str""+ ""String_Node_Str"");
            continue;
          }
          logger.error(""String_Node_Str"" + nodes.get(i).getVmName(),result[i].throwable);
          success=false;
        }
      }
    }
    logger.info(total + ""String_Node_Str"");
    failedNodes.addAll(nodesStatus.values());
    return success;
  }
 catch (  InterruptedException e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}"
48709,"public void removeDeletedNode(final String clusterName,final Set<String> deletedNodeNames){
  if (deletedNodeNames.isEmpty()) {
    return;
  }
  List<NodeEntity> nodes=getClusterEntityMgr().findAllNodes(clusterName);
  for (  NodeEntity node : nodes) {
    if (deletedNodeNames.contains(node.getVmName())) {
      logger.info(""String_Node_Str"" + node.getVmName() + ""String_Node_Str"");
      getClusterEntityMgr().delete(node);
    }
  }
}","@Transactional private void removeDeletedNode(final String clusterName,final List<BaseNode> deletedNodes){
  if (deletedNodes == null || deletedNodes.isEmpty()) {
    return;
  }
  for (  BaseNode deletedNode : deletedNodes) {
    NodeEntity node=getClusterEntityMgr().getNodeByVmName(deletedNode.getVmName());
    if (node != null) {
      if (deletedNode.isSuccess()) {
        getClusterEntityMgr().delete(node);
      }
 else {
        node.setActionFailed(true);
        node.setErrMessage(deletedNode.getErrMessage());
      }
    }
  }
}"
48710,"@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  List<BaseNode> addedNodes=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_ADDED_NODES_JOB_PARAM,new TypeToken<List<BaseNode>>(){
  }
.getType());
  List<BaseNode> deletedNodes=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_DELETED_NODES_JOB_PARAM,new TypeToken<List<BaseNode>>(){
  }
.getType());
  Set<String> deletedNodeNames=new HashSet<String>();
  if (deletedNodes != null) {
    for (    BaseNode node : deletedNodes) {
      deletedNodeNames.add(node.getVmName());
    }
  }
  lockClusterEntityMgr.getLock(clusterName).lock();
  putIntoJobExecutionContext(chunkContext,JobConstants.CLUSTER_EXCLUSIVE_WRITE_LOCKED,true);
  addNodeToMetaData(clusterName,addedNodes,deletedNodeNames);
  removeDeletedNode(clusterName,deletedNodeNames);
  verifyCreatedNodes(chunkContext,clusterName);
  if (chunkContext.getStepContext().getJobName().equals(JobConstants.RESUME_CLUSTER_JOB_NAME)) {
    clusterEntityMgr.syncUp(clusterName,false);
  }
  return RepeatStatus.FINISHED;
}","@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  List<BaseNode> addedNodes=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_ADDED_NODES_JOB_PARAM,new TypeToken<List<BaseNode>>(){
  }
.getType());
  List<BaseNode> deletedNodes=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_DELETED_NODES_JOB_PARAM,new TypeToken<List<BaseNode>>(){
  }
.getType());
  Set<String> deletedNodeNames=new HashSet<String>();
  if (deletedNodes != null) {
    for (    BaseNode node : deletedNodes) {
      deletedNodeNames.add(node.getVmName());
    }
  }
  lockClusterEntityMgr.getLock(clusterName).lock();
  putIntoJobExecutionContext(chunkContext,JobConstants.CLUSTER_EXCLUSIVE_WRITE_LOCKED,true);
  addNodeToMetaData(clusterName,addedNodes,deletedNodeNames);
  removeDeletedNode(clusterName,deletedNodes);
  verifyCreatedNodes(chunkContext,clusterName);
  if (chunkContext.getStepContext().getJobName().equals(JobConstants.RESUME_CLUSTER_JOB_NAME)) {
    clusterEntityMgr.syncUp(clusterName,false);
  }
  return RepeatStatus.FINISHED;
}"
48711,"public static boolean verifyNodesStatus(List<NodeEntity> nodes,NodeStatus expectedStatus,boolean ignoreMissing){
  boolean success=true;
  for (  NodeEntity node : nodes) {
    try {
      verifyNodeStatus(node,expectedStatus,ignoreMissing);
    }
 catch (    Exception e) {
      node.setActionFailed(true);
      logger.debug(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ e.getMessage());
      if (node.getErrMessage() == null) {
        node.setErrMessage(e.getMessage());
        logger.debug(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ e.getMessage());
      }
      success=false;
    }
  }
  return success;
}","public static boolean verifyNodesStatus(List<NodeEntity> nodes,NodeStatus expectedStatus,boolean ignoreMissing){
  boolean success=true;
  for (  NodeEntity node : nodes) {
    try {
      verifyNodeStatus(node,expectedStatus,ignoreMissing);
    }
 catch (    Exception e) {
      node.setActionFailed(true);
      logger.debug(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ e.getMessage());
      if (node.getErrMessage() == null || node.getErrMessage().isEmpty()) {
        node.setErrMessage(e.getMessage());
        logger.debug(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ e.getMessage());
      }
      success=false;
    }
  }
  return success;
}"
48712,"public static void verifyNodeStatus(NodeEntity node,NodeStatus expectedStatus,boolean ignoreMissing){
  if (node.getStatus() != expectedStatus) {
    if (ignoreMissing && (node.getStatus() == NodeStatus.NOT_EXIST || node.isDisconnected())) {
      return;
    }
    if (node.isDisconnected()) {
      logger.info(""String_Node_Str"" + node.getVmName() + ""String_Node_Str"");
      throw ClusteringServiceException.VM_UNAVAILABLE(node.getVmName());
    }
    VcVirtualMachine vm=VcCache.getIgnoreMissing(node.getMoId());
    if (expectedStatus == NodeStatus.VM_READY) {
      if (vm == null || (!vm.isPoweredOn()) || !VcVmUtil.checkIpAddresses(vm)) {
        throw ClusteringServiceException.VM_STATUS_ERROR(node.getStatus().toString(),expectedStatus.toString());
      }
      String haFlag=node.getNodeGroup().getHaFlag();
      if (haFlag != null && Constants.HA_FLAG_FT.equals(haFlag.toLowerCase())) {
        if (!VcVmUtil.verifyFTState(vm)) {
          logger.info(""String_Node_Str"" + vm.getName() + ""String_Node_Str""+ ""String_Node_Str""+ vm.getFTState()+ ""String_Node_Str"");
          throw ClusteringServiceException.ENABLE_FT_FAILED(null,node.getVmName());
        }
      }
    }
 else {
      if (vm == null || (!vm.isPoweredOff())) {
        throw ClusteringServiceException.VM_STATUS_ERROR(node.getStatus().toString(),expectedStatus.toString());
      }
    }
  }
}","public static void verifyNodeStatus(NodeEntity node,NodeStatus expectedStatus,boolean ignoreMissing){
  if (node.getStatus() != expectedStatus) {
    if (ignoreMissing && (node.getStatus() == NodeStatus.NOT_EXIST || node.isDisconnected())) {
      return;
    }
    if (node.isDisconnected()) {
      logger.info(""String_Node_Str"" + node.getVmName() + ""String_Node_Str"");
      throw ClusteringServiceException.VM_UNAVAILABLE(node.getVmName());
    }
    VcVirtualMachine vm=VcCache.getIgnoreMissing(node.getMoId());
    if (expectedStatus == NodeStatus.VM_READY) {
      if (vm == null || (!vm.isPoweredOn())) {
        throw ClusteringServiceException.VM_STATUS_ERROR(node.getStatus().toString(),expectedStatus.toString());
      }
      if (!VcVmUtil.checkIpAddresses(vm)) {
        throw ClusteringServiceException.CANNOT_GET_IP_ADDRESS(node.getVmName());
      }
      String haFlag=node.getNodeGroup().getHaFlag();
      if (haFlag != null && Constants.HA_FLAG_FT.equals(haFlag.toLowerCase())) {
        if (!VcVmUtil.verifyFTState(vm)) {
          logger.info(""String_Node_Str"" + vm.getName() + ""String_Node_Str""+ ""String_Node_Str""+ vm.getFTState()+ ""String_Node_Str"");
          throw ClusteringServiceException.ENABLE_FT_FAILED(null,node.getVmName());
        }
      }
    }
 else {
      if (vm == null || (!vm.isPoweredOff())) {
        throw ClusteringServiceException.VM_STATUS_ERROR(node.getStatus().toString(),expectedStatus.toString());
      }
    }
  }
}"
48713,"@Override protected boolean execute(){
  logger.info(""String_Node_Str"" + vmId + ""String_Node_Str"");
  NodeEntity nodeEntity=lockClusterEntityMgr.getClusterEntityMgr().getNodeByMobId(vmId);
  if (nodeEntity == null) {
    logger.info(""String_Node_Str"" + nodeEntity.getVmName() + ""String_Node_Str"");
  }
  QueryIpAddress query=new QueryIpAddress(nodeEntity.fetchAllPortGroups(),Constants.VM_POWER_ON_WAITING_SEC);
  query.setVmId(vmId);
  try {
    query.call();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + vmId,e);
  }
  String clusterName=CommonUtil.getClusterName(nodeEntity.getVmName());
  lockClusterEntityMgr.refreshNodeByMobId(clusterName,vmId,false);
  return true;
}","@Override protected boolean execute(){
  logger.info(""String_Node_Str"" + vmId + ""String_Node_Str"");
  NodeEntity nodeEntity=lockClusterEntityMgr.getClusterEntityMgr().getNodeWithNicsByMobId(vmId);
  if (nodeEntity == null) {
    logger.info(""String_Node_Str"" + nodeEntity.getVmName() + ""String_Node_Str"");
  }
  QueryIpAddress query=new QueryIpAddress(nodeEntity.fetchAllPortGroups(),Constants.VM_POWER_ON_WAITING_SEC);
  query.setVmId(vmId);
  try {
    query.call();
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + vmId,e);
  }
  String clusterName=CommonUtil.getClusterName(nodeEntity.getVmName());
  lockClusterEntityMgr.refreshNodeByMobId(clusterName,vmId,false);
  return true;
}"
48714,"@SuppressWarnings(""String_Node_Str"") @Override public boolean createVcVms(List<NetworkAdd> networkAdds,List<BaseNode> vNodes,Map<String,Set<String>> occupiedIpSets,StatusUpdater statusUpdator){
  if (vNodes.isEmpty()) {
    logger.info(""String_Node_Str"");
    return true;
  }
  updateNicLabels(vNodes);
  allocateStaticIp(vNodes,networkAdds,occupiedIpSets);
  Map<String,Folder> folders=createVcFolders(vNodes.get(0).getCluster());
  String clusterRpName=createVcResourcePools(vNodes);
  logger.info(""String_Node_Str"");
  VcVmUtil.updateVm(templateVm.getId());
  VmCreateSpec sourceSpec=new VmCreateSpec();
  sourceSpec.setVmId(templateVm.getId());
  sourceSpec.setVmName(templateVm.getName());
  sourceSpec.setTargetHost(templateVm.getHost());
  List<VmCreateSpec> specs=new ArrayList<VmCreateSpec>();
  Map<String,BaseNode> nodeMap=new HashMap<String,BaseNode>();
  for (  BaseNode vNode : vNodes) {
    nodeMap.put(vNode.getVmName(),vNode);
    vNode.setSuccess(false);
    vNode.setFinished(false);
    VmCreateSpec spec=new VmCreateSpec();
    VmSchema createSchema=getVmSchema(vNode);
    spec.setSchema(createSchema);
    String defaultPgName=null;
    GuestMachineIdSpec machineIdSpec=new GuestMachineIdSpec(networkAdds,vNode.fetchPortGroupToIpV4Map(),vNode.getPrimaryMgtPgName());
    logger.info(""String_Node_Str"" + vNode.getVmName() + ""String_Node_Str""+ machineIdSpec.toString());
    spec.setBootupConfigs(machineIdSpec.toGuestVarialbe());
    QueryIpAddress query=new QueryIpAddress(vNode.getNics().keySet(),Constants.VM_POWER_ON_WAITING_SEC);
    spec.setPostPowerOn(query);
    spec.setPrePowerOn(getPrePowerOnFunc(vNode));
    spec.setLinkedClone(false);
    spec.setTargetDs(getVcDatastore(vNode));
    spec.setTargetFolder(folders.get(vNode.getGroupName()));
    spec.setTargetHost(VcResourceUtils.findHost(vNode.getTargetHost()));
    spec.setTargetRp(getVcResourcePool(vNode,clusterRpName));
    spec.setVmName(vNode.getVmName());
    specs.add(spec);
  }
  UpdateVmProgressCallback callback=new UpdateVmProgressCallback(getLockClusterEntityMgr(),statusUpdator,vNodes.get(0).getClusterName());
  logger.info(""String_Node_Str"");
  AuAssert.check(specs.size() > 0);
  VmSchema vmSchema=specs.get(0).getSchema();
  VcVmUtil.checkAndCreateSnapshot(vmSchema);
  List<VmCreateResult<?>> results=cloneService.createCopies(sourceSpec,cloneConcurrency,specs,callback);
  if (results == null || results.isEmpty()) {
    for (    VmCreateSpec spec : specs) {
      BaseNode node=nodeMap.get(spec.getVmName());
      node.setFinished(true);
      node.setSuccess(false);
    }
    return false;
  }
  boolean success=true;
  int total=0;
  for (  VmCreateResult<?> result : results) {
    VmCreateSpec spec=(VmCreateSpec)result.getSpec();
    BaseNode node=nodeMap.get(spec.getVmName());
    node.setVmMobId(spec.getVmId());
    node.setSuccess(true);
    node.setFinished(true);
    boolean vmSucc=VcVmUtil.setBaseNodeForVm(node,spec.getVmId());
    if (!vmSucc || !result.isSuccess()) {
      success=false;
      node.setSuccess(false);
      node.setErrMessage(result.getErrMessage());
    }
 else {
      total++;
    }
  }
  logger.info(total + ""String_Node_Str"");
  return success;
}","@SuppressWarnings(""String_Node_Str"") @Override public boolean createVcVms(List<NetworkAdd> networkAdds,List<BaseNode> vNodes,Map<String,Set<String>> occupiedIpSets,StatusUpdater statusUpdator){
  if (vNodes.isEmpty()) {
    logger.info(""String_Node_Str"");
    return true;
  }
  updateNicLabels(vNodes);
  allocateStaticIp(vNodes,networkAdds,occupiedIpSets);
  Map<String,Folder> folders=createVcFolders(vNodes.get(0).getCluster());
  String clusterRpName=createVcResourcePools(vNodes);
  logger.info(""String_Node_Str"");
  VcVmUtil.updateVm(templateVm.getId());
  VmCreateSpec sourceSpec=new VmCreateSpec();
  sourceSpec.setVmId(templateVm.getId());
  sourceSpec.setVmName(templateVm.getName());
  sourceSpec.setTargetHost(templateVm.getHost());
  List<VmCreateSpec> specs=new ArrayList<VmCreateSpec>();
  Map<String,BaseNode> nodeMap=new HashMap<String,BaseNode>();
  for (  BaseNode vNode : vNodes) {
    nodeMap.put(vNode.getVmName(),vNode);
    vNode.setSuccess(false);
    vNode.setFinished(false);
    VmCreateSpec spec=new VmCreateSpec();
    VmSchema createSchema=getVmSchema(vNode);
    spec.setSchema(createSchema);
    String defaultPgName=null;
    GuestMachineIdSpec machineIdSpec=new GuestMachineIdSpec(networkAdds,vNode.fetchPortGroupToIpV4Map(),vNode.getPrimaryMgtPgName());
    logger.info(""String_Node_Str"" + vNode.getVmName() + ""String_Node_Str""+ machineIdSpec.toString());
    spec.setBootupConfigs(machineIdSpec.toGuestVarialbe());
    QueryIpAddress query=new QueryIpAddress(vNode.getNics().keySet(),Constants.VM_POWER_ON_WAITING_SEC);
    spec.setPostPowerOn(query);
    spec.setPrePowerOn(getPrePowerOnFunc(vNode));
    spec.setLinkedClone(false);
    spec.setTargetDs(getVcDatastore(vNode));
    spec.setTargetFolder(folders.get(vNode.getGroupName()));
    spec.setTargetHost(VcResourceUtils.findHost(vNode.getTargetHost()));
    spec.setTargetRp(getVcResourcePool(vNode,clusterRpName));
    spec.setVmName(vNode.getVmName());
    specs.add(spec);
  }
  UpdateVmProgressCallback callback=new UpdateVmProgressCallback(getLockClusterEntityMgr(),statusUpdator,vNodes.get(0).getClusterName());
  logger.info(""String_Node_Str"");
  AuAssert.check(specs.size() > 0);
  VmSchema vmSchema=specs.get(0).getSchema();
  VcVmUtil.checkAndCreateSnapshot(vmSchema);
  List<VmCreateResult<?>> results=cloneService.createCopies(sourceSpec,cloneConcurrency,specs,callback);
  if (results == null || results.isEmpty()) {
    for (    VmCreateSpec spec : specs) {
      BaseNode node=nodeMap.get(spec.getVmName());
      node.setFinished(true);
      node.setSuccess(false);
    }
    return false;
  }
  boolean success=true;
  int total=0;
  for (  VmCreateResult<?> result : results) {
    VmCreateSpec spec=(VmCreateSpec)result.getSpec();
    BaseNode node=nodeMap.get(spec.getVmName());
    node.setVmMobId(spec.getVmId());
    node.setSuccess(true);
    node.setFinished(true);
    boolean vmSucc=VcVmUtil.setBaseNodeForVm(node,spec.getVmId());
    if (!vmSucc || !result.isSuccess()) {
      success=false;
      node.setSuccess(false);
      if (result.getErrMessage() != null) {
        node.setErrMessage(result.getErrMessage());
      }
 else {
        node.setErrMessage(node.getNodeAction());
      }
    }
 else {
      total++;
    }
  }
  logger.info(total + ""String_Node_Str"");
  return success;
}"
48715,"@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  if (clusterName == null) {
    clusterName=getJobParameters(chunkContext).getString(JobConstants.TARGET_NAME_JOB_PARAM).split(""String_Node_Str"")[0];
  }
  lockClusterEntityMgr.syncUp(clusterName,false);
  List<NodeOperationStatus> nodesStatus=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_NODES_STATUS,new TypeToken<List<NodeOperationStatus>>(){
  }
.getType());
  if (nodesStatus != null) {
    for (    NodeOperationStatus node : nodesStatus) {
      NodeEntity entity=getClusterEntityMgr().findNodeByName(node.getNodeName());
      entity.setActionFailed(!node.isSucceed());
      entity.setErrMessage(node.getErrorMessage());
    }
  }
  Boolean success=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_OPERATION_SUCCESS,Boolean.class);
  if (success != null && !success) {
    return RepeatStatus.FINISHED;
  }
  NodeStatus expectedStatus=getFromJobExecutionContext(chunkContext,JobConstants.EXPECTED_NODE_STATUS,NodeStatus.class);
  if (expectedStatus != null) {
    logger.info(""String_Node_Str"" + expectedStatus);
    List<NodeEntity> nodes=getClusterEntityMgr().findAllNodes(clusterName);
    success=JobUtils.verifyNodesStatus(nodes,expectedStatus,true);
    putIntoJobExecutionContext(chunkContext,JobConstants.VERIFY_NODE_STATUS_RESULT_PARAM,success);
  }
  return RepeatStatus.FINISHED;
}","@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  if (clusterName == null) {
    clusterName=getJobParameters(chunkContext).getString(JobConstants.TARGET_NAME_JOB_PARAM).split(""String_Node_Str"")[0];
  }
  lockClusterEntityMgr.syncUp(clusterName,false);
  setNodeErrorMessages(chunkContext);
  Boolean success=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_OPERATION_SUCCESS,Boolean.class);
  if (success != null && !success) {
    return RepeatStatus.FINISHED;
  }
  verifyNodeStatus(chunkContext,clusterName);
  return RepeatStatus.FINISHED;
}"
48716,"private void verifyCreatedNodes(ChunkContext chunkContext,String clusterName){
  Boolean created=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_CREATE_VM_OPERATION_SUCCESS,Boolean.class);
  String verifyScope=getJobParameters(chunkContext).getString(JobConstants.VERIFY_NODE_STATUS_SCOPE_PARAM);
  String groupName=null;
  long oldInstanceNum=0;
  if (verifyScope != null && verifyScope.equals(JobConstants.GROUP_NODE_SCOPE_VALUE)) {
    groupName=getJobParameters(chunkContext).getString(JobConstants.GROUP_NAME_JOB_PARAM);
    oldInstanceNum=getJobParameters(chunkContext).getLong(JobConstants.GROUP_INSTANCE_OLD_NUMBER_JOB_PARAM);
  }
  if (created != null && created) {
    boolean success=JobUtils.VerifyClusterNodes(clusterName,verifyScope,groupName,oldInstanceNum,getClusterEntityMgr());
    putIntoJobExecutionContext(chunkContext,JobConstants.VERIFY_NODE_STATUS_RESULT_PARAM,success);
  }
}","@Transactional private void verifyCreatedNodes(ChunkContext chunkContext,String clusterName){
  Boolean created=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_CREATE_VM_OPERATION_SUCCESS,Boolean.class);
  String verifyScope=getJobParameters(chunkContext).getString(JobConstants.VERIFY_NODE_STATUS_SCOPE_PARAM);
  String groupName=null;
  long oldInstanceNum=0;
  if (verifyScope != null && verifyScope.equals(JobConstants.GROUP_NODE_SCOPE_VALUE)) {
    groupName=getJobParameters(chunkContext).getString(JobConstants.GROUP_NAME_JOB_PARAM);
    oldInstanceNum=getJobParameters(chunkContext).getLong(JobConstants.GROUP_INSTANCE_OLD_NUMBER_JOB_PARAM);
  }
  if (created != null && created) {
    boolean success=JobUtils.VerifyClusterNodes(clusterName,verifyScope,groupName,oldInstanceNum,getClusterEntityMgr());
    putIntoJobExecutionContext(chunkContext,JobConstants.VERIFY_NODE_STATUS_RESULT_PARAM,success);
  }
}"
48717,"public static boolean verifyNodesStatus(List<NodeEntity> nodes,NodeStatus expectedStatus,boolean ignoreMissing){
  boolean success=true;
  for (  NodeEntity node : nodes) {
    try {
      verifyNodeStatus(node,expectedStatus,ignoreMissing);
    }
 catch (    Exception e) {
      node.setActionFailed(true);
      node.setErrMessage(e.getMessage());
      success=false;
    }
  }
  return success;
}","public static boolean verifyNodesStatus(List<NodeEntity> nodes,NodeStatus expectedStatus,boolean ignoreMissing){
  boolean success=true;
  for (  NodeEntity node : nodes) {
    try {
      verifyNodeStatus(node,expectedStatus,ignoreMissing);
    }
 catch (    Exception e) {
      node.setActionFailed(true);
      logger.debug(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ e.getMessage());
      if (node.getErrMessage() == null) {
        node.setErrMessage(e.getMessage());
        logger.debug(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ e.getMessage());
      }
      success=false;
    }
  }
  return success;
}"
48718,"@Transactional @RetryTransaction public boolean handleOperationStatus(String clusterName,OperationStatusWithDetail status){
  logger.info(""String_Node_Str"" + status.getOperationStatus());
  boolean finished=status.getOperationStatus().isFinished();
  final Map<String,GroupData> groups=status.getClusterData().getGroups();
  ClusterEntity cluster=findByName(clusterName);
  AuAssert.check(cluster.getId() != null);
  for (  NodeGroupEntity group : cluster.getNodeGroups()) {
    for (    String groupName : groups.keySet()) {
      if (groupName.equals(group.getName())) {
        for (        ServerData serverData : groups.get(groupName).getInstances()) {
          logger.debug(""String_Node_Str"" + serverData.getName() + ""String_Node_Str""+ serverData.getAction()+ ""String_Node_Str""+ serverData.getStatus());
          Iterator<NodeEntity> iter=group.getNodes().iterator();
          while (iter.hasNext()) {
            NodeEntity oldNode=iter.next();
            if (oldNode.getVmName().equals(serverData.getName())) {
              logger.debug(""String_Node_Str"" + oldNode.getVmName() + ""String_Node_Str""+ oldNode.getStatus());
              oldNode.setAction(serverData.getAction());
              logger.debug(""String_Node_Str"" + NodeStatus.fromString(serverData.getStatus()));
              String errorMsg=serverData.getError_msg();
              if (errorMsg != null && !errorMsg.isEmpty()) {
                oldNode.setActionFailed(true);
                oldNode.setErrMessage(errorMsg);
                logger.debug(""String_Node_Str"" + errorMsg);
              }
              if (!oldNode.isDisconnected()) {
                oldNode.setStatus(NodeStatus.fromString(serverData.getStatus()),false);
                logger.debug(""String_Node_Str"" + oldNode.getVmName() + ""String_Node_Str""+ oldNode.getStatus());
              }
 else {
                logger.debug(""String_Node_Str"");
              }
              update(oldNode);
              break;
            }
          }
        }
      }
    }
  }
  logger.debug(""String_Node_Str"");
  return finished;
}","@Transactional @RetryTransaction public boolean handleOperationStatus(String clusterName,OperationStatusWithDetail status,boolean lastUpdate){
  logger.info(""String_Node_Str"" + status.getOperationStatus());
  boolean finished=status.getOperationStatus().isFinished();
  final Map<String,GroupData> groups=status.getClusterData().getGroups();
  ClusterEntity cluster=findByName(clusterName);
  AuAssert.check(cluster.getId() != null);
  for (  NodeGroupEntity group : cluster.getNodeGroups()) {
    for (    String groupName : groups.keySet()) {
      if (groupName.equals(group.getName())) {
        for (        ServerData serverData : groups.get(groupName).getInstances()) {
          logger.debug(""String_Node_Str"" + serverData.getName() + ""String_Node_Str""+ serverData.getAction()+ ""String_Node_Str""+ serverData.getStatus());
          Iterator<NodeEntity> iter=group.getNodes().iterator();
          while (iter.hasNext()) {
            NodeEntity oldNode=iter.next();
            if (oldNode.getVmName().equals(serverData.getName())) {
              logger.debug(""String_Node_Str"" + oldNode.getVmName() + ""String_Node_Str""+ oldNode.getStatus());
              oldNode.setAction(serverData.getAction());
              logger.debug(""String_Node_Str"" + NodeStatus.fromString(serverData.getStatus()));
              String errorMsg=serverData.getError_msg();
              if (lastUpdate && errorMsg != null && !errorMsg.isEmpty()) {
                oldNode.setActionFailed(true);
                oldNode.setErrMessage(errorMsg);
                logger.debug(""String_Node_Str"" + errorMsg);
              }
              if (!oldNode.isDisconnected()) {
                oldNode.setStatus(NodeStatus.fromString(serverData.getStatus()),false);
                logger.debug(""String_Node_Str"" + oldNode.getVmName() + ""String_Node_Str""+ oldNode.getStatus());
              }
 else {
                logger.debug(""String_Node_Str"");
              }
              update(oldNode);
              break;
            }
          }
        }
      }
    }
  }
  logger.debug(""String_Node_Str"");
  return finished;
}"
48719,"@Override @ClusterEntityConcurrentWriteLock public boolean handleOperationStatus(String clusterName,OperationStatusWithDetail status){
  return clusterEntityMgr.handleOperationStatus(clusterName,status);
}","@Override @ClusterEntityConcurrentWriteLock public boolean handleOperationStatus(String clusterName,OperationStatusWithDetail status,boolean lastUpdate){
  return clusterEntityMgr.handleOperationStatus(clusterName,status,lastUpdate);
}"
48720,"@Override @ClusterEntityExclusiveWriteLock public boolean handleOperationStatus(String clusterName,OperationStatusWithDetail status){
  return clusterEntityMgr.handleOperationStatus(clusterName,status);
}","@Override @ClusterEntityExclusiveWriteLock public boolean handleOperationStatus(String clusterName,OperationStatusWithDetail status,boolean lastUpdate){
  return clusterEntityMgr.handleOperationStatus(clusterName,status,lastUpdate);
}"
48721,"public boolean handleOperationStatus(String clusterName,OperationStatusWithDetail status);","public boolean handleOperationStatus(String clusterName,OperationStatusWithDetail status,boolean lastUpdate);"
48722,"public boolean handleOperationStatus(String clusterName,OperationStatusWithDetail status);","public boolean handleOperationStatus(String clusterName,OperationStatusWithDetail status,boolean lastUpdate);"
48723,"@Override public void doWork() throws Exception {
  boolean exit=false;
  logger.info(""String_Node_Str"" + targetName);
  OperationStatusWithDetail detailedStatus=null;
  SoftwareManagementClient monitorClient=new SoftwareManagementClient();
  monitorClient.init();
  while (!exit) {
    try {
      Thread.sleep(queryInterval);
    }
 catch (    InterruptedException e) {
      logger.info(""String_Node_Str"");
      stop=true;
    }
    if (stop) {
      logger.info(""String_Node_Str"");
      exit=true;
    }
    logger.info(""String_Node_Str"");
    detailedStatus=monitorClient.getOperationStatusWithDetail(targetName);
    if (null == detailedStatus) {
      logger.error(""String_Node_Str"");
      break;
    }
    logger.info(""String_Node_Str"" + detailedStatus.getOperationStatus().isFinished());
    logger.debug(detailedStatus.toString());
    logger.info(""String_Node_Str"");
    if (detailedStatus.getOperationStatus().getProgress() < 100) {
      int progress=detailedStatus.getOperationStatus().getProgress();
      statusUpdater.setProgress(((double)progress) / 100);
    }
    setLastErrorMsg(detailedStatus.getOperationStatus().getErrorMsg());
    clusterEntityMgr.handleOperationStatus(targetName.split(""String_Node_Str"")[0],detailedStatus);
    if (queryInterval == QUERY_INTERVAL_DEFAULT) {
      int size=detailedStatus.getClusterData().getClusterSize();
      if (size > BIG_CLUSTER_NODES_COUNT) {
        queryInterval=Math.min(QUERY_INTERVAL_MAX,QUERY_INTERVAL_LONG * (size / BIG_CLUSTER_NODES_COUNT));
        logger.info(""String_Node_Str"" + queryInterval / 1000 + ""String_Node_Str"" + size + ""String_Node_Str"");
      }
    }
  }
  if (monitorClient != null) {
    monitorClient.close();
  }
}","@Override public void doWork() throws Exception {
  boolean exit=false;
  logger.info(""String_Node_Str"" + targetName);
  OperationStatusWithDetail detailedStatus=null;
  SoftwareManagementClient monitorClient=new SoftwareManagementClient();
  monitorClient.init();
  while (!exit) {
    try {
      Thread.sleep(queryInterval);
    }
 catch (    InterruptedException e) {
      logger.info(""String_Node_Str"");
      stop=true;
    }
    if (stop) {
      logger.info(""String_Node_Str"");
      exit=true;
    }
    logger.info(""String_Node_Str"");
    detailedStatus=monitorClient.getOperationStatusWithDetail(targetName);
    if (null == detailedStatus) {
      logger.error(""String_Node_Str"");
      break;
    }
    logger.info(""String_Node_Str"" + detailedStatus.getOperationStatus().isFinished());
    logger.debug(detailedStatus.toString());
    logger.info(""String_Node_Str"");
    if (detailedStatus.getOperationStatus().getProgress() < 100) {
      int progress=detailedStatus.getOperationStatus().getProgress();
      statusUpdater.setProgress(((double)progress) / 100);
    }
    setLastErrorMsg(detailedStatus.getOperationStatus().getErrorMsg());
    clusterEntityMgr.handleOperationStatus(targetName.split(""String_Node_Str"")[0],detailedStatus,exit);
    if (queryInterval == QUERY_INTERVAL_DEFAULT) {
      int size=detailedStatus.getClusterData().getClusterSize();
      if (size > BIG_CLUSTER_NODES_COUNT) {
        queryInterval=Math.min(QUERY_INTERVAL_MAX,QUERY_INTERVAL_LONG * (size / BIG_CLUSTER_NODES_COUNT));
        logger.info(""String_Node_Str"" + queryInterval / 1000 + ""String_Node_Str"" + size + ""String_Node_Str"");
      }
    }
  }
  if (monitorClient != null) {
    monitorClient.close();
  }
}"
48724,"public static boolean setBaseNodeForVm(BaseNode vNode,String vmId){
  if (vmId == null) {
    vNode.setNodeAction(Constants.NODE_ACTION_CLONING_FAILED);
    return false;
  }
  VcVirtualMachine vm=VcCache.getIgnoreMissing(vmId);
  if (vm == null) {
    logger.info(""String_Node_Str"" + vmId + ""String_Node_Str"");
    vNode.setNodeAction(Constants.NODE_ACTION_CLONING_FAILED);
    return false;
  }
  boolean success=true;
  for (  String portGroup : vNode.getNics().keySet()) {
    String ipv4Address=VcVmUtil.getIpAddressOfPortGroup(vm,portGroup,false);
    vNode.updateNicOfPortGroup(portGroup,ipv4Address,null,null);
  }
  if (vNode.ipsReadyV4()) {
    vNode.setSuccess(true);
    vNode.setGuestHostName(VcVmUtil.getGuestHostName(vm,false));
    vNode.setTargetHost(vm.getHost().getName());
    vNode.setVmMobId(vm.getId());
    if (vm.isPoweredOn()) {
      vNode.setNodeStatus(NodeStatus.VM_READY);
      vNode.setNodeAction(null);
    }
 else {
      vNode.setNodeStatus(NodeStatus.POWERED_OFF);
      vNode.setNodeAction(Constants.NODE_ACTION_CLONING_FAILED);
    }
  }
 else {
    vNode.setSuccess(false);
    vNode.resetIpsV4();
    if (vm != null) {
      vNode.setVmMobId(vm.getId());
      if (vm.isPoweredOn()) {
        vNode.setNodeStatus(NodeStatus.POWERED_ON);
        vNode.setNodeAction(Constants.NODE_ACTION_GET_IP_FAILED);
      }
 else {
        vNode.setNodeStatus(NodeStatus.POWERED_OFF);
        vNode.setNodeAction(Constants.NODE_ACTION_CLONING_FAILED);
      }
    }
    success=false;
    logger.error(""String_Node_Str"" + vNode.getVmName());
  }
  if (success) {
    String haFlag=vNode.getNodeGroup().getHaFlag();
    if (haFlag != null && Constants.HA_FLAG_FT.equals(haFlag.toLowerCase()) && !verifyFTState(vm)) {
      logger.error(""String_Node_Str"" + vm.getName() + ""String_Node_Str""+ ""String_Node_Str""+ vm.getFTState()+ ""String_Node_Str"");
      vNode.setNodeAction(Constants.NODE_ACTION_WRONG_FT_STATUS);
      return false;
    }
  }
  return success;
}","public static boolean setBaseNodeForVm(BaseNode vNode,String vmId){
  if (vmId == null) {
    vNode.setNodeAction(Constants.NODE_ACTION_CLONING_FAILED);
    return false;
  }
  VcVirtualMachine vm=VcCache.getIgnoreMissing(vmId);
  if (vm == null) {
    logger.info(""String_Node_Str"" + vmId + ""String_Node_Str"");
    vNode.setNodeAction(Constants.NODE_ACTION_CLONING_FAILED);
    return false;
  }
  boolean success=true;
  for (  String portGroup : vNode.getNics().keySet()) {
    String ipv4Address=VcVmUtil.getIpAddressOfPortGroup(vm,portGroup,false);
    vNode.updateNicOfPortGroup(portGroup,ipv4Address,null,null);
  }
  if (vNode.ipsReadyV4()) {
    vNode.setSuccess(true);
    vNode.setGuestHostName(VcVmUtil.getGuestHostName(vm,false));
    vNode.setTargetHost(vm.getHost().getName());
    vNode.setVmMobId(vm.getId());
    if (vm.isPoweredOn()) {
      vNode.setNodeStatus(NodeStatus.VM_READY);
      vNode.setNodeAction(null);
    }
 else {
      vNode.setNodeStatus(NodeStatus.POWERED_OFF);
      vNode.setNodeAction(Constants.NODE_ACTION_CREATION_FAILED);
    }
  }
 else {
    vNode.setSuccess(false);
    vNode.resetIpsV4();
    if (vm != null) {
      vNode.setVmMobId(vm.getId());
      if (vm.isPoweredOn()) {
        vNode.setNodeStatus(NodeStatus.POWERED_ON);
        vNode.setNodeAction(Constants.NODE_ACTION_GET_IP_FAILED);
      }
 else {
        vNode.setNodeStatus(NodeStatus.POWERED_OFF);
        vNode.setNodeAction(Constants.NODE_ACTION_CREATION_FAILED);
      }
    }
    success=false;
    logger.error(""String_Node_Str"" + vNode.getVmName());
  }
  if (success) {
    String haFlag=vNode.getNodeGroup().getHaFlag();
    if (haFlag != null && Constants.HA_FLAG_FT.equals(haFlag.toLowerCase()) && !verifyFTState(vm)) {
      logger.error(""String_Node_Str"" + vm.getName() + ""String_Node_Str""+ ""String_Node_Str""+ vm.getFTState()+ ""String_Node_Str"");
      vNode.setNodeAction(Constants.NODE_ACTION_WRONG_FT_STATUS);
      return false;
    }
  }
  return success;
}"
48725,"@Test public void testExclusiveCompetitiveInTwoThread() throws Exception {
  setThreadStarted(false);
  LockTestThread t=new LockTestThread(exclusiveLockedMgr);
  t.start();
  while (!isThreadStarted()) {
    Thread.sleep(10);
  }
  Thread.sleep(40);
  long start=System.currentTimeMillis();
  exclusiveLockedMgr.removeVmReference(LOCKED_CLUSTER_NAME,""String_Node_Str"");
  long end=System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  Assert.assertTrue((end - start) >= 100,""String_Node_Str"" + (end - start));
  t.join();
}","@Test public void testExclusiveCompetitiveInTwoThread() throws Exception {
  setThreadStarted(false);
  LockTestThread t=new LockTestThread(exclusiveLockedMgr);
  t.start();
  while (!isThreadStarted()) {
    Thread.sleep(10);
  }
  Thread.sleep(40);
  long start=System.currentTimeMillis();
  exclusiveLockedMgr.removeVmReference(LOCKED_CLUSTER_NAME,""String_Node_Str"");
  long end=System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + (end - start) + ""String_Node_Str"");
  t.join();
}"
48726,"/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
public void validateClusterCreate(List<String> failedMsgList,List<String> warningMsgList){
  boolean namenodeHACheck=false;
  int masterCount=0, jobtrackerCount=0, resourcemanagerCount=0, hbasemasterCount=0, zookeeperCount=0, workerCount=0, numOfJournalNode=0;
  boolean appendWarningStr=false;
  if (warningMsgList != null && warningMsgList.isEmpty()) {
    appendWarningStr=true;
  }
  NodeGroupCreate[] nodeGroupCreates=getNodeGroups();
  AuAssert.check(nodeGroupCreates != null && nodeGroupCreates.length > 0);
  if (hasHDFSUrlConfigured() && !validateHDFSUrl()) {
    failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getExternalHDFS()).toString());
  }
  validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList);
  validateNodeGroupRoles(failedMsgList);
  validateStorageType(failedMsgList);
  validateSwapRatio(nodeGroupCreates,failedMsgList);
  for (  NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
    checkInstanceNum(nodeGroupCreate,failedMsgList);
    checkCPUAndMemory(nodeGroupCreate,failedMsgList,warningMsgList);
    List<NodeGroupRole> groupRoles=getNodeGroupRoles(nodeGroupCreate);
    if (groupRoles != null) {
      for (      NodeGroupRole role : groupRoles) {
switch (role) {
case MASTER:
          masterCount++;
        int numOfInstance=nodeGroupCreate.getInstanceNum();
      if (numOfInstance >= 0 && numOfInstance != 1) {
        if (numOfInstance != 2) {
          collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
        }
 else {
          namenodeHACheck=true;
        }
      }
    break;
case JOB_TRACKER:
  jobtrackerCount++;
if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
  failedMsgList.add(Constants.WRONG_NUM_OF_JOBTRACKER);
}
break;
case RESOURCEMANAGER:
resourcemanagerCount++;
if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
failedMsgList.add(Constants.WRONG_NUM_OF_RESOURCEMANAGER);
}
break;
case HBASE_MASTER:
hbasemasterCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
break;
case ZOOKEEPER:
zookeeperCount++;
if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_ZOOKEEPER);
}
 else if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_ZOOKEEPER);
}
break;
case JOURNAL_NODE:
numOfJournalNode+=nodeGroupCreate.getInstanceNum();
if (nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_DATANODE.toString()) || nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_CLIENT_ROLE.toString())) {
failedMsgList.add(Constants.DATA_CLIENT_NODE_JOURNALNODE_COEXIST);
}
break;
case WORKER:
workerCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
 else if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
List<String> roles=nodeGroupCreate.getRoles();
if (roles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString()) && !roles.contains(HadoopRole.HADOOP_DATANODE.toString())) {
warningMsgList.add(Constants.REGISONSERVER_DATANODE_SEPERATION);
}
break;
case CLIENT:
if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
case NONE:
break;
default :
break;
}
}
}
}
if (!supportedWithHdfs2()) {
if (namenodeHACheck || masterCount > 1) {
failedMsgList.add(Constants.CURRENT_DISTRO_CAN_NOT_SUPPORT_HDFS2);
}
}
 else if (namenodeHACheck) {
if (numOfJournalNode >= 0 && numOfJournalNode < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_JOURNALNODE);
}
 else if (numOfJournalNode > 0 && numOfJournalNode % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_JOURNALNODE);
}
if (zookeeperCount == 0) {
failedMsgList.add(Constants.NAMENODE_AUTO_FAILOVER_ZOOKEEPER);
}
}
if ((jobtrackerCount > 1) || (resourcemanagerCount > 1) || (zookeeperCount > 1)|| (hbasemasterCount > 1)) {
failedMsgList.add(Constants.WRONG_NUM_OF_NODEGROUPS);
}
if (workerCount == 0) {
warningMsgList.add(Constants.WRONG_NUM_OF_WORKERNODES);
}
if (numOfJournalNode > 0 && !namenodeHACheck) {
failedMsgList.add(Constants.NO_NAMENODE_HA);
}
if (!warningMsgList.isEmpty() && appendWarningStr) {
warningMsgList.set(0,""String_Node_Str"" + warningMsgList.get(0));
}
}","/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
public void validateClusterCreate(List<String> failedMsgList,List<String> warningMsgList){
  boolean namenodeHACheck=false;
  int masterCount=0, jobtrackerCount=0, resourcemanagerCount=0, hbasemasterCount=0, zookeeperCount=0, workerCount=0, numOfJournalNode=0;
  boolean appendWarningStr=false;
  if (warningMsgList != null && warningMsgList.isEmpty()) {
    appendWarningStr=true;
  }
  NodeGroupCreate[] nodeGroupCreates=getNodeGroups();
  AuAssert.check(nodeGroupCreates != null && nodeGroupCreates.length > 0);
  if (hasHDFSUrlConfigured() && !validateHDFSUrl()) {
    failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getExternalHDFS()).toString());
  }
  validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList);
  validateNodeGroupRoles(failedMsgList);
  validateStorageType(failedMsgList);
  validateSwapRatio(nodeGroupCreates,failedMsgList);
  for (  NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
    checkInstanceNum(nodeGroupCreate,failedMsgList);
    checkCPUAndMemory(nodeGroupCreate,failedMsgList,warningMsgList);
    List<NodeGroupRole> groupRoles=getNodeGroupRoles(nodeGroupCreate);
    if (groupRoles != null) {
      for (      NodeGroupRole role : groupRoles) {
switch (role) {
case MASTER:
          masterCount++;
        int numOfInstance=nodeGroupCreate.getInstanceNum();
      if (numOfInstance >= 0 && numOfInstance != 1) {
        if (numOfInstance != 2) {
          collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
        }
 else {
          namenodeHACheck=true;
        }
      }
    break;
case JOB_TRACKER:
  jobtrackerCount++;
if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
  failedMsgList.add(Constants.WRONG_NUM_OF_JOBTRACKER);
}
break;
case RESOURCEMANAGER:
resourcemanagerCount++;
if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
failedMsgList.add(Constants.WRONG_NUM_OF_RESOURCEMANAGER);
}
break;
case HBASE_MASTER:
hbasemasterCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
break;
case ZOOKEEPER:
zookeeperCount++;
if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_ZOOKEEPER);
}
 else if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_ZOOKEEPER);
}
break;
case JOURNAL_NODE:
numOfJournalNode+=nodeGroupCreate.getInstanceNum();
if (nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_DATANODE.toString()) || nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_CLIENT_ROLE.toString())) {
failedMsgList.add(Constants.DATA_CLIENT_NODE_JOURNALNODE_COEXIST);
}
break;
case WORKER:
workerCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
 else if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
List<String> roles=nodeGroupCreate.getRoles();
if (roles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString()) && !roles.contains(HadoopRole.HADOOP_DATANODE.toString())) {
warningMsgList.add(Constants.REGISONSERVER_DATANODE_SEPERATION);
}
break;
case CLIENT:
if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
case NONE:
break;
default :
break;
}
}
}
}
if (!supportedWithHdfs2()) {
if (namenodeHACheck || masterCount > 1) {
failedMsgList.add(Constants.CURRENT_DISTRO_CAN_NOT_SUPPORT_HDFS2);
}
}
 else if (namenodeHACheck) {
if (numOfJournalNode >= 0 && numOfJournalNode < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_JOURNALNODE);
}
 else if (numOfJournalNode > 0 && numOfJournalNode % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_JOURNALNODE);
}
if (zookeeperCount == 0) {
failedMsgList.add(Constants.NAMENODE_AUTO_FAILOVER_ZOOKEEPER);
}
}
if ((jobtrackerCount > 1) || (resourcemanagerCount > 1) || (zookeeperCount > 1)|| (hbasemasterCount > 1)) {
failedMsgList.add(Constants.WRONG_NUM_OF_NODEGROUPS);
}
if (numOfJournalNode > 0 && !namenodeHACheck) {
failedMsgList.add(Constants.NO_NAMENODE_HA);
}
if (!warningMsgList.isEmpty() && appendWarningStr) {
warningMsgList.set(0,""String_Node_Str"" + warningMsgList.get(0));
}
}"
48727,"public int compare(String str1,String str2){
  if (HadoopRole.fromString(str1).shouldRunAfterHDFS()) {
    return 1;
  }
 else   if (HadoopRole.fromString(str2).shouldRunAfterHDFS()) {
    return -1;
  }
 else {
    return 0;
  }
}","public int compare(NodeGroupCreate arg0,NodeGroupCreate arg1){
  if (arg0.getGroupType().equals(arg1.getGroupType())) {
    return arg0.getName().compareTo(arg1.getName());
  }
 else {
    return arg0.getGroupType().compareTo(arg1.getGroupType());
  }
}"
48728,"@SuppressWarnings(""String_Node_Str"") private NodeGroupCreate convertNodeGroups(String distro,NodeGroupEntity ngEntity,String clusterName){
  Gson gson=new Gson();
  List<String> groupRoles=gson.fromJson(ngEntity.getRoles(),List.class);
  Collections.sort(groupRoles,new Comparator<String>(){
    public int compare(    String str1,    String str2){
      if (HadoopRole.fromString(str1).shouldRunAfterHDFS()) {
        return 1;
      }
 else       if (HadoopRole.fromString(str2).shouldRunAfterHDFS()) {
        return -1;
      }
 else {
        return 0;
      }
    }
  }
);
  EnumSet<HadoopRole> enumRoles=getEnumRoles(groupRoles,distro);
  if (enumRoles.isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(ngEntity.getName());
  }
  GroupType groupType=GroupType.fromHadoopRole(enumRoles);
  AuAssert.check(groupType != null);
  NodeGroupCreate group=new NodeGroupCreate();
  group.setName(ngEntity.getName());
  group.setGroupType(groupType);
  group.setRoles(groupRoles);
  int cpu=ngEntity.getCpuNum();
  if (cpu > 0) {
    group.setCpuNum(cpu);
  }
  int memory=ngEntity.getMemorySize();
  if (memory > 0) {
    group.setMemCapacityMB(memory);
  }
  Float swapRatio=ngEntity.getSwapRatio();
  if (swapRatio != null && swapRatio > 0) {
    group.setSwapRatio(swapRatio);
  }
  if (ngEntity.getNodeType() != null) {
    group.setInstanceType(ngEntity.getNodeType());
  }
  group.setInstanceNum(ngEntity.getDefineInstanceNum());
  Integer instancePerHost=ngEntity.getInstancePerHost();
  Set<NodeGroupAssociation> associonEntities=ngEntity.getGroupAssociations();
  String ngRacks=ngEntity.getGroupRacks();
  if (instancePerHost == null && (associonEntities == null || associonEntities.isEmpty()) && ngRacks == null) {
    group.setPlacementPolicies(null);
  }
 else {
    PlacementPolicy policies=new PlacementPolicy();
    policies.setInstancePerHost(instancePerHost);
    if (ngRacks != null) {
      policies.setGroupRacks((GroupRacks)new Gson().fromJson(ngRacks,GroupRacks.class));
    }
    if (associonEntities != null) {
      List<GroupAssociation> associons=new ArrayList<GroupAssociation>(associonEntities.size());
      for (      NodeGroupAssociation ae : associonEntities) {
        GroupAssociation a=new GroupAssociation();
        a.setReference(ae.getReferencedGroup());
        a.setType(ae.getAssociationType());
        associons.add(a);
      }
      policies.setGroupAssociations(associons);
    }
    group.setPlacementPolicies(policies);
  }
  String rps=ngEntity.getVcRpNames();
  if (rps != null && rps.length() > 0) {
    logger.debug(""String_Node_Str"" + ngEntity.getName());
    String[] rpNames=gson.fromJson(rps,String[].class);
    List<VcCluster> vcClusters=rpMgr.getVcResourcePoolByNameList(rpNames);
    group.setVcClusters(vcClusters);
    group.setRpNames(Arrays.asList(rpNames));
  }
  expandGroupStorage(ngEntity,group,enumRoles);
  group.setHaFlag(ngEntity.getHaFlag());
  if (ngEntity.getHadoopConfig() != null) {
    Map<String,Object> hadoopConfig=(new Gson()).fromJson(ngEntity.getHadoopConfig(),Map.class);
    group.setConfiguration(hadoopConfig);
  }
  group.setVmFolderPath(ngEntity.getVmFolderPath());
  return group;
}","@SuppressWarnings(""String_Node_Str"") private NodeGroupCreate convertNodeGroups(String distro,NodeGroupEntity ngEntity,String clusterName){
  Gson gson=new Gson();
  List<String> groupRoles=gson.fromJson(ngEntity.getRoles(),List.class);
  EnumSet<HadoopRole> enumRoles=getEnumRoles(groupRoles,distro);
  if (enumRoles.isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(ngEntity.getName());
  }
  GroupType groupType=GroupType.fromHadoopRole(enumRoles);
  AuAssert.check(groupType != null);
  NodeGroupCreate group=new NodeGroupCreate();
  group.setName(ngEntity.getName());
  group.setGroupType(groupType);
  group.setRoles(groupRoles);
  int cpu=ngEntity.getCpuNum();
  if (cpu > 0) {
    group.setCpuNum(cpu);
  }
  int memory=ngEntity.getMemorySize();
  if (memory > 0) {
    group.setMemCapacityMB(memory);
  }
  Float swapRatio=ngEntity.getSwapRatio();
  if (swapRatio != null && swapRatio > 0) {
    group.setSwapRatio(swapRatio);
  }
  if (ngEntity.getNodeType() != null) {
    group.setInstanceType(ngEntity.getNodeType());
  }
  group.setInstanceNum(ngEntity.getDefineInstanceNum());
  Integer instancePerHost=ngEntity.getInstancePerHost();
  Set<NodeGroupAssociation> associonEntities=ngEntity.getGroupAssociations();
  String ngRacks=ngEntity.getGroupRacks();
  if (instancePerHost == null && (associonEntities == null || associonEntities.isEmpty()) && ngRacks == null) {
    group.setPlacementPolicies(null);
  }
 else {
    PlacementPolicy policies=new PlacementPolicy();
    policies.setInstancePerHost(instancePerHost);
    if (ngRacks != null) {
      policies.setGroupRacks((GroupRacks)new Gson().fromJson(ngRacks,GroupRacks.class));
    }
    if (associonEntities != null) {
      List<GroupAssociation> associons=new ArrayList<GroupAssociation>(associonEntities.size());
      for (      NodeGroupAssociation ae : associonEntities) {
        GroupAssociation a=new GroupAssociation();
        a.setReference(ae.getReferencedGroup());
        a.setType(ae.getAssociationType());
        associons.add(a);
      }
      policies.setGroupAssociations(associons);
    }
    group.setPlacementPolicies(policies);
  }
  String rps=ngEntity.getVcRpNames();
  if (rps != null && rps.length() > 0) {
    logger.debug(""String_Node_Str"" + ngEntity.getName());
    String[] rpNames=gson.fromJson(rps,String[].class);
    List<VcCluster> vcClusters=rpMgr.getVcResourcePoolByNameList(rpNames);
    group.setVcClusters(vcClusters);
    group.setRpNames(Arrays.asList(rpNames));
  }
  expandGroupStorage(ngEntity,group,enumRoles);
  group.setHaFlag(ngEntity.getHaFlag());
  if (ngEntity.getHadoopConfig() != null) {
    Map<String,Object> hadoopConfig=(new Gson()).fromJson(ngEntity.getHadoopConfig(),Map.class);
    group.setConfiguration(hadoopConfig);
  }
  group.setVmFolderPath(ngEntity.getVmFolderPath());
  return group;
}"
48729,"@Transactional public ClusterEntity createClusterConfig(ClusterCreate cluster){
  String name=cluster.getName();
  if (name == null || name.isEmpty()) {
    throw ClusterConfigException.CLUSTER_NAME_MISSING();
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  DistroRead distro=distroMgr.getDistroByName(cluster.getDistro());
  if (cluster.getDistro() == null || distro == null) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",cluster.getDistro());
  }
  checkClusterRoles(cluster,distro.getRoles(),failedMsgList);
  if (!cluster.getDistroVendor().equalsIgnoreCase(Constants.MAPR_VENDOR)) {
    List<String> allNetworkNames=new ArrayList<String>();
    for (    NetworkEntity entity : networkMgr.getAllNetworkEntities()) {
      allNetworkNames.add(entity.getName());
    }
    cluster.validateClusterCreate(failedMsgList,warningMsgList);
  }
 else {
    cluster.validateClusterCreateOfMapr(failedMsgList,warningMsgList);
  }
  if (!failedMsgList.isEmpty()) {
    throw ClusterConfigException.INVALID_SPEC(failedMsgList);
  }
  if (!validateRacksInfo(cluster,failedMsgList)) {
    throw ClusterConfigException.INVALID_PLACEMENT_POLICIES(failedMsgList);
  }
  transformHDFSUrl(cluster);
  try {
    ClusterEntity entity=clusterEntityMgr.findByName(name);
    if (entity != null) {
      logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
      throw BddException.ALREADY_EXISTS(""String_Node_Str"",name);
    }
    logger.debug(""String_Node_Str"" + name);
    Gson gson=new Gson();
    ClusterEntity clusterEntity=new ClusterEntity(name);
    clusterEntity.setDistro(cluster.getDistro());
    clusterEntity.setDistroVendor(cluster.getDistroVendor());
    clusterEntity.setDistroVersion(cluster.getDistroVersion());
    clusterEntity.setStartAfterDeploy(true);
    clusterEntity.setPassword(cluster.getPassword());
    if (cluster.containsComputeOnlyNodeGroups()) {
      clusterEntity.setAutomationEnable(automationEnable);
    }
 else {
      clusterEntity.setAutomationEnable(null);
    }
    clusterEntity.setVhmMinNum(-1);
    clusterEntity.setVhmMaxNum(-1);
    if (cluster.getRpNames() != null && cluster.getRpNames().size() > 0) {
      logger.debug(""String_Node_Str"" + cluster.getRpNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcRpNameList(cluster.getRpNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    if (cluster.getDsNames() != null && !cluster.getDsNames().isEmpty()) {
      logger.debug(""String_Node_Str"" + cluster.getDsNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcDatastoreNameList(cluster.getDsNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    clusterEntity.setNetworkConfig(validateAndConvertNetNamesToNetConfigs(cluster.getNetworkConfig(),cluster.getDistroVendor().equalsIgnoreCase(Constants.MAPR_VENDOR)));
    clusterEntity.setVhmJobTrackerPort(""String_Node_Str"");
    if (cluster.getConfiguration() != null && cluster.getConfiguration().size() > 0) {
      CommonClusterExpandPolicy.validateAppConfig(cluster.getConfiguration(),cluster.isValidateConfig());
      clusterEntity.setHadoopConfig((new Gson()).toJson(cluster.getConfiguration()));
      updateVhmJobTrackerPort(cluster,clusterEntity);
    }
    NodeGroupCreate[] groups=cluster.getNodeGroups();
    if (groups != null && groups.length > 0) {
      clusterEntity.setNodeGroups(convertNodeGroupsToEntities(gson,clusterEntity,cluster.getDistro(),groups,EnumSet.noneOf(HadoopRole.class),cluster.isValidateConfig()));
      validateMemorySize(clusterEntity.getNodeGroups(),failedMsgList);
      if (!failedMsgList.isEmpty()) {
        throw ClusterConfigException.INVALID_SPEC(failedMsgList);
      }
    }
    if (cluster.getTopologyPolicy() == null) {
      clusterEntity.setTopologyPolicy(TopologyType.NONE);
    }
 else {
      clusterEntity.setTopologyPolicy(cluster.getTopologyPolicy());
    }
    if (clusterEntity.getTopologyPolicy() == TopologyType.HVE) {
      boolean hveSupported=false;
      if (clusterEntity.getDistro() != null) {
        DistroRead dr=distroMgr.getDistroByName(clusterEntity.getDistro());
        if (dr != null) {
          hveSupported=dr.isHveSupported();
        }
      }
      if (!hveSupported) {
        throw ClusterConfigException.INVALID_TOPOLOGY_POLICY(clusterEntity.getTopologyPolicy(),""String_Node_Str"");
      }
    }
    clusterEntityMgr.insert(clusterEntity);
    logger.debug(""String_Node_Str"" + name);
    return clusterEntity;
  }
 catch (  UniqueConstraintViolationException ex) {
    logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
    throw BddException.ALREADY_EXISTS(ex,""String_Node_Str"",name);
  }
}","@Transactional public ClusterEntity createClusterConfig(ClusterCreate cluster){
  String name=cluster.getName();
  if (name == null || name.isEmpty()) {
    throw ClusterConfigException.CLUSTER_NAME_MISSING();
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  DistroRead distro=distroMgr.getDistroByName(cluster.getDistro());
  if (cluster.getDistro() == null || distro == null) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",cluster.getDistro());
  }
  checkClusterRoles(cluster,distro.getRoles(),failedMsgList);
  if (!cluster.getDistroVendor().equalsIgnoreCase(Constants.MAPR_VENDOR)) {
    List<String> allNetworkNames=new ArrayList<String>();
    for (    NetworkEntity entity : networkMgr.getAllNetworkEntities()) {
      allNetworkNames.add(entity.getName());
    }
    cluster.validateClusterCreate(failedMsgList,warningMsgList);
  }
 else {
    cluster.validateClusterCreateOfMapr(failedMsgList,warningMsgList);
  }
  if (!failedMsgList.isEmpty()) {
    throw ClusterConfigException.INVALID_SPEC(failedMsgList);
  }
  if (!validateRacksInfo(cluster,failedMsgList)) {
    throw ClusterConfigException.INVALID_PLACEMENT_POLICIES(failedMsgList);
  }
  transformHDFSUrl(cluster);
  try {
    ClusterEntity entity=clusterEntityMgr.findByName(name);
    if (entity != null) {
      logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
      throw BddException.ALREADY_EXISTS(""String_Node_Str"",name);
    }
    logger.debug(""String_Node_Str"" + name);
    Gson gson=new Gson();
    ClusterEntity clusterEntity=new ClusterEntity(name);
    clusterEntity.setDistro(cluster.getDistro());
    clusterEntity.setDistroVendor(cluster.getDistroVendor());
    clusterEntity.setDistroVersion(cluster.getDistroVersion());
    clusterEntity.setStartAfterDeploy(true);
    clusterEntity.setPassword(cluster.getPassword());
    if (cluster.containsComputeOnlyNodeGroups()) {
      clusterEntity.setAutomationEnable(automationEnable);
    }
 else {
      clusterEntity.setAutomationEnable(null);
    }
    clusterEntity.setVhmMinNum(-1);
    clusterEntity.setVhmMaxNum(-1);
    if (cluster.getRpNames() != null && cluster.getRpNames().size() > 0) {
      logger.debug(""String_Node_Str"" + cluster.getRpNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcRpNameList(cluster.getRpNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    if (cluster.getDsNames() != null && !cluster.getDsNames().isEmpty()) {
      logger.debug(""String_Node_Str"" + cluster.getDsNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcDatastoreNameList(cluster.getDsNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    clusterEntity.setNetworkConfig(validateAndConvertNetNamesToNetConfigs(cluster.getNetworkConfig(),cluster.getDistroVendor().equalsIgnoreCase(Constants.MAPR_VENDOR)));
    clusterEntity.setVhmJobTrackerPort(""String_Node_Str"");
    if (cluster.getConfiguration() != null && cluster.getConfiguration().size() > 0) {
      CommonClusterExpandPolicy.validateAppConfig(cluster.getConfiguration(),cluster.isValidateConfig());
      clusterEntity.setHadoopConfig((new Gson()).toJson(cluster.getConfiguration()));
      updateVhmJobTrackerPort(cluster,clusterEntity);
    }
    NodeGroupCreate[] groups=cluster.getNodeGroups();
    if (groups != null && groups.length > 0) {
      clusterEntity.setNodeGroups(convertNodeGroupsToEntities(gson,clusterEntity,cluster.getDistro(),groups,cluster.isValidateConfig()));
      validateMemorySize(clusterEntity.getNodeGroups(),failedMsgList);
      if (!failedMsgList.isEmpty()) {
        throw ClusterConfigException.INVALID_SPEC(failedMsgList);
      }
    }
    if (cluster.getTopologyPolicy() == null) {
      clusterEntity.setTopologyPolicy(TopologyType.NONE);
    }
 else {
      clusterEntity.setTopologyPolicy(cluster.getTopologyPolicy());
    }
    if (clusterEntity.getTopologyPolicy() == TopologyType.HVE) {
      boolean hveSupported=false;
      if (clusterEntity.getDistro() != null) {
        DistroRead dr=distroMgr.getDistroByName(clusterEntity.getDistro());
        if (dr != null) {
          hveSupported=dr.isHveSupported();
        }
      }
      if (!hveSupported) {
        throw ClusterConfigException.INVALID_TOPOLOGY_POLICY(clusterEntity.getTopologyPolicy(),""String_Node_Str"");
      }
    }
    clusterEntityMgr.insert(clusterEntity);
    logger.debug(""String_Node_Str"" + name);
    return clusterEntity;
  }
 catch (  UniqueConstraintViolationException ex) {
    logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
    throw BddException.ALREADY_EXISTS(ex,""String_Node_Str"",name);
  }
}"
48730,"private Set<NodeGroupEntity> convertNodeGroupsToEntities(Gson gson,ClusterEntity clusterEntity,String distro,NodeGroupCreate[] groups,EnumSet<HadoopRole> allRoles,boolean validateWhiteList){
  Set<NodeGroupEntity> nodeGroups;
  nodeGroups=new HashSet<NodeGroupEntity>();
  Set<String> referencedNodeGroups=new HashSet<String>();
  for (  NodeGroupCreate group : groups) {
    NodeGroupEntity groupEntity=convertGroup(gson,clusterEntity,allRoles,group,distro,validateWhiteList);
    if (groupEntity != null) {
      nodeGroups.add(groupEntity);
      if (groupEntity.getStorageType() == DatastoreType.TEMPFS) {
        for (        NodeGroupAssociation associate : groupEntity.getGroupAssociations()) {
          referencedNodeGroups.add(associate.getReferencedGroup());
        }
      }
    }
  }
  for (  String nodeGroupName : referencedNodeGroups) {
    for (    NodeGroupEntity groupEntity : nodeGroups) {
      if (groupEntity.getName().equals(nodeGroupName)) {
        @SuppressWarnings(""String_Node_Str"") List<String> sortedRoles=gson.fromJson(groupEntity.getRoles(),List.class);
        sortedRoles.add(0,HadoopRole.TEMPFS_SERVER_ROLE.toString());
        groupEntity.setRoles(gson.toJson(sortedRoles));
      }
    }
  }
  return nodeGroups;
}","private Set<NodeGroupEntity> convertNodeGroupsToEntities(Gson gson,ClusterEntity clusterEntity,String distro,NodeGroupCreate[] groups,boolean validateWhiteList){
  Set<NodeGroupEntity> nodeGroups;
  nodeGroups=new HashSet<NodeGroupEntity>();
  Set<String> referencedNodeGroups=new HashSet<String>();
  for (  NodeGroupCreate group : groups) {
    NodeGroupEntity groupEntity=convertGroup(gson,clusterEntity,group,distro,validateWhiteList);
    if (groupEntity != null) {
      nodeGroups.add(groupEntity);
      if (groupEntity.getStorageType() == DatastoreType.TEMPFS) {
        for (        NodeGroupAssociation associate : groupEntity.getGroupAssociations()) {
          referencedNodeGroups.add(associate.getReferencedGroup());
        }
      }
    }
  }
  for (  String nodeGroupName : referencedNodeGroups) {
    for (    NodeGroupEntity groupEntity : nodeGroups) {
      if (groupEntity.getName().equals(nodeGroupName)) {
        @SuppressWarnings(""String_Node_Str"") List<String> sortedRoles=gson.fromJson(groupEntity.getRoles(),List.class);
        sortedRoles.add(0,HadoopRole.TEMPFS_SERVER_ROLE.toString());
        groupEntity.setRoles(gson.toJson(sortedRoles));
      }
    }
  }
  return nodeGroups;
}"
48731,"private NodeGroupEntity convertGroup(Gson gson,ClusterEntity clusterEntity,EnumSet<HadoopRole> allRoles,NodeGroupCreate group,String distro,boolean validateWhiteList){
  NodeGroupEntity groupEntity=new NodeGroupEntity();
  if (group.getRoles() == null || group.getRoles().isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  Set<String> roles=new HashSet<String>();
  groupEntity.setCluster(clusterEntity);
  int cpuNum=group.getCpuNum() == null ? 0 : group.getCpuNum();
  if (!VcVmUtil.validateCPU(clusteringService.getTemplateVmId(),cpuNum)) {
    throw VcProviderException.CPU_NUM_NOT_MULTIPLE_OF_CORES_PER_SOCKET(group.getName(),clusteringService.getTemplateVmName());
  }
  groupEntity.setCpuNum(cpuNum);
  groupEntity.setDefineInstanceNum(group.getInstanceNum());
  groupEntity.setMemorySize(group.getMemCapacityMB() == null ? 0 : group.getMemCapacityMB());
  groupEntity.setSwapRatio(group.getSwapRatio());
  groupEntity.setName(group.getName());
  groupEntity.setNodeType(group.getInstanceType());
  PlacementPolicy policies=group.getPlacementPolicies();
  if (policies != null) {
    List<GroupAssociation> associons=policies.getGroupAssociations();
    if (associons != null) {
      Set<NodeGroupAssociation> associonEntities=new HashSet<NodeGroupAssociation>();
      for (      GroupAssociation a : associons) {
        NodeGroupAssociation ae=new NodeGroupAssociation();
        ae.setAssociationType(a.getType());
        ae.setNodeGroup(groupEntity);
        ae.setReferencedGroup(a.getReference());
        associonEntities.add(ae);
      }
      groupEntity.setGroupAssociations(associonEntities);
    }
    if (policies.getInstancePerHost() != null) {
      groupEntity.setInstancePerHost(policies.getInstancePerHost());
    }
    if (policies.getGroupRacks() != null) {
      groupEntity.setGroupRacks((new Gson()).toJson(policies.getGroupRacks()));
    }
  }
  if (group.getRpNames() != null && group.getRpNames().size() > 0) {
    groupEntity.setVcRpNameList(group.getRpNames());
  }
  convertStorage(group,groupEntity,roles);
  roles.addAll(group.getRoles());
  List<String> sortedRolesByDependency=new ArrayList<String>();
  sortedRolesByDependency.addAll(roles);
  Collections.sort(sortedRolesByDependency,new RoleComparactor());
  EnumSet<HadoopRole> enumRoles=getEnumRoles(group.getRoles(),distro);
  if (enumRoles.isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  groupEntity.setRoles(gson.toJson(sortedRolesByDependency));
  GroupType groupType=GroupType.fromHadoopRole(enumRoles);
  if (groupType == GroupType.CLIENT_GROUP && group.getInstanceNum() <= 0) {
    logger.warn(""String_Node_Str"" + group.getName() + ""String_Node_Str"");
    return null;
  }
  allRoles.addAll(enumRoles);
  List<String> dsNames=groupEntity.getVcDatastoreNameList();
  if (dsNames == null) {
    dsNames=clusterEntity.getVcDatastoreNameList();
  }
  Set<String> sharedPattern;
  Set<String> localPattern;
  if (dsNames != null) {
    sharedPattern=datastoreMgr.getSharedDatastoresByNames(dsNames);
    localPattern=datastoreMgr.getLocalDatastoresByNames(dsNames);
  }
 else {
    sharedPattern=datastoreMgr.getAllSharedDatastores();
    localPattern=datastoreMgr.getAllLocalDatastores();
  }
  CommonClusterExpandPolicy.expandGroupInstanceType(groupEntity,groupType,sharedPattern,localPattern);
  groupEntity.setHaFlag(group.getHaFlag());
  if (group.getConfiguration() != null && group.getConfiguration().size() > 0) {
    CommonClusterExpandPolicy.validateAppConfig(group.getConfiguration(),validateWhiteList);
    groupEntity.setHadoopConfig(gson.toJson(group.getConfiguration()));
  }
  groupEntity.setVmFolderPath(clusterEntity);
  logger.debug(""String_Node_Str"" + group.getName());
  return groupEntity;
}","private NodeGroupEntity convertGroup(Gson gson,ClusterEntity clusterEntity,NodeGroupCreate group,String distro,boolean validateWhiteList){
  NodeGroupEntity groupEntity=new NodeGroupEntity();
  if (group.getRoles() == null || group.getRoles().isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  groupEntity.setCluster(clusterEntity);
  int cpuNum=group.getCpuNum() == null ? 0 : group.getCpuNum();
  if (!VcVmUtil.validateCPU(clusteringService.getTemplateVmId(),cpuNum)) {
    throw VcProviderException.CPU_NUM_NOT_MULTIPLE_OF_CORES_PER_SOCKET(group.getName(),clusteringService.getTemplateVmName());
  }
  groupEntity.setCpuNum(cpuNum);
  groupEntity.setDefineInstanceNum(group.getInstanceNum());
  groupEntity.setMemorySize(group.getMemCapacityMB() == null ? 0 : group.getMemCapacityMB());
  groupEntity.setSwapRatio(group.getSwapRatio());
  groupEntity.setName(group.getName());
  groupEntity.setNodeType(group.getInstanceType());
  PlacementPolicy policies=group.getPlacementPolicies();
  if (policies != null) {
    List<GroupAssociation> associons=policies.getGroupAssociations();
    if (associons != null) {
      Set<NodeGroupAssociation> associonEntities=new HashSet<NodeGroupAssociation>();
      for (      GroupAssociation a : associons) {
        NodeGroupAssociation ae=new NodeGroupAssociation();
        ae.setAssociationType(a.getType());
        ae.setNodeGroup(groupEntity);
        ae.setReferencedGroup(a.getReference());
        associonEntities.add(ae);
      }
      groupEntity.setGroupAssociations(associonEntities);
    }
    if (policies.getInstancePerHost() != null) {
      groupEntity.setInstancePerHost(policies.getInstancePerHost());
    }
    if (policies.getGroupRacks() != null) {
      groupEntity.setGroupRacks((new Gson()).toJson(policies.getGroupRacks()));
    }
  }
  if (group.getRpNames() != null && group.getRpNames().size() > 0) {
    groupEntity.setVcRpNameList(group.getRpNames());
  }
  Set<String> roles=new LinkedHashSet<String>();
  convertStorage(group,groupEntity,roles);
  roles.addAll(group.getRoles());
  EnumSet<HadoopRole> enumRoles=getEnumRoles(group.getRoles(),distro);
  if (enumRoles.isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  groupEntity.setRoles(gson.toJson(roles));
  GroupType groupType=GroupType.fromHadoopRole(enumRoles);
  if (groupType == GroupType.CLIENT_GROUP && group.getInstanceNum() <= 0) {
    logger.warn(""String_Node_Str"" + group.getName() + ""String_Node_Str"");
    return null;
  }
  List<String> dsNames=groupEntity.getVcDatastoreNameList();
  if (dsNames == null) {
    dsNames=clusterEntity.getVcDatastoreNameList();
  }
  Set<String> sharedPattern;
  Set<String> localPattern;
  if (dsNames != null) {
    sharedPattern=datastoreMgr.getSharedDatastoresByNames(dsNames);
    localPattern=datastoreMgr.getLocalDatastoresByNames(dsNames);
  }
 else {
    sharedPattern=datastoreMgr.getAllSharedDatastores();
    localPattern=datastoreMgr.getAllLocalDatastores();
  }
  CommonClusterExpandPolicy.expandGroupInstanceType(groupEntity,groupType,sharedPattern,localPattern);
  groupEntity.setHaFlag(group.getHaFlag());
  if (group.getConfiguration() != null && group.getConfiguration().size() > 0) {
    CommonClusterExpandPolicy.validateAppConfig(group.getConfiguration(),validateWhiteList);
    groupEntity.setHadoopConfig(gson.toJson(group.getConfiguration()));
  }
  groupEntity.setVmFolderPath(clusterEntity);
  logger.debug(""String_Node_Str"" + group.getName());
  return groupEntity;
}"
48732,"private boolean containInvalidCharacter(String password){
  if (password.contains(Constants.NEW_LINE)) {
    return true;
  }
  return false;
}","private boolean containInvalidCharacter(String password){
  if (password.contains(Constants.ESCAPE_CHAR)) {
    return true;
  }
  return false;
}"
48733,"private NodeGroupEntity convertGroup(Gson gson,ClusterEntity clusterEntity,EnumSet<HadoopRole> allRoles,NodeGroupCreate group,String distro,boolean validateWhiteList){
  NodeGroupEntity groupEntity=new NodeGroupEntity();
  if (group.getRoles() == null || group.getRoles().isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  Set<String> roles=new HashSet<String>();
  groupEntity.setCluster(clusterEntity);
  int cpuNum=group.getCpuNum() == null ? 0 : group.getCpuNum();
  if (!VcVmUtil.validateCPU(clusteringService.getTemplateVmId(),cpuNum)) {
    throw VcProviderException.CPU_NUM_NOT_MULTIPLE_OF_CORES_PER_SOCKET(group.getName(),clusteringService.getTemplateVmName());
  }
  groupEntity.setCpuNum(cpuNum);
  groupEntity.setDefineInstanceNum(group.getInstanceNum());
  groupEntity.setMemorySize(group.getMemCapacityMB() == null ? 0 : group.getMemCapacityMB());
  groupEntity.setSwapRatio(group.getSwapRatio());
  groupEntity.setName(group.getName());
  groupEntity.setNodeType(group.getInstanceType());
  PlacementPolicy policies=group.getPlacementPolicies();
  if (policies != null) {
    List<GroupAssociation> associons=policies.getGroupAssociations();
    if (associons != null) {
      Set<NodeGroupAssociation> associonEntities=new TreeSet<NodeGroupAssociation>();
      for (      GroupAssociation a : associons) {
        NodeGroupAssociation ae=new NodeGroupAssociation();
        ae.setAssociationType(a.getType());
        ae.setNodeGroup(groupEntity);
        ae.setReferencedGroup(a.getReference());
        associonEntities.add(ae);
      }
      groupEntity.setGroupAssociations(associonEntities);
    }
    if (policies.getInstancePerHost() != null) {
      groupEntity.setInstancePerHost(policies.getInstancePerHost());
    }
    if (policies.getGroupRacks() != null) {
      groupEntity.setGroupRacks((new Gson()).toJson(policies.getGroupRacks()));
    }
  }
  if (group.getRpNames() != null && group.getRpNames().size() > 0) {
    groupEntity.setVcRpNameList(group.getRpNames());
  }
  convertStorage(group,groupEntity,roles);
  roles.addAll(group.getRoles());
  List<String> sortedRolesByDependency=new ArrayList<String>();
  sortedRolesByDependency.addAll(roles);
  Collections.sort(sortedRolesByDependency,new RoleComparactor());
  EnumSet<HadoopRole> enumRoles=getEnumRoles(group.getRoles(),distro);
  if (enumRoles.isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  groupEntity.setRoles(gson.toJson(sortedRolesByDependency));
  GroupType groupType=GroupType.fromHadoopRole(enumRoles);
  if (groupType == GroupType.CLIENT_GROUP && group.getInstanceNum() <= 0) {
    logger.warn(""String_Node_Str"" + group.getName() + ""String_Node_Str"");
    return null;
  }
  allRoles.addAll(enumRoles);
  List<String> dsNames=groupEntity.getVcDatastoreNameList();
  if (dsNames == null) {
    dsNames=clusterEntity.getVcDatastoreNameList();
  }
  Set<String> sharedPattern;
  Set<String> localPattern;
  if (dsNames != null) {
    sharedPattern=datastoreMgr.getSharedDatastoresByNames(dsNames);
    localPattern=datastoreMgr.getLocalDatastoresByNames(dsNames);
  }
 else {
    sharedPattern=datastoreMgr.getAllSharedDatastores();
    localPattern=datastoreMgr.getAllLocalDatastores();
  }
  CommonClusterExpandPolicy.expandGroupInstanceType(groupEntity,groupType,sharedPattern,localPattern);
  groupEntity.setHaFlag(group.getHaFlag());
  if (group.getConfiguration() != null && group.getConfiguration().size() > 0) {
    CommonClusterExpandPolicy.validateAppConfig(group.getConfiguration(),validateWhiteList);
    groupEntity.setHadoopConfig(gson.toJson(group.getConfiguration()));
  }
  groupEntity.setVmFolderPath(clusterEntity);
  logger.debug(""String_Node_Str"" + group.getName());
  return groupEntity;
}","private NodeGroupEntity convertGroup(Gson gson,ClusterEntity clusterEntity,EnumSet<HadoopRole> allRoles,NodeGroupCreate group,String distro,boolean validateWhiteList){
  NodeGroupEntity groupEntity=new NodeGroupEntity();
  if (group.getRoles() == null || group.getRoles().isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  Set<String> roles=new HashSet<String>();
  groupEntity.setCluster(clusterEntity);
  int cpuNum=group.getCpuNum() == null ? 0 : group.getCpuNum();
  if (!VcVmUtil.validateCPU(clusteringService.getTemplateVmId(),cpuNum)) {
    throw VcProviderException.CPU_NUM_NOT_MULTIPLE_OF_CORES_PER_SOCKET(group.getName(),clusteringService.getTemplateVmName());
  }
  groupEntity.setCpuNum(cpuNum);
  groupEntity.setDefineInstanceNum(group.getInstanceNum());
  groupEntity.setMemorySize(group.getMemCapacityMB() == null ? 0 : group.getMemCapacityMB());
  groupEntity.setSwapRatio(group.getSwapRatio());
  groupEntity.setName(group.getName());
  groupEntity.setNodeType(group.getInstanceType());
  PlacementPolicy policies=group.getPlacementPolicies();
  if (policies != null) {
    List<GroupAssociation> associons=policies.getGroupAssociations();
    if (associons != null) {
      Set<NodeGroupAssociation> associonEntities=new HashSet<NodeGroupAssociation>();
      for (      GroupAssociation a : associons) {
        NodeGroupAssociation ae=new NodeGroupAssociation();
        ae.setAssociationType(a.getType());
        ae.setNodeGroup(groupEntity);
        ae.setReferencedGroup(a.getReference());
        associonEntities.add(ae);
      }
      groupEntity.setGroupAssociations(associonEntities);
    }
    if (policies.getInstancePerHost() != null) {
      groupEntity.setInstancePerHost(policies.getInstancePerHost());
    }
    if (policies.getGroupRacks() != null) {
      groupEntity.setGroupRacks((new Gson()).toJson(policies.getGroupRacks()));
    }
  }
  if (group.getRpNames() != null && group.getRpNames().size() > 0) {
    groupEntity.setVcRpNameList(group.getRpNames());
  }
  convertStorage(group,groupEntity,roles);
  roles.addAll(group.getRoles());
  List<String> sortedRolesByDependency=new ArrayList<String>();
  sortedRolesByDependency.addAll(roles);
  Collections.sort(sortedRolesByDependency,new RoleComparactor());
  EnumSet<HadoopRole> enumRoles=getEnumRoles(group.getRoles(),distro);
  if (enumRoles.isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  groupEntity.setRoles(gson.toJson(sortedRolesByDependency));
  GroupType groupType=GroupType.fromHadoopRole(enumRoles);
  if (groupType == GroupType.CLIENT_GROUP && group.getInstanceNum() <= 0) {
    logger.warn(""String_Node_Str"" + group.getName() + ""String_Node_Str"");
    return null;
  }
  allRoles.addAll(enumRoles);
  List<String> dsNames=groupEntity.getVcDatastoreNameList();
  if (dsNames == null) {
    dsNames=clusterEntity.getVcDatastoreNameList();
  }
  Set<String> sharedPattern;
  Set<String> localPattern;
  if (dsNames != null) {
    sharedPattern=datastoreMgr.getSharedDatastoresByNames(dsNames);
    localPattern=datastoreMgr.getLocalDatastoresByNames(dsNames);
  }
 else {
    sharedPattern=datastoreMgr.getAllSharedDatastores();
    localPattern=datastoreMgr.getAllLocalDatastores();
  }
  CommonClusterExpandPolicy.expandGroupInstanceType(groupEntity,groupType,sharedPattern,localPattern);
  groupEntity.setHaFlag(group.getHaFlag());
  if (group.getConfiguration() != null && group.getConfiguration().size() > 0) {
    CommonClusterExpandPolicy.validateAppConfig(group.getConfiguration(),validateWhiteList);
    groupEntity.setHadoopConfig(gson.toJson(group.getConfiguration()));
  }
  groupEntity.setVmFolderPath(clusterEntity);
  logger.debug(""String_Node_Str"" + group.getName());
  return groupEntity;
}"
48734,"/** 
 * Send request to load or update a VcObject with synchronization.
 * @param moRef
 * @param waitForRequest true if the caller blocks until the request finishes.
 * @param forcedUpdates the set of forced updates on the object
 * @param forceLoad true if force fetching the object when missing the cache.
 * @return the VcObject if available, null is possible if {@code waitForRequest}is set to false.
 */
private VcObject requestObject(ManagedObjectReference moRef,boolean waitForRequest,final EnumSet<UpdateType> forcedUpdates,boolean forceLoad){
  VcObjectRequest req=null;
  boolean isNewRequest=false;
synchronized (objCache) {
    IVcCacheObject obj=objCache.get(moRef);
    if (obj instanceof VcObjectRequest) {
      req=(VcObjectRequest)obj;
      AuAssert.check(req.getMoRef().equals(moRef));
      if (forcedUpdates != null) {
        VcObjectImpl renewResult=req.addUpdates(forcedUpdates);
        if (renewResult != null) {
          obj=renewResult;
        }
      }
    }
    if (obj == null) {
      if (forceLoad) {
        req=new VcObjectRequest(objCache,moRef);
        isNewRequest=true;
      }
 else {
        return null;
      }
    }
 else     if (obj instanceof VcObject) {
      if (forcedUpdates != null) {
        req=new VcObjectRequest(objCache,(VcObjectImpl)obj,forcedUpdates);
        isNewRequest=true;
      }
 else {
        return (VcObject)obj;
      }
    }
  }
  if (isNewRequest) {
    CmsWorker.addRequest(WorkQueue.VC_QUERY_NO_DELAY,req);
  }
  if (waitForRequest) {
    return req.getResult();
  }
 else {
    return null;
  }
}","/** 
 * Send request to load or update a VcObject with synchronization.
 * @param moRef
 * @param waitForRequest true if the caller blocks until the request finishes.
 * @param forcedUpdates the set of forced updates on the object
 * @param forceLoad true if force fetching the object when missing the cache.
 * @return the VcObject if available, null is possible if {@code waitForRequest}is set to false.
 */
private VcObject requestObject(ManagedObjectReference moRef,boolean waitForRequest,final EnumSet<UpdateType> forcedUpdates,boolean forceLoad){
  VcObjectRequest req=null;
  boolean isNewRequest=false;
synchronized (objCache) {
    IVcCacheObject obj=objCache.get(moRef);
    if (obj instanceof VcObjectRequest) {
      req=(VcObjectRequest)obj;
      AuAssert.check(req.getMoRef().equals(moRef));
      if (forcedUpdates != null) {
        VcObjectImpl renewResult=req.addUpdates(forcedUpdates);
        if (renewResult != null) {
          obj=renewResult;
        }
      }
    }
    if (obj == null) {
      if (forceLoad) {
        req=new VcObjectRequest(objCache,moRef);
        isNewRequest=true;
      }
 else {
        return null;
      }
    }
 else     if (obj instanceof VcObject) {
      if (forcedUpdates != null) {
        req=new VcObjectRequest(objCache,(VcObjectImpl)obj,forcedUpdates);
        isNewRequest=true;
      }
 else {
        return (VcObject)obj;
      }
    }
  }
  if (isNewRequest) {
    CmsWorker.addRequest(WorkQueue.VC_QUERY_NO_DELAY,req);
  }
  if (waitForRequest && req != null) {
    return req.getResult();
  }
 else {
    return null;
  }
}"
48735,"private List<ManagedObjectReference> getSharedNetworkInt() throws Exception {
  List<HostSystem> hostList=MoUtil.getManagedObjects(host);
  List<ManagedObjectReference> results=new ArrayList<ManagedObjectReference>();
  ManagedObjectReference[] candidateList=null;
  HashMap<ManagedObjectReference,Integer> map=new HashMap<ManagedObjectReference,Integer>();
  if (hostList.size() == 0) {
    return results;
  }
  for (  HostSystem h : hostList) {
    ManagedObjectReference[] netMorefs=h.getNetwork();
    if (candidateList == null) {
      candidateList=netMorefs;
    }
    for (    ManagedObjectReference mo : netMorefs) {
      Integer count=map.get(mo);
      if (count != null) {
        map.put(mo,count + 1);
      }
 else {
        map.put(mo,Integer.valueOf(1));
      }
    }
  }
  for (  ManagedObjectReference mo : candidateList) {
    if (map.get(mo).equals(hostList.size())) {
      results.add(mo);
    }
  }
  return results;
}","private List<ManagedObjectReference> getSharedNetworkInt() throws Exception {
  List<HostSystem> hostList=MoUtil.getManagedObjects(host);
  List<ManagedObjectReference> results=new ArrayList<ManagedObjectReference>();
  ManagedObjectReference[] candidateList=null;
  HashMap<ManagedObjectReference,Integer> map=new HashMap<ManagedObjectReference,Integer>();
  if (hostList.size() == 0) {
    return results;
  }
  for (  HostSystem h : hostList) {
    ManagedObjectReference[] netMorefs=h.getNetwork();
    if (candidateList == null) {
      candidateList=netMorefs;
    }
    for (    ManagedObjectReference mo : netMorefs) {
      Integer count=map.get(mo);
      if (count != null) {
        map.put(mo,count + 1);
      }
 else {
        map.put(mo,Integer.valueOf(1));
      }
    }
  }
  if (candidateList != null) {
    for (    ManagedObjectReference mo : candidateList) {
      if (map.get(mo).equals(hostList.size())) {
        results.add(mo);
      }
    }
  }
  return results;
}"
48736,"private Folder getTargetFolder(NodeEntity node){
  VcVirtualMachine vm=VcCache.get(node.getMoId());
  return vm.getParentFolder();
}","private Folder getTargetFolder(final NodeEntity node){
  return VcContext.inVcSessionDo(new VcSession<Folder>(){
    @Override protected Folder body() throws Exception {
      VcVirtualMachine vm=VcCache.get(node.getMoId());
      return vm.getParentFolder();
    }
  }
);
}"
48737,"@Override public ExitStatus afterStep(StepExecution se){
  logger.info(""String_Node_Str"" + se.getStepName());
  VmEventProcessor processor=clusteringService.getEventProcessor();
  processor.tryResume();
  ExecutionContext jec=se.getJobExecution().getExecutionContext();
  if (se.getStatus().equals(BatchStatus.COMPLETED)) {
    jec.put(se.getStepName() + ""String_Node_Str"",true);
    jobExecutionStatusHolder.setCurrentStepProgress(se.getJobExecution().getId(),1);
  }
 else {
    for (    Throwable t : se.getFailureExceptions()) {
      String msg=t.getMessage();
      if (msg != null && !msg.isEmpty()) {
        TrackableTasklet.putIntoJobExecutionContext(jec,JobConstants.CURRENT_ERROR_MESSAGE,msg);
        break;
      }
    }
  }
  return se.getExitStatus();
}","@Override public ExitStatus afterStep(StepExecution se){
  logger.info(""String_Node_Str"" + se.getStepName());
  if (clusteringService != null) {
    VmEventProcessor processor=clusteringService.getEventProcessor();
    processor.tryResume();
  }
  ExecutionContext jec=se.getJobExecution().getExecutionContext();
  if (se.getStatus().equals(BatchStatus.COMPLETED)) {
    jec.put(se.getStepName() + ""String_Node_Str"",true);
    jobExecutionStatusHolder.setCurrentStepProgress(se.getJobExecution().getId(),1);
  }
 else {
    for (    Throwable t : se.getFailureExceptions()) {
      String msg=t.getMessage();
      if (msg != null && !msg.isEmpty()) {
        TrackableTasklet.putIntoJobExecutionContext(jec,JobConstants.CURRENT_ERROR_MESSAGE,msg);
        break;
      }
    }
  }
  return se.getExitStatus();
}"
48738,"private String switchMobId(String moId,VcVirtualMachine vm) throws Exception {
  if (vm.getConfig().getFtInfo() != null) {
    vm.update();
    if (vm.getConfig().getFtInfo().getRole() != 1) {
      FaultToleranceSecondaryConfigInfo ftInfo=(FaultToleranceSecondaryConfigInfo)vm.getConfig().getFtInfo();
      moId=MoUtil.morefToString(ftInfo.getPrimaryVM());
      logger.info(""String_Node_Str"" + moId);
    }
  }
  return moId;
}","private String switchMobId(String moId,VcVirtualMachine vm) throws Exception {
  if (vm.getConfig() != null && vm.getConfig().getFtInfo() != null) {
    vm.update();
    if (vm.getConfig().getFtInfo().getRole() != 1) {
      FaultToleranceSecondaryConfigInfo ftInfo=(FaultToleranceSecondaryConfigInfo)vm.getConfig().getFtInfo();
      moId=MoUtil.morefToString(ftInfo.getPrimaryVM());
      logger.info(""String_Node_Str"" + moId);
    }
  }
  return moId;
}"
48739,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void setParam(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String clusterName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String elasticityMode,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final Integer minComputeNodeNum,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final Integer maxComputeNodeNum,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final Integer targetComputeNodeNum,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String ioShares){
  try {
    ClusterRead cluster=restClient.get(clusterName,false);
    if (cluster == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterName,Constants.OUTPUT_OP_SET_PARAM,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"" + clusterName + ""String_Node_Str"");
      return;
    }
    if (elasticityMode != null || minComputeNodeNum != null || maxComputeNodeNum != null || targetComputeNodeNum != null) {
      if (!cluster.validateSetManualElasticity()) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterName,Constants.OUTPUT_OP_SET_PARAM,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_SHOULD_HAVE_COMPUTE_ONLY_GROUP);
        return;
      }
    }
 else     if (ioShares == null) {
      System.out.println(""String_Node_Str"");
      return;
    }
    ElasticityMode mode=null;
    if (elasticityMode != null) {
      try {
        mode=ElasticityMode.valueOf(elasticityMode.toUpperCase());
      }
 catch (      IllegalArgumentException e) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterName,Constants.OUTPUT_OP_SET_PARAM,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + elasticityMode);
        return;
      }
    }
    Boolean enableAuto=null;
    if (mode != null) {
      enableAuto=(mode == ElasticityMode.AUTO) ? true : false;
    }
    if (!cluster.validateSetParamParameters(targetComputeNodeNum,minComputeNodeNum,maxComputeNodeNum)) {
      return;
    }
    Priority ioPriority=null;
    if (ioShares != null) {
      try {
        ioPriority=Priority.valueOf(ioShares.toUpperCase());
      }
 catch (      IllegalArgumentException ex) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterName,Constants.OUTPUT_OP_SET_PARAM,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ ioShares);
        return;
      }
    }
    ElasticityRequestBody requestBody=new ElasticityRequestBody();
    requestBody.setEnableAuto(enableAuto);
    if (mode != null) {
      if (mode == ElasticityMode.AUTO) {
        requestBody.setMinComputeNodeNum(minComputeNodeNum);
        requestBody.setMaxComputeNodeNum(maxComputeNodeNum);
      }
 else {
        requestBody.setActiveComputeNodeNum(targetComputeNodeNum);
      }
    }
 else {
      requestBody.setMinComputeNodeNum(minComputeNodeNum);
      requestBody.setMaxComputeNodeNum(maxComputeNodeNum);
      requestBody.setActiveComputeNodeNum(targetComputeNodeNum);
    }
    requestBody.setIoPriority(ioPriority);
    restClient.setParam(cluster,requestBody);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,clusterName,Constants.OUTPUT_OP_RESULT_ADJUST);
    if (mode != null) {
      if (mode == ElasticityMode.AUTO) {
        if (targetComputeNodeNum != null) {
          System.out.println(""String_Node_Str"");
        }
      }
 else {
        if (minComputeNodeNum != null || maxComputeNodeNum != null) {
          System.out.println(""String_Node_Str"");
        }
      }
    }
  }
 catch (  CliRestException e) {
    if (e.getMessage() != null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterName,Constants.OUTPUT_OP_SET_PARAM,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    }
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void setParam(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String clusterName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String elasticityMode,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final Integer minComputeNodeNum,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final Integer maxComputeNodeNum,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final Integer targetComputeNodeNum,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String ioShares){
  try {
    ClusterRead cluster=restClient.get(clusterName,false);
    if (cluster == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterName,Constants.OUTPUT_OP_SET_PARAM,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"" + clusterName + ""String_Node_Str"");
      return;
    }
    if (elasticityMode != null || minComputeNodeNum != null || maxComputeNodeNum != null || targetComputeNodeNum != null) {
      if (!cluster.validateSetManualElasticity()) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterName,Constants.OUTPUT_OP_SET_PARAM,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_SHOULD_HAVE_COMPUTE_ONLY_GROUP);
        return;
      }
    }
 else     if (ioShares == null) {
      System.out.println(""String_Node_Str"");
      return;
    }
    ElasticityMode mode=null;
    if (elasticityMode != null) {
      try {
        mode=ElasticityMode.valueOf(elasticityMode.toUpperCase());
      }
 catch (      IllegalArgumentException e) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterName,Constants.OUTPUT_OP_SET_PARAM,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + elasticityMode);
        return;
      }
    }
    Boolean enableAuto=null;
    if (mode != null) {
      enableAuto=(mode == ElasticityMode.AUTO) ? true : false;
    }
    try {
      if (!cluster.validateSetParamParameters(targetComputeNodeNum,minComputeNodeNum,maxComputeNodeNum)) {
        return;
      }
    }
 catch (    Exception e) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterName,Constants.OUTPUT_OP_SET_PARAM,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
      return;
    }
    Priority ioPriority=null;
    if (ioShares != null) {
      try {
        ioPriority=Priority.valueOf(ioShares.toUpperCase());
      }
 catch (      IllegalArgumentException ex) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterName,Constants.OUTPUT_OP_SET_PARAM,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ ioShares);
        return;
      }
    }
    ElasticityRequestBody requestBody=new ElasticityRequestBody();
    requestBody.setEnableAuto(enableAuto);
    if (mode != null) {
      if (mode == ElasticityMode.AUTO) {
        requestBody.setMinComputeNodeNum(minComputeNodeNum);
        requestBody.setMaxComputeNodeNum(maxComputeNodeNum);
      }
 else {
        requestBody.setActiveComputeNodeNum(targetComputeNodeNum);
      }
    }
 else {
      requestBody.setMinComputeNodeNum(minComputeNodeNum);
      requestBody.setMaxComputeNodeNum(maxComputeNodeNum);
      requestBody.setActiveComputeNodeNum(targetComputeNodeNum);
    }
    requestBody.setIoPriority(ioPriority);
    restClient.setParam(cluster,requestBody);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,clusterName,Constants.OUTPUT_OP_RESULT_ADJUST);
    if (mode != null) {
      if (mode == ElasticityMode.AUTO) {
        if (targetComputeNodeNum != null) {
          System.out.println(""String_Node_Str"");
        }
      }
 else {
        if (minComputeNodeNum != null || maxComputeNodeNum != null) {
          System.out.println(""String_Node_Str"");
        }
      }
    }
  }
 catch (  CliRestException e) {
    if (e.getMessage() != null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterName,Constants.OUTPUT_OP_SET_PARAM,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    }
  }
}"
48740,"private void addDatastoreEntity(final DatastoreType type,final List<String> datastores,final String name,final boolean regex){
  if (dsDao.nameExisted(name)) {
    throw BddException.ALREADY_EXISTS(""String_Node_Str"",name);
  }
  resService.refreshDatastore();
  for (  String ds : datastores) {
    String dsPattern=ds;
    if (!regex) {
      dsPattern=CommonUtil.getDatastoreJavaPattern(ds);
    }
    if (!resService.isDatastoreExistInVC(dsPattern)) {
      throw VcProviderException.DATASTORE_NOT_FOUND(ds);
    }
    VcDatastoreEntity entity=new VcDatastoreEntity();
    entity.setType(type);
    entity.setName(name);
    entity.setVcDatastore(ds);
    entity.setRegex(regex);
    dsDao.insert(entity);
    logger.info(""String_Node_Str"" + ds);
  }
}","private void addDatastoreEntity(final DatastoreType type,final List<String> datastores,final String name,final boolean regex){
  if (dsDao.nameExisted(name)) {
    throw BddException.ALREADY_EXISTS(""String_Node_Str"",name);
  }
  resService.refreshDatastore();
  for (  String ds : datastores) {
    String dsPattern=ds;
    if (!regex) {
      dsPattern=CommonUtil.getDatastoreJavaPattern(ds);
    }
    if (!resService.isDatastoreExistInVC(dsPattern)) {
      throw VcProviderException.DATASTORE_NOT_FOUND(ds);
    }
    VcDatastoreEntity entity=new VcDatastoreEntity();
    entity.setType(type);
    entity.setName(name);
    entity.setVcDatastore(ds);
    entity.setRegex(regex);
    dsDao.insert(entity);
    logger.info(""String_Node_Str"" + type + ""String_Node_Str""+ ds);
  }
}"
48741,"/** 
 * Get the datastore path for a file under the VM directory on a different datastore. The file would be either at the root of the datastore name-prefixed with the VM name or in a directory with same name as the VM directory.
 * @param vm virtual machine object
 * @param ds datastore (null means the default VM datastore)
 * @param name file name
 * @return
 */
public static String getDsPath(VcVirtualMachine vm,VcDatastore ds,String name){
  if (ds == null) {
    return getDsPath(vm,name);
  }
 else {
    try {
      return String.format(""String_Node_Str"",ds.getURLName(),dropDsFromPath(vm.getPathName()).trim(),name);
    }
 catch (    Exception ex) {
      throw BaseVMException.INVALID_FILE_PATH(ex,vm.getPathName());
    }
  }
}","/** 
 * Get the datastore path for a file under the VM directory on a different datastore. The file would be either at the root of the datastore name-prefixed with the VM name or in a directory with same name as the VM directory.
 * @param vm virtual machine object
 * @param ds datastore (null means the default VM datastore)
 * @param name file name
 * @return
 */
public static String getDsPath(VcVirtualMachine vm,VcDatastore ds,String name){
  if (ds == null) {
    return getDsPath(vm,name);
  }
 else {
    try {
      return String.format(""String_Node_Str"",ds.getName());
    }
 catch (    Exception ex) {
      throw BaseVMException.INVALID_FILE_PATH(ex,vm.getPathName());
    }
  }
}"
48742,"public static void setString(String key,String value){
  config.setProperty(key,value);
  if (vcCfg.containsKey(key)) {
    vcCfg.setProperty(key,value);
  }
 else   if (serengetiCfg.containsKey(key)) {
    serengetiCfg.setProperty(key,value);
  }
}","public static void setString(String key,String value){
  config.setProperty(key,value);
  if (vcCfg.containsKey(key)) {
    vcCfg.setProperty(key,value);
  }
 else {
    serengetiCfg.setProperty(key,value);
  }
}"
48743,"/** 
 * Set the boolean value of a given key
 * @param key
 * @param value
 */
public static void setBoolean(String key,Boolean value){
  config.setProperty(key,value);
  if (vcCfg.containsKey(key)) {
    vcCfg.setProperty(key,value);
  }
 else   if (serengetiCfg.containsKey(key)) {
    serengetiCfg.setProperty(key,value);
  }
}","/** 
 * Set the boolean value of a given key
 * @param key
 * @param value
 */
public static void setBoolean(String key,Boolean value){
  config.setProperty(key,value);
  if (vcCfg.containsKey(key)) {
    vcCfg.setProperty(key,value);
  }
 else {
    serengetiCfg.setProperty(key,value);
  }
}"
48744,"/** 
 * This sends a URL POST request to the Extension vService guest API to register a new extension. Upon success, set vcExtensionRegistered to true. Note that the extension will not be fully configured until we log in to VC as this extension and make some VMODL calls to finish the job. Note also that we only need to do this once per CMS install, not once per CMS startup, but it doesn't seem to hurt to do it every time.
 * @synchronized for preventing concurrent call to register EVS.
 */
private static synchronized void registerExtensionVService(){
  if (vcExtensionRegistered) {
    return;
  }
  logger.debug(""String_Node_Str"" + evsURL + ""String_Node_Str""+ evsToken);
  Writer output=null;
  BufferedReader input=null;
  try {
    Certificate cert=CmsKeyStore.getCertificate(CmsKeyStore.VC_EXT_KEY);
    URL url=new URL(evsURL);
    URLConnection connection=url.openConnection();
    connection.setRequestProperty(""String_Node_Str"",evsToken);
    connection.setDoInput(true);
    connection.setDoOutput(true);
    connection.setUseCaches(false);
    output=new OutputStreamWriter(connection.getOutputStream());
    String evsSchema=""String_Node_Str"";
    String payload=""String_Node_Str"" + evsSchema + ""String_Node_Str""+ ""String_Node_Str""+ extKey+ ""String_Node_Str""+ ""String_Node_Str""+ CertificateToPem(cert)+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    output.write(payload);
    output.flush();
    connection.connect();
    Map<String,List<String>> headers=connection.getHeaderFields();
    for (    Map.Entry<String,List<String>> e : headers.entrySet()) {
      for (      String val : e.getValue()) {
        logger.info(""String_Node_Str"" + e.getKey() + ""String_Node_Str""+ val);
      }
    }
    input=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    for (String str=input.readLine(); str != null; str=input.readLine()) {
      logger.debug(""String_Node_Str"" + str);
    }
    vcExtensionRegistered=true;
    logger.debug(""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + evsURL,e);
  }
 finally {
    if (output != null) {
      try {
        output.close();
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"",e);
      }
    }
    if (input != null) {
      try {
        input.close();
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"",e);
      }
    }
  }
}","/** 
 * This sends a URL POST request to the Extension vService guest API to register a new extension. Upon success, set vcExtensionRegistered to true. Note that the extension will not be fully configured until we log in to VC as this extension and make some VMODL calls to finish the job. Note also that we only need to do this once per CMS install, not once per CMS startup, but it doesn't seem to hurt to do it every time.
 * @synchronized for preventing concurrent call to register EVS.
 */
private static synchronized void registerExtensionVService(){
  if (vcExtensionRegistered) {
    return;
  }
  logger.debug(""String_Node_Str"" + evsURL + ""String_Node_Str""+ evsToken);
  Writer output=null;
  BufferedReader input=null;
  try {
    Certificate cert=CmsKeyStore.getCertificate(CmsKeyStore.VC_EXT_KEY);
    URL url=new URL(evsURL);
    URLConnection connection=url.openConnection();
    connection.setRequestProperty(""String_Node_Str"",evsToken);
    connection.setDoInput(true);
    connection.setDoOutput(true);
    connection.setUseCaches(false);
    output=new OutputStreamWriter(connection.getOutputStream());
    String evsSchema=""String_Node_Str"";
    String payload=""String_Node_Str"" + evsSchema + ""String_Node_Str""+ ""String_Node_Str""+ extKey+ ""String_Node_Str""+ ""String_Node_Str""+ CertificateToPem(cert)+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    output.write(payload);
    output.flush();
    connection.connect();
    Map<String,List<String>> headers=connection.getHeaderFields();
    for (    Map.Entry<String,List<String>> e : headers.entrySet()) {
      for (      String val : e.getValue()) {
        logger.info(""String_Node_Str"" + e.getKey() + ""String_Node_Str""+ val);
      }
    }
    input=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    for (String str=input.readLine(); str != null; str=input.readLine()) {
      logger.debug(""String_Node_Str"" + str);
    }
    vcExtensionRegistered=true;
    Configuration.setBoolean(SERENGETI_EXTENSION_REGISTERED,true);
    Configuration.save();
    logger.debug(""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + evsURL,e);
  }
 finally {
    if (output != null) {
      try {
        output.close();
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"",e);
      }
    }
    if (input != null) {
      try {
        input.close();
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"",e);
      }
    }
  }
}"
48745,"private static void initVcConfig(){
  vcHost=Configuration.getString(""String_Node_Str"");
  vcPort=Configuration.getInt(""String_Node_Str"",443);
  evsURL=Configuration.getString(""String_Node_Str"");
  evsToken=Configuration.getString(""String_Node_Str"");
  vcThumbprint=Configuration.getString(""String_Node_Str"",null);
  extKey=""String_Node_Str"" + Configuration.getCmsInstanceId();
  userName=Configuration.getString(""String_Node_Str"",null);
  password=Configuration.getString(""String_Node_Str"",null);
  locale=Configuration.getString(""String_Node_Str"",""String_Node_Str"");
  HttpsConnectionUtil.init(vcThumbprint);
  configured=true;
}","private static void initVcConfig(){
  vcHost=Configuration.getString(""String_Node_Str"");
  vcPort=Configuration.getInt(""String_Node_Str"",443);
  evsURL=Configuration.getString(""String_Node_Str"");
  evsToken=Configuration.getString(""String_Node_Str"");
  vcThumbprint=Configuration.getString(""String_Node_Str"",null);
  extKey=""String_Node_Str"" + Configuration.getCmsInstanceId();
  vcExtensionRegistered=Configuration.getBoolean(SERENGETI_EXTENSION_REGISTERED,false);
  userName=Configuration.getString(""String_Node_Str"",null);
  password=Configuration.getString(""String_Node_Str"",null);
  locale=Configuration.getString(""String_Node_Str"",""String_Node_Str"");
  HttpsConnectionUtil.init(vcThumbprint);
  configured=true;
}"
48746,"private void configureExtensionVService() throws Exception {
  ExtensionManager em=service.extensionManager;
  Extension us=em.findExtension(extKey);
  AuAssert.check(us != null);
  Description desc=new DescriptionImpl();
  desc.setLabel(""String_Node_Str"");
  desc.setSummary(""String_Node_Str"" + Configuration.getCmsInstanceId());
  us.setDescription(desc);
  us.setCompany(""String_Node_Str"");
  us.setShownInSolutionManager(true);
  ManagedEntityInfo info=new ManagedEntityInfoImpl();
  info.setType(""String_Node_Str"");
  info.setDescription(""String_Node_Str"");
  ManagedEntityInfo[] infos=new ManagedEntityInfo[1];
  infos[0]=info;
  us.setManagedEntityInfo(infos);
  Extension.ResourceInfo extensionResourceInfo=new ExtensionImpl.ResourceInfoImpl();
  extensionResourceInfo.setLocale(""String_Node_Str"");
  extensionResourceInfo.setModule(""String_Node_Str"");
  KeyValue localizedExt[]=new KeyValue[2];
  localizedExt[0]=new KeyValueImpl();
  localizedExt[0].setKey(us.getKey() + ""String_Node_Str"");
  localizedExt[0].setValue(us.getDescription().getLabel());
  localizedExt[1]=new KeyValueImpl();
  localizedExt[1].setKey(us.getKey() + ""String_Node_Str"");
  localizedExt[1].setValue(us.getDescription().getSummary());
  extensionResourceInfo.setData(localizedExt);
  Extension.ResourceInfo eventResourceInfo=new ExtensionImpl.ResourceInfoImpl();
  eventResourceInfo.setLocale(""String_Node_Str"");
  eventResourceInfo.setModule(""String_Node_Str"");
class KeyValueList extends ArrayList<KeyValue> {
    public void add(    String key,    String value){
      KeyValue pair=new KeyValueImpl();
      pair.setKey(key);
      pair.setValue(value);
      super.add(pair);
    }
  }
  ;
  KeyValueList resourceInfo=new KeyValueList();
  ArrayList<Extension.EventTypeInfo> eventTypes=new ArrayList<Extension.EventTypeInfo>();
  for (  EventSeverity severity : Event.EventSeverity.values()) {
    resourceInfo.add(""String_Node_Str"" + severity.name() + ""String_Node_Str"",""String_Node_Str"");
    resourceInfo.add(""String_Node_Str"" + severity.name() + ""String_Node_Str"",""String_Node_Str"");
    resourceInfo.add(""String_Node_Str"" + severity.name() + ""String_Node_Str"",severity.name());
    resourceInfo.add(""String_Node_Str"" + severity.name() + ""String_Node_Str"",""String_Node_Str"");
    resourceInfo.add(""String_Node_Str"" + severity.name() + ""String_Node_Str"",""String_Node_Str"");
    Extension.EventTypeInfo event=new ExtensionImpl.EventTypeInfoImpl();
    event.setEventID(""String_Node_Str"" + severity.name());
    event.setEventTypeSchema(""String_Node_Str"" + severity.name() + ""String_Node_Str"");
    eventTypes.add(event);
  }
  eventResourceInfo.setData(resourceInfo.toArray(new KeyValue[0]));
  us.setResourceList(new Extension.ResourceInfo[]{extensionResourceInfo,eventResourceInfo});
  us.setEventList(eventTypes.toArray(new Extension.EventTypeInfo[0]));
  us.setShownInSolutionManager(true);
  em.updateExtension(us);
}","private void configureExtensionVService() throws Exception {
  ExtensionManager em=service.extensionManager;
  Extension us=em.findExtension(extKey);
  AuAssert.check(us != null);
  Description desc=new DescriptionImpl();
  desc.setLabel(""String_Node_Str"");
  desc.setSummary(""String_Node_Str"" + Configuration.getCmsInstanceId());
  us.setDescription(desc);
  us.setCompany(""String_Node_Str"");
  us.setShownInSolutionManager(true);
  ExtendedProductInfo extInfo=new ExtendedProductInfoImpl();
  extInfo.setCompanyUrl(""String_Node_Str"");
  us.setExtendedProductInfo(extInfo);
  ManagedEntityInfo info=new ManagedEntityInfoImpl();
  info.setType(""String_Node_Str"");
  info.setDescription(""String_Node_Str"");
  ManagedEntityInfo[] infos=new ManagedEntityInfo[1];
  infos[0]=info;
  us.setManagedEntityInfo(infos);
  Extension.ResourceInfo extensionResourceInfo=new ExtensionImpl.ResourceInfoImpl();
  extensionResourceInfo.setLocale(""String_Node_Str"");
  extensionResourceInfo.setModule(""String_Node_Str"");
  KeyValue localizedExt[]=new KeyValue[2];
  localizedExt[0]=new KeyValueImpl();
  localizedExt[0].setKey(us.getKey() + ""String_Node_Str"");
  localizedExt[0].setValue(us.getDescription().getLabel());
  localizedExt[1]=new KeyValueImpl();
  localizedExt[1].setKey(us.getKey() + ""String_Node_Str"");
  localizedExt[1].setValue(us.getDescription().getSummary());
  extensionResourceInfo.setData(localizedExt);
  Extension.ResourceInfo eventResourceInfo=new ExtensionImpl.ResourceInfoImpl();
  eventResourceInfo.setLocale(""String_Node_Str"");
  eventResourceInfo.setModule(""String_Node_Str"");
class KeyValueList extends ArrayList<KeyValue> {
    public void add(    String key,    String value){
      KeyValue pair=new KeyValueImpl();
      pair.setKey(key);
      pair.setValue(value);
      super.add(pair);
    }
  }
  ;
  KeyValueList resourceInfo=new KeyValueList();
  ArrayList<Extension.EventTypeInfo> eventTypes=new ArrayList<Extension.EventTypeInfo>();
  for (  EventSeverity severity : Event.EventSeverity.values()) {
    resourceInfo.add(""String_Node_Str"" + severity.name() + ""String_Node_Str"",""String_Node_Str"");
    resourceInfo.add(""String_Node_Str"" + severity.name() + ""String_Node_Str"",""String_Node_Str"");
    resourceInfo.add(""String_Node_Str"" + severity.name() + ""String_Node_Str"",severity.name());
    resourceInfo.add(""String_Node_Str"" + severity.name() + ""String_Node_Str"",""String_Node_Str"");
    resourceInfo.add(""String_Node_Str"" + severity.name() + ""String_Node_Str"",""String_Node_Str"");
    Extension.EventTypeInfo event=new ExtensionImpl.EventTypeInfoImpl();
    event.setEventID(""String_Node_Str"" + severity.name());
    event.setEventTypeSchema(""String_Node_Str"" + severity.name() + ""String_Node_Str"");
    eventTypes.add(event);
  }
  eventResourceInfo.setData(resourceInfo.toArray(new KeyValue[0]));
  us.setResourceList(new Extension.ResourceInfo[]{extensionResourceInfo,eventResourceInfo});
  us.setEventList(eventTypes.toArray(new Extension.EventTypeInfo[0]));
  us.setShownInSolutionManager(true);
  SolutionManagerInfo sm=new SolutionManagerInfoImpl();
  sm.setSmallIconUrl(""String_Node_Str"");
  us.setSolutionManagerInfo(sm);
  em.updateExtension(us);
}"
48747,"public void setRegex(Boolean regex){
  if (regex != null && regex) {
    this.regex=""String_Node_Str"";
  }
 else {
    this.regex=""String_Node_Str"";
  }
}","public void setRegex(String regex){
  this.regex=regex;
}"
48748,"@Override @Transactional(readOnly=true) public List<DatastoreRead> getAllDatastoreReads(){
  logger.debug(""String_Node_Str"");
  List<VcDatastoreEntity> entities=dsDao.findAllSortByName();
  List<DatastoreRead> result=new ArrayList<DatastoreRead>();
  if (entities.isEmpty()) {
    return result;
  }
  DatastoreRead read=new DatastoreRead();
  read.setName(entities.get(0).getName());
  read.setType(entities.get(0).getType());
  read.setRegex(entities.get(0).getRegex());
  read.setDatastoreReadDetails(new ArrayList<DatastoreReadDetail>());
  result.add(read);
  for (  VcDatastoreEntity entity : entities) {
    if (!entity.getName().equals(read.getName())) {
      read=new DatastoreRead();
      read.setName(entity.getName());
      read.setType(entity.getType());
      read.setRegex(entity.getRegex());
      read.setDatastoreReadDetails(new ArrayList<DatastoreReadDetail>());
      result.add(read);
    }
    DatastoreReadDetail detail=new DatastoreReadDetail();
    detail.setVcDatastoreName(entity.getVcDatastore());
    read.getDatastoreReadDetails().add(detail);
  }
  logger.debug(""String_Node_Str"" + result);
  return result;
}","@Override @Transactional(readOnly=true) public List<DatastoreRead> getAllDatastoreReads(){
  logger.debug(""String_Node_Str"");
  List<VcDatastoreEntity> entities=dsDao.findAllSortByName();
  List<DatastoreRead> result=new ArrayList<DatastoreRead>();
  if (entities.isEmpty()) {
    return result;
  }
  DatastoreRead read=new DatastoreRead();
  read.setName(entities.get(0).getName());
  read.setType(entities.get(0).getType());
  read.setRegexByBoolean(entities.get(0).getRegex());
  read.setDatastoreReadDetails(new ArrayList<DatastoreReadDetail>());
  result.add(read);
  for (  VcDatastoreEntity entity : entities) {
    if (!entity.getName().equals(read.getName())) {
      read=new DatastoreRead();
      read.setName(entity.getName());
      read.setType(entity.getType());
      read.setRegexByBoolean(entity.getRegex());
      read.setDatastoreReadDetails(new ArrayList<DatastoreReadDetail>());
      result.add(read);
    }
    DatastoreReadDetail detail=new DatastoreReadDetail();
    detail.setVcDatastoreName(entity.getVcDatastore());
    read.getDatastoreReadDetails().add(detail);
  }
  logger.debug(""String_Node_Str"" + result);
  return result;
}"
48749,"@Override @Transactional(readOnly=true) public DatastoreRead getDatastoreRead(String name){
  logger.debug(""String_Node_Str"" + name);
  List<VcDatastoreEntity> entities=dsDao.findByName(name);
  if (entities.isEmpty()) {
    return null;
  }
  DatastoreRead read=new DatastoreRead();
  read.setName(name);
  read.setType(entities.get(0).getType());
  read.setRegex(entities.get(0).getRegex());
  read.setDatastoreReadDetails(new ArrayList<DatastoreReadDetail>());
  for (  VcDatastoreEntity entity : entities) {
    DatastoreReadDetail detail=new DatastoreReadDetail();
    detail.setVcDatastoreName(entity.getVcDatastore());
    read.getDatastoreReadDetails().add(detail);
  }
  logger.debug(""String_Node_Str"" + read);
  return read;
}","@Override @Transactional(readOnly=true) public DatastoreRead getDatastoreRead(String name){
  logger.debug(""String_Node_Str"" + name);
  List<VcDatastoreEntity> entities=dsDao.findByName(name);
  if (entities.isEmpty()) {
    return null;
  }
  DatastoreRead read=new DatastoreRead();
  read.setName(name);
  read.setType(entities.get(0).getType());
  read.setRegexByBoolean(entities.get(0).getRegex());
  read.setDatastoreReadDetails(new ArrayList<DatastoreReadDetail>());
  for (  VcDatastoreEntity entity : entities) {
    DatastoreReadDetail detail=new DatastoreReadDetail();
    detail.setVcDatastoreName(entity.getVcDatastore());
    read.getDatastoreReadDetails().add(detail);
  }
  logger.debug(""String_Node_Str"" + read);
  return read;
}"
48750,"/** 
 * Blocking wait for task completion. Wait on task's monitor until a notification of a task completion by VcEventListener thread.
 * @return the VC object as a result of this task.
 * @exception on failure
 */
public synchronized VcObject waitForCompletion() throws Exception {
  Task task=getManagedObject();
  StatsType oldSrc=Profiler.pushInc(StatsType.VC_TASK_WAIT,getType());
  long lastWaitStartedNanos;
  long waitFinishedNanos=System.nanoTime();
  state=task.getInfo().getState();
  totalWaitTimeNanos=0;
  while (state != State.success) {
    boolean normalWaitCompletion=false;
switch (state) {
case success:
      break;
case error:
    completionTimeNanos=waitFinishedNanos;
  logTaskError(task);
assistBadTaskCompletion();
throw task.getInfo().getError();
case queued:
case running:
lastWaitStartedNanos=System.nanoTime();
try {
isWaiting=true;
wait(TimeUnit.NANOSECONDS.toMillis(getWaitIntervalNanos()));
normalWaitCompletion=true;
}
 catch (InterruptedException e) {
}
 finally {
isWaiting=false;
waitFinishedNanos=System.nanoTime();
lastWaitTimeNanos=waitFinishedNanos - lastWaitStartedNanos;
totalWaitTimeNanos+=lastWaitTimeNanos;
}
break;
default :
AuAssert.check(false);
}
state=task.getInfo().getState();
verifyWaitCompletion(normalWaitCompletion);
}
AuAssert.check(taskCompleted());
logger.debug(""String_Node_Str"" + type + ""String_Node_Str"");
completionTimeNanos=waitFinishedNanos;
assistBadTaskCompletion();
if (!(type.getTargetClass() == Void.class)) {
taskResult=task.getInfo().getResult();
if (taskResult instanceof ManagedObjectReference) {
if (type == TaskType.Snapshot) {
VcVirtualMachineImpl vm=(VcVirtualMachineImpl)parent;
vm.update();
result=vm.getSnapshot((ManagedObjectReference)taskResult);
}
 else {
result=VcCache.load((ManagedObjectReference)taskResult);
if (type == TaskType.CloneVm || type == TaskType.CreateVm) {
VcVirtualMachineImpl vm=(VcVirtualMachineImpl)result;
vm.refreshRP();
}
}
AuAssert.check(type.getTargetClass().isInstance(result));
}
 else if (taskResult != null) {
AuAssert.check(type.getTargetClass().isInstance(taskResult));
}
}
invokeCallbacks(true);
Profiler.pop(oldSrc);
return result;
}","/** 
 * Blocking wait for task completion. Wait on task's monitor until a notification of a task completion by VcEventListener thread.
 * @return the VC object as a result of this task.
 * @exception on failure
 */
public synchronized VcObject waitForCompletion() throws Exception {
  totalWaitTimeNanos=0;
  Exception catchedException=null;
  for (int i=0; i < maxRetryNum; i++) {
    try {
      return waitForCompletionIntenal();
    }
 catch (    Exception e) {
      catchedException=e;
      if (VcUtil.isRecoverableException(e)) {
        wait(TimeUnit.NANOSECONDS.toMillis(getWaitIntervalNanos()));
        continue;
      }
      throw e;
    }
  }
  throw catchedException;
}"
48751,"/** 
 * A way to call ""VC pseudo-tasks"". Pseudo-tasks should have been tasks, but aren't for some strange reasons. Example: ResourcePool.updateConfig().
 * @param name       pseudo-task name
 * @param eventType  expected completion event
 * @param refId      target for expected event
 * @param obj        code to execute
 * @return moref returned by the task
 * @throws Exception
 */
public ManagedObjectReference execPseudoTask(String name,VcEventType eventType,ManagedObjectReference moRef,IVcPseudoTaskBody obj) throws Exception {
  AuAssert.check(eventType != null);
  AuAssert.check(VcContext.isInTaskSession());
  VcPseudoTask task=pseudoTaskStarted(name,eventType,moRef);
  Profiler.inc(StatsType.VC_TASK_EXEC,task.getName());
  ManagedObjectReference res=null;
  try {
    res=obj.body();
  }
 catch (  Exception e) {
    pseudoTaskFailed(task);
    VcCache.refreshAll(moRef);
    throw e;
  }
  return res;
}","/** 
 * A way to call ""VC pseudo-tasks"". Pseudo-tasks should have been tasks, but aren't for some strange reasons. Example: ResourcePool.updateConfig().
 * @param name       pseudo-task name
 * @param eventType  expected completion event
 * @param refId      target for expected event
 * @param obj        code to execute
 * @return moref returned by the task
 * @throws Exception
 */
public ManagedObjectReference execPseudoTask(String name,VcEventType eventType,ManagedObjectReference moRef,IVcPseudoTaskBody obj) throws Exception {
  Exception catchedException=null;
  for (int i=0; i < MaxRetryNum; i++) {
    try {
      return execPseudoTaskInternal(name,eventType,moRef,obj);
    }
 catch (    Exception e) {
      catchedException=e;
      if (VcUtil.isRecoverableException(e)) {
        logger.debug(""String_Node_Str"" + obj,e);
        wait(waitInterval);
        continue;
      }
      throw e;
    }
  }
  throw catchedException;
}"
48752,"/** 
 * Safely execute the task specified by IVcTaskBody object. This is the only safe way to execute tasks to avoid lost completion notifications. A read lock is held until a task moRef is received from VC.
 * @param taskObj   task object
 * @return VcTask    task handle
 * @throws Exception
 */
public VcTask execute(IVcTaskBody taskObj) throws Exception {
  AuAssert.check(VcContext.isInTaskSession());
  VcTask task=null;
  rwLock.readLock().lock();
  try {
    task=taskObj.body();
    Profiler.inc(StatsType.VC_TASK_EXEC,task.getType());
    taskStarted(task);
  }
  finally {
    rwLock.readLock().unlock();
  }
  return task;
}","/** 
 * Safely execute the task specified by IVcTaskBody object. This is the only safe way to execute tasks to avoid lost completion notifications. A read lock is held until a task moRef is received from VC.
 * @param taskObj   task object
 * @return VcTask    task handle
 * @throws Exception
 */
public VcTask execute(IVcTaskBody taskObj) throws Exception {
  Exception catchedException=null;
  for (int i=0; i < MaxRetryNum; i++) {
    try {
      return executeInternal(taskObj);
    }
 catch (    Exception e) {
      catchedException=e;
      if (VcUtil.isRecoverableException(e)) {
        logger.debug(""String_Node_Str"" + taskObj,e);
        wait(waitInterval);
        continue;
      }
      throw e;
    }
  }
  throw catchedException;
}"
48753,"private boolean containInvalidCharacter(String password){
  if (password.contains(Constants.NEW_LINE)) {
    return true;
  }
  return false;
}","private boolean containInvalidCharacter(String password){
  if (password.contains(Constants.ESCAPE_CHAR)) {
    return true;
  }
  return false;
}"
48754,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void setParam(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String clusterName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String elasticityMode,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final Integer minComputeNodeNum,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final Integer maxComputeNodeNum,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final Integer targetComputeNodeNum,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String ioShares){
  try {
    ClusterRead cluster=restClient.get(clusterName,false);
    if (cluster == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterName,Constants.OUTPUT_OP_SET_PARAM,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"" + clusterName + ""String_Node_Str"");
      return;
    }
    if (elasticityMode != null || minComputeNodeNum != null || maxComputeNodeNum != null || targetComputeNodeNum != null) {
      if (!cluster.validateSetManualElasticity()) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterName,Constants.OUTPUT_OP_SET_PARAM,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_SHOULD_HAVE_COMPUTE_ONLY_GROUP);
        return;
      }
    }
 else     if (ioShares == null) {
      return;
    }
    ElasticityMode mode=null;
    if (elasticityMode != null) {
      try {
        mode=ElasticityMode.valueOf(elasticityMode.toUpperCase());
      }
 catch (      IllegalArgumentException e) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterName,Constants.OUTPUT_OP_SET_PARAM,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + elasticityMode);
        return;
      }
    }
    Boolean enableAuto=null;
    if (mode != null) {
      enableAuto=(mode == ElasticityMode.AUTO) ? true : false;
    }
    if (!cluster.validateSetParamParameters(targetComputeNodeNum,minComputeNodeNum,maxComputeNodeNum)) {
      return;
    }
    Priority ioPriority=null;
    if (ioShares != null) {
      try {
        ioPriority=Priority.valueOf(ioShares.toUpperCase());
      }
 catch (      IllegalArgumentException ex) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterName,Constants.OUTPUT_OP_SET_PARAM,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ ioShares);
        return;
      }
    }
    ElasticityRequestBody requestBody=new ElasticityRequestBody();
    requestBody.setEnableAuto(enableAuto);
    if (mode != null) {
      if (mode == ElasticityMode.AUTO) {
        requestBody.setMinComputeNodeNum(minComputeNodeNum);
        requestBody.setMaxComputeNodeNum(maxComputeNodeNum);
      }
 else {
        requestBody.setActiveComputeNodeNum(targetComputeNodeNum);
      }
    }
 else {
      requestBody.setMinComputeNodeNum(minComputeNodeNum);
      requestBody.setMaxComputeNodeNum(maxComputeNodeNum);
      requestBody.setActiveComputeNodeNum(targetComputeNodeNum);
    }
    requestBody.setIoPriority(ioPriority);
    restClient.setParam(cluster,requestBody);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,clusterName,Constants.OUTPUT_OP_RESULT_ADJUST);
    if (mode != null) {
      if (mode == ElasticityMode.AUTO) {
        if (targetComputeNodeNum != null) {
          System.out.println(""String_Node_Str"");
        }
      }
 else {
        if (minComputeNodeNum != null || maxComputeNodeNum != null) {
          System.out.println(""String_Node_Str"");
        }
      }
    }
  }
 catch (  CliRestException e) {
    if (e.getMessage() != null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterName,Constants.OUTPUT_OP_SET_PARAM,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    }
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void setParam(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String clusterName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String elasticityMode,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final Integer minComputeNodeNum,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final Integer maxComputeNodeNum,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final Integer targetComputeNodeNum,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String ioShares){
  try {
    ClusterRead cluster=restClient.get(clusterName,false);
    if (cluster == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterName,Constants.OUTPUT_OP_SET_PARAM,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"" + clusterName + ""String_Node_Str"");
      return;
    }
    if (elasticityMode != null || minComputeNodeNum != null || maxComputeNodeNum != null || targetComputeNodeNum != null) {
      if (!cluster.validateSetManualElasticity()) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterName,Constants.OUTPUT_OP_SET_PARAM,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_SHOULD_HAVE_COMPUTE_ONLY_GROUP);
        return;
      }
    }
 else     if (ioShares == null) {
      System.out.println(""String_Node_Str"");
      return;
    }
    ElasticityMode mode=null;
    if (elasticityMode != null) {
      try {
        mode=ElasticityMode.valueOf(elasticityMode.toUpperCase());
      }
 catch (      IllegalArgumentException e) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterName,Constants.OUTPUT_OP_SET_PARAM,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + elasticityMode);
        return;
      }
    }
    Boolean enableAuto=null;
    if (mode != null) {
      enableAuto=(mode == ElasticityMode.AUTO) ? true : false;
    }
    if (!cluster.validateSetParamParameters(targetComputeNodeNum,minComputeNodeNum,maxComputeNodeNum)) {
      return;
    }
    Priority ioPriority=null;
    if (ioShares != null) {
      try {
        ioPriority=Priority.valueOf(ioShares.toUpperCase());
      }
 catch (      IllegalArgumentException ex) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterName,Constants.OUTPUT_OP_SET_PARAM,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ ioShares);
        return;
      }
    }
    ElasticityRequestBody requestBody=new ElasticityRequestBody();
    requestBody.setEnableAuto(enableAuto);
    if (mode != null) {
      if (mode == ElasticityMode.AUTO) {
        requestBody.setMinComputeNodeNum(minComputeNodeNum);
        requestBody.setMaxComputeNodeNum(maxComputeNodeNum);
      }
 else {
        requestBody.setActiveComputeNodeNum(targetComputeNodeNum);
      }
    }
 else {
      requestBody.setMinComputeNodeNum(minComputeNodeNum);
      requestBody.setMaxComputeNodeNum(maxComputeNodeNum);
      requestBody.setActiveComputeNodeNum(targetComputeNodeNum);
    }
    requestBody.setIoPriority(ioPriority);
    restClient.setParam(cluster,requestBody);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,clusterName,Constants.OUTPUT_OP_RESULT_ADJUST);
    if (mode != null) {
      if (mode == ElasticityMode.AUTO) {
        if (targetComputeNodeNum != null) {
          System.out.println(""String_Node_Str"");
        }
      }
 else {
        if (minComputeNodeNum != null || maxComputeNodeNum != null) {
          System.out.println(""String_Node_Str"");
        }
      }
    }
  }
 catch (  CliRestException e) {
    if (e.getMessage() != null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,clusterName,Constants.OUTPUT_OP_SET_PARAM,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    }
  }
}"
48755,"public boolean execCmd(String user,String privateKeyFile,String hostIP,int sshPort,String command,InputStream in,OutputStream out){
  AuAssert.check(command != null);
  connect(user,privateKeyFile,hostIP,sshPort);
  ChannelExec channel=null;
  logger.info(""String_Node_Str"");
  BufferedReader bufferedReader=null;
  try {
    channel=(ChannelExec)session.openChannel(""String_Node_Str"");
    if (channel != null) {
      logger.debug(""String_Node_Str"");
      channel.setPty(true);
      channel.setCommand(command);
      channel.setInputStream(in);
      channel.setOutputStream(out);
      bufferedReader=new BufferedReader(new InputStreamReader(channel.getInputStream()));
      channel.connect();
      if (!channel.isConnected()) {
        logger.error(""String_Node_Str"");
      }
      StringBuilder buff=new StringBuilder();
      while (true) {
        String line=bufferedReader.readLine();
        buff.append(line);
        if (channel.isClosed()) {
          int exitStatus=channel.getExitStatus();
          logger.debug(""String_Node_Str"" + exitStatus);
          logger.debug(""String_Node_Str"" + buff.toString());
          if (exitStatus == 0) {
            return true;
          }
          return false;
        }
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException e) {
        }
      }
    }
 else {
      logger.error(""String_Node_Str"" + hostIP + ""String_Node_Str"");
      return false;
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  JSchException e) {
    e.printStackTrace();
  }
 finally {
    if (channel != null && channel.isConnected()) {
      channel.disconnect();
    }
    if (session != null && channel.isConnected()) {
      session.disconnect();
    }
    try {
      bufferedReader.close();
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"" + e.getMessage());
    }
  }
  return false;
}","public boolean execCmd(String user,String privateKeyFile,String hostIP,int sshPort,String command,InputStream in,OutputStream out){
  AuAssert.check(command != null);
  connect(user,privateKeyFile,hostIP,sshPort);
  ChannelExec channel=null;
  logger.info(""String_Node_Str"");
  try {
    channel=(ChannelExec)session.openChannel(""String_Node_Str"");
    if (channel != null) {
      logger.debug(""String_Node_Str"");
      channel.setPty(true);
      channel.setCommand(command);
      channel.setInputStream(in);
      channel.setOutputStream(out);
      channel.connect();
      if (!channel.isConnected()) {
        logger.error(""String_Node_Str"");
      }
      while (true) {
        if (channel.isClosed()) {
          int exitStatus=channel.getExitStatus();
          logger.debug(""String_Node_Str"" + exitStatus);
          if (exitStatus == 0) {
            return true;
          }
          return false;
        }
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException e) {
        }
      }
    }
 else {
      logger.error(""String_Node_Str"" + hostIP + ""String_Node_Str"");
      return false;
    }
  }
 catch (  JSchException e) {
    e.printStackTrace();
  }
 finally {
    if (channel != null && channel.isConnected()) {
      channel.disconnect();
    }
    if (session != null && channel.isConnected()) {
      session.disconnect();
    }
  }
  return false;
}"
48756,"public boolean execCmd(String user,String privateKeyFile,String hostIP,int sshPort,String command,InputStream in,OutputStream out){
  AuAssert.check(command != null);
  connect(user,privateKeyFile,hostIP,sshPort);
  ChannelExec channel=null;
  logger.info(""String_Node_Str"");
  BufferedReader bufferedReader=null;
  try {
    channel=(ChannelExec)session.openChannel(""String_Node_Str"");
    if (channel != null) {
      logger.debug(""String_Node_Str"");
      channel.setPty(true);
      channel.setCommand(command);
      channel.setInputStream(in);
      channel.setOutputStream(out);
      bufferedReader=new BufferedReader(new InputStreamReader(channel.getInputStream()));
      channel.connect();
      if (!channel.isConnected()) {
        logger.error(""String_Node_Str"");
      }
      StringBuilder buff=new StringBuilder();
      while (true) {
        String line=bufferedReader.readLine();
        buff.append(line);
        if (channel.isClosed()) {
          int exitStatus=channel.getExitStatus();
          logger.debug(""String_Node_Str"" + exitStatus);
          logger.debug(""String_Node_Str"" + buff.toString());
          if (exitStatus == 0) {
            return true;
          }
          return false;
        }
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException e) {
        }
      }
    }
 else {
      logger.error(""String_Node_Str"" + hostIP + ""String_Node_Str"");
      return false;
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  JSchException e) {
    e.printStackTrace();
  }
 finally {
    if (channel != null && channel.isConnected()) {
      channel.disconnect();
    }
    if (session != null && channel.isConnected()) {
      session.disconnect();
    }
    try {
      bufferedReader.close();
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"" + e.getMessage());
    }
  }
  return false;
}","public boolean execCmd(String user,String privateKeyFile,String hostIP,int sshPort,String command,InputStream in,OutputStream out){
  AuAssert.check(command != null);
  connect(user,privateKeyFile,hostIP,sshPort);
  ChannelExec channel=null;
  logger.info(""String_Node_Str"");
  try {
    channel=(ChannelExec)session.openChannel(""String_Node_Str"");
    if (channel != null) {
      logger.debug(""String_Node_Str"");
      channel.setPty(true);
      channel.setCommand(command);
      channel.setInputStream(in);
      channel.setOutputStream(out);
      channel.connect();
      if (!channel.isConnected()) {
        logger.error(""String_Node_Str"");
      }
      while (true) {
        if (channel.isClosed()) {
          int exitStatus=channel.getExitStatus();
          logger.debug(""String_Node_Str"" + exitStatus);
          if (exitStatus == 0) {
            return true;
          }
          return false;
        }
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException e) {
        }
      }
    }
 else {
      logger.error(""String_Node_Str"" + hostIP + ""String_Node_Str"");
      return false;
    }
  }
 catch (  JSchException e) {
    e.printStackTrace();
  }
 finally {
    if (channel != null && channel.isConnected()) {
      channel.disconnect();
    }
    if (session != null && channel.isConnected()) {
      session.disconnect();
    }
  }
  return false;
}"
48757,"@Override public Void call() throws Exception {
  long start=System.currentTimeMillis();
  vm=VcCache.getIgnoreMissing(vmId);
  while (System.currentTimeMillis() - start < timeout) {
    boolean stop=VcContext.inVcSessionDo(new VcSession<Boolean>(){
      @Override protected Boolean body() throws Exception {
        if (vm != null && vm.isPoweredOn()) {
          return false;
        }
 else {
          logger.info(""String_Node_Str"" + ""String_Node_Str"");
          return true;
        }
      }
    }
);
    int found=0;
    for (    String pgName : portGroups) {
      String ip=VcVmUtil.getIpAddressOfPortGroup(vm,pgName,false);
      if (!ip.equals(Constants.NULL_IPV4_ADDRESS)) {
        logger.info(""String_Node_Str"" + vmId + ""String_Node_Str""+ pgName+ ""String_Node_Str""+ ip);
        found+=1;
      }
    }
    if (found == portGroups.size()) {
      break;
    }
    if (stop) {
      break;
    }
    Thread.sleep(checkPeriod);
  }
  return null;
}","@Override public Void call() throws Exception {
  long start=System.currentTimeMillis();
  vm=VcCache.getIgnoreMissing(vmId);
  while (System.currentTimeMillis() - start < timeout) {
    boolean stop=VcContext.inVcSessionDo(new VcSession<Boolean>(){
      @Override protected Boolean body() throws Exception {
        if (vm != null && vm.isPoweredOn()) {
          return false;
        }
 else {
          logger.info(""String_Node_Str"" + ""String_Node_Str"");
          return true;
        }
      }
    }
);
    int found=0;
    for (    String pgName : portGroups) {
      String ip=VcVmUtil.getIpAddressOfPortGroup(vm,pgName,false);
      if (!ip.equals(Constants.NULL_IPV4_ADDRESS)) {
        logger.info(""String_Node_Str"" + vm.getName() + ""String_Node_Str""+ pgName+ ""String_Node_Str""+ ip);
        found+=1;
      }
    }
    if (found == portGroups.size()) {
      break;
    }
    if (stop) {
      break;
    }
    Thread.sleep(checkPeriod);
  }
  return null;
}"
48758,"/** 
 * Blocking wait for task completion. Wait on task's monitor until a notification of a task completion by VcEventListener thread.
 * @return the VC object as a result of this task.
 * @exception on failure
 */
public synchronized VcObject waitForCompletion() throws Exception {
  totalWaitTimeNanos=0;
  Exception catchedException=null;
  for (int i=0; i < maxRetryNum; i++) {
    try {
      return waitForCompletionIntenal();
    }
 catch (    Exception e) {
      catchedException=e;
      if (VcUtil.isRecoverableException(e)) {
        wait(TimeUnit.NANOSECONDS.toMillis(getWaitIntervalNanos()));
        continue;
      }
      throw e;
    }
  }
  throw catchedException;
}","/** 
 * Blocking wait for task completion. Wait on task's monitor until a notification of a task completion by VcEventListener thread.
 * @return the VC object as a result of this task.
 * @exception on failure
 */
public synchronized VcObject waitForCompletion() throws Exception {
  totalWaitTimeNanos=0;
  Exception catchedException=null;
  for (int i=0; i < maxRetryNum; i++) {
    try {
      return waitForCompletionIntenal();
    }
 catch (    Exception e) {
      catchedException=e;
      if (VcUtil.isRecoverableException(e)) {
        wait(TimeUnit.NANOSECONDS.toMillis(badTaskWaitIntervalNanos));
        continue;
      }
      throw e;
    }
  }
  throw catchedException;
}"
48759,"/** 
 * A way to call ""VC pseudo-tasks"". Pseudo-tasks should have been tasks, but aren't for some strange reasons. Example: ResourcePool.updateConfig().
 * @param name       pseudo-task name
 * @param eventType  expected completion event
 * @param refId      target for expected event
 * @param obj        code to execute
 * @return moref returned by the task
 * @throws Exception
 */
public ManagedObjectReference execPseudoTask(String name,VcEventType eventType,ManagedObjectReference moRef,IVcPseudoTaskBody obj) throws Exception {
  Exception catchedException=null;
  for (int i=0; i < MaxRetryNum; i++) {
    try {
      return execPseudoTaskInternal(name,eventType,moRef,obj);
    }
 catch (    Exception e) {
      catchedException=e;
      if (VcUtil.isRecoverableException(e)) {
        logger.debug(""String_Node_Str"" + obj,e);
        wait(waitInterval);
        continue;
      }
      throw e;
    }
  }
  throw catchedException;
}","/** 
 * A way to call ""VC pseudo-tasks"". Pseudo-tasks should have been tasks, but aren't for some strange reasons. Example: ResourcePool.updateConfig().
 * @param name       pseudo-task name
 * @param eventType  expected completion event
 * @param refId      target for expected event
 * @param obj        code to execute
 * @return moref returned by the task
 * @throws Exception
 */
public ManagedObjectReference execPseudoTask(String name,VcEventType eventType,ManagedObjectReference moRef,IVcPseudoTaskBody obj) throws Exception {
  Exception catchedException=null;
  for (int i=0; i < maxRetryNum; i++) {
    try {
      return execPseudoTaskInternal(name,eventType,moRef,obj);
    }
 catch (    Exception e) {
      catchedException=e;
      if (VcUtil.isRecoverableException(e) && (i < maxRetryNum - 1)) {
        logger.debug(""String_Node_Str"" + name,e);
        wait(waitInterval);
        logger.info(""String_Node_Str"" + name + ""String_Node_Str""+ (i + 1)+ ""String_Node_Str"");
        continue;
      }
      throw e;
    }
  }
  throw catchedException;
}"
48760,"/** 
 * Safely execute the task specified by IVcTaskBody object. This is the only safe way to execute tasks to avoid lost completion notifications. A read lock is held until a task moRef is received from VC.
 * @param taskObj   task object
 * @return VcTask    task handle
 * @throws Exception
 */
public VcTask execute(IVcTaskBody taskObj) throws Exception {
  Exception catchedException=null;
  for (int i=0; i < MaxRetryNum; i++) {
    try {
      return executeInternal(taskObj);
    }
 catch (    Exception e) {
      catchedException=e;
      if (VcUtil.isRecoverableException(e)) {
        logger.debug(""String_Node_Str"" + taskObj,e);
        wait(waitInterval);
        continue;
      }
      throw e;
    }
  }
  throw catchedException;
}","/** 
 * Safely execute the task specified by IVcTaskBody object. This is the only safe way to execute tasks to avoid lost completion notifications. A read lock is held until a task moRef is received from VC.
 * @param taskObj   task object
 * @return VcTask    task handle
 * @throws Exception
 */
public VcTask execute(IVcTaskBody taskObj) throws Exception {
  Exception catchedException=null;
  for (int i=0; i < maxRetryNum; i++) {
    try {
      return executeInternal(taskObj);
    }
 catch (    Exception e) {
      catchedException=e;
      if (VcUtil.isRecoverableException(e) && (i < maxRetryNum - 1)) {
        logger.debug(""String_Node_Str"" + taskObj.body().getId(),e);
        wait(waitInterval);
        logger.info(""String_Node_Str"" + taskObj.body().getId() + ""String_Node_Str""+ (i + 1)+ ""String_Node_Str"");
        continue;
      }
      throw e;
    }
  }
  throw catchedException;
}"
48761,"public static boolean isRecoverableException(Throwable e){
  return (e instanceof SSLPeerUnverifiedException || e instanceof SocketTimeoutException);
}","public static boolean isRecoverableException(Throwable e){
  return (e instanceof SSLPeerUnverifiedException || e instanceof SocketTimeoutException || e instanceof HostCommunication);
}"
48762,"@Test public void testSupportedWithHdfs2(){
  ClusterCreate cluster=new ClusterCreate();
  cluster.setDistroVendor(Constants.DEFAULT_VENDOR);
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(false,cluster.supportedWithHdfs2());
  cluster.setDistroVendor(Constants.CDH_VENDOR);
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(false,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(false,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(false,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(true,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(true,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(true,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(true,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(true,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(true,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(false,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(false,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(false,cluster.supportedWithHdfs2());
  cluster.setDistroVendor(Constants.PHD_VENDOR);
  assertEquals(true,cluster.supportedWithHdfs2());
}","@Test public void testSupportedWithHdfs2(){
  ClusterCreate cluster=new ClusterCreate();
  cluster.setDistroVendor(Constants.DEFAULT_VENDOR);
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(false,cluster.supportedWithHdfs2());
  cluster.setDistroVendor(Constants.CDH_VENDOR);
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(true,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(true,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(true,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(true,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(true,cluster.supportedWithHdfs2());
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(true,cluster.supportedWithHdfs2());
  cluster.setDistroVendor(Constants.GPHD_VENDOR);
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(false,cluster.supportedWithHdfs2());
  cluster.setDistroVendor(Constants.MAPR_VENDOR);
  cluster.setDistroVersion(""String_Node_Str"");
  assertEquals(false,cluster.supportedWithHdfs2());
  cluster.setDistroVendor(Constants.PHD_VENDOR);
  assertEquals(true,cluster.supportedWithHdfs2());
}"
48763,"@Override public void checkServerTrusted(X509Certificate[] chain,String authType) throws CertificateException {
  String errorMsg=""String_Node_Str"";
  char[] pwd=""String_Node_Str"".toCharArray();
  try {
    File file=new File(""String_Node_Str"");
    if (file.isFile() == false) {
      char SEP=File.separatorChar;
      File dir=new File(System.getProperty(""String_Node_Str"") + SEP + ""String_Node_Str""+ SEP+ ""String_Node_Str"");
      file=new File(dir,""String_Node_Str"");
      if (file.isFile() == false) {
        file=new File(dir,""String_Node_Str"");
      }
    }
    InputStream in=new FileInputStream(file);
    keyStore.load(in,pwd);
    if (in != null) {
      in.close();
    }
    MessageDigest sha1=MessageDigest.getInstance(""String_Node_Str"");
    MessageDigest md5=MessageDigest.getInstance(""String_Node_Str"");
    String md5Fingerprint=""String_Node_Str"";
    String sha1Fingerprint=""String_Node_Str"";
    SimpleDateFormat dateFormate=new SimpleDateFormat(""String_Node_Str"");
    for (int i=0; i < chain.length; i++) {
      X509Certificate cert=chain[i];
      sha1.update(cert.getEncoded());
      md5.update(cert.getEncoded());
      md5Fingerprint=toHexString(md5.digest());
      sha1Fingerprint=toHexString(sha1.digest());
      if (keyStore.getCertificate(md5Fingerprint) != null) {
        if (i == chain.length - 1) {
          return;
        }
 else {
          continue;
        }
      }
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"" + cert.getSubjectDN());
      System.out.println(""String_Node_Str"" + cert.getIssuerDN());
      System.out.println(""String_Node_Str"" + sha1Fingerprint);
      System.out.println(""String_Node_Str"" + md5Fingerprint);
      System.out.println(""String_Node_Str"" + dateFormate.format(cert.getNotBefore()));
      System.out.println(""String_Node_Str"" + dateFormate.format(cert.getNotAfter()));
      System.out.println(""String_Node_Str"" + cert.getSignature());
      System.out.println();
      ConsoleReader reader=new ConsoleReader();
      reader.setDefaultPrompt(Constants.PARAM_PROMPT_ADD_CERTIFICATE_MESSAGE);
      String readMsg=""String_Node_Str"";
      if (RunWayConfig.getRunType().equals(RunType.MANUAL)) {
        readMsg=reader.readLine();
      }
 else {
        readMsg=""String_Node_Str"";
      }
      if (!readMsg.trim().equalsIgnoreCase(""String_Node_Str"") && !readMsg.trim().equalsIgnoreCase(""String_Node_Str"")) {
        if (i == chain.length - 1) {
          throw new CertificateException(""String_Node_Str"");
        }
 else {
          continue;
        }
      }
      keyStore.setCertificateEntry(md5Fingerprint,cert);
      OutputStream out=new FileOutputStream(""String_Node_Str"");
      keyStore.store(out,pwd);
      if (out != null) {
        out.close();
      }
    }
  }
 catch (  FileNotFoundException e) {
    errorMsg=""String_Node_Str"" + e.getMessage();
  }
catch (  NoSuchAlgorithmException e) {
    errorMsg=""String_Node_Str"" + e.getMessage();
  }
catch (  IOException e) {
    errorMsg=""String_Node_Str"" + e.getMessage();
  }
catch (  KeyStoreException e) {
    errorMsg=""String_Node_Str"" + e.getMessage();
  }
 finally {
    if (!CommandsUtils.isBlank(errorMsg)) {
      System.out.println(errorMsg);
      logger.error(errorMsg);
    }
  }
}","@Override public void checkServerTrusted(X509Certificate[] chain,String authType) throws CertificateException {
  String errorMsg=""String_Node_Str"";
  char[] pwd=""String_Node_Str"".toCharArray();
  InputStream in=null;
  OutputStream out=null;
  try {
    File file=new File(""String_Node_Str"");
    if (file.isFile() == false) {
      char SEP=File.separatorChar;
      File dir=new File(System.getProperty(""String_Node_Str"") + SEP + ""String_Node_Str""+ SEP+ ""String_Node_Str"");
      file=new File(dir,""String_Node_Str"");
      if (file.isFile() == false) {
        file=new File(dir,""String_Node_Str"");
      }
    }
    in=new FileInputStream(file);
    keyStore.load(in,pwd);
    MessageDigest sha1=MessageDigest.getInstance(""String_Node_Str"");
    MessageDigest md5=MessageDigest.getInstance(""String_Node_Str"");
    String md5Fingerprint=""String_Node_Str"";
    String sha1Fingerprint=""String_Node_Str"";
    SimpleDateFormat dateFormate=new SimpleDateFormat(""String_Node_Str"");
    for (int i=0; i < chain.length; i++) {
      X509Certificate cert=chain[i];
      sha1.update(cert.getEncoded());
      md5.update(cert.getEncoded());
      md5Fingerprint=toHexString(md5.digest());
      sha1Fingerprint=toHexString(sha1.digest());
      if (keyStore.getCertificate(md5Fingerprint) != null) {
        if (i == chain.length - 1) {
          return;
        }
 else {
          continue;
        }
      }
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"" + cert.getSubjectDN());
      System.out.println(""String_Node_Str"" + cert.getIssuerDN());
      System.out.println(""String_Node_Str"" + sha1Fingerprint);
      System.out.println(""String_Node_Str"" + md5Fingerprint);
      System.out.println(""String_Node_Str"" + dateFormate.format(cert.getNotBefore()));
      System.out.println(""String_Node_Str"" + dateFormate.format(cert.getNotAfter()));
      System.out.println(""String_Node_Str"" + cert.getSignature());
      System.out.println();
      ConsoleReader reader=new ConsoleReader();
      reader.setDefaultPrompt(Constants.PARAM_PROMPT_ADD_CERTIFICATE_MESSAGE);
      String readMsg=""String_Node_Str"";
      if (RunWayConfig.getRunType().equals(RunType.MANUAL)) {
        readMsg=reader.readLine();
      }
 else {
        readMsg=""String_Node_Str"";
      }
      if (!readMsg.trim().equalsIgnoreCase(""String_Node_Str"") && !readMsg.trim().equalsIgnoreCase(""String_Node_Str"")) {
        if (i == chain.length - 1) {
          throw new CertificateException(""String_Node_Str"");
        }
 else {
          continue;
        }
      }
      keyStore.setCertificateEntry(md5Fingerprint,cert);
      out=new FileOutputStream(""String_Node_Str"");
      keyStore.store(out,pwd);
    }
  }
 catch (  FileNotFoundException e) {
    errorMsg=""String_Node_Str"" + e.getMessage();
  }
catch (  NoSuchAlgorithmException e) {
    errorMsg=""String_Node_Str"" + e.getMessage();
  }
catch (  IOException e) {
    errorMsg=""String_Node_Str"" + e.getMessage();
  }
catch (  KeyStoreException e) {
    errorMsg=""String_Node_Str"" + e.getMessage();
  }
 finally {
    if (!CommandsUtils.isBlank(errorMsg)) {
      System.out.println(errorMsg);
      logger.error(errorMsg);
    }
    if (in != null) {
      try {
        in.close();
      }
 catch (      IOException e) {
        logger.warn(""String_Node_Str"");
      }
    }
    if (out != null) {
      try {
        out.close();
      }
 catch (      IOException e) {
        logger.warn(""String_Node_Str"");
      }
    }
  }
}"
48764,"public boolean execCmd(String user,String privateKeyFile,String hostIP,int sshPort,String command,InputStream in,OutputStream out){
  AuAssert.check(command != null);
  connect(user,privateKeyFile,hostIP,sshPort);
  ChannelExec channel=null;
  BufferedReader in=null;
  logger.info(""String_Node_Str"");
  BufferedReader bufferedReader=null;
  try {
    channel=(ChannelExec)session.openChannel(""String_Node_Str"");
    if (channel != null) {
      logger.debug(""String_Node_Str"");
      channel.setPty(true);
      channel.setCommand(command);
      channel.setInputStream(in);
      channel.setOutputStream(out);
      bufferedReader=new BufferedReader(new InputStreamReader(channel.getInputStream()));
      channel.connect();
      if (!channel.isConnected()) {
        logger.error(""String_Node_Str"");
      }
      StringBuilder buff=new StringBuilder();
      while (true) {
        String line=bufferedReader.readLine();
        buff.append(line);
        if (channel.isClosed()) {
          int exitStatus=channel.getExitStatus();
          logger.debug(""String_Node_Str"" + exitStatus);
          logger.debug(""String_Node_Str"" + buff.toString());
          if (exitStatus == 0) {
            return true;
          }
          return false;
        }
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException e) {
        }
      }
    }
 else {
      logger.error(""String_Node_Str"" + hostIP + ""String_Node_Str"");
      return false;
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  JSchException e) {
    e.printStackTrace();
  }
 finally {
    if (channel != null && channel.isConnected()) {
      channel.disconnect();
    }
    if (session != null && channel.isConnected()) {
      session.disconnect();
    }
    try {
      bufferedReader.close();
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"" + e.getMessage());
    }
  }
  return false;
}","public boolean execCmd(String user,String privateKeyFile,String hostIP,int sshPort,String command,InputStream in,OutputStream out){
  AuAssert.check(command != null);
  connect(user,privateKeyFile,hostIP,sshPort);
  ChannelExec channel=null;
  logger.info(""String_Node_Str"");
  BufferedReader bufferedReader=null;
  try {
    channel=(ChannelExec)session.openChannel(""String_Node_Str"");
    if (channel != null) {
      logger.debug(""String_Node_Str"");
      channel.setPty(true);
      channel.setCommand(command);
      channel.setInputStream(in);
      channel.setOutputStream(out);
      bufferedReader=new BufferedReader(new InputStreamReader(channel.getInputStream()));
      channel.connect();
      if (!channel.isConnected()) {
        logger.error(""String_Node_Str"");
      }
      StringBuilder buff=new StringBuilder();
      while (true) {
        String line=bufferedReader.readLine();
        buff.append(line);
        if (channel.isClosed()) {
          int exitStatus=channel.getExitStatus();
          logger.debug(""String_Node_Str"" + exitStatus);
          logger.debug(""String_Node_Str"" + buff.toString());
          if (exitStatus == 0) {
            return true;
          }
          return false;
        }
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException e) {
        }
      }
    }
 else {
      logger.error(""String_Node_Str"" + hostIP + ""String_Node_Str"");
      return false;
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  JSchException e) {
    e.printStackTrace();
  }
 finally {
    if (channel != null && channel.isConnected()) {
      channel.disconnect();
    }
    if (session != null && channel.isConnected()) {
      session.disconnect();
    }
    try {
      bufferedReader.close();
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"" + e.getMessage());
    }
  }
  return false;
}"
48765,"private String getMaprActiveJobTrackerIp(final String maprNodeIP,final String clusterName){
  String activeJobTrackerIp=""String_Node_Str"";
  String errorMsg=""String_Node_Str"";
  JSch jsch=new JSch();
  String sshUser=Configuration.getString(""String_Node_Str"",""String_Node_Str"");
  int sshPort=Configuration.getInt(""String_Node_Str"",22);
  String prvKeyFile=Configuration.getString(""String_Node_Str"",""String_Node_Str"");
  ChannelExec channel=null;
  try {
    Session session=jsch.getSession(sshUser,maprNodeIP,sshPort);
    jsch.addIdentity(prvKeyFile);
    java.util.Properties config=new java.util.Properties();
    config.put(""String_Node_Str"",""String_Node_Str"");
    session.setConfig(config);
    session.setTimeout(15000);
    session.connect();
    logger.debug(""String_Node_Str"");
    channel=(ChannelExec)session.openChannel(""String_Node_Str"");
    if (channel != null) {
      logger.debug(""String_Node_Str"");
      StringBuffer buff=new StringBuffer();
      String cmd=""String_Node_Str"";
      logger.debug(""String_Node_Str"" + cmd);
      channel.setPty(true);
      channel.setCommand(""String_Node_Str"" + cmd);
      BufferedReader in=new BufferedReader(new InputStreamReader(channel.getInputStream()));
      channel.connect();
      if (!canChannelConnect(channel)) {
        errorMsg=""String_Node_Str"";
        logger.error(errorMsg);
        throw BddException.INTERNAL(null,errorMsg);
      }
      while (true) {
        String line=in.readLine();
        buff.append(line);
        logger.debug(""String_Node_Str"" + line);
        if (channel.isClosed()) {
          int exitStatus=channel.getExitStatus();
          logger.debug(""String_Node_Str"" + exitStatus);
          break;
        }
      }
      in.close();
      Pattern ipPattern=Pattern.compile(Constants.IP_PATTERN);
      Matcher matcher=ipPattern.matcher(buff.toString());
      if (matcher.find()) {
        activeJobTrackerIp=matcher.group();
      }
 else {
        errorMsg=""String_Node_Str"" + clusterName;
        logger.error(errorMsg);
        throw BddException.INTERNAL(null,errorMsg);
      }
    }
 else {
      errorMsg=""String_Node_Str"";
      logger.error(errorMsg);
      throw BddException.INTERNAL(null,errorMsg);
    }
  }
 catch (  JSchException e) {
    errorMsg=""String_Node_Str"" + e.getMessage();
    logger.error(errorMsg);
    throw BddException.INTERNAL(null,errorMsg);
  }
catch (  IOException e) {
    errorMsg=""String_Node_Str"" + e.getMessage();
    logger.error(errorMsg);
    throw BddException.INTERNAL(null,errorMsg);
  }
 finally {
    channel.disconnect();
  }
  return activeJobTrackerIp;
}","private String getMaprActiveJobTrackerIp(final String maprNodeIP,final String clusterName){
  String activeJobTrackerIp=""String_Node_Str"";
  String errorMsg=""String_Node_Str"";
  JSch jsch=new JSch();
  String sshUser=Configuration.getString(""String_Node_Str"",""String_Node_Str"");
  int sshPort=Configuration.getInt(""String_Node_Str"",22);
  String prvKeyFile=Configuration.getString(""String_Node_Str"",""String_Node_Str"");
  Session session=null;
  ChannelExec channel=null;
  BufferedReader in=null;
  try {
    session=jsch.getSession(sshUser,maprNodeIP,sshPort);
    jsch.addIdentity(prvKeyFile);
    java.util.Properties config=new java.util.Properties();
    config.put(""String_Node_Str"",""String_Node_Str"");
    session.setConfig(config);
    session.setTimeout(15000);
    session.connect();
    logger.debug(""String_Node_Str"");
    channel=(ChannelExec)session.openChannel(""String_Node_Str"");
    if (channel != null) {
      logger.debug(""String_Node_Str"");
      StringBuffer buff=new StringBuffer();
      String cmd=""String_Node_Str"";
      logger.debug(""String_Node_Str"" + cmd);
      channel.setPty(true);
      channel.setCommand(""String_Node_Str"" + cmd);
      in=new BufferedReader(new InputStreamReader(channel.getInputStream()));
      channel.connect();
      if (!canChannelConnect(channel)) {
        errorMsg=""String_Node_Str"";
        logger.error(errorMsg);
        throw BddException.INTERNAL(null,errorMsg);
      }
      while (true) {
        String line=in.readLine();
        buff.append(line);
        logger.debug(""String_Node_Str"" + line);
        if (channel.isClosed()) {
          int exitStatus=channel.getExitStatus();
          logger.debug(""String_Node_Str"" + exitStatus);
          break;
        }
      }
      Pattern ipPattern=Pattern.compile(Constants.IP_PATTERN);
      Matcher matcher=ipPattern.matcher(buff.toString());
      if (matcher.find()) {
        activeJobTrackerIp=matcher.group();
      }
 else {
        errorMsg=""String_Node_Str"" + clusterName;
        logger.error(errorMsg);
        throw BddException.INTERNAL(null,errorMsg);
      }
    }
 else {
      errorMsg=""String_Node_Str"";
      logger.error(errorMsg);
      throw BddException.INTERNAL(null,errorMsg);
    }
  }
 catch (  JSchException e) {
    errorMsg=""String_Node_Str"" + e.getMessage();
    logger.error(errorMsg);
    throw BddException.INTERNAL(null,errorMsg);
  }
catch (  IOException e) {
    errorMsg=""String_Node_Str"" + e.getMessage();
    logger.error(errorMsg);
    throw BddException.INTERNAL(null,errorMsg);
  }
 finally {
    if (channel != null && channel.isConnected()) {
      channel.disconnect();
    }
    if (session != null && session.isConnected()) {
      session.disconnect();
    }
    if (in != null) {
      try {
        in.close();
      }
 catch (      IOException e) {
        errorMsg=""String_Node_Str"" + e.getMessage();
        logger.error(errorMsg);
      }
    }
  }
  return activeJobTrackerIp;
}"
48766,"/** 
 * Load and create cluster from spec file
 * @return cluster spec
 */
public static ClusterCreate loadFromFile(File file) throws FileNotFoundException {
  Reader fileReader=new FileReader(file);
  Gson gson=new Gson();
  return gson.fromJson(fileReader,ClusterCreate.class);
}","/** 
 * Load and create cluster from spec file
 * @return cluster spec
 */
public static ClusterCreate loadFromFile(File file) throws FileNotFoundException {
  Reader fileReader=null;
  try {
    fileReader=new FileReader(file);
    Gson gson=new Gson();
    return gson.fromJson(fileReader,ClusterCreate.class);
  }
  finally {
    if (fileReader != null) {
      try {
        fileReader.close();
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"" + e.getMessage());
      }
    }
  }
}"
48767,"public boolean execCmd(String user,String privateKeyFile,String hostIP,int sshPort,String command){
  AuAssert.check(command != null);
  connect(user,privateKeyFile,hostIP,sshPort);
  ChannelExec channel=null;
  logger.info(""String_Node_Str"");
  try {
    channel=(ChannelExec)session.openChannel(""String_Node_Str"");
    if (channel != null) {
      logger.debug(""String_Node_Str"");
      channel.setPty(true);
      channel.setCommand(command);
      BufferedReader in=new BufferedReader(new InputStreamReader(channel.getInputStream()));
      channel.connect();
      if (!channel.isConnected()) {
        logger.error(""String_Node_Str"");
      }
      StringBuilder buff=new StringBuilder();
      while (true) {
        String line=in.readLine();
        buff.append(line);
        if (channel.isClosed()) {
          int exitStatus=channel.getExitStatus();
          logger.debug(""String_Node_Str"" + exitStatus);
          logger.debug(""String_Node_Str"" + buff.toString());
          in.close();
          if (exitStatus == 0) {
            return true;
          }
 else {
            return false;
          }
        }
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException e) {
        }
      }
    }
 else {
      logger.error(""String_Node_Str"" + hostIP + ""String_Node_Str"");
      return false;
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  JSchException e) {
    e.printStackTrace();
  }
 finally {
    if (channel != null) {
      channel.disconnect();
    }
    if (session != null) {
      session.disconnect();
    }
  }
  return false;
}","public boolean execCmd(String user,String privateKeyFile,String hostIP,int sshPort,String command){
  AuAssert.check(command != null);
  connect(user,privateKeyFile,hostIP,sshPort);
  ChannelExec channel=null;
  BufferedReader in=null;
  logger.info(""String_Node_Str"");
  try {
    channel=(ChannelExec)session.openChannel(""String_Node_Str"");
    if (channel != null) {
      logger.debug(""String_Node_Str"");
      channel.setPty(true);
      channel.setCommand(command);
      in=new BufferedReader(new InputStreamReader(channel.getInputStream()));
      channel.connect();
      if (!channel.isConnected()) {
        logger.error(""String_Node_Str"");
      }
      StringBuilder buff=new StringBuilder();
      while (true) {
        String line=in.readLine();
        buff.append(line);
        if (channel.isClosed()) {
          int exitStatus=channel.getExitStatus();
          logger.debug(""String_Node_Str"" + exitStatus);
          logger.debug(""String_Node_Str"" + buff.toString());
          if (exitStatus == 0) {
            return true;
          }
          return false;
        }
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException e) {
        }
      }
    }
 else {
      logger.error(""String_Node_Str"" + hostIP + ""String_Node_Str"");
      return false;
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  JSchException e) {
    e.printStackTrace();
  }
 finally {
    if (channel != null && channel.isConnected()) {
      channel.disconnect();
    }
    if (session != null && session.isConnected()) {
      session.disconnect();
    }
    if (in != null) {
      try {
        in.close();
      }
 catch (      IOException e) {
        String errorMsg=""String_Node_Str"" + e.getMessage();
        logger.error(errorMsg);
      }
    }
  }
  return false;
}"
48768,"public synchronized void init(){
  if (!initialized) {
    Configuration.approveBootstrapInstanceId(Configuration.BootstrapUsage.ALLOWED);
    Configuration.approveBootstrapInstanceId(Configuration.BootstrapUsage.FINALIZED);
    VcContext.initVcContext();
    new VcEventRouter();
    CmsWorker.addPeriodic(new VcInventory.SyncInventoryRequest());
    VcInventory.loadInventory();
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      logger.warn(""String_Node_Str"" + e.getMessage());
    }
    startVMEventProcessor();
    String poolSize=Configuration.getNonEmptyString(""String_Node_Str"");
    if (poolSize == null) {
      Scheduler.init(Constants.DEFAULT_SCHEDULER_POOL_SIZE,Constants.DEFAULT_SCHEDULER_POOL_SIZE);
    }
 else {
      Scheduler.init(Integer.parseInt(poolSize),Integer.parseInt(poolSize));
    }
    String concurrency=Configuration.getNonEmptyString(""String_Node_Str"");
    if (concurrency != null) {
      cloneConcurrency=Integer.parseInt(concurrency);
    }
 else {
      cloneConcurrency=1;
    }
    CmsWorker.addPeriodic(new ClusterNodeUpdator(getClusterEntityMgr()));
    snapshotTemplateVM();
    loadTemplateNetworkLable();
    convertTemplateVm();
    clusterInitializerService.transformClusterStatus(ClusterStatus.PROVISIONING,ClusterStatus.PROVISION_ERROR);
    elasticityScheduleMgr.start();
    initialized=true;
  }
}","public synchronized void init(){
  if (!initialized) {
    Configuration.approveBootstrapInstanceId(Configuration.BootstrapUsage.ALLOWED);
    Configuration.approveBootstrapInstanceId(Configuration.BootstrapUsage.FINALIZED);
    VcContext.initVcContext();
    new VcEventRouter();
    CmsWorker.addPeriodic(new VcInventory.SyncInventoryRequest());
    VcInventory.loadInventory();
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      logger.warn(""String_Node_Str"" + e.getMessage());
    }
    startVMEventProcessor();
    String poolSize=Configuration.getNonEmptyString(""String_Node_Str"");
    if (poolSize == null) {
      Scheduler.init(Constants.DEFAULT_SCHEDULER_POOL_SIZE,Constants.DEFAULT_SCHEDULER_POOL_SIZE);
    }
 else {
      Scheduler.init(Integer.parseInt(poolSize),Integer.parseInt(poolSize));
    }
    String concurrency=Configuration.getNonEmptyString(""String_Node_Str"");
    if (concurrency != null) {
      cloneConcurrency=Integer.parseInt(concurrency);
    }
 else {
      cloneConcurrency=1;
    }
    CmsWorker.addPeriodic(new ClusterNodeUpdator(getClusterEntityMgr()));
    snapshotTemplateVM();
    loadTemplateNetworkLable();
    convertTemplateVm();
    clusterInitializerService.transformClusterStatus(ClusterStatus.PROVISIONING,ClusterStatus.PROVISION_ERROR);
    elasticityScheduleMgr.start();
    configureAlarm();
    initialized=true;
  }
}"
48769,"private Map<String,Folder> executeFolderCreationProcedures(ClusterCreate cluster,Callable<Void>[] storeProcedures){
  Map<String,Folder> folders=new HashMap<String,Folder>();
  try {
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProcedures,callback);
    if (result == null) {
      logger.error(""String_Node_Str"");
      throw ClusteringServiceException.CREATE_FOLDER_FAILED(cluster.getName());
    }
    int total=0;
    boolean success=true;
    for (int i=0; i < storeProcedures.length; i++) {
      CreateVMFolderSP sp=(CreateVMFolderSP)storeProcedures[i];
      if (result[i].finished && result[i].throwable == null) {
        ++total;
        Folder childFolder=sp.getResult().get(sp.getResult().size() - 1);
        folders.put(childFolder.getName(),childFolder);
      }
 else       if (result[i].throwable != null) {
        logger.error(""String_Node_Str"",result[i].throwable);
        success=false;
      }
    }
    logger.info(total + ""String_Node_Str"");
    if (!success) {
      throw ClusteringServiceException.CREATE_FOLDER_FAILED(cluster.getName());
    }
    return folders;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}","private Map<String,Folder> executeFolderCreationProcedures(ClusterCreate cluster,Callable<Void>[] storeProcedures){
  Map<String,Folder> folders=new HashMap<String,Folder>();
  try {
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProcedures,callback);
    if (result == null) {
      logger.error(""String_Node_Str"");
      if (cluster != null)       throw ClusteringServiceException.CREATE_FOLDER_FAILED(cluster.getName());
    }
    int total=0;
    boolean success=true;
    for (int i=0; i < storeProcedures.length; i++) {
      CreateVMFolderSP sp=(CreateVMFolderSP)storeProcedures[i];
      if (result[i].finished && result[i].throwable == null) {
        ++total;
        Folder childFolder=sp.getResult().get(sp.getResult().size() - 1);
        folders.put(childFolder.getName(),childFolder);
      }
 else       if (result[i].throwable != null) {
        logger.error(""String_Node_Str"",result[i].throwable);
        success=false;
      }
    }
    logger.info(total + ""String_Node_Str"");
    if (!success) {
      if (cluster != null)       throw ClusteringServiceException.CREATE_FOLDER_FAILED(cluster.getName());
    }
    return folders;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}"
48770,"private ServiceContents(long genCount) throws Exception {
  this.genCount=genCount;
  long startNanos=System.nanoTime();
  String sessionTicket=loginAndGetSessionTicket();
  ManagedObjectReference svcRef=new ManagedObjectReference();
  boolean done=false;
  svcRef.setType(""String_Node_Str"");
  svcRef.setValue(""String_Node_Str"");
  try {
    initVmomiClient();
    instance=vmomiClient.createStub(ServiceInstance.class,svcRef);
    instanceContent=instance.retrieveContent();
    sessionManager=vmomiClient.createStub(SessionManager.class,instanceContent.getSessionManager());
    if (sessionTicket != null) {
      try {
        sessionManager.loginBySessionTicket(sessionTicket);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        throw e;
      }
    }
 else     if (userName != null) {
      logger.info(""String_Node_Str"");
      sessionManager.login(userName,password,locale);
    }
 else {
      throw VcException.LOGIN_ERROR();
    }
    fileManager=getManagedObject(instanceContent.getFileManager());
    vmdkManager=getManagedObject(instanceContent.getVirtualDiskManager());
    taskManager=getManagedObject(instanceContent.getTaskManager());
    ovfManager=getManagedObject(instanceContent.getOvfManager());
    perfManager=getManagedObject(instanceContent.getPerfManager());
    optionManager=getManagedObject(instanceContent.getSetting());
    propertyCollector=getManagedObject(instanceContent.getPropertyCollector());
    extensionManager=getManagedObject(instanceContent.getExtensionManager());
    logger.info(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ serviceName+ ""String_Node_Str""+ genCount+ ""String_Node_Str""+ TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos)+ ""String_Node_Str"");
    done=true;
  }
  finally {
    if (!done) {
      cleanup();
    }
  }
}","private ServiceContents(long genCount) throws Exception {
  this.genCount=genCount;
  long startNanos=System.nanoTime();
  String sessionTicket=loginAndGetSessionTicket();
  ManagedObjectReference svcRef=new ManagedObjectReference();
  boolean done=false;
  svcRef.setType(""String_Node_Str"");
  svcRef.setValue(""String_Node_Str"");
  try {
    initVmomiClient();
    instance=vmomiClient.createStub(ServiceInstance.class,svcRef);
    instanceContent=instance.retrieveContent();
    sessionManager=vmomiClient.createStub(SessionManager.class,instanceContent.getSessionManager());
    if (sessionTicket != null) {
      try {
        sessionManager.loginBySessionTicket(sessionTicket);
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
        throw e;
      }
    }
 else     if (userName != null) {
      logger.info(""String_Node_Str"");
      sessionManager.login(userName,password,locale);
    }
 else {
      throw VcException.LOGIN_ERROR();
    }
    fileManager=getManagedObject(instanceContent.getFileManager());
    vmdkManager=getManagedObject(instanceContent.getVirtualDiskManager());
    taskManager=getManagedObject(instanceContent.getTaskManager());
    ovfManager=getManagedObject(instanceContent.getOvfManager());
    perfManager=getManagedObject(instanceContent.getPerfManager());
    optionManager=getManagedObject(instanceContent.getSetting());
    propertyCollector=getManagedObject(instanceContent.getPropertyCollector());
    extensionManager=getManagedObject(instanceContent.getExtensionManager());
    alarmManager=getManagedObject(instanceContent.getAlarmManager());
    logger.info(""String_Node_Str"" + Thread.currentThread().getName() + ""String_Node_Str""+ serviceName+ ""String_Node_Str""+ genCount+ ""String_Node_Str""+ TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos)+ ""String_Node_Str"");
    done=true;
  }
  finally {
    if (!done) {
      cleanup();
    }
  }
}"
48771,"private void processEvent(VcEventType type,Event e,String moId,boolean external) throws Exception {
  try {
switch (type) {
case VmRemoved:
{
        logger.debug(""String_Node_Str"" + moId);
        if (clusterEntityMgr.getNodeByMobId(moId) != null) {
          clusterEntityMgr.refreshNodeByMobId(moId,null,true);
        }
        break;
      }
case VmDisconnected:
{
      VcVirtualMachine vm=VcCache.getIgnoreMissing(moId);
      if (vm == null) {
        if (clusterEntityMgr.getNodeByMobId(moId) != null) {
          logger.debug(""String_Node_Str"" + moId + ""String_Node_Str"");
          clusterEntityMgr.removeVmReference(moId);
        }
        break;
      }
      if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
        vm.updateRuntime();
        if ((!vm.isConnected()) || vm.getHost().isUnavailbleForManagement()) {
          clusterEntityMgr.setNodeConnectionState(vm.getName());
          logConnectionChangeEvent(vm.getName());
        }
      }
      break;
    }
case VmPoweredOn:
{
    refreshNodeWithAction(moId,true,Constants.NODE_ACTION_WAITING_IP,""String_Node_Str"");
    if (external) {
      NodePowerOnRequest request=new NodePowerOnRequest(clusterEntityMgr,moId);
      CmsWorker.addRequest(WorkQueue.VC_TASK_NO_DELAY,request);
    }
    break;
  }
case VmCloned:
{
  refreshNodeWithAction(moId,true,Constants.NODE_ACTION_RECONFIGURE,""String_Node_Str"");
  break;
}
case VmSuspended:
{
refreshNodeWithAction(moId,true,null,""String_Node_Str"");
break;
}
case VmPoweredOff:
{
refreshNodeWithAction(moId,true,null,""String_Node_Str"");
break;
}
case VmConnected:
{
try {
refreshNodeWithAction(moId,false,null,type.name());
}
 catch (AuroraException ex) {
logger.error(""String_Node_Str"" + ex.getMessage() + ""String_Node_Str"");
}
break;
}
case VhmError:
case VhmWarning:
{
EventEx event=(EventEx)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
break;
}
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + event.getEventTypeId() + ""String_Node_Str""+ vm.getName()+ ""String_Node_Str""+ event.getMessage());
vm.updateRuntime();
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),event.getMessage(),true);
}
break;
}
case VhmInfo:
{
EventEx event=(EventEx)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
break;
}
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + event.getEventTypeId() + ""String_Node_Str""+ vm.getName()+ ""String_Node_Str""+ event.getMessage());
vm.updateRuntime();
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),""String_Node_Str"",true);
}
break;
}
default :
{
if (external) {
VcVirtualMachine vm=VcCache.getIgnoreMissing(moId);
if (vm == null) {
break;
}
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),true);
}
break;
}
}
}
 catch (ManagedObjectNotFound exp) {
VcUtil.processNotFoundException(exp,moId,logger);
}
}","private void processEvent(VcEventType type,Event e,String moId,boolean external) throws Exception {
  try {
switch (type) {
case VmRemoved:
{
        logger.debug(""String_Node_Str"" + moId);
        if (clusterEntityMgr.getNodeByMobId(moId) != null) {
          clusterEntityMgr.refreshNodeByMobId(moId,null,true);
        }
        break;
      }
case VmDisconnected:
{
      VcVirtualMachine vm=VcCache.getIgnoreMissing(moId);
      if (vm == null) {
        if (clusterEntityMgr.getNodeByMobId(moId) != null) {
          logger.debug(""String_Node_Str"" + moId + ""String_Node_Str"");
          clusterEntityMgr.removeVmReference(moId);
        }
        break;
      }
      if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
        vm.updateRuntime();
        if ((!vm.isConnected()) || vm.getHost().isUnavailbleForManagement()) {
          clusterEntityMgr.setNodeConnectionState(vm.getName());
          logConnectionChangeEvent(vm.getName());
        }
      }
      break;
    }
case VmPoweredOn:
{
    refreshNodeWithAction(moId,true,Constants.NODE_ACTION_WAITING_IP,""String_Node_Str"");
    if (external) {
      NodePowerOnRequest request=new NodePowerOnRequest(clusterEntityMgr,moId);
      CmsWorker.addRequest(WorkQueue.VC_TASK_NO_DELAY,request);
    }
    break;
  }
case VmCloned:
{
  refreshNodeWithAction(moId,true,Constants.NODE_ACTION_RECONFIGURE,""String_Node_Str"");
  break;
}
case VmSuspended:
{
refreshNodeWithAction(moId,true,null,""String_Node_Str"");
break;
}
case VmPoweredOff:
{
refreshNodeWithAction(moId,true,null,""String_Node_Str"");
break;
}
case VmConnected:
{
try {
refreshNodeWithAction(moId,false,null,type.name());
}
 catch (AuroraException ex) {
logger.error(""String_Node_Str"" + ex.getMessage() + ""String_Node_Str"");
}
break;
}
case VmMigrated:
{
refreshNodeWithAction(moId,false,null,type.name());
break;
}
case VhmError:
case VhmWarning:
{
EventEx event=(EventEx)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
break;
}
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + event.getEventTypeId() + ""String_Node_Str""+ vm.getName()+ ""String_Node_Str""+ event.getMessage());
vm.updateRuntime();
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),event.getMessage(),true);
}
break;
}
case VhmInfo:
{
EventEx event=(EventEx)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
break;
}
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + event.getEventTypeId() + ""String_Node_Str""+ vm.getName()+ ""String_Node_Str""+ event.getMessage());
vm.updateRuntime();
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),""String_Node_Str"",true);
}
break;
}
default :
{
if (external) {
VcVirtualMachine vm=VcCache.getIgnoreMissing(moId);
if (vm == null) {
break;
}
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),true);
}
break;
}
}
}
 catch (ManagedObjectNotFound exp) {
VcUtil.processNotFoundException(exp,moId,logger);
}
}"
48772,"private boolean isValidPassword(String password){
  if (password.length() < Constants.PASSWORD_MIN_LENGTH || password.length() > Constants.PASSWORD_MAX_LENGTH) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,null,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PASSWORD_LENGTH_REQUIREMENT);
    return false;
  }
  return true;
}","private boolean isValidPassword(String password){
  if (password.length() < Constants.PASSWORD_MIN_LENGTH || password.length() > Constants.PASSWORD_MAX_LENGTH) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,null,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PASSWORD_LENGTH_REQUIREMENT);
    return false;
  }
  if (containInvalidCharacter(password)) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,null,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PASSWORD_CHARACTER_REQUIREMENT);
    return false;
  }
  return true;
}"
48773,"private String getPassword(){
  System.out.println(""String_Node_Str"" + Constants.PASSWORD_LENGTH_REQUIREMENT);
  String firstPassword=getInputedPassword(Constants.ENTER_PASSWORD);
  if (firstPassword == null) {
    return null;
  }
  String secondPassword=getInputedPassword(Constants.CONFIRM_PASSWORD);
  if (secondPassword == null) {
    return null;
  }
  if (!firstPassword.equals(secondPassword)) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,null,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PASSWORD_CONFIRMATION_FAILED);
    return null;
  }
  return firstPassword;
}","private String getPassword(){
  System.out.println(""String_Node_Str"" + Constants.PASSWORD_HINT);
  String firstPassword=getInputedPassword(Constants.ENTER_PASSWORD);
  if (firstPassword == null) {
    return null;
  }
  String secondPassword=getInputedPassword(Constants.CONFIRM_PASSWORD);
  if (secondPassword == null) {
    return null;
  }
  if (!firstPassword.equals(secondPassword)) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,null,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PASSWORD_CONFIRMATION_FAILED);
    return null;
  }
  return firstPassword;
}"
48774,"private boolean containInvalidCharacter(String password){
  Pattern pattern=Pattern.compile(""String_Node_Str"");
  Matcher matcher=pattern.matcher(password);
  if (matcher.matches()) {
    return false;
  }
  return true;
}","private boolean containInvalidCharacter(String password){
  if (password.contains(Constants.NEW_LINE)) {
    return true;
  }
  return false;
}"
48775,"private boolean setPasswordForNode() throws Exception {
  logger.info(""String_Node_Str"" + nodeIP);
  String privateKeyFile=Configuration.getString(Constants.SSH_PRIVATE_KEY_CONFIG_NAME,Constants.SSH_PRIVATE_KEY_FILE_NAME);
  String sshUser=Configuration.getString(Constants.SSH_USER_CONFIG_NAME,Constants.DEFAULT_SSH_USER_NAME);
  int sshPort=Configuration.getInt(Constants.SSH_PORT_CONFIG_NAME,Constants.DEFAULT_SSH_PORT);
  String cmd=generateSetPasswdCommand(Constants.SET_PASSWORD_SCRIPT_CONFIG_NAME,password);
  boolean setPasswordSucceed=false;
  for (int i=0; i < Constants.SET_PASSWORD_MAX_RETRY_TIMES; i++) {
    SSHUtil sshUtil=new SSHUtil();
    setPasswordSucceed=sshUtil.execCmd(sshUser,privateKeyFile,nodeIP,sshPort,cmd);
    if (setPasswordSucceed) {
      break;
    }
 else {
      logger.info(""String_Node_Str"" + nodeIP + ""String_Node_Str""+ (i + 1)+ ""String_Node_Str"");
      try {
        Thread.sleep(2000);
      }
 catch (      InterruptedException e) {
        logger.info(""String_Node_Str"");
      }
    }
  }
  if (setPasswordSucceed) {
    logger.info(""String_Node_Str"" + nodeIP + ""String_Node_Str"");
    return true;
  }
 else {
    logger.info(""String_Node_Str"" + nodeIP + ""String_Node_Str"");
    throw new Exception(Constants.CHECK_WHETHER_SSH_ACCESS_AVAILABLE);
  }
}","private boolean setPasswordForNode() throws Exception {
  logger.info(""String_Node_Str"" + nodeIP);
  String privateKeyFile=Configuration.getString(Constants.SSH_PRIVATE_KEY_CONFIG_NAME,Constants.SSH_PRIVATE_KEY_FILE_NAME);
  String sshUser=Configuration.getString(Constants.SSH_USER_CONFIG_NAME,Constants.DEFAULT_SSH_USER_NAME);
  int sshPort=Configuration.getInt(Constants.SSH_PORT_CONFIG_NAME,Constants.DEFAULT_SSH_PORT);
  String cmd=generateSetPasswdCommand(Constants.SET_PASSWORD_SCRIPT_CONFIG_NAME,password);
  InputStream in=null;
  try {
    in=parseInputStream(new String(password + Constants.NEW_LINE + password+ Constants.NEW_LINE));
    boolean setPasswordSucceed=false;
    for (int i=0; i < Constants.SET_PASSWORD_MAX_RETRY_TIMES; i++) {
      SSHUtil sshUtil=new SSHUtil();
      setPasswordSucceed=sshUtil.execCmd(sshUser,privateKeyFile,nodeIP,sshPort,cmd,in,null);
      if (setPasswordSucceed) {
        break;
      }
 else {
        logger.info(""String_Node_Str"" + nodeIP + ""String_Node_Str""+ (i + 1)+ ""String_Node_Str"");
        try {
          Thread.sleep(2000);
        }
 catch (        InterruptedException e) {
          logger.info(""String_Node_Str"");
        }
      }
    }
    if (setPasswordSucceed) {
      logger.info(""String_Node_Str"" + nodeIP + ""String_Node_Str"");
      return true;
    }
 else {
      logger.info(""String_Node_Str"" + nodeIP + ""String_Node_Str"");
      throw new Exception(Constants.CHECK_WHETHER_SSH_ACCESS_AVAILABLE);
    }
  }
  finally {
    if (in != null) {
      in.close();
    }
  }
}"
48776,"private String generateSetPasswdCommand(String setPasswdScriptConfig,String password){
  String scriptFileName=Configuration.getString(setPasswdScriptConfig,Constants.DEFAULT_SET_PASSWORD_SCRIPT);
  String[] commands=new String[8];
  String tmpScript=""String_Node_Str"";
  commands[0]=""String_Node_Str"" + tmpScript;
  commands[1]=""String_Node_Str"" + scriptFileName + ""String_Node_Str""+ ""String_Node_Str""+ tmpScript;
  commands[2]=""String_Node_Str"" + password + ""String_Node_Str""+ tmpScript;
  commands[3]=commands[2];
  commands[4]=""String_Node_Str"" + tmpScript;
  commands[5]=""String_Node_Str"" + tmpScript;
  commands[6]=""String_Node_Str"" + tmpScript;
  commands[7]=""String_Node_Str"" + tmpScript;
  StringBuilder sb=new StringBuilder().append(commands[0]).append(""String_Node_Str"").append(commands[1]).append(""String_Node_Str"").append(commands[2]).append(""String_Node_Str"").append(commands[3]).append(""String_Node_Str"").append(commands[4]).append(""String_Node_Str"").append(commands[5]).append(""String_Node_Str"").append(commands[6]).append(""String_Node_Str"").append(commands[7]);
  return sb.toString();
}","private String generateSetPasswdCommand(String setPasswdScriptConfig,String password){
  String scriptFileName=Configuration.getString(setPasswdScriptConfig,Constants.DEFAULT_SET_PASSWORD_SCRIPT);
  return ""String_Node_Str"" + scriptFileName + ""String_Node_Str"";
}"
48777,"public boolean execCmd(String user,String privateKeyFile,String hostIP,int sshPort,String command){
  AuAssert.check(command != null);
  connect(user,privateKeyFile,hostIP,sshPort);
  ChannelExec channel=null;
  BufferedReader in=null;
  logger.info(""String_Node_Str"");
  try {
    channel=(ChannelExec)session.openChannel(""String_Node_Str"");
    if (channel != null) {
      logger.debug(""String_Node_Str"");
      channel.setPty(true);
      channel.setCommand(command);
      in=new BufferedReader(new InputStreamReader(channel.getInputStream()));
      channel.connect();
      if (!channel.isConnected()) {
        logger.error(""String_Node_Str"");
      }
      StringBuilder buff=new StringBuilder();
      while (true) {
        String line=in.readLine();
        buff.append(line);
        if (channel.isClosed()) {
          int exitStatus=channel.getExitStatus();
          logger.debug(""String_Node_Str"" + exitStatus);
          logger.debug(""String_Node_Str"" + buff.toString());
          if (exitStatus == 0) {
            return true;
          }
          return false;
        }
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException e) {
        }
      }
    }
 else {
      logger.error(""String_Node_Str"" + hostIP + ""String_Node_Str"");
      return false;
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  JSchException e) {
    e.printStackTrace();
  }
 finally {
    if (channel != null && channel.isConnected()) {
      channel.disconnect();
    }
    if (session != null && session.isConnected()) {
      session.disconnect();
    }
    if (in != null) {
      try {
        in.close();
      }
 catch (      IOException e) {
        String errorMsg=""String_Node_Str"" + e.getMessage();
        logger.error(errorMsg);
      }
    }
  }
  return false;
}","public boolean execCmd(String user,String privateKeyFile,String hostIP,int sshPort,String command,InputStream in,OutputStream out){
  AuAssert.check(command != null);
  connect(user,privateKeyFile,hostIP,sshPort);
  ChannelExec channel=null;
  BufferedReader in=null;
  logger.info(""String_Node_Str"");
  BufferedReader bufferedReader=null;
  try {
    channel=(ChannelExec)session.openChannel(""String_Node_Str"");
    if (channel != null) {
      logger.debug(""String_Node_Str"");
      channel.setPty(true);
      channel.setCommand(command);
      channel.setInputStream(in);
      channel.setOutputStream(out);
      bufferedReader=new BufferedReader(new InputStreamReader(channel.getInputStream()));
      channel.connect();
      if (!channel.isConnected()) {
        logger.error(""String_Node_Str"");
      }
      StringBuilder buff=new StringBuilder();
      while (true) {
        String line=bufferedReader.readLine();
        buff.append(line);
        if (channel.isClosed()) {
          int exitStatus=channel.getExitStatus();
          logger.debug(""String_Node_Str"" + exitStatus);
          logger.debug(""String_Node_Str"" + buff.toString());
          if (exitStatus == 0) {
            return true;
          }
          return false;
        }
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException e) {
        }
      }
    }
 else {
      logger.error(""String_Node_Str"" + hostIP + ""String_Node_Str"");
      return false;
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  JSchException e) {
    e.printStackTrace();
  }
 finally {
    if (channel != null && channel.isConnected()) {
      channel.disconnect();
    }
    if (session != null && channel.isConnected()) {
      session.disconnect();
    }
    try {
      bufferedReader.close();
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"" + e.getMessage());
    }
  }
  return false;
}"
48778,"public static void configureAlarm(Folder rootFolder) throws Exception {
  AlarmManager alarmManager=VcContext.getService().getAlarmManager();
  String SERENGETI_UUID=rootFolder.getName();
  String ALARM_CLEARED_MSG=""String_Node_Str"";
  EventAlarmExpression raiseExpression=new EventAlarmExpressionImpl();
  raiseExpression.setEventType(new TypeNameImpl(""String_Node_Str""));
  raiseExpression.setEventTypeId(""String_Node_Str"");
  raiseExpression.setStatus(ManagedEntity.Status.yellow);
  EventAlarmExpression clearExpression=new EventAlarmExpressionImpl();
  clearExpression.setEventType(new TypeNameImpl(""String_Node_Str""));
  clearExpression.setEventTypeId(""String_Node_Str"");
  clearExpression.setComparisons(new EventAlarmExpressionImpl.ComparisonImpl[]{new EventAlarmExpressionImpl.ComparisonImpl(""String_Node_Str"",""String_Node_Str"",ALARM_CLEARED_MSG)});
  clearExpression.setStatus(ManagedEntity.Status.green);
  OrAlarmExpression or=new OrAlarmExpressionImpl();
  or.setExpression(new AlarmExpression[]{raiseExpression,clearExpression});
  AlarmTriggeringAction alarmAction=new AlarmTriggeringActionImpl();
  alarmAction.setAction(null);
  TransitionSpec tSpec=new AlarmTriggeringActionImpl.TransitionSpecImpl();
  tSpec.setRepeats(false);
  tSpec.setStartState(Status.green);
  tSpec.setFinalState(Status.yellow);
  alarmAction.setTransitionSpecs(new TransitionSpec[]{tSpec});
  alarmAction.setGreen2yellow(true);
  AlarmSpec spec=new AlarmSpecImpl();
  spec.setActionFrequency(0);
  spec.setExpression(or);
  String alarmName=""String_Node_Str"" + SERENGETI_UUID;
  spec.setName(alarmName);
  spec.setSystemName(null);
  spec.setDescription(""String_Node_Str"");
  spec.setEnabled(true);
  AlarmSetting as=new AlarmSettingImpl();
  as.setReportingFrequency(0);
  as.setToleranceRange(0);
  spec.setSetting(as);
  ManagedObjectReference[] existingAlarms=alarmManager.getAlarm(rootFolder._getRef());
  Alarm existing=null;
  try {
    if (existingAlarms != null) {
      for (      ManagedObjectReference m : existingAlarms) {
        Alarm a=MoUtil.getManagedObject(m);
        if (a.getInfo().getName().equals(alarmName)) {
          existing=a;
          break;
        }
      }
    }
  }
 catch (  NullPointerException e) {
    logger.error(""String_Node_Str"",e);
  }
  try {
    if (existing != null) {
      existing.reconfigure(spec);
      logger.info(""String_Node_Str"" + alarmName + ""String_Node_Str"");
    }
 else {
      ManagedObjectReference alarmMoref=alarmManager.create(rootFolder._getRef(),spec);
      logger.info(""String_Node_Str"" + alarmMoref.getValue() + ""String_Node_Str""+ alarmName);
    }
  }
 catch (  InvalidName e) {
    logger.error(""String_Node_Str"",e);
  }
catch (  DuplicateName e) {
    logger.error(""String_Node_Str"",e);
  }
}","public static void configureAlarm(Folder rootFolder) throws Exception {
  AlarmManager alarmManager=VcContext.getService().getAlarmManager();
  String SERENGETI_UUID=rootFolder.getName();
  String ALARM_CLEARED_MSG=""String_Node_Str"";
  EventAlarmExpression raiseExpression=new EventAlarmExpressionImpl();
  raiseExpression.setEventType(new TypeNameImpl(""String_Node_Str""));
  raiseExpression.setEventTypeId(""String_Node_Str"");
  raiseExpression.setStatus(ManagedEntity.Status.yellow);
  EventAlarmExpression clearExpression=new EventAlarmExpressionImpl();
  clearExpression.setEventType(new TypeNameImpl(""String_Node_Str""));
  clearExpression.setEventTypeId(""String_Node_Str"");
  clearExpression.setComparisons(new EventAlarmExpressionImpl.ComparisonImpl[]{new EventAlarmExpressionImpl.ComparisonImpl(""String_Node_Str"",""String_Node_Str"",ALARM_CLEARED_MSG)});
  clearExpression.setStatus(ManagedEntity.Status.green);
  OrAlarmExpression or=new OrAlarmExpressionImpl();
  or.setExpression(new AlarmExpression[]{raiseExpression,clearExpression});
  AlarmTriggeringAction alarmAction=new AlarmTriggeringActionImpl();
  alarmAction.setAction(null);
  TransitionSpec tSpec=new AlarmTriggeringActionImpl.TransitionSpecImpl();
  tSpec.setRepeats(false);
  tSpec.setStartState(Status.green);
  tSpec.setFinalState(Status.yellow);
  alarmAction.setTransitionSpecs(new TransitionSpec[]{tSpec});
  alarmAction.setGreen2yellow(true);
  AlarmSpec spec=new AlarmSpecImpl();
  spec.setActionFrequency(0);
  spec.setExpression(or);
  String alarmName=""String_Node_Str"" + SERENGETI_UUID;
  if (alarmName.length() > 80) {
    alarmName=alarmName.substring(0,80);
  }
  spec.setName(alarmName);
  spec.setSystemName(null);
  spec.setDescription(""String_Node_Str"");
  spec.setEnabled(true);
  AlarmSetting as=new AlarmSettingImpl();
  as.setReportingFrequency(0);
  as.setToleranceRange(0);
  spec.setSetting(as);
  ManagedObjectReference[] existingAlarms=alarmManager.getAlarm(rootFolder._getRef());
  Alarm existing=null;
  try {
    if (existingAlarms != null) {
      for (      ManagedObjectReference m : existingAlarms) {
        Alarm a=MoUtil.getManagedObject(m);
        if (a.getInfo().getName().equals(alarmName)) {
          existing=a;
          break;
        }
      }
    }
  }
 catch (  NullPointerException e) {
    logger.error(""String_Node_Str"",e);
  }
  try {
    if (existing != null) {
      existing.reconfigure(spec);
      logger.info(""String_Node_Str"" + alarmName + ""String_Node_Str"");
    }
 else {
      ManagedObjectReference alarmMoref=alarmManager.create(rootFolder._getRef(),spec);
      logger.info(""String_Node_Str"" + alarmMoref.getValue() + ""String_Node_Str""+ alarmName);
    }
  }
 catch (  InvalidName e) {
    logger.error(""String_Node_Str"",e);
  }
catch (  DuplicateName e) {
    logger.error(""String_Node_Str"",e);
  }
}"
48779,"public static void configureAlarm(Folder rootFolder) throws Exception {
  AlarmManager alarmManager=VcContext.getService().getAlarmManager();
  String SERENGETI_UUID=rootFolder.getName();
  String ALARM_CLEARED_MSG=""String_Node_Str"";
  EventAlarmExpression raiseExpression=new EventAlarmExpressionImpl();
  raiseExpression.setEventType(new TypeNameImpl(""String_Node_Str""));
  raiseExpression.setEventTypeId(""String_Node_Str"");
  raiseExpression.setStatus(ManagedEntity.Status.yellow);
  EventAlarmExpression clearExpression=new EventAlarmExpressionImpl();
  clearExpression.setEventType(new TypeNameImpl(""String_Node_Str""));
  clearExpression.setEventTypeId(""String_Node_Str"");
  clearExpression.setComparisons(new EventAlarmExpressionImpl.ComparisonImpl[]{new EventAlarmExpressionImpl.ComparisonImpl(""String_Node_Str"",""String_Node_Str"",ALARM_CLEARED_MSG)});
  clearExpression.setStatus(ManagedEntity.Status.green);
  OrAlarmExpression or=new OrAlarmExpressionImpl();
  or.setExpression(new AlarmExpression[]{raiseExpression,clearExpression});
  AlarmTriggeringAction alarmAction=new AlarmTriggeringActionImpl();
  alarmAction.setAction(null);
  TransitionSpec tSpec=new AlarmTriggeringActionImpl.TransitionSpecImpl();
  tSpec.setRepeats(false);
  tSpec.setStartState(Status.green);
  tSpec.setFinalState(Status.yellow);
  alarmAction.setTransitionSpecs(new TransitionSpec[]{tSpec});
  alarmAction.setGreen2yellow(true);
  AlarmSpec spec=new AlarmSpecImpl();
  spec.setActionFrequency(0);
  spec.setExpression(or);
  String alarmName=""String_Node_Str"" + SERENGETI_UUID;
  if (alarmName.length() > 80) {
    alarmName=alarmName.substring(0,80);
  }
  spec.setName(alarmName);
  spec.setSystemName(null);
  spec.setDescription(""String_Node_Str"");
  spec.setEnabled(true);
  AlarmSetting as=new AlarmSettingImpl();
  as.setReportingFrequency(0);
  as.setToleranceRange(0);
  spec.setSetting(as);
  ManagedObjectReference[] existingAlarms=alarmManager.getAlarm(rootFolder._getRef());
  Alarm existing=null;
  try {
    if (existingAlarms != null) {
      for (      ManagedObjectReference m : existingAlarms) {
        Alarm a=MoUtil.getManagedObject(m);
        if (a.getInfo().getName().equals(alarmName)) {
          existing=a;
          break;
        }
      }
    }
  }
 catch (  NullPointerException e) {
    logger.error(""String_Node_Str"",e);
  }
  try {
    if (existing != null) {
      existing.reconfigure(spec);
      logger.info(""String_Node_Str"" + alarmName + ""String_Node_Str"");
    }
 else {
      ManagedObjectReference alarmMoref=alarmManager.create(rootFolder._getRef(),spec);
      logger.info(""String_Node_Str"" + alarmMoref.getValue() + ""String_Node_Str""+ alarmName);
    }
  }
 catch (  InvalidName e) {
    logger.error(""String_Node_Str"",e);
  }
catch (  DuplicateName e) {
    logger.error(""String_Node_Str"",e);
  }
}","public static void configureAlarm(Folder rootFolder) throws Exception {
  AlarmManager alarmManager=VcContext.getService().getAlarmManager();
  String SERENGETI_UUID=rootFolder.getName();
  String ALARM_CLEARED_MSG=""String_Node_Str"";
  EventAlarmExpression raiseExpression=new EventAlarmExpressionImpl();
  raiseExpression.setEventType(new TypeNameImpl(""String_Node_Str""));
  raiseExpression.setEventTypeId(""String_Node_Str"");
  raiseExpression.setStatus(ManagedEntity.Status.yellow);
  raiseExpression.setObjectType(new TypeNameImpl(""String_Node_Str""));
  EventAlarmExpression clearExpression=new EventAlarmExpressionImpl();
  clearExpression.setEventType(new TypeNameImpl(""String_Node_Str""));
  clearExpression.setEventTypeId(""String_Node_Str"");
  clearExpression.setComparisons(new EventAlarmExpressionImpl.ComparisonImpl[]{new EventAlarmExpressionImpl.ComparisonImpl(""String_Node_Str"",""String_Node_Str"",ALARM_CLEARED_MSG)});
  clearExpression.setStatus(ManagedEntity.Status.green);
  clearExpression.setObjectType(new TypeNameImpl(""String_Node_Str""));
  OrAlarmExpression or=new OrAlarmExpressionImpl();
  or.setExpression(new AlarmExpression[]{raiseExpression,clearExpression});
  AlarmTriggeringAction alarmAction=new AlarmTriggeringActionImpl();
  alarmAction.setAction(null);
  TransitionSpec tSpec=new AlarmTriggeringActionImpl.TransitionSpecImpl();
  tSpec.setRepeats(false);
  tSpec.setStartState(Status.green);
  tSpec.setFinalState(Status.yellow);
  alarmAction.setTransitionSpecs(new TransitionSpec[]{tSpec});
  alarmAction.setGreen2yellow(true);
  AlarmSpec spec=new AlarmSpecImpl();
  spec.setActionFrequency(0);
  spec.setExpression(or);
  String alarmName=""String_Node_Str"" + SERENGETI_UUID;
  if (alarmName.length() > 80) {
    alarmName=alarmName.substring(0,80);
  }
  spec.setName(alarmName);
  spec.setSystemName(null);
  spec.setDescription(""String_Node_Str"");
  spec.setEnabled(true);
  AlarmSetting as=new AlarmSettingImpl();
  as.setReportingFrequency(0);
  as.setToleranceRange(0);
  spec.setSetting(as);
  ManagedObjectReference[] existingAlarms=alarmManager.getAlarm(rootFolder._getRef());
  Alarm existing=null;
  try {
    if (existingAlarms != null) {
      for (      ManagedObjectReference m : existingAlarms) {
        Alarm a=MoUtil.getManagedObject(m);
        if (a.getInfo().getName().equals(alarmName)) {
          existing=a;
          break;
        }
      }
    }
  }
 catch (  NullPointerException e) {
    logger.error(""String_Node_Str"",e);
  }
  try {
    if (existing != null) {
      existing.reconfigure(spec);
      logger.info(""String_Node_Str"" + alarmName + ""String_Node_Str"");
    }
 else {
      ManagedObjectReference alarmMoref=alarmManager.create(rootFolder._getRef(),spec);
      logger.info(""String_Node_Str"" + alarmMoref.getValue() + ""String_Node_Str""+ alarmName);
    }
  }
 catch (  InvalidName e) {
    logger.error(""String_Node_Str"",e);
  }
catch (  DuplicateName e) {
    logger.error(""String_Node_Str"",e);
  }
}"
48780,"@SuppressWarnings(""String_Node_Str"") public boolean setAutoElasticity(String clusterName,boolean refreshAllNodes){
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=getClusterEntityMgr().findByName(clusterName);
  List<NodeEntity> nodes=clusterEntityMgr.findAllNodes(clusterName);
  Boolean enableAutoElasticity=cluster.getAutomationEnable();
  if (enableAutoElasticity == null) {
    return true;
  }
  String masterMoId=cluster.getVhmMasterMoid();
  if (masterMoId == null) {
    updateVhmMasterMoid(clusterName);
    cluster=getClusterEntityMgr().findByName(clusterName);
    masterMoId=cluster.getVhmMasterMoid();
    if (masterMoId == null) {
      logger.error(""String_Node_Str"");
      throw ClusteringServiceException.SET_AUTO_ELASTICITY_FAILED(cluster.getName());
    }
  }
  String serengetiUUID=ConfigInfo.getSerengetiRootFolder();
  int minComputeNodeNum=cluster.getVhmMinNum();
  int maxComputeNodeNum=cluster.getVhmMaxNum();
  String jobTrackerPort=cluster.getVhmJobTrackerPort();
  VcVirtualMachine vcVm=VcCache.getIgnoreMissing(masterMoId);
  if (vcVm == null) {
    logger.error(""String_Node_Str"");
    return false;
  }
  String masterUUID=vcVm.getConfig().getUuid();
  Callable<Void>[] storeProcedures=new Callable[nodes.size()];
  int i=0;
  for (  NodeEntity node : nodes) {
    VcVirtualMachine vm=VcCache.getIgnoreMissing(node.getMoId());
    if (vm == null) {
      logger.error(""String_Node_Str"" + node.getVmName());
      return false;
    }
    if (!refreshAllNodes && !vm.getId().equalsIgnoreCase(masterMoId)) {
      continue;
    }
    List<String> roles=new Gson().fromJson(node.getNodeGroup().getRoles(),List.class);
    String distroVendor=node.getNodeGroup().getCluster().getDistroVendor();
    boolean isComputeOnlyNode=CommonUtil.isComputeOnly(roles,distroVendor);
    SetAutoElasticitySP sp=new SetAutoElasticitySP(vm,serengetiUUID,masterMoId,masterUUID,enableAutoElasticity,minComputeNodeNum,maxComputeNodeNum,jobTrackerPort,isComputeOnlyNode);
    storeProcedures[i]=sp;
    i++;
  }
  try {
    logger.info(""String_Node_Str"");
    boolean success=true;
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProcedures,callback);
    if (result == null) {
      logger.error(""String_Node_Str"");
      throw ClusteringServiceException.SET_AUTO_ELASTICITY_FAILED(clusterName);
    }
    for (i=0; i < storeProcedures.length; i++) {
      if (result[i].throwable != null) {
        logger.error(""String_Node_Str"",result[i].throwable);
        success=false;
      }
    }
    return success;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}","@SuppressWarnings(""String_Node_Str"") public boolean setAutoElasticity(String clusterName,boolean refreshAllNodes){
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=getClusterEntityMgr().findByName(clusterName);
  List<NodeEntity> nodes=clusterEntityMgr.findAllNodes(clusterName);
  Boolean enableAutoElasticity=cluster.getAutomationEnable();
  if (enableAutoElasticity == null) {
    return true;
  }
  String masterMoId=cluster.getVhmMasterMoid();
  if (masterMoId == null) {
    updateVhmMasterMoid(clusterName);
    cluster=getClusterEntityMgr().findByName(clusterName);
    masterMoId=cluster.getVhmMasterMoid();
    if (masterMoId == null) {
      logger.error(""String_Node_Str"");
      throw ClusteringServiceException.SET_AUTO_ELASTICITY_FAILED(cluster.getName());
    }
  }
  String serengetiUUID=ConfigInfo.getSerengetiRootFolder();
  int minComputeNodeNum=cluster.getVhmMinNum();
  int maxComputeNodeNum=cluster.getVhmMaxNum();
  String jobTrackerPort=cluster.getVhmJobTrackerPort();
  VcVirtualMachine vcVm=VcCache.getIgnoreMissing(masterMoId);
  if (vcVm == null) {
    logger.error(""String_Node_Str"");
    return false;
  }
  String masterUUID=vcVm.getConfig().getUuid();
  Callable<Void>[] storeProcedures=new Callable[nodes.size()];
  int i=0;
  for (  NodeEntity node : nodes) {
    VcVirtualMachine vm=VcCache.getIgnoreMissing(node.getMoId());
    if (vm == null) {
      logger.error(""String_Node_Str"" + node.getVmName());
      continue;
    }
    if (!refreshAllNodes && !vm.getId().equalsIgnoreCase(masterMoId)) {
      continue;
    }
    List<String> roles=new Gson().fromJson(node.getNodeGroup().getRoles(),List.class);
    String distroVendor=node.getNodeGroup().getCluster().getDistroVendor();
    boolean isComputeOnlyNode=CommonUtil.isComputeOnly(roles,distroVendor);
    SetAutoElasticitySP sp=new SetAutoElasticitySP(vm,serengetiUUID,masterMoId,masterUUID,enableAutoElasticity,minComputeNodeNum,maxComputeNodeNum,jobTrackerPort,isComputeOnlyNode);
    storeProcedures[i]=sp;
    i++;
  }
  try {
    logger.info(""String_Node_Str"");
    boolean success=true;
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProcedures,callback);
    if (result == null) {
      logger.error(""String_Node_Str"");
      throw ClusteringServiceException.SET_AUTO_ELASTICITY_FAILED(clusterName);
    }
    for (i=0; i < storeProcedures.length; i++) {
      if (result[i].throwable != null) {
        logger.error(""String_Node_Str"",result[i].throwable);
        success=false;
      }
    }
    return success;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}"
48781,"/** 
 * Reverse to the previous function: given a string in the format MOREF_GUID_FORMAT, return ManagedObjectReference. Returns null if the string has incorrect format.
 */
public static ManagedObjectReference stringToMoref(String str){
  String[] comps=str.split(""String_Node_Str"");
  if (comps.length != 2 && comps.length != 3) {
    return null;
  }
  for (int i=0; i < comps.length; i++) {
    if (comps[i] != null && (comps[i].equals(""String_Node_Str"") || comps[i].equals(""String_Node_Str""))) {
      comps[i]=null;
    }
  }
  ManagedObjectReference ref=new ManagedObjectReference();
  if (comps.length == 2) {
    ref.setServerGuid(null);
    ref.setType(comps[0]);
    ref.setValue(comps[1]);
  }
 else {
    ref.setServerGuid(comps[0]);
    ref.setType(comps[1]);
    ref.setValue(comps[2]);
  }
  if (ref.getType() == null || ref.getValue() == null || (ref.getServerGuid() != null && !ref.getServerGuid().equals(VcContext.getServerGuid()))) {
    return null;
  }
  return ref;
}","/** 
 * Reverse to the previous function: given a string in the format MOREF_GUID_FORMAT, return ManagedObjectReference. Returns null if the string has incorrect format.
 */
public static ManagedObjectReference stringToMoref(String str){
  if (str == null) {
    return null;
  }
  String[] comps=str.split(""String_Node_Str"");
  if (comps.length != 2 && comps.length != 3) {
    return null;
  }
  for (int i=0; i < comps.length; i++) {
    if (comps[i] != null && (comps[i].equals(""String_Node_Str"") || comps[i].equals(""String_Node_Str""))) {
      comps[i]=null;
    }
  }
  ManagedObjectReference ref=new ManagedObjectReference();
  if (comps.length == 2) {
    ref.setServerGuid(null);
    ref.setType(comps[0]);
    ref.setValue(comps[1]);
  }
 else {
    ref.setServerGuid(comps[0]);
    ref.setType(comps[1]);
    ref.setValue(comps[2]);
  }
  if (ref.getType() == null || ref.getValue() == null || (ref.getServerGuid() != null && !ref.getServerGuid().equals(VcContext.getServerGuid()))) {
    return null;
  }
  return ref;
}"
48782,"private CreateVmSP getReplacementVmSp(ClusterCreate clusterSpec,String groupName,NodeEntity node,List<DiskSpec> fullDiskSet){
  VmSchema createSchema=VcVmUtil.getVmSchema(clusterSpec,groupName,fullDiskSet,clusteringService.getTemplateVmId(),Constants.ROOT_SNAPSTHOT_NAME);
  List<NetworkAdd> networkAdds=clusterSpec.getNetworkings();
  GuestMachineIdSpec machineIdSpec=new GuestMachineIdSpec(networkAdds,node.fetchPortGroupToIpMap(),node.getIpConfigsInfo().get(NetConfigInfo.NetTrafficType.MGT_NETWORK).get(0).getPortGroupName());
  logger.info(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ machineIdSpec.toString());
  Map<String,String> guestVariable=machineIdSpec.toGuestVarialbe();
  VcVmUtil.addBootupUUID(guestVariable);
  String haFlag=clusterSpec.getNodeGroup(groupName).getHaFlag();
  boolean ha=false;
  boolean ft=false;
  if (haFlag != null && Constants.HA_FLAG_ON.equals(haFlag.toLowerCase())) {
    ha=true;
  }
  if (haFlag != null && Constants.HA_FLAG_FT.equals(haFlag.toLowerCase())) {
    ha=true;
    ft=true;
  }
  ReplaceVmPrePowerOn prePowerOn=new ReplaceVmPrePowerOn(node.getMoId(),node.getVmName(),clusterSpec.getNodeGroup(groupName).getStorage().getShares(),createSchema.networkSchema,ha,ft);
  return new CreateVmSP(node.getVmName() + RECOVERY_VM_NAME_POSTFIX,createSchema,VcVmUtil.getTargetRp(clusterSpec.getName(),groupName,node),getTargetDatastore(fullDiskSet),prePowerOn,null,guestVariable,false,getTargetFolder(node,clusterSpec.getNodeGroup(groupName)),getTargetHost(node));
}","private CreateVmSP getReplacementVmSp(ClusterCreate clusterSpec,String groupName,NodeEntity node,List<DiskSpec> fullDiskSet){
  VmSchema createSchema=VcVmUtil.getVmSchema(clusterSpec,groupName,fullDiskSet,clusteringService.getTemplateVmId(),Constants.ROOT_SNAPSTHOT_NAME);
  List<NetworkAdd> networkAdds=clusterSpec.getNetworkings();
  GuestMachineIdSpec machineIdSpec=new GuestMachineIdSpec(networkAdds,node.fetchPortGroupToIpMap(),node.getIpConfigsInfo().get(NetConfigInfo.NetTrafficType.MGT_NETWORK).get(0).getPortGroupName());
  logger.info(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ machineIdSpec.toString());
  Map<String,String> guestVariable=machineIdSpec.toGuestVarialbe();
  VcVmUtil.addBootupUUID(guestVariable);
  String haFlag=clusterSpec.getNodeGroup(groupName).getHaFlag();
  boolean ha=false;
  boolean ft=false;
  if (haFlag != null && Constants.HA_FLAG_ON.equals(haFlag.toLowerCase())) {
    ha=true;
  }
  if (haFlag != null && Constants.HA_FLAG_FT.equals(haFlag.toLowerCase())) {
    ha=true;
    ft=true;
  }
  ReplaceVmPrePowerOn prePowerOn=new ReplaceVmPrePowerOn(node.getMoId(),node.getVmName(),clusterSpec.getNodeGroup(groupName).getStorage().getShares(),createSchema.networkSchema,ha,ft);
  return new CreateVmSP(node.getVmName() + RECOVERY_VM_NAME_POSTFIX,createSchema,VcVmUtil.getTargetRp(clusterSpec.getName(),groupName,node),getTargetDatastore(fullDiskSet),prePowerOn,null,guestVariable,false,getTargetFolder(node),getTargetHost(node));
}"
48783,"private Folder getTargetFolder(NodeEntity node,NodeGroupCreate nodeGroup){
  VcVirtualMachine vm=VcCache.get(node.getMoId());
  String folderPath=nodeGroup.getVmFolderPath();
  List<String> folderNames=Arrays.asList(folderPath.split(""String_Node_Str""));
  AuAssert.check(!folderNames.isEmpty());
  return VcResourceUtils.findFolderByNameList(vm.getDatacenter(),folderNames);
}","private Folder getTargetFolder(NodeEntity node){
  VcVirtualMachine vm=VcCache.get(node.getMoId());
  return vm.getParentFolder();
}"
48784,"private void processEvent(VcEventType type,Event e,String moId,boolean external) throws Exception {
  try {
switch (type) {
case VmRemoved:
{
        logger.debug(""String_Node_Str"" + moId);
        if (clusterEntityMgr.getNodeByMobId(moId) != null) {
          clusterEntityMgr.refreshNodeByMobId(moId,null,true);
        }
        break;
      }
case VmDisconnected:
{
      VcVirtualMachine vm=VcCache.getIgnoreMissing(e.getVm().getVm());
      if (vm == null) {
        if (clusterEntityMgr.getNodeByMobId(moId) != null) {
          logger.debug(""String_Node_Str"" + moId + ""String_Node_Str"");
          clusterEntityMgr.removeVmReference(moId);
        }
        break;
      }
      if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
        vm.updateRuntime();
        if ((!vm.isConnected()) || vm.getHost().isUnavailbleForManagement()) {
          clusterEntityMgr.setNodeConnectionState(vm.getName());
          logConnectionChangeEvent(vm.getName());
        }
      }
      break;
    }
case VmPoweredOn:
{
    refreshNodeWithAction(e,moId,true,Constants.NODE_ACTION_WAITING_IP,""String_Node_Str"");
    if (external) {
      NodePowerOnRequest request=new NodePowerOnRequest(clusterEntityMgr,moId);
      CmsWorker.addRequest(WorkQueue.VC_TASK_NO_DELAY,request);
    }
    break;
  }
case VmCloned:
{
  refreshNodeWithAction(e,moId,true,Constants.NODE_ACTION_RECONFIGURE,""String_Node_Str"");
  break;
}
case VmSuspended:
{
refreshNodeWithAction(e,moId,true,null,""String_Node_Str"");
break;
}
case VmPoweredOff:
{
refreshNodeWithAction(e,moId,true,null,""String_Node_Str"");
break;
}
case VmConnected:
{
try {
refreshNodeWithAction(e,moId,false,null,type.name());
}
 catch (AuroraException ex) {
logger.error(""String_Node_Str"" + ex.getMessage() + ""String_Node_Str"");
}
break;
}
case VhmError:
case VhmWarning:
{
EventEx event=(EventEx)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
break;
}
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + event.getEventTypeId() + ""String_Node_Str""+ vm.getName()+ ""String_Node_Str""+ event.getMessage());
vm.updateRuntime();
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),event.getMessage(),true);
}
break;
}
case VhmInfo:
{
EventEx event=(EventEx)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
break;
}
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + event.getEventTypeId() + ""String_Node_Str""+ vm.getName()+ ""String_Node_Str""+ event.getMessage());
vm.updateRuntime();
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),""String_Node_Str"",true);
}
break;
}
default :
{
if (external) {
VcVirtualMachine vm=VcCache.getIgnoreMissing(moId);
if (vm == null) {
break;
}
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),true);
}
break;
}
}
}
 catch (ManagedObjectNotFound exp) {
VcUtil.processNotFoundException(exp,moId,logger);
}
}","private void processEvent(VcEventType type,Event e,String moId,boolean external) throws Exception {
  try {
switch (type) {
case VmRemoved:
{
        logger.debug(""String_Node_Str"" + moId);
        if (clusterEntityMgr.getNodeByMobId(moId) != null) {
          clusterEntityMgr.refreshNodeByMobId(moId,null,true);
        }
        break;
      }
case VmDisconnected:
{
      VcVirtualMachine vm=VcCache.getIgnoreMissing(moId);
      if (vm == null) {
        if (clusterEntityMgr.getNodeByMobId(moId) != null) {
          logger.debug(""String_Node_Str"" + moId + ""String_Node_Str"");
          clusterEntityMgr.removeVmReference(moId);
        }
        break;
      }
      if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
        vm.updateRuntime();
        if ((!vm.isConnected()) || vm.getHost().isUnavailbleForManagement()) {
          clusterEntityMgr.setNodeConnectionState(vm.getName());
          logConnectionChangeEvent(vm.getName());
        }
      }
      break;
    }
case VmPoweredOn:
{
    refreshNodeWithAction(moId,true,Constants.NODE_ACTION_WAITING_IP,""String_Node_Str"");
    if (external) {
      NodePowerOnRequest request=new NodePowerOnRequest(clusterEntityMgr,moId);
      CmsWorker.addRequest(WorkQueue.VC_TASK_NO_DELAY,request);
    }
    break;
  }
case VmCloned:
{
  refreshNodeWithAction(moId,true,Constants.NODE_ACTION_RECONFIGURE,""String_Node_Str"");
  break;
}
case VmSuspended:
{
refreshNodeWithAction(moId,true,null,""String_Node_Str"");
break;
}
case VmPoweredOff:
{
refreshNodeWithAction(moId,true,null,""String_Node_Str"");
break;
}
case VmConnected:
{
try {
refreshNodeWithAction(moId,false,null,type.name());
}
 catch (AuroraException ex) {
logger.error(""String_Node_Str"" + ex.getMessage() + ""String_Node_Str"");
}
break;
}
case VhmError:
case VhmWarning:
{
EventEx event=(EventEx)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
break;
}
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + event.getEventTypeId() + ""String_Node_Str""+ vm.getName()+ ""String_Node_Str""+ event.getMessage());
vm.updateRuntime();
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),event.getMessage(),true);
}
break;
}
case VhmInfo:
{
EventEx event=(EventEx)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
break;
}
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + event.getEventTypeId() + ""String_Node_Str""+ vm.getName()+ ""String_Node_Str""+ event.getMessage());
vm.updateRuntime();
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),""String_Node_Str"",true);
}
break;
}
default :
{
if (external) {
VcVirtualMachine vm=VcCache.getIgnoreMissing(moId);
if (vm == null) {
break;
}
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),true);
}
break;
}
}
}
 catch (ManagedObjectNotFound exp) {
VcUtil.processNotFoundException(exp,moId,logger);
}
}"
48785,"private void refreshNodeWithAction(Event e,String moId,boolean setAction,String action,String eventName) throws Exception {
  VcVirtualMachine vm=VcCache.getIgnoreMissing(e.getVm().getVm());
  if (vm == null) {
    return;
  }
  if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
    logger.info(""String_Node_Str"" + eventName + ""String_Node_Str""+ vm.getName());
    vm.updateRuntime();
    if (setAction) {
      clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),action,true);
    }
 else {
      clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),true);
    }
  }
  return;
}","private void refreshNodeWithAction(String moId,boolean setAction,String action,String eventName) throws Exception {
  VcVirtualMachine vm=VcCache.getIgnoreMissing(moId);
  if (vm == null) {
    return;
  }
  if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
    logger.info(""String_Node_Str"" + eventName + ""String_Node_Str""+ vm.getName());
    vm.updateRuntime();
    if (setAction) {
      clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),action,true);
    }
 else {
      clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),true);
    }
  }
  return;
}"
48786,"private boolean processExternalEvent(VcEventType type,Event e,String moId) throws Exception {
  if (clusterEntityMgr.getNodeByMobId(moId) != null) {
    return true;
  }
  if (type != VcEventType.VmRemoved) {
    VcVirtualMachine vm=VcCache.getIgnoreMissing(e.getVm().getVm());
    if (vm == null) {
      return false;
    }
    logger.debug(""String_Node_Str"");
    if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null && VcResourceUtils.insidedRootFolder(vm)) {
      logger.info(""String_Node_Str"" + vm.getName() + ""String_Node_Str"");
      return true;
    }
  }
  return false;
}","private boolean processExternalEvent(VcEventType type,Event e,String moId) throws Exception {
  if (clusterEntityMgr.getNodeByMobId(moId) != null) {
    return true;
  }
  if (type != VcEventType.VmRemoved) {
    VcVirtualMachine vm=VcCache.getIgnoreMissing(e.getVm().getVm());
    if (vm == null) {
      return false;
    }
    logger.debug(""String_Node_Str"");
    if (rootSerengetiFolder == null) {
      initRootFolder();
    }
    if (rootSerengetiFolder == null) {
      return false;
    }
    if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null && VcResourceUtils.insidedRootFolder(rootSerengetiFolder,vm)) {
      logger.info(""String_Node_Str"" + vm.getName() + ""String_Node_Str"");
      return true;
    }
  }
  return false;
}"
48787,"public static boolean insidedRootFolder(VcVirtualMachine vm){
  String root=ConfigInfo.getSerengetiRootFolder();
  List<String> folderNames=new ArrayList<String>();
  folderNames.add(root);
  String[] split=vm.getName().split(""String_Node_Str"");
  AuAssert.check(split != null && split.length == 3);
  folderNames.add(split[0]);
  folderNames.add(split[1]);
  Folder folder=null;
  try {
    folder=VcResourceUtils.findFolderByNameList(vm.getDatacenter(),folderNames);
  }
 catch (  Exception e) {
    logger.debug(""String_Node_Str"",e);
  }
  if (folder != null) {
    return VcResourceUtils.isObjectInFolder(folder,vm.getId());
  }
 else {
    return false;
  }
}","public static boolean insidedRootFolder(final Folder rootFolder,final VcVirtualMachine vm){
  String[] split=vm.getName().split(""String_Node_Str"");
  if (split == null || split.length != 3) {
    logger.debug(""String_Node_Str"");
    return false;
  }
  final String groupFolderName=split[1];
  final String clusterFolderName=split[0];
  return VcContext.inVcSessionDo(new VcSession<Boolean>(){
    @Override protected Boolean body() throws Exception {
      try {
        Folder groupFolder=vm.getParentFolder();
        if (groupFolder == null || groupFolder.getName() == null || !groupFolder.getName().equals(groupFolderName)) {
          logger.debug(""String_Node_Str"");
          return false;
        }
        ManagedObjectReference mo=groupFolder.getParent();
        if (mo == null) {
          logger.debug(""String_Node_Str"");
          return false;
        }
        Folder clusterFolder=MoUtil.getManagedObject(mo);
        if (clusterFolder == null || clusterFolder.getName() == null || !clusterFolder.getName().equals(clusterFolderName)) {
          logger.debug(""String_Node_Str"");
          return false;
        }
        mo=clusterFolder.getParent();
        if (mo == null) {
          logger.debug(""String_Node_Str"");
          return false;
        }
        if (MoUtil.morefToString(mo).equals(MoUtil.morefToString(rootFolder._getRef()))) {
          return true;
        }
      }
 catch (      Exception e) {
        logger.info(""String_Node_Str"",e);
      }
      return false;
    }
  }
);
}"
48788,"@SuppressWarnings(""String_Node_Str"") public boolean setAutoElasticity(String clusterName,boolean refreshAllNodes){
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=getClusterEntityMgr().findByName(clusterName);
  List<NodeEntity> nodes=clusterEntityMgr.findAllNodes(clusterName);
  Boolean enableAutoElasticity=cluster.getAutomationEnable();
  if (enableAutoElasticity == null) {
    return true;
  }
  String masterMoId=cluster.getVhmMasterMoid();
  if (masterMoId == null) {
    updateVhmMasterMoid(clusterName);
    cluster=getClusterEntityMgr().findByName(clusterName);
    masterMoId=cluster.getVhmMasterMoid();
    if (masterMoId == null) {
      logger.error(""String_Node_Str"");
      throw ClusteringServiceException.SET_AUTO_ELASTICITY_FAILED(cluster.getName());
    }
  }
  String serengetiUUID=ConfigInfo.getSerengetiRootFolder();
  int minComputeNodeNum=cluster.getVhmMinNum();
  int maxComputeNodeNum=cluster.getVhmMaxNum();
  String jobTrackerPort=cluster.getVhmJobTrackerPort();
  VcVirtualMachine vcVm=VcCache.getIgnoreMissing(masterMoId);
  if (vcVm == null) {
    logger.error(""String_Node_Str"");
    return false;
  }
  String masterUUID=vcVm.getConfig().getUuid();
  Callable<Void>[] storeProcedures=new Callable[nodes.size()];
  int i=0;
  for (  NodeEntity node : nodes) {
    VcVirtualMachine vm=VcCache.getIgnoreMissing(node.getMoId());
    if (vm == null) {
      logger.error(""String_Node_Str"" + node.getVmName());
      continue;
    }
    if (!refreshAllNodes && !vm.getId().equalsIgnoreCase(masterMoId)) {
      continue;
    }
    List<String> roles=new Gson().fromJson(node.getNodeGroup().getRoles(),List.class);
    String distroVendor=node.getNodeGroup().getCluster().getDistroVendor();
    boolean isComputeOnlyNode=CommonUtil.isComputeOnly(roles,distroVendor);
    SetAutoElasticitySP sp=new SetAutoElasticitySP(vm,serengetiUUID,masterMoId,masterUUID,enableAutoElasticity,minComputeNodeNum,maxComputeNodeNum,jobTrackerPort,isComputeOnlyNode);
    storeProcedures[i]=sp;
    i++;
  }
  try {
    logger.info(""String_Node_Str"");
    boolean success=true;
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProcedures,callback);
    if (result == null) {
      logger.error(""String_Node_Str"");
      throw ClusteringServiceException.SET_AUTO_ELASTICITY_FAILED(clusterName);
    }
    for (i=0; i < storeProcedures.length; i++) {
      if (result[i].throwable != null) {
        logger.error(""String_Node_Str"",result[i].throwable);
        success=false;
      }
    }
    return success;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}","@SuppressWarnings(""String_Node_Str"") public boolean setAutoElasticity(String clusterName,boolean refreshAllNodes){
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=getClusterEntityMgr().findByName(clusterName);
  List<NodeEntity> nodes=clusterEntityMgr.findAllNodes(clusterName);
  Boolean enableAutoElasticity=cluster.getAutomationEnable();
  if (enableAutoElasticity == null) {
    return true;
  }
  String masterMoId=cluster.getVhmMasterMoid();
  if (masterMoId == null) {
    updateVhmMasterMoid(clusterName);
    cluster=getClusterEntityMgr().findByName(clusterName);
    masterMoId=cluster.getVhmMasterMoid();
    if (masterMoId == null) {
      logger.error(""String_Node_Str"");
      throw ClusteringServiceException.SET_AUTO_ELASTICITY_FAILED(cluster.getName());
    }
  }
  String serengetiUUID=ConfigInfo.getSerengetiRootFolder();
  int minComputeNodeNum=cluster.getVhmMinNum();
  int maxComputeNodeNum=cluster.getVhmMaxNum();
  String jobTrackerPort=cluster.getVhmJobTrackerPort();
  VcVirtualMachine vcVm=VcCache.getIgnoreMissing(masterMoId);
  if (vcVm == null) {
    logger.error(""String_Node_Str"");
    return false;
  }
  String masterUUID=vcVm.getConfig().getUuid();
  Callable<Void>[] storeProcedures=new Callable[nodes.size()];
  int i=0;
  for (  NodeEntity node : nodes) {
    VcVirtualMachine vm=VcCache.getIgnoreMissing(node.getMoId());
    if (vm == null) {
      logger.error(""String_Node_Str"" + node.getVmName());
      continue;
    }
    if (!refreshAllNodes && !vm.getId().equalsIgnoreCase(masterMoId)) {
      continue;
    }
    List<String> roles=new Gson().fromJson(node.getNodeGroup().getRoles(),List.class);
    String distroVendor=node.getNodeGroup().getCluster().getDistroVendor();
    boolean isComputeOnlyNode=CommonUtil.isComputeOnly(roles,distroVendor);
    SetAutoElasticitySP sp=new SetAutoElasticitySP(clusterName,vm,serengetiUUID,masterMoId,masterUUID,enableAutoElasticity,minComputeNodeNum,maxComputeNodeNum,jobTrackerPort,isComputeOnlyNode);
    storeProcedures[i]=sp;
    i++;
  }
  try {
    logger.info(""String_Node_Str"");
    boolean success=true;
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProcedures,callback);
    if (result == null) {
      logger.error(""String_Node_Str"");
      throw ClusteringServiceException.SET_AUTO_ELASTICITY_FAILED(clusterName);
    }
    for (i=0; i < storeProcedures.length; i++) {
      if (result[i].throwable != null) {
        logger.error(""String_Node_Str"",result[i].throwable);
        success=false;
      }
    }
    return success;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}"
48789,"public SetAutoElasticitySP(VcVirtualMachine vcVm,String serengetiUUID,String masterMoId,String masterUUID,Boolean enableAutoElasticity,int minComputeNodeNum,int maxComputeNodeNum,String jobTrackerPort,boolean isComputeOnlyNode){
  this.vcVm=vcVm;
  this.serengetiUUID=serengetiUUID;
  this.masterMoId=masterMoId;
  this.masterUUID=masterUUID;
  this.enableAutoElasticity=enableAutoElasticity;
  this.minComputeNodeNum=minComputeNodeNum;
  this.maxComputeNodeNum=maxComputeNodeNum;
  this.jobTrackerPort=jobTrackerPort;
  this.isComputeOnlyNode=isComputeOnlyNode;
}","public SetAutoElasticitySP(String clusterName,VcVirtualMachine vcVm,String serengetiUUID,String masterMoId,String masterUUID,Boolean enableAutoElasticity,int minComputeNodeNum,int maxComputeNodeNum,String jobTrackerPort,boolean isComputeOnlyNode){
  this.clusterName=clusterName;
  this.vcVm=vcVm;
  this.serengetiUUID=serengetiUUID;
  this.masterMoId=masterMoId;
  this.masterUUID=masterUUID;
  this.enableAutoElasticity=enableAutoElasticity;
  this.minComputeNodeNum=minComputeNodeNum;
  this.maxComputeNodeNum=maxComputeNodeNum;
  this.jobTrackerPort=jobTrackerPort;
  this.isComputeOnlyNode=isComputeOnlyNode;
}"
48790,"@Override public Void call() throws Exception {
  if (vcVm == null) {
    logger.info(""String_Node_Str"");
    return null;
  }
  final VcVirtualMachine vm=VcCache.getIgnoreMissing(vcVm.getId());
  if (vm == null) {
    logger.info(""String_Node_Str"");
  }
  VcContext.inVcSessionDo(new VcSession<Void>(){
    @Override protected Void body() throws Exception {
      List<OptionValue> options=new ArrayList<OptionValue>();
      if (vm.getId().equalsIgnoreCase(masterMoId)) {
        options.add(new OptionValueImpl(VHMConstants.VHM_ENABLE,enableAutoElasticity.toString()));
        options.add(new OptionValueImpl(VHMConstants.VHM_INSTANCERANGE_COMPUTENODE_NUM,(new Integer(minComputeNodeNum)).toString() + ""String_Node_Str"" + (new Integer(maxComputeNodeNum)).toString()));
        options.add(new OptionValueImpl(VHMConstants.VHM_JOBTRACKER_PORT,jobTrackerPort));
      }
      options.add(new OptionValueImpl(VHMConstants.VHM_MASTER_MOID,masterMoId.split(""String_Node_Str"")[2]));
      options.add(new OptionValueImpl(VHMConstants.VHM_MASTER_UUID,masterUUID));
      options.add(new OptionValueImpl(VHMConstants.VHM_SERENGETI_UUID,serengetiUUID));
      options.add(new OptionValueImpl(VHMConstants.VHM_ELASTIC,(new Boolean(isComputeOnlyNode)).toString()));
      OptionValue[] optionValues=options.toArray((OptionValue[])Array.newInstance(OptionValue.class,options.size()));
      ConfigSpec spec=new ConfigSpecImpl();
      spec.setExtraConfig(optionValues);
      vm.reconfigure(spec);
      logger.info(""String_Node_Str"" + masterMoId + ""String_Node_Str""+ masterUUID+ ""String_Node_Str""+ isComputeOnlyNode+ ""String_Node_Str""+ enableAutoElasticity+ ""String_Node_Str""+ jobTrackerPort+ ""String_Node_Str""+ minComputeNodeNum+ ""String_Node_Str""+ maxComputeNodeNum);
      return null;
    }
    protected boolean isTaskSession(){
      return true;
    }
  }
);
  return null;
}","@Override public Void call() throws Exception {
  if (vcVm == null) {
    logger.info(""String_Node_Str"");
    return null;
  }
  final VcVirtualMachine vm=VcCache.getIgnoreMissing(vcVm.getId());
  if (vm == null) {
    logger.info(""String_Node_Str"");
  }
  VcContext.inVcSessionDo(new VcSession<Void>(){
    @Override protected Void body() throws Exception {
      List<OptionValue> options=new ArrayList<OptionValue>();
      if (vm.getId().equalsIgnoreCase(masterMoId)) {
        options.add(new OptionValueImpl(VHMConstants.VHM_ENABLE,enableAutoElasticity.toString()));
        options.add(new OptionValueImpl(VHMConstants.VHM_INSTANCERANGE_COMPUTENODE_NUM,(new Integer(minComputeNodeNum)).toString() + ""String_Node_Str"" + (new Integer(maxComputeNodeNum)).toString()));
        options.add(new OptionValueImpl(VHMConstants.VHM_JOBTRACKER_PORT,jobTrackerPort));
        options.add(new OptionValueImpl(VHMConstants.VHM_CLUSTER_NAME,clusterName));
      }
      options.add(new OptionValueImpl(VHMConstants.VHM_MASTER_MOID,masterMoId.split(""String_Node_Str"")[2]));
      options.add(new OptionValueImpl(VHMConstants.VHM_MASTER_UUID,masterUUID));
      options.add(new OptionValueImpl(VHMConstants.VHM_SERENGETI_UUID,serengetiUUID));
      options.add(new OptionValueImpl(VHMConstants.VHM_ELASTIC,(new Boolean(isComputeOnlyNode)).toString()));
      OptionValue[] optionValues=options.toArray((OptionValue[])Array.newInstance(OptionValue.class,options.size()));
      ConfigSpec spec=new ConfigSpecImpl();
      spec.setExtraConfig(optionValues);
      vm.reconfigure(spec);
      logger.info(""String_Node_Str"" + masterMoId + ""String_Node_Str""+ masterUUID+ ""String_Node_Str""+ isComputeOnlyNode+ ""String_Node_Str""+ enableAutoElasticity+ ""String_Node_Str""+ jobTrackerPort+ ""String_Node_Str""+ minComputeNodeNum+ ""String_Node_Str""+ maxComputeNodeNum);
      return null;
    }
    protected boolean isTaskSession(){
      return true;
    }
  }
);
  return null;
}"
48791,"@Override protected Void body() throws Exception {
  List<OptionValue> options=new ArrayList<OptionValue>();
  if (vm.getId().equalsIgnoreCase(masterMoId)) {
    options.add(new OptionValueImpl(VHMConstants.VHM_ENABLE,enableAutoElasticity.toString()));
    options.add(new OptionValueImpl(VHMConstants.VHM_INSTANCERANGE_COMPUTENODE_NUM,(new Integer(minComputeNodeNum)).toString() + ""String_Node_Str"" + (new Integer(maxComputeNodeNum)).toString()));
    options.add(new OptionValueImpl(VHMConstants.VHM_JOBTRACKER_PORT,jobTrackerPort));
  }
  options.add(new OptionValueImpl(VHMConstants.VHM_MASTER_MOID,masterMoId.split(""String_Node_Str"")[2]));
  options.add(new OptionValueImpl(VHMConstants.VHM_MASTER_UUID,masterUUID));
  options.add(new OptionValueImpl(VHMConstants.VHM_SERENGETI_UUID,serengetiUUID));
  options.add(new OptionValueImpl(VHMConstants.VHM_ELASTIC,(new Boolean(isComputeOnlyNode)).toString()));
  OptionValue[] optionValues=options.toArray((OptionValue[])Array.newInstance(OptionValue.class,options.size()));
  ConfigSpec spec=new ConfigSpecImpl();
  spec.setExtraConfig(optionValues);
  vm.reconfigure(spec);
  logger.info(""String_Node_Str"" + masterMoId + ""String_Node_Str""+ masterUUID+ ""String_Node_Str""+ isComputeOnlyNode+ ""String_Node_Str""+ enableAutoElasticity+ ""String_Node_Str""+ jobTrackerPort+ ""String_Node_Str""+ minComputeNodeNum+ ""String_Node_Str""+ maxComputeNodeNum);
  return null;
}","@Override protected Void body() throws Exception {
  List<OptionValue> options=new ArrayList<OptionValue>();
  if (vm.getId().equalsIgnoreCase(masterMoId)) {
    options.add(new OptionValueImpl(VHMConstants.VHM_ENABLE,enableAutoElasticity.toString()));
    options.add(new OptionValueImpl(VHMConstants.VHM_INSTANCERANGE_COMPUTENODE_NUM,(new Integer(minComputeNodeNum)).toString() + ""String_Node_Str"" + (new Integer(maxComputeNodeNum)).toString()));
    options.add(new OptionValueImpl(VHMConstants.VHM_JOBTRACKER_PORT,jobTrackerPort));
    options.add(new OptionValueImpl(VHMConstants.VHM_CLUSTER_NAME,clusterName));
  }
  options.add(new OptionValueImpl(VHMConstants.VHM_MASTER_MOID,masterMoId.split(""String_Node_Str"")[2]));
  options.add(new OptionValueImpl(VHMConstants.VHM_MASTER_UUID,masterUUID));
  options.add(new OptionValueImpl(VHMConstants.VHM_SERENGETI_UUID,serengetiUUID));
  options.add(new OptionValueImpl(VHMConstants.VHM_ELASTIC,(new Boolean(isComputeOnlyNode)).toString()));
  OptionValue[] optionValues=options.toArray((OptionValue[])Array.newInstance(OptionValue.class,options.size()));
  ConfigSpec spec=new ConfigSpecImpl();
  spec.setExtraConfig(optionValues);
  vm.reconfigure(spec);
  logger.info(""String_Node_Str"" + masterMoId + ""String_Node_Str""+ masterUUID+ ""String_Node_Str""+ isComputeOnlyNode+ ""String_Node_Str""+ enableAutoElasticity+ ""String_Node_Str""+ jobTrackerPort+ ""String_Node_Str""+ minComputeNodeNum+ ""String_Node_Str""+ maxComputeNodeNum);
  return null;
}"
48792,"private void redirectRequest(long taskId,HttpServletRequest request,HttpServletResponse response){
  StringBuffer url=request.getRequestURL();
  int subLength=url.length() - request.getPathInfo().length();
  url.setLength(subLength);
  url.append(""String_Node_Str"").append(Long.toString(taskId));
  response.setHeader(""String_Node_Str"",url.toString());
}","private void redirectRequest(long taskId,HttpServletRequest request,HttpServletResponse response){
  StringBuffer url=request.getRequestURL();
  String pathInfo=request.getPathInfo();
  if (!CommonUtil.validataPathInfo(pathInfo)) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",pathInfo);
  }
  int subLength=url.length() - pathInfo.length();
  url.setLength(subLength);
  url.append(""String_Node_Str"").append(Long.toString(taskId));
  response.setHeader(""String_Node_Str"",url.toString());
}"
48793,"@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  if (clusterName == null) {
    clusterName=getJobParameters(chunkContext).getString(JobConstants.TARGET_NAME_JOB_PARAM).split(""String_Node_Str"")[0];
  }
  getClusterEntityMgr().syncUp(clusterName,false);
  Boolean success=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_OPERATION_SUCCESS,Boolean.class);
  if (success != null && !success) {
    throw ClusteringServiceException.CLUSTER_OPERATION_FAILED(clusterName);
  }
  NodeStatus expectedStatus=getFromJobExecutionContext(chunkContext,JobConstants.EXPECTED_NODE_STATUS,NodeStatus.class);
  if (expectedStatus != null) {
    logger.info(""String_Node_Str"" + expectedStatus);
    List<NodeEntity> nodes=getClusterEntityMgr().findAllNodes(clusterName);
    JobUtils.verifyNodesStatus(nodes,expectedStatus,true);
  }
  return RepeatStatus.FINISHED;
}","@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  if (clusterName == null) {
    clusterName=getJobParameters(chunkContext).getString(JobConstants.TARGET_NAME_JOB_PARAM).split(""String_Node_Str"")[0];
  }
synchronized (getClusterEntityMgr()) {
    VmEventProcessor processor=clusteringService.getEventProcessor();
    processor.trySuspend();
    getClusterEntityMgr().syncUp(clusterName,false);
  }
  Boolean success=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_OPERATION_SUCCESS,Boolean.class);
  if (success != null && !success) {
    throw ClusteringServiceException.CLUSTER_OPERATION_FAILED(clusterName);
  }
  NodeStatus expectedStatus=getFromJobExecutionContext(chunkContext,JobConstants.EXPECTED_NODE_STATUS,NodeStatus.class);
  if (expectedStatus != null) {
    logger.info(""String_Node_Str"" + expectedStatus);
    List<NodeEntity> nodes=getClusterEntityMgr().findAllNodes(clusterName);
    JobUtils.verifyNodesStatus(nodes,expectedStatus,true);
  }
  return RepeatStatus.FINISHED;
}"
48794,"@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  List<BaseNode> addedNodes=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_ADDED_NODES_JOB_PARAM,new TypeToken<List<BaseNode>>(){
  }
.getType());
  List<BaseNode> deletedNodes=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_DELETED_NODES_JOB_PARAM,new TypeToken<List<BaseNode>>(){
  }
.getType());
  Set<String> deletedNodeNames=new HashSet<String>();
  if (deletedNodes != null) {
    for (    BaseNode node : deletedNodes) {
      deletedNodeNames.add(node.getVmName());
    }
  }
synchronized (getClusterEntityMgr()) {
    addNodeToMetaData(clusterName,addedNodes,deletedNodeNames);
    removeDeletedNode(clusterName,deletedNodeNames);
  }
  return RepeatStatus.FINISHED;
}","@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  List<BaseNode> addedNodes=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_ADDED_NODES_JOB_PARAM,new TypeToken<List<BaseNode>>(){
  }
.getType());
  List<BaseNode> deletedNodes=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_DELETED_NODES_JOB_PARAM,new TypeToken<List<BaseNode>>(){
  }
.getType());
  Set<String> deletedNodeNames=new HashSet<String>();
  if (deletedNodes != null) {
    for (    BaseNode node : deletedNodes) {
      deletedNodeNames.add(node.getVmName());
    }
  }
synchronized (getClusterEntityMgr()) {
    VmEventProcessor processor=clusteringService.getEventProcessor();
    processor.trySuspend();
    addNodeToMetaData(clusterName,addedNodes,deletedNodeNames);
    removeDeletedNode(clusterName,deletedNodeNames);
  }
  return RepeatStatus.FINISHED;
}"
48795,"private void deleteClusterNodes(String clusterName,boolean success){
  ClusterEntity cluster=getClusterEntityMgr().findByName(clusterName);
  AuAssert.check(cluster != null);
  if (success) {
    releaseIp(cluster);
    getClusterEntityMgr().delete(cluster);
  }
}","private void deleteClusterNodes(String clusterName,boolean success){
  ClusterEntity cluster=getClusterEntityMgr().findByName(clusterName);
  AuAssert.check(cluster != null);
  if (success) {
    releaseIp(cluster);
synchronized (getClusterEntityMgr()) {
      VmEventProcessor processor=clusteringService.getEventProcessor();
      processor.trySuspend();
      getClusterEntityMgr().delete(cluster);
    }
  }
}"
48796,"@Override public ExitStatus afterStep(StepExecution se){
  logger.info(""String_Node_Str"" + se.getStepName());
  ExecutionContext jec=se.getJobExecution().getExecutionContext();
  if (se.getStatus().equals(BatchStatus.COMPLETED)) {
    jec.put(se.getStepName() + ""String_Node_Str"",true);
    jobExecutionStatusHolder.setCurrentStepProgress(se.getJobExecution().getId(),1);
  }
 else {
    for (    Throwable t : se.getFailureExceptions()) {
      String msg=t.getMessage();
      if (msg != null && !msg.isEmpty()) {
        TrackableTasklet.putIntoJobExecutionContext(jec,JobConstants.CURRENT_ERROR_MESSAGE,msg);
        break;
      }
    }
  }
  return se.getExitStatus();
}","@Override public ExitStatus afterStep(StepExecution se){
  logger.info(""String_Node_Str"" + se.getStepName());
  VmEventProcessor processor=clusteringService.getEventProcessor();
  processor.tryResume();
  ExecutionContext jec=se.getJobExecution().getExecutionContext();
  if (se.getStatus().equals(BatchStatus.COMPLETED)) {
    jec.put(se.getStepName() + ""String_Node_Str"",true);
    jobExecutionStatusHolder.setCurrentStepProgress(se.getJobExecution().getId(),1);
  }
 else {
    for (    Throwable t : se.getFailureExceptions()) {
      String msg=t.getMessage();
      if (msg != null && !msg.isEmpty()) {
        TrackableTasklet.putIntoJobExecutionContext(jec,JobConstants.CURRENT_ERROR_MESSAGE,msg);
        break;
      }
    }
  }
  return se.getExitStatus();
}"
48797,"private boolean isValidPassword(String password){
  if (password.length() < Constants.PASSWORD_MIN_LENGTH || password.length() > Constants.PASSWORD_MAX_LENGTH) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,null,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PASSWORD_LENGTH_INVALID);
    return false;
  }
  return true;
}","private boolean isValidPassword(String password){
  if (password.length() < Constants.PASSWORD_MIN_LENGTH || password.length() > Constants.PASSWORD_MAX_LENGTH) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,null,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PASSWORD_LENGTH_REQUIREMENT);
    return false;
  }
  return true;
}"
48798,"private String getPassword(){
  String firstPassword=getInputedPassword(Constants.ENTER_PASSWORD);
  if (firstPassword == null) {
    return null;
  }
  String secondPassword=getInputedPassword(Constants.CONFIRM_PASSWORD);
  if (secondPassword == null) {
    return null;
  }
  if (!firstPassword.equals(secondPassword)) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,null,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PASSWORD_CONFIRMATION_FAILED);
    return null;
  }
  return firstPassword;
}","private String getPassword(){
  System.out.println(""String_Node_Str"" + Constants.PASSWORD_LENGTH_REQUIREMENT);
  String firstPassword=getInputedPassword(Constants.ENTER_PASSWORD);
  if (firstPassword == null) {
    return null;
  }
  String secondPassword=getInputedPassword(Constants.CONFIRM_PASSWORD);
  if (secondPassword == null) {
    return null;
  }
  if (!firstPassword.equals(secondPassword)) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,null,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PASSWORD_CONFIRMATION_FAILED);
    return null;
  }
  return firstPassword;
}"
48799,"@Transactional private void replaceNodeEntity(BaseNode vNode){
  logger.info(""String_Node_Str"" + vNode.getVmName());
  ClusterEntity cluster=getClusterEntityMgr().findByName(vNode.getClusterName());
  AuAssert.check(cluster != null);
  NodeGroupEntity nodeGroupEntity=getClusterEntityMgr().findByName(vNode.getClusterName(),vNode.getGroupName());
  AuAssert.check(nodeGroupEntity != null);
  if (nodeGroupEntity.getNodes() == null) {
    nodeGroupEntity.setNodes(new LinkedList<NodeEntity>());
  }
  boolean insert=false;
  NodeEntity nodeEntity=getClusterEntityMgr().findByName(nodeGroupEntity,vNode.getVmName());
  if (nodeEntity == null) {
    nodeEntity=new NodeEntity();
    nodeGroupEntity.getNodes().add(nodeEntity);
    insert=true;
  }
  nodeEntity.setVmName(vNode.getVmName());
  setNodeStatus(nodeEntity,vNode);
  if (vNode.getVmMobId() == null && nodeEntity.getMoId() != null) {
    vNode.setVmMobId(nodeEntity.getMoId());
  }
  nodeEntity.setVcRp(rpDao.findByClusterAndRp(vNode.getTargetVcCluster(),vNode.getTargetRp()));
  if (vNode.getVmMobId() != null) {
    nodeEntity.setMoId(vNode.getVmMobId());
    nodeEntity.setRack(vNode.getTargetRack());
    nodeEntity.setHostName(vNode.getTargetHost());
    nodeEntity.setIpConfigs(vNode.getIpConfigs());
    nodeEntity.setGuestHostName(vNode.getGuestHostName());
    nodeEntity.setCpuNum(vNode.getCpu());
    nodeEntity.setMemorySize((long)vNode.getMem());
    Set<DiskEntity> diskEntities=nodeEntity.getDisks();
    DiskEntity systemDisk=nodeEntity.findSystemDisk();
    if (systemDisk == null)     systemDisk=new DiskEntity(nodeEntity.getVmName() + ""String_Node_Str"");
    systemDisk.setDiskType(DiskType.SYSTEM_DISK.getType());
    systemDisk.setExternalAddress(DiskEntity.getSystemDiskExternalAddress());
    systemDisk.setNodeEntity(nodeEntity);
    systemDisk.setDatastoreName(vNode.getTargetDs());
    VcVmUtil.populateDiskInfo(systemDisk,vNode.getVmMobId());
    diskEntities.add(systemDisk);
    for (    Disk disk : vNode.getVmSchema().diskSchema.getDisks()) {
      DiskEntity newDisk=nodeEntity.findDisk(disk.name);
      if (newDisk == null) {
        newDisk=new DiskEntity(disk.name);
        diskEntities.add(newDisk);
      }
      newDisk.setSizeInMB(disk.initialSizeMB);
      newDisk.setAllocType(disk.allocationType.toString());
      newDisk.setDatastoreName(disk.datastore);
      newDisk.setDiskType(disk.type);
      newDisk.setExternalAddress(disk.externalAddress);
      newDisk.setNodeEntity(nodeEntity);
      VcVmUtil.populateDiskInfo(newDisk,vNode.getVmMobId());
    }
  }
  nodeEntity.setNodeGroup(nodeGroupEntity);
  if (insert) {
    getClusterEntityMgr().insert(nodeEntity);
  }
 else {
    getClusterEntityMgr().update(nodeEntity);
  }
  logger.info(""String_Node_Str"" + vNode.getVmName());
}","@Transactional private void replaceNodeEntity(BaseNode vNode){
  logger.info(""String_Node_Str"" + vNode.getVmName());
  ClusterEntity cluster=getClusterEntityMgr().findByName(vNode.getClusterName());
  AuAssert.check(cluster != null);
  NodeGroupEntity nodeGroupEntity=getClusterEntityMgr().findByName(vNode.getClusterName(),vNode.getGroupName());
  AuAssert.check(nodeGroupEntity != null);
  if (nodeGroupEntity.getNodes() == null) {
    nodeGroupEntity.setNodes(new LinkedList<NodeEntity>());
  }
  boolean insert=false;
  NodeEntity nodeEntity=getClusterEntityMgr().findByName(nodeGroupEntity,vNode.getVmName());
  if (nodeEntity == null) {
    nodeEntity=new NodeEntity();
    nodeGroupEntity.getNodes().add(nodeEntity);
    insert=true;
  }
  nodeEntity.setVmName(vNode.getVmName());
  setNodeStatus(nodeEntity,vNode);
  if (vNode.getVmMobId() == null && nodeEntity.getMoId() != null) {
    vNode.setVmMobId(nodeEntity.getMoId());
  }
  nodeEntity.setVcRp(rpDao.findByClusterAndRp(vNode.getTargetVcCluster(),vNode.getTargetRp()));
  nodeEntity.setIpConfigs(vNode.getIpConfigs());
  if (vNode.getVmMobId() != null) {
    nodeEntity.setMoId(vNode.getVmMobId());
    nodeEntity.setRack(vNode.getTargetRack());
    nodeEntity.setHostName(vNode.getTargetHost());
    nodeEntity.setGuestHostName(vNode.getGuestHostName());
    nodeEntity.setCpuNum(vNode.getCpu());
    nodeEntity.setMemorySize((long)vNode.getMem());
    Set<DiskEntity> diskEntities=nodeEntity.getDisks();
    DiskEntity systemDisk=nodeEntity.findSystemDisk();
    if (systemDisk == null)     systemDisk=new DiskEntity(nodeEntity.getVmName() + ""String_Node_Str"");
    systemDisk.setDiskType(DiskType.SYSTEM_DISK.getType());
    systemDisk.setExternalAddress(DiskEntity.getSystemDiskExternalAddress());
    systemDisk.setNodeEntity(nodeEntity);
    systemDisk.setDatastoreName(vNode.getTargetDs());
    VcVmUtil.populateDiskInfo(systemDisk,vNode.getVmMobId());
    diskEntities.add(systemDisk);
    for (    Disk disk : vNode.getVmSchema().diskSchema.getDisks()) {
      DiskEntity newDisk=nodeEntity.findDisk(disk.name);
      if (newDisk == null) {
        newDisk=new DiskEntity(disk.name);
        diskEntities.add(newDisk);
      }
      newDisk.setSizeInMB(disk.initialSizeMB);
      newDisk.setAllocType(disk.allocationType.toString());
      newDisk.setDatastoreName(disk.datastore);
      newDisk.setDiskType(disk.type);
      newDisk.setExternalAddress(disk.externalAddress);
      newDisk.setNodeEntity(nodeEntity);
      VcVmUtil.populateDiskInfo(newDisk,vNode.getVmMobId());
    }
  }
  nodeEntity.setNodeGroup(nodeGroupEntity);
  if (insert) {
    getClusterEntityMgr().insert(nodeEntity);
  }
 else {
    getClusterEntityMgr().update(nodeEntity);
  }
  logger.info(""String_Node_Str"" + vNode.getVmName());
}"
48800,"@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  List<BaseNode> addedNodes=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_ADDED_NODES_JOB_PARAM,new TypeToken<List<BaseNode>>(){
  }
.getType());
  List<BaseNode> deletedNodes=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_DELETED_NODES_JOB_PARAM,new TypeToken<List<BaseNode>>(){
  }
.getType());
  Set<String> deletedNodeNames=new HashSet<String>();
  if (deletedNodes != null) {
    for (    BaseNode node : deletedNodes) {
      deletedNodeNames.add(node.getVmName());
    }
  }
synchronized (getClusterEntityMgr()) {
    VmEventProcessor processor=clusteringService.getEventProcessor();
    processor.trySuspend();
    addNodeToMetaData(clusterName,addedNodes,deletedNodeNames);
    removeDeletedNode(clusterName,deletedNodeNames);
  }
  return RepeatStatus.FINISHED;
}","@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  List<BaseNode> addedNodes=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_ADDED_NODES_JOB_PARAM,new TypeToken<List<BaseNode>>(){
  }
.getType());
  List<BaseNode> deletedNodes=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_DELETED_NODES_JOB_PARAM,new TypeToken<List<BaseNode>>(){
  }
.getType());
  Set<String> deletedNodeNames=new HashSet<String>();
  if (deletedNodes != null) {
    for (    BaseNode node : deletedNodes) {
      deletedNodeNames.add(node.getVmName());
    }
  }
synchronized (getClusterEntityMgr()) {
    VmEventProcessor processor=clusteringService.getEventProcessor();
    processor.trySuspend();
    addNodeToMetaData(clusterName,addedNodes,deletedNodeNames);
    removeDeletedNode(clusterName,deletedNodeNames);
    if (chunkContext.getStepContext().getJobName().equals(JobConstants.RESUME_CLUSTER_JOB_NAME)) {
      clusterEntityMgr.syncUp(clusterName,false);
    }
  }
  return RepeatStatus.FINISHED;
}"
48801,"/** 
 * This sends a URL POST request to the Extension vService guest API to register a new extension. Upon success, set vcExtensionRegistered to true. Note that the extension will not be fully configured until we log in to VC as this extension and make some VMODL calls to finish the job. Note also that we only need to do this once per CMS install, not once per CMS startup, but it doesn't seem to hurt to do it every time.
 * @synchronized for preventing concurrent call to register EVS.
 */
private static synchronized void registerExtensionVService(){
  if (vcExtensionRegistered) {
    return;
  }
  logger.debug(""String_Node_Str"" + evsURL + ""String_Node_Str""+ evsToken);
  try {
    Certificate cert=CmsKeyStore.getCertificate(CmsKeyStore.VC_EXT_KEY);
    URL url=new URL(evsURL);
    URLConnection connection=url.openConnection();
    connection.setRequestProperty(""String_Node_Str"",evsToken);
    connection.setDoInput(true);
    connection.setDoOutput(true);
    connection.setUseCaches(false);
    Writer output=new OutputStreamWriter(connection.getOutputStream());
    String evsSchema=""String_Node_Str"";
    String payload=""String_Node_Str"" + evsSchema + ""String_Node_Str""+ ""String_Node_Str""+ extKey+ ""String_Node_Str""+ ""String_Node_Str""+ CertificateToPem(cert)+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    output.write(payload);
    output.flush();
    connection.connect();
    Map<String,List<String>> headers=connection.getHeaderFields();
    for (    Map.Entry<String,List<String>> e : headers.entrySet()) {
      for (      String val : e.getValue()) {
        logger.info(""String_Node_Str"" + e.getKey() + ""String_Node_Str""+ val);
      }
    }
    BufferedReader input=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    for (String str=input.readLine(); str != null; str=input.readLine()) {
      logger.debug(""String_Node_Str"" + str);
    }
    input.close();
    output.close();
    vcExtensionRegistered=true;
    logger.debug(""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + evsURL,e);
  }
}","/** 
 * This sends a URL POST request to the Extension vService guest API to register a new extension. Upon success, set vcExtensionRegistered to true. Note that the extension will not be fully configured until we log in to VC as this extension and make some VMODL calls to finish the job. Note also that we only need to do this once per CMS install, not once per CMS startup, but it doesn't seem to hurt to do it every time.
 * @synchronized for preventing concurrent call to register EVS.
 */
private static synchronized void registerExtensionVService(){
  if (vcExtensionRegistered) {
    return;
  }
  logger.debug(""String_Node_Str"" + evsURL + ""String_Node_Str""+ evsToken);
  Writer output=null;
  BufferedReader input=null;
  try {
    Certificate cert=CmsKeyStore.getCertificate(CmsKeyStore.VC_EXT_KEY);
    URL url=new URL(evsURL);
    URLConnection connection=url.openConnection();
    connection.setRequestProperty(""String_Node_Str"",evsToken);
    connection.setDoInput(true);
    connection.setDoOutput(true);
    connection.setUseCaches(false);
    output=new OutputStreamWriter(connection.getOutputStream());
    String evsSchema=""String_Node_Str"";
    String payload=""String_Node_Str"" + evsSchema + ""String_Node_Str""+ ""String_Node_Str""+ extKey+ ""String_Node_Str""+ ""String_Node_Str""+ CertificateToPem(cert)+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    output.write(payload);
    output.flush();
    connection.connect();
    Map<String,List<String>> headers=connection.getHeaderFields();
    for (    Map.Entry<String,List<String>> e : headers.entrySet()) {
      for (      String val : e.getValue()) {
        logger.info(""String_Node_Str"" + e.getKey() + ""String_Node_Str""+ val);
      }
    }
    input=new BufferedReader(new InputStreamReader(connection.getInputStream()));
    for (String str=input.readLine(); str != null; str=input.readLine()) {
      logger.debug(""String_Node_Str"" + str);
    }
    vcExtensionRegistered=true;
    logger.debug(""String_Node_Str"");
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + evsURL,e);
  }
 finally {
    if (output != null) {
      try {
        output.close();
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"",e);
      }
    }
    if (input != null) {
      try {
        input.close();
      }
 catch (      IOException e) {
        logger.error(""String_Node_Str"",e);
      }
    }
  }
}"
48802,"@Override @Transactional(readOnly=true) public List<IpBlockEntity> findAllIpBlocks(NetworkEntity entity){
  AuAssert.check(entity.getAllocType() == AllocType.IP_POOL,""String_Node_Str"");
  return iIpBlockDao.merge(IpBlockEntity.dup(entity.getIpBlocks()),true,true,false);
}","@Override @Transactional(readOnly=true) public List<IpBlockEntity> findAllIpBlocks(NetworkEntity entity){
  AuAssert.check(entity.getAllocType() == AllocType.IP_POOL,""String_Node_Str"");
  return iIpBlockDao.merge(IpBlockEntity.dup(entity.getIpBlocks()),true,true,true);
}"
48803,"private boolean containInvalidCharacter(String password){
  Pattern pattern=Pattern.compile(""String_Node_Str"");
  Matcher matcher=pattern.matcher(password);
  if (matcher.matches()) {
    return false;
  }
  return true;
}","private boolean containInvalidCharacter(String password){
  if (password.contains(Constants.NEW_LINE)) {
    return true;
  }
  return false;
}"
48804,"private boolean setPasswordForNode() throws Exception {
  logger.info(""String_Node_Str"" + nodeIP);
  String privateKeyFile=Configuration.getString(Constants.SSH_PRIVATE_KEY_CONFIG_NAME,Constants.SSH_PRIVATE_KEY_FILE_NAME);
  String sshUser=Configuration.getString(Constants.SSH_USER_CONFIG_NAME,Constants.DEFAULT_SSH_USER_NAME);
  int sshPort=Configuration.getInt(Constants.SSH_PORT_CONFIG_NAME,Constants.DEFAULT_SSH_PORT);
  String cmd=generateSetPasswdCommand(Constants.SET_PASSWORD_SCRIPT_CONFIG_NAME,password);
  boolean setPasswordSucceed=false;
  for (int i=0; i < Constants.SET_PASSWORD_MAX_RETRY_TIMES; i++) {
    SSHUtil sshUtil=new SSHUtil();
    setPasswordSucceed=sshUtil.execCmd(sshUser,privateKeyFile,nodeIP,sshPort,cmd);
    if (setPasswordSucceed) {
      break;
    }
 else {
      logger.info(""String_Node_Str"" + nodeIP + ""String_Node_Str""+ (i + 1)+ ""String_Node_Str"");
      try {
        Thread.sleep(2000);
      }
 catch (      InterruptedException e) {
        logger.info(""String_Node_Str"");
      }
    }
  }
  if (setPasswordSucceed) {
    logger.info(""String_Node_Str"" + nodeIP + ""String_Node_Str"");
    return true;
  }
 else {
    logger.info(""String_Node_Str"" + nodeIP + ""String_Node_Str"");
    throw new Exception(Constants.CHECK_WHETHER_SSH_ACCESS_AVAILABLE);
  }
}","private boolean setPasswordForNode() throws Exception {
  logger.info(""String_Node_Str"" + nodeIP);
  String privateKeyFile=Configuration.getString(Constants.SSH_PRIVATE_KEY_CONFIG_NAME,Constants.SSH_PRIVATE_KEY_FILE_NAME);
  String sshUser=Configuration.getString(Constants.SSH_USER_CONFIG_NAME,Constants.DEFAULT_SSH_USER_NAME);
  int sshPort=Configuration.getInt(Constants.SSH_PORT_CONFIG_NAME,Constants.DEFAULT_SSH_PORT);
  String cmd=generateSetPasswdCommand(Constants.SET_PASSWORD_SCRIPT_CONFIG_NAME,password);
  InputStream in=null;
  try {
    in=parseInputStream(new String(password + Constants.NEW_LINE + password+ Constants.NEW_LINE));
    boolean setPasswordSucceed=false;
    for (int i=0; i < Constants.SET_PASSWORD_MAX_RETRY_TIMES; i++) {
      SSHUtil sshUtil=new SSHUtil();
      setPasswordSucceed=sshUtil.execCmd(sshUser,privateKeyFile,nodeIP,sshPort,cmd,in,null);
      if (setPasswordSucceed) {
        break;
      }
 else {
        logger.info(""String_Node_Str"" + nodeIP + ""String_Node_Str""+ (i + 1)+ ""String_Node_Str"");
        try {
          Thread.sleep(2000);
        }
 catch (        InterruptedException e) {
          logger.info(""String_Node_Str"");
        }
      }
    }
    if (setPasswordSucceed) {
      logger.info(""String_Node_Str"" + nodeIP + ""String_Node_Str"");
      return true;
    }
 else {
      logger.info(""String_Node_Str"" + nodeIP + ""String_Node_Str"");
      throw new Exception(Constants.CHECK_WHETHER_SSH_ACCESS_AVAILABLE);
    }
  }
  finally {
    if (in != null) {
      in.close();
    }
  }
}"
48805,"private String generateSetPasswdCommand(String setPasswdScriptConfig,String password){
  String scriptFileName=Configuration.getString(setPasswdScriptConfig,Constants.DEFAULT_SET_PASSWORD_SCRIPT);
  String[] commands=new String[8];
  String tmpScript=""String_Node_Str"";
  commands[0]=""String_Node_Str"" + tmpScript;
  commands[1]=""String_Node_Str"" + scriptFileName + ""String_Node_Str""+ ""String_Node_Str""+ tmpScript;
  commands[2]=""String_Node_Str"" + password + ""String_Node_Str""+ tmpScript;
  commands[3]=commands[2];
  commands[4]=""String_Node_Str"" + tmpScript;
  commands[5]=""String_Node_Str"" + tmpScript;
  commands[6]=""String_Node_Str"" + tmpScript;
  commands[7]=""String_Node_Str"" + tmpScript;
  StringBuilder sb=new StringBuilder().append(commands[0]).append(""String_Node_Str"").append(commands[1]).append(""String_Node_Str"").append(commands[2]).append(""String_Node_Str"").append(commands[3]).append(""String_Node_Str"").append(commands[4]).append(""String_Node_Str"").append(commands[5]).append(""String_Node_Str"").append(commands[6]).append(""String_Node_Str"").append(commands[7]);
  return sb.toString();
}","private String generateSetPasswdCommand(String setPasswdScriptConfig,String password){
  String scriptFileName=Configuration.getString(setPasswdScriptConfig,Constants.DEFAULT_SET_PASSWORD_SCRIPT);
  return ""String_Node_Str"" + scriptFileName + ""String_Node_Str"";
}"
48806,"public boolean execCmd(String user,String privateKeyFile,String hostIP,int sshPort,String command){
  AuAssert.check(command != null);
  connect(user,privateKeyFile,hostIP,sshPort);
  ChannelExec channel=null;
  logger.info(""String_Node_Str"");
  try {
    channel=(ChannelExec)session.openChannel(""String_Node_Str"");
    if (channel != null) {
      logger.debug(""String_Node_Str"");
      channel.setPty(true);
      channel.setCommand(command);
      BufferedReader in=new BufferedReader(new InputStreamReader(channel.getInputStream()));
      channel.connect();
      if (!channel.isConnected()) {
        logger.error(""String_Node_Str"");
      }
      StringBuilder buff=new StringBuilder();
      while (true) {
        String line=in.readLine();
        buff.append(line);
        if (channel.isClosed()) {
          int exitStatus=channel.getExitStatus();
          logger.debug(""String_Node_Str"" + exitStatus);
          logger.debug(""String_Node_Str"" + buff.toString());
          in.close();
          if (exitStatus == 0) {
            return true;
          }
 else {
            return false;
          }
        }
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException e) {
        }
      }
    }
 else {
      logger.error(""String_Node_Str"" + hostIP + ""String_Node_Str"");
      return false;
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  JSchException e) {
    e.printStackTrace();
  }
 finally {
    if (channel != null) {
      channel.disconnect();
    }
    if (session != null) {
      session.disconnect();
    }
  }
  return false;
}","public boolean execCmd(String user,String privateKeyFile,String hostIP,int sshPort,String command,InputStream in,OutputStream out){
  AuAssert.check(command != null);
  connect(user,privateKeyFile,hostIP,sshPort);
  ChannelExec channel=null;
  logger.info(""String_Node_Str"");
  BufferedReader bufferedReader=null;
  try {
    channel=(ChannelExec)session.openChannel(""String_Node_Str"");
    if (channel != null) {
      logger.debug(""String_Node_Str"");
      channel.setPty(true);
      channel.setCommand(command);
      channel.setInputStream(in);
      channel.setOutputStream(out);
      bufferedReader=new BufferedReader(new InputStreamReader(channel.getInputStream()));
      channel.connect();
      if (!channel.isConnected()) {
        logger.error(""String_Node_Str"");
      }
      StringBuilder buff=new StringBuilder();
      while (true) {
        String line=bufferedReader.readLine();
        buff.append(line);
        if (channel.isClosed()) {
          int exitStatus=channel.getExitStatus();
          logger.debug(""String_Node_Str"" + exitStatus);
          logger.debug(""String_Node_Str"" + buff.toString());
          if (exitStatus == 0) {
            return true;
          }
 else {
            return false;
          }
        }
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException e) {
        }
      }
    }
 else {
      logger.error(""String_Node_Str"" + hostIP + ""String_Node_Str"");
      return false;
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  JSchException e) {
    e.printStackTrace();
  }
 finally {
    if (channel != null && channel.isConnected()) {
      channel.disconnect();
    }
    if (session != null && channel.isConnected()) {
      session.disconnect();
    }
    try {
      bufferedReader.close();
    }
 catch (    IOException e) {
      logger.error(""String_Node_Str"" + e.getMessage());
    }
  }
  return false;
}"
48807,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void resizeCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String nodeGroup,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final int instanceNum,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final int cpuNumber,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final long memory){
  if ((instanceNum > 0 && cpuNumber == 0 && memory == 0) || (instanceNum == 0 && (cpuNumber > 0 || memory > 0))) {
    try {
      ClusterRead cluster=restClient.get(name,false);
      if (cluster == null) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"" + name + ""String_Node_Str"");
        return;
      }
      List<NodeGroupRead> ngs=cluster.getNodeGroups();
      boolean found=false;
      for (      NodeGroupRead ng : ngs) {
        if (ng.getName().equals(nodeGroup)) {
          found=true;
          if (ng.getRoles() != null && ng.getRoles().contains(HadoopRole.ZOOKEEPER_ROLE.toString()) && instanceNum > 1) {
            CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.ZOOKEEPER_NOT_RESIZE);
            return;
          }
          break;
        }
      }
      if (!found) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"" + nodeGroup + ""String_Node_Str"");
        return;
      }
      TaskRead taskRead=null;
      if (instanceNum > 0) {
        restClient.resize(name,nodeGroup,instanceNum);
      }
 else       if (cpuNumber > 0 || memory > 0) {
        if (cluster.getStatus().ordinal() != ClusterStatus.RUNNING.ordinal()) {
          CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
          return;
        }
        ResourceScale resScale=new ResourceScale(name,nodeGroup,cpuNumber,memory);
        taskRead=restClient.scale(resScale);
      }
      CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_RESIZE);
      if (taskRead != null) {
        System.out.println();
        printScaleReport(taskRead,name,nodeGroup);
      }
    }
 catch (    CliRestException e) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    }
  }
 else {
    if (instanceNum > 0 && (cpuNumber > 0 || memory > 0)) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
    }
 else     if (instanceNum == 0 && cpuNumber == 0 && memory == 0) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + (instanceNum < 0 ? ""String_Node_Str"" + instanceNum + ""String_Node_Str"" : ""String_Node_Str"") + (cpuNumber < 0 ? ""String_Node_Str"" + cpuNumber + ""String_Node_Str"" : ""String_Node_Str"")+ (memory < 0 ? ""String_Node_Str"" + memory : ""String_Node_Str""));
    }
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void resizeCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String nodeGroup,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final int instanceNum,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final int cpuNumber,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final long memory){
  if ((instanceNum > 0 && cpuNumber == 0 && memory == 0) || (instanceNum == 0 && (cpuNumber > 0 || memory > 0))) {
    try {
      ClusterRead cluster=restClient.get(name,false);
      if (cluster == null) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"" + name + ""String_Node_Str"");
        return;
      }
      List<NodeGroupRead> ngs=cluster.getNodeGroups();
      boolean found=false;
      for (      NodeGroupRead ng : ngs) {
        if (ng.getName().equals(nodeGroup)) {
          found=true;
          if (ng.getRoles() != null && ng.getRoles().contains(HadoopRole.ZOOKEEPER_ROLE.toString()) && instanceNum > 1) {
            CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.ZOOKEEPER_NOT_RESIZE);
            return;
          }
          break;
        }
      }
      if (!found) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"" + nodeGroup + ""String_Node_Str"");
        return;
      }
      TaskRead taskRead=null;
      if (instanceNum > 0) {
        restClient.resize(name,nodeGroup,instanceNum);
      }
 else       if (cpuNumber > 0 || memory > 0) {
        if (cluster.getStatus().ordinal() != ClusterStatus.RUNNING.ordinal()) {
          CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
          return;
        }
        ResourceScale resScale=new ResourceScale(name,nodeGroup,cpuNumber,memory);
        taskRead=restClient.scale(resScale);
      }
      CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_RESIZE);
      if (taskRead != null) {
        System.out.println();
        printScaleReport(taskRead,name,nodeGroup);
      }
    }
 catch (    CliRestException e) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    }
  }
 else {
    if (instanceNum > 0 && (cpuNumber > 0 || memory > 0)) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
    }
 else     if (instanceNum == 0 && cpuNumber == 0 && memory == 0) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
    }
 else {
      List<String> invalidParams=new ArrayList<String>();
      if (instanceNum < 0) {
        invalidParams.add(""String_Node_Str"" + instanceNum);
      }
      if (cpuNumber < 0) {
        invalidParams.add(""String_Node_Str"" + cpuNumber);
      }
      if (memory < 0) {
        invalidParams.add(""String_Node_Str"" + memory);
      }
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + StringUtils.join(invalidParams,""String_Node_Str""));
    }
  }
}"
48808,"private void processEvent(VcEventType type,Event e,String moId,boolean external) throws Exception {
  try {
switch (type) {
case VmRemoved:
{
        logger.debug(""String_Node_Str"" + moId);
        if (clusterEntityMgr.getNodeByMobId(moId) != null) {
          clusterEntityMgr.refreshNodeByMobId(moId,null,true);
        }
        break;
      }
case VmDisconnected:
{
      refreshNodeWithAction(e,null,true,null,""String_Node_Str"");
      break;
    }
case VmPoweredOn:
{
    refreshNodeWithAction(e,moId,true,Constants.NODE_ACTION_WAITING_IP,""String_Node_Str"");
    if (external) {
      NodePowerOnRequest request=new NodePowerOnRequest(clusterEntityMgr,moId);
      CmsWorker.addRequest(WorkQueue.VC_TASK_NO_DELAY,request);
    }
    break;
  }
case VmCloned:
{
  refreshNodeWithAction(e,moId,true,Constants.NODE_ACTION_RECONFIGURE,""String_Node_Str"");
  break;
}
case VmSuspended:
{
refreshNodeWithAction(e,moId,true,null,""String_Node_Str"");
break;
}
case VmPoweredOff:
{
refreshNodeWithAction(e,moId,true,null,""String_Node_Str"");
break;
}
case VmConnected:
case VmMigrated:
case VmRelocated:
{
refreshNodeWithAction(e,moId,false,null,type.name());
break;
}
case VhmError:
case VhmWarning:
case VhmInfo:
case VhmUser:
{
EventEx event=(EventEx)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
break;
}
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + e.getDynamicType() + ""String_Node_Str""+ vm.getName()+ ""String_Node_Str""+ event.getMessage());
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),event.getMessage(),true);
}
break;
}
default :
{
break;
}
}
}
 catch (ManagedObjectNotFound exp) {
VcUtil.processNotFoundException(exp,moId,logger);
}
}","private void processEvent(VcEventType type,Event e,String moId,boolean external) throws Exception {
  try {
switch (type) {
case VmRemoved:
{
        logger.debug(""String_Node_Str"" + moId);
        if (clusterEntityMgr.getNodeByMobId(moId) != null) {
          clusterEntityMgr.refreshNodeByMobId(moId,null,true);
        }
        break;
      }
case VmDisconnected:
{
      refreshNodeWithAction(e,null,true,null,""String_Node_Str"");
      break;
    }
case VmPoweredOn:
{
    refreshNodeWithAction(e,moId,true,Constants.NODE_ACTION_WAITING_IP,""String_Node_Str"");
    if (external) {
      NodePowerOnRequest request=new NodePowerOnRequest(clusterEntityMgr,moId);
      CmsWorker.addRequest(WorkQueue.VC_TASK_NO_DELAY,request);
    }
    break;
  }
case VmCloned:
{
  refreshNodeWithAction(e,moId,true,Constants.NODE_ACTION_RECONFIGURE,""String_Node_Str"");
  break;
}
case VmSuspended:
{
refreshNodeWithAction(e,moId,true,null,""String_Node_Str"");
break;
}
case VmPoweredOff:
{
refreshNodeWithAction(e,moId,true,null,""String_Node_Str"");
break;
}
case VmConnected:
case VmMigrated:
case VmRelocated:
{
refreshNodeWithAction(e,moId,false,null,type.name());
break;
}
case VhmError:
case VhmWarning:
{
EventEx event=(EventEx)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
break;
}
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + event.getEventTypeId() + ""String_Node_Str""+ vm.getName()+ ""String_Node_Str""+ event.getMessage());
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),event.getMessage(),true);
}
break;
}
case VhmInfo:
{
EventEx event=(EventEx)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
break;
}
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + event.getEventTypeId() + ""String_Node_Str""+ vm.getName()+ ""String_Node_Str""+ event.getMessage());
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),""String_Node_Str"",true);
}
break;
}
default :
{
break;
}
}
}
 catch (ManagedObjectNotFound exp) {
VcUtil.processNotFoundException(exp,moId,logger);
}
}"
48809,"@Override public boolean setPasswordForNode(String clusterName,String nodeIP,String password){
  logger.info(""String_Node_Str"" + nodeIP + ""String_Node_Str""+ clusterName);
  String privateKeyFile=Configuration.getString(Constants.SSH_PRIVATE_KEY_CONFIG_NAME,Constants.SSH_PRIVATE_KEY_FILE_NAME);
  String sshUser=Configuration.getString(Constants.SSH_USER_CONFIG_NAME,Constants.DEFAULT_SSH_USER_NAME);
  int sshPort=Configuration.getInt(Constants.SSH_PORT_CONFIG_NAME,Constants.DEFAULT_SSH_PORT);
  String[] cmds=generateSetPasswdCommand(Constants.SET_PASSWORD_SCRIPT_CONFIG_NAME,password);
  boolean succeed=false;
  for (  String cmd : cmds) {
    succeed=SSHUtil.execCmd(sshUser,privateKeyFile,nodeIP,sshPort,cmd);
    if (succeed) {
      logger.info(""String_Node_Str"" + ""String_Node_Str"" + nodeIP + ""String_Node_Str"");
    }
 else {
      logger.info(""String_Node_Str"" + ""String_Node_Str"" + nodeIP + ""String_Node_Str"");
    }
  }
  if (succeed) {
    logger.info(""String_Node_Str"" + nodeIP + ""String_Node_Str"");
    return true;
  }
 else {
    logger.info(""String_Node_Str"" + nodeIP + ""String_Node_Str"");
    return false;
  }
}","@Override public boolean setPasswordForNode(String clusterName,String nodeIP,String password){
  logger.info(""String_Node_Str"" + nodeIP + ""String_Node_Str""+ clusterName);
  String privateKeyFile=Configuration.getString(Constants.SSH_PRIVATE_KEY_CONFIG_NAME,Constants.SSH_PRIVATE_KEY_FILE_NAME);
  String sshUser=Configuration.getString(Constants.SSH_USER_CONFIG_NAME,Constants.DEFAULT_SSH_USER_NAME);
  int sshPort=Configuration.getInt(Constants.SSH_PORT_CONFIG_NAME,Constants.DEFAULT_SSH_PORT);
  String[] cmds=generateSetPasswdCommand(Constants.SET_PASSWORD_SCRIPT_CONFIG_NAME,password);
  boolean setPasswordSucceed=false;
  for (int i=0; i < Constants.SET_PASSWORD_MAX_RETRY_TIMES; i++) {
    boolean commandSucceed=false;
    for (    String cmd : cmds) {
      commandSucceed=SSHUtil.execCmd(sshUser,privateKeyFile,nodeIP,sshPort,cmd);
      if (commandSucceed) {
        logger.info(""String_Node_Str"" + ""String_Node_Str"" + nodeIP + ""String_Node_Str"");
      }
 else {
        logger.info(""String_Node_Str"" + ""String_Node_Str"" + nodeIP + ""String_Node_Str"");
        break;
      }
    }
    if (commandSucceed) {
      setPasswordSucceed=true;
      break;
    }
 else {
      logger.info(""String_Node_Str"" + nodeIP + ""String_Node_Str""+ (i + 1)+ ""String_Node_Str"");
      try {
        Thread.sleep(2000);
      }
 catch (      InterruptedException e) {
        logger.info(""String_Node_Str"");
      }
    }
  }
  if (setPasswordSucceed) {
    logger.info(""String_Node_Str"" + nodeIP + ""String_Node_Str"");
    return true;
  }
 else {
    logger.info(""String_Node_Str"" + nodeIP + ""String_Node_Str"");
    return false;
  }
}"
48810,"public ArrayList<String> setPasswordForNodes(String clusterName,ArrayList<String> ipsOfNodes,String password){
  AuAssert.check(!ipsOfNodes.isEmpty());
  logger.info(""String_Node_Str"" + clusterName);
  logger.info(""String_Node_Str"" + ipsOfNodes.toString());
  ArrayList<String> failedIPs=null;
  List<Callable<Void>> storeProcedures=new ArrayList<Callable<Void>>();
  for (  String nodeIP : ipsOfNodes) {
    SetVMPasswordSP setVMPasswordSP=new SetVMPasswordSP(clusterName,nodeIP,password);
    storeProcedures.add(setVMPasswordSP);
  }
  AuAssert.check(!storeProcedures.isEmpty());
  try {
    Callable<Void>[] storeProceduresArray=storeProcedures.toArray(new Callable[0]);
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProceduresArray,callback);
    for (int i=0; i < storeProceduresArray.length; i++) {
      if (!result[i].finished || result[i].throwable != null) {
        SetVMPasswordSP sp=(SetVMPasswordSP)storeProceduresArray[i];
        String failedNodeIP=sp.getNodeIP();
        if (failedIPs == null) {
          failedIPs=new ArrayList<String>();
        }
        failedIPs.add(failedNodeIP);
      }
    }
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName);
    throw BddException.INTERNAL(e,""String_Node_Str"" + clusterName);
  }
  return failedIPs;
}","public ArrayList<String> setPasswordForNodes(String clusterName,ArrayList<String> ipsOfNodes,String password){
  AuAssert.check(!ipsOfNodes.isEmpty());
  logger.info(""String_Node_Str"" + clusterName);
  logger.info(""String_Node_Str"" + ipsOfNodes.toString());
  ArrayList<String> failedIPs=null;
  List<Callable<Void>> storeProcedures=new ArrayList<Callable<Void>>();
  for (  String nodeIP : ipsOfNodes) {
    SetVMPasswordSP setVMPasswordSP=new SetVMPasswordSP(nodeIP,password);
    storeProcedures.add(setVMPasswordSP);
  }
  AuAssert.check(!storeProcedures.isEmpty());
  try {
    Callable<Void>[] storeProceduresArray=storeProcedures.toArray(new Callable[0]);
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProceduresArray,callback);
    for (int i=0; i < storeProceduresArray.length; i++) {
      if (!result[i].finished || result[i].throwable != null) {
        SetVMPasswordSP sp=(SetVMPasswordSP)storeProceduresArray[i];
        String failedNodeIP=sp.getNodeIP();
        if (failedIPs == null) {
          failedIPs=new ArrayList<String>();
        }
        failedIPs.add(failedNodeIP);
      }
    }
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName);
    throw BddException.INTERNAL(e,""String_Node_Str"" + clusterName);
  }
  return failedIPs;
}"
48811,"@Override public boolean setPasswordForNode(String clusterName,String nodeIP,String password) throws Exception {
  logger.info(""String_Node_Str"" + nodeIP + ""String_Node_Str""+ clusterName);
  String privateKeyFile=Configuration.getString(Constants.SSH_PRIVATE_KEY_CONFIG_NAME,Constants.SSH_PRIVATE_KEY_FILE_NAME);
  String sshUser=Configuration.getString(Constants.SSH_USER_CONFIG_NAME,Constants.DEFAULT_SSH_USER_NAME);
  int sshPort=Configuration.getInt(Constants.SSH_PORT_CONFIG_NAME,Constants.DEFAULT_SSH_PORT);
  String[] cmds=generateSetPasswdCommand(Constants.SET_PASSWORD_SCRIPT_CONFIG_NAME,password);
  boolean setPasswordSucceed=false;
  for (int i=0; i < Constants.SET_PASSWORD_MAX_RETRY_TIMES; i++) {
    boolean commandSucceed=false;
    for (    String cmd : cmds) {
      commandSucceed=SSHUtil.execCmd(sshUser,privateKeyFile,nodeIP,sshPort,cmd);
      if (commandSucceed) {
        logger.info(""String_Node_Str"" + ""String_Node_Str"" + nodeIP + ""String_Node_Str"");
      }
 else {
        logger.info(""String_Node_Str"" + ""String_Node_Str"" + nodeIP + ""String_Node_Str"");
        break;
      }
    }
    if (commandSucceed) {
      setPasswordSucceed=true;
      break;
    }
 else {
      logger.info(""String_Node_Str"" + nodeIP + ""String_Node_Str""+ (i + 1)+ ""String_Node_Str"");
      try {
        Thread.sleep(2000);
      }
 catch (      InterruptedException e) {
        logger.info(""String_Node_Str"");
      }
    }
  }
  if (setPasswordSucceed) {
    logger.info(""String_Node_Str"" + nodeIP + ""String_Node_Str"");
    return true;
  }
 else {
    logger.info(""String_Node_Str"" + nodeIP + ""String_Node_Str"");
    throw new Exception(Constants.CHECK_WHETHER_SSH_ACCESS_AVAILABLE);
  }
}","@Override public boolean setPasswordForNode(String clusterName,String nodeIP,String password) throws Exception {
  AuAssert.check(clusterName != null && nodeIP != null && password != null);
  List<Callable<Void>> storeProcedures=new ArrayList<Callable<Void>>();
  SetVMPasswordSP setVMPasswordSP=new SetVMPasswordSP(nodeIP,password);
  storeProcedures.add(setVMPasswordSP);
  AuAssert.check(!storeProcedures.isEmpty());
  try {
    Callable<Void>[] storeProceduresArray=storeProcedures.toArray(new Callable[0]);
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProceduresArray,callback);
    if (result[0].finished && result[0].throwable == null) {
      return true;
    }
    return false;
  }
 catch (  Exception e) {
    throw BddException.INTERNAL(e,""String_Node_Str"" + nodeIP + ""String_Node_Str""+ clusterName);
  }
}"
48812,"public SetVMPasswordSP(String clusterName,String nodeIP,String password){
  this.clusterName=clusterName;
  this.nodeIP=nodeIP;
  this.password=password;
}","public SetVMPasswordSP(String nodeIP,String password){
  this.nodeIP=nodeIP;
  this.password=password;
}"
48813,"@Override public Void call() throws Exception {
  setPasswordService.setPasswordForNode(clusterName,nodeIP,password);
  return null;
}","@Override public Void call() throws Exception {
  setPasswordForNode();
  return null;
}"
48814,"public static boolean execCmd(String user,String privateKeyFile,String hostIP,int sshPort,String command){
  AuAssert.check(command != null);
  connect(user,privateKeyFile,hostIP,sshPort);
  ChannelExec channel=null;
  logger.info(""String_Node_Str"");
  try {
    channel=(ChannelExec)session.openChannel(""String_Node_Str"");
    if (channel != null) {
      logger.debug(""String_Node_Str"");
      channel.setPty(true);
      channel.setCommand(command);
      BufferedReader in=new BufferedReader(new InputStreamReader(channel.getInputStream()));
      channel.connect();
      if (!channel.isConnected()) {
        logger.error(""String_Node_Str"");
      }
      StringBuilder buff=new StringBuilder();
      while (true) {
        String line=in.readLine();
        buff.append(line);
        if (channel.isClosed()) {
          int exitStatus=channel.getExitStatus();
          logger.debug(""String_Node_Str"" + exitStatus);
          logger.debug(""String_Node_Str"" + buff.toString());
          in.close();
          if (exitStatus == 0) {
            return true;
          }
 else {
            return false;
          }
        }
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException e) {
        }
      }
    }
 else {
      logger.error(""String_Node_Str"" + hostIP + ""String_Node_Str"");
      return false;
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  JSchException e) {
    e.printStackTrace();
  }
 finally {
    if (channel != null) {
      channel.disconnect();
    }
    if (session != null) {
      session.disconnect();
    }
  }
  return false;
}","public boolean execCmd(String user,String privateKeyFile,String hostIP,int sshPort,String command){
  AuAssert.check(command != null);
  connect(user,privateKeyFile,hostIP,sshPort);
  ChannelExec channel=null;
  logger.info(""String_Node_Str"");
  try {
    channel=(ChannelExec)session.openChannel(""String_Node_Str"");
    if (channel != null) {
      logger.debug(""String_Node_Str"");
      channel.setPty(true);
      channel.setCommand(command);
      BufferedReader in=new BufferedReader(new InputStreamReader(channel.getInputStream()));
      channel.connect();
      if (!channel.isConnected()) {
        logger.error(""String_Node_Str"");
      }
      StringBuilder buff=new StringBuilder();
      while (true) {
        String line=in.readLine();
        buff.append(line);
        if (channel.isClosed()) {
          int exitStatus=channel.getExitStatus();
          logger.debug(""String_Node_Str"" + exitStatus);
          logger.debug(""String_Node_Str"" + buff.toString());
          in.close();
          if (exitStatus == 0) {
            return true;
          }
 else {
            return false;
          }
        }
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException e) {
        }
      }
    }
 else {
      logger.error(""String_Node_Str"" + hostIP + ""String_Node_Str"");
      return false;
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  JSchException e) {
    e.printStackTrace();
  }
 finally {
    if (channel != null) {
      channel.disconnect();
    }
    if (session != null) {
      session.disconnect();
    }
  }
  return false;
}"
48815,"private static void connect(String user,String privateKeyFile,String hostIP,int sshPort){
  jsch=new JSch();
  try {
    session=jsch.getSession(user,hostIP,sshPort);
    jsch.addIdentity(privateKeyFile);
    java.util.Properties config=new java.util.Properties();
    config.put(""String_Node_Str"",""String_Node_Str"");
    session.setConfig(config);
    session.setTimeout(Constants.SSH_SESSION_TIMEOUT);
    session.connect();
    logger.debug(""String_Node_Str"");
  }
 catch (  JSchException e) {
    e.printStackTrace();
  }
}","private void connect(String user,String privateKeyFile,String hostIP,int sshPort){
  jsch=new JSch();
  try {
    session=jsch.getSession(user,hostIP,sshPort);
    jsch.addIdentity(privateKeyFile);
    java.util.Properties config=new java.util.Properties();
    config.put(""String_Node_Str"",""String_Node_Str"");
    session.setConfig(config);
    session.setTimeout(Constants.SSH_SESSION_TIMEOUT);
    session.connect();
    logger.debug(""String_Node_Str"");
  }
 catch (  JSchException e) {
    e.printStackTrace();
  }
}"
48816,"private void showFailedMsg(String name,List<String> failedMsgList){
  StringBuilder failedMsg=new StringBuilder();
  failedMsg.append(Constants.INVALID_VALUE);
  if (failedMsgList.size() > 1) {
    failedMsg.append(""String_Node_Str"");
  }
  failedMsg.append(""String_Node_Str"");
  StringBuilder tmpMsg=new StringBuilder();
  for (  String msg : failedMsgList) {
    tmpMsg.append(msg);
  }
  failedMsg.append(tmpMsg);
  CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,failedMsg.toString());
}","private void showFailedMsg(String name,List<String> failedMsgList){
  StringBuilder failedMsg=new StringBuilder();
  failedMsg.append(Constants.INVALID_VALUE);
  if (failedMsgList.size() > 1) {
    failedMsg.append(""String_Node_Str"");
  }
  failedMsg.append(""String_Node_Str"");
  StringBuilder tmpMsg=new StringBuilder();
  for (  String msg : failedMsgList) {
    tmpMsg.append(msg).append(""String_Node_Str"");
  }
  failedMsg.append(tmpMsg);
  CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,failedMsg.toString());
}"
48817,"/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
public void validateClusterCreate(List<String> failedMsgList,List<String> warningMsgList,final List<String> distroRoles){
  boolean namenodeHACheck=false;
  int masterCount=0, jobtrackerCount=0, resourcemanagerCount=0, hbasemasterCount=0, zookeeperCount=0, workerCount=0, numOfJournalNode=0;
  boolean appendWarningStr=false;
  if (warningMsgList != null && warningMsgList.isEmpty()) {
    appendWarningStr=true;
  }
  NodeGroupCreate[] nodeGroupCreates=getNodeGroups();
  AuAssert.check(nodeGroupCreates != null && nodeGroupCreates.length > 0);
  if (hasHDFSUrlConfigured() && !validateHDFSUrl()) {
    failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getExternalHDFS()).toString());
  }
  validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList);
  validateNodeGroupRoles(failedMsgList);
  validateStorageType(failedMsgList);
  validateSwapRatio(nodeGroupCreates,failedMsgList);
  for (  NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
    checkInstanceNum(nodeGroupCreate,failedMsgList);
    makeVmMemoryDivisibleBy4(nodeGroupCreate,warningMsgList);
    checkNodeGroupRoles(nodeGroupCreate,distroRoles,failedMsgList);
    List<NodeGroupRole> groupRoles=getNodeGroupRoles(nodeGroupCreate);
    if (groupRoles != null) {
      for (      NodeGroupRole role : groupRoles) {
switch (role) {
case MASTER:
          masterCount++;
        int numOfInstance=nodeGroupCreate.getInstanceNum();
      if (numOfInstance >= 0 && numOfInstance != 1) {
        if (numOfInstance != 2) {
          collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
        }
 else {
          namenodeHACheck=true;
        }
      }
    break;
case JOB_TRACKER:
  jobtrackerCount++;
if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
  failedMsgList.add(Constants.WRONG_NUM_OF_JOBTRACKER);
}
break;
case RESOURCEMANAGER:
resourcemanagerCount++;
if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
failedMsgList.add(Constants.WRONG_NUM_OF_RESOURCEMANAGER);
}
break;
case HBASE_MASTER:
hbasemasterCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
break;
case ZOOKEEPER:
zookeeperCount++;
if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_ZOOKEEPER);
}
 else if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_ZOOKEEPER);
}
break;
case JOURNAL_NODE:
numOfJournalNode+=nodeGroupCreate.getInstanceNum();
if (nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_DATANODE.toString()) || nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_CLIENT_ROLE.toString())) {
failedMsgList.add(Constants.DATA_CLIENT_NODE_JOURNALNODE_COEXIST);
}
break;
case WORKER:
workerCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
 else if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
List<String> roles=nodeGroupCreate.getRoles();
if (roles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString()) && !roles.contains(HadoopRole.HADOOP_DATANODE.toString())) {
warningMsgList.add(Constants.REGISONSERVER_DATANODE_SEPERATION);
}
break;
case CLIENT:
if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
break;
case NONE:
warningMsgList.add(Constants.NOT_DEFINED_ROLE);
break;
default :
}
}
}
}
if (!supportedWithHdfs2()) {
if (namenodeHACheck || masterCount > 1) {
failedMsgList.add(Constants.CURRENT_DISTRO_CAN_NOT_SUPPORT_HDFS2);
}
}
 else if (namenodeHACheck) {
if (numOfJournalNode >= 0 && numOfJournalNode < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_JOURNALNODE);
}
 else if (numOfJournalNode > 0 && numOfJournalNode % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_JOURNALNODE);
}
if (zookeeperCount == 0) {
failedMsgList.add(Constants.NAMENODE_AUTO_FAILOVER_ZOOKEEPER);
}
}
if ((jobtrackerCount > 1) || (resourcemanagerCount > 1) || (zookeeperCount > 1)|| (hbasemasterCount > 1)) {
failedMsgList.add(Constants.WRONG_NUM_OF_NODEGROUPS);
}
if (workerCount == 0) {
warningMsgList.add(Constants.WRONG_NUM_OF_WORKERNODES);
}
if (numOfJournalNode > 0 && !namenodeHACheck) {
failedMsgList.add(Constants.NO_NAMENODE_HA);
}
if (!warningMsgList.isEmpty() && appendWarningStr) {
warningMsgList.set(0,""String_Node_Str"" + warningMsgList.get(0));
}
}","/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
public void validateClusterCreate(List<String> failedMsgList,List<String> warningMsgList,final List<String> distroRoles){
  boolean namenodeHACheck=false;
  int masterCount=0, jobtrackerCount=0, resourcemanagerCount=0, hbasemasterCount=0, zookeeperCount=0, workerCount=0, numOfJournalNode=0;
  boolean appendWarningStr=false;
  if (warningMsgList != null && warningMsgList.isEmpty()) {
    appendWarningStr=true;
  }
  NodeGroupCreate[] nodeGroupCreates=getNodeGroups();
  AuAssert.check(nodeGroupCreates != null && nodeGroupCreates.length > 0);
  if (hasHDFSUrlConfigured() && !validateHDFSUrl()) {
    failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getExternalHDFS()).toString());
  }
  validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList);
  validateNodeGroupRoles(failedMsgList);
  validateStorageType(failedMsgList);
  validateSwapRatio(nodeGroupCreates,failedMsgList);
  for (  NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
    checkInstanceNum(nodeGroupCreate,failedMsgList);
    checkCPUAndMemory(nodeGroupCreate,failedMsgList,warningMsgList);
    checkNodeGroupRoles(nodeGroupCreate,distroRoles,failedMsgList);
    List<NodeGroupRole> groupRoles=getNodeGroupRoles(nodeGroupCreate);
    if (groupRoles != null) {
      for (      NodeGroupRole role : groupRoles) {
switch (role) {
case MASTER:
          masterCount++;
        int numOfInstance=nodeGroupCreate.getInstanceNum();
      if (numOfInstance >= 0 && numOfInstance != 1) {
        if (numOfInstance != 2) {
          collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
        }
 else {
          namenodeHACheck=true;
        }
      }
    break;
case JOB_TRACKER:
  jobtrackerCount++;
if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
  failedMsgList.add(Constants.WRONG_NUM_OF_JOBTRACKER);
}
break;
case RESOURCEMANAGER:
resourcemanagerCount++;
if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
failedMsgList.add(Constants.WRONG_NUM_OF_RESOURCEMANAGER);
}
break;
case HBASE_MASTER:
hbasemasterCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
break;
case ZOOKEEPER:
zookeeperCount++;
if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_ZOOKEEPER);
}
 else if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_ZOOKEEPER);
}
break;
case JOURNAL_NODE:
numOfJournalNode+=nodeGroupCreate.getInstanceNum();
if (nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_DATANODE.toString()) || nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_CLIENT_ROLE.toString())) {
failedMsgList.add(Constants.DATA_CLIENT_NODE_JOURNALNODE_COEXIST);
}
break;
case WORKER:
workerCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
 else if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
List<String> roles=nodeGroupCreate.getRoles();
if (roles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString()) && !roles.contains(HadoopRole.HADOOP_DATANODE.toString())) {
warningMsgList.add(Constants.REGISONSERVER_DATANODE_SEPERATION);
}
break;
case CLIENT:
if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
break;
case NONE:
warningMsgList.add(Constants.NOT_DEFINED_ROLE);
break;
default :
}
}
}
}
if (!supportedWithHdfs2()) {
if (namenodeHACheck || masterCount > 1) {
failedMsgList.add(Constants.CURRENT_DISTRO_CAN_NOT_SUPPORT_HDFS2);
}
}
 else if (namenodeHACheck) {
if (numOfJournalNode >= 0 && numOfJournalNode < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_JOURNALNODE);
}
 else if (numOfJournalNode > 0 && numOfJournalNode % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_JOURNALNODE);
}
if (zookeeperCount == 0) {
failedMsgList.add(Constants.NAMENODE_AUTO_FAILOVER_ZOOKEEPER);
}
}
if ((jobtrackerCount > 1) || (resourcemanagerCount > 1) || (zookeeperCount > 1)|| (hbasemasterCount > 1)) {
failedMsgList.add(Constants.WRONG_NUM_OF_NODEGROUPS);
}
if (workerCount == 0) {
warningMsgList.add(Constants.WRONG_NUM_OF_WORKERNODES);
}
if (numOfJournalNode > 0 && !namenodeHACheck) {
failedMsgList.add(Constants.NO_NAMENODE_HA);
}
if (!warningMsgList.isEmpty() && appendWarningStr) {
warningMsgList.set(0,""String_Node_Str"" + warningMsgList.get(0));
}
}"
48818,"private void makeVmMemoryDivisibleBy4(NodeGroupCreate nodeGroup,List<String> warningMsgList){
  int memoryNum=nodeGroup.getMemCapacityMB();
  if (memoryNum > 0) {
    long converted=CommonUtil.makeVmMemoryDivisibleBy4(memoryNum);
    if (converted < memoryNum) {
      nodeGroup.setMemCapacityMB((int)converted);
      warningMsgList.add(Constants.CONVERTED_MEMORY_DIVISIBLE_BY_4 + ""String_Node_Str"" + nodeGroup.getName()+ ""String_Node_Str""+ converted+ ""String_Node_Str""+ memoryNum+ ""String_Node_Str"");
    }
  }
}","private void makeVmMemoryDivisibleBy4(NodeGroupCreate nodeGroup,List<String> warningMsgList){
  int memoryCap=nodeGroup.getMemCapacityMB();
  if (memoryCap > 0) {
    long converted=CommonUtil.makeVmMemoryDivisibleBy4(memoryCap);
    if (converted < memoryCap) {
      nodeGroup.setMemCapacityMB((int)converted);
      warningMsgList.add(Constants.CONVERTED_MEMORY_DIVISIBLE_BY_4 + ""String_Node_Str"" + nodeGroup.getName()+ ""String_Node_Str""+ converted+ ""String_Node_Str""+ memoryCap+ ""String_Node_Str"");
    }
  }
}"
48819,"public void setMemCapacityMB(int memCapacityMB){
  this.memCapacityMB=memCapacityMB;
}","public void setMemCapacityMB(Integer memCapacityMB){
  this.memCapacityMB=memCapacityMB;
}"
48820,"public int getCpuNum(){
  return cpuNum;
}","public Integer getCpuNum(){
  return cpuNum;
}"
48821,"public void setCpuNum(int cpuNum){
  this.cpuNum=cpuNum;
}","public void setCpuNum(Integer cpuNum){
  this.cpuNum=cpuNum;
}"
48822,"public int getMemCapacityMB(){
  return memCapacityMB;
}","public Integer getMemCapacityMB(){
  return memCapacityMB;
}"
48823,"private NodeGroupEntity convertGroup(Gson gson,ClusterEntity clusterEntity,EnumSet<HadoopRole> allRoles,NodeGroupCreate group,String distro,boolean validateWhiteList){
  NodeGroupEntity groupEntity=new NodeGroupEntity();
  if (group.getRoles() == null || group.getRoles().isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  Set<String> roles=new HashSet<String>();
  groupEntity.setCluster(clusterEntity);
  groupEntity.setCpuNum(group.getCpuNum());
  groupEntity.setDefineInstanceNum(group.getInstanceNum());
  groupEntity.setMemorySize(group.getMemCapacityMB());
  groupEntity.setSwapRatio(group.getSwapRatio());
  groupEntity.setName(group.getName());
  groupEntity.setNodeType(group.getInstanceType());
  PlacementPolicy policies=group.getPlacementPolicies();
  if (policies != null) {
    List<GroupAssociation> associons=policies.getGroupAssociations();
    if (associons != null) {
      Set<NodeGroupAssociation> associonEntities=new TreeSet<NodeGroupAssociation>();
      for (      GroupAssociation a : associons) {
        NodeGroupAssociation ae=new NodeGroupAssociation();
        ae.setAssociationType(a.getType());
        ae.setNodeGroup(groupEntity);
        ae.setReferencedGroup(a.getReference());
        associonEntities.add(ae);
      }
      groupEntity.setGroupAssociations(associonEntities);
    }
    if (policies.getInstancePerHost() != null) {
      groupEntity.setInstancePerHost(policies.getInstancePerHost());
    }
    if (policies.getGroupRacks() != null) {
      groupEntity.setGroupRacks((new Gson()).toJson(policies.getGroupRacks()));
    }
  }
  if (group.getRpNames() != null && group.getRpNames().size() > 0) {
    groupEntity.setVcRpNameList(group.getRpNames());
  }
  convertStorage(group,groupEntity,roles);
  roles.addAll(group.getRoles());
  List<String> sortedRolesByDependency=new ArrayList<String>();
  sortedRolesByDependency.addAll(roles);
  Collections.sort(sortedRolesByDependency,new RoleComparactor());
  EnumSet<HadoopRole> enumRoles=getEnumRoles(group.getRoles(),distro);
  if (enumRoles.isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  groupEntity.setRoles(gson.toJson(sortedRolesByDependency));
  GroupType groupType=GroupType.fromHadoopRole(enumRoles);
  if (groupType == GroupType.CLIENT_GROUP && group.getInstanceNum() <= 0) {
    logger.warn(""String_Node_Str"" + group.getName() + ""String_Node_Str"");
    return null;
  }
  allRoles.addAll(enumRoles);
  List<String> dsNames=groupEntity.getVcDatastoreNameList();
  if (dsNames == null) {
    dsNames=clusterEntity.getVcDatastoreNameList();
  }
  Set<String> sharedPattern;
  Set<String> localPattern;
  if (dsNames != null) {
    sharedPattern=datastoreMgr.getSharedDatastoresByNames(dsNames);
    localPattern=datastoreMgr.getLocalDatastoresByNames(dsNames);
  }
 else {
    sharedPattern=datastoreMgr.getAllSharedDatastores();
    localPattern=datastoreMgr.getAllLocalDatastores();
  }
  CommonClusterExpandPolicy.expandGroupInstanceType(groupEntity,groupType,sharedPattern,localPattern);
  groupEntity.setHaFlag(group.getHaFlag());
  if (group.getConfiguration() != null && group.getConfiguration().size() > 0) {
    CommonClusterExpandPolicy.validateAppConfig(group.getConfiguration(),validateWhiteList);
    groupEntity.setHadoopConfig(gson.toJson(group.getConfiguration()));
  }
  groupEntity.setVmFolderPath(clusterEntity);
  logger.debug(""String_Node_Str"" + group.getName());
  return groupEntity;
}","private NodeGroupEntity convertGroup(Gson gson,ClusterEntity clusterEntity,EnumSet<HadoopRole> allRoles,NodeGroupCreate group,String distro,boolean validateWhiteList){
  NodeGroupEntity groupEntity=new NodeGroupEntity();
  if (group.getRoles() == null || group.getRoles().isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  Set<String> roles=new HashSet<String>();
  groupEntity.setCluster(clusterEntity);
  groupEntity.setCpuNum(group.getCpuNum() == null ? 0 : group.getCpuNum());
  groupEntity.setDefineInstanceNum(group.getInstanceNum());
  groupEntity.setMemorySize(group.getMemCapacityMB() == null ? 0 : group.getMemCapacityMB());
  groupEntity.setSwapRatio(group.getSwapRatio());
  groupEntity.setName(group.getName());
  groupEntity.setNodeType(group.getInstanceType());
  PlacementPolicy policies=group.getPlacementPolicies();
  if (policies != null) {
    List<GroupAssociation> associons=policies.getGroupAssociations();
    if (associons != null) {
      Set<NodeGroupAssociation> associonEntities=new TreeSet<NodeGroupAssociation>();
      for (      GroupAssociation a : associons) {
        NodeGroupAssociation ae=new NodeGroupAssociation();
        ae.setAssociationType(a.getType());
        ae.setNodeGroup(groupEntity);
        ae.setReferencedGroup(a.getReference());
        associonEntities.add(ae);
      }
      groupEntity.setGroupAssociations(associonEntities);
    }
    if (policies.getInstancePerHost() != null) {
      groupEntity.setInstancePerHost(policies.getInstancePerHost());
    }
    if (policies.getGroupRacks() != null) {
      groupEntity.setGroupRacks((new Gson()).toJson(policies.getGroupRacks()));
    }
  }
  if (group.getRpNames() != null && group.getRpNames().size() > 0) {
    groupEntity.setVcRpNameList(group.getRpNames());
  }
  convertStorage(group,groupEntity,roles);
  roles.addAll(group.getRoles());
  List<String> sortedRolesByDependency=new ArrayList<String>();
  sortedRolesByDependency.addAll(roles);
  Collections.sort(sortedRolesByDependency,new RoleComparactor());
  EnumSet<HadoopRole> enumRoles=getEnumRoles(group.getRoles(),distro);
  if (enumRoles.isEmpty()) {
    throw ClusterConfigException.NO_HADOOP_ROLE_SPECIFIED(group.getName());
  }
  groupEntity.setRoles(gson.toJson(sortedRolesByDependency));
  GroupType groupType=GroupType.fromHadoopRole(enumRoles);
  if (groupType == GroupType.CLIENT_GROUP && group.getInstanceNum() <= 0) {
    logger.warn(""String_Node_Str"" + group.getName() + ""String_Node_Str"");
    return null;
  }
  allRoles.addAll(enumRoles);
  List<String> dsNames=groupEntity.getVcDatastoreNameList();
  if (dsNames == null) {
    dsNames=clusterEntity.getVcDatastoreNameList();
  }
  Set<String> sharedPattern;
  Set<String> localPattern;
  if (dsNames != null) {
    sharedPattern=datastoreMgr.getSharedDatastoresByNames(dsNames);
    localPattern=datastoreMgr.getLocalDatastoresByNames(dsNames);
  }
 else {
    sharedPattern=datastoreMgr.getAllSharedDatastores();
    localPattern=datastoreMgr.getAllLocalDatastores();
  }
  CommonClusterExpandPolicy.expandGroupInstanceType(groupEntity,groupType,sharedPattern,localPattern);
  groupEntity.setHaFlag(group.getHaFlag());
  if (group.getConfiguration() != null && group.getConfiguration().size() > 0) {
    CommonClusterExpandPolicy.validateAppConfig(group.getConfiguration(),validateWhiteList);
    groupEntity.setHadoopConfig(gson.toJson(group.getConfiguration()));
  }
  groupEntity.setVmFolderPath(clusterEntity);
  logger.debug(""String_Node_Str"" + group.getName());
  return groupEntity;
}"
48824,"public Long createCluster(ClusterCreate createSpec) throws Exception {
  if (CommonUtil.isBlank(createSpec.getDistro())) {
    setDefaultDistro(createSpec);
  }
  DistroRead distroRead=getDistroManager().getDistroByName(createSpec.getDistro());
  createSpec.setDistroVendor(distroRead.getVendor());
  createSpec.setDistroVersion(distroRead.getVersion());
  createAutoRps(createSpec);
  ClusterCreate clusterSpec=ClusterSpecFactory.getCustomizedSpec(createSpec);
  createSpec.verifyClusterNameLength();
  clusterSpec.validateNodeGroupNames();
  if (clusterSpec != null && clusterSpec.getNodeGroups() != null) {
    for (    NodeGroupCreate ng : clusterSpec.getNodeGroups()) {
      String templateVmId=clusteringService.getTemplateVmId();
      if (templateVmId != null) {
        VcResourceUtils.checkVmMaxConfiguration(templateVmId,ng.getCpuNum(),ng.getMemCapacityMB());
      }
    }
  }
  String name=clusterSpec.getName();
  logger.info(""String_Node_Str"" + name);
  List<String> dsNames=getUsedDS(clusterSpec.getDsNames());
  if (dsNames.isEmpty()) {
    throw ClusterConfigException.NO_DATASTORE_ADDED();
  }
  List<VcCluster> vcClusters=getUsedVcClusters(clusterSpec.getRpNames());
  if (vcClusters == null || vcClusters.isEmpty()) {
    throw ClusterConfigException.NO_RESOURCE_POOL_ADDED();
  }
  validateDatastore(dsNames,vcClusters);
  validateNetworkAccessibility(createSpec.getNetworkNames(),vcClusters);
  clusterConfigMgr.createClusterConfig(clusterSpec);
  clusterEntityMgr.updateClusterStatus(name,ClusterStatus.PROVISIONING);
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.PROVISION_ERROR.name()));
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(createSpec.getName()));
  param.put(JobConstants.VERIFY_NODE_STATUS_SCOPE_PARAM,new JobParameter(JobConstants.CLUSTER_NODE_SCOPE_VALUE));
  JobParameters jobParameters=new JobParameters(param);
  return jobManager.runJob(JobConstants.CREATE_CLUSTER_JOB_NAME,jobParameters);
}","public Long createCluster(ClusterCreate createSpec) throws Exception {
  if (CommonUtil.isBlank(createSpec.getDistro())) {
    setDefaultDistro(createSpec);
  }
  DistroRead distroRead=getDistroManager().getDistroByName(createSpec.getDistro());
  createSpec.setDistroVendor(distroRead.getVendor());
  createSpec.setDistroVersion(distroRead.getVersion());
  createAutoRps(createSpec);
  ClusterCreate clusterSpec=ClusterSpecFactory.getCustomizedSpec(createSpec);
  createSpec.verifyClusterNameLength();
  clusterSpec.validateNodeGroupNames();
  if (clusterSpec != null && clusterSpec.getNodeGroups() != null) {
    for (    NodeGroupCreate ng : clusterSpec.getNodeGroups()) {
      String templateVmId=clusteringService.getTemplateVmId();
      if (templateVmId != null) {
        VcResourceUtils.checkVmMaxConfiguration(templateVmId,ng.getCpuNum() == null ? 0 : ng.getCpuNum(),ng.getMemCapacityMB() == null ? 0 : ng.getMemCapacityMB());
      }
    }
  }
  String name=clusterSpec.getName();
  logger.info(""String_Node_Str"" + name);
  List<String> dsNames=getUsedDS(clusterSpec.getDsNames());
  if (dsNames.isEmpty()) {
    throw ClusterConfigException.NO_DATASTORE_ADDED();
  }
  List<VcCluster> vcClusters=getUsedVcClusters(clusterSpec.getRpNames());
  if (vcClusters == null || vcClusters.isEmpty()) {
    throw ClusterConfigException.NO_RESOURCE_POOL_ADDED();
  }
  validateDatastore(dsNames,vcClusters);
  validateNetworkAccessibility(createSpec.getNetworkNames(),vcClusters);
  clusterConfigMgr.createClusterConfig(clusterSpec);
  clusterEntityMgr.updateClusterStatus(name,ClusterStatus.PROVISIONING);
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.PROVISION_ERROR.name()));
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(createSpec.getName()));
  param.put(JobConstants.VERIFY_NODE_STATUS_SCOPE_PARAM,new JobParameter(JobConstants.CLUSTER_NODE_SCOPE_VALUE));
  JobParameters jobParameters=new JobParameters(param);
  return jobManager.runJob(JobConstants.CREATE_CLUSTER_JOB_NAME,jobParameters);
}"
48825,"private CreateVmPrePowerOn getPrePowerOnFunc(BaseNode vNode){
  boolean persistentDiskMode=false;
  String haFlag=vNode.getNodeGroup().getHaFlag();
  boolean ha=false;
  boolean ft=false;
  if (haFlag != null && Constants.HA_FLAG_ON.equals(haFlag.toLowerCase())) {
    ha=true;
  }
  if (haFlag != null && Constants.HA_FLAG_FT.equals(haFlag.toLowerCase())) {
    ha=true;
    ft=true;
    if (vNode.getNodeGroup().getCpuNum() > 1) {
      throw ClusteringServiceException.CPU_NUMBER_MORE_THAN_ONE(vNode.getVmName());
    }
    logger.debug(""String_Node_Str"" + vNode.getVmName());
    logger.debug(""String_Node_Str"" + vNode.getVmName());
    persistentDiskMode=true;
  }
  List<String> roles=vNode.getNodeGroup().getRoles();
  if (roles != null && HadoopRole.hasMgmtRole(roles)) {
    logger.debug(vNode.getVmName() + ""String_Node_Str"");
    logger.debug(""String_Node_Str"" + vNode.getVmName());
    persistentDiskMode=true;
  }
  if (persistentDiskMode) {
    setPersistentDiskMode(vNode);
  }
  ClusterEntity clusterEntity=getClusterEntityMgr().findByName(vNode.getClusterName());
  CreateVmPrePowerOn prePowerOn=new CreateVmPrePowerOn(ha,ft,clusterEntity.getIoShares());
  return prePowerOn;
}","private CreateVmPrePowerOn getPrePowerOnFunc(BaseNode vNode){
  boolean persistentDiskMode=false;
  String haFlag=vNode.getNodeGroup().getHaFlag();
  boolean ha=false;
  boolean ft=false;
  if (haFlag != null && Constants.HA_FLAG_ON.equals(haFlag.toLowerCase())) {
    ha=true;
  }
  if (haFlag != null && Constants.HA_FLAG_FT.equals(haFlag.toLowerCase())) {
    ha=true;
    ft=true;
    Integer cpuNum=vNode.getNodeGroup().getCpuNum();
    cpuNum=(cpuNum == null) ? 0 : cpuNum;
    if (cpuNum > 1) {
      throw ClusteringServiceException.CPU_NUMBER_MORE_THAN_ONE(vNode.getVmName());
    }
    logger.debug(""String_Node_Str"" + vNode.getVmName());
    logger.debug(""String_Node_Str"" + vNode.getVmName());
    persistentDiskMode=true;
  }
  List<String> roles=vNode.getNodeGroup().getRoles();
  if (roles != null && HadoopRole.hasMgmtRole(roles)) {
    logger.debug(vNode.getVmName() + ""String_Node_Str"");
    logger.debug(""String_Node_Str"" + vNode.getVmName());
    persistentDiskMode=true;
  }
  if (persistentDiskMode) {
    setPersistentDiskMode(vNode);
  }
  ClusterEntity clusterEntity=getClusterEntityMgr().findByName(vNode.getClusterName());
  CreateVmPrePowerOn prePowerOn=new CreateVmPrePowerOn(ha,ft,clusterEntity.getIoShares());
  return prePowerOn;
}"
48826,"public static void expandGroupInstanceType(NodeGroupEntity ngEntity,GroupType groupType,Set<String> sharedPattern,Set<String> localPattern){
  logger.debug(""String_Node_Str"" + ngEntity.getName());
  InstanceType instanceType=ngEntity.getNodeType();
  if (instanceType == null) {
    if (groupType == GroupType.MASTER_GROUP || groupType == GroupType.MASTER_JOBTRACKER_GROUP || groupType == GroupType.HBASE_MASTER_GROUP || groupType == GroupType.ZOOKEEPER_GROUP) {
      instanceType=InstanceType.MEDIUM;
    }
 else {
      instanceType=InstanceType.SMALL;
    }
  }
  logger.debug(""String_Node_Str"" + instanceType.toString());
  int memory=ngEntity.getMemorySize();
  if (memory <= 0) {
    ngEntity.setMemorySize(instanceType.getMemoryMB());
  }
  int cpu=ngEntity.getCpuNum();
  if (cpu <= 0) {
    ngEntity.setCpuNum(instanceType.getCpuNum());
  }
  if (ngEntity.getStorageSize() <= 0) {
    ngEntity.setStorageSize(getStorage(instanceType,groupType));
    logger.debug(""String_Node_Str"" + ngEntity.getStorageSize());
  }
 else {
    logger.debug(""String_Node_Str"" + ngEntity.getStorageSize());
  }
  if (ngEntity.getStorageType() == null) {
    DatastoreType storeType=groupType.getStorageEnumType();
    if ((sharedPattern == null || sharedPattern.isEmpty()) && storeType == DatastoreType.SHARED) {
      storeType=DatastoreType.LOCAL;
    }
    if ((localPattern == null || localPattern.isEmpty()) && storeType == DatastoreType.LOCAL) {
      storeType=DatastoreType.SHARED;
    }
    ngEntity.setStorageType(storeType);
  }
 else {
    if ((sharedPattern == null || sharedPattern.isEmpty()) && (ngEntity.getStorageType().equals(DatastoreType.SHARED))) {
      String msg=""String_Node_Str"" + ngEntity.getName() + ""String_Node_Str"";
      logger.error(msg);
      throw ClusterConfigException.CLUSTER_CONFIG_DATASTORE_TYPE_NONEXISTENT(msg);
    }
    if ((localPattern == null || localPattern.isEmpty()) && (ngEntity.getStorageType().equals(DatastoreType.LOCAL))) {
      String msg=""String_Node_Str"" + ngEntity.getName() + ""String_Node_Str"";
      logger.error(msg);
      throw ClusterConfigException.CLUSTER_CONFIG_DATASTORE_TYPE_NONEXISTENT(msg);
    }
  }
}","public static void expandGroupInstanceType(NodeGroupEntity ngEntity,GroupType groupType,Set<String> sharedPattern,Set<String> localPattern){
  logger.debug(""String_Node_Str"" + ngEntity.getName());
  InstanceType instanceType=ngEntity.getNodeType();
  if (instanceType == null) {
    if (groupType == GroupType.MASTER_GROUP || groupType == GroupType.MASTER_JOBTRACKER_GROUP || groupType == GroupType.HBASE_MASTER_GROUP || groupType == GroupType.ZOOKEEPER_GROUP) {
      instanceType=InstanceType.MEDIUM;
    }
 else {
      instanceType=InstanceType.SMALL;
    }
  }
  logger.debug(""String_Node_Str"" + instanceType.toString());
  int memory=ngEntity.getMemorySize();
  if (memory == 0) {
    ngEntity.setMemorySize(instanceType.getMemoryMB());
  }
  int cpu=ngEntity.getCpuNum();
  if (cpu == 0) {
    ngEntity.setCpuNum(instanceType.getCpuNum());
  }
  if (ngEntity.getStorageSize() <= 0) {
    ngEntity.setStorageSize(getStorage(instanceType,groupType));
    logger.debug(""String_Node_Str"" + ngEntity.getStorageSize());
  }
 else {
    logger.debug(""String_Node_Str"" + ngEntity.getStorageSize());
  }
  if (ngEntity.getStorageType() == null) {
    DatastoreType storeType=groupType.getStorageEnumType();
    if ((sharedPattern == null || sharedPattern.isEmpty()) && storeType == DatastoreType.SHARED) {
      storeType=DatastoreType.LOCAL;
    }
    if ((localPattern == null || localPattern.isEmpty()) && storeType == DatastoreType.LOCAL) {
      storeType=DatastoreType.SHARED;
    }
    ngEntity.setStorageType(storeType);
  }
 else {
    if ((sharedPattern == null || sharedPattern.isEmpty()) && (ngEntity.getStorageType().equals(DatastoreType.SHARED))) {
      String msg=""String_Node_Str"" + ngEntity.getName() + ""String_Node_Str"";
      logger.error(msg);
      throw ClusterConfigException.CLUSTER_CONFIG_DATASTORE_TYPE_NONEXISTENT(msg);
    }
    if ((localPattern == null || localPattern.isEmpty()) && (ngEntity.getStorageType().equals(DatastoreType.LOCAL))) {
      String msg=""String_Node_Str"" + ngEntity.getName() + ""String_Node_Str"";
      logger.error(msg);
      throw ClusterConfigException.CLUSTER_CONFIG_DATASTORE_TYPE_NONEXISTENT(msg);
    }
  }
}"
48827,"public static VmSchema getVmSchema(ClusterCreate spec,String nodeGroup,List<DiskSpec> diskSet,String templateVmId,String templateVmSnapId){
  NodeGroupCreate groupSpec=spec.getNodeGroup(nodeGroup);
  VmSchema schema=new VmSchema();
  ResourceSchema resourceSchema=new ResourceSchema();
  resourceSchema.name=""String_Node_Str"";
  resourceSchema.cpuReservationMHz=0;
  resourceSchema.memReservationSize=0;
  resourceSchema.numCPUs=groupSpec.getCpuNum();
  resourceSchema.memSize=groupSpec.getMemCapacityMB();
  resourceSchema.priority=com.vmware.aurora.interfaces.model.IDatabaseConfig.Priority.Normal;
  schema.resourceSchema=resourceSchema;
  DiskSchema diskSchema=new DiskSchema();
  ArrayList<Disk> disks=new ArrayList<Disk>(diskSet.size());
  for (  DiskSpec disk : diskSet) {
    Disk tmDisk=new Disk();
    tmDisk.name=disk.getName();
    tmDisk.type=disk.getDiskType().getType();
    tmDisk.initialSizeMB=disk.getSize() * 1024;
    if (disk.getAllocType() != null && !disk.getAllocType().isEmpty())     tmDisk.allocationType=AllocationType.valueOf(disk.getAllocType().toUpperCase());
 else     tmDisk.allocationType=null;
    tmDisk.datastore=disk.getTargetDs();
    tmDisk.externalAddress=disk.getExternalAddress();
    tmDisk.vmdkPath=disk.getVmdkPath();
    tmDisk.mode=DiskMode.valueOf(disk.getDiskMode());
    disks.add(tmDisk);
  }
  diskSchema.setParent(templateVmId);
  diskSchema.setParentSnap(templateVmSnapId);
  diskSchema.setDisks(disks);
  schema.diskSchema=diskSchema;
  ArrayList<Network> networks=new ArrayList<Network>();
  List<NetworkAdd> networkAdds=spec.getNetworkings();
  int labelIndex=1;
  for (  NetworkAdd networkAdd : networkAdds) {
    Network network=new Network();
    network.vcNetwork=networkAdd.getPortGroup();
    network.nicLabel=NIC_LABEL_PREFIX + labelIndex;
    labelIndex++;
    networks.add(network);
  }
  NetworkSchema networkSchema=new NetworkSchema();
  networkSchema.name=""String_Node_Str"";
  networkSchema.networks=networks;
  schema.networkSchema=networkSchema;
  return schema;
}","public static VmSchema getVmSchema(ClusterCreate spec,String nodeGroup,List<DiskSpec> diskSet,String templateVmId,String templateVmSnapId){
  NodeGroupCreate groupSpec=spec.getNodeGroup(nodeGroup);
  VmSchema schema=new VmSchema();
  ResourceSchema resourceSchema=new ResourceSchema();
  resourceSchema.name=""String_Node_Str"";
  resourceSchema.cpuReservationMHz=0;
  resourceSchema.memReservationSize=0;
  resourceSchema.numCPUs=(groupSpec.getCpuNum() == null) ? 0 : groupSpec.getCpuNum();
  resourceSchema.memSize=(groupSpec.getMemCapacityMB() == null) ? 0 : groupSpec.getMemCapacityMB();
  resourceSchema.priority=com.vmware.aurora.interfaces.model.IDatabaseConfig.Priority.Normal;
  schema.resourceSchema=resourceSchema;
  DiskSchema diskSchema=new DiskSchema();
  ArrayList<Disk> disks=new ArrayList<Disk>(diskSet.size());
  for (  DiskSpec disk : diskSet) {
    Disk tmDisk=new Disk();
    tmDisk.name=disk.getName();
    tmDisk.type=disk.getDiskType().getType();
    tmDisk.initialSizeMB=disk.getSize() * 1024;
    if (disk.getAllocType() != null && !disk.getAllocType().isEmpty())     tmDisk.allocationType=AllocationType.valueOf(disk.getAllocType().toUpperCase());
 else     tmDisk.allocationType=null;
    tmDisk.datastore=disk.getTargetDs();
    tmDisk.externalAddress=disk.getExternalAddress();
    tmDisk.vmdkPath=disk.getVmdkPath();
    tmDisk.mode=DiskMode.valueOf(disk.getDiskMode());
    disks.add(tmDisk);
  }
  diskSchema.setParent(templateVmId);
  diskSchema.setParentSnap(templateVmSnapId);
  diskSchema.setDisks(disks);
  schema.diskSchema=diskSchema;
  ArrayList<Network> networks=new ArrayList<Network>();
  List<NetworkAdd> networkAdds=spec.getNetworkings();
  int labelIndex=1;
  for (  NetworkAdd networkAdd : networkAdds) {
    Network network=new Network();
    network.vcNetwork=networkAdd.getPortGroup();
    network.nicLabel=NIC_LABEL_PREFIX + labelIndex;
    labelIndex++;
    networks.add(network);
  }
  NetworkSchema networkSchema=new NetworkSchema();
  networkSchema.name=""String_Node_Str"";
  networkSchema.networks=networks;
  schema.networkSchema=networkSchema;
  return schema;
}"
48828,"@Override public BaseNode getBaseNode(ClusterCreate cluster,NodeGroupCreate nodeGroup,int index){
  String vmName=PlacementUtil.getVmName(cluster.getName(),nodeGroup.getName(),index);
  BaseNode node=new BaseNode(vmName,nodeGroup,cluster);
  List<DiskSpec> disks=new ArrayList<DiskSpec>();
  DiskSpec systemDisk=new DiskSpec(templateNode.getDisks().get(0));
  systemDisk.setSize(systemDisk.getSize() + (nodeGroup.getMemCapacityMB() + 1023) / 1024);
  systemDisk.setDiskType(DiskType.SYSTEM_DISK);
  systemDisk.setSeparable(false);
  disks.add(systemDisk);
  AllocationType diskAllocType=null;
  if (nodeGroup.getStorage().getAllocType() != null) {
    diskAllocType=AllocationType.valueOf(nodeGroup.getStorage().getAllocType());
  }
 else {
    diskAllocType=AllocationType.THICK;
  }
  int swapDisk=(((int)Math.ceil(nodeGroup.getMemCapacityMB() * nodeGroup.getSwapRatio()) + 1023) / 1024);
  disks.add(new DiskSpec(DiskType.SWAP_DISK.getDiskName(),swapDisk,node.getVmName(),false,DiskType.SWAP_DISK,DiskScsiControllerType.LSI_CONTROLLER,null,diskAllocType.toString(),null,null,null));
  if (!DatastoreType.TEMPFS.name().equalsIgnoreCase(nodeGroup.getStorage().getType())) {
    disks.add(new DiskSpec(DiskType.DATA_DISK.getDiskName(),nodeGroup.getStorage().getSizeGB(),node.getVmName(),true,DiskType.DATA_DISK,nodeGroup.getStorage().getControllerType(),nodeGroup.getStorage().getSplitPolicy(),diskAllocType.toString(),null,null,null));
  }
  node.setDisks(disks);
  node.setVmFolder(nodeGroup.getVmFolderPath());
  NetworkSchema netSchema=new NetworkSchema();
  ArrayList<Network> networks=new ArrayList<Network>();
  netSchema.networks=networks;
  for (  NetworkAdd networkAdd : cluster.getNetworkings()) {
    Network network=new Network();
    network.vcNetwork=networkAdd.getPortGroup();
    networks.add(network);
  }
  node.getVmSchema().networkSchema=netSchema;
  ResourceSchema resourceSchema=new ResourceSchema();
  resourceSchema.numCPUs=node.getCpu();
  resourceSchema.cpuReservationMHz=0;
  resourceSchema.memSize=node.getMem();
  resourceSchema.memReservationSize=0;
  resourceSchema.name=""String_Node_Str"";
  resourceSchema.priority=Priority.Normal;
  node.getVmSchema().resourceSchema=resourceSchema;
  return node;
}","@Override public BaseNode getBaseNode(ClusterCreate cluster,NodeGroupCreate nodeGroup,int index){
  String vmName=PlacementUtil.getVmName(cluster.getName(),nodeGroup.getName(),index);
  BaseNode node=new BaseNode(vmName,nodeGroup,cluster);
  List<DiskSpec> disks=new ArrayList<DiskSpec>();
  DiskSpec systemDisk=new DiskSpec(templateNode.getDisks().get(0));
  Integer memCapa=nodeGroup.getMemCapacityMB();
  memCapa=(memCapa == null) ? 0 : memCapa;
  systemDisk.setSize(systemDisk.getSize() + (memCapa + 1023) / 1024);
  systemDisk.setDiskType(DiskType.SYSTEM_DISK);
  systemDisk.setSeparable(false);
  disks.add(systemDisk);
  AllocationType diskAllocType=null;
  if (nodeGroup.getStorage().getAllocType() != null) {
    diskAllocType=AllocationType.valueOf(nodeGroup.getStorage().getAllocType());
  }
 else {
    diskAllocType=AllocationType.THICK;
  }
  int swapDisk=(((int)Math.ceil(nodeGroup.getMemCapacityMB() * nodeGroup.getSwapRatio()) + 1023) / 1024);
  disks.add(new DiskSpec(DiskType.SWAP_DISK.getDiskName(),swapDisk,node.getVmName(),false,DiskType.SWAP_DISK,DiskScsiControllerType.LSI_CONTROLLER,null,diskAllocType.toString(),null,null,null));
  if (!DatastoreType.TEMPFS.name().equalsIgnoreCase(nodeGroup.getStorage().getType())) {
    disks.add(new DiskSpec(DiskType.DATA_DISK.getDiskName(),nodeGroup.getStorage().getSizeGB(),node.getVmName(),true,DiskType.DATA_DISK,nodeGroup.getStorage().getControllerType(),nodeGroup.getStorage().getSplitPolicy(),diskAllocType.toString(),null,null,null));
  }
  node.setDisks(disks);
  node.setVmFolder(nodeGroup.getVmFolderPath());
  NetworkSchema netSchema=new NetworkSchema();
  ArrayList<Network> networks=new ArrayList<Network>();
  netSchema.networks=networks;
  for (  NetworkAdd networkAdd : cluster.getNetworkings()) {
    Network network=new Network();
    network.vcNetwork=networkAdd.getPortGroup();
    networks.add(network);
  }
  node.getVmSchema().networkSchema=netSchema;
  ResourceSchema resourceSchema=new ResourceSchema();
  resourceSchema.numCPUs=node.getCpu();
  resourceSchema.cpuReservationMHz=0;
  resourceSchema.memSize=node.getMem();
  resourceSchema.memReservationSize=0;
  resourceSchema.name=""String_Node_Str"";
  resourceSchema.priority=Priority.Normal;
  node.getVmSchema().resourceSchema=resourceSchema;
  return node;
}"
48829,"public int getMem(){
  return nodeGroup.getMemCapacityMB();
}","public int getMem(){
  return nodeGroup.getMemCapacityMB() == null ? 0 : nodeGroup.getMemCapacityMB();
}"
48830,"public int getCpu(){
  return nodeGroup.getCpuNum();
}","public int getCpu(){
  return nodeGroup.getCpuNum() == null ? 0 : nodeGroup.getCpuNum();
}"
48831,"/** 
 * set cluster parameters asynchronously
 * @param clusterName
 * @param activeComputeNodeNum
 * @param minComputeNodeNum
 * @param maxComputeNodeNum
 * @param enableAuto
 * @param ioPriority
 * @return
 * @throws Exception
 */
public Long asyncSetParam(String clusterName,Integer activeComputeNodeNum,Integer minComputeNodeNum,Integer maxComputeNodeNum,Boolean enableAuto,Priority ioPriority) throws Exception {
  syncSetParam(clusterName,activeComputeNodeNum,minComputeNodeNum,maxComputeNodeNum,enableAuto,ioPriority);
  ClusterRead cluster=getClusterByName(clusterName,false);
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus())) {
    String msg=""String_Node_Str"" + clusterName + ""String_Node_Str"";
    logger.error(msg);
    throw ClusterManagerException.SET_MANUAL_ELASTICITY_NOT_ALLOWED_ERROR(msg);
  }
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  if (activeComputeNodeNum == null) {
    activeComputeNodeNum=cluster.getVhmTargetNum();
  }
  if (activeComputeNodeNum == -1) {
    param.put(JobConstants.VHM_ACTION_JOB_PARAM,new JobParameter(LimitInstruction.actionUnlimit));
  }
 else {
    param.put(JobConstants.VHM_ACTION_JOB_PARAM,new JobParameter(LimitInstruction.actionSetTarget));
  }
  param.put(JobConstants.ACTIVE_COMPUTE_NODE_NUMBER_JOB_PARAM,new JobParameter(Long.valueOf(activeComputeNodeNum)));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  JobParameters jobParameters=new JobParameters(param);
  try {
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.VHM_RUNNING);
    return jobManager.runJob(JobConstants.SET_MANUAL_ELASTICITY_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.RUNNING);
    throw e;
  }
}","/** 
 * set cluster parameters asynchronously
 * @param clusterName
 * @param activeComputeNodeNum
 * @param minComputeNodeNum
 * @param maxComputeNodeNum
 * @param enableAuto
 * @param ioPriority
 * @return
 * @throws Exception
 */
public Long asyncSetParam(String clusterName,Integer activeComputeNodeNum,Integer minComputeNodeNum,Integer maxComputeNodeNum,Boolean enableAuto,Priority ioPriority) throws Exception {
  syncSetParam(clusterName,activeComputeNodeNum,minComputeNodeNum,maxComputeNodeNum,enableAuto,ioPriority);
  ClusterRead cluster=getClusterByName(clusterName,false);
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus())) {
    String msg=""String_Node_Str"" + clusterName + ""String_Node_Str"";
    logger.error(msg);
    throw ClusterManagerException.SET_MANUAL_ELASTICITY_NOT_ALLOWED_ERROR(msg);
  }
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  if (activeComputeNodeNum == null) {
    param.put(JobConstants.VHM_ACTION_JOB_PARAM,new JobParameter(LimitInstruction.actionWaitForManual));
  }
 else   if (activeComputeNodeNum == -1) {
    param.put(JobConstants.VHM_ACTION_JOB_PARAM,new JobParameter(LimitInstruction.actionUnlimit));
  }
 else {
    param.put(JobConstants.VHM_ACTION_JOB_PARAM,new JobParameter(LimitInstruction.actionSetTarget));
  }
  if (activeComputeNodeNum != null) {
    param.put(JobConstants.ACTIVE_COMPUTE_NODE_NUMBER_JOB_PARAM,new JobParameter(Long.valueOf(activeComputeNodeNum)));
  }
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  JobParameters jobParameters=new JobParameters(param);
  try {
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.VHM_RUNNING);
    return jobManager.runJob(JobConstants.SET_MANUAL_ELASTICITY_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.RUNNING);
    throw e;
  }
}"
48832,"@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  Map<String,JobParameter> allParameters=getJobParameters(chunkContext).getParameters();
  if (!allParameters.containsKey(JobConstants.VHM_ACTION_JOB_PARAM) && !allParameters.containsKey(JobConstants.ACTIVE_COMPUTE_NODE_NUMBER_JOB_PARAM)) {
    return RepeatStatus.FINISHED;
  }
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  Long activeComputeNodeNum=getJobParameters(chunkContext).getLong(JobConstants.ACTIVE_COMPUTE_NODE_NUMBER_JOB_PARAM);
  String action=getJobParameters(chunkContext).getString(JobConstants.VHM_ACTION_JOB_PARAM);
  if (action != null) {
    vhmAction=action;
  }
  if (vhmAction == LimitInstruction.actionWaitForManual) {
    if (!disableAutoElasticity(clusterName)) {
      throw TaskException.EXECUTION_FAILED(""String_Node_Str"" + clusterName);
    }
  }
  MessageHandler listener=null;
  if (vhmAction == LimitInstruction.actionSetTarget || vhmAction == LimitInstruction.actionUnlimit) {
    StatusUpdater statusUpdater=new DefaultStatusUpdater(jobExecutionStatusHolder,getJobExecutionId(chunkContext));
    listener=new VHMReceiveListener(clusterName,statusUpdater);
  }
  Map<String,Object> sendParam=new HashMap<String,Object>();
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_VERSION,Constants.VHM_PROTOCOL_VERSION);
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_CLUSTER_NAME,clusterName);
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_INSTANCE_NUM,activeComputeNodeNum);
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_RECEIVE_ROUTE_KEY,CommonUtil.getUUID());
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_ACTION,vhmAction);
  Map<String,Object> ret=executionService.execute(new VHMMessageTask(sendParam,listener));
  if (!(Boolean)ret.get(""String_Node_Str"")) {
    String errorMessage=(String)ret.get(""String_Node_Str"");
    putIntoJobExecutionContext(chunkContext,JobConstants.CURRENT_ERROR_MESSAGE,errorMessage);
    throw TaskException.EXECUTION_FAILED(errorMessage);
  }
  return RepeatStatus.FINISHED;
}","@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  Map<String,JobParameter> allParameters=getJobParameters(chunkContext).getParameters();
  if (!allParameters.containsKey(JobConstants.VHM_ACTION_JOB_PARAM) && !allParameters.containsKey(JobConstants.ACTIVE_COMPUTE_NODE_NUMBER_JOB_PARAM)) {
    return RepeatStatus.FINISHED;
  }
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  Long activeComputeNodeNum=getJobParameters(chunkContext).getLong(JobConstants.ACTIVE_COMPUTE_NODE_NUMBER_JOB_PARAM);
  String action=getJobParameters(chunkContext).getString(JobConstants.VHM_ACTION_JOB_PARAM);
  if (action != null) {
    vhmAction=action;
  }
  MessageHandler listener=null;
  if (vhmAction == LimitInstruction.actionSetTarget || vhmAction == LimitInstruction.actionUnlimit) {
    StatusUpdater statusUpdater=new DefaultStatusUpdater(jobExecutionStatusHolder,getJobExecutionId(chunkContext));
    listener=new VHMReceiveListener(clusterName,statusUpdater);
  }
  Map<String,Object> sendParam=new HashMap<String,Object>();
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_VERSION,Constants.VHM_PROTOCOL_VERSION);
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_CLUSTER_NAME,clusterName);
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_INSTANCE_NUM,activeComputeNodeNum);
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_RECEIVE_ROUTE_KEY,CommonUtil.getUUID());
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_ACTION,vhmAction);
  Map<String,Object> ret=executionService.execute(new VHMMessageTask(sendParam,listener));
  if (!(Boolean)ret.get(""String_Node_Str"")) {
    String errorMessage=(String)ret.get(""String_Node_Str"");
    putIntoJobExecutionContext(chunkContext,JobConstants.CURRENT_ERROR_MESSAGE,errorMessage);
    throw TaskException.EXECUTION_FAILED(errorMessage);
  }
  return RepeatStatus.FINISHED;
}"
48833,"private boolean placeDisk(VirtualNode vNode,AbstractHost host){
  AbstractHost clonedHost=AbstractHost.clone(host);
  Map<BaseNode,List<DiskSpec>> result=new HashMap<BaseNode,List<DiskSpec>>();
  for (  BaseNode node : vNode.getBaseNodes()) {
    List<DiskSpec> disks;
    List<AbstractDatastore> imagestores=clonedHost.getDatastores(node.getImagestoreNamePattern());
    List<AbstractDatastore> diskstores=clonedHost.getDatastores(node.getDiskstoreNamePattern());
    List<DiskSpec> systemDisks=new ArrayList<DiskSpec>();
    List<DiskSpec> unseprable=new ArrayList<DiskSpec>();
    List<DiskSpec> separable=new ArrayList<DiskSpec>();
    List<DiskSpec> removed=new ArrayList<DiskSpec>();
    for (    DiskSpec disk : node.getDisks()) {
      if (disk.getSplitPolicy() != null && DiskSplitPolicy.BI_SECTOR.equals(disk.getSplitPolicy())) {
        int half=disk.getSize() / 2;
        unseprable.add(new DiskSpec(disk.getName().split(""String_Node_Str"")[0] + ""String_Node_Str"",half,node.getVmName(),false,disk.getDiskType(),disk.getController(),null,disk.getAllocType(),null,null,null));
        unseprable.add(new DiskSpec(disk.getName().split(""String_Node_Str"")[0] + ""String_Node_Str"",disk.getSize() - half,node.getVmName(),false,disk.getDiskType(),disk.getController(),null,disk.getAllocType(),null,null,null));
        removed.add(disk);
      }
    }
    node.getDisks().removeAll(removed);
    for (    DiskSpec disk : node.getDisks()) {
      if (DiskType.DATA_DISK == disk.getDiskType()) {
        if (disk.isSeparable()) {
          separable.add(disk);
        }
 else {
          unseprable.add(disk);
        }
      }
 else {
        systemDisks.add(disk);
      }
    }
    disks=placeUnSeparableDisks(systemDisks,imagestores);
    List<DiskSpec> subDisks=placeUnSeparableDisks(unseprable,diskstores);
    if (disks == null) {
      return false;
    }
 else {
      disks.addAll(subDisks);
    }
    subDisks=placeSeparableDisks(separable,diskstores);
    if (subDisks == null) {
      return false;
    }
 else {
      disks.addAll(subDisks);
    }
    result.put(node,disks);
  }
  for (  BaseNode node : vNode.getBaseNodes()) {
    AuAssert.check(result.get(node) != null);
    node.setDisks(result.get(node));
  }
  return true;
}","private boolean placeDisk(VirtualNode vNode,AbstractHost host){
  AbstractHost clonedHost=AbstractHost.clone(host);
  Map<BaseNode,List<DiskSpec>> result=new HashMap<BaseNode,List<DiskSpec>>();
  for (  BaseNode node : vNode.getBaseNodes()) {
    List<DiskSpec> disks;
    List<AbstractDatastore> imagestores=clonedHost.getDatastores(node.getImagestoreNamePattern());
    List<AbstractDatastore> diskstores=clonedHost.getDatastores(node.getDiskstoreNamePattern());
    List<DiskSpec> systemDisks=new ArrayList<DiskSpec>();
    List<DiskSpec> unseparable=new ArrayList<DiskSpec>();
    List<DiskSpec> separable=new ArrayList<DiskSpec>();
    List<DiskSpec> removed=new ArrayList<DiskSpec>();
    for (    DiskSpec disk : node.getDisks()) {
      if (disk.getSplitPolicy() != null && DiskSplitPolicy.BI_SECTOR.equals(disk.getSplitPolicy())) {
        int half=disk.getSize() / 2;
        unseparable.add(new DiskSpec(disk.getName().split(""String_Node_Str"")[0] + ""String_Node_Str"",half,node.getVmName(),false,disk.getDiskType(),disk.getController(),null,disk.getAllocType(),null,null,null));
        unseparable.add(new DiskSpec(disk.getName().split(""String_Node_Str"")[0] + ""String_Node_Str"",disk.getSize() - half,node.getVmName(),false,disk.getDiskType(),disk.getController(),null,disk.getAllocType(),null,null,null));
        removed.add(disk);
      }
    }
    node.getDisks().removeAll(removed);
    for (    DiskSpec disk : node.getDisks()) {
      if (DiskType.DATA_DISK == disk.getDiskType()) {
        if (disk.isSeparable()) {
          separable.add(disk);
        }
 else {
          unseparable.add(disk);
        }
      }
 else {
        systemDisks.add(disk);
      }
    }
    disks=placeUnSeparableDisks(systemDisks,imagestores);
    if (disks == null) {
      logger.info(""String_Node_Str"" + getDiskSize(systemDisks) + ""String_Node_Str""+ getDsFree(imagestores)+ ""String_Node_Str"");
      return false;
    }
    List<DiskSpec> subDisks=null;
    if (unseparable != null && unseparable.size() != 0) {
      subDisks=placeUnSeparableDisks(unseparable,diskstores);
      if (subDisks == null) {
        logger.info(""String_Node_Str"" + getDiskSize(unseparable) + ""String_Node_Str""+ getDsFree(diskstores)+ ""String_Node_Str"");
        return false;
      }
 else {
        disks.addAll(subDisks);
      }
    }
    if (separable != null && separable.size() != 0) {
      subDisks=placeSeparableDisks(separable,diskstores);
      if (subDisks == null) {
        logger.info(""String_Node_Str"" + getDiskSize(separable) + ""String_Node_Str""+ getDsFree(diskstores)+ ""String_Node_Str"");
        return false;
      }
 else {
        disks.addAll(subDisks);
      }
    }
    result.put(node,disks);
  }
  for (  BaseNode node : vNode.getBaseNodes()) {
    AuAssert.check(result.get(node) != null);
    node.setDisks(result.get(node));
  }
  return true;
}"
48834,"private void refreshNodeStatus(NodeEntity node,boolean inSession){
  String mobId=node.getMoId();
  if (mobId == null) {
    setNotExist(node);
    return;
  }
  VcVirtualMachine vcVm=VcCache.getIgnoreMissing(mobId);
  if (vcVm == null) {
    setNotExist(node);
    return;
  }
  if (!vcVm.isPoweredOn()) {
    node.setStatus(NodeStatus.POWERED_OFF);
    node.resetIps();
  }
 else {
    node.setStatus(NodeStatus.POWERED_ON);
  }
  if (vcVm.isPoweredOn() && node.isPowerStatusChanged()) {
    for (    String portGroup : node.fetchAllPortGroups()) {
      String ip=VcVmUtil.getIpAddressOfPortGroup(vcVm,portGroup,inSession);
      node.updateIpAddressOfPortGroup(portGroup,ip);
    }
    if (node.ipsReady()) {
      node.setStatus(NodeStatus.VM_READY);
      if (node.getAction() != null && (node.getAction().equals(Constants.NODE_ACTION_WAITING_IP) || node.getAction().equals(Constants.NODE_ACTION_RECONFIGURE))) {
        node.setAction(null);
      }
    }
    String guestHostName=VcVmUtil.getGuestHostName(vcVm,inSession);
    if (guestHostName != null) {
      node.setGuestHostName(guestHostName);
    }
  }
  node.setHostName(vcVm.getHost().getName());
  update(node);
}","private void refreshNodeStatus(NodeEntity node,boolean inSession){
  String mobId=node.getMoId();
  if (mobId == null) {
    setNotExist(node);
    return;
  }
  VcVirtualMachine vcVm=VcCache.getIgnoreMissing(mobId);
  if (vcVm == null) {
    setNotExist(node);
    return;
  }
  if (!vcVm.isPoweredOn()) {
    node.setStatus(NodeStatus.POWERED_OFF);
    node.resetIps();
  }
 else {
    node.setStatus(NodeStatus.POWERED_ON);
  }
  if (vcVm.isPoweredOn()) {
    for (    String portGroup : node.fetchAllPortGroups()) {
      String ip=VcVmUtil.getIpAddressOfPortGroup(vcVm,portGroup,inSession);
      node.updateIpAddressOfPortGroup(portGroup,ip);
    }
    if (node.ipsReady()) {
      node.setStatus(NodeStatus.VM_READY);
      if (node.getAction() != null && (node.getAction().equals(Constants.NODE_ACTION_WAITING_IP) || node.getAction().equals(Constants.NODE_ACTION_RECONFIGURE))) {
        node.setAction(null);
      }
    }
    String guestHostName=VcVmUtil.getGuestHostName(vcVm,inSession);
    if (guestHostName != null) {
      node.setGuestHostName(guestHostName);
    }
  }
  node.setHostName(vcVm.getHost().getName());
  update(node);
}"
48835,"/** 
 * this method will delete the cluster root folder, if there is any VM existed and powered on in the folder, the folder deletion will fail.
 * @param node
 * @throws BddException
 */
private void deleteFolders(BaseNode node) throws BddException {
  String path=node.getVmFolder();
  String[] folderNames=path.split(""String_Node_Str"");
  AuAssert.check(folderNames.length == 3);
  VcDatacenter dc=templateVm.getDatacenter();
  List<String> deletedFolders=new ArrayList<String>();
  deletedFolders.add(folderNames[0]);
  deletedFolders.add(folderNames[1]);
  Folder folder=null;
  try {
    folder=VcResourceUtils.findFolderByNameList(dc,deletedFolders);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
  String clusterFolderName=folderNames[0] + ""String_Node_Str"" + folderNames[1];
  logger.info(""String_Node_Str"" + clusterFolderName);
  List<Folder> folders=new ArrayList<Folder>();
  folders.add(folder);
  DeleteVMFolderSP sp=new DeleteVMFolderSP(folders,true,false);
  Callable<Void>[] storedProcedures=new Callable[1];
  storedProcedures[0]=sp;
  try {
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storedProcedures,callback);
    if (result == null || result.length == 0) {
      logger.error(""String_Node_Str"");
      return;
    }
    if (result[0].finished && result[0].throwable == null) {
      logger.info(""String_Node_Str"" + clusterFolderName + ""String_Node_Str"");
    }
 else {
      logger.info(""String_Node_Str"" + clusterFolderName,result[0].throwable);
    }
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}","/** 
 * this method will delete the cluster root folder, if there is any VM existed and powered on in the folder, the folder deletion will fail.
 * @param node
 * @throws BddException
 */
private void deleteFolders(BaseNode node) throws BddException {
  String path=node.getVmFolder();
  String[] folderNames=path.split(""String_Node_Str"");
  AuAssert.check(folderNames.length == 3);
  VcDatacenter dc=templateVm.getDatacenter();
  List<String> deletedFolders=new ArrayList<String>();
  deletedFolders.add(folderNames[0]);
  deletedFolders.add(folderNames[1]);
  Folder folder=null;
  try {
    folder=VcResourceUtils.findFolderByNameList(dc,deletedFolders);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
  if (folder == null) {
    logger.info(""String_Node_Str"");
  }
  String clusterFolderName=folderNames[0] + ""String_Node_Str"" + folderNames[1];
  logger.info(""String_Node_Str"" + clusterFolderName);
  List<Folder> folders=new ArrayList<Folder>();
  folders.add(folder);
  DeleteVMFolderSP sp=new DeleteVMFolderSP(folders,true,false);
  Callable<Void>[] storedProcedures=new Callable[1];
  storedProcedures[0]=sp;
  try {
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storedProcedures,callback);
    if (result == null || result.length == 0) {
      logger.error(""String_Node_Str"");
      return;
    }
    if (result[0].finished && result[0].throwable == null) {
      logger.info(""String_Node_Str"" + clusterFolderName + ""String_Node_Str"");
    }
 else {
      logger.info(""String_Node_Str"" + clusterFolderName,result[0].throwable);
    }
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}"
48836,"private void processEvent(VcEventType type,Event e,String moId,boolean external) throws Exception {
  try {
switch (type) {
case VmRemoved:
{
        logger.debug(""String_Node_Str"" + moId);
        if (clusterEntityMgr.getNodeByMobId(moId) != null) {
          clusterEntityMgr.refreshNodeByMobId(moId,null,true);
        }
        break;
      }
case VmDisconnected:
{
      refreshNodeWithAction(e,null,true,null,""String_Node_Str"");
      break;
    }
case VmPoweredOn:
{
    refreshNodeWithAction(e,moId,true,Constants.NODE_ACTION_WAITING_IP,""String_Node_Str"");
    if (external) {
      NodePowerOnRequest request=new NodePowerOnRequest(clusterEntityMgr,moId);
      CmsWorker.addRequest(WorkQueue.VC_TASK_NO_DELAY,request);
    }
    break;
  }
case VmCloned:
{
  refreshNodeWithAction(e,moId,true,Constants.NODE_ACTION_RECONFIGURE,""String_Node_Str"");
  break;
}
case VmSuspended:
{
refreshNodeWithAction(e,moId,true,null,""String_Node_Str"");
break;
}
case VmPoweredOff:
{
refreshNodeWithAction(e,moId,true,null,""String_Node_Str"");
break;
}
case VhmError:
case VhmWarning:
case VhmInfo:
case VhmUser:
{
EventEx event=(EventEx)e;
refreshNodeWithAction(e,moId,true,null,""String_Node_Str"");
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
break;
}
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + e.getDynamicType() + ""String_Node_Str""+ vm.getName()+ ""String_Node_Str""+ event.getMessage());
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),event.getMessage(),true);
}
break;
}
default :
{
refreshNodeWithAction(e,moId,false,null,type.name());
break;
}
}
}
 catch (ManagedObjectNotFound exp) {
VcUtil.processNotFoundException(exp,moId,logger);
}
}","private void processEvent(VcEventType type,Event e,String moId,boolean external) throws Exception {
  try {
switch (type) {
case VmRemoved:
{
        logger.debug(""String_Node_Str"" + moId);
        if (clusterEntityMgr.getNodeByMobId(moId) != null) {
          clusterEntityMgr.refreshNodeByMobId(moId,null,true);
        }
        break;
      }
case VmDisconnected:
{
      refreshNodeWithAction(e,null,true,null,""String_Node_Str"");
      break;
    }
case VmPoweredOn:
{
    refreshNodeWithAction(e,moId,true,Constants.NODE_ACTION_WAITING_IP,""String_Node_Str"");
    if (external) {
      NodePowerOnRequest request=new NodePowerOnRequest(clusterEntityMgr,moId);
      CmsWorker.addRequest(WorkQueue.VC_TASK_NO_DELAY,request);
    }
    break;
  }
case VmCloned:
{
  refreshNodeWithAction(e,moId,true,Constants.NODE_ACTION_RECONFIGURE,""String_Node_Str"");
  break;
}
case VmSuspended:
{
refreshNodeWithAction(e,moId,true,null,""String_Node_Str"");
break;
}
case VmPoweredOff:
{
refreshNodeWithAction(e,moId,true,null,""String_Node_Str"");
break;
}
case VhmError:
case VhmWarning:
case VhmInfo:
case VhmUser:
{
EventEx event=(EventEx)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
break;
}
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + e.getDynamicType() + ""String_Node_Str""+ vm.getName()+ ""String_Node_Str""+ event.getMessage());
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),event.getMessage(),true);
}
break;
}
default :
{
refreshNodeWithAction(e,moId,false,null,type.name());
break;
}
}
}
 catch (ManagedObjectNotFound exp) {
VcUtil.processNotFoundException(exp,moId,logger);
}
}"
48837,"public void setStatus(NodeStatus status,boolean validation){
  if (validation) {
    setStatus(status);
  }
 else {
    this.status=status;
  }
}","public void setStatus(NodeStatus status,boolean validation){
  if (validation) {
    setStatus(status);
  }
 else {
    logger.debug(""String_Node_Str"" + getVmName() + ""String_Node_Str""+ status+ ""String_Node_Str"");
    this.status=status;
  }
}"
48838,"/** 
 * the latest_task_id attribute of a cluster entity records the latest job id the cluster executes
 * @return
 */
public List<TaskRead> getLatestTaskForExistedClusters(){
  List<Long> taskIds=clusterEntityMgr.getLatestTaskIds();
  List<TaskRead> taskReads=new ArrayList<TaskRead>(taskIds.size());
  for (  Long id : taskIds) {
    if (id == null)     continue;
    TaskRead task=getJobExecutionStatus(id);
    task.setType(Type.INNER);
    taskReads.add(task);
  }
  return taskReads;
}","/** 
 * the latest_task_id attribute of a cluster entity records the latest job id the cluster executes
 * @return
 */
public List<TaskRead> getLatestTaskForExistedClusters(){
  List<Long> taskIds=clusterEntityMgr.getLatestTaskIds();
  List<TaskRead> taskReads=new ArrayList<TaskRead>(taskIds.size());
  for (  Long id : taskIds) {
    if (id == null)     continue;
    TaskRead task=getJobExecutionStatus(id);
    task.setType(Type.INNER);
    if (task.getStatus() == TaskRead.Status.COMPLETED) {
      task.setProgress(1.0);
    }
    taskReads.add(task);
  }
  return taskReads;
}"
48839,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET,produces=""String_Node_Str"") @ResponseBody public TaskRead getTaskById(@PathVariable long taskId) throws Exception {
  TaskRead task=jobManager.getJobExecutionStatus(taskId);
  if (task.getType() == null) {
    task.setType(Type.INNER);
  }
  return task;
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET,produces=""String_Node_Str"") @ResponseBody public TaskRead getTaskById(@PathVariable long taskId) throws Exception {
  TaskRead task=jobManager.getJobExecutionStatus(taskId);
  if (task.getStatus() == TaskRead.Status.COMPLETED) {
    task.setProgress(1.0);
  }
  if (task.getType() == null) {
    task.setType(Type.INNER);
  }
  return task;
}"
48840,"public void run(){
  File currentFile=null;
  while (!isTerminate) {
    try {
      File directory=new File(""String_Node_Str"");
      File[] files=directory.listFiles(new FilenameFilter(){
        public boolean accept(        File dir,        String name){
          if (name.startsWith(filenamePrefix))           return true;
 else           return false;
        }
      }
);
      Arrays.sort(files,new Comparator<File>(){
        public int compare(        File f1,        File f2){
          return Long.valueOf(f1.lastModified()).compareTo(f2.lastModified());
        }
      }
);
      for (      File file : files) {
        currentFile=file;
        String filename=file.getName();
        logger.info(""String_Node_Str"" + filename + ""String_Node_Str"");
        String[] strs=filename.substring(filenamePrefix.length()).split(""String_Node_Str"");
        if (strs == null || strs.length != 2) {
          logger.error(""String_Node_Str"" + filename + ""String_Node_Str""+ filenamePrefix+ ""String_Node_Str"");
          file.delete();
          continue;
        }
        String clusterName=strs[0];
        String nodeCountStr=strs[1];
        ClusterRead cluster=null;
        try {
          cluster=clusterMgr.getClusterByName(clusterName,false);
        }
 catch (        BddException e) {
          logger.error(""String_Node_Str"",e);
          file.delete();
          continue;
        }
        if (cluster == null) {
          logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
          file.delete();
          continue;
        }
        if (!cluster.validateSetManualElasticity()) {
          logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
          file.delete();
          continue;
        }
        int nodeCount;
        try {
          nodeCount=Integer.valueOf(nodeCountStr);
        }
 catch (        NumberFormatException e) {
          logger.error(nodeCountStr + ""String_Node_Str"");
          file.delete();
          continue;
        }
        if (nodeCount < -1) {
          logger.error(""String_Node_Str"" + nodeCountStr + ""String_Node_Str"");
          file.delete();
          continue;
        }
        int computeNodeNum=cluster.retrieveComputeNodeNum();
        if (nodeCount > computeNodeNum) {
          logger.error(""String_Node_Str"" + computeNodeNum);
          file.delete();
          continue;
        }
        if (cluster.getAutomationEnable() == true && cluster.getVhmMinNum() == nodeCount && cluster.getVhmMaxNum() == nodeCount) {
          logger.info(""String_Node_Str"");
        }
 else {
          try {
            List<String> nodeGroupNames=clusterMgr.syncSetParam(clusterName,null,Integer.valueOf(nodeCount),Integer.valueOf(nodeCount),true,null);
            logger.info(nodeGroupNames + ""String_Node_Str"" + nodeCount);
          }
 catch (          BddException e) {
            logger.error(""String_Node_Str"",e);
          }
        }
        file.delete();
      }
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      logger.warn(""String_Node_Str"");
      isTerminate=true;
    }
catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
    }
 finally {
      if (currentFile != null && currentFile.exists()) {
        currentFile.delete();
      }
    }
  }
}","public void run(){
  while (!isTerminate) {
    try {
      File directory=new File(""String_Node_Str"");
      File[] files=directory.listFiles(new FilenameFilter(){
        public boolean accept(        File dir,        String name){
          if (name.startsWith(filenamePrefix))           return true;
 else           return false;
        }
      }
);
      Arrays.sort(files,new Comparator<File>(){
        public int compare(        File f1,        File f2){
          return Long.valueOf(f1.lastModified()).compareTo(f2.lastModified());
        }
      }
);
      for (      File file : files) {
        String filename=file.getName();
        logger.info(""String_Node_Str"" + filename + ""String_Node_Str"");
        String[] strs=filename.substring(filenamePrefix.length()).split(""String_Node_Str"");
        if (strs == null || strs.length != 2) {
          logger.error(""String_Node_Str"" + filename + ""String_Node_Str""+ filenamePrefix+ ""String_Node_Str"");
          continue;
        }
        String clusterName=strs[0];
        String nodeCountStr=strs[1];
        ClusterRead cluster=null;
        try {
          cluster=clusterMgr.getClusterByName(clusterName,false);
        }
 catch (        BddException e) {
          logger.error(""String_Node_Str"",e);
          continue;
        }
        if (cluster == null) {
          logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
          continue;
        }
        if (!cluster.validateSetManualElasticity()) {
          logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
          continue;
        }
        int nodeCount;
        try {
          nodeCount=Integer.valueOf(nodeCountStr);
        }
 catch (        NumberFormatException e) {
          logger.error(nodeCountStr + ""String_Node_Str"");
          continue;
        }
        if (nodeCount < -1) {
          logger.error(""String_Node_Str"" + nodeCountStr + ""String_Node_Str"");
          continue;
        }
        int computeNodeNum=cluster.retrieveComputeNodeNum();
        if (nodeCount > computeNodeNum) {
          logger.error(""String_Node_Str"" + computeNodeNum);
          continue;
        }
        try {
          List<String> nodeGroupNames=clusterMgr.syncSetParam(clusterName,null,Integer.valueOf(nodeCount),Integer.valueOf(nodeCount),true,null);
          logger.info(nodeGroupNames + ""String_Node_Str"" + nodeCount);
          file.delete();
        }
 catch (        BddException e) {
          logger.error(""String_Node_Str"",e);
        }
      }
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      logger.warn(""String_Node_Str"");
      isTerminate=true;
    }
catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
    }
  }
}"
48841,"/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
public void validateClusterCreate(List<String> failedMsgList,List<String> warningMsgList,final List<String> distroRoles){
  boolean namenodeHACheck=false;
  int masterCount=0, jobtrackerCount=0, resourcemanagerCount=0, hbasemasterCount=0, zookeeperCount=0, workerCount=0, numOfJournalNode=0;
  boolean appendWarningStr=false;
  if (warningMsgList != null && warningMsgList.isEmpty()) {
    appendWarningStr=true;
  }
  NodeGroupCreate[] nodeGroupCreates=getNodeGroups();
  AuAssert.check(nodeGroupCreates != null && nodeGroupCreates.length > 0);
  if (hasHDFSUrlConfigured() && !validateHDFSUrl()) {
    failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getExternalHDFS()).toString());
  }
  validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList);
  validateNodeGroupRoles(failedMsgList);
  validateStorageType(failedMsgList);
  validateSwapRatio(nodeGroupCreates,failedMsgList);
  for (  NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
    checkInstanceNum(nodeGroupCreate,failedMsgList);
    checkNodeGroupRoles(nodeGroupCreate,distroRoles,failedMsgList);
    List<NodeGroupRole> groupRoles=getNodeGroupRoles(nodeGroupCreate);
    if (groupRoles != null) {
      for (      NodeGroupRole role : groupRoles) {
switch (role) {
case MASTER:
          masterCount++;
        int numOfInstance=nodeGroupCreate.getInstanceNum();
      if (numOfInstance >= 0 && numOfInstance != 1) {
        if (numOfInstance != 2) {
          collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
        }
 else {
          namenodeHACheck=true;
        }
      }
    break;
case JOB_TRACKER:
  jobtrackerCount++;
if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
  failedMsgList.add(Constants.WRONG_NUM_OF_JOBTRACKER);
}
break;
case RESOURCEMANAGER:
resourcemanagerCount++;
if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
failedMsgList.add(Constants.WRONG_NUM_OF_RESOURCEMANAGER);
}
break;
case HBASE_MASTER:
hbasemasterCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
break;
case ZOOKEEPER:
zookeeperCount++;
if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_ZOOKEEPER);
}
 else if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_ZOOKEEPER);
}
break;
case JOURNAL_NODE:
numOfJournalNode+=nodeGroupCreate.getInstanceNum();
if (nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_DATANODE.toString()) || nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_CLIENT_ROLE.toString())) {
failedMsgList.add(Constants.DATA_CLIENT_NODE_JOURNALNODE_COEXIST);
}
break;
case WORKER:
workerCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
 else if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
List<String> roles=nodeGroupCreate.getRoles();
if (roles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString()) && !roles.contains(HadoopRole.HADOOP_DATANODE.toString())) {
warningMsgList.add(Constants.REGISONSERVER_DATANODE_SEPERATION);
}
break;
case CLIENT:
if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
break;
case NONE:
warningMsgList.add(Constants.NOT_DEFINED_ROLE);
break;
default :
}
}
}
}
if (!supportedWithHdfs2()) {
if (namenodeHACheck || masterCount > 1) {
failedMsgList.add(Constants.CURRENT_DISTRO_CAN_NOT_SUPPORT_HDFS2);
}
}
 else if (namenodeHACheck) {
if (numOfJournalNode >= 0 && numOfJournalNode < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_JOURNALNODE);
}
 else if (numOfJournalNode > 0 && numOfJournalNode % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_JOURNALNODE);
}
if (zookeeperCount == 0) {
failedMsgList.add(Constants.NAMENODE_AUTO_FAILOVER_ZOOKEEPER);
}
}
if ((jobtrackerCount > 1) || (resourcemanagerCount > 1) || (zookeeperCount > 1)|| (hbasemasterCount > 1)) {
failedMsgList.add(Constants.WRONG_NUM_OF_NODEGROUPS);
}
if (workerCount == 0) {
warningMsgList.add(Constants.WRONG_NUM_OF_WORKERNODES);
}
if (numOfJournalNode > 0 && !namenodeHACheck) {
failedMsgList.add(Constants.NO_NAMENODE_HA);
}
if (!warningMsgList.isEmpty() && appendWarningStr) {
warningMsgList.set(0,""String_Node_Str"" + warningMsgList.get(0));
}
}","/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
public void validateClusterCreate(List<String> failedMsgList,List<String> warningMsgList,final List<String> distroRoles){
  boolean namenodeHACheck=false;
  int masterCount=0, jobtrackerCount=0, resourcemanagerCount=0, hbasemasterCount=0, zookeeperCount=0, workerCount=0, numOfJournalNode=0;
  boolean appendWarningStr=false;
  if (warningMsgList != null && warningMsgList.isEmpty()) {
    appendWarningStr=true;
  }
  NodeGroupCreate[] nodeGroupCreates=getNodeGroups();
  AuAssert.check(nodeGroupCreates != null && nodeGroupCreates.length > 0);
  if (hasHDFSUrlConfigured() && !validateHDFSUrl()) {
    failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getExternalHDFS()).toString());
  }
  validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList);
  validateNodeGroupRoles(failedMsgList);
  validateStorageType(failedMsgList);
  validateSwapRatio(nodeGroupCreates,failedMsgList);
  for (  NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
    checkInstanceNum(nodeGroupCreate,failedMsgList);
    makeVmMemoryDivisibleBy4(nodeGroupCreate,warningMsgList);
    checkNodeGroupRoles(nodeGroupCreate,distroRoles,failedMsgList);
    List<NodeGroupRole> groupRoles=getNodeGroupRoles(nodeGroupCreate);
    if (groupRoles != null) {
      for (      NodeGroupRole role : groupRoles) {
switch (role) {
case MASTER:
          masterCount++;
        int numOfInstance=nodeGroupCreate.getInstanceNum();
      if (numOfInstance >= 0 && numOfInstance != 1) {
        if (numOfInstance != 2) {
          collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
        }
 else {
          namenodeHACheck=true;
        }
      }
    break;
case JOB_TRACKER:
  jobtrackerCount++;
if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
  failedMsgList.add(Constants.WRONG_NUM_OF_JOBTRACKER);
}
break;
case RESOURCEMANAGER:
resourcemanagerCount++;
if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
failedMsgList.add(Constants.WRONG_NUM_OF_RESOURCEMANAGER);
}
break;
case HBASE_MASTER:
hbasemasterCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
break;
case ZOOKEEPER:
zookeeperCount++;
if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_ZOOKEEPER);
}
 else if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_ZOOKEEPER);
}
break;
case JOURNAL_NODE:
numOfJournalNode+=nodeGroupCreate.getInstanceNum();
if (nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_DATANODE.toString()) || nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_CLIENT_ROLE.toString())) {
failedMsgList.add(Constants.DATA_CLIENT_NODE_JOURNALNODE_COEXIST);
}
break;
case WORKER:
workerCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
 else if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
List<String> roles=nodeGroupCreate.getRoles();
if (roles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString()) && !roles.contains(HadoopRole.HADOOP_DATANODE.toString())) {
warningMsgList.add(Constants.REGISONSERVER_DATANODE_SEPERATION);
}
break;
case CLIENT:
if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
break;
case NONE:
warningMsgList.add(Constants.NOT_DEFINED_ROLE);
break;
default :
}
}
}
}
if (!supportedWithHdfs2()) {
if (namenodeHACheck || masterCount > 1) {
failedMsgList.add(Constants.CURRENT_DISTRO_CAN_NOT_SUPPORT_HDFS2);
}
}
 else if (namenodeHACheck) {
if (numOfJournalNode >= 0 && numOfJournalNode < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_JOURNALNODE);
}
 else if (numOfJournalNode > 0 && numOfJournalNode % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_JOURNALNODE);
}
if (zookeeperCount == 0) {
failedMsgList.add(Constants.NAMENODE_AUTO_FAILOVER_ZOOKEEPER);
}
}
if ((jobtrackerCount > 1) || (resourcemanagerCount > 1) || (zookeeperCount > 1)|| (hbasemasterCount > 1)) {
failedMsgList.add(Constants.WRONG_NUM_OF_NODEGROUPS);
}
if (workerCount == 0) {
warningMsgList.add(Constants.WRONG_NUM_OF_WORKERNODES);
}
if (numOfJournalNode > 0 && !namenodeHACheck) {
failedMsgList.add(Constants.NO_NAMENODE_HA);
}
if (!warningMsgList.isEmpty() && appendWarningStr) {
warningMsgList.set(0,""String_Node_Str"" + warningMsgList.get(0));
}
}"
48842,"private void makeVmMemoryDivisibleBy4(NodeGroupCreate nodeGroup,List<String> warningMsgList){
  int memoryCap=nodeGroup.getMemCapacityMB();
  if (memoryCap > 0) {
    long converted=CommonUtil.makeVmMemoryDivisibleBy4(memoryCap);
    if (converted < memoryCap) {
      nodeGroup.setMemCapacityMB((int)converted);
      warningMsgList.add(Constants.CONVERTED_MEMORY_DIVISIBLE_BY_4 + ""String_Node_Str"" + nodeGroup.getName()+ ""String_Node_Str""+ converted+ ""String_Node_Str""+ memoryCap+ ""String_Node_Str"");
    }
  }
}","private void makeVmMemoryDivisibleBy4(NodeGroupCreate nodeGroup,List<String> warningMsgList){
  int memoryNum=nodeGroup.getMemCapacityMB();
  if (memoryNum > 0) {
    long converted=CommonUtil.makeVmMemoryDivisibleBy4(memoryNum);
    if (converted < memoryNum) {
      nodeGroup.setMemCapacityMB((int)converted);
      warningMsgList.add(Constants.CONVERTED_MEMORY_DIVISIBLE_BY_4 + ""String_Node_Str"" + nodeGroup.getName()+ ""String_Node_Str""+ converted+ ""String_Node_Str""+ memoryNum+ ""String_Node_Str"");
    }
  }
}"
48843,"@Test public void testValidateClusterCreate(){
  ClusterCreate cluster=new ClusterCreate();
  cluster.setDistroVendor(Constants.DEFAULT_VENDOR);
  Map<NetTrafficType,List<String>> networkConfig=new HashMap<NetTrafficType,List<String>>();
  List<String> mgtnets=new ArrayList<String>();
  mgtnets.add(""String_Node_Str"");
  networkConfig.put(NetTrafficType.MGT_NETWORK,mgtnets);
  List<String> hadpnets=new ArrayList<String>();
  hadpnets.add(""String_Node_Str"");
  networkConfig.put(NetTrafficType.HDFS_NETWORK,hadpnets);
  cluster.setNetworkConfig(networkConfig);
  NodeGroupCreate master=new NodeGroupCreate();
  master.setName(""String_Node_Str"");
  master.setCpuNum(2);
  master.setMemCapacityMB(7501);
  master.setSwapRatio(0F);
  master.setInstanceNum(1);
  master.setRoles(Arrays.asList(HadoopRole.HADOOP_NAMENODE_ROLE.toString(),HadoopRole.HADOOP_JOBTRACKER_ROLE.toString()));
  NodeGroupCreate worker=new NodeGroupCreate();
  worker.setName(""String_Node_Str"");
  worker.setRoles(Arrays.asList(HadoopRole.HADOOP_DATANODE.toString(),HadoopRole.HADOOP_TASKTRACKER.toString()));
  worker.setCpuNum(2);
  worker.setMemCapacityMB(3748);
  worker.setInstanceNum(0);
  NodeGroupCreate client=new NodeGroupCreate();
  client.setName(""String_Node_Str"");
  client.setCpuNum(2);
  client.setMemCapacityMB(3748);
  client.setInstanceNum(0);
  client.setRoles(Arrays.asList(HadoopRole.HADOOP_CLIENT_ROLE.toString(),HadoopRole.HIVE_SERVER_ROLE.toString(),HadoopRole.HIVE_ROLE.toString()));
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  List<String> distroRoles=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  cluster.setNodeGroups(new NodeGroupCreate[]{master,worker,client});
  cluster.validateClusterCreate(failedMsgList,warningMsgList,distroRoles);
  assertEquals(3,failedMsgList.size());
  assertEquals(""String_Node_Str"",failedMsgList.get(0));
  assertEquals(""String_Node_Str"",failedMsgList.get(1));
  assertEquals(""String_Node_Str"",failedMsgList.get(2));
  assertEquals(1,warningMsgList.size());
  assertEquals(""String_Node_Str"",warningMsgList.get(0));
}","@Test public void testValidateClusterCreate(){
  ClusterCreate cluster=new ClusterCreate();
  cluster.setDistroVendor(Constants.DEFAULT_VENDOR);
  Map<NetTrafficType,List<String>> networkConfig=new HashMap<NetTrafficType,List<String>>();
  List<String> mgtnets=new ArrayList<String>();
  mgtnets.add(""String_Node_Str"");
  networkConfig.put(NetTrafficType.MGT_NETWORK,mgtnets);
  List<String> hadpnets=new ArrayList<String>();
  hadpnets.add(""String_Node_Str"");
  networkConfig.put(NetTrafficType.HDFS_NETWORK,hadpnets);
  cluster.setNetworkConfig(networkConfig);
  NodeGroupCreate master=new NodeGroupCreate();
  master.setName(""String_Node_Str"");
  master.setMemCapacityMB(7501);
  master.setSwapRatio(0F);
  master.setInstanceNum(1);
  master.setRoles(Arrays.asList(HadoopRole.HADOOP_NAMENODE_ROLE.toString(),HadoopRole.HADOOP_JOBTRACKER_ROLE.toString()));
  NodeGroupCreate worker=new NodeGroupCreate();
  worker.setName(""String_Node_Str"");
  worker.setRoles(Arrays.asList(HadoopRole.HADOOP_DATANODE.toString(),HadoopRole.HADOOP_TASKTRACKER.toString()));
  worker.setMemCapacityMB(3748);
  worker.setInstanceNum(0);
  NodeGroupCreate client=new NodeGroupCreate();
  client.setName(""String_Node_Str"");
  client.setMemCapacityMB(3748);
  client.setInstanceNum(0);
  client.setRoles(Arrays.asList(HadoopRole.HADOOP_CLIENT_ROLE.toString(),HadoopRole.HIVE_SERVER_ROLE.toString(),HadoopRole.HIVE_ROLE.toString()));
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  List<String> distroRoles=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  cluster.setNodeGroups(new NodeGroupCreate[]{master,worker,client});
  cluster.validateClusterCreate(failedMsgList,warningMsgList,distroRoles);
  assertEquals(3,failedMsgList.size());
  assertEquals(""String_Node_Str"",failedMsgList.get(0));
  assertEquals(""String_Node_Str"",failedMsgList.get(1));
  assertEquals(""String_Node_Str"",failedMsgList.get(2));
  assertEquals(1,warningMsgList.size());
  assertEquals(""String_Node_Str"",warningMsgList.get(0));
}"
48844,"public void testClusterConfigWithGroupSlave(){
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  spec.setNetworkConfig(createNetConfigs());
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  rps.add(""String_Node_Str"");
  rps.add(""String_Node_Str"");
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  NodeGroupCreate[] nodegroups=new NodeGroupCreate[1];
  NodeGroupCreate group=new NodeGroupCreate();
  nodegroups[0]=group;
  group.setCpuNum(3);
  group.setInstanceNum(10);
  group.setCpuNum(2);
  group.setMemCapacityMB(7500);
  group.setInstanceType(InstanceType.SMALL);
  group.setHaFlag(""String_Node_Str"");
  group.setName(""String_Node_Str"");
  List<String> roles=new ArrayList<String>();
  roles.add(""String_Node_Str"");
  group.setRoles(roles);
  spec.setNodeGroups(nodegroups);
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1 && manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
}","public void testClusterConfigWithGroupSlave(){
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  spec.setNetworkConfig(createNetConfigs());
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  rps.add(""String_Node_Str"");
  rps.add(""String_Node_Str"");
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  NodeGroupCreate[] nodegroups=new NodeGroupCreate[1];
  NodeGroupCreate group=new NodeGroupCreate();
  nodegroups[0]=group;
  group.setCpuNum(3);
  group.setInstanceNum(10);
  group.setInstanceType(InstanceType.SMALL);
  group.setHaFlag(""String_Node_Str"");
  group.setName(""String_Node_Str"");
  List<String> roles=new ArrayList<String>();
  roles.add(""String_Node_Str"");
  group.setRoles(roles);
  spec.setNodeGroups(nodegroups);
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1 && manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
}"
48845,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test(groups={""String_Node_Str""}) public void testClusterAppConfig() throws Exception {
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  spec.setNetworkConfig(createNetConfigs());
  spec.setType(ClusterType.HDFS_MAPRED);
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  spec=ClusterSpecFactory.getCustomizedSpec(spec);
  for (  NodeGroupCreate nodeGroup : spec.getNodeGroups()) {
    nodeGroup.setCpuNum(2);
    nodeGroup.setMemCapacityMB(7500);
  }
  spec.setType(null);
  String configJson=""String_Node_Str"";
  Map config=(new Gson()).fromJson(configJson,Map.class);
  spec.setConfiguration((Map<String,Object>)(config.get(""String_Node_Str"")));
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findClusterById(1l);
  List<ClusterEntity> cs=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity c : cs) {
    System.out.println(c.getId());
  }
  cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test(groups={""String_Node_Str""}) public void testClusterAppConfig() throws Exception {
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  spec.setNetworkConfig(createNetConfigs());
  spec.setType(ClusterType.HDFS_MAPRED);
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  spec=ClusterSpecFactory.getCustomizedSpec(spec);
  spec.setType(null);
  String configJson=""String_Node_Str"";
  Map config=(new Gson()).fromJson(configJson,Map.class);
  spec.setConfiguration((Map<String,Object>)(config.get(""String_Node_Str"")));
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findClusterById(1l);
  List<ClusterEntity> cs=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity c : cs) {
    System.out.println(c.getId());
  }
  cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
}"
48846,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test(groups={""String_Node_Str""}) public void testClusterConfigWithExternalHDFSFailure() throws Exception {
  String[] hdfsArray=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  spec.setNetworkConfig(createNetConfigs());
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  String clusterConfigJson=""String_Node_Str"" + hdfsArray[1] + ""String_Node_Str"";
  Map clusterConfig=(new Gson()).fromJson(clusterConfigJson,Map.class);
  spec.setConfiguration((Map<String,Object>)(clusterConfig.get(""String_Node_Str"")));
  NodeGroupCreate ng0=new NodeGroupCreate();
  List<String> masterRole=new ArrayList<String>();
  masterRole.add(""String_Node_Str"");
  masterRole.add(""String_Node_Str"");
  ng0.setRoles(masterRole);
  ng0.setName(""String_Node_Str"");
  ng0.setInstanceNum(1);
  ng0.setCpuNum(2);
  ng0.setMemCapacityMB(7500);
  ng0.setInstanceType(InstanceType.LARGE);
  String ng0ConfigJson=""String_Node_Str"" + hdfsArray[2] + ""String_Node_Str"";
  Map ng0Config=(new Gson()).fromJson(ng0ConfigJson,Map.class);
  ng0.setConfiguration((Map<String,Object>)(ng0Config.get(""String_Node_Str"")));
  NodeGroupCreate ng1=new NodeGroupCreate();
  List<String> computeRoles=new ArrayList<String>();
  computeRoles.add(""String_Node_Str"");
  ng1.setRoles(computeRoles);
  ng1.setName(""String_Node_Str"");
  ng1.setInstanceNum(4);
  ng1.setCpuNum(2);
  ng1.setMemCapacityMB(7500);
  ng1.setInstanceType(InstanceType.MEDIUM);
  StorageRead storage=new StorageRead();
  storage.setType(""String_Node_Str"");
  storage.setSizeGB(10);
  ng1.setStorage(storage);
  String ng1ConfigJson=""String_Node_Str"" + hdfsArray[3] + ""String_Node_Str"";
  Map ng1Config=(new Gson()).fromJson(ng1ConfigJson,Map.class);
  ng1.setConfiguration((Map<String,Object>)(ng1Config.get(""String_Node_Str"")));
  NodeGroupCreate ng2=new NodeGroupCreate();
  List<String> dataRoles=new ArrayList<String>();
  dataRoles.add(""String_Node_Str"");
  ng2.setRoles(dataRoles);
  ng2.setName(""String_Node_Str"");
  ng2.setInstanceNum(2);
  ng2.setCpuNum(2);
  ng2.setMemCapacityMB(7500);
  ng2.setInstanceType(InstanceType.MEDIUM);
  StorageRead storageCompute=new StorageRead();
  storageCompute.setType(""String_Node_Str"");
  storageCompute.setSizeGB(10);
  ng2.setStorage(storageCompute);
  NodeGroupCreate[] ngs=new NodeGroupCreate[]{ng0,ng1,ng2};
  spec.setNodeGroups(ngs);
  spec=ClusterSpecFactory.getCustomizedSpec(spec);
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findClusterById(1l);
  List<ClusterEntity> cs=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity c : cs) {
    System.out.println(c.getId());
  }
  cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(Pattern.compile(""String_Node_Str"" + hdfsArray[0] + ""String_Node_Str"").matcher(manifest).matches() == false,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[1]) != -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[2]) != -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[3]) != -1,""String_Node_Str"");
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test(groups={""String_Node_Str""}) public void testClusterConfigWithExternalHDFSFailure() throws Exception {
  String[] hdfsArray=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  spec.setNetworkConfig(createNetConfigs());
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  String clusterConfigJson=""String_Node_Str"" + hdfsArray[1] + ""String_Node_Str"";
  Map clusterConfig=(new Gson()).fromJson(clusterConfigJson,Map.class);
  spec.setConfiguration((Map<String,Object>)(clusterConfig.get(""String_Node_Str"")));
  NodeGroupCreate ng0=new NodeGroupCreate();
  List<String> masterRole=new ArrayList<String>();
  masterRole.add(""String_Node_Str"");
  masterRole.add(""String_Node_Str"");
  ng0.setRoles(masterRole);
  ng0.setName(""String_Node_Str"");
  ng0.setInstanceNum(1);
  ng0.setInstanceType(InstanceType.LARGE);
  String ng0ConfigJson=""String_Node_Str"" + hdfsArray[2] + ""String_Node_Str"";
  Map ng0Config=(new Gson()).fromJson(ng0ConfigJson,Map.class);
  ng0.setConfiguration((Map<String,Object>)(ng0Config.get(""String_Node_Str"")));
  NodeGroupCreate ng1=new NodeGroupCreate();
  List<String> computeRoles=new ArrayList<String>();
  computeRoles.add(""String_Node_Str"");
  ng1.setRoles(computeRoles);
  ng1.setName(""String_Node_Str"");
  ng1.setInstanceNum(4);
  ng1.setCpuNum(2);
  ng1.setMemCapacityMB(7500);
  ng1.setInstanceType(InstanceType.MEDIUM);
  StorageRead storage=new StorageRead();
  storage.setType(""String_Node_Str"");
  storage.setSizeGB(10);
  ng1.setStorage(storage);
  String ng1ConfigJson=""String_Node_Str"" + hdfsArray[3] + ""String_Node_Str"";
  Map ng1Config=(new Gson()).fromJson(ng1ConfigJson,Map.class);
  ng1.setConfiguration((Map<String,Object>)(ng1Config.get(""String_Node_Str"")));
  NodeGroupCreate ng2=new NodeGroupCreate();
  List<String> dataRoles=new ArrayList<String>();
  dataRoles.add(""String_Node_Str"");
  ng2.setRoles(dataRoles);
  ng2.setName(""String_Node_Str"");
  ng2.setInstanceNum(2);
  ng2.setInstanceType(InstanceType.MEDIUM);
  StorageRead storageCompute=new StorageRead();
  storageCompute.setType(""String_Node_Str"");
  storageCompute.setSizeGB(10);
  ng2.setStorage(storageCompute);
  NodeGroupCreate[] ngs=new NodeGroupCreate[]{ng0,ng1,ng2};
  spec.setNodeGroups(ngs);
  spec=ClusterSpecFactory.getCustomizedSpec(spec);
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findClusterById(1l);
  List<ClusterEntity> cs=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity c : cs) {
    System.out.println(c.getId());
  }
  cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(Pattern.compile(""String_Node_Str"" + hdfsArray[0] + ""String_Node_Str"").matcher(manifest).matches() == false,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[1]) != -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[2]) != -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[3]) != -1,""String_Node_Str"");
}"
48847,"@Test(groups={""String_Node_Str""}) public void testClusterConfigWithClusterStorage() throws Exception {
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  spec.setNetworkConfig(createNetConfigs());
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  List<String> dsNames=new ArrayList<String>();
  dsNames.add(""String_Node_Str"");
  dsNames.add(""String_Node_Str"");
  spec.setDsNames(dsNames);
  spec.setType(ClusterType.HDFS_MAPRED);
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  spec=ClusterSpecFactory.getCustomizedSpec(spec);
  for (  NodeGroupCreate nodeGroup : spec.getNodeGroups()) {
    nodeGroup.setCpuNum(2);
    nodeGroup.setMemCapacityMB(7500);
  }
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findClusterById(1l);
  List<ClusterEntity> cs=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity c : cs) {
    System.out.println(c.getId());
  }
  cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
}","@Test(groups={""String_Node_Str""}) public void testClusterConfigWithClusterStorage() throws Exception {
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  spec.setNetworkConfig(createNetConfigs());
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  List<String> dsNames=new ArrayList<String>();
  dsNames.add(""String_Node_Str"");
  dsNames.add(""String_Node_Str"");
  spec.setDsNames(dsNames);
  spec.setType(ClusterType.HDFS_MAPRED);
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  spec=ClusterSpecFactory.getCustomizedSpec(spec);
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findClusterById(1l);
  List<ClusterEntity> cs=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity c : cs) {
    System.out.println(c.getId());
  }
  cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
}"
48848,"@Test(groups={""String_Node_Str""}) public void testClusterConfig() throws Exception {
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  spec.setNetworkConfig(createNetConfigs());
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  spec.setType(ClusterType.HDFS_MAPRED);
  spec=ClusterSpecFactory.getCustomizedSpec(spec);
  for (  NodeGroupCreate nodeGroup : spec.getNodeGroups()) {
    nodeGroup.setCpuNum(2);
    nodeGroup.setMemCapacityMB(7500);
  }
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findClusterById(1l);
  List<ClusterEntity> cs=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity c : cs) {
    System.out.println(c.getId());
  }
  cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
}","@Test(groups={""String_Node_Str""}) public void testClusterConfig() throws Exception {
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  spec.setNetworkConfig(createNetConfigs());
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  spec.setType(ClusterType.HDFS_MAPRED);
  spec=ClusterSpecFactory.getCustomizedSpec(spec);
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findClusterById(1l);
  List<ClusterEntity> cs=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity c : cs) {
    System.out.println(c.getId());
  }
  cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
}"
48849,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test(groups={""String_Node_Str""}) public void testClusterConfigWithExternalHDFS() throws Exception {
  String[] hdfsArray=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  spec.setNetworkConfig(createNetConfigs());
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  spec.setExternalHDFS(hdfsArray[0]);
  String clusterConfigJson=""String_Node_Str"" + hdfsArray[1] + ""String_Node_Str"";
  Map clusterConfig=(new Gson()).fromJson(clusterConfigJson,Map.class);
  spec.setConfiguration((Map<String,Object>)(clusterConfig.get(""String_Node_Str"")));
  NodeGroupCreate ng0=new NodeGroupCreate();
  List<String> jobtrackerRole=new ArrayList<String>();
  jobtrackerRole.add(""String_Node_Str"");
  ng0.setRoles(jobtrackerRole);
  ng0.setName(""String_Node_Str"");
  ng0.setInstanceNum(1);
  ng0.setCpuNum(2);
  ng0.setMemCapacityMB(7500);
  ng0.setInstanceType(InstanceType.LARGE);
  String ng0ConfigJson=""String_Node_Str"" + hdfsArray[2] + ""String_Node_Str"";
  Map ng0Config=(new Gson()).fromJson(ng0ConfigJson,Map.class);
  ng0.setConfiguration((Map<String,Object>)(ng0Config.get(""String_Node_Str"")));
  NodeGroupCreate ng1=new NodeGroupCreate();
  List<String> computeRoles=new ArrayList<String>();
  computeRoles.add(""String_Node_Str"");
  ng1.setRoles(computeRoles);
  ng1.setName(""String_Node_Str"");
  ng1.setInstanceNum(4);
  ng1.setCpuNum(2);
  ng1.setMemCapacityMB(7500);
  ng1.setInstanceType(InstanceType.MEDIUM);
  StorageRead storage=new StorageRead();
  storage.setType(""String_Node_Str"");
  storage.setSizeGB(10);
  ng1.setStorage(storage);
  String ng1ConfigJson=""String_Node_Str"" + hdfsArray[3] + ""String_Node_Str"";
  Map ng1Config=(new Gson()).fromJson(ng1ConfigJson,Map.class);
  ng1.setConfiguration((Map<String,Object>)(ng1Config.get(""String_Node_Str"")));
  NodeGroupCreate ng2=new NodeGroupCreate();
  ng2.setRoles(computeRoles);
  ng2.setName(""String_Node_Str"");
  ng2.setInstanceNum(2);
  ng2.setCpuNum(2);
  ng2.setMemCapacityMB(7500);
  ng2.setInstanceType(InstanceType.MEDIUM);
  StorageRead storageCompute=new StorageRead();
  storageCompute.setType(""String_Node_Str"");
  storageCompute.setSizeGB(10);
  ng2.setStorage(storageCompute);
  NodeGroupCreate[] ngs=new NodeGroupCreate[]{ng0,ng1,ng2};
  spec.setNodeGroups(ngs);
  spec=ClusterSpecFactory.getCustomizedSpec(spec);
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findClusterById(1l);
  List<ClusterEntity> cs=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity c : cs) {
    System.out.println(c.getId());
  }
  cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(Pattern.compile(""String_Node_Str"" + hdfsArray[0] + ""String_Node_Str"").matcher(manifest).matches(),""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[1]) == -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[2]) == -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[3]) == -1,""String_Node_Str"");
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test(groups={""String_Node_Str""}) public void testClusterConfigWithExternalHDFS() throws Exception {
  String[] hdfsArray=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  spec.setNetworkConfig(createNetConfigs());
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  spec.setExternalHDFS(hdfsArray[0]);
  String clusterConfigJson=""String_Node_Str"" + hdfsArray[1] + ""String_Node_Str"";
  Map clusterConfig=(new Gson()).fromJson(clusterConfigJson,Map.class);
  spec.setConfiguration((Map<String,Object>)(clusterConfig.get(""String_Node_Str"")));
  NodeGroupCreate ng0=new NodeGroupCreate();
  List<String> jobtrackerRole=new ArrayList<String>();
  jobtrackerRole.add(""String_Node_Str"");
  ng0.setRoles(jobtrackerRole);
  ng0.setName(""String_Node_Str"");
  ng0.setInstanceNum(1);
  ng0.setInstanceType(InstanceType.LARGE);
  String ng0ConfigJson=""String_Node_Str"" + hdfsArray[2] + ""String_Node_Str"";
  Map ng0Config=(new Gson()).fromJson(ng0ConfigJson,Map.class);
  ng0.setConfiguration((Map<String,Object>)(ng0Config.get(""String_Node_Str"")));
  NodeGroupCreate ng1=new NodeGroupCreate();
  List<String> computeRoles=new ArrayList<String>();
  computeRoles.add(""String_Node_Str"");
  ng1.setRoles(computeRoles);
  ng1.setName(""String_Node_Str"");
  ng1.setInstanceNum(4);
  ng1.setInstanceType(InstanceType.MEDIUM);
  StorageRead storage=new StorageRead();
  storage.setType(""String_Node_Str"");
  storage.setSizeGB(10);
  ng1.setStorage(storage);
  String ng1ConfigJson=""String_Node_Str"" + hdfsArray[3] + ""String_Node_Str"";
  Map ng1Config=(new Gson()).fromJson(ng1ConfigJson,Map.class);
  ng1.setConfiguration((Map<String,Object>)(ng1Config.get(""String_Node_Str"")));
  NodeGroupCreate ng2=new NodeGroupCreate();
  ng2.setRoles(computeRoles);
  ng2.setName(""String_Node_Str"");
  ng2.setInstanceNum(2);
  ng2.setInstanceType(InstanceType.MEDIUM);
  StorageRead storageCompute=new StorageRead();
  storageCompute.setType(""String_Node_Str"");
  storageCompute.setSizeGB(10);
  ng2.setStorage(storageCompute);
  NodeGroupCreate[] ngs=new NodeGroupCreate[]{ng0,ng1,ng2};
  spec.setNodeGroups(ngs);
  spec=ClusterSpecFactory.getCustomizedSpec(spec);
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findClusterById(1l);
  List<ClusterEntity> cs=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity c : cs) {
    System.out.println(c.getId());
  }
  cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(Pattern.compile(""String_Node_Str"" + hdfsArray[0] + ""String_Node_Str"").matcher(manifest).matches(),""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[1]) == -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[2]) == -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[3]) == -1,""String_Node_Str"");
}"
48850,"@Test(groups={""String_Node_Str""}) public void testClusterConfigWithTempfs() throws Exception {
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  spec.setNetworkConfig(createNetConfigs());
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  NodeGroupCreate[] ngs=new NodeGroupCreate[3];
  NodeGroupCreate ng0=new NodeGroupCreate();
  ngs[0]=ng0;
  List<String> masterRoles=new ArrayList<String>();
  masterRoles.add(""String_Node_Str"");
  masterRoles.add(""String_Node_Str"");
  ngs[0].setRoles(masterRoles);
  ngs[0].setName(""String_Node_Str"");
  ngs[0].setInstanceNum(1);
  ngs[0].setCpuNum(2);
  ngs[0].setMemCapacityMB(7500);
  ngs[0].setInstanceType(InstanceType.LARGE);
  NodeGroupCreate ng1=new NodeGroupCreate();
  ngs[1]=ng1;
  List<String> dataNodeRoles=new ArrayList<String>();
  dataNodeRoles.add(""String_Node_Str"");
  ngs[1].setRoles(dataNodeRoles);
  ngs[1].setName(""String_Node_Str"");
  ngs[1].setInstanceNum(4);
  ngs[1].setCpuNum(2);
  ngs[1].setMemCapacityMB(7500);
  ngs[1].setInstanceType(InstanceType.MEDIUM);
  StorageRead storage=new StorageRead();
  storage.setType(""String_Node_Str"");
  storage.setSizeGB(50);
  ngs[1].setStorage(storage);
  NodeGroupCreate ng2=new NodeGroupCreate();
  ngs[2]=ng2;
  List<String> computeNodeRoles=new ArrayList<String>();
  computeNodeRoles.add(""String_Node_Str"");
  ngs[2].setRoles(computeNodeRoles);
  ngs[2].setName(""String_Node_Str"");
  ngs[2].setInstanceNum(8);
  ngs[2].setCpuNum(2);
  ngs[2].setMemCapacityMB(7500);
  ngs[2].setInstanceType(InstanceType.MEDIUM);
  StorageRead storageCompute=new StorageRead();
  storageCompute.setType(""String_Node_Str"");
  storageCompute.setSizeGB(50);
  ngs[2].setStorage(storageCompute);
  PlacementPolicy policy=new PlacementPolicy();
  policy.setInstancePerHost(2);
  List<GroupAssociation> associates=new ArrayList<GroupAssociation>();
  GroupAssociation associate=new GroupAssociation();
  associate.setReference(""String_Node_Str"");
  associate.setType(GroupAssociationType.STRICT);
  associates.add(associate);
  policy.setGroupAssociations(associates);
  ngs[2].setPlacementPolicies(policy);
  spec.setNodeGroups(ngs);
  spec=ClusterSpecFactory.getCustomizedSpec(spec);
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findClusterById(1l);
  List<ClusterEntity> cs=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity c : cs) {
    System.out.println(c.getId());
  }
  cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
}","@Test(groups={""String_Node_Str""}) public void testClusterConfigWithTempfs() throws Exception {
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  spec.setNetworkConfig(createNetConfigs());
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  NodeGroupCreate[] ngs=new NodeGroupCreate[3];
  NodeGroupCreate ng0=new NodeGroupCreate();
  ngs[0]=ng0;
  List<String> masterRoles=new ArrayList<String>();
  masterRoles.add(""String_Node_Str"");
  masterRoles.add(""String_Node_Str"");
  ngs[0].setRoles(masterRoles);
  ngs[0].setName(""String_Node_Str"");
  ngs[0].setInstanceNum(1);
  ngs[0].setInstanceType(InstanceType.LARGE);
  NodeGroupCreate ng1=new NodeGroupCreate();
  ngs[1]=ng1;
  List<String> dataNodeRoles=new ArrayList<String>();
  dataNodeRoles.add(""String_Node_Str"");
  ngs[1].setRoles(dataNodeRoles);
  ngs[1].setName(""String_Node_Str"");
  ngs[1].setInstanceNum(4);
  ngs[1].setInstanceType(InstanceType.MEDIUM);
  StorageRead storage=new StorageRead();
  storage.setType(""String_Node_Str"");
  storage.setSizeGB(50);
  ngs[1].setStorage(storage);
  NodeGroupCreate ng2=new NodeGroupCreate();
  ngs[2]=ng2;
  List<String> computeNodeRoles=new ArrayList<String>();
  computeNodeRoles.add(""String_Node_Str"");
  ngs[2].setRoles(computeNodeRoles);
  ngs[2].setName(""String_Node_Str"");
  ngs[2].setInstanceNum(8);
  ngs[2].setInstanceType(InstanceType.MEDIUM);
  StorageRead storageCompute=new StorageRead();
  storageCompute.setType(""String_Node_Str"");
  storageCompute.setSizeGB(50);
  ngs[2].setStorage(storageCompute);
  PlacementPolicy policy=new PlacementPolicy();
  policy.setInstancePerHost(2);
  List<GroupAssociation> associates=new ArrayList<GroupAssociation>();
  GroupAssociation associate=new GroupAssociation();
  associate.setReference(""String_Node_Str"");
  associate.setType(GroupAssociationType.STRICT);
  associates.add(associate);
  policy.setGroupAssociations(associates);
  ngs[2].setPlacementPolicies(policy);
  spec.setNodeGroups(ngs);
  spec=ClusterSpecFactory.getCustomizedSpec(spec);
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findClusterById(1l);
  List<ClusterEntity> cs=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity c : cs) {
    System.out.println(c.getId());
  }
  cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
}"
48851,"private CreateVmSP getReplacementVmSp(ClusterCreate clusterSpec,String groupName,NodeEntity node,List<DiskSpec> fullDiskSet){
  VmSchema createSchema=VcVmUtil.getVmSchema(clusterSpec,groupName,fullDiskSet,clusteringService.getTemplateVmId(),Constants.ROOT_SNAPSTHOT_NAME);
  List<NetworkAdd> networkAdds=clusterSpec.getNetworkings();
  GuestMachineIdSpec machineIdSpec=new GuestMachineIdSpec(networkAdds,node.fetchPortGroupToIpMap(),node.getGuestHostName());
  logger.info(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ machineIdSpec.toString());
  Map<String,String> guestVariable=machineIdSpec.toGuestVarialbe();
  VcVmUtil.addBootupUUID(guestVariable);
  String haFlag=clusterSpec.getNodeGroup(groupName).getHaFlag();
  boolean ha=false;
  boolean ft=false;
  if (haFlag != null && Constants.HA_FLAG_ON.equals(haFlag.toLowerCase())) {
    ha=true;
  }
  if (haFlag != null && Constants.HA_FLAG_FT.equals(haFlag.toLowerCase())) {
    ha=true;
    ft=true;
  }
  ReplaceVmPrePowerOn prePowerOn=new ReplaceVmPrePowerOn(node.getMoId(),node.getVmName(),clusterSpec.getNodeGroup(groupName).getStorage().getShares(),createSchema.networkSchema,ha,ft);
  return new CreateVmSP(node.getVmName() + RECOVERY_VM_NAME_POSTFIX,createSchema,VcVmUtil.getTargetRp(clusterSpec.getName(),groupName,node),getTargetDatastore(fullDiskSet),prePowerOn,null,guestVariable,false,getTargetFolder(node,clusterSpec.getNodeGroup(groupName)),getTargetHost(node));
}","private CreateVmSP getReplacementVmSp(ClusterCreate clusterSpec,String groupName,NodeEntity node,List<DiskSpec> fullDiskSet){
  VmSchema createSchema=VcVmUtil.getVmSchema(clusterSpec,groupName,fullDiskSet,clusteringService.getTemplateVmId(),Constants.ROOT_SNAPSTHOT_NAME);
  List<NetworkAdd> networkAdds=clusterSpec.getNetworkings();
  GuestMachineIdSpec machineIdSpec=new GuestMachineIdSpec(networkAdds,node.fetchPortGroupToIpMap(),node.getIpConfigsInfo().get(NetConfigInfo.NetTrafficType.MGT_NETWORK).get(0).getPortGroupName());
  logger.info(""String_Node_Str"" + node.getVmName() + ""String_Node_Str""+ machineIdSpec.toString());
  Map<String,String> guestVariable=machineIdSpec.toGuestVarialbe();
  VcVmUtil.addBootupUUID(guestVariable);
  String haFlag=clusterSpec.getNodeGroup(groupName).getHaFlag();
  boolean ha=false;
  boolean ft=false;
  if (haFlag != null && Constants.HA_FLAG_ON.equals(haFlag.toLowerCase())) {
    ha=true;
  }
  if (haFlag != null && Constants.HA_FLAG_FT.equals(haFlag.toLowerCase())) {
    ha=true;
    ft=true;
  }
  ReplaceVmPrePowerOn prePowerOn=new ReplaceVmPrePowerOn(node.getMoId(),node.getVmName(),clusterSpec.getNodeGroup(groupName).getStorage().getShares(),createSchema.networkSchema,ha,ft);
  return new CreateVmSP(node.getVmName() + RECOVERY_VM_NAME_POSTFIX,createSchema,VcVmUtil.getTargetRp(clusterSpec.getName(),groupName,node),getTargetDatastore(fullDiskSet),prePowerOn,null,guestVariable,false,getTargetFolder(node,clusterSpec.getNodeGroup(groupName)),getTargetHost(node));
}"
48852,"@SuppressWarnings(""String_Node_Str"") @Override public boolean createVcVms(List<NetworkAdd> networkAdds,List<BaseNode> vNodes,Map<String,Set<String>> occupiedIpSets,StatusUpdater statusUpdator){
  if (vNodes.isEmpty()) {
    logger.info(""String_Node_Str"");
    return true;
  }
  updateNicLabels(vNodes);
  allocateStaticIp(vNodes,networkAdds,occupiedIpSets);
  Map<String,Folder> folders=createVcFolders(vNodes.get(0).getCluster());
  String clusterRpName=createVcResourcePools(vNodes);
  logger.info(""String_Node_Str"");
  VcVmUtil.updateVm(templateVm.getId());
  VmCreateSpec sourceSpec=new VmCreateSpec();
  sourceSpec.setVmId(templateVm.getId());
  sourceSpec.setVmName(templateVm.getName());
  sourceSpec.setTargetHost(templateVm.getHost());
  List<VmCreateSpec> specs=new ArrayList<VmCreateSpec>();
  Map<String,BaseNode> nodeMap=new HashMap<String,BaseNode>();
  for (  BaseNode vNode : vNodes) {
    nodeMap.put(vNode.getVmName(),vNode);
    vNode.setSuccess(false);
    vNode.setFinished(true);
    VmCreateSpec spec=new VmCreateSpec();
    VmSchema createSchema=getVmSchema(vNode);
    spec.setSchema(createSchema);
    GuestMachineIdSpec machineIdSpec=new GuestMachineIdSpec(networkAdds,vNode.fetchPortGroupToIpMap(),vNode.getIpConfigs().get(NetConfigInfo.NetTrafficType.MGT_NETWORK).get(0).getPortGroupName());
    logger.info(""String_Node_Str"" + vNode.getVmName() + ""String_Node_Str""+ machineIdSpec.toString());
    spec.setBootupConfigs(machineIdSpec.toGuestVarialbe());
    QueryIpAddress query=new QueryIpAddress(vNode.fetchAllPortGroups(),Constants.VM_POWER_ON_WAITING_SEC);
    spec.setPostPowerOn(query);
    spec.setPrePowerOn(getPrePowerOnFunc(vNode));
    spec.setLinkedClone(false);
    spec.setTargetDs(getVcDatastore(vNode));
    spec.setTargetFolder(folders.get(vNode.getGroupName()));
    spec.setTargetHost(VcResourceUtils.findHost(vNode.getTargetHost()));
    spec.setTargetRp(getVcResourcePool(vNode,clusterRpName));
    spec.setVmName(vNode.getVmName());
    specs.add(spec);
  }
  try {
    UpdateVmProgressCallback callback=new UpdateVmProgressCallback(clusterEntityMgr,statusUpdator,vNodes.get(0).getClusterName());
    logger.info(""String_Node_Str"");
    AuAssert.check(specs.size() > 0);
    VmSchema vmSchema=specs.get(0).getSchema();
    VcVmUtil.checkAndCreateSnapshot(vmSchema);
    List<VmCreateSpec> results=cloneService.createCopies(sourceSpec,cloneConcurrency,specs,callback);
    logger.info(results.size() + ""String_Node_Str"");
    boolean success=(specs.size() == results.size());
    for (    VmCreateSpec spec : results) {
      BaseNode node=nodeMap.get(spec.getVmName());
      node.setVmMobId(spec.getVmId());
      VcVirtualMachine vm=VcCache.getIgnoreMissing(spec.getVmId());
      if (vm != null) {
        boolean vmSucc=VcVmUtil.setBaseNodeForVm(node,vm);
        if (!vmSucc) {
          success=false;
        }
      }
      node.setSuccess(success);
    }
    return success;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public boolean createVcVms(List<NetworkAdd> networkAdds,List<BaseNode> vNodes,Map<String,Set<String>> occupiedIpSets,StatusUpdater statusUpdator){
  if (vNodes.isEmpty()) {
    logger.info(""String_Node_Str"");
    return true;
  }
  updateNicLabels(vNodes);
  allocateStaticIp(vNodes,networkAdds,occupiedIpSets);
  Map<String,Folder> folders=createVcFolders(vNodes.get(0).getCluster());
  String clusterRpName=createVcResourcePools(vNodes);
  logger.info(""String_Node_Str"");
  VcVmUtil.updateVm(templateVm.getId());
  VmCreateSpec sourceSpec=new VmCreateSpec();
  sourceSpec.setVmId(templateVm.getId());
  sourceSpec.setVmName(templateVm.getName());
  sourceSpec.setTargetHost(templateVm.getHost());
  List<VmCreateSpec> specs=new ArrayList<VmCreateSpec>();
  Map<String,BaseNode> nodeMap=new HashMap<String,BaseNode>();
  for (  BaseNode vNode : vNodes) {
    nodeMap.put(vNode.getVmName(),vNode);
    vNode.setSuccess(false);
    vNode.setFinished(true);
    VmCreateSpec spec=new VmCreateSpec();
    VmSchema createSchema=getVmSchema(vNode);
    spec.setSchema(createSchema);
    String defaultPgName=null;
    if (vNode.getIpConfigs() != null && vNode.getIpConfigs().containsKey(NetConfigInfo.NetTrafficType.MGT_NETWORK) && !vNode.getIpConfigs().get(NetConfigInfo.NetTrafficType.MGT_NETWORK).isEmpty()) {
      defaultPgName=vNode.getIpConfigs().get(NetConfigInfo.NetTrafficType.MGT_NETWORK).get(0).getPortGroupName();
    }
    GuestMachineIdSpec machineIdSpec=new GuestMachineIdSpec(networkAdds,vNode.fetchPortGroupToIpMap(),defaultPgName);
    logger.info(""String_Node_Str"" + vNode.getVmName() + ""String_Node_Str""+ machineIdSpec.toString());
    spec.setBootupConfigs(machineIdSpec.toGuestVarialbe());
    QueryIpAddress query=new QueryIpAddress(vNode.fetchAllPortGroups(),Constants.VM_POWER_ON_WAITING_SEC);
    spec.setPostPowerOn(query);
    spec.setPrePowerOn(getPrePowerOnFunc(vNode));
    spec.setLinkedClone(false);
    spec.setTargetDs(getVcDatastore(vNode));
    spec.setTargetFolder(folders.get(vNode.getGroupName()));
    spec.setTargetHost(VcResourceUtils.findHost(vNode.getTargetHost()));
    spec.setTargetRp(getVcResourcePool(vNode,clusterRpName));
    spec.setVmName(vNode.getVmName());
    specs.add(spec);
  }
  try {
    UpdateVmProgressCallback callback=new UpdateVmProgressCallback(clusterEntityMgr,statusUpdator,vNodes.get(0).getClusterName());
    logger.info(""String_Node_Str"");
    AuAssert.check(specs.size() > 0);
    VmSchema vmSchema=specs.get(0).getSchema();
    VcVmUtil.checkAndCreateSnapshot(vmSchema);
    List<VmCreateSpec> results=cloneService.createCopies(sourceSpec,cloneConcurrency,specs,callback);
    logger.info(results.size() + ""String_Node_Str"");
    boolean success=(specs.size() == results.size());
    for (    VmCreateSpec spec : results) {
      BaseNode node=nodeMap.get(spec.getVmName());
      node.setVmMobId(spec.getVmId());
      VcVirtualMachine vm=VcCache.getIgnoreMissing(spec.getVmId());
      if (vm != null) {
        boolean vmSucc=VcVmUtil.setBaseNodeForVm(node,vm);
        if (!vmSucc) {
          success=false;
        }
      }
      node.setSuccess(success);
    }
    return success;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}"
48853,"public Map<String,String> toGuestVarialbe(){
  Map<String,String> guestVarialbe=new HashMap<String,String>();
  Gson gson=new Gson();
  guestVarialbe.put(Constants.GUEST_VARIABLE_NIC_DEVICES,gson.toJson(nics));
  NicDeviceConfigSpec defaultNic=null;
  for (  NicDeviceConfigSpec nic : nics) {
    if (nic.getPortGroupName().equals(defaultPg)) {
      defaultNic=nic;
      break;
    }
  }
  AuAssert.check(defaultNic != null);
  guestVarialbe.put(Constants.GUEST_VARIABLE_POLICY_KEY,defaultNic.getBootProto());
  guestVarialbe.put(Constants.GUEST_VARIABLE_PORT_GROUP,defaultNic.getPortGroupName());
  guestVarialbe.put(Constants.GUEST_VARIABLE_IP_KEY,defaultNic.getIpAddress());
  guestVarialbe.put(Constants.GUEST_VARIABLE_GATEWAY_KEY,defaultNic.getGateway());
  guestVarialbe.put(Constants.GUEST_VARIABLE_NETMASK_KEY,defaultNic.getNetmask());
  guestVarialbe.put(Constants.GUEST_VARIABLE_DNS_KEY_0,defaultNic.getDnsServer0());
  guestVarialbe.put(Constants.GUEST_VARIABLE_DNS_KEY_1,defaultNic.getDnsServer1());
  return guestVarialbe;
}","public Map<String,String> toGuestVarialbe(){
  Map<String,String> guestVarialbe=new HashMap<String,String>();
  Gson gson=new Gson();
  guestVarialbe.put(Constants.GUEST_VARIABLE_NIC_DEVICES,gson.toJson(nics));
  NicDeviceConfigSpec defaultNic=null;
  if (defaultPg == null) {
    defaultNic=nics[0];
  }
 else {
    for (    NicDeviceConfigSpec nic : nics) {
      if (nic.getPortGroupName().equals(defaultPg)) {
        defaultNic=nic;
        break;
      }
    }
  }
  AuAssert.check(defaultNic != null);
  guestVarialbe.put(Constants.GUEST_VARIABLE_POLICY_KEY,defaultNic.getBootProto());
  guestVarialbe.put(Constants.GUEST_VARIABLE_PORT_GROUP,defaultNic.getPortGroupName());
  guestVarialbe.put(Constants.GUEST_VARIABLE_IP_KEY,defaultNic.getIpAddress());
  guestVarialbe.put(Constants.GUEST_VARIABLE_GATEWAY_KEY,defaultNic.getGateway());
  guestVarialbe.put(Constants.GUEST_VARIABLE_NETMASK_KEY,defaultNic.getNetmask());
  guestVarialbe.put(Constants.GUEST_VARIABLE_DNS_KEY_0,defaultNic.getDnsServer0());
  guestVarialbe.put(Constants.GUEST_VARIABLE_DNS_KEY_1,defaultNic.getDnsServer1());
  return guestVarialbe;
}"
48854,"public void run(){
  File currentFile=null;
  while (!isTerminate) {
    try {
      File directory=new File(""String_Node_Str"");
      File[] files=directory.listFiles(new FilenameFilter(){
        public boolean accept(        File dir,        String name){
          if (name.startsWith(filenamePrefix))           return true;
 else           return false;
        }
      }
);
      Arrays.sort(files,new Comparator<File>(){
        public int compare(        File f1,        File f2){
          return Long.valueOf(f1.lastModified()).compareTo(f2.lastModified());
        }
      }
);
      for (      File file : files) {
        currentFile=file;
        String filename=file.getName();
        logger.info(""String_Node_Str"" + filename + ""String_Node_Str"");
        String[] strs=filename.substring(filenamePrefix.length()).split(""String_Node_Str"");
        if (strs == null || strs.length != 2) {
          logger.error(""String_Node_Str"" + filename + ""String_Node_Str""+ filenamePrefix+ ""String_Node_Str"");
          file.delete();
          continue;
        }
        String clusterName=strs[0];
        String nodeCountStr=strs[1];
        ClusterRead cluster=null;
        try {
          cluster=clusterMgr.getClusterByName(clusterName,true);
        }
 catch (        BddException e) {
          logger.error(""String_Node_Str"",e);
          file.delete();
          continue;
        }
        if (cluster == null) {
          logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
          file.delete();
          continue;
        }
        if (!cluster.validateSetManualElasticity()) {
          logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
          file.delete();
          continue;
        }
        int nodeCount;
        try {
          nodeCount=Integer.valueOf(nodeCountStr);
        }
 catch (        NumberFormatException e) {
          logger.error(nodeCountStr + ""String_Node_Str"");
          file.delete();
          continue;
        }
        if (nodeCount < -1) {
          logger.error(""String_Node_Str"" + nodeCountStr + ""String_Node_Str"");
          file.delete();
          continue;
        }
        int computeNodeNum=cluster.retrieveComputeNodeNum();
        if (nodeCount > computeNodeNum) {
          logger.error(""String_Node_Str"" + computeNodeNum);
          file.delete();
          continue;
        }
        if (cluster.getAutomationEnable() == true && cluster.getVhmMinNum() == nodeCount && cluster.getVhmMaxNum() == nodeCount) {
          logger.info(""String_Node_Str"");
        }
 else {
          try {
            List<String> nodeGroupNames=clusterMgr.syncSetParam(clusterName,null,Integer.valueOf(nodeCount),Integer.valueOf(nodeCount),true,null);
            logger.info(nodeGroupNames + ""String_Node_Str"" + nodeCount);
          }
 catch (          BddException e) {
            logger.error(""String_Node_Str"",e);
          }
        }
        file.delete();
      }
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      logger.warn(""String_Node_Str"");
      isTerminate=true;
    }
catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
    }
 finally {
      if (currentFile != null && currentFile.exists()) {
        currentFile.delete();
      }
    }
  }
}","public void run(){
  File currentFile=null;
  while (!isTerminate) {
    try {
      File directory=new File(""String_Node_Str"");
      File[] files=directory.listFiles(new FilenameFilter(){
        public boolean accept(        File dir,        String name){
          if (name.startsWith(filenamePrefix))           return true;
 else           return false;
        }
      }
);
      Arrays.sort(files,new Comparator<File>(){
        public int compare(        File f1,        File f2){
          return Long.valueOf(f1.lastModified()).compareTo(f2.lastModified());
        }
      }
);
      for (      File file : files) {
        currentFile=file;
        String filename=file.getName();
        logger.info(""String_Node_Str"" + filename + ""String_Node_Str"");
        String[] strs=filename.substring(filenamePrefix.length()).split(""String_Node_Str"");
        if (strs == null || strs.length != 2) {
          logger.error(""String_Node_Str"" + filename + ""String_Node_Str""+ filenamePrefix+ ""String_Node_Str"");
          file.delete();
          continue;
        }
        String clusterName=strs[0];
        String nodeCountStr=strs[1];
        ClusterRead cluster=null;
        try {
          cluster=clusterMgr.getClusterByName(clusterName,false);
        }
 catch (        BddException e) {
          logger.error(""String_Node_Str"",e);
          file.delete();
          continue;
        }
        if (cluster == null) {
          logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
          file.delete();
          continue;
        }
        if (!cluster.validateSetManualElasticity()) {
          logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
          file.delete();
          continue;
        }
        int nodeCount;
        try {
          nodeCount=Integer.valueOf(nodeCountStr);
        }
 catch (        NumberFormatException e) {
          logger.error(nodeCountStr + ""String_Node_Str"");
          file.delete();
          continue;
        }
        if (nodeCount < -1) {
          logger.error(""String_Node_Str"" + nodeCountStr + ""String_Node_Str"");
          file.delete();
          continue;
        }
        int computeNodeNum=cluster.retrieveComputeNodeNum();
        if (nodeCount > computeNodeNum) {
          logger.error(""String_Node_Str"" + computeNodeNum);
          file.delete();
          continue;
        }
        if (cluster.getAutomationEnable() == true && cluster.getVhmMinNum() == nodeCount && cluster.getVhmMaxNum() == nodeCount) {
          logger.info(""String_Node_Str"");
        }
 else {
          try {
            List<String> nodeGroupNames=clusterMgr.syncSetParam(clusterName,null,Integer.valueOf(nodeCount),Integer.valueOf(nodeCount),true,null);
            logger.info(nodeGroupNames + ""String_Node_Str"" + nodeCount);
          }
 catch (          BddException e) {
            logger.error(""String_Node_Str"",e);
          }
        }
        file.delete();
      }
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      logger.warn(""String_Node_Str"");
      isTerminate=true;
    }
catch (    Exception e) {
      logger.error(""String_Node_Str"",e);
    }
 finally {
      if (currentFile != null && currentFile.exists()) {
        currentFile.delete();
      }
    }
  }
}"
48855,"@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder){
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  ClusterCreate clusterSpec=configMgr.getClusterConfig(clusterName);
  String newPassword=clusterSpec.getPassword();
  if (newPassword == null) {
    logger.info(""String_Node_Str"");
    return RepeatStatus.FINISHED;
  }
  List<BaseNode> addedNodes=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_ADDED_NODES_JOB_PARAM,new TypeToken<List<BaseNode>>(){
  }
.getType());
  ArrayList<String> ipOfAddedNodes=getAddedNodeIPs(addedNodes);
  if (ipOfAddedNodes.isEmpty()) {
    throw TaskException.EXECUTION_FAILED(""String_Node_Str"");
  }
  ArrayList<String> failedNodes=setPasswordService.setPasswordForNodes(clusterName,ipOfAddedNodes,newPassword);
  boolean success=false;
  if (failedNodes == null) {
    success=true;
  }
 else {
    logger.info(""String_Node_Str"" + failedNodes.toString());
  }
  putIntoJobExecutionContext(chunkContext,JobConstants.CLUSTER_EXISTING_NODES_JOB_PARAM,success);
  if (!success) {
    throw TaskException.EXECUTION_FAILED(""String_Node_Str"" + failedNodes.toString());
  }
  return RepeatStatus.FINISHED;
}","@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder){
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  ClusterCreate clusterSpec=configMgr.getClusterConfig(clusterName);
  String newPassword=clusterSpec.getPassword();
  if (newPassword == null) {
    logger.info(""String_Node_Str"");
    return RepeatStatus.FINISHED;
  }
  ArrayList<String> nodeIPs=null;
  if (managementOperation == ManagementOperation.CREATE || managementOperation == ManagementOperation.RESIZE) {
    List<BaseNode> addedNodes=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_ADDED_NODES_JOB_PARAM,new TypeToken<List<BaseNode>>(){
    }
.getType());
    nodeIPs=getAddedNodeIPs(addedNodes);
  }
 else   if (managementOperation == ManagementOperation.RESUME) {
    nodeIPs=getAllNodeIPsFromEntitys(entityMgr.findAllNodes(clusterName));
  }
 else {
    throw TaskException.EXECUTION_FAILED(""String_Node_Str"");
  }
  if (nodeIPs == null) {
    throw TaskException.EXECUTION_FAILED(""String_Node_Str"");
  }
  ArrayList<String> failedNodes=setPasswordService.setPasswordForNodes(clusterName,nodeIPs,newPassword);
  boolean success=false;
  if (failedNodes == null) {
    success=true;
  }
 else {
    logger.info(""String_Node_Str"" + failedNodes.toString());
  }
  putIntoJobExecutionContext(chunkContext,JobConstants.CLUSTER_EXISTING_NODES_JOB_PARAM,success);
  if (!success) {
    throw TaskException.EXECUTION_FAILED(""String_Node_Str"" + failedNodes.toString());
  }
  return RepeatStatus.FINISHED;
}"
48856,"private ArrayList<String> getAddedNodeIPs(List<BaseNode> addedNodes){
  ArrayList<String> nodeIPs=null;
  for (  BaseNode node : addedNodes) {
    Map<NetTrafficType,List<IpConfigInfo>> ipConfigs=node.getIpConfigs();
    if (!ipConfigs.containsKey(NetTrafficType.MGT_NETWORK)) {
      logger.error(""String_Node_Str"");
      return nodeIPs;
    }
    if (nodeIPs == null) {
      nodeIPs=new ArrayList<String>();
    }
    nodeIPs.add(ipConfigs.get(NetTrafficType.MGT_NETWORK).get(0).getIpAddress());
  }
  return nodeIPs;
}","private ArrayList<String> getAddedNodeIPs(List<BaseNode> addedNodes){
  if (addedNodes == null) {
    return null;
  }
  ArrayList<String> nodeIPs=null;
  for (  BaseNode node : addedNodes) {
    Map<NetTrafficType,List<IpConfigInfo>> ipConfigs=node.getIpConfigs();
    if (!ipConfigs.containsKey(NetTrafficType.MGT_NETWORK)) {
      logger.error(""String_Node_Str"");
      return nodeIPs;
    }
    if (nodeIPs == null) {
      nodeIPs=new ArrayList<String>();
    }
    nodeIPs.add(ipConfigs.get(NetTrafficType.MGT_NETWORK).get(0).getIpAddress());
  }
  return nodeIPs;
}"
48857,"/** 
 * Add successfully created node, which information is got from vc creation. If deleted any VM, or nodes during vm creation step, which may violate placement policy. We'll remove the node if it's not re-created.
 * @param clusterName
 * @param addedNodes
 * @param deletedNodeNames
 * @return
 */
public void addNodeToMetaData(String clusterName,List<BaseNode> addedNodes,Set<String> deletedNodeNames){
  if (addedNodes == null || addedNodes.isEmpty()) {
    logger.info(""String_Node_Str"");
    return;
  }
  for (  BaseNode vNode : addedNodes) {
    deletedNodeNames.remove(vNode.getVmName());
synchronized (getClusterEntityMgr()) {
      replaceNodeEntity(vNode);
    }
  }
}","/** 
 * Add successfully created node, which information is got from vc creation. If deleted any VM, or nodes during vm creation step, which may violate placement policy. We'll remove the node if it's not re-created.
 * @param clusterName
 * @param addedNodes
 * @param deletedNodeNames
 * @return
 */
public void addNodeToMetaData(String clusterName,List<BaseNode> addedNodes,Set<String> deletedNodeNames){
  if (addedNodes == null || addedNodes.isEmpty()) {
    logger.info(""String_Node_Str"");
    return;
  }
  for (  BaseNode vNode : addedNodes) {
    deletedNodeNames.remove(vNode.getVmName());
    replaceNodeEntity(vNode);
  }
}"
48858,"@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  List<BaseNode> addedNodes=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_ADDED_NODES_JOB_PARAM,new TypeToken<List<BaseNode>>(){
  }
.getType());
  List<BaseNode> deletedNodes=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_DELETED_NODES_JOB_PARAM,new TypeToken<List<BaseNode>>(){
  }
.getType());
  Set<String> deletedNodeNames=new HashSet<String>();
  if (deletedNodes != null) {
    for (    BaseNode node : deletedNodes) {
      deletedNodeNames.add(node.getVmName());
    }
  }
  addNodeToMetaData(clusterName,addedNodes,deletedNodeNames);
  removeDeletedNode(clusterName,deletedNodeNames);
  return RepeatStatus.FINISHED;
}","@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  List<BaseNode> addedNodes=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_ADDED_NODES_JOB_PARAM,new TypeToken<List<BaseNode>>(){
  }
.getType());
  List<BaseNode> deletedNodes=getFromJobExecutionContext(chunkContext,JobConstants.CLUSTER_DELETED_NODES_JOB_PARAM,new TypeToken<List<BaseNode>>(){
  }
.getType());
  Set<String> deletedNodeNames=new HashSet<String>();
  if (deletedNodes != null) {
    for (    BaseNode node : deletedNodes) {
      deletedNodeNames.add(node.getVmName());
    }
  }
synchronized (getClusterEntityMgr()) {
    addNodeToMetaData(clusterName,addedNodes,deletedNodeNames);
    removeDeletedNode(clusterName,deletedNodeNames);
  }
  return RepeatStatus.FINISHED;
}"
48859,"private void processEvent(VcEventType type,Event e,String moId,boolean external) throws Exception {
  try {
switch (type) {
case VmRemoved:
{
        logger.debug(""String_Node_Str"" + moId);
        if (clusterEntityMgr.getNodeByMobId(moId) != null) {
          clusterEntityMgr.refreshNodeByMobId(moId,null,true);
        }
        break;
      }
case VmDisconnected:
{
      refreshNodeWithAction(e,null,true,null,""String_Node_Str"");
      break;
    }
case VmPoweredOn:
{
    refreshNodeWithAction(e,moId,true,Constants.NODE_ACTION_WAITING_IP,""String_Node_Str"");
    if (external) {
      NodePowerOnRequest request=new NodePowerOnRequest(clusterEntityMgr,moId);
      CmsWorker.addRequest(WorkQueue.VC_TASK_NO_DELAY,request);
    }
    break;
  }
case VmCloned:
{
  refreshNodeWithAction(e,moId,true,Constants.NODE_ACTION_RECONFIGURE,""String_Node_Str"");
  break;
}
case VmSuspended:
{
refreshNodeWithAction(e,moId,true,null,""String_Node_Str"");
break;
}
case VmPoweredOff:
{
refreshNodeWithAction(e,moId,true,null,""String_Node_Str"");
break;
}
case VhmError:
case VhmWarning:
case VhmInfo:
case VhmUser:
{
EventEx event=(EventEx)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
break;
}
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + e.getDynamicType() + ""String_Node_Str""+ vm.getName()+ ""String_Node_Str""+ event.getMessage());
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),event.getMessage(),true);
}
break;
}
default :
{
refreshNodeWithAction(e,moId,false,null,type.name());
break;
}
}
}
 catch (ManagedObjectNotFound exp) {
VcUtil.processNotFoundException(exp,moId,logger);
}
}","private void processEvent(VcEventType type,Event e,String moId,boolean external) throws Exception {
  try {
switch (type) {
case VmRemoved:
{
        logger.debug(""String_Node_Str"" + moId);
        if (clusterEntityMgr.getNodeByMobId(moId) != null) {
          clusterEntityMgr.refreshNodeByMobId(moId,null,true);
        }
        break;
      }
case VmDisconnected:
{
      refreshNodeWithAction(e,null,true,null,""String_Node_Str"");
      break;
    }
case VmPoweredOn:
{
    refreshNodeWithAction(e,moId,true,Constants.NODE_ACTION_WAITING_IP,""String_Node_Str"");
    if (external) {
      NodePowerOnRequest request=new NodePowerOnRequest(clusterEntityMgr,moId);
      CmsWorker.addRequest(WorkQueue.VC_TASK_NO_DELAY,request);
    }
    break;
  }
case VmCloned:
{
  refreshNodeWithAction(e,moId,true,Constants.NODE_ACTION_RECONFIGURE,""String_Node_Str"");
  break;
}
case VmSuspended:
{
refreshNodeWithAction(e,moId,true,null,""String_Node_Str"");
break;
}
case VmPoweredOff:
{
refreshNodeWithAction(e,moId,true,null,""String_Node_Str"");
break;
}
case VmConnected:
case VmMigrated:
case VmRelocated:
{
refreshNodeWithAction(e,moId,false,null,type.name());
break;
}
case VhmError:
case VhmWarning:
case VhmInfo:
case VhmUser:
{
EventEx event=(EventEx)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
break;
}
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + e.getDynamicType() + ""String_Node_Str""+ vm.getName()+ ""String_Node_Str""+ event.getMessage());
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),event.getMessage(),true);
}
break;
}
default :
{
break;
}
}
}
 catch (ManagedObjectNotFound exp) {
VcUtil.processNotFoundException(exp,moId,logger);
}
}"
48860,"/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
public void validateClusterCreate(List<String> failedMsgList,List<String> warningMsgList,final List<String> distroRoles){
  boolean namenodeHACheck=false;
  int masterCount=0, jobtrackerCount=0, resourcemanagerCount=0, hbasemasterCount=0, zookeeperCount=0, workerCount=0, numOfJournalNode=0;
  boolean appendWarningStr=false;
  if (warningMsgList != null && warningMsgList.isEmpty()) {
    appendWarningStr=true;
  }
  NodeGroupCreate[] nodeGroupCreates=getNodeGroups();
  AuAssert.check(nodeGroupCreates != null && nodeGroupCreates.length > 0);
  if (hasHDFSUrlConfigured() && !validateHDFSUrl()) {
    failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getExternalHDFS()).toString());
  }
  validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList);
  validateNodeGroupRoles(failedMsgList);
  validateStorageType(failedMsgList);
  validateSwapRatio(nodeGroupCreates,failedMsgList);
  for (  NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
    checkInstanceNum(nodeGroupCreate,failedMsgList);
    makeVmMemoryDivisibleBy4(nodeGroupCreate,warningMsgList);
    checkNodeGroupRoles(nodeGroupCreate,distroRoles,failedMsgList);
    List<NodeGroupRole> groupRoles=getNodeGroupRoles(nodeGroupCreate);
    if (groupRoles != null) {
      for (      NodeGroupRole role : groupRoles) {
switch (role) {
case MASTER:
          masterCount++;
        int numOfInstance=nodeGroupCreate.getInstanceNum();
      if (numOfInstance >= 0 && numOfInstance != 1) {
        if (numOfInstance != 2) {
          collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
        }
 else {
          namenodeHACheck=true;
        }
      }
    break;
case JOB_TRACKER:
  jobtrackerCount++;
if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
  failedMsgList.add(Constants.WRONG_NUM_OF_JOBTRACKER);
}
break;
case RESOURCEMANAGER:
resourcemanagerCount++;
if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
failedMsgList.add(Constants.WRONG_NUM_OF_RESOURCEMANAGER);
}
break;
case HBASE_MASTER:
hbasemasterCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
break;
case ZOOKEEPER:
zookeeperCount++;
if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_ZOOKEEPER);
}
 else if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_ZOOKEEPER);
}
break;
case JOURNAL_NODE:
numOfJournalNode+=nodeGroupCreate.getInstanceNum();
if (nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_DATANODE.toString()) || nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_CLIENT_ROLE.toString())) {
failedMsgList.add(Constants.DATA_CLIENT_NODE_JOURNALNODE_COEXIST);
}
break;
case WORKER:
workerCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
 else if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
List<String> roles=nodeGroupCreate.getRoles();
if (roles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString()) && !roles.contains(HadoopRole.HADOOP_DATANODE.toString())) {
warningMsgList.add(Constants.REGISONSERVER_DATANODE_SEPERATION);
}
break;
case CLIENT:
if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
break;
case NONE:
warningMsgList.add(Constants.NOT_DEFINED_ROLE);
break;
default :
}
}
}
}
if (!supportedWithHdfs2()) {
if (namenodeHACheck || masterCount > 1) {
failedMsgList.add(Constants.CURRENT_DISTRO_CAN_NOT_SUPPORT_HDFS2);
}
}
 else if (namenodeHACheck) {
if (numOfJournalNode >= 0 && numOfJournalNode < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_JOURNALNODE);
}
 else if (numOfJournalNode > 0 && numOfJournalNode % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_JOURNALNODE);
}
if (zookeeperCount == 0) {
failedMsgList.add(Constants.NAMENODE_AUTO_FAILOVER_ZOOKEEPER);
}
}
if ((jobtrackerCount > 1) || (resourcemanagerCount > 1) || (zookeeperCount > 1)|| (hbasemasterCount > 1)) {
failedMsgList.add(Constants.WRONG_NUM_OF_NODEGROUPS);
}
if (workerCount == 0) {
warningMsgList.add(Constants.WRONG_NUM_OF_WORKERNODES);
}
if (numOfJournalNode > 0 && !namenodeHACheck) {
failedMsgList.add(Constants.NO_NAMENODE_HA);
}
if (!warningMsgList.isEmpty() && appendWarningStr) {
warningMsgList.set(0,""String_Node_Str"" + warningMsgList.get(0));
}
}","/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
public void validateClusterCreate(List<String> failedMsgList,List<String> warningMsgList,final List<String> distroRoles){
  boolean namenodeHACheck=false;
  int masterCount=0, jobtrackerCount=0, resourcemanagerCount=0, hbasemasterCount=0, zookeeperCount=0, workerCount=0, numOfJournalNode=0;
  boolean appendWarningStr=false;
  if (warningMsgList != null && warningMsgList.isEmpty()) {
    appendWarningStr=true;
  }
  NodeGroupCreate[] nodeGroupCreates=getNodeGroups();
  AuAssert.check(nodeGroupCreates != null && nodeGroupCreates.length > 0);
  if (hasHDFSUrlConfigured() && !validateHDFSUrl()) {
    failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getExternalHDFS()).toString());
  }
  validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList);
  validateNodeGroupRoles(failedMsgList);
  validateStorageType(failedMsgList);
  validateSwapRatio(nodeGroupCreates,failedMsgList);
  for (  NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
    checkInstanceNum(nodeGroupCreate,failedMsgList);
    checkCPUAndMemory(nodeGroupCreate,failedMsgList,warningMsgList);
    checkNodeGroupRoles(nodeGroupCreate,distroRoles,failedMsgList);
    List<NodeGroupRole> groupRoles=getNodeGroupRoles(nodeGroupCreate);
    if (groupRoles != null) {
      for (      NodeGroupRole role : groupRoles) {
switch (role) {
case MASTER:
          masterCount++;
        int numOfInstance=nodeGroupCreate.getInstanceNum();
      if (numOfInstance >= 0 && numOfInstance != 1) {
        if (numOfInstance != 2) {
          collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
        }
 else {
          namenodeHACheck=true;
        }
      }
    break;
case JOB_TRACKER:
  jobtrackerCount++;
if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
  failedMsgList.add(Constants.WRONG_NUM_OF_JOBTRACKER);
}
break;
case RESOURCEMANAGER:
resourcemanagerCount++;
if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
failedMsgList.add(Constants.WRONG_NUM_OF_RESOURCEMANAGER);
}
break;
case HBASE_MASTER:
hbasemasterCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
break;
case ZOOKEEPER:
zookeeperCount++;
if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_ZOOKEEPER);
}
 else if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_ZOOKEEPER);
}
break;
case JOURNAL_NODE:
numOfJournalNode+=nodeGroupCreate.getInstanceNum();
if (nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_DATANODE.toString()) || nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_CLIENT_ROLE.toString())) {
failedMsgList.add(Constants.DATA_CLIENT_NODE_JOURNALNODE_COEXIST);
}
break;
case WORKER:
workerCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
 else if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
List<String> roles=nodeGroupCreate.getRoles();
if (roles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString()) && !roles.contains(HadoopRole.HADOOP_DATANODE.toString())) {
warningMsgList.add(Constants.REGISONSERVER_DATANODE_SEPERATION);
}
break;
case CLIENT:
if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
break;
case NONE:
warningMsgList.add(Constants.NOT_DEFINED_ROLE);
break;
default :
}
}
}
}
if (!supportedWithHdfs2()) {
if (namenodeHACheck || masterCount > 1) {
failedMsgList.add(Constants.CURRENT_DISTRO_CAN_NOT_SUPPORT_HDFS2);
}
}
 else if (namenodeHACheck) {
if (numOfJournalNode >= 0 && numOfJournalNode < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_JOURNALNODE);
}
 else if (numOfJournalNode > 0 && numOfJournalNode % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_JOURNALNODE);
}
if (zookeeperCount == 0) {
failedMsgList.add(Constants.NAMENODE_AUTO_FAILOVER_ZOOKEEPER);
}
}
if ((jobtrackerCount > 1) || (resourcemanagerCount > 1) || (zookeeperCount > 1)|| (hbasemasterCount > 1)) {
failedMsgList.add(Constants.WRONG_NUM_OF_NODEGROUPS);
}
if (workerCount == 0) {
warningMsgList.add(Constants.WRONG_NUM_OF_WORKERNODES);
}
if (numOfJournalNode > 0 && !namenodeHACheck) {
failedMsgList.add(Constants.NO_NAMENODE_HA);
}
if (!warningMsgList.isEmpty() && appendWarningStr) {
warningMsgList.set(0,""String_Node_Str"" + warningMsgList.get(0));
}
}"
48861,"private void makeVmMemoryDivisibleBy4(NodeGroupCreate nodeGroup,List<String> warningMsgList){
  int memoryNum=nodeGroup.getMemCapacityMB();
  if (memoryNum > 0) {
    long converted=CommonUtil.makeVmMemoryDivisibleBy4(memoryNum);
    if (converted < memoryNum) {
      nodeGroup.setMemCapacityMB((int)converted);
      warningMsgList.add(Constants.CONVERTED_MEMORY_DIVISIBLE_BY_4 + ""String_Node_Str"" + nodeGroup.getName()+ ""String_Node_Str""+ converted+ ""String_Node_Str""+ memoryNum+ ""String_Node_Str"");
    }
  }
}","private void makeVmMemoryDivisibleBy4(NodeGroupCreate nodeGroup,List<String> warningMsgList){
  int memoryCap=nodeGroup.getMemCapacityMB();
  if (memoryCap > 0) {
    long converted=CommonUtil.makeVmMemoryDivisibleBy4(memoryCap);
    if (converted < memoryCap) {
      nodeGroup.setMemCapacityMB((int)converted);
      warningMsgList.add(Constants.CONVERTED_MEMORY_DIVISIBLE_BY_4 + ""String_Node_Str"" + nodeGroup.getName()+ ""String_Node_Str""+ converted+ ""String_Node_Str""+ memoryCap+ ""String_Node_Str"");
    }
  }
}"
48862,"@Test public void testValidateClusterCreate(){
  ClusterCreate cluster=new ClusterCreate();
  cluster.setDistroVendor(Constants.DEFAULT_VENDOR);
  Map<NetTrafficType,List<String>> networkConfig=new HashMap<NetTrafficType,List<String>>();
  List<String> mgtnets=new ArrayList<String>();
  mgtnets.add(""String_Node_Str"");
  networkConfig.put(NetTrafficType.MGT_NETWORK,mgtnets);
  List<String> hadpnets=new ArrayList<String>();
  hadpnets.add(""String_Node_Str"");
  networkConfig.put(NetTrafficType.HDFS_NETWORK,hadpnets);
  cluster.setNetworkConfig(networkConfig);
  NodeGroupCreate master=new NodeGroupCreate();
  master.setName(""String_Node_Str"");
  master.setMemCapacityMB(7501);
  master.setSwapRatio(0F);
  master.setInstanceNum(1);
  master.setRoles(Arrays.asList(HadoopRole.HADOOP_NAMENODE_ROLE.toString(),HadoopRole.HADOOP_JOBTRACKER_ROLE.toString()));
  NodeGroupCreate worker=new NodeGroupCreate();
  worker.setName(""String_Node_Str"");
  worker.setRoles(Arrays.asList(HadoopRole.HADOOP_DATANODE.toString(),HadoopRole.HADOOP_TASKTRACKER.toString()));
  worker.setMemCapacityMB(3748);
  worker.setInstanceNum(0);
  NodeGroupCreate client=new NodeGroupCreate();
  client.setName(""String_Node_Str"");
  client.setMemCapacityMB(3748);
  client.setInstanceNum(0);
  client.setRoles(Arrays.asList(HadoopRole.HADOOP_CLIENT_ROLE.toString(),HadoopRole.HIVE_SERVER_ROLE.toString(),HadoopRole.HIVE_ROLE.toString()));
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  List<String> distroRoles=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  cluster.setNodeGroups(new NodeGroupCreate[]{master,worker,client});
  cluster.validateClusterCreate(failedMsgList,warningMsgList,distroRoles);
  assertEquals(3,failedMsgList.size());
  assertEquals(""String_Node_Str"",failedMsgList.get(0));
  assertEquals(""String_Node_Str"",failedMsgList.get(1));
  assertEquals(""String_Node_Str"",failedMsgList.get(2));
  assertEquals(1,warningMsgList.size());
  assertEquals(""String_Node_Str"",warningMsgList.get(0));
}","@Test public void testValidateClusterCreate(){
  ClusterCreate cluster=new ClusterCreate();
  cluster.setDistroVendor(Constants.DEFAULT_VENDOR);
  Map<NetTrafficType,List<String>> networkConfig=new HashMap<NetTrafficType,List<String>>();
  List<String> mgtnets=new ArrayList<String>();
  mgtnets.add(""String_Node_Str"");
  networkConfig.put(NetTrafficType.MGT_NETWORK,mgtnets);
  List<String> hadpnets=new ArrayList<String>();
  hadpnets.add(""String_Node_Str"");
  networkConfig.put(NetTrafficType.HDFS_NETWORK,hadpnets);
  cluster.setNetworkConfig(networkConfig);
  NodeGroupCreate master=new NodeGroupCreate();
  master.setName(""String_Node_Str"");
  master.setCpuNum(2);
  master.setMemCapacityMB(7501);
  master.setSwapRatio(0F);
  master.setInstanceNum(1);
  master.setRoles(Arrays.asList(HadoopRole.HADOOP_NAMENODE_ROLE.toString(),HadoopRole.HADOOP_JOBTRACKER_ROLE.toString()));
  NodeGroupCreate worker=new NodeGroupCreate();
  worker.setName(""String_Node_Str"");
  worker.setRoles(Arrays.asList(HadoopRole.HADOOP_DATANODE.toString(),HadoopRole.HADOOP_TASKTRACKER.toString()));
  worker.setCpuNum(2);
  worker.setMemCapacityMB(3748);
  worker.setInstanceNum(0);
  NodeGroupCreate client=new NodeGroupCreate();
  client.setName(""String_Node_Str"");
  client.setCpuNum(2);
  client.setMemCapacityMB(3748);
  client.setInstanceNum(0);
  client.setRoles(Arrays.asList(HadoopRole.HADOOP_CLIENT_ROLE.toString(),HadoopRole.HIVE_SERVER_ROLE.toString(),HadoopRole.HIVE_ROLE.toString()));
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  List<String> distroRoles=Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  cluster.setNodeGroups(new NodeGroupCreate[]{master,worker,client});
  cluster.validateClusterCreate(failedMsgList,warningMsgList,distroRoles);
  assertEquals(3,failedMsgList.size());
  assertEquals(""String_Node_Str"",failedMsgList.get(0));
  assertEquals(""String_Node_Str"",failedMsgList.get(1));
  assertEquals(""String_Node_Str"",failedMsgList.get(2));
  assertEquals(1,warningMsgList.size());
  assertEquals(""String_Node_Str"",warningMsgList.get(0));
}"
48863,"public void testClusterConfigWithGroupSlave(){
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  spec.setNetworkConfig(createNetConfigs());
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  rps.add(""String_Node_Str"");
  rps.add(""String_Node_Str"");
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  NodeGroupCreate[] nodegroups=new NodeGroupCreate[1];
  NodeGroupCreate group=new NodeGroupCreate();
  nodegroups[0]=group;
  group.setCpuNum(3);
  group.setInstanceNum(10);
  group.setInstanceType(InstanceType.SMALL);
  group.setHaFlag(""String_Node_Str"");
  group.setName(""String_Node_Str"");
  List<String> roles=new ArrayList<String>();
  roles.add(""String_Node_Str"");
  group.setRoles(roles);
  spec.setNodeGroups(nodegroups);
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1 && manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
}","public void testClusterConfigWithGroupSlave(){
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  spec.setNetworkConfig(createNetConfigs());
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  rps.add(""String_Node_Str"");
  rps.add(""String_Node_Str"");
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  NodeGroupCreate[] nodegroups=new NodeGroupCreate[1];
  NodeGroupCreate group=new NodeGroupCreate();
  nodegroups[0]=group;
  group.setCpuNum(3);
  group.setInstanceNum(10);
  group.setCpuNum(2);
  group.setMemCapacityMB(7500);
  group.setInstanceType(InstanceType.SMALL);
  group.setHaFlag(""String_Node_Str"");
  group.setName(""String_Node_Str"");
  List<String> roles=new ArrayList<String>();
  roles.add(""String_Node_Str"");
  group.setRoles(roles);
  spec.setNodeGroups(nodegroups);
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1 && manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
}"
48864,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test(groups={""String_Node_Str""}) public void testClusterAppConfig() throws Exception {
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  spec.setNetworkConfig(createNetConfigs());
  spec.setType(ClusterType.HDFS_MAPRED);
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  spec=ClusterSpecFactory.getCustomizedSpec(spec);
  spec.setType(null);
  String configJson=""String_Node_Str"";
  Map config=(new Gson()).fromJson(configJson,Map.class);
  spec.setConfiguration((Map<String,Object>)(config.get(""String_Node_Str"")));
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findClusterById(1l);
  List<ClusterEntity> cs=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity c : cs) {
    System.out.println(c.getId());
  }
  cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test(groups={""String_Node_Str""}) public void testClusterAppConfig() throws Exception {
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  spec.setNetworkConfig(createNetConfigs());
  spec.setType(ClusterType.HDFS_MAPRED);
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  spec=ClusterSpecFactory.getCustomizedSpec(spec);
  for (  NodeGroupCreate nodeGroup : spec.getNodeGroups()) {
    nodeGroup.setCpuNum(2);
    nodeGroup.setMemCapacityMB(7500);
  }
  spec.setType(null);
  String configJson=""String_Node_Str"";
  Map config=(new Gson()).fromJson(configJson,Map.class);
  spec.setConfiguration((Map<String,Object>)(config.get(""String_Node_Str"")));
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findClusterById(1l);
  List<ClusterEntity> cs=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity c : cs) {
    System.out.println(c.getId());
  }
  cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
}"
48865,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test(groups={""String_Node_Str""}) public void testClusterConfigWithExternalHDFSFailure() throws Exception {
  String[] hdfsArray=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  spec.setNetworkConfig(createNetConfigs());
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  String clusterConfigJson=""String_Node_Str"" + hdfsArray[1] + ""String_Node_Str"";
  Map clusterConfig=(new Gson()).fromJson(clusterConfigJson,Map.class);
  spec.setConfiguration((Map<String,Object>)(clusterConfig.get(""String_Node_Str"")));
  NodeGroupCreate ng0=new NodeGroupCreate();
  List<String> masterRole=new ArrayList<String>();
  masterRole.add(""String_Node_Str"");
  masterRole.add(""String_Node_Str"");
  ng0.setRoles(masterRole);
  ng0.setName(""String_Node_Str"");
  ng0.setInstanceNum(1);
  ng0.setInstanceType(InstanceType.LARGE);
  String ng0ConfigJson=""String_Node_Str"" + hdfsArray[2] + ""String_Node_Str"";
  Map ng0Config=(new Gson()).fromJson(ng0ConfigJson,Map.class);
  ng0.setConfiguration((Map<String,Object>)(ng0Config.get(""String_Node_Str"")));
  NodeGroupCreate ng1=new NodeGroupCreate();
  List<String> computeRoles=new ArrayList<String>();
  computeRoles.add(""String_Node_Str"");
  ng1.setRoles(computeRoles);
  ng1.setName(""String_Node_Str"");
  ng1.setInstanceNum(4);
  ng1.setInstanceType(InstanceType.MEDIUM);
  StorageRead storage=new StorageRead();
  storage.setType(""String_Node_Str"");
  storage.setSizeGB(10);
  ng1.setStorage(storage);
  String ng1ConfigJson=""String_Node_Str"" + hdfsArray[3] + ""String_Node_Str"";
  Map ng1Config=(new Gson()).fromJson(ng1ConfigJson,Map.class);
  ng1.setConfiguration((Map<String,Object>)(ng1Config.get(""String_Node_Str"")));
  NodeGroupCreate ng2=new NodeGroupCreate();
  List<String> dataRoles=new ArrayList<String>();
  dataRoles.add(""String_Node_Str"");
  ng2.setRoles(dataRoles);
  ng2.setName(""String_Node_Str"");
  ng2.setInstanceNum(2);
  ng2.setInstanceType(InstanceType.MEDIUM);
  StorageRead storageCompute=new StorageRead();
  storageCompute.setType(""String_Node_Str"");
  storageCompute.setSizeGB(10);
  ng2.setStorage(storageCompute);
  NodeGroupCreate[] ngs=new NodeGroupCreate[]{ng0,ng1,ng2};
  spec.setNodeGroups(ngs);
  spec=ClusterSpecFactory.getCustomizedSpec(spec);
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findClusterById(1l);
  List<ClusterEntity> cs=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity c : cs) {
    System.out.println(c.getId());
  }
  cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(Pattern.compile(""String_Node_Str"" + hdfsArray[0] + ""String_Node_Str"").matcher(manifest).matches() == false,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[1]) != -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[2]) != -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[3]) != -1,""String_Node_Str"");
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test(groups={""String_Node_Str""}) public void testClusterConfigWithExternalHDFSFailure() throws Exception {
  String[] hdfsArray=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  spec.setNetworkConfig(createNetConfigs());
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  String clusterConfigJson=""String_Node_Str"" + hdfsArray[1] + ""String_Node_Str"";
  Map clusterConfig=(new Gson()).fromJson(clusterConfigJson,Map.class);
  spec.setConfiguration((Map<String,Object>)(clusterConfig.get(""String_Node_Str"")));
  NodeGroupCreate ng0=new NodeGroupCreate();
  List<String> masterRole=new ArrayList<String>();
  masterRole.add(""String_Node_Str"");
  masterRole.add(""String_Node_Str"");
  ng0.setRoles(masterRole);
  ng0.setName(""String_Node_Str"");
  ng0.setInstanceNum(1);
  ng0.setCpuNum(2);
  ng0.setMemCapacityMB(7500);
  ng0.setInstanceType(InstanceType.LARGE);
  String ng0ConfigJson=""String_Node_Str"" + hdfsArray[2] + ""String_Node_Str"";
  Map ng0Config=(new Gson()).fromJson(ng0ConfigJson,Map.class);
  ng0.setConfiguration((Map<String,Object>)(ng0Config.get(""String_Node_Str"")));
  NodeGroupCreate ng1=new NodeGroupCreate();
  List<String> computeRoles=new ArrayList<String>();
  computeRoles.add(""String_Node_Str"");
  ng1.setRoles(computeRoles);
  ng1.setName(""String_Node_Str"");
  ng1.setInstanceNum(4);
  ng1.setCpuNum(2);
  ng1.setMemCapacityMB(7500);
  ng1.setInstanceType(InstanceType.MEDIUM);
  StorageRead storage=new StorageRead();
  storage.setType(""String_Node_Str"");
  storage.setSizeGB(10);
  ng1.setStorage(storage);
  String ng1ConfigJson=""String_Node_Str"" + hdfsArray[3] + ""String_Node_Str"";
  Map ng1Config=(new Gson()).fromJson(ng1ConfigJson,Map.class);
  ng1.setConfiguration((Map<String,Object>)(ng1Config.get(""String_Node_Str"")));
  NodeGroupCreate ng2=new NodeGroupCreate();
  List<String> dataRoles=new ArrayList<String>();
  dataRoles.add(""String_Node_Str"");
  ng2.setRoles(dataRoles);
  ng2.setName(""String_Node_Str"");
  ng2.setInstanceNum(2);
  ng2.setCpuNum(2);
  ng2.setMemCapacityMB(7500);
  ng2.setInstanceType(InstanceType.MEDIUM);
  StorageRead storageCompute=new StorageRead();
  storageCompute.setType(""String_Node_Str"");
  storageCompute.setSizeGB(10);
  ng2.setStorage(storageCompute);
  NodeGroupCreate[] ngs=new NodeGroupCreate[]{ng0,ng1,ng2};
  spec.setNodeGroups(ngs);
  spec=ClusterSpecFactory.getCustomizedSpec(spec);
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findClusterById(1l);
  List<ClusterEntity> cs=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity c : cs) {
    System.out.println(c.getId());
  }
  cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(Pattern.compile(""String_Node_Str"" + hdfsArray[0] + ""String_Node_Str"").matcher(manifest).matches() == false,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[1]) != -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[2]) != -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[3]) != -1,""String_Node_Str"");
}"
48866,"@Test(groups={""String_Node_Str""}) public void testClusterConfigWithClusterStorage() throws Exception {
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  spec.setNetworkConfig(createNetConfigs());
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  List<String> dsNames=new ArrayList<String>();
  dsNames.add(""String_Node_Str"");
  dsNames.add(""String_Node_Str"");
  spec.setDsNames(dsNames);
  spec.setType(ClusterType.HDFS_MAPRED);
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  spec=ClusterSpecFactory.getCustomizedSpec(spec);
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findClusterById(1l);
  List<ClusterEntity> cs=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity c : cs) {
    System.out.println(c.getId());
  }
  cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
}","@Test(groups={""String_Node_Str""}) public void testClusterConfigWithClusterStorage() throws Exception {
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  spec.setNetworkConfig(createNetConfigs());
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  List<String> dsNames=new ArrayList<String>();
  dsNames.add(""String_Node_Str"");
  dsNames.add(""String_Node_Str"");
  spec.setDsNames(dsNames);
  spec.setType(ClusterType.HDFS_MAPRED);
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  spec=ClusterSpecFactory.getCustomizedSpec(spec);
  for (  NodeGroupCreate nodeGroup : spec.getNodeGroups()) {
    nodeGroup.setCpuNum(2);
    nodeGroup.setMemCapacityMB(7500);
  }
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findClusterById(1l);
  List<ClusterEntity> cs=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity c : cs) {
    System.out.println(c.getId());
  }
  cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
}"
48867,"@Test(groups={""String_Node_Str""}) public void testClusterConfig() throws Exception {
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  spec.setNetworkConfig(createNetConfigs());
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  spec.setType(ClusterType.HDFS_MAPRED);
  spec=ClusterSpecFactory.getCustomizedSpec(spec);
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findClusterById(1l);
  List<ClusterEntity> cs=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity c : cs) {
    System.out.println(c.getId());
  }
  cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
}","@Test(groups={""String_Node_Str""}) public void testClusterConfig() throws Exception {
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  spec.setNetworkConfig(createNetConfigs());
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  spec.setType(ClusterType.HDFS_MAPRED);
  spec=ClusterSpecFactory.getCustomizedSpec(spec);
  for (  NodeGroupCreate nodeGroup : spec.getNodeGroups()) {
    nodeGroup.setCpuNum(2);
    nodeGroup.setMemCapacityMB(7500);
  }
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findClusterById(1l);
  List<ClusterEntity> cs=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity c : cs) {
    System.out.println(c.getId());
  }
  cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
}"
48868,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test(groups={""String_Node_Str""}) public void testClusterConfigWithExternalHDFS() throws Exception {
  String[] hdfsArray=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  spec.setNetworkConfig(createNetConfigs());
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  spec.setExternalHDFS(hdfsArray[0]);
  String clusterConfigJson=""String_Node_Str"" + hdfsArray[1] + ""String_Node_Str"";
  Map clusterConfig=(new Gson()).fromJson(clusterConfigJson,Map.class);
  spec.setConfiguration((Map<String,Object>)(clusterConfig.get(""String_Node_Str"")));
  NodeGroupCreate ng0=new NodeGroupCreate();
  List<String> jobtrackerRole=new ArrayList<String>();
  jobtrackerRole.add(""String_Node_Str"");
  ng0.setRoles(jobtrackerRole);
  ng0.setName(""String_Node_Str"");
  ng0.setInstanceNum(1);
  ng0.setInstanceType(InstanceType.LARGE);
  String ng0ConfigJson=""String_Node_Str"" + hdfsArray[2] + ""String_Node_Str"";
  Map ng0Config=(new Gson()).fromJson(ng0ConfigJson,Map.class);
  ng0.setConfiguration((Map<String,Object>)(ng0Config.get(""String_Node_Str"")));
  NodeGroupCreate ng1=new NodeGroupCreate();
  List<String> computeRoles=new ArrayList<String>();
  computeRoles.add(""String_Node_Str"");
  ng1.setRoles(computeRoles);
  ng1.setName(""String_Node_Str"");
  ng1.setInstanceNum(4);
  ng1.setInstanceType(InstanceType.MEDIUM);
  StorageRead storage=new StorageRead();
  storage.setType(""String_Node_Str"");
  storage.setSizeGB(10);
  ng1.setStorage(storage);
  String ng1ConfigJson=""String_Node_Str"" + hdfsArray[3] + ""String_Node_Str"";
  Map ng1Config=(new Gson()).fromJson(ng1ConfigJson,Map.class);
  ng1.setConfiguration((Map<String,Object>)(ng1Config.get(""String_Node_Str"")));
  NodeGroupCreate ng2=new NodeGroupCreate();
  ng2.setRoles(computeRoles);
  ng2.setName(""String_Node_Str"");
  ng2.setInstanceNum(2);
  ng2.setInstanceType(InstanceType.MEDIUM);
  StorageRead storageCompute=new StorageRead();
  storageCompute.setType(""String_Node_Str"");
  storageCompute.setSizeGB(10);
  ng2.setStorage(storageCompute);
  NodeGroupCreate[] ngs=new NodeGroupCreate[]{ng0,ng1,ng2};
  spec.setNodeGroups(ngs);
  spec=ClusterSpecFactory.getCustomizedSpec(spec);
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findClusterById(1l);
  List<ClusterEntity> cs=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity c : cs) {
    System.out.println(c.getId());
  }
  cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(Pattern.compile(""String_Node_Str"" + hdfsArray[0] + ""String_Node_Str"").matcher(manifest).matches(),""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[1]) == -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[2]) == -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[3]) == -1,""String_Node_Str"");
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test(groups={""String_Node_Str""}) public void testClusterConfigWithExternalHDFS() throws Exception {
  String[] hdfsArray=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  spec.setNetworkConfig(createNetConfigs());
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  spec.setExternalHDFS(hdfsArray[0]);
  String clusterConfigJson=""String_Node_Str"" + hdfsArray[1] + ""String_Node_Str"";
  Map clusterConfig=(new Gson()).fromJson(clusterConfigJson,Map.class);
  spec.setConfiguration((Map<String,Object>)(clusterConfig.get(""String_Node_Str"")));
  NodeGroupCreate ng0=new NodeGroupCreate();
  List<String> jobtrackerRole=new ArrayList<String>();
  jobtrackerRole.add(""String_Node_Str"");
  ng0.setRoles(jobtrackerRole);
  ng0.setName(""String_Node_Str"");
  ng0.setInstanceNum(1);
  ng0.setCpuNum(2);
  ng0.setMemCapacityMB(7500);
  ng0.setInstanceType(InstanceType.LARGE);
  String ng0ConfigJson=""String_Node_Str"" + hdfsArray[2] + ""String_Node_Str"";
  Map ng0Config=(new Gson()).fromJson(ng0ConfigJson,Map.class);
  ng0.setConfiguration((Map<String,Object>)(ng0Config.get(""String_Node_Str"")));
  NodeGroupCreate ng1=new NodeGroupCreate();
  List<String> computeRoles=new ArrayList<String>();
  computeRoles.add(""String_Node_Str"");
  ng1.setRoles(computeRoles);
  ng1.setName(""String_Node_Str"");
  ng1.setInstanceNum(4);
  ng1.setCpuNum(2);
  ng1.setMemCapacityMB(7500);
  ng1.setInstanceType(InstanceType.MEDIUM);
  StorageRead storage=new StorageRead();
  storage.setType(""String_Node_Str"");
  storage.setSizeGB(10);
  ng1.setStorage(storage);
  String ng1ConfigJson=""String_Node_Str"" + hdfsArray[3] + ""String_Node_Str"";
  Map ng1Config=(new Gson()).fromJson(ng1ConfigJson,Map.class);
  ng1.setConfiguration((Map<String,Object>)(ng1Config.get(""String_Node_Str"")));
  NodeGroupCreate ng2=new NodeGroupCreate();
  ng2.setRoles(computeRoles);
  ng2.setName(""String_Node_Str"");
  ng2.setInstanceNum(2);
  ng2.setCpuNum(2);
  ng2.setMemCapacityMB(7500);
  ng2.setInstanceType(InstanceType.MEDIUM);
  StorageRead storageCompute=new StorageRead();
  storageCompute.setType(""String_Node_Str"");
  storageCompute.setSizeGB(10);
  ng2.setStorage(storageCompute);
  NodeGroupCreate[] ngs=new NodeGroupCreate[]{ng0,ng1,ng2};
  spec.setNodeGroups(ngs);
  spec=ClusterSpecFactory.getCustomizedSpec(spec);
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findClusterById(1l);
  List<ClusterEntity> cs=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity c : cs) {
    System.out.println(c.getId());
  }
  cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(Pattern.compile(""String_Node_Str"" + hdfsArray[0] + ""String_Node_Str"").matcher(manifest).matches(),""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[1]) == -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[2]) == -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(hdfsArray[3]) == -1,""String_Node_Str"");
}"
48869,"@Test(groups={""String_Node_Str""}) public void testClusterConfigWithTempfs() throws Exception {
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  spec.setNetworkConfig(createNetConfigs());
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  NodeGroupCreate[] ngs=new NodeGroupCreate[3];
  NodeGroupCreate ng0=new NodeGroupCreate();
  ngs[0]=ng0;
  List<String> masterRoles=new ArrayList<String>();
  masterRoles.add(""String_Node_Str"");
  masterRoles.add(""String_Node_Str"");
  ngs[0].setRoles(masterRoles);
  ngs[0].setName(""String_Node_Str"");
  ngs[0].setInstanceNum(1);
  ngs[0].setInstanceType(InstanceType.LARGE);
  NodeGroupCreate ng1=new NodeGroupCreate();
  ngs[1]=ng1;
  List<String> dataNodeRoles=new ArrayList<String>();
  dataNodeRoles.add(""String_Node_Str"");
  ngs[1].setRoles(dataNodeRoles);
  ngs[1].setName(""String_Node_Str"");
  ngs[1].setInstanceNum(4);
  ngs[1].setInstanceType(InstanceType.MEDIUM);
  StorageRead storage=new StorageRead();
  storage.setType(""String_Node_Str"");
  storage.setSizeGB(50);
  ngs[1].setStorage(storage);
  NodeGroupCreate ng2=new NodeGroupCreate();
  ngs[2]=ng2;
  List<String> computeNodeRoles=new ArrayList<String>();
  computeNodeRoles.add(""String_Node_Str"");
  ngs[2].setRoles(computeNodeRoles);
  ngs[2].setName(""String_Node_Str"");
  ngs[2].setInstanceNum(8);
  ngs[2].setInstanceType(InstanceType.MEDIUM);
  StorageRead storageCompute=new StorageRead();
  storageCompute.setType(""String_Node_Str"");
  storageCompute.setSizeGB(50);
  ngs[2].setStorage(storageCompute);
  PlacementPolicy policy=new PlacementPolicy();
  policy.setInstancePerHost(2);
  List<GroupAssociation> associates=new ArrayList<GroupAssociation>();
  GroupAssociation associate=new GroupAssociation();
  associate.setReference(""String_Node_Str"");
  associate.setType(GroupAssociationType.STRICT);
  associates.add(associate);
  policy.setGroupAssociations(associates);
  ngs[2].setPlacementPolicies(policy);
  spec.setNodeGroups(ngs);
  spec=ClusterSpecFactory.getCustomizedSpec(spec);
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findClusterById(1l);
  List<ClusterEntity> cs=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity c : cs) {
    System.out.println(c.getId());
  }
  cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
}","@Test(groups={""String_Node_Str""}) public void testClusterConfigWithTempfs() throws Exception {
  ClusterCreate spec=new ClusterCreate();
  spec.setName(""String_Node_Str"");
  List<String> rps=new ArrayList<String>();
  rps.add(""String_Node_Str"");
  spec.setRpNames(rps);
  spec.setNetworkConfig(createNetConfigs());
  spec.setDistro(""String_Node_Str"");
  spec.setDistroVendor(Constants.DEFAULT_VENDOR);
  NodeGroupCreate[] ngs=new NodeGroupCreate[3];
  NodeGroupCreate ng0=new NodeGroupCreate();
  ngs[0]=ng0;
  List<String> masterRoles=new ArrayList<String>();
  masterRoles.add(""String_Node_Str"");
  masterRoles.add(""String_Node_Str"");
  ngs[0].setRoles(masterRoles);
  ngs[0].setName(""String_Node_Str"");
  ngs[0].setInstanceNum(1);
  ngs[0].setCpuNum(2);
  ngs[0].setMemCapacityMB(7500);
  ngs[0].setInstanceType(InstanceType.LARGE);
  NodeGroupCreate ng1=new NodeGroupCreate();
  ngs[1]=ng1;
  List<String> dataNodeRoles=new ArrayList<String>();
  dataNodeRoles.add(""String_Node_Str"");
  ngs[1].setRoles(dataNodeRoles);
  ngs[1].setName(""String_Node_Str"");
  ngs[1].setInstanceNum(4);
  ngs[1].setCpuNum(2);
  ngs[1].setMemCapacityMB(7500);
  ngs[1].setInstanceType(InstanceType.MEDIUM);
  StorageRead storage=new StorageRead();
  storage.setType(""String_Node_Str"");
  storage.setSizeGB(50);
  ngs[1].setStorage(storage);
  NodeGroupCreate ng2=new NodeGroupCreate();
  ngs[2]=ng2;
  List<String> computeNodeRoles=new ArrayList<String>();
  computeNodeRoles.add(""String_Node_Str"");
  ngs[2].setRoles(computeNodeRoles);
  ngs[2].setName(""String_Node_Str"");
  ngs[2].setInstanceNum(8);
  ngs[2].setCpuNum(2);
  ngs[2].setMemCapacityMB(7500);
  ngs[2].setInstanceType(InstanceType.MEDIUM);
  StorageRead storageCompute=new StorageRead();
  storageCompute.setType(""String_Node_Str"");
  storageCompute.setSizeGB(50);
  ngs[2].setStorage(storageCompute);
  PlacementPolicy policy=new PlacementPolicy();
  policy.setInstancePerHost(2);
  List<GroupAssociation> associates=new ArrayList<GroupAssociation>();
  GroupAssociation associate=new GroupAssociation();
  associate.setReference(""String_Node_Str"");
  associate.setType(GroupAssociationType.STRICT);
  associates.add(associate);
  policy.setGroupAssociations(associates);
  ngs[2].setPlacementPolicies(policy);
  spec.setNodeGroups(ngs);
  spec=ClusterSpecFactory.getCustomizedSpec(spec);
  clusterConfigMgr.createClusterConfig(spec);
  ClusterEntity cluster=clusterEntityMgr.findClusterById(1l);
  List<ClusterEntity> cs=clusterEntityMgr.findAllClusters();
  for (  ClusterEntity c : cs) {
    System.out.println(c.getId());
  }
  cluster=clusterEntityMgr.findByName(""String_Node_Str"");
  Assert.assertTrue(cluster != null);
  ClusterCreate attrs=clusterConfigMgr.getClusterConfig(""String_Node_Str"");
  String manifest=gson.toJson(attrs);
  System.out.println(manifest);
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
  Assert.assertTrue(manifest.indexOf(""String_Node_Str"") != -1,""String_Node_Str"");
}"
48870,"public static void setNetworkSchema(ConfigSpecImpl spec,VcCluster cluster,NetworkSchema networkSchema,VcVirtualMachine vcVm) throws Exception {
  List<VirtualDeviceSpec> changes=new ArrayList<VirtualDeviceSpec>();
  for (  NetworkSchema.Network network : networkSchema.networks) {
    VcNetwork vN=cluster.getNetwork(network.vcNetwork);
    AuAssert.check(vN != null);
    VirtualDevice nic=null;
    if (network.nicLabel != null) {
      nic=vcVm.getDeviceByLabel(network.nicLabel);
      if (nic != null) {
        changes.add(VmConfigUtil.removeDeviceSpec(nic));
      }
    }
    VirtualDeviceSpec deviceSpec=VmConfigUtil.createNetworkDevice(VmConfigUtil.EthernetControllerType.VMXNET3,network.nicLabel,vN);
    changes.add(deviceSpec);
  }
  spec.setDeviceChange(changes.toArray(new VirtualDeviceSpec[changes.size()]));
}","public static void setNetworkSchema(ConfigSpecImpl spec,VcCluster cluster,NetworkSchema networkSchema,VcVirtualMachine vcVm) throws Exception {
  List<VirtualDeviceSpec> changes=new ArrayList<VirtualDeviceSpec>();
  for (  NetworkSchema.Network network : networkSchema.networks) {
    VcNetwork vN=cluster.getNetwork(network.vcNetwork);
    if (vN == null) {
      logger.error(""String_Node_Str"" + network.vcNetwork + ""String_Node_Str""+ cluster.getName());
      throw new Exception(""String_Node_Str"" + network.vcNetwork + ""String_Node_Str""+ cluster.getName());
    }
    VirtualDevice nic=null;
    if (network.nicLabel != null) {
      nic=vcVm.getDeviceByLabel(network.nicLabel);
      if (nic != null) {
        changes.add(VmConfigUtil.removeDeviceSpec(nic));
      }
    }
    VirtualDeviceSpec deviceSpec=VmConfigUtil.createNetworkDevice(VmConfigUtil.EthernetControllerType.VMXNET3,network.nicLabel,vN);
    changes.add(deviceSpec);
  }
  spec.setDeviceChange(changes.toArray(new VirtualDeviceSpec[changes.size()]));
}"
48871,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST,consumes=""String_Node_Str"") @ResponseStatus(HttpStatus.ACCEPTED) public void createCluster(@RequestBody ClusterCreate createSpec,HttpServletRequest request,HttpServletResponse response) throws Exception {
  String clusterName=createSpec.getName();
  if (!CommonUtil.validateClusterName(clusterName)) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
  }
  createSpec.validateNodeGroupNames();
  long jobExecutionId=clusterMgr.createCluster(createSpec);
  redirectRequest(jobExecutionId,request,response);
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.POST,consumes=""String_Node_Str"") @ResponseStatus(HttpStatus.ACCEPTED) public void createCluster(@RequestBody ClusterCreate createSpec,HttpServletRequest request,HttpServletResponse response) throws Exception {
  String clusterName=createSpec.getName();
  if (!CommonUtil.validateClusterName(clusterName)) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
  }
  long jobExecutionId=clusterMgr.createCluster(createSpec);
  redirectRequest(jobExecutionId,request,response);
}"
48872,"@JsonIgnore public boolean isSpecFile(){
  return specFile;
}","public Boolean isSpecFile(){
  return specFile;
}"
48873,"public void setSpecFile(boolean specFile){
  this.specFile=specFile;
}","public void setSpecFile(Boolean specFile){
  this.specFile=specFile;
}"
48874,"public ClusterCreate getClusterSpec(String clusterName){
  ClusterCreate spec=clusterConfigMgr.getClusterConfig(clusterName);
  spec.setVcClusters(null);
  spec.setTemplateId(null);
  spec.setDistroMap(null);
  spec.setSharedDatastorePattern(null);
  spec.setLocalDatastorePattern(null);
  spec.setNetworkings(null);
  spec.setRpNames(null);
  spec.setDsNames(null);
  spec.setNetworkConfig(null);
  spec.setName(null);
  spec.setDistro(null);
  spec.setValidateConfig(null);
  spec.setTopologyPolicy(null);
  spec.setHostToRackMap(null);
  spec.setHttpProxy(null);
  spec.setNoProxy(null);
  spec.setDistroVendor(null);
  spec.setDistroVersion(null);
  NodeGroupCreate[] groups=spec.getNodeGroups();
  if (groups != null) {
    for (    NodeGroupCreate group : groups) {
      group.setVcClusters(null);
      group.setGroupType(null);
      group.setRpNames(null);
      group.getStorage().setDsNames(null);
      group.getStorage().setImagestoreNamePattern(null);
      group.getStorage().setDiskstoreNamePattern(null);
      group.setVmFolderPath(null);
      group.getStorage().setSplitPolicy(null);
      group.getStorage().setControllerType(null);
      group.getStorage().setAllocType(null);
      if (group.getPlacementPolicies() != null) {
        List<GroupAssociation> associations=group.getPlacementPolicies().getGroupAssociations();
        if (associations != null && associations.isEmpty()) {
          group.getPlacementPolicies().setGroupAssociations(null);
        }
      }
    }
  }
  return spec;
}","public ClusterCreate getClusterSpec(String clusterName){
  ClusterCreate spec=clusterConfigMgr.getClusterConfig(clusterName);
  spec.setVcClusters(null);
  spec.setTemplateId(null);
  spec.setDistroMap(null);
  spec.setSharedDatastorePattern(null);
  spec.setLocalDatastorePattern(null);
  spec.setNetworkings(null);
  spec.setRpNames(null);
  spec.setDsNames(null);
  spec.setNetworkConfig(null);
  spec.setName(null);
  spec.setDistro(null);
  spec.setValidateConfig(null);
  spec.setSpecFile(null);
  spec.setTopologyPolicy(null);
  spec.setHostToRackMap(null);
  spec.setHttpProxy(null);
  spec.setNoProxy(null);
  spec.setDistroVendor(null);
  spec.setDistroVersion(null);
  NodeGroupCreate[] groups=spec.getNodeGroups();
  if (groups != null) {
    for (    NodeGroupCreate group : groups) {
      group.setVcClusters(null);
      group.setGroupType(null);
      group.setRpNames(null);
      group.getStorage().setDsNames(null);
      group.getStorage().setImagestoreNamePattern(null);
      group.getStorage().setDiskstoreNamePattern(null);
      group.setVmFolderPath(null);
      group.getStorage().setSplitPolicy(null);
      group.getStorage().setControllerType(null);
      group.getStorage().setAllocType(null);
      if (group.getPlacementPolicies() != null) {
        List<GroupAssociation> associations=group.getPlacementPolicies().getGroupAssociations();
        if (associations != null && associations.isEmpty()) {
          group.getPlacementPolicies().setGroupAssociations(null);
        }
      }
    }
  }
  return spec;
}"
48875,"public static VcProviderException MEMORY_EXCEED_LIMIT(long memory,long maxMemory,String vmName){
  return new VcProviderException(null,""String_Node_Str"",memory,maxMemory,vmName);
}","public static VcProviderException MEMORY_EXCEED_LIMIT(long maxMemory,String vmName){
  return new VcProviderException(null,""String_Node_Str"",maxMemory,vmName);
}"
48876,"public static VcProviderException CPU_EXCEED_LIMIT(int cpuNumber,int maxCpuNumber,String vmName){
  return new VcProviderException(null,""String_Node_Str"",cpuNumber,maxCpuNumber,vmName);
}","public static VcProviderException CPU_EXCEED_LIMIT(int cpuNumber,String vmName,int maxCpuNumber){
  return new VcProviderException(null,""String_Node_Str"",cpuNumber,vmName,maxCpuNumber);
}"
48877,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void modifyNetwork(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String ip){
  if (!validateIP(ip,Constants.OUTPUT_OP_MODIFY)) {
    return;
  }
  NetworkAdd networkAdd=new NetworkAdd();
  networkAdd.setName(name);
  try {
    networkAdd.setIp(transferIpInfo(ip));
    networkRestClient.increaseIPs(networkAdd);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_NETWORK,name,Constants.OUTPUT_OP_RESULT_MODIFY);
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_NETWORK,name,Constants.OUTPUT_OP_RESULT_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void modifyNetwork(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String ip){
  if (!validateIP(ip,Constants.OUTPUT_OP_MODIFY)) {
    return;
  }
  NetworkAdd networkAdd=new NetworkAdd();
  networkAdd.setName(name);
  try {
    networkAdd.setIp(transferIpInfo(ip));
    networkRestClient.increaseIPs(networkAdd);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_NETWORK,name,Constants.OUTPUT_OP_RESULT_MODIFY);
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_NETWORK,name,Constants.OUTPUT_OP_MODIFY,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}"
48878,"@Override @Transactional public synchronized NetworkEntity addDhcpNetwork(final String name,final String portGroup){
  if (!resService.isNetworkExistInVc(portGroup)) {
    throw VcProviderException.NETWORK_NOT_FOUND(portGroup);
  }
  try {
    NetworkEntity network=new NetworkEntity(name,portGroup,AllocType.DHCP,null,null,null,null);
    networkDao.insert(network);
    network.validate();
    return network;
  }
 catch (  UniqueConstraintViolationException ex) {
    logger.error(""String_Node_Str"");
    throw BddException.ALREADY_EXISTS(ex,""String_Node_Str"",name);
  }
}","@Override @Transactional public synchronized NetworkEntity addDhcpNetwork(final String name,final String portGroup){
  validateNetworkName(name);
  if (!resService.isNetworkExistInVc(portGroup)) {
    throw VcProviderException.NETWORK_NOT_FOUND(portGroup);
  }
  try {
    NetworkEntity network=new NetworkEntity(name,portGroup,AllocType.DHCP,null,null,null,null);
    networkDao.insert(network);
    network.validate();
    return network;
  }
 catch (  UniqueConstraintViolationException ex) {
    logger.error(""String_Node_Str"");
    throw BddException.ALREADY_EXISTS(ex,""String_Node_Str"",name);
  }
}"
48879,"@Override @Transactional public synchronized NetworkEntity addIpPoolNetwork(final String name,final String portGroup,final String netmask,final String gateway,final String dns1,final String dns2,final List<IpBlock> ipBlocks){
  try {
    if (!resService.isNetworkExistInVc(portGroup)) {
      throw VcProviderException.NETWORK_NOT_FOUND(portGroup);
    }
    NetworkEntity network=new NetworkEntity(name,portGroup,AllocType.IP_POOL,netmask,gateway,dns1,dns2);
    networkDao.insert(network);
    List<IpBlockEntity> blocks=new ArrayList<IpBlockEntity>(ipBlocks.size());
    for (    IpBlock ib : ipBlocks) {
      IpBlockEntity blk=new IpBlockEntity(null,IpBlockEntity.FREE_BLOCK_OWNER_ID,BlockType.FREE,IpAddressUtil.getAddressAsLong(ib.getBeginIp()),IpAddressUtil.getAddressAsLong(ib.getEndIp()));
      blocks.add(blk);
    }
    networkDao.addIpBlocks(network,blocks);
    network.validate();
    return network;
  }
 catch (  UniqueConstraintViolationException ex) {
    logger.error(""String_Node_Str"");
    throw BddException.ALREADY_EXISTS(ex,""String_Node_Str"",name);
  }
}","@Override @Transactional public synchronized NetworkEntity addIpPoolNetwork(final String name,final String portGroup,final String netmask,final String gateway,final String dns1,final String dns2,final List<IpBlock> ipBlocks){
  try {
    validateNetworkName(name);
    if (!resService.isNetworkExistInVc(portGroup)) {
      throw VcProviderException.NETWORK_NOT_FOUND(portGroup);
    }
    NetworkEntity network=new NetworkEntity(name,portGroup,AllocType.IP_POOL,netmask,gateway,dns1,dns2);
    networkDao.insert(network);
    List<IpBlockEntity> blocks=new ArrayList<IpBlockEntity>(ipBlocks.size());
    for (    IpBlock ib : ipBlocks) {
      IpBlockEntity blk=new IpBlockEntity(null,IpBlockEntity.FREE_BLOCK_OWNER_ID,BlockType.FREE,IpAddressUtil.getAddressAsLong(ib.getBeginIp()),IpAddressUtil.getAddressAsLong(ib.getEndIp()));
      blocks.add(blk);
    }
    networkDao.addIpBlocks(network,blocks);
    network.validate();
    return network;
  }
 catch (  UniqueConstraintViolationException ex) {
    logger.error(""String_Node_Str"");
    throw BddException.ALREADY_EXISTS(ex,""String_Node_Str"",name);
  }
}"
48880,"@Test(groups={""String_Node_Str""}) public void deleteNetwork(){
  new Expectations(){
{
      resService.isNetworkExistInVc(anyString);
      result=true;
    }
  }
;
  networkSvc.setResService(resService);
  networkSvc.setNetworkDao(networkDao);
  networkSvc.setClusterDAO(clusterDAO);
  networkSvc.addDhcpNetwork(""String_Node_Str"",""String_Node_Str"");
  new Verifications(){
{
      networkDao.insert(withAny(new NetworkEntity()));
    }
  }
;
  new Expectations(){
{
      NetworkEntity network=new NetworkEntity();
      network.setIpBlocks(new ArrayList<IpBlockEntity>());
      networkDao.findNetworkByName(anyString);
      result=network;
      networkDao.delete(withAny(network));
    }
  }
;
  networkSvc.removeNetwork(""String_Node_Str"");
}","@Test(groups={""String_Node_Str""}) public void deleteNetwork(){
  new Expectations(){
{
      resService.isNetworkExistInVc(anyString);
      result=true;
    }
  }
;
  networkSvc.setResService(resService);
  networkSvc.setNetworkDao(networkDao);
  networkSvc.setClusterDAO(clusterDAO);
  networkSvc.addDhcpNetwork(""String_Node_Str"",""String_Node_Str"");
  new Verifications(){
{
      networkDao.insert(withAny(new NetworkEntity()));
    }
  }
;
  new Expectations(){
{
      NetworkEntity network=new NetworkEntity();
      network.setIpBlocks(new ArrayList<IpBlockEntity>());
      networkDao.findNetworkByName(""String_Node_Str"");
      result=network;
      networkDao.delete(withAny(network));
    }
  }
;
  networkSvc.removeNetwork(""String_Node_Str"");
}"
48881,"public Long createCluster(ClusterCreate createSpec) throws Exception {
  if (CommonUtil.isBlank(createSpec.getDistro())) {
    setDefaultDistro(createSpec);
  }
  DistroRead distroRead=getDistroManager().getDistroByName(createSpec.getDistro());
  createSpec.setDistroVendor(distroRead.getVendor());
  createSpec.setDistroVersion(distroRead.getVersion());
  createAutoRps(createSpec);
  ClusterCreate clusterSpec=ClusterSpecFactory.getCustomizedSpec(createSpec);
  if (clusterSpec != null && clusterSpec.getNodeGroups() != null) {
    for (    NodeGroupCreate ng : clusterSpec.getNodeGroups()) {
      String templateVmId=clusteringService.getTemplateVmId();
      if (templateVmId != null) {
        VcResourceUtils.checkVmMaxConfiguration(templateVmId,ng.getCpuNum(),ng.getMemCapacityMB());
      }
    }
  }
  String name=clusterSpec.getName();
  logger.info(""String_Node_Str"" + name);
  List<String> dsNames=getUsedDS(clusterSpec.getDsNames());
  if (dsNames.isEmpty()) {
    throw ClusterConfigException.NO_DATASTORE_ADDED();
  }
  List<VcCluster> vcClusters=getUsedVcClusters(clusterSpec.getRpNames());
  if (vcClusters == null || vcClusters.isEmpty()) {
    throw ClusterConfigException.NO_RESOURCE_POOL_ADDED();
  }
  validateDatastore(dsNames,vcClusters);
  validateNetworkAccessibility(createSpec.getNetworkNames(),vcClusters);
  clusterConfigMgr.createClusterConfig(clusterSpec);
  clusterEntityMgr.updateClusterStatus(name,ClusterStatus.PROVISIONING);
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.PROVISION_ERROR.name()));
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(createSpec.getName()));
  param.put(JobConstants.VERIFY_NODE_STATUS_SCOPE_PARAM,new JobParameter(JobConstants.CLUSTER_NODE_SCOPE_VALUE));
  JobParameters jobParameters=new JobParameters(param);
  return jobManager.runJob(JobConstants.CREATE_CLUSTER_JOB_NAME,jobParameters);
}","public Long createCluster(ClusterCreate createSpec) throws Exception {
  if (CommonUtil.isBlank(createSpec.getDistro())) {
    setDefaultDistro(createSpec);
  }
  DistroRead distroRead=getDistroManager().getDistroByName(createSpec.getDistro());
  createSpec.setDistroVendor(distroRead.getVendor());
  createSpec.setDistroVersion(distroRead.getVersion());
  createAutoRps(createSpec);
  ClusterCreate clusterSpec=ClusterSpecFactory.getCustomizedSpec(createSpec);
  clusterSpec.validateNodeGroupNames();
  if (clusterSpec != null && clusterSpec.getNodeGroups() != null) {
    for (    NodeGroupCreate ng : clusterSpec.getNodeGroups()) {
      String templateVmId=clusteringService.getTemplateVmId();
      if (templateVmId != null) {
        VcResourceUtils.checkVmMaxConfiguration(templateVmId,ng.getCpuNum(),ng.getMemCapacityMB());
      }
    }
  }
  String name=clusterSpec.getName();
  logger.info(""String_Node_Str"" + name);
  List<String> dsNames=getUsedDS(clusterSpec.getDsNames());
  if (dsNames.isEmpty()) {
    throw ClusterConfigException.NO_DATASTORE_ADDED();
  }
  List<VcCluster> vcClusters=getUsedVcClusters(clusterSpec.getRpNames());
  if (vcClusters == null || vcClusters.isEmpty()) {
    throw ClusterConfigException.NO_RESOURCE_POOL_ADDED();
  }
  validateDatastore(dsNames,vcClusters);
  validateNetworkAccessibility(createSpec.getNetworkNames(),vcClusters);
  clusterConfigMgr.createClusterConfig(clusterSpec);
  clusterEntityMgr.updateClusterStatus(name,ClusterStatus.PROVISIONING);
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.PROVISION_ERROR.name()));
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(createSpec.getName()));
  param.put(JobConstants.VERIFY_NODE_STATUS_SCOPE_PARAM,new JobParameter(JobConstants.CLUSTER_NODE_SCOPE_VALUE));
  JobParameters jobParameters=new JobParameters(param);
  return jobManager.runJob(JobConstants.CREATE_CLUSTER_JOB_NAME,jobParameters);
}"
48882,"private Map<String,Integer> collectResourcePoolInfo(List<BaseNode> vNodes,Map<String,List<String>> vcClusterRpNamesMap,Map<Long,List<NodeGroupCreate>> rpNodeGroupsMap){
  List<String> resourcePoolNames=null;
  List<NodeGroupCreate> nodeGroups=null;
  int resourcePoolNameCount=0;
  int nodeGroupNameCount=0;
  for (  BaseNode baseNode : vNodes) {
    String vcCluster=baseNode.getTargetVcCluster();
    VcCluster cluster=VcResourceUtils.findVcCluster(vcCluster);
    if (!cluster.getConfig().getDRSEnabled()) {
      logger.debug(""String_Node_Str"" + vcCluster + ""String_Node_Str"");
      continue;
    }
    AuAssert.check(!CommonUtil.isBlank(vcCluster),""String_Node_Str"");
    if (!vcClusterRpNamesMap.containsKey(vcCluster)) {
      resourcePoolNames=new ArrayList<String>();
    }
 else {
      resourcePoolNames=vcClusterRpNamesMap.get(vcCluster);
    }
    String vcRp=baseNode.getTargetRp();
    long rpHashCode=vcCluster.hashCode() ^ (vcCluster + vcRp).hashCode();
    if (!rpNodeGroupsMap.containsKey(rpHashCode)) {
      nodeGroups=new ArrayList<NodeGroupCreate>();
    }
 else {
      nodeGroups=rpNodeGroupsMap.get(rpHashCode);
    }
    NodeGroupCreate nodeGroup=baseNode.getNodeGroup();
    if (!getAllNodeGroupNames(nodeGroups).contains(nodeGroup.getName())) {
      nodeGroups.add(nodeGroup);
      rpNodeGroupsMap.put(rpHashCode,nodeGroups);
      nodeGroupNameCount++;
    }
    if (!resourcePoolNames.contains(vcRp)) {
      resourcePoolNames.add(vcRp);
      vcClusterRpNamesMap.put(vcCluster,resourcePoolNames);
      resourcePoolNameCount++;
    }
  }
  Map<String,Integer> countResult=new HashMap<String,Integer>();
  countResult.put(""String_Node_Str"",resourcePoolNameCount);
  countResult.put(""String_Node_Str"",nodeGroupNameCount);
  return countResult;
}","private Map<String,Integer> collectResourcePoolInfo(List<BaseNode> vNodes,final String uuid,Map<String,List<String>> vcClusterRpNamesMap,Map<Long,List<NodeGroupCreate>> rpNodeGroupsMap){
  List<String> resourcePoolNames=null;
  List<NodeGroupCreate> nodeGroups=null;
  int resourcePoolNameCount=0;
  int nodeGroupNameCount=0;
  for (  BaseNode baseNode : vNodes) {
    String vcCluster=baseNode.getTargetVcCluster();
    VcCluster cluster=VcResourceUtils.findVcCluster(vcCluster);
    if (!cluster.getConfig().getDRSEnabled()) {
      logger.debug(""String_Node_Str"" + vcCluster + ""String_Node_Str"");
      continue;
    }
    AuAssert.check(!CommonUtil.isBlank(vcCluster),""String_Node_Str"");
    if (!vcClusterRpNamesMap.containsKey(vcCluster)) {
      resourcePoolNames=new ArrayList<String>();
    }
 else {
      resourcePoolNames=vcClusterRpNamesMap.get(vcCluster);
    }
    String vcRp=baseNode.getTargetRp();
    String rpPath=""String_Node_Str"" + vcCluster + ""String_Node_Str""+ vcRp+ ""String_Node_Str""+ uuid;
    long rpHashCode=rpPath.hashCode();
    if (!rpNodeGroupsMap.containsKey(rpHashCode)) {
      nodeGroups=new ArrayList<NodeGroupCreate>();
    }
 else {
      nodeGroups=rpNodeGroupsMap.get(rpHashCode);
    }
    NodeGroupCreate nodeGroup=baseNode.getNodeGroup();
    if (!getAllNodeGroupNames(nodeGroups).contains(nodeGroup.getName())) {
      nodeGroups.add(nodeGroup);
      rpNodeGroupsMap.put(rpHashCode,nodeGroups);
      nodeGroupNameCount++;
    }
    if (!resourcePoolNames.contains(vcRp)) {
      resourcePoolNames.add(vcRp);
      vcClusterRpNamesMap.put(vcCluster,resourcePoolNames);
      resourcePoolNameCount++;
    }
  }
  Map<String,Integer> countResult=new HashMap<String,Integer>();
  countResult.put(""String_Node_Str"",resourcePoolNameCount);
  countResult.put(""String_Node_Str"",nodeGroupNameCount);
  return countResult;
}"
48883,"private String createVcResourcePools(List<BaseNode> vNodes){
  logger.info(""String_Node_Str"");
  String clusterName=vNodes.get(0).getClusterName();
  String uuid=ConfigInfo.getSerengetiUUID();
  String clusterRpName=uuid + ""String_Node_Str"" + clusterName;
  if (clusterRpName.length() > VC_RP_MAX_NAME_LENGTH) {
    throw ClusteringServiceException.CLUSTER_NAME_TOO_LONG(clusterName);
  }
  Map<String,List<String>> vcClusterRpNamesMap=new HashMap<String,List<String>>();
  Map<Long,List<NodeGroupCreate>> rpNodeGroupsMap=new HashMap<Long,List<NodeGroupCreate>>();
  Map<String,Integer> countResult=collectResourcePoolInfo(vNodes,vcClusterRpNamesMap,rpNodeGroupsMap);
  try {
    int resourcePoolNameCount=countResult.get(""String_Node_Str"");
    Callable<Void>[] clusterSPs=new Callable[resourcePoolNameCount];
    int i=0;
    for (    Entry<String,List<String>> vcClusterRpNamesEntry : vcClusterRpNamesMap.entrySet()) {
      String vcClusterName=vcClusterRpNamesEntry.getKey();
      VcCluster vcCluster=VcResourceUtils.findVcCluster(vcClusterName);
      if (vcCluster == null) {
        String errorMsg=""String_Node_Str"" + vcClusterName + ""String_Node_Str"";
        logger.error(errorMsg);
        throw BddException.INTERNAL(null,errorMsg);
      }
      List<String> resourcePoolNames=vcClusterRpNamesEntry.getValue();
      for (      String resourcePoolName : resourcePoolNames) {
        VcResourcePool parentVcResourcePool=VcResourceUtils.findRPInVCCluster(vcClusterName,resourcePoolName);
        if (parentVcResourcePool == null) {
          String errorMsg=""String_Node_Str"" + resourcePoolName + ""String_Node_Str"";
          logger.error(errorMsg);
          throw BddException.INTERNAL(null,errorMsg);
        }
        CreateResourcePoolSP clusterSP=new CreateResourcePoolSP(parentVcResourcePool,clusterRpName);
        clusterSPs[i]=clusterSP;
        i++;
      }
    }
    logger.info(""String_Node_Str"");
    executeResourcePoolStoreProcedures(clusterSPs,""String_Node_Str"",clusterName);
    int nodeGroupNameCount=countResult.get(""String_Node_Str"");
    Callable<Void>[] nodeGroupSPs=new Callable[nodeGroupNameCount];
    i=0;
    for (    Entry<String,List<String>> vcClusterRpNamesEntry : vcClusterRpNamesMap.entrySet()) {
      String vcClusterName=vcClusterRpNamesEntry.getKey();
      VcCluster vcCluster=VcResourceUtils.findVcCluster(vcClusterName);
      if (vcCluster == null) {
        String errorMsg=""String_Node_Str"" + vcClusterName + ""String_Node_Str"";
        logger.error(errorMsg);
        throw BddException.INTERNAL(null,errorMsg);
      }
      if (!vcCluster.getConfig().getDRSEnabled()) {
        continue;
      }
      List<String> resourcePoolNames=vcClusterRpNamesEntry.getValue();
      for (      String resourcePoolName : resourcePoolNames) {
        VcResourcePool parentVcResourcePool=null;
        String vcRPName=CommonUtil.isBlank(resourcePoolName) ? clusterRpName : resourcePoolName + ""String_Node_Str"" + clusterRpName;
        parentVcResourcePool=VcResourceUtils.findRPInVCCluster(vcClusterName,vcRPName);
        if (parentVcResourcePool == null) {
          String errorMsg=""String_Node_Str"" + vcRPName + (CommonUtil.isBlank(resourcePoolName) ? ""String_Node_Str"" : ""String_Node_Str"" + resourcePoolName)+ ""String_Node_Str"";
          logger.error(errorMsg);
          throw BddException.INTERNAL(null,errorMsg);
        }
        long rpHashCode=vcClusterName.hashCode() ^ (vcClusterName + resourcePoolName).hashCode();
        for (        NodeGroupCreate nodeGroup : rpNodeGroupsMap.get(rpHashCode)) {
          AuAssert.check(nodeGroup != null,""String_Node_Str"");
          if (nodeGroup.getName().length() > 80) {
            throw ClusteringServiceException.GROUP_NAME_TOO_LONG(nodeGroup.getName());
          }
          CreateResourcePoolSP nodeGroupSP=new CreateResourcePoolSP(parentVcResourcePool,nodeGroup.getName(),nodeGroup);
          nodeGroupSPs[i]=nodeGroupSP;
          i++;
        }
      }
    }
    logger.info(""String_Node_Str"");
    executeResourcePoolStoreProcedures(nodeGroupSPs,""String_Node_Str"",clusterName);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
  return clusterRpName;
}","private String createVcResourcePools(List<BaseNode> vNodes){
  logger.info(""String_Node_Str"");
  String clusterName=vNodes.get(0).getClusterName();
  String uuid=ConfigInfo.getSerengetiUUID();
  String clusterRpName=uuid + ""String_Node_Str"" + clusterName;
  if (clusterRpName.length() > VC_RP_MAX_NAME_LENGTH) {
    throw ClusteringServiceException.CLUSTER_NAME_TOO_LONG(clusterName);
  }
  Map<String,List<String>> vcClusterRpNamesMap=new HashMap<String,List<String>>();
  Map<Long,List<NodeGroupCreate>> rpNodeGroupsMap=new HashMap<Long,List<NodeGroupCreate>>();
  Map<String,Integer> countResult=collectResourcePoolInfo(vNodes,uuid,vcClusterRpNamesMap,rpNodeGroupsMap);
  try {
    int resourcePoolNameCount=countResult.get(""String_Node_Str"");
    Callable<Void>[] clusterSPs=new Callable[resourcePoolNameCount];
    int i=0;
    for (    Entry<String,List<String>> vcClusterRpNamesEntry : vcClusterRpNamesMap.entrySet()) {
      String vcClusterName=vcClusterRpNamesEntry.getKey();
      VcCluster vcCluster=VcResourceUtils.findVcCluster(vcClusterName);
      if (vcCluster == null) {
        String errorMsg=""String_Node_Str"" + vcClusterName + ""String_Node_Str"";
        logger.error(errorMsg);
        throw BddException.INTERNAL(null,errorMsg);
      }
      List<String> resourcePoolNames=vcClusterRpNamesEntry.getValue();
      for (      String resourcePoolName : resourcePoolNames) {
        VcResourcePool parentVcResourcePool=VcResourceUtils.findRPInVCCluster(vcClusterName,resourcePoolName);
        if (parentVcResourcePool == null) {
          String errorMsg=""String_Node_Str"" + resourcePoolName + ""String_Node_Str"";
          logger.error(errorMsg);
          throw BddException.INTERNAL(null,errorMsg);
        }
        CreateResourcePoolSP clusterSP=new CreateResourcePoolSP(parentVcResourcePool,clusterRpName);
        clusterSPs[i]=clusterSP;
        i++;
      }
    }
    logger.info(""String_Node_Str"");
    executeResourcePoolStoreProcedures(clusterSPs,""String_Node_Str"",clusterName);
    int nodeGroupNameCount=countResult.get(""String_Node_Str"");
    Callable<Void>[] nodeGroupSPs=new Callable[nodeGroupNameCount];
    i=0;
    for (    Entry<String,List<String>> vcClusterRpNamesEntry : vcClusterRpNamesMap.entrySet()) {
      String vcClusterName=vcClusterRpNamesEntry.getKey();
      VcCluster vcCluster=VcResourceUtils.findVcCluster(vcClusterName);
      if (vcCluster == null) {
        String errorMsg=""String_Node_Str"" + vcClusterName + ""String_Node_Str"";
        logger.error(errorMsg);
        throw BddException.INTERNAL(null,errorMsg);
      }
      if (!vcCluster.getConfig().getDRSEnabled()) {
        continue;
      }
      List<String> resourcePoolNames=vcClusterRpNamesEntry.getValue();
      for (      String resourcePoolName : resourcePoolNames) {
        VcResourcePool parentVcResourcePool=null;
        String vcRPName=CommonUtil.isBlank(resourcePoolName) ? clusterRpName : resourcePoolName + ""String_Node_Str"" + clusterRpName;
        parentVcResourcePool=VcResourceUtils.findRPInVCCluster(vcClusterName,vcRPName);
        if (parentVcResourcePool == null) {
          String errorMsg=""String_Node_Str"" + vcRPName + (CommonUtil.isBlank(resourcePoolName) ? ""String_Node_Str"" : ""String_Node_Str"" + resourcePoolName)+ ""String_Node_Str"";
          logger.error(errorMsg);
          throw BddException.INTERNAL(null,errorMsg);
        }
        String rpPath=""String_Node_Str"" + vcClusterName + ""String_Node_Str""+ resourcePoolName+ ""String_Node_Str""+ uuid;
        long rpHashCode=rpPath.hashCode();
        for (        NodeGroupCreate nodeGroup : rpNodeGroupsMap.get(rpHashCode)) {
          AuAssert.check(nodeGroup != null,""String_Node_Str"");
          if (nodeGroup.getName().length() > 80) {
            throw ClusteringServiceException.GROUP_NAME_TOO_LONG(nodeGroup.getName());
          }
          CreateResourcePoolSP nodeGroupSP=new CreateResourcePoolSP(parentVcResourcePool,nodeGroup.getName(),nodeGroup);
          nodeGroupSPs[i]=nodeGroupSP;
          i++;
        }
      }
    }
    logger.info(""String_Node_Str"");
    executeResourcePoolStoreProcedures(nodeGroupSPs,""String_Node_Str"",clusterName);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
  return clusterRpName;
}"
48884,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String hdfsNetworkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String mapredNetworkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String topology,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean alwaysAnswerYes,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean setClusterPassword){
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
 else   if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_BLANK_SPACE);
    return;
  }
  if (resume && setClusterPassword) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.RESUME_DONOT_NEED_SET_PASSWORD);
    return;
  }
 else   if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (setClusterPassword) {
    String password=getPassword();
    if (password == null) {
      return;
    }
 else {
      clusterCreate.setPassword(password);
    }
  }
  if (type != null) {
    ClusterType clusterType=ClusterType.getByDescription(type);
    if (clusterType == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ type);
      return;
    }
    clusterCreate.setType(clusterType);
  }
 else   if (specFilePath == null) {
    clusterCreate.setType(ClusterType.HDFS_MAPRED);
  }
  if (topology != null) {
    try {
      clusterCreate.setTopologyPolicy(TopologyType.valueOf(topology));
    }
 catch (    IllegalArgumentException ex) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ topology);
      return;
    }
  }
 else {
    clusterCreate.setTopologyPolicy(TopologyType.NONE);
  }
  try {
    if (distro != null) {
      List<String> distroNames=getDistroNames();
      if (validName(distro,distroNames)) {
        clusterCreate.setDistro(distro);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
        return;
      }
    }
 else {
      String defaultDistroName=clusterCreate.getDefaultDistroName(distroRestClient.getAll());
      if (CommandsUtils.isBlank(defaultDistroName)) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM__NO_DEFAULT_DISTRO);
        return;
      }
 else {
        clusterCreate.setDistro(defaultDistroName);
      }
    }
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  DistroRead distroRead=distroRestClient.get(clusterCreate.getDistro());
  clusterCreate.setDistroVendor(distroRead.getVendor());
  clusterCreate.setDistroVersion(distroRead.getVersion());
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  Set<String> allNetworkNames=new HashSet<String>();
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setSpecFile(true);
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
      clusterCreate.validateNodeGroupNames();
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
    }
    allNetworkNames=getAllNetworkNames();
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  if (allNetworkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CANNOT_FIND_NETWORK);
    return;
  }
  Map<NetTrafficType,List<String>> networkConfig=new HashMap<NetTrafficType,List<String>>();
  if (networkName == null) {
    if (allNetworkNames.size() == 1) {
      networkConfig.put(NetTrafficType.MGT_NETWORK,new ArrayList<String>());
      networkConfig.get(NetTrafficType.MGT_NETWORK).addAll(allNetworkNames);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
      return;
    }
  }
 else {
    if (!allNetworkNames.contains(networkName) || (hdfsNetworkName != null && !allNetworkNames.contains(hdfsNetworkName)) || (mapredNetworkName != null && !allNetworkNames.contains(mapredNetworkName))) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + allNetworkNames.toString());
      return;
    }
    networkConfig.put(NetTrafficType.MGT_NETWORK,new ArrayList<String>());
    networkConfig.get(NetTrafficType.MGT_NETWORK).add(networkName);
    if (hdfsNetworkName != null) {
      networkConfig.put(NetTrafficType.HDFS_NETWORK,new ArrayList<String>());
      networkConfig.get(NetTrafficType.HDFS_NETWORK).add(hdfsNetworkName);
    }
    if (mapredNetworkName != null) {
      networkConfig.put(NetTrafficType.MAPRED_NETWORK,new ArrayList<String>());
      networkConfig.get(NetTrafficType.MAPRED_NETWORK).add(mapredNetworkName);
    }
  }
  notifyNetsUsage(networkConfig,warningMsgList);
  clusterCreate.setNetworkConfig(networkConfig);
  clusterCreate.validateCDHVersion(warningMsgList);
  if (specFilePath != null && !clusterCreate.getDistro().equalsIgnoreCase(com.vmware.bdd.utils.Constants.MAPR_VENDOR)) {
    List<String> distroRoles=findDistroRoles(clusterCreate);
    clusterCreate.validateClusterCreate(failedMsgList,warningMsgList,distroRoles);
  }
  if (type != null && specFilePath != null) {
    warningMsgList.add(Constants.TYPE_SPECFILE_CONFLICT);
  }
  if (!failedMsgList.isEmpty()) {
    showFailedMsg(clusterCreate.getName(),failedMsgList);
    return;
  }
  try {
    if (!CommandsUtils.showWarningMsg(clusterCreate.getName(),Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,warningMsgList,alwaysAnswerYes)) {
      return;
    }
    restClient.create(clusterCreate);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,CommandsUtils.getExceptionMessage(e));
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String hdfsNetworkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String mapredNetworkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String topology,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean alwaysAnswerYes,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean setClusterPassword){
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
 else   if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_BLANK_SPACE);
    return;
  }
  if (resume && setClusterPassword) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.RESUME_DONOT_NEED_SET_PASSWORD);
    return;
  }
 else   if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (setClusterPassword) {
    String password=getPassword();
    if (password == null) {
      return;
    }
 else {
      clusterCreate.setPassword(password);
    }
  }
  if (type != null) {
    ClusterType clusterType=ClusterType.getByDescription(type);
    if (clusterType == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ type);
      return;
    }
    clusterCreate.setType(clusterType);
  }
 else   if (specFilePath == null) {
    clusterCreate.setType(ClusterType.HDFS_MAPRED);
  }
  if (topology != null) {
    try {
      clusterCreate.setTopologyPolicy(TopologyType.valueOf(topology));
    }
 catch (    IllegalArgumentException ex) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ topology);
      return;
    }
  }
 else {
    clusterCreate.setTopologyPolicy(TopologyType.NONE);
  }
  try {
    if (distro != null) {
      List<String> distroNames=getDistroNames();
      if (validName(distro,distroNames)) {
        clusterCreate.setDistro(distro);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
        return;
      }
    }
 else {
      String defaultDistroName=clusterCreate.getDefaultDistroName(distroRestClient.getAll());
      if (CommandsUtils.isBlank(defaultDistroName)) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM__NO_DEFAULT_DISTRO);
        return;
      }
 else {
        clusterCreate.setDistro(defaultDistroName);
      }
    }
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  DistroRead distroRead=distroRestClient.get(clusterCreate.getDistro());
  clusterCreate.setDistroVendor(distroRead.getVendor());
  clusterCreate.setDistroVersion(distroRead.getVersion());
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  Set<String> allNetworkNames=new HashSet<String>();
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setSpecFile(true);
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
      clusterCreate.validateNodeGroupNames();
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
    }
    allNetworkNames=getAllNetworkNames();
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  if (allNetworkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CANNOT_FIND_NETWORK);
    return;
  }
  Map<NetTrafficType,List<String>> networkConfig=new HashMap<NetTrafficType,List<String>>();
  if (networkName == null) {
    if (allNetworkNames.size() == 1) {
      networkConfig.put(NetTrafficType.MGT_NETWORK,new ArrayList<String>());
      networkConfig.get(NetTrafficType.MGT_NETWORK).addAll(allNetworkNames);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
      return;
    }
  }
 else {
    if (!allNetworkNames.contains(networkName) || (hdfsNetworkName != null && !allNetworkNames.contains(hdfsNetworkName)) || (mapredNetworkName != null && !allNetworkNames.contains(mapredNetworkName))) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + allNetworkNames.toString());
      return;
    }
    networkConfig.put(NetTrafficType.MGT_NETWORK,new ArrayList<String>());
    networkConfig.get(NetTrafficType.MGT_NETWORK).add(networkName);
    if (hdfsNetworkName != null) {
      networkConfig.put(NetTrafficType.HDFS_NETWORK,new ArrayList<String>());
      networkConfig.get(NetTrafficType.HDFS_NETWORK).add(hdfsNetworkName);
    }
    if (mapredNetworkName != null) {
      networkConfig.put(NetTrafficType.MAPRED_NETWORK,new ArrayList<String>());
      networkConfig.get(NetTrafficType.MAPRED_NETWORK).add(mapredNetworkName);
    }
  }
  notifyNetsUsage(networkConfig,warningMsgList);
  clusterCreate.setNetworkConfig(networkConfig);
  clusterCreate.validateCDHVersion(warningMsgList);
  if (specFilePath != null) {
    List<String> distroRoles=findDistroRoles(clusterCreate);
    if (!clusterCreate.getDistro().equalsIgnoreCase(com.vmware.bdd.utils.Constants.MAPR_VENDOR)) {
      clusterCreate.validateClusterCreate(failedMsgList,warningMsgList,distroRoles);
    }
 else {
      clusterCreate.validateClusterCreateOfMapr(failedMsgList,distroRoles);
    }
  }
  if (type != null && specFilePath != null) {
    warningMsgList.add(Constants.TYPE_SPECFILE_CONFLICT);
  }
  if (!failedMsgList.isEmpty()) {
    showFailedMsg(clusterCreate.getName(),failedMsgList);
    return;
  }
  try {
    if (!CommandsUtils.showWarningMsg(clusterCreate.getName(),Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,warningMsgList,alwaysAnswerYes)) {
      return;
    }
    restClient.create(clusterCreate);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,CommandsUtils.getExceptionMessage(e));
  }
}"
48885,"@Transactional public ClusterEntity createClusterConfig(ClusterCreate cluster){
  String name=cluster.getName();
  if (name == null || name.isEmpty()) {
    throw ClusterConfigException.CLUSTER_NAME_MISSING();
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  if (cluster.getDistro() == null || distroMgr.getDistroByName(cluster.getDistro()) == null) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",cluster.getDistro());
  }
  if (!cluster.getDistroVendor().equalsIgnoreCase(Constants.MAPR_VENDOR)) {
    List<String> allNetworkNames=new ArrayList<String>();
    for (    NetworkEntity entity : networkMgr.getAllNetworkEntities()) {
      allNetworkNames.add(entity.getName());
    }
    cluster.validateClusterCreate(failedMsgList,warningMsgList,distroMgr.getDistroByName(cluster.getDistro()).getRoles());
  }
  if (!failedMsgList.isEmpty()) {
    throw ClusterConfigException.INVALID_SPEC(failedMsgList);
  }
  if (!validateRacksInfo(cluster,failedMsgList)) {
    throw ClusterConfigException.INVALID_PLACEMENT_POLICIES(failedMsgList);
  }
  transformHDFSUrl(cluster);
  try {
    ClusterEntity entity=clusterEntityMgr.findByName(name);
    if (entity != null) {
      logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
      throw BddException.ALREADY_EXISTS(""String_Node_Str"",name);
    }
    logger.debug(""String_Node_Str"" + name);
    Gson gson=new Gson();
    ClusterEntity clusterEntity=new ClusterEntity(name);
    clusterEntity.setDistro(cluster.getDistro());
    clusterEntity.setDistroVendor(cluster.getDistroVendor());
    clusterEntity.setDistroVersion(cluster.getDistroVersion());
    clusterEntity.setStartAfterDeploy(true);
    clusterEntity.setPassword(cluster.getPassword());
    if (cluster.containsComputeOnlyNodeGroups()) {
      clusterEntity.setAutomationEnable(automationEnable);
    }
 else {
      clusterEntity.setAutomationEnable(null);
    }
    clusterEntity.setVhmMinNum(-1);
    clusterEntity.setVhmMaxNum(-1);
    if (cluster.getRpNames() != null && cluster.getRpNames().size() > 0) {
      logger.debug(""String_Node_Str"" + cluster.getRpNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcRpNameList(cluster.getRpNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    if (cluster.getDsNames() != null && !cluster.getDsNames().isEmpty()) {
      logger.debug(""String_Node_Str"" + cluster.getDsNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcDatastoreNameList(cluster.getDsNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    clusterEntity.setNetworkConfig(convertNetNamesToNetConfigs(cluster.getNetworkConfig()));
    clusterEntity.setVhmJobTrackerPort(""String_Node_Str"");
    if (cluster.getConfiguration() != null && cluster.getConfiguration().size() > 0) {
      CommonClusterExpandPolicy.validateAppConfig(cluster.getConfiguration(),cluster.isValidateConfig());
      clusterEntity.setHadoopConfig((new Gson()).toJson(cluster.getConfiguration()));
      updateVhmJobTrackerPort(cluster,clusterEntity);
    }
    NodeGroupCreate[] groups=cluster.getNodeGroups();
    if (groups != null && groups.length > 0) {
      clusterEntity.setNodeGroups(convertNodeGroupsToEntities(gson,clusterEntity,cluster.getDistro(),groups,EnumSet.noneOf(HadoopRole.class),cluster.isValidateConfig()));
      validateMemorySize(clusterEntity.getNodeGroups(),failedMsgList);
      if (!failedMsgList.isEmpty()) {
        throw ClusterConfigException.INVALID_SPEC(failedMsgList);
      }
    }
    if (cluster.getTopologyPolicy() == null) {
      clusterEntity.setTopologyPolicy(TopologyType.NONE);
    }
 else {
      clusterEntity.setTopologyPolicy(cluster.getTopologyPolicy());
    }
    if (clusterEntity.getTopologyPolicy() == TopologyType.HVE) {
      boolean hveSupported=false;
      if (clusterEntity.getDistro() != null) {
        DistroRead dr=distroMgr.getDistroByName(clusterEntity.getDistro());
        if (dr != null) {
          hveSupported=dr.isHveSupported();
        }
      }
      if (!hveSupported) {
        throw ClusterConfigException.INVALID_TOPOLOGY_POLICY(clusterEntity.getTopologyPolicy(),""String_Node_Str"");
      }
    }
    clusterEntityMgr.insert(clusterEntity);
    logger.debug(""String_Node_Str"" + name);
    return clusterEntity;
  }
 catch (  UniqueConstraintViolationException ex) {
    logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
    throw BddException.ALREADY_EXISTS(ex,""String_Node_Str"",name);
  }
}","@Transactional public ClusterEntity createClusterConfig(ClusterCreate cluster){
  String name=cluster.getName();
  if (name == null || name.isEmpty()) {
    throw ClusterConfigException.CLUSTER_NAME_MISSING();
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  DistroRead distro=distroMgr.getDistroByName(cluster.getDistro());
  if (cluster.getDistro() == null || distro == null) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",cluster.getDistro());
  }
  if (!cluster.getDistroVendor().equalsIgnoreCase(Constants.MAPR_VENDOR)) {
    List<String> allNetworkNames=new ArrayList<String>();
    for (    NetworkEntity entity : networkMgr.getAllNetworkEntities()) {
      allNetworkNames.add(entity.getName());
    }
    cluster.validateClusterCreate(failedMsgList,warningMsgList,distro.getRoles());
  }
 else {
    cluster.validateClusterCreateOfMapr(failedMsgList,distro.getRoles());
  }
  if (!failedMsgList.isEmpty()) {
    throw ClusterConfigException.INVALID_SPEC(failedMsgList);
  }
  if (!validateRacksInfo(cluster,failedMsgList)) {
    throw ClusterConfigException.INVALID_PLACEMENT_POLICIES(failedMsgList);
  }
  transformHDFSUrl(cluster);
  try {
    ClusterEntity entity=clusterEntityMgr.findByName(name);
    if (entity != null) {
      logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
      throw BddException.ALREADY_EXISTS(""String_Node_Str"",name);
    }
    logger.debug(""String_Node_Str"" + name);
    Gson gson=new Gson();
    ClusterEntity clusterEntity=new ClusterEntity(name);
    clusterEntity.setDistro(cluster.getDistro());
    clusterEntity.setDistroVendor(cluster.getDistroVendor());
    clusterEntity.setDistroVersion(cluster.getDistroVersion());
    clusterEntity.setStartAfterDeploy(true);
    clusterEntity.setPassword(cluster.getPassword());
    if (cluster.containsComputeOnlyNodeGroups()) {
      clusterEntity.setAutomationEnable(automationEnable);
    }
 else {
      clusterEntity.setAutomationEnable(null);
    }
    clusterEntity.setVhmMinNum(-1);
    clusterEntity.setVhmMaxNum(-1);
    if (cluster.getRpNames() != null && cluster.getRpNames().size() > 0) {
      logger.debug(""String_Node_Str"" + cluster.getRpNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcRpNameList(cluster.getRpNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    if (cluster.getDsNames() != null && !cluster.getDsNames().isEmpty()) {
      logger.debug(""String_Node_Str"" + cluster.getDsNames() + ""String_Node_Str""+ name);
      clusterEntity.setVcDatastoreNameList(cluster.getDsNames());
    }
 else {
      logger.debug(""String_Node_Str"");
    }
    clusterEntity.setNetworkConfig(convertNetNamesToNetConfigs(cluster.getNetworkConfig()));
    clusterEntity.setVhmJobTrackerPort(""String_Node_Str"");
    if (cluster.getConfiguration() != null && cluster.getConfiguration().size() > 0) {
      CommonClusterExpandPolicy.validateAppConfig(cluster.getConfiguration(),cluster.isValidateConfig());
      clusterEntity.setHadoopConfig((new Gson()).toJson(cluster.getConfiguration()));
      updateVhmJobTrackerPort(cluster,clusterEntity);
    }
    NodeGroupCreate[] groups=cluster.getNodeGroups();
    if (groups != null && groups.length > 0) {
      clusterEntity.setNodeGroups(convertNodeGroupsToEntities(gson,clusterEntity,cluster.getDistro(),groups,EnumSet.noneOf(HadoopRole.class),cluster.isValidateConfig()));
      validateMemorySize(clusterEntity.getNodeGroups(),failedMsgList);
      if (!failedMsgList.isEmpty()) {
        throw ClusterConfigException.INVALID_SPEC(failedMsgList);
      }
    }
    if (cluster.getTopologyPolicy() == null) {
      clusterEntity.setTopologyPolicy(TopologyType.NONE);
    }
 else {
      clusterEntity.setTopologyPolicy(cluster.getTopologyPolicy());
    }
    if (clusterEntity.getTopologyPolicy() == TopologyType.HVE) {
      boolean hveSupported=false;
      if (clusterEntity.getDistro() != null) {
        DistroRead dr=distroMgr.getDistroByName(clusterEntity.getDistro());
        if (dr != null) {
          hveSupported=dr.isHveSupported();
        }
      }
      if (!hveSupported) {
        throw ClusterConfigException.INVALID_TOPOLOGY_POLICY(clusterEntity.getTopologyPolicy(),""String_Node_Str"");
      }
    }
    clusterEntityMgr.insert(clusterEntity);
    logger.debug(""String_Node_Str"" + name);
    return clusterEntity;
  }
 catch (  UniqueConstraintViolationException ex) {
    logger.info(""String_Node_Str"" + name + ""String_Node_Str"");
    throw BddException.ALREADY_EXISTS(ex,""String_Node_Str"",name);
  }
}"
48886,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String hdfsNetworkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String mapredNetworkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String topology,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean alwaysAnswerYes){
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
 else   if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_BLANK_SPACE);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (type != null) {
    ClusterType clusterType=ClusterType.getByDescription(type);
    if (clusterType == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ type);
      return;
    }
    clusterCreate.setType(clusterType);
  }
 else   if (specFilePath == null) {
    clusterCreate.setType(ClusterType.HDFS_MAPRED);
  }
  if (topology != null) {
    try {
      clusterCreate.setTopologyPolicy(TopologyType.valueOf(topology));
    }
 catch (    IllegalArgumentException ex) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ topology);
      return;
    }
  }
 else {
    clusterCreate.setTopologyPolicy(TopologyType.NONE);
  }
  try {
    if (distro != null) {
      List<String> distroNames=getDistroNames();
      if (validName(distro,distroNames)) {
        clusterCreate.setDistro(distro);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
        return;
      }
    }
 else {
      String defaultDistroName=clusterCreate.getDefaultDistroName(distroRestClient.getAll());
      if (CommandsUtils.isBlank(defaultDistroName)) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM__NO_DEFAULT_DISTRO);
        return;
      }
 else {
        clusterCreate.setDistro(defaultDistroName);
      }
    }
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  DistroRead distroRead=distroRestClient.get(clusterCreate.getDistro());
  clusterCreate.setDistroVendor(distroRead.getVendor());
  clusterCreate.setDistroVersion(distroRead.getVersion());
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  Set<String> allNetworkNames=new HashSet<String>();
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setSpecFile(true);
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
    }
    allNetworkNames=getAllNetworkNames();
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  if (allNetworkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CANNOT_FIND_NETWORK);
    return;
  }
  Map<NetTrafficType,List<String>> networkConfig=new HashMap<NetTrafficType,List<String>>();
  if (networkName == null) {
    if (allNetworkNames.size() == 1) {
      networkConfig.put(NetTrafficType.MGT_NETWORK,new ArrayList<String>());
      networkConfig.get(NetTrafficType.MGT_NETWORK).addAll(allNetworkNames);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
      return;
    }
  }
 else {
    if (!allNetworkNames.contains(networkName) || (hdfsNetworkName != null && !allNetworkNames.contains(hdfsNetworkName)) || (mapredNetworkName != null && !allNetworkNames.contains(mapredNetworkName))) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + allNetworkNames.toString());
      return;
    }
    networkConfig.put(NetTrafficType.MGT_NETWORK,new ArrayList<String>());
    networkConfig.get(NetTrafficType.MGT_NETWORK).add(networkName);
    if (hdfsNetworkName != null) {
      networkConfig.put(NetTrafficType.HDFS_NETWORK,new ArrayList<String>());
      networkConfig.get(NetTrafficType.HDFS_NETWORK).add(hdfsNetworkName);
    }
    if (mapredNetworkName != null) {
      networkConfig.put(NetTrafficType.MAPRED_NETWORK,new ArrayList<String>());
      networkConfig.get(NetTrafficType.MAPRED_NETWORK).add(mapredNetworkName);
    }
  }
  notifyNetsUsage(networkConfig,warningMsgList);
  clusterCreate.setNetworkConfig(networkConfig);
  clusterCreate.validateCDHVersion(warningMsgList);
  if (specFilePath != null && !clusterCreate.getDistro().equalsIgnoreCase(com.vmware.bdd.utils.Constants.MAPR_VENDOR)) {
    List<String> distroRoles=findDistroRoles(clusterCreate);
    clusterCreate.validateClusterCreate(failedMsgList,warningMsgList,distroRoles);
  }
  if (type != null && specFilePath != null) {
    warningMsgList.add(Constants.TYPE_SPECFILE_CONFLICT);
  }
  if (!failedMsgList.isEmpty()) {
    showFailedMsg(clusterCreate.getName(),failedMsgList);
    return;
  }
  try {
    if (!CommandsUtils.showWarningMsg(clusterCreate.getName(),Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,warningMsgList,alwaysAnswerYes)) {
      return;
    }
    restClient.create(clusterCreate);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    System.out.print(e.getStackTrace());
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,CommandsUtils.getExceptionMessage(e));
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String hdfsNetworkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String mapredNetworkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String topology,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean alwaysAnswerYes){
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
 else   if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_BLANK_SPACE);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (type != null) {
    ClusterType clusterType=ClusterType.getByDescription(type);
    if (clusterType == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ type);
      return;
    }
    clusterCreate.setType(clusterType);
  }
 else   if (specFilePath == null) {
    clusterCreate.setType(ClusterType.HDFS_MAPRED);
  }
  if (topology != null) {
    try {
      clusterCreate.setTopologyPolicy(TopologyType.valueOf(topology));
    }
 catch (    IllegalArgumentException ex) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ topology);
      return;
    }
  }
 else {
    clusterCreate.setTopologyPolicy(TopologyType.NONE);
  }
  try {
    if (distro != null) {
      List<String> distroNames=getDistroNames();
      if (validName(distro,distroNames)) {
        clusterCreate.setDistro(distro);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
        return;
      }
    }
 else {
      String defaultDistroName=clusterCreate.getDefaultDistroName(distroRestClient.getAll());
      if (CommandsUtils.isBlank(defaultDistroName)) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM__NO_DEFAULT_DISTRO);
        return;
      }
 else {
        clusterCreate.setDistro(defaultDistroName);
      }
    }
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  DistroRead distroRead=distroRestClient.get(clusterCreate.getDistro());
  clusterCreate.setDistroVendor(distroRead.getVendor());
  clusterCreate.setDistroVersion(distroRead.getVersion());
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  Set<String> allNetworkNames=new HashSet<String>();
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setSpecFile(true);
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
    }
    allNetworkNames=getAllNetworkNames();
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  if (allNetworkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CANNOT_FIND_NETWORK);
    return;
  }
  Map<NetTrafficType,List<String>> networkConfig=new HashMap<NetTrafficType,List<String>>();
  if (networkName == null) {
    if (allNetworkNames.size() == 1) {
      networkConfig.put(NetTrafficType.MGT_NETWORK,new ArrayList<String>());
      networkConfig.get(NetTrafficType.MGT_NETWORK).addAll(allNetworkNames);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
      return;
    }
  }
 else {
    if (!allNetworkNames.contains(networkName) || (hdfsNetworkName != null && !allNetworkNames.contains(hdfsNetworkName)) || (mapredNetworkName != null && !allNetworkNames.contains(mapredNetworkName))) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + allNetworkNames.toString());
      return;
    }
    networkConfig.put(NetTrafficType.MGT_NETWORK,new ArrayList<String>());
    networkConfig.get(NetTrafficType.MGT_NETWORK).add(networkName);
    if (hdfsNetworkName != null) {
      networkConfig.put(NetTrafficType.HDFS_NETWORK,new ArrayList<String>());
      networkConfig.get(NetTrafficType.HDFS_NETWORK).add(hdfsNetworkName);
    }
    if (mapredNetworkName != null) {
      networkConfig.put(NetTrafficType.MAPRED_NETWORK,new ArrayList<String>());
      networkConfig.get(NetTrafficType.MAPRED_NETWORK).add(mapredNetworkName);
    }
  }
  notifyNetsUsage(networkConfig,warningMsgList);
  clusterCreate.setNetworkConfig(networkConfig);
  clusterCreate.validateCDHVersion(warningMsgList);
  if (specFilePath != null && !clusterCreate.getDistro().equalsIgnoreCase(com.vmware.bdd.utils.Constants.MAPR_VENDOR)) {
    List<String> distroRoles=findDistroRoles(clusterCreate);
    clusterCreate.validateClusterCreate(failedMsgList,warningMsgList,distroRoles);
  }
  if (type != null && specFilePath != null) {
    warningMsgList.add(Constants.TYPE_SPECFILE_CONFLICT);
  }
  if (!failedMsgList.isEmpty()) {
    showFailedMsg(clusterCreate.getName(),failedMsgList);
    return;
  }
  try {
    if (!CommandsUtils.showWarningMsg(clusterCreate.getName(),Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,warningMsgList,alwaysAnswerYes)) {
      return;
    }
    restClient.create(clusterCreate);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,CommandsUtils.getExceptionMessage(e));
  }
}"
48887,"public ClusterCreate getClusterSpec(String clusterName){
  ClusterCreate spec=clusterConfigMgr.getClusterConfig(clusterName);
  spec.setVcClusters(null);
  spec.setTemplateId(null);
  spec.setDistroMap(null);
  spec.setSharedDatastorePattern(null);
  spec.setLocalDatastorePattern(null);
  spec.setNetworkings(null);
  spec.setRpNames(null);
  spec.setDsNames(null);
  spec.setNetworkConfig(null);
  spec.setName(null);
  spec.setDistro(null);
  spec.setValidateConfig(null);
  spec.setSpecFile(null);
  spec.setTopologyPolicy(null);
  spec.setHostToRackMap(null);
  spec.setHttpProxy(null);
  spec.setNoProxy(null);
  spec.setDistroVendor(null);
  spec.setDistroVersion(null);
  NodeGroupCreate[] groups=spec.getNodeGroups();
  if (groups != null) {
    for (    NodeGroupCreate group : groups) {
      group.setVcClusters(null);
      group.setGroupType(null);
      group.setRpNames(null);
      group.getStorage().setDsNames(null);
      group.getStorage().setImagestoreNamePattern(null);
      group.getStorage().setDiskstoreNamePattern(null);
      group.setVmFolderPath(null);
      group.getStorage().setSplitPolicy(null);
      group.getStorage().setControllerType(null);
      group.getStorage().setAllocType(null);
      if (group.getPlacementPolicies() != null) {
        List<GroupAssociation> associations=group.getPlacementPolicies().getGroupAssociations();
        if (associations != null && associations.isEmpty()) {
          group.getPlacementPolicies().setGroupAssociations(null);
        }
      }
    }
  }
  return spec;
}","public ClusterCreate getClusterSpec(String clusterName){
  ClusterCreate spec=clusterConfigMgr.getClusterConfig(clusterName);
  spec.setVcClusters(null);
  spec.setTemplateId(null);
  spec.setDistroMap(null);
  spec.setSharedDatastorePattern(null);
  spec.setLocalDatastorePattern(null);
  spec.setNetworkings(null);
  spec.setRpNames(null);
  spec.setDsNames(null);
  spec.setNetworkConfig(null);
  spec.setName(null);
  spec.setDistro(null);
  spec.setValidateConfig(null);
  spec.setSpecFile(null);
  spec.setTopologyPolicy(null);
  spec.setHostToRackMap(null);
  spec.setHttpProxy(null);
  spec.setNoProxy(null);
  spec.setDistroVendor(null);
  spec.setDistroVersion(null);
  spec.setPassword(null);
  NodeGroupCreate[] groups=spec.getNodeGroups();
  if (groups != null) {
    for (    NodeGroupCreate group : groups) {
      group.setVcClusters(null);
      group.setGroupType(null);
      group.setRpNames(null);
      group.getStorage().setDsNames(null);
      group.getStorage().setImagestoreNamePattern(null);
      group.getStorage().setDiskstoreNamePattern(null);
      group.setVmFolderPath(null);
      group.getStorage().setSplitPolicy(null);
      group.getStorage().setControllerType(null);
      group.getStorage().setAllocType(null);
      if (group.getPlacementPolicies() != null) {
        List<GroupAssociation> associations=group.getPlacementPolicies().getGroupAssociations();
        if (associations != null && associations.isEmpty()) {
          group.getPlacementPolicies().setGroupAssociations(null);
        }
      }
    }
  }
  return spec;
}"
48888,"public ClusterCreate getClusterSpec(String clusterName){
  ClusterCreate spec=clusterConfigMgr.getClusterConfig(clusterName);
  spec.setVcClusters(null);
  spec.setTemplateId(null);
  spec.setDistroMap(null);
  spec.setSharedDatastorePattern(null);
  spec.setLocalDatastorePattern(null);
  spec.setNetworkings(null);
  spec.setRpNames(null);
  spec.setDsNames(null);
  spec.setNetworkConfig(null);
  spec.setName(null);
  spec.setDistro(null);
  spec.setValidateConfig(null);
  spec.setSpecFile(null);
  spec.setTopologyPolicy(null);
  spec.setHostToRackMap(null);
  spec.setHttpProxy(null);
  spec.setNoProxy(null);
  spec.setDistroVendor(null);
  spec.setDistroVersion(null);
  NodeGroupCreate[] groups=spec.getNodeGroups();
  if (groups != null) {
    for (    NodeGroupCreate group : groups) {
      group.setVcClusters(null);
      group.setGroupType(null);
      group.setRpNames(null);
      group.getStorage().setDsNames(null);
      group.getStorage().setImagestoreNamePattern(null);
      group.getStorage().setDiskstoreNamePattern(null);
      group.setVmFolderPath(null);
      group.getStorage().setSplitPolicy(null);
      group.getStorage().setControllerType(null);
      group.getStorage().setAllocType(null);
      if (group.getPlacementPolicies() != null) {
        List<GroupAssociation> associations=group.getPlacementPolicies().getGroupAssociations();
        if (associations != null && associations.isEmpty()) {
          group.getPlacementPolicies().setGroupAssociations(null);
        }
      }
    }
  }
  return spec;
}","public ClusterCreate getClusterSpec(String clusterName){
  ClusterCreate spec=clusterConfigMgr.getClusterConfig(clusterName);
  spec.setVcClusters(null);
  spec.setTemplateId(null);
  spec.setDistroMap(null);
  spec.setSharedDatastorePattern(null);
  spec.setLocalDatastorePattern(null);
  spec.setNetworkings(null);
  spec.setRpNames(null);
  spec.setDsNames(null);
  spec.setNetworkConfig(null);
  spec.setName(null);
  spec.setDistro(null);
  spec.setValidateConfig(null);
  spec.setSpecFile(null);
  spec.setTopologyPolicy(null);
  spec.setHostToRackMap(null);
  spec.setHttpProxy(null);
  spec.setNoProxy(null);
  spec.setDistroVendor(null);
  spec.setDistroVersion(null);
  spec.setPassword(null);
  NodeGroupCreate[] groups=spec.getNodeGroups();
  if (groups != null) {
    for (    NodeGroupCreate group : groups) {
      group.setVcClusters(null);
      group.setGroupType(null);
      group.setRpNames(null);
      group.getStorage().setDsNames(null);
      group.getStorage().setImagestoreNamePattern(null);
      group.getStorage().setDiskstoreNamePattern(null);
      group.setVmFolderPath(null);
      group.getStorage().setSplitPolicy(null);
      group.getStorage().setControllerType(null);
      group.getStorage().setAllocType(null);
      if (group.getPlacementPolicies() != null) {
        List<GroupAssociation> associations=group.getPlacementPolicies().getGroupAssociations();
        if (associations != null && associations.isEmpty()) {
          group.getPlacementPolicies().setGroupAssociations(null);
        }
      }
    }
  }
  return spec;
}"
48889,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String hdfsNetworkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String mapredNetworkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String topology,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean alwaysAnswerYes){
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
 else   if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_BLANK_SPACE);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (type != null) {
    ClusterType clusterType=ClusterType.getByDescription(type);
    if (clusterType == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ type);
      return;
    }
    clusterCreate.setType(clusterType);
  }
 else   if (specFilePath == null) {
    clusterCreate.setType(ClusterType.HDFS_MAPRED);
  }
  if (topology != null) {
    try {
      clusterCreate.setTopologyPolicy(TopologyType.valueOf(topology));
    }
 catch (    IllegalArgumentException ex) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ topology);
      return;
    }
  }
 else {
    clusterCreate.setTopologyPolicy(TopologyType.NONE);
  }
  try {
    if (distro != null) {
      List<String> distroNames=getDistroNames();
      if (validName(distro,distroNames)) {
        clusterCreate.setDistro(distro);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
        return;
      }
    }
 else {
      String defaultDistroName=clusterCreate.getDefaultDistroName(distroRestClient.getAll());
      if (CommandsUtils.isBlank(defaultDistroName)) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM__NO_DEFAULT_DISTRO);
        return;
      }
 else {
        clusterCreate.setDistro(defaultDistroName);
      }
    }
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  DistroRead distroRead=distroRestClient.get(clusterCreate.getDistro());
  clusterCreate.setDistroVendor(distroRead.getVendor());
  clusterCreate.setDistroVersion(distroRead.getVersion());
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  Set<String> allNetworkNames=new HashSet<String>();
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setSpecFile(true);
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
    }
    allNetworkNames=getAllNetworkNames();
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  if (allNetworkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CANNOT_FIND_NETWORK);
    return;
  }
  Map<NetTrafficType,List<String>> networkConfig=new HashMap<NetTrafficType,List<String>>();
  if (networkName == null) {
    if (allNetworkNames.size() == 1) {
      networkConfig.put(NetTrafficType.MGT_NETWORK,new ArrayList<String>());
      networkConfig.get(NetTrafficType.MGT_NETWORK).addAll(allNetworkNames);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
      return;
    }
  }
 else {
    if (!allNetworkNames.contains(networkName) || (hdfsNetworkName != null && !allNetworkNames.contains(hdfsNetworkName)) || (mapredNetworkName != null && !allNetworkNames.contains(mapredNetworkName))) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + allNetworkNames.toString());
      return;
    }
    networkConfig.put(NetTrafficType.MGT_NETWORK,new ArrayList<String>());
    networkConfig.get(NetTrafficType.MGT_NETWORK).add(networkName);
    if (hdfsNetworkName != null) {
      networkConfig.put(NetTrafficType.HDFS_NETWORK,new ArrayList<String>());
      networkConfig.get(NetTrafficType.HDFS_NETWORK).add(hdfsNetworkName);
    }
    if (mapredNetworkName != null) {
      networkConfig.put(NetTrafficType.MAPRED_NETWORK,new ArrayList<String>());
      networkConfig.get(NetTrafficType.MAPRED_NETWORK).add(mapredNetworkName);
    }
  }
  notifyNetsUsage(networkConfig,warningMsgList);
  clusterCreate.setNetworkConfig(networkConfig);
  clusterCreate.validateCDHVersion(warningMsgList);
  if (specFilePath != null && !clusterCreate.getDistro().equalsIgnoreCase(com.vmware.bdd.utils.Constants.MAPR_VENDOR)) {
    List<String> distroRoles=findDistroRoles(clusterCreate);
    clusterCreate.validateClusterCreate(failedMsgList,warningMsgList,distroRoles);
  }
  if (type != null && specFilePath != null) {
    warningMsgList.add(Constants.TYPE_SPECFILE_CONFLICT);
  }
  if (!failedMsgList.isEmpty()) {
    showFailedMsg(clusterCreate.getName(),failedMsgList);
    return;
  }
  try {
    if (!CommandsUtils.showWarningMsg(clusterCreate.getName(),Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,warningMsgList,alwaysAnswerYes)) {
      return;
    }
    restClient.create(clusterCreate);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,CommandsUtils.getExceptionMessage(e));
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String hdfsNetworkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String mapredNetworkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String topology,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean alwaysAnswerYes){
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
 else   if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_BLANK_SPACE);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (type != null) {
    ClusterType clusterType=ClusterType.getByDescription(type);
    if (clusterType == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ type);
      return;
    }
    clusterCreate.setType(clusterType);
  }
 else   if (specFilePath == null) {
    clusterCreate.setType(ClusterType.HDFS_MAPRED);
  }
  if (topology != null) {
    try {
      clusterCreate.setTopologyPolicy(TopologyType.valueOf(topology));
    }
 catch (    IllegalArgumentException ex) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ topology);
      return;
    }
  }
 else {
    clusterCreate.setTopologyPolicy(TopologyType.NONE);
  }
  try {
    if (distro != null) {
      List<String> distroNames=getDistroNames();
      if (validName(distro,distroNames)) {
        clusterCreate.setDistro(distro);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
        return;
      }
    }
 else {
      String defaultDistroName=clusterCreate.getDefaultDistroName(distroRestClient.getAll());
      if (CommandsUtils.isBlank(defaultDistroName)) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM__NO_DEFAULT_DISTRO);
        return;
      }
 else {
        clusterCreate.setDistro(defaultDistroName);
      }
    }
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  DistroRead distroRead=distroRestClient.get(clusterCreate.getDistro());
  clusterCreate.setDistroVendor(distroRead.getVendor());
  clusterCreate.setDistroVersion(distroRead.getVersion());
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  Set<String> allNetworkNames=new HashSet<String>();
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setSpecFile(true);
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
      clusterCreate.validateNodeGroupNames();
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
    }
    allNetworkNames=getAllNetworkNames();
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  if (allNetworkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CANNOT_FIND_NETWORK);
    return;
  }
  Map<NetTrafficType,List<String>> networkConfig=new HashMap<NetTrafficType,List<String>>();
  if (networkName == null) {
    if (allNetworkNames.size() == 1) {
      networkConfig.put(NetTrafficType.MGT_NETWORK,new ArrayList<String>());
      networkConfig.get(NetTrafficType.MGT_NETWORK).addAll(allNetworkNames);
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
      return;
    }
  }
 else {
    if (!allNetworkNames.contains(networkName) || (hdfsNetworkName != null && !allNetworkNames.contains(hdfsNetworkName)) || (mapredNetworkName != null && !allNetworkNames.contains(mapredNetworkName))) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + allNetworkNames.toString());
      return;
    }
    networkConfig.put(NetTrafficType.MGT_NETWORK,new ArrayList<String>());
    networkConfig.get(NetTrafficType.MGT_NETWORK).add(networkName);
    if (hdfsNetworkName != null) {
      networkConfig.put(NetTrafficType.HDFS_NETWORK,new ArrayList<String>());
      networkConfig.get(NetTrafficType.HDFS_NETWORK).add(hdfsNetworkName);
    }
    if (mapredNetworkName != null) {
      networkConfig.put(NetTrafficType.MAPRED_NETWORK,new ArrayList<String>());
      networkConfig.get(NetTrafficType.MAPRED_NETWORK).add(mapredNetworkName);
    }
  }
  notifyNetsUsage(networkConfig,warningMsgList);
  clusterCreate.setNetworkConfig(networkConfig);
  clusterCreate.validateCDHVersion(warningMsgList);
  if (specFilePath != null && !clusterCreate.getDistro().equalsIgnoreCase(com.vmware.bdd.utils.Constants.MAPR_VENDOR)) {
    List<String> distroRoles=findDistroRoles(clusterCreate);
    clusterCreate.validateClusterCreate(failedMsgList,warningMsgList,distroRoles);
  }
  if (type != null && specFilePath != null) {
    warningMsgList.add(Constants.TYPE_SPECFILE_CONFLICT);
  }
  if (!failedMsgList.isEmpty()) {
    showFailedMsg(clusterCreate.getName(),failedMsgList);
    return;
  }
  try {
    if (!CommandsUtils.showWarningMsg(clusterCreate.getName(),Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,warningMsgList,alwaysAnswerYes)) {
      return;
    }
    restClient.create(clusterCreate);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,CommandsUtils.getExceptionMessage(e));
  }
}"
48890,"/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
public void validateClusterCreate(List<String> failedMsgList,List<String> warningMsgList,final List<String> distroRoles){
  boolean namenodeHACheck=false;
  int masterCount=0, jobtrackerCount=0, resourcemanagerCount=0, hbasemasterCount=0, zookeeperCount=0, workerCount=0, numOfJournalNode=0;
  boolean appendWarningStr=false;
  if (warningMsgList != null && warningMsgList.isEmpty()) {
    appendWarningStr=true;
  }
  NodeGroupCreate[] nodeGroupCreates=getNodeGroups();
  if (nodeGroupCreates == null || nodeGroupCreates.length == 0) {
    failedMsgList.add(Constants.MULTI_INPUTS_CHECK);
    return;
  }
 else {
    if (hasHDFSUrlConfigured() && !validateHDFSUrl()) {
      failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getExternalHDFS()).toString());
    }
    validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList);
    validateNodeGroupRoles(failedMsgList);
    validateStorageType(failedMsgList);
    validateSwapRatio(nodeGroupCreates,failedMsgList);
    for (    NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
      checkInstanceNum(nodeGroupCreate,failedMsgList);
      makeVmMemoryDivisibleBy4(nodeGroupCreate,warningMsgList);
      checkNodeGroupRoles(nodeGroupCreate,distroRoles,failedMsgList);
      List<NodeGroupRole> groupRoles=getNodeGroupRoles(nodeGroupCreate);
      if (groupRoles != null) {
        for (        NodeGroupRole role : groupRoles) {
switch (role) {
case MASTER:
            masterCount++;
          int numOfInstance=nodeGroupCreate.getInstanceNum();
        if (numOfInstance >= 0 && numOfInstance != 1) {
          if (numOfInstance != 2) {
            collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
          }
 else {
            namenodeHACheck=true;
          }
        }
      break;
case JOB_TRACKER:
    jobtrackerCount++;
  if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
    failedMsgList.add(Constants.WRONG_NUM_OF_JOBTRACKER);
  }
break;
case RESOURCEMANAGER:
resourcemanagerCount++;
if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
failedMsgList.add(Constants.WRONG_NUM_OF_RESOURCEMANAGER);
}
break;
case HBASE_MASTER:
hbasemasterCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
break;
case ZOOKEEPER:
zookeeperCount++;
if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_ZOOKEEPER);
}
 else if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_ZOOKEEPER);
}
break;
case JOURNAL_NODE:
numOfJournalNode+=nodeGroupCreate.getInstanceNum();
if (nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_DATANODE.toString()) || nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_CLIENT_ROLE.toString())) {
failedMsgList.add(Constants.DATA_CLIENT_NODE_JOURNALNODE_COEXIST);
}
break;
case WORKER:
workerCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
 else if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
List<String> roles=nodeGroupCreate.getRoles();
if (roles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString()) && !roles.contains(HadoopRole.HADOOP_DATANODE.toString())) {
warningMsgList.add(Constants.REGISONSERVER_DATANODE_SEPERATION);
}
break;
case CLIENT:
if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
break;
case NONE:
warningMsgList.add(Constants.NOT_DEFINED_ROLE);
break;
default :
}
}
}
}
if (!supportedWithHdfs2()) {
if (namenodeHACheck || masterCount > 1) {
failedMsgList.add(Constants.CURRENT_DISTRO_CAN_NOT_SUPPORT_HDFS2);
}
}
 else if (namenodeHACheck) {
if (numOfJournalNode >= 0 && numOfJournalNode < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_JOURNALNODE);
}
 else if (numOfJournalNode > 0 && numOfJournalNode % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_JOURNALNODE);
}
if (zookeeperCount == 0) {
failedMsgList.add(Constants.NAMENODE_AUTO_FAILOVER_ZOOKEEPER);
}
}
if ((jobtrackerCount > 1) || (resourcemanagerCount > 1) || (zookeeperCount > 1)|| (hbasemasterCount > 1)) {
failedMsgList.add(Constants.WRONG_NUM_OF_NODEGROUPS);
}
if (workerCount == 0) {
warningMsgList.add(Constants.WRONG_NUM_OF_WORKERNODES);
}
if (numOfJournalNode > 0 && !namenodeHACheck) {
failedMsgList.add(Constants.NO_NAMENODE_HA);
}
if (!warningMsgList.isEmpty() && appendWarningStr) {
warningMsgList.set(0,""String_Node_Str"" + warningMsgList.get(0));
}
}
}","/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
public void validateClusterCreate(List<String> failedMsgList,List<String> warningMsgList,final List<String> distroRoles){
  boolean namenodeHACheck=false;
  int masterCount=0, jobtrackerCount=0, resourcemanagerCount=0, hbasemasterCount=0, zookeeperCount=0, workerCount=0, numOfJournalNode=0;
  boolean appendWarningStr=false;
  if (warningMsgList != null && warningMsgList.isEmpty()) {
    appendWarningStr=true;
  }
  NodeGroupCreate[] nodeGroupCreates=getNodeGroups();
  AuAssert.check(nodeGroupCreates != null && nodeGroupCreates.length > 0);
  if (hasHDFSUrlConfigured() && !validateHDFSUrl()) {
    failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getExternalHDFS()).toString());
  }
  validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList);
  validateNodeGroupRoles(failedMsgList);
  validateStorageType(failedMsgList);
  validateSwapRatio(nodeGroupCreates,failedMsgList);
  for (  NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
    checkInstanceNum(nodeGroupCreate,failedMsgList);
    makeVmMemoryDivisibleBy4(nodeGroupCreate,warningMsgList);
    checkNodeGroupRoles(nodeGroupCreate,distroRoles,failedMsgList);
    List<NodeGroupRole> groupRoles=getNodeGroupRoles(nodeGroupCreate);
    if (groupRoles != null) {
      for (      NodeGroupRole role : groupRoles) {
switch (role) {
case MASTER:
          masterCount++;
        int numOfInstance=nodeGroupCreate.getInstanceNum();
      if (numOfInstance >= 0 && numOfInstance != 1) {
        if (numOfInstance != 2) {
          collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
        }
 else {
          namenodeHACheck=true;
        }
      }
    break;
case JOB_TRACKER:
  jobtrackerCount++;
if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
  failedMsgList.add(Constants.WRONG_NUM_OF_JOBTRACKER);
}
break;
case RESOURCEMANAGER:
resourcemanagerCount++;
if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
failedMsgList.add(Constants.WRONG_NUM_OF_RESOURCEMANAGER);
}
break;
case HBASE_MASTER:
hbasemasterCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
break;
case ZOOKEEPER:
zookeeperCount++;
if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_ZOOKEEPER);
}
 else if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_ZOOKEEPER);
}
break;
case JOURNAL_NODE:
numOfJournalNode+=nodeGroupCreate.getInstanceNum();
if (nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_DATANODE.toString()) || nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_CLIENT_ROLE.toString())) {
failedMsgList.add(Constants.DATA_CLIENT_NODE_JOURNALNODE_COEXIST);
}
break;
case WORKER:
workerCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
 else if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
List<String> roles=nodeGroupCreate.getRoles();
if (roles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString()) && !roles.contains(HadoopRole.HADOOP_DATANODE.toString())) {
warningMsgList.add(Constants.REGISONSERVER_DATANODE_SEPERATION);
}
break;
case CLIENT:
if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
break;
case NONE:
warningMsgList.add(Constants.NOT_DEFINED_ROLE);
break;
default :
}
}
}
}
if (!supportedWithHdfs2()) {
if (namenodeHACheck || masterCount > 1) {
failedMsgList.add(Constants.CURRENT_DISTRO_CAN_NOT_SUPPORT_HDFS2);
}
}
 else if (namenodeHACheck) {
if (numOfJournalNode >= 0 && numOfJournalNode < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_JOURNALNODE);
}
 else if (numOfJournalNode > 0 && numOfJournalNode % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_JOURNALNODE);
}
if (zookeeperCount == 0) {
failedMsgList.add(Constants.NAMENODE_AUTO_FAILOVER_ZOOKEEPER);
}
}
if ((jobtrackerCount > 1) || (resourcemanagerCount > 1) || (zookeeperCount > 1)|| (hbasemasterCount > 1)) {
failedMsgList.add(Constants.WRONG_NUM_OF_NODEGROUPS);
}
if (workerCount == 0) {
warningMsgList.add(Constants.WRONG_NUM_OF_WORKERNODES);
}
if (numOfJournalNode > 0 && !namenodeHACheck) {
failedMsgList.add(Constants.NO_NAMENODE_HA);
}
if (!warningMsgList.isEmpty() && appendWarningStr) {
warningMsgList.set(0,""String_Node_Str"" + warningMsgList.get(0));
}
}"
48891,"@Transactional synchronized public void refreshNodeByVmName(String vmId,String vmName,String nodeAction,boolean inSession){
  NodeEntity node=nodeDao.findByName(vmName);
  if (node != null) {
    node.setMoId(vmId);
    refreshNodeStatus(node,inSession);
    node.setAction(nodeAction);
  }
}","@Transactional synchronized public void refreshNodeByVmName(String vmId,String vmName,String nodeAction,boolean inSession){
  NodeEntity node=nodeDao.findByName(vmName);
  if (node != null) {
    node.setMoId(vmId);
    node.setAction(nodeAction);
    refreshNodeStatus(node,inSession);
  }
}"
48892,"@Transactional synchronized public void refreshNodeByMobId(String vmId,String action,boolean inSession){
  NodeEntity node=nodeDao.findByMobId(vmId);
  if (node != null) {
    refreshNodeStatus(node,inSession);
    node.setAction(action);
  }
}","@Transactional synchronized public void refreshNodeByMobId(String vmId,String action,boolean inSession){
  NodeEntity node=nodeDao.findByMobId(vmId);
  if (node != null) {
    node.setAction(action);
    refreshNodeStatus(node,inSession);
  }
}"
48893,"private void refreshNodeStatus(NodeEntity node,boolean inSession){
  String mobId=node.getMoId();
  if (mobId == null) {
    setNotExist(node);
    return;
  }
  VcVirtualMachine vcVm=VcCache.getIgnoreMissing(mobId);
  if (vcVm == null) {
    setNotExist(node);
    return;
  }
  if (!vcVm.isPoweredOn()) {
    node.setStatus(NodeStatus.POWERED_OFF);
    node.resetIps();
  }
 else {
    node.setStatus(NodeStatus.POWERED_ON);
  }
  if (node.isPowerStatusChanged()) {
    if (vcVm.isPoweredOn()) {
      for (      String portGroup : node.fetchAllPortGroups()) {
        String ip=VcVmUtil.getIpAddressOfPortGroup(vcVm,portGroup,inSession);
        node.updateIpAddressOfPortGroup(portGroup,ip);
      }
      if (node.ipsReady()) {
        node.setStatus(NodeStatus.VM_READY);
        if (node.getAction() != null && node.getAction().equals(Constants.NODE_ACTION_WAITING_IP)) {
          node.setAction(null);
        }
      }
      String guestHostName=VcVmUtil.getGuestHostName(vcVm,inSession);
      if (guestHostName != null) {
        node.setGuestHostName(guestHostName);
      }
    }
    node.setHostName(vcVm.getHost().getName());
  }
  update(node);
}","private void refreshNodeStatus(NodeEntity node,boolean inSession){
  String mobId=node.getMoId();
  if (mobId == null) {
    setNotExist(node);
    return;
  }
  VcVirtualMachine vcVm=VcCache.getIgnoreMissing(mobId);
  if (vcVm == null) {
    setNotExist(node);
    return;
  }
  if (!vcVm.isPoweredOn()) {
    node.setStatus(NodeStatus.POWERED_OFF);
    node.resetIps();
  }
 else {
    node.setStatus(NodeStatus.POWERED_ON);
  }
  if (vcVm.isPoweredOn()) {
    for (    String portGroup : node.fetchAllPortGroups()) {
      String ip=VcVmUtil.getIpAddressOfPortGroup(vcVm,portGroup,inSession);
      node.updateIpAddressOfPortGroup(portGroup,ip);
    }
    if (node.ipsReady()) {
      node.setStatus(NodeStatus.VM_READY);
      if (node.getAction() != null && node.getAction().equals(Constants.NODE_ACTION_WAITING_IP)) {
        node.setAction(null);
      }
    }
    String guestHostName=VcVmUtil.getGuestHostName(vcVm,inSession);
    if (guestHostName != null) {
      node.setGuestHostName(guestHostName);
    }
  }
  node.setHostName(vcVm.getHost().getName());
  update(node);
}"
48894,"private void processEvent(VcEventType type,Event e,String moId,boolean external) throws Exception {
  try {
switch (type) {
case VmRemoved:
{
        logger.debug(""String_Node_Str"" + moId);
        if (clusterEntityMgr.getNodeByMobId(moId) != null) {
          clusterEntityMgr.refreshNodeByMobId(moId,null,true);
        }
        break;
      }
case VmPoweredOn:
{
      refreshNodeWithAction(e,moId,true,Constants.NODE_ACTION_WAITING_IP,""String_Node_Str"");
      if (external) {
        NodePowerOnRequest request=new NodePowerOnRequest(clusterEntityMgr,moId);
        CmsWorker.addRequest(WorkQueue.VC_TASK_NO_DELAY,request);
      }
      break;
    }
case VmCloned:
{
    refreshNodeWithAction(e,moId,true,Constants.NODE_ACTION_RECONFIGURE,""String_Node_Str"");
    break;
  }
case VmSuspended:
{
  refreshNodeWithAction(e,moId,true,null,""String_Node_Str"");
  break;
}
case VmPoweredOff:
{
refreshNodeWithAction(e,moId,true,null,""String_Node_Str"");
break;
}
case VhmError:
case VhmWarning:
case VhmInfo:
case VhmUser:
{
EventEx event=(EventEx)e;
refreshNodeWithAction(e,moId,true,null,""String_Node_Str"");
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
break;
}
vm.updateRuntime();
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + e.getDynamicType() + ""String_Node_Str""+ vm.getName()+ ""String_Node_Str""+ event.getMessage());
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),event.getMessage(),true);
}
break;
}
default :
{
refreshNodeWithAction(e,moId,false,null,type.name());
break;
}
}
}
 catch (ManagedObjectNotFound exp) {
VcUtil.processNotFoundException(exp,moId,logger);
}
}","private void processEvent(VcEventType type,Event e,String moId,boolean external) throws Exception {
  try {
switch (type) {
case VmRemoved:
{
        logger.debug(""String_Node_Str"" + moId);
        if (clusterEntityMgr.getNodeByMobId(moId) != null) {
          clusterEntityMgr.refreshNodeByMobId(moId,null,true);
        }
        break;
      }
case VmDisconnected:
{
      refreshNodeWithAction(e,null,true,null,""String_Node_Str"");
      break;
    }
case VmPoweredOn:
{
    refreshNodeWithAction(e,moId,true,Constants.NODE_ACTION_WAITING_IP,""String_Node_Str"");
    if (external) {
      NodePowerOnRequest request=new NodePowerOnRequest(clusterEntityMgr,moId);
      CmsWorker.addRequest(WorkQueue.VC_TASK_NO_DELAY,request);
    }
    break;
  }
case VmCloned:
{
  refreshNodeWithAction(e,moId,true,Constants.NODE_ACTION_RECONFIGURE,""String_Node_Str"");
  break;
}
case VmSuspended:
{
refreshNodeWithAction(e,moId,true,null,""String_Node_Str"");
break;
}
case VmPoweredOff:
{
refreshNodeWithAction(e,moId,true,null,""String_Node_Str"");
break;
}
case VhmError:
case VhmWarning:
case VhmInfo:
case VhmUser:
{
EventEx event=(EventEx)e;
refreshNodeWithAction(e,moId,true,null,""String_Node_Str"");
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
break;
}
vm.updateRuntime();
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + e.getDynamicType() + ""String_Node_Str""+ vm.getName()+ ""String_Node_Str""+ event.getMessage());
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),event.getMessage(),true);
}
break;
}
default :
{
refreshNodeWithAction(e,moId,false,null,type.name());
break;
}
}
}
 catch (ManagedObjectNotFound exp) {
VcUtil.processNotFoundException(exp,moId,logger);
}
}"
48895,"private List<VcCluster> getUsedVcClusters(List<String> rpNames){
  List<VcCluster> clusters=null;
  if (rpNames == null || rpNames.isEmpty()) {
    clusters=clusterConfigMgr.getRpMgr().getAllVcResourcePool();
  }
 else {
    clusters=new ArrayList<VcCluster>();
    for (    String rpName : rpNames) {
      clusters.addAll(clusterConfigMgr.getRpMgr().getVcResourcePoolByName(rpName));
    }
  }
  return clusters;
}","private List<VcCluster> getUsedVcClusters(List<String> rpNames){
  List<VcCluster> clusters=null;
  if (rpNames == null || rpNames.isEmpty()) {
    clusters=clusterConfigMgr.getRpMgr().getAllVcResourcePool();
  }
 else {
    clusters=new ArrayList<VcCluster>();
    StringBuffer nonexistentRpNames=new StringBuffer();
    for (    String rpName : rpNames) {
      List<VcCluster> vcClusters=clusterConfigMgr.getRpMgr().getVcResourcePoolByName(rpName);
      if (vcClusters == null) {
        nonexistentRpNames.append(rpName).append(""String_Node_Str"");
      }
 else {
        clusters.addAll(vcClusters);
      }
    }
    if (nonexistentRpNames.length() > 0) {
      nonexistentRpNames.delete(nonexistentRpNames.length() - 1,nonexistentRpNames.length());
      throw VcProviderException.RESOURCE_POOL_NOT_FOUND(nonexistentRpNames.toString());
    }
  }
  return clusters;
}"
48896,"@SuppressWarnings(""String_Node_Str"") @Override public boolean createVcVms(NetworkAdd networkAdd,List<BaseNode> vNodes,StatusUpdater statusUpdator,Set<String> occupiedIps){
  if (vNodes.isEmpty()) {
    logger.info(""String_Node_Str"");
    return true;
  }
  setNetworkSchema(vNodes);
  allocateStaticIp(networkAdd,vNodes,occupiedIps);
  Map<String,Folder> folders=createVcFolders(vNodes.get(0).getCluster());
  String clusterRpName=createVcResourcePools(vNodes);
  logger.info(""String_Node_Str"");
  VcVmUtil.updateVm(templateVm.getId());
  VmCreateSpec sourceSpec=new VmCreateSpec();
  sourceSpec.setVmId(templateVm.getId());
  sourceSpec.setVmName(templateVm.getName());
  sourceSpec.setTargetHost(templateVm.getHost());
  List<VmCreateSpec> specs=new ArrayList<VmCreateSpec>();
  Map<String,BaseNode> nodeMap=new HashMap<String,BaseNode>();
  for (  BaseNode vNode : vNodes) {
    nodeMap.put(vNode.getVmName(),vNode);
    vNode.setSuccess(false);
    vNode.setFinished(true);
    VmCreateSpec spec=new VmCreateSpec();
    VmSchema createSchema=getVmSchema(vNode);
    spec.setSchema(createSchema);
    Map<String,String> guestVariable=getNetworkGuestVariable(networkAdd,vNode.getIpAddress(),vNode.getGuestHostName());
    spec.setBootupConfigs(guestVariable);
    QueryIpAddress query=new QueryIpAddress(Constants.VM_POWER_ON_WAITING_SEC);
    spec.setPostPowerOn(query);
    spec.setPrePowerOn(getPrePowerOnFunc(vNode));
    spec.setLinkedClone(false);
    spec.setTargetDs(getVcDatastore(vNode));
    spec.setTargetFolder(folders.get(vNode.getGroupName()));
    spec.setTargetHost(VcResourceUtils.findHost(vNode.getTargetHost()));
    spec.setTargetRp(getVcResourcePool(vNode,clusterRpName));
    spec.setVmName(vNode.getVmName());
    specs.add(spec);
  }
  try {
    UpdateVmProgressCallback callback=new UpdateVmProgressCallback(clusterEntityMgr,statusUpdator,vNodes.get(0).getClusterName());
    logger.info(""String_Node_Str"");
    List<VmCreateSpec> results=cloneService.createCopies(sourceSpec,cloneConcurrency,specs,callback);
    logger.info(results.size() + ""String_Node_Str"");
    boolean success=(specs.size() == results.size());
    for (    VmCreateSpec spec : results) {
      BaseNode node=nodeMap.get(spec.getVmName());
      node.setVmMobId(spec.getVmId());
      VcVirtualMachine vm=VcCache.getIgnoreMissing(spec.getVmId());
      if (vm != null) {
        boolean vmSucc=VcVmUtil.setBaseNodeForVm(node,vm);
        if (!vmSucc) {
          success=false;
        }
      }
      node.setSuccess(success);
    }
    return success;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public boolean createVcVms(NetworkAdd networkAdd,List<BaseNode> vNodes,StatusUpdater statusUpdator,Set<String> occupiedIps){
  if (vNodes.isEmpty()) {
    logger.info(""String_Node_Str"");
    return true;
  }
  setNetworkSchema(vNodes);
  allocateStaticIp(networkAdd,vNodes,occupiedIps);
  Map<String,Folder> folders=createVcFolders(vNodes.get(0).getCluster());
  String clusterRpName=createVcResourcePools(vNodes);
  logger.info(""String_Node_Str"");
  VcVmUtil.updateVm(templateVm.getId());
  VmCreateSpec sourceSpec=new VmCreateSpec();
  sourceSpec.setVmId(templateVm.getId());
  sourceSpec.setVmName(templateVm.getName());
  sourceSpec.setTargetHost(templateVm.getHost());
  List<VmCreateSpec> specs=new ArrayList<VmCreateSpec>();
  Map<String,BaseNode> nodeMap=new HashMap<String,BaseNode>();
  for (  BaseNode vNode : vNodes) {
    nodeMap.put(vNode.getVmName(),vNode);
    vNode.setSuccess(false);
    vNode.setFinished(true);
    VmCreateSpec spec=new VmCreateSpec();
    VmSchema createSchema=getVmSchema(vNode);
    spec.setSchema(createSchema);
    Map<String,String> guestVariable=getNetworkGuestVariable(networkAdd,vNode.getIpAddress(),vNode.getGuestHostName());
    spec.setBootupConfigs(guestVariable);
    QueryIpAddress query=new QueryIpAddress(Constants.VM_POWER_ON_WAITING_SEC);
    spec.setPostPowerOn(query);
    spec.setPrePowerOn(getPrePowerOnFunc(vNode));
    spec.setLinkedClone(false);
    spec.setTargetDs(getVcDatastore(vNode));
    spec.setTargetFolder(folders.get(vNode.getGroupName()));
    spec.setTargetHost(VcResourceUtils.findHost(vNode.getTargetHost()));
    spec.setTargetRp(getVcResourcePool(vNode,clusterRpName));
    spec.setVmName(vNode.getVmName());
    specs.add(spec);
  }
  try {
    UpdateVmProgressCallback callback=new UpdateVmProgressCallback(clusterEntityMgr,statusUpdator,vNodes.get(0).getClusterName());
    logger.info(""String_Node_Str"");
    AuAssert.check(specs.size() > 0);
    VmSchema vmSchema=specs.get(0).getSchema();
    VcVmUtil.checkAndCreateSnapshot(vmSchema);
    List<VmCreateSpec> results=cloneService.createCopies(sourceSpec,cloneConcurrency,specs,callback);
    logger.info(results.size() + ""String_Node_Str"");
    boolean success=(specs.size() == results.size());
    for (    VmCreateSpec spec : results) {
      BaseNode node=nodeMap.get(spec.getVmName());
      node.setVmMobId(spec.getVmId());
      VcVirtualMachine vm=VcCache.getIgnoreMissing(spec.getVmId());
      if (vm != null) {
        boolean vmSucc=VcVmUtil.setBaseNodeForVm(node,vm);
        if (!vmSucc) {
          success=false;
        }
      }
      node.setSuccess(success);
    }
    return success;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}"
48897,"protected boolean isTaskSession(){
  return true;
}","@Override protected boolean isTaskSession(){
  return true;
}"
48898,"@Override protected Void body() throws Exception {
  FlagInfo flagInfo=new FlagInfoImpl();
  flagInfo.setDiskUuidEnabled(true);
  ConfigSpec configSpec=new ConfigSpecImpl();
  configSpec.setFlags(flagInfo);
  vm.reconfigure(configSpec);
  return null;
}","@Override protected Void body() throws Exception {
  final VcVirtualMachine template=VcCache.get(vmSchema.diskSchema.getParent());
  VcSnapshot snap=template.getSnapshotByName(vmSchema.diskSchema.getParentSnap());
  if (snap == null) {
    snap=template.createSnapshot(vmSchema.diskSchema.getParentSnap(),""String_Node_Str"");
  }
  return null;
}"
48899,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String topology,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean alwaysAnswerYes){
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
 else   if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_BLANK_SPACE);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (type != null) {
    ClusterType clusterType=ClusterType.getByDescription(type);
    if (clusterType == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ type);
      return;
    }
    clusterCreate.setType(clusterType);
  }
 else   if (specFilePath == null) {
    clusterCreate.setType(ClusterType.HDFS_MAPRED);
  }
  if (topology != null) {
    try {
      clusterCreate.setTopologyPolicy(TopologyType.valueOf(topology));
    }
 catch (    IllegalArgumentException ex) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ topology);
      return;
    }
  }
 else {
    clusterCreate.setTopologyPolicy(TopologyType.NONE);
  }
  try {
    if (distro != null) {
      List<String> distroNames=getDistroNames();
      if (validName(distro,distroNames)) {
        clusterCreate.setDistro(distro);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
        return;
      }
    }
 else {
      String defaultDistroName=clusterCreate.getDefaultDistroName(distroRestClient.getAll());
      if (CommandsUtils.isBlank(defaultDistroName)) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM__NO_DEFAULT_DISTRO);
        return;
      }
 else {
        clusterCreate.setDistro(defaultDistroName);
      }
    }
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  DistroRead distroRead=distroRestClient.get(clusterCreate.getDistro());
  clusterCreate.setDistroVendor(distroRead.getVendor());
  clusterCreate.setDistroVersion(distroRead.getVersion());
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  List<String> networkNames=null;
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setSpecFile(true);
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
    }
    networkNames=getNetworkNames();
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  if (networkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_EXISTED);
    return;
  }
 else {
    if (networkName != null) {
      if (validName(networkName,networkNames)) {
        clusterCreate.setNetworkName(networkName);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + networkNames);
        return;
      }
    }
 else {
      if (networkNames.size() == 1) {
        clusterCreate.setNetworkName(networkNames.get(0));
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
        return;
      }
    }
  }
  clusterCreate.validateCDHVersion(warningMsgList);
  if (specFilePath != null && !clusterCreate.getDistro().equalsIgnoreCase(com.vmware.bdd.utils.Constants.MAPR_VENDOR)) {
    List<String> distroRoles=findDistroRoles(clusterCreate);
    clusterCreate.validateClusterCreate(failedMsgList,warningMsgList,distroRoles);
  }
  if (type != null && specFilePath != null) {
    warningMsgList.add(Constants.TYPE_SPECFILE_CONFLICT);
  }
  if (!failedMsgList.isEmpty()) {
    showFailedMsg(clusterCreate.getName(),failedMsgList);
    return;
  }
  try {
    if (!CommandsUtils.showWarningMsg(clusterCreate.getName(),Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,warningMsgList,alwaysAnswerYes)) {
      return;
    }
    restClient.create(clusterCreate);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,CommandsUtils.getExceptionMessage(e));
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String topology,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean alwaysAnswerYes){
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
 else   if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_BLANK_SPACE);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (type != null) {
    ClusterType clusterType=ClusterType.getByDescription(type);
    if (clusterType == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ type);
      return;
    }
    clusterCreate.setType(clusterType);
  }
 else   if (specFilePath == null) {
    clusterCreate.setType(ClusterType.HDFS_MAPRED);
  }
  if (topology != null) {
    try {
      clusterCreate.setTopologyPolicy(TopologyType.valueOf(topology));
    }
 catch (    IllegalArgumentException ex) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ topology);
      return;
    }
  }
 else {
    clusterCreate.setTopologyPolicy(TopologyType.NONE);
  }
  try {
    if (distro != null) {
      List<String> distroNames=getDistroNames();
      if (validName(distro,distroNames)) {
        clusterCreate.setDistro(distro);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
        return;
      }
    }
 else {
      String defaultDistroName=clusterCreate.getDefaultDistroName(distroRestClient.getAll());
      if (CommandsUtils.isBlank(defaultDistroName)) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM__NO_DEFAULT_DISTRO);
        return;
      }
 else {
        clusterCreate.setDistro(defaultDistroName);
      }
    }
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  DistroRead distroRead=distroRestClient.get(clusterCreate.getDistro());
  clusterCreate.setDistroVendor(distroRead.getVendor());
  clusterCreate.setDistroVersion(distroRead.getVersion());
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  List<String> networkNames=null;
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setSpecFile(true);
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
    }
    networkNames=getNetworkNames();
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  if (networkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CANNOT_FIND_NETWORK);
    return;
  }
 else {
    if (networkName != null) {
      if (validName(networkName,networkNames)) {
        clusterCreate.setNetworkName(networkName);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + networkNames);
        return;
      }
    }
 else {
      if (networkNames.size() == 1) {
        clusterCreate.setNetworkName(networkNames.get(0));
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
        return;
      }
    }
  }
  clusterCreate.validateCDHVersion(warningMsgList);
  if (specFilePath != null && !clusterCreate.getDistro().equalsIgnoreCase(com.vmware.bdd.utils.Constants.MAPR_VENDOR)) {
    List<String> distroRoles=findDistroRoles(clusterCreate);
    clusterCreate.validateClusterCreate(failedMsgList,warningMsgList,distroRoles);
  }
  if (type != null && specFilePath != null) {
    warningMsgList.add(Constants.TYPE_SPECFILE_CONFLICT);
  }
  if (!failedMsgList.isEmpty()) {
    showFailedMsg(clusterCreate.getName(),failedMsgList);
    return;
  }
  try {
    if (!CommandsUtils.showWarningMsg(clusterCreate.getName(),Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,warningMsgList,alwaysAnswerYes)) {
      return;
    }
    restClient.create(clusterCreate);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,CommandsUtils.getExceptionMessage(e));
  }
}"
48900,"private List<ManagedObjectReference> getSharedDatastoreInt() throws Exception {
  AuAssert.check(VcContext.isInSession());
  List<HostSystem> hostList=MoUtil.getManagedObjects(host);
  List<ManagedObjectReference> results=new ArrayList<ManagedObjectReference>();
  DatastoreInfo[] candidateList=null;
  HashMap<String,Integer> map=new HashMap<String,Integer>();
  if (hostList.size() == 0) {
    return results;
  }
  for (  HostSystem h : hostList) {
    DatastoreInfo[] info=h.queryConnectionInfo().getDatastore();
    if (candidateList == null) {
      candidateList=info;
    }
    for (    DatastoreInfo n : info) {
      String name=n.getSummary().getName();
      Integer count=map.get(name);
      if (count != null) {
        map.put(name,count + 1);
      }
 else {
        map.put(name,Integer.valueOf(1));
      }
    }
  }
  for (  DatastoreInfo n : candidateList) {
    if (map.get(n.getSummary().getName()).equals(hostList.size())) {
      results.add(n.getSummary().getDatastore());
    }
  }
  return results;
}","private List<ManagedObjectReference> getSharedDatastoreInt() throws Exception {
  AuAssert.check(VcContext.isInSession());
  List<HostSystem> hostList=MoUtil.getManagedObjects(host);
  List<ManagedObjectReference> results=new ArrayList<ManagedObjectReference>();
  DatastoreInfo[] candidateList=null;
  HashMap<String,Integer> map=new HashMap<String,Integer>();
  if (hostList.size() == 0) {
    return results;
  }
  for (  HostSystem h : hostList) {
    DatastoreInfo[] info=h.queryConnectionInfo().getDatastore();
    if (info == null)     continue;
    if (candidateList == null) {
      candidateList=info;
    }
    for (    DatastoreInfo n : info) {
      String name=n.getSummary().getName();
      Integer count=map.get(name);
      if (count != null) {
        map.put(name,count + 1);
      }
 else {
        map.put(name,Integer.valueOf(1));
      }
    }
  }
  if (candidateList != null) {
    for (    DatastoreInfo n : candidateList) {
      if (map.get(n.getSummary().getName()).equals(hostList.size())) {
        results.add(n.getSummary().getDatastore());
      }
    }
  }
  return results;
}"
48901,"private void showFailedMsg(String name,List<String> failedMsgList){
  StringBuilder failedMsg=new StringBuilder();
  failedMsg.append(Constants.INVALID_VALUE);
  if (failedMsgList.size() > 1) {
    failedMsg.append(""String_Node_Str"");
  }
  failedMsg.append(""String_Node_Str"");
  StringBuilder tmpMsg=new StringBuilder();
  for (  String msg : failedMsgList) {
    tmpMsg.append(""String_Node_Str"").append(msg);
  }
  tmpMsg.replace(0,1,""String_Node_Str"");
  failedMsg.append(tmpMsg);
  failedMsg.append(""String_Node_Str"");
  CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,failedMsg.toString());
}","private void showFailedMsg(String name,List<String> failedMsgList){
  StringBuilder failedMsg=new StringBuilder();
  failedMsg.append(Constants.INVALID_VALUE);
  if (failedMsgList.size() > 1) {
    failedMsg.append(""String_Node_Str"");
  }
  failedMsg.append(""String_Node_Str"");
  StringBuilder tmpMsg=new StringBuilder();
  for (  String msg : failedMsgList) {
    tmpMsg.append(msg);
  }
  failedMsg.append(tmpMsg);
  CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,failedMsg.toString());
}"
48902,"private void collectInstanceNumInvalidateMsg(NodeGroupCreate nodeGroup,List<String> failedMsgList){
  failedMsgList.add(new StringBuilder().append(nodeGroup.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(nodeGroup.getInstanceNum()).toString());
}","private void collectInstanceNumInvalidateMsg(NodeGroupCreate nodeGroup,List<String> failedMsgList){
  failedMsgList.add(new StringBuilder().append(nodeGroup.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(nodeGroup.getInstanceNum()).append(""String_Node_Str"").toString());
}"
48903,"public boolean validatePlacementPolicies(ClusterCreate cluster,Map<String,NodeGroupCreate> groups,List<String> failedMsgList,List<String> warningMsgList){
  boolean valid=true;
  TopologyType topologyType=cluster.getTopologyPolicy();
  if (topologyType != null && (topologyType.equals(TopologyType.HVE) || topologyType.equals(TopologyType.RACK_AS_RACK)) && isWorkerGroup()) {
    if (getPlacementPolicies() == null) {
      setPlacementPolicies(new PlacementPolicy());
    }
    if (getPlacementPolicies().getGroupRacks() == null && getPlacementPolicies().getGroupAssociations() == null) {
      GroupRacks groupRacks=new GroupRacks();
      groupRacks.setType(GroupRacksType.ROUNDROBIN);
      groupRacks.setRacks(new String[0]);
      getPlacementPolicies().setGroupRacks(groupRacks);
    }
  }
  PlacementPolicy policies=getPlacementPolicies();
  if (policies != null) {
    if (policies.getInstancePerHost() != null) {
      if (policies.getInstancePerHost() <= 0) {
        valid=false;
        failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").append(policies.getInstancePerHost()).toString());
      }
 else       if (calculateHostNum() < 0) {
        valid=false;
        failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").append(policies.getInstancePerHost()).append(""String_Node_Str"").toString());
      }
    }
    if (policies.getGroupRacks() != null) {
      GroupRacks r=policies.getGroupRacks();
      if (r.getType() == null) {
        r.setType(GroupRacksType.ROUNDROBIN);
      }
      if (r.getRacks() == null) {
        r.setRacks(new String[0]);
      }
      if (getStorage() != null && getStorage().getType() != null && getStorage().getType().equals(DatastoreType.SHARED.toString())) {
        warningMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getName()).append(""String_Node_Str"").toString());
      }
    }
    if (policies.getGroupAssociations() != null) {
      if (policies.getGroupRacks() != null) {
        warningMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getName()).append(""String_Node_Str"").toString());
      }
      if (policies.getGroupAssociations().size() != 1) {
        valid=false;
        failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").toString());
      }
 else {
        GroupAssociation a=policies.getGroupAssociations().get(0);
        if (a.getType() == null) {
          a.setType(GroupAssociationType.WEAK);
        }
        if (a.getReference() == null) {
          valid=false;
          failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").toString());
        }
 else         if (a.getReference().equals(getName())) {
          valid=false;
          failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").toString());
        }
 else         if (!groups.containsKey(a.getReference())) {
          valid=false;
          failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").append(a.getReference()).append(""String_Node_Str"").toString());
        }
 else {
          if (a.getType() == GroupAssociationType.STRICT) {
            int hostNum=1;
            int refHostNum=groups.get(a.getReference()).getInstanceNum();
            if (calculateHostNum() != null) {
              hostNum=calculateHostNum();
            }
            if (groups.get(a.getReference()).calculateHostNum() != null) {
              refHostNum=groups.get(a.getReference()).calculateHostNum();
            }
            if (hostNum > refHostNum) {
              valid=false;
              failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"" + ""String_Node_Str"").append(a.getReference()).append(""String_Node_Str"").toString());
            }
          }
          PlacementPolicy refPolicies=groups.get(a.getReference()).getPlacementPolicies();
          if (refPolicies != null && refPolicies.getGroupAssociations() != null && !refPolicies.getGroupAssociations().isEmpty()) {
            valid=false;
            failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").append(a.getReference()).append(""String_Node_Str"").toString());
          }
        }
      }
    }
  }
  return valid;
}","public boolean validatePlacementPolicies(ClusterCreate cluster,Map<String,NodeGroupCreate> groups,List<String> failedMsgList,List<String> warningMsgList){
  boolean valid=true;
  TopologyType topologyType=cluster.getTopologyPolicy();
  if (topologyType != null && (topologyType.equals(TopologyType.HVE) || topologyType.equals(TopologyType.RACK_AS_RACK)) && isWorkerGroup()) {
    if (getPlacementPolicies() == null) {
      setPlacementPolicies(new PlacementPolicy());
    }
    if (getPlacementPolicies().getGroupRacks() == null && getPlacementPolicies().getGroupAssociations() == null) {
      GroupRacks groupRacks=new GroupRacks();
      groupRacks.setType(GroupRacksType.ROUNDROBIN);
      groupRacks.setRacks(new String[0]);
      getPlacementPolicies().setGroupRacks(groupRacks);
    }
  }
  PlacementPolicy policies=getPlacementPolicies();
  if (policies != null) {
    if (policies.getInstancePerHost() != null) {
      if (policies.getInstancePerHost() <= 0) {
        valid=false;
        failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").append(policies.getInstancePerHost()).append(""String_Node_Str"").toString());
      }
 else       if (calculateHostNum() < 0) {
        valid=false;
        failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").append(policies.getInstancePerHost()).append(""String_Node_Str"").toString());
      }
    }
    if (policies.getGroupRacks() != null) {
      GroupRacks r=policies.getGroupRacks();
      if (r.getType() == null) {
        r.setType(GroupRacksType.ROUNDROBIN);
      }
      if (r.getRacks() == null) {
        r.setRacks(new String[0]);
      }
      if (getStorage() != null && getStorage().getType() != null && getStorage().getType().equals(DatastoreType.SHARED.toString())) {
        warningMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getName()).append(""String_Node_Str"").toString());
      }
    }
    if (policies.getGroupAssociations() != null) {
      if (policies.getGroupRacks() != null) {
        warningMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getName()).append(""String_Node_Str"").toString());
      }
      if (policies.getGroupAssociations().size() != 1) {
        valid=false;
        failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").toString());
      }
 else {
        GroupAssociation a=policies.getGroupAssociations().get(0);
        if (a.getType() == null) {
          a.setType(GroupAssociationType.WEAK);
        }
        if (a.getReference() == null) {
          valid=false;
          failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").toString());
        }
 else         if (a.getReference().equals(getName())) {
          valid=false;
          failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").toString());
        }
 else         if (!groups.containsKey(a.getReference())) {
          valid=false;
          failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").append(a.getReference()).append(""String_Node_Str"").toString());
        }
 else {
          if (a.getType() == GroupAssociationType.STRICT) {
            int hostNum=1;
            int refHostNum=groups.get(a.getReference()).getInstanceNum();
            if (calculateHostNum() != null) {
              hostNum=calculateHostNum();
            }
            if (groups.get(a.getReference()).calculateHostNum() != null) {
              refHostNum=groups.get(a.getReference()).calculateHostNum();
            }
            if (hostNum > refHostNum) {
              valid=false;
              failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"" + ""String_Node_Str"").append(a.getReference()).append(""String_Node_Str"").toString());
            }
          }
          PlacementPolicy refPolicies=groups.get(a.getReference()).getPlacementPolicies();
          if (refPolicies != null && refPolicies.getGroupAssociations() != null && !refPolicies.getGroupAssociations().isEmpty()) {
            valid=false;
            failedMsgList.add(new StringBuilder().append(getName()).append(""String_Node_Str"").append(a.getReference()).append(""String_Node_Str"").toString());
          }
        }
      }
    }
  }
  return valid;
}"
48904,"public String getVersion(){
  return ""String_Node_Str"";
}","public String getVersion(){
  return Constants.VERSION;
}"
48905,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void conn(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String hostName){
  if (!validateHostPort(hostName)) {
    return;
  }
  Map<String,String> loginInfo=new HashMap<String,String>();
  String username=null;
  String password=null;
  loginInfo.put(""String_Node_Str"",username);
  loginInfo.put(""String_Node_Str"",password);
  try {
    if (CommandsUtils.isBlank(username)) {
      if (!prompt(Constants.CONNECT_ENTER_USER_NAME,PromptType.USER_NAME,loginInfo)) {
        return;
      }
    }
    if (CommandsUtils.isBlank(password)) {
      if (!prompt(Constants.CONNECT_ENTER_PASSWORD,PromptType.PASSWORD,loginInfo)) {
        return;
      }
    }
    connect(hostName,loginInfo,3);
  }
 catch (  Exception e) {
    System.out.println();
    printConnectionFailure(e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void conn(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String hostName){
  if (!validateHostPort(hostName)) {
    return;
  }
  Map<String,String> loginInfo=new HashMap<String,String>();
  String username=null;
  String password=null;
  loginInfo.put(""String_Node_Str"",username);
  loginInfo.put(""String_Node_Str"",password);
  try {
    if (CommandsUtils.isBlank(username)) {
      if (!prompt(Constants.CONNECT_ENTER_USER_NAME,PromptType.USER_NAME,loginInfo)) {
        return;
      }
    }
    if (CommandsUtils.isBlank(password)) {
      if (!prompt(Constants.CONNECT_ENTER_PASSWORD,PromptType.PASSWORD,loginInfo)) {
        return;
      }
    }
    connect(hostName,loginInfo,3);
    getServerVersion(hostName);
  }
 catch (  Exception e) {
    System.out.println();
    printConnectionFailure(e.getMessage());
  }
}"
48906,"@CliCommand(value={""String_Node_Str""},help=""String_Node_Str"") public String getBanner(){
  StringBuilder buf=new StringBuilder();
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + this.getVersion());
  return buf.toString();
}","public String getBanner(){
  StringBuilder buf=new StringBuilder();
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + OsUtils.LINE_SEPARATOR);
  buf.append(""String_Node_Str"" + this.getVersion());
  return buf.toString();
}"
48907,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseStatus(HttpStatus.OK) @ResponseBody public String getHello(){
  return ""String_Node_Str"";
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) @ResponseStatus(HttpStatus.OK) @ResponseBody public String getHello(){
  return Constants.VERSION;
}"
48908,"public String retrieveVhmTargetNum(){
  if (vhmTargetNum == null) {
    return ""String_Node_Str"";
  }
 else {
    return vhmTargetNum.toString();
  }
}","public String retrieveVhmTargetNum(){
  if (vhmTargetNum == null || vhmTargetNum == -1) {
    return ""String_Node_Str"";
  }
 else {
    return vhmTargetNum.toString();
  }
}"
48909,"private void refreshNodeStatus(NodeEntity node,boolean inSession){
  String mobId=node.getMoId();
  if (mobId == null) {
    setNotExist(node);
    return;
  }
  VcVirtualMachine vcVm=VcCache.getIgnoreMissing(mobId);
  if (vcVm == null) {
    setNotExist(node);
    return;
  }
  if (!vcVm.isPoweredOn()) {
    node.setStatus(NodeStatus.POWERED_OFF);
  }
 else {
    node.setStatus(NodeStatus.POWERED_ON);
  }
  if (node.isPowerStatusChanged()) {
    if (vcVm.isPoweredOn()) {
      String ipAddress=VcVmUtil.getIpAddress(vcVm,inSession);
      if (ipAddress != null) {
        node.setStatus(NodeStatus.VM_READY);
        node.setIpAddress(ipAddress);
        if (node.getAction() != null && node.getAction().equals(Constants.NODE_ACTION_WAITING_IP)) {
          node.setAction(null);
        }
      }
      String guestHostName=VcVmUtil.getGuestHostName(vcVm,inSession);
      if (guestHostName != null) {
        node.setGuestHostName(guestHostName);
      }
    }
    node.setHostName(vcVm.getHost().getName());
  }
  update(node);
}","private void refreshNodeStatus(NodeEntity node,boolean inSession){
  String mobId=node.getMoId();
  if (mobId == null) {
    setNotExist(node);
    return;
  }
  VcVirtualMachine vcVm=VcCache.getIgnoreMissing(mobId);
  if (vcVm == null) {
    setNotExist(node);
    return;
  }
  if (!vcVm.isPoweredOn()) {
    node.setStatus(NodeStatus.POWERED_OFF);
    node.setIpAddress(null);
  }
 else {
    node.setStatus(NodeStatus.POWERED_ON);
  }
  if (node.isPowerStatusChanged()) {
    if (vcVm.isPoweredOn()) {
      String ipAddress=VcVmUtil.getIpAddress(vcVm,inSession);
      if (ipAddress != null) {
        node.setStatus(NodeStatus.VM_READY);
        node.setIpAddress(ipAddress);
        if (node.getAction() != null && node.getAction().equals(Constants.NODE_ACTION_WAITING_IP)) {
          node.setAction(null);
        }
      }
      String guestHostName=VcVmUtil.getGuestHostName(vcVm,inSession);
      if (guestHostName != null) {
        node.setGuestHostName(guestHostName);
      }
    }
    node.setHostName(vcVm.getHost().getName());
  }
  update(node);
}"
48910,"@Override public Void call() throws Exception {
  final VcVirtualMachine vcVm=VcCache.getIgnoreMissing(vmId);
  if (vcVm == null) {
    logger.info(""String_Node_Str"" + vmId + ""String_Node_Str"");
    return null;
  }
  VcContext.inVcSessionDo(new VcSession<Void>(){
    @Override protected Void body() throws Exception {
      try {
        FaultToleranceConfigInfo info=vcVm.getConfig().getFtInfo();
        if (info != null && info.getRole() == 1) {
          logger.info(""String_Node_Str"" + vcVm.getName() + ""String_Node_Str"");
          vcVm.turnOffFT();
        }
        if (vcVm.isPoweredOn()) {
          vcVm.powerOff();
        }
        vcVm.destroy();
        return null;
      }
 catch (      ManagedObjectNotFound e) {
        VcUtil.processNotFoundException(e,vmId,logger);
        return null;
      }
    }
    protected boolean isTaskSession(){
      return true;
    }
  }
);
  return null;
}","@Override public Void call() throws Exception {
  final VcVirtualMachine vcVm=VcCache.getIgnoreMissing(vmId);
  if (vcVm == null) {
    logger.info(""String_Node_Str"" + vmId + ""String_Node_Str"");
    return null;
  }
  VcContext.inVcSessionDo(new VcSession<Void>(){
    @Override protected Void body() throws Exception {
      try {
        FaultToleranceConfigInfo info=vcVm.getConfig().getFtInfo();
        if (info != null && info.getRole() == 1) {
          logger.info(""String_Node_Str"" + vcVm.getName() + ""String_Node_Str"");
          vcVm.turnOffFT();
        }
        if (vcVm.isPoweredOn()) {
          vcVm.powerOff();
        }
        vcVm.destroy();
        return null;
      }
 catch (      ManagedObjectNotFound e) {
        VcUtil.processNotFoundException(e,vmId,logger);
        return null;
      }
catch (      Exception e) {
        if (vcVm.getConnectionState() == ConnectionState.inaccessible) {
          logger.error(""String_Node_Str"" + vcVm.getName(),e);
          logger.info(""String_Node_Str"" + vcVm.getName());
          vcVm.unregister();
          return null;
        }
 else {
          throw e;
        }
      }
    }
    protected boolean isTaskSession(){
      return true;
    }
  }
);
  return null;
}"
48911,"@Override protected Void body() throws Exception {
  try {
    FaultToleranceConfigInfo info=vcVm.getConfig().getFtInfo();
    if (info != null && info.getRole() == 1) {
      logger.info(""String_Node_Str"" + vcVm.getName() + ""String_Node_Str"");
      vcVm.turnOffFT();
    }
    if (vcVm.isPoweredOn()) {
      vcVm.powerOff();
    }
    vcVm.destroy();
    return null;
  }
 catch (  ManagedObjectNotFound e) {
    VcUtil.processNotFoundException(e,vmId,logger);
    return null;
  }
}","@Override protected Void body() throws Exception {
  try {
    FaultToleranceConfigInfo info=vcVm.getConfig().getFtInfo();
    if (info != null && info.getRole() == 1) {
      logger.info(""String_Node_Str"" + vcVm.getName() + ""String_Node_Str"");
      vcVm.turnOffFT();
    }
    if (vcVm.isPoweredOn()) {
      vcVm.powerOff();
    }
    vcVm.destroy();
    return null;
  }
 catch (  ManagedObjectNotFound e) {
    VcUtil.processNotFoundException(e,vmId,logger);
    return null;
  }
catch (  Exception e) {
    if (vcVm.getConnectionState() == ConnectionState.inaccessible) {
      logger.error(""String_Node_Str"" + vcVm.getName(),e);
      logger.info(""String_Node_Str"" + vcVm.getName());
      vcVm.unregister();
      return null;
    }
 else {
      throw e;
    }
  }
}"
48912,"public VcEventRouter(){
  VcEventListener.installExtEventHandler(vmEvents,new IVcEventHandler(){
    @Override public boolean eventHandler(    VcEventType type,    Event e) throws Exception {
      AuAssert.check(e instanceof VmEvent || e instanceof EventEx);
      ManagedObjectReference moRef=e.getVm().getVm();
switch (type) {
case VmRemoved:
{
          VcCache.purge(moRef);
          ManagedObjectReference rpMoRef=VcCache.removeVmRpPair(moRef);
          if (rpMoRef != null) {
            VcCache.refresh(rpMoRef);
          }
          return false;
        }
case VmResourcePoolMoved:
{
        VmResourcePoolMovedEvent event=(VmResourcePoolMovedEvent)e;
        VcCache.refresh(event.getOldParent().getResourcePool());
        VcCache.refresh(event.getNewParent().getResourcePool());
        break;
      }
case VmCreated:
{
      VmCreatedEvent event=(VmCreatedEvent)e;
      VcVirtualMachine vm=VcCache.get(event.getVm().getVm());
      vm.refreshRP();
      break;
    }
}
VcCache.refreshAll(moRef);
return false;
}
}
);
VcEventListener.installExtEventHandler(rpEvents,new IVcEventHandler(){
@Override public boolean eventHandler(VcEventType type,Event e) throws Exception {
ManagedObjectReference moRef=((ResourcePoolEvent)e).getResourcePool().getResourcePool();
if (type == VcEventType.ResourcePoolDestroyed) {
  VcCache.purge(moRef);
}
 else {
  VcCache.refreshAll(moRef);
}
return false;
}
}
);
}","public VcEventRouter(){
  VcEventListener.installExtEventHandler(vmEvents,new IVcEventHandler(){
    @Override public boolean eventHandler(    VcEventType type,    Event e) throws Exception {
      AuAssert.check(e instanceof VmEvent || e instanceof EventEx);
      ManagedObjectReference moRef=e.getVm().getVm();
switch (type) {
case VmRemoved:
{
          VcCache.purge(moRef);
          ManagedObjectReference rpMoRef=VcCache.removeVmRpPair(moRef);
          if (rpMoRef != null) {
            VcCache.refresh(rpMoRef);
          }
          return false;
        }
case VmDisconnected:
case VmConnected:
{
        VcVirtualMachine vm=VcCache.getIgnoreMissing(moRef);
        if (vm == null) {
          return false;
        }
        vm.update();
      }
case VmResourcePoolMoved:
{
      VmResourcePoolMovedEvent event=(VmResourcePoolMovedEvent)e;
      VcCache.refresh(event.getOldParent().getResourcePool());
      VcCache.refresh(event.getNewParent().getResourcePool());
      break;
    }
case VmCreated:
{
    VmCreatedEvent event=(VmCreatedEvent)e;
    VcVirtualMachine vm=VcCache.get(event.getVm().getVm());
    vm.refreshRP();
    break;
  }
}
VcCache.refreshAll(moRef);
return false;
}
}
);
VcEventListener.installExtEventHandler(rpEvents,new IVcEventHandler(){
@Override public boolean eventHandler(VcEventType type,Event e) throws Exception {
ManagedObjectReference moRef=((ResourcePoolEvent)e).getResourcePool().getResourcePool();
if (type == VcEventType.ResourcePoolDestroyed) {
VcCache.purge(moRef);
}
 else {
VcCache.refreshAll(moRef);
}
return false;
}
}
);
}"
48913,"public static VcProviderException MEMORY_EXCEED_LIMIT(String vmName){
  return new VcProviderException(null,""String_Node_Str"",vmName);
}","public static VcProviderException MEMORY_EXCEED_LIMIT(long memory,long maxMemory,String vmName){
  return new VcProviderException(null,""String_Node_Str"",memory,maxMemory,vmName);
}"
48914,"public static VcProviderException CPU_EXCEED_LIMIT(String vmName){
  return new VcProviderException(null,""String_Node_Str"",vmName);
}","public static VcProviderException CPU_EXCEED_LIMIT(int cpuNumber,int maxCpuNumber,String vmName){
  return new VcProviderException(null,""String_Node_Str"",cpuNumber,maxCpuNumber,vmName);
}"
48915,"public Priority getShares(){
  return shares;
}","@JsonIgnore public Priority getShares(){
  return shares;
}"
48916,"@Override public boolean scaleNodeResource(String nodeName,int cpuNumber,long memory){
  logger.info(""String_Node_Str"" + nodeName + ""String_Node_Str""+ cpuNumber+ ""String_Node_Str""+ memory);
  NodeEntity node=clusterEntityMgr.findNodeByName(nodeName);
  DiskEntity swapDisk=findSwapDisk(node);
  VcDatastore targetDs=null;
  long newSwapSizeInMB=0;
  if (memory > getVmOriginalMemory(nodeName)) {
    newSwapSizeInMB=(((long)Math.ceil(memory * node.getNodeGroup().getSwapRatio()) + 1023) / 1024) * 1024;
    logger.info(""String_Node_Str"" + newSwapSizeInMB);
    targetDs=getTargetDsForSwapDisk(node,swapDisk,newSwapSizeInMB);
  }
  ScaleVMSP scaleVMSP=new ScaleVMSP(node.getMoId(),cpuNumber,memory,targetDs,swapDisk,newSwapSizeInMB);
  boolean vmResult=VcVmUtil.runSPOnSingleVM(node,scaleVMSP);
  return vmResult;
}","@Override public boolean scaleNodeResource(String nodeName,int cpuNumber,long memory){
  logger.info(""String_Node_Str"" + nodeName + ""String_Node_Str""+ cpuNumber+ ""String_Node_Str""+ memory);
  NodeEntity node=clusterEntityMgr.findNodeByName(nodeName);
  DiskEntity swapDisk=findSwapDisk(node);
  VcDatastore targetDs=null;
  long newSwapSizeInMB=0;
  if (memory > 0) {
    newSwapSizeInMB=(((long)Math.ceil(memory * node.getNodeGroup().getSwapRatio()) + 1023) / 1024) * 1024;
    logger.info(""String_Node_Str"" + newSwapSizeInMB);
    targetDs=getTargetDsForSwapDisk(node,swapDisk,newSwapSizeInMB);
  }
  ScaleVMSP scaleVMSP=new ScaleVMSP(node.getMoId(),cpuNumber,memory,targetDs,swapDisk,newSwapSizeInMB);
  boolean vmResult=VcVmUtil.runSPOnSingleVM(node,scaleVMSP);
  return vmResult;
}"
48917,"@Override public Void call() throws Exception {
  final VcVirtualMachine vcVm=VcCache.getIgnoreMissing(vmId);
  if (vcVm == null) {
    logger.info(""String_Node_Str"" + vmId + ""String_Node_Str"");
    return null;
  }
  if (vcVm.isPoweredOn()) {
    logger.info(""String_Node_Str"" + vcVm.getName() + ""String_Node_Str"");
    return null;
  }
  logger.info(""String_Node_Str"" + vmId + ""String_Node_Str""+ cpuNumber+ ""String_Node_Str""+ memory);
  return VcContext.inVcSessionDo(new VcSession<Void>(){
    @Override protected Void body() throws Exception {
      ConfigSpecImpl newConfigSpec=new ConfigSpecImpl();
      if (cpuNumber > 0) {
        newConfigSpec.setNumCPUs(cpuNumber);
      }
      if (memory > 0) {
        VmConfigUtil.setMemoryAndBalloon(newConfigSpec,memory);
        if (targetDs != null) {
          VirtualDisk vmSwapDisk=VcVmUtil.findVirtualDisk(vmId,swapDisk.getExternalAddress());
          logger.info(""String_Node_Str"" + swapDisk.getDatastoreName());
          logger.info(""String_Node_Str"" + targetDs.getName());
          if (swapDisk.getDatastoreMoId().equals(targetDs.getId())) {
            VirtualDeviceSpec devSpec=new VirtualDeviceSpecImpl();
            devSpec.setOperation(VirtualDeviceSpec.Operation.edit);
            vmSwapDisk.setCapacityInKB(newSwapSizeInMB * 1024);
            devSpec.setDevice(vmSwapDisk);
            VirtualDeviceSpec[] changes={devSpec};
            newConfigSpec.setDeviceChange(changes);
            logger.info(""String_Node_Str"");
          }
 else {
            vcVm.detachVirtualDisk(new DeviceId(swapDisk.getExternalAddress()),true);
            AllocationType allocType=swapDisk.getAllocType() == null ? null : AllocationType.valueOf(swapDisk.getAllocType());
            DiskCreateSpec[] addDisks={new DiskCreateSpec(new DeviceId(swapDisk.getExternalAddress()),targetDs,swapDisk.getName(),DiskMode.independent_persistent,DiskSize.sizeFromMB(newSwapSizeInMB),allocType)};
            vcVm.changeDisks(null,addDisks);
          }
        }
      }
      vcVm.reconfigure(newConfigSpec);
      return null;
    }
    protected boolean isTaskSession(){
      return true;
    }
  }
);
}","@Override public Void call() throws Exception {
  final VcVirtualMachine vcVm=VcCache.getIgnoreMissing(vmId);
  if (vcVm == null) {
    logger.info(""String_Node_Str"" + vmId + ""String_Node_Str"");
    return null;
  }
  if (vcVm.isPoweredOn()) {
    logger.info(""String_Node_Str"" + vcVm.getName() + ""String_Node_Str"");
    return null;
  }
  logger.info(""String_Node_Str"" + vmId + ""String_Node_Str""+ cpuNumber+ ""String_Node_Str""+ memory);
  return VcContext.inVcSessionDo(new VcSession<Void>(){
    @Override protected Void body() throws Exception {
      ConfigSpecImpl newConfigSpec=new ConfigSpecImpl();
      if (cpuNumber > 0) {
        newConfigSpec.setNumCPUs(cpuNumber);
      }
      if (memory > 0) {
        VmConfigUtil.setMemoryAndBalloon(newConfigSpec,memory);
        if (targetDs != null) {
          logger.info(""String_Node_Str"" + swapDisk.getDatastoreName());
          logger.info(""String_Node_Str"" + targetDs.getName());
          vcVm.detachVirtualDisk(new DeviceId(swapDisk.getExternalAddress()),true);
          AllocationType allocType=swapDisk.getAllocType() == null ? null : AllocationType.valueOf(swapDisk.getAllocType());
          DiskCreateSpec[] addDisks={new DiskCreateSpec(new DeviceId(swapDisk.getExternalAddress()),targetDs,swapDisk.getName(),DiskMode.independent_persistent,DiskSize.sizeFromMB(newSwapSizeInMB),allocType)};
          vcVm.changeDisks(null,addDisks);
        }
      }
      vcVm.reconfigure(newConfigSpec);
      return null;
    }
    protected boolean isTaskSession(){
      return true;
    }
  }
);
}"
48918,"@Override protected Void body() throws Exception {
  ConfigSpecImpl newConfigSpec=new ConfigSpecImpl();
  if (cpuNumber > 0) {
    newConfigSpec.setNumCPUs(cpuNumber);
  }
  if (memory > 0) {
    VmConfigUtil.setMemoryAndBalloon(newConfigSpec,memory);
    if (targetDs != null) {
      VirtualDisk vmSwapDisk=VcVmUtil.findVirtualDisk(vmId,swapDisk.getExternalAddress());
      logger.info(""String_Node_Str"" + swapDisk.getDatastoreName());
      logger.info(""String_Node_Str"" + targetDs.getName());
      if (swapDisk.getDatastoreMoId().equals(targetDs.getId())) {
        VirtualDeviceSpec devSpec=new VirtualDeviceSpecImpl();
        devSpec.setOperation(VirtualDeviceSpec.Operation.edit);
        vmSwapDisk.setCapacityInKB(newSwapSizeInMB * 1024);
        devSpec.setDevice(vmSwapDisk);
        VirtualDeviceSpec[] changes={devSpec};
        newConfigSpec.setDeviceChange(changes);
        logger.info(""String_Node_Str"");
      }
 else {
        vcVm.detachVirtualDisk(new DeviceId(swapDisk.getExternalAddress()),true);
        AllocationType allocType=swapDisk.getAllocType() == null ? null : AllocationType.valueOf(swapDisk.getAllocType());
        DiskCreateSpec[] addDisks={new DiskCreateSpec(new DeviceId(swapDisk.getExternalAddress()),targetDs,swapDisk.getName(),DiskMode.independent_persistent,DiskSize.sizeFromMB(newSwapSizeInMB),allocType)};
        vcVm.changeDisks(null,addDisks);
      }
    }
  }
  vcVm.reconfigure(newConfigSpec);
  return null;
}","@Override protected Void body() throws Exception {
  ConfigSpecImpl newConfigSpec=new ConfigSpecImpl();
  if (cpuNumber > 0) {
    newConfigSpec.setNumCPUs(cpuNumber);
  }
  if (memory > 0) {
    VmConfigUtil.setMemoryAndBalloon(newConfigSpec,memory);
    if (targetDs != null) {
      logger.info(""String_Node_Str"" + swapDisk.getDatastoreName());
      logger.info(""String_Node_Str"" + targetDs.getName());
      vcVm.detachVirtualDisk(new DeviceId(swapDisk.getExternalAddress()),true);
      AllocationType allocType=swapDisk.getAllocType() == null ? null : AllocationType.valueOf(swapDisk.getAllocType());
      DiskCreateSpec[] addDisks={new DiskCreateSpec(new DeviceId(swapDisk.getExternalAddress()),targetDs,swapDisk.getName(),DiskMode.independent_persistent,DiskSize.sizeFromMB(newSwapSizeInMB),allocType)};
      vcVm.changeDisks(null,addDisks);
    }
  }
  vcVm.reconfigure(newConfigSpec);
  return null;
}"
48919,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void resizeCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String nodeGroup,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final int instanceNum,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final int cpuNumber,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final long memory){
  if ((instanceNum > 1 && cpuNumber == 0 && memory == 0) || (instanceNum == 0 && cpuNumber > 0 && memory == 0) || (instanceNum == 0 && cpuNumber == 0 && memory > 0)|| (instanceNum == 0 && cpuNumber > 0 && memory > 0)) {
    try {
      ClusterRead cluster=restClient.get(name,false);
      if (cluster == null) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"" + name + ""String_Node_Str"");
        return;
      }
      List<NodeGroupRead> ngs=cluster.getNodeGroups();
      boolean found=false;
      for (      NodeGroupRead ng : ngs) {
        if (ng.getName().equals(nodeGroup)) {
          found=true;
          if (ng.getRoles() != null && ng.getRoles().contains(HadoopRole.ZOOKEEPER_ROLE.toString()) && instanceNum > 1) {
            CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.ZOOKEEPER_NOT_RESIZE);
            return;
          }
          break;
        }
      }
      if (!found) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"" + nodeGroup + ""String_Node_Str"");
        return;
      }
      TaskRead taskRead=null;
      if (instanceNum > 1) {
        restClient.resize(name,nodeGroup,instanceNum);
      }
 else       if (cpuNumber > 0 || memory > 0) {
        if (cluster.getStatus().ordinal() != ClusterStatus.RUNNING.ordinal()) {
          CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
          return;
        }
        ResourceScale resScale=new ResourceScale(name,nodeGroup,cpuNumber,memory);
        taskRead=restClient.scale(resScale);
      }
      CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_RESIZE);
      if (taskRead != null) {
        System.out.println();
        printScaleReport(taskRead,name,nodeGroup);
      }
    }
 catch (    CliRestException e) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    }
  }
 else {
    if (instanceNum > 1 && (cpuNumber > 0 || memory > 0)) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + instanceNum+ ""String_Node_Str""+ cpuNumber+ ""String_Node_Str""+ memory);
    }
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void resizeCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String nodeGroup,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final int instanceNum,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final int cpuNumber,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final long memory){
  if ((instanceNum > 0 && cpuNumber == 0 && memory == 0) || (instanceNum == 0 && (cpuNumber > 0 || memory > 0))) {
    try {
      ClusterRead cluster=restClient.get(name,false);
      if (cluster == null) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"" + name + ""String_Node_Str"");
        return;
      }
      List<NodeGroupRead> ngs=cluster.getNodeGroups();
      boolean found=false;
      for (      NodeGroupRead ng : ngs) {
        if (ng.getName().equals(nodeGroup)) {
          found=true;
          if (ng.getRoles() != null && ng.getRoles().contains(HadoopRole.ZOOKEEPER_ROLE.toString()) && instanceNum > 1) {
            CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.ZOOKEEPER_NOT_RESIZE);
            return;
          }
          break;
        }
      }
      if (!found) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"" + nodeGroup + ""String_Node_Str"");
        return;
      }
      TaskRead taskRead=null;
      if (instanceNum > 0) {
        restClient.resize(name,nodeGroup,instanceNum);
      }
 else       if (cpuNumber > 0 || memory > 0) {
        if (cluster.getStatus().ordinal() != ClusterStatus.RUNNING.ordinal()) {
          CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
          return;
        }
        ResourceScale resScale=new ResourceScale(name,nodeGroup,cpuNumber,memory);
        taskRead=restClient.scale(resScale);
      }
      CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_RESIZE);
      if (taskRead != null) {
        System.out.println();
        printScaleReport(taskRead,name,nodeGroup);
      }
    }
 catch (    CliRestException e) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    }
  }
 else {
    if (instanceNum > 0 && (cpuNumber > 0 || memory > 0)) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
    }
 else     if (instanceNum == 0 && cpuNumber == 0 && memory == 0) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,""String_Node_Str"");
    }
 else {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESIZE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + (instanceNum < 0 ? ""String_Node_Str"" + instanceNum + ""String_Node_Str"" : ""String_Node_Str"") + (cpuNumber < 0 ? ""String_Node_Str"" + cpuNumber + ""String_Node_Str"" : ""String_Node_Str"")+ (memory < 0 ? ""String_Node_Str"" + memory : ""String_Node_Str""));
    }
  }
}"
48920,"/** 
 * cluster create, resize, resume will all call this method for static ip allocation the network contains all allocated ip address to this cluster, so some of them may already be occupied by existing node. So we need to detect if that ip is allocated, before assign that one to one node
 * @param networkAdd
 * @param vNodes
 * @param occupiedIps
 */
private void allocateStaticIp(NetworkAdd networkAdd,List<BaseNode> vNodes,Set<String> occupiedIps){
  if (networkAdd.isDhcp()) {
    logger.info(""String_Node_Str"");
    return;
  }
  logger.info(""String_Node_Str"");
  List<String> availableIps=IpBlock.getIpAddressFromIpBlock(networkAdd.getIp());
  AuAssert.check(availableIps.size() == vNodes.size());
  for (int i=0; i < availableIps.size(); i++) {
    if (occupiedIps.contains(availableIps.get(i))) {
      continue;
    }
    vNodes.get(i).setIpAddress(availableIps.get(i));
  }
  logger.info(""String_Node_Str"");
}","/** 
 * cluster create, resize, resume will all call this method for static ip allocation the network contains all allocated ip address to this cluster, so some of them may already be occupied by existing node. So we need to detect if that ip is allocated, before assign that one to one node
 * @param networkAdd
 * @param vNodes
 * @param occupiedIps
 */
private void allocateStaticIp(NetworkAdd networkAdd,List<BaseNode> vNodes,Set<String> occupiedIps){
  if (networkAdd.isDhcp()) {
    logger.info(""String_Node_Str"");
    return;
  }
  logger.info(""String_Node_Str"");
  List<String> availableIps=IpBlock.getIpAddressFromIpBlock(networkAdd.getIp());
  availableIps.removeAll(occupiedIps);
  AuAssert.check(availableIps.size() == vNodes.size());
  for (int i=0; i < availableIps.size(); i++) {
    vNodes.get(i).setIpAddress(availableIps.get(i));
  }
  logger.info(""String_Node_Str"");
}"
48921,"public static boolean setBaseNodeForVm(BaseNode vNode,VcVirtualMachine vm){
  boolean success=true;
  String vmName=vm.getName();
  vm=VcCache.getIgnoreMissing(vm.getId());
  if (vm == null) {
    logger.info(""String_Node_Str"" + vmName + ""String_Node_Str"");
  }
  String ip=null;
  if (vm != null) {
    ip=VcVmUtil.getIpAddress(vm,false);
  }
  if (ip != null) {
    vNode.setSuccess(true);
    vNode.setIpAddress(ip);
    vNode.setGuestHostName(VcVmUtil.getGuestHostName(vm,false));
    vNode.setTargetHost(vm.getHost().getName());
    vNode.setVmMobId(vm.getId());
    if (vm.isPoweredOn()) {
      vNode.setNodeStatus(NodeStatus.VM_READY);
      vNode.setNodeAction(null);
    }
 else {
      vNode.setNodeStatus(NodeStatus.POWERED_OFF);
      vNode.setNodeAction(Constants.NODE_ACTION_CLONING_FAILED);
    }
  }
 else {
    vNode.setSuccess(false);
    if (vm != null) {
      vNode.setVmMobId(vm.getId());
      if (vm.isPoweredOn()) {
        vNode.setNodeStatus(NodeStatus.POWERED_ON);
        vNode.setNodeAction(Constants.NODE_ACTION_GET_IP_FAILED);
      }
 else {
        vNode.setNodeStatus(NodeStatus.POWERED_OFF);
        vNode.setNodeAction(Constants.NODE_ACTION_CLONING_FAILED);
      }
    }
    success=false;
    logger.error(""String_Node_Str"" + vNode.getVmName());
  }
  if (success) {
    String haFlag=vNode.getNodeGroup().getHaFlag();
    if (haFlag != null && Constants.HA_FLAG_FT.equals(haFlag.toLowerCase())) {
      logger.error(""String_Node_Str"" + vm.getName() + ""String_Node_Str""+ ""String_Node_Str""+ vm.getFTState()+ ""String_Node_Str"");
      return verifyFTState(vm);
    }
  }
  return success;
}","public static boolean setBaseNodeForVm(BaseNode vNode,VcVirtualMachine vm){
  boolean success=true;
  String vmName=vm.getName();
  vm=VcCache.getIgnoreMissing(vm.getId());
  if (vm == null) {
    logger.info(""String_Node_Str"" + vmName + ""String_Node_Str"");
  }
  String ip=null;
  if (vm != null) {
    ip=VcVmUtil.getIpAddress(vm,false);
  }
  if (ip != null) {
    vNode.setSuccess(true);
    vNode.setIpAddress(ip);
    vNode.setGuestHostName(VcVmUtil.getGuestHostName(vm,false));
    vNode.setTargetHost(vm.getHost().getName());
    vNode.setVmMobId(vm.getId());
    if (vm.isPoweredOn()) {
      vNode.setNodeStatus(NodeStatus.VM_READY);
      vNode.setNodeAction(null);
    }
 else {
      vNode.setNodeStatus(NodeStatus.POWERED_OFF);
      vNode.setNodeAction(Constants.NODE_ACTION_CLONING_FAILED);
    }
  }
 else {
    vNode.setSuccess(false);
    vNode.setIpAddress(null);
    if (vm != null) {
      vNode.setVmMobId(vm.getId());
      if (vm.isPoweredOn()) {
        vNode.setNodeStatus(NodeStatus.POWERED_ON);
        vNode.setNodeAction(Constants.NODE_ACTION_GET_IP_FAILED);
      }
 else {
        vNode.setNodeStatus(NodeStatus.POWERED_OFF);
        vNode.setNodeAction(Constants.NODE_ACTION_CLONING_FAILED);
      }
    }
    success=false;
    logger.error(""String_Node_Str"" + vNode.getVmName());
  }
  if (success) {
    String haFlag=vNode.getNodeGroup().getHaFlag();
    if (haFlag != null && Constants.HA_FLAG_FT.equals(haFlag.toLowerCase())) {
      logger.error(""String_Node_Str"" + vm.getName() + ""String_Node_Str""+ ""String_Node_Str""+ vm.getFTState()+ ""String_Node_Str"");
      return verifyFTState(vm);
    }
  }
  return success;
}"
48922,"private void deleteChildRps(String hadoopClusterName,List<BaseNode> vNodes){
  logger.info(""String_Node_Str"" + hadoopClusterName);
  Map<String,Map<String,VcResourcePool>> clusterMap=new HashMap<String,Map<String,VcResourcePool>>();
  for (  BaseNode node : vNodes) {
    String vcClusterName=node.getTargetVcCluster();
    String vcRpName=node.getTargetRp();
    if (clusterMap.get(vcClusterName) == null) {
      clusterMap.put(vcClusterName,new HashMap<String,VcResourcePool>());
    }
    Map<String,VcResourcePool> rpMap=clusterMap.get(vcClusterName);
    if (rpMap.get(vcRpName) == null) {
      VcResourcePool vcRp=VcResourceUtils.findRPInVCCluster(vcClusterName,vcRpName);
      rpMap.put(vcRpName,vcRp);
    }
  }
  List<VcResourcePool> rps=new ArrayList<VcResourcePool>();
  for (  Map<String,VcResourcePool> map : clusterMap.values()) {
    rps.addAll(map.values());
  }
  Callable<Void>[] storedProcedures=new Callable[rps.size()];
  String childRp=ConfigInfo.getSerengetiUUID() + ""String_Node_Str"" + hadoopClusterName;
  int i=0;
  for (  VcResourcePool rp : rps) {
    DeleteRpSp sp=new DeleteRpSp(rp,childRp);
    storedProcedures[i]=sp;
    i++;
  }
  try {
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storedProcedures,callback);
    if (result == null || result.length == 0) {
      logger.error(""String_Node_Str"");
      return;
    }
    int total=0;
    for (int j=0; j < storedProcedures.length; j++) {
      if (result[j].throwable != null) {
        DeleteRpSp sp=(DeleteRpSp)storedProcedures[j];
        logger.error(""String_Node_Str"" + sp.getDeleteRpName() + ""String_Node_Str""+ sp.getVcRp(),result[j].throwable);
      }
 else {
        total++;
      }
    }
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}","private void deleteChildRps(String hadoopClusterName,List<BaseNode> vNodes){
  logger.info(""String_Node_Str"" + hadoopClusterName);
  Map<String,Map<String,VcResourcePool>> clusterMap=new HashMap<String,Map<String,VcResourcePool>>();
  for (  BaseNode node : vNodes) {
    String vcClusterName=node.getTargetVcCluster();
    AuAssert.check(vcClusterName != null);
    String vcRpName=node.getTargetRp();
    if (clusterMap.get(vcClusterName) == null) {
      clusterMap.put(vcClusterName,new HashMap<String,VcResourcePool>());
    }
    Map<String,VcResourcePool> rpMap=clusterMap.get(vcClusterName);
    if (rpMap.get(vcRpName) == null) {
      VcResourcePool vcRp=VcResourceUtils.findRPInVCCluster(vcClusterName,vcRpName);
      if (vcRp != null) {
        rpMap.put(vcRpName,vcRp);
      }
    }
  }
  List<VcResourcePool> rps=new ArrayList<VcResourcePool>();
  for (  Map<String,VcResourcePool> map : clusterMap.values()) {
    rps.addAll(map.values());
  }
  Callable<Void>[] storedProcedures=new Callable[rps.size()];
  String childRp=ConfigInfo.getSerengetiUUID() + ""String_Node_Str"" + hadoopClusterName;
  int i=0;
  for (  VcResourcePool rp : rps) {
    DeleteRpSp sp=new DeleteRpSp(rp,childRp);
    storedProcedures[i]=sp;
    i++;
  }
  try {
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storedProcedures,callback);
    if (result == null || result.length == 0) {
      logger.error(""String_Node_Str"");
      return;
    }
    int total=0;
    for (int j=0; j < storedProcedures.length; j++) {
      if (result[j].throwable != null) {
        DeleteRpSp sp=(DeleteRpSp)storedProcedures[j];
        logger.error(""String_Node_Str"" + sp.getDeleteRpName() + ""String_Node_Str""+ sp.getVcRp(),result[j].throwable);
      }
 else {
        total++;
      }
    }
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}"
48923,"@Transactional private void replaceNodeEntity(BaseNode vNode){
  logger.info(""String_Node_Str"" + vNode.getVmName());
  ClusterEntity cluster=getClusterEntityMgr().findByName(vNode.getClusterName());
  AuAssert.check(cluster != null);
  NodeGroupEntity nodeGroupEntity=getClusterEntityMgr().findByName(vNode.getClusterName(),vNode.getGroupName());
  AuAssert.check(nodeGroupEntity != null);
  if (nodeGroupEntity.getNodes() == null) {
    nodeGroupEntity.setNodes(new LinkedList<NodeEntity>());
  }
  boolean insert=false;
  NodeEntity nodeEntity=getClusterEntityMgr().findByName(nodeGroupEntity,vNode.getVmName());
  if (nodeEntity == null) {
    nodeEntity=new NodeEntity();
    nodeGroupEntity.getNodes().add(nodeEntity);
    insert=true;
  }
  nodeEntity.setVmName(vNode.getVmName());
  setNodeStatus(nodeEntity,vNode);
  if (vNode.getVmMobId() == null && nodeEntity.getMoId() != null) {
    vNode.setVmMobId(nodeEntity.getMoId());
  }
  if (vNode.getVmMobId() != null) {
    nodeEntity.setMoId(vNode.getVmMobId());
    nodeEntity.setRack(vNode.getTargetRack());
    nodeEntity.setHostName(vNode.getTargetHost());
    nodeEntity.setIpAddress(vNode.getIpAddress());
    nodeEntity.setGuestHostName(vNode.getGuestHostName());
    nodeEntity.setCpuNum(vNode.getCpu());
    nodeEntity.setMemorySize((long)vNode.getMem());
    nodeEntity.setVcRp(rpDao.findByClusterAndRp(vNode.getTargetVcCluster(),vNode.getTargetRp()));
    Set<DiskEntity> diskEntities=nodeEntity.getDisks();
    DiskEntity systemDisk=nodeEntity.findSystemDisk();
    if (systemDisk == null)     systemDisk=new DiskEntity(nodeEntity.getVmName() + ""String_Node_Str"");
    systemDisk.setDiskType(DiskType.SYSTEM_DISK.getType());
    systemDisk.setExternalAddress(DiskEntity.getSystemDiskExternalAddress());
    systemDisk.setNodeEntity(nodeEntity);
    systemDisk.setDatastoreName(vNode.getTargetDs());
    VcVmUtil.populateDiskInfo(systemDisk,vNode.getVmMobId());
    diskEntities.add(systemDisk);
    char c=DATA_DISK_START_INDEX;
    for (    Disk disk : vNode.getVmSchema().diskSchema.getDisks()) {
      DiskEntity newDisk=nodeEntity.findDisk(disk.name);
      if (newDisk == null) {
        newDisk=new DiskEntity(disk.name);
        diskEntities.add(newDisk);
      }
      newDisk.setSizeInMB(disk.initialSizeMB);
      newDisk.setAllocType(disk.allocationType.toString());
      newDisk.setDatastoreName(disk.datastore);
      newDisk.setDiskType(disk.type);
      newDisk.setExternalAddress(disk.externalAddress);
      newDisk.setNodeEntity(nodeEntity);
      VcVmUtil.populateDiskInfo(newDisk,vNode.getVmMobId());
      if (DiskType.SWAP_DISK.getType().equals(disk.type)) {
        newDisk.setDeviceName(SWAP_DEVICE_NAME);
      }
 else {
        newDisk.setDeviceName(DEVICE_NAME_PREFIX + (c++));
      }
    }
  }
  nodeEntity.setNodeGroup(nodeGroupEntity);
  if (insert) {
    getClusterEntityMgr().insert(nodeEntity);
  }
 else {
    getClusterEntityMgr().update(nodeEntity);
  }
  logger.info(""String_Node_Str"" + vNode.getVmName());
}","@Transactional private void replaceNodeEntity(BaseNode vNode){
  logger.info(""String_Node_Str"" + vNode.getVmName());
  ClusterEntity cluster=getClusterEntityMgr().findByName(vNode.getClusterName());
  AuAssert.check(cluster != null);
  NodeGroupEntity nodeGroupEntity=getClusterEntityMgr().findByName(vNode.getClusterName(),vNode.getGroupName());
  AuAssert.check(nodeGroupEntity != null);
  if (nodeGroupEntity.getNodes() == null) {
    nodeGroupEntity.setNodes(new LinkedList<NodeEntity>());
  }
  boolean insert=false;
  NodeEntity nodeEntity=getClusterEntityMgr().findByName(nodeGroupEntity,vNode.getVmName());
  if (nodeEntity == null) {
    nodeEntity=new NodeEntity();
    nodeGroupEntity.getNodes().add(nodeEntity);
    insert=true;
  }
  nodeEntity.setVmName(vNode.getVmName());
  setNodeStatus(nodeEntity,vNode);
  if (vNode.getVmMobId() == null && nodeEntity.getMoId() != null) {
    vNode.setVmMobId(nodeEntity.getMoId());
  }
  nodeEntity.setVcRp(rpDao.findByClusterAndRp(vNode.getTargetVcCluster(),vNode.getTargetRp()));
  if (vNode.getVmMobId() != null) {
    nodeEntity.setMoId(vNode.getVmMobId());
    nodeEntity.setRack(vNode.getTargetRack());
    nodeEntity.setHostName(vNode.getTargetHost());
    nodeEntity.setIpAddress(vNode.getIpAddress());
    nodeEntity.setGuestHostName(vNode.getGuestHostName());
    nodeEntity.setCpuNum(vNode.getCpu());
    nodeEntity.setMemorySize((long)vNode.getMem());
    Set<DiskEntity> diskEntities=nodeEntity.getDisks();
    DiskEntity systemDisk=nodeEntity.findSystemDisk();
    if (systemDisk == null)     systemDisk=new DiskEntity(nodeEntity.getVmName() + ""String_Node_Str"");
    systemDisk.setDiskType(DiskType.SYSTEM_DISK.getType());
    systemDisk.setExternalAddress(DiskEntity.getSystemDiskExternalAddress());
    systemDisk.setNodeEntity(nodeEntity);
    systemDisk.setDatastoreName(vNode.getTargetDs());
    VcVmUtil.populateDiskInfo(systemDisk,vNode.getVmMobId());
    diskEntities.add(systemDisk);
    char c=DATA_DISK_START_INDEX;
    for (    Disk disk : vNode.getVmSchema().diskSchema.getDisks()) {
      DiskEntity newDisk=nodeEntity.findDisk(disk.name);
      if (newDisk == null) {
        newDisk=new DiskEntity(disk.name);
        diskEntities.add(newDisk);
      }
      newDisk.setSizeInMB(disk.initialSizeMB);
      newDisk.setAllocType(disk.allocationType.toString());
      newDisk.setDatastoreName(disk.datastore);
      newDisk.setDiskType(disk.type);
      newDisk.setExternalAddress(disk.externalAddress);
      newDisk.setNodeEntity(nodeEntity);
      VcVmUtil.populateDiskInfo(newDisk,vNode.getVmMobId());
      if (DiskType.SWAP_DISK.getType().equals(disk.type)) {
        newDisk.setDeviceName(SWAP_DEVICE_NAME);
      }
 else {
        newDisk.setDeviceName(DEVICE_NAME_PREFIX + (c++));
      }
    }
  }
  nodeEntity.setNodeGroup(nodeGroupEntity);
  if (insert) {
    getClusterEntityMgr().insert(nodeEntity);
  }
 else {
    getClusterEntityMgr().update(nodeEntity);
  }
  logger.info(""String_Node_Str"" + vNode.getVmName());
}"
48924,"@Override protected Integer body() throws Exception {
  final VcVirtualMachine vcVm=VcCache.getIgnoreMissing(vmId);
  if (vcVm == null) {
    logger.info(""String_Node_Str"" + vmId + ""String_Node_Str"");
    return -1;
  }
  VirtualMachine vimVm=vcVm.getManagedObject();
  EnvironmentBrowser envBrowser=MoUtil.getManagedObject(vimVm.getEnvironmentBrowser());
  ConfigOption configOption=envBrowser.queryConfigOption(null,null);
  int hardwareVersion=configOption.getHardwareOptions().getHwVersion();
  logger.info(""String_Node_Str"" + hardwareVersion);
  return hardwareVersion;
}","@Override protected Integer body() throws Exception {
  VirtualMachine vimVm=vcVm.getManagedObject();
  EnvironmentBrowser envBrowser=MoUtil.getManagedObject(vimVm.getEnvironmentBrowser());
  ConfigOption configOption=envBrowser.queryConfigOption(null,null);
  int hardwareVersion=configOption.getHardwareOptions().getHwVersion();
  logger.info(""String_Node_Str"" + hardwareVersion);
  return hardwareVersion;
}"
48925,"public static void checkVmMaxConfiguration(final String vmId,final int cpuNumber,final long memory){
  int hardwareVersion=VcContext.inVcSessionDo(new VcSession<Integer>(){
    @Override protected Integer body() throws Exception {
      final VcVirtualMachine vcVm=VcCache.getIgnoreMissing(vmId);
      if (vcVm == null) {
        logger.info(""String_Node_Str"" + vmId + ""String_Node_Str"");
        return -1;
      }
      VirtualMachine vimVm=vcVm.getManagedObject();
      EnvironmentBrowser envBrowser=MoUtil.getManagedObject(vimVm.getEnvironmentBrowser());
      ConfigOption configOption=envBrowser.queryConfigOption(null,null);
      int hardwareVersion=configOption.getHardwareOptions().getHwVersion();
      logger.info(""String_Node_Str"" + hardwareVersion);
      return hardwareVersion;
    }
  }
);
  compareMaxConfiguration(vmId,hardwareVersion,cpuNumber,memory);
}","public static void checkVmMaxConfiguration(final String vmId,final int cpuNumber,final long memory){
  final VcVirtualMachine vcVm=VcCache.getIgnoreMissing(vmId);
  int hardwareVersion=0;
  if (vcVm == null) {
    logger.info(""String_Node_Str"" + vmId + ""String_Node_Str"");
    hardwareVersion=-1;
  }
 else {
    hardwareVersion=VcContext.inVcSessionDo(new VcSession<Integer>(){
      @Override protected Integer body() throws Exception {
        VirtualMachine vimVm=vcVm.getManagedObject();
        EnvironmentBrowser envBrowser=MoUtil.getManagedObject(vimVm.getEnvironmentBrowser());
        ConfigOption configOption=envBrowser.queryConfigOption(null,null);
        int hardwareVersion=configOption.getHardwareOptions().getHwVersion();
        logger.info(""String_Node_Str"" + hardwareVersion);
        return hardwareVersion;
      }
    }
);
  }
  compareMaxConfiguration(vcVm.getName(),hardwareVersion,cpuNumber,memory);
}"
48926,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String topology,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean alwaysAnswerYes){
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
 else   if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_BLANK_SPACE);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (type != null) {
    ClusterType clusterType=ClusterType.getByDescription(type);
    if (clusterType == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ type);
      return;
    }
    clusterCreate.setType(clusterType);
  }
 else   if (specFilePath == null) {
    clusterCreate.setType(ClusterType.HDFS_MAPRED);
  }
  if (topology != null) {
    try {
      clusterCreate.setTopologyPolicy(TopologyType.valueOf(topology));
    }
 catch (    IllegalArgumentException ex) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ topology);
      return;
    }
  }
 else {
    clusterCreate.setTopologyPolicy(TopologyType.NONE);
  }
  try {
    if (distro != null) {
      List<String> distroNames=getDistroNames();
      if (validName(distro,distroNames)) {
        clusterCreate.setDistro(distro);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
        return;
      }
    }
 else {
      String defaultDistroName=clusterCreate.getDefaultDistroName(distroRestClient.getAll());
      if (CommandsUtils.isBlank(defaultDistroName)) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM__NO_DEFAULT_DISTRO);
        return;
      }
 else {
        clusterCreate.setDistro(defaultDistroName);
      }
    }
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  DistroRead distroRead=distroRestClient.get(clusterCreate.getDistro());
  clusterCreate.setDistroVendor(distroRead.getVendor());
  clusterCreate.setDistroVersion(distroRead.getVersion());
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  List<String> networkNames=null;
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setSpecFile(true);
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
    }
    networkNames=getNetworkNames();
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  if (networkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_EXISTED);
    return;
  }
 else {
    if (networkName != null) {
      if (validName(networkName,networkNames)) {
        clusterCreate.setNetworkName(networkName);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + networkNames);
        return;
      }
    }
 else {
      if (networkNames.size() == 1) {
        clusterCreate.setNetworkName(networkNames.get(0));
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
        return;
      }
    }
  }
  clusterCreate.validateCDHVersion(warningMsgList);
  if (specFilePath != null && !clusterCreate.getDistro().equalsIgnoreCase(com.vmware.bdd.utils.Constants.MAPR_VENDOR)) {
    List<String> distroRoles=findDistroRoles(clusterCreate);
    clusterCreate.validateClusterCreate(failedMsgList,warningMsgList,distroRoles);
  }
  if (type != null && specFilePath != null) {
    warningMsgList.add(Constants.TYPE_SPECFILE_CONFLICT);
  }
  if (!failedMsgList.isEmpty()) {
    showFailedMsg(clusterCreate.getName(),failedMsgList);
    return;
  }
  try {
    if (!CommandsUtils.showWarningMsg(clusterCreate.getName(),Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,warningMsgList,alwaysAnswerYes)) {
      return;
    }
    restClient.create(clusterCreate);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String topology,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean alwaysAnswerYes){
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
 else   if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_BLANK_SPACE);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (type != null) {
    ClusterType clusterType=ClusterType.getByDescription(type);
    if (clusterType == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ type);
      return;
    }
    clusterCreate.setType(clusterType);
  }
 else   if (specFilePath == null) {
    clusterCreate.setType(ClusterType.HDFS_MAPRED);
  }
  if (topology != null) {
    try {
      clusterCreate.setTopologyPolicy(TopologyType.valueOf(topology));
    }
 catch (    IllegalArgumentException ex) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ topology);
      return;
    }
  }
 else {
    clusterCreate.setTopologyPolicy(TopologyType.NONE);
  }
  try {
    if (distro != null) {
      List<String> distroNames=getDistroNames();
      if (validName(distro,distroNames)) {
        clusterCreate.setDistro(distro);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
        return;
      }
    }
 else {
      String defaultDistroName=clusterCreate.getDefaultDistroName(distroRestClient.getAll());
      if (CommandsUtils.isBlank(defaultDistroName)) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM__NO_DEFAULT_DISTRO);
        return;
      }
 else {
        clusterCreate.setDistro(defaultDistroName);
      }
    }
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  DistroRead distroRead=distroRestClient.get(clusterCreate.getDistro());
  clusterCreate.setDistroVendor(distroRead.getVendor());
  clusterCreate.setDistroVersion(distroRead.getVersion());
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  List<String> networkNames=null;
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setSpecFile(true);
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
    }
    networkNames=getNetworkNames();
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  if (networkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_EXISTED);
    return;
  }
 else {
    if (networkName != null) {
      if (validName(networkName,networkNames)) {
        clusterCreate.setNetworkName(networkName);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + networkNames);
        return;
      }
    }
 else {
      if (networkNames.size() == 1) {
        clusterCreate.setNetworkName(networkNames.get(0));
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
        return;
      }
    }
  }
  clusterCreate.validateCDHVersion(warningMsgList);
  if (specFilePath != null && !clusterCreate.getDistro().equalsIgnoreCase(com.vmware.bdd.utils.Constants.MAPR_VENDOR)) {
    List<String> distroRoles=findDistroRoles(clusterCreate);
    clusterCreate.validateClusterCreate(failedMsgList,warningMsgList,distroRoles);
  }
  if (type != null && specFilePath != null) {
    warningMsgList.add(Constants.TYPE_SPECFILE_CONFLICT);
  }
  if (!failedMsgList.isEmpty()) {
    showFailedMsg(clusterCreate.getName(),failedMsgList);
    return;
  }
  try {
    if (!CommandsUtils.showWarningMsg(clusterCreate.getName(),Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,warningMsgList,alwaysAnswerYes)) {
      return;
    }
    restClient.create(clusterCreate);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,CommandsUtils.getExceptionMessage(e));
  }
}"
48927,"/** 
 * Disconnect the session
 */
public void disconnect(){
  try {
    checkConnection();
    logout(Constants.REST_PATH_LOGOUT,String.class);
  }
 catch (  CliRestException cliRestException) {
    if (cliRestException.getStatus() == HttpStatus.UNAUTHORIZED) {
      writeCookieInfo(""String_Node_Str"");
    }
  }
catch (  Exception e) {
    System.out.println(Constants.DISCONNECT_FAILURE + ""String_Node_Str"" + getExceptionMessage(e));
  }
}","/** 
 * Disconnect the session
 */
public void disconnect(){
  try {
    checkConnection();
    logout(Constants.REST_PATH_LOGOUT,String.class);
  }
 catch (  CliRestException cliRestException) {
    if (cliRestException.getStatus() == HttpStatus.UNAUTHORIZED) {
      writeCookieInfo(""String_Node_Str"");
    }
  }
catch (  Exception e) {
    System.out.println(Constants.DISCONNECT_FAILURE + ""String_Node_Str"" + CommandsUtils.getExceptionMessage(e));
  }
}"
48928,"/** 
 * Update an object
 * @param entity the updated content
 * @param path the rest url
 * @param verb the http method
 * @param prettyOutput output callback
 */
public void update(Object entity,final String path,final HttpMethod verb,PrettyOutput... prettyOutput){
  checkConnection();
  try {
    if (verb == HttpMethod.PUT) {
      ResponseEntity<String> response=restUpdate(path,entity);
      if (!validateAuthorization(response)) {
        return;
      }
      processResponse(response,HttpMethod.PUT,prettyOutput);
    }
 else {
      throw new Exception(Constants.HTTP_VERB_ERROR);
    }
  }
 catch (  Exception e) {
    throw new CliRestException(getExceptionMessage(e));
  }
}","/** 
 * Update an object
 * @param entity the updated content
 * @param path the rest url
 * @param verb the http method
 * @param prettyOutput output callback
 */
public void update(Object entity,final String path,final HttpMethod verb,PrettyOutput... prettyOutput){
  checkConnection();
  try {
    if (verb == HttpMethod.PUT) {
      ResponseEntity<String> response=restUpdate(path,entity);
      if (!validateAuthorization(response)) {
        return;
      }
      processResponse(response,HttpMethod.PUT,prettyOutput);
    }
 else {
      throw new Exception(Constants.HTTP_VERB_ERROR);
    }
  }
 catch (  Exception e) {
    throw new CliRestException(CommandsUtils.getExceptionMessage(e));
  }
}"
48929,"public TaskRead updateWithReturn(Object entity,final String path,final HttpMethod verb,PrettyOutput... prettyOutput){
  checkConnection();
  try {
    if (verb == HttpMethod.PUT) {
      ResponseEntity<String> response=restUpdate(path,entity);
      if (!validateAuthorization(response)) {
        return null;
      }
      return processResponse(response,HttpMethod.PUT,prettyOutput);
    }
 else {
      throw new Exception(Constants.HTTP_VERB_ERROR);
    }
  }
 catch (  Exception e) {
    throw new CliRestException(getExceptionMessage(e));
  }
}","public TaskRead updateWithReturn(Object entity,final String path,final HttpMethod verb,PrettyOutput... prettyOutput){
  checkConnection();
  try {
    if (verb == HttpMethod.PUT) {
      ResponseEntity<String> response=restUpdate(path,entity);
      if (!validateAuthorization(response)) {
        return null;
      }
      return processResponse(response,HttpMethod.PUT,prettyOutput);
    }
 else {
      throw new Exception(Constants.HTTP_VERB_ERROR);
    }
  }
 catch (  Exception e) {
    throw new CliRestException(CommandsUtils.getExceptionMessage(e));
  }
}"
48930,"/** 
 * process requests with query parameters
 * @param id
 * @param path the rest url
 * @param verb the http method
 * @param queryStrings required query strings
 * @param prettyOutput output callback
 */
public void actionOps(final String id,final String path,final HttpMethod verb,final Map<String,String> queryStrings,PrettyOutput... prettyOutput){
  checkConnection();
  try {
    if (verb == HttpMethod.PUT) {
      ResponseEntity<String> response=restActionOps(path,id,queryStrings);
      if (!validateAuthorization(response)) {
        return;
      }
      processResponse(response,HttpMethod.PUT,prettyOutput);
    }
 else {
      throw new Exception(Constants.HTTP_VERB_ERROR);
    }
  }
 catch (  Exception e) {
    throw new CliRestException(getExceptionMessage(e));
  }
}","/** 
 * process requests with query parameters
 * @param id
 * @param path the rest url
 * @param verb the http method
 * @param queryStrings required query strings
 * @param prettyOutput output callback
 */
public void actionOps(final String id,final String path,final HttpMethod verb,final Map<String,String> queryStrings,PrettyOutput... prettyOutput){
  checkConnection();
  try {
    if (verb == HttpMethod.PUT) {
      ResponseEntity<String> response=restActionOps(path,id,queryStrings);
      if (!validateAuthorization(response)) {
        return;
      }
      processResponse(response,HttpMethod.PUT,prettyOutput);
    }
 else {
      throw new Exception(Constants.HTTP_VERB_ERROR);
    }
  }
 catch (  Exception e) {
    throw new CliRestException(CommandsUtils.getExceptionMessage(e));
  }
}"
48931,"/** 
 * Generic method to get all objects of a type
 * @param entityType object type
 * @param path the rest url
 * @param verb the http method
 * @param detail flag to retrieve detailed information or not
 * @return the objects
 */
public <T>T getAllObjects(final Class<T> entityType,final String path,final HttpMethod verb,final boolean detail){
  checkConnection();
  try {
    if (verb == HttpMethod.GET) {
      ResponseEntity<T> response=restGet(path,entityType,detail);
      if (!validateAuthorization(response)) {
        return null;
      }
      T objectsRead=response.getBody();
      return objectsRead;
    }
 else {
      throw new Exception(Constants.HTTP_VERB_ERROR);
    }
  }
 catch (  Exception e) {
    throw new CliRestException(getExceptionMessage(e));
  }
}","/** 
 * Generic method to get all objects of a type
 * @param entityType object type
 * @param path the rest url
 * @param verb the http method
 * @param detail flag to retrieve detailed information or not
 * @return the objects
 */
public <T>T getAllObjects(final Class<T> entityType,final String path,final HttpMethod verb,final boolean detail){
  checkConnection();
  try {
    if (verb == HttpMethod.GET) {
      ResponseEntity<T> response=restGet(path,entityType,detail);
      if (!validateAuthorization(response)) {
        return null;
      }
      T objectsRead=response.getBody();
      return objectsRead;
    }
 else {
      throw new Exception(Constants.HTTP_VERB_ERROR);
    }
  }
 catch (  Exception e) {
    throw new CliRestException(CommandsUtils.getExceptionMessage(e));
  }
}"
48932,"/** 
 * Delete an object by id
 * @param id
 * @param path the rest url
 * @param verb the http method
 * @param prettyOutput utput callback
 */
public void deleteObject(final String id,final String path,final HttpMethod verb,PrettyOutput... prettyOutput){
  checkConnection();
  try {
    if (verb == HttpMethod.DELETE) {
      ResponseEntity<String> response=restDelete(path,id);
      if (!validateAuthorization(response)) {
        return;
      }
      processResponse(response,HttpMethod.DELETE,prettyOutput);
    }
 else {
      throw new Exception(Constants.HTTP_VERB_ERROR);
    }
  }
 catch (  Exception e) {
    throw new CliRestException(getExceptionMessage(e));
  }
}","/** 
 * Delete an object by id
 * @param id
 * @param path the rest url
 * @param verb the http method
 * @param prettyOutput utput callback
 */
public void deleteObject(final String id,final String path,final HttpMethod verb,PrettyOutput... prettyOutput){
  checkConnection();
  try {
    if (verb == HttpMethod.DELETE) {
      ResponseEntity<String> response=restDelete(path,id);
      if (!validateAuthorization(response)) {
        return;
      }
      processResponse(response,HttpMethod.DELETE,prettyOutput);
    }
 else {
      throw new Exception(Constants.HTTP_VERB_ERROR);
    }
  }
 catch (  Exception e) {
    throw new CliRestException(CommandsUtils.getExceptionMessage(e));
  }
}"
48933,"/** 
 * connect to a Serengeti server
 * @param host host url with optional port
 * @param username serengeti login user name
 * @param password serengeti password
 */
public Connect.ConnectType connect(final String host,final String username,final String password){
  String oldHostUri=hostUri;
  hostUri=Constants.HTTPS_CONNECTION_PREFIX + host + Constants.HTTPS_CONNECTION_LOGIN_SUFFIX;
  try {
    ResponseEntity<String> response=login(Constants.REST_PATH_LOGIN,String.class,username,password);
    if (response.getStatusCode() == HttpStatus.OK) {
      updateHostproperty(host);
      String cookieValue=response.getHeaders().getFirst(""String_Node_Str"");
      if (cookieValue.contains(""String_Node_Str"")) {
        cookieValue=cookieValue.split(""String_Node_Str"")[0];
      }
      writeCookieInfo(cookieValue);
      System.out.println(Constants.CONNECT_SUCCESS);
    }
 else {
      System.out.println(Constants.CONNECT_FAILURE);
      hostUri=oldHostUri;
      return Connect.ConnectType.ERROR;
    }
  }
 catch (  CliRestException cliRestException) {
    if (cliRestException.getStatus() == HttpStatus.UNAUTHORIZED) {
      System.out.println(Constants.CONNECT_UNAUTHORIZATION_CONNECT);
      hostUri=oldHostUri;
      return Connect.ConnectType.UNAUTHORIZATION;
    }
 else {
      System.out.println(Constants.CONNECT_FAILURE + ""String_Node_Str"" + cliRestException.getStatus()+ ""String_Node_Str""+ cliRestException.getMessage().toLowerCase());
      return Connect.ConnectType.ERROR;
    }
  }
catch (  Exception e) {
    System.out.println(Constants.CONNECT_FAILURE + ""String_Node_Str"" + (getExceptionMessage(e)));
    return Connect.ConnectType.ERROR;
  }
  return Connect.ConnectType.SUCCESS;
}","/** 
 * connect to a Serengeti server
 * @param host host url with optional port
 * @param username serengeti login user name
 * @param password serengeti password
 */
public Connect.ConnectType connect(final String host,final String username,final String password){
  String oldHostUri=hostUri;
  hostUri=Constants.HTTPS_CONNECTION_PREFIX + host + Constants.HTTPS_CONNECTION_LOGIN_SUFFIX;
  try {
    ResponseEntity<String> response=login(Constants.REST_PATH_LOGIN,String.class,username,password);
    if (response.getStatusCode() == HttpStatus.OK) {
      updateHostproperty(host);
      String cookieValue=response.getHeaders().getFirst(""String_Node_Str"");
      if (cookieValue.contains(""String_Node_Str"")) {
        cookieValue=cookieValue.split(""String_Node_Str"")[0];
      }
      writeCookieInfo(cookieValue);
      System.out.println(Constants.CONNECT_SUCCESS);
    }
 else {
      System.out.println(Constants.CONNECT_FAILURE);
      hostUri=oldHostUri;
      return Connect.ConnectType.ERROR;
    }
  }
 catch (  CliRestException cliRestException) {
    if (cliRestException.getStatus() == HttpStatus.UNAUTHORIZED) {
      System.out.println(Constants.CONNECT_UNAUTHORIZATION_CONNECT);
      hostUri=oldHostUri;
      return Connect.ConnectType.UNAUTHORIZATION;
    }
 else {
      System.out.println(Constants.CONNECT_FAILURE + ""String_Node_Str"" + cliRestException.getStatus()+ ""String_Node_Str""+ cliRestException.getMessage().toLowerCase());
      return Connect.ConnectType.ERROR;
    }
  }
catch (  Exception e) {
    System.out.println(Constants.CONNECT_FAILURE + ""String_Node_Str"" + (CommandsUtils.getExceptionMessage(e)));
    return Connect.ConnectType.ERROR;
  }
  return Connect.ConnectType.SUCCESS;
}"
48934,"/** 
 * Generic method to get an object by id
 * @param id
 * @param entityType the object type
 * @param path the rest url
 * @param verb the http method
 * @param detail flag to retrieve detailed information or not
 * @return the object
 */
public <T>T getObject(final String id,Class<T> entityType,final String path,final HttpMethod verb,final boolean detail){
  checkConnection();
  try {
    if (verb == HttpMethod.GET) {
      ResponseEntity<T> response=restGetById(path,id,entityType,detail);
      if (!validateAuthorization(response)) {
        return null;
      }
      T objectRead=response.getBody();
      return objectRead;
    }
 else {
      throw new Exception(Constants.HTTP_VERB_ERROR);
    }
  }
 catch (  Exception e) {
    throw new CliRestException(getExceptionMessage(e));
  }
}","/** 
 * Generic method to get an object by id
 * @param id
 * @param entityType the object type
 * @param path the rest url
 * @param verb the http method
 * @param detail flag to retrieve detailed information or not
 * @return the object
 */
public <T>T getObject(final String id,Class<T> entityType,final String path,final HttpMethod verb,final boolean detail){
  checkConnection();
  try {
    if (verb == HttpMethod.GET) {
      ResponseEntity<T> response=restGetById(path,id,entityType,detail);
      if (!validateAuthorization(response)) {
        return null;
      }
      T objectRead=response.getBody();
      return objectRead;
    }
 else {
      throw new Exception(Constants.HTTP_VERB_ERROR);
    }
  }
 catch (  Exception e) {
    throw new CliRestException(CommandsUtils.getExceptionMessage(e));
  }
}"
48935,"/** 
 * Create an object through rest apis
 * @param entity the creation content
 * @param path the rest url
 * @param verb the http method
 * @param prettyOutput output callback
 */
public void createObject(Object entity,final String path,final HttpMethod verb,PrettyOutput... prettyOutput){
  checkConnection();
  try {
    if (verb == HttpMethod.POST) {
      ResponseEntity<String> response=restPost(path,entity);
      if (!validateAuthorization(response)) {
        return;
      }
      processResponse(response,HttpMethod.POST,prettyOutput);
    }
 else {
      throw new Exception(Constants.HTTP_VERB_ERROR);
    }
  }
 catch (  Exception e) {
    throw new CliRestException(getExceptionMessage(e));
  }
}","/** 
 * Create an object through rest apis
 * @param entity the creation content
 * @param path the rest url
 * @param verb the http method
 * @param prettyOutput output callback
 */
public void createObject(Object entity,final String path,final HttpMethod verb,PrettyOutput... prettyOutput){
  checkConnection();
  try {
    if (verb == HttpMethod.POST) {
      ResponseEntity<String> response=restPost(path,entity);
      if (!validateAuthorization(response)) {
        return;
      }
      processResponse(response,HttpMethod.POST,prettyOutput);
    }
 else {
      throw new Exception(Constants.HTTP_VERB_ERROR);
    }
  }
 catch (  Exception e) {
    throw new CliRestException(CommandsUtils.getExceptionMessage(e));
  }
}"
48936,"/** 
 * Method to get by path
 * @param entityType
 * @param path
 * @param verb
 * @param detail
 * @return
 */
public <T>T getObjectByPath(Class<T> entityType,final String path,final HttpMethod verb,final boolean detail){
  checkConnection();
  try {
    if (verb == HttpMethod.GET) {
      ResponseEntity<T> response=restGet(path,entityType,detail);
      T objectRead=response.getBody();
      return objectRead;
    }
 else {
      throw new Exception(Constants.HTTP_VERB_ERROR);
    }
  }
 catch (  Exception e) {
    throw new CliRestException(getExceptionMessage(e));
  }
}","/** 
 * Method to get by path
 * @param entityType
 * @param path
 * @param verb
 * @param detail
 * @return
 */
public <T>T getObjectByPath(Class<T> entityType,final String path,final HttpMethod verb,final boolean detail){
  checkConnection();
  try {
    if (verb == HttpMethod.GET) {
      ResponseEntity<T> response=restGet(path,entityType,detail);
      T objectRead=response.getBody();
      return objectRead;
    }
 else {
      throw new Exception(Constants.HTTP_VERB_ERROR);
    }
  }
 catch (  Exception e) {
    throw new CliRestException(CommandsUtils.getExceptionMessage(e));
  }
}"
48937,"private CreateVmSP getReplacementVmSp(ClusterCreate clusterSpec,String groupName,NodeEntity node,List<DiskSpec> fullDiskSet){
  VmSchema createSchema=VcVmUtil.getVmSchema(clusterSpec,groupName,fullDiskSet,clusteringService.getTemplateVmId(),clusteringService.getTemplateSnapId());
  NetworkAdd networkAdd=clusterSpec.getNetworking().get(0);
  Map<String,String> guestVariable=ClusteringService.getNetworkGuestVariable(networkAdd,node.getIpAddress(),node.getGuestHostName());
  VcVmUtil.addBootupUUID(guestVariable);
  ReplaceVmPrePowerOn prePowerOn=new ReplaceVmPrePowerOn(node.getMoId(),node.getVmName(),clusterSpec.getNodeGroup(groupName).getStorage().getShares(),createSchema.networkSchema);
  return new CreateVmSP(node.getVmName() + RECOVERY_VM_NAME_POSTFIX,createSchema,VcVmUtil.getTargetRp(clusterSpec.getName(),groupName,node),getTargetDatastore(fullDiskSet),prePowerOn,null,guestVariable,false,getTargetFolder(node,clusterSpec.getNodeGroup(groupName)),getTargetHost(node));
}","private CreateVmSP getReplacementVmSp(ClusterCreate clusterSpec,String groupName,NodeEntity node,List<DiskSpec> fullDiskSet){
  VmSchema createSchema=VcVmUtil.getVmSchema(clusterSpec,groupName,fullDiskSet,clusteringService.getTemplateVmId(),Constants.ROOT_SNAPSTHOT_NAME);
  NetworkAdd networkAdd=clusterSpec.getNetworking().get(0);
  Map<String,String> guestVariable=ClusteringService.getNetworkGuestVariable(networkAdd,node.getIpAddress(),node.getGuestHostName());
  VcVmUtil.addBootupUUID(guestVariable);
  ReplaceVmPrePowerOn prePowerOn=new ReplaceVmPrePowerOn(node.getMoId(),node.getVmName(),clusterSpec.getNodeGroup(groupName).getStorage().getShares(),createSchema.networkSchema);
  return new CreateVmSP(node.getVmName() + RECOVERY_VM_NAME_POSTFIX,createSchema,VcVmUtil.getTargetRp(clusterSpec.getName(),groupName,node),getTargetDatastore(fullDiskSet),prePowerOn,null,guestVariable,false,getTargetFolder(node,clusterSpec.getNodeGroup(groupName)),getTargetHost(node));
}"
48938,"private void snapshotTemplateVM(){
  final VcVirtualMachine templateVM=getTemplateVm();
  if (templateVM == null) {
    throw ClusteringServiceException.TEMPLATE_VM_NOT_FOUND();
  }
  try {
    final VcSnapshot snapshot=templateVM.getSnapshotByName(Constants.ROOT_SNAPSTHOT_NAME);
    if (snapshot == null) {
      if (!ConfigInfo.isJustUpgraded()) {
        TakeSnapshotSP snapshotSp=new TakeSnapshotSP(templateVM.getId(),Constants.ROOT_SNAPSTHOT_NAME,Constants.ROOT_SNAPSTHOT_DESC);
        snapshotSp.call();
        templateSnapId=snapshotSp.getSnapId();
      }
    }
 else {
      if (ConfigInfo.isJustUpgraded()) {
        VcContext.inVcSessionDo(new VcSession<Boolean>(){
          @Override protected boolean isTaskSession(){
            return true;
          }
          @Override protected Boolean body() throws Exception {
            snapshot.remove();
            return true;
          }
        }
);
        ConfigInfo.setJustUpgraded(false);
        ConfigInfo.save();
      }
 else {
        templateSnapId=snapshot.getName();
      }
    }
    this.templateVm=templateVM;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"");
    throw BddException.INTERNAL(e,""String_Node_Str"");
  }
}","private void snapshotTemplateVM(){
  final VcVirtualMachine templateVM=getTemplateVm();
  if (templateVM == null) {
    throw ClusteringServiceException.TEMPLATE_VM_NOT_FOUND();
  }
  try {
    if (ConfigInfo.isJustUpgraded()) {
      removeRootSnapshot(templateVM);
      ConfigInfo.setJustUpgraded(false);
      ConfigInfo.save();
    }
    this.templateVm=templateVM;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"");
    throw BddException.INTERNAL(e,""String_Node_Str"");
  }
}"
48939,"private VmSchema getVmSchema(BaseNode vNode){
  VmSchema schema=vNode.getVmSchema();
  schema.diskSchema.setParent(getTemplateVmId());
  schema.diskSchema.setParentSnap(getTemplateSnapId());
  return schema;
}","private VmSchema getVmSchema(BaseNode vNode){
  VmSchema schema=vNode.getVmSchema();
  schema.diskSchema.setParent(getTemplateVmId());
  schema.diskSchema.setParentSnap(Constants.ROOT_SNAPSTHOT_NAME);
  return schema;
}"
48940,"public void callInternal() throws Exception {
  final VcVirtualMachine template=VcCache.get(vmSchema.diskSchema.getParent());
  VcSnapshot snap=template.getSnapshotByName(vmSchema.diskSchema.getParentSnap());
  ConfigSpecImpl configSpec=new ConfigSpecImpl();
  ResourceSchemaUtil.setResourceSchema(configSpec,vmSchema.resourceSchema);
  HashMap<String,Disk.Operation> diskMap=new HashMap<String,Disk.Operation>();
  if (requireClone()) {
    VcVirtualMachine.CreateSpec vmSpec=new VcVirtualMachine.CreateSpec(newVmName,snap,targetRp,targetDs,vmFolder,host,linkedClone,configSpec);
    vcVm=template.cloneVm(vmSpec,null);
  }
 else {
    copyParentVmSettings(template,configSpec);
    vcVm=targetRp.createVm(configSpec,targetDs,vmFolder);
  }
  configSpec=new ConfigSpecImpl();
  NetworkSchemaUtil.setNetworkSchema(configSpec,targetRp.getVcCluster(),vmSchema.networkSchema,vcVm);
  vcVm.reconfigure(configSpec);
  if (host != null) {
    vcVm.disableDrs();
  }
  List<VcHost> hostList=new ArrayList<VcHost>();
  List<DiskCreateSpec> addDisks=DiskSchemaUtil.getDisksToAdd(hostList,targetRp,targetDs,vmSchema.diskSchema,diskMap);
  DiskCreateSpec[] tmpAddDisks=addDisks.toArray(new DiskCreateSpec[addDisks.size()]);
  if (hostList.size() > 0 && !hostList.contains(vcVm.getHost())) {
    vcVm.migrate(hostList.get(0));
  }
  vcVm.changeDisks(null,tmpAddDisks);
  List<VirtualDeviceSpec> deviceChange=new ArrayList<VirtualDeviceSpec>();
  for (  Disk disk : vmSchema.diskSchema.getDisks()) {
    if (disk.vmdkPath == null || disk.vmdkPath.isEmpty())     continue;
    VirtualDisk.FlatVer2BackingInfo backing=new VirtualDiskImpl.FlatVer2BackingInfoImpl();
    backing.setFileName(disk.vmdkPath);
    backing.setDiskMode(disk.mode.toString());
    deviceChange.add(vcVm.attachVirtualDiskSpec(new DeviceId(disk.externalAddress),backing,false,DiskSize.sizeFromMB(disk.initialSizeMB)));
  }
  if (!deviceChange.isEmpty()) {
    vcVm.reconfigure(VmConfigUtil.createConfigSpec(deviceChange));
  }
  if (linkedClone) {
    ArrayList<DeviceId> disksToPromote=new ArrayList<DeviceId>();
    for (    Entry<String,Disk.Operation> entry : diskMap.entrySet()) {
      if (entry.getValue() == Disk.Operation.PROMOTE) {
        disksToPromote.add(new DeviceId(entry.getKey()));
      }
    }
    if (disksToPromote.size() >= 1) {
      vcVm.promoteDisks(disksToPromote.toArray(new DeviceId[0]));
    }
  }
  if (bootupConfigs != null) {
    vcVm.setGuestConfigs(bootupConfigs);
  }
  if (prePowerOn != null) {
    prePowerOn.setVm(vcVm);
    prePowerOn.call();
  }
  vcVm.powerOn(host);
  if (postPowerOn != null) {
    postPowerOn.setVm(vcVm);
    postPowerOn.call();
  }
}","public void callInternal() throws Exception {
  final VcVirtualMachine template=VcCache.get(vmSchema.diskSchema.getParent());
  VcSnapshot snap=template.getSnapshotByName(vmSchema.diskSchema.getParentSnap());
  if (snap == null) {
    snap=template.createSnapshot(vmSchema.diskSchema.getParentSnap(),""String_Node_Str"");
  }
  ConfigSpecImpl configSpec=new ConfigSpecImpl();
  ResourceSchemaUtil.setResourceSchema(configSpec,vmSchema.resourceSchema);
  HashMap<String,Disk.Operation> diskMap=new HashMap<String,Disk.Operation>();
  if (requireClone()) {
    VcVirtualMachine.CreateSpec vmSpec=new VcVirtualMachine.CreateSpec(newVmName,snap,targetRp,targetDs,vmFolder,host,linkedClone,configSpec);
    vcVm=template.cloneVm(vmSpec,null);
  }
 else {
    copyParentVmSettings(template,configSpec);
    vcVm=targetRp.createVm(configSpec,targetDs,vmFolder);
  }
  configSpec=new ConfigSpecImpl();
  NetworkSchemaUtil.setNetworkSchema(configSpec,targetRp.getVcCluster(),vmSchema.networkSchema,vcVm);
  vcVm.reconfigure(configSpec);
  if (host != null) {
    vcVm.disableDrs();
  }
  List<VcHost> hostList=new ArrayList<VcHost>();
  List<DiskCreateSpec> addDisks=DiskSchemaUtil.getDisksToAdd(hostList,targetRp,targetDs,vmSchema.diskSchema,diskMap);
  DiskCreateSpec[] tmpAddDisks=addDisks.toArray(new DiskCreateSpec[addDisks.size()]);
  if (hostList.size() > 0 && !hostList.contains(vcVm.getHost())) {
    vcVm.migrate(hostList.get(0));
  }
  vcVm.changeDisks(null,tmpAddDisks);
  List<VirtualDeviceSpec> deviceChange=new ArrayList<VirtualDeviceSpec>();
  for (  Disk disk : vmSchema.diskSchema.getDisks()) {
    if (disk.vmdkPath == null || disk.vmdkPath.isEmpty())     continue;
    VirtualDisk.FlatVer2BackingInfo backing=new VirtualDiskImpl.FlatVer2BackingInfoImpl();
    backing.setFileName(disk.vmdkPath);
    backing.setDiskMode(disk.mode.toString());
    deviceChange.add(vcVm.attachVirtualDiskSpec(new DeviceId(disk.externalAddress),backing,false,DiskSize.sizeFromMB(disk.initialSizeMB)));
  }
  if (!deviceChange.isEmpty()) {
    vcVm.reconfigure(VmConfigUtil.createConfigSpec(deviceChange));
  }
  if (linkedClone) {
    ArrayList<DeviceId> disksToPromote=new ArrayList<DeviceId>();
    for (    Entry<String,Disk.Operation> entry : diskMap.entrySet()) {
      if (entry.getValue() == Disk.Operation.PROMOTE) {
        disksToPromote.add(new DeviceId(entry.getKey()));
      }
    }
    if (disksToPromote.size() >= 1) {
      vcVm.promoteDisks(disksToPromote.toArray(new DeviceId[0]));
    }
  }
  if (bootupConfigs != null) {
    vcVm.setGuestConfigs(bootupConfigs);
  }
  if (prePowerOn != null) {
    prePowerOn.setVm(vcVm);
    prePowerOn.call();
  }
  vcVm.powerOn(host);
  if (postPowerOn != null) {
    postPowerOn.setVm(vcVm);
    postPowerOn.call();
  }
}"
48941,"public synchronized void init(){
  if (!initialized) {
    Configuration.approveBootstrapInstanceId(Configuration.BootstrapUsage.ALLOWED);
    Configuration.approveBootstrapInstanceId(Configuration.BootstrapUsage.FINALIZED);
    VcContext.initVcContext();
    new VcEventRouter();
    CmsWorker.addPeriodic(new VcInventory.SyncInventoryRequest());
    VcInventory.loadInventory();
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      logger.warn(""String_Node_Str"" + e.getMessage());
    }
    new VcEventProcessor(getClusterEntityMgr());
    String poolSize=Configuration.getNonEmptyString(""String_Node_Str"");
    if (poolSize == null) {
      Scheduler.init(Constants.DEFAULT_SCHEDULER_POOL_SIZE,Constants.DEFAULT_SCHEDULER_POOL_SIZE);
    }
 else {
      Scheduler.init(Integer.parseInt(poolSize),Integer.parseInt(poolSize));
    }
    String concurrency=Configuration.getNonEmptyString(""String_Node_Str"");
    if (concurrency != null) {
      cloneConcurrency=Integer.parseInt(concurrency);
    }
 else {
      cloneConcurrency=1;
    }
    CmsWorker.addPeriodic(new ClusterNodeUpdator(getClusterEntityMgr()));
    snapshotTemplateVM();
    loadTemplateNetworkLable();
    convertTemplateVm();
    initialized=true;
  }
}","public synchronized void init(){
  if (!initialized) {
    Configuration.approveBootstrapInstanceId(Configuration.BootstrapUsage.ALLOWED);
    Configuration.approveBootstrapInstanceId(Configuration.BootstrapUsage.FINALIZED);
    VcContext.initVcContext();
    new VcEventRouter();
    CmsWorker.addPeriodic(new VcInventory.SyncInventoryRequest());
    VcInventory.loadInventory();
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
      logger.warn(""String_Node_Str"" + e.getMessage());
    }
    new VcEventProcessor(getClusterEntityMgr());
    String poolSize=Configuration.getNonEmptyString(""String_Node_Str"");
    if (poolSize == null) {
      Scheduler.init(Constants.DEFAULT_SCHEDULER_POOL_SIZE,Constants.DEFAULT_SCHEDULER_POOL_SIZE);
    }
 else {
      Scheduler.init(Integer.parseInt(poolSize),Integer.parseInt(poolSize));
    }
    String concurrency=Configuration.getNonEmptyString(""String_Node_Str"");
    if (concurrency != null) {
      cloneConcurrency=Integer.parseInt(concurrency);
    }
 else {
      cloneConcurrency=1;
    }
    CmsWorker.addPeriodic(new ClusterNodeUpdator(getClusterEntityMgr()));
    snapshotTemplateVM();
    loadTemplateNetworkLable();
    convertTemplateVm();
    clusterInitializerService.transformClusterStatus(ClusterStatus.PROVISIONING,ClusterStatus.PROVISION_ERROR);
    initialized=true;
  }
}"
48942,"public static void waitForManual(String clusterName,IExecutionService executionService){
  logger.info(""String_Node_Str"");
  Map<String,Object> sendParam=new HashMap<String,Object>();
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_VERSION,Constants.VHM_PROTOCOL_VERSION);
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_CLUSTER_NAME,clusterName);
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_RECEIVE_ROUTE_KEY,CommonUtil.getUUID());
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_ACTION,LimitInstruction.actionWaitForManual);
  Map<String,Object> ret=null;
  try {
    ret=executionService.execute(new VHMMessageTask(sendParam,null));
    if (!(Boolean)ret.get(""String_Node_Str"")) {
      String errorMessage=(String)ret.get(""String_Node_Str"");
      throw TaskException.EXECUTION_FAILED(errorMessage);
    }
  }
 catch (  Exception e) {
    throw TaskException.EXECUTION_FAILED(""String_Node_Str"" + clusterName);
  }
}","public static void waitForManual(String clusterName,IExecutionService executionService){
  logger.info(""String_Node_Str"");
  Map<String,Object> sendParam=new HashMap<String,Object>();
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_VERSION,Constants.VHM_PROTOCOL_VERSION);
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_CLUSTER_NAME,clusterName);
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_RECEIVE_ROUTE_KEY,CommonUtil.getUUID());
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_ACTION,LimitInstruction.actionWaitForManual);
  Map<String,Object> ret=null;
  try {
    ret=executionService.execute(new VHMMessageTask(sendParam,null));
    if (!(Boolean)ret.get(""String_Node_Str"")) {
      String errorMessage=(String)ret.get(""String_Node_Str"");
      throw TaskException.EXECUTION_FAILED(errorMessage);
    }
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName);
  }
}"
48943,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void conn(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String hostName){
  Map<String,String> loginInfo=new HashMap<String,String>();
  String username=null;
  String password=null;
  loginInfo.put(""String_Node_Str"",username);
  loginInfo.put(""String_Node_Str"",password);
  try {
    if (CommandsUtils.isBlank(username)) {
      if (!prompt(Constants.CONNECT_ENTER_USER_NAME,PromptType.USER_NAME,loginInfo)) {
        return;
      }
    }
    if (CommandsUtils.isBlank(password)) {
      if (!prompt(Constants.CONNECT_ENTER_PASSWORD,PromptType.PASSWORD,loginInfo)) {
        return;
      }
    }
    connect(hostName,loginInfo,3);
  }
 catch (  Exception e) {
    System.out.println();
    printConnectionFailure(e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void conn(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String hostName){
  if (!validateHostPort(hostName)) {
    return;
  }
  Map<String,String> loginInfo=new HashMap<String,String>();
  String username=null;
  String password=null;
  loginInfo.put(""String_Node_Str"",username);
  loginInfo.put(""String_Node_Str"",password);
  try {
    if (CommandsUtils.isBlank(username)) {
      if (!prompt(Constants.CONNECT_ENTER_USER_NAME,PromptType.USER_NAME,loginInfo)) {
        return;
      }
    }
    if (CommandsUtils.isBlank(password)) {
      if (!prompt(Constants.CONNECT_ENTER_PASSWORD,PromptType.PASSWORD,loginInfo)) {
        return;
      }
    }
    connect(hostName,loginInfo,3);
  }
 catch (  Exception e) {
    System.out.println();
    printConnectionFailure(e.getMessage());
  }
}"
48944,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void loggedConn(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String hostName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String username,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String password){
  Map<String,String> loginInfo=new HashMap<String,String>();
  loginInfo.put(""String_Node_Str"",username);
  loginInfo.put(""String_Node_Str"",password);
  try {
    if (CommandsUtils.isBlank(username)) {
      if (!prompt(Constants.CONNECT_ENTER_USER_NAME,PromptType.USER_NAME,loginInfo)) {
        return;
      }
    }
    if (CommandsUtils.isBlank(password)) {
      if (!prompt(Constants.CONNECT_ENTER_PASSWORD,PromptType.PASSWORD,loginInfo)) {
        return;
      }
    }
    connect(hostName,loginInfo,3);
  }
 catch (  Exception e) {
    System.out.println();
    printConnectionFailure(e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void loggedConn(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String hostName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String username,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String password){
  if (!validateHostPort(hostName)) {
    return;
  }
  Map<String,String> loginInfo=new HashMap<String,String>();
  loginInfo.put(""String_Node_Str"",username);
  loginInfo.put(""String_Node_Str"",password);
  try {
    if (CommandsUtils.isBlank(username)) {
      if (!prompt(Constants.CONNECT_ENTER_USER_NAME,PromptType.USER_NAME,loginInfo)) {
        return;
      }
    }
    if (CommandsUtils.isBlank(password)) {
      if (!prompt(Constants.CONNECT_ENTER_PASSWORD,PromptType.PASSWORD,loginInfo)) {
        return;
      }
    }
    connect(hostName,loginInfo,3);
  }
 catch (  Exception e) {
    System.out.println();
    printConnectionFailure(e.getMessage());
  }
}"
48945,"@Override public boolean isNetworkExistInVc(String networkName) throws VcProviderException {
  boolean result=false;
  VcNetwork network=VcResourceUtils.findNetworkInVC(networkName);
  if (network != null) {
    result=true;
  }
  return result;
}","@Override public boolean isNetworkExistInVc(String networkName) throws VcProviderException {
  boolean result=false;
  refreshNetwork();
  VcNetwork network=VcResourceUtils.findNetworkInVC(networkName);
  if (network != null) {
    result=true;
  }
  return result;
}"
48946,"@Override public boolean isNetworkSharedInCluster(String networkName,String clusterName) throws VcProviderException {
  boolean result=true;
  VcNetwork vcNetwork=getNetworkByName(networkName);
  if (vcNetwork == null) {
    return false;
  }
 else {
    String portGroupName=vcNetwork.getName();
    List<VcHost> hosts=getHostsByClusterName(clusterName);
    for (    VcHost vcHost : hosts) {
      List<VcNetwork> networks=vcHost.getNetworks();
      boolean found=false;
      for (      VcNetwork network : networks) {
        if (network.getName().equals(portGroupName)) {
          found=true;
          break;
        }
      }
      if (!found) {
        logger.error(""String_Node_Str"" + vcHost + ""String_Node_Str""+ networks+ ""String_Node_Str""+ portGroupName);
        result=false;
        break;
      }
    }
  }
  return result;
}","@Override public boolean isNetworkSharedInCluster(String networkName,String clusterName) throws VcProviderException {
  boolean result=true;
  refreshNetwork();
  VcNetwork vcNetwork=getNetworkByName(networkName);
  if (vcNetwork == null) {
    return false;
  }
 else {
    String portGroupName=vcNetwork.getName();
    List<VcHost> hosts=getHostsByClusterName(clusterName);
    for (    VcHost vcHost : hosts) {
      List<VcNetwork> networks=vcHost.getNetworks();
      boolean found=false;
      for (      VcNetwork network : networks) {
        if (network.getName().equals(portGroupName)) {
          found=true;
          break;
        }
      }
      if (!found) {
        logger.error(""String_Node_Str"" + vcHost + ""String_Node_Str""+ networks+ ""String_Node_Str""+ portGroupName);
        result=false;
        break;
      }
    }
  }
  return result;
}"
48947,"private CreateVmSP getReplacementVmSp(ClusterCreate clusterSpec,String groupName,NodeEntity node,List<DiskSpec> fullDiskSet){
  VmSchema createSchema=VcVmUtil.getVmSchema(clusterSpec,groupName,fullDiskSet,clusteringService.getTemplateVmId(),clusteringService.getTemplateSnapId());
  NetworkAdd networkAdd=clusterSpec.getNetworking().get(0);
  Map<String,String> guestVariable=ClusteringService.getNetworkGuestVariable(networkAdd,node.getIpAddress(),node.getGuestHostName());
  VcVmUtil.addBootupUUID(guestVariable);
  ReplaceVmPrePowerOn prePowerOn=new ReplaceVmPrePowerOn(node.getMoId(),node.getVmName(),clusterSpec.getNodeGroup(groupName).getStorage().getShares(),fullDiskSet);
  QueryIpAddress query=new QueryIpAddress(Constants.VM_POWER_ON_WAITING_SEC);
  return new CreateVmSP(node.getVmName() + RECOVERY_VM_NAME_POSTFIX,createSchema,VcVmUtil.getTargetRp(clusterSpec.getName(),groupName,node),getTargetDatastore(fullDiskSet),prePowerOn,query,guestVariable,false,getTargetFolder(node,clusterSpec.getNodeGroup(groupName)),getTargetHost(node));
}","private CreateVmSP getReplacementVmSp(ClusterCreate clusterSpec,String groupName,NodeEntity node,List<DiskSpec> fullDiskSet){
  VmSchema createSchema=VcVmUtil.getVmSchema(clusterSpec,groupName,fullDiskSet,clusteringService.getTemplateVmId(),clusteringService.getTemplateSnapId());
  NetworkAdd networkAdd=clusterSpec.getNetworking().get(0);
  Map<String,String> guestVariable=ClusteringService.getNetworkGuestVariable(networkAdd,node.getIpAddress(),node.getGuestHostName());
  VcVmUtil.addBootupUUID(guestVariable);
  ReplaceVmPrePowerOn prePowerOn=new ReplaceVmPrePowerOn(node.getMoId(),node.getVmName(),clusterSpec.getNodeGroup(groupName).getStorage().getShares(),fullDiskSet,createSchema.networkSchema);
  QueryIpAddress query=new QueryIpAddress(Constants.VM_POWER_ON_WAITING_SEC);
  return new CreateVmSP(node.getVmName() + RECOVERY_VM_NAME_POSTFIX,createSchema,VcVmUtil.getTargetRp(clusterSpec.getName(),groupName,node),getTargetDatastore(fullDiskSet),prePowerOn,query,guestVariable,false,getTargetFolder(node,clusterSpec.getNodeGroup(groupName)),getTargetHost(node));
}"
48948,"@Override public Void call() throws Exception {
  final VcVirtualMachine oldVm=VcCache.getIgnoreMissing(oldVmId);
  if (oldVm == null) {
    logger.info(""String_Node_Str"" + oldVmId + ""String_Node_Str"");
    return null;
  }
  VcContext.inVcSessionDo(new VcSession<Void>(){
    @Override protected Void body() throws Exception {
      logger.info(""String_Node_Str"");
      OptionValue[] optionValues=getVhmExtraConfigs(oldVm);
      if (optionValues.length != 0) {
        ConfigSpec spec=new ConfigSpecImpl();
        spec.setExtraConfig(optionValues);
        vm.reconfigure(spec);
      }
      logger.info(""String_Node_Str"");
      destroyVm(oldVm);
      logger.info(""String_Node_Str"" + vm.getName() + ""String_Node_Str""+ newName);
      vm.rename(newName);
      logger.info(""String_Node_Str"");
      if (!Priority.NORMAL.equals(ioShares)) {
        VcVmUtil.configIOShares(oldVmId,ioShares);
      }
      return null;
    }
    protected boolean isTaskSession(){
      return true;
    }
  }
);
  return null;
}","@Override public Void call() throws Exception {
  final VcVirtualMachine oldVm=VcCache.getIgnoreMissing(oldVmId);
  if (oldVm == null) {
    logger.info(""String_Node_Str"" + oldVmId + ""String_Node_Str"");
    return null;
  }
  VcContext.inVcSessionDo(new VcSession<Void>(){
    @Override protected Void body() throws Exception {
      logger.info(""String_Node_Str"");
      copyNicSettings(oldVm);
      logger.info(""String_Node_Str"");
      OptionValue[] optionValues=getVhmExtraConfigs(oldVm);
      if (optionValues.length != 0) {
        ConfigSpec spec=new ConfigSpecImpl();
        spec.setExtraConfig(optionValues);
        vm.reconfigure(spec);
      }
      logger.info(""String_Node_Str"");
      destroyVm(oldVm);
      logger.info(""String_Node_Str"" + vm.getName() + ""String_Node_Str""+ newName);
      vm.rename(newName);
      logger.info(""String_Node_Str"");
      if (!Priority.NORMAL.equals(ioShares)) {
        VcVmUtil.configIOShares(oldVmId,ioShares);
      }
      return null;
    }
    protected boolean isTaskSession(){
      return true;
    }
  }
);
  return null;
}"
48949,"private void destroyVm(VcVirtualMachine oldVm) throws Exception {
  FaultToleranceConfigInfo info=oldVm.getConfig().getFtInfo();
  if (info != null && info.getRole() == 1) {
    logger.info(""String_Node_Str"" + oldVm.getName() + ""String_Node_Str"");
    oldVm.turnOffFT();
  }
  if (oldVm.isPoweredOn() && !oldVm.shutdownGuest(Constants.VM_FAST_SHUTDOWN_WAITING_SEC * 1000)) {
    oldVm.powerOff();
  }
  for (  DiskSpec disk : fullDiskSet) {
    if (disk.getVmdkPath() != null && !disk.getVmdkPath().isEmpty()) {
      oldVm.detachVirtualDisk(new DeviceId(disk.getExternalAddress()),false);
    }
  }
  try {
    oldVm.destroy(false);
  }
 catch (  Exception e) {
    logger.warn(""String_Node_Str"" + oldVm.getName() + ""String_Node_Str""+ e.getMessage());
    logger.info(""String_Node_Str"");
    oldVm.unregister();
  }
  logger.info(""String_Node_Str"" + oldVm.getName() + ""String_Node_Str"");
}","private void destroyVm(VcVirtualMachine oldVm) throws Exception {
  FaultToleranceConfigInfo info=oldVm.getConfig().getFtInfo();
  if (info != null && info.getRole() == 1) {
    logger.info(""String_Node_Str"" + oldVm.getName() + ""String_Node_Str"");
    oldVm.turnOffFT();
  }
  if (oldVm.isPoweredOn() && !oldVm.shutdownGuest(Constants.VM_FAST_SHUTDOWN_WAITING_SEC * 1000)) {
    oldVm.powerOff();
  }
  try {
    for (    DiskSpec disk : fullDiskSet) {
      if (disk.getVmdkPath() != null && !disk.getVmdkPath().isEmpty()) {
        oldVm.detachVirtualDisk(new DeviceId(disk.getExternalAddress()),false);
      }
    }
    oldVm.destroy(false);
  }
 catch (  Exception e) {
    logger.warn(""String_Node_Str"" + oldVm.getName() + ""String_Node_Str""+ e.getMessage());
    logger.info(""String_Node_Str"");
    oldVm.unregister();
  }
  logger.info(""String_Node_Str"" + oldVm.getName() + ""String_Node_Str"");
}"
48950,"public ReplaceVmPrePowerOn(String vmId,String newName,Priority ioShares,List<DiskSpec> fullDiskSet){
  this.oldVmId=vmId;
  this.newName=newName;
  this.ioShares=ioShares;
  this.fullDiskSet=fullDiskSet;
}","public ReplaceVmPrePowerOn(String vmId,String newName,Priority ioShares,List<DiskSpec> fullDiskSet,NetworkSchema networkSchema){
  this.oldVmId=vmId;
  this.newName=newName;
  this.ioShares=ioShares;
  this.fullDiskSet=fullDiskSet;
  this.networkSchema=networkSchema;
}"
48951,"@Override protected Void body() throws Exception {
  logger.info(""String_Node_Str"");
  OptionValue[] optionValues=getVhmExtraConfigs(oldVm);
  if (optionValues.length != 0) {
    ConfigSpec spec=new ConfigSpecImpl();
    spec.setExtraConfig(optionValues);
    vm.reconfigure(spec);
  }
  logger.info(""String_Node_Str"");
  destroyVm(oldVm);
  logger.info(""String_Node_Str"" + vm.getName() + ""String_Node_Str""+ newName);
  vm.rename(newName);
  logger.info(""String_Node_Str"");
  if (!Priority.NORMAL.equals(ioShares)) {
    VcVmUtil.configIOShares(oldVmId,ioShares);
  }
  return null;
}","@Override protected Void body() throws Exception {
  logger.info(""String_Node_Str"");
  copyNicSettings(oldVm);
  logger.info(""String_Node_Str"");
  OptionValue[] optionValues=getVhmExtraConfigs(oldVm);
  if (optionValues.length != 0) {
    ConfigSpec spec=new ConfigSpecImpl();
    spec.setExtraConfig(optionValues);
    vm.reconfigure(spec);
  }
  logger.info(""String_Node_Str"");
  destroyVm(oldVm);
  logger.info(""String_Node_Str"" + vm.getName() + ""String_Node_Str""+ newName);
  vm.rename(newName);
  logger.info(""String_Node_Str"");
  if (!Priority.NORMAL.equals(ioShares)) {
    VcVmUtil.configIOShares(oldVmId,ioShares);
  }
  return null;
}"
48952,"private String createVcResourcePools(List<BaseNode> vNodes){
  logger.info(""String_Node_Str"");
  String clusterName=vNodes.get(0).getClusterName();
  String uuid=ConfigInfo.getSerengetiUUID();
  String clusterRpName=uuid + ""String_Node_Str"" + clusterName;
  if (clusterRpName.length() > VC_RP_MAX_NAME_LENGTH) {
    throw ClusteringServiceException.CLUSTER_NAME_TOO_LONG(clusterName);
  }
  Map<String,List<String>> vcClusterRpNamesMap=new HashMap<String,List<String>>();
  Map<Long,List<NodeGroupCreate>> rpNodeGroupsMap=new HashMap<Long,List<NodeGroupCreate>>();
  Map<String,Integer> countResult=collectResourcePoolInfo(vNodes,vcClusterRpNamesMap,rpNodeGroupsMap);
  try {
    int resourcePoolNameCount=countResult.get(""String_Node_Str"");
    Callable<Void>[] clusterSPs=new Callable[resourcePoolNameCount];
    int i=0;
    for (    Entry<String,List<String>> vcClusterRpNamesEntry : vcClusterRpNamesMap.entrySet()) {
      String vcClusterName=vcClusterRpNamesEntry.getKey();
      List<String> resourcePoolNames=vcClusterRpNamesEntry.getValue();
      for (      String resourcePoolName : resourcePoolNames) {
        VcResourcePool parentVcResourcePool=VcResourceUtils.findRPInVCCluster(vcClusterName,resourcePoolName);
        CreateResourcePoolSP clusterSP=new CreateResourcePoolSP(parentVcResourcePool,clusterRpName);
        clusterSPs[i]=clusterSP;
        i++;
      }
    }
    logger.info(""String_Node_Str"");
    executeResourcePoolStoreProcedures(clusterSPs,""String_Node_Str"",clusterName);
    int nodeGroupNameCount=countResult.get(""String_Node_Str"");
    Callable<Void>[] nodeGroupSPs=new Callable[nodeGroupNameCount];
    i=0;
    for (    Entry<String,List<String>> vcClusterRpNamesEntry : vcClusterRpNamesMap.entrySet()) {
      String vcClusterName=vcClusterRpNamesEntry.getKey();
      VcCluster vcCluster=VcResourceUtils.findVcCluster(vcClusterName);
      if (!vcCluster.getConfig().getDRSEnabled()) {
        continue;
      }
      List<String> resourcePoolNames=vcClusterRpNamesEntry.getValue();
      for (      String resourcePoolName : resourcePoolNames) {
        VcResourcePool parentVcResourcePool=null;
        String vcRPName=CommonUtil.isBlank(resourcePoolName) ? clusterRpName : resourcePoolName + ""String_Node_Str"" + clusterRpName;
        parentVcResourcePool=VcResourceUtils.findRPInVCCluster(vcClusterName,vcRPName);
        long rpHashCode=vcClusterName.hashCode() ^ (vcClusterName + resourcePoolName).hashCode();
        for (        NodeGroupCreate nodeGroup : rpNodeGroupsMap.get(rpHashCode)) {
          AuAssert.check(nodeGroup != null,""String_Node_Str"");
          if (nodeGroup.getName().length() > 80) {
            throw ClusteringServiceException.GROUP_NAME_TOO_LONG(clusterName);
          }
          CreateResourcePoolSP nodeGroupSP=new CreateResourcePoolSP(parentVcResourcePool,nodeGroup.getName(),nodeGroup);
          nodeGroupSPs[i]=nodeGroupSP;
          i++;
        }
      }
    }
    logger.info(""String_Node_Str"");
    executeResourcePoolStoreProcedures(nodeGroupSPs,""String_Node_Str"",clusterName);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
  return clusterRpName;
}","private String createVcResourcePools(List<BaseNode> vNodes){
  logger.info(""String_Node_Str"");
  String clusterName=vNodes.get(0).getClusterName();
  String uuid=ConfigInfo.getSerengetiUUID();
  String clusterRpName=uuid + ""String_Node_Str"" + clusterName;
  if (clusterRpName.length() > VC_RP_MAX_NAME_LENGTH) {
    throw ClusteringServiceException.CLUSTER_NAME_TOO_LONG(clusterName);
  }
  Map<String,List<String>> vcClusterRpNamesMap=new HashMap<String,List<String>>();
  Map<Long,List<NodeGroupCreate>> rpNodeGroupsMap=new HashMap<Long,List<NodeGroupCreate>>();
  Map<String,Integer> countResult=collectResourcePoolInfo(vNodes,vcClusterRpNamesMap,rpNodeGroupsMap);
  try {
    int resourcePoolNameCount=countResult.get(""String_Node_Str"");
    Callable<Void>[] clusterSPs=new Callable[resourcePoolNameCount];
    int i=0;
    for (    Entry<String,List<String>> vcClusterRpNamesEntry : vcClusterRpNamesMap.entrySet()) {
      String vcClusterName=vcClusterRpNamesEntry.getKey();
      VcCluster vcCluster=VcResourceUtils.findVcCluster(vcClusterName);
      if (vcCluster == null) {
        String errorMsg=""String_Node_Str"" + vcClusterName + ""String_Node_Str"";
        logger.error(errorMsg);
        throw BddException.INTERNAL(null,errorMsg);
      }
      List<String> resourcePoolNames=vcClusterRpNamesEntry.getValue();
      for (      String resourcePoolName : resourcePoolNames) {
        VcResourcePool parentVcResourcePool=VcResourceUtils.findRPInVCCluster(vcClusterName,resourcePoolName);
        if (parentVcResourcePool == null) {
          String errorMsg=""String_Node_Str"" + resourcePoolName + ""String_Node_Str"";
          logger.error(errorMsg);
          throw BddException.INTERNAL(null,errorMsg);
        }
        CreateResourcePoolSP clusterSP=new CreateResourcePoolSP(parentVcResourcePool,clusterRpName);
        clusterSPs[i]=clusterSP;
        i++;
      }
    }
    logger.info(""String_Node_Str"");
    executeResourcePoolStoreProcedures(clusterSPs,""String_Node_Str"",clusterName);
    int nodeGroupNameCount=countResult.get(""String_Node_Str"");
    Callable<Void>[] nodeGroupSPs=new Callable[nodeGroupNameCount];
    i=0;
    for (    Entry<String,List<String>> vcClusterRpNamesEntry : vcClusterRpNamesMap.entrySet()) {
      String vcClusterName=vcClusterRpNamesEntry.getKey();
      VcCluster vcCluster=VcResourceUtils.findVcCluster(vcClusterName);
      if (vcCluster == null) {
        String errorMsg=""String_Node_Str"" + vcClusterName + ""String_Node_Str"";
        logger.error(errorMsg);
        throw BddException.INTERNAL(null,errorMsg);
      }
      if (!vcCluster.getConfig().getDRSEnabled()) {
        continue;
      }
      List<String> resourcePoolNames=vcClusterRpNamesEntry.getValue();
      for (      String resourcePoolName : resourcePoolNames) {
        VcResourcePool parentVcResourcePool=null;
        String vcRPName=CommonUtil.isBlank(resourcePoolName) ? clusterRpName : resourcePoolName + ""String_Node_Str"" + clusterRpName;
        parentVcResourcePool=VcResourceUtils.findRPInVCCluster(vcClusterName,vcRPName);
        if (parentVcResourcePool == null) {
          String errorMsg=""String_Node_Str"" + vcRPName + ""String_Node_Str""+ (CommonUtil.isBlank(resourcePoolName) ? ""String_Node_Str"" : ""String_Node_Str"" + resourcePoolName + ""String_Node_Str"")+ ""String_Node_Str"";
          logger.error(errorMsg);
          throw BddException.INTERNAL(null,errorMsg);
        }
        long rpHashCode=vcClusterName.hashCode() ^ (vcClusterName + resourcePoolName).hashCode();
        for (        NodeGroupCreate nodeGroup : rpNodeGroupsMap.get(rpHashCode)) {
          AuAssert.check(nodeGroup != null,""String_Node_Str"");
          if (nodeGroup.getName().length() > 80) {
            throw ClusteringServiceException.GROUP_NAME_TOO_LONG(clusterName);
          }
          CreateResourcePoolSP nodeGroupSP=new CreateResourcePoolSP(parentVcResourcePool,nodeGroup.getName(),nodeGroup);
          nodeGroupSPs[i]=nodeGroupSP;
          i++;
        }
      }
    }
    logger.info(""String_Node_Str"");
    executeResourcePoolStoreProcedures(nodeGroupSPs,""String_Node_Str"",clusterName);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
  return clusterRpName;
}"
48953,"public static void prettyJsonOutput(Object object,String fileName) throws JsonParseException, JsonMappingException, IOException {
  OutputStream out=null;
  if (fileName != null) {
    out=new FileOutputStream(fileName);
  }
 else {
    out=System.out;
  }
  JsonFactory factory=new JsonFactory();
  JsonGenerator generator=factory.createJsonGenerator(out);
  ObjectMapper mapper=getMapper();
  mapper.setSerializationInclusion(Inclusion.NON_NULL);
  generator.setCodec(mapper);
  DefaultPrettyPrinter prettyPrinter=new DefaultPrettyPrinter();
  Indenter indenter=new Lf2SpacesIndenter();
  prettyPrinter.indentArraysWith(indenter);
  generator.setPrettyPrinter(prettyPrinter);
  generator.writeObject(object);
}","public static void prettyJsonOutput(Object object,String fileName) throws JsonParseException, JsonMappingException, IOException {
  OutputStream out=null;
  if (fileName != null) {
    out=new FileOutputStream(fileName);
  }
 else {
    out=System.out;
  }
  JsonFactory factory=new JsonFactory();
  JsonGenerator generator=factory.createJsonGenerator(out);
  ObjectMapper mapper=getMapper();
  mapper.setSerializationInclusion(Inclusion.NON_NULL);
  generator.setCodec(mapper);
  DefaultPrettyPrinter prettyPrinter=new DefaultPrettyPrinter();
  Indenter indenter=new Lf2SpacesIndenter();
  prettyPrinter.indentArraysWith(indenter);
  generator.setPrettyPrinter(prettyPrinter);
  generator.writeObject(object);
  if (fileName == null) {
    System.out.println();
  }
 else {
    File file=new File(fileName);
    System.out.println(""String_Node_Str"" + file.getAbsolutePath());
  }
}"
48954,"public boolean isSpecFile(){
  return specFile;
}","@JsonIgnore public boolean isSpecFile(){
  return specFile;
}"
48955,"@SuppressWarnings(""String_Node_Str"") public ClusterRead toClusterRead(String clusterName){
  ClusterEntity cluster=findByName(clusterName);
  ClusterStatus clusterStatus=cluster.getStatus();
  ClusterRead clusterRead=new ClusterRead();
  clusterRead.setInstanceNum(cluster.getRealInstanceNum());
  clusterRead.setName(cluster.getName());
  clusterRead.setStatus(clusterStatus);
  clusterRead.setDistro(cluster.getDistro());
  clusterRead.setDistroVendor(cluster.getDistroVendor());
  clusterRead.setTopologyPolicy(cluster.getTopologyPolicy());
  clusterRead.setAutomationEnable(cluster.getAutomationEnable());
  clusterRead.setVhmMinNum(cluster.getVhmMinNum());
  clusterRead.setVhmTargetNum(cluster.getVhmTargetNum());
  clusterRead.setIoShares(cluster.getIoShares());
  List<NodeGroupRead> groupList=new ArrayList<NodeGroupRead>();
  for (  NodeGroupEntity group : cluster.getNodeGroups()) {
    groupList.add(group.toNodeGroupRead());
  }
  clusterRead.setNodeGroups(groupList);
  if (cluster.getHadoopConfig() != null) {
    Map conf=(new Gson()).fromJson(cluster.getHadoopConfig(),Map.class);
    Map hadoopConf=(Map)conf.get(""String_Node_Str"");
    if (hadoopConf != null) {
      Map coreSiteConf=(Map)hadoopConf.get(""String_Node_Str"");
      if (coreSiteConf != null) {
        String hdfs=(String)coreSiteConf.get(""String_Node_Str"");
        if (hdfs != null && !hdfs.isEmpty()) {
          clusterRead.setExternalHDFS(hdfs);
        }
      }
    }
  }
  Set<VcResourcePoolEntity> rps=cluster.getUsedRps();
  List<ResourcePoolRead> rpReads=new ArrayList<ResourcePoolRead>(rps.size());
  for (  VcResourcePoolEntity rp : rps) {
    ResourcePoolRead rpRead=rp.toRest();
    rpRead.setNodes(null);
    rpReads.add(rpRead);
  }
  clusterRead.setResourcePools(rpReads);
  if (clusterStatus == ClusterStatus.RUNNING || clusterStatus == ClusterStatus.STOPPED) {
    clusterRead.setDcSeperation(clusterRead.validateSetManualElasticity());
  }
  return clusterRead;
}","@SuppressWarnings(""String_Node_Str"") public ClusterRead toClusterRead(String clusterName){
  ClusterEntity cluster=findByName(clusterName);
  ClusterStatus clusterStatus=cluster.getStatus();
  ClusterRead clusterRead=new ClusterRead();
  clusterRead.setInstanceNum(cluster.getRealInstanceNum());
  clusterRead.setName(cluster.getName());
  clusterRead.setStatus(clusterStatus);
  clusterRead.setDistro(cluster.getDistro());
  clusterRead.setDistroVendor(cluster.getDistroVendor());
  clusterRead.setTopologyPolicy(cluster.getTopologyPolicy());
  clusterRead.setAutomationEnable(cluster.getAutomationEnable());
  clusterRead.setVhmMinNum(cluster.getVhmMinNum());
  clusterRead.setVhmTargetNum(cluster.getVhmTargetNum());
  clusterRead.setIoShares(cluster.getIoShares());
  boolean computeOnly=true;
  List<NodeGroupRead> groupList=new ArrayList<NodeGroupRead>();
  for (  NodeGroupEntity group : cluster.getNodeGroups()) {
    groupList.add(group.toNodeGroupRead());
    if (group.getRoles() != null && (group.getRoles().contains(HadoopRole.HADOOP_NAMENODE_ROLE.toString()) || group.getRoles().contains(HadoopRole.MAPR_CLDB_ROLE.toString()))) {
      computeOnly=false;
    }
  }
  clusterRead.setNodeGroups(groupList);
  if (computeOnly && cluster.getHadoopConfig() != null) {
    Map conf=(new Gson()).fromJson(cluster.getHadoopConfig(),Map.class);
    Map hadoopConf=(Map)conf.get(""String_Node_Str"");
    if (hadoopConf != null) {
      Map coreSiteConf=(Map)hadoopConf.get(""String_Node_Str"");
      if (coreSiteConf != null) {
        String hdfs=(String)coreSiteConf.get(""String_Node_Str"");
        if (hdfs != null && !hdfs.isEmpty()) {
          clusterRead.setExternalHDFS(hdfs);
        }
      }
    }
  }
  Set<VcResourcePoolEntity> rps=cluster.getUsedRps();
  List<ResourcePoolRead> rpReads=new ArrayList<ResourcePoolRead>(rps.size());
  for (  VcResourcePoolEntity rp : rps) {
    ResourcePoolRead rpRead=rp.toRest();
    rpRead.setNodes(null);
    rpReads.add(rpRead);
  }
  clusterRead.setResourcePools(rpReads);
  if (clusterStatus == ClusterStatus.RUNNING || clusterStatus == ClusterStatus.STOPPED) {
    clusterRead.setDcSeperation(clusterRead.validateSetManualElasticity());
  }
  return clusterRead;
}"
48956,"/** 
 * Check if any compute only node group exists.
 */
public boolean containsComputeOnlyNodeGroups(){
  int count=0;
  for (  NodeGroupCreate nodeGroup : this.getNodeGroups()) {
    if (nodeGroup.getRoles() != null && nodeGroup.getRoles().contains(HadoopRole.HADOOP_TASKTRACKER.toString()) && (nodeGroup.getRoles().size() == 1 || (nodeGroup.getRoles().size() == 2 && nodeGroup.getRoles().contains(HadoopRole.TEMPFS_CLIENT_ROLE.toString())))) {
      count++;
    }
  }
  return count != 0 ? true : false;
}","/** 
 * Check if any compute only node group exists.
 */
public boolean containsComputeOnlyNodeGroups(){
  for (  NodeGroupCreate nodeGroup : this.getNodeGroups()) {
    if (CommonUtil.isComputeOnly(nodeGroup.getRoles(),distroVendor)) {
      return true;
    }
  }
  return false;
}"
48957,"public boolean validateSetManualElasticity(List<String>... nodeGroupNames){
  List<NodeGroupRead> nodeGroups=getNodeGroups();
  if (nodeGroups != null && !nodeGroups.isEmpty()) {
    int count=0;
    for (    NodeGroupRead nodeGroup : getNodeGroups()) {
      boolean isComputeOnly=false;
      if (distroVendor.equalsIgnoreCase(Constants.MAPR_VENDOR)) {
        if (nodeGroup.getRoles() != null && nodeGroup.getRoles().contains(HadoopRole.MAPR_TASKTRACKER_ROLE.toString()) && !nodeGroup.getRoles().contains(HadoopRole.MAPR_NFS_ROLE.toString())) {
          isComputeOnly=true;
        }
      }
 else {
        if (nodeGroup.getRoles() != null && nodeGroup.getRoles().contains(HadoopRole.HADOOP_TASKTRACKER.toString()) && (nodeGroup.getRoles().size() == 1 || (nodeGroup.getRoles().size() == 2 && nodeGroup.getRoles().contains(HadoopRole.TEMPFS_CLIENT_ROLE.toString())))) {
          isComputeOnly=true;
        }
      }
      if (isComputeOnly) {
        if (nodeGroupNames != null && nodeGroupNames.length > 0) {
          nodeGroupNames[0].add(nodeGroup.getName());
        }
        count++;
      }
    }
    if (count == 0) {
      return false;
    }
  }
 else {
    return false;
  }
  return true;
}","public boolean validateSetManualElasticity(List<String>... nodeGroupNames){
  List<NodeGroupRead> nodeGroups=getNodeGroups();
  if (nodeGroups != null && !nodeGroups.isEmpty()) {
    int count=0;
    for (    NodeGroupRead nodeGroup : getNodeGroups()) {
      if (CommonUtil.isComputeOnly(nodeGroup.getRoles(),distroVendor)) {
        if (nodeGroupNames != null && nodeGroupNames.length > 0) {
          nodeGroupNames[0].add(nodeGroup.getName());
        }
        count++;
      }
    }
    if (count == 0) {
      return false;
    }
  }
 else {
    return false;
  }
  return true;
}"
48958,"public Long startCluster(String clusterName) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (ClusterStatus.RUNNING.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw ClusterManagerException.ALREADY_STARTED_ERROR(clusterName);
  }
  if (!ClusterStatus.STOPPED.equals(cluster.getStatus()) && !ClusterStatus.ERROR.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.START_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.ERROR.name()));
  JobParameters jobParameters=new JobParameters(param);
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.STARTING);
  try {
    return jobManager.runJob(JobConstants.START_CLUSTER_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.ERROR);
    throw e;
  }
}","public Long startCluster(String clusterName) throws Exception {
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (ClusterStatus.RUNNING.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw ClusterManagerException.ALREADY_STARTED_ERROR(clusterName);
  }
  if (!ClusterStatus.STOPPED.equals(cluster.getStatus()) && !ClusterStatus.ERROR.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.START_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  cluster.setVhmTargetNum(-1);
  clusterEntityMgr.update(cluster);
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.ERROR.name()));
  JobParameters jobParameters=new JobParameters(param);
  clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.STARTING);
  try {
    return jobManager.runJob(JobConstants.START_CLUSTER_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.ERROR);
    throw e;
  }
}"
48959,"/** 
 * set cluster parameters synchronously
 * @param clusterName
 * @param activeComputeNodeNum
 * @param minComputeNodeNum
 * @param mode
 * @param ioPriority
 * @throws Exception
 */
@SuppressWarnings(""String_Node_Str"") public List<String> syncSetParam(String clusterName,Integer activeComputeNodeNum,Integer minComputeNodeNum,Boolean enableAuto,Priority ioPriority) throws Exception {
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  ClusterRead clusterRead=getClusterByName(clusterName,false);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (ioPriority != null) {
    prioritizeCluster(clusterName,ioPriority);
  }
  cluster=clusterEntityMgr.findByName(clusterName);
  if (enableAuto != null && enableAuto != cluster.getAutomationEnable()) {
    cluster.setAutomationEnable(enableAuto);
  }
  if (minComputeNodeNum != null && minComputeNodeNum != cluster.getVhmMinNum()) {
    cluster.setVhmMinNum(minComputeNodeNum);
  }
  List<String> nodeGroupNames=new ArrayList<String>();
  if ((enableAuto != null || minComputeNodeNum != null || activeComputeNodeNum != null) && !clusterRead.validateSetManualElasticity(nodeGroupNames)) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
  }
  if (activeComputeNodeNum != null) {
    if (!activeComputeNodeNum.equals(cluster.getVhmTargetNum())) {
      cluster.setVhmTargetNum(activeComputeNodeNum);
    }
  }
  if ((enableAuto != null) && !ClusterStatus.RUNNING.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus()) && !ClusterStatus.STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  clusterEntityMgr.update(cluster);
  if (enableAuto != null || minComputeNodeNum != null) {
    boolean success=clusteringService.setAutoElasticity(clusterName);
    if (!success) {
      throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
    }
  }
  if (enableAuto != null && !enableAuto && cluster.getVhmTargetNum() == null) {
    JobUtils.waitForManual(clusterName,executionService);
  }
  return nodeGroupNames;
}","/** 
 * set cluster parameters synchronously
 * @param clusterName
 * @param activeComputeNodeNum
 * @param minComputeNodeNum
 * @param mode
 * @param ioPriority
 * @throws Exception
 */
@SuppressWarnings(""String_Node_Str"") public List<String> syncSetParam(String clusterName,Integer activeComputeNodeNum,Integer minComputeNodeNum,Boolean enableAuto,Priority ioPriority) throws Exception {
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  ClusterRead clusterRead=getClusterByName(clusterName,false);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (ioPriority != null) {
    prioritizeCluster(clusterName,ioPriority);
  }
  cluster=clusterEntityMgr.findByName(clusterName);
  if (enableAuto != null && enableAuto != cluster.getAutomationEnable()) {
    cluster.setAutomationEnable(enableAuto);
  }
  if (minComputeNodeNum != null && minComputeNodeNum != cluster.getVhmMinNum()) {
    cluster.setVhmMinNum(minComputeNodeNum);
  }
  List<String> nodeGroupNames=new ArrayList<String>();
  if ((enableAuto != null || minComputeNodeNum != null || activeComputeNodeNum != null) && !clusterRead.validateSetManualElasticity(nodeGroupNames)) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
  }
  if (activeComputeNodeNum != null) {
    if (!activeComputeNodeNum.equals(cluster.getVhmTargetNum())) {
      cluster.setVhmTargetNum(activeComputeNodeNum);
    }
  }
  if ((enableAuto != null) && !ClusterStatus.RUNNING.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus()) && !ClusterStatus.STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  clusterEntityMgr.update(cluster);
  if (enableAuto != null || minComputeNodeNum != null) {
    boolean success=clusteringService.setAutoElasticity(clusterName,false);
    if (!success) {
      throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
    }
  }
  if (enableAuto != null && !enableAuto && cluster.getVhmTargetNum() == null) {
    JobUtils.waitForManual(clusterName,executionService);
  }
  return nodeGroupNames;
}"
48960,"/** 
 * Set auto elasticity
 * @param clusterName
 * @return
 */
public boolean setAutoElasticity(String clusterName);","/** 
 * Set auto elasticity
 * @param clusterName
 * @return
 */
public boolean setAutoElasticity(String clusterName,boolean refreshAllNodes);"
48961,"@SuppressWarnings(""String_Node_Str"") public boolean setAutoElasticity(String clusterName){
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=getClusterEntityMgr().findByName(clusterName);
  List<NodeEntity> nodes=clusterEntityMgr.findAllNodes(clusterName);
  Boolean enableAutoElasticity=cluster.getAutomationEnable();
  if (enableAutoElasticity == null) {
    return true;
  }
  String masterMoId=cluster.getVhmMasterMoid();
  if (masterMoId == null) {
    logger.error(""String_Node_Str"");
    throw ClusteringServiceException.SET_AUTO_ELASTICITY_FAILED(cluster.getName());
  }
  String serengetiUUID=ConfigInfo.getSerengetiRootFolder();
  int minComputeNodeNum=cluster.getVhmMinNum();
  String jobTrackerPort=cluster.getVhmJobTrackerPort();
  VcVirtualMachine vcVm=VcCache.getIgnoreMissing(masterMoId);
  if (vcVm == null) {
    logger.error(""String_Node_Str"");
    return false;
  }
  String masterUUID=vcVm.getConfig().getUuid();
  Callable<Void>[] storeProcedures=new Callable[nodes.size()];
  int i=0;
  for (  NodeEntity node : nodes) {
    List<String> roles=new Gson().fromJson(node.getNodeGroup().getRoles(),List.class);
    boolean isComputeOnlyNode=false;
    if (roles.contains(HadoopRole.HADOOP_TASKTRACKER.toString()) && (roles.size() == 1 || (roles.size() == 2 && roles.contains(HadoopRole.TEMPFS_CLIENT_ROLE.toString())))) {
      isComputeOnlyNode=true;
    }
    VcVirtualMachine vm=VcCache.getIgnoreMissing(node.getMoId());
    if (vm == null) {
      logger.error(""String_Node_Str"" + node.getVmName());
      return false;
    }
    SetAutoElasticitySP sp=new SetAutoElasticitySP(vm,serengetiUUID,masterMoId,masterUUID,enableAutoElasticity,minComputeNodeNum,jobTrackerPort,isComputeOnlyNode);
    storeProcedures[i]=sp;
    i++;
  }
  try {
    logger.info(""String_Node_Str"");
    boolean success=true;
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProcedures,callback);
    if (result == null) {
      logger.error(""String_Node_Str"");
      throw ClusteringServiceException.SET_AUTO_ELASTICITY_FAILED(clusterName);
    }
    for (i=0; i < storeProcedures.length; i++) {
      if (result[i].throwable != null) {
        logger.error(""String_Node_Str"",result[i].throwable);
        success=false;
      }
    }
    return success;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}","@SuppressWarnings(""String_Node_Str"") public boolean setAutoElasticity(String clusterName,boolean refreshAllNodes){
  logger.info(""String_Node_Str"" + clusterName);
  ClusterEntity cluster=getClusterEntityMgr().findByName(clusterName);
  List<NodeEntity> nodes=clusterEntityMgr.findAllNodes(clusterName);
  Boolean enableAutoElasticity=cluster.getAutomationEnable();
  if (enableAutoElasticity == null) {
    return true;
  }
  String masterMoId=cluster.getVhmMasterMoid();
  if (masterMoId == null) {
    logger.error(""String_Node_Str"");
    throw ClusteringServiceException.SET_AUTO_ELASTICITY_FAILED(cluster.getName());
  }
  String serengetiUUID=ConfigInfo.getSerengetiRootFolder();
  int minComputeNodeNum=cluster.getVhmMinNum();
  String jobTrackerPort=cluster.getVhmJobTrackerPort();
  VcVirtualMachine vcVm=VcCache.getIgnoreMissing(masterMoId);
  if (vcVm == null) {
    logger.error(""String_Node_Str"");
    return false;
  }
  String masterUUID=vcVm.getConfig().getUuid();
  Callable<Void>[] storeProcedures=new Callable[nodes.size()];
  int i=0;
  for (  NodeEntity node : nodes) {
    VcVirtualMachine vm=VcCache.getIgnoreMissing(node.getMoId());
    if (vm == null) {
      logger.error(""String_Node_Str"" + node.getVmName());
      return false;
    }
    if (!refreshAllNodes && !vm.getId().equalsIgnoreCase(masterMoId)) {
      continue;
    }
    List<String> roles=new Gson().fromJson(node.getNodeGroup().getRoles(),List.class);
    String distroVendor=node.getNodeGroup().getCluster().getDistroVendor();
    boolean isComputeOnlyNode=CommonUtil.isComputeOnly(roles,distroVendor);
    SetAutoElasticitySP sp=new SetAutoElasticitySP(vm,serengetiUUID,masterMoId,masterUUID,enableAutoElasticity,minComputeNodeNum,jobTrackerPort,isComputeOnlyNode);
    storeProcedures[i]=sp;
    i++;
  }
  try {
    logger.info(""String_Node_Str"");
    boolean success=true;
    NoProgressUpdateCallback callback=new NoProgressUpdateCallback();
    ExecutionResult[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProcedures,callback);
    if (result == null) {
      logger.error(""String_Node_Str"");
      throw ClusteringServiceException.SET_AUTO_ELASTICITY_FAILED(clusterName);
    }
    for (i=0; i < storeProcedures.length; i++) {
      if (result[i].throwable != null) {
        logger.error(""String_Node_Str"",result[i].throwable);
        success=false;
      }
    }
    return success;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}"
48962,"private void setAutoFlag(boolean isReset){
  ClusterEntity clusterEntity=clusterEntityMgr.findByName(clusterName);
  Boolean value=null;
  if (!isReset) {
    preAutoFlag=clusterEntity.getAutomationEnable();
    if (preAutoFlag == null || !preAutoFlag) {
      return;
    }
    value=false;
    logger.info(""String_Node_Str"");
  }
 else {
    if (clusterEntity.getAutomationEnable() == preAutoFlag) {
      return;
    }
    value=preAutoFlag;
    logger.info(""String_Node_Str"" + preAutoFlag);
  }
  clusterEntity.setAutomationEnable(value);
  clusterEntityMgr.update(clusterEntity);
  if (!clusteringService.setAutoElasticity(clusterName)) {
    throw TaskException.EXECUTION_FAILED(""String_Node_Str"" + clusterName);
  }
}","private void setAutoFlag(boolean isReset){
  ClusterEntity clusterEntity=clusterEntityMgr.findByName(clusterName);
  Boolean value=null;
  if (!isReset) {
    preAutoFlag=clusterEntity.getAutomationEnable();
    if (preAutoFlag == null || !preAutoFlag) {
      return;
    }
    value=false;
    logger.info(""String_Node_Str"");
  }
 else {
    if (clusterEntity.getAutomationEnable() == preAutoFlag) {
      return;
    }
    value=preAutoFlag;
    logger.info(""String_Node_Str"" + preAutoFlag);
  }
  clusterEntity.setAutomationEnable(value);
  clusterEntityMgr.update(clusterEntity);
  if (!clusteringService.setAutoElasticity(clusterName,false)) {
    throw TaskException.EXECUTION_FAILED(""String_Node_Str"" + clusterName);
  }
}"
48963,"private void updateVhmMasterMoid(String clusterName){
  ClusterEntity cluster=getClusterEntityMgr().findByName(clusterName);
  if (cluster.getVhmMasterMoid() == null) {
    List<NodeEntity> nodes=getClusterEntityMgr().findAllNodes(clusterName);
    for (    NodeEntity node : nodes) {
      if (node.getMoId() != null && node.getNodeGroup().getRoles() != null) {
        @SuppressWarnings(""String_Node_Str"") List<String> roles=new Gson().fromJson(node.getNodeGroup().getRoles(),List.class);
        if (roles.contains(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString())) {
          cluster.setVhmMasterMoid(node.getMoId());
          break;
        }
      }
    }
  }
}","private void updateVhmMasterMoid(String clusterName){
  ClusterEntity cluster=getClusterEntityMgr().findByName(clusterName);
  if (cluster.getVhmMasterMoid() == null) {
    List<NodeEntity> nodes=getClusterEntityMgr().findAllNodes(clusterName);
    for (    NodeEntity node : nodes) {
      if (node.getMoId() != null && node.getNodeGroup().getRoles() != null) {
        @SuppressWarnings(""String_Node_Str"") List<String> roles=new Gson().fromJson(node.getNodeGroup().getRoles(),List.class);
        if (cluster.getDistro().equalsIgnoreCase(Constants.MAPR_VENDOR)) {
          if (roles.contains(HadoopRole.MAPR_JOBTRACKER_ROLE.toString())) {
            cluster.setVhmMasterMoid(node.getMoId());
            break;
          }
        }
 else {
          if (roles.contains(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString())) {
            cluster.setVhmMasterMoid(node.getMoId());
            break;
          }
        }
      }
    }
  }
}"
48964,"@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  boolean success=clusteringService.setAutoElasticity(clusterName);
  putIntoJobExecutionContext(chunkContext,JobConstants.CLUSTER_EXISTING_NODES_JOB_PARAM,success);
  if (!success) {
    throw TaskException.EXECUTION_FAILED(""String_Node_Str"" + clusterName + ""String_Node_Str"");
  }
  return RepeatStatus.FINISHED;
}","@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  boolean success=clusteringService.setAutoElasticity(clusterName,refreshAllNodes);
  putIntoJobExecutionContext(chunkContext,JobConstants.CLUSTER_EXISTING_NODES_JOB_PARAM,success);
  if (!success) {
    throw TaskException.EXECUTION_FAILED(""String_Node_Str"" + clusterName + ""String_Node_Str"");
  }
  return RepeatStatus.FINISHED;
}"
48965,"private boolean diableAutoEalsticity(String clusterName){
  AuAssert.check(clusteringService != null);
  AuAssert.check(clusterEntityManager != null);
  ClusterEntity clusterEntity=clusterEntityManager.findByName(clusterName);
  if (clusterEntity.getAutomationEnable() == null || !clusterEntity.getAutomationEnable()) {
    return true;
  }
  clusterEntity.setAutomationEnable(false);
  clusterEntityManager.update(clusterEntity);
  return clusteringService.setAutoElasticity(clusterName);
}","private boolean diableAutoEalsticity(String clusterName){
  AuAssert.check(clusteringService != null);
  AuAssert.check(clusterEntityManager != null);
  ClusterEntity clusterEntity=clusterEntityManager.findByName(clusterName);
  if (clusterEntity.getAutomationEnable() == null || !clusterEntity.getAutomationEnable()) {
    return true;
  }
  clusterEntity.setAutomationEnable(false);
  clusterEntityManager.update(clusterEntity);
  return clusteringService.setAutoElasticity(clusterName,false);
}"
48966,"@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  Long activeComputeNodeNum=getJobParameters(chunkContext).getLong(JobConstants.ACTIVE_COMPUTE_NODE_NUMBER_JOB_PARAM);
  String action=getJobParameters(chunkContext).getString(JobConstants.VHM_ACTION_JOB_PARAM);
  if (action != null) {
    vhmAction=action;
  }
  if (vhmAction == LimitInstruction.actionWaitForManual) {
    if (!diableAutoEalsticity(clusterName)) {
      throw TaskException.EXECUTION_FAILED(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    }
  }
  MessageHandler listener=null;
  if (vhmAction == LimitInstruction.actionSetTarget || vhmAction == LimitInstruction.actionUnlimit) {
    StatusUpdater statusUpdater=new DefaultStatusUpdater(jobExecutionStatusHolder,getJobExecutionId(chunkContext));
    listener=new VHMReceiveListener(clusterName,statusUpdater);
  }
  Map<String,Object> sendParam=new HashMap<String,Object>();
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_VERSION,Constants.VHM_PROTOCOL_VERSION);
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_CLUSTER_NAME,clusterName);
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_INSTANCE_NUM,activeComputeNodeNum);
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_RECEIVE_ROUTE_KEY,CommonUtil.getUUID());
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_ACTION,vhmAction);
  Map<String,Object> ret=executionService.execute(new VHMMessageTask(sendParam,listener));
  if (!(Boolean)ret.get(""String_Node_Str"")) {
    String errorMessage=(String)ret.get(""String_Node_Str"");
    putIntoJobExecutionContext(chunkContext,JobConstants.CURRENT_ERROR_MESSAGE,errorMessage);
    throw TaskException.EXECUTION_FAILED(errorMessage);
  }
  return RepeatStatus.FINISHED;
}","@Override public RepeatStatus executeStep(ChunkContext chunkContext,JobExecutionStatusHolder jobExecutionStatusHolder) throws Exception {
  Map<String,JobParameter> allParameters=getJobParameters(chunkContext).getParameters();
  if (!allParameters.containsKey(JobConstants.VHM_ACTION_JOB_PARAM) && !allParameters.containsKey(JobConstants.ACTIVE_COMPUTE_NODE_NUMBER_JOB_PARAM)) {
    return RepeatStatus.FINISHED;
  }
  String clusterName=getJobParameters(chunkContext).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  Long activeComputeNodeNum=getJobParameters(chunkContext).getLong(JobConstants.ACTIVE_COMPUTE_NODE_NUMBER_JOB_PARAM);
  String action=getJobParameters(chunkContext).getString(JobConstants.VHM_ACTION_JOB_PARAM);
  if (action != null) {
    vhmAction=action;
  }
  if (vhmAction == LimitInstruction.actionWaitForManual) {
    if (!diableAutoEalsticity(clusterName)) {
      throw TaskException.EXECUTION_FAILED(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    }
  }
  MessageHandler listener=null;
  if (vhmAction == LimitInstruction.actionSetTarget || vhmAction == LimitInstruction.actionUnlimit) {
    StatusUpdater statusUpdater=new DefaultStatusUpdater(jobExecutionStatusHolder,getJobExecutionId(chunkContext));
    listener=new VHMReceiveListener(clusterName,statusUpdater);
  }
  Map<String,Object> sendParam=new HashMap<String,Object>();
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_VERSION,Constants.VHM_PROTOCOL_VERSION);
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_CLUSTER_NAME,clusterName);
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_INSTANCE_NUM,activeComputeNodeNum);
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_RECEIVE_ROUTE_KEY,CommonUtil.getUUID());
  sendParam.put(Constants.SET_MANUAL_ELASTICITY_INFO_ACTION,vhmAction);
  Map<String,Object> ret=executionService.execute(new VHMMessageTask(sendParam,listener));
  if (!(Boolean)ret.get(""String_Node_Str"")) {
    String errorMessage=(String)ret.get(""String_Node_Str"");
    putIntoJobExecutionContext(chunkContext,JobConstants.CURRENT_ERROR_MESSAGE,errorMessage);
    throw TaskException.EXECUTION_FAILED(errorMessage);
  }
  return RepeatStatus.FINISHED;
}"
48967,"@Override public Void call() throws Exception {
  if (vcVm == null) {
    logger.info(""String_Node_Str"");
    return null;
  }
  final VcVirtualMachine vm=VcCache.getIgnoreMissing(vcVm.getId());
  if (vm == null) {
    logger.info(""String_Node_Str"");
  }
  VcContext.inVcSessionDo(new VcSession<Void>(){
    @Override protected Void body() throws Exception {
      List<OptionValue> options=new ArrayList<OptionValue>();
      if (vm.getId().equalsIgnoreCase(masterMoId)) {
        options.add(new OptionValueImpl(""String_Node_Str"",enableAutoElasticity.toString()));
        options.add(new OptionValueImpl(""String_Node_Str"",(new Integer(minComputeNodeNum)).toString()));
        options.add(new OptionValueImpl(""String_Node_Str"",jobTrackerPort));
      }
      options.add(new OptionValueImpl(""String_Node_Str"",masterMoId.split(""String_Node_Str"")[2]));
      options.add(new OptionValueImpl(""String_Node_Str"",masterUUID));
      options.add(new OptionValueImpl(""String_Node_Str"",serengetiUUID));
      options.add(new OptionValueImpl(""String_Node_Str"",(new Boolean(isComputeOnlyNode)).toString()));
      OptionValue[] optionValues=options.toArray((OptionValue[])Array.newInstance(OptionValue.class,options.size()));
      ConfigSpec spec=new ConfigSpecImpl();
      spec.setExtraConfig(optionValues);
      vm.reconfigure(spec);
      logger.info(""String_Node_Str"" + masterMoId + ""String_Node_Str""+ masterUUID+ ""String_Node_Str""+ isComputeOnlyNode+ ""String_Node_Str""+ enableAutoElasticity+ ""String_Node_Str""+ jobTrackerPort+ ""String_Node_Str""+ minComputeNodeNum);
      return null;
    }
    protected boolean isTaskSession(){
      return true;
    }
  }
);
  return null;
}","@Override public Void call() throws Exception {
  if (vcVm == null) {
    logger.info(""String_Node_Str"");
    return null;
  }
  final VcVirtualMachine vm=VcCache.getIgnoreMissing(vcVm.getId());
  if (vm == null) {
    logger.info(""String_Node_Str"");
  }
  VcContext.inVcSessionDo(new VcSession<Void>(){
    @Override protected Void body() throws Exception {
      List<OptionValue> options=new ArrayList<OptionValue>();
      if (vm.getId().equalsIgnoreCase(masterMoId)) {
        options.add(new OptionValueImpl(VHMConstants.VHM_ENABLE,enableAutoElasticity.toString()));
        options.add(new OptionValueImpl(VHMConstants.VHM_MIN_COMPUTENODE_NUM,(new Integer(minComputeNodeNum)).toString()));
        options.add(new OptionValueImpl(VHMConstants.VHM_JOBTRACKER_PORT,jobTrackerPort));
      }
      options.add(new OptionValueImpl(VHMConstants.VHM_MASTER_MOID,masterMoId.split(""String_Node_Str"")[2]));
      options.add(new OptionValueImpl(VHMConstants.VHM_MASTER_UUID,masterUUID));
      options.add(new OptionValueImpl(VHMConstants.VHM_SERENGETI_UUID,serengetiUUID));
      options.add(new OptionValueImpl(VHMConstants.VHM_ELASTIC,(new Boolean(isComputeOnlyNode)).toString()));
      OptionValue[] optionValues=options.toArray((OptionValue[])Array.newInstance(OptionValue.class,options.size()));
      ConfigSpec spec=new ConfigSpecImpl();
      spec.setExtraConfig(optionValues);
      vm.reconfigure(spec);
      logger.info(""String_Node_Str"" + masterMoId + ""String_Node_Str""+ masterUUID+ ""String_Node_Str""+ isComputeOnlyNode+ ""String_Node_Str""+ enableAutoElasticity+ ""String_Node_Str""+ jobTrackerPort+ ""String_Node_Str""+ minComputeNodeNum);
      return null;
    }
    protected boolean isTaskSession(){
      return true;
    }
  }
);
  return null;
}"
48968,"@Override protected Void body() throws Exception {
  List<OptionValue> options=new ArrayList<OptionValue>();
  if (vm.getId().equalsIgnoreCase(masterMoId)) {
    options.add(new OptionValueImpl(""String_Node_Str"",enableAutoElasticity.toString()));
    options.add(new OptionValueImpl(""String_Node_Str"",(new Integer(minComputeNodeNum)).toString()));
    options.add(new OptionValueImpl(""String_Node_Str"",jobTrackerPort));
  }
  options.add(new OptionValueImpl(""String_Node_Str"",masterMoId.split(""String_Node_Str"")[2]));
  options.add(new OptionValueImpl(""String_Node_Str"",masterUUID));
  options.add(new OptionValueImpl(""String_Node_Str"",serengetiUUID));
  options.add(new OptionValueImpl(""String_Node_Str"",(new Boolean(isComputeOnlyNode)).toString()));
  OptionValue[] optionValues=options.toArray((OptionValue[])Array.newInstance(OptionValue.class,options.size()));
  ConfigSpec spec=new ConfigSpecImpl();
  spec.setExtraConfig(optionValues);
  vm.reconfigure(spec);
  logger.info(""String_Node_Str"" + masterMoId + ""String_Node_Str""+ masterUUID+ ""String_Node_Str""+ isComputeOnlyNode+ ""String_Node_Str""+ enableAutoElasticity+ ""String_Node_Str""+ jobTrackerPort+ ""String_Node_Str""+ minComputeNodeNum);
  return null;
}","@Override protected Void body() throws Exception {
  List<OptionValue> options=new ArrayList<OptionValue>();
  if (vm.getId().equalsIgnoreCase(masterMoId)) {
    options.add(new OptionValueImpl(VHMConstants.VHM_ENABLE,enableAutoElasticity.toString()));
    options.add(new OptionValueImpl(VHMConstants.VHM_MIN_COMPUTENODE_NUM,(new Integer(minComputeNodeNum)).toString()));
    options.add(new OptionValueImpl(VHMConstants.VHM_JOBTRACKER_PORT,jobTrackerPort));
  }
  options.add(new OptionValueImpl(VHMConstants.VHM_MASTER_MOID,masterMoId.split(""String_Node_Str"")[2]));
  options.add(new OptionValueImpl(VHMConstants.VHM_MASTER_UUID,masterUUID));
  options.add(new OptionValueImpl(VHMConstants.VHM_SERENGETI_UUID,serengetiUUID));
  options.add(new OptionValueImpl(VHMConstants.VHM_ELASTIC,(new Boolean(isComputeOnlyNode)).toString()));
  OptionValue[] optionValues=options.toArray((OptionValue[])Array.newInstance(OptionValue.class,options.size()));
  ConfigSpec spec=new ConfigSpecImpl();
  spec.setExtraConfig(optionValues);
  vm.reconfigure(spec);
  logger.info(""String_Node_Str"" + masterMoId + ""String_Node_Str""+ masterUUID+ ""String_Node_Str""+ isComputeOnlyNode+ ""String_Node_Str""+ enableAutoElasticity+ ""String_Node_Str""+ jobTrackerPort+ ""String_Node_Str""+ minComputeNodeNum);
  return null;
}"
48969,"/** 
 * set cluster parameters asynchronously
 * @param clusterName
 * @param enableManualElasticity
 * @param activeComputeNodeNum
 * @return
 * @throws Exception
 */
public Long asyncSetParam(String clusterName,Integer activeComputeNodeNum,Integer minComputeNodeNum,Boolean enableAuto,Priority ioPriority) throws Exception {
  ClusterRead cluster=getClusterByName(clusterName,false);
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus())) {
    String msg=""String_Node_Str"";
    logger.error(msg);
    throw ClusterManagerException.SET_MANUAL_ELASTICITY_NOT_ALLOWED_ERROR(msg);
  }
  List<NodeGroupRead> nodeGroups=cluster.getNodeGroups();
  String hadoopJobTrackerIP=""String_Node_Str"";
  for (  NodeGroupRead nodeGroup : nodeGroups) {
    if (nodeGroup.getRoles() != null && (nodeGroup.getRoles().contains(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString()) || nodeGroup.getRoles().contains(HadoopRole.MAPR_JOBTRACKER_ROLE.toString()))) {
      if (!cluster.getDistroVendor().equalsIgnoreCase(Constants.MAPR_VENDOR)) {
        AuAssert.check(nodeGroup.getInstanceNum() == 1,""String_Node_Str"");
      }
      hadoopJobTrackerIP=nodeGroup.getInstances().get(0).getIp();
      if (nodeGroup.getInstanceNum() > 1) {
        hadoopJobTrackerIP=getActiveJobTrackerIp(hadoopJobTrackerIP,clusterName);
      }
      AuAssert.check(!CommonUtil.isBlank(hadoopJobTrackerIP),""String_Node_Str"");
      break;
    }
  }
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  if (activeComputeNodeNum == null) {
    activeComputeNodeNum=cluster.getVhmTargetNum();
  }
  if (activeComputeNodeNum == -1) {
    param.put(JobConstants.VHM_ACTION_JOB_PARAM,new JobParameter(LimitInstruction.actionUnlimit));
  }
 else {
    param.put(JobConstants.VHM_ACTION_JOB_PARAM,new JobParameter(LimitInstruction.actionSetTarget));
  }
  param.put(JobConstants.ACTIVE_COMPUTE_NODE_NUMBER_JOB_PARAM,new JobParameter(Long.valueOf(activeComputeNodeNum)));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  JobParameters jobParameters=new JobParameters(param);
  try {
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.VHM_RUNNING);
    return jobManager.runJob(JobConstants.SET_MANUAL_ELASTICITY_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.RUNNING);
    throw e;
  }
}","/** 
 * set cluster parameters asynchronously
 * @param clusterName
 * @param enableManualElasticity
 * @param activeComputeNodeNum
 * @return
 * @throws Exception
 */
public Long asyncSetParam(String clusterName,Integer activeComputeNodeNum,Integer minComputeNodeNum,Boolean enableAuto,Priority ioPriority) throws Exception {
  syncSetParam(clusterName,activeComputeNodeNum,minComputeNodeNum,enableAuto,ioPriority);
  ClusterRead cluster=getClusterByName(clusterName,false);
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus())) {
    String msg=""String_Node_Str"";
    logger.error(msg);
    throw ClusterManagerException.SET_MANUAL_ELASTICITY_NOT_ALLOWED_ERROR(msg);
  }
  List<NodeGroupRead> nodeGroups=cluster.getNodeGroups();
  String hadoopJobTrackerIP=""String_Node_Str"";
  for (  NodeGroupRead nodeGroup : nodeGroups) {
    if (nodeGroup.getRoles() != null && (nodeGroup.getRoles().contains(HadoopRole.HADOOP_JOBTRACKER_ROLE.toString()) || nodeGroup.getRoles().contains(HadoopRole.MAPR_JOBTRACKER_ROLE.toString()))) {
      if (!cluster.getDistroVendor().equalsIgnoreCase(Constants.MAPR_VENDOR)) {
        AuAssert.check(nodeGroup.getInstanceNum() == 1,""String_Node_Str"");
      }
      hadoopJobTrackerIP=nodeGroup.getInstances().get(0).getIp();
      if (nodeGroup.getInstanceNum() > 1) {
        hadoopJobTrackerIP=getActiveJobTrackerIp(hadoopJobTrackerIP,clusterName);
      }
      AuAssert.check(!CommonUtil.isBlank(hadoopJobTrackerIP),""String_Node_Str"");
      break;
    }
  }
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(clusterName));
  if (activeComputeNodeNum == null) {
    activeComputeNodeNum=cluster.getVhmTargetNum();
  }
  if (activeComputeNodeNum == -1) {
    param.put(JobConstants.VHM_ACTION_JOB_PARAM,new JobParameter(LimitInstruction.actionUnlimit));
  }
 else {
    param.put(JobConstants.VHM_ACTION_JOB_PARAM,new JobParameter(LimitInstruction.actionSetTarget));
  }
  param.put(JobConstants.ACTIVE_COMPUTE_NODE_NUMBER_JOB_PARAM,new JobParameter(Long.valueOf(activeComputeNodeNum)));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  JobParameters jobParameters=new JobParameters(param);
  try {
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.VHM_RUNNING);
    return jobManager.runJob(JobConstants.SET_MANUAL_ELASTICITY_JOB_NAME,jobParameters);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + clusterName,e);
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.RUNNING);
    throw e;
  }
}"
48970,"public void validateCDHVersion(List<String> warningMsgList){
  if (this.getDistroVendor().equalsIgnoreCase(Constants.CDH_VENDOR) && (compare(this.getDistroVersion(),""String_Node_Str"") > 0)) {
    warningMsgList.add(Constants.MUST_CONFIGURE_FQDN);
  }
}","public void validateCDHVersion(List<String> warningMsgList){
  if (this.getDistroVendor().equalsIgnoreCase(Constants.CDH_VENDOR)) {
    Pattern pattern=Pattern.compile(Constants.CDH4_PATTERN);
    if (!pattern.matcher(this.getDistroVersion()).matches()) {
      return;
    }
    if (compare(this.getDistroVersion(),""String_Node_Str"") > 0) {
      warningMsgList.add(Constants.MUST_CONFIGURE_FQDN);
    }
  }
}"
48971,"@Test public void testValidateCDHVersion(){
  List<String> warningMsgList=new LinkedList<String>();
  ClusterCreate cluster=new ClusterCreate();
  cluster.setDistroVendor(Constants.CDH_VENDOR);
  cluster.setDistroVersion(""String_Node_Str"");
  cluster.validateCDHVersion(warningMsgList);
  assertEquals(true,warningMsgList.size() == 0);
  warningMsgList.clear();
  cluster.setDistroVersion(""String_Node_Str"");
  cluster.validateCDHVersion(warningMsgList);
  assertEquals(true,warningMsgList.size() == 1);
  warningMsgList.clear();
  cluster.setDistroVersion(""String_Node_Str"");
  cluster.validateCDHVersion(warningMsgList);
  assertEquals(true,warningMsgList.size() == 1);
  warningMsgList.clear();
  cluster.setDistroVersion(""String_Node_Str"");
  cluster.validateCDHVersion(warningMsgList);
  assertEquals(true,warningMsgList.size() == 0);
  warningMsgList.clear();
  cluster.setDistroVersion(""String_Node_Str"");
  cluster.validateCDHVersion(warningMsgList);
  assertEquals(true,warningMsgList.size() == 0);
  warningMsgList.clear();
  cluster.setDistroVersion(""String_Node_Str"");
  cluster.validateCDHVersion(warningMsgList);
  assertEquals(true,warningMsgList.size() == 0);
  warningMsgList.clear();
  cluster.setDistroVersion(""String_Node_Str"");
  cluster.validateCDHVersion(warningMsgList);
  assertEquals(true,warningMsgList.size() == 0);
}","@Test public void testValidateCDHVersion(){
  List<String> warningMsgList=new LinkedList<String>();
  ClusterCreate cluster=new ClusterCreate();
  cluster.setDistroVendor(Constants.CDH_VENDOR);
  cluster.setDistroVersion(""String_Node_Str"");
  cluster.validateCDHVersion(warningMsgList);
  assertEquals(true,warningMsgList.size() == 0);
  warningMsgList.clear();
  cluster.setDistroVersion(""String_Node_Str"");
  cluster.validateCDHVersion(warningMsgList);
  assertEquals(true,warningMsgList.size() == 1);
  warningMsgList.clear();
  cluster.setDistroVersion(""String_Node_Str"");
  cluster.validateCDHVersion(warningMsgList);
  assertEquals(true,warningMsgList.size() == 1);
  warningMsgList.clear();
  cluster.setDistroVersion(""String_Node_Str"");
  cluster.validateCDHVersion(warningMsgList);
  assertEquals(true,warningMsgList.size() == 0);
  warningMsgList.clear();
  cluster.setDistroVersion(""String_Node_Str"");
  cluster.validateCDHVersion(warningMsgList);
  assertEquals(true,warningMsgList.size() == 0);
  warningMsgList.clear();
  cluster.setDistroVersion(""String_Node_Str"");
  cluster.validateCDHVersion(warningMsgList);
  assertEquals(true,warningMsgList.size() == 0);
  warningMsgList.clear();
  cluster.setDistroVersion(""String_Node_Str"");
  cluster.validateCDHVersion(warningMsgList);
  assertEquals(true,warningMsgList.size() == 0);
  cluster.setDistroVersion(""String_Node_Str"");
  cluster.validateCDHVersion(warningMsgList);
  assertEquals(true,warningMsgList.size() == 0);
}"
48972,"@Override public void allocate(VirtualNode vNode,AbstractHost host){
  for (  BaseNode node : vNode.getBaseNodes()) {
    this.dc.getDatastore(node.getTargetDs()).allocate(node.getSystemDiskSize());
    for (    Disk disk : node.getVmSchema().diskSchema.getDisks()) {
      this.dc.getDatastore(disk.datastore).allocate(disk.initialSizeMB / 1024);
    }
  }
}","@Override public void allocate(VirtualNode vNode,AbstractHost host){
  for (  BaseNode node : vNode.getBaseNodes()) {
    for (    DiskSpec disk : node.getDisks()) {
      this.dc.getDatastore(disk.getTargetDs()).allocate(disk.getSize());
    }
  }
}"
48973,"@Override public BaseNode getBaseNode(ClusterCreate cluster,NodeGroupCreate nodeGroup,int index){
  String vmName=PlacementUtil.getVmName(cluster.getName(),nodeGroup.getName(),index);
  BaseNode node=new BaseNode(vmName,nodeGroup,cluster);
  List<DiskSpec> disks=new ArrayList<DiskSpec>();
  DiskSpec systemDisk=new DiskSpec(templateNode.getDisks().get(0));
  systemDisk.setDiskType(DiskType.SYSTEM_DISK);
  systemDisk.setSeparable(false);
  disks.add(systemDisk);
  AllocationType diskAllocType=null;
  if (nodeGroup.getStorage().getAllocType() != null) {
    diskAllocType=AllocationType.valueOf(nodeGroup.getStorage().getAllocType());
  }
 else {
    diskAllocType=AllocationType.THICK;
  }
  int swapDisk=(((int)Math.ceil(nodeGroup.getMemCapacityMB() * nodeGroup.getSwapRatio()) + 1023) / 1024);
  disks.add(new DiskSpec(DiskType.SWAP_DISK.getDiskName(),swapDisk,node.getVmName(),false,DiskType.SWAP_DISK,DiskScsiControllerType.LSI_CONTROLLER,null,diskAllocType.toString(),null,null,null));
  if (!DatastoreType.TEMPFS.name().equalsIgnoreCase(nodeGroup.getStorage().getType())) {
    disks.add(new DiskSpec(DiskType.DATA_DISK.getDiskName(),nodeGroup.getStorage().getSizeGB(),node.getVmName(),true,DiskType.DATA_DISK,nodeGroup.getStorage().getControllerType(),nodeGroup.getStorage().getSplitPolicy(),diskAllocType.toString(),null,null,null));
  }
  node.setDisks(disks);
  node.setVmFolder(nodeGroup.getVmFolderPath());
  NetworkSchema netSchema=new NetworkSchema();
  ArrayList<Network> networks=new ArrayList<Network>();
  netSchema.networks=networks;
  Network network=new Network();
  network.vcNetwork=cluster.getNetworking().get(0).getPortGroup();
  networks.add(network);
  node.getVmSchema().networkSchema=netSchema;
  ResourceSchema resourceSchema=new ResourceSchema();
  resourceSchema.numCPUs=node.getCpu();
  resourceSchema.cpuReservationMHz=0;
  resourceSchema.memSize=node.getMem();
  resourceSchema.memReservationSize=0;
  resourceSchema.name=""String_Node_Str"";
  resourceSchema.priority=Priority.Normal;
  node.getVmSchema().resourceSchema=resourceSchema;
  return node;
}","@Override public BaseNode getBaseNode(ClusterCreate cluster,NodeGroupCreate nodeGroup,int index){
  String vmName=PlacementUtil.getVmName(cluster.getName(),nodeGroup.getName(),index);
  BaseNode node=new BaseNode(vmName,nodeGroup,cluster);
  List<DiskSpec> disks=new ArrayList<DiskSpec>();
  DiskSpec systemDisk=new DiskSpec(templateNode.getDisks().get(0));
  systemDisk.setSize(systemDisk.getSize() + (nodeGroup.getMemCapacityMB() + 1023) / 1024);
  systemDisk.setDiskType(DiskType.SYSTEM_DISK);
  systemDisk.setSeparable(false);
  disks.add(systemDisk);
  AllocationType diskAllocType=null;
  if (nodeGroup.getStorage().getAllocType() != null) {
    diskAllocType=AllocationType.valueOf(nodeGroup.getStorage().getAllocType());
  }
 else {
    diskAllocType=AllocationType.THICK;
  }
  int swapDisk=(((int)Math.ceil(nodeGroup.getMemCapacityMB() * nodeGroup.getSwapRatio()) + 1023) / 1024);
  disks.add(new DiskSpec(DiskType.SWAP_DISK.getDiskName(),swapDisk,node.getVmName(),false,DiskType.SWAP_DISK,DiskScsiControllerType.LSI_CONTROLLER,null,diskAllocType.toString(),null,null,null));
  if (!DatastoreType.TEMPFS.name().equalsIgnoreCase(nodeGroup.getStorage().getType())) {
    disks.add(new DiskSpec(DiskType.DATA_DISK.getDiskName(),nodeGroup.getStorage().getSizeGB(),node.getVmName(),true,DiskType.DATA_DISK,nodeGroup.getStorage().getControllerType(),nodeGroup.getStorage().getSplitPolicy(),diskAllocType.toString(),null,null,null));
  }
  node.setDisks(disks);
  node.setVmFolder(nodeGroup.getVmFolderPath());
  NetworkSchema netSchema=new NetworkSchema();
  ArrayList<Network> networks=new ArrayList<Network>();
  netSchema.networks=networks;
  Network network=new Network();
  network.vcNetwork=cluster.getNetworking().get(0).getPortGroup();
  networks.add(network);
  node.getVmSchema().networkSchema=netSchema;
  ResourceSchema resourceSchema=new ResourceSchema();
  resourceSchema.numCPUs=node.getCpu();
  resourceSchema.cpuReservationMHz=0;
  resourceSchema.memSize=node.getMem();
  resourceSchema.memReservationSize=0;
  resourceSchema.name=""String_Node_Str"";
  resourceSchema.priority=Priority.Normal;
  node.getVmSchema().resourceSchema=resourceSchema;
  return node;
}"
48974,"/** 
 * copy parent vm's configurations, includes vApp configs, hardware version info
 */
private void copyParentVmSettings(VcVirtualMachine template,ConfigSpec configSpec){
  configSpec.setName(newVmName);
  VmConfigInfo configInfo=template.getConfig().getVAppConfig();
  VmConfigSpec vAppSpec=new VmConfigSpecImpl();
  vAppSpec.setOvfEnvironmentTransport(configInfo.getOvfEnvironmentTransport());
  List<ProductSpec> productSpecs=new ArrayList<ProductSpec>();
  for (  ProductInfo info : configInfo.getProduct()) {
    ProductSpec spec=new ProductSpecImpl();
    spec.setInfo(info);
    spec.setOperation(Operation.add);
    productSpecs.add(spec);
  }
  vAppSpec.setProduct(productSpecs.toArray(new ProductSpec[productSpecs.size()]));
  configSpec.setVAppConfig(vAppSpec);
  configSpec.setGuestId(template.getConfig().getGuestId());
  configSpec.setVersion(template.getConfig().getVersion());
}","/** 
 * copy parent vm's configurations, includes vApp configs, hardware version info
 */
private void copyParentVmSettings(VcVirtualMachine template,ConfigSpec configSpec){
  configSpec.setName(newVmName);
  configSpec.setGuestId(template.getConfig().getGuestId());
  configSpec.setVersion(template.getConfig().getVersion());
  VmConfigInfo configInfo=template.getConfig().getVAppConfig();
  if (configInfo == null) {
    return;
  }
  VmConfigSpec vAppSpec=new VmConfigSpecImpl();
  vAppSpec.setOvfEnvironmentTransport(configInfo.getOvfEnvironmentTransport());
  List<ProductSpec> productSpecs=new ArrayList<ProductSpec>();
  for (  ProductInfo info : configInfo.getProduct()) {
    ProductSpec spec=new ProductSpecImpl();
    spec.setInfo(info);
    spec.setOperation(Operation.add);
    productSpecs.add(spec);
  }
  vAppSpec.setProduct(productSpecs.toArray(new ProductSpec[productSpecs.size()]));
  configSpec.setVAppConfig(vAppSpec);
}"
48975,"private void convertTemplateVm(){
  templateNode=new BaseNode(templateVm.getName());
  List<DiskSpec> diskSpecs=new ArrayList<DiskSpec>();
  for (  DeviceId slot : templateVm.getVirtualDiskIds()) {
    VirtualDisk vmdk=(VirtualDisk)templateVm.getVirtualDevice(slot);
    DiskSpec spec=new DiskSpec();
    spec.setSize((int)(vmdk.getCapacityInKB() / (1024 * 1024)));
    spec.setDiskType(DiskType.SYSTEM_DISK);
    spec.setController(DiskScsiControllerType.LSI_CONTROLLER);
    diskSpecs.add(spec);
  }
  templateNode.setDisks(diskSpecs);
}","private void convertTemplateVm(){
  templateNode=new BaseNode(templateVm.getName());
  List<DiskSpec> diskSpecs=new ArrayList<DiskSpec>();
  for (  DeviceId slot : templateVm.getVirtualDiskIds()) {
    VirtualDisk vmdk=(VirtualDisk)templateVm.getVirtualDevice(slot);
    DiskSpec spec=new DiskSpec();
    spec.setSize((int)(vmdk.getCapacityInKB() / (1024 * 1024)));
    spec.setDiskType(DiskType.SYSTEM_DISK);
    spec.setController(DiskScsiControllerType.LSI_CONTROLLER);
    diskSpecs.add(spec);
  }
  templateNode.setDisks(diskSpecs);
  templateNode.setVmMobId(templateVm.getId());
}"
48976,"@SuppressWarnings(""String_Node_Str"") @Override public boolean createVcVms(List<BaseNode> vNodes,StatusUpdater statusUpdator){
  if (vNodes.isEmpty()) {
    logger.info(""String_Node_Str"");
    return true;
  }
  Map<String,Folder> folders=createVcFolders(vNodes.get(0).getCluster());
  String clusterRpName=createVcResourcePools(vNodes);
  logger.info(""String_Node_Str"");
  FastCloneService<BaseNode> cloneSrv=new FastCloneServiceImpl<BaseNode>();
  cloneSrv.addResource(templateNode,cloneConcurrency);
  for (int i=0; i < vNodes.size(); i++) {
    BaseNode vNode=vNodes.get(i);
    vNode.setTargetVcDs(getVcDatastore(vNode));
    vNode.setTargetVcRp(getVcResourcePool(vNode,clusterRpName));
    vNode.setTargetVcFoler(folders.get(vNode.getGroupName()));
    vNode.setTargetVcHost(VcResourceUtils.findHost(vNode.getTargetHost()));
  }
  cloneSrv.addConsumers(vNodes);
  try {
    UpdateVmProgressCallback callback=new UpdateVmProgressCallback(clusterEntityMgr,statusUpdator,vNodes.get(0).getClusterName());
    cloneSrv.setProgressCallback(callback);
    logger.info(""String_Node_Str"");
    boolean success=cloneSrv.start();
    logger.info(cloneSrv.getCopied().size() + ""String_Node_Str"");
    return success;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public boolean createVcVms(List<BaseNode> vNodes,StatusUpdater statusUpdator){
  if (vNodes.isEmpty()) {
    logger.info(""String_Node_Str"");
    return true;
  }
  Map<String,Folder> folders=createVcFolders(vNodes.get(0).getCluster());
  String clusterRpName=createVcResourcePools(vNodes);
  logger.info(""String_Node_Str"");
  FastCloneService<BaseNode> cloneSrv=new FastCloneServiceImpl<BaseNode>();
  AbstractFastCopierFactory<BaseNode> copierFactory=new VmCloneSpFactory();
  cloneSrv.setFastCopierFactory(copierFactory);
  cloneSrv.addResource(templateNode,cloneConcurrency);
  for (  BaseNode vNode : vNodes) {
    vNode.setTargetVcDs(getVcDatastore(vNode));
    vNode.setTargetVcRp(getVcResourcePool(vNode,clusterRpName));
    vNode.setTargetVcFoler(folders.get(vNode.getGroupName()));
    vNode.setTargetVcHost(VcResourceUtils.findHost(vNode.getTargetHost()));
  }
  cloneSrv.addConsumers(vNodes);
  try {
    UpdateVmProgressCallback callback=new UpdateVmProgressCallback(clusterEntityMgr,statusUpdator,vNodes.get(0).getClusterName());
    cloneSrv.setProgressCallback(callback);
    logger.info(""String_Node_Str"");
    boolean success=cloneSrv.start();
    logger.info(cloneSrv.getCopied().size() + ""String_Node_Str"");
    return success;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}"
48977,"@Override public boolean reconfigVms(NetworkAdd networkAdd,List<BaseNode> vNodes,StatusUpdater statusUpdator,Set<String> occupiedIps){
  if (vNodes.isEmpty()) {
    logger.info(""String_Node_Str"");
    return true;
  }
  setNetworkSchema(vNodes);
  allocateStaticIp(networkAdd,vNodes,occupiedIps);
  Pair<Callable<Void>,Callable<Void>>[] storeProcedures=new Pair[vNodes.size()];
  for (int i=0; i < vNodes.size(); i++) {
    BaseNode vNode=vNodes.get(i);
    VmSchema createSchema=getVmSchema(vNode);
    Map<String,String> guestVariable=getNetworkGuestVariable(networkAdd,vNode.getIpAddress(),vNode.getGuestHostName());
    QueryIpAddress query=new QueryIpAddress(Constants.VM_POWER_ON_WAITING_SEC);
    CreateVmPrePowerOn prePowerOn=getPrePowerOnFunc(vNode);
    VcVirtualMachine vcVm=VcCache.getIgnoreMissing(vNode.getVmMobId());
    CreateVmSP cloneVmSp=null;
    if (vcVm != null) {
      cloneVmSp=new CreateVmSP(vcVm,createSchema,vNode.getTargetVcRp(),vNode.getTargetVcDs(),prePowerOn,query,guestVariable,false,vNode.getTargetVcFolder(),vNode.getTargetVcHost());
    }
 else {
      cloneVmSp=new CreateVmSP(vNode.getVmName(),createSchema,vNode.getTargetVcRp(),vNode.getTargetVcDs(),prePowerOn,query,guestVariable,false,vNode.getTargetVcFolder(),vNode.getTargetVcHost());
    }
    CompensateCreateVmSP deleteVmSp=new CompensateCreateVmSP(cloneVmSp);
    storeProcedures[i]=new Pair<Callable<Void>,Callable<Void>>(cloneVmSp,deleteVmSp);
  }
  try {
    UpdateVmProgressCallback callback=new UpdateVmProgressCallback(clusterEntityMgr,statusUpdator,vNodes.get(0).getClusterName());
    logger.info(""String_Node_Str"");
    Pair<ExecutionResult,ExecutionResult>[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProcedures,storeProcedures.length,callback);
    if (result == null) {
      logger.error(""String_Node_Str"");
      return false;
    }
    int total=0;
    boolean success=true;
    List<BaseNode> failedNodes=new ArrayList<BaseNode>();
    for (int i=0; i < storeProcedures.length; i++) {
      Pair<ExecutionResult,ExecutionResult> pair=result[i];
      BaseNode vNode=vNodes.get(i);
      CreateVmSP sp=(CreateVmSP)storeProcedures[i].first;
      if (pair.first.finished && pair.first.throwable == null && pair.second.finished == false) {
        ++total;
        VcVirtualMachine vm=sp.getVM();
        AuAssert.check(vm != null);
        boolean vmSucc=VcVmUtil.setBaseNodeForVm(vNode,vm);
        if (!vmSucc) {
          success=vmSucc;
        }
      }
 else       if (pair.first.throwable != null) {
        processException(pair.first.throwable);
        logger.error(""String_Node_Str"" + vNode.getVmName(),pair.first.throwable);
        vNode.setSuccess(false);
        if (sp.getVM() != null) {
          vNode.setVmMobId(sp.getVM().getId());
        }
        failedNodes.add(vNode);
        success=false;
      }
      vNode.setFinished(true);
    }
    logger.info(total + ""String_Node_Str"");
    return success;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}","@Override public boolean reconfigVms(NetworkAdd networkAdd,List<BaseNode> vNodes,StatusUpdater statusUpdator,Set<String> occupiedIps){
  if (vNodes.isEmpty()) {
    logger.info(""String_Node_Str"");
    return true;
  }
  setNetworkSchema(vNodes);
  allocateStaticIp(networkAdd,vNodes,occupiedIps);
  Pair<Callable<Void>,Callable<Void>>[] storeProcedures=new Pair[vNodes.size()];
  String uuid=ConfigInfo.getSerengetiUUID();
  String clusterRpName=uuid + ""String_Node_Str"" + vNodes.get(0).getClusterName();
  for (int i=0; i < vNodes.size(); i++) {
    BaseNode vNode=vNodes.get(i);
    VmSchema createSchema=getVmSchema(vNode);
    Map<String,String> guestVariable=getNetworkGuestVariable(networkAdd,vNode.getIpAddress(),vNode.getGuestHostName());
    QueryIpAddress query=new QueryIpAddress(Constants.VM_POWER_ON_WAITING_SEC);
    CreateVmPrePowerOn prePowerOn=getPrePowerOnFunc(vNode);
    VcVirtualMachine vcVm=VcCache.getIgnoreMissing(vNode.getVmMobId());
    CreateVmSP cloneVmSp=null;
    if (vcVm != null) {
      cloneVmSp=new CreateVmSP(vcVm,createSchema,getVcResourcePool(vNode,clusterRpName),getVcDatastore(vNode),prePowerOn,query,guestVariable,false,getVcFolder(vNode),VcResourceUtils.findHost(vNode.getTargetHost()));
    }
 else {
      cloneVmSp=new CreateVmSP(vNode.getVmName(),createSchema,getVcResourcePool(vNode,clusterRpName),getVcDatastore(vNode),prePowerOn,query,guestVariable,false,getVcFolder(vNode),VcResourceUtils.findHost(vNode.getTargetHost()));
    }
    CompensateCreateVmSP deleteVmSp=new CompensateCreateVmSP(cloneVmSp);
    storeProcedures[i]=new Pair<Callable<Void>,Callable<Void>>(cloneVmSp,deleteVmSp);
  }
  try {
    UpdateVmProgressCallback callback=new UpdateVmProgressCallback(clusterEntityMgr,statusUpdator,vNodes.get(0).getClusterName());
    logger.info(""String_Node_Str"");
    Pair<ExecutionResult,ExecutionResult>[] result=Scheduler.executeStoredProcedures(com.vmware.aurora.composition.concurrent.Priority.BACKGROUND,storeProcedures,storeProcedures.length,callback);
    if (result == null) {
      logger.error(""String_Node_Str"");
      return false;
    }
    int total=0;
    boolean success=true;
    List<BaseNode> failedNodes=new ArrayList<BaseNode>();
    for (int i=0; i < storeProcedures.length; i++) {
      Pair<ExecutionResult,ExecutionResult> pair=result[i];
      BaseNode vNode=vNodes.get(i);
      CreateVmSP sp=(CreateVmSP)storeProcedures[i].first;
      if (pair.first.finished && pair.first.throwable == null && pair.second.finished == false) {
        ++total;
        VcVirtualMachine vm=sp.getVM();
        AuAssert.check(vm != null);
        boolean vmSucc=VcVmUtil.setBaseNodeForVm(vNode,vm);
        if (!vmSucc) {
          success=vmSucc;
        }
      }
 else       if (pair.first.throwable != null) {
        processException(pair.first.throwable);
        logger.error(""String_Node_Str"" + vNode.getVmName(),pair.first.throwable);
        vNode.setSuccess(false);
        if (sp.getVM() != null) {
          vNode.setVmMobId(sp.getVM().getId());
        }
        failedNodes.add(vNode);
        success=false;
      }
      vNode.setFinished(true);
    }
    logger.info(total + ""String_Node_Str"");
    return success;
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"",e);
    throw BddException.INTERNAL(e,e.getMessage());
  }
}"
48978,"@Override public boolean eventHandler(VcEventType type,Event e) throws Exception {
  AuAssert.check(e instanceof VmEvent || e instanceof EventEx);
  ManagedObjectReference moRef=e.getVm().getVm();
  String moId=MoUtil.morefToString(moRef);
  logger.debug(""String_Node_Str"" + e);
switch (type) {
case VmRemoved:
{
      logger.debug(""String_Node_Str"" + moId);
      if (clusterEntityMgr.getNodeByMobId(moId) != null) {
        clusterEntityMgr.refreshNodeByMobId(moId,null,true);
      }
      return false;
    }
case VmPoweredOn:
{
    VmPoweredOnEvent event=(VmPoweredOnEvent)e;
    e.getVm();
    VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
    if (vm == null) {
      return false;
    }
    vm.updateRuntime();
    if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
      logger.info(""String_Node_Str"" + vm.getName());
      clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),Constants.NODE_ACTION_WAITING_IP,true);
    }
    break;
  }
case VmCloned:
{
  VmClonedEvent event=(VmClonedEvent)e;
  e.getVm();
  VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
  if (vm == null) {
    return false;
  }
  vm.updateRuntime();
  if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
    logger.info(""String_Node_Str"" + vm.getName());
    clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),Constants.NODE_ACTION_RECONFIGURE,true);
  }
  break;
}
case VmSuspended:
{
VmSuspendedEvent event=(VmSuspendedEvent)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
  return false;
}
vm.updateRuntime();
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
  logger.info(""String_Node_Str"" + vm.getName());
  clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),null,true);
}
break;
}
case VmPoweredOff:
{
VmPoweredOffEvent event=(VmPoweredOffEvent)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
return false;
}
vm.updateRuntime();
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + vm.getName());
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),null,true);
}
break;
}
}
return false;
}","@Override public boolean eventHandler(VcEventType type,Event e) throws Exception {
  AuAssert.check(e instanceof VmEvent || e instanceof EventEx);
  ManagedObjectReference moRef=e.getVm().getVm();
  String moId=MoUtil.morefToString(moRef);
  logger.debug(""String_Node_Str"" + e);
switch (type) {
case VmRemoved:
{
      logger.debug(""String_Node_Str"" + moId);
      if (clusterEntityMgr.getNodeByMobId(moId) != null) {
        clusterEntityMgr.refreshNodeByMobId(moId,null,true);
      }
      return false;
    }
case VmPoweredOn:
{
    VmPoweredOnEvent event=(VmPoweredOnEvent)e;
    e.getVm();
    VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
    if (vm == null) {
      return false;
    }
    vm.updateRuntime();
    if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
      logger.info(""String_Node_Str"" + vm.getName());
      clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),Constants.NODE_ACTION_WAITING_IP,true);
    }
    break;
  }
case VmCloned:
{
  VmClonedEvent event=(VmClonedEvent)e;
  e.getVm();
  VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
  if (vm == null) {
    return false;
  }
  vm.updateRuntime();
  if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
    logger.info(""String_Node_Str"" + vm.getName());
    clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),Constants.NODE_ACTION_WAITING,true);
  }
  break;
}
case VmSuspended:
{
VmSuspendedEvent event=(VmSuspendedEvent)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
  return false;
}
vm.updateRuntime();
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
  logger.info(""String_Node_Str"" + vm.getName());
  clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),null,true);
}
break;
}
case VmPoweredOff:
{
VmPoweredOffEvent event=(VmPoweredOffEvent)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
return false;
}
vm.updateRuntime();
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + vm.getName());
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),null,true);
}
break;
}
}
return false;
}"
48979,"public VcEventProcessor(final ClusterEntityManager clusterEntityMgr){
  VcEventListener.installExtEventHandler(vmEvents,new IVcEventHandler(){
    @Override public boolean eventHandler(    VcEventType type,    Event e) throws Exception {
      AuAssert.check(e instanceof VmEvent || e instanceof EventEx);
      ManagedObjectReference moRef=e.getVm().getVm();
      String moId=MoUtil.morefToString(moRef);
      logger.debug(""String_Node_Str"" + e);
switch (type) {
case VmRemoved:
{
          logger.debug(""String_Node_Str"" + moId);
          if (clusterEntityMgr.getNodeByMobId(moId) != null) {
            clusterEntityMgr.refreshNodeByMobId(moId,null,true);
          }
          return false;
        }
case VmPoweredOn:
{
        VmPoweredOnEvent event=(VmPoweredOnEvent)e;
        e.getVm();
        VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
        if (vm == null) {
          return false;
        }
        vm.updateRuntime();
        if (clusterEntityMgr.getNodeByMobId(moId) != null) {
          logger.info(""String_Node_Str"" + vm.getName());
          clusterEntityMgr.refreshNodeByMobId(moId,Constants.NODE_ACTION_WAITING_IP,true);
          NodePowerOnRequest request=new NodePowerOnRequest(clusterEntityMgr,moId);
          CmsWorker.addRequest(WorkQueue.VC_TASK_NO_DELAY,request);
        }
        break;
      }
case VmPoweredOff:
{
      VmPoweredOffEvent event=(VmPoweredOffEvent)e;
      VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
      if (vm == null) {
        return false;
      }
      vm.updateRuntime();
      if (clusterEntityMgr.getNodeByMobId(moId) != null) {
        logger.info(""String_Node_Str"" + vm.getName());
        clusterEntityMgr.refreshNodeByMobId(moId,null,true);
      }
      break;
    }
case VmSuspended:
{
    VmSuspendedEvent event=(VmSuspendedEvent)e;
    VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
    if (vm == null) {
      return false;
    }
    vm.updateRuntime();
    if (clusterEntityMgr.getNodeByMobId(moId) != null) {
      logger.info(""String_Node_Str"" + vm.getName());
      clusterEntityMgr.refreshNodeByMobId(moId,null,true);
    }
    break;
  }
}
VcCache.refreshAll(moRef);
return false;
}
}
);
VcEventListener.installEventHandler(vmEvents,new IVcEventHandler(){
@Override public boolean eventHandler(VcEventType type,Event e) throws Exception {
AuAssert.check(e instanceof VmEvent || e instanceof EventEx);
ManagedObjectReference moRef=e.getVm().getVm();
String moId=MoUtil.morefToString(moRef);
logger.debug(""String_Node_Str"" + e);
switch (type) {
case VmRemoved:
{
  logger.debug(""String_Node_Str"" + moId);
  if (clusterEntityMgr.getNodeByMobId(moId) != null) {
    clusterEntityMgr.refreshNodeByMobId(moId,null,true);
  }
  return false;
}
case VmPoweredOn:
{
VmPoweredOnEvent event=(VmPoweredOnEvent)e;
e.getVm();
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
  return false;
}
vm.updateRuntime();
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
  logger.info(""String_Node_Str"" + vm.getName());
  clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),Constants.NODE_ACTION_WAITING_IP,true);
}
break;
}
case VmCloned:
{
VmClonedEvent event=(VmClonedEvent)e;
e.getVm();
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
return false;
}
vm.updateRuntime();
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + vm.getName());
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),Constants.NODE_ACTION_RECONFIGURE,true);
}
break;
}
case VmSuspended:
{
VmSuspendedEvent event=(VmSuspendedEvent)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
return false;
}
vm.updateRuntime();
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + vm.getName());
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),null,true);
}
break;
}
case VmPoweredOff:
{
VmPoweredOffEvent event=(VmPoweredOffEvent)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
return false;
}
vm.updateRuntime();
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + vm.getName());
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),null,true);
}
break;
}
}
return false;
}
}
);
}","public VcEventProcessor(final ClusterEntityManager clusterEntityMgr){
  VcEventListener.installExtEventHandler(vmEvents,new IVcEventHandler(){
    @Override public boolean eventHandler(    VcEventType type,    Event e) throws Exception {
      AuAssert.check(e instanceof VmEvent || e instanceof EventEx);
      ManagedObjectReference moRef=e.getVm().getVm();
      String moId=MoUtil.morefToString(moRef);
      logger.debug(""String_Node_Str"" + e);
switch (type) {
case VmRemoved:
{
          logger.debug(""String_Node_Str"" + moId);
          if (clusterEntityMgr.getNodeByMobId(moId) != null) {
            clusterEntityMgr.refreshNodeByMobId(moId,null,true);
          }
          return false;
        }
case VmPoweredOn:
{
        VmPoweredOnEvent event=(VmPoweredOnEvent)e;
        e.getVm();
        VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
        if (vm == null) {
          return false;
        }
        vm.updateRuntime();
        if (clusterEntityMgr.getNodeByMobId(moId) != null) {
          logger.info(""String_Node_Str"" + vm.getName());
          clusterEntityMgr.refreshNodeByMobId(moId,Constants.NODE_ACTION_WAITING_IP,true);
          NodePowerOnRequest request=new NodePowerOnRequest(clusterEntityMgr,moId);
          CmsWorker.addRequest(WorkQueue.VC_TASK_NO_DELAY,request);
        }
        break;
      }
case VmPoweredOff:
{
      VmPoweredOffEvent event=(VmPoweredOffEvent)e;
      VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
      if (vm == null) {
        return false;
      }
      vm.updateRuntime();
      if (clusterEntityMgr.getNodeByMobId(moId) != null) {
        logger.info(""String_Node_Str"" + vm.getName());
        clusterEntityMgr.refreshNodeByMobId(moId,null,true);
      }
      break;
    }
case VmSuspended:
{
    VmSuspendedEvent event=(VmSuspendedEvent)e;
    VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
    if (vm == null) {
      return false;
    }
    vm.updateRuntime();
    if (clusterEntityMgr.getNodeByMobId(moId) != null) {
      logger.info(""String_Node_Str"" + vm.getName());
      clusterEntityMgr.refreshNodeByMobId(moId,null,true);
    }
    break;
  }
}
VcCache.refreshAll(moRef);
return false;
}
}
);
VcEventListener.installEventHandler(vmEvents,new IVcEventHandler(){
@Override public boolean eventHandler(VcEventType type,Event e) throws Exception {
AuAssert.check(e instanceof VmEvent || e instanceof EventEx);
ManagedObjectReference moRef=e.getVm().getVm();
String moId=MoUtil.morefToString(moRef);
logger.debug(""String_Node_Str"" + e);
switch (type) {
case VmRemoved:
{
  logger.debug(""String_Node_Str"" + moId);
  if (clusterEntityMgr.getNodeByMobId(moId) != null) {
    clusterEntityMgr.refreshNodeByMobId(moId,null,true);
  }
  return false;
}
case VmPoweredOn:
{
VmPoweredOnEvent event=(VmPoweredOnEvent)e;
e.getVm();
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
  return false;
}
vm.updateRuntime();
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
  logger.info(""String_Node_Str"" + vm.getName());
  clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),Constants.NODE_ACTION_WAITING_IP,true);
}
break;
}
case VmCloned:
{
VmClonedEvent event=(VmClonedEvent)e;
e.getVm();
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
return false;
}
vm.updateRuntime();
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + vm.getName());
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),Constants.NODE_ACTION_WAITING,true);
}
break;
}
case VmSuspended:
{
VmSuspendedEvent event=(VmSuspendedEvent)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
return false;
}
vm.updateRuntime();
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + vm.getName());
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),null,true);
}
break;
}
case VmPoweredOff:
{
VmPoweredOffEvent event=(VmPoweredOffEvent)e;
VcVirtualMachine vm=VcCache.getIgnoreMissing(event.getVm().getVm());
if (vm == null) {
return false;
}
vm.updateRuntime();
if (clusterEntityMgr.getNodeByVmName(vm.getName()) != null) {
logger.info(""String_Node_Str"" + vm.getName());
clusterEntityMgr.refreshNodeByVmName(moId,vm.getName(),null,true);
}
break;
}
}
return false;
}
}
);
}"
48980,"/** 
 * set cluster parameters synchronously
 * @param clusterName
 * @param activeComputeNodeNum
 * @param minComputeNodeNum
 * @param mode
 * @param ioPriority
 * @throws Exception
 */
@SuppressWarnings(""String_Node_Str"") public List<String> syncSetParam(String clusterName,Integer activeComputeNodeNum,Integer minComputeNodeNum,Boolean enableAuto,Priority ioPriority) throws Exception {
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  ClusterRead clusterRead=getClusterByName(clusterName,false);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (ioPriority != null) {
    prioritizeCluster(clusterName,ioPriority);
  }
  cluster=clusterEntityMgr.findByName(clusterName);
  if (enableAuto != null && enableAuto != cluster.getAutomationEnable()) {
    cluster.setAutomationEnable(enableAuto);
  }
  if (minComputeNodeNum != null && minComputeNodeNum != cluster.getVhmMinNum()) {
    cluster.setVhmMinNum(minComputeNodeNum);
  }
  List<String> nodeGroupNames=new ArrayList<String>();
  if ((enableAuto != null || minComputeNodeNum != null || activeComputeNodeNum != null) && !clusterRead.validateSetManualElasticity(nodeGroupNames)) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
  }
  if (activeComputeNodeNum != null) {
    if (activeComputeNodeNum != cluster.getVhmTargetNum()) {
      cluster.setVhmTargetNum(activeComputeNodeNum);
    }
  }
  if ((enableAuto != null) && !ClusterStatus.RUNNING.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus()) && !ClusterStatus.STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  clusterEntityMgr.update(cluster);
  if (enableAuto != null || minComputeNodeNum != null) {
    boolean success=clusteringService.setAutoElasticity(clusterName);
    if (!success) {
      throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
    }
  }
  if (enableAuto != null && !enableAuto && cluster.getVhmTargetNum() == null) {
    JobUtils.waitForManual(clusterName,executionService);
  }
  return nodeGroupNames;
}","/** 
 * set cluster parameters synchronously
 * @param clusterName
 * @param activeComputeNodeNum
 * @param minComputeNodeNum
 * @param mode
 * @param ioPriority
 * @throws Exception
 */
@SuppressWarnings(""String_Node_Str"") public List<String> syncSetParam(String clusterName,Integer activeComputeNodeNum,Integer minComputeNodeNum,Boolean enableAuto,Priority ioPriority) throws Exception {
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  ClusterRead clusterRead=getClusterByName(clusterName,false);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (ioPriority != null) {
    prioritizeCluster(clusterName,ioPriority);
  }
  cluster=clusterEntityMgr.findByName(clusterName);
  if (enableAuto != null && enableAuto != cluster.getAutomationEnable()) {
    cluster.setAutomationEnable(enableAuto);
  }
  if (minComputeNodeNum != null && minComputeNodeNum != cluster.getVhmMinNum()) {
    cluster.setVhmMinNum(minComputeNodeNum);
  }
  List<String> nodeGroupNames=new ArrayList<String>();
  if ((enableAuto != null || minComputeNodeNum != null || activeComputeNodeNum != null) && !clusterRead.validateSetManualElasticity(nodeGroupNames)) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
  }
  if (activeComputeNodeNum != null) {
    if (!activeComputeNodeNum.equals(cluster.getVhmTargetNum())) {
      cluster.setVhmTargetNum(activeComputeNodeNum);
    }
  }
  if ((enableAuto != null) && !ClusterStatus.RUNNING.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus()) && !ClusterStatus.STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  clusterEntityMgr.update(cluster);
  if (enableAuto != null || minComputeNodeNum != null) {
    boolean success=clusteringService.setAutoElasticity(clusterName);
    if (!success) {
      throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
    }
  }
  if (enableAuto != null && !enableAuto && cluster.getVhmTargetNum() == null) {
    JobUtils.waitForManual(clusterName,executionService);
  }
  return nodeGroupNames;
}"
48981,"private void setClusterStatus(JobExecution je){
  String successStatus=getJobParameters(je).getString(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM);
  String failureStatus=getJobParameters(je).getString(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM);
  String clusterName=getJobParameters(je).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  if (clusterName == null) {
    clusterName=getJobParameters(je).getString(JobConstants.TARGET_NAME_JOB_PARAM).split(""String_Node_Str"")[0];
  }
  Boolean success=TrackableTasklet.getFromJobExecutionContext(je.getExecutionContext(),JobConstants.CLUSTER_OPERATION_SUCCESS,Boolean.class);
  if (success == null || success) {
    success=(je.getExitStatus().equals(ExitStatus.COMPLETED));
  }
  ClusterStatus status=null;
  if (success & successStatus != null) {
    status=ClusterStatus.valueOf(successStatus);
  }
 else   if (!success && failureStatus != null) {
    status=ClusterStatus.valueOf(failureStatus);
  }
  logger.info(""String_Node_Str"" + clusterName + ""String_Node_Str""+ status);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster != null && status != null) {
    clusterEntityMgr.updateClusterStatus(clusterName,status);
  }
}","private void setClusterStatus(JobExecution je){
  String successStatus=getJobParameters(je).getString(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM);
  String failureStatus=getJobParameters(je).getString(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM);
  String clusterName=getJobParameters(je).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  if (clusterName == null) {
    clusterName=getJobParameters(je).getString(JobConstants.TARGET_NAME_JOB_PARAM).split(""String_Node_Str"")[0];
  }
  Boolean success=TrackableTasklet.getFromJobExecutionContext(je.getExecutionContext(),JobConstants.CLUSTER_OPERATION_SUCCESS,Boolean.class);
  if (success == null || success) {
    success=(je.getExitStatus().equals(ExitStatus.COMPLETED));
  }
  ClusterStatus status=null;
  if (success && successStatus != null) {
    status=ClusterStatus.valueOf(successStatus);
  }
 else   if (!success && failureStatus != null) {
    status=ClusterStatus.valueOf(failureStatus);
  }
  logger.info(""String_Node_Str"" + clusterName + ""String_Node_Str""+ status);
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster != null && status != null) {
    clusterEntityMgr.updateClusterStatus(clusterName,status);
  }
}"
48982,"@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String topology,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean alwaysAnswerYes){
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
 else   if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_BLANK_SPACE);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (type != null) {
    ClusterType clusterType=ClusterType.getByDescription(type);
    if (clusterType == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ type);
      return;
    }
    clusterCreate.setType(clusterType);
  }
 else   if (specFilePath == null) {
    clusterCreate.setType(ClusterType.HDFS_MAPRED);
  }
  if (topology != null) {
    try {
      clusterCreate.setTopologyPolicy(TopologyType.valueOf(topology));
    }
 catch (    IllegalArgumentException ex) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ topology);
      return;
    }
  }
 else {
    clusterCreate.setTopologyPolicy(TopologyType.NONE);
  }
  try {
    if (distro != null) {
      List<String> distroNames=getDistroNames();
      if (validName(distro,distroNames)) {
        clusterCreate.setDistro(distro);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
        return;
      }
    }
 else {
      String defaultDistroName=clusterCreate.getDefaultDistroName(distroRestClient.getAll());
      if (CommandsUtils.isBlank(defaultDistroName)) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM__NO_DEFAULT_DISTRO);
        return;
      }
 else {
        clusterCreate.setDistro(defaultDistroName);
      }
    }
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  DistroRead distroRead=distroRestClient.get(clusterCreate.getDistro());
  clusterCreate.setDistroVendor(distroRead.getVendor());
  clusterCreate.setDistroVersion(distroRead.getVersion());
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  List<String> networkNames=null;
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setSpecFile(true);
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
    }
    networkNames=getNetworkNames();
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  if (networkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_EXISTED);
    return;
  }
 else {
    if (networkName != null) {
      if (validName(networkName,networkNames)) {
        clusterCreate.setNetworkName(networkName);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + networkNames);
        return;
      }
    }
 else {
      if (networkNames.size() == 1) {
        clusterCreate.setNetworkName(networkNames.get(0));
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
        return;
      }
    }
  }
  if (specFilePath != null && !clusterCreate.getDistro().equalsIgnoreCase(com.vmware.bdd.utils.Constants.MAPR_VENDOR)) {
    List<String> distroRoles=findDistroRoles(clusterCreate);
    clusterCreate.validateClusterCreate(failedMsgList,warningMsgList,distroRoles);
  }
  if (type != null && specFilePath != null) {
    warningMsgList.add(Constants.TYPE_SPECFILE_CONFLICT);
  }
  if (!failedMsgList.isEmpty()) {
    showFailedMsg(clusterCreate.getName(),failedMsgList);
    return;
  }
  try {
    if (!CommandsUtils.showWarningMsg(clusterCreate.getName(),Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,warningMsgList,alwaysAnswerYes)) {
      return;
    }
    restClient.create(clusterCreate);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}","@CliCommand(value=""String_Node_Str"",help=""String_Node_Str"") public void createCluster(@CliOption(key={""String_Node_Str""},mandatory=true,help=""String_Node_Str"") final String name,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String type,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String distro,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String specFilePath,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String rpNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String dsNames,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String networkName,@CliOption(key={""String_Node_Str""},mandatory=false,help=""String_Node_Str"") final String topology,@CliOption(key={""String_Node_Str""},mandatory=false,specifiedDefaultValue=""String_Node_Str"",unspecifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean resume,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean skipConfigValidation,@CliOption(key={""String_Node_Str""},mandatory=false,unspecifiedDefaultValue=""String_Node_Str"",specifiedDefaultValue=""String_Node_Str"",help=""String_Node_Str"") final boolean alwaysAnswerYes){
  if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_HORIZONTAL_LINE);
    return;
  }
 else   if (name.indexOf(""String_Node_Str"") != -1) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER + Constants.PARAM_NOT_CONTAIN_BLANK_SPACE);
    return;
  }
  if (resume) {
    resumeCreateCluster(name);
    return;
  }
  ClusterCreate clusterCreate=new ClusterCreate();
  clusterCreate.setName(name);
  if (type != null) {
    ClusterType clusterType=ClusterType.getByDescription(type);
    if (clusterType == null) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ type);
      return;
    }
    clusterCreate.setType(clusterType);
  }
 else   if (specFilePath == null) {
    clusterCreate.setType(ClusterType.HDFS_MAPRED);
  }
  if (topology != null) {
    try {
      clusterCreate.setTopologyPolicy(TopologyType.valueOf(topology));
    }
 catch (    IllegalArgumentException ex) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INVALID_VALUE + ""String_Node_Str"" + ""String_Node_Str""+ topology);
      return;
    }
  }
 else {
    clusterCreate.setTopologyPolicy(TopologyType.NONE);
  }
  try {
    if (distro != null) {
      List<String> distroNames=getDistroNames();
      if (validName(distro,distroNames)) {
        clusterCreate.setDistro(distro);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_DISTRO + Constants.PARAM_NOT_SUPPORTED + distroNames);
        return;
      }
    }
 else {
      String defaultDistroName=clusterCreate.getDefaultDistroName(distroRestClient.getAll());
      if (CommandsUtils.isBlank(defaultDistroName)) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM__NO_DEFAULT_DISTRO);
        return;
      }
 else {
        clusterCreate.setDistro(defaultDistroName);
      }
    }
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  DistroRead distroRead=distroRestClient.get(clusterCreate.getDistro());
  clusterCreate.setDistroVendor(distroRead.getVendor());
  clusterCreate.setDistroVersion(distroRead.getVersion());
  if (rpNames != null) {
    List<String> rpNamesList=CommandsUtils.inputsConvert(rpNames);
    if (rpNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_RPNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setRpNames(rpNamesList);
    }
  }
  if (dsNames != null) {
    List<String> dsNamesList=CommandsUtils.inputsConvert(dsNames);
    if (dsNamesList.isEmpty()) {
      CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.INPUT_DSNAMES_PARAM + Constants.MULTI_INPUTS_CHECK);
      return;
    }
 else {
      clusterCreate.setDsNames(dsNamesList);
    }
  }
  List<String> failedMsgList=new ArrayList<String>();
  List<String> warningMsgList=new ArrayList<String>();
  List<String> networkNames=null;
  try {
    if (specFilePath != null) {
      ClusterCreate clusterSpec=CommandsUtils.getObjectByJsonString(ClusterCreate.class,CommandsUtils.dataFromFile(specFilePath));
      clusterCreate.setSpecFile(true);
      clusterCreate.setExternalHDFS(clusterSpec.getExternalHDFS());
      clusterCreate.setNodeGroups(clusterSpec.getNodeGroups());
      clusterCreate.setConfiguration(clusterSpec.getConfiguration());
      validateConfiguration(clusterCreate,skipConfigValidation,warningMsgList);
      if (!validateHAInfo(clusterCreate.getNodeGroups())) {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_CLUSTER_SPEC_HA_ERROR + specFilePath);
        return;
      }
    }
    networkNames=getNetworkNames();
  }
 catch (  Exception e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
    return;
  }
  if (networkNames.isEmpty()) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_EXISTED);
    return;
  }
 else {
    if (networkName != null) {
      if (validName(networkName,networkNames)) {
        clusterCreate.setNetworkName(networkName);
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SUPPORTED + networkNames);
        return;
      }
    }
 else {
      if (networkNames.size() == 1) {
        clusterCreate.setNetworkName(networkNames.get(0));
      }
 else {
        CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,Constants.PARAM_NETWORK_NAME + Constants.PARAM_NOT_SPECIFIED);
        return;
      }
    }
  }
  clusterCreate.validateCDHVersion(warningMsgList);
  if (specFilePath != null && !clusterCreate.getDistro().equalsIgnoreCase(com.vmware.bdd.utils.Constants.MAPR_VENDOR)) {
    List<String> distroRoles=findDistroRoles(clusterCreate);
    clusterCreate.validateClusterCreate(failedMsgList,warningMsgList,distroRoles);
  }
  if (type != null && specFilePath != null) {
    warningMsgList.add(Constants.TYPE_SPECFILE_CONFLICT);
  }
  if (!failedMsgList.isEmpty()) {
    showFailedMsg(clusterCreate.getName(),failedMsgList);
    return;
  }
  try {
    if (!CommandsUtils.showWarningMsg(clusterCreate.getName(),Constants.OUTPUT_OBJECT_CLUSTER,Constants.OUTPUT_OP_CREATE,warningMsgList,alwaysAnswerYes)) {
      return;
    }
    restClient.create(clusterCreate);
    CommandsUtils.printCmdSuccess(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_RESULT_CREAT);
  }
 catch (  CliRestException e) {
    CommandsUtils.printCmdFailure(Constants.OUTPUT_OBJECT_CLUSTER,name,Constants.OUTPUT_OP_CREATE,Constants.OUTPUT_OP_RESULT_FAIL,e.getMessage());
  }
}"
48983,"/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
public void validateClusterCreate(List<String> failedMsgList,List<String> warningMsgList,final List<String> distroRoles){
  boolean namenodeHACheck=false;
  int masterCount=0, jobtrackerCount=0, resourcemanagerCount=0, hbasemasterCount=0, zookeeperCount=0, workerCount=0, numOfJournalNode=0;
  boolean appendWarningStr=false;
  if (warningMsgList != null && warningMsgList.isEmpty()) {
    appendWarningStr=true;
  }
  NodeGroupCreate[] nodeGroupCreates=getNodeGroups();
  if (nodeGroupCreates == null || nodeGroupCreates.length == 0) {
    failedMsgList.add(Constants.MULTI_INPUTS_CHECK);
    return;
  }
 else {
    if (hasHDFSUrlConfigured() && !validateHDFSUrl()) {
      failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getExternalHDFS()).toString());
    }
    validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList);
    validateNodeGroupRoles(failedMsgList);
    validateStorageType(failedMsgList);
    validateSwapRatio(nodeGroupCreates,failedMsgList);
    for (    NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
      checkInstanceNum(nodeGroupCreate,failedMsgList);
      checkNodeGroupRoles(nodeGroupCreate,distroRoles,failedMsgList);
      List<NodeGroupRole> groupRoles=getNodeGroupRoles(nodeGroupCreate);
      if (groupRoles != null) {
        for (        NodeGroupRole role : groupRoles) {
switch (role) {
case MASTER:
            masterCount++;
          int numOfInstance=nodeGroupCreate.getInstanceNum();
        if (numOfInstance >= 0 && numOfInstance != 1) {
          if (numOfInstance != 2) {
            collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
          }
 else {
            namenodeHACheck=true;
          }
        }
      break;
case JOB_TRACKER:
    jobtrackerCount++;
  if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
    failedMsgList.add(Constants.WRONG_NUM_OF_JOBTRACKER);
  }
break;
case RESOURCEMANAGER:
resourcemanagerCount++;
if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
failedMsgList.add(Constants.WRONG_NUM_OF_RESOURCEMANAGER);
}
break;
case HBASE_MASTER:
hbasemasterCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
break;
case ZOOKEEPER:
zookeeperCount++;
if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_ZOOKEEPER);
}
 else if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_ZOOKEEPER);
}
break;
case JOURNAL_NODE:
numOfJournalNode+=nodeGroupCreate.getInstanceNum();
if (nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_DATANODE.toString()) || nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_CLIENT_ROLE.toString())) {
failedMsgList.add(Constants.DATA_CLIENT_NODE_JOURNALNODE_COEXIST);
}
break;
case WORKER:
workerCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
 else if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
List<String> roles=nodeGroupCreate.getRoles();
if (roles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString()) && !roles.contains(HadoopRole.HADOOP_DATANODE.toString())) {
warningMsgList.add(Constants.REGISONSERVER_DATANODE_SEPERATION);
}
break;
case CLIENT:
if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
break;
case NONE:
warningMsgList.add(Constants.NOT_DEFINED_ROLE);
break;
default :
}
}
}
}
if (!supportedWithHdfs2()) {
if (namenodeHACheck || masterCount > 1) {
failedMsgList.add(Constants.CURRENT_DISTRO_CAN_NOT_SUPPORT_HDFS2);
}
}
 else if (namenodeHACheck) {
if (numOfJournalNode >= 0 && numOfJournalNode < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_JOURNALNODE);
}
 else if (numOfJournalNode > 0 && numOfJournalNode % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_JOURNALNODE);
}
if (zookeeperCount == 0) {
failedMsgList.add(Constants.NAMENODE_AUTO_FAILOVER_ZOOKEEPER);
}
}
if ((jobtrackerCount > 1) || (resourcemanagerCount > 1) || (zookeeperCount > 1)|| (hbasemasterCount > 1)) {
failedMsgList.add(Constants.WRONG_NUM_OF_NODEGROUPS);
}
if (workerCount == 0) {
warningMsgList.add(Constants.WRONG_NUM_OF_WORKERNODES);
}
if (numOfJournalNode > 0 && !namenodeHACheck) {
failedMsgList.add(Constants.NO_NAMENODE_HA);
}
if (!warningMsgList.isEmpty() && appendWarningStr) {
warningMsgList.set(0,""String_Node_Str"" + warningMsgList.get(0));
}
}
}","/** 
 * Validate nodeGroupCreates member formats and values in the ClusterCreate.
 */
public void validateClusterCreate(List<String> failedMsgList,List<String> warningMsgList,final List<String> distroRoles){
  boolean namenodeHACheck=false;
  int masterCount=0, jobtrackerCount=0, resourcemanagerCount=0, hbasemasterCount=0, zookeeperCount=0, workerCount=0, numOfJournalNode=0;
  boolean appendWarningStr=false;
  if (warningMsgList != null && warningMsgList.isEmpty()) {
    appendWarningStr=true;
  }
  NodeGroupCreate[] nodeGroupCreates=getNodeGroups();
  if (nodeGroupCreates == null || nodeGroupCreates.length == 0) {
    failedMsgList.add(Constants.MULTI_INPUTS_CHECK);
    return;
  }
 else {
    if (hasHDFSUrlConfigured() && !validateHDFSUrl()) {
      failedMsgList.add(new StringBuilder().append(""String_Node_Str"").append(getExternalHDFS()).toString());
    }
    validateNodeGroupPlacementPolicies(failedMsgList,warningMsgList);
    validateNodeGroupRoles(failedMsgList);
    validateStorageType(failedMsgList);
    validateSwapRatio(nodeGroupCreates,failedMsgList);
    for (    NodeGroupCreate nodeGroupCreate : nodeGroupCreates) {
      checkInstanceNum(nodeGroupCreate,failedMsgList);
      makeVmMemoryDevisibleBy4(nodeGroupCreate,warningMsgList);
      checkNodeGroupRoles(nodeGroupCreate,distroRoles,failedMsgList);
      List<NodeGroupRole> groupRoles=getNodeGroupRoles(nodeGroupCreate);
      if (groupRoles != null) {
        for (        NodeGroupRole role : groupRoles) {
switch (role) {
case MASTER:
            masterCount++;
          int numOfInstance=nodeGroupCreate.getInstanceNum();
        if (numOfInstance >= 0 && numOfInstance != 1) {
          if (numOfInstance != 2) {
            collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
          }
 else {
            namenodeHACheck=true;
          }
        }
      break;
case JOB_TRACKER:
    jobtrackerCount++;
  if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
    failedMsgList.add(Constants.WRONG_NUM_OF_JOBTRACKER);
  }
break;
case RESOURCEMANAGER:
resourcemanagerCount++;
if (nodeGroupCreate.getInstanceNum() >= 0 && nodeGroupCreate.getInstanceNum() != 1) {
failedMsgList.add(Constants.WRONG_NUM_OF_RESOURCEMANAGER);
}
break;
case HBASE_MASTER:
hbasemasterCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
break;
case ZOOKEEPER:
zookeeperCount++;
if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_ZOOKEEPER);
}
 else if (nodeGroupCreate.getInstanceNum() > 0 && nodeGroupCreate.getInstanceNum() % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_ZOOKEEPER);
}
break;
case JOURNAL_NODE:
numOfJournalNode+=nodeGroupCreate.getInstanceNum();
if (nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_DATANODE.toString()) || nodeGroupCreate.getRoles().contains(HadoopRole.HADOOP_CLIENT_ROLE.toString())) {
failedMsgList.add(Constants.DATA_CLIENT_NODE_JOURNALNODE_COEXIST);
}
break;
case WORKER:
workerCount++;
if (nodeGroupCreate.getInstanceNum() == 0) {
collectInstanceNumInvalidateMsg(nodeGroupCreate,failedMsgList);
}
 else if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
List<String> roles=nodeGroupCreate.getRoles();
if (roles.contains(HadoopRole.HBASE_REGIONSERVER_ROLE.toString()) && !roles.contains(HadoopRole.HADOOP_DATANODE.toString())) {
warningMsgList.add(Constants.REGISONSERVER_DATANODE_SEPERATION);
}
break;
case CLIENT:
if (isHAFlag(nodeGroupCreate)) {
warningMsgList.add(Constants.WORKER_CLIENT_HA_FLAG);
}
break;
case NONE:
warningMsgList.add(Constants.NOT_DEFINED_ROLE);
break;
default :
}
}
}
}
if (!supportedWithHdfs2()) {
if (namenodeHACheck || masterCount > 1) {
failedMsgList.add(Constants.CURRENT_DISTRO_CAN_NOT_SUPPORT_HDFS2);
}
}
 else if (namenodeHACheck) {
if (numOfJournalNode >= 0 && numOfJournalNode < 3) {
failedMsgList.add(Constants.WRONG_NUM_OF_JOURNALNODE);
}
 else if (numOfJournalNode > 0 && numOfJournalNode % 2 == 0) {
warningMsgList.add(Constants.ODD_NUM_OF_JOURNALNODE);
}
if (zookeeperCount == 0) {
failedMsgList.add(Constants.NAMENODE_AUTO_FAILOVER_ZOOKEEPER);
}
}
if ((jobtrackerCount > 1) || (resourcemanagerCount > 1) || (zookeeperCount > 1)|| (hbasemasterCount > 1)) {
failedMsgList.add(Constants.WRONG_NUM_OF_NODEGROUPS);
}
if (workerCount == 0) {
warningMsgList.add(Constants.WRONG_NUM_OF_WORKERNODES);
}
if (numOfJournalNode > 0 && !namenodeHACheck) {
failedMsgList.add(Constants.NO_NAMENODE_HA);
}
if (!warningMsgList.isEmpty() && appendWarningStr) {
warningMsgList.set(0,""String_Node_Str"" + warningMsgList.get(0));
}
}
}"
48984,"public static long makeVmMemoryDevisibleBy4(long memory){
  if ((memory % 4) == 0) {
    return memory;
  }
 else {
    long temp=memory / 4;
    return (temp + 1) * 4;
  }
}","public static long makeVmMemoryDevisibleBy4(long memory){
  return CommonUtil.makeVmMemoryDevisibleBy4(memory);
}"
48985,"/** 
 * set cluster parameters synchronously
 * @param clusterName
 * @param activeComputeNodeNum
 * @param minComputeNodeNum
 * @param mode
 * @param ioPriority
 * @throws Exception
 */
@SuppressWarnings(""String_Node_Str"") public List<String> syncSetParam(String clusterName,Integer activeComputeNodeNum,Integer minComputeNodeNum,Boolean enableAuto,Priority ioPriority) throws Exception {
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  ClusterRead clusterRead=getClusterByName(clusterName,false);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (ioPriority != null) {
    prioritizeCluster(clusterName,ioPriority);
  }
  cluster=clusterEntityMgr.findByName(clusterName);
  if (enableAuto != null && enableAuto != cluster.getAutomationEnable()) {
    cluster.setAutomationEnable(enableAuto);
  }
  if (minComputeNodeNum != null && minComputeNodeNum != cluster.getVhmMinNum()) {
    cluster.setVhmMinNum(minComputeNodeNum);
  }
  List<String> nodeGroupNames=new ArrayList<String>();
  if ((enableAuto != null || minComputeNodeNum != null || activeComputeNodeNum != null) && !clusterRead.validateSetManualElasticity(nodeGroupNames)) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
  }
  if (activeComputeNodeNum != null) {
    if (activeComputeNodeNum != cluster.getVhmTargetNum()) {
      cluster.setVhmTargetNum(activeComputeNodeNum);
    }
  }
  clusterEntityMgr.update(cluster);
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  if (enableAuto != null) {
    boolean success=clusteringService.setAutoElasticity(clusterName);
    if (!success) {
      throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
    }
  }
  return nodeGroupNames;
}","/** 
 * set cluster parameters synchronously
 * @param clusterName
 * @param activeComputeNodeNum
 * @param minComputeNodeNum
 * @param mode
 * @param ioPriority
 * @throws Exception
 */
@SuppressWarnings(""String_Node_Str"") public List<String> syncSetParam(String clusterName,Integer activeComputeNodeNum,Integer minComputeNodeNum,Boolean enableAuto,Priority ioPriority) throws Exception {
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  ClusterRead clusterRead=getClusterByName(clusterName,false);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (ioPriority != null) {
    prioritizeCluster(clusterName,ioPriority);
  }
  cluster=clusterEntityMgr.findByName(clusterName);
  if (enableAuto != null && enableAuto != cluster.getAutomationEnable()) {
    cluster.setAutomationEnable(enableAuto);
  }
  if (minComputeNodeNum != null && minComputeNodeNum != cluster.getVhmMinNum()) {
    cluster.setVhmMinNum(minComputeNodeNum);
  }
  List<String> nodeGroupNames=new ArrayList<String>();
  if ((enableAuto != null || minComputeNodeNum != null || activeComputeNodeNum != null) && !clusterRead.validateSetManualElasticity(nodeGroupNames)) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
  }
  if (activeComputeNodeNum != null) {
    if (activeComputeNodeNum != cluster.getVhmTargetNum()) {
      cluster.setVhmTargetNum(activeComputeNodeNum);
    }
  }
  if ((enableAuto != null) && !ClusterStatus.RUNNING.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus()) && !ClusterStatus.STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  clusterEntityMgr.update(cluster);
  if (enableAuto != null) {
    boolean success=clusteringService.setAutoElasticity(clusterName);
    if (!success) {
      throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
    }
  }
  if (enableAuto != null && !enableAuto && cluster.getVhmTargetNum() == null) {
    JobUtils.waitForManual(clusterName,executionService);
  }
  return nodeGroupNames;
}"
48986,"@Override public void beforeJob(JobExecution je){
  clusterName=getJobParameters(je).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  if (clusterName == null) {
    clusterName=getJobParameters(je).getString(JobConstants.TARGET_NAME_JOB_PARAM).split(""String_Node_Str"")[0];
  }
  if (!subJob) {
    clusterEntityMgr.updateClusterTaskId(clusterName,je.getId());
  }
  if (recoverAutoFlagAfterJob != null) {
    setAutoFlag(false);
    if (preAutoFlag != null) {
      waitForManual();
    }
  }
  super.beforeJob(je);
}","@Override public void beforeJob(JobExecution je){
  clusterName=getJobParameters(je).getString(JobConstants.CLUSTER_NAME_JOB_PARAM);
  if (clusterName == null) {
    clusterName=getJobParameters(je).getString(JobConstants.TARGET_NAME_JOB_PARAM).split(""String_Node_Str"")[0];
  }
  if (!subJob) {
    clusterEntityMgr.updateClusterTaskId(clusterName,je.getId());
  }
  if (recoverAutoFlagAfterJob != null) {
    setAutoFlag(false);
    if (preAutoFlag != null && preAutoFlag) {
      JobUtils.waitForManual(clusterName,executionService);
    }
  }
  super.beforeJob(je);
}"
48987,"private TaskRead processResponse(ResponseEntity<String> response,HttpMethod verb,PrettyOutput... prettyOutput) throws Exception {
  HttpStatus responseStatus=response.getStatusCode();
  if (responseStatus == HttpStatus.ACCEPTED) {
    HttpHeaders headers=response.getHeaders();
    URI taskURI=headers.getLocation();
    String[] taskURIs=taskURI.toString().split(""String_Node_Str"");
    String taskId=taskURIs[taskURIs.length - 1];
    TaskRead taskRead;
    int oldProgress=0;
    Status oldTaskStatus=null;
    Status taskStatus=null;
    int progress=0;
    do {
      ResponseEntity<TaskRead> taskResponse=restGetById(Constants.REST_PATH_TASK,taskId,TaskRead.class,false);
      taskRead=taskResponse.getBody();
      progress=(int)(taskRead.getProgress() * 100);
      taskStatus=taskRead.getStatus();
      if ((prettyOutput != null && prettyOutput.length > 0 && (taskRead.getType() == Type.VHM ? prettyOutput[0].isRefresh(true) : prettyOutput[0].isRefresh(false))) || oldTaskStatus != taskStatus || oldProgress != progress) {
        clearScreen();
        if (prettyOutput != null && prettyOutput.length > 0 && prettyOutput[0].getCompletedTaskSummary() != null) {
          for (          String summary : prettyOutput[0].getCompletedTaskSummary()) {
            System.out.println(summary + ""String_Node_Str"");
          }
        }
        System.out.println(taskStatus + ""String_Node_Str"" + progress+ ""String_Node_Str"");
        if (prettyOutput != null && prettyOutput.length > 0) {
          prettyOutput[0].prettyOutput();
        }
        if (oldTaskStatus != taskStatus || oldProgress != progress) {
          oldTaskStatus=taskStatus;
          oldProgress=progress;
          if (taskRead.getProgressMessage() != null) {
            System.out.println(taskRead.getProgressMessage());
          }
        }
      }
      try {
        Thread.sleep(3 * 1000);
      }
 catch (      InterruptedException ex) {
      }
    }
 while (taskRead.getStatus() != TaskRead.Status.COMPLETED && taskRead.getStatus() != TaskRead.Status.FAILED && taskRead.getStatus() != TaskRead.Status.ABANDONED && taskRead.getStatus() != TaskRead.Status.STOPPED);
    String logdir=taskRead.getWorkDir();
    String errorMsg=taskRead.getErrorMessage();
    if (!taskRead.getStatus().equals(TaskRead.Status.COMPLETED)) {
      if (!CommandsUtils.isBlank(logdir)) {
        String outputErrorInfo=Constants.OUTPUT_LOG_INFO + Constants.COMMON_LOG_FILE_PATH + ""String_Node_Str""+ logdir;
        if (errorMsg != null) {
          outputErrorInfo=errorMsg + ""String_Node_Str"" + outputErrorInfo;
        }
        throw new CliRestException(outputErrorInfo);
      }
 else       if (errorMsg != null && !errorMsg.isEmpty()) {
        String outputErrorInfo=errorMsg + ""String_Node_Str"" + Constants.OUTPUT_LOG_INFO+ Constants.COMMON_LOG_FILE_PATH;
        throw new CliRestException(outputErrorInfo);
      }
 else {
        throw new CliRestException(""String_Node_Str"");
      }
    }
 else {
      if (taskRead.getType().equals(Type.VHM)) {
        logger.info(""String_Node_Str"");
        Thread.sleep(5 * 1000);
        if (prettyOutput != null && prettyOutput.length > 0 && prettyOutput[0].isRefresh(true)) {
          clearScreen();
          System.out.println(taskStatus + ""String_Node_Str"" + progress+ ""String_Node_Str"");
          if (prettyOutput != null && prettyOutput.length > 0) {
            prettyOutput[0].prettyOutput();
          }
        }
      }
 else {
        return taskRead;
      }
    }
  }
  return null;
}","private TaskRead processResponse(ResponseEntity<String> response,HttpMethod verb,PrettyOutput... prettyOutput) throws Exception {
  HttpStatus responseStatus=response.getStatusCode();
  if (responseStatus == HttpStatus.ACCEPTED) {
    HttpHeaders headers=response.getHeaders();
    URI taskURI=headers.getLocation();
    String[] taskURIs=taskURI.toString().split(""String_Node_Str"");
    String taskId=taskURIs[taskURIs.length - 1];
    TaskRead taskRead;
    int oldProgress=0;
    Status oldTaskStatus=null;
    Status taskStatus=null;
    int progress=0;
    do {
      ResponseEntity<TaskRead> taskResponse=restGetById(Constants.REST_PATH_TASK,taskId,TaskRead.class,false);
      taskRead=taskResponse.getBody();
      progress=(int)(taskRead.getProgress() * 100);
      taskStatus=taskRead.getStatus();
      if ((prettyOutput != null && prettyOutput.length > 0 && (taskRead.getType() == Type.VHM ? prettyOutput[0].isRefresh(true) : prettyOutput[0].isRefresh(false))) || oldTaskStatus != taskStatus || oldProgress != progress) {
        clearScreen();
        if (prettyOutput != null && prettyOutput.length > 0 && prettyOutput[0].getCompletedTaskSummary() != null) {
          for (          String summary : prettyOutput[0].getCompletedTaskSummary()) {
            System.out.println(summary + ""String_Node_Str"");
          }
        }
        System.out.println(taskStatus + ""String_Node_Str"" + progress+ ""String_Node_Str"");
        if (prettyOutput != null && prettyOutput.length > 0) {
          prettyOutput[0].prettyOutput();
        }
        if (oldTaskStatus != taskStatus || oldProgress != progress) {
          oldTaskStatus=taskStatus;
          oldProgress=progress;
          if (taskRead.getProgressMessage() != null) {
            System.out.println(taskRead.getProgressMessage());
          }
        }
      }
      try {
        Thread.sleep(3 * 1000);
      }
 catch (      InterruptedException ex) {
      }
    }
 while (taskRead.getStatus() != TaskRead.Status.COMPLETED && taskRead.getStatus() != TaskRead.Status.FAILED && taskRead.getStatus() != TaskRead.Status.ABANDONED && taskRead.getStatus() != TaskRead.Status.STOPPED);
    String errorMsg=taskRead.getErrorMessage();
    if (!taskRead.getStatus().equals(TaskRead.Status.COMPLETED)) {
      String outputErrorInfo=Constants.OUTPUT_LOG_INFO + Constants.COMMON_LOG_FILE_PATH;
      if (errorMsg != null) {
        outputErrorInfo=errorMsg + ""String_Node_Str"" + outputErrorInfo;
      }
      throw new CliRestException(outputErrorInfo);
    }
 else {
      if (taskRead.getType().equals(Type.VHM)) {
        logger.info(""String_Node_Str"");
        Thread.sleep(5 * 1000);
        if (prettyOutput != null && prettyOutput.length > 0 && prettyOutput[0].isRefresh(true)) {
          clearScreen();
          System.out.println(taskStatus + ""String_Node_Str"" + progress+ ""String_Node_Str"");
          if (prettyOutput != null && prettyOutput.length > 0) {
            prettyOutput[0].prettyOutput();
          }
        }
      }
 else {
        return taskRead;
      }
    }
  }
  return null;
}"
48988,"/** 
 * deep clone a host object, use Gson as the tricky
 * @param other
 * @return
 */
public static AbstractHost clone(AbstractHost other){
  Gson gson=new Gson();
  return gson.fromJson(gson.toJson(other),AbstractHost.class);
}","/** 
 * deep clone a host object, use json as the tricky
 * @param other
 * @return
 */
public static AbstractHost clone(AbstractHost other){
  AbstractHost cloned=new AbstractHost(other.name);
  cloned.parent=other.parent;
  cloned.datastores=new ArrayList<AbstractDatastore>(other.datastores.size());
  for (  AbstractDatastore ad : other.datastores) {
    cloned.datastores.add(ad.clone());
  }
  return cloned;
}"
48989,"public Long createCluster(ClusterCreate createSpec) throws Exception {
  if (CommonUtil.isBlank(createSpec.getDistro())) {
    setDefaultDistro(createSpec);
  }
  DistroRead distroRead=getDistroManager().getDistroByName(createSpec.getDistro());
  createSpec.setDistroVendor(distroRead.getVendor());
  createSpec.setDistroVersion(distroRead.getVersion());
  createAutoRps(createSpec);
  ClusterCreate clusterSpec=ClusterSpecFactory.getCustomizedSpec(createSpec);
  if (clusterSpec != null && clusterSpec.getNodeGroups() != null) {
    for (    NodeGroupCreate ng : clusterSpec.getNodeGroups()) {
      String templateVmId=clusteringService.getTemplateVmId();
      if (templateVmId != null) {
        VcResourceUtils.checkVmMaxConfiguration(templateVmId,ng.getCpuNum(),ng.getMemCapacityMB());
      }
    }
  }
  String name=clusterSpec.getName();
  logger.info(""String_Node_Str"" + name);
  List<String> dsNames=getUsedDS(clusterSpec.getDsNames());
  if (dsNames.isEmpty()) {
    throw ClusterConfigException.NO_DATASTORE_ADDED();
  }
  List<VcCluster> vcClusters=getUsedVcClusters(clusterSpec.getRpNames());
  if (vcClusters.isEmpty()) {
    throw ClusterConfigException.NO_RESOURCE_POOL_ADDED();
  }
  validateDatastore(dsNames,vcClusters);
  validateNetworkAccessibility(name,createSpec.getNetworkName(),vcClusters);
  clusterConfigMgr.createClusterConfig(clusterSpec);
  clusterEntityMgr.updateClusterStatus(name,ClusterStatus.PROVISIONING);
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.PROVISION_ERROR.name()));
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(createSpec.getName()));
  param.put(JobConstants.VERIFY_NODE_STATUS_SCOPE_PARAM,new JobParameter(JobConstants.CLUSTER_NODE_SCOPE_VALUE));
  JobParameters jobParameters=new JobParameters(param);
  return jobManager.runJob(JobConstants.CREATE_CLUSTER_JOB_NAME,jobParameters);
}","public Long createCluster(ClusterCreate createSpec) throws Exception {
  if (CommonUtil.isBlank(createSpec.getDistro())) {
    setDefaultDistro(createSpec);
  }
  DistroRead distroRead=getDistroManager().getDistroByName(createSpec.getDistro());
  createSpec.setDistroVendor(distroRead.getVendor());
  createSpec.setDistroVersion(distroRead.getVersion());
  createAutoRps(createSpec);
  ClusterCreate clusterSpec=ClusterSpecFactory.getCustomizedSpec(createSpec);
  if (clusterSpec != null && clusterSpec.getNodeGroups() != null) {
    for (    NodeGroupCreate ng : clusterSpec.getNodeGroups()) {
      String templateVmId=clusteringService.getTemplateVmId();
      if (templateVmId != null) {
        VcResourceUtils.checkVmMaxConfiguration(templateVmId,ng.getCpuNum(),ng.getMemCapacityMB());
      }
    }
  }
  String name=clusterSpec.getName();
  logger.info(""String_Node_Str"" + name);
  List<String> dsNames=getUsedDS(clusterSpec.getDsNames());
  if (dsNames.isEmpty()) {
    throw ClusterConfigException.NO_DATASTORE_ADDED();
  }
  List<VcCluster> vcClusters=getUsedVcClusters(clusterSpec.getRpNames());
  if (vcClusters == null || vcClusters.isEmpty()) {
    throw ClusterConfigException.NO_RESOURCE_POOL_ADDED();
  }
  validateDatastore(dsNames,vcClusters);
  validateNetworkAccessibility(name,createSpec.getNetworkName(),vcClusters);
  clusterConfigMgr.createClusterConfig(clusterSpec);
  clusterEntityMgr.updateClusterStatus(name,ClusterStatus.PROVISIONING);
  Map<String,JobParameter> param=new TreeMap<String,JobParameter>();
  param.put(JobConstants.TIMESTAMP_JOB_PARAM,new JobParameter(new Date()));
  param.put(JobConstants.CLUSTER_SUCCESS_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.RUNNING.name()));
  param.put(JobConstants.CLUSTER_FAILURE_STATUS_JOB_PARAM,new JobParameter(ClusterStatus.PROVISION_ERROR.name()));
  param.put(JobConstants.CLUSTER_NAME_JOB_PARAM,new JobParameter(createSpec.getName()));
  param.put(JobConstants.VERIFY_NODE_STATUS_SCOPE_PARAM,new JobParameter(JobConstants.CLUSTER_NODE_SCOPE_VALUE));
  JobParameters jobParameters=new JobParameters(param);
  return jobManager.runJob(JobConstants.CREATE_CLUSTER_JOB_NAME,jobParameters);
}"
48990,"/** 
 * set cluster parameters synchronously
 * @param clusterName
 * @param activeComputeNodeNum
 * @param minComputeNodeNum
 * @param mode
 * @param ioPriority
 * @throws Exception
 */
@SuppressWarnings(""String_Node_Str"") public List<String> syncSetParam(String clusterName,Integer activeComputeNodeNum,Integer minComputeNodeNum,Boolean enableAuto,Priority ioPriority) throws Exception {
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  ClusterRead clusterRead=getClusterByName(clusterName,false);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (ioPriority != null) {
    prioritizeCluster(clusterName,ioPriority);
  }
  cluster=clusterEntityMgr.findByName(clusterName);
  if (enableAuto != null && enableAuto != cluster.getAutomationEnable()) {
    cluster.setAutomationEnable(enableAuto);
  }
  if (minComputeNodeNum != null && minComputeNodeNum != cluster.getVhmMinNum()) {
    cluster.setVhmMinNum(minComputeNodeNum);
  }
  List<String> nodeGroupNames=new ArrayList<String>();
  if ((enableAuto != null || minComputeNodeNum != null || activeComputeNodeNum != null) && !clusterRead.validateSetManualElasticity(nodeGroupNames)) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
  }
  if (activeComputeNodeNum != null) {
    if (activeComputeNodeNum != cluster.getVhmTargetNum()) {
      cluster.setVhmTargetNum(activeComputeNodeNum);
    }
  }
  if ((enableAuto != null) && !ClusterStatus.RUNNING.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus()) && !ClusterStatus.STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  clusterEntityMgr.update(cluster);
  if (enableAuto != null) {
    boolean success=clusteringService.setAutoElasticity(clusterName);
    if (!success) {
      throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
    }
  }
  if (enableAuto != null && !enableAuto && cluster.getVhmTargetNum() == null) {
    JobUtils.waitForManual(clusterName,executionService);
  }
  return nodeGroupNames;
}","/** 
 * set cluster parameters synchronously
 * @param clusterName
 * @param activeComputeNodeNum
 * @param minComputeNodeNum
 * @param mode
 * @param ioPriority
 * @throws Exception
 */
@SuppressWarnings(""String_Node_Str"") public List<String> syncSetParam(String clusterName,Integer activeComputeNodeNum,Integer minComputeNodeNum,Boolean enableAuto,Priority ioPriority) throws Exception {
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  ClusterRead clusterRead=getClusterByName(clusterName,false);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (ioPriority != null) {
    prioritizeCluster(clusterName,ioPriority);
  }
  cluster=clusterEntityMgr.findByName(clusterName);
  if (enableAuto != null && enableAuto != cluster.getAutomationEnable()) {
    cluster.setAutomationEnable(enableAuto);
  }
  if (minComputeNodeNum != null && minComputeNodeNum != cluster.getVhmMinNum()) {
    cluster.setVhmMinNum(minComputeNodeNum);
  }
  List<String> nodeGroupNames=new ArrayList<String>();
  if ((enableAuto != null || minComputeNodeNum != null || activeComputeNodeNum != null) && !clusterRead.validateSetManualElasticity(nodeGroupNames)) {
    throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
  }
  if (activeComputeNodeNum != null) {
    if (activeComputeNodeNum != cluster.getVhmTargetNum()) {
      cluster.setVhmTargetNum(activeComputeNodeNum);
    }
  }
  if ((enableAuto != null) && !ClusterStatus.RUNNING.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus()) && !ClusterStatus.STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  clusterEntityMgr.update(cluster);
  if (enableAuto != null || minComputeNodeNum != null) {
    boolean success=clusteringService.setAutoElasticity(clusterName);
    if (!success) {
      throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
    }
  }
  if (enableAuto != null && !enableAuto && cluster.getVhmTargetNum() == null) {
    JobUtils.waitForManual(clusterName,executionService);
  }
  return nodeGroupNames;
}"
48991,"public static ClusterCreate getSimpleClusterSpec(String specName) throws Exception {
  String json=TestPlacementUtil.readJson(specName);
  logger.info(json);
  Gson gson=new Gson();
  try {
    return gson.fromJson(json,ClusterCreate.class);
  }
 catch (  Exception e) {
    logger.error(e.getMessage());
    throw e;
  }
}","public static ClusterCreate getSimpleClusterSpec(String specName) throws Exception {
  String json=TestPlacementUtil.readJson(specName);
  logger.info(json);
  ObjectMapper mapper=new ObjectMapper();
  try {
    return mapper.readValue(json,ClusterCreate.class);
  }
 catch (  Exception e) {
    logger.error(e.getMessage());
    throw e;
  }
}"
48992,"public static AbstractDatacenter getAbstractDatacenter(String fileName) throws Exception {
  String json=TestPlacementUtil.readJson(fileName);
  logger.info(json);
  Gson gson=new Gson();
  try {
    AbstractDatacenter dc=gson.fromJson(json,AbstractDatacenter.class);
    for (    AbstractCluster cluster : dc.getClusters()) {
      List<AbstractDatastore> dsList=new ArrayList<AbstractDatastore>();
      for (      AbstractDatastore datastore : cluster.getDatastores()) {
        AbstractDatastore ds=dc.findAbstractDatastore(datastore.getName());
        AuAssert.check(ds != null);
        dsList.add(ds);
      }
      cluster.setDatastores(dsList);
      for (      AbstractHost host : cluster.getHosts()) {
        List<AbstractDatastore> datastores=new ArrayList<AbstractDatastore>();
        for (        AbstractDatastore datastore : host.getDatastores()) {
          AbstractDatastore ds=dc.findAbstractDatastore(datastore.getName());
          AuAssert.check(ds != null);
          datastores.add(ds);
        }
        host.setDatastores(datastores);
        host.setParent(cluster);
      }
    }
    Assert.assertTrue(dc.findAbstractCluster(""String_Node_Str"") != null,""String_Node_Str"");
    return dc;
  }
 catch (  Exception e) {
    logger.error(e.getMessage());
    throw e;
  }
}","public static AbstractDatacenter getAbstractDatacenter(String fileName) throws Exception {
  String json=TestPlacementUtil.readJson(fileName);
  logger.info(json);
  ObjectMapper mapper=new ObjectMapper();
  try {
    AbstractDatacenter dc=mapper.readValue(json,AbstractDatacenter.class);
    for (    AbstractCluster cluster : dc.getClusters()) {
      List<AbstractDatastore> dsList=new ArrayList<AbstractDatastore>();
      for (      AbstractDatastore datastore : cluster.getDatastores()) {
        AbstractDatastore ds=dc.findAbstractDatastore(datastore.getName());
        AuAssert.check(ds != null);
        dsList.add(ds);
      }
      cluster.setDatastores(dsList);
      for (      AbstractHost host : cluster.getHosts()) {
        List<AbstractDatastore> datastores=new ArrayList<AbstractDatastore>();
        for (        AbstractDatastore datastore : host.getDatastores()) {
          AbstractDatastore ds=dc.findAbstractDatastore(datastore.getName());
          AuAssert.check(ds != null);
          datastores.add(ds);
        }
        host.setDatastores(datastores);
        host.setParent(cluster);
      }
    }
    Assert.assertTrue(dc.findAbstractCluster(""String_Node_Str"") != null,""String_Node_Str"");
    return dc;
  }
 catch (  Exception e) {
    logger.error(e.getMessage());
    throw e;
  }
}"
48993,"public static List<BaseNode> getExistedNodes(String fileName) throws Exception {
  ClusterCreate cluster=getSimpleClusterSpec(DC_SPLIT_CLUSTER_SPEC);
  String json=readJson(fileName);
  Gson gson=new Gson();
  List<BaseNode> existedNodes;
  try {
    existedNodes=gson.fromJson(json,new TypeToken<List<BaseNode>>(){
    }
.getType());
  }
 catch (  Exception e) {
    logger.error(e.getMessage());
    throw e;
  }
  Assert.assertNotNull(existedNodes);
  for (  BaseNode node : existedNodes) {
    node.setCluster(cluster);
    String groupName=node.getVmName().split(""String_Node_Str"")[1];
    node.setNodeGroup(cluster.getNodeGroup(groupName));
  }
  return existedNodes;
}","public static List<BaseNode> getExistedNodes(String fileName) throws Exception {
  ClusterCreate cluster=getSimpleClusterSpec(DC_SPLIT_CLUSTER_SPEC);
  String json=readJson(fileName);
  ObjectMapper mapper=new ObjectMapper();
  List<BaseNode> existedNodes;
  try {
    existedNodes=mapper.readValue(json,new TypeReference<List<BaseNode>>(){
    }
);
  }
 catch (  Exception e) {
    logger.error(e.getMessage());
    throw e;
  }
  Assert.assertNotNull(existedNodes);
  for (  BaseNode node : existedNodes) {
    node.setCluster(cluster);
    String groupName=node.getVmName().split(""String_Node_Str"")[1];
    node.setNodeGroup(cluster.getNodeGroup(groupName));
  }
  return existedNodes;
}"
48994,"public static String[] getDatastoreNamePattern(ClusterCreate clusterSpec,NodeGroupCreate nodeGroupSpec){
  AuAssert.check(nodeGroupSpec != null && nodeGroupSpec.getStorage() != null);
  String[] patterns;
  StorageRead storage=nodeGroupSpec.getStorage();
  if (storage.getNamePattern() != null) {
    patterns=(String[])storage.getNamePattern().toArray();
  }
 else   if (DatastoreType.SHARED.toString().equalsIgnoreCase(storage.getType())) {
    patterns=clusterSpec.getSharedPattern().toArray(new String[clusterSpec.getSharedPattern().size()]);
  }
 else   if (DatastoreType.LOCAL.toString().equalsIgnoreCase(storage.getType())) {
    patterns=clusterSpec.getLocalPattern().toArray(new String[clusterSpec.getLocalPattern().size()]);
  }
 else {
    if (!clusterSpec.getLocalPattern().isEmpty()) {
      patterns=clusterSpec.getLocalPattern().toArray(new String[clusterSpec.getLocalPattern().size()]);
    }
 else {
      patterns=clusterSpec.getSharedPattern().toArray(new String[clusterSpec.getSharedPattern().size()]);
    }
  }
  for (int i=0; i < patterns.length; i++) {
    patterns[i]=CommonUtil.getDatastoreJavaPattern(patterns[i]);
  }
  return patterns;
}","public static String[] getDatastoreNamePattern(ClusterCreate clusterSpec,NodeGroupCreate nodeGroupSpec){
  AuAssert.check(nodeGroupSpec != null && nodeGroupSpec.getStorage() != null);
  String[] patterns;
  StorageRead storage=nodeGroupSpec.getStorage();
  if (storage.getNamePattern() != null) {
    patterns=storage.getNamePattern().toArray(new String[storage.getNamePattern().size()]);
  }
 else   if (DatastoreType.SHARED.toString().equalsIgnoreCase(storage.getType())) {
    patterns=clusterSpec.getSharedPattern().toArray(new String[clusterSpec.getSharedPattern().size()]);
  }
 else   if (DatastoreType.LOCAL.toString().equalsIgnoreCase(storage.getType())) {
    patterns=clusterSpec.getLocalPattern().toArray(new String[clusterSpec.getLocalPattern().size()]);
  }
 else {
    if (!clusterSpec.getLocalPattern().isEmpty()) {
      patterns=clusterSpec.getLocalPattern().toArray(new String[clusterSpec.getLocalPattern().size()]);
    }
 else {
      patterns=clusterSpec.getSharedPattern().toArray(new String[clusterSpec.getSharedPattern().size()]);
    }
  }
  for (int i=0; i < patterns.length; i++) {
    patterns[i]=CommonUtil.getDatastoreJavaPattern(patterns[i]);
  }
  return patterns;
}"
48995,"public Long fixDiskFailures(String clusterName,String groupName) throws Exception {
  ClusterStatus oldStatus=clusterEntityMgr.findByName(clusterName).getStatus();
  if (ClusterStatus.RUNNING != oldStatus) {
    throw ClusterHealServiceException.NOT_SUPPORTED(clusterName,""String_Node_Str"");
  }
  List<NodeGroupEntity> nodeGroups;
  if (groupName != null) {
    NodeGroupEntity nodeGroup=clusterEntityMgr.findByName(clusterName,groupName);
    AuAssert.check(nodeGroup != null);
    nodeGroups=new ArrayList<NodeGroupEntity>(1);
    nodeGroups.add(nodeGroup);
  }
 else {
    nodeGroups=clusterEntityMgr.findAllGroups(clusterName);
  }
  boolean workerNodesFound=false;
  JobParametersBuilder parametersBuilder=new JobParametersBuilder();
  List<JobParameters> jobParameterList=new ArrayList<JobParameters>();
  for (  NodeGroupEntity nodeGroup : nodeGroups) {
    List<String> roles=nodeGroup.getRoleNameList();
    if (HadoopRole.hasMgmtRole(roles)) {
      logger.info(""String_Node_Str"" + nodeGroup.getName() + ""String_Node_Str"");
      continue;
    }
    workerNodesFound=true;
    for (    NodeEntity node : clusterEntityMgr.findAllNodes(clusterName,nodeGroup.getName())) {
      if (clusterHealService.hasBadDisks(node.getVmName())) {
        logger.warn(""String_Node_Str"" + node.getVmName() + ""String_Node_Str"");
        JobParameters nodeParameters=parametersBuilder.addString(JobConstants.CLUSTER_NAME_JOB_PARAM,clusterName).addString(JobConstants.TARGET_NAME_JOB_PARAM,node.getVmName()).addString(JobConstants.GROUP_NAME_JOB_PARAM,nodeGroup.getName()).addString(JobConstants.SUB_JOB_NODE_NAME,node.getVmName()).toJobParameters();
        jobParameterList.add(nodeParameters);
      }
    }
  }
  if (!workerNodesFound) {
    throw ClusterHealServiceException.NOT_SUPPORTED(clusterName,""String_Node_Str"");
  }
  if (jobParameterList.isEmpty()) {
    logger.info(""String_Node_Str"");
    throw ClusterHealServiceException.NOT_NEEDED(clusterName);
  }
  try {
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.MAINTENANCE);
    return jobManager.runSubJobForNodes(JobConstants.FIX_NODE_DISK_FAILURE_JOB_NAME,jobParameterList,clusterName,oldStatus,oldStatus);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + e.getMessage());
    throw e;
  }
}","public Long fixDiskFailures(String clusterName,String groupName) throws Exception {
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  ClusterStatus oldStatus=cluster.getStatus();
  if (ClusterStatus.RUNNING != oldStatus) {
    throw ClusterHealServiceException.NOT_SUPPORTED(clusterName,""String_Node_Str"");
  }
  List<NodeGroupEntity> nodeGroups;
  if (groupName != null) {
    NodeGroupEntity nodeGroup=clusterEntityMgr.findByName(clusterName,groupName);
    if (nodeGroup == null) {
      logger.error(""String_Node_Str"" + groupName + ""String_Node_Str"");
      throw BddException.NOT_FOUND(""String_Node_Str"",groupName);
    }
    nodeGroups=new ArrayList<NodeGroupEntity>(1);
    nodeGroups.add(nodeGroup);
  }
 else {
    nodeGroups=clusterEntityMgr.findAllGroups(clusterName);
  }
  boolean workerNodesFound=false;
  JobParametersBuilder parametersBuilder=new JobParametersBuilder();
  List<JobParameters> jobParameterList=new ArrayList<JobParameters>();
  for (  NodeGroupEntity nodeGroup : nodeGroups) {
    List<String> roles=nodeGroup.getRoleNameList();
    if (HadoopRole.hasMgmtRole(roles)) {
      logger.info(""String_Node_Str"" + nodeGroup.getName() + ""String_Node_Str"");
      continue;
    }
    workerNodesFound=true;
    for (    NodeEntity node : clusterEntityMgr.findAllNodes(clusterName,nodeGroup.getName())) {
      if (clusterHealService.hasBadDisks(node.getVmName())) {
        logger.warn(""String_Node_Str"" + node.getVmName() + ""String_Node_Str"");
        JobParameters nodeParameters=parametersBuilder.addString(JobConstants.CLUSTER_NAME_JOB_PARAM,clusterName).addString(JobConstants.TARGET_NAME_JOB_PARAM,node.getVmName()).addString(JobConstants.GROUP_NAME_JOB_PARAM,nodeGroup.getName()).addString(JobConstants.SUB_JOB_NODE_NAME,node.getVmName()).toJobParameters();
        jobParameterList.add(nodeParameters);
      }
    }
  }
  if (!workerNodesFound) {
    throw ClusterHealServiceException.NOT_SUPPORTED(clusterName,""String_Node_Str"");
  }
  if (jobParameterList.isEmpty()) {
    logger.info(""String_Node_Str"");
    throw ClusterHealServiceException.NOT_NEEDED(clusterName);
  }
  try {
    clusterEntityMgr.updateClusterStatus(clusterName,ClusterStatus.MAINTENANCE);
    return jobManager.runSubJobForNodes(JobConstants.FIX_NODE_DISK_FAILURE_JOB_NAME,jobParameterList,clusterName,oldStatus,oldStatus);
  }
 catch (  Exception e) {
    logger.error(""String_Node_Str"" + e.getMessage());
    throw e;
  }
}"
48996,"public static void refreshDatastore(final VcCluster cl){
  VcContext.inVcSessionDo(new VcSession<Void>(){
    @Override protected Void body(){
      try {
        cl.update();
      }
 catch (      Exception e) {
        logger.info(""String_Node_Str"" + cl.getName() + ""String_Node_Str"",e);
      }
      List<VcDatastore> dss=cl.getAllDatastores();
      if (dss != null) {
        for (        VcDatastore ds : dss) {
          try {
            ds.update();
          }
 catch (          Exception e) {
            logger.info(""String_Node_Str"" + ds.getName() + ""String_Node_Str"",e);
          }
        }
      }
      return null;
    }
  }
);
}","public static void refreshDatastore(final VcCluster cl){
  VcContext.inVcSessionDo(new VcSession<Void>(){
    @Override protected Void body(){
      try {
        cl.update();
      }
 catch (      Exception e) {
        logger.info(""String_Node_Str"" + cl.getName() + ""String_Node_Str"",e);
      }
      List<VcDatastore> dss=cl.getAllDatastores();
      if (dss != null) {
        for (        VcDatastore ds : dss) {
          try {
            ds.update();
          }
 catch (          Exception e) {
            logger.info(""String_Node_Str"" + ds.getName() + ""String_Node_Str"",e);
          }
        }
      }
      try {
        List<VcHost> hosts=cl.getHosts();
        if (hosts != null) {
          for (          VcHost host : hosts) {
            try {
              host.update();
            }
 catch (            Exception e) {
              logger.info(""String_Node_Str"" + host.getName() + ""String_Node_Str"",e);
            }
          }
        }
      }
 catch (      Exception e) {
        logger.info(""String_Node_Str"" + cl.getName() + ""String_Node_Str"",e);
      }
      return null;
    }
  }
);
}"
48997,"/** 
 * set cluster parameters synchronously
 * @param clusterName
 * @param nodeGroupName
 * @param activeComputeNodeNum
 * @param minComputeNodeNum
 * @param mode
 * @param ioPriority
 * @throws Exception
 */
@SuppressWarnings(""String_Node_Str"") public List<String> syncSetParam(String clusterName,String nodeGroupName,Integer activeComputeNodeNum,Integer minComputeNodeNum,Boolean enableAuto,Priority ioPriority) throws Exception {
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  ClusterRead clusterRead=getClusterByName(clusterName,false);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (enableAuto != null && enableAuto != cluster.getAutomationEnable()) {
    cluster.setAutomationEnable(enableAuto);
  }
  if (minComputeNodeNum != null && minComputeNodeNum != cluster.getVhmMinNum()) {
    cluster.setVhmMinNum(minComputeNodeNum);
  }
  List<String> nodeGroupNames=new ArrayList<String>();
  if (!clusterRead.validateSetManualElasticity(nodeGroupName,nodeGroupNames)) {
    if (nodeGroupName != null) {
      throw BddException.INVALID_PARAMETER(""String_Node_Str"",nodeGroupName);
    }
 else {
      throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
    }
  }
  if (nodeGroupName == null && activeComputeNodeNum != null) {
    if (activeComputeNodeNum != cluster.getVhmTargetNum()) {
      cluster.setVhmTargetNum(activeComputeNodeNum);
    }
  }
  clusterEntityMgr.update(cluster);
  if (nodeGroupName != null) {
    NodeGroupEntity ngEntity=clusterEntityMgr.findByName(clusterName,nodeGroupName);
    if (activeComputeNodeNum != ngEntity.getVhmTargetNum()) {
      ngEntity.setVhmTargetNum(activeComputeNodeNum);
      clusterEntityMgr.update(ngEntity);
    }
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus()) && !ClusterStatus.STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  boolean sucess=clusteringService.setAutoElasticity(clusterName,null);
  if (!sucess) {
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  if (ioPriority != null) {
    prioritizeCluster(clusterName,nodeGroupName,ioPriority);
  }
  return nodeGroupNames;
}","/** 
 * set cluster parameters synchronously
 * @param clusterName
 * @param nodeGroupName
 * @param activeComputeNodeNum
 * @param minComputeNodeNum
 * @param mode
 * @param ioPriority
 * @throws Exception
 */
@SuppressWarnings(""String_Node_Str"") public List<String> syncSetParam(String clusterName,String nodeGroupName,Integer activeComputeNodeNum,Integer minComputeNodeNum,Boolean enableAuto,Priority ioPriority) throws Exception {
  ClusterEntity cluster=clusterEntityMgr.findByName(clusterName);
  ClusterRead clusterRead=getClusterByName(clusterName,false);
  if (cluster == null) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str"");
    throw BddException.NOT_FOUND(""String_Node_Str"",clusterName);
  }
  if (ioPriority != null) {
    prioritizeCluster(clusterName,nodeGroupName,ioPriority);
  }
  if (enableAuto != null && enableAuto != cluster.getAutomationEnable()) {
    cluster.setAutomationEnable(enableAuto);
  }
  if (minComputeNodeNum != null && minComputeNodeNum != cluster.getVhmMinNum()) {
    cluster.setVhmMinNum(minComputeNodeNum);
  }
  List<String> nodeGroupNames=new ArrayList<String>();
  if (!clusterRead.validateSetManualElasticity(nodeGroupName,nodeGroupNames)) {
    if (nodeGroupName != null) {
      throw BddException.INVALID_PARAMETER(""String_Node_Str"",nodeGroupName);
    }
 else {
      throw BddException.INVALID_PARAMETER(""String_Node_Str"",clusterName);
    }
  }
  if (nodeGroupName == null && activeComputeNodeNum != null) {
    if (activeComputeNodeNum != cluster.getVhmTargetNum()) {
      cluster.setVhmTargetNum(activeComputeNodeNum);
    }
  }
  clusterEntityMgr.update(cluster);
  if (nodeGroupName != null) {
    NodeGroupEntity ngEntity=clusterEntityMgr.findByName(clusterName,nodeGroupName);
    if (activeComputeNodeNum != ngEntity.getVhmTargetNum()) {
      ngEntity.setVhmTargetNum(activeComputeNodeNum);
      clusterEntityMgr.update(ngEntity);
    }
  }
  if (!ClusterStatus.RUNNING.equals(cluster.getStatus()) && !ClusterStatus.STOPPED.equals(cluster.getStatus())) {
    logger.error(""String_Node_Str"" + clusterName + ""String_Node_Str""+ cluster.getStatus()+ ""String_Node_Str"");
    throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
  }
  if (enableAuto != null && enableAuto) {
    boolean sucess=clusteringService.setAutoElasticity(clusterName,null);
    if (!sucess) {
      throw ClusterManagerException.SET_AUTO_ELASTICITY_NOT_ALLOWED_ERROR(clusterName,""String_Node_Str"");
    }
  }
  return nodeGroupNames;
}"
48998,"public ClusterCreate getClusterSpec(String clusterName){
  ClusterCreate spec=clusterConfigMgr.getClusterConfig(clusterName);
  spec.setVcClusters(null);
  spec.setTemplateId(null);
  spec.setDistroMap(null);
  spec.setSharedPattern(null);
  spec.setLocalPattern(null);
  spec.setNetworking(null);
  spec.setRpNames(null);
  spec.setDsNames(null);
  spec.setNetworkName(null);
  spec.setName(null);
  spec.setDistro(null);
  spec.setValidateConfig(null);
  spec.setTopologyPolicy(null);
  spec.setHostToRackMap(null);
  spec.setHttpProxy(null);
  spec.setNoProxy(null);
  spec.setDistroVendor(null);
  spec.setDistroVersion(null);
  NodeGroupCreate[] groups=spec.getNodeGroups();
  if (groups != null) {
    for (    NodeGroupCreate group : groups) {
      group.setVcClusters(null);
      group.setGroupType(null);
      group.setRpNames(null);
      group.getStorage().setDsNames(null);
      group.getStorage().setNamePattern(null);
      group.setVmFolderPath(null);
      group.getStorage().setSplitPolicy(null);
      group.getStorage().setControllerType(null);
      group.getStorage().setAllocType(null);
    }
  }
  return spec;
}","public ClusterCreate getClusterSpec(String clusterName){
  ClusterCreate spec=clusterConfigMgr.getClusterConfig(clusterName);
  spec.setVcClusters(null);
  spec.setTemplateId(null);
  spec.setDistroMap(null);
  spec.setSharedPattern(null);
  spec.setLocalPattern(null);
  spec.setNetworking(null);
  spec.setRpNames(null);
  spec.setDsNames(null);
  spec.setNetworkName(null);
  spec.setName(null);
  spec.setDistro(null);
  spec.setValidateConfig(null);
  spec.setTopologyPolicy(null);
  spec.setHostToRackMap(null);
  spec.setHttpProxy(null);
  spec.setNoProxy(null);
  spec.setDistroVendor(null);
  spec.setDistroVersion(null);
  NodeGroupCreate[] groups=spec.getNodeGroups();
  if (groups != null) {
    for (    NodeGroupCreate group : groups) {
      group.setVcClusters(null);
      group.setGroupType(null);
      group.setRpNames(null);
      group.getStorage().setDsNames(null);
      group.getStorage().setNamePattern(null);
      group.setVmFolderPath(null);
      group.getStorage().setSplitPolicy(null);
      group.getStorage().setControllerType(null);
      group.getStorage().setAllocType(null);
      if (group.getPlacementPolicies() != null) {
        List<GroupAssociation> associations=group.getPlacementPolicies().getGroupAssociations();
        if (associations != null && associations.isEmpty()) {
          group.getPlacementPolicies().setGroupAssociations(null);
        }
      }
    }
  }
  return spec;
}"
48999,"public static void verifyNodesStatus(List<NodeEntity> nodes,NodeStatus expectedStatus,boolean ignoreMissing){
  for (  NodeEntity node : nodes) {
    if (node.getStatus() != expectedStatus) {
      if (ignoreMissing && node.getStatus() == NodeStatus.NOT_EXIST) {
        continue;
      }
      if (expectedStatus == NodeStatus.VM_READY) {
        VcVirtualMachine vm=VcCache.getIgnoreMissing(node.getMoId());
        if (vm != null && vm.isPoweredOn() && (VcVmUtil.getIpAddress(vm,false) != null)) {
          continue;
        }
      }
      throw ClusteringServiceException.VM_STATUS_ERROR(node.getVmName(),node.getStatus().toString(),expectedStatus.toString());
    }
  }
}","public static void verifyNodesStatus(List<NodeEntity> nodes,NodeStatus expectedStatus,boolean ignoreMissing){
  for (  NodeEntity node : nodes) {
    if (node.getStatus() != expectedStatus) {
      if (ignoreMissing && node.getStatus() == NodeStatus.NOT_EXIST) {
        continue;
      }
      if (expectedStatus == NodeStatus.VM_READY) {
        VcVirtualMachine vm=VcCache.getIgnoreMissing(node.getMoId());
        if (vm == null || !vm.isPoweredOn() || (VcVmUtil.getIpAddress(vm,false) == null)) {
          throw ClusteringServiceException.VM_STATUS_ERROR(node.getVmName(),node.getStatus().toString(),expectedStatus.toString());
        }
        String haFlag=node.getNodeGroup().getHaFlag();
        if (haFlag != null && Constants.HA_FLAG_FT.equals(haFlag.toLowerCase())) {
          if (!VcVmUtil.verifyFTState(vm)) {
            logger.info(""String_Node_Str"" + vm.getName() + ""String_Node_Str""+ ""String_Node_Str""+ vm.getFTState()+ ""String_Node_Str"");
            throw ClusteringServiceException.ENABLE_FT_FAILED(null,node.getVmName());
          }
        }
      }
    }
  }
}"
49000,"/** 
 * separate vc unreachable node from existing node list. if the node is powered off, or powered on but ip address is not accessible, remove the node from good nodes
 * @param existingNodes
 * @param deletedNodes
 * @param occupiedIps
 */
public static void separateVcUnreachableNodes(List<BaseNode> existingNodes,List<BaseNode> deletedNodes,Set<String> occupiedIps){
  for (  BaseNode node : existingNodes) {
    if (node.getVmMobId() == null) {
      deletedNodes.add(node);
      continue;
    }
    VcVirtualMachine vm=VcCache.getIgnoreMissing(node.getVmMobId());
    if (vm == null || vm.isPoweredOff() || (VcVmUtil.getIpAddress(vm,false) == null)) {
      deletedNodes.add(node);
      continue;
    }
    occupiedIps.add(node.getIpAddress());
  }
  existingNodes.removeAll(deletedNodes);
}","/** 
 * separate vc unreachable node from existing node list. if the node is powered off, or powered on but ip address is not accessible, remove the node from good nodes
 * @param existingNodes
 * @param deletedNodes
 * @param occupiedIps
 */
public static void separateVcUnreachableNodes(List<BaseNode> existingNodes,List<BaseNode> deletedNodes,Set<String> occupiedIps){
  for (  BaseNode node : existingNodes) {
    if (node.getVmMobId() == null) {
      deletedNodes.add(node);
      continue;
    }
    VcVirtualMachine vm=VcCache.getIgnoreMissing(node.getVmMobId());
    if (vm == null || vm.isPoweredOff() || (VcVmUtil.getIpAddress(vm,false) == null)) {
      deletedNodes.add(node);
      continue;
    }
    String haFlag=node.getNodeGroup().getHaFlag();
    if (haFlag != null && Constants.HA_FLAG_FT.equals(haFlag.toLowerCase())) {
      if (!VcVmUtil.verifyFTState(vm)) {
        logger.info(""String_Node_Str"" + vm.getName() + ""String_Node_Str""+ ""String_Node_Str""+ vm.getFTState()+ ""String_Node_Str"");
        deletedNodes.add(node);
        continue;
      }
    }
    occupiedIps.add(node.getIpAddress());
  }
  existingNodes.removeAll(deletedNodes);
}"
