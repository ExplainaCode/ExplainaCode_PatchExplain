record_number,buggy_code,fixed_code
56001,"/** 
 * Sets or removes a construction mark
 * @param x x coordinate
 * @param y y coordinate
 * @param set If true, the construction mark shall be set, otherwise, it shall be removed.
 * @param flattenPositions The positions that need to be flattened to position this building. This value might be null whenever set is false.
 */
public abstract void setConstructMarking(int x,int y,boolean set,RelativePoint[] flattenPositions);","/** 
 * Sets or removes a construction mark
 * @param x x coordinate
 * @param y y coordinate
 * @param set If true, the construction mark shall be set, otherwise, it shall be removed.
 * @param binaryConstructionMarkValues If true, the construction marks can only have to values: Either building is possible (set == <code>true</code>) or building is not possible (set == <code>false</code>).
 * @param flattenPositions The positions that need to be flattened to position this building. This value might be null whenever set is false.
 */
public abstract void setConstructMarking(int x,int y,boolean set,boolean binaryConstructionMarkValues,RelativePoint[] flattenPositions);"
56002,"@Override public void run(){
  while (!canceled) {
    try {
synchronized (this) {
        while (buildingType == null) {
          this.wait();
        }
      }
      while (buildingType != null && !canceled) {
        if (!pausingSupplier.isPausing()) {
          StopWatch watch=new MilliStopWatch();
          watch.restart();
          EBuildingType buildingType=this.buildingType;
          if (buildingType != null && mapArea != null) {
            algorithm.calculateConstructMarks(mapArea,buildingType.getBuildingAreaBitSet(),buildingType.getGroundtypes(),buildingType.getBlockedTiles());
          }
          watch.stop(""String_Node_Str"");
        }
synchronized (this) {
          wait(AlgorithmConstants.CONSTRUCT_MARKS_MAX_REFRESH_TIME);
        }
      }
      algorithm.removeConstructionMarks();
    }
 catch (    InterruptedException e) {
    }
catch (    Throwable t) {
      t.printStackTrace();
    }
  }
}","@Override public void run(){
  while (!canceled) {
    try {
synchronized (this) {
        while (buildingType == null) {
          this.wait();
        }
      }
      while (buildingType != null && !canceled) {
        if (!pausingSupplier.isPausing()) {
          StopWatch watch=new MilliStopWatch();
          watch.restart();
          EBuildingType buildingType=this.buildingType;
          if (buildingType != null && mapArea != null) {
            algorithm.calculateConstructMarks(mapArea,buildingType.getBuildingAreaBitSet(),buildingType.getGroundtypes(),buildingType.getBlockedTiles(),buildingType.isMine());
          }
          watch.stop(""String_Node_Str"");
        }
synchronized (this) {
          wait(AlgorithmConstants.CONSTRUCT_MARKS_MAX_REFRESH_TIME);
        }
      }
      algorithm.removeConstructionMarks();
    }
 catch (    InterruptedException e) {
    }
catch (    Throwable t) {
      t.printStackTrace();
    }
  }
}"
56003,"public void calculateConstructMarks(final MapRectangle mapArea,final BuildingAreaBitSet buildingArea,final ELandscapeType[] landscapeTypes,RelativePoint[] flattenPositions){
  if (lastArea != null) {
    removeConstructionMarks(lastArea,mapArea);
  }
  final short[] xJumps=buildingArea.xJumps;
  final short[] yJumps=buildingArea.yJumps;
  final int lineLength=mapArea.getLineLength() + mapArea.getHeight() / 2;
  final BitSet doneSet=new BitSet(lineLength * mapArea.getHeight());
  final int xOffsetForBuilding=buildingArea.minX;
  final int yOffsetForBuilding=buildingArea.minY;
  final int buildingAreaWidth=buildingArea.width;
  final int buildingAreaHeight=buildingArea.height;
  for (int line=0; line < mapArea.getHeight(); line++) {
    final int y=mapArea.getLineY(line);
    final int xLineOffset=mapArea.getMinX();
    DX_LOOP:     for (int dx=0; dx < lineLength; dx++) {
      final int x=xLineOffset + dx;
      final short partitionId;
      if (!mapArea.contains(x,y) || doneSet.get(dx + line * lineLength)) {
        continue;
      }
{
        int firstPosX=buildingArea.aPosition.calculateX(x);
        int firstPosY=buildingArea.aPosition.calculateY(y);
        if (!map.isInBounds(firstPosX,firstPosY)) {
          continue;
        }
        partitionId=map.getPartitionIdAt(firstPosX,firstPosY);
        if (!map.canPlayerConstructOnPartition(playerId,partitionId)) {
          continue DX_LOOP;
        }
      }
      for (int buildingDx=buildingAreaWidth - 1; buildingDx >= 0; buildingDx--) {
        for (int buildingDy=buildingAreaHeight - 1; buildingDy >= 0; buildingDy--) {
          int index=buildingDx + buildingDy * buildingAreaWidth;
          if (xJumps[index] != 0 && !map.canUsePositionForConstruction(x + buildingDx + xOffsetForBuilding,y + buildingDy + yOffsetForBuilding,landscapeTypes,partitionId)) {
            map.setConstructMarking(x,y,false,null);
            for (int pruneX=0; pruneX < xJumps[index]; pruneX++) {
              int currYJumps=yJumps[(buildingDx - pruneX) + buildingDy * buildingAreaWidth];
              for (int pruneY=0; pruneY < currYJumps; pruneY++) {
                if (pruneY == 0 && pruneX == 0) {
                  continue;
                }
                doneSet.set((dx + pruneX) + (line + pruneY) * lineLength);
                map.setConstructMarking(x + pruneX,y + pruneY,false,null);
              }
            }
            continue DX_LOOP;
          }
        }
      }
      map.setConstructMarking(x,y,true,flattenPositions);
    }
  }
  lastArea=mapArea;
}","public void calculateConstructMarks(final MapRectangle mapArea,final BuildingAreaBitSet buildingArea,final ELandscapeType[] landscapeTypes,RelativePoint[] flattenPositions,boolean binaryConstructionMarkValues){
  if (lastArea != null) {
    removeConstructionMarks(lastArea,mapArea);
  }
  final short[] xJumps=buildingArea.xJumps;
  final short[] yJumps=buildingArea.yJumps;
  final int lineLength=mapArea.getLineLength() + mapArea.getHeight() / 2;
  final BitSet doneSet=new BitSet(lineLength * mapArea.getHeight());
  final int xOffsetForBuilding=buildingArea.minX;
  final int yOffsetForBuilding=buildingArea.minY;
  final int buildingAreaWidth=buildingArea.width;
  final int buildingAreaHeight=buildingArea.height;
  for (int line=0; line < mapArea.getHeight(); line++) {
    final int y=mapArea.getLineY(line);
    final int xLineOffset=mapArea.getMinX();
    DX_LOOP:     for (int dx=0; dx < lineLength; dx++) {
      final int x=xLineOffset + dx;
      final short partitionId;
      if (!mapArea.contains(x,y) || doneSet.get(dx + line * lineLength)) {
        continue;
      }
{
        int firstPosX=buildingArea.aPosition.calculateX(x);
        int firstPosY=buildingArea.aPosition.calculateY(y);
        if (!map.isInBounds(firstPosX,firstPosY)) {
          continue;
        }
        partitionId=map.getPartitionIdAt(firstPosX,firstPosY);
        if (!map.canPlayerConstructOnPartition(playerId,partitionId)) {
          continue DX_LOOP;
        }
      }
      for (int buildingDx=buildingAreaWidth - 1; buildingDx >= 0; buildingDx--) {
        for (int buildingDy=buildingAreaHeight - 1; buildingDy >= 0; buildingDy--) {
          int index=buildingDx + buildingDy * buildingAreaWidth;
          if (xJumps[index] != 0 && !map.canUsePositionForConstruction(x + buildingDx + xOffsetForBuilding,y + buildingDy + yOffsetForBuilding,landscapeTypes,partitionId)) {
            map.setConstructMarking(x,y,false,binaryConstructionMarkValues,null);
            for (int pruneX=0; pruneX < xJumps[index]; pruneX++) {
              int currYJumps=yJumps[(buildingDx - pruneX) + buildingDy * buildingAreaWidth];
              for (int pruneY=0; pruneY < currYJumps; pruneY++) {
                if (pruneY == 0 && pruneX == 0) {
                  continue;
                }
                doneSet.set((dx + pruneX) + (line + pruneY) * lineLength);
                map.setConstructMarking(x + pruneX,y + pruneY,false,binaryConstructionMarkValues,null);
              }
            }
            continue DX_LOOP;
          }
        }
      }
      map.setConstructMarking(x,y,true,binaryConstructionMarkValues,flattenPositions);
    }
  }
  lastArea=mapArea;
}"
56004,"/** 
 * Removes all construction marks in the given area.
 * @param area The area to remove the marks
 * @param notIn The area of marks that should be skipped.
 */
private void removeConstructionMarks(IMapArea area,IMapArea notIn){
  for (  ShortPoint2D pos : new MapShapeFilter(area,map.getWidth(),map.getHeight())) {
    if (!notIn.contains(pos)) {
      map.setConstructMarking(pos.x,pos.y,false,null);
    }
  }
}","/** 
 * Removes all construction marks in the given area.
 * @param area The area to remove the marks
 * @param notIn The area of marks that should be skipped.
 */
private void removeConstructionMarks(IMapArea area,IMapArea notIn){
  for (  ShortPoint2D pos : new MapShapeFilter(area,map.getWidth(),map.getHeight())) {
    if (!notIn.contains(pos)) {
      map.setConstructMarking(pos.x,pos.y,false,false,null);
    }
  }
}"
56005,"@Override public final void setConstructMarking(int x,int y,boolean set,RelativePoint[] flattenPositions){
  if (isInBounds(x,y)) {
    if (set) {
      mapObjectsManager.setConstructionMarking(x,y,getConstructionMarkValue(x,y,flattenPositions));
    }
 else {
      mapObjectsManager.setConstructionMarking(x,y,(byte)-1);
    }
  }
}","@Override public final void setConstructMarking(int x,int y,boolean set,boolean binaryConstructionMarkValues,RelativePoint[] flattenPositions){
  if (isInBounds(x,y)) {
    if (set) {
      byte newValue=binaryConstructionMarkValues ? 0 : getConstructionMarkValue(x,y,flattenPositions);
      mapObjectsManager.setConstructionMarking(x,y,newValue);
    }
 else {
      mapObjectsManager.setConstructionMarking(x,y,(byte)-1);
    }
  }
}"
56006,"@Test public void test(){
  boolean[][] blocked={{false,false,false,false,false,false,false,false,false,false,false,false},{false,false,false,false,false,false,false,false,false,false,false,false},{false,false,false,false,false,false,false,false,false,false,false,false},{false,false,false,false,false,false,true,false,false,false,false,false},{false,false,false,false,false,false,true,false,false,false,false,false},{false,false,false,false,false,false,false,false,false,false,false,false},{false,false,false,false,false,false,false,false,false,false,false,false},{false,false,false,false,false,false,false,false,false,false,false,false},{false,false,false,false,false,false,false,false,false,false,false,false},{false,false,false,false,false,false,false,false,false,false,false,false},{false,false,false,false,false,false,false,false,false,false,false,false}};
  boolean[][] buildingMask={{false,false,true,false,false},{true,true,true,true,true},{false,false,false,false,false}};
  MapRectangle mapArea=new MapRectangle(-15,-15,30,30);
  BuildingAreaBitSet buildingSet=new BuildingAreaBitSet(BuildingAreaBitSetTest.createRelativePoints(buildingMask));
  TestMap map=new TestMap(blocked);
  NewConstructionMarksAlgorithm algorithm=new NewConstructionMarksAlgorithm(map,(byte)0);
  algorithm.calculateConstructMarks(mapArea,buildingSet,null,null);
  for (int y=0; y < map.height; y++) {
    for (int x=0; x < map.width; x++) {
      assertEquals(x + ""String_Node_Str"" + y,canCostructAt(map,x,y,buildingSet),map.marksSet[x + y * map.width] > 0);
    }
  }
}","@Test public void test(){
  boolean[][] blocked={{false,false,false,false,false,false,false,false,false,false,false,false},{false,false,false,false,false,false,false,false,false,false,false,false},{false,false,false,false,false,false,false,false,false,false,false,false},{false,false,false,false,false,false,true,false,false,false,false,false},{false,false,false,false,false,false,true,false,false,false,false,false},{false,false,false,false,false,false,false,false,false,false,false,false},{false,false,false,false,false,false,false,false,false,false,false,false},{false,false,false,false,false,false,false,false,false,false,false,false},{false,false,false,false,false,false,false,false,false,false,false,false},{false,false,false,false,false,false,false,false,false,false,false,false},{false,false,false,false,false,false,false,false,false,false,false,false}};
  boolean[][] buildingMask={{false,false,true,false,false},{true,true,true,true,true},{false,false,false,false,false}};
  MapRectangle mapArea=new MapRectangle(-15,-15,30,30);
  BuildingAreaBitSet buildingSet=new BuildingAreaBitSet(BuildingAreaBitSetTest.createRelativePoints(buildingMask));
  TestMap map=new TestMap(blocked);
  NewConstructionMarksAlgorithm algorithm=new NewConstructionMarksAlgorithm(map,(byte)0);
  algorithm.calculateConstructMarks(mapArea,buildingSet,null,null,false);
  for (int y=0; y < map.height; y++) {
    for (int x=0; x < map.width; x++) {
      assertEquals(x + ""String_Node_Str"" + y,canCostructAt(map,x,y,buildingSet),map.marksSet[x + y * map.width] > 0);
    }
  }
}"
56007,"@Override public void setConstructMarking(int x,int y,boolean set,RelativePoint[] flattenPositions){
  if (isInBounds(x,y))   marksSet[x + y * width]=set ? 1 : -1;
}","@Override public void setConstructMarking(int x,int y,boolean set,boolean binaryConstructionMarkValues,RelativePoint[] flattenPositions){
  if (isInBounds(x,y))   marksSet[x + y * width]=set ? 1 : -1;
}"
56008,"@Override public EMovableType popWeaponForBearer(){
  List<RequestStack> stacks=super.getStacks();
  for (  RequestStack stack : stacks) {
    if (stack.getMaterialType() == EMaterialType.BOW || stack.getMaterialType() == EMaterialType.SWORD || stack.getMaterialType() == EMaterialType.SPEAR) {
      if (stack.hasMaterial()) {
        stack.pop();
        return getSoldierType(stack.getMaterialType());
      }
    }
  }
  return null;
}","@Override public EMovableType popWeaponForBearer(){
  List<RequestStack> stacks=super.getStacks();
  for (  RequestStack stack : stacks) {
    if (stack.getMaterialType() == EMaterialType.BOW || stack.getMaterialType() == EMaterialType.SWORD || stack.getMaterialType() == EMaterialType.SPEAR) {
      if (stack.pop()) {
        return getSoldierType(stack.getMaterialType());
      }
    }
  }
  return null;
}"
56009,"@Override protected int subTimerEvent(){
  RequestStack wineStack=getWineStack();
  if (wineStack.hasMaterial()) {
    wineStack.pop();
    return CONSUME_DELAY;
  }
 else {
    return CHECK_DELAY;
  }
}","@Override protected int subTimerEvent(){
  RequestStack wineStack=getWineStack();
  if (wineStack.pop()) {
    return CONSUME_DELAY;
  }
 else {
    return CHECK_DELAY;
  }
}"
56010,"@Override public final boolean popMaterialFromStack(EMaterialType material){
  for (  RequestStack stack : super.getStacks()) {
    if (stack.getMaterialType() == material) {
      stack.pop();
      return true;
    }
  }
  return false;
}","@Override public final boolean popMaterialFromStack(EMaterialType material){
  for (  RequestStack stack : super.getStacks()) {
    if (stack.getMaterialType() == material) {
      return stack.pop();
    }
  }
  return false;
}"
56011,"@Override public final void popMaterial(ShortPoint2D position,EMaterialType materialType){
  mapObjectsManager.popMaterial(position.x,position.y,materialType);
}","@Override public final boolean popMaterial(ShortPoint2D position,EMaterialType materialType){
  return mapObjectsManager.popMaterial(position.x,position.y,materialType);
}"
56012,"/** 
 * Pops a materials of the given type from the given location.
 * @param position The location to pop the material.
 * @param materialType The  {@link EMaterialType} type to be popped.
 */
void popMaterial(ShortPoint2D position,EMaterialType materialType);","/** 
 * Pops a materials of the given type from the given location.
 * @param position The location to pop the material.
 * @param materialType The  {@link EMaterialType} type to be popped.
 * @return if <code>true</code>, the material has been popped. If <code>false</code>, no material of this type has been found at the givenposition.
 */
boolean popMaterial(ShortPoint2D position,EMaterialType materialType);"
56013,"/** 
 * Pops a material from this stack. The material is of the type returned by   {@link #getMaterialType()} and specified in the constructor.
 */
public void pop(){
  grid.popMaterial(position,materialType);
  popped++;
}","/** 
 * Pops a material from this stack. The material is of the type returned by   {@link #getMaterialType()} and specified in the constructor.
 * @return <code>true</code> if there was a material to be popped from this stack. False otherwise.
 */
public boolean pop(){
  if (grid.popMaterial(position,materialType)) {
    popped++;
    return true;
  }
 else {
    return false;
  }
}"
56014,"@Override protected void action(){
switch (state) {
case JOBLESS:
    break;
case INIT_JOB:
  goToDiggablePosition();
break;
case PLAYING_ACTION:
executeDigg();
if (!requester.isDiggerRequestActive()) {
reportJobless();
break;
}
case GOING_TO_POS:
if (needsToBeWorkedOn(super.getPos())) {
super.playAction(EAction.ACTION1,1f);
this.state=EDiggerState.PLAYING_ACTION;
}
 else {
goToDiggablePosition();
}
break;
case DEAD_OBJECT:
break;
}
}","@Override protected void action(){
switch (state) {
case JOBLESS:
    break;
case INIT_JOB:
  goToDiggablePosition();
break;
case PLAYING_ACTION:
executeDigg();
if (!requester.isDiggerRequestActive()) {
super.getStrategyGrid().setMarked(super.getPos(),false);
reportJobless();
break;
}
case GOING_TO_POS:
if (needsToBeWorkedOn(super.getPos())) {
super.playAction(EAction.ACTION1,1f);
this.state=EDiggerState.PLAYING_ACTION;
}
 else {
goToDiggablePosition();
}
break;
case DEAD_OBJECT:
break;
}
}"
56015,"private boolean goToRandomDirection(Movable pushingMovable){
  int offset=RandomSingleton.getInt(0,EDirection.NUMBER_OF_DIRECTIONS - 1);
  EDirection pushedFromDir=EDirection.getDirection(this.getPos(),pushingMovable.getPos());
  for (int i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
    EDirection currDir=EDirection.values[(i + offset) % EDirection.NUMBER_OF_DIRECTIONS];
    if (currDir != pushedFromDir && goInDirection(currDir)) {
      return true;
    }
  }
  return false;
}","private boolean goToRandomDirection(Movable pushingMovable){
  int offset=RandomSingleton.getInt(0,EDirection.NUMBER_OF_DIRECTIONS - 1);
  EDirection pushedFromDir=EDirection.getDirection(this.getPos(),pushingMovable.getPos());
  for (int i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
    EDirection currDir=EDirection.values[(i + offset) % EDirection.NUMBER_OF_DIRECTIONS];
    if (currDir != pushedFromDir && goInDirection(currDir,false)) {
      return true;
    }
  }
  return false;
}"
56016,"/** 
 * Tries to go a step in the given direction.
 * @param direction direction to go
 * @return true if the step can and will immediately be executed. <br>false if the target position is generally blocked or a movable occupies that position.
 */
final boolean goInDirection(EDirection direction){
  ShortPoint2D pos=direction.getNextHexPoint(position);
  if (grid.isValidPosition(this,pos) && grid.hasNoMovableAt(pos.x,pos.y)) {
    initGoingSingleStep(pos);
    this.direction=direction;
    setState(EMovableState.GOING_SINGLE_STEP);
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Tries to go a step in the given direction.
 * @param direction direction to go
 * @param force If true, the step will be forced and the method will always return true.
 * @return true if the step can and will immediately be executed. <br>false if the target position is generally blocked or a movable occupies that position.
 */
final boolean goInDirection(EDirection direction,boolean force){
  ShortPoint2D pos=direction.getNextHexPoint(position);
  if (force || (grid.isValidPosition(this,pos) && grid.hasNoMovableAt(pos.x,pos.y))) {
    this.direction=direction;
    initGoingSingleStep(pos);
    setState(EMovableState.GOING_SINGLE_STEP);
    return true;
  }
 else {
    return false;
  }
}"
56017,"public void leavePosition(){
  if (!enableNothingToDo) {
    return;
  }
  int offset=RandomSingleton.getInt(0,EDirection.NUMBER_OF_DIRECTIONS - 1);
  for (int i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
    EDirection currDir=EDirection.values[(i + offset) % EDirection.NUMBER_OF_DIRECTIONS];
    if (goInDirection(currDir)) {
      break;
    }
 else {
      Movable movableAtPos=grid.getMovableAt(currDir.getNextTileX(position.x),currDir.getNextTileY(position.y));
      if (movableAtPos != null) {
        movableAtPos.push(this);
      }
    }
  }
}","public void leavePosition(){
  if (!enableNothingToDo) {
    return;
  }
  int offset=RandomSingleton.getInt(0,EDirection.NUMBER_OF_DIRECTIONS - 1);
  for (int i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
    EDirection currDir=EDirection.values[(i + offset) % EDirection.NUMBER_OF_DIRECTIONS];
    if (goInDirection(currDir,false)) {
      break;
    }
 else {
      Movable movableAtPos=grid.getMovableAt(currDir.getNextTileX(position.x),currDir.getNextTileY(position.y));
      if (movableAtPos != null) {
        movableAtPos.push(this);
      }
    }
  }
}"
56018,"/** 
 * Tries to walk the movable into a position where it has a minimum distance to others.
 * @return true if the movable moves to flock, false if no flocking is required.
 */
private boolean flockToDecentralize(){
  ShortPoint2D decentVector=grid.calcDecentralizeVector(position.x,position.y);
  EDirection randomDirection=direction.getNeighbor(RandomSingleton.getInt(-1,1));
  int dx=randomDirection.gridDeltaX + decentVector.x;
  int dy=randomDirection.gridDeltaY + decentVector.y;
  if (ShortPoint2D.getOnGridDist(dx,dy) >= 2) {
    flockDelay=Math.max(flockDelay - 100,500);
    if (this.goInDirection(EDirection.getApproxDirection(0,0,dx,dy))) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    flockDelay=Math.min(flockDelay + 100,1000);
    return false;
  }
}","/** 
 * Tries to walk the movable into a position where it has a minimum distance to others.
 * @return true if the movable moves to flock, false if no flocking is required.
 */
private boolean flockToDecentralize(){
  ShortPoint2D decentVector=grid.calcDecentralizeVector(position.x,position.y);
  EDirection randomDirection=direction.getNeighbor(RandomSingleton.getInt(-1,1));
  int dx=randomDirection.gridDeltaX + decentVector.x;
  int dy=randomDirection.gridDeltaY + decentVector.y;
  if (ShortPoint2D.getOnGridDist(dx,dy) >= 2) {
    flockDelay=Math.max(flockDelay - 100,500);
    if (this.goInDirection(EDirection.getApproxDirection(0,0,dx,dy),false)) {
      return true;
    }
 else {
      return false;
    }
  }
 else {
    flockDelay=Math.min(flockDelay + 100,1000);
    return false;
  }
}"
56019,"/** 
 * Tries to go a step in the given direction.
 * @param direction direction to go
 * @return true if the step can and will immediately be executed. <br>false if the target position is generally blocked or a movable occupies that position.
 */
protected final boolean goInDirection(EDirection direction){
  return movable.goInDirection(direction);
}","/** 
 * Tries to go a step in the given direction.
 * @param direction direction to go
 * @param force If true, the step will be forced and the method will always return true.
 * @return true if the step can and will immediately be executed. <br>false if the target position is generally blocked or a movable occupies that position.
 */
protected final boolean goInDirection(EDirection direction,boolean force){
  return movable.goInDirection(direction,force);
}"
56020,"@Override protected void action(){
  ShortPoint2D position=super.getPos();
  if (!super.isValidPosition(position)) {
    if (searchesCounter > 120) {
      super.getMovable().kill();
      return;
    }
    if (super.preSearchPath(true,position.x,position.y,Constants.MOVABLE_FLEE_TO_VALID_POSITION_RADIUS,ESearchType.VALID_FREE_POSITION)) {
      super.followPresearchedPath();
    }
 else {
      EDirection currentDirection=super.getMovable().getDirection();
      EDirection newDirection;
      if (turnNextTime || RandomSingleton.nextF() < 0.10) {
        turnNextTime=false;
        newDirection=currentDirection.getNeighbor(RandomSingleton.getInt(-1,1));
      }
 else {
        newDirection=currentDirection;
      }
      ShortPoint2D newPos=newDirection.getNextHexPoint(position);
      if (super.getStrategyGrid().isFreePosition(newPos)) {
        super.goInDirection(newDirection);
      }
 else {
        super.lookInDirection(newDirection);
        turnNextTime=true;
      }
    }
    searchesCounter++;
  }
 else {
    super.convertTo(super.getMovable().getMovableType());
  }
}","@Override protected void action(){
  ShortPoint2D position=super.getPos();
  if (!super.isValidPosition(position)) {
    if (searchesCounter > 120) {
      super.getMovable().kill();
      return;
    }
    if (super.preSearchPath(true,position.x,position.y,Constants.MOVABLE_FLEE_TO_VALID_POSITION_RADIUS,ESearchType.VALID_FREE_POSITION)) {
      super.followPresearchedPath();
    }
 else {
      EDirection currentDirection=super.getMovable().getDirection();
      EDirection newDirection;
      if (turnNextTime || RandomSingleton.nextF() < 0.10) {
        turnNextTime=false;
        newDirection=currentDirection.getNeighbor(RandomSingleton.getInt(-1,1));
      }
 else {
        newDirection=currentDirection;
      }
      ShortPoint2D newPos=newDirection.getNextHexPoint(position);
      if (super.getStrategyGrid().isFreePosition(newPos)) {
        super.goInDirection(newDirection,true);
        turnNextTime=RandomSingleton.getInt(7) == 0;
      }
 else {
        super.lookInDirection(newDirection);
        turnNextTime=true;
      }
    }
    searchesCounter++;
  }
 else {
    super.convertTo(super.getMovable().getMovableType());
  }
}"
56021,"private void goToEnemy(IAttackable enemy){
  if (inSaveGotoMode) {
    goToSavely(enemy);
  }
 else {
    ShortPoint2D pos=super.getPos();
    EDirection dir=EDirection.getApproxDirection(pos,enemy.getPos());
    ShortPoint2D nextPos=dir.getNextHexPoint(pos);
    if (super.isValidPosition(nextPos)) {
      super.goInDirection(dir);
      return;
    }
 else {
      goToSavely(enemy);
      inSaveGotoMode=true;
    }
  }
}","private void goToEnemy(IAttackable enemy){
  if (inSaveGotoMode) {
    goToSavely(enemy);
  }
 else {
    ShortPoint2D pos=super.getPos();
    EDirection dir=EDirection.getApproxDirection(pos,enemy.getPos());
    if (super.goInDirection(dir,false)) {
      return;
    }
 else {
      inSaveGotoMode=true;
      goToSavely(enemy);
    }
  }
}"
56022,"private void findWorkablePosition(){
  EDirection closeForeignTileDir=getCloseForeignTile();
  if (closeForeignTileDir != null && super.goInDirection(closeForeignTileDir)) {
    this.state=EPioneerState.GOING_TO_POS;
    return;
  }
  centerPos=null;
  ShortPoint2D pos=super.getPos();
  if (super.preSearchPath(true,pos.x,pos.y,(short)30,ESearchType.UNENFORCED_FOREIGN_GROUND)) {
    super.followPresearchedPath();
    this.state=EPioneerState.GOING_TO_POS;
  }
 else {
    this.state=EPioneerState.JOBLESS;
  }
}","private void findWorkablePosition(){
  EDirection closeForeignTileDir=getCloseForeignTile();
  if (closeForeignTileDir != null && super.goInDirection(closeForeignTileDir,false)) {
    this.state=EPioneerState.GOING_TO_POS;
    return;
  }
  centerPos=null;
  ShortPoint2D pos=super.getPos();
  if (super.preSearchPath(true,pos.x,pos.y,(short)30,ESearchType.UNENFORCED_FOREIGN_GROUND)) {
    super.followPresearchedPath();
    this.state=EPioneerState.GOING_TO_POS;
  }
 else {
    this.state=EPioneerState.JOBLESS;
  }
}"
56023,"/** 
 * Registers the given listener to receive data of the type it specifys with it's getKeys() method.
 * @param listener The listener that shall be registered.
 */
public void registerListener(IChannelListener listener){
  ENetworkKey[] keys=listener.getKeys();
  for (int i=0; i < keys.length; i++) {
    listenerRegistry.put(keys[i],listener);
  }
}","/** 
 * Registers the given listener to receive data of the type it specifies with it's getKeys() method.
 * @param listener The listener that shall be registered.
 */
public void registerListener(IChannelListener listener){
  ENetworkKey[] keys=listener.getKeys();
  for (int i=0; i < keys.length; i++) {
    listenerRegistry.put(keys[i],listener);
  }
}"
56024,"public void playerLeft(Player player){
synchronized (players) {
    players.remove(player);
    sendMatchInfoUpdate(NetworkConstants.ENetworkMessage.PLAYER_LEFT,player.getPlayerInfo());
    player.sendPacket(NetworkConstants.ENetworkKey.MATCH_INFO_UPDATE,generateMatchInfoUpdate(NetworkConstants.ENetworkMessage.PLAYER_LEFT,player.getPlayerInfo()));
    if (isRunning()) {
synchronized (leftPlayers) {
        leftPlayers.add(player);
      }
    }
  }
}","public void playerLeft(Player player){
synchronized (players) {
    players.remove(player);
    sendMatchInfoUpdate(NetworkConstants.ENetworkMessage.PLAYER_LEFT,player.getPlayerInfo());
    player.sendPacket(NetworkConstants.ENetworkKey.MATCH_INFO_UPDATE,generateMatchInfoUpdate(NetworkConstants.ENetworkMessage.PLAYER_LEFT,player.getPlayerInfo()));
    if (isRunning()) {
synchronized (leftPlayers) {
        leftPlayers.add(player);
      }
    }
    if (players.isEmpty()) {
      shutdownMatch();
    }
  }
}"
56025,"public List<? extends T> getItems(){
  return items;
}","public List<T> getItems(){
  return items;
}"
56026,"public void stop(){
  listener=null;
  items=Collections.emptyList();
}","public void stop(){
  listener=null;
  items=new LinkedList<>();
}"
56027,"public ChangingList(List<? extends T> items){
  setList(items);
}","public ChangingList(List<T> items){
  this.items=items;
}"
56028,"public synchronized void setListener(IChangingListListener<T> listener){
  this.listener=listener;
}","public void setListener(IChangingListListener<? super T> listener){
  this.listener=listener;
}"
56029,"public void setList(List<? extends T> items){
  if (items == null) {
    throw new NullPointerException();
  }
  this.items=items;
  informListener();
}","public void setList(List<T> items){
  if (items == null) {
    throw new NullPointerException();
  }
  this.items=items;
  notifyListener();
}"
56030,void listChanged(ChangingList<T> list);,void listChanged(ChangingList<? extends T> list);
56031,"@Override public Component getListCellRendererComponent(JList<? extends IMapDefinition> list,IMapDefinition map,int index,boolean isSelected,boolean hasFocus){
  return new MapDefintionPanel(map.getName(),map.getDescription(),map.getCreationDate(),isSelected);
}","@Override public Component getListCellRendererComponent(JList<? extends IMapDefinition> list,IMapDefinition map,int index,boolean isSelected,boolean hasFocus){
  return new MapDefintionPanel(map.getMapName(),map.getDescription(),map.getCreationDate(),isSelected);
}"
56032,"protected ListModel<IMapDefinition> generateModel(ChangingList<IMapDefinition> maps){
  DefaultListModel<IMapDefinition> model=new DefaultListModel<IMapDefinition>();
  for (  IMapDefinition curr : maps.getItems())   model.addElement(curr);
  return model;
}","protected ListModel<IMapDefinition> generateModel(ChangingList<? extends IMapDefinition> maps){
  DefaultListModel<IMapDefinition> model=new DefaultListModel<IMapDefinition>();
  for (  IMapDefinition curr : maps.getItems())   model.addElement(curr);
  return model;
}"
56033,"@Override public void onDetach(){
  connector.getPlayers().setListener(null);
}","@Override public void onDetach(){
  connector.getPlayers().removeListener(this);
}"
56034,"@Override public void listChanged(ChangingList<IMultiplayerPlayer> list){
  multiplayerList.setItems(list.getItems());
}","@Override public void listChanged(ChangingList<? extends IMultiplayerPlayer> list){
  multiplayerList.setItems(list.getItems());
}"
56035,"public JoinableGameItem(IJoinableGame item){
  super(item.getMap().getName(),item.getId());
}","public JoinableGameItem(IJoinableGame item){
  super(item.getMap().getMapName(),item.getId());
}"
56036,"public LoadableMapListItem(IMapDefinition item){
  super(item.getName(),toPlayerString(item.getPlayers()));
}","public LoadableMapListItem(IMapDefinition item){
  super(item.getMapName(),toPlayerString(item.getPlayers()));
}"
56037,"public void stop(){
  listener=null;
  items=Collections.emptyList();
}","public void stop(){
  listener=null;
  items=new LinkedList<>();
}"
56038,"public synchronized void setListener(IChangingListListener<? super T> listener){
  this.listener=listener;
}","public void setListener(IChangingListListener<? super T> listener){
  this.listener=listener;
}"
56039,"@Override public void onDetach(){
  connector.getPlayers().setListener(null);
}","@Override public void onDetach(){
  connector.getPlayers().removeListener(this);
}"
56040,"@Override public void onDetach(){
  super.onDetach();
  getList().setListener(null);
}","@Override public void onDetach(){
  super.onDetach();
  getList().removeListener(this);
}"
56041,"short getPartitionIdAt(int x,int y);","public abstract short getPartitionIdAt(int x,int y);"
56042,"boolean canConstructAt(short x,short y,EBuildingType type,byte playerId);","public abstract boolean canConstructAt(short x,short y,EBuildingType type,byte playerId);"
56043,"/** 
 * @return height of map
 */
short getHeight();","/** 
 * @return height of map
 */
public abstract short getHeight();"
56044,"/** 
 * Checks if the given position is valid to build a building of given player that can stand on the given   {@link ELandscapeType}s. Bounds checks will be done by this method.
 * @param x x coordinate of the target position
 * @param y y coordinate of the target position
 * @param landscapeTypes allowed landscape types
 * @param partitionId player
 * @return true if a building can be positioned at the given position<br>false otherwise.
 */
boolean canUsePositionForConstruction(int x,int y,ELandscapeType[] landscapeTypes,short partitionId);","/** 
 * Checks if the given position is valid to build a building of given player that can stand on the given   {@link ELandscapeType}s. Bounds checks will be done by this method.
 * @param x x coordinate of the target position
 * @param y y coordinate of the target position
 * @param landscapeTypes allowed landscape types
 * @param partitionId player
 * @return true if a building can be positioned at the given position<br>false otherwise.
 */
public abstract boolean canUsePositionForConstruction(int x,int y,ELandscapeType[] landscapeTypes,short partitionId);"
56045,"byte getConstructionMarkValue(int mapX,int mapY,final RelativePoint[] flattenPositions);","public abstract byte getConstructionMarkValue(int mapX,int mapY,final RelativePoint[] flattenPositions);"
56046,"boolean isInBounds(int x,int y);","public abstract boolean isInBounds(int x,int y);"
56047,"boolean canPlayerConstructOnPartition(byte playerId,short partitionId);","public abstract boolean canPlayerConstructOnPartition(byte playerId,short partitionId);"
56048,"/** 
 * @return width of map.
 */
short getWidth();","/** 
 * @return width of map.
 */
public abstract short getWidth();"
56049,"/** 
 * Sets or removes a construction mark
 * @param x x coordinate
 * @param y y coordinate
 * @param set If true, the construction mark shall be set, otherwise, it shall be removed.
 * @param flattenPositions The positions that need to be flattened to position this building. This value might be null whenever set is false.
 */
void setConstructMarking(int x,int y,boolean set,RelativePoint[] flattenPositions);","/** 
 * Sets or removes a construction mark
 * @param x x coordinate
 * @param y y coordinate
 * @param set If true, the construction mark shall be set, otherwise, it shall be removed.
 * @param flattenPositions The positions that need to be flattened to position this building. This value might be null whenever set is false.
 */
public abstract void setConstructMarking(int x,int y,boolean set,RelativePoint[] flattenPositions);"
56050,"public static void main(String[] args){
  try {
    final File file=new File(args[0]);
    JSettlersGame game=new JSettlersGame(MapLoader.getLoaderForListedMap(new DirectoryMapLister.ListedMapFile(file,false)),123456L,(byte)0,null);
    game.start();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public static void main(String[] args){
  try {
    final File file=new File(args[0]);
    JSettlersGame game=new JSettlersGame(MapLoader.getLoaderForListedMap(new DirectoryMapLister.ListedMapFile(file,false)),123456L,(byte)0,null,null);
    game.start();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
56051,public void notify(int time);,void notify(int time);
56052,"private void initializeBuildingLists(){
  for (  EBuildingType buildingType : EBuildingType.values()) {
    buildingNeeds.put(buildingType,new ArrayList<BuildingCount>());
    buildingIsNeededBy.put(buildingType,new ArrayList<EBuildingType>());
  }
  buildingNeeds.get(SAWMILL).add(new BuildingCount(LUMBERJACK,3));
  buildingNeeds.get(TEMPLE).add(new BuildingCount(WINEGROWER,1));
  buildingNeeds.get(WATERWORKS).add(new BuildingCount(FARM,2));
  buildingNeeds.get(MILL).add(new BuildingCount(FARM,1));
  buildingNeeds.get(BAKER).add(new BuildingCount(MILL,1 / 3));
  buildingNeeds.get(PIG_FARM).add(new BuildingCount(FARM,1));
  buildingNeeds.get(SLAUGHTERHOUSE).add(new BuildingCount(PIG_FARM,1 / 3));
  buildingNeeds.get(IRONMELT).add(new BuildingCount(COALMINE,1));
  buildingNeeds.get(IRONMELT).add(new BuildingCount(IRONMINE,1));
  buildingNeeds.get(WEAPONSMITH).add(new BuildingCount(COALMINE,1));
  buildingNeeds.get(WEAPONSMITH).add(new BuildingCount(IRONMELT,1));
  buildingNeeds.get(GOLDMELT).add(new BuildingCount(GOLDMINE,1));
  buildingNeeds.get(BARRACK).add(new BuildingCount(WEAPONSMITH,4));
  buildingNeeds.get(IRONMINE).add(new BuildingCount(COALMINE,2));
  for (  Map.Entry<EBuildingType,List<BuildingCount>> buildingNeedsEntry : buildingNeeds.entrySet()) {
    for (    BuildingCount neededBuildingCount : buildingNeedsEntry.getValue()) {
      buildingIsNeededBy.get(neededBuildingCount.buildingType).add(buildingNeedsEntry.getKey());
    }
  }
  buildingsToBuild.add(LUMBERJACK);
  buildingsToBuild.add(LUMBERJACK);
  buildingsToBuild.add(SAWMILL);
  buildingsToBuild.add(LUMBERJACK);
  buildingsToBuild.add(FORESTER);
  buildingsToBuild.add(STONECUTTER);
  buildingsToBuild.add(LUMBERJACK);
  buildingsToBuild.add(FORESTER);
  buildingsToBuild.add(LUMBERJACK);
  buildingsToBuild.add(SAWMILL);
  buildingsToBuild.add(LUMBERJACK);
  buildingsToBuild.add(FORESTER);
  buildingsToBuild.add(STONECUTTER);
  buildingsToBuild.add(LUMBERJACK);
  buildingsToBuild.add(LUMBERJACK);
  buildingsToBuild.add(SAWMILL);
  buildingsToBuild.add(FORESTER);
  buildingsToBuild.add(STONECUTTER);
  buildingsToBuild.add(STONECUTTER);
  buildingsToBuild.add(STONECUTTER);
  buildingsToBuild.add(WINEGROWER);
  buildingsToBuild.add(WINEGROWER);
  buildingsToBuild.add(WINEGROWER);
  buildingsToBuild.add(WINEGROWER);
  buildingsToBuild.add(FARM);
  buildingsToBuild.add(FARM);
  buildingsToBuild.add(FARM);
  buildingsToBuild.add(TEMPLE);
  buildingsToBuild.add(TEMPLE);
  buildingsToBuild.add(TEMPLE);
  buildingsToBuild.add(TEMPLE);
  buildingsToBuild.add(WATERWORKS);
  buildingsToBuild.add(MILL);
  buildingsToBuild.add(BAKER);
  buildingsToBuild.add(BAKER);
  buildingsToBuild.add(PIG_FARM);
  buildingsToBuild.add(SLAUGHTERHOUSE);
  buildingsToBuild.add(WATERWORKS);
  buildingsToBuild.add(COALMINE);
  buildingsToBuild.add(IRONMINE);
  buildingsToBuild.add(IRONMELT);
  buildingsToBuild.add(COALMINE);
  buildingsToBuild.add(WEAPONSMITH);
  buildingsToBuild.add(BARRACK);
  buildingsToBuild.add(BIG_TEMPLE);
  buildingsToBuild.add(COALMINE);
  buildingsToBuild.add(IRONMINE);
  buildingsToBuild.add(IRONMELT);
  buildingsToBuild.add(COALMINE);
  buildingsToBuild.add(WEAPONSMITH);
  buildingsToBuild.add(COALMINE);
  buildingsToBuild.add(IRONMINE);
  buildingsToBuild.add(IRONMELT);
  buildingsToBuild.add(COALMINE);
  buildingsToBuild.add(WEAPONSMITH);
  buildingsToBuild.add(FISHER);
  buildingsToBuild.add(COALMINE);
  buildingsToBuild.add(GOLDMINE);
  buildingsToBuild.add(GOLDMELT);
  buildingsToBuild.add(FARM);
  buildingsToBuild.add(FARM);
  buildingsToBuild.add(FARM);
  buildingsToBuild.add(WATERWORKS);
  buildingsToBuild.add(MILL);
  buildingsToBuild.add(BAKER);
  buildingsToBuild.add(BAKER);
  buildingsToBuild.add(PIG_FARM);
  buildingsToBuild.add(WATERWORKS);
  buildingsToBuild.add(COALMINE);
  buildingsToBuild.add(IRONMINE);
  buildingsToBuild.add(IRONMELT);
  buildingsToBuild.add(COALMINE);
  buildingsToBuild.add(WEAPONSMITH);
  buildingsToBuild.add(COALMINE);
  buildingsToBuild.add(IRONMINE);
  buildingsToBuild.add(IRONMELT);
  buildingsToBuild.add(COALMINE);
  buildingsToBuild.add(WEAPONSMITH);
  buildingsToBuild.add(COALMINE);
  buildingsToBuild.add(IRONMINE);
  buildingsToBuild.add(IRONMELT);
  buildingsToBuild.add(COALMINE);
  buildingsToBuild.add(WEAPONSMITH);
  buildingsToBuild.add(BARRACK);
}","private void initializeBuildingLists(){
  for (  EBuildingType buildingType : EBuildingType.values()) {
    buildingNeeds.put(buildingType,new ArrayList<BuildingCount>());
    buildingIsNeededBy.put(buildingType,new ArrayList<EBuildingType>());
  }
  buildingNeeds.get(SAWMILL).add(new BuildingCount(LUMBERJACK,3));
  buildingNeeds.get(TEMPLE).add(new BuildingCount(WINEGROWER,1));
  buildingNeeds.get(MILL).add(new BuildingCount(FARM,1));
  buildingNeeds.get(BAKER).add(new BuildingCount(MILL,(float)1 / 3));
  buildingNeeds.get(PIG_FARM).add(new BuildingCount(FARM,1));
  buildingNeeds.get(SLAUGHTERHOUSE).add(new BuildingCount(PIG_FARM,(float)1 / 3));
  buildingNeeds.get(IRONMELT).add(new BuildingCount(COALMINE,1));
  buildingNeeds.get(IRONMELT).add(new BuildingCount(IRONMINE,1));
  buildingNeeds.get(WEAPONSMITH).add(new BuildingCount(COALMINE,1));
  buildingNeeds.get(WEAPONSMITH).add(new BuildingCount(IRONMELT,1));
  buildingNeeds.get(GOLDMELT).add(new BuildingCount(GOLDMINE,1));
  buildingNeeds.get(BARRACK).add(new BuildingCount(WEAPONSMITH,4));
  buildingNeeds.get(IRONMINE).add(new BuildingCount(COALMINE,2));
  for (  Map.Entry<EBuildingType,List<BuildingCount>> buildingNeedsEntry : buildingNeeds.entrySet()) {
    for (    BuildingCount neededBuildingCount : buildingNeedsEntry.getValue()) {
      buildingIsNeededBy.get(neededBuildingCount.buildingType).add(buildingNeedsEntry.getKey());
    }
  }
  buildingsToBuild.add(LUMBERJACK);
  buildingsToBuild.add(LUMBERJACK);
  buildingsToBuild.add(SAWMILL);
  buildingsToBuild.add(LUMBERJACK);
  buildingsToBuild.add(FORESTER);
  buildingsToBuild.add(STONECUTTER);
  buildingsToBuild.add(LUMBERJACK);
  buildingsToBuild.add(FORESTER);
  buildingsToBuild.add(LUMBERJACK);
  buildingsToBuild.add(SAWMILL);
  buildingsToBuild.add(LUMBERJACK);
  buildingsToBuild.add(FORESTER);
  buildingsToBuild.add(STONECUTTER);
  buildingsToBuild.add(LUMBERJACK);
  buildingsToBuild.add(LUMBERJACK);
  buildingsToBuild.add(SAWMILL);
  buildingsToBuild.add(FORESTER);
  buildingsToBuild.add(STONECUTTER);
  buildingsToBuild.add(STONECUTTER);
  buildingsToBuild.add(STONECUTTER);
  buildingsToBuild.add(WINEGROWER);
  buildingsToBuild.add(WINEGROWER);
  buildingsToBuild.add(WINEGROWER);
  buildingsToBuild.add(WINEGROWER);
  buildingsToBuild.add(FARM);
  buildingsToBuild.add(FARM);
  buildingsToBuild.add(FARM);
  buildingsToBuild.add(TEMPLE);
  buildingsToBuild.add(TEMPLE);
  buildingsToBuild.add(TEMPLE);
  buildingsToBuild.add(TEMPLE);
  buildingsToBuild.add(WATERWORKS);
  buildingsToBuild.add(MILL);
  buildingsToBuild.add(BAKER);
  buildingsToBuild.add(BAKER);
  buildingsToBuild.add(PIG_FARM);
  buildingsToBuild.add(SLAUGHTERHOUSE);
  buildingsToBuild.add(WATERWORKS);
  buildingsToBuild.add(COALMINE);
  buildingsToBuild.add(IRONMINE);
  buildingsToBuild.add(IRONMELT);
  buildingsToBuild.add(COALMINE);
  buildingsToBuild.add(WEAPONSMITH);
  buildingsToBuild.add(BARRACK);
  buildingsToBuild.add(BIG_TEMPLE);
  buildingsToBuild.add(COALMINE);
  buildingsToBuild.add(IRONMINE);
  buildingsToBuild.add(IRONMELT);
  buildingsToBuild.add(COALMINE);
  buildingsToBuild.add(WEAPONSMITH);
  buildingsToBuild.add(COALMINE);
  buildingsToBuild.add(IRONMINE);
  buildingsToBuild.add(IRONMELT);
  buildingsToBuild.add(COALMINE);
  buildingsToBuild.add(WEAPONSMITH);
  buildingsToBuild.add(FISHER);
  buildingsToBuild.add(COALMINE);
  buildingsToBuild.add(GOLDMINE);
  buildingsToBuild.add(GOLDMELT);
  buildingsToBuild.add(FARM);
  buildingsToBuild.add(FARM);
  buildingsToBuild.add(FARM);
  buildingsToBuild.add(WATERWORKS);
  buildingsToBuild.add(MILL);
  buildingsToBuild.add(BAKER);
  buildingsToBuild.add(BAKER);
  buildingsToBuild.add(PIG_FARM);
  buildingsToBuild.add(WATERWORKS);
  buildingsToBuild.add(COALMINE);
  buildingsToBuild.add(IRONMINE);
  buildingsToBuild.add(IRONMELT);
  buildingsToBuild.add(COALMINE);
  buildingsToBuild.add(WEAPONSMITH);
  buildingsToBuild.add(COALMINE);
  buildingsToBuild.add(IRONMINE);
  buildingsToBuild.add(IRONMELT);
  buildingsToBuild.add(COALMINE);
  buildingsToBuild.add(WEAPONSMITH);
  buildingsToBuild.add(COALMINE);
  buildingsToBuild.add(IRONMINE);
  buildingsToBuild.add(IRONMELT);
  buildingsToBuild.add(COALMINE);
  buildingsToBuild.add(WEAPONSMITH);
  buildingsToBuild.add(BARRACK);
}"
56053,"@Override public ShortPoint2D findBestConstructionPosition(AiStatistics aiStatistics,AbstractConstructionMarkableMap constructionMap,byte playerId){
  List<ScoredConstructionPosition> scoredConstructionPositions=new ArrayList<ScoredConstructionPosition>();
  for (  ShortPoint2D point : aiStatistics.getLandForPlayer(playerId)) {
    if (constructionMap.canConstructAt(point.x,point.y,buildingType,playerId) && !aiStatistics.blocksWorkingAreaOfOtherBuilding(point)) {
      ShortPoint2D fishPosition=aiStatistics.getNearestResourcePointForPlayer(point,FISH,playerId);
      if (fishPosition != null) {
        double fishDistance=aiStatistics.getDistance(point,fishPosition);
        scoredConstructionPositions.add(new ScoredConstructionPosition(point,fishDistance));
      }
    }
  }
  return ScoredConstructionPosition.detectPositionWithLowestScore(scoredConstructionPositions);
}","@Override public ShortPoint2D findBestConstructionPosition(AiStatistics aiStatistics,AbstractConstructionMarkableMap constructionMap,byte playerId){
  List<ScoredConstructionPosition> scoredConstructionPositions=new ArrayList<ScoredConstructionPosition>();
  double fishDistance=Double.MAX_VALUE;
  for (  ShortPoint2D point : aiStatistics.getLandForPlayer(playerId)) {
    if (constructionMap.canConstructAt(point.x,point.y,buildingType,playerId) && !aiStatistics.blocksWorkingAreaOfOtherBuilding(point)) {
      ShortPoint2D fishPosition=aiStatistics.getNearestResourcePointForPlayer(point,FISH,playerId,fishDistance);
      if (fishPosition != null) {
        fishDistance=aiStatistics.getDistance(point,fishPosition);
        scoredConstructionPositions.add(new ScoredConstructionPosition(point,fishDistance));
      }
    }
  }
  return ScoredConstructionPosition.detectPositionWithLowestScore(scoredConstructionPositions);
}"
56054,"private ImportantResource detectMostImportantResourcePoints(AiStatistics aiStatistics,byte playerId,ShortPoint2D referencePoint){
  List<ShortPoint2D> trees=aiStatistics.getTreesForPlayer(playerId);
  List<ShortPoint2D> stones=aiStatistics.getStonesForPlayer(playerId);
  List<ShortPoint2D> rivers=aiStatistics.getRiversForPlayer(playerId);
  if (trees.size() < 30) {
    return ImportantResource.TREES;
  }
  if (stones.size() < 7) {
    return ImportantResource.STONES;
  }
  if (rivers.size() < 15) {
    return ImportantResource.RIVER;
  }
  if (aiStatistics.getNearestResourcePointForPlayer(referencePoint,EResourceType.COAL,playerId) == null) {
    return ImportantResource.COAL;
  }
  if (aiStatistics.getNearestResourcePointForPlayer(referencePoint,EResourceType.IRON,playerId) == null) {
    return ImportantResource.IRON;
  }
  if (aiStatistics.getNearestResourcePointForPlayer(referencePoint,EResourceType.FISH,playerId) == null) {
    return ImportantResource.FISH;
  }
  if (aiStatistics.getNearestResourcePointForPlayer(referencePoint,EResourceType.GOLD,playerId) == null) {
    return ImportantResource.GOLD;
  }
  return ImportantResource.COAL;
}","private ImportantResource detectMostImportantResourcePoints(AiStatistics aiStatistics,byte playerId,ShortPoint2D referencePoint){
  List<ShortPoint2D> trees=aiStatistics.getTreesForPlayer(playerId);
  List<ShortPoint2D> stones=aiStatistics.getStonesForPlayer(playerId);
  List<ShortPoint2D> rivers=aiStatistics.getRiversForPlayer(playerId);
  if (trees.size() < 30) {
    return ImportantResource.TREES;
  }
  if (stones.size() < 7) {
    return ImportantResource.STONES;
  }
  if (rivers.size() < 15) {
    return ImportantResource.RIVER;
  }
  if (aiStatistics.getNearestResourcePointForPlayer(referencePoint,EResourceType.COAL,playerId,Double.MAX_VALUE) == null) {
    return ImportantResource.COAL;
  }
  if (aiStatistics.getNearestResourcePointForPlayer(referencePoint,EResourceType.IRON,playerId,Double.MAX_VALUE) == null) {
    return ImportantResource.IRON;
  }
  if (aiStatistics.getNearestResourcePointForPlayer(referencePoint,EResourceType.FISH,playerId,Double.MAX_VALUE) == null) {
    return ImportantResource.FISH;
  }
  if (aiStatistics.getNearestResourcePointForPlayer(referencePoint,EResourceType.GOLD,playerId,Double.MAX_VALUE) == null) {
    return ImportantResource.GOLD;
  }
  return ImportantResource.COAL;
}"
56055,"@Override public ShortPoint2D findBestConstructionPosition(AiStatistics aiStatistics,AbstractConstructionMarkableMap constructionMap,byte playerId){
  List<ShortPoint2D> borderLandNextToFreeLandForPlayer=aiStatistics.getBorderLandNextToFreeLandForPlayer(playerId);
  if (borderLandNextToFreeLandForPlayer.size() == 0) {
    return null;
  }
  ImportantResource importantResource=detectMostImportantResourcePoints(aiStatistics,playerId,borderLandNextToFreeLandForPlayer.get(0));
  List<ShortPoint2D> militaryBuildings=aiStatistics.getBuildingPositionsOfTypeForPlayer(TOWER,playerId);
  militaryBuildings.addAll(aiStatistics.getBuildingPositionsOfTypeForPlayer(BIG_TOWER,playerId));
  militaryBuildings.addAll(aiStatistics.getBuildingPositionsOfTypeForPlayer(CASTLE,playerId));
  double nearestResourcePointDistance=Double.MAX_VALUE;
  List<ScoredConstructionPosition> scoredConstructionPositions=new ArrayList<ScoredConstructionPosition>();
  for (  ShortPoint2D point : borderLandNextToFreeLandForPlayer) {
    if (constructionMap.canConstructAt(point.x,point.y,buildingType,playerId) && !aiStatistics.blocksWorkingAreaOfOtherBuilding(point)) {
      ShortPoint2D nearestResourcePoint;
switch (importantResource) {
case TREES:
        nearestResourcePoint=aiStatistics.getNearestCuttableObjectPointInDefaultPartitionFor(point,EMapObjectType.TREE_ADULT);
      break;
case STONES:
    nearestResourcePoint=aiStatistics.getNearestCuttableObjectPointInDefaultPartitionFor(point,EMapObjectType.STONE);
  break;
case RIVER:
nearestResourcePoint=aiStatistics.getNearestRiverPointInDefaultPartitionFor(point);
break;
case GOLD:
nearestResourcePoint=aiStatistics.getNearestResourcePointInDefaultPartitionFor(point,EResourceType.GOLD);
break;
case FISH:
nearestResourcePoint=aiStatistics.getNearestResourcePointInDefaultPartitionFor(point,EResourceType.FISH);
break;
case IRON:
nearestResourcePoint=aiStatistics.getNearestResourcePointInDefaultPartitionFor(point,EResourceType.IRON);
break;
default :
nearestResourcePoint=aiStatistics.getNearestResourcePointInDefaultPartitionFor(point,EResourceType.COAL,nearestResourcePointDistance);
}
if (nearestResourcePoint != null) {
nearestResourcePointDistance=aiStatistics.getDistance(nearestResourcePoint,point);
ShortPoint2D nearestMilitairyBuildingPosition=aiStatistics.detectNearestPointFromList(point,militaryBuildings);
double militairyBuildingDistance=aiStatistics.getDistance(point,nearestMilitairyBuildingPosition);
scoredConstructionPositions.add(new ScoredConstructionPosition(point,nearestResourcePointDistance - militairyBuildingDistance));
}
}
}
return ScoredConstructionPosition.detectPositionWithLowestScore(scoredConstructionPositions);
}","@Override public ShortPoint2D findBestConstructionPosition(AiStatistics aiStatistics,AbstractConstructionMarkableMap constructionMap,byte playerId){
  List<ShortPoint2D> borderLandNextToFreeLandForPlayer=aiStatistics.getBorderLandNextToFreeLandForPlayer(playerId);
  if (borderLandNextToFreeLandForPlayer.size() == 0) {
    return null;
  }
  ImportantResource importantResource=detectMostImportantResourcePoints(aiStatistics,playerId,borderLandNextToFreeLandForPlayer.get(0));
  List<ShortPoint2D> militaryBuildings=aiStatistics.getBuildingPositionsOfTypeForPlayer(TOWER,playerId);
  militaryBuildings.addAll(aiStatistics.getBuildingPositionsOfTypeForPlayer(BIG_TOWER,playerId));
  militaryBuildings.addAll(aiStatistics.getBuildingPositionsOfTypeForPlayer(CASTLE,playerId));
  double nearestResourcePointDistance=Double.MAX_VALUE;
  List<ScoredConstructionPosition> scoredConstructionPositions=new ArrayList<ScoredConstructionPosition>();
  for (  ShortPoint2D point : borderLandNextToFreeLandForPlayer) {
    if (constructionMap.canConstructAt(point.x,point.y,buildingType,playerId) && !aiStatistics.blocksWorkingAreaOfOtherBuilding(point)) {
      ShortPoint2D nearestResourcePoint;
switch (importantResource) {
case TREES:
        nearestResourcePoint=aiStatistics.getNearestCuttableObjectPointInDefaultPartitionFor(point,EMapObjectType.TREE_ADULT,nearestResourcePointDistance);
      break;
case STONES:
    nearestResourcePoint=aiStatistics.getNearestCuttableObjectPointInDefaultPartitionFor(point,EMapObjectType.STONE,nearestResourcePointDistance);
  break;
case RIVER:
nearestResourcePoint=aiStatistics.getNearestRiverPointInDefaultPartitionFor(point,nearestResourcePointDistance);
break;
case GOLD:
nearestResourcePoint=aiStatistics.getNearestResourcePointInDefaultPartitionFor(point,EResourceType.GOLD,nearestResourcePointDistance);
break;
case FISH:
nearestResourcePoint=aiStatistics.getNearestResourcePointInDefaultPartitionFor(point,EResourceType.FISH,nearestResourcePointDistance);
break;
case IRON:
nearestResourcePoint=aiStatistics.getNearestResourcePointInDefaultPartitionFor(point,EResourceType.IRON,nearestResourcePointDistance);
break;
default :
nearestResourcePoint=aiStatistics.getNearestResourcePointInDefaultPartitionFor(point,EResourceType.COAL,nearestResourcePointDistance);
}
if (nearestResourcePoint != null) {
nearestResourcePointDistance=aiStatistics.getDistance(nearestResourcePoint,point);
ShortPoint2D nearestMilitairyBuildingPosition=aiStatistics.detectNearestPointFromList(point,militaryBuildings);
double militairyBuildingDistance=aiStatistics.getDistance(point,nearestMilitairyBuildingPosition);
scoredConstructionPositions.add(new ScoredConstructionPosition(point,nearestResourcePointDistance - militairyBuildingDistance));
}
}
}
return ScoredConstructionPosition.detectPositionWithLowestScore(scoredConstructionPositions);
}"
56056,"public ShortPoint2D getNearestResourcePointForPlayer(ShortPoint2D point,EResourceType resourceType,byte playerId){
  Map<Integer,List<Integer>> sortedResourcePoints=landscapeGrid.getSortedMapForResourceType(resourceType);
  return getNearestPointInDefaultPartitionOutOfSortedMap(point,sortedResourcePoints,playerId);
}","public ShortPoint2D getNearestResourcePointForPlayer(ShortPoint2D point,EResourceType resourceType,byte playerId,double currentNearestPointDistance){
  Map<Integer,List<Integer>> sortedResourcePoints=landscapeGrid.getSortedMapForResourceType(resourceType);
  return getNearestPointInDefaultPartitionOutOfSortedMap(point,sortedResourcePoints,playerId,currentNearestPointDistance);
}"
56057,"public void updateStatistics(){
  long startTime=System.currentTimeMillis();
  updateBuildingStatistics();
  updateMapStatistics();
  System.out.println(this.getClass().getSimpleName() + ""String_Node_Str"" + Thread.currentThread().getStackTrace()[1].getMethodName()+ ""String_Node_Str""+ (System.currentTimeMillis() - startTime)+ ""String_Node_Str"");
}","public void updateStatistics(){
  updateBuildingStatistics();
  updateMapStatistics();
}"
56058,"public ShortPoint2D getNearestRiverPointInDefaultPartitionFor(ShortPoint2D referencePoint){
  return getNearestPointInDefaultPartitionOutOfSortedMap(referencePoint,sortedRiversInDefaultPartition,(byte)-1);
}","public ShortPoint2D getNearestRiverPointInDefaultPartitionFor(ShortPoint2D referencePoint,double currentNearestPointDistance){
  return getNearestPointInDefaultPartitionOutOfSortedMap(referencePoint,sortedRiversInDefaultPartition,(byte)-1,currentNearestPointDistance);
}"
56059,"public ShortPoint2D getNearestCuttableObjectPointInDefaultPartitionFor(ShortPoint2D point,EMapObjectType cuttableObject){
  Map<Integer,List<Integer>> sortedResourcePoints=sortedCuttableObjectsInDefaultPartition.get(cuttableObject);
  return getNearestPointInDefaultPartitionOutOfSortedMap(point,sortedResourcePoints,(byte)-1);
}","public ShortPoint2D getNearestCuttableObjectPointInDefaultPartitionFor(ShortPoint2D point,EMapObjectType cuttableObject,double currentNearestPointDistance){
  Map<Integer,List<Integer>> sortedResourcePoints=sortedCuttableObjectsInDefaultPartition.get(cuttableObject);
  return getNearestPointInDefaultPartitionOutOfSortedMap(point,sortedResourcePoints,(byte)-1,currentNearestPointDistance);
}"
56060,"@Override protected boolean checkPathStepPreconditions(ShortPoint2D pathTarget,int step){
  boolean result=!((state == ESoldierState.SEARCH_FOR_ENEMIES || state == ESoldierState.HITTING) && step >= 2);
  if (!result && oldPathTarget == null) {
    oldPathTarget=pathTarget;
  }
  if (state == ESoldierState.GOING_TO_TOWER && (!building.isNotDestroyed() || building.getPlayer() != super.getPlayer())) {
    result=false;
  }
  return result;
}","@Override protected boolean checkPathStepPreconditions(ShortPoint2D pathTarget,int step){
  boolean result=!((state == ESoldierState.SEARCH_FOR_ENEMIES || state == ESoldierState.HITTING) && step >= 2);
  if (!result && oldPathTarget == null) {
    oldPathTarget=pathTarget;
  }
  if (state == ESoldierState.GOING_TO_TOWER && (!building.isNotDestroyed() || building.getPlayer() != super.getPlayer())) {
    result=false;
  }
  if (enemy != null && state == ESoldierState.SEARCH_FOR_ENEMIES && isEnemyAttackable(enemy,false)) {
    result=false;
  }
  return result;
}"
56061,"@Override public ShortPoint2D findBestConstructionPosition(AiStatistics aiStatistics,AbstractConstructionMarkableMap constructionMap,byte playerId){
  List<ShortPoint2D> borderLandNextToFreeLandForPlayer=aiStatistics.getBorderLandNextToFreeLandForPlayer(playerId);
  if (borderLandNextToFreeLandForPlayer.size() == 0) {
    return null;
  }
  ImportantResource importantResource=detectMostImportantResourcePoints(aiStatistics,playerId,borderLandNextToFreeLandForPlayer.get(0));
  List<ShortPoint2D> militaryBuildings=aiStatistics.getBuildingPositionsOfTypeForPlayer(TOWER,playerId);
  militaryBuildings.addAll(aiStatistics.getBuildingPositionsOfTypeForPlayer(BIG_TOWER,playerId));
  militaryBuildings.addAll(aiStatistics.getBuildingPositionsOfTypeForPlayer(CASTLE,playerId));
  List<ScoredConstructionPosition> scoredConstructionPositions=new ArrayList<ScoredConstructionPosition>();
  for (  ShortPoint2D point : borderLandNextToFreeLandForPlayer) {
    if (constructionMap.canConstructAt(point.x,point.y,buildingType,playerId) && !aiStatistics.blocksWorkingAreaOfOtherBuilding(point)) {
      ShortPoint2D nearestResourcePoint;
switch (importantResource) {
case TREES:
        nearestResourcePoint=aiStatistics.getNearestCuttableObjectPointInDefaultPartitionFor(point,EMapObjectType.TREE_ADULT);
      break;
case STONES:
    nearestResourcePoint=aiStatistics.getNearestCuttableObjectPointInDefaultPartitionFor(point,EMapObjectType.STONE);
  break;
case RIVER:
nearestResourcePoint=aiStatistics.getNearestRiverPointInDefaultPartitionFor(point);
break;
case GOLD:
nearestResourcePoint=aiStatistics.getNearestResourcePointInDefaultPartitionFor(point,EResourceType.GOLD);
break;
case FISH:
nearestResourcePoint=aiStatistics.getNearestResourcePointInDefaultPartitionFor(point,EResourceType.FISH);
break;
case IRON:
nearestResourcePoint=aiStatistics.getNearestResourcePointInDefaultPartitionFor(point,EResourceType.IRON);
break;
default :
nearestResourcePoint=aiStatistics.getNearestResourcePointInDefaultPartitionFor(point,EResourceType.COAL);
}
double nearestResourcePointDistance=aiStatistics.getDistance(nearestResourcePoint,point);
ShortPoint2D nearestMilitairyBuildingPosition=aiStatistics.detectNearestPointFromList(point,militaryBuildings);
double militairyBuildingDistance=aiStatistics.getDistance(point,nearestMilitairyBuildingPosition);
scoredConstructionPositions.add(new ScoredConstructionPosition(point,nearestResourcePointDistance - militairyBuildingDistance));
}
}
return ScoredConstructionPosition.detectPositionWithLowestScore(scoredConstructionPositions);
}","@Override public ShortPoint2D findBestConstructionPosition(AiStatistics aiStatistics,AbstractConstructionMarkableMap constructionMap,byte playerId){
  List<ShortPoint2D> borderLandNextToFreeLandForPlayer=aiStatistics.getBorderLandNextToFreeLandForPlayer(playerId);
  if (borderLandNextToFreeLandForPlayer.size() == 0) {
    return null;
  }
  ImportantResource importantResource=detectMostImportantResourcePoints(aiStatistics,playerId,borderLandNextToFreeLandForPlayer.get(0));
  List<ShortPoint2D> militaryBuildings=aiStatistics.getBuildingPositionsOfTypeForPlayer(TOWER,playerId);
  militaryBuildings.addAll(aiStatistics.getBuildingPositionsOfTypeForPlayer(BIG_TOWER,playerId));
  militaryBuildings.addAll(aiStatistics.getBuildingPositionsOfTypeForPlayer(CASTLE,playerId));
  double nearestResourcePointDistance=Double.MAX_VALUE;
  List<ScoredConstructionPosition> scoredConstructionPositions=new ArrayList<ScoredConstructionPosition>();
  for (  ShortPoint2D point : borderLandNextToFreeLandForPlayer) {
    if (constructionMap.canConstructAt(point.x,point.y,buildingType,playerId) && !aiStatistics.blocksWorkingAreaOfOtherBuilding(point)) {
      ShortPoint2D nearestResourcePoint;
switch (importantResource) {
case TREES:
        nearestResourcePoint=aiStatistics.getNearestCuttableObjectPointInDefaultPartitionFor(point,EMapObjectType.TREE_ADULT);
      break;
case STONES:
    nearestResourcePoint=aiStatistics.getNearestCuttableObjectPointInDefaultPartitionFor(point,EMapObjectType.STONE);
  break;
case RIVER:
nearestResourcePoint=aiStatistics.getNearestRiverPointInDefaultPartitionFor(point);
break;
case GOLD:
nearestResourcePoint=aiStatistics.getNearestResourcePointInDefaultPartitionFor(point,EResourceType.GOLD);
break;
case FISH:
nearestResourcePoint=aiStatistics.getNearestResourcePointInDefaultPartitionFor(point,EResourceType.FISH);
break;
case IRON:
nearestResourcePoint=aiStatistics.getNearestResourcePointInDefaultPartitionFor(point,EResourceType.IRON);
break;
default :
nearestResourcePoint=aiStatistics.getNearestResourcePointInDefaultPartitionFor(point,EResourceType.COAL,nearestResourcePointDistance);
}
if (nearestResourcePoint != null) {
nearestResourcePointDistance=aiStatistics.getDistance(nearestResourcePoint,point);
ShortPoint2D nearestMilitairyBuildingPosition=aiStatistics.detectNearestPointFromList(point,militaryBuildings);
double militairyBuildingDistance=aiStatistics.getDistance(point,nearestMilitairyBuildingPosition);
scoredConstructionPositions.add(new ScoredConstructionPosition(point,nearestResourcePointDistance - militairyBuildingDistance));
}
}
}
return ScoredConstructionPosition.detectPositionWithLowestScore(scoredConstructionPositions);
}"
56062,"public AiExecutor(List<Byte> aiPlayers,MainGrid mainGrid,ITaskScheduler taskScheduler){
  shutdownRequested=false;
  aiStatistics=new AiStatistics(mainGrid);
  this.whatToDoAis=new ArrayList<IWhatToDoAi>();
  nextExecutionTime=0;
  for (  byte playerId : aiPlayers) {
    whatToDoAis.add(new RomanWhatToDoAi(playerId,aiStatistics,mainGrid,taskScheduler));
  }
}","public AiExecutor(List<Byte> aiPlayers,MainGrid mainGrid,ITaskScheduler taskScheduler){
  aiStatistics=new AiStatistics(mainGrid);
  this.whatToDoAis=new ArrayList<IWhatToDoAi>();
  nextExecutionTime=0;
  for (  byte playerId : aiPlayers) {
    whatToDoAis.add(new RomanWhatToDoAi(playerId,aiStatistics,mainGrid,taskScheduler));
  }
}"
56063,"private ShortPoint2D getNearestPointInDefaultPartitionOutOfSortedMap(ShortPoint2D point,Map<Integer,List<Integer>> sortedPoints,byte playerId){
  ShortPoint2D result=null;
  double currentNearestPointDistance=Double.MAX_VALUE;
  ShortPoint2D nearestRightPoint=getNearestPoinInDefaultPartionOutOfSortedMapInXDirection(point,sortedPoints,currentNearestPointDistance,new Integer(point.x),1,new Integer(mainGrid.getWidth() + 1),playerId);
  if (nearestRightPoint != null) {
    currentNearestPointDistance=getDistance(point,nearestRightPoint);
    result=nearestRightPoint;
  }
  ShortPoint2D nearestLeftPoint=getNearestPoinInDefaultPartionOutOfSortedMapInXDirection(point,sortedPoints,currentNearestPointDistance,new Integer(point.x - 1),-1,-1,playerId);
  if (nearestLeftPoint != null) {
    result=nearestLeftPoint;
  }
  return result;
}","private ShortPoint2D getNearestPointInDefaultPartitionOutOfSortedMap(ShortPoint2D point,Map<Integer,List<Integer>> sortedPoints,byte playerId,double currentNearestPointDistance){
  ShortPoint2D result=null;
  ShortPoint2D nearestRightPoint=getNearestPoinInDefaultPartionOutOfSortedMapInXDirection(point,sortedPoints,currentNearestPointDistance,new Integer(point.x),1,new Integer(mainGrid.getWidth() + 1),playerId);
  if (nearestRightPoint != null) {
    currentNearestPointDistance=getDistance(point,nearestRightPoint);
    result=nearestRightPoint;
  }
  ShortPoint2D nearestLeftPoint=getNearestPoinInDefaultPartionOutOfSortedMapInXDirection(point,sortedPoints,currentNearestPointDistance,new Integer(point.x - 1),-1,-1,playerId);
  if (nearestLeftPoint != null) {
    result=nearestLeftPoint;
  }
  return result;
}"
56064,"public void updateStatistics(){
  updateBuildingStatistics();
  updateMapStatistics();
}","public void updateStatistics(){
  long startTime=System.currentTimeMillis();
  updateBuildingStatistics();
  updateMapStatistics();
  System.out.println(this.getClass().getSimpleName() + ""String_Node_Str"" + Thread.currentThread().getStackTrace()[1].getMethodName()+ ""String_Node_Str""+ (System.currentTimeMillis() - startTime)+ ""String_Node_Str"");
}"
56065,"public ShortPoint2D getNearestResourcePointInDefaultPartitionFor(ShortPoint2D point,EResourceType resourceType){
  Map<Integer,List<Integer>> sortedResourcePoints=landscapeGrid.getSortedMapForResourceType(resourceType);
  return getNearestPointInDefaultPartitionOutOfSortedMap(point,sortedResourcePoints,(byte)-1);
}","public ShortPoint2D getNearestResourcePointInDefaultPartitionFor(ShortPoint2D point,EResourceType resourceType,double currentNearestPointDistance){
  Map<Integer,List<Integer>> sortedResourcePoints=landscapeGrid.getSortedMapForResourceType(resourceType);
  return getNearestPointInDefaultPartitionOutOfSortedMap(point,sortedResourcePoints,(byte)-1,currentNearestPointDistance);
}"
56066,"public void setActiveItem(T activeItem){
  if (items.contains(activeItem)) {
    this.activeItem=activeItem;
  }
}","public void setActiveItem(T activeItem){
synchronized (itemsMutex) {
    if (items.contains(activeItem)) {
      this.activeItem=activeItem;
    }
  }
}"
56067,"public void setItems(List<? extends T> list){
synchronized (itemsMutex) {
    this.items=list;
    if (items.size() > 0) {
      activeItem=items.get(0);
    }
 else {
      activeItem=null;
    }
  }
}","public void setItems(List<? extends T> list){
synchronized (itemsMutex) {
    this.items=list;
    if (!items.contains(activeItem)) {
      if (items.size() > 0) {
        activeItem=items.get(0);
      }
 else {
        activeItem=null;
      }
    }
  }
}"
56068,"/** 
 * Notifies this listener of the current progress of the start. May only be called before   {@link #startFinished(IStartedGame)} is called.
 * @param state
 * @param progress
 */
void startProgressChanged(EProgressState state,float progress);","/** 
 * Notifies this listener of the current progress of the start. May only be called before   {@link #preLoadFinished(IStartedGame)} is called.
 * @param state
 * @param progress
 */
void startProgressChanged(EProgressState state,float progress);"
56069,"/** 
 * Notifies the listener that a game was started and gives it access to the game data.
 * @param game The game that was just started.
 * @retrun A {@link IMapInterfaceConnector} that can be used to access the game afterwards.
 */
IMapInterfaceConnector startFinished(IStartedGame game);",void startFinished();
56070,"@Override public MapInterfaceConnector startFinished(IStartedGame game){
  MapContent content=new MapContent(game,contentSetable.getSoundPlayer());
  contentSetable.setContent(content);
  game.setGameExitListener(new IGameExitListener(){
    @Override public void gameExited(    IStartedGame game){
      contentSetable.goToStartScreen(""String_Node_Str"");
    }
  }
);
  return content.getInterfaceConnector();
}","@Override public void startFinished(){
}"
56071,"@Override public void run(){
  try {
    updateProgressListener(EProgressState.LOADING,0.1f);
    DataOutputStream replayFileStream=createReplayFileStream();
    IGameClock gameClock=MatchConstants.clock=networkConnector.getGameClock();
    gameClock.setReplayLogStream(replayFileStream);
    RandomSingleton.load(randomSeed);
    Movable.resetState();
    updateProgressListener(EProgressState.LOADING_MAP,0.3f);
    Thread imagePreloader=ImageProvider.getInstance().startPreloading();
    MainGridWithUiSettings gridWithUiState=mapCreator.loadMainGrid(availablePlayers);
    mainGrid=gridWithUiState.getMainGrid();
    PlayerState playerState=gridWithUiState.getPlayerState(playerId);
    RescheduleTimer.schedule(gameClock);
    updateProgressListener(EProgressState.LOADING_IMAGES,0.7f);
    statistics=new GameStatistics(gameClock);
    mainGrid.initForPlayer(playerId,playerState.getFogOfWar());
    mainGrid.startThreads();
    if (imagePreloader != null)     imagePreloader.join();
    waitForStartingGameListener();
    updateProgressListener(EProgressState.WAITING_FOR_OTHER_PLAYERS,0.98f);
    if (replayFileInputStream != null) {
      gameClock.loadReplayLogFromStream(replayFileInputStream);
    }
    networkConnector.setStartFinished(true);
    waitForAllPlayersStartFinished(networkConnector);
    final IMapInterfaceConnector connector=startingGameListener.startFinished(this);
    connector.loadUIState(playerState.getUiState());
    GuiInterface guiInterface=new GuiInterface(connector,gameClock,networkConnector.getTaskScheduler(),mainGrid.getGuiInputGrid(),this,playerId,multiplayer);
    gameClock.startExecution();
    gameRunning=true;
synchronized (stopMutex) {
      while (!stopped) {
        try {
          stopMutex.wait();
        }
 catch (        InterruptedException e) {
        }
      }
    }
    networkConnector.shutdown();
    gameClock.stopExecution();
    connector.shutdown();
    mainGrid.stopThreads();
    guiInterface.stop();
    RescheduleTimer.stop();
    Movable.resetState();
    Building.dropAllBuildings();
    System.setErr(systemErrorStream);
    System.setOut(systemOutStream);
  }
 catch (  MapLoadException e) {
    e.printStackTrace();
    reportFail(EGameError.MAPLOADING_ERROR,e);
  }
catch (  Exception e) {
    e.printStackTrace();
    reportFail(EGameError.UNKNOWN_ERROR,e);
  }
 finally {
    if (exitListener != null) {
      exitListener.gameExited(this);
    }
  }
}","@Override public void run(){
  try {
    updateProgressListener(EProgressState.LOADING,0.1f);
    DataOutputStream replayFileStream=createReplayFileStream();
    IGameClock gameClock=MatchConstants.clock=networkConnector.getGameClock();
    gameClock.setReplayLogStream(replayFileStream);
    RandomSingleton.load(randomSeed);
    Movable.resetState();
    updateProgressListener(EProgressState.LOADING_MAP,0.3f);
    Thread imagePreloader=ImageProvider.getInstance().startPreloading();
    MainGridWithUiSettings gridWithUiState=mapCreator.loadMainGrid(availablePlayers);
    mainGrid=gridWithUiState.getMainGrid();
    PlayerState playerState=gridWithUiState.getPlayerState(playerId);
    RescheduleTimer.schedule(gameClock);
    updateProgressListener(EProgressState.LOADING_IMAGES,0.7f);
    statistics=new GameStatistics(gameClock);
    mainGrid.initForPlayer(playerId,playerState.getFogOfWar());
    mainGrid.startThreads();
    if (imagePreloader != null)     imagePreloader.join();
    waitForStartingGameListener();
    updateProgressListener(EProgressState.WAITING_FOR_OTHER_PLAYERS,0.98f);
    if (replayFileInputStream != null) {
      gameClock.loadReplayLogFromStream(replayFileInputStream);
    }
    networkConnector.setStartFinished(true);
    waitForAllPlayersStartFinished(networkConnector);
    final IMapInterfaceConnector connector=startingGameListener.preLoadFinished(this);
    connector.loadUIState(playerState.getUiState());
    GuiInterface guiInterface=new GuiInterface(connector,gameClock,networkConnector.getTaskScheduler(),mainGrid.getGuiInputGrid(),this,playerId,multiplayer);
    gameClock.startExecution();
    gameRunning=true;
    startingGameListener.startFinished();
synchronized (stopMutex) {
      while (!stopped) {
        try {
          stopMutex.wait();
        }
 catch (        InterruptedException e) {
        }
      }
    }
    networkConnector.shutdown();
    gameClock.stopExecution();
    connector.shutdown();
    mainGrid.stopThreads();
    guiInterface.stop();
    RescheduleTimer.stop();
    Movable.resetState();
    Building.dropAllBuildings();
    System.setErr(systemErrorStream);
    System.setOut(systemOutStream);
  }
 catch (  MapLoadException e) {
    e.printStackTrace();
    reportFail(EGameError.MAPLOADING_ERROR,e);
  }
catch (  Exception e) {
    e.printStackTrace();
    reportFail(EGameError.UNKNOWN_ERROR,e);
  }
 finally {
    if (exitListener != null) {
      exitListener.gameExited(this);
    }
  }
}"
56072,"@Override public IMapInterfaceConnector startFinished(IStartedGame game){
  startedGame=game;
synchronized (waitMutex) {
    waitMutex.notifyAll();
  }
  return new DummyMapInterfaceConnector();
}","@Override public void startFinished(){
synchronized (waitMutex) {
    waitMutex.notifyAll();
  }
}"
56073,"@Override public MapInterfaceConnector startFinished(IStartedGame game){
  return getJsettlersActivity().showGameMap(game);
}","@Override public void startFinished(){
}"
56074,"private String getLockstepText(int lockstep){
  int hours=time / (1000 * 60 * 60);
  int minutes=(time / (1000 * 60)) % 60;
  int seconds=(time / 1000) % 60;
  int millis=time % 1000;
  return String.format(""String_Node_Str"",lockstep,time,hours,minutes,seconds,millis);
}","private String getLockstepText(int lockstep){
  int time=lockstep * NetworkConstants.Client.LOCKSTEP_PERIOD;
  int hours=time / (1000 * 60 * 60);
  int minutes=(time / (1000 * 60)) % 60;
  int seconds=(time / 1000) % 60;
  int millis=time % 1000;
  return String.format(""String_Node_Str"",lockstep,time,hours,minutes,seconds,millis);
}"
56075,"@Override public void run(){
  try {
    updateProgressListener(EProgressState.LOADING,0.1f);
    DataOutputStream replayFileStream=createReplayFileStream();
    IGameClock gameClock=MatchConstants.clock=networkConnector.getGameClock();
    gameClock.setReplayLogStream(replayFileStream);
    RandomSingleton.load(randomSeed);
    Movable.resetState();
    updateProgressListener(EProgressState.LOADING_MAP,0.3f);
    Thread imagePreloader=ImageProvider.getInstance().startPreloading();
    MainGridWithUiSettings gridWithUiState=mapCreator.loadMainGrid(availablePlayers);
    mainGrid=gridWithUiState.getMainGrid();
    PlayerState playerState=gridWithUiState.getPlayerState(playerId);
    RescheduleTimer.schedule(gameClock);
    updateProgressListener(EProgressState.LOADING_IMAGES,0.7f);
    statistics=new GameStatistics(gameClock);
    mainGrid.initForPlayer(playerId,playerState.getFogOfWar());
    mainGrid.startThreads();
    if (imagePreloader != null)     imagePreloader.join();
    waitForStartingGameListener();
    updateProgressListener(EProgressState.WAITING_FOR_OTHER_PLAYERS,0.98f);
    networkConnector.setStartFinished(true);
    waitForAllPlayersStartFinished(networkConnector);
    final IMapInterfaceConnector connector=startingGameListener.startFinished(this);
    connector.loadUIState(playerState.getUiState());
    GuiInterface guiInterface=new GuiInterface(connector,gameClock,networkConnector.getTaskScheduler(),mainGrid.getGuiInputGrid(),this,playerId,multiplayer);
    if (replayFileInputStream != null) {
      gameClock.loadReplayLogFromStream(replayFileInputStream);
    }
    gameClock.startExecution();
    gameRunning=true;
synchronized (stopMutex) {
      while (!stopped) {
        try {
          stopMutex.wait();
        }
 catch (        InterruptedException e) {
        }
      }
    }
    networkConnector.shutdown();
    gameClock.stopExecution();
    connector.shutdown();
    mainGrid.stopThreads();
    guiInterface.stop();
    RescheduleTimer.stop();
    Movable.resetState();
    Building.dropAllBuildings();
    System.setErr(systemErrorStream);
    System.setOut(systemOutStream);
  }
 catch (  MapLoadException e) {
    e.printStackTrace();
    reportFail(EGameError.MAPLOADING_ERROR,e);
  }
catch (  Exception e) {
    e.printStackTrace();
    reportFail(EGameError.UNKNOWN_ERROR,e);
  }
 finally {
    if (exitListener != null) {
      exitListener.gameExited(this);
    }
  }
}","@Override public void run(){
  try {
    updateProgressListener(EProgressState.LOADING,0.1f);
    DataOutputStream replayFileStream=createReplayFileStream();
    IGameClock gameClock=MatchConstants.clock=networkConnector.getGameClock();
    gameClock.setReplayLogStream(replayFileStream);
    RandomSingleton.load(randomSeed);
    Movable.resetState();
    updateProgressListener(EProgressState.LOADING_MAP,0.3f);
    Thread imagePreloader=ImageProvider.getInstance().startPreloading();
    MainGridWithUiSettings gridWithUiState=mapCreator.loadMainGrid(availablePlayers);
    mainGrid=gridWithUiState.getMainGrid();
    PlayerState playerState=gridWithUiState.getPlayerState(playerId);
    RescheduleTimer.schedule(gameClock);
    updateProgressListener(EProgressState.LOADING_IMAGES,0.7f);
    statistics=new GameStatistics(gameClock);
    mainGrid.initForPlayer(playerId,playerState.getFogOfWar());
    mainGrid.startThreads();
    if (imagePreloader != null)     imagePreloader.join();
    waitForStartingGameListener();
    updateProgressListener(EProgressState.WAITING_FOR_OTHER_PLAYERS,0.98f);
    if (replayFileInputStream != null) {
      gameClock.loadReplayLogFromStream(replayFileInputStream);
    }
    networkConnector.setStartFinished(true);
    waitForAllPlayersStartFinished(networkConnector);
    final IMapInterfaceConnector connector=startingGameListener.startFinished(this);
    connector.loadUIState(playerState.getUiState());
    GuiInterface guiInterface=new GuiInterface(connector,gameClock,networkConnector.getTaskScheduler(),mainGrid.getGuiInputGrid(),this,playerId,multiplayer);
    gameClock.startExecution();
    gameRunning=true;
synchronized (stopMutex) {
      while (!stopped) {
        try {
          stopMutex.wait();
        }
 catch (        InterruptedException e) {
        }
      }
    }
    networkConnector.shutdown();
    gameClock.stopExecution();
    connector.shutdown();
    mainGrid.stopThreads();
    guiInterface.stop();
    RescheduleTimer.stop();
    Movable.resetState();
    Building.dropAllBuildings();
    System.setErr(systemErrorStream);
    System.setOut(systemOutStream);
  }
 catch (  MapLoadException e) {
    e.printStackTrace();
    reportFail(EGameError.MAPLOADING_ERROR,e);
  }
catch (  Exception e) {
    e.printStackTrace();
    reportFail(EGameError.UNKNOWN_ERROR,e);
  }
 finally {
    if (exitListener != null) {
      exitListener.gameExited(this);
    }
  }
}"
56076,"private void pathingAction(){
  if (!path.hasNextStep() || !strategy.checkPathStepPreconditions(path.getTargetPos(),path.getStep())) {
    setState(EMovableState.DOING_NOTHING);
    movableAction=EAction.NO_ACTION;
    path=null;
    checkPlayerOfCurrentPosition();
    return;
  }
  direction=EDirection.getDirection(position.x,position.y,path.nextX(),path.nextY());
  if (grid.hasNoMovableAt(path.nextX(),path.nextY())) {
    if (!grid.isValidNextPathPosition(this,path.getNextPos(),path.getTargetPos())) {
      Path newPath=grid.calculatePathTo(this,path.getTargetPos());
      if (newPath == null) {
        setState(EMovableState.DOING_NOTHING);
        movableAction=EAction.NO_ACTION;
        strategy.pathAborted(path.getTargetPos());
        path=null;
        return;
      }
 else {
        this.path=newPath;
      }
    }
    goSinglePathStep();
  }
 else {
    movableAction=EAction.NO_ACTION;
    boolean pushedSuccessful=grid.getMovableAt(path.nextX(),path.nextY()).push(this);
    if (!pushedSuccessful) {
      path=strategy.findWayAroundObstacle(direction,position,path);
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
    }
  }
}","private void pathingAction(){
  if (!path.hasNextStep() || !strategy.checkPathStepPreconditions(path.getTargetPos(),path.getStep())) {
    setState(EMovableState.DOING_NOTHING);
    movableAction=EAction.NO_ACTION;
    path=null;
    checkPlayerOfCurrentPosition();
    return;
  }
  direction=EDirection.getDirection(position.x,position.y,path.nextX(),path.nextY());
  if (grid.hasNoMovableAt(path.nextX(),path.nextY())) {
    if (!grid.isValidNextPathPosition(this,path.getNextPos(),path.getTargetPos())) {
      Path newPath=grid.calculatePathTo(this,path.getTargetPos());
      if (newPath == null) {
        setState(EMovableState.DOING_NOTHING);
        movableAction=EAction.NO_ACTION;
        strategy.pathAborted(path.getTargetPos());
        path=null;
        return;
      }
 else {
        this.path=newPath;
      }
    }
    goSinglePathStep();
  }
 else {
    movableAction=EAction.NO_ACTION;
    boolean pushedSuccessful=grid.getMovableAt(path.nextX(),path.nextY()).push(this);
    if (!pushedSuccessful) {
      path=strategy.findWayAroundObstacle(direction,position,path);
    }
 else     if (movableAction == EAction.NO_ACTION) {
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
    }
  }
}"
56077,"@Override public Path searchDijkstra(IPathCalculatable pathCalculateable,short centerX,short centerY,short radius,ESearchType searchType){
  return dijkstra.find(pathCalculateable,centerX,centerY,(short)1,radius,searchType);
}","@Override public Path searchDijkstra(IPathCalculatable pathCalculateable,short centerX,short centerY,short radius,ESearchType searchType){
  return dijkstra.find(pathCalculateable,centerX,centerY,(short)0,radius,searchType);
}"
56078,"private void pathingAction(){
  if (!path.hasNextStep() || !strategy.checkPathStepPreconditions(path.getTargetPos(),path.getStep())) {
    setState(EMovableState.DOING_NOTHING);
    movableAction=EAction.NO_ACTION;
    path=null;
    checkPlayerOfCurrentPosition();
    return;
  }
  direction=EDirection.getDirection(position.x,position.y,path.nextX(),path.nextY());
  if (grid.hasNoMovableAt(path.nextX(),path.nextY())) {
    if (!grid.isValidNextPathPosition(this,path.getNextPos(),path.getTargetPos())) {
      Path newPath=grid.calculatePathTo(this,path.getTargetPos());
      if (newPath == null) {
        setState(EMovableState.DOING_NOTHING);
        movableAction=EAction.NO_ACTION;
        strategy.pathAborted(path.getTargetPos());
        path=null;
        return;
      }
 else {
        this.path=newPath;
      }
    }
    goSinglePathStep();
  }
 else {
    movableAction=EAction.NO_ACTION;
    boolean pushedSuccessful=grid.getMovableAt(path.nextX(),path.nextY()).push(this);
    if (!pushedSuccessful) {
      path=strategy.findWayAroundObstacle(direction,position,path);
    }
  }
}","private void pathingAction(){
  if (!path.hasNextStep() || !strategy.checkPathStepPreconditions(path.getTargetPos(),path.getStep())) {
    setState(EMovableState.DOING_NOTHING);
    movableAction=EAction.NO_ACTION;
    path=null;
    checkPlayerOfCurrentPosition();
    return;
  }
  direction=EDirection.getDirection(position.x,position.y,path.nextX(),path.nextY());
  if (grid.hasNoMovableAt(path.nextX(),path.nextY())) {
    if (!grid.isValidNextPathPosition(this,path.getNextPos(),path.getTargetPos())) {
      Path newPath=grid.calculatePathTo(this,path.getTargetPos());
      if (newPath == null) {
        setState(EMovableState.DOING_NOTHING);
        movableAction=EAction.NO_ACTION;
        strategy.pathAborted(path.getTargetPos());
        path=null;
        return;
      }
 else {
        this.path=newPath;
      }
    }
    goSinglePathStep();
  }
 else {
    movableAction=EAction.NO_ACTION;
    boolean pushedSuccessful=grid.getMovableAt(path.nextX(),path.nextY()).push(this);
    if (!pushedSuccessful) {
      path=strategy.findWayAroundObstacle(direction,position,path);
      animationDuration=Constants.MOVABLE_INTERRUPT_PERIOD;
    }
  }
}"
56079,"@Override public final void debug(){
  System.out.println(""String_Node_Str"");
}","@Override public final void debug(){
  System.out.println(""String_Node_Str"" + this);
}"
56080,"protected void play(){
  try {
    File temp=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    data.doPreSaveActions();
    MapSaver.saveMap(generateMapHeader(),data,new FileOutputStream(temp));
    String[] args=new String[]{""String_Node_Str"",""String_Node_Str"",System.getProperty(""String_Node_Str""),SwingManagedJSettlers.class.getName(),""String_Node_Str"" + temp.getAbsolutePath()};
    System.out.println(""String_Node_Str"");
    for (    String arg : args) {
      System.out.print(arg + ""String_Node_Str"");
    }
    System.out.println();
    File working=new File(""String_Node_Str"").getAbsoluteFile();
    System.out.println(""String_Node_Str"" + working);
    ProcessBuilder builder=new ProcessBuilder(args);
    builder.directory(working);
    builder.redirectErrorStream(true);
    final Process process=builder.start();
    new Thread(new Runnable(){
      @Override public void run(){
        BufferedReader reader=new BufferedReader(new InputStreamReader(process.getInputStream()));
        while (true) {
          String line;
          try {
            line=reader.readLine();
          }
 catch (          IOException e) {
            break;
          }
          if (line == null) {
            break;
          }
          System.out.println(""String_Node_Str"" + line);
        }
      }
    }
,""String_Node_Str"");
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","protected void play(){
  try {
    File temp=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
    data.doPreSaveActions();
    MapSaver.saveMap(generateMapHeader(),data,new FileOutputStream(temp));
    String[] args=new String[]{""String_Node_Str"",""String_Node_Str"",System.getProperty(""String_Node_Str""),SwingManagedJSettlers.class.getName(),""String_Node_Str"" + temp.getAbsolutePath()};
    System.out.println(""String_Node_Str"");
    for (    String arg : args) {
      System.out.print(arg + ""String_Node_Str"");
    }
    System.out.println();
    ProcessBuilder builder=new ProcessBuilder(args);
    builder.redirectErrorStream(true);
    final Process process=builder.start();
    new Thread(new Runnable(){
      @Override public void run(){
        BufferedReader reader=new BufferedReader(new InputStreamReader(process.getInputStream()));
        while (true) {
          String line;
          try {
            line=reader.readLine();
          }
 catch (          IOException e) {
            break;
          }
          if (line == null) {
            break;
          }
          System.out.println(""String_Node_Str"" + line);
        }
      }
    }
,""String_Node_Str"");
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}"
56081,"public String[] getSndFolders(){
  return getFolders(""String_Node_Str"");
}","public String[] getSndFolders(){
  return getFolders(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}"
56082,"private String[] getFolders(String string){
  String[] result=properties.getProperty(""String_Node_Str"").split(SPLIT_CHARACTER);
  for (int i=0; i < result.length; i++) {
    result[i]=result[i].replaceFirst(""String_Node_Str"",""String_Node_Str"" + string);
  }
  return result;
}","private String[] getFolders(String... subfolders){
  String[] settlersFolder=properties.getProperty(""String_Node_Str"").split(SPLIT_CHARACTER);
  String[] result=new String[settlersFolder.length * subfolders.length];
  int resultIdx=0;
  for (int subfolderIdx=0; subfolderIdx < subfolders.length; subfolderIdx++) {
    for (int folderIdx=0; folderIdx < settlersFolder.length; folderIdx++) {
      result[resultIdx++]=settlersFolder[folderIdx].replaceFirst(""String_Node_Str"",""String_Node_Str"" + subfolders[subfolderIdx]);
    }
  }
  return result;
}"
56083,"public String[] getGfxFolders(){
  return getFolders(""String_Node_Str"");
}","public String[] getGfxFolders(){
  return getFolders(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}"
56084,"private void handleBricklayerRequest(){
  BricklayerRequest bricklayerRequest=bricklayerRequests.poll();
  if (bricklayerRequest != null && !bricklayerRequest.building.isConstructionFinished()) {
    IManageableBricklayer bricklayer=joblessBricklayers.removeObjectNextTo(bricklayerRequest.getPos());
    if (bricklayer != null) {
      if (!bricklayer.setBricklayerJob(bricklayerRequest.building,bricklayerRequest.bricklayerTargetPos,bricklayerRequest.direction)) {
        bricklayerRequests.add(bricklayerRequest);
      }
    }
 else {
      createNewToolUserIfLimitNotExceeded(EMovableType.BRICKLAYER,bricklayerRequest.getPos());
      bricklayerRequests.offerLast(bricklayerRequest);
    }
  }
}","private void handleBricklayerRequest(){
  BricklayerRequest bricklayerRequest=bricklayerRequests.poll();
  if (bricklayerRequest != null && !bricklayerRequest.building.isConstructionFinished()) {
    IManageableBricklayer bricklayer=joblessBricklayers.removeObjectNextTo(bricklayerRequest.getPos());
    if (bricklayer != null) {
      if (!bricklayer.setBricklayerJob(bricklayerRequest.building,bricklayerRequest.bricklayerTargetPos,bricklayerRequest.direction)) {
        bricklayerRequests.add(bricklayerRequest);
      }
    }
 else     if (!bricklayerRequest.isCreationRequested()) {
      createNewToolUserIfLimitNotExceeded(EMovableType.BRICKLAYER,bricklayerRequest.getPos());
      bricklayerRequest.creationRequested();
      bricklayerRequests.offerLast(bricklayerRequest);
    }
 else {
      bricklayerRequests.offerLast(bricklayerRequest);
    }
  }
}"
56085,"@Override public final boolean setBuilding(ShortPoint2D position,Building newBuilding){
  if (MainGrid.this.isInBounds(position.x,position.y)) {
    FreeMapArea protectedArea=new FreeMapArea(position,newBuilding.getBuildingType().getProtectedTiles());
    if (canConstructAt(protectedArea)) {
      setProtectedState(protectedArea,true);
      mapObjectsManager.addBuildingTo(position,newBuilding);
      objectsGrid.setBuildingArea(new FreeMapArea(position,newBuilding.getBuildingType().getBlockedTiles()),newBuilding);
      return true;
    }
 else {
      return false;
    }
  }
 else {
    return false;
  }
}","@Override public final boolean setBuilding(ShortPoint2D position,Building newBuilding){
  if (MainGrid.this.isInBounds(position.x,position.y)) {
    FreeMapArea protectedArea=new FreeMapArea(position,newBuilding.getBuildingType().getProtectedTiles());
    if (canConstructAt(protectedArea)) {
      setProtectedState(protectedArea,true);
      mapObjectsManager.addBuildingTo(position,newBuilding);
      objectsGrid.setBuildingArea(protectedArea,newBuilding);
      return true;
    }
 else {
      return false;
    }
  }
 else {
    return false;
  }
}"
56086,"@Override public final void removeBuildingAt(ShortPoint2D pos){
  IBuilding building=(IBuilding)objectsGrid.getMapObjectAt(pos.x,pos.y,EMapObjectType.BUILDING);
  mapObjectsManager.removeMapObjectType(pos.x,pos.y,EMapObjectType.BUILDING);
  FreeMapArea area=new FreeMapArea(pos,building.getBuildingType().getProtectedTiles());
  objectsGrid.setBuildingArea(area,null);
  for (  ShortPoint2D curr : area) {
    short x=curr.x;
    short y=curr.y;
    if (isInBounds(x,y)) {
      flagsGrid.setBlockedAndProtected(x,y,false);
    }
  }
}","@Override public final void removeBuildingAt(ShortPoint2D pos){
  IBuilding building=(IBuilding)objectsGrid.getMapObjectAt(pos.x,pos.y,EMapObjectType.BUILDING);
  mapObjectsManager.removeMapObjectType(pos.x,pos.y,EMapObjectType.BUILDING);
  FreeMapArea area=new FreeMapArea(pos,building.getBuildingType().getProtectedTiles());
  objectsGrid.setBuildingArea(area,null);
  for (  ShortPoint2D curr : area) {
    short x=curr.x;
    short y=curr.y;
    if (isInBounds(x,y)) {
      StackMapObject stack=(StackMapObject)objectsGrid.getMapObjectAt(x,y,EMapObjectType.STACK_OBJECT);
      flagsGrid.setBlockedAndProtected(x,y,false,stack != null);
    }
  }
}"
56087,"/** 
 * sets this position blocked and protected.
 * @param x x coordinate
 * @param y y coordinate
 * @param blocked the position will be set to blocked and protected if blocked == true<br> otherwise it will be set to unblocked and unprotected.
 */
public void setBlockedAndProtected(int x,int y,boolean blocked){
  final int idx=x + y * width;
  this.blockedGrid.set(idx,blocked);
  this.protectedGrid.set(idx,blocked);
  if (blockingChangedListener != null) {
    this.blockingChangedListener.blockingChanged(x,y,blocked);
  }
  if (protectedChangedListener != null) {
    this.protectedChangedListener.protectedChanged(x,y,blocked);
  }
}","/** 
 * Sets this position's blocked and protected.
 * @param x x coordinate
 * @param y y coordinate
 * @param blocked new blocked value of this position
 * @param newProtected new protected value of this position
 */
public void setBlockedAndProtected(int x,int y,boolean blocked,boolean newProtected){
  final int idx=x + y * width;
  this.blockedGrid.set(idx,blocked);
  this.protectedGrid.set(idx,newProtected);
  if (blockingChangedListener != null) {
    this.blockingChangedListener.blockingChanged(x,y,blocked);
  }
  if (protectedChangedListener != null) {
    this.protectedChangedListener.protectedChanged(x,y,newProtected);
  }
}"
56088,"private final void removeStackObject(short x,short y,StackMapObject stackObject){
  removeMapObject(x,y,stackObject);
  if (grid.getMapObject(x,y,EMapObjectType.STACK_OBJECT) == null) {
    grid.setProtected(x,y,false);
  }
}","private final void removeStackObject(short x,short y,StackMapObject stackObject){
  removeMapObject(x,y,stackObject);
  if (!grid.isBuildingAreaAt(x,y) && grid.getMapObject(x,y,EMapObjectType.STACK_OBJECT) == null) {
    grid.setProtected(x,y,false);
  }
}"
56089,"private void reoffer(){
  super.getStrategyGrid().takeMaterial(offer,materialType);
  super.getStrategyGrid().dropMaterial(offer,materialType,true);
}","private void reoffer(){
  if (super.getStrategyGrid().takeMaterial(offer,materialType)) {
    super.getStrategyGrid().dropMaterial(offer,materialType,true);
  }
}"
56090,"/** 
 * Schedules the given   {@link IScheduledTimerable} in max delay milliseconds.
 * @param t
 * @param delay
 */
public static void add(IScheduledTimerable t,int delay){
  get().add_(t,delay);
}","/** 
 * Schedules the given   {@link IScheduledTimerable} in max delay milliseconds.
 * @param t
 * @param delay
 */
public static void add(IScheduledTimerable t,int delay){
  get().addTimerable(t,delay);
}"
56091,"@Override public void timerEvent(){
  ArrayList<IScheduledTimerable> queue=timerables[currTimeSlot];
  for (  IScheduledTimerable curr : queue) {
    try {
      int delay=curr.timerEvent();
      add_(curr,delay);
    }
 catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
      try {
        curr.kill();
      }
 catch (      Throwable t2) {
        System.err.println(""String_Node_Str"");
        t2.printStackTrace();
      }
    }
  }
  queue.clear();
  currTimeSlot=(currTimeSlot + 1) % TIME_SLOTS;
}","@Override public void timerEvent(){
  ArrayList<IScheduledTimerable> queue=timerables[currTimeSlot];
  for (  IScheduledTimerable curr : queue) {
    try {
      int delay=curr.timerEvent();
      addTimerable(curr,delay);
    }
 catch (    Throwable t) {
      System.err.println(""String_Node_Str"");
      t.printStackTrace();
      try {
        curr.kill();
      }
 catch (      Throwable t2) {
        System.err.println(""String_Node_Str"");
        t2.printStackTrace();
      }
    }
  }
  queue.clear();
  currTimeSlot=(currTimeSlot + 1) % TIME_SLOTS;
}"
56092,"public Thread startPreloading(){
  Thread thread=new Thread(new ImagePreloadTask(),""String_Node_Str"");
  thread.start();
  return thread;
}","/** 
 * Starts preloading the images, if lookup paths have been set.
 * @return
 */
public Thread startPreloading(){
  if (!lookupPaths.isEmpty()) {
    Thread thread=new Thread(new ImagePreloadTask(),""String_Node_Str"");
    thread.start();
    return thread;
  }
 else {
    return null;
  }
}"
56093,"@Override public void run(){
  try {
    updateProgressListener(EProgressState.LOADING,0.1f);
    DataOutputStream replayFileStream=createReplayFileStream();
    IGameClock gameClock=MatchConstants.clock=networkConnector.getGameClock();
    gameClock.setReplayLogStream(replayFileStream);
    RandomSingleton.load(randomSeed);
    Movable.resetState();
    updateProgressListener(EProgressState.LOADING_MAP,0.3f);
    Thread imagePreloader=ImageProvider.getInstance().startPreloading();
    MainGridWithUiSettings gridWithUiState=mapcreator.loadMainGrid(availablePlayers);
    mainGrid=gridWithUiState.getMainGrid();
    PlayerState playerState=gridWithUiState.getPlayerState(playerId);
    RescheduleTimer.schedule(gameClock);
    updateProgressListener(EProgressState.LOADING_IMAGES,0.7f);
    statistics=new GameStatistics(gameClock);
    mainGrid.initForPlayer(playerId,playerState.getFogOfWar());
    mainGrid.startThreads();
    imagePreloader.join();
    waitForStartingGameListener();
    updateProgressListener(EProgressState.WAITING_FOR_OTHER_PLAYERS,0.98f);
    networkConnector.setStartFinished(true);
    waitForAllPlayersStartFinished(networkConnector);
    final IMapInterfaceConnector connector=startingGameListener.startFinished(this);
    connector.loadUIState(playerState.getUiState());
    GuiInterface guiInterface=new GuiInterface(connector,gameClock,networkConnector.getTaskScheduler(),mainGrid.getGuiInputGrid(),this,playerId,multiplayer);
    if (replayFileInputStream != null) {
      gameClock.loadReplayLogFromStream(replayFileInputStream);
    }
    gameClock.startExecution();
    gameRunning=true;
synchronized (stopMutex) {
      while (!stopped) {
        try {
          stopMutex.wait();
        }
 catch (        InterruptedException e) {
        }
      }
    }
    networkConnector.shutdown();
    gameClock.stopExecution();
    connector.shutdown();
    mainGrid.stopThreads();
    guiInterface.stop();
    RescheduleTimer.stop();
    Movable.resetState();
    Building.dropAllBuildings();
  }
 catch (  MapLoadException e) {
    e.printStackTrace();
    reportFail(EGameError.MAPLOADING_ERROR,e);
  }
catch (  Exception e) {
    e.printStackTrace();
    reportFail(EGameError.UNKNOWN_ERROR,e);
  }
  if (exitListener != null) {
    exitListener.gameExited(this);
  }
}","@Override public void run(){
  try {
    updateProgressListener(EProgressState.LOADING,0.1f);
    DataOutputStream replayFileStream=createReplayFileStream();
    IGameClock gameClock=MatchConstants.clock=networkConnector.getGameClock();
    gameClock.setReplayLogStream(replayFileStream);
    RandomSingleton.load(randomSeed);
    Movable.resetState();
    updateProgressListener(EProgressState.LOADING_MAP,0.3f);
    Thread imagePreloader=ImageProvider.getInstance().startPreloading();
    MainGridWithUiSettings gridWithUiState=mapcreator.loadMainGrid(availablePlayers);
    mainGrid=gridWithUiState.getMainGrid();
    PlayerState playerState=gridWithUiState.getPlayerState(playerId);
    RescheduleTimer.schedule(gameClock);
    updateProgressListener(EProgressState.LOADING_IMAGES,0.7f);
    statistics=new GameStatistics(gameClock);
    mainGrid.initForPlayer(playerId,playerState.getFogOfWar());
    mainGrid.startThreads();
    if (imagePreloader != null)     imagePreloader.join();
    waitForStartingGameListener();
    updateProgressListener(EProgressState.WAITING_FOR_OTHER_PLAYERS,0.98f);
    networkConnector.setStartFinished(true);
    waitForAllPlayersStartFinished(networkConnector);
    final IMapInterfaceConnector connector=startingGameListener.startFinished(this);
    connector.loadUIState(playerState.getUiState());
    GuiInterface guiInterface=new GuiInterface(connector,gameClock,networkConnector.getTaskScheduler(),mainGrid.getGuiInputGrid(),this,playerId,multiplayer);
    if (replayFileInputStream != null) {
      gameClock.loadReplayLogFromStream(replayFileInputStream);
    }
    gameClock.startExecution();
    gameRunning=true;
synchronized (stopMutex) {
      while (!stopped) {
        try {
          stopMutex.wait();
        }
 catch (        InterruptedException e) {
        }
      }
    }
    networkConnector.shutdown();
    gameClock.stopExecution();
    connector.shutdown();
    mainGrid.stopThreads();
    guiInterface.stop();
    RescheduleTimer.stop();
    Movable.resetState();
    Building.dropAllBuildings();
  }
 catch (  MapLoadException e) {
    e.printStackTrace();
    reportFail(EGameError.MAPLOADING_ERROR,e);
  }
catch (  Exception e) {
    e.printStackTrace();
    reportFail(EGameError.UNKNOWN_ERROR,e);
  }
  if (exitListener != null) {
    exitListener.gameExited(this);
  }
}"
56094,"/** 
 * Gets the geometry of the background as array.
 * @param boundbuffer The buffer of opengl.
 * @param context The context to use.
 * @return The geometry as float array.
 */
private void reloadGeometry(GLBuffer boundbuffer,MapRectangle area,MapDrawContext context){
  boolean hasInvalidFields=!geometryInvalid.isEmpty();
  int width=context.getMap().getWidth();
  int height=context.getMap().getHeight();
  int oldbuffertop=0;
  int oldbufferbottom=0;
  if (oldBufferPosition != null) {
    oldbuffertop=oldBufferPosition.getLineY(0);
    oldbufferbottom=oldbuffertop + bufferheight;
  }
  for (int line=0; line < bufferheight; line++) {
    int y=area.getLineY(line);
    int minx=area.getLineStartX(line);
    int maxx=minx + bufferwidth;
    int oldminx=0;
    int oldmaxx=0;
    if (y >= oldbuffertop && y < oldbufferbottom) {
      oldminx=oldBufferPosition.getLineStartX(y - oldbuffertop);
      oldmaxx=oldminx + bufferwidth;
    }
    boolean lineIsInMap=y >= 0 && y < height;
    for (int x=minx; x < maxx; x++) {
      int bufferPosition=getBufferPosition(y,x);
      if (oldminx > x || oldmaxx <= x) {
        redrawPoint(boundbuffer,context,x,y,false,bufferPosition);
      }
 else       if (lineIsInMap && x >= 0 && x < width) {
        if (hasInvalidFields) {
          boolean invalid=false;
synchronized (this) {
            invalid=geometryInvalid.get(bufferPosition);
            geometryInvalid.clear(bufferPosition);
          }
          if (invalid) {
            redrawPoint(boundbuffer,context,x,y,true,bufferPosition);
          }
        }
 else         if (context.getVisibleStatus(x,y) != fogOfWarStatus[bufferPosition * 4]) {
          redrawPoint(boundbuffer,context,x,y,true,bufferPosition);
          invalidatePoint(x - 1,y);
          invalidatePoint(x - 1,y - 1);
          invalidatePoint(x - 1,y - 1);
        }
      }
    }
  }
  oldBufferPosition=area;
}","/** 
 * Gets the geometry of the background as array.
 * @param boundbuffer The buffer of opengl.
 * @param context The context to use.
 * @return The geometry as float array.
 */
private void reloadGeometry(GLBuffer boundbuffer,MapRectangle area,MapDrawContext context){
  boolean hasInvalidFields=!geometryInvalid.isEmpty();
  int width=context.getMap().getWidth();
  int height=context.getMap().getHeight();
  int oldbuffertop=oldBufferPosition.getLineY(0);
  int oldbufferbottom=oldbuffertop + bufferheight;
  for (int line=0; line < bufferheight; line++) {
    int y=area.getLineY(line);
    int minx=area.getLineStartX(line);
    int maxx=minx + bufferwidth;
    int oldminx=0;
    int oldmaxx=0;
    if (y >= oldbuffertop && y < oldbufferbottom) {
      oldminx=oldBufferPosition.getLineStartX(y - oldbuffertop);
      oldmaxx=oldminx + bufferwidth;
    }
    boolean lineIsInMap=y >= 0 && y < height;
    for (int x=minx; x < maxx; x++) {
      int bufferPosition=getBufferPosition(y,x);
      if (oldminx > x || oldmaxx <= x) {
        redrawPoint(boundbuffer,context,x,y,false,bufferPosition);
      }
 else       if (lineIsInMap && x >= 0 && x < width) {
        if (hasInvalidFields) {
          boolean invalid=false;
synchronized (this) {
            invalid=geometryInvalid.get(bufferPosition);
            geometryInvalid.clear(bufferPosition);
          }
          if (invalid) {
            redrawPoint(boundbuffer,context,x,y,true,bufferPosition);
          }
        }
 else         if (context.getVisibleStatus(x,y) != fogOfWarStatus[bufferPosition * 4]) {
          redrawPoint(boundbuffer,context,x,y,true,bufferPosition);
          invalidatePoint(x - 1,y);
          invalidatePoint(x - 1,y - 1);
          invalidatePoint(x - 1,y - 1);
        }
      }
    }
  }
  oldBufferPosition=area;
}"
56095,"/** 
 * Draws a given map content.
 * @param context The context to draw at.
 * @param screen2
 */
public void drawMapContent(MapDrawContext context,FloatRectangle screen){
  GLDrawContext gl=context.getGl();
  MapRectangle screenArea=context.getConverter().getMapForScreen(screen);
  if (!gl.isGeometryValid(geometryindex) || screenArea.getLineLength() + 1 != bufferwidth || screenArea.getLines() != bufferheight) {
    regenerateGeometry(gl,screenArea);
    oldBufferPosition=null;
  }
  GLBuffer boundbuffer=gl.startWriteGeometry(geometryindex);
  reloadGeometry(boundbuffer,screenArea,context);
  gl.endWriteGeometry(geometryindex);
  gl.glPushMatrix();
  gl.glTranslatef(0,0,-.1f);
  gl.glScalef(1,1,0);
  gl.glMultMatrixf(context.getConverter().getMatrixWithHeight(),0);
  gl.color(1,1,1,1);
  gl.drawTrianglesWithTextureColored(getTexture(context.getGl()),geometryindex,geometrytirs);
  gl.glPopMatrix();
}","/** 
 * Draws a given map content.
 * @param context The context to draw at.
 * @param screen2
 */
public void drawMapContent(MapDrawContext context,FloatRectangle screen){
  GLDrawContext gl=context.getGl();
  MapRectangle screenArea=context.getConverter().getMapForScreen(screen);
  if (!gl.isGeometryValid(geometryindex) || screenArea.getLineLength() + 1 != bufferwidth || screenArea.getLines() != bufferheight) {
    regenerateGeometry(gl,screenArea);
  }
  GLBuffer boundbuffer=gl.startWriteGeometry(geometryindex);
  reloadGeometry(boundbuffer,screenArea,context);
  gl.endWriteGeometry(geometryindex);
  gl.glPushMatrix();
  gl.glTranslatef(0,0,-.1f);
  gl.glScalef(1,1,0);
  gl.glMultMatrixf(context.getConverter().getMatrixWithHeight(),0);
  gl.color(1,1,1,1);
  gl.drawTrianglesWithTextureColored(getTexture(context.getGl()),geometryindex,geometrytirs);
  gl.glPopMatrix();
}"
56096,"/** 
 * Sets up the   {@link ResourceManager} by using a configuration file. <br>First it is checked, if the given argsMap contains a ""configFile"" parameter. If so, the path specified for this parameter is used to get the file. <br> If the parameter is not given, the defaultConfigFile is used.
 * @param argsMap
 * @param defaultConfigFileName
 * @throws FileNotFoundException
 * @throws IOException
 */
public static void setupResourceManagers(HashMap<String,String> argsMap,String defaultConfigFileName) throws FileNotFoundException, IOException {
  File configFile=getConfigFile(argsMap,defaultConfigFileName);
  SwingResourceLoader.setupResourcesManagerByConfigFile(configFile);
}","/** 
 * Sets up the   {@link ResourceManager} by using a configuration file. <br>First it is checked, if the given argsMap contains a ""configFile"" parameter. If so, the path specified for this parameter is used to get the file. <br> If the parameter is not given, the defaultConfigFile is used.
 * @param argsMap
 * @param defaultConfigFileName
 * @throws FileNotFoundException
 * @throws IOException
 */
public static void setupResourceManagers(HashMap<String,String> argsMap,String defaultConfigFileName) throws FileNotFoundException, IOException {
  File configFile=getConfigFile(argsMap,defaultConfigFileName);
  SwingResourceLoader.setupSwingResourcesByConfigFile(configFile);
}"
56097,"public void execute() throws IOException {
  if (destinationDirectory == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (configFile == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  SwingResourceLoader.setupResourcesManagerByConfigFile(configFile);
  String listOutputPackage=listOutputClass.replaceAll(""String_Node_Str"",""String_Node_Str"");
  File listOutputDir=new File(listOutputDirectory.getAbsolutePath() + ""String_Node_Str"" + listOutputPackage.replaceAll(""String_Node_Str"",""String_Node_Str""));
  listOutputDir.mkdirs();
  PrintWriter listOutput=new PrintWriter(listOutputDirectory.getAbsolutePath() + ""String_Node_Str"" + listOutputClass.replaceAll(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str"");
  listOutput.println(""String_Node_Str"" + listOutputPackage + ""String_Node_Str"");
  listOutput.println(""String_Node_Str"");
  listOutput.println(""String_Node_Str"" + listOutputClass.replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
  exportBuildingImages(listOutput);
  exportMaterialImages(listOutput);
  listOutput.println(""String_Node_Str"");
  listOutput.close();
}","public void execute() throws IOException {
  if (destinationDirectory == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (configFile == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  SwingResourceLoader.setupSwingResourcesByConfigFile(configFile);
  String listOutputPackage=listOutputClass.replaceAll(""String_Node_Str"",""String_Node_Str"");
  File listOutputDir=new File(listOutputDirectory.getAbsolutePath() + ""String_Node_Str"" + listOutputPackage.replaceAll(""String_Node_Str"",""String_Node_Str""));
  listOutputDir.mkdirs();
  PrintWriter listOutput=new PrintWriter(listOutputDirectory.getAbsolutePath() + ""String_Node_Str"" + listOutputClass.replaceAll(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str"");
  listOutput.println(""String_Node_Str"" + listOutputPackage + ""String_Node_Str"");
  listOutput.println(""String_Node_Str"");
  listOutput.println(""String_Node_Str"" + listOutputClass.replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
  exportBuildingImages(listOutput);
  exportMaterialImages(listOutput);
  listOutput.println(""String_Node_Str"");
  listOutput.close();
}"
56098,"@Override public String toString(){
  return file.getFileName();
}","@Override public String toString(){
  return ""String_Node_Str"" + file.getFileName() + ""String_Node_Str""+ getMapID();
}"
56099,"@Override public void run(){
  try {
    updateProgressListener(EProgressState.LOADING,0.1f);
    DataOutputStream replayFileStream=createReplayFileStream();
    IGameClock gameClock=MatchConstants.clock=networkConnector.getGameClock();
    gameClock.setReplayLogStream(replayFileStream);
    RandomSingleton.load(randomSeed);
    updateProgressListener(EProgressState.LOADING_MAP,0.3f);
    Thread imagePreloader=ImageProvider.getInstance().startPreloading();
    MainGridWithUiSettings gridWithUiState=mapcreator.loadMainGrid(availablePlayers);
    mainGrid=gridWithUiState.getMainGrid();
    PlayerState playerState=gridWithUiState.getPlayerState(playerId);
    RescheduleTimer.schedule(gameClock);
    updateProgressListener(EProgressState.LOADING_IMAGES,0.7f);
    statistics=new GameStatistics(gameClock);
    mainGrid.initForPlayer(playerId,playerState.getFogOfWar());
    mainGrid.startThreads();
    imagePreloader.join();
    waitForStartingGameListener();
    updateProgressListener(EProgressState.WAITING_FOR_OTHER_PLAYERS,0.98f);
    networkConnector.setStartFinished(true);
    waitForAllPlayersStartFinished(networkConnector);
    final IMapInterfaceConnector connector=startingGameListener.startFinished(this);
    connector.loadUIState(playerState.getUiState());
    GuiInterface guiInterface=new GuiInterface(connector,gameClock,networkConnector.getTaskScheduler(),mainGrid.getGuiInputGrid(),this,playerId,multiplayer);
    if (replayFileInputStream != null) {
      gameClock.loadReplayLogFromStream(replayFileInputStream);
    }
    gameClock.startExecution();
    gameRunning=true;
synchronized (stopMutex) {
      while (!stopped) {
        try {
          stopMutex.wait();
        }
 catch (        InterruptedException e) {
        }
      }
    }
    networkConnector.shutdown();
    gameClock.stopExecution();
    connector.shutdown();
    mainGrid.stopThreads();
    guiInterface.stop();
    RescheduleTimer.stop();
    Movable.dropAllMovables();
    Building.dropAllBuildings();
  }
 catch (  MapLoadException e) {
    e.printStackTrace();
    reportFail(EGameError.MAPLOADING_ERROR,e);
  }
catch (  Exception e) {
    e.printStackTrace();
    reportFail(EGameError.UNKNOWN_ERROR,e);
  }
  if (exitListener != null) {
    exitListener.gameExited(this);
  }
}","@Override public void run(){
  try {
    updateProgressListener(EProgressState.LOADING,0.1f);
    DataOutputStream replayFileStream=createReplayFileStream();
    IGameClock gameClock=MatchConstants.clock=networkConnector.getGameClock();
    gameClock.setReplayLogStream(replayFileStream);
    RandomSingleton.load(randomSeed);
    Movable.resetState();
    updateProgressListener(EProgressState.LOADING_MAP,0.3f);
    Thread imagePreloader=ImageProvider.getInstance().startPreloading();
    MainGridWithUiSettings gridWithUiState=mapcreator.loadMainGrid(availablePlayers);
    mainGrid=gridWithUiState.getMainGrid();
    PlayerState playerState=gridWithUiState.getPlayerState(playerId);
    RescheduleTimer.schedule(gameClock);
    updateProgressListener(EProgressState.LOADING_IMAGES,0.7f);
    statistics=new GameStatistics(gameClock);
    mainGrid.initForPlayer(playerId,playerState.getFogOfWar());
    mainGrid.startThreads();
    imagePreloader.join();
    waitForStartingGameListener();
    updateProgressListener(EProgressState.WAITING_FOR_OTHER_PLAYERS,0.98f);
    networkConnector.setStartFinished(true);
    waitForAllPlayersStartFinished(networkConnector);
    final IMapInterfaceConnector connector=startingGameListener.startFinished(this);
    connector.loadUIState(playerState.getUiState());
    GuiInterface guiInterface=new GuiInterface(connector,gameClock,networkConnector.getTaskScheduler(),mainGrid.getGuiInputGrid(),this,playerId,multiplayer);
    if (replayFileInputStream != null) {
      gameClock.loadReplayLogFromStream(replayFileInputStream);
    }
    gameClock.startExecution();
    gameRunning=true;
synchronized (stopMutex) {
      while (!stopped) {
        try {
          stopMutex.wait();
        }
 catch (        InterruptedException e) {
        }
      }
    }
    networkConnector.shutdown();
    gameClock.stopExecution();
    connector.shutdown();
    mainGrid.stopThreads();
    guiInterface.stop();
    RescheduleTimer.stop();
    Movable.resetState();
    Building.dropAllBuildings();
  }
 catch (  MapLoadException e) {
    e.printStackTrace();
    reportFail(EGameError.MAPLOADING_ERROR,e);
  }
catch (  Exception e) {
    e.printStackTrace();
    reportFail(EGameError.UNKNOWN_ERROR,e);
  }
  if (exitListener != null) {
    exitListener.gameExited(this);
  }
}"
56100,"/** 
 * loads the list of double random numbers with the given seed.
 */
public static void load(long seed){
  uniIns=new RandomSingleton(seed);
}","/** 
 * loads the list of double random numbers with the given seed.
 */
public static void load(long seed){
  uniIns=new RandomSingleton(seed);
  System.out.println(""String_Node_Str"" + nextD() + ""String_Node_Str""+ nextD()+ ""String_Node_Str""+ nextD()+ ""String_Node_Str""+ nextD());
}"
56101,"public void execute() throws IOException {
  if (destinationDirectory == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (configFile == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  SwingResourceLoader.setupResourceManagersByConfigFile(configFile);
  String listOutputPackage=listOutputClass.replaceAll(""String_Node_Str"",""String_Node_Str"");
  File listOutputDir=new File(listOutputDirectory.getAbsolutePath() + ""String_Node_Str"" + listOutputPackage.replaceAll(""String_Node_Str"",""String_Node_Str""));
  listOutputDir.mkdirs();
  PrintWriter listOutput=new PrintWriter(listOutputDirectory.getAbsolutePath() + ""String_Node_Str"" + listOutputClass.replaceAll(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str"");
  listOutput.println(""String_Node_Str"" + listOutputPackage + ""String_Node_Str"");
  listOutput.println(""String_Node_Str"");
  listOutput.println(""String_Node_Str"" + listOutputClass.replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
  exportBuildingImages(listOutput);
  exportMaterialImages(listOutput);
  listOutput.println(""String_Node_Str"");
  listOutput.close();
}","public void execute() throws IOException {
  if (destinationDirectory == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  if (configFile == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  SwingResourceLoader.setupResourcesManagerByConfigFile(configFile);
  String listOutputPackage=listOutputClass.replaceAll(""String_Node_Str"",""String_Node_Str"");
  File listOutputDir=new File(listOutputDirectory.getAbsolutePath() + ""String_Node_Str"" + listOutputPackage.replaceAll(""String_Node_Str"",""String_Node_Str""));
  listOutputDir.mkdirs();
  PrintWriter listOutput=new PrintWriter(listOutputDirectory.getAbsolutePath() + ""String_Node_Str"" + listOutputClass.replaceAll(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str"");
  listOutput.println(""String_Node_Str"" + listOutputPackage + ""String_Node_Str"");
  listOutput.println(""String_Node_Str"");
  listOutput.println(""String_Node_Str"" + listOutputClass.replaceAll(""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
  exportBuildingImages(listOutput);
  exportMaterialImages(listOutput);
  listOutput.println(""String_Node_Str"");
  listOutput.close();
}"
56102,"private void loadFileList(){
  freshMaps.clear();
  savedMaps.clear();
  addFilesToLists(mapsDir);
  addFilesToLists(saveDir);
  Collections.sort(freshMaps);
  Collections.sort(savedMaps);
}","private void loadFileList(){
  freshMaps.clear();
  savedMaps.clear();
  addFilesToLists(mapsDir);
  saveDir.mkdirs();
  addFilesToLists(saveDir);
  Collections.sort(freshMaps);
  Collections.sort(savedMaps);
}"
56103,"private boolean isInBounds(int x,int y){
  return 0 <= x && x < width && 0 <= y && y < height;
}","@Override public boolean isInBounds(int x,int y){
  return 0 <= x && x < width && 0 <= y && y < height;
}"
56104,"public void calculateConstructMarks(final MapRectangle mapArea,final BuildingAreaBitSet buildingArea,final ELandscapeType[] landscapeTypes,RelativePoint[] flattenPositions){
  if (lastArea != null) {
    removeConstructionMarks(lastArea,mapArea);
  }
  final short[] xJumps=buildingArea.xJumps;
  final short[] yJumps=buildingArea.yJumps;
  final int lineLength=mapArea.getLineLength() + mapArea.getHeight() / 2;
  final BitSet doneSet=new BitSet(lineLength * mapArea.getHeight());
  final int xOffsetForBuilding=buildingArea.minX;
  final int yOffsetForBuilding=buildingArea.minY;
  final int buildingAreaWidth=buildingArea.width;
  final int buildingAreaHeight=buildingArea.height;
  for (int line=0; line < mapArea.getHeight(); line++) {
    final int y=mapArea.getLineY(line);
    final int xLineOffset=mapArea.getMinX();
    DX_LOOP:     for (int dx=0; dx < lineLength; dx++) {
      final int x=xLineOffset + dx;
      final short partitionId;
{
        int firstPosX=buildingArea.aPosition.calculateX(x);
        int firstPosY=buildingArea.aPosition.calculateY(y);
        partitionId=map.getPartitionIdAt(firstPosX,firstPosY);
        if (!map.canPlayerConstructOnPartition(playerId,partitionId)) {
          continue DX_LOOP;
        }
      }
      if (!mapArea.contains(x,y) || doneSet.get(dx + line * lineLength)) {
        continue;
      }
      for (int buildingDx=buildingAreaWidth - 1; buildingDx >= 0; buildingDx--) {
        for (int buildingDy=buildingAreaHeight - 1; buildingDy >= 0; buildingDy--) {
          int index=buildingDx + buildingDy * buildingAreaWidth;
          if (xJumps[index] != 0 && !map.canUsePositionForConstruction(x + buildingDx + xOffsetForBuilding,y + buildingDy + yOffsetForBuilding,landscapeTypes,partitionId)) {
            map.setConstructMarking(x,y,false,null);
            for (int pruneX=0; pruneX < xJumps[index]; pruneX++) {
              int currYJumps=yJumps[(buildingDx - pruneX) + buildingDy * buildingAreaWidth];
              for (int pruneY=0; pruneY < currYJumps; pruneY++) {
                if (pruneY == 0 && pruneX == 0) {
                  continue;
                }
                doneSet.set((dx + pruneX) + (line + pruneY) * lineLength);
                map.setConstructMarking(x + pruneX,y + pruneY,false,null);
              }
            }
            continue DX_LOOP;
          }
        }
      }
      map.setConstructMarking(x,y,true,flattenPositions);
    }
  }
  lastArea=mapArea;
}","public void calculateConstructMarks(final MapRectangle mapArea,final BuildingAreaBitSet buildingArea,final ELandscapeType[] landscapeTypes,RelativePoint[] flattenPositions){
  if (lastArea != null) {
    removeConstructionMarks(lastArea,mapArea);
  }
  final short[] xJumps=buildingArea.xJumps;
  final short[] yJumps=buildingArea.yJumps;
  final int lineLength=mapArea.getLineLength() + mapArea.getHeight() / 2;
  final BitSet doneSet=new BitSet(lineLength * mapArea.getHeight());
  final int xOffsetForBuilding=buildingArea.minX;
  final int yOffsetForBuilding=buildingArea.minY;
  final int buildingAreaWidth=buildingArea.width;
  final int buildingAreaHeight=buildingArea.height;
  for (int line=0; line < mapArea.getHeight(); line++) {
    final int y=mapArea.getLineY(line);
    final int xLineOffset=mapArea.getMinX();
    DX_LOOP:     for (int dx=0; dx < lineLength; dx++) {
      final int x=xLineOffset + dx;
      final short partitionId;
      if (!mapArea.contains(x,y) || doneSet.get(dx + line * lineLength)) {
        continue;
      }
{
        int firstPosX=buildingArea.aPosition.calculateX(x);
        int firstPosY=buildingArea.aPosition.calculateY(y);
        if (!map.isInBounds(firstPosX,firstPosY)) {
          continue;
        }
        partitionId=map.getPartitionIdAt(firstPosX,firstPosY);
        if (!map.canPlayerConstructOnPartition(playerId,partitionId)) {
          continue DX_LOOP;
        }
      }
      for (int buildingDx=buildingAreaWidth - 1; buildingDx >= 0; buildingDx--) {
        for (int buildingDy=buildingAreaHeight - 1; buildingDy >= 0; buildingDy--) {
          int index=buildingDx + buildingDy * buildingAreaWidth;
          if (xJumps[index] != 0 && !map.canUsePositionForConstruction(x + buildingDx + xOffsetForBuilding,y + buildingDy + yOffsetForBuilding,landscapeTypes,partitionId)) {
            map.setConstructMarking(x,y,false,null);
            for (int pruneX=0; pruneX < xJumps[index]; pruneX++) {
              int currYJumps=yJumps[(buildingDx - pruneX) + buildingDy * buildingAreaWidth];
              for (int pruneY=0; pruneY < currYJumps; pruneY++) {
                if (pruneY == 0 && pruneX == 0) {
                  continue;
                }
                doneSet.set((dx + pruneX) + (line + pruneY) * lineLength);
                map.setConstructMarking(x + pruneX,y + pruneY,false,null);
              }
            }
            continue DX_LOOP;
          }
        }
      }
      map.setConstructMarking(x,y,true,flattenPositions);
    }
  }
  lastArea=mapArea;
}"
56105,"private void showXML(){
  StringBuilder builder=new StringBuilder(""String_Node_Str"");
  for (  RelativePoint tile : definition.getBlocked()) {
    builder.append(""String_Node_Str"");
    builder.append(tile.getDx());
    builder.append(""String_Node_Str"");
    builder.append(tile.getDy());
    builder.append(""String_Node_Str"");
  }
  for (  RelativePoint tile : definition.getJustProtected()) {
    builder.append(""String_Node_Str"");
    builder.append(tile.getDx());
    builder.append(""String_Node_Str"");
    builder.append(tile.getDy());
    builder.append(""String_Node_Str"");
  }
  RelativePoint door=definition.getDoor();
  builder.append(""String_Node_Str"");
  builder.append(door.getDx());
  builder.append(""String_Node_Str"");
  builder.append(door.getDy());
  builder.append(""String_Node_Str"");
  for (  RelativeStack stack : definition.getStacks()) {
    builder.append(""String_Node_Str"");
    builder.append(stack.getDx());
    builder.append(""String_Node_Str"");
    builder.append(stack.getDy());
    builder.append(""String_Node_Str"");
    builder.append(stack.getMaterialType().name());
    builder.append(""String_Node_Str"");
    builder.append(stack.requiredForBuild());
    builder.append(""String_Node_Str"");
  }
  for (  RelativeBricklayer bricklayer : definition.getBricklayers()) {
    builder.append(""String_Node_Str"");
    builder.append(bricklayer.getPosition().getDx());
    builder.append(""String_Node_Str"");
    builder.append(bricklayer.getPosition().getDy());
    builder.append(""String_Node_Str"");
    builder.append(bricklayer.getDirection());
    builder.append(""String_Node_Str"");
  }
  RelativePoint flag=definition.getFlag();
  builder.append(""String_Node_Str"");
  builder.append(flag.getDx());
  builder.append(""String_Node_Str"");
  builder.append(flag.getDy());
  builder.append(""String_Node_Str"");
  for (  RelativePoint mark : definition.getBuildmarks()) {
    builder.append(""String_Node_Str"");
    builder.append(mark.getDx());
    builder.append(""String_Node_Str"");
    builder.append(mark.getDy());
    builder.append(""String_Node_Str"");
  }
  JDialog dialog=new JDialog(window,""String_Node_Str"");
  dialog.add(new JScrollPane(new JTextArea(builder.toString())));
  dialog.pack();
  dialog.setVisible(true);
}","private void showXML(){
  StringBuilder builder=new StringBuilder(""String_Node_Str"");
  for (  RelativePoint tile : definition.getBlocked()) {
    builder.append(""String_Node_Str"");
    builder.append(tile.getDx());
    builder.append(""String_Node_Str"");
    builder.append(tile.getDy());
    builder.append(""String_Node_Str"");
  }
  for (  RelativePoint tile : definition.getJustProtected()) {
    builder.append(""String_Node_Str"");
    builder.append(tile.getDx());
    builder.append(""String_Node_Str"");
    builder.append(tile.getDy());
    builder.append(""String_Node_Str"");
  }
  RelativePoint door=definition.getDoor();
  builder.append(""String_Node_Str"");
  builder.append(door.getDx());
  builder.append(""String_Node_Str"");
  builder.append(door.getDy());
  builder.append(""String_Node_Str"");
  for (  RelativeStack stack : definition.getStacks()) {
    builder.append(""String_Node_Str"");
    builder.append(stack.getDx());
    builder.append(""String_Node_Str"");
    builder.append(stack.getDy());
    builder.append(""String_Node_Str"");
    builder.append(stack.getMaterialType().name());
    builder.append(""String_Node_Str"");
    builder.append(stack.requiredForBuild());
    builder.append(""String_Node_Str"");
  }
  for (  RelativeBricklayer bricklayer : definition.getBricklayers()) {
    builder.append(""String_Node_Str"");
    builder.append(bricklayer.getPosition().getDx());
    builder.append(""String_Node_Str"");
    builder.append(bricklayer.getPosition().getDy());
    builder.append(""String_Node_Str"");
    builder.append(bricklayer.getDirection());
    builder.append(""String_Node_Str"");
  }
  RelativePoint flag=definition.getFlag();
  builder.append(""String_Node_Str"");
  builder.append(flag.getDx());
  builder.append(""String_Node_Str"");
  builder.append(flag.getDy());
  builder.append(""String_Node_Str"");
  for (  RelativePoint mark : definition.getBuildmarks()) {
    builder.append(""String_Node_Str"");
    builder.append(mark.getDx());
    builder.append(""String_Node_Str"");
    builder.append(mark.getDy());
    builder.append(""String_Node_Str"");
  }
  JDialog dialog=new JDialog(window,""String_Node_Str"");
  dialog.add(new JScrollPane(new JTextArea(builder.toString())));
  dialog.setLocationRelativeTo(null);
  dialog.pack();
  dialog.setVisible(true);
}"
56106,"protected void editSettings(){
  final JDialog dialog=new JDialog(window,EditorLabels.getLabel(""String_Node_Str""),true);
  final MapHeaderEditor headerEditor=new MapHeaderEditor(header,true);
  JPanel box=new JPanel();
  box.setLayout(new BoxLayout(box,BoxLayout.PAGE_AXIS));
  box.add(headerEditor);
  JButton okButton=new JButton(""String_Node_Str"");
  okButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      MapFileHeader nheader=headerEditor.getHeader();
      if (nheader.getWidth() != header.getWidth() || nheader.getHeight() != header.getHeight()) {
        JOptionPane.showMessageDialog(window,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        return;
      }
      header=nheader;
      data.setMaxPlayers(header.getMaxPlayer());
      dataTester.retest();
      dialog.setVisible(false);
    }
  }
);
  box.add(okButton);
  dialog.add(box);
  dialog.pack();
  dialog.setVisible(true);
}","protected void editSettings(){
  final JDialog dialog=new JDialog(window,EditorLabels.getLabel(""String_Node_Str""),true);
  final MapHeaderEditor headerEditor=new MapHeaderEditor(header,true);
  JPanel box=new JPanel();
  box.setLayout(new BoxLayout(box,BoxLayout.PAGE_AXIS));
  box.add(headerEditor);
  JButton okButton=new JButton(""String_Node_Str"");
  okButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      MapFileHeader nheader=headerEditor.getHeader();
      if (nheader.getWidth() != header.getWidth() || nheader.getHeight() != header.getHeight()) {
        JOptionPane.showMessageDialog(window,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        return;
      }
      header=nheader;
      data.setMaxPlayers(header.getMaxPlayer());
      dataTester.retest();
      dialog.setVisible(false);
    }
  }
);
  box.add(okButton);
  dialog.add(box);
  dialog.setLocationRelativeTo(null);
  dialog.pack();
  dialog.setVisible(true);
}"
56107,"private void generate(boolean sizeChangable){
  nameField=new JTextField();
  descriptionField=new JTextArea();
  descriptionField.setMinimumSize(new Dimension(200,50));
  width=new SpinnerNumberModel(DEFAULT_MAPSIZE,MIN_MAPSIZE,MAX_MAPSIZE,1);
  height=new SpinnerNumberModel(DEFAULT_MAPSIZE,MIN_MAPSIZE,MAX_MAPSIZE,1);
  minPlayer=new SpinnerNumberModel(1,1,CommonConstants.MAX_PLAYERS,1);
  maxPlayer=new SpinnerNumberModel(1,1,CommonConstants.MAX_PLAYERS,1);
  JSpinner widthField=new JSpinner(width);
  JSpinner heightField=new JSpinner(height);
  JSpinner minPlayerField=new JSpinner(minPlayer);
  JSpinner maxPlayerField=new JSpinner(maxPlayer);
  JLabel nameLabel=new JLabel(""String_Node_Str"");
  JLabel descriptionLabel=new JLabel(""String_Node_Str"");
  JLabel widthLabel=new JLabel(""String_Node_Str"");
  JLabel heightLabel=new JLabel(""String_Node_Str"");
  JLabel minPlayerLabel=new JLabel(""String_Node_Str"");
  JLabel maxPlayerLabel=new JLabel(""String_Node_Str"");
  add(nameField);
  add(descriptionField);
  add(heightField);
  add(widthField);
  add(minPlayerField);
  add(maxPlayerField);
  add(nameLabel);
  add(descriptionLabel);
  add(widthLabel);
  add(heightLabel);
  add(maxPlayerLabel);
  add(minPlayerLabel);
  GroupLayout layout=new GroupLayout(this);
  setLayout(layout);
  layout.setAutoCreateGaps(true);
  layout.setAutoCreateContainerGaps(true);
  layout.setHorizontalGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup().addComponent(nameLabel).addComponent(descriptionLabel).addComponent(heightLabel).addComponent(widthLabel).addComponent(maxPlayerLabel).addComponent(minPlayerLabel)).addGroup(layout.createParallelGroup().addComponent(nameField).addComponent(descriptionField).addComponent(heightField).addComponent(widthField).addComponent(maxPlayerField).addComponent(minPlayerField)));
  layout.setVerticalGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup().addComponent(nameLabel).addComponent(nameField)).addGroup(layout.createParallelGroup().addComponent(descriptionLabel).addComponent(descriptionField)).addGroup(layout.createParallelGroup().addComponent(widthLabel).addComponent(widthField)).addGroup(layout.createParallelGroup().addComponent(heightLabel).addComponent(heightField)).addGroup(layout.createParallelGroup().addComponent(minPlayerLabel).addComponent(minPlayerField)).addGroup(layout.createParallelGroup().addComponent(maxPlayerLabel).addComponent(maxPlayerField)));
  if (!sizeChangable) {
    widthField.setEnabled(false);
    heightField.setEnabled(false);
  }
}","private void generate(boolean sizeChangable){
  nameField=new JTextField();
  descriptionField=new JTextArea();
  descriptionField.setMinimumSize(new Dimension(200,50));
  descriptionField.setLineWrap(true);
  descriptionField.setWrapStyleWord(true);
  width=new SpinnerNumberModel(DEFAULT_MAPSIZE,MIN_MAPSIZE,MAX_MAPSIZE,1);
  height=new SpinnerNumberModel(DEFAULT_MAPSIZE,MIN_MAPSIZE,MAX_MAPSIZE,1);
  minPlayer=new SpinnerNumberModel(1,1,CommonConstants.MAX_PLAYERS,1);
  maxPlayer=new SpinnerNumberModel(1,1,CommonConstants.MAX_PLAYERS,1);
  JSpinner widthField=new JSpinner(width);
  JSpinner heightField=new JSpinner(height);
  JSpinner minPlayerField=new JSpinner(minPlayer);
  JSpinner maxPlayerField=new JSpinner(maxPlayer);
  JLabel nameLabel=new JLabel(""String_Node_Str"");
  JLabel descriptionLabel=new JLabel(""String_Node_Str"");
  JLabel widthLabel=new JLabel(""String_Node_Str"");
  JLabel heightLabel=new JLabel(""String_Node_Str"");
  JLabel minPlayerLabel=new JLabel(""String_Node_Str"");
  JLabel maxPlayerLabel=new JLabel(""String_Node_Str"");
  add(nameField);
  add(descriptionField);
  add(heightField);
  add(widthField);
  add(minPlayerField);
  add(maxPlayerField);
  add(nameLabel);
  add(descriptionLabel);
  add(widthLabel);
  add(heightLabel);
  add(maxPlayerLabel);
  add(minPlayerLabel);
  GroupLayout layout=new GroupLayout(this);
  setLayout(layout);
  layout.setAutoCreateGaps(true);
  layout.setAutoCreateContainerGaps(true);
  layout.setHorizontalGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup().addComponent(nameLabel).addComponent(descriptionLabel).addComponent(heightLabel).addComponent(widthLabel).addComponent(maxPlayerLabel).addComponent(minPlayerLabel)).addGroup(layout.createParallelGroup().addComponent(nameField).addComponent(descriptionField).addComponent(heightField).addComponent(widthField).addComponent(maxPlayerField).addComponent(minPlayerField)));
  layout.setVerticalGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup().addComponent(nameLabel).addComponent(nameField)).addGroup(layout.createParallelGroup().addComponent(descriptionLabel).addComponent(descriptionField)).addGroup(layout.createParallelGroup().addComponent(widthLabel).addComponent(widthField)).addGroup(layout.createParallelGroup().addComponent(heightLabel).addComponent(heightField)).addGroup(layout.createParallelGroup().addComponent(minPlayerLabel).addComponent(minPlayerField)).addGroup(layout.createParallelGroup().addComponent(maxPlayerLabel).addComponent(maxPlayerField)));
  if (!sizeChangable) {
    widthField.setEnabled(false);
    heightField.setEnabled(false);
  }
}"
56108,"private void setState(AsyncNetworkClientFactoryState state){
  if (this.state == AsyncNetworkClientFactoryState.CLOSED) {
    networkClient.close();
  }
 else {
    this.state=state;
  }
synchronized (lock) {
    lock.notifyAll();
  }
}","private void setState(AsyncNetworkClientFactoryState state){
  if (this.state == AsyncNetworkClientFactoryState.CLOSED) {
    close();
  }
 else {
    this.state=state;
  }
synchronized (lock) {
    lock.notifyAll();
  }
}"
56109,"public void close(){
  setState(AsyncNetworkClientFactoryState.CLOSED);
  if (state != AsyncNetworkClientFactoryState.CONNECTING_TO_SERVER) {
    networkClient.close();
  }
}","public synchronized void close(){
  if (networkClient != null) {
    networkClient.close();
    networkClient=null;
  }
}"
56110,"public BuildingAreaBitSet(RelativePoint[] protectedTiles){
  short minX=protectedTiles[0].getDx();
  short maxX=protectedTiles[0].getDx();
  short minY=protectedTiles[0].getDy();
  short maxY=protectedTiles[0].getDy();
  for (int i=0; i < protectedTiles.length; i++) {
    minX=min(minX,protectedTiles[i].getDx());
    maxX=max(maxX,protectedTiles[i].getDx());
    minY=min(minY,protectedTiles[i].getDy());
    maxY=max(maxY,protectedTiles[i].getDy());
  }
  this.numberOfPositions=protectedTiles.length;
  this.minX=minX;
  this.minY=minY;
  this.maxX=maxX;
  this.maxY=maxY;
  this.width=(short)(maxX - minX + 1);
  this.height=(short)(maxY - minY + 1);
  this.bitSet=new BitSet(width * height);
  for (int i=0; i < protectedTiles.length; i++) {
    set(protectedTiles[i].getDx(),protectedTiles[i].getDy());
  }
  this.xJumps=new short[width * height];
  calculateXJumps();
  this.yJumps=new short[width * height];
  calculateYJumps();
}","public BuildingAreaBitSet(RelativePoint[] protectedTiles){
  short minX=protectedTiles[0].getDx();
  short maxX=protectedTiles[0].getDx();
  short minY=protectedTiles[0].getDy();
  short maxY=protectedTiles[0].getDy();
  for (int i=0; i < protectedTiles.length; i++) {
    minX=min(minX,protectedTiles[i].getDx());
    maxX=max(maxX,protectedTiles[i].getDx());
    minY=min(minY,protectedTiles[i].getDy());
    maxY=max(maxY,protectedTiles[i].getDy());
  }
  this.aPosition=protectedTiles[0];
  this.numberOfPositions=protectedTiles.length;
  this.minX=minX;
  this.minY=minY;
  this.maxX=maxX;
  this.maxY=maxY;
  this.width=(short)(maxX - minX + 1);
  this.height=(short)(maxY - minY + 1);
  this.bitSet=new BitSet(width * height);
  for (int i=0; i < protectedTiles.length; i++) {
    set(protectedTiles[i].getDx(),protectedTiles[i].getDy());
  }
  this.xJumps=new short[width * height];
  calculateXJumps();
  this.yJumps=new short[width * height];
  calculateYJumps();
}"
56111,"private IAttackable getEnemyInSearchArea(byte searchingPlayer,HexGridArea area,boolean isBowman){
  for (  ShortPoint2D curr : area) {
    short x=curr.x;
    short y=curr.y;
    if (0 <= x && x < width && 0 <= y && y < height) {
      IAttackable currAttackable=movableGrid.getMovableAt(x,y);
      if (currAttackable == null && !isBowman) {
        currAttackable=(IAttackable)objectsGrid.getMapObjectAt(x,y,EMapObjectType.ATTACKABLE_TOWER);
      }
      if (currAttackable != null && MovableGrid.isEnemy(searchingPlayer,currAttackable)) {
        return currAttackable;
      }
    }
  }
  return null;
}","private IAttackable getEnemyInSearchArea(byte searchingPlayer,HexGridArea area,boolean isBowman,boolean includeTowers){
  for (  ShortPoint2D curr : area) {
    short x=curr.x;
    short y=curr.y;
    if (0 <= x && x < width && 0 <= y && y < height) {
      IAttackable currAttackable=movableGrid.getMovableAt(x,y);
      if (includeTowers && !isBowman && currAttackable == null) {
        currAttackable=(IAttackable)objectsGrid.getMapObjectAt(x,y,EMapObjectType.ATTACKABLE_TOWER);
      }
      if (currAttackable != null && MovableGrid.isEnemy(searchingPlayer,currAttackable)) {
        return currAttackable;
      }
    }
  }
  return null;
}"
56112,"/** 
 * Searches for an enemy around the position of the given movable in it's search radius.
 * @param centerPos The center position to start the search.
 * @param movable The movable searching an enemy.
 * @param searchRadius The radius of the search for enemy attackables.
 * @return The closest enemy or null if none exists in the search radius.
 */
public abstract IAttackable getEnemyInSearchArea(ShortPoint2D centerPos,IAttackable movable,short searchRadius);","/** 
 * Searches for an enemy around the position of the given movable in it's search radius.
 * @param centerPos The center position to start the search.
 * @param movable The movable searching an enemy.
 * @param searchRadius The radius of the search for enemy attackables.
 * @param includeTowers If true, towers are included in the search, if false, only movables are searched.
 * @return The closest enemy or null if none exists in the search radius.
 */
public abstract IAttackable getEnemyInSearchArea(ShortPoint2D centerPos,IAttackable movable,short searchRadius,boolean includeTowers);"
56113,"@Override protected void moveToPathSet(ShortPoint2D oldPosition,ShortPoint2D oldTargetPos,ShortPoint2D targetPos){
  if (targetPos != null && this.oldPathTarget != null) {
    oldPathTarget=null;
    inSaveGotoMode=false;
  }
}","@Override protected void moveToPathSet(ShortPoint2D oldPosition,ShortPoint2D oldTargetPos,ShortPoint2D targetPos){
  if (targetPos != null && this.oldPathTarget != null) {
    oldPathTarget=null;
    inSaveGotoMode=false;
  }
  changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
}"
56114,"@Override protected void action(){
switch (state) {
case AGGRESSIVE:
    break;
case HITTING:
  hitEnemy(enemy);
if (state != ESoldierState.HITTING) {
  break;
}
if (enemy.getHealth() <= 0) {
enemy=null;
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
break;
}
case SEARCH_FOR_ENEMIES:
IAttackable oldEnemy=enemy;
enemy=super.getStrategyGrid().getEnemyInSearchArea(getAttackPosition(),super.getMovable(),getSearchDistance(isInTower));
if (oldEnemy != null && oldEnemy != enemy) {
inSaveGotoMode=false;
}
if (enemy == null) {
if (defending) {
building.towerDefended(this);
defending=false;
}
changeStateTo(ESoldierState.AGGRESSIVE);
break;
}
if (isEnemyAttackable(enemy,isInTower)) {
super.lookInDirection(EDirection.getApproxDirection(super.getPos(),enemy.getPos()));
startAttackAnimation(enemy);
changeStateTo(ESoldierState.HITTING);
}
 else if (!isInTower) {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
goToEnemy(enemy);
}
break;
case INIT_GOTO_TOWER:
if (super.getPos().equals(building.getDoor()) || super.goToPos(building.getDoor())) {
changeStateTo(ESoldierState.GOING_TO_TOWER);
}
 else {
building.requestFailed(this.movableType);
building=null;
state=ESoldierState.AGGRESSIVE;
}
break;
case GOING_TO_TOWER:
if (building.isNotDestroyed() && building.getPlayer() == super.getPlayer()) {
OccupyerPlace place=building.addSoldier(this);
super.setPosition(place.getPosition().calculatePoint(building.getDoor()));
super.enableNothingToDoAction(false);
super.setVisible(false);
if (isBowman()) {
this.inTowerAttackPosition=building.getTowerBowmanSearchPosition(place);
}
changeStateTo(ESoldierState.AGGRESSIVE);
isInTower=true;
}
 else {
changeStateTo(ESoldierState.AGGRESSIVE);
building=null;
}
break;
}
}","@Override protected void action(){
switch (state) {
case AGGRESSIVE:
    break;
case HITTING:
  hitEnemy(enemy);
if (state != ESoldierState.HITTING) {
  break;
}
if (enemy.getHealth() <= 0) {
enemy=null;
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
break;
}
case SEARCH_FOR_ENEMIES:
IAttackable oldEnemy=enemy;
enemy=super.getStrategyGrid().getEnemyInSearchArea(getAttackPosition(),super.getMovable(),getSearchDistance(isInTower),!defending);
if (oldEnemy != null && oldEnemy != enemy) {
inSaveGotoMode=false;
}
if (enemy == null) {
if (defending) {
building.towerDefended(this);
defending=false;
}
changeStateTo(ESoldierState.AGGRESSIVE);
break;
}
if (isEnemyAttackable(enemy,isInTower)) {
super.lookInDirection(EDirection.getApproxDirection(super.getPos(),enemy.getPos()));
startAttackAnimation(enemy);
changeStateTo(ESoldierState.HITTING);
}
 else if (!isInTower) {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
goToEnemy(enemy);
}
 else {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
}
break;
case INIT_GOTO_TOWER:
if (super.getPos().equals(building.getDoor()) || super.goToPos(building.getDoor())) {
changeStateTo(ESoldierState.GOING_TO_TOWER);
}
 else {
building.requestFailed(this.movableType);
building=null;
state=ESoldierState.AGGRESSIVE;
}
break;
case GOING_TO_TOWER:
if (building.isNotDestroyed() && building.getPlayer() == super.getPlayer()) {
OccupyerPlace place=building.addSoldier(this);
super.setPosition(place.getPosition().calculatePoint(building.getDoor()));
super.enableNothingToDoAction(false);
super.setVisible(false);
if (isBowman()) {
this.inTowerAttackPosition=building.getTowerBowmanSearchPosition(place);
}
changeStateTo(ESoldierState.AGGRESSIVE);
isInTower=true;
}
 else {
changeStateTo(ESoldierState.AGGRESSIVE);
building=null;
}
break;
}
}"
56115,"private final boolean isAllowedLandscape(int x,int y,ELandscapeType[] landscapes){
  ELandscapeType landscapeAt=landscapeGrid.getLandscapeTypeAt(x,y);
  for (byte i=0; i < landscapes.length; i++) {
    if (landscapeAt == landscapes[i]) {
      return true;
    }
  }
  return false;
}","private boolean isAllowedLandscape(int x,int y,ELandscapeType[] landscapes){
  ELandscapeType landscapeAt=landscapeGrid.getLandscapeTypeAt(x,y);
  for (byte i=0; i < landscapes.length; i++) {
    if (landscapeAt == landscapes[i]) {
      return true;
    }
  }
  return false;
}"
56116,"@Override public final boolean canUsePositionForConstruction(int x,int y,ELandscapeType[] landscapeTypes,byte player){
  return isInBounds(x,y) && !flagsGrid.isProtected(x,y) && ((CommonConstants.ENABLE_ALL_PLAYER_SELECTION && partitionsGrid.getPlayerIdAt(x,y) >= 0) || partitionsGrid.getPlayerIdAt(x,y) == player)&& isAllowedLandscape(x,y,landscapeTypes);
}","@Override public boolean canUsePositionForConstruction(int x,int y,ELandscapeType[] landscapeTypes,short partitionId){
  return isInBounds(x,y) && !flagsGrid.isProtected(x,y) && partitionsGrid.getPartitionIdAt(x,y) == partitionId && isAllowedLandscape(x,y,landscapeTypes);
}"
56117,"private void handleDiggerRequest(){
  DiggerRequest request=diggerRequests.peek();
  if (request == null) {
    return;
  }
  if (request.requester.isDiggerRequestActive()) {
    IManageableDigger digger=joblessDiggers.removeObjectNextTo(request.getPos());
    if (digger != null) {
      digger.setDiggerJob(request.requester);
      request.amount--;
      if (request.creationRequested > 0) {
        request.creationRequested--;
      }
    }
 else {
      if (request.amount > request.creationRequested) {
        if (createNewToolUserIfLimitNotExceeded(EMovableType.DIGGER,request.getPos())) {
          request.creationRequested++;
        }
      }
    }
    if (request.amount <= 0) {
      diggerRequests.poll();
    }
  }
 else {
    diggerRequests.poll();
  }
}","private void handleDiggerRequest(){
  DiggerRequest request=diggerRequests.peek();
  if (request == null) {
    return;
  }
  if (request.requester.isDiggerRequestActive()) {
    IManageableDigger digger=joblessDiggers.removeObjectNextTo(request.getPos());
    if (digger != null) {
      if (digger.setDiggerJob(request.requester)) {
        request.amount--;
        if (request.creationRequested > 0) {
          request.creationRequested--;
        }
      }
    }
 else {
      if (request.amount > request.creationRequested) {
        if (createNewToolUserIfLimitNotExceeded(EMovableType.DIGGER,request.getPos())) {
          request.creationRequested++;
        }
      }
    }
    if (request.amount <= 0) {
      diggerRequests.poll();
    }
  }
 else {
    diggerRequests.poll();
  }
}"
56118,"private void handleBricklayerRequest(){
  BricklayerRequest bricklayerRequest=bricklayerRequests.poll();
  if (bricklayerRequest != null && !bricklayerRequest.building.isConstructionFinished()) {
    IManageableBricklayer bricklayer=joblessBricklayers.removeObjectNextTo(bricklayerRequest.getPos());
    if (bricklayer != null) {
      bricklayer.setBricklayerJob(bricklayerRequest.building,bricklayerRequest.bricklayerTargetPos,bricklayerRequest.direction);
    }
 else {
      createNewToolUserIfLimitNotExceeded(EMovableType.BRICKLAYER,bricklayerRequest.getPos());
      bricklayerRequests.offerLast(bricklayerRequest);
    }
  }
}","private void handleBricklayerRequest(){
  BricklayerRequest bricklayerRequest=bricklayerRequests.poll();
  if (bricklayerRequest != null && !bricklayerRequest.building.isConstructionFinished()) {
    IManageableBricklayer bricklayer=joblessBricklayers.removeObjectNextTo(bricklayerRequest.getPos());
    if (bricklayer != null) {
      if (!bricklayer.setBricklayerJob(bricklayerRequest.building,bricklayerRequest.bricklayerTargetPos,bricklayerRequest.direction)) {
        bricklayerRequests.add(bricklayerRequest);
      }
    }
 else {
      createNewToolUserIfLimitNotExceeded(EMovableType.BRICKLAYER,bricklayerRequest.getPos());
      bricklayerRequests.offerLast(bricklayerRequest);
    }
  }
}"
56119,"void setBricklayerJob(IConstructableBuilding constructionSite,ShortPoint2D bricklayerTargetPos,EDirection direction);","/** 
 * @param constructionSite
 * @param bricklayerTargetPos
 * @param direction
 * @return Returns true if the request can be handled by this bricklayer.
 */
boolean setBricklayerJob(IConstructableBuilding constructionSite,ShortPoint2D bricklayerTargetPos,EDirection direction);"
56120,void setDiggerJob(IDiggerRequester requester);,"/** 
 * @param requester
 * @return true if the job can be handled by this digger, false if another digger needs to be asked.
 */
boolean setDiggerJob(IDiggerRequester requester);"
56121,"/** 
 * Sets a job to this   {@link IManagerBearer} object. The job is to deliver the given offer tot the given request.
 * @param materialType
 * @param offerPosition
 * @param request
 */
void deliver(EMaterialType materialType,ShortPoint2D offerPosition,IMaterialRequest request);","/** 
 * Sets a job to this   {@link IManagerBearer} object. The job is to deliver the given offer tot the given request.
 * @param materialType
 * @param offerPosition
 * @param request
 * @return true if the job can be handled, false if another bearer needs to be asked.
 */
boolean deliver(EMaterialType materialType,ShortPoint2D offerPosition,IMaterialRequest request);"
56122,"@Override public void deliver(EMaterialType materialType,ShortPoint2D offer,IMaterialRequest request){
  this.offer=offer;
  this.request=request;
  this.materialType=materialType;
  this.state=EBearerState.INIT_CARRY_JOB;
  request.deliveryAccepted();
}","@Override public boolean deliver(EMaterialType materialType,ShortPoint2D offer,IMaterialRequest request){
  if (state == EBearerState.JOBLESS) {
    this.offer=offer;
    this.request=request;
    this.materialType=materialType;
    this.state=EBearerState.INIT_CARRY_JOB;
    request.deliveryAccepted();
    return true;
  }
 else {
    return false;
  }
}"
56123,"@Override public void setBricklayerJob(IConstructableBuilding constructionSite,ShortPoint2D bricklayerTargetPos,EDirection direction){
}","@Override public boolean setBricklayerJob(IConstructableBuilding constructionSite,ShortPoint2D bricklayerTargetPos,EDirection direction){
  if (state == EBricklayerState.JOBLESS) {
    this.constructionSite=constructionSite;
    this.bricklayerTargetPos=bricklayerTargetPos;
    this.lookDirection=direction;
    this.state=EBricklayerState.INIT_JOB;
    return true;
  }
 else {
    return false;
  }
}"
56124,"@Override protected void action(){
switch (state) {
case JOBLESS:
    break;
case INIT_JOB:
  if (!constructionSite.isConstructionFinished() && super.goToPos(bricklayerTargetPos)) {
    this.state=EBricklayerState.GOING_TO_POS;
  }
 else {
    makeJobless();
  }
break;
case GOING_TO_POS:
super.lookInDirection(lookDirection);
state=EBricklayerState.BUILDING;
case BUILDING:
tryToBuild();
break;
}
}","@Override protected void action(){
switch (state) {
case JOBLESS:
    break;
case INIT_JOB:
  if (!constructionSite.isConstructionFinished() && super.goToPos(bricklayerTargetPos)) {
    this.state=EBricklayerState.GOING_TO_POS;
  }
 else {
    makeJobless();
  }
break;
case GOING_TO_POS:
super.lookInDirection(lookDirection);
state=EBricklayerState.BUILDING;
case BUILDING:
tryToBuild();
break;
case DEAD_OBJECT:
break;
}
}"
56125,"@Override protected void strategyKilledEvent(ShortPoint2D pathTarget){
  if (state == EBricklayerState.JOBLESS) {
    super.getStrategyGrid().removeJobless(this);
  }
}","@Override protected void strategyKilledEvent(ShortPoint2D pathTarget){
  if (state == EBricklayerState.JOBLESS) {
    super.getStrategyGrid().removeJobless(this);
  }
  state=EBricklayerState.DEAD_OBJECT;
}"
56126,"@Override public void setDiggerJob(IDiggerRequester requester){
}","@Override public boolean setDiggerJob(IDiggerRequester requester){
  if (state == EDiggerState.JOBLESS) {
    this.requester=requester;
    this.state=EDiggerState.INIT_JOB;
    return true;
  }
 else {
    return false;
  }
}"
56127,"@Override protected void action(){
switch (state) {
case JOBLESS:
    break;
case INIT_JOB:
  goToDiggablePosition();
break;
case PLAYING_ACTION:
executeDigg();
if (!requester.isDiggerRequestActive()) {
reportAsJobless();
break;
}
case GOING_TO_POS:
if (needsToBeWorkedOn(super.getPos())) {
super.playAction(EAction.ACTION1,1f);
this.state=EDiggerState.PLAYING_ACTION;
}
 else {
goToDiggablePosition();
}
break;
}
}","@Override protected void action(){
switch (state) {
case JOBLESS:
    break;
case INIT_JOB:
  goToDiggablePosition();
break;
case PLAYING_ACTION:
executeDigg();
if (!requester.isDiggerRequestActive()) {
reportAsJobless();
break;
}
case GOING_TO_POS:
if (needsToBeWorkedOn(super.getPos())) {
super.playAction(EAction.ACTION1,1f);
this.state=EDiggerState.PLAYING_ACTION;
}
 else {
goToDiggablePosition();
}
break;
case DEAD_OBJECT:
break;
}
}"
56128,"@Override protected void strategyKilledEvent(ShortPoint2D pathTarget){
  if (pathTarget != null) {
    super.getStrategyGrid().setMarked(pathTarget,false);
  }
  if (state == EDiggerState.JOBLESS) {
    super.getStrategyGrid().removeJobless(this);
  }
}","@Override protected void strategyKilledEvent(ShortPoint2D pathTarget){
  if (pathTarget != null) {
    super.getStrategyGrid().setMarked(pathTarget,false);
  }
  if (state == EDiggerState.JOBLESS) {
    super.getStrategyGrid().removeJobless(this);
  }
  state=EDiggerState.DEAD_OBJECT;
}"
56129,"@Override public boolean canUsePositionForConstruction(int x,int y,ELandscapeType[] landscapeTypes,byte player){
  return isInBounds(x,y) && !blockedSet.get(x + y * width);
}","@Override public boolean canUsePositionForConstruction(int x,int y,ELandscapeType[] landscapeTypes,short partitionId){
  return isInBounds(x,y) && !blockedSet.get(x + y * width);
}"
56130,"@Override public NewMovable getEnemyInSearchArea(ShortPoint2D centerPos,IAttackable attackable,short searchRadius){
  return null;
}","@Override public NewMovable getEnemyInSearchArea(ShortPoint2D centerPos,IAttackable attackable,short searchRadius,boolean includeTowers){
  return null;
}"
56131,"private void handleSelectPointAction(PointAction action){
  ShortPoint2D pos=action.getPosition();
  grid.postionClicked(pos.x,pos.y);
  if (activeAction == null) {
    ISelectable selected=getSelectableAt(pos);
    if (selected != null) {
      setSelection(new SelectionSet(selected));
    }
 else {
      setSelection(new SelectionSet());
    }
  }
 else {
switch (activeAction.getActionType()) {
case BUILD:
      EBuildingType type=previewBuilding;
    ShortPoint2D pos2=grid.getConstructablePosition(pos,type,playerId,InputSettings.USE_NEIGHBOR_POSITIONS_FOR_CONSTRUCTION);
  if (pos2 != null) {
    cancelBuildingCreation();
    scheduleTask(new GeneralGuiTask(EGuiAction.BUILD,playerId,pos2,type));
    break;
  }
 else {
    return;
  }
default :
break;
}
setActiveAction(null);
}
}","private void handleSelectPointAction(PointAction action){
  ShortPoint2D pos=action.getPosition();
  grid.postionClicked(pos.x,pos.y);
  if (activeAction == null) {
    ISelectable selected=getSelectableAt(pos);
    if (selected != null) {
      setSelection(new SelectionSet(selected));
    }
 else {
      setSelection(new SelectionSet());
    }
  }
 else {
switch (activeAction.getActionType()) {
case BUILD:
      EBuildingType type=previewBuilding;
    ShortPoint2D pos2=grid.getConstructablePosition(pos,type,playerId,InputSettings.USE_NEIGHBOR_POSITIONS_FOR_CONSTRUCTION);
  if (pos2 != null) {
    scheduleTask(new GeneralGuiTask(EGuiAction.BUILD,playerId,pos2,type));
  }
return;
default :
break;
}
setActiveAction(null);
}
}"
56132,"@Override public void deliver(EMaterialType materialType,ShortPoint2D offerPosition,IMaterialRequest request){
  request.deliveryAccepted();
  request.deliveryFulfilled();
}","@Override public boolean deliver(EMaterialType materialType,ShortPoint2D offerPosition,IMaterialRequest request){
  request.deliveryAccepted();
  request.deliveryFulfilled();
  return true;
}"
56133,"public void addJoblessAt(final ShortPoint2D pos){
  jobless.add(new IManagerBearer(){
    private static final long serialVersionUID=3833820381369081344L;
    @Override public ShortPoint2D getPos(){
      return pos;
    }
    @Override public void deliver(    EMaterialType materialType,    ShortPoint2D offerPosition,    IMaterialRequest request){
      request.deliveryAccepted();
      request.deliveryFulfilled();
    }
  }
);
}","public void addJoblessAt(final ShortPoint2D pos){
  jobless.add(new IManagerBearer(){
    private static final long serialVersionUID=3833820381369081344L;
    @Override public ShortPoint2D getPos(){
      return pos;
    }
    @Override public boolean deliver(    EMaterialType materialType,    ShortPoint2D offerPosition,    IMaterialRequest request){
      request.deliveryAccepted();
      request.deliveryFulfilled();
      return true;
    }
  }
);
}"
56134,"private void handleDiggerRequest(){
  DiggerRequest request=diggerRequests.peek();
  if (request != null && request.requester.isDiggerRequestActive()) {
    IManageableDigger digger=joblessDiggers.removeObjectNextTo(request.getPos());
    if (digger != null) {
      digger.setDiggerJob(request.requester);
      request.amount--;
      if (request.creationRequested > 0) {
        request.creationRequested--;
      }
    }
 else {
      if (request.amount > request.creationRequested) {
        if (createNewToolUserIfLimitNotExceeded(EMovableType.DIGGER,request.getPos())) {
          request.creationRequested++;
        }
      }
    }
    if (request.amount <= 0) {
      diggerRequests.poll();
    }
  }
}","private void handleDiggerRequest(){
  DiggerRequest request=diggerRequests.peek();
  if (request == null) {
    return;
  }
  if (request.requester.isDiggerRequestActive()) {
    IManageableDigger digger=joblessDiggers.removeObjectNextTo(request.getPos());
    if (digger != null) {
      digger.setDiggerJob(request.requester);
      request.amount--;
      if (request.creationRequested > 0) {
        request.creationRequested--;
      }
    }
 else {
      if (request.amount > request.creationRequested) {
        if (createNewToolUserIfLimitNotExceeded(EMovableType.DIGGER,request.getPos())) {
          request.creationRequested++;
        }
      }
    }
    if (request.amount <= 0) {
      diggerRequests.poll();
    }
  }
 else {
    diggerRequests.poll();
  }
}"
56135,"/** 
 * Checks if the given position is valid to build a building of given player that can stand on the given   {@link ELandscapeType}s. Bounds checks will be done by this method.
 * @param x x coordinate of the target position
 * @param y y coordinate of the target position
 * @param landscapeTypes allowed landscape types
 * @param player player
 * @return true if a building can be positioned at the given position<br>false otherwise.
 */
public abstract boolean canUsePositionForConstruction(int x,int y,ELandscapeType[] landscapeTypes,byte player);","/** 
 * Checks if the given position is valid to build a building of given player that can stand on the given   {@link ELandscapeType}s. Bounds checks will be done by this method.
 * @param x x coordinate of the target position
 * @param y y coordinate of the target position
 * @param landscapeTypes allowed landscape types
 * @param partitionId player
 * @return true if a building can be positioned at the given position<br>false otherwise.
 */
public abstract boolean canUsePositionForConstruction(int x,int y,ELandscapeType[] landscapeTypes,short partitionId);"
56136,"public void calculateConstructMarks(final MapRectangle mapArea,final BuildingAreaBitSet buildingArea,final ELandscapeType[] landscapeTypes,RelativePoint[] flattenPositions){
  if (lastArea != null) {
    removeConstructionMarks(lastArea,mapArea);
  }
  final short[] xJumps=buildingArea.xJumps;
  final short[] yJumps=buildingArea.yJumps;
  final int lineLength=mapArea.getLineLength() + mapArea.getHeight() / 2;
  final BitSet doneSet=new BitSet(lineLength * mapArea.getHeight());
  final int xOffsetForBuilding=buildingArea.minX;
  final int yOffsetForBuilding=buildingArea.minY;
  final int buildingAreaWidth=buildingArea.width;
  final int buildingAreaHeight=buildingArea.height;
  for (int line=0; line < mapArea.getHeight(); line++) {
    final int y=mapArea.getLineY(line);
    final int xLineOffset=mapArea.getMinX();
    DX_LOOP:     for (int dx=0; dx < lineLength; dx++) {
      final int x=xLineOffset + dx;
      if (!mapArea.contains(x,y) || doneSet.get(dx + line * lineLength)) {
        continue;
      }
      for (int buildingDx=buildingAreaWidth - 1; buildingDx >= 0; buildingDx--) {
        for (int buildingDy=buildingAreaHeight - 1; buildingDy >= 0; buildingDy--) {
          int index=buildingDx + buildingDy * buildingAreaWidth;
          if (xJumps[index] != 0 && !map.canUsePositionForConstruction(x + buildingDx + xOffsetForBuilding,y + buildingDy + yOffsetForBuilding,landscapeTypes,player)) {
            map.setConstructMarking(x,y,false,null);
            for (int pruneX=0; pruneX < xJumps[index]; pruneX++) {
              int currYJumps=yJumps[(buildingDx - pruneX) + buildingDy * buildingAreaWidth];
              for (int pruneY=0; pruneY < currYJumps; pruneY++) {
                if (pruneY == 0 && pruneX == 0) {
                  continue;
                }
                doneSet.set((dx + pruneX) + (line + pruneY) * lineLength);
                map.setConstructMarking(x + pruneX,y + pruneY,false,null);
              }
            }
            continue DX_LOOP;
          }
        }
      }
      map.setConstructMarking(x,y,true,flattenPositions);
    }
  }
  lastArea=mapArea;
}","public void calculateConstructMarks(final MapRectangle mapArea,final BuildingAreaBitSet buildingArea,final ELandscapeType[] landscapeTypes,RelativePoint[] flattenPositions){
  if (lastArea != null) {
    removeConstructionMarks(lastArea,mapArea);
  }
  final short[] xJumps=buildingArea.xJumps;
  final short[] yJumps=buildingArea.yJumps;
  final int lineLength=mapArea.getLineLength() + mapArea.getHeight() / 2;
  final BitSet doneSet=new BitSet(lineLength * mapArea.getHeight());
  final int xOffsetForBuilding=buildingArea.minX;
  final int yOffsetForBuilding=buildingArea.minY;
  final int buildingAreaWidth=buildingArea.width;
  final int buildingAreaHeight=buildingArea.height;
  for (int line=0; line < mapArea.getHeight(); line++) {
    final int y=mapArea.getLineY(line);
    final int xLineOffset=mapArea.getMinX();
    DX_LOOP:     for (int dx=0; dx < lineLength; dx++) {
      final int x=xLineOffset + dx;
      final short partitionId;
{
        int firstPosX=buildingArea.aPosition.calculateX(x);
        int firstPosY=buildingArea.aPosition.calculateY(y);
        partitionId=map.getPartitionIdAt(firstPosX,firstPosY);
        if (!map.canPlayerConstructOnPartition(playerId,partitionId)) {
          continue DX_LOOP;
        }
      }
      if (!mapArea.contains(x,y) || doneSet.get(dx + line * lineLength)) {
        continue;
      }
      for (int buildingDx=buildingAreaWidth - 1; buildingDx >= 0; buildingDx--) {
        for (int buildingDy=buildingAreaHeight - 1; buildingDy >= 0; buildingDy--) {
          int index=buildingDx + buildingDy * buildingAreaWidth;
          if (xJumps[index] != 0 && !map.canUsePositionForConstruction(x + buildingDx + xOffsetForBuilding,y + buildingDy + yOffsetForBuilding,landscapeTypes,partitionId)) {
            map.setConstructMarking(x,y,false,null);
            for (int pruneX=0; pruneX < xJumps[index]; pruneX++) {
              int currYJumps=yJumps[(buildingDx - pruneX) + buildingDy * buildingAreaWidth];
              for (int pruneY=0; pruneY < currYJumps; pruneY++) {
                if (pruneY == 0 && pruneX == 0) {
                  continue;
                }
                doneSet.set((dx + pruneX) + (line + pruneY) * lineLength);
                map.setConstructMarking(x + pruneX,y + pruneY,false,null);
              }
            }
            continue DX_LOOP;
          }
        }
      }
      map.setConstructMarking(x,y,true,flattenPositions);
    }
  }
  lastArea=mapArea;
}"
56137,"public NewConstructionMarksAlgorithm(AbstractConstructionMarkableMap map,byte player){
  this.map=map;
  this.player=player;
}","public NewConstructionMarksAlgorithm(AbstractConstructionMarkableMap map,byte player){
  this.map=map;
  this.playerId=player;
}"
56138,"public boolean equals(ShortPoint2D other){
  return other != null && other.x == x && other.y == y;
}","public boolean equals(int x,int y){
  return this.x == x && this.y == y;
}"
56139,"@Override public final OccupyerPlace addSoldier(IBuildingOccupyableMovable soldier){
  OccupyerPlace freePosition=findFreePositionFor(soldier.getSoldierType());
  emptyPlaces.remove(freePosition);
  currentlyCommingSoldiers[freePosition.getType().ordinal()]--;
  TowerOccupier towerOccupier=new TowerOccupier(freePosition,soldier);
  occupiers.add(towerOccupier);
  occupyAreaIfNeeded();
  soldier.setSelected(super.isSelected());
  addInformableMapObject(towerOccupier,true);
  return freePosition;
}","@Override public final OccupyerPlace addSoldier(IBuildingOccupyableMovable soldier){
  OccupyerPlace freePosition=findFreePositionFor(soldier.getSoldierType());
  currentlyCommingSoldiers[freePosition.getType().ordinal()]--;
  emptyPlaces.remove(freePosition);
  TowerOccupier towerOccupier=new TowerOccupier(freePosition,soldier);
  occupiers.add(towerOccupier);
  occupyAreaIfNeeded();
  soldier.setSelected(super.isSelected());
  addInformableMapObject(towerOccupier,true);
  return freePosition;
}"
56140,"public final boolean canOccupyBuilding(){
  return getMovableType().getSelectionType() == ESelectionType.SOLDIERS;
}","public final boolean canOccupyBuilding(){
  return movableType.getSelectionType() == ESelectionType.SOLDIERS;
}"
56141,"public void checkPlayerOfPosition(Player playerOfPosition){
  if (playerOfPosition != player && !strategy.isMoveToAble() && strategy.getClass() != FleeStrategy.class) {
    setStrategy(new FleeStrategy(this));
  }
}","public void checkPlayerOfPosition(Player playerOfPosition){
  if (playerOfPosition != player && movableType.needsPlayersGround() && strategy.getClass() != FleeStrategy.class) {
    setStrategy(new FleeStrategy(this));
  }
}"
56142,"@Override protected void strategyKilledEvent(ShortPoint2D pathTarget){
  if (building != null) {
    if (isInTower) {
      building.removeSoldier(this);
    }
 else {
      building.requestFailed(movableType);
    }
  }
}","@Override protected void strategyKilledEvent(ShortPoint2D pathTarget){
  if (building != null) {
    if (isInTower) {
      building.removeSoldier(this);
    }
 else {
      notifyTowerThatRequestFailed();
    }
  }
}"
56143,"@Override protected void action(){
switch (state) {
case AGGRESSIVE:
    break;
case HITTING:
  hitEnemy(enemy);
if (state != ESoldierState.HITTING) {
  break;
}
if (enemy.getHealth() <= 0) {
enemy=null;
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
break;
}
case SEARCH_FOR_ENEMIES:
IAttackable oldEnemy=enemy;
enemy=super.getStrategyGrid().getEnemyInSearchArea(getAttackPosition(),super.getMovable(),getSearchDistance(isInTower),!defending);
if (oldEnemy != null && oldEnemy != enemy) {
inSaveGotoMode=false;
}
if (enemy == null) {
if (defending) {
building.towerDefended(this);
defending=false;
}
changeStateTo(ESoldierState.AGGRESSIVE);
break;
}
if (isEnemyAttackable(enemy,isInTower)) {
super.lookInDirection(EDirection.getApproxDirection(super.getPos(),enemy.getPos()));
startAttackAnimation(enemy);
changeStateTo(ESoldierState.HITTING);
}
 else if (!isInTower) {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
goToEnemy(enemy);
}
 else {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
}
break;
case INIT_GOTO_TOWER:
if (super.getPos().equals(building.getDoor()) || super.goToPos(building.getDoor())) {
changeStateTo(ESoldierState.GOING_TO_TOWER);
}
 else {
building.requestFailed(this.movableType);
building=null;
state=ESoldierState.AGGRESSIVE;
}
break;
case GOING_TO_TOWER:
if (building.isNotDestroyed() && building.getPlayer() == super.getPlayer()) {
OccupyerPlace place=building.addSoldier(this);
super.setPosition(place.getPosition().calculatePoint(building.getDoor()));
super.enableNothingToDoAction(false);
super.setVisible(false);
if (isBowman()) {
this.inTowerAttackPosition=building.getTowerBowmanSearchPosition(place);
}
changeStateTo(ESoldierState.AGGRESSIVE);
isInTower=true;
}
 else {
changeStateTo(ESoldierState.AGGRESSIVE);
building=null;
}
break;
}
}","@Override protected void action(){
switch (state) {
case AGGRESSIVE:
    break;
case HITTING:
  hitEnemy(enemy);
if (state != ESoldierState.HITTING) {
  break;
}
if (enemy.getHealth() <= 0) {
enemy=null;
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
break;
}
case SEARCH_FOR_ENEMIES:
IAttackable oldEnemy=enemy;
enemy=super.getStrategyGrid().getEnemyInSearchArea(getAttackPosition(),super.getMovable(),getSearchDistance(isInTower),!defending);
if (oldEnemy != null && oldEnemy != enemy) {
inSaveGotoMode=false;
}
if (enemy == null) {
if (defending) {
building.towerDefended(this);
defending=false;
}
changeStateTo(ESoldierState.AGGRESSIVE);
break;
}
if (isEnemyAttackable(enemy,isInTower)) {
super.lookInDirection(EDirection.getApproxDirection(super.getPos(),enemy.getPos()));
startAttackAnimation(enemy);
changeStateTo(ESoldierState.HITTING);
}
 else if (!isInTower) {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
goToEnemy(enemy);
}
 else {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
}
break;
case INIT_GOTO_TOWER:
if (super.getPos().equals(building.getDoor()) || super.goToPos(building.getDoor())) {
changeStateTo(ESoldierState.GOING_TO_TOWER);
}
 else {
notifyTowerThatRequestFailed();
}
break;
case GOING_TO_TOWER:
if (building.isNotDestroyed() && building.getPlayer() == super.getPlayer()) {
OccupyerPlace place=building.addSoldier(this);
super.setPosition(place.getPosition().calculatePoint(building.getDoor()));
super.enableNothingToDoAction(false);
super.setVisible(false);
if (isBowman()) {
this.inTowerAttackPosition=building.getTowerBowmanSearchPosition(place);
}
changeStateTo(ESoldierState.AGGRESSIVE);
isInTower=true;
}
 else {
changeStateTo(ESoldierState.AGGRESSIVE);
building=null;
}
break;
}
}"
56144,"public static void main(String[] args) throws FileNotFoundException, IOException, InterruptedException {
  HashMap<String,String> argsMap=MainUtils.createArgumentsMap(args);
  SwingManagedJSettlers.setupResourceManagers(argsMap,new File(""String_Node_Str""));
  int targetGameTime=Integer.valueOf(argsMap.get(""String_Node_Str"")) * 60 * 1000;
  OfflineNetworkConnector networkConnector=new OfflineNetworkConnector();
  JSettlersGame game=getReplayGame(argsMap,networkConnector);
  IStartingGame startingGame=game.start();
  ReplayToolApp replayTool=new ReplayToolApp();
  replayTool.waitForGameStartup(startingGame);
  networkConnector.scheduleTaskAt(targetGameTime / NetworkConstants.Client.LOCKSTEP_PERIOD,new SimpleGuiTask(EGuiAction.QUICK_SAVE,(byte)0));
  MatchConstants.clock.fastForwardTo(targetGameTime);
  MapLoader newSavegame=MapList.getDefaultList().getSavedMaps().get(0);
  replayTool.createReplayOfRemainingTasks(newSavegame);
  Thread.sleep(2000);
  System.exit(0);
}","public static void main(String[] args) throws FileNotFoundException, IOException, InterruptedException {
  HashMap<String,String> argsMap=MainUtils.createArgumentsMap(args);
  SwingManagedJSettlers.loadDebugSettings(argsMap);
  SwingManagedJSettlers.setupResourceManagers(argsMap,new File(""String_Node_Str""));
  int targetGameTime=Integer.valueOf(argsMap.get(""String_Node_Str"")) * 60 * 1000;
  OfflineNetworkConnector networkConnector=new OfflineNetworkConnector();
  JSettlersGame game=getReplayGame(argsMap,networkConnector);
  IStartingGame startingGame=game.start();
  ReplayToolApp replayTool=new ReplayToolApp();
  replayTool.waitForGameStartup(startingGame);
  networkConnector.scheduleTaskAt(targetGameTime / NetworkConstants.Client.LOCKSTEP_PERIOD,new SimpleGuiTask(EGuiAction.QUICK_SAVE,(byte)0));
  MatchConstants.clock.fastForwardTo(targetGameTime);
  MapLoader newSavegame=MapList.getDefaultList().getSavedMaps().get(0);
  replayTool.createReplayOfRemainingTasks(newSavegame);
  Thread.sleep(2000);
  System.exit(0);
}"
56145,"private static void loadDebugSettings(HashMap<String,String> argsMap){
  if (argsMap.containsKey(""String_Node_Str"")) {
    CommonConstants.ENABLE_ALL_PLAYER_FOG_OF_WAR=true;
    CommonConstants.ENABLE_ALL_PLAYER_SELECTION=true;
    CommonConstants.ENABLE_FOG_OF_WAR_DISABLING=true;
  }
  if (argsMap.containsKey(""String_Node_Str"")) {
    CommonConstants.DEFAULT_SERVER_ADDRESS=""String_Node_Str"";
  }
}","public static void loadDebugSettings(HashMap<String,String> argsMap){
  if (argsMap.containsKey(""String_Node_Str"")) {
    CommonConstants.ENABLE_ALL_PLAYER_FOG_OF_WAR=true;
    CommonConstants.ENABLE_ALL_PLAYER_SELECTION=true;
    CommonConstants.ENABLE_FOG_OF_WAR_DISABLING=true;
  }
  if (argsMap.containsKey(""String_Node_Str"")) {
    CommonConstants.DEFAULT_SERVER_ADDRESS=""String_Node_Str"";
  }
}"
56146,"private void drawMovableAt(IMovable movable,Image image,int x,int y){
  byte fogstatus=context.getVisibleStatus(x,y);
  if (fogstatus == 0) {
    return;
  }
  Color color=context.getPlayerColor(movable.getPlayerId());
  float shade=MapObjectDrawer.getColor(fogstatus);
  float viewX;
  float viewY;
  if (movable.getAction() == EAction.WALKING) {
    int originx=x - movable.getDirection().getGridDeltaX();
    int originy=y - movable.getDirection().getGridDeltaY();
    viewX=betweenTilesX(originx,originy,x,y,movable.getMoveProgress());
    viewY=betweenTilesY;
  }
 else {
    int height=context.getHeight(x,y);
    viewX=context.getConverter().getViewX(x,y,height);
    viewY=context.getConverter().getViewY(x,y,height);
  }
  image.drawAt(context.getGl(),context.getDrawBuffer(),viewX,viewY,color,shade);
  if (movable.isSelected()) {
    drawSelectionMark(viewX,viewY,movable.getHealth());
  }
}","private void drawMovableAt(IMovable movable,Image image,int x,int y){
  byte fogstatus=context.getVisibleStatus(x,y);
  if (fogstatus <= CommonConstants.FOG_OF_WAR_EXPLORED) {
    return;
  }
  Color color=context.getPlayerColor(movable.getPlayerId());
  float shade=MapObjectDrawer.getColor(fogstatus);
  float viewX;
  float viewY;
  if (movable.getAction() == EAction.WALKING) {
    int originx=x - movable.getDirection().getGridDeltaX();
    int originy=y - movable.getDirection().getGridDeltaY();
    viewX=betweenTilesX(originx,originy,x,y,movable.getMoveProgress());
    viewY=betweenTilesY;
  }
 else {
    int height=context.getHeight(x,y);
    viewX=context.getConverter().getViewX(x,y,height);
    viewY=context.getConverter().getViewY(x,y,height);
  }
  image.drawAt(context.getGl(),context.getDrawBuffer(),viewX,viewY,color,shade);
  if (movable.isSelected()) {
    drawSelectionMark(viewX,viewY,movable.getHealth());
  }
}"
56147,"/** 
 * Draws a player border at a given position.
 * @param player The player.
 */
public void drawPlayerBorderObject(int x,int y,byte player){
  forceSetup();
  byte fogstatus=context.getVisibleStatus(x,y);
  if (fogstatus == 0) {
    return;
  }
  float base=getColor(fogstatus);
  Color color=context.getPlayerColor(player);
  draw(imageProvider.getSettlerSequence(FILE_BORDERPOST,65).getImageSafe(0),x,y,color,base);
}","/** 
 * Draws a player border at a given position.
 * @param player The player.
 */
public void drawPlayerBorderObject(int x,int y,byte player){
  forceSetup();
  byte fogstatus=context.getVisibleStatus(x,y);
  if (fogstatus <= CommonConstants.FOG_OF_WAR_EXPLORED) {
    return;
  }
  float base=getColor(fogstatus);
  Color color=context.getPlayerColor(player);
  draw(imageProvider.getSettlerSequence(FILE_BORDERPOST,65).getImageSafe(0),x,y,color,base);
}"
56148,"/** 
 * Draws a given buildng to the context.
 * @param context
 * @param building
 * @param color Gray color shade
 */
private void drawBuilding(int x,int y,IBuilding building,float color){
  EBuildingType type=building.getBuildingType();
  float state=building.getStateProgress();
  float maskState;
  if (state < 0.5f) {
    maskState=state * 2;
    for (    ImageLink link : type.getBuildImages()) {
      Image image=imageProvider.getImage(link);
      drawWithConstructionMask(x,y,maskState,image,color);
    }
  }
 else   if (state < 0.99) {
    maskState=state * 2 - 1;
    for (    ImageLink link : type.getBuildImages()) {
      Image image=imageProvider.getImage(link);
      draw(image,x,y,color);
    }
    for (    ImageLink link : type.getImages()) {
      Image image=imageProvider.getImage(link);
      drawWithConstructionMask(x,y,maskState,image,color);
    }
  }
 else {
    if (type == EBuildingType.MILL && ((IBuilding.IMill)building).isRotating()) {
      Sequence<? extends Image> seq=this.imageProvider.getSettlerSequence(MILL_FILE,MILL_SEQ);
      if (seq.length() > 0) {
        int i=getAnimationStep(x,y);
        int step=i % seq.length();
        draw(seq.getImageSafe(step),x,y,color);
      }
      playSound(building,42);
    }
 else {
      ImageLink[] images=type.getImages();
      if (images.length > 0) {
        Image image=imageProvider.getImage(images[0]);
        draw(image,x,y,color);
      }
      if (building instanceof IBuilding.IOccupyed) {
        drawOccupiers(x,y,(IBuilding.IOccupyed)building,color);
      }
      for (int i=1; i < images.length; i++) {
        Image image=imageProvider.getImage(images[i]);
        draw(image,x,y,color);
      }
    }
  }
  if (building.isSelected()) {
    drawBuildingSelectMarker(x,y);
  }
}","/** 
 * Draws a given buildng to the context.
 * @param context
 * @param building
 * @param color Gray color shade
 */
private void drawBuilding(int x,int y,IBuilding building,float color){
  EBuildingType type=building.getBuildingType();
  float state=building.getStateProgress();
  float maskState;
  if (state < 0.5f) {
    maskState=state * 2;
    for (    ImageLink link : type.getBuildImages()) {
      Image image=imageProvider.getImage(link);
      drawWithConstructionMask(x,y,maskState,image,color);
    }
  }
 else   if (state < 0.99) {
    maskState=state * 2 - 1;
    for (    ImageLink link : type.getBuildImages()) {
      Image image=imageProvider.getImage(link);
      draw(image,x,y,color);
    }
    for (    ImageLink link : type.getImages()) {
      Image image=imageProvider.getImage(link);
      drawWithConstructionMask(x,y,maskState,image,color);
    }
  }
 else {
    if (type == EBuildingType.MILL && ((IBuilding.IMill)building).isRotating()) {
      Sequence<? extends Image> seq=this.imageProvider.getSettlerSequence(MILL_FILE,MILL_SEQ);
      if (seq.length() > 0) {
        int i=getAnimationStep(x,y);
        int step=i % seq.length();
        draw(seq.getImageSafe(step),x,y,color);
      }
      playSound(building,42);
    }
 else {
      ImageLink[] images=type.getImages();
      if (images.length > 0) {
        Image image=imageProvider.getImage(images[0]);
        draw(image,x,y,color);
      }
      if (building instanceof IBuilding.IOccupyed && context.getVisibleStatus(x,y) > CommonConstants.FOG_OF_WAR_EXPLORED) {
        drawOccupiers(x,y,(IBuilding.IOccupyed)building,color);
      }
      for (int i=1; i < images.length; i++) {
        Image image=imageProvider.getImage(images[i]);
        draw(image,x,y,color);
      }
    }
  }
  if (building.isSelected()) {
    drawBuildingSelectMarker(x,y);
  }
}"
56149,"private void pathingAction(){
  if (progress >= 1) {
    if (path.isFinished() || !strategy.checkPathStepPreconditions(path.getTargetPos(),path.getStep())) {
      setState(ENewMovableState.DOING_NOTHING);
      movableAction=EAction.NO_ACTION;
      path=null;
      return;
    }
    direction=EDirection.getDirection(position.x,position.y,path.nextX(),path.nextY());
    if (grid.hasNoMovableAt(path.nextX(),path.nextY())) {
      goSinglePathStep();
    }
 else {
      boolean pushedSuccessful=grid.getMovableAt(path.nextX(),path.nextY()).push(this);
      if (!pushedSuccessful) {
        delayCtr++;
        if (delayCtr > 4) {
          delayCtr=0;
          path=strategy.findWayAroundObstacle(direction,position,path);
        }
      }
      return;
    }
  }
 else {
    progress+=WALKING_PROGRESS_INCREASE;
  }
}","private void pathingAction(){
  if (progress >= 1) {
    if (path.isFinished() || !strategy.checkPathStepPreconditions(path.getTargetPos(),path.getStep())) {
      setState(ENewMovableState.DOING_NOTHING);
      movableAction=EAction.NO_ACTION;
      path=null;
      checkPlayerOfCurrentPosition();
      return;
    }
    direction=EDirection.getDirection(position.x,position.y,path.nextX(),path.nextY());
    if (grid.hasNoMovableAt(path.nextX(),path.nextY())) {
      goSinglePathStep();
    }
 else {
      boolean pushedSuccessful=grid.getMovableAt(path.nextX(),path.nextY()).push(this);
      if (!pushedSuccessful) {
        delayCtr++;
        if (delayCtr > 4) {
          delayCtr=0;
          path=strategy.findWayAroundObstacle(direction,position,path);
        }
      }
      return;
    }
  }
 else {
    progress+=WALKING_PROGRESS_INCREASE;
  }
}"
56150,"public void checkPlayerOfPosition(Player currentPlayer){
  if (currentPlayer != player && !strategy.isMoveToAble()) {
    abortCurrentWork();
    Path path=grid.searchDijkstra(this,position.x,position.y,Constants.MOVABLE_FLEE_BACK_TO_COUNTRY_RADIUS,ESearchType.OWN_GROUND);
    if (path != null) {
      followPath(path);
    }
 else {
      kill();
    }
  }
}","public void checkPlayerOfPosition(Player playerOfPosition){
  if (playerOfPosition != player && !strategy.isMoveToAble()) {
    abortCurrentWork();
    Path path=grid.searchDijkstra(this,position.x,position.y,Constants.MOVABLE_FLEE_BACK_TO_COUNTRY_RADIUS,ESearchType.OWN_GROUND);
    if (path != null) {
      followPath(path);
    }
 else {
      kill();
    }
  }
}"
56151,"/** 
 * Adds all elements of this list to the given   {@link DoubleLinkedList}. After this operation this list will not contain any elements.
 * @param newList The list to append all the elements of this list.
 */
public void mergeInto(DoubleLinkedList<T> newList){
  newList.head.prev.next=this.head.next;
  this.head.next.prev=newList.head.prev;
  this.head.prev.next=newList.head;
  newList.head.prev=this.head.prev;
  this.head.next=this.head;
  this.head.prev=this.head;
  this.size=0;
}","/** 
 * Adds all elements of this list to the given   {@link DoubleLinkedList}. After this operation this list will not contain any elements.
 * @param newList The list to append all the elements of this list.
 */
public void mergeInto(DoubleLinkedList<T> newList){
  newList.head.prev.next=this.head.next;
  this.head.next.prev=newList.head.prev;
  this.head.prev.next=newList.head;
  newList.head.prev=this.head.prev;
  newList.size+=size;
  clear();
}"
56152,"@Override protected void action(){
switch (state) {
case JOBLESS:
    break;
case INIT_JOB:
  if (super.goToPos(bricklayerTargetPos)) {
    this.state=EBricklayerState.GOING_TO_POS;
  }
 else {
    makeJobless();
  }
break;
case GOING_TO_POS:
super.lookInDirection(lookDirection);
state=EBricklayerState.BUILDING;
case BUILDING:
tryToBuild();
break;
}
}","@Override protected void action(){
switch (state) {
case JOBLESS:
    break;
case INIT_JOB:
  if (!constructionSite.isConstructionFinished() && super.goToPos(bricklayerTargetPos)) {
    this.state=EBricklayerState.GOING_TO_POS;
  }
 else {
    makeJobless();
  }
break;
case GOING_TO_POS:
super.lookInDirection(lookDirection);
state=EBricklayerState.BUILDING;
case BUILDING:
tryToBuild();
break;
}
}"
56153,"@Test public void testMerge(){
  DoubleLinkedList<DoubleLinkedIntListItem> list2=new DoubleLinkedList<DoubleLinkedIntListItem>();
  for (int i=0; i < TEST_NUMBERS; i++) {
    list.pushEnd(new DoubleLinkedIntListItem(i));
    list2.pushEnd(new DoubleLinkedIntListItem(i));
  }
  list2.mergeInto(list);
  assertEquals(0,list2.size());
  assertEquals(list2.head,((DoubleLinkedListItem<DoubleLinkedIntListItem>)list2.head).next);
  assertEquals(list2.head,((DoubleLinkedListItem<DoubleLinkedIntListItem>)list2.head).prev);
  int i=0;
  for (  DoubleLinkedIntListItem curr : list) {
    assertEquals(i % TEST_NUMBERS,curr.value);
    i++;
  }
}","@Test public void testMerge(){
  DoubleLinkedList<DoubleLinkedIntListItem> list2=new DoubleLinkedList<DoubleLinkedIntListItem>();
  for (int i=0; i < TEST_NUMBERS; i++) {
    list.pushEnd(new DoubleLinkedIntListItem(i));
    list2.pushEnd(new DoubleLinkedIntListItem(i));
  }
  list2.mergeInto(list);
  assertEquals(0,list2.size());
  assertEquals(TEST_NUMBERS * 2,list.size());
  assertEquals(list2.head,((DoubleLinkedListItem<DoubleLinkedIntListItem>)list2.head).next);
  assertEquals(list2.head,((DoubleLinkedListItem<DoubleLinkedIntListItem>)list2.head).prev);
  int i=0;
  for (  DoubleLinkedIntListItem curr : list) {
    assertEquals(i % TEST_NUMBERS,curr.value);
    i++;
  }
}"
56154,"@Override public final boolean setBuilding(ShortPoint2D position,Building newBuilding){
  if (MainGrid.this.isInBounds(position.x,position.y)) {
    FreeMapArea protectedArea=new FreeMapArea(position,newBuilding.getBuildingType().getProtectedTiles());
    if (canConstructAt(protectedArea)) {
      setProtectedState(protectedArea,true);
      mapObjectsManager.addBuildingTo(position,newBuilding);
      objectsGrid.setBuildingArea(new FreeMapArea(position,newBuilding.getBuildingType().getBlockedTiles()),newBuilding);
      return true;
    }
 else {
      return false;
    }
  }
 else {
    return false;
  }
}","@Override public final boolean setBuilding(ShortPoint2D position,Building newBuilding){
  if (MainGrid.this.isInBounds(position.x,position.y)) {
    FreeMapArea protectedArea=new FreeMapArea(position,newBuilding.getBuildingType().getProtectedTiles());
    if (canConstructAt(protectedArea)) {
      setProtectedState(protectedArea,true);
      mapObjectsManager.addBuildingTo(position,newBuilding);
      objectsGrid.setBuildingArea(new FreeMapArea(position,newBuilding.getBuildingType().getBlockedTiles()),newBuilding);
      landscapeGrid.stopUnflattening(protectedArea);
      return true;
    }
 else {
      return false;
    }
  }
 else {
    return false;
  }
}"
56155,"private final void setProtectedState(FreeMapArea area,boolean setProtected){
  for (  ShortPoint2D curr : area) {
    if (MainGrid.this.isInBounds(curr.x,curr.y))     flagsGrid.setProtected(curr.x,curr.y,setProtected);
  }
}","private final void setProtectedState(FreeMapArea area,boolean setProtected){
  for (  ShortPoint2D curr : area) {
    flagsGrid.setProtected(curr.x,curr.y,setProtected);
  }
}"
56156,"@Override public final int getDebugColorAt(int x,int y){
  final int SCALE=4;
  int value=partitionsGrid.getPartitionIdAt(x,y);
  return Color.getABGR(((float)(value % SCALE)) / SCALE,((float)((value / SCALE) % SCALE)) / SCALE,((float)((value / SCALE / SCALE) % SCALE)) / SCALE,1);
}","@Override public final int getDebugColorAt(int x,int y){
  return flagsGrid.isMarked(x,y) ? Color.ORANGE.getARGB() : (objectsGrid.getMapObjectAt(x,y,EMapObjectType.INFORMABLE_MAP_OBJECT) != null ? Color.GREEN.getARGB() : (objectsGrid.getMapObjectAt(x,y,EMapObjectType.ATTACKABLE_TOWER) != null ? Color.RED.getARGB() : (flagsGrid.isBlocked(x,y) ? Color.BLACK.getARGB() : (flagsGrid.isProtected(x,y) ? Color.BLUE.getARGB() : 0))));
}"
56157,"@Override public final int getDebugColorAt(int x,int y){
  return flagsGrid.isMarked(x,y) ? Color.ORANGE.getARGB() : (objectsGrid.getMapObjectAt(x,y,EMapObjectType.INFORMABLE_MAP_OBJECT) != null ? Color.GREEN.getARGB() : (objectsGrid.getMapObjectAt(x,y,EMapObjectType.ATTACKABLE_TOWER) != null ? Color.RED.getARGB() : (flagsGrid.isBlocked(x,y) ? Color.BLACK.getARGB() : (flagsGrid.isProtected(x,y) ? Color.BLUE.getARGB() : 0))));
}","@Override public final int getDebugColorAt(int x,int y){
  final int SCALE=4;
  int value=partitionsGrid.getPartitionIdAt(x,y);
  return Color.getABGR(((float)(value % SCALE)) / SCALE,((float)((value / SCALE) % SCALE)) / SCALE,((float)((value / SCALE / SCALE) % SCALE)) / SCALE,1);
}"
56158,"/** 
 * Lets the given movable enter the given position.
 * @param position Position to be entered.
 * @param movable Movable that enters the position.
 */
public final void movableEntered(ShortPoint2D position,NewMovable movable){
  short x=position.x;
  short y=position.y;
  int idx=x + y * width;
  if (idx < 0) {
    System.out.println(""String_Node_Str"");
  }
  this.movableGrid[idx]=movable;
  if (movable != null && movable.getMovableType() == EMovableType.BEARER) {
    ground.walkOn(x,y);
  }
}","/** 
 * Lets the given movable enter the given position.
 * @param position Position to be entered.
 * @param movable Movable that enters the position.
 */
public final void movableEntered(ShortPoint2D position,NewMovable movable){
  short x=position.x;
  short y=position.y;
  int idx=x + y * width;
  if (idx < 0) {
    System.out.println(""String_Node_Str"");
  }
  NewMovable oldMovable=this.movableGrid[idx];
  if (oldMovable != null && oldMovable.getID() == -2147481896) {
    System.out.println();
  }
  this.movableGrid[idx]=movable;
  if (movable != null && movable.getMovableType() == EMovableType.BEARER) {
    ground.walkOn(x,y);
  }
}"
56159,"/** 
 * kills this movable.
 */
@Override public final void kill(){
  MovableTimer.remove(this);
  grid.leavePosition(this.position,this);
  this.health=0;
  this.strategy.strategyKilledEvent(path != null ? path.getTargetPos() : null);
  movablesByID.remove(this.getID());
  allMovables.remove(this);
  grid.addSelfDeletingMapObject(position,EMapObjectType.GHOST,Constants.GHOST_PLAY_DURATION,player);
}","/** 
 * kills this movable.
 */
@Override public final void kill(){
  if (health == -100) {
    return;
  }
  MovableTimer.remove(this);
  grid.leavePosition(this.position,this);
  this.health=-100;
  this.strategy.strategyKilledEvent(path != null ? path.getTargetPos() : null);
  movablesByID.remove(this.getID());
  allMovables.remove(this);
  grid.addSelfDeletingMapObject(position,EMapObjectType.GHOST,Constants.GHOST_PLAY_DURATION,player);
}"
56160,"@Override public void eventDataChanged(GOEvent event){
  Action action=getActionForDraw((GODrawEvent)event);
  if (action.getActionType() == EActionType.PAN_TO) {
    minimap.getContext().scrollTo(((PointAction)action).getPosition());
  }
}","@Override public void eventDataChanged(GOEvent event){
  Action action=getActionForDraw((GODrawEvent)event);
  if (action != null && action.getActionType() == EActionType.PAN_TO) {
    minimap.getContext().scrollTo(((PointAction)action).getPosition());
  }
}"
56161,"private void handleJobFailed(boolean reportAsJobless){
switch (state) {
case INIT_CARRY_JOB:
case GOING_TO_OFFER:
    reoffer();
case TAKING:
  if (targetMovableType != null) {
    workerRequester.workerCreationRequestFailed(targetMovableType,super.getPos());
  }
case GOING_TO_REQUEST:
if (request != null && request.isActive()) {
  request.deliveryAborted();
}
break;
case INIT_BECOME_SOLDIER_JOB:
case GOING_TO_BARRACK:
barrack.bearerRequestFailed();
break;
case DROPPING:
break;
case INIT_CONVERT_WITH_TOOL_JOB:
reoffer();
case INIT_CONVERT_JOB:
workerRequester.workerCreationRequestFailed(targetMovableType,super.getPos());
break;
case DEAD_OBJECT:
break;
case JOBLESS:
break;
default :
break;
}
EMaterialType carriedMaterial=super.setMaterial(EMaterialType.NO_MATERIAL);
if (carriedMaterial != EMaterialType.NO_MATERIAL) {
super.getStrategyGrid().dropMaterial(super.getPos(),materialType,true);
}
offer=null;
request=null;
materialType=null;
targetMovableType=null;
workerRequester=null;
state=EBearerState.JOBLESS;
if (reportAsJobless) {
reportAsJobless();
}
}","private void handleJobFailed(boolean reportAsJobless){
switch (state) {
case INIT_CARRY_JOB:
case GOING_TO_OFFER:
    reoffer();
case TAKING:
  if (targetMovableType != null) {
    workerRequester.workerCreationRequestFailed(targetMovableType,super.getPos());
  }
case GOING_TO_REQUEST:
if (request != null) {
  request.deliveryAborted();
}
break;
case INIT_BECOME_SOLDIER_JOB:
case GOING_TO_BARRACK:
barrack.bearerRequestFailed();
break;
case DROPPING:
break;
case INIT_CONVERT_WITH_TOOL_JOB:
reoffer();
case INIT_CONVERT_JOB:
workerRequester.workerCreationRequestFailed(targetMovableType,super.getPos());
break;
case DEAD_OBJECT:
break;
case JOBLESS:
break;
default :
break;
}
EMaterialType carriedMaterial=super.setMaterial(EMaterialType.NO_MATERIAL);
if (carriedMaterial != EMaterialType.NO_MATERIAL) {
super.getStrategyGrid().dropMaterial(super.getPos(),materialType,true);
}
offer=null;
request=null;
materialType=null;
targetMovableType=null;
workerRequester=null;
state=EBearerState.JOBLESS;
if (reportAsJobless) {
reportAsJobless();
}
}"
56162,"private void updateFiles(DefaultHttpClient httpClient,UpdateListener c) throws IOException, ClientProtocolException {
  c.setProgressState(""String_Node_Str"",-1);
  if (serverrev == null) {
    serverrev=loadRevision(httpClient);
  }
  final String url=SERVER_ROOT + ""String_Node_Str"";
  HttpGet httpRequest=new HttpGet(url);
  HttpResponse response=httpClient.execute(httpRequest);
  ZipInputStream inputStream=new ZipInputStream(response.getEntity().getContent());
  try {
    int files=0;
    byte[] buffer=new byte[1024];
    long size=response.getEntity().getContentLength();
    long read=0;
    ZipEntry entry;
    while ((entry=inputStream.getNextEntry()) != null) {
      String name=entry.getName();
      c.setProgressState(""String_Node_Str"",(float)read / size);
      if (name.startsWith(RESOURCE_PREFIX)) {
        String outfilename=destdir.getAbsolutePath() + ""String_Node_Str"" + name.substring(RESOURCE_PREFIX.length());
        File outfile=new File(outfilename);
        if (entry.isDirectory()) {
          if (outfile.exists() && !outfile.isDirectory()) {
            outfile.delete();
          }
          if (!outfile.isDirectory()) {
            outfile.mkdirs();
          }
        }
 else {
          File tmpFile=new File(outfilename + ""String_Node_Str"");
          tmpFile.getParentFile().mkdirs();
          tmpFile.deleteOnExit();
          FileOutputStream out=new FileOutputStream(tmpFile);
          while (true) {
            int len=inputStream.read(buffer);
            if (len <= 0) {
              break;
            }
            read+=len;
            out.write(buffer,0,len);
          }
          out.close();
          tmpFile.renameTo(outfile);
          files++;
        }
      }
    }
    System.out.println(""String_Node_Str"" + files + ""String_Node_Str"");
    writeMyVersion(getVersionFile(),serverrev);
    prefs.edit().putInt(PREF_REVISION,Revision.REVISION).putBoolean(PREF_OUTDATED,false).commit();
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
  setUpdating(false);
}","private void updateFiles(DefaultHttpClient httpClient,UpdateListener c) throws IOException, ClientProtocolException {
  c.setProgressState(""String_Node_Str"",-1);
  if (serverData == null) {
    serverData=loadRevision(httpClient);
  }
  final String url=SERVER_ROOT + ""String_Node_Str"";
  HttpGet httpRequest=new HttpGet(url);
  HttpResponse response=httpClient.execute(httpRequest);
  InputStream compressed=response.getEntity().getContent();
  ZipInputStream inputStream=new ZipInputStream(compressed);
  try {
    int files=0;
    byte[] buffer=new byte[1024];
    long read=0;
    ZipEntry entry;
    while ((entry=inputStream.getNextEntry()) != null) {
      String name=entry.getName();
      c.setProgressState(""String_Node_Str"",(float)read / serverData.size);
      System.out.println(""String_Node_Str"" + read + ""String_Node_Str""+ serverData.size);
      if (name.startsWith(RESOURCE_PREFIX)) {
        String outfilename=destdir.getAbsolutePath() + ""String_Node_Str"" + name.substring(RESOURCE_PREFIX.length());
        File outfile=new File(outfilename);
        if (entry.isDirectory()) {
          if (outfile.exists() && !outfile.isDirectory()) {
            outfile.delete();
          }
          if (!outfile.isDirectory()) {
            outfile.mkdirs();
          }
        }
 else {
          File tmpFile=new File(outfilename + ""String_Node_Str"");
          tmpFile.getParentFile().mkdirs();
          tmpFile.deleteOnExit();
          FileOutputStream out=new FileOutputStream(tmpFile);
          while (true) {
            int len=inputStream.read(buffer);
            if (len <= 0) {
              break;
            }
            read+=len;
            out.write(buffer,0,len);
          }
          out.close();
          tmpFile.renameTo(outfile);
          files++;
        }
      }
    }
    System.out.println(""String_Node_Str"" + files + ""String_Node_Str"");
    prefs.edit().putInt(PREF_REVISION,REVISION).putBoolean(PREF_OUTDATED,false).putString(PREF_RESOURCEVERSION,serverData.revision).commit();
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
  setUpdating(false);
}"
56163,"public boolean needsUpdate(){
  return needsUpdate;
}","public boolean needsUpdate(){
  return prefs.getBoolean(PREF_OUTDATED,true);
}"
56164,"public void startUpdate(final UpdateListener listener){
  if (isUpdating()) {
    return;
  }
  needsUpdate=false;
  setUpdating(true);
  new Thread(new Runnable(){
    @Override public void run(){
      try {
        updateFiles(createClient(),listener);
      }
 catch (      Throwable t) {
        setUpdating(false);
      }
      listener.setProgressState(""String_Node_Str"",1);
      if (listener != null) {
        listener.resourceUpdateFinished();
      }
    }
  }
,""String_Node_Str"").start();
}","public void startUpdate(final UpdateListener listener){
  if (isUpdating()) {
    return;
  }
  setUpdating(true);
  new Thread(new Runnable(){
    @Override public void run(){
      try {
synchronized (updateMutex) {
          updateFiles(createClient(),listener);
        }
      }
 catch (      Throwable t) {
        t.printStackTrace();
      }
      setUpdating(false);
      listener.setProgressState(""String_Node_Str"",1);
      if (listener != null) {
        listener.resourceUpdateFinished();
      }
    }
  }
,""String_Node_Str"").start();
}"
56165,"public ResourceUpdater(Context context,File destdir){
  this.resources=context.getResources();
  this.prefs=context.getSharedPreferences(""String_Node_Str"",0);
  this.destdir=destdir;
  int revHash=Revision.REVISION + LogicRevision.REVISION * 10000;
  if (prefs.getInt(PREF_REVISION,-1) != revHash || prefs.getBoolean(PREF_OUTDATED,false)) {
    needsUpdate=true;
  }
}","public ResourceUpdater(Context context,File destdir){
  this.resources=context.getResources();
  this.prefs=context.getSharedPreferences(""String_Node_Str"",0);
  this.destdir=destdir;
  int revHash=REVISION;
  if (prefs.getInt(PREF_REVISION,-1) != revHash) {
    requireUpdate();
  }
}"
56166,"@Override public void run(){
  try {
    updateFiles(createClient(),listener);
  }
 catch (  Throwable t) {
    setUpdating(false);
  }
  listener.setProgressState(""String_Node_Str"",1);
  if (listener != null) {
    listener.resourceUpdateFinished();
  }
}","@Override public void run(){
  try {
synchronized (updateMutex) {
      updateFiles(createClient(),listener);
    }
  }
 catch (  Throwable t) {
    t.printStackTrace();
  }
  setUpdating(false);
  listener.setProgressState(""String_Node_Str"",1);
  if (listener != null) {
    listener.resourceUpdateFinished();
  }
}"
56167,"private static String loadRevision(DefaultHttpClient httpClient) throws IOException, ClientProtocolException {
  final String url=SERVER_ROOT + ""String_Node_Str"";
  HttpGet httpRequest=new HttpGet(url);
  HttpResponse response=httpClient.execute(httpRequest);
  InputStream inputStream=response.getEntity().getContent();
  return getString(inputStream);
}","private static ServerData loadRevision(DefaultHttpClient httpClient) throws IOException, ClientProtocolException {
  final String url=SERVER_ROOT + ""String_Node_Str"";
  HttpGet httpRequest=new HttpGet(url);
  HttpResponse response=httpClient.execute(httpRequest);
  InputStream inputStream=response.getEntity().getContent();
  return new ServerData(getString(inputStream));
}"
56168,"@Override public void run(){
  while (!stopped) {
    updateLine();
  }
}","@Override public void run(){
  while (!stopped) {
    try {
      updateLine();
    }
 catch (    Throwable e) {
      e.printStackTrace();
    }
  }
}"
56169,"@Override public final int getDebugColorAt(int x,int y){
  int value=partitionsGrid.getPartitionIdAt(x,y);
  return Color.getABGR((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
}","@Override public final int getDebugColorAt(int x,int y){
  int value=partitionsGrid.getTowerCountAt(x,y) + 1;
  return Color.getABGR((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
}"
56170,"@Override public void kill(){
  System.out.println(""String_Node_Str"");
  Timer100Milli.remove(this);
  placeReusableMaterials();
  releaseRequestStacks();
  this.state=STATE_DESTROYED;
  grid.removeBuildingAt(pos);
  grid.getMapObjectsManager().addSelfDeletingMapObject(pos,EMapObjectType.BUILDING_DECONSTRUCTION_SMOKE,BUILDING_DESTRUCTION_SMOKE_DURATION,player);
  placeAdditionalMapObjects(grid,pos,false);
  placeFlag(false);
  allBuildings.remove(this);
  killedEvent();
}","@Override public void kill(){
  System.out.println(""String_Node_Str"");
  Timer100Milli.remove(this);
  this.state=STATE_DESTROYED;
  grid.removeBuildingAt(pos);
  grid.getMapObjectsManager().addSelfDeletingMapObject(pos,EMapObjectType.BUILDING_DECONSTRUCTION_SMOKE,BUILDING_DESTRUCTION_SMOKE_DURATION,player);
  placeAdditionalMapObjects(grid,pos,false);
  placeFlag(false);
  allBuildings.remove(this);
  placeReusableMaterials();
  releaseRequestStacks();
  killedEvent();
}"
56171,"@Override protected void action(){
switch (state) {
case AGGRESSIVE:
    break;
case HITTING:
  hitEnemy(enemy);
if (state != ESoldierState.HITTING) {
  break;
}
if (enemy.getHealth() <= 0) {
enemy=null;
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
break;
}
case SEARCH_FOR_ENEMIES:
IAttackable oldEnemy=enemy;
enemy=super.getStrategyGrid().getEnemyInSearchArea(getAttackPosition(),super.getMovable(),getSearchDistance(isInTower));
if (oldEnemy != null && oldEnemy != enemy) {
inSaveGotoMode=false;
}
if (enemy == null) {
if (defending) {
building.towerDefended(this);
defending=false;
}
changeStateTo(ESoldierState.AGGRESSIVE);
break;
}
if (isEnemyAttackable(enemy,isInTower)) {
super.lookInDirection(EDirection.getApproxDirection(super.getPos(),enemy.getPos()));
startAttackAnimation(enemy);
changeStateTo(ESoldierState.HITTING);
}
 else if (!isInTower) {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
goToEnemy(enemy);
}
break;
case INIT_GOTO_TOWER:
if (super.getPos().equals(building.getDoor()) || super.goToPos(building.getDoor())) {
changeStateTo(ESoldierState.GOING_TO_TOWER);
}
 else {
building.requestFailed(this.movableType);
building=null;
state=ESoldierState.AGGRESSIVE;
}
break;
case GOING_TO_TOWER:
if (building.isNotDestroyed() && building.getPlayer() == super.getPlayer()) {
OccupyerPlace place=building.addSoldier(this);
super.setPosition(place.getPosition().calculatePoint(building.getDoor()));
super.enableNothingToDoAction(false);
super.setVisible(false);
if (isBowman()) {
this.inTowerAttackPosition=building.getTowerBowmanSearchPosition(place);
}
changeStateTo(ESoldierState.AGGRESSIVE);
isInTower=true;
}
 else {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
}
break;
}
}","@Override protected void action(){
switch (state) {
case AGGRESSIVE:
    break;
case HITTING:
  hitEnemy(enemy);
if (state != ESoldierState.HITTING) {
  break;
}
if (enemy.getHealth() <= 0) {
enemy=null;
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
break;
}
case SEARCH_FOR_ENEMIES:
IAttackable oldEnemy=enemy;
enemy=super.getStrategyGrid().getEnemyInSearchArea(getAttackPosition(),super.getMovable(),getSearchDistance(isInTower));
if (oldEnemy != null && oldEnemy != enemy) {
inSaveGotoMode=false;
}
if (enemy == null) {
if (defending) {
building.towerDefended(this);
defending=false;
}
changeStateTo(ESoldierState.AGGRESSIVE);
break;
}
if (isEnemyAttackable(enemy,isInTower)) {
super.lookInDirection(EDirection.getApproxDirection(super.getPos(),enemy.getPos()));
startAttackAnimation(enemy);
changeStateTo(ESoldierState.HITTING);
}
 else if (!isInTower) {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
goToEnemy(enemy);
}
break;
case INIT_GOTO_TOWER:
if (super.getPos().equals(building.getDoor()) || super.goToPos(building.getDoor())) {
changeStateTo(ESoldierState.GOING_TO_TOWER);
}
 else {
building.requestFailed(this.movableType);
building=null;
state=ESoldierState.AGGRESSIVE;
}
break;
case GOING_TO_TOWER:
if (building.isNotDestroyed() && building.getPlayer() == super.getPlayer()) {
OccupyerPlace place=building.addSoldier(this);
super.setPosition(place.getPosition().calculatePoint(building.getDoor()));
super.enableNothingToDoAction(false);
super.setVisible(false);
if (isBowman()) {
this.inTowerAttackPosition=building.getTowerBowmanSearchPosition(place);
}
changeStateTo(ESoldierState.AGGRESSIVE);
isInTower=true;
}
 else {
changeStateTo(ESoldierState.AGGRESSIVE);
building=null;
}
break;
}
}"
56172,"@Override public final int getDebugColorAt(int x,int y){
  return flagsGrid.isMarked(x,y) ? Color.ORANGE.getARGB() : (objectsGrid.getMapObjectAt(x,y,EMapObjectType.INFORMABLE_MAP_OBJECT) != null ? Color.GREEN.getARGB() : (objectsGrid.getMapObjectAt(x,y,EMapObjectType.ATTACKABLE_TOWER) != null ? Color.RED.getARGB() : (flagsGrid.isBlocked(x,y) ? Color.BLACK.getARGB() : (flagsGrid.isProtected(x,y) ? Color.BLUE.getARGB() : 0))));
}","@Override public final int getDebugColorAt(int x,int y){
  final int SCALE=4;
  int value=partitionsGrid.getPartitionIdAt(x,y);
  return Color.getABGR(((float)(value % SCALE)) / SCALE,((float)((value / SCALE) % SCALE)) / SCALE,((float)((value / SCALE / SCALE) % SCALE)) / SCALE,1);
}"
56173,"public LandscapeGrid(short width,short height){
  this.width=width;
  this.height=height;
  int tiles=width * height;
  this.heightGrid=new byte[tiles];
  this.landscapeGrid=new byte[tiles];
  this.resourceAmount=new byte[tiles];
  this.resourceType=new byte[tiles];
  this.temporaryFlatened=new byte[tiles];
  this.blockedPartitions=new short[tiles];
  initDebugColors();
  this.flattenedResetter=new FlattenedResetter(this);
  setBackgroundListener(null);
}","public LandscapeGrid(short width,short height){
  this.width=width;
  this.height=height;
  final int tiles=width * height;
  this.heightGrid=new byte[tiles];
  this.landscapeGrid=new byte[tiles];
  this.resourceAmount=new byte[tiles];
  this.resourceType=new byte[tiles];
  this.temporaryFlatened=new byte[tiles];
  this.blockedPartitions=new short[tiles];
  initDebugColors();
  this.flattenedResetter=new FlattenedResetter(this);
  setBackgroundListener(null);
}"
56174,"public final void setDebugColor(int x,int y,int argb){
  if (CommonConstants.ENABLE_DEBUG_COLORS) {
    debugColors[x + y * width]=argb;
  }
}","@Override public final void setDebugColor(int x,int y,int argb){
  if (CommonConstants.ENABLE_DEBUG_COLORS) {
    debugColors[x + y * width]=argb;
  }
}"
56175,"@Override public boolean contains(int x,int y){
  return grid.partitionRepresentatives[grid.partitions[x + y * width]] == partition;
}","@Override public boolean contains(int x,int y){
  return partitionRepresentatives[partitions[x + y * width]] == partition;
}"
56176,"/** 
 * Checks if the given partitions is divided and the both given positions are on separated parts of the partition.
 * @param partition
 * @param pos1
 * @param pos2
 */
private void checkIfDividePartition(Short partition,ShortPoint2D pos1,ShortPoint2D pos2){
  if (partition != NO_PLAYER_PARTITION_ID && !PartitionsDividedTester.isPartitionNotDivided(this,pos1,pos2,partition)) {
    dividePartition(partition,pos1,pos2);
  }
}","/** 
 * Checks if the given partitions is divided and the both given positions are on separated parts of the partition.
 * @param partition
 * @param pos1
 * @param pos2
 */
private void checkIfDividePartition(Short partition,ShortPoint2D pos1,ShortPoint2D pos2){
  if (partition != NO_PLAYER_PARTITION_ID && PartitionsDividedTester.isPartitionDivided(partitionRepresentatives,partitions,width,pos1,pos2,partition)) {
    dividePartition(partition,pos1,pos2);
  }
}"
56177,"@Override protected MaterialRequestObject getRequestForPrio(int prio){
  DoubleLinkedList<MaterialRequestObject> queue=queues[prio];
  int numberOfElements=queue.size();
  for (int handledElements=0; handledElements < numberOfElements; handledElements++) {
    MaterialRequestObject result=queue.getFront();
    int inDelivery=result.inDelivery;
    int stillNeeded=result.getStillNeeded();
    if (stillNeeded <= 0) {
      result.requestQueue=null;
      queue.popFront();
      numberOfElements--;
    }
 else     if (stillNeeded <= inDelivery || inDelivery >= result.getInDeliveryable()) {
      queue.pushEnd(queue.popFront());
    }
 else {
      if (result.isRoundRobinRequest()) {
        queue.pushEnd(queue.popFront());
      }
      return result;
    }
  }
  return null;
}","@Override protected MaterialRequestObject getRequestForPrio(int prio){
  DoubleLinkedList<MaterialRequestObject> queue=queues[prio];
  int numberOfElements=queue.size();
  for (int handledElements=0; handledElements < numberOfElements; handledElements++) {
    MaterialRequestObject request=queue.getFront();
    int inDelivery=request.inDelivery;
    int stillNeeded=request.getStillNeeded();
    if (stillNeeded <= 0) {
      request.requestQueue=null;
      queue.popFront();
      numberOfElements--;
    }
 else     if (stillNeeded <= inDelivery || inDelivery >= request.getInDeliveryable()) {
      queue.pushEnd(queue.popFront());
    }
 else {
      if (request.isRoundRobinRequest()) {
        queue.pushEnd(queue.popFront());
      }
      return request;
    }
  }
  return null;
}"
56178,"@Override public void kill(){
  System.out.println(""String_Node_Str"");
  Timer100Milli.remove(this);
  this.state=STATE_DESTROYED;
  grid.removeBuildingAt(pos);
  grid.getMapObjectsManager().addSelfDeletingMapObject(pos,EMapObjectType.BUILDING_DECONSTRUCTION_SMOKE,BUILDING_DESTRUCTION_SMOKE_DURATION,player);
  placeAdditionalMapObjects(grid,pos,false);
  placeFlag(false);
  allBuildings.remove(this);
  placeReusableMaterials();
  releaseRequestStacks();
  killedEvent();
}","@Override public void kill(){
  System.out.println(""String_Node_Str"");
  Timer100Milli.remove(this);
  grid.removeBuildingAt(pos);
  grid.getMapObjectsManager().addSelfDeletingMapObject(pos,EMapObjectType.BUILDING_DECONSTRUCTION_SMOKE,BUILDING_DESTRUCTION_SMOKE_DURATION,player);
  placeAdditionalMapObjects(grid,pos,false);
  placeFlag(false);
  allBuildings.remove(this);
  placeReusableMaterials();
  releaseRequestStacks();
  this.state=STATE_DESTROYED;
  killedEvent();
}"
56179,"@Override public final int getDebugColorAt(int x,int y){
  int value=partitionsGrid.getTowerCountAt(x,y) + 1;
  return Color.getABGR((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
}","@Override public final int getDebugColorAt(int x,int y){
  int value=partitionsGrid.getPartitionIdAt(x,y);
  return Color.getABGR((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
}"
56180,"private void goToDiggablePosition(){
  ShortPoint2D diggablePos=getDiggablePosition();
  if (diggablePos != null) {
    if (super.goToPos(diggablePos)) {
      state=EDiggerState.GOING_TO_POS;
      super.getStrategyGrid().setMarked(diggablePos,true);
    }
 else {
      reportAsJobless();
    }
  }
 else {
    reportAsJobless();
  }
}","private void goToDiggablePosition(){
  super.getStrategyGrid().setMarked(super.getPos(),false);
  ShortPoint2D diggablePos=getDiggablePosition();
  if (diggablePos != null) {
    if (super.goToPos(diggablePos)) {
      state=EDiggerState.GOING_TO_POS;
      super.getStrategyGrid().setMarked(diggablePos,true);
    }
 else {
      reportAsJobless();
    }
  }
 else {
    reportAsJobless();
  }
}"
56181,"private void executeDigg(){
  ShortPoint2D pos=super.getPos();
  super.getStrategyGrid().changeHeightTowards(pos.x,pos.y,requester.getAverageHeight());
  super.getStrategyGrid().setMarked(super.getPos(),false);
}","private void executeDigg(){
  ShortPoint2D pos=super.getPos();
  super.getStrategyGrid().changeHeightTowards(pos.x,pos.y,requester.getAverageHeight());
}"
56182,"@Override public void receiveHit(float strength,ShortPoint2D attackerPos,byte attackingPlayer){
  NewMovable attacker=getGrid().getMovable(attackerPos);
  if (attacker != null && attacker.getPlayer() == getPlayer()) {
    return;
  }
  if (doorHealth > 0) {
    doorHealth-=strength / Constants.DOOR_HIT_RESISTENCY_FACTOR;
    if (doorHealth <= 0) {
      doorHealth=0;
      inFight=true;
      OccupyingBuilding.this.getGrid().getMapObjectsManager().addSelfDeletingMapObject(getPos(),EMapObjectType.GHOST,Constants.GHOST_PLAY_DURATION,getPlayer());
      pollNewDefender();
    }
  }
 else   if (currDefender != null) {
    IAttackableMovable movable=currDefender.getSoldier().getMovable();
    movable.receiveHit(strength,attackerPos,attackingPlayer);
    if (movable.getHealth() <= 0) {
      if (occupiers.isEmpty()) {
        currDefender=null;
        changePlayerTo(attackerPos);
      }
 else {
        emptyPlaces.add(currDefender.place);
        searchedSoldiers.add(getSearchType(currDefender.getSoldier().getMovableType()));
        pollNewDefender();
      }
    }
  }
  OccupyingBuilding.this.getPlayer().showMessage(SimpleMessage.attacked(attackingPlayer,attackerPos));
}","@Override public void receiveHit(float strength,ShortPoint2D attackerPos,byte attackingPlayer){
  NewMovable attacker=getGrid().getMovable(attackerPos);
  if (attacker != null && attacker.getPlayer() == getPlayer()) {
    return;
  }
  if (doorHealth > 0) {
    doorHealth-=strength / Constants.DOOR_HIT_RESISTENCY_FACTOR;
    if (doorHealth <= 0) {
      doorHealth=0;
      inFight=true;
      OccupyingBuilding.this.getGrid().getMapObjectsManager().addSelfDeletingMapObject(getPos(),EMapObjectType.GHOST,Constants.GHOST_PLAY_DURATION,getPlayer());
      pollNewDefender(attackerPos);
    }
  }
 else   if (currDefender != null) {
    IAttackableMovable movable=currDefender.getSoldier().getMovable();
    movable.receiveHit(strength,attackerPos,attackingPlayer);
    if (movable.getHealth() <= 0) {
      emptyPlaces.add(currDefender.place);
      searchedSoldiers.add(getSearchType(currDefender.getSoldier().getMovableType()));
      pollNewDefender(attackerPos);
    }
  }
  OccupyingBuilding.this.getPlayer().showMessage(SimpleMessage.attacked(attackingPlayer,attackerPos));
}"
56183,"private void pollNewDefender(){
  if (occupiers.isEmpty()) {
    currDefender=null;
  }
 else {
    currDefender=removeSoldier();
    currDefender.getSoldier().setDefendingAt(getPos());
  }
}","private void pollNewDefender(ShortPoint2D attackerPos){
  if (occupiers.isEmpty()) {
    currDefender=null;
    changePlayerTo(attackerPos);
  }
 else {
    currDefender=removeSoldier();
    currDefender.getSoldier().setDefendingAt(getPos());
  }
}"
56184,"public void movePositionTo(ShortPoint2D position,MaterialsManager newManager){
  for (int i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
    requestQueues[i].moveObjectsOfPositionTo(position,newManager.requestQueues[i]);
  }
}","public void movePositionTo(ShortPoint2D position,MaterialsManager newManager){
  for (int i=0; i < EMaterialType.NUMBER_OF_MATERIALS; i++) {
    requestQueues[i].moveObjectsOfPositionTo(position,newManager.requestQueues[i]);
  }
}"
56185,"public void mergeInto(MaterialsManager newManager){
  for (int i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
    requestQueues[i].mergeInto(newManager.requestQueues[i]);
  }
}","public void mergeInto(MaterialsManager newManager){
  for (int i=0; i < EMaterialType.NUMBER_OF_MATERIALS; i++) {
    requestQueues[i].mergeInto(newManager.requestQueues[i]);
  }
}"
56186,void setOccupyableBuilding(IOccupyableBuilding building);,boolean setOccupyableBuilding(IOccupyableBuilding building);
56187,"public final boolean setOccupyableBuilding(IOccupyableBuilding building){
  if (canOccupyBuilding()) {
    ((SoldierStrategy)strategy).setOccupyableBuilding(building);
    return true;
  }
 else {
    return false;
  }
}","public final boolean setOccupyableBuilding(IOccupyableBuilding building){
  if (canOccupyBuilding()) {
    return ((SoldierStrategy)strategy).setOccupyableBuilding(building);
  }
 else {
    return false;
  }
}"
56188,"@Override public void setOccupyableBuilding(IOccupyableBuilding building){
  this.building=building;
  changeStateTo(ESoldierState.INIT_GOTO_TOWER);
  super.abortPath();
  this.oldPathTarget=null;
}","@Override public boolean setOccupyableBuilding(IOccupyableBuilding building){
  if (state != ESoldierState.GOING_TO_TOWER && state != ESoldierState.INIT_GOTO_TOWER) {
    this.building=building;
    changeStateTo(ESoldierState.INIT_GOTO_TOWER);
    super.abortPath();
    this.oldPathTarget=null;
    return true;
  }
 else {
    return false;
  }
}"
56189,"@Override protected void action(){
switch (state) {
case AGGRESSIVE:
    break;
case HITTING:
  hitEnemy(enemy);
if (state != ESoldierState.HITTING) {
  break;
}
if (enemy.getHealth() <= 0) {
enemy=null;
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
break;
}
case SEARCH_FOR_ENEMIES:
IAttackable oldEnemy=enemy;
enemy=super.getStrategyGrid().getEnemyInSearchArea(getAttackPosition(),super.getMovable(),getSearchDistance(isInTower));
if (oldEnemy != null && oldEnemy != enemy) {
inSaveGotoMode=false;
}
if (enemy == null) {
if (defending) {
building.towerDefended(this);
defending=false;
}
changeStateTo(ESoldierState.AGGRESSIVE);
break;
}
if (isEnemyAttackable(enemy,isInTower)) {
super.lookInDirection(EDirection.getApproxDirection(super.getPos(),enemy.getPos()));
startAttackAnimation(enemy);
changeStateTo(ESoldierState.HITTING);
}
 else if (!isInTower) {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
goToEnemy(enemy);
}
break;
case INIT_GOTO_TOWER:
super.goToPos(building.getDoor());
changeStateTo(ESoldierState.GOING_TO_TOWER);
break;
case GOING_TO_TOWER:
if (building.isNotDestroyed() && building.getPlayer() == super.getPlayer()) {
OccupyerPlace place=building.addSoldier(this);
super.setPosition(place.getPosition().calculatePoint(building.getDoor()));
super.enableNothingToDoAction(false);
super.setVisible(false);
if (isBowman()) {
this.inTowerAttackPosition=building.getTowerBowmanSearchPosition(place);
}
changeStateTo(ESoldierState.AGGRESSIVE);
isInTower=true;
}
 else {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
}
break;
}
}","@Override protected void action(){
switch (state) {
case AGGRESSIVE:
    break;
case HITTING:
  hitEnemy(enemy);
if (state != ESoldierState.HITTING) {
  break;
}
if (enemy.getHealth() <= 0) {
enemy=null;
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
break;
}
case SEARCH_FOR_ENEMIES:
IAttackable oldEnemy=enemy;
enemy=super.getStrategyGrid().getEnemyInSearchArea(getAttackPosition(),super.getMovable(),getSearchDistance(isInTower));
if (oldEnemy != null && oldEnemy != enemy) {
inSaveGotoMode=false;
}
if (enemy == null) {
if (defending) {
building.towerDefended(this);
defending=false;
}
changeStateTo(ESoldierState.AGGRESSIVE);
break;
}
if (isEnemyAttackable(enemy,isInTower)) {
super.lookInDirection(EDirection.getApproxDirection(super.getPos(),enemy.getPos()));
startAttackAnimation(enemy);
changeStateTo(ESoldierState.HITTING);
}
 else if (!isInTower) {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
goToEnemy(enemy);
}
break;
case INIT_GOTO_TOWER:
if (super.getPos().equals(building.getDoor()) || super.goToPos(building.getDoor())) {
changeStateTo(ESoldierState.GOING_TO_TOWER);
}
 else {
building.requestFailed(this.movableType);
building=null;
state=ESoldierState.AGGRESSIVE;
}
break;
case GOING_TO_TOWER:
if (building.isNotDestroyed() && building.getPlayer() == super.getPlayer()) {
OccupyerPlace place=building.addSoldier(this);
super.setPosition(place.getPosition().calculatePoint(building.getDoor()));
super.enableNothingToDoAction(false);
super.setVisible(false);
if (isBowman()) {
this.inTowerAttackPosition=building.getTowerBowmanSearchPosition(place);
}
changeStateTo(ESoldierState.AGGRESSIVE);
isInTower=true;
}
 else {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
}
break;
}
}"
56190,"@Override public void postionClicked(short x,short y){
  System.out.println(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str""+ partitionsGrid.getPlayerIdAt(x,y)+ ""String_Node_Str""+ partitionsGrid.getPartitionIdAt(x,y)+ ""String_Node_Str""+ partitionsGrid.getRealPartitionIdAt(x,y));
}","@Override public void postionClicked(short x,short y){
  System.out.println(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str""+ partitionsGrid.getPlayerIdAt(x,y)+ ""String_Node_Str""+ partitionsGrid.getPartitionIdAt(x,y)+ ""String_Node_Str""+ partitionsGrid.getRealPartitionIdAt(x,y)+ ""String_Node_Str""+ partitionsGrid.getTowerCountAt(x,y));
}"
56191,"@Override public final int getDebugColorAt(int x,int y){
  return flagsGrid.isMarked(x,y) ? Color.ORANGE.getARGB() : (objectsGrid.getMapObjectAt(x,y,EMapObjectType.INFORMABLE_MAP_OBJECT) != null ? Color.GREEN.getARGB() : (objectsGrid.getMapObjectAt(x,y,EMapObjectType.ATTACKABLE_TOWER) != null ? Color.RED.getARGB() : (flagsGrid.isBlocked(x,y) ? Color.BLACK.getARGB() : (flagsGrid.isProtected(x,y) ? Color.BLUE.getARGB() : 0))));
}","@Override public final int getDebugColorAt(int x,int y){
  int value=partitionsGrid.getPartitionIdAt(x,y);
  return Color.getABGR((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
}"
56192,"public void removePositionTo(final int x,final int y,final Partition newPartitionObject){
  if (this == newPartitionObject) {
    System.out.println(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"");
  }
  this.decrement(x,y);
  newPartitionObject.increment(x,y);
  super.removePositionTo(x,y,newPartitionObject,newPartitionObject.playerId == this.playerId);
  if (isEmpty())   super.stopManager();
}","public void removePositionTo(final int x,final int y,final Partition newPartitionObject){
  if (this == newPartitionObject) {
    System.err.println(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"");
  }
  this.decrement(x,y);
  newPartitionObject.increment(x,y);
  super.removePositionTo(x,y,newPartitionObject,newPartitionObject.playerId == this.playerId);
  if (isEmpty())   super.stopManager();
}"
56193,"public void setPartitionAt(int x,int y,short newPartition){
  if (getPartitionIdAt(x,y) != partitionRepresentatives[newPartition]) {
    if (x == 106 && y == 212) {
      System.out.println();
    }
    changePartitionUncheckedAt(x,y,newPartition);
  }
}","public void setPartitionAt(int x,int y,short newPartition){
  if (getPartitionIdAt(x,y) != partitionRepresentatives[newPartition]) {
    if (x == 106 && y == 212) {
      System.out.println();
    }
    byte playerId=changePartitionUncheckedAt(x,y,newPartition);
    notifyPlayerChangedListener(x,y,playerId);
  }
}"
56194,"/** 
 * Changes the partition at the given position to the given new partition. <br> NOTE: There will be no checks if the new partition exists or if this change divides an other partition or should lead to a merge.
 * @param x x coordinate of the position.
 * @param y y coordinate of the position.
 * @param newPartition The new partition that will be set at the given partition.
 */
void changePartitionUncheckedAt(int x,int y,short newPartition){
  int idx=x + y * width;
  Partition oldPartitionObject=partitionObjects[partitions[idx]];
  Partition newPartitionObject=partitionObjects[newPartition];
  oldPartitionObject.removePositionTo(x,y,newPartitionObject);
synchronized (partitionsWriteLock) {
    partitions[idx]=newPartition;
  }
  if (oldPartitionObject.playerId != newPartitionObject.playerId) {
    playerChangedListener.playerChangedAt(x,y,newPartitionObject.playerId);
  }
}","/** 
 * Changes the partition at the given position to the given new partition. <br> NOTE: There will be no checks if the new partition exists or if this change divides an other partition or should lead to a merge.
 * @param x x coordinate of the position.
 * @param y y coordinate of the position.
 * @param newPartition The new partition that will be set at the given partition.
 * @return the player id of the new partition.
 */
byte changePartitionUncheckedAt(int x,int y,short newPartition){
  int idx=x + y * width;
  Partition oldPartitionObject=partitionObjects[partitions[idx]];
  Partition newPartitionObject=partitionObjects[newPartition];
  oldPartitionObject.removePositionTo(x,y,newPartitionObject);
synchronized (partitionsWriteLock) {
    partitions[idx]=newPartition;
  }
  return newPartitionObject.playerId;
}"
56195,"public void changePlayerAt(ShortPoint2D position,byte playerId){
  int idx=position.x + position.y * width;
  if (towers[idx] <= 0) {
    short newPartition=createNewPartition(playerId);
    changePartitionUncheckedAt(position.x,position.y,newPartition);
    PartitionsListingBorderVisitor borderVisitor=new PartitionsListingBorderVisitor(this,blockingProvider);
    for (    EDirection currDir : EDirection.values) {
      borderVisitor.visit(currDir.gridDeltaX + position.x,currDir.gridDeltaY + position.y);
    }
    checkMergesAndDividesOnPartitionsList(playerId,newPartition,borderVisitor.getPartitionsList());
  }
}","public void changePlayerAt(ShortPoint2D position,byte playerId){
  int idx=position.x + position.y * width;
  if (towers[idx] <= 0) {
    short newPartition=createNewPartition(playerId);
    changePartitionUncheckedAt(position.x,position.y,newPartition);
    notifyPlayerChangedListener(position.x,position.y,playerId);
    PartitionsListingBorderVisitor borderVisitor=new PartitionsListingBorderVisitor(this,blockingProvider);
    for (    EDirection currDir : EDirection.values) {
      borderVisitor.visit(currDir.gridDeltaX + position.x,currDir.gridDeltaY + position.y);
    }
    checkMergesAndDividesOnPartitionsList(playerId,newPartition,borderVisitor.getPartitionsList());
  }
}"
56196,"/** 
 * Occupies the given area for the given playerId.
 * @param playerId
 * @param filteredInfluencingArea
 * @param borders
 */
private void occupyArea(final byte playerId,Iterable<ShortPoint2D> influencingArea,SRectangle borders){
  IPredicate<ShortPoint2D> predicate=new IPredicate<ShortPoint2D>(){
    @Override public boolean evaluate(    ShortPoint2D pos){
      int index=pos.x + pos.y * width;
      return towers[index] <= 0 && partitionObjects[partitions[index]].playerId != playerId;
    }
  }
;
  IteratorFilter<ShortPoint2D> filtered=new IteratorFilter<ShortPoint2D>(influencingArea,predicate);
  PartitionCalculatorAlgorithm partitioner=new PartitionCalculatorAlgorithm(filtered,blockingProvider,borders.xMin,borders.yMin,borders.xMax,borders.yMax);
  partitioner.calculatePartitions();
  short[] newPartitionsMap=acquirePartitionedArea(playerId,partitioner);
  checkForMergesAndDivides(playerId,partitioner,newPartitionsMap);
  changeTowerCounter(playerId,influencingArea,+1);
}","/** 
 * Occupies the given area for the given playerId.
 * @param playerId
 * @param filteredInfluencingArea
 * @param borders
 */
private void occupyArea(final byte playerId,Iterable<ShortPoint2D> influencingArea,SRectangle borders){
  IPredicate<ShortPoint2D> predicate=new IPredicate<ShortPoint2D>(){
    @Override public boolean evaluate(    ShortPoint2D pos){
      int index=pos.x + pos.y * width;
      return towers[index] <= 0 && partitionObjects[partitions[index]].playerId != playerId;
    }
  }
;
  Iterable<ShortPoint2D> filtered=new IteratorFilter<ShortPoint2D>(influencingArea,predicate).toList();
  PartitionCalculatorAlgorithm partitioner=new PartitionCalculatorAlgorithm(filtered,blockingProvider,borders.xMin,borders.yMin,borders.xMax,borders.yMax);
  partitioner.calculatePartitions();
  short[] newPartitionsMap=acquirePartitionedArea(playerId,partitioner);
  checkForMergesAndDivides(playerId,partitioner,newPartitionsMap);
  changeTowerCounter(playerId,influencingArea,+1);
  for (  ShortPoint2D curr : filtered) {
    notifyPlayerChangedListener(curr.x,curr.y,playerId);
  }
}"
56197,"@Override public void executeTask(TaskPacket iTask){
  if (!(iTask instanceof SimpleGuiTask)) {
    return;
  }
  SimpleGuiTask guiTask=(SimpleGuiTask)iTask;
  System.out.println(""String_Node_Str"" + guiTask.getGuiAction());
switch (guiTask.getGuiAction()) {
case SET_WORK_AREA:
{
      WorkAreaGuiTask task=(WorkAreaGuiTask)guiTask;
      setWorkArea(task.getPosition(),task.getBuildingPos().x,task.getBuildingPos().y);
    }
  break;
case BUILD:
{
  GeneralGuiTask task=(GeneralGuiTask)guiTask;
  grid.constructBuildingAt(task.getPosition(),task.getType());
}
break;
case MOVE_TO:
{
MoveToGuiTask task=(MoveToGuiTask)guiTask;
moveSelectedTo(task.getPosition(),task.getSelection());
}
break;
case QUICK_SAVE:
try {
grid.save(guiInterface.getUIState());
}
 catch (FileNotFoundException e) {
e.printStackTrace();
}
catch (IOException e) {
e.printStackTrace();
}
catch (InterruptedException e) {
e.printStackTrace();
}
break;
case DESTROY_BUILDING:
{
ShortPoint2D buildingPos=((DestroyBuildingGuiTask)guiTask).getPosition();
((Building)grid.getBuildingAt(buildingPos.x,buildingPos.y)).kill();
}
break;
case DESTROY_MOVABLES:
killSelectedMovables(((MovableGuiTask)guiTask).getSelection());
break;
case START_WORKING:
case STOP_WORKING:
stopOrStartWorking(((MovableGuiTask)guiTask).getSelection(),guiTask.getGuiAction() == EGuiAction.STOP_WORKING);
break;
case CONVERT:
convertMovables((ConvertGuiTask)guiTask);
break;
case SET_BUILDING_PRIORITY:
setBuildingPriority((SetBuildingPriorityGuiTask)guiTask);
break;
case SET_MATERIAL_DISTRIBUTION_SETTINGS:
{
SetMaterialDistributionSettingsGuiTask task=(SetMaterialDistributionSettingsGuiTask)guiTask;
grid.setMaterialDistributionSettings(task.getManagerPosition(),task.getMaterialType(),task.getProbabilities());
}
break;
case SET_MATERIAL_PRIORITIES:
{
SetMaterialPrioritiesGuiTask task=(SetMaterialPrioritiesGuiTask)guiTask;
grid.setMaterialPrioritiesSetting(task.getManagerPosition(),task.getMaterialTypeForPriority());
}
break;
default :
break;
}
}","@Override public void executeTask(TaskPacket iTask){
  if (!(iTask instanceof SimpleGuiTask)) {
    return;
  }
  SimpleGuiTask guiTask=(SimpleGuiTask)iTask;
  System.out.println(""String_Node_Str"" + guiTask.getGuiAction());
switch (guiTask.getGuiAction()) {
case SET_WORK_AREA:
{
      WorkAreaGuiTask task=(WorkAreaGuiTask)guiTask;
      setWorkArea(task.getPosition(),task.getBuildingPos().x,task.getBuildingPos().y);
    }
  break;
case BUILD:
{
  GeneralGuiTask task=(GeneralGuiTask)guiTask;
  grid.constructBuildingAt(task.getPosition(),task.getType());
}
break;
case MOVE_TO:
{
MoveToGuiTask task=(MoveToGuiTask)guiTask;
moveSelectedTo(task.getPosition(),task.getSelection());
}
break;
case QUICK_SAVE:
try {
grid.save(guiInterface.getUIState());
}
 catch (FileNotFoundException e) {
e.printStackTrace();
}
catch (IOException e) {
e.printStackTrace();
}
catch (InterruptedException e) {
e.printStackTrace();
}
break;
case DESTROY_BUILDING:
{
ShortPoint2D buildingPos=((DestroyBuildingGuiTask)guiTask).getPosition();
Building building=((Building)grid.getBuildingAt(buildingPos.x,buildingPos.y));
if (building != null) {
building.kill();
}
}
break;
case DESTROY_MOVABLES:
killSelectedMovables(((MovableGuiTask)guiTask).getSelection());
break;
case START_WORKING:
case STOP_WORKING:
stopOrStartWorking(((MovableGuiTask)guiTask).getSelection(),guiTask.getGuiAction() == EGuiAction.STOP_WORKING);
break;
case CONVERT:
convertMovables((ConvertGuiTask)guiTask);
break;
case SET_BUILDING_PRIORITY:
setBuildingPriority((SetBuildingPriorityGuiTask)guiTask);
break;
case SET_MATERIAL_DISTRIBUTION_SETTINGS:
{
SetMaterialDistributionSettingsGuiTask task=(SetMaterialDistributionSettingsGuiTask)guiTask;
grid.setMaterialDistributionSettings(task.getManagerPosition(),task.getMaterialType(),task.getProbabilities());
}
break;
case SET_MATERIAL_PRIORITIES:
{
SetMaterialPrioritiesGuiTask task=(SetMaterialPrioritiesGuiTask)guiTask;
grid.setMaterialPrioritiesSetting(task.getManagerPosition(),task.getMaterialTypeForPriority());
}
break;
default :
break;
}
}"
56198,"@Override public final int getDebugColorAt(int x,int y){
  int value=partitionsGrid.getPartitionIdAt(x,y);
  return Color.getABGR((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
}","@Override public final int getDebugColorAt(int x,int y){
  return flagsGrid.isMarked(x,y) ? Color.ORANGE.getARGB() : (objectsGrid.getMapObjectAt(x,y,EMapObjectType.INFORMABLE_MAP_OBJECT) != null ? Color.GREEN.getARGB() : (objectsGrid.getMapObjectAt(x,y,EMapObjectType.ATTACKABLE_TOWER) != null ? Color.RED.getARGB() : (flagsGrid.isBlocked(x,y) ? Color.BLACK.getARGB() : (flagsGrid.isProtected(x,y) ? Color.BLUE.getARGB() : 0))));
}"
56199,"private void checkWorkerCreationRequests(){
  EMovableType[] movableTypes=workerCreationRequests.getSlotTypes();
  for (int slotIdx=0; slotIdx < movableTypes.length; slotIdx++) {
    WorkerCreationRequest workerRequest=workerCreationRequests.popFront(slotIdx);
    if (workerRequest != null) {
      EMaterialType tool=workerRequest.movableType.getTool();
      if (tool != EMaterialType.NO_MATERIAL) {
        if (toolRequestingWorkerRequests.getSlotSize(tool) <= 3) {
          MaterialOffer offer=this.materialOffers.removeOfferCloseTo(workerRequest.movableType.getTool(),workerRequest.position);
          if (offer != null) {
            IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(workerRequest.position);
            if (manageableBearer != null) {
              manageableBearer.becomeWorker(this,workerRequest.movableType,offer.getPos());
            }
 else {
              workerCreationRequests.pushLast(slotIdx,workerRequest);
            }
          }
 else {
            toolProductionRequests.add(tool,new ProductionRequest(tool,workerRequest.position));
            toolRequestingWorkerRequests.pushLast(tool,workerRequest);
          }
        }
 else {
          workerCreationRequests.pushLast(slotIdx,workerRequest);
        }
      }
 else {
        IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(workerRequest.position);
        if (manageableBearer != null) {
          manageableBearer.becomeWorker(this,workerRequest.movableType);
        }
 else {
          workerCreationRequests.pushLast(slotIdx,workerRequest);
        }
      }
    }
  }
}","private void checkWorkerCreationRequests(){
  EMovableType[] movableTypes=workerCreationRequests.getSlotTypes();
  for (int slotIdx=0; slotIdx < movableTypes.length; slotIdx++) {
    WorkerCreationRequest workerRequest=workerCreationRequests.popFront(slotIdx);
    if (workerRequest != null) {
      EMaterialType tool=workerRequest.movableType.getTool();
      if (tool != EMaterialType.NO_MATERIAL) {
        if (toolRequestingWorkerRequests.getSlotSize(tool) <= 3) {
          MaterialOffer offer=this.materialOffers.removeOfferCloseTo(tool,workerRequest.position);
          if (offer != null) {
            IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(workerRequest.position);
            if (manageableBearer != null) {
              manageableBearer.becomeWorker(this,workerRequest.movableType,offer.getPos());
            }
 else {
              workerCreationRequests.pushLast(slotIdx,workerRequest);
              materialOffers.addOffer(offer.getPos(),tool);
            }
          }
 else {
            toolProductionRequests.add(tool,new ProductionRequest(tool,workerRequest.position));
            toolRequestingWorkerRequests.pushLast(tool,workerRequest);
          }
        }
 else {
          workerCreationRequests.pushLast(slotIdx,workerRequest);
        }
      }
 else {
        IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(workerRequest.position);
        if (manageableBearer != null) {
          manageableBearer.becomeWorker(this,workerRequest.movableType);
        }
 else {
          workerCreationRequests.pushLast(slotIdx,workerRequest);
        }
      }
    }
  }
}"
56200,"@Override public void postionClicked(short x,short y){
  System.out.println(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str""+ partitionsGrid.getRealPartitionIdAt(x,y));
}","@Override public void postionClicked(short x,short y){
  System.out.println(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str""+ partitionsGrid.getPlayerIdAt(x,y)+ ""String_Node_Str""+ partitionsGrid.getPartitionIdAt(x,y)+ ""String_Node_Str""+ partitionsGrid.getRealPartitionIdAt(x,y));
}"
56201,"@Override public final int getDebugColorAt(int x,int y){
  return flagsGrid.isMarked(x,y) ? Color.ORANGE.getARGB() : (objectsGrid.getMapObjectAt(x,y,EMapObjectType.INFORMABLE_MAP_OBJECT) != null ? Color.GREEN.getARGB() : (objectsGrid.getMapObjectAt(x,y,EMapObjectType.ATTACKABLE_TOWER) != null ? Color.RED.getARGB() : (flagsGrid.isBlocked(x,y) ? Color.BLACK.getARGB() : (flagsGrid.isProtected(x,y) ? Color.BLUE.getARGB() : 0))));
}","@Override public final int getDebugColorAt(int x,int y){
  int value=partitionsGrid.getPartitionIdAt(x,y);
  return Color.getABGR((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
}"
56202,"public LinkedList<Tuple<Short,ShortPoint2D>> getPartitionsList(){
  if (partitionsList.size() >= 2 && partitionsList.getFirst().e1.equals(partitionsList.getLast().e1)) {
    partitionsList.removeFirst();
  }
  return partitionsList;
}","public LinkedList<Tuple<Short,ShortPoint2D>> getPartitionsList(){
  LinkedList<Tuple<Short,ShortPoint2D>> resultList=new LinkedList<Tuple<Short,ShortPoint2D>>();
  resultList.addAll(partitionsList);
  if (resultList.size() >= 2 && resultList.getFirst().e1.equals(resultList.getLast().e1)) {
    resultList.removeFirst();
  }
  return resultList;
}"
56203,"/** 
 * Reads a new file header from the stream.
 * @param stream The stream to read from.
 * @return
 */
public static MapFileHeader readFromStream(InputStream stream) throws IOException {
  try {
    DataInputStream in=new DataInputStream(stream);
    for (    byte b : START_BYTES) {
      if (in.readByte() != b) {
        throw new IOException(""String_Node_Str"");
      }
    }
    int version=in.readShort();
    if (version < MIN_VERSION) {
      throw new IOException(""String_Node_Str"");
    }
    String typeStr=in.readUTF();
    MapType type=MapType.valueOf(typeStr);
    String mapName=in.readUTF();
    String mapId=(version == 2) ? in.readUTF() : mapName;
    String baseMapId=(version == 2) ? in.readUTF() : null;
    String description=in.readUTF();
    short width=in.readShort();
    short height=in.readShort();
    short minplayer=in.readShort();
    short maxplayer=in.readShort();
    short[] bgimage=new short[PREVIEW_IMAGE_SIZE * PREVIEW_IMAGE_SIZE];
    for (int i=0; i < PREVIEW_IMAGE_SIZE * PREVIEW_IMAGE_SIZE; i++) {
      bgimage[i]=in.readShort();
    }
    ;
    Date date=null;
    if (type == MapType.SAVED_SINGLE) {
      long datetime=in.readLong();
      date=new Date(datetime);
    }
    return new MapFileHeader(type,mapName,mapId,baseMapId,description,width,height,minplayer,maxplayer,date,bgimage);
  }
 catch (  Throwable t) {
    if (t instanceof IOException) {
      throw (IOException)t;
    }
 else {
      throw new IOException(t);
    }
  }
}","/** 
 * Reads a new file header from the stream.
 * @param stream The stream to read from.
 * @return
 */
public static MapFileHeader readFromStream(InputStream stream) throws IOException {
  try {
    DataInputStream in=new DataInputStream(stream);
    for (    byte b : START_BYTES) {
      if (in.readByte() != b) {
        throw new IOException(""String_Node_Str"");
      }
    }
    int version=in.readShort();
    if (version < MIN_VERSION) {
      throw new IOException(""String_Node_Str"");
    }
    String typeStr=in.readUTF();
    MapType type=MapType.valueOf(typeStr);
    String mapName=in.readUTF();
    String mapId=(version == 2) ? in.readUTF() : mapName;
    String baseMapId=(version == 2) ? in.readUTF() : null;
    String description=in.readUTF();
    short width=in.readShort();
    short height=in.readShort();
    short minplayer=in.readShort();
    short maxplayer=in.readShort();
    short[] bgimage=new short[PREVIEW_IMAGE_SIZE * PREVIEW_IMAGE_SIZE];
    for (int i=0; i < PREVIEW_IMAGE_SIZE * PREVIEW_IMAGE_SIZE; i++) {
      bgimage[i]=in.readShort();
    }
    Date date=null;
    if (type == MapType.SAVED_SINGLE) {
      long datetime=in.readLong();
      date=new Date(datetime);
    }
    return new MapFileHeader(type,mapName,mapId,baseMapId,description,width,height,minplayer,maxplayer,date,bgimage);
  }
 catch (  Throwable t) {
    if (t instanceof IOException) {
      throw (IOException)t;
    }
 else {
      throw new IOException(t);
    }
  }
}"
56204,"public void writeTo(OutputStream stream) throws IOException {
  DataOutputStream out=new DataOutputStream(stream);
  out.write(START_BYTES);
  out.writeShort(VERSION);
  out.writeUTF(type.toString());
  out.writeUTF(name);
  out.writeUTF(mapId);
  out.writeUTF(baseMapId);
  out.writeUTF(description);
  out.writeShort(width);
  out.writeShort(height);
  out.writeShort(minPlayer);
  out.writeShort(maxPlayer);
  for (int i=0; i < PREVIEW_IMAGE_SIZE * PREVIEW_IMAGE_SIZE; i++) {
    out.writeShort(bgimage[i]);
  }
  ;
  if (type == MapType.SAVED_SINGLE) {
    out.writeLong(date.getTime());
  }
}","public void writeTo(OutputStream stream) throws IOException {
  DataOutputStream out=new DataOutputStream(stream);
  out.write(START_BYTES);
  out.writeShort(VERSION);
  out.writeUTF(type.toString());
  out.writeUTF(name);
  out.writeUTF(mapId);
  out.writeUTF(baseMapId == null ? ""String_Node_Str"" : baseMapId);
  out.writeUTF(description);
  out.writeShort(width);
  out.writeShort(height);
  out.writeShort(minPlayer);
  out.writeShort(maxPlayer);
  for (int i=0; i < PREVIEW_IMAGE_SIZE * PREVIEW_IMAGE_SIZE; i++) {
    out.writeShort(bgimage[i]);
  }
  ;
  if (type == MapType.SAVED_SINGLE) {
    out.writeLong(date.getTime());
  }
}"
56205,"/** 
 * Saves a random map to the given file.
 * @param header The header to save
 * @param definition The random map rule text.
 * @throws IOException
 */
public synchronized void saveRandomMap(MapFileHeader header,String definition) throws IOException {
  OutputStream out=getOutputStream(header);
  MapSaver.saveRandomMap(header,definition,out);
  loadFileList();
}","/** 
 * Saves a random map to the given file.
 * @param header The header to save
 * @param definition The random map rule text.
 * @throws IOException
 */
public synchronized void saveRandomMap(MapFileHeader header,String definition) throws IOException {
  OutputStream out=getOutputStream(header,mapsDir);
  MapSaver.saveRandomMap(header,definition,out);
  loadFileList();
}"
56206,"/** 
 * Gets an output stream that can be used to store the map. The stream is to a file with a nice name and does not override any other file.
 * @param header The header to create the file name from. It is not written to the stream.
 * @return A output stream to a fresh generated file.
 * @throws IOException
 */
private OutputStream getOutputStream(MapFileHeader header) throws IOException {
  String name=header.getName().toLowerCase().replaceAll(""String_Node_Str"",""String_Node_Str"");
  if (name.isEmpty()) {
    name=""String_Node_Str"";
  }
  Date date=header.getDate();
  if (date != null) {
    SimpleDateFormat format=new SimpleDateFormat(""String_Node_Str"");
    name+=format.format(date);
  }
  File file=new File(saveDir,name + MAP_EXTENSION);
  int i=1;
  while (file.exists()) {
    file=new File(saveDir,name + ""String_Node_Str"" + i+ MAP_EXTENSION);
    i++;
  }
  try {
    return new BufferedOutputStream(new FileOutputStream(file));
  }
 catch (  FileNotFoundException e) {
    throw new IOException(e);
  }
}","/** 
 * Gets an output stream that can be used to store the map. The stream is to a file with a nice name and does not override any other file.
 * @param header The header to create the file name from. It is not written to the stream.
 * @param baseDir The base directory where map should be saved.
 * @return A output stream to a fresh generated file.
 * @throws IOException
 */
private OutputStream getOutputStream(MapFileHeader header,File baseDir) throws IOException {
  String name=header.getName().toLowerCase().replaceAll(""String_Node_Str"",""String_Node_Str"");
  if (name.isEmpty()) {
    name=""String_Node_Str"";
  }
  Date date=header.getDate();
  if (date != null) {
    SimpleDateFormat format=new SimpleDateFormat(""String_Node_Str"");
    name+=format.format(date);
  }
  File file=new File(baseDir,name + MAP_EXTENSION);
  int i=1;
  while (file.exists()) {
    file=new File(baseDir,name + ""String_Node_Str"" + i+ MAP_EXTENSION);
    i++;
  }
  try {
    return new BufferedOutputStream(new FileOutputStream(file));
  }
 catch (  FileNotFoundException e) {
    throw new IOException(e);
  }
}"
56207,"/** 
 * Saves a map to disk. The map logic should be paused while calling this method.
 * @param state
 * @param grid
 * @throws IOException
 */
public synchronized void saveMap(UIState state,MainGrid grid) throws IOException {
  MapFileHeader header=grid.generateSaveHeader();
  OutputStream out=getOutputStream(header);
  header.writeTo(out);
  state.writeTo(out);
  GameSerializer gameSerializer=new GameSerializer();
  gameSerializer.save(grid,out);
  loadFileList();
}","/** 
 * Saves a map to disk. The map logic should be paused while calling this method.
 * @param state
 * @param grid
 * @throws IOException
 */
public synchronized void saveMap(UIState state,MainGrid grid) throws IOException {
  MapFileHeader header=grid.generateSaveHeader();
  OutputStream out=getOutputStream(header,saveDir);
  header.writeTo(out);
  state.writeTo(out);
  GameSerializer gameSerializer=new GameSerializer();
  gameSerializer.save(grid,out);
  loadFileList();
}"
56208,"/** 
 * Creates a new   {@link JSettlersGame} object with an {@link OfflineTaskScheduler}.
 * @param mapCreator
 * @param randomSeed
 * @param playerNumber
 */
public JSettlersGame(IGameCreator mapCreator,long randomSeed,byte playerNumber){
  this(mapCreator,randomSeed,new OfflineTaskScheduler(),playerNumber,false);
}","/** 
 * @param mapCreator
 * @param randomSeed
 * @param playerNumber
 */
public JSettlersGame(IGameCreator mapCreator,long randomSeed,byte playerNumber,File loadableReplayFile){
  this(mapCreator,randomSeed,new OfflineTaskScheduler(),playerNumber,false,loadableReplayFile);
}"
56209,"@Override public void run(){
  try {
    updateProgressListener(EProgressState.LOADING,0.1f);
    DataOutputStream replayFileStream=createReplayFileStream();
    IGameClock gameClock=MatchConstants.clock=taskScheduler.getGameClock();
    gameClock.setReplayLogfile(replayFileStream);
    RandomSingleton.load(randomSeed);
    updateProgressListener(EProgressState.LOADING_MAP,0.3f);
    Thread imagePreloader=ImageProvider.getInstance().startPreloading();
    mainGrid=mapcreator.getMainGrid(playerNumber);
    UIState uiState=mapcreator.getUISettings(playerNumber);
    updateProgressListener(EProgressState.LOADING_IMAGES,0.7f);
    statistics=new GameStatistics(gameClock);
    mainGrid.startThreads();
    imagePreloader.join();
    waitForStartingGameListener();
    final MapInterfaceConnector connector=startingGameListener.startFinished(this);
    connector.loadUIState(uiState.getUiStateData());
    GuiInterface guiInterface=new GuiInterface(connector,gameClock,taskScheduler,mainGrid.getGuiInputGrid(),this,playerNumber,multiplayer);
    gameClock.startExecution();
synchronized (stopMutex) {
      while (!stopped) {
        try {
          stopMutex.wait();
        }
 catch (        InterruptedException e) {
        }
      }
    }
    taskScheduler.shutdown();
    gameClock.stopExecution();
    connector.stop();
    mainGrid.stopThreads();
    guiInterface.stop();
    Timer100Milli.stop();
    MovableTimer.stop();
    PartitionManagerTimer.stop();
    NewMovable.dropAllMovables();
    Building.dropAllBuildings();
  }
 catch (  MapLoadException e) {
    e.printStackTrace();
    reportFail(EGameError.MAPLOADING_ERROR,e);
  }
catch (  Exception e) {
    e.printStackTrace();
    reportFail(EGameError.UNKNOWN_ERROR,e);
  }
  if (exitListener != null) {
    exitListener.gameExited(this);
  }
}","@Override public void run(){
  try {
    updateProgressListener(EProgressState.LOADING,0.1f);
    DataOutputStream replayFileStream=createReplayFileStream();
    IGameClock gameClock=MatchConstants.clock=taskScheduler.getGameClock();
    gameClock.setReplayLogStream(replayFileStream);
    RandomSingleton.load(randomSeed);
    updateProgressListener(EProgressState.LOADING_MAP,0.3f);
    Thread imagePreloader=ImageProvider.getInstance().startPreloading();
    mainGrid=mapcreator.getMainGrid(playerNumber);
    UIState uiState=mapcreator.getUISettings(playerNumber);
    updateProgressListener(EProgressState.LOADING_IMAGES,0.7f);
    statistics=new GameStatistics(gameClock);
    mainGrid.startThreads();
    imagePreloader.join();
    waitForStartingGameListener();
    final MapInterfaceConnector connector=startingGameListener.startFinished(this);
    connector.loadUIState(uiState.getUiStateData());
    GuiInterface guiInterface=new GuiInterface(connector,gameClock,taskScheduler,mainGrid.getGuiInputGrid(),this,playerNumber,multiplayer);
    if (loadableReplayFile != null) {
      gameClock.loadReplayLogFromStream(new DataInputStream(new FileInputStream(loadableReplayFile.getAbsolutePath())));
    }
    gameClock.startExecution();
synchronized (stopMutex) {
      while (!stopped) {
        try {
          stopMutex.wait();
        }
 catch (        InterruptedException e) {
        }
      }
    }
    taskScheduler.shutdown();
    gameClock.stopExecution();
    connector.stop();
    mainGrid.stopThreads();
    guiInterface.stop();
    Timer100Milli.stop();
    MovableTimer.stop();
    PartitionManagerTimer.stop();
    NewMovable.dropAllMovables();
    Building.dropAllBuildings();
  }
 catch (  MapLoadException e) {
    e.printStackTrace();
    reportFail(EGameError.MAPLOADING_ERROR,e);
  }
catch (  Exception e) {
    e.printStackTrace();
    reportFail(EGameError.UNKNOWN_ERROR,e);
  }
  if (exitListener != null) {
    exitListener.gameExited(this);
  }
}"
56210,"protected void save(){
  try {
    MapFileHeader imagedHeader=generateMapHeader();
    data.doPreSaveActions();
    MapList.getDefaultList().saveMap(imagedHeader,data);
  }
 catch (  Throwable e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(saveButton,e.getMessage());
  }
}","protected void save(){
  try {
    MapFileHeader imagedHeader=generateMapHeader();
    data.doPreSaveActions();
    MapList.getDefaultList().saveNewMap(imagedHeader,data);
  }
 catch (  Throwable e) {
    e.printStackTrace();
    JOptionPane.showMessageDialog(saveButton,e.getMessage());
  }
}"
56211,"/** 
 * Sets the stream to be used to log the actions of the users.
 * @param replayFileStream
 */
void setReplayLogfile(OutputStream replayFileStream);","/** 
 * Sets the stream to be used to log the actions of the users.
 * @param replayFileStream
 */
void setReplayLogfile(DataOutputStream replayFileStream);"
56212,"@Override public void setReplayLogfile(OutputStream replayFileStream){
  if (replayFileStream != null) {
    replayLogStream=new DataOutputStream(replayFileStream);
  }
 else {
    closeReplayLogStreamIfNeeded();
  }
}","@Override public void setReplayLogfile(DataOutputStream replayFileStream){
  if (replayFileStream != null) {
    replayLogStream=replayFileStream;
  }
 else {
    closeReplayLogStreamIfNeeded();
  }
}"
56213,"/** 
 * Normalizes the partitions and compacts them.
 */
private void normalizePartitions(){
  short[] compacted=new short[partitions.length + 1];
  compacted[NO_PARTITION]=NO_PARTITION;
  compacted[BLOCKED_PARTITION]=BLOCKED_PARTITION;
  short compactedCount=NUMBER_OF_RESERVED_PARTITIONS;
  for (short i=NUMBER_OF_RESERVED_PARTITIONS; i < nextFreePartition; i++) {
    short representative=i;
    short nextRep;
    while (representative != (nextRep=partitions[representative])) {
      representative=nextRep;
    }
    if (compacted[representative] == 0) {
      compacted[representative]=compactedCount++;
      partitionBorderPositions[compactedCount]=partitionBorderPositions[representative];
    }
    partitions[i]=representative;
    compacted[i]=compacted[representative];
  }
  partitions=compacted;
  neededPartitions=compactedCount;
}","/** 
 * Normalizes the partitions and compacts them.
 */
private void normalizePartitions(){
  short[] compacted=new short[nextFreePartition];
  compacted[NO_PARTITION]=NO_PARTITION;
  compacted[BLOCKED_PARTITION]=BLOCKED_PARTITION;
  short compactedCount=NUMBER_OF_RESERVED_PARTITIONS;
  for (short i=NUMBER_OF_RESERVED_PARTITIONS; i < nextFreePartition; i++) {
    short representative=i;
    short nextRep;
    while (representative != (nextRep=partitions[representative])) {
      representative=nextRep;
    }
    if (compacted[representative] == 0) {
      short newPartitionId=compactedCount++;
      compacted[representative]=newPartitionId;
      partitionBorderPositions[newPartitionId]=partitionBorderPositions[representative];
    }
    partitions[i]=representative;
    compacted[i]=compacted[representative];
  }
  partitions=compacted;
  neededPartitions=compactedCount;
}"
56214,"private MapFileHeader generateMapHeader(){
  short[] image=new PreviewImageCreator(header.getWidth(),header.getHeight(),MapFileHeader.PREVIEW_IMAGE_SIZE,data.getPreviewImageDataSupplier()).getPreviewImage();
  MapFileHeader imagedHeader=new MapFileHeader(header.getType(),header.getName(),header.getDescription(),header.getWidth(),header.getHeight(),header.getMinPlayer(),header.getMaxPlayer(),new Date(),image);
  return imagedHeader;
}","private MapFileHeader generateMapHeader(){
  short[] image=new PreviewImageCreator(header.getWidth(),header.getHeight(),MapFileHeader.PREVIEW_IMAGE_SIZE,data.getPreviewImageDataSupplier()).getPreviewImage();
  MapFileHeader imagedHeader=new MapFileHeader(header.getType(),header.getName(),header.getBaseMapId(),header.getDescription(),header.getWidth(),header.getHeight(),header.getMinPlayer(),header.getMaxPlayer(),new Date(),image);
  return imagedHeader;
}"
56215,"public MapFileHeader getHeader(){
  String name=nameField.getText();
  String description=descriptionField.getText();
  short width=this.width.getNumber().shortValue();
  short height=this.height.getNumber().shortValue();
  short minPlayer=this.minPlayer.getNumber().shortValue();
  short maxPlayer=this.maxPlayer.getNumber().shortValue();
  return new MapFileHeader(MapType.NORMAL,name,description,width,height,minPlayer,maxPlayer,new Date(),new short[MapFileHeader.PREVIEW_IMAGE_SIZE * MapFileHeader.PREVIEW_IMAGE_SIZE]);
}","public MapFileHeader getHeader(){
  String name=nameField.getText();
  String description=descriptionField.getText();
  short width=this.width.getNumber().shortValue();
  short height=this.height.getNumber().shortValue();
  short minPlayer=this.minPlayer.getNumber().shortValue();
  short maxPlayer=this.maxPlayer.getNumber().shortValue();
  return new MapFileHeader(MapType.NORMAL,name,null,description,width,height,minPlayer,maxPlayer,new Date(),new short[MapFileHeader.PREVIEW_IMAGE_SIZE * MapFileHeader.PREVIEW_IMAGE_SIZE]);
}"
56216,"public MapFileHeader generateSaveHeader(){
  PreviewImageCreator previewImageCreator=new PreviewImageCreator(width,height,MapFileHeader.PREVIEW_IMAGE_SIZE,landscapeGrid.getPreviewImageDataSupplier());
  short[] bgImage=previewImageCreator.getPreviewImage();
  return new MapFileHeader(MapType.SAVED_SINGLE,""String_Node_Str"",""String_Node_Str"",width,height,(short)1,(short)1,new Date(),bgImage);
}","public MapFileHeader generateSaveHeader(){
  PreviewImageCreator previewImageCreator=new PreviewImageCreator(width,height,MapFileHeader.PREVIEW_IMAGE_SIZE,landscapeGrid.getPreviewImageDataSupplier());
  short[] bgImage=previewImageCreator.getPreviewImage();
  return new MapFileHeader(MapType.SAVED_SINGLE,mapName,mapId,""String_Node_Str"",width,height,(short)1,(short)1,new Date(),bgImage);
}"
56217,"private MainGrid(IMapData mapGrid,byte players,byte fowPlayer){
  this((short)mapGrid.getWidth(),(short)mapGrid.getHeight(),players,fowPlayer);
  for (short y=0; y < height; y++) {
    for (short x=0; x < width; x++) {
      ELandscapeType landscape=mapGrid.getLandscape(x,y);
      setLandscapeTypeAt(x,y,landscape);
      landscapeGrid.setHeightAt(x,y,mapGrid.getLandscapeHeight(x,y));
      landscapeGrid.setResourceAt(x,y,mapGrid.getResourceType(x,y),mapGrid.getResourceAmount(x,y));
      landscapeGrid.setBlockedPartition(x,y,mapGrid.getBlockedPartition(x,y));
    }
  }
  for (short y=0; y < height; y++) {
    for (short x=0; x < width; x++) {
      MapObject object=mapGrid.getMapObject(x,y);
      if (object != null && isOccupyableBuilding(object)) {
        addMapObject(x,y,object);
      }
      if ((x + y / 2) % 4 == 0 && y % 4 == 0 && isInsideWater(x,y)) {
        mapObjectsManager.addWaves(x,y);
        if (landscapeGrid.getResourceAmountAt(x,y) > 50) {
          mapObjectsManager.addFish(x,y);
        }
      }
    }
  }
  for (short y=0; y < height; y++) {
    for (short x=0; x < width; x++) {
      MapObject object=mapGrid.getMapObject(x,y);
      if (object != null && !isOccupyableBuilding(object)) {
        addMapObject(x,y,object);
      }
    }
  }
  System.out.println(""String_Node_Str"");
}","public MainGrid(String mapId,String mapName,IMapData mapGrid,byte players,byte fowPlayer){
  this(mapId,mapName,(short)mapGrid.getWidth(),(short)mapGrid.getHeight(),players,fowPlayer);
  for (short y=0; y < height; y++) {
    for (short x=0; x < width; x++) {
      ELandscapeType landscape=mapGrid.getLandscape(x,y);
      setLandscapeTypeAt(x,y,landscape);
      landscapeGrid.setHeightAt(x,y,mapGrid.getLandscapeHeight(x,y));
      landscapeGrid.setResourceAt(x,y,mapGrid.getResourceType(x,y),mapGrid.getResourceAmount(x,y));
      landscapeGrid.setBlockedPartition(x,y,mapGrid.getBlockedPartition(x,y));
    }
  }
  for (short y=0; y < height; y++) {
    for (short x=0; x < width; x++) {
      MapObject object=mapGrid.getMapObject(x,y);
      if (object != null && isOccupyableBuilding(object)) {
        addMapObject(x,y,object);
      }
      if ((x + y / 2) % 4 == 0 && y % 4 == 0 && isInsideWater(x,y)) {
        mapObjectsManager.addWaves(x,y);
        if (landscapeGrid.getResourceAmountAt(x,y) > 50) {
          mapObjectsManager.addFish(x,y);
        }
      }
    }
  }
  for (short y=0; y < height; y++) {
    for (short x=0; x < width; x++) {
      MapObject object=mapGrid.getMapObject(x,y);
      if (object != null && !isOccupyableBuilding(object)) {
        addMapObject(x,y,object);
      }
    }
  }
  System.out.println(""String_Node_Str"");
}"
56218,"/** 
 * Reads a new file header from the stream.
 * @param stream The stream to read from.
 * @return
 */
public static MapFileHeader readFromStream(InputStream stream) throws IOException {
  try {
    DataInputStream in=new DataInputStream(stream);
    for (    byte b : START_BYTES) {
      if (in.readByte() != b) {
        throw new IOException(""String_Node_Str"");
      }
    }
    int version=in.readShort();
    if (version != ALLOWED_VERSION) {
      throw new IOException(""String_Node_Str"");
    }
    String typeStr=in.readUTF();
    MapType type=MapType.valueOf(typeStr);
    String name=in.readUTF();
    String description=in.readUTF();
    short width=in.readShort();
    short height=in.readShort();
    short minplayer=in.readShort();
    short maxplayer=in.readShort();
    short[] bgimage=new short[PREVIEW_IMAGE_SIZE * PREVIEW_IMAGE_SIZE];
    for (int i=0; i < PREVIEW_IMAGE_SIZE * PREVIEW_IMAGE_SIZE; i++) {
      bgimage[i]=in.readShort();
    }
    ;
    Date date=null;
    if (type == MapType.SAVED_SINGLE) {
      long datetime=in.readLong();
      date=new Date(datetime);
    }
    return new MapFileHeader(type,name,description,width,height,minplayer,maxplayer,date,bgimage);
  }
 catch (  Throwable t) {
    if (t instanceof IOException) {
      throw (IOException)t;
    }
 else {
      throw new IOException(t);
    }
  }
}","/** 
 * Reads a new file header from the stream.
 * @param stream The stream to read from.
 * @return
 */
public static MapFileHeader readFromStream(InputStream stream) throws IOException {
  try {
    DataInputStream in=new DataInputStream(stream);
    for (    byte b : START_BYTES) {
      if (in.readByte() != b) {
        throw new IOException(""String_Node_Str"");
      }
    }
    int version=in.readShort();
    if (version < MIN_VERSION) {
      throw new IOException(""String_Node_Str"");
    }
    String typeStr=in.readUTF();
    MapType type=MapType.valueOf(typeStr);
    String mapName=in.readUTF();
    String mapId=(version == 2) ? in.readUTF() : mapName;
    String baseMapId=(version == 2) ? in.readUTF() : null;
    String description=in.readUTF();
    short width=in.readShort();
    short height=in.readShort();
    short minplayer=in.readShort();
    short maxplayer=in.readShort();
    short[] bgimage=new short[PREVIEW_IMAGE_SIZE * PREVIEW_IMAGE_SIZE];
    for (int i=0; i < PREVIEW_IMAGE_SIZE * PREVIEW_IMAGE_SIZE; i++) {
      bgimage[i]=in.readShort();
    }
    ;
    Date date=null;
    if (type == MapType.SAVED_SINGLE) {
      long datetime=in.readLong();
      date=new Date(datetime);
    }
    return new MapFileHeader(type,mapName,mapId,baseMapId,description,width,height,minplayer,maxplayer,date,bgimage);
  }
 catch (  Throwable t) {
    if (t instanceof IOException) {
      throw (IOException)t;
    }
 else {
      throw new IOException(t);
    }
  }
}"
56219,"public String getUniqueId(){
  return getName();
}","public String getUniqueId(){
  return mapId;
}"
56220,"public void writeTo(OutputStream stream) throws IOException {
  DataOutputStream out=new DataOutputStream(stream);
  out.write(START_BYTES);
  out.writeShort(ALLOWED_VERSION);
  out.writeUTF(type.toString());
  out.writeUTF(name);
  out.writeUTF(description);
  out.writeShort(width);
  out.writeShort(height);
  out.writeShort(minPlayer);
  out.writeShort(maxPlayer);
  for (int i=0; i < PREVIEW_IMAGE_SIZE * PREVIEW_IMAGE_SIZE; i++) {
    out.writeShort(bgimage[i]);
  }
  ;
  if (type == MapType.SAVED_SINGLE) {
    out.writeLong(date.getTime());
  }
}","public void writeTo(OutputStream stream) throws IOException {
  DataOutputStream out=new DataOutputStream(stream);
  out.write(START_BYTES);
  out.writeShort(VERSION);
  out.writeUTF(type.toString());
  out.writeUTF(name);
  out.writeUTF(mapId);
  out.writeUTF(baseMapId);
  out.writeUTF(description);
  out.writeShort(width);
  out.writeShort(height);
  out.writeShort(minPlayer);
  out.writeShort(maxPlayer);
  for (int i=0; i < PREVIEW_IMAGE_SIZE * PREVIEW_IMAGE_SIZE; i++) {
    out.writeShort(bgimage[i]);
  }
  ;
  if (type == MapType.SAVED_SINGLE) {
    out.writeLong(date.getTime());
  }
}"
56221,"public MapFileHeader(MapType type,String name,String description,short width,short height,short minplayer,short maxplayer,Date date,short[] bgimage){
  if (bgimage.length != PREVIEW_IMAGE_SIZE * PREVIEW_IMAGE_SIZE) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.type=type;
  this.name=name;
  this.description=description;
  this.width=width;
  this.height=height;
  this.minPlayer=minplayer;
  this.maxPlayer=maxplayer;
  this.date=date;
  this.bgimage=bgimage;
}","public MapFileHeader(MapType type,String name,String mapId,String baseMapId,String description,short width,short height,short minplayer,short maxplayer,Date date,short[] bgimage){
  if (bgimage.length != PREVIEW_IMAGE_SIZE * PREVIEW_IMAGE_SIZE) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.type=type;
  this.name=name;
  this.mapId=mapId;
  this.baseMapId=baseMapId;
  this.description=description;
  this.width=width;
  this.height=height;
  this.minPlayer=minplayer;
  this.maxPlayer=maxplayer;
  this.date=date;
  this.bgimage=bgimage;
}"
56222,"/** 
 * Gives the   {@link MapLoader} for the map with the given id.
 * @param id The id of the map to be found.
 * @return Returns the corresponding {@link MapLoader}<br> or null if no map with the given id has been found.
 */
public MapLoader getMapById(String id){
  ArrayList<MapLoader> maps=new ArrayList<MapLoader>();
  maps.addAll(getFreshMaps());
  maps.addAll(getSavedMaps());
  for (  MapLoader curr : maps) {
    if (curr.getUniqueID().equals(id)) {
      return curr;
    }
  }
  return null;
}","/** 
 * Gives the   {@link MapLoader} for the map with the given id.
 * @param id The id of the map to be found.
 * @return Returns the corresponding {@link MapLoader}<br> or null if no map with the given id has been found.
 */
public MapLoader getMapById(String id){
  ArrayList<MapLoader> maps=new ArrayList<MapLoader>();
  maps.addAll(getFreshMaps());
  maps.addAll(getSavedMaps());
  for (  MapLoader curr : maps) {
    if (curr.getMapID().equals(id)) {
      return curr;
    }
  }
  return null;
}"
56223,"@Override public MainGrid getMainGrid(byte player) throws MapLoadException {
  try {
    if (mainGrid == null) {
      loadAll();
    }
    if (mapData != null) {
      mainGrid=MainGrid.create(mapData,(byte)mapData.getPlayerCount(),player);
      if (mainGrid == null) {
        throw new MapLoadException(""String_Node_Str"");
      }
    }
    return mainGrid;
  }
 catch (  IOException e) {
    throw new MapLoadException(e);
  }
}","@Override public MainGrid getMainGrid(byte player) throws MapLoadException {
  try {
    if (mainGrid == null) {
      loadAll();
    }
    if (mapData != null) {
      mainGrid=new MainGrid(getMapID(),getMapName(),mapData,(byte)mapData.getPlayerCount(),player);
      if (mainGrid == null) {
        throw new MapLoadException(""String_Node_Str"");
      }
    }
    return mainGrid;
  }
 catch (  IOException e) {
    throw new MapLoadException(e);
  }
}"
56224,"@Override public int getMaxPlayers(){
  try {
    return getFileHeader().getMaxPlayer();
  }
 catch (  MapLoadException e) {
    return 1;
  }
}","public int getMaxPlayers(){
  try {
    return getFileHeader().getMaxPlayer();
  }
 catch (  MapLoadException e) {
    return 1;
  }
}"
56225,"public String getMapID(){
  return getUniqueID();
}","@Override public String getMapID(){
  try {
    return getFileHeader().getUniqueId();
  }
 catch (  MapLoadException e) {
    return ""String_Node_Str"";
  }
}"
56226,"@Override public File getFile(){
  return file;
}","public File getFile(){
  return file;
}"
56227,"@Override public String getId(){
  return mapLoader.getUniqueID();
}","@Override public String getId(){
  return mapLoader.getMapID();
}"
56228,"private void select(ShortPoint2D pos){
  if (grid.isInBounds(pos)) {
    short x=pos.x;
    short y=pos.y;
    IGuiMovable m1=grid.getMovable(x,y);
    IGuiMovable m3=grid.getMovable((short)(x + 1),(short)(y + 1));
    IGuiMovable m2=grid.getMovable((x),(short)(y + 1));
    IGuiMovable m4=grid.getMovable((short)(x + 1),(short)(y + 2));
    if (m1 != null) {
      setSelection(new SelectionSet(m1));
      System.out.println(""String_Node_Str"" + pos);
    }
 else     if (m2 != null) {
      setSelection(new SelectionSet(m2));
    }
 else     if (m3 != null) {
      setSelection(new SelectionSet(m3));
    }
 else     if (m4 != null) {
      setSelection(new SelectionSet(m4));
    }
 else {
      IBuilding building=getBuildingAround(pos);
      if (building != null) {
        setSelection(new SelectionSet(building));
      }
 else {
        setSelection(new SelectionSet());
      }
    }
  }
}","private void select(ShortPoint2D pos){
  if (grid.isInBounds(pos)) {
    short x=pos.x;
    short y=pos.y;
    IGuiMovable m1=grid.getMovable(x,y);
    IGuiMovable m3=grid.getMovable((short)(x + 1),(short)(y + 1));
    IGuiMovable m2=grid.getMovable((x),(short)(y + 1));
    IGuiMovable m4=grid.getMovable((short)(x + 1),(short)(y + 2));
    if (m1 != null && canSelectPlayer(m1.getPlayerId())) {
      setSelection(new SelectionSet(m1));
      System.out.println(""String_Node_Str"" + pos);
    }
 else     if (m2 != null && canSelectPlayer(m2.getPlayerId())) {
      setSelection(new SelectionSet(m2));
    }
 else     if (m3 != null && canSelectPlayer(m3.getPlayerId())) {
      setSelection(new SelectionSet(m3));
    }
 else     if (m4 != null && canSelectPlayer(m4.getPlayerId())) {
      setSelection(new SelectionSet(m4));
    }
 else {
      IBuilding building=getBuildingAround(pos);
      if (building != null && canSelectPlayer(building.getPlayerId())) {
        setSelection(new SelectionSet(building));
      }
 else {
        setSelection(new SelectionSet());
      }
    }
  }
}"
56229,"private void selectArea(SelectAreaAction action){
  SelectionSet selectionSet=new SelectionSet();
  for (  ShortPoint2D curr : new MapShapeFilter(action.getArea(),grid.getWidth(),grid.getHeight())) {
    IGuiMovable movable=grid.getMovable(curr.x,curr.y);
    if (movable != null && (CommonConstants.ENABLE_ALL_PLAYER_SELECTION || movable.getPlayerId() == player)) {
      selectionSet.add(movable);
    }
    IBuilding building=grid.getBuildingAt(curr.x,curr.y);
    if (building != null && (CommonConstants.ENABLE_ALL_PLAYER_SELECTION || building.getPlayerId() == player)) {
      selectionSet.add(building);
    }
  }
  setSelection(selectionSet);
}","private void selectArea(SelectAreaAction action){
  SelectionSet selectionSet=new SelectionSet();
  for (  ShortPoint2D curr : new MapShapeFilter(action.getArea(),grid.getWidth(),grid.getHeight())) {
    IGuiMovable movable=grid.getMovable(curr.x,curr.y);
    if (movable != null && canSelectPlayer(movable.getPlayerId())) {
      selectionSet.add(movable);
    }
    IBuilding building=grid.getBuildingAt(curr.x,curr.y);
    if (building != null && canSelectPlayer(building.getPlayerId())) {
      selectionSet.add(building);
    }
  }
  setSelection(selectionSet);
}"
56230,"@Override public void run(){
  try {
    updateProgressListener(EProgressState.LOADING,0.1f);
    String replayFilename=""String_Node_Str"" + logDateFormat.format(new Date()) + ""String_Node_Str""+ mapcreator.getMapName()+ ""String_Node_Str"";
    OutputStream replayFileStream=ResourceManager.writeFile(replayFilename);
    IGameClock gameClock=MatchConstants.clock=taskScheduler.getGameClock();
    gameClock.setReplayLogfile(replayFileStream);
    RandomSingleton.load(randomSeed);
    updateProgressListener(EProgressState.LOADING_MAP,0.3f);
    Thread imagePreloader=ImageProvider.getInstance().startPreloading();
    mainGrid=mapcreator.getMainGrid(playerNumber);
    UIState uiState=mapcreator.getUISettings(playerNumber);
    updateProgressListener(EProgressState.LOADING_IMAGES,0.7f);
    statistics=new GameStatistics(gameClock);
    mainGrid.startThreads();
    imagePreloader.join();
    waitForStartingGameListener();
    final MapInterfaceConnector connector=startingGameListener.startFinished(this);
    connector.loadUIState(uiState.getUiStateData());
    GuiInterface guiInterface=new GuiInterface(connector,gameClock,taskScheduler,mainGrid.getGuiInputGrid(),this,playerNumber,multiplayer);
    gameClock.startExecution();
synchronized (stopMutex) {
      while (!stopped) {
        try {
          stopMutex.wait();
        }
 catch (        InterruptedException e) {
        }
      }
    }
    gameClock.stopExecution();
    connector.stop();
    mainGrid.stopThreads();
    guiInterface.stop();
    Timer100Milli.stop();
    MovableTimer.stop();
    PartitionManagerTimer.stop();
    NewMovable.dropAllMovables();
    Building.dropAllBuildings();
  }
 catch (  MapLoadException e) {
    e.printStackTrace();
    reportFail(EGameError.MAPLOADING_ERROR,e);
  }
catch (  Exception e) {
    e.printStackTrace();
    reportFail(EGameError.UNKNOWN_ERROR,e);
  }
  if (exitListener != null) {
    exitListener.gameExited(this);
  }
}","@Override public void run(){
  try {
    updateProgressListener(EProgressState.LOADING,0.1f);
    String replayFilename=""String_Node_Str"" + logDateFormat.format(new Date()) + ""String_Node_Str""+ mapcreator.getMapName()+ ""String_Node_Str"";
    OutputStream replayFileStream=ResourceManager.writeFile(replayFilename);
    IGameClock gameClock=MatchConstants.clock=taskScheduler.getGameClock();
    gameClock.setReplayLogfile(replayFileStream);
    RandomSingleton.load(randomSeed);
    updateProgressListener(EProgressState.LOADING_MAP,0.3f);
    Thread imagePreloader=ImageProvider.getInstance().startPreloading();
    mainGrid=mapcreator.getMainGrid(playerNumber);
    UIState uiState=mapcreator.getUISettings(playerNumber);
    updateProgressListener(EProgressState.LOADING_IMAGES,0.7f);
    statistics=new GameStatistics(gameClock);
    mainGrid.startThreads();
    imagePreloader.join();
    waitForStartingGameListener();
    final MapInterfaceConnector connector=startingGameListener.startFinished(this);
    connector.loadUIState(uiState.getUiStateData());
    GuiInterface guiInterface=new GuiInterface(connector,gameClock,taskScheduler,mainGrid.getGuiInputGrid(),this,playerNumber,multiplayer);
    gameClock.startExecution();
synchronized (stopMutex) {
      while (!stopped) {
        try {
          stopMutex.wait();
        }
 catch (        InterruptedException e) {
        }
      }
    }
    taskScheduler.shutdown();
    gameClock.stopExecution();
    connector.stop();
    mainGrid.stopThreads();
    guiInterface.stop();
    Timer100Milli.stop();
    MovableTimer.stop();
    PartitionManagerTimer.stop();
    NewMovable.dropAllMovables();
    Building.dropAllBuildings();
  }
 catch (  MapLoadException e) {
    e.printStackTrace();
    reportFail(EGameError.MAPLOADING_ERROR,e);
  }
catch (  Exception e) {
    e.printStackTrace();
    reportFail(EGameError.UNKNOWN_ERROR,e);
  }
  if (exitListener != null) {
    exitListener.gameExited(this);
  }
}"
56231,"@Override public void setReplayLogfile(OutputStream replayFileStream){
}","@Override public void setReplayLogfile(DataOutputStream replayFileStream){
}"
56232,"@Override public void close(){
  state=EPlayerState.DISCONNECTED;
  timer.cancel();
  channel.close();
}","@Override public void close(){
  state=EPlayerState.DISCONNECTED;
  timer.cancel();
  channel.close();
  clock.stopExecution();
}"
56233,"@Override public void run(){
  try {
    updateProgressListener(EProgressState.LOADING,0.1f);
    String replayFilename=""String_Node_Str"" + logDateFormat.format(new Date()) + ""String_Node_Str""+ mapcreator.getMapName()+ ""String_Node_Str"";
    OutputStream replayFileStream=ResourceManager.writeFile(replayFilename);
    IGameClock gameClock=MatchConstants.clock=taskScheduler.getGameClock();
    gameClock.setReplayLogfile(replayFileStream);
    RandomSingleton.load(randomSeed);
    updateProgressListener(EProgressState.LOADING_MAP,0.3f);
    Thread imagePreloader=ImageProvider.getInstance().startPreloading();
    mainGrid=mapcreator.getMainGrid(playerNumber);
    UIState uiState=mapcreator.getUISettings(playerNumber);
    updateProgressListener(EProgressState.LOADING_IMAGES,0.7f);
    statistics=new GameStatistics(gameClock);
    mainGrid.startThreads();
    imagePreloader.join();
    waitForStartingGameListener();
    final MapInterfaceConnector connector=startingGameListener.startFinished(this);
    connector.loadUIState(uiState.getUiStateData());
    GuiInterface guiInterface=new GuiInterface(connector,gameClock,taskScheduler,mainGrid.getGuiInputGrid(),this,playerNumber,multiplayer);
    gameClock.startExecution();
synchronized (stopMutex) {
      while (!stopped) {
        try {
          stopMutex.wait();
        }
 catch (        InterruptedException e) {
        }
      }
    }
    taskScheduler.shutdown();
    gameClock.stopExecution();
    connector.stop();
    mainGrid.stopThreads();
    guiInterface.stop();
    Timer100Milli.stop();
    MovableTimer.stop();
    PartitionManagerTimer.stop();
    NewMovable.dropAllMovables();
    Building.dropAllBuildings();
  }
 catch (  MapLoadException e) {
    e.printStackTrace();
    reportFail(EGameError.MAPLOADING_ERROR,e);
  }
catch (  Exception e) {
    e.printStackTrace();
    reportFail(EGameError.UNKNOWN_ERROR,e);
  }
  if (exitListener != null) {
    exitListener.gameExited(this);
  }
}","@Override public void run(){
  try {
    updateProgressListener(EProgressState.LOADING,0.1f);
    DataOutputStream replayFileStream=createReplayFileStream();
    IGameClock gameClock=MatchConstants.clock=taskScheduler.getGameClock();
    gameClock.setReplayLogfile(replayFileStream);
    RandomSingleton.load(randomSeed);
    updateProgressListener(EProgressState.LOADING_MAP,0.3f);
    Thread imagePreloader=ImageProvider.getInstance().startPreloading();
    mainGrid=mapcreator.getMainGrid(playerNumber);
    UIState uiState=mapcreator.getUISettings(playerNumber);
    updateProgressListener(EProgressState.LOADING_IMAGES,0.7f);
    statistics=new GameStatistics(gameClock);
    mainGrid.startThreads();
    imagePreloader.join();
    waitForStartingGameListener();
    final MapInterfaceConnector connector=startingGameListener.startFinished(this);
    connector.loadUIState(uiState.getUiStateData());
    GuiInterface guiInterface=new GuiInterface(connector,gameClock,taskScheduler,mainGrid.getGuiInputGrid(),this,playerNumber,multiplayer);
    gameClock.startExecution();
synchronized (stopMutex) {
      while (!stopped) {
        try {
          stopMutex.wait();
        }
 catch (        InterruptedException e) {
        }
      }
    }
    taskScheduler.shutdown();
    gameClock.stopExecution();
    connector.stop();
    mainGrid.stopThreads();
    guiInterface.stop();
    Timer100Milli.stop();
    MovableTimer.stop();
    PartitionManagerTimer.stop();
    NewMovable.dropAllMovables();
    Building.dropAllBuildings();
  }
 catch (  MapLoadException e) {
    e.printStackTrace();
    reportFail(EGameError.MAPLOADING_ERROR,e);
  }
catch (  Exception e) {
    e.printStackTrace();
    reportFail(EGameError.UNKNOWN_ERROR,e);
  }
  if (exitListener != null) {
    exitListener.gameExited(this);
  }
}"
56234,"@Override public void action(Action action){
  if (action.getActionType() != EActionType.SCREEN_CHANGE) {
    System.out.println(""String_Node_Str"" + action.getActionType() + ""String_Node_Str""+ MatchConstants.clock.getTime());
  }
switch (action.getActionType()) {
case BUILD:
    this.setSelection(new SelectionSet());
  EBuildingType buildingType=((BuildAction)action).getBuilding();
System.out.println(""String_Node_Str"" + buildingType);
this.previewBuilding=buildingType;
connector.setPreviewBuildingType(buildingType);
constructionMarksCalculator.setBuildingType(buildingType);
setActiveAction(action);
break;
case DEBUG_ACTION:
for (ISelectable curr : currentSelection) {
if (curr instanceof IDebugable) {
((IDebugable)curr).debug();
}
}
break;
case SPEED_TOGGLE_PAUSE:
clock.invertPausing();
break;
case SPEED_SET_PAUSE:
clock.setPausing(true);
break;
case SPEED_UNSET_PAUSE:
clock.setPausing(false);
break;
case SPEED_SLOW:
if (!multiplayer) {
clock.setGameSpeed(0.5f);
}
break;
case SPEED_FAST:
if (!multiplayer) {
clock.setGameSpeed(2.0f);
}
break;
case SPEED_FASTER:
if (!multiplayer) {
clock.multiplyGameSpeed(1.2f);
}
break;
case SPEED_SLOWER:
if (!multiplayer) {
clock.multiplyGameSpeed(1 / 1.2f);
}
break;
case SPEED_NORMAL:
if (!multiplayer) {
clock.setGameSpeed(1.0f);
}
break;
case FAST_FORWARD:
if (!multiplayer) {
clock.fastForward();
}
break;
case SELECT_POINT:
handleSelectPointAction((PointAction)action);
break;
case SELECT_AREA:
selectArea((SelectAreaAction)action);
break;
case MOVE_TO:
if (previewBuilding != null) {
cancelBuildingCreation();
setActiveAction(null);
}
 else {
PointAction moveToAction=(PointAction)action;
if (currentSelection.getSelectionType() == ESelectionType.BUILDING && currentSelection.getSize() == 1) {
setBuildingWorkArea(moveToAction.getPosition());
}
 else {
moveTo(moveToAction.getPosition());
}
}
break;
case SET_WORK_AREA:
if (currentSelection.getSize() > 0) {
setBuildingWorkArea(((PointAction)action).getPosition());
}
break;
case DESTROY:
destroySelected();
break;
case STOP_WORKING:
stopOrStartWorkingAction(true);
break;
case START_WORKING:
stopOrStartWorkingAction(false);
break;
case SHOW_SELECTION:
showSelection();
break;
case SCREEN_CHANGE:
constructionMarksCalculator.setScreen(((ScreenChangeAction)action).getScreenArea());
break;
case TOGGLE_DEBUG:
grid.resetDebugColors();
break;
case TOGGLE_FOG_OF_WAR:
grid.toggleFogOfWar();
break;
case SAVE:
taskScheduler.scheduleTask(new SimpleGuiTask(EGuiAction.QUICK_SAVE));
break;
case CONVERT:
sendConvertAction((ConvertAction)action);
break;
case SET_BUILDING_PRIORITY:
setBuildingPriority(((SetBuildingPriorityAction)action).getNewPriority());
break;
case SET_MATERIAL_DISTRIBUTION_SETTINGS:
{
SetMaterialDistributionSettingsAction a=(SetMaterialDistributionSettingsAction)action;
taskScheduler.scheduleTask(new SetMaterialDistributionSettingsGuiTask(a.getManagerPosition(),a.getMaterialType(),a.getProbabilities()));
break;
}
case SET_MATERIAL_PRIORITIES:
{
SetMaterialPrioritiesAction a=(SetMaterialPrioritiesAction)action;
taskScheduler.scheduleTask(new SetMaterialPrioritiesGuiTask(a.getManagerPosition(),a.getMaterialTypeForPriority()));
break;
}
case EXIT:
gameStoppable.stopGame();
break;
default :
System.err.println(""String_Node_Str"" + action.getActionType() + ""String_Node_Str"");
}
}","@Override public void action(Action action){
  if (action.getActionType() != EActionType.SCREEN_CHANGE) {
    System.out.println(""String_Node_Str"" + action.getActionType() + ""String_Node_Str""+ MatchConstants.clock.getTime());
  }
switch (action.getActionType()) {
case BUILD:
    this.setSelection(new SelectionSet());
  EBuildingType buildingType=((BuildAction)action).getBuilding();
System.out.println(""String_Node_Str"" + buildingType);
this.previewBuilding=buildingType;
connector.setPreviewBuildingType(buildingType);
constructionMarksCalculator.setBuildingType(buildingType);
setActiveAction(action);
break;
case DEBUG_ACTION:
for (ISelectable curr : currentSelection) {
if (curr instanceof IDebugable) {
((IDebugable)curr).debug();
}
}
break;
case SPEED_TOGGLE_PAUSE:
clock.invertPausing();
break;
case SPEED_SET_PAUSE:
clock.setPausing(true);
break;
case SPEED_UNSET_PAUSE:
clock.setPausing(false);
break;
case SPEED_SLOW:
if (!multiplayer) {
clock.setGameSpeed(0.5f);
}
break;
case SPEED_FAST:
if (!multiplayer) {
clock.setGameSpeed(2.0f);
}
break;
case SPEED_FASTER:
if (!multiplayer) {
clock.multiplyGameSpeed(1.2f);
}
break;
case SPEED_SLOWER:
if (!multiplayer) {
clock.multiplyGameSpeed(1 / 1.2f);
}
break;
case SPEED_NORMAL:
if (!multiplayer) {
clock.setGameSpeed(1.0f);
}
break;
case FAST_FORWARD:
if (!multiplayer) {
clock.fastForward();
}
break;
case SELECT_POINT:
handleSelectPointAction((PointAction)action);
break;
case SELECT_AREA:
selectArea((SelectAreaAction)action);
break;
case MOVE_TO:
if (previewBuilding != null) {
cancelBuildingCreation();
setActiveAction(null);
}
 else {
PointAction moveToAction=(PointAction)action;
if (currentSelection.getSelectionType() == ESelectionType.BUILDING && currentSelection.getSize() == 1) {
setBuildingWorkArea(moveToAction.getPosition());
}
 else {
moveTo(moveToAction.getPosition());
}
}
break;
case SET_WORK_AREA:
if (currentSelection.getSize() > 0) {
setBuildingWorkArea(((PointAction)action).getPosition());
}
break;
case DESTROY:
destroySelected();
break;
case STOP_WORKING:
stopOrStartWorkingAction(true);
break;
case START_WORKING:
stopOrStartWorkingAction(false);
break;
case SHOW_SELECTION:
showSelection();
break;
case SCREEN_CHANGE:
constructionMarksCalculator.setScreen(((ScreenChangeAction)action).getScreenArea());
break;
case TOGGLE_DEBUG:
grid.resetDebugColors();
break;
case TOGGLE_FOG_OF_WAR:
if (CommonConstants.ENABLE_FOG_OF_WAR_DISABLING) {
grid.toggleFogOfWar();
}
break;
case SAVE:
taskScheduler.scheduleTask(new SimpleGuiTask(EGuiAction.QUICK_SAVE));
break;
case CONVERT:
sendConvertAction((ConvertAction)action);
break;
case SET_BUILDING_PRIORITY:
setBuildingPriority(((SetBuildingPriorityAction)action).getNewPriority());
break;
case SET_MATERIAL_DISTRIBUTION_SETTINGS:
{
SetMaterialDistributionSettingsAction a=(SetMaterialDistributionSettingsAction)action;
taskScheduler.scheduleTask(new SetMaterialDistributionSettingsGuiTask(a.getManagerPosition(),a.getMaterialType(),a.getProbabilities()));
break;
}
case SET_MATERIAL_PRIORITIES:
{
SetMaterialPrioritiesAction a=(SetMaterialPrioritiesAction)action;
taskScheduler.scheduleTask(new SetMaterialPrioritiesGuiTask(a.getManagerPosition(),a.getMaterialTypeForPriority()));
break;
}
case EXIT:
gameStoppable.stopGame();
break;
default :
System.err.println(""String_Node_Str"" + action.getActionType() + ""String_Node_Str"");
}
}"
56235,"private static void loadDebugSettings(List<String> argsList){
  if (argsList.contains(""String_Node_Str"")) {
    CommonConstants.ENABLE_ALL_PLAYER_FOG_OF_WAR=true;
    CommonConstants.ENABLE_ALL_PLAYER_SELECTION=true;
  }
  if (argsList.contains(""String_Node_Str"") || argsList.contains(""String_Node_Str"")) {
    CommonConstants.DEFAULT_SERVER_ADDRESS=""String_Node_Str"";
  }
}","private static void loadDebugSettings(List<String> argsList){
  if (argsList.contains(""String_Node_Str"")) {
    CommonConstants.ENABLE_ALL_PLAYER_FOG_OF_WAR=true;
    CommonConstants.ENABLE_ALL_PLAYER_SELECTION=true;
    CommonConstants.ENABLE_FOG_OF_WAR_DISABLING=true;
  }
  if (argsList.contains(""String_Node_Str"") || argsList.contains(""String_Node_Str"")) {
    CommonConstants.DEFAULT_SERVER_ADDRESS=""String_Node_Str"";
  }
}"
56236,"/** 
 * This method activates the unflattening process. This causes a flattened position to be turned into grass after a while.
 * @param x X coordinate of the position.
 * @param y Y coordinate of the position.
 */
public void activateUnflattening(short x,short y){
  this.temporaryFlatened[x + y * width]=(byte)(40 + RandomSingleton.nextF() * 80);
  this.flattenedResetter.addPosition(x,y);
}","/** 
 * This method activates the unflattening process. This causes a flattened position to be turned into grass after a while.
 * @param x X coordinate of the position.
 * @param y Y coordinate of the position.
 */
public void activateUnflattening(short x,short y){
  ELandscapeType landscapeType=getLandscapeTypeAt(x,y);
  if (landscapeType == ELandscapeType.MOUNTAIN || landscapeType == ELandscapeType.DESERT) {
    return;
  }
  this.temporaryFlatened[x + y * width]=(byte)(40 + RandomSingleton.nextF() * 80);
  this.flattenedResetter.addPosition(x,y);
}"
56237,"@Override public final void setWorkAreaCenter(ShortPoint2D workAreaCenter){
  drawWorkAreaCircle(false);
  this.workAreaCenter=workAreaCenter;
  if (isSelected()) {
    drawWorkAreaCircle(true);
  }
}","@Override public final void setWorkAreaCenter(ShortPoint2D newWorkAreaCenter){
  int distance=super.getPos().getOnGridDistTo(newWorkAreaCenter);
  if (distance < Constants.BUILDINGS_MAX_WORKRADIUS_FACTOR * super.getBuildingType().getWorkradius()) {
    drawWorkAreaCircle(false);
    this.workAreaCenter=newWorkAreaCenter;
    if (isSelected()) {
      drawWorkAreaCircle(true);
    }
  }
}"
56238,"/** 
 * move the selected movables to the given position.
 * @param pos position to move to
 * @param list
 */
private void moveSelectedTo(ShortPoint2D pos,List<Integer> list){
  if (list.size() == 1) {
    NewMovable currMovable=NewMovable.getMovableByID(list.get(0));
    if (currMovable != null)     currMovable.moveTo(pos);
  }
 else   if (!list.isEmpty()) {
    float radius=(float)(Math.sqrt(list.size() / 3.14f)) * 2;
    MapCircle mapCircle=new MapCircle(pos,radius);
    NewMovable leader=null;
    Iterator<ShortPoint2D> circleIter=mapCircle.iterator();
    int ctr=0;
    for (    Integer currID : list) {
      NewMovable currMovable=NewMovable.getMovableByID(currID);
      if (leader == null || ctr % 30 == 0) {
        leader=currMovable;
      }
      if (currMovable != null) {
        circleIter.next();
        currMovable.moveTo(circleIter.next());
      }
      ctr++;
    }
  }
}","/** 
 * Move the selected   {@link NewMovable} to the given position.
 * @param targetPosition position to move to
 * @param movableIds A list of the id's of the movables.
 */
private void moveSelectedTo(ShortPoint2D targetPosition,List<Integer> movableIds){
  if (movableIds.size() == 1) {
    NewMovable currMovable=NewMovable.getMovableByID(movableIds.get(0));
    if (currMovable != null)     currMovable.moveTo(targetPosition);
  }
 else   if (!movableIds.isEmpty()) {
    short radius=1;
    short ringsWithoutSuccessCtr=0;
    Iterator<ShortPoint2D> posIterator=new HexBorderArea(targetPosition,radius).iterator();
    for (    Integer currMovableId : movableIds) {
      NewMovable currMovable=NewMovable.getMovableByID(currMovableId);
      ShortPoint2D currTargetPos;
      do {
        if (!posIterator.hasNext()) {
          ringsWithoutSuccessCtr++;
          if (ringsWithoutSuccessCtr > 5) {
            return;
          }
          radius++;
          posIterator=new HexBorderArea(targetPosition,radius).iterator();
        }
        currTargetPos=posIterator.next();
      }
 while (!canMoveTo(currMovable,currTargetPos));
      ringsWithoutSuccessCtr=0;
      currMovable.moveTo(currTargetPos);
    }
  }
}"
56239,"@Override public final boolean isBlocked(short x,short y){
  return flagsGrid.isBlocked(x,y);
}","@Override public boolean isBlocked(ShortPoint2D position){
  return flagsGrid.isBlocked(position.x,position.y);
}"
56240,"@Override public final short getBlockedPartition(short x,short y){
  return landscapeGrid.getBlockedPartitionAt(x,y);
}","@Override public short getBlockedPartition(ShortPoint2D position){
  return landscapeGrid.getBlockedPartitionAt(position.x,position.y);
}"
56241,"private Action getForMinimap(float relativex,float relativey,boolean selecting){
  float minimapx=(relativex - constants.MINIMAP_BOTTOMLEFT_X) / constants.MINIMAP_WIDTH;
  float minimapy=((relativey - constants.UI_CENTERY) / (1 - constants.UI_CENTERY) - constants.MINIMAP_BOTTOM_Y) / constants.MINIMAP_HEIGHT;
  ShortPoint2D clickPosition=minimap.getClickPositionIfOnMap(minimapx,minimapy);
  if (clickPosition != null) {
    if (selecting) {
      return new PointAction(EActionType.PAN_TO,clickPosition);
    }
 else {
      return new PointAction(EActionType.SELECT_POINT,clickPosition);
    }
  }
 else {
    return null;
  }
}","private Action getForMinimap(float relativex,float relativey,boolean selecting){
  float minimapx=(relativex - constants.MINIMAP_BOTTOMLEFT_X) / constants.MINIMAP_WIDTH;
  float minimapy=((relativey - constants.UI_CENTERY) / (1 - constants.UI_CENTERY) - constants.MINIMAP_BOTTOM_Y) / constants.MINIMAP_HEIGHT;
  ShortPoint2D clickPosition=minimap.getClickPositionIfOnMap(minimapx,minimapy);
  if (clickPosition != null) {
    if (selecting) {
      return new PointAction(EActionType.PAN_TO,clickPosition);
    }
 else {
      return new PointAction(EActionType.MOVE_TO,clickPosition);
    }
  }
 else {
    return null;
  }
}"
56242,"public static MapInterfaceConnector openTestWindow(IGraphicsGrid map){
  ImageProvider.getInstance().startPreloading();
  JOGLPanel content=new JOGLPanel(new SoundPlayer(){
    @Override public void playSound(    int sound,    float lvolume,    float rvolume){
    }
    @Override public void setSoundDataRetriever(    ISoundDataRetriever soundDataRetriever){
    }
  }
);
  new NativeAreaWindow(content.getArea());
  MapInterfaceConnector connector=content.showGameMap(map,null);
  connector.addListener(new IMapInterfaceListener(){
    @Override public void action(    Action action){
      if (action.getActionType() == EActionType.SELECT_POINT) {
        PointAction selectAction=(PointAction)action;
        System.out.println(""String_Node_Str"" + action.getActionType() + ""String_Node_Str""+ selectAction.getPosition());
      }
 else {
        System.out.println(""String_Node_Str"" + action.getActionType());
      }
    }
  }
);
  return connector;
}","public static MapInterfaceConnector openTestWindow(IStartedGame game){
  ImageProvider.getInstance().startPreloading();
  JSettlersScreen content=SwingManagedJSettlers.startGui(Collections.<String>emptyList());
  MapContent mapContent=new MapContent(game,new SwingSoundPlayer());
  content.setContent(mapContent);
  mapContent.getInterfaceConnector().addListener(new IMapInterfaceListener(){
    @Override public void action(    Action action){
      if (action.getActionType() == EActionType.SELECT_POINT) {
        PointAction selectAction=(PointAction)action;
        System.out.println(""String_Node_Str"" + action.getActionType() + ""String_Node_Str""+ selectAction.getPosition());
      }
 else {
        System.out.println(""String_Node_Str"" + action.getActionType());
      }
    }
  }
);
  return mapContent.getInterfaceConnector();
}"
56243,"public void removePositionTo(final int x,final int y,final Partition newPartitionObject){
}","public void removePositionTo(final int x,final int y,final Partition newPartitionObject){
  if (this == newPartitionObject) {
    System.out.println(""String_Node_Str"" + x + ""String_Node_Str""+ y+ ""String_Node_Str"");
  }
  this.decrement(x,y);
  newPartitionObject.increment(x,y);
  super.removePositionTo(x,y,newPartitionObject,newPartitionObject.playerId == this.playerId);
  if (isEmpty())   super.stopManager();
}"
56244,"/** 
 * Occupies the given area for the given playerId.
 * @param playerId
 * @param filteredInfluencingArea
 * @param borders
 */
private void occupyArea(byte playerId,Iterable<ShortPoint2D> influencingArea,SRectangle borders){
  IPredicate<ShortPoint2D> predicate=new IPredicate<ShortPoint2D>(){
    @Override public boolean evaluate(    ShortPoint2D pos){
      return towers[pos.x + pos.y * width] <= 0;
    }
  }
;
  IteratorFilter<ShortPoint2D> filtered=new IteratorFilter<ShortPoint2D>(influencingArea,predicate);
  PartitionCalculatorAlgorithm partitioner=new PartitionCalculatorAlgorithm(filtered,blockingProvider,borders.xMin,borders.yMin,borders.xMax,borders.yMax);
  partitioner.calculatePartitions();
  short[] newPartitionsMap=acquirePartitionedArea(playerId,partitioner);
  checkForMergesAndDivides(playerId,partitioner,newPartitionsMap);
  changeTowerCounter(playerId,influencingArea,+1);
}","/** 
 * Occupies the given area for the given playerId.
 * @param playerId
 * @param filteredInfluencingArea
 * @param borders
 */
private void occupyArea(final byte playerId,Iterable<ShortPoint2D> influencingArea,SRectangle borders){
  IPredicate<ShortPoint2D> predicate=new IPredicate<ShortPoint2D>(){
    @Override public boolean evaluate(    ShortPoint2D pos){
      int index=pos.x + pos.y * width;
      return towers[index] <= 0 && partitionObjects[partitions[index]].playerId != playerId;
    }
  }
;
  IteratorFilter<ShortPoint2D> filtered=new IteratorFilter<ShortPoint2D>(influencingArea,predicate);
  PartitionCalculatorAlgorithm partitioner=new PartitionCalculatorAlgorithm(filtered,blockingProvider,borders.xMin,borders.yMin,borders.xMax,borders.yMax);
  partitioner.calculatePartitions();
  short[] newPartitionsMap=acquirePartitionedArea(playerId,partitioner);
  checkForMergesAndDivides(playerId,partitioner,newPartitionsMap);
  changeTowerCounter(playerId,influencingArea,+1);
}"
56245,"private MovableTestWindow() throws InterruptedException {
  MatchConstants.clock=new NetworkTimer();
  MatchConstants.clock.startExecution();
  RandomSingleton.load(1000);
  MovableTestsMap grid=new MovableTestsMap(100,100);
  MapInterfaceConnector connector=TestWindow.openTestWindow(grid);
  movable=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(49,50),PLAYER_0);
  movable.setSelected(true);
  connector.setSelection(new SelectionSet(movable));
  connector.addListener(new IMapInterfaceListener(){
    @Override public void action(    Action action){
switch (action.getActionType()) {
case MOVE_TO:
        movable.moveTo(((PointAction)action).getPosition());
      break;
case SPEED_FASTER:
    MatchConstants.clock.multiplyGameSpeed(1.2f);
  break;
case SPEED_SLOWER:
MatchConstants.clock.multiplyGameSpeed(1 / 1.2f);
break;
case FAST_FORWARD:
MatchConstants.clock.fastForward();
break;
default :
break;
}
}
}
);
grid.getMovableGrid().dropMaterial(new ShortPoint2D(40,40),EMaterialType.PLANK,true);
grid.getMovableGrid().dropMaterial(new ShortPoint2D(60,60),EMaterialType.STONE,true);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(30,30),PLAYER_0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(31,31),PLAYER_0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(32,32),PLAYER_0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(33,33),PLAYER_0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(50,50),PLAYER_0);
{
for (int x=30; x < 40; x++) {
for (int y=80; y < 90; y++) {
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(x,y),PLAYER_0);
}
}
}
{
Thread.sleep(3000);
NewMovable m1=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(50,65),PLAYER_0);
NewMovable m2=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(51,65),PLAYER_0);
NewMovable m3=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(50,64),PLAYER_0);
m1.moveTo(new ShortPoint2D(52,65));
m2.moveTo(new ShortPoint2D(49,63));
m3.moveTo(new ShortPoint2D(50,66));
}
}","private MovableTestWindow() throws InterruptedException {
  MatchConstants.clock=new NetworkTimer(true);
  MatchConstants.clock.startExecution();
  RandomSingleton.load(1000);
  MovableTestsMap grid=new MovableTestsMap(100,100,PLAYER_0);
  MapInterfaceConnector connector=TestWindow.openTestWindow(grid);
  movable=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(49,50),PLAYER_0);
  movable.setSelected(true);
  connector.setSelection(new SelectionSet(movable));
  connector.addListener(new IMapInterfaceListener(){
    @Override public void action(    Action action){
switch (action.getActionType()) {
case MOVE_TO:
        movable.moveTo(((PointAction)action).getPosition());
      break;
case SPEED_FASTER:
    MatchConstants.clock.multiplyGameSpeed(1.2f);
  break;
case SPEED_SLOWER:
MatchConstants.clock.multiplyGameSpeed(1 / 1.2f);
break;
case FAST_FORWARD:
MatchConstants.clock.fastForward();
break;
default :
break;
}
}
}
);
grid.getMovableGrid().dropMaterial(new ShortPoint2D(40,40),EMaterialType.PLANK,true);
grid.getMovableGrid().dropMaterial(new ShortPoint2D(60,60),EMaterialType.STONE,true);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(30,30),PLAYER_0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(31,31),PLAYER_0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(32,32),PLAYER_0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(33,33),PLAYER_0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(50,50),PLAYER_0);
{
for (int x=30; x < 40; x++) {
for (int y=80; y < 90; y++) {
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(x,y),PLAYER_0);
}
}
}
{
Thread.sleep(3000);
NewMovable m1=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(50,65),PLAYER_0);
NewMovable m2=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(51,65),PLAYER_0);
NewMovable m3=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(50,64),PLAYER_0);
m1.moveTo(new ShortPoint2D(52,65));
m2.moveTo(new ShortPoint2D(49,63));
m3.moveTo(new ShortPoint2D(50,66));
}
}"
56246,"public MovableTestsMap(int width,int height){
  this.width=(short)width;
  this.height=(short)height;
  this.movableMap=new NewMovable[width][height];
  this.materialTypeMap=new EMaterialType[width][height];
  this.materialAmmountMap=new byte[width][height];
  aStar=new HexAStar(this,this.width,this.height);
}","public MovableTestsMap(int width,int height,Player defaultPlayer){
  this.width=(short)width;
  this.height=(short)height;
  this.defaultPlayer=defaultPlayer;
  this.movableMap=new NewMovable[width][height];
  this.materialTypeMap=new EMaterialType[width][height];
  this.materialAmmountMap=new byte[width][height];
  aStar=new HexAStar(this,this.width,this.height);
}"
56247,"/** 
 * Creates a new SWING GUI for the game.
 * @param argsList
 * @param startScreen
 * @return
 */
public static JSettlersScreen startGui(List<String> argsList,IStartScreen startScreen){
  Area area=new Area();
  JSettlersScreen content=new JSettlersScreen();
  area.add(content.getRegion());
  content.setContent(new StartScreen(startScreen,content));
  if (argsList.contains(""String_Node_Str"")) {
    startJogl(area);
  }
 else   if (argsList.contains(""String_Node_Str"")) {
    startNative(area);
  }
 else {
    try {
      startNative(area);
    }
 catch (    Throwable t) {
      startJogl(area);
    }
  }
  startRedrawTimer(content);
  return content;
}","/** 
 * Creates a new SWING GUI for the game.
 * @param argsList
 * @return
 */
public static JSettlersScreen startGui(List<String> argsList){
  Area area=new Area();
  JSettlersScreen content=new JSettlersScreen();
  area.add(content.getRegion());
  if (argsList.contains(""String_Node_Str"")) {
    startJogl(area);
  }
 else   if (argsList.contains(""String_Node_Str"")) {
    startNative(area);
  }
 else {
    try {
      startNative(area);
    }
 catch (    Throwable t) {
      startJogl(area);
    }
  }
  startRedrawTimer(content);
  return content;
}"
56248,"/** 
 * @param args args can have no entries or <br> args[0] must be ""host"" or ""client""
 * @throws FileNotFoundException
 * @throws IOException
 * @throws ClassNotFoundException
 */
public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException {
  List<String> argsList=Arrays.asList(args);
  loadDebugSettings(argsList);
  ResourceManager.setProvider(new SwingResourceProvider());
  startGui(argsList,new StartScreenConnector());
  ImageProvider.getInstance().startPreloading();
}","/** 
 * @param args args can have no entries or <br> args[0] must be ""host"" or ""client""
 * @throws FileNotFoundException
 * @throws IOException
 * @throws ClassNotFoundException
 */
public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException {
  List<String> argsList=Arrays.asList(args);
  loadDebugSettings(argsList);
  ResourceManager.setProvider(new SwingResourceProvider());
  JSettlersScreen content=startGui(argsList);
  generateContent(new StartScreenConnector(),content);
  ImageProvider.getInstance().startPreloading();
}"
56249,"@Override public void stop(){
  listener=null;
  items=null;
}","@Override public void stop(){
  listener=null;
  items=Collections.emptyList();
}"
56250,"public ChangingList(List<? extends T> items){
  this.items=items;
}","public ChangingList(List<? extends T> items){
  setList(items);
}"
56251,"public void setList(List<T> items){
  this.items=items;
  informListener();
}","public void setList(List<? extends T> items){
  if (items == null) {
    throw new NullPointerException();
  }
  this.items=items;
  informListener();
}"
56252,"private IPacketReceiver<MatchStartPacket> generateMatchStartedListener(){
  return new IPacketReceiver<MatchStartPacket>(){
    @Override public void receivePacket(    MatchStartPacket packet){
      updatePlayersList(packet.getMatchInfo().getPlayers());
      MapLoader mapLoader=MapList.getDefaultList().getMapById(packet.getMatchInfo().getMapInfo().getId());
      long randomSeed=packet.getRandomSeed();
      byte myPlayerNumber=getMyPlayerNumber();
      JSettlersGame game=new JSettlersGame(mapLoader,randomSeed,myPlayerNumber);
      multiplayerListener.gameIsStarting(game.start());
    }
  }
;
}","private IPacketReceiver<MatchStartPacket> generateMatchStartedListener(){
  return new IPacketReceiver<MatchStartPacket>(){
    @Override public void receivePacket(    MatchStartPacket packet){
      updatePlayersList(packet.getMatchInfo().getPlayers());
      MapLoader mapLoader=MapList.getDefaultList().getMapById(packet.getMatchInfo().getMapInfo().getId());
      long randomSeed=packet.getRandomSeed();
      byte myPlayerNumber=getMyPlayerNumber();
      JSettlersGame game=new JSettlersGame(mapLoader,randomSeed,networkClient,myPlayerNumber);
      multiplayerListener.gameIsStarting(game.start());
    }
  }
;
}"
56253,"public StartScreen(IStartScreen connector,IContentSetable contentSetable){
  this.connector=connector;
  this.contentSetable=contentSetable;
  addButtons();
  content=new UIPanel();
  addChild(content,.55f,.05f,.95f,.95f);
}","public StartScreen(IStartScreen connector,IContentSetable contentSetable){
  this.connector=connector;
  this.contentSetable=contentSetable;
  setBackground(BACKGROUND);
  addButtons();
  content=new UIPanel();
  addChild(content,.55f,.05f,.95f,.95f);
}"
56254,"public JoinPhaseScreen(IJoinPhaseMultiplayerGameConnector connector,IContentSetable contentSetable){
  this.connector=connector;
  this.contentSetable=contentSetable;
  connector.setMultiplayerListener(this);
  addStartButton();
  addPlayerList();
}","public JoinPhaseScreen(IJoinPhaseMultiplayerGameConnector connector,IContentSetable contentSetable){
  this.connector=connector;
  this.contentSetable=contentSetable;
  setBackground(StartScreen.BACKGROUND);
  connector.setMultiplayerListener(this);
  addStartButton();
  addPlayerList();
}"
56255,"private void addPlayerList(){
  multiplayerList=new UIList<IMultiplayerPlayer>(connector.getPlayers().getItems(),new ListItemGenerator<IMultiplayerPlayer>(){
    @Override public UIListItem getItem(    IMultiplayerPlayer item){
      return new GenericListItem(item.getName(),item.toString());
    }
  }
,.1f);
}","private void addPlayerList(){
  multiplayerList=new UIList<IMultiplayerPlayer>(connector.getPlayers().getItems(),new ListItemGenerator<IMultiplayerPlayer>(){
    @Override public UIListItem getItem(    IMultiplayerPlayer item){
      return new GenericListItem(item.getName(),item.toString());
    }
  }
,.1f);
  this.addChild(multiplayerList,.1f,.15f,.1f,.85f);
}"
56256,"@Override public void gameAborted(){
}","@Override public void gameAborted(){
  throw new UnsupportedOperationException();
}"
56257,"public ProgressPanel(){
  setBackground(new OriginalImageLink(EImageLinkType.GUI,2,29,0));
}","public ProgressPanel(){
  setBackground(StartScreen.BACKGROUND);
}"
56258,"@Override protected void receivePacket(int key,TimeSyncPacket packet) throws IOException {
  int expectedRemoteTime=packet.getTime() + rttSupplier.getRoundTripTime().getRtt() / 2;
  int localTime=clock.getTime();
  int deltaTime=localTime - expectedRemoteTime;
  if (deltaTime > Client.TIME_SYNC_TOLERATED_DIFFERENCE) {
    clock.stopClockFor((int)(deltaTime * Client.TIME_SYNC_APPROACH_FACTOR));
  }
}","@Override protected void receivePacket(int key,TimeSyncPacket packet) throws IOException {
  int expectedRemoteTime=packet.getTime() + rttSupplier.getRoundTripTime().getRtt() / 2;
  int localTime=clock.getTime();
  int deltaTime=localTime - expectedRemoteTime;
  if (deltaTime > Client.TIME_SYNC_TOLERATED_DIFFERENCE) {
    clock.pauseClockFor((int)(deltaTime * Client.TIME_SYNC_APPROACH_FACTOR));
  }
}"
56259,"/** 
 * Gets the round trip time of this   {@link Channel}.
 * @return Returns the current {@link RoundTripTime}.
 */
public RoundTripTime getRoundTripTime(){
  return currRtt;
}","/** 
 * Gets the round trip time of this   {@link Channel}.
 * @return Returns the current {@link RoundTripTime}.
 */
@Override public RoundTripTime getRoundTripTime(){
  return currRtt;
}"
56260,"public NetworkTimer(boolean noLockstepWaiting){
  this();
  if (noLockstepWaiting) {
    maxAllowedLockstep=Integer.MAX_VALUE;
  }
}","public NetworkTimer(boolean disableLockstepWaiting){
  this();
  if (disableLockstepWaiting) {
    maxAllowedLockstep=Integer.MAX_VALUE;
  }
}"
56261,"/** 
 * Sets the multiplayer listener that listens to game state changes. If the game has already started,  {@link IMultiplayerListener#gameStarted(IStartingGame)} is calledimmediately by this method.
 * @param l�stener
 */
public void setMultiplayerListener(IMultiplayerListener l){
}","/** 
 * Sets the multiplayer listener that listens to game state changes. If the game has already started,  {@link IMultiplayerListener#gameStarted(IStartingGame)} is calledimmediately by this method.
 * @param listener
 */
public void setMultiplayerListener(IMultiplayerListener listener);"
56262,"@Override protected void constructionFinishedEvent(){
  IRequestStackListener listener=new IRequestStackListener(){
    @Override public void materialDelivered(    RequestStack stack){
      getGrid().requestSoilderable(Barrack.this);
    }
  }
;
  for (  RequestStack curr : super.getStacks()) {
    curr.setListener(listener);
  }
}","@Override protected void constructionFinishedEvent(){
  for (  RequestStack curr : super.getStacks()) {
    curr.setListener(this);
  }
}"
56263,"public MainGrid load(InputStream inStream) throws MapLoadException {
  try {
    final ObjectInputStream ois=new ObjectInputStream(inStream);
    LoadRunnable runnable=new LoadRunnable(ois);
    Thread t=new Thread(null,runnable,""String_Node_Str"",LOAD_STACK_SIZE);
    t.start();
    t.join();
    return runnable.grid;
  }
 catch (  Throwable t) {
    throw new MapLoadException(t);
  }
}","public MainGrid load(InputStream inStream) throws MapLoadException {
  try {
    final ObjectInputStream ois=new ObjectInputStream(inStream);
    LoadRunnable runnable=new LoadRunnable(ois);
    Thread t=new Thread(null,runnable,""String_Node_Str"",LOAD_STACK_SIZE);
    t.start();
    t.join();
    if (runnable.grid != null) {
      return runnable.grid;
    }
 else {
      throw new MapLoadException(""String_Node_Str"",runnable.exception);
    }
  }
 catch (  Throwable t) {
    throw new MapLoadException(t);
  }
}"
56264,"/** 
 * Saves the grid to the given output file.
 * @param grid The grid to use.
 * @param out The output file/stream for the game.
 * @throws IOException
 */
public void save(MainGrid grid,OutputStream out) throws IOException {
  final ObjectOutputStream oos=new ObjectOutputStream(out);
  Thread t=new Thread(null,new GameSaveTask(grid,oos),""String_Node_Str"",SAVE_STACK_SIZE);
  t.start();
  try {
    t.join();
  }
 catch (  InterruptedException e) {
    throw new IOException(e);
  }
  oos.flush();
  oos.close();
}","/** 
 * Saves the grid to the given output file.
 * @param grid The grid to use.
 * @param out The output file/stream for the game.
 * @throws IOException
 */
public void save(MainGrid grid,OutputStream out) throws IOException {
  final ObjectOutputStream oos=new ObjectOutputStream(out);
  GameSaveTask runnable=new GameSaveTask(grid,oos);
  Thread t=new Thread(null,runnable,""String_Node_Str"",SAVE_STACK_SIZE);
  t.start();
  try {
    t.join();
  }
 catch (  InterruptedException e) {
    throw new IOException(e);
  }
  if (runnable.exception != null) {
    throw new IOException(""String_Node_Str"",runnable.exception);
  }
  oos.flush();
  oos.close();
}"
56265,"@Override public void run(){
  try {
    NetworkTimer.get().setGameTime(ois.readInt());
    grid=(MainGrid)ois.readObject();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
catch (  ClassNotFoundException e) {
    e.printStackTrace();
  }
}","@Override public void run(){
  try {
    NetworkTimer.get().setGameTime(ois.readInt());
    grid=(MainGrid)ois.readObject();
  }
 catch (  Throwable t) {
    t.printStackTrace();
    this.exception=t;
  }
}"
56266,"private boolean isFlatened(){
  if (shouldBeFlatened()) {
    for (    RelativePoint currPos : type.getBlockedTiles()) {
      if (grid.getHeightAt(currPos.calculatePoint(this.pos)) != heightAvg) {
        return false;
      }
    }
    return true;
  }
 else {
    return true;
  }
}","private boolean isFlatened(){
  if (shouldBeFlatened()) {
    return grid.isAreaFlattenedAtHeight(pos,getFlattenTiles(),heightAvg);
  }
 else {
    return true;
  }
}"
56267,"@Override public void changeHeightTowards(short x,short y,byte targetHeight){
  landscapeGrid.flattenAndChangeHeightTowards(x,y,targetHeight);
}","@Override public void changeHeightTowards(short x,short y,byte targetHeight){
  landscapeGrid.flattenAndChangeHeightTowards(x,y,targetHeight);
  objectsGrid.removeMapObjectType(x,y,EMapObjectType.CORN_ADULT);
  objectsGrid.removeMapObjectType(x,y,EMapObjectType.CORN_DEAD);
  objectsGrid.removeMapObjectType(x,y,EMapObjectType.CORN_GROWING);
}"
56268,"private final boolean isCornPlantable(int x,int y){
  ELandscapeType landscapeType=landscapeGrid.getLandscapeTypeAt(x,y);
  return (landscapeType.isGrass() || landscapeType == ELandscapeType.EARTH) && !flagsGrid.isProtected(x,y) && !hasProtectedNeighbor(x,y)&& !objectsGrid.hasMapObjectType(x,y,EMapObjectType.CORN_GROWING)&& !objectsGrid.hasMapObjectType(x,y,EMapObjectType.CORN_ADULT)&& !objectsGrid.hasNeighborObjectType(x,y,EMapObjectType.CORN_ADULT)&& !objectsGrid.hasNeighborObjectType(x,y,EMapObjectType.CORN_GROWING);
}","private final boolean isCornPlantable(int x,int y){
  ELandscapeType landscapeType=landscapeGrid.getLandscapeTypeAt(x,y);
  return (landscapeType == ELandscapeType.GRASS || landscapeType == ELandscapeType.EARTH) && !flagsGrid.isProtected(x,y) && !hasProtectedNeighbor(x,y)&& !objectsGrid.hasMapObjectType(x,y,EMapObjectType.CORN_GROWING)&& !objectsGrid.hasMapObjectType(x,y,EMapObjectType.CORN_ADULT)&& !objectsGrid.hasNeighborObjectType(x,y,EMapObjectType.CORN_ADULT)&& !objectsGrid.hasNeighborObjectType(x,y,EMapObjectType.CORN_GROWING)&& areAllNeighborsOneOf(x,y,2,ELandscapeType.GRASS,ELandscapeType.EARTH);
}"
56269,"private ShortPoint2D getDiggablePosition(){
  RelativePoint[] blockedTiles=requester.getBuildingType().getProtectedTiles();
  ShortPoint2D buildingPos=requester.getPos();
  int offset=RandomSingleton.getInt(0,blockedTiles.length - 1);
  for (int i=0; i < blockedTiles.length; i++) {
    ShortPoint2D pos=blockedTiles[(i + offset) % blockedTiles.length].calculatePoint(buildingPos);
    if (needsToBeWorkedOn(pos) && !super.getStrategyGrid().isMarked(pos)) {
      return pos;
    }
  }
  return null;
}","private ShortPoint2D getDiggablePosition(){
  RelativePoint[] blockedTiles=requester.getBuildingType().getProtectedTiles();
  ShortPoint2D buildingPos=requester.getPos();
  int offset=RandomSingleton.getInt(0,blockedTiles.length - 1);
  for (int i=0; i < blockedTiles.length; i++) {
    ShortPoint2D pos=blockedTiles[(i + offset) % blockedTiles.length].calculatePoint(buildingPos);
    if (!super.getStrategyGrid().isMarked(pos) && needsToBeWorkedOn(pos)) {
      return pos;
    }
  }
  return null;
}"
56270,"@Override public void changeHeightTowards(short x,short y,byte targetHeight){
  byte currHeight=landscapeGrid.getHeightAt(x,y);
  landscapeGrid.setHeightAt(x,y,(byte)(currHeight + Math.signum(targetHeight - currHeight)));
  landscapeGrid.setLandscapeTypeAt(x,y,ELandscapeType.FLATTENED);
}","@Override public void changeHeightTowards(short x,short y,byte targetHeight){
  landscapeGrid.flattenAndChangeHeightTowards(x,y,targetHeight);
}"
56271,"@Override public final void removeBuildingAt(ShortPoint2D pos){
  IBuilding building=(IBuilding)objectsGrid.getMapObjectAt(pos.x,pos.y,EMapObjectType.BUILDING);
  mapObjectsManager.removeMapObjectType(pos.x,pos.y,EMapObjectType.BUILDING);
  FreeMapArea area=new FreeMapArea(pos,building.getBuildingType().getProtectedTiles());
  objectsGrid.setBuildingArea(area,null);
  for (  ShortPoint2D curr : area) {
    short x=curr.x;
    short y=curr.y;
    if (isInBounds(x,y)) {
      flagsGrid.setBlockedAndProtected(x,y,false);
    }
  }
}","@Override public final void removeBuildingAt(ShortPoint2D pos){
  IBuilding building=(IBuilding)objectsGrid.getMapObjectAt(pos.x,pos.y,EMapObjectType.BUILDING);
  mapObjectsManager.removeMapObjectType(pos.x,pos.y,EMapObjectType.BUILDING);
  FreeMapArea area=new FreeMapArea(pos,building.getBuildingType().getProtectedTiles());
  objectsGrid.setBuildingArea(area,null);
  for (  ShortPoint2D curr : area) {
    short x=curr.x;
    short y=curr.y;
    if (isInBounds(x,y)) {
      flagsGrid.setBlockedAndProtected(x,y,false);
      landscapeGrid.activateUnflattening(x,y);
    }
  }
}"
56272,"@Override public boolean countFlattenedDown(short x,short y){
  int i=x + y * width;
  temporaryFlatened[i]--;
  if (temporaryFlatened[i] <= -30) {
    temporaryFlatened[i]=0;
    setLandscapeTypeAt(x,y,ELandscapeType.GRASS);
    return true;
  }
 else {
    return false;
  }
}","@Override public boolean countFlattenedDown(short x,short y){
  final int index=x + y * width;
  byte flattenedValue=temporaryFlatened[index];
  if (flattenedValue == Byte.MAX_VALUE) {
    return true;
  }
  flattenedValue--;
  temporaryFlatened[index]=flattenedValue;
  if (flattenedValue <= -30) {
    temporaryFlatened[index]=0;
    setLandscapeTypeAt(x,y,ELandscapeType.GRASS);
    return true;
  }
 else {
    return false;
  }
}"
56273,"@Override protected void onPause(){
  super.onPause();
  goView.onPause();
  soundPlayer.setPaused(true);
  if (!goView.canPreserveContext()) {
    ImageProvider.getInstance().invalidateAll();
  }
}","@Override protected void onPause(){
  super.onPause();
  goView.onPause();
  soundPlayer.setPaused(true);
  goView.setContextDestroyedListener(new IContextDestroyedListener(){
    @Override public void glContextDestroyed(){
      ImageProvider.getInstance().invalidateAll();
    }
  }
);
}"
56274,"@Override public IMovable getMovableAt(int x,int y){
  if (x > MOVABLE_BORDER && getLandscapeTypeAt(x,y) == ELandscapeType.GRASS && getRand(x,y) > 1 - MOVABLE_PROBABILITY) {
    return movable;
  }
 else {
    return null;
  }
}","@Override public IMovable getMovableAt(int x,int y){
  if (x > MOVABLE_BORDER && getLandscapeTypeAt(x,y) == ELandscapeType.GRASS && getRand(x,y) > 1 - MOVABLE_PROBABILITY) {
    return new BgMovable(new ShortPoint2D(x,y));
  }
 else {
    return null;
  }
}"
56275,"@Override public EMaterialType getMaterial(){
  return null;
}","@Override public EMaterialType getMaterial(){
  return EMaterialType.NO_MATERIAL;
}"
56276,"@Override public ShortPoint2D getPos(){
  return null;
}","@Override public ShortPoint2D getPos(){
  return point;
}"
56277,"@Override public final ShortPoint2D getConstructablePosition(ShortPoint2D pos,EBuildingType type,boolean useNeighbors){
  Player player=partitionsGrid.getPlayerAt(pos.x,pos.y);
  if (constructionMarksGrid.canConstructAt(pos.x,pos.y,type,player)) {
    return pos;
  }
 else   if (useNeighbors) {
    for (    ShortPoint2D neighbour : new MapNeighboursArea(pos)) {
      if (constructionMarksGrid.canConstructAt(neighbour.x,neighbour.y,type,player)) {
        return neighbour;
      }
    }
    return null;
  }
 else {
    return null;
  }
}","@Override public final ShortPoint2D getConstructablePosition(ShortPoint2D pos,EBuildingType type,boolean useNeighbors){
  Player player=partitionsGrid.getPlayerAt(pos.x,pos.y);
  if (player != null) {
    if (constructionMarksGrid.canConstructAt(pos.x,pos.y,type,player)) {
      return pos;
    }
 else     if (useNeighbors) {
      for (      ShortPoint2D neighbour : new MapNeighboursArea(pos)) {
        if (constructionMarksGrid.canConstructAt(neighbour.x,neighbour.y,type,player)) {
          return neighbour;
        }
      }
      return null;
    }
  }
  return null;
}"
56278,"public Player getPlayerAt(int x,int y){
  return players[partitionObjects[partitions[x + y * width]].playerId];
}","public Player getPlayerAt(int x,int y){
  short playerId=partitionObjects[partitions[x + y * width]].playerId;
  if (playerId >= 0) {
    return players[playerId];
  }
 else {
    return null;
  }
}"
56279,"public AndroidTextDrawer(EFontSize size,AndroidContext context){
  this.size=size;
  this.context=context;
}","private AndroidTextDrawer(EFontSize size,AndroidContext context){
  this.size=size;
  this.context=context;
}"
56280,"private void tryEnableContextPreservation(){
  try {
    Method m=GLSurfaceView.class.getMethod(""String_Node_Str"",Boolean.TYPE);
    m.invoke(this,true);
  }
 catch (  Throwable t) {
    Log.w(""String_Node_Str"",""String_Node_Str"");
  }
}","private void tryEnableContextPreservation(){
  try {
    Method m=GLSurfaceView.class.getMethod(""String_Node_Str"",Boolean.TYPE);
    m.invoke(this,true);
  }
 catch (  Throwable t) {
    Log.d(""String_Node_Str"",""String_Node_Str"");
  }
}"
56281,"public GOSurfaceView(Context context,Area area){
  super(context);
  this.area=area;
  setRenderer(new Renderer(context));
  setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY);
  tryEnableContextPreservation();
  area.addRedrawListener(this);
}","public GOSurfaceView(Context context,Area area){
  super(context);
  this.area=area;
  setEGLContextFactory(new Factory());
  setRenderer(new Renderer(context));
  setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY);
  tryEnableContextPreservation();
  area.addRedrawListener(this);
}"
56282,"public void setScreen(MapRectangle mapArea){
  this.mapArea=mapArea;
  this.notifyAll();
}","public synchronized void setScreen(MapRectangle mapArea){
  this.mapArea=mapArea;
  this.notifyAll();
}"
56283,"public void setBuildingType(EBuildingType type){
  this.buildingType=type;
  this.notifyAll();
}","public synchronized void setBuildingType(EBuildingType type){
  this.buildingType=type;
  this.notifyAll();
}"
56284,"private final void initPathfinders(){
  pathfinderGrid=new PathfinderGrid();
  aStar=new BucketQueueAStar(pathfinderGrid,width,height);
  dijkstra=new DijkstraAlgorithm(pathfinderGrid,aStar,width,height);
  inAreaFinder=new InAreaFinder(pathfinderGrid,width,height);
}","private final void initPathfinders(){
  pathfinderGrid=new PathfinderGrid();
  aStar=new HexAStar(pathfinderGrid,width,height);
  dijkstra=new DijkstraAlgorithm(pathfinderGrid,aStar,width,height);
  inAreaFinder=new InAreaFinder(pathfinderGrid,width,height);
}"
56285,"@Override public final boolean setBuilding(ShortPoint2D position,Building newBuilding){
  if (MainGrid.this.isInBounds(position.x,position.y)) {
    FreeMapArea area=new FreeMapArea(position,newBuilding.getBuildingType().getBlockedTiles());
    if (canConstructAt(area)) {
      setProtectedState(area,true);
      mapObjectsManager.addBuildingTo(position,newBuilding);
      objectsGrid.setBuildingArea(area,newBuilding);
      return true;
    }
 else {
      return false;
    }
  }
 else {
    return false;
  }
}","@Override public final boolean setBuilding(ShortPoint2D position,Building newBuilding){
  if (MainGrid.this.isInBounds(position.x,position.y)) {
    FreeMapArea protectedArea=new FreeMapArea(position,newBuilding.getBuildingType().getProtectedTiles());
    if (canConstructAt(protectedArea)) {
      setProtectedState(protectedArea,true);
      mapObjectsManager.addBuildingTo(position,newBuilding);
      objectsGrid.setBuildingArea(new FreeMapArea(position,newBuilding.getBuildingType().getBlockedTiles()),newBuilding);
      return true;
    }
 else {
      return false;
    }
  }
 else {
    return false;
  }
}"
56286,"@Override public final int getDebugColorAt(int x,int y){
  int value=partitionsGrid.getRealPartitionIdAt(x,y);
  return Color.getABGR((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
}","@Override public final int getDebugColorAt(int x,int y){
  return flagsGrid.isMarked(x,y) ? Color.ORANGE.getARGB() : (objectsGrid.getMapObjectAt(x,y,EMapObjectType.INFORMABLE_MAP_OBJECT) != null ? Color.GREEN.getARGB() : (objectsGrid.getMapObjectAt(x,y,EMapObjectType.ATTACKABLE_TOWER) != null ? Color.RED.getARGB() : (flagsGrid.isBlocked(x,y) ? Color.BLACK.getARGB() : (flagsGrid.isProtected(x,y) ? Color.BLUE.getARGB() : 0))));
}"
56287,"public void setBuildingArea(FreeMapArea area,Building buildingValue){
  for (  ShortPoint2D curr : area) {
    buildingsGrid[curr.x + curr.y * width]=buildingValue;
  }
}","public void setBuildingArea(FreeMapArea area,Building building){
  for (  ShortPoint2D curr : area) {
    buildingsGrid[curr.x + curr.y * width]=building;
  }
}"
56288,"@Test public void testPushAndPop(){
  assertEquals(0,list.size());
  for (int i=0; i < TEST_NUMBERS; i++) {
    list.pushFront(i);
    assertEquals(i + 1,list.size());
  }
  for (int i=TEST_NUMBERS - 1; i >= 0; i--) {
    assertEquals(i + 1,list.size());
    assertEquals(i,list.popFront());
  }
  assertEquals(0,list.size());
}","@Test public void testPushAndPop(){
  assertEquals(0,list.size());
  for (int i=0; i < TEST_NUMBERS; i++) {
    list.pushFront(i);
    assertEquals(i + 1,list.size());
  }
  for (int i=TEST_NUMBERS - 1; i >= 0; i--) {
    assertEquals(i + 1,list.size());
    assertEquals(i,list.popFront().value);
  }
  assertEquals(0,list.size());
}"
56289,"private void assertListsEqual(DoubleLinkedIntList copy){
  assertEquals(list.size(),copy.size());
  while (!list.isEmpty()) {
    assertEquals(list.popFront(),copy.popFront());
  }
}","private void assertListsEqual(DoubleLinkedIntList copy){
  assertEquals(list.size(),copy.size());
  while (!list.isEmpty()) {
    assertEquals(list.popFront().value,copy.popFront().value);
  }
}"
56290,"@Test public void testRemoveByHandle(){
  DoubleLinkedIntListItem handles[]=new DoubleLinkedIntListItem[TEST_NUMBERS];
  for (int i=0; i < TEST_NUMBERS; i++) {
    handles[i]=list.pushFront(i);
  }
  list.remove(handles[4]);
  list.remove(handles[7]);
  assertEquals(TEST_NUMBERS - 2,list.size());
  for (int i=TEST_NUMBERS - 1; i >= 0; i--) {
    if (i == 4 || i == 7) {
      continue;
    }
    assertEquals(i,list.popFront());
  }
  assertEquals(0,list.size());
}","@Test public void testRemoveByHandle(){
  DoubleLinkedIntListItem handles[]=new DoubleLinkedIntListItem[TEST_NUMBERS];
  for (int i=0; i < TEST_NUMBERS; i++) {
    handles[i]=list.pushFront(i);
  }
  list.remove(handles[4]);
  list.remove(handles[7]);
  assertEquals(TEST_NUMBERS - 2,list.size());
  for (int i=TEST_NUMBERS - 1; i >= 0; i--) {
    if (i == 4 || i == 7) {
      continue;
    }
    assertEquals(i,list.popFront().value);
  }
  assertEquals(0,list.size());
}"
56291,"private final void initStartNode(short sx,short sy,short tx,short ty){
  int flatIdx=getFlatIdx(sx,sy);
  open.insert(flatIdx);
  openList.set(flatIdx);
  depthParentHeap[getDepthIdx(flatIdx)]=0;
  depthParentHeap[getParentIdx(flatIdx)]=-1;
  costsAndHeuristics[getCostsIdx(flatIdx)]=0;
  costsAndHeuristics[getHeuristicIdx(flatIdx)]=getHeuristicCost(sx,sy,tx,ty);
}","private final void initStartNode(short sx,short sy,short tx,short ty){
  int flatIdx=getFlatIdx(sx,sy);
  depthParentHeap[getDepthIdx(flatIdx)]=0;
  depthParentHeap[getParentIdx(flatIdx)]=-1;
  costsAndHeuristics[getCostsIdx(flatIdx)]=0;
  costsAndHeuristics[getHeuristicIdx(flatIdx)]=getHeuristicCost(sx,sy,tx,ty);
  open.insert(flatIdx);
  openList.set(flatIdx);
}"
56292,"public DoubleLinkedIntListItem pushFront(int value){
  DoubleLinkedIntListItem newItem=new DoubleLinkedIntListItem(value);
  newItem.next=head.next;
  newItem.prev=head;
  newItem.next.prev=newItem;
  head.next=newItem;
  size++;
  return newItem;
}","public void pushFront(DoubleLinkedIntListItem newItem){
  newItem.next=head.next;
  newItem.prev=head;
  newItem.next.prev=newItem;
  head.next=newItem;
  size++;
}"
56293,"public int popFront(){
  final DoubleLinkedIntListItem item=head.next;
  item.next.prev=head;
  head.next=item.next;
  size--;
  return item.value;
}","public DoubleLinkedIntListItem popFront(){
  final DoubleLinkedIntListItem item=head.next;
  item.next.prev=head;
  head.next=item.next;
  item.next=null;
  item.prev=null;
  size--;
  return item;
}"
56294,"public MinBucketQueue(IRankSupplier rankSupplier,int maxNumberOfIds){
  this.rankSupplier=rankSupplier;
  this.buckets=new DoubleLinkedIntList[NUMBER_OF_BUCKETS];
  for (int i=0; i < NUMBER_OF_BUCKETS; i++) {
    this.buckets[i]=new DoubleLinkedIntList();
  }
  this.handles=new DoubleLinkedIntListItem[maxNumberOfIds];
}","public MinBucketQueue(IRankSupplier rankSupplier,int maxNumberOfIds){
  this.rankSupplier=rankSupplier;
  this.buckets=new DoubleLinkedIntList[NUMBER_OF_BUCKETS];
  for (int i=0; i < NUMBER_OF_BUCKETS; i++) {
    this.buckets[i]=new DoubleLinkedIntList();
  }
  this.handles=new DoubleLinkedIntListItem[maxNumberOfIds];
  for (int i=0; i < maxNumberOfIds; i++) {
    handles[i]=new DoubleLinkedIntListItem(i);
  }
}"
56295,"@Override public void insert(int elementId){
  final DoubleLinkedIntListItem handle=buckets[getRankIdx(elementId)].pushFront(elementId);
  handles[elementId]=handle;
  size++;
}","@Override public void insert(int elementId){
  buckets[getRankIdx(elementId)].pushFront(handles[elementId]);
  size++;
}"
56296,"@Override public int deleteMin(){
  while (buckets[minIdx].isEmpty()) {
    minIdx=(minIdx + 1) & MODULO_MASK;
  }
  size--;
  final int elementId=buckets[minIdx].popFront();
  return elementId;
}","@Override public int deleteMin(){
  while (buckets[minIdx].isEmpty()) {
    minIdx=(minIdx + 1) & MODULO_MASK;
  }
  size--;
  final int elementId=buckets[minIdx].popFront().value;
  return elementId;
}"
56297,"private final void initPathfinders(){
  pathfinderGrid=new PathfinderGrid();
  aStar=new HexAStar(pathfinderGrid,width,height);
  dijkstra=new DijkstraAlgorithm(pathfinderGrid,aStar,width,height);
  inAreaFinder=new InAreaFinder(pathfinderGrid,width,height);
}","private final void initPathfinders(){
  pathfinderGrid=new PathfinderGrid();
  aStar=new BucketQueueAStar(pathfinderGrid,width,height);
  dijkstra=new DijkstraAlgorithm(pathfinderGrid,aStar,width,height);
  inAreaFinder=new InAreaFinder(pathfinderGrid,width,height);
}"
56298,"/** 
 * @param args args can have no entries or <br> args[0] must be ""host"" or ""client""
 * @throws FileNotFoundException
 * @throws IOException
 * @throws ClassNotFoundException
 */
public static void main(String[] args){
  ResourceManager.setProvider(new SwingResourceProvider());
  ManagedJSettlers game=new ManagedJSettlers();
  game.start(getGui());
  ImageProvider.getInstance().startPreloading();
}","/** 
 * @param args args can have no entries or <br> args[0] must be ""host"" or ""client""
 * @throws FileNotFoundException
 * @throws IOException
 * @throws ClassNotFoundException
 */
public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException {
  ResourceManager.setProvider(new SwingResourceProvider());
  ManagedJSettlers game=new ManagedJSettlers();
  game.start(getGui());
  ImageProvider.getInstance().startPreloading();
}"
56299,"@Override public Action replaceAction(Action action){
  if (action.getActionType() == EActionType.SELECT_POINT) {
    return new MoveToAction(((SelectAction)action).getPosition());
  }
  return super.replaceAction(action);
}","@Override public Action replaceAction(Action action){
  if (action.getActionType() == EActionType.SELECT_POINT) {
    return new PointAction(EActionType.MOVE_TO,((PointAction)action).getPosition());
  }
  return super.replaceAction(action);
}"
56300,"@Override public Action replaceAction(Action action){
  if (action.getActionType() == EActionType.SELECT_POINT) {
    return new SelectAction(((SelectAction)action).getPosition(),EActionType.SET_WORK_AREA);
  }
  return super.replaceAction(action);
}","@Override public Action replaceAction(Action action){
  if (action.getActionType() == EActionType.SELECT_POINT) {
    return new PointAction(EActionType.SET_WORK_AREA,((PointAction)action).getPosition());
  }
  return super.replaceAction(action);
}"
56301,"@SuppressWarnings(""String_Node_Str"") private void visualizeAlgoResult(final IBlockingProvider blockingProvider,final PartitionCalculatorAlgorithm algo){
  TestWindow.openTestWindow(new GraphicsGridAdapter(WIDTH,HEIGHT){
    @Override public int getDebugColorAt(    int x,    int y){
      int value;
      value=algo.getPartitionAt(x,y) + 1;
      return blockingProvider.isBlocked(x,y) ? Color.BLACK.getABGR() : Color.getARGB((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
    }
  }
);
  try {
    Thread.sleep(60000);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}","@SuppressWarnings(""String_Node_Str"") private void visualizeAlgoResult(final IBlockingProvider blockingProvider,final PartitionCalculatorAlgorithm algo){
  TestWindow.openTestWindow(new GraphicsGridAdapter(WIDTH,HEIGHT){
    @Override public int getDebugColorAt(    int x,    int y){
      int value;
      value=algo.getPartitionAt(x,y) + 1;
      boolean isBlocked=false;
      return isBlocked ? Color.BLACK.getABGR() : Color.getARGB((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
    }
  }
);
  try {
    Thread.sleep(60000);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
}"
56302,"@Override public int getDebugColorAt(int x,int y){
  int value;
  value=algo.getPartitionAt(x,y) + 1;
  return blockingProvider.isBlocked(x,y) ? Color.BLACK.getABGR() : Color.getARGB((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
}","@Override public int getDebugColorAt(int x,int y){
  int value;
  value=algo.getPartitionAt(x,y) + 1;
  boolean isBlocked=false;
  return isBlocked ? Color.BLACK.getABGR() : Color.getARGB((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
}"
56303,"@Test public void testMergeAndRepresentatives(){
  short partition1=grid.createNewPartition((byte)1);
  short partition2=grid.createNewPartition((byte)1);
  short partition3=grid.createNewPartition((byte)1);
  short partition4=grid.createNewPartition((byte)1);
  short partition5=grid.createNewPartition((byte)1);
  grid.mergePartitions(partition1,partition2);
  grid.mergePartitions(partition3,partition4);
  grid.mergePartitions(partition1,partition4);
  grid.mergePartitions(partition4,partition5);
  for (int i=1; i < 5; i++) {
    assertEquals(grid.partitionRepresentative[i],grid.partitionRepresentative[i + 1]);
  }
}","@Test public void testMergeAndRepresentatives(){
  short partitions[]=new short[]{grid.createNewPartition((byte)1),grid.createNewPartition((byte)1),grid.createNewPartition((byte)1),grid.createNewPartition((byte)1),grid.createNewPartition((byte)1)};
  grid.mergePartitions(partitions[0],partitions[1]);
  grid.mergePartitions(partitions[2],partitions[3]);
  grid.mergePartitions(partitions[0],partitions[3]);
  grid.mergePartitions(partitions[3],partitions[4]);
  for (int i=0; i < partitions.length - 1; i++) {
    assertEquals(grid.partitionRepresentative[partitions[i]],grid.partitionRepresentative[partitions[i + 1]]);
  }
}"
56304,"private void startTest(){
  addTower(0,50,100,40);
  addTower(0,150,100,40);
  addTower(0,100,100,40);
  addTower(1,75,55,44);
  addTower(1,125,150,44);
  removeTower(100,100);
}","private void startTest(){
  addTower(0,82,120,40);
  addTower(0,75,85,40);
  addTower(0,125,105,40);
  addTower(0,94,71,40);
  changePlayerOfTower(82,120,1);
  changePlayerOfTower(75,85,1);
  changePlayerOfTower(125,105,1);
  changePlayerOfTower(94,71,1);
}"
56305,"@Override public byte getPlayerIdAt(int x,int y){
  return 0;
}","@Override public byte getPlayerIdAt(int x,int y){
  return grid.getPlayerIdAt(x,y);
}"
56306,"private void removeTower(int x,int y){
  grid.removeTowerAndFreeOccupiedArea(new ShortPoint2D(x,y));
}","private void removeTower(int x,int y){
  blockArea(getTowerBlockArea(x,y),false);
  grid.removeTowerAndFreeOccupiedArea(new ShortPoint2D(x,y));
}"
56307,"private PartitionsGridTestingWnd(){
  this.grid=new PartitionsGrid(WIDTH,HEIGHT,(byte)10,IPartitionsGridBlockingProvider.DEFAULT_IMPLEMENTATION);
}","private PartitionsGridTestingWnd(){
  this.grid=new PartitionsGrid(WIDTH,HEIGHT,(byte)10,new IPartitionsGridBlockingProvider(){
    @Override public boolean isBlocked(    int x,    int y){
      return blockedGrid.get(x + y * WIDTH);
    }
    @Override public void registerListener(    IBlockingChangedListener listener){
    }
  }
);
}"
56308,"@Override public boolean isBorder(int x,int y){
  return false;
}","@Override public boolean isBorder(int x,int y){
  byte playerAtPos=getPlayerIdAt(x,y);
  for (  EDirection dir : EDirection.values) {
    int currX=x + dir.gridDeltaX;
    int currY=y + dir.gridDeltaY;
    if (currX >= 0 && currY >= 0 && currX < WIDTH && currY < HEIGHT && playerAtPos != getPlayerIdAt(currX,currY)) {
      return true;
    }
  }
  return false;
}"
56309,"private void addTower(int playerId,int x,int y,int radius){
  grid.addTowerAndOccupyArea((byte)playerId,new MapCircle(new ShortPoint2D(x,y),radius));
}","private void addTower(int playerId,int x,int y,int radius){
  blockArea(getTowerBlockArea(x,y),true);
  grid.addTowerAndOccupyArea((byte)playerId,new MapCircle(new ShortPoint2D(x,y),radius));
}"
56310,"private IGraphicsGrid getGraphicsGrid(){
  return new IGraphicsGrid(){
    @Override public void setBackgroundListener(    IGraphicsBackgroundListener backgroundListener){
    }
    @Override public int nextDrawableX(    int x,    int y,    int maxX){
      return x + 1;
    }
    @Override public boolean isFogOfWarVisible(    int x,    int y){
      return true;
    }
    @Override public boolean isBorder(    int x,    int y){
      return false;
    }
    @Override public short getWidth(){
      return WIDTH;
    }
    @Override public byte getVisibleStatus(    int x,    int y){
      return CommonConstants.FOG_OF_WAR_VISIBLE;
    }
    @Override public byte getPlayerIdAt(    int x,    int y){
      return 0;
    }
    @Override public IMovable getMovableAt(    int x,    int y){
      return null;
    }
    @Override public IMapObject getMapObjectsAt(    int x,    int y){
      return null;
    }
    @Override public ELandscapeType getLandscapeTypeAt(    int x,    int y){
      return ELandscapeType.GRASS;
    }
    @Override public byte getHeightAt(    int x,    int y){
      return 0;
    }
    @Override public short getHeight(){
      return HEIGHT;
    }
    @Override public int getDebugColorAt(    int x,    int y){
      int value=grid.getPartitionIdAt(x,y);
      return Color.getARGB((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
    }
  }
;
}","private IGraphicsGrid getGraphicsGrid(){
  return new IGraphicsGrid(){
    @Override public void setBackgroundListener(    IGraphicsBackgroundListener backgroundListener){
    }
    @Override public int nextDrawableX(    int x,    int y,    int maxX){
      return x + 1;
    }
    @Override public boolean isFogOfWarVisible(    int x,    int y){
      return true;
    }
    @Override public boolean isBorder(    int x,    int y){
      byte playerAtPos=getPlayerIdAt(x,y);
      for (      EDirection dir : EDirection.values) {
        int currX=x + dir.gridDeltaX;
        int currY=y + dir.gridDeltaY;
        if (currX >= 0 && currY >= 0 && currX < WIDTH && currY < HEIGHT && playerAtPos != getPlayerIdAt(currX,currY)) {
          return true;
        }
      }
      return false;
    }
    @Override public short getWidth(){
      return WIDTH;
    }
    @Override public byte getVisibleStatus(    int x,    int y){
      return CommonConstants.FOG_OF_WAR_VISIBLE;
    }
    @Override public byte getPlayerIdAt(    int x,    int y){
      return grid.getPlayerIdAt(x,y);
    }
    @Override public IMovable getMovableAt(    int x,    int y){
      return null;
    }
    @Override public IMapObject getMapObjectsAt(    int x,    int y){
      return null;
    }
    @Override public ELandscapeType getLandscapeTypeAt(    int x,    int y){
      return ELandscapeType.GRASS;
    }
    @Override public byte getHeightAt(    int x,    int y){
      return 0;
    }
    @Override public short getHeight(){
      return HEIGHT;
    }
    @Override public int getDebugColorAt(    int x,    int y){
      int value=grid.getTowerCountAt(x,y);
      return Color.getARGB((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
    }
  }
;
}"
56311,"@Override public int getDebugColorAt(int x,int y){
  int value=grid.getPartitionIdAt(x,y);
  return Color.getARGB((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
}","@Override public int getDebugColorAt(int x,int y){
  int value=grid.getTowerCountAt(x,y);
  return Color.getARGB((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
}"
56312,"private void calculateBlockedPartitions(){
  MilliStopWatch watch=new MilliStopWatch();
  BitSet notBlockedSet=new BitSet(width * height);
  for (short y=0; y < height; y++) {
    for (short x=0; x < width; x++) {
      notBlockedSet.set(x + width * y,!landscapes[x][y].isBlocking);
    }
  }
  PartitionCalculatorAlgorithm partitionCalculator=new PartitionCalculatorAlgorithm(0,0,width,height,notBlockedSet,IBlockingProvider.DEFAULT_PROVIDER);
  partitionCalculator.calculatePartitions();
  for (short y=0; y < height; y++) {
    for (short x=0; x < width; x++) {
      blockedPartitions[x][y]=partitionCalculator.getPartitionAt(x,y);
    }
  }
  watch.stop(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + partitionCalculator.getNumberOfPartitions() + ""String_Node_Str"");
}","private void calculateBlockedPartitions(){
  MilliStopWatch watch=new MilliStopWatch();
  BitSet notBlockedSet=new BitSet(width * height);
  for (short y=0; y < height; y++) {
    for (short x=0; x < width; x++) {
      notBlockedSet.set(x + width * y,!landscapes[x][y].isBlocking);
    }
  }
  PartitionCalculatorAlgorithm partitionCalculator=new PartitionCalculatorAlgorithm(0,0,width,height,notBlockedSet,IBlockingProvider.DEFAULT_IMPLEMENTATION);
  partitionCalculator.calculatePartitions();
  for (short y=0; y < height; y++) {
    for (short x=0; x < width; x++) {
      blockedPartitions[x][y]=partitionCalculator.getPartitionAt(x,y);
    }
  }
  watch.stop(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + partitionCalculator.getNumberOfPartitions() + ""String_Node_Str"");
}"
56313,"private void placeAdditionalMapObjects(IBuildingsGrid grid,ShortPoint2D pos,boolean place){
  if (place) {
    grid.getMapObjectsManager().addSimpleMapObject(pos,EMapObjectType.BUILDINGSITE_SIGN,false,null);
  }
 else {
    grid.getMapObjectsManager().removeMapObjectType(pos.x,pos.y,EMapObjectType.BUILDINGSITE_SIGN);
  }
  for (  RelativePoint curr : type.getBuildmarks()) {
    if (place) {
      grid.getMapObjectsManager().addSimpleMapObject(curr.calculatePoint(pos),EMapObjectType.BUILDINGSITE_POST,false,null);
    }
 else {
      ShortPoint2D postPos=curr.calculatePoint(pos);
      grid.getMapObjectsManager().removeMapObjectType(postPos.x,postPos.y,EMapObjectType.BUILDINGSITE_POST);
    }
  }
}","protected void placeAdditionalMapObjects(IBuildingsGrid grid,ShortPoint2D pos,boolean place){
  if (place) {
    grid.getMapObjectsManager().addSimpleMapObject(pos,EMapObjectType.BUILDINGSITE_SIGN,false,null);
  }
 else {
    grid.getMapObjectsManager().removeMapObjectType(pos.x,pos.y,EMapObjectType.BUILDINGSITE_SIGN);
  }
  for (  RelativePoint curr : type.getBuildmarks()) {
    if (place) {
      grid.getMapObjectsManager().addSimpleMapObject(curr.calculatePoint(pos),EMapObjectType.BUILDINGSITE_POST,false,null);
    }
 else {
      ShortPoint2D postPos=curr.calculatePoint(pos);
      grid.getMapObjectsManager().removeMapObjectType(postPos.x,postPos.y,EMapObjectType.BUILDINGSITE_POST);
    }
  }
}"
56314,"@Override public final int getDebugColorAt(int x,int y){
  int value=partitionsGrid.getPartitionIdAt(x,y) + 1;
  return Color.getARGB((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
}","@Override public final int getDebugColorAt(int x,int y){
  return flagsGrid.isMarked(x,y) ? Color.ORANGE.getARGB() : (objectsGrid.getMapObjectAt(x,y,EMapObjectType.INFORMABLE_MAP_OBJECT) != null ? Color.GREEN.getARGB() : (objectsGrid.getMapObjectAt(x,y,EMapObjectType.ATTACKABLE_TOWER) != null ? Color.RED.getARGB() : (flagsGrid.isBlocked(x,y) ? Color.BLACK.getARGB() : (flagsGrid.isProtected(x,y) ? Color.BLUE.getARGB() : 0))));
}"
56315,"@Override public void timerEvent(){
  if (health <= 0) {
    return;
  }
switch (state) {
case SLEEPING:
    return;
case DOING_NOTHING:
  if (visible && enableNothingToDo) {
    doingNothingAction();
  }
break;
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
progressCurrentAction();
break;
case PATHING:
pathingAction();
break;
default :
break;
}
if (moveToRequest != null) {
switch (state) {
case PATHING:
if (progress < 1) {
break;
}
setState(ENewMovableState.DOING_NOTHING);
case DOING_NOTHING:
ShortPoint2D oldTargetPos;
if (path != null) {
oldTargetPos=path.getTargetPos();
}
 else {
oldTargetPos=null;
}
goToPos(moveToRequest);
moveToRequest=null;
if (path != null) {
this.strategy.moveToPathSet(oldTargetPos,path.getTargetPos());
}
break;
default :
break;
}
}
if (state == ENewMovableState.DOING_NOTHING) {
strategy.action();
}
}","@Override public void timerEvent(){
  if (health <= 0) {
    return;
  }
switch (state) {
case SLEEPING:
    return;
case DOING_NOTHING:
  if (visible && enableNothingToDo) {
    doingNothingAction();
  }
break;
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
progressCurrentAction();
break;
case PATHING:
pathingAction();
break;
default :
break;
}
if (moveToRequest != null) {
switch (state) {
case PATHING:
if (progress < 1) {
break;
}
setState(ENewMovableState.DOING_NOTHING);
case DOING_NOTHING:
ShortPoint2D targetPos=path != null ? path.getTargetPos() : null;
ShortPoint2D oldPos=position;
boolean foundPath=goToPos(moveToRequest);
moveToRequest=null;
if (foundPath) {
this.strategy.moveToPathSet(oldPos,targetPos,path.getTargetPos());
}
break;
default :
break;
}
}
if (state == ENewMovableState.DOING_NOTHING) {
strategy.action();
}
}"
56316,"protected void moveToPathSet(@SuppressWarnings(""String_Node_Str"") ShortPoint2D oldTargetPos,@SuppressWarnings(""String_Node_Str"") ShortPoint2D targetPos){
}","/** 
 * @param oldPosition The position the movable was positioned before the new path has been calculated and the first step on the new path has been done.
 * @param oldTargetPos The target position of the old path or null if no old path was set.
 * @param targetPos The new target position.
 */
protected void moveToPathSet(@SuppressWarnings(""String_Node_Str"") ShortPoint2D oldPosition,@SuppressWarnings(""String_Node_Str"") ShortPoint2D oldTargetPos,@SuppressWarnings(""String_Node_Str"") ShortPoint2D targetPos){
}"
56317,"@Override protected void moveToPathSet(ShortPoint2D oldTargetPos,ShortPoint2D targetPos){
  if (targetPos != null && this.oldPathTarget != null) {
    oldPathTarget=null;
    inSaveGotoMode=false;
  }
}","@Override protected void moveToPathSet(ShortPoint2D oldPosition,ShortPoint2D oldTargetPos,ShortPoint2D targetPos){
  if (targetPos != null && this.oldPathTarget != null) {
    oldPathTarget=null;
    inSaveGotoMode=false;
  }
}"
56318,"@Override protected void moveToPathSet(ShortPoint2D oldTargetPos,ShortPoint2D targetPos){
  this.state=EPioneerState.GOING_TO_POS;
  centerPos=null;
  super.getStrategyGrid().setMarked(super.getPos(),false);
  if (oldTargetPos != null) {
    super.getStrategyGrid().setMarked(oldTargetPos,false);
  }
}","@Override protected void moveToPathSet(ShortPoint2D oldPosition,ShortPoint2D oldTargetPos,ShortPoint2D targetPos){
  this.state=EPioneerState.GOING_TO_POS;
  centerPos=null;
  super.getStrategyGrid().setMarked(oldPosition,false);
  if (oldTargetPos != null) {
    super.getStrategyGrid().setMarked(oldTargetPos,false);
  }
}"
56319,"@Override protected void moveToPathSet(ShortPoint2D oldTargetPos,ShortPoint2D targetPos){
  this.state=EPioneerState.GOING_TO_POS;
  centerPos=null;
}","@Override protected void moveToPathSet(ShortPoint2D oldPosition,ShortPoint2D oldTargetPos,ShortPoint2D targetPos){
  this.state=EPioneerState.GOING_TO_POS;
  centerPos=null;
}"
56320,"@Override public void occupyAreaByTower(Player player,MapCircle influencingArea){
  partitionsGrid.addTowerAndOccupyArea(player.playerId,influencingArea);
  bordersThread.checkPositions(influencingArea);
  landmarksCorrection.addLandmarkedPositions(influencingArea);
}","@Override public void occupyAreaByTower(Player player,MapCircle influencingArea){
  partitionsGrid.addTowerAndOccupyArea(player.playerId,influencingArea);
  checkAllPositionsForEnclosedBlockedAreas(influencingArea);
}"
56321,"@Override public final short getPartitionAt(short x,short y){
  return partitionsGrid.getPartitionIdAt(x,y);
}","@Override public final short getPartitionAt(int x,int y){
  return partitionsGrid.getPartitionIdAt(x,y);
}"
56322,"@Override public void freeAreaOccupiedByTower(ShortPoint2D towerPosition){
  Iterable<ShortPoint2D> changedPositions=partitionsGrid.removeTowerAndFreeOccupiedArea(towerPosition);
  bordersThread.checkPositions(changedPositions);
  landmarksCorrection.addLandmarkedPositions(changedPositions);
}","@Override public void freeAreaOccupiedByTower(ShortPoint2D towerPosition){
  Iterable<ShortPoint2D> positions=partitionsGrid.removeTowerAndFreeOccupiedArea(towerPosition);
  checkAllPositionsForEnclosedBlockedAreas(positions);
}"
56323,"@Override public void changePlayerAt(ShortPoint2D position,Player player){
  partitionsGrid.changePlayerAt(position,player.playerId);
  bordersThread.checkPosition(position);
  landmarksCorrection.addLandmarkedPosition(position);
}","@Override public void changePlayerAt(ShortPoint2D position,Player player){
  partitionsGrid.changePlayerAt(position,player.playerId);
  bordersThread.checkPosition(position);
  checkForEnclosedBlockedArea(position);
}"
56324,"@Override public final boolean setBuilding(ShortPoint2D position,Building newBuilding){
  if (MainGrid.this.isInBounds(position.x,position.y)) {
    FreeMapArea area=new FreeMapArea(position,newBuilding.getBuildingType().getProtectedTiles());
    if (canConstructAt(area)) {
      setProtectedState(area,true);
      mapObjectsManager.addBuildingTo(position,newBuilding);
      objectsGrid.setBuildingArea(area,newBuilding);
      return true;
    }
 else {
      return false;
    }
  }
 else {
    return false;
  }
}","@Override public final boolean setBuilding(ShortPoint2D position,Building newBuilding){
  if (MainGrid.this.isInBounds(position.x,position.y)) {
    FreeMapArea area=new FreeMapArea(position,newBuilding.getBuildingType().getBlockedTiles());
    if (canConstructAt(area)) {
      setProtectedState(area,true);
      mapObjectsManager.addBuildingTo(position,newBuilding);
      objectsGrid.setBuildingArea(area,newBuilding);
      return true;
    }
 else {
      return false;
    }
  }
 else {
    return false;
  }
}"
56325,"public void startThreads(){
  bordersThread.start();
  fogOfWar.start(new FogOfWarGrid());
  landmarksCorrection.start();
  partitionsGrid.startThreads();
}","public void startThreads(){
  bordersThread.start();
  fogOfWar.start(new FogOfWarGrid());
  partitionsGrid.startThreads();
}"
56326,"public void stopThreads(){
  bordersThread.cancel();
  fogOfWar.cancel();
  landmarksCorrection.cancel();
  partitionsGrid.cancelThreads();
}","public void stopThreads(){
  bordersThread.cancel();
  fogOfWar.cancel();
  partitionsGrid.cancelThreads();
}"
56327,"@Override public void changePlayerOfTower(ShortPoint2D towerPosition,Player newPlayer,FreeMapArea groundArea){
  Iterable<ShortPoint2D> changedPositions=partitionsGrid.changePlayerOfTower(towerPosition,newPlayer.playerId,groundArea);
  bordersThread.checkPositions(changedPositions);
  landmarksCorrection.addLandmarkedPositions(changedPositions);
}","@Override public void changePlayerOfTower(ShortPoint2D towerPosition,Player newPlayer,FreeMapArea groundArea){
  Iterable<ShortPoint2D> positions=partitionsGrid.changePlayerOfTower(towerPosition,newPlayer.playerId,groundArea);
  checkAllPositionsForEnclosedBlockedAreas(positions);
}"
56328,"@Override public final int getDebugColorAt(int x,int y){
  int value=partitionsGrid.getTowerCountAt(x,y) + 1;
  return Color.getABGR((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
}","@Override public final int getDebugColorAt(int x,int y){
  int value=partitionsGrid.getRealPartitionIdAt(x,y);
  return Color.getABGR((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
}"
56329,"@Override public final void setDebugColor(final short x,final short y,Color color){
  landscapeGrid.setDebugColor(x,y,color.getARGB());
}","@Override public void setDebugColor(short x,short y,Color color){
  landscapeGrid.setDebugColor(x,y,color.getARGB());
}"
56330,"public FlagsGrid(final short width,final short height){
  this.width=width;
  this.blockedGrid=new BitSet(width * height);
  this.protectedGrid=new BitSet(width * height);
  this.markedGrid=new BitSet(width * height);
  this.bordersGrid=new BitSet(width * height);
}","public FlagsGrid(final short width,final short height){
  this.width=width;
  this.blockedGrid=new BitSet(width * height);
  this.protectedGrid=new BitSet(width * height);
  this.markedGrid=new BitSet(width * height);
  this.bordersGrid=new BitSet(width * height);
  initAdditional();
}"
56331,"public Building getBuildingOn(short x,short y){
  return buildingsGrid[x + y * width];
}","public Building getBuildingOn(int x,int y){
  return buildingsGrid[x + y * width];
}"
56332,"@Override public boolean contains(int x,int y){
  return grid.partitionRepresentative[grid.partitions[x + y * width]] == partition;
}","@Override public boolean contains(int x,int y){
  return grid.partitionRepresentatives[grid.partitions[x + y * width]] == partition;
}"
56333,"/** 
 * Tests if the given positions (that need to lie on the border of the given partition) are connected by the given partition.
 * @param pos1 The first position.
 * @param pos2 The second position.
 * @param partition The partition of both positions.
 * @return true if both positions are connected by the given partition.<br>false if the positions are not connected.
 */
public static boolean isPartitionNotDivided(final PartitionsGrid grid,final ShortPoint2D pos1,final ShortPoint2D pos2,final short partition){
  final short width=grid.width;
  final short pos2X=pos2.x;
  final short pos2Y=pos2.y;
  boolean pos2NotOnBorder=BorderTraversingAlgorithm.traverseBorder(new IContainingProvider(){
    @Override public boolean contains(    int x,    int y){
      return grid.partitionRepresentative[grid.partitions[x + y * width]] == partition;
    }
  }
,pos1,new ITraversingVisitor(){
    @Override public boolean visit(    int x,    int y){
      return pos2X != x || pos2Y != y;
    }
  }
,false);
  return !pos2NotOnBorder;
}","/** 
 * Tests if the given positions (that need to lie on the border of the given partition) are connected by the given partition.
 * @param pos1 The first position.
 * @param pos2 The second position.
 * @param partition The partition of both positions.
 * @return true if both positions are connected by the given partition.<br>false if the positions are not connected.
 */
public static boolean isPartitionNotDivided(final PartitionsGrid grid,final ShortPoint2D pos1,final ShortPoint2D pos2,final short partition){
  final short width=grid.width;
  final short pos2X=pos2.x;
  final short pos2Y=pos2.y;
  boolean pos2NotOnBorder=BorderTraversingAlgorithm.traverseBorder(new IContainingProvider(){
    @Override public boolean contains(    int x,    int y){
      return grid.partitionRepresentatives[grid.partitions[x + y * width]] == partition;
    }
  }
,pos1,new ITraversingVisitor(){
    @Override public boolean visit(    int x,    int y){
      return pos2X != x || pos2Y != y;
    }
  }
,false);
  return !pos2NotOnBorder;
}"
56334,"public static void main(String args[]){
  JOGLPanel content=new JOGLPanel(new SoundPlayer(){
    @Override public void playSound(    int sound,    float lvolume,    float rvolume){
    }
    @Override public void setSoundDataRetriever(    ISoundDataRetriever soundDataRetriever){
    }
  }
);
  ResourceManager.setProvider(new SwingResourceProvider());
  map=new Map();
  MapInterfaceConnector connector=content.showGameMap(map,null);
  connector.addListener(new IMapInterfaceListener(){
    @Override public void action(    Action action){
      if (action.getActionType() == EActionType.SELECT_POINT) {
        System.out.println(""String_Node_Str"" + ((SelectAction)action).getPosition());
      }
    }
  }
);
  JFrame jsettlersWnd=new JFrame(""String_Node_Str"");
  AreaContainer panel=new AreaContainer(content.getArea());
  panel.setPreferredSize(new Dimension(640,480));
  jsettlersWnd.add(panel);
  panel.requestFocusInWindow();
  jsettlersWnd.pack();
  jsettlersWnd.setSize(1200,800);
  jsettlersWnd.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  jsettlersWnd.setVisible(true);
  jsettlersWnd.setLocationRelativeTo(null);
  thread=new LandmarksCorrectingThread(map);
  test1();
  test2();
}","public static void main(String args[]){
  JOGLPanel content=new JOGLPanel(new SoundPlayer(){
    @Override public void playSound(    int sound,    float lvolume,    float rvolume){
    }
    @Override public void setSoundDataRetriever(    ISoundDataRetriever soundDataRetriever){
    }
  }
);
  ResourceManager.setProvider(new SwingResourceProvider());
  map=new Map();
  MapInterfaceConnector connector=content.showGameMap(map,null);
  connector.addListener(new IMapInterfaceListener(){
    @Override public void action(    Action action){
      if (action.getActionType() == EActionType.SELECT_POINT) {
        System.out.println(""String_Node_Str"" + ((PointAction)action).getPosition());
      }
    }
  }
);
  JFrame jsettlersWnd=new JFrame(""String_Node_Str"");
  AreaContainer panel=new AreaContainer(content.getArea());
  panel.setPreferredSize(new Dimension(640,480));
  jsettlersWnd.add(panel);
  panel.requestFocusInWindow();
  jsettlersWnd.pack();
  jsettlersWnd.setSize(1200,800);
  jsettlersWnd.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  jsettlersWnd.setVisible(true);
  jsettlersWnd.setLocationRelativeTo(null);
  thread=new LandmarksCorrectingThread(map);
  test1();
  test2();
}"
56335,"@Override public void action(Action action){
  if (action.getActionType() == EActionType.SELECT_POINT) {
    System.out.println(""String_Node_Str"" + ((SelectAction)action).getPosition());
  }
}","@Override public void action(Action action){
  if (action.getActionType() == EActionType.SELECT_POINT) {
    System.out.println(""String_Node_Str"" + ((PointAction)action).getPosition());
  }
}"
56336,"@Override public void action(Action action){
switch (action.getActionType()) {
case MOVE_TO:
    movable.moveTo(((MoveToAction)action).getPosition());
  break;
case SPEED_FASTER:
NetworkTimer.multiplyGameSpeed(1.2f);
break;
case SPEED_SLOWER:
NetworkTimer.multiplyGameSpeed(1 / 1.2f);
break;
case FAST_FORWARD:
NetworkTimer.get().fastForward();
break;
default :
break;
}
}","@Override public void action(Action action){
switch (action.getActionType()) {
case MOVE_TO:
    movable.moveTo(((PointAction)action).getPosition());
  break;
case SPEED_FASTER:
NetworkTimer.multiplyGameSpeed(1.2f);
break;
case SPEED_SLOWER:
NetworkTimer.multiplyGameSpeed(1 / 1.2f);
break;
case FAST_FORWARD:
NetworkTimer.get().fastForward();
break;
default :
break;
}
}"
56337,"private MovableTestWindow() throws InterruptedException {
  NetworkTimer.get().schedule();
  RandomSingleton.load(1000);
  MovableTestsMap grid=new MovableTestsMap(100,100);
  MapInterfaceConnector connector=TestWindow.openTestWindow(grid);
  movable=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(49,50),PLAYER_0);
  movable.setSelected(true);
  connector.setSelection(new SelectionSet(movable));
  connector.addListener(new IMapInterfaceListener(){
    @Override public void action(    Action action){
switch (action.getActionType()) {
case MOVE_TO:
        movable.moveTo(((MoveToAction)action).getPosition());
      break;
case SPEED_FASTER:
    NetworkTimer.multiplyGameSpeed(1.2f);
  break;
case SPEED_SLOWER:
NetworkTimer.multiplyGameSpeed(1 / 1.2f);
break;
case FAST_FORWARD:
NetworkTimer.get().fastForward();
break;
default :
break;
}
}
}
);
grid.getMovableGrid().dropMaterial(new ShortPoint2D(40,40),EMaterialType.PLANK,true);
grid.getMovableGrid().dropMaterial(new ShortPoint2D(60,60),EMaterialType.STONE,true);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(30,30),PLAYER_0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(31,31),PLAYER_0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(32,32),PLAYER_0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(33,33),PLAYER_0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(50,50),PLAYER_0);
{
for (int x=30; x < 40; x++) {
for (int y=80; y < 90; y++) {
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(x,y),PLAYER_0);
}
}
}
{
Thread.sleep(3000);
NewMovable m1=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(50,65),PLAYER_0);
NewMovable m2=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(51,65),PLAYER_0);
NewMovable m3=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(50,64),PLAYER_0);
m1.moveTo(new ShortPoint2D(52,65));
m2.moveTo(new ShortPoint2D(49,63));
m3.moveTo(new ShortPoint2D(50,66));
}
}","private MovableTestWindow() throws InterruptedException {
  NetworkTimer.get().schedule();
  RandomSingleton.load(1000);
  MovableTestsMap grid=new MovableTestsMap(100,100);
  MapInterfaceConnector connector=TestWindow.openTestWindow(grid);
  movable=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(49,50),PLAYER_0);
  movable.setSelected(true);
  connector.setSelection(new SelectionSet(movable));
  connector.addListener(new IMapInterfaceListener(){
    @Override public void action(    Action action){
switch (action.getActionType()) {
case MOVE_TO:
        movable.moveTo(((PointAction)action).getPosition());
      break;
case SPEED_FASTER:
    NetworkTimer.multiplyGameSpeed(1.2f);
  break;
case SPEED_SLOWER:
NetworkTimer.multiplyGameSpeed(1 / 1.2f);
break;
case FAST_FORWARD:
NetworkTimer.get().fastForward();
break;
default :
break;
}
}
}
);
grid.getMovableGrid().dropMaterial(new ShortPoint2D(40,40),EMaterialType.PLANK,true);
grid.getMovableGrid().dropMaterial(new ShortPoint2D(60,60),EMaterialType.STONE,true);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(30,30),PLAYER_0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(31,31),PLAYER_0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(32,32),PLAYER_0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(33,33),PLAYER_0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(50,50),PLAYER_0);
{
for (int x=30; x < 40; x++) {
for (int y=80; y < 90; y++) {
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(x,y),PLAYER_0);
}
}
}
{
Thread.sleep(3000);
NewMovable m1=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(50,65),PLAYER_0);
NewMovable m2=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(51,65),PLAYER_0);
NewMovable m3=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(50,64),PLAYER_0);
m1.moveTo(new ShortPoint2D(52,65));
m2.moveTo(new ShortPoint2D(49,63));
m3.moveTo(new ShortPoint2D(50,66));
}
}"
56338,"@Test public void testCompareOldAndNew() throws MapLoadException {
  MainGrid grid=new MapLoader(new File(MapList.getDefaultFolder(),""String_Node_Str"")).getMainGrid();
  MainGridDataAccessor gridAccessor=new MainGridDataAccessor(grid);
  short width=gridAccessor.getWidth();
  short height=gridAccessor.getHeight();
  BitSet notBlockingSet=new BitSet(width * height);
  LandscapeGrid landscapeGrid=gridAccessor.getLandscapeGrid();
  for (short y=0; y < height; y++) {
    for (short x=0; x < width; x++) {
      notBlockingSet.set(x + y * width,!landscapeGrid.getLandscapeTypeAt(x,y).isBlocking);
    }
  }
  PartitionCalculatorAlgorithm partitioner=new PartitionCalculatorAlgorithm(0,0,width,height,notBlockingSet,IBlockingProvider.DEFAULT_PROVIDER);
  partitioner.calculatePartitions();
  System.out.println(""String_Node_Str"" + partitioner.getNumberOfPartitions());
  for (short y=0; y < height; y++) {
    for (short x=0; x < width; x++) {
      assertEquals(gridAccessor.getLandscapeGrid().getBlockedPartitionAt(x,y),partitioner.getPartitionAt(x,y));
    }
  }
}","@Test public void testCompareOldAndNew() throws MapLoadException {
  MainGrid grid=new MapLoader(new File(MapList.getDefaultFolder(),""String_Node_Str"")).getMainGrid();
  MainGridDataAccessor gridAccessor=new MainGridDataAccessor(grid);
  short width=gridAccessor.getWidth();
  short height=gridAccessor.getHeight();
  BitSet notBlockingSet=new BitSet(width * height);
  LandscapeGrid landscapeGrid=gridAccessor.getLandscapeGrid();
  for (short y=0; y < height; y++) {
    for (short x=0; x < width; x++) {
      notBlockingSet.set(x + y * width,!landscapeGrid.getLandscapeTypeAt(x,y).isBlocking);
    }
  }
  PartitionCalculatorAlgorithm partitioner=new PartitionCalculatorAlgorithm(0,0,width,height,notBlockingSet,IBlockingProvider.DEFAULT_IMPLEMENTATION);
  partitioner.calculatePartitions();
  System.out.println(""String_Node_Str"" + partitioner.getNumberOfPartitions());
  for (short y=0; y < height; y++) {
    for (short x=0; x < width; x++) {
      assertEquals(gridAccessor.getLandscapeGrid().getBlockedPartitionAt(x,y),partitioner.getPartitionAt(x,y));
    }
  }
}"
56339,"public static void main(String[] args) throws MapLoadException, InterruptedException {
  MainGrid grid=new MapLoader(new File(MapList.getDefaultFolder(),""String_Node_Str"")).getMainGrid();
  MainGridDataAccessor gridAccessor=new MainGridDataAccessor(grid);
  short width=gridAccessor.getWidth();
  short height=gridAccessor.getHeight();
  BitSet notBlockingSet=new BitSet(width * height);
  LandscapeGrid landscapeGrid=gridAccessor.getLandscapeGrid();
  for (short y=0; y < height; y++) {
    for (short x=0; x < width; x++) {
      notBlockingSet.set(x + y * width,!landscapeGrid.getLandscapeTypeAt(x,y).isBlocking);
    }
  }
  Thread.sleep(500);
  MilliStopWatch watch=new MilliStopWatch();
  PartitionCalculatorAlgorithm partitioner=new PartitionCalculatorAlgorithm(0,0,width,height,notBlockingSet,IBlockingProvider.DEFAULT_PROVIDER);
  partitioner.calculatePartitions();
  System.out.println(""String_Node_Str"" + partitioner.getNumberOfPartitions());
  watch.stop(""String_Node_Str"");
  System.exit(0);
}","public static void main(String[] args) throws MapLoadException, InterruptedException {
  MainGrid grid=new MapLoader(new File(MapList.getDefaultFolder(),""String_Node_Str"")).getMainGrid();
  MainGridDataAccessor gridAccessor=new MainGridDataAccessor(grid);
  short width=gridAccessor.getWidth();
  short height=gridAccessor.getHeight();
  BitSet notBlockingSet=new BitSet(width * height);
  LandscapeGrid landscapeGrid=gridAccessor.getLandscapeGrid();
  for (short y=0; y < height; y++) {
    for (short x=0; x < width; x++) {
      notBlockingSet.set(x + y * width,!landscapeGrid.getLandscapeTypeAt(x,y).isBlocking);
    }
  }
  Thread.sleep(500);
  MilliStopWatch watch=new MilliStopWatch();
  PartitionCalculatorAlgorithm partitioner=new PartitionCalculatorAlgorithm(0,0,width,height,notBlockingSet,IBlockingProvider.DEFAULT_IMPLEMENTATION);
  partitioner.calculatePartitions();
  System.out.println(""String_Node_Str"" + partitioner.getNumberOfPartitions());
  watch.stop(""String_Node_Str"");
  System.exit(0);
}"
56340,"private PartitionsGridTestingWnd(){
  this.grid=new PartitionsGrid(WIDTH,HEIGHT,(byte)10,IBlockingProvider.DEFAULT_PROVIDER);
}","private PartitionsGridTestingWnd(){
  this.grid=new PartitionsGrid(WIDTH,HEIGHT,(byte)10,IPartitionsGridBlockingProvider.DEFAULT_IMPLEMENTATION);
}"
56341,"private void changePlayerOfTower(int x,int y,int newPlayer){
  ShortPoint2D pos=new ShortPoint2D(x,y);
  grid.changePlayerOfTower(pos,(byte)newPlayer,new FreeMapArea(pos,EBuildingType.TOWER.getProtectedTiles()));
}","@SuppressWarnings(""String_Node_Str"") private void changePlayerOfTower(int x,int y,int newPlayer){
  ShortPoint2D pos=new ShortPoint2D(x,y);
  grid.changePlayerOfTower(pos,(byte)newPlayer,new FreeMapArea(pos,EBuildingType.TOWER.getProtectedTiles()));
}"
56342,"@Override public void run(){
  while (!canceled) {
    try {
synchronized (this) {
        while (buildingType == null) {
          this.wait();
        }
      }
      while (buildingType != null && !canceled) {
        if (!NetworkTimer.isPausing()) {
          StopWatch watch=new MilliStopWatch();
          watch.start();
          calculateConstructMarks();
          watch.stop(""String_Node_Str"");
        }
synchronized (this) {
          wait(AlgorithmConstants.CONSTRUCT_MARKS_MAX_REFRESH_TIME);
        }
      }
      removeConstructionMarks(lastArea);
      lastArea=null;
    }
 catch (    InterruptedException e) {
    }
catch (    Throwable e) {
      e.printStackTrace();
    }
  }
}","@Override public void run(){
  while (!canceled) {
    try {
synchronized (this) {
        while (buildingType == null) {
          this.wait();
        }
      }
      while (buildingType != null && !canceled) {
        if (!NetworkTimer.isPausing()) {
          StopWatch watch=new MilliStopWatch();
          watch.start();
          calculateConstructMarks();
          watch.stop(""String_Node_Str"");
        }
synchronized (this) {
          wait(AlgorithmConstants.CONSTRUCT_MARKS_MAX_REFRESH_TIME);
        }
      }
      removeConstructionMarks(lastArea);
      lastArea=null;
    }
 catch (    InterruptedException e) {
    }
catch (    Throwable t) {
      t.printStackTrace();
    }
  }
}"
56343,"/** 
 * Normalizes the partitions and compacts them.
 */
private void normalizePartitions(){
  short[] compacted=new short[partitions.length + 1];
  compacted[NO_PARTITION]=NO_PARTITION;
  compacted[BLOCKED_PARTITION]=BLOCKED_PARTITION;
  short compactedCount=NUMBER_OF_RESERVED_PARTITIONS;
  for (short i=NUMBER_OF_RESERVED_PARTITIONS; i < nextFreePartition; i++) {
    short representative=i;
    short nextRep;
    while (representative != (nextRep=partitions[representative])) {
      representative=nextRep;
    }
    if (compacted[representative] == 0) {
      compacted[representative]=compactedCount++;
      partitionBorderPositions[compactedCount]=partitionBorderPositions[representative];
    }
    partitions[i]=representative;
    compacted[i]=compacted[representative];
  }
  partitions=compacted;
  neededPartitions=(short)(compactedCount - 1);
}","/** 
 * Normalizes the partitions and compacts them.
 */
private void normalizePartitions(){
  short[] compacted=new short[partitions.length + 1];
  compacted[NO_PARTITION]=NO_PARTITION;
  compacted[BLOCKED_PARTITION]=BLOCKED_PARTITION;
  short compactedCount=NUMBER_OF_RESERVED_PARTITIONS;
  for (short i=NUMBER_OF_RESERVED_PARTITIONS; i < nextFreePartition; i++) {
    short representative=i;
    short nextRep;
    while (representative != (nextRep=partitions[representative])) {
      representative=nextRep;
    }
    if (compacted[representative] == 0) {
      compacted[representative]=compactedCount++;
      partitionBorderPositions[compactedCount]=partitionBorderPositions[representative];
    }
    partitions[i]=representative;
    compacted[i]=compacted[representative];
  }
  partitions=compacted;
  neededPartitions=compactedCount;
}"
56344,"public static void dropAllBuildings(){
  allBuildings.clear();
  OccupyingBuilding.dropAllBuildings();
}","public static void dropAllBuildings(){
  allBuildings.clear();
}"
56345,"@Override public void receiveHit(float strength,ShortPoint2D attackerPos){
  if (doorHealth > 0) {
    doorHealth-=strength / Constants.DOOR_HIT_RESISTENCY_FACTOR;
    if (doorHealth <= 0) {
      doorHealth=0;
      inFight=true;
      OccupyingBuilding.this.getGrid().getMapObjectsManager().addSelfDeletingMapObject(getPos(),EMapObjectType.GHOST,Constants.GHOST_PLAY_DURATION,getPlayer());
      pollNewDefender();
    }
  }
 else   if (currDefender != null) {
    IAttackableMovable movable=currDefender.getSoldier().getMovable();
    movable.receiveHit(strength,attackerPos);
    if (movable.getHealth() <= 0) {
      if (occupiers.isEmpty()) {
        currDefender=null;
        changePlayerTo(attackerPos);
      }
 else {
        emptyPlaces.add(currDefender.place);
        searchedSoldiers.add(getSearchType(currDefender.getSoldier().getMovableType()));
        pollNewDefender();
      }
    }
  }
}","@Override public void receiveHit(float strength,ShortPoint2D attackerPos){
  if (getGrid().getMovable(attackerPos).getPlayer() == getPlayer()) {
    return;
  }
  if (doorHealth > 0) {
    doorHealth-=strength / Constants.DOOR_HIT_RESISTENCY_FACTOR;
    if (doorHealth <= 0) {
      doorHealth=0;
      inFight=true;
      OccupyingBuilding.this.getGrid().getMapObjectsManager().addSelfDeletingMapObject(getPos(),EMapObjectType.GHOST,Constants.GHOST_PLAY_DURATION,getPlayer());
      pollNewDefender();
    }
  }
 else   if (currDefender != null) {
    IAttackableMovable movable=currDefender.getSoldier().getMovable();
    movable.receiveHit(strength,attackerPos);
    if (movable.getHealth() <= 0) {
      if (occupiers.isEmpty()) {
        currDefender=null;
        changePlayerTo(attackerPos);
      }
 else {
        emptyPlaces.add(currDefender.place);
        searchedSoldiers.add(getSearchType(currDefender.getSoldier().getMovableType()));
        pollNewDefender();
      }
    }
  }
}"
56346,"@Override protected final void killedEvent(){
  setSelected(false);
  if (occupiedArea) {
    freeArea();
    int idx=0;
    FreeMapArea buildingArea=super.getBuildingArea();
    for (    TowerOccupyer curr : occupiers) {
      addInformableMapObject(curr,false);
      curr.getSoldier().leaveOccupyableBuilding(buildingArea.get(idx));
      idx++;
    }
    occupiers.clear();
  }
  allOccupyingBuildings.remove(this);
  setAttackableTowerObject(false);
}","@Override protected final void killedEvent(){
  setSelected(false);
  if (occupiedArea) {
    freeArea();
    int idx=0;
    FreeMapArea buildingArea=super.getBuildingArea();
    for (    TowerOccupyer curr : occupiers) {
      addInformableMapObject(curr,false);
      curr.getSoldier().leaveOccupyableBuilding(buildingArea.get(idx));
      idx++;
    }
    occupiers.clear();
  }
  setAttackableTowerObject(false);
}"
56347,"@Override public void towerDefended(IBuildingOccupyableMovable soldier){
  inFight=false;
  occupiers.add(new TowerOccupyer(attackableTowerObject.currDefender.place,soldier));
  attackableTowerObject.currDefender=null;
}","@Override public void towerDefended(IBuildingOccupyableMovable soldier){
  inFight=false;
  if (attackableTowerObject.currDefender == null) {
    System.out.println();
  }
  occupiers.add(new TowerOccupyer(attackableTowerObject.currDefender.place,soldier));
  attackableTowerObject.currDefender=null;
}"
56348,"public OccupyingBuilding(EBuildingType type,Player player){
  super(type,player);
  this.occupiers=new LinkedList<TowerOccupyer>();
  initSoldierRequests();
  allOccupyingBuildings.add(this);
  delayCtr=(byte)RandomSingleton.getInt(0,3);
}","public OccupyingBuilding(EBuildingType type,Player player){
  super(type,player);
  this.occupiers=new LinkedList<TowerOccupyer>();
  initSoldierRequests();
  delayCtr=(byte)RandomSingleton.getInt(0,3);
}"
56349,"@Override public final int getDebugColorAt(int x,int y){
  return flagsGrid.isMarked(x,y) ? Color.ORANGE.getARGB() : (objectsGrid.getMapObjectAt(x,y,EMapObjectType.INFORMABLE_MAP_OBJECT) != null ? Color.GREEN.getARGB() : (objectsGrid.getMapObjectAt(x,y,EMapObjectType.ATTACKABLE_TOWER) != null ? Color.RED.getARGB() : (flagsGrid.isBlocked(x,y) ? Color.BLACK.getARGB() : (flagsGrid.isProtected(x,y) ? Color.BLUE.getARGB() : 0))));
}","@Override public final int getDebugColorAt(int x,int y){
  int value=partitionsGrid.getPartitionIdAt(x,y) + 1;
  return Color.getARGB((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
}"
56350,"private static void loadSingleLib(String file) throws IOException {
  File temporary=File.createTempFile(""String_Node_Str"" + file,""String_Node_Str"" + getExtension());
  FileOutputStream out=new FileOutputStream(temporary);
  String filename=getLibDir() + System.mapLibraryName(file);
  InputStream in=JoglLoader.class.getResourceAsStream(filename);
  if (in == null) {
    throw new IOException(""String_Node_Str"");
  }
  int n;
  byte buffer[]=new byte[4096];
  while ((n=in.read(buffer)) != -1) {
    out.write(buffer,0,n);
  }
  in.close();
  out.close();
  System.load(temporary.getAbsolutePath());
  temporary.deleteOnExit();
}","private static void loadSingleLib(String file) throws IOException {
  File temporary=File.createTempFile(""String_Node_Str"" + file,""String_Node_Str"" + getExtension());
  String filename=getLibDir() + System.mapLibraryName(file);
  InputStream in=JoglLoader.class.getResourceAsStream(filename);
  if (in == null) {
    throw new IOException(""String_Node_Str"");
  }
  FileOutputStream out=new FileOutputStream(temporary);
  int n;
  byte buffer[]=new byte[4096];
  while ((n=in.read(buffer)) != -1) {
    out.write(buffer,0,n);
  }
  in.close();
  out.close();
  System.load(temporary.getAbsolutePath());
  temporary.deleteOnExit();
}"
56351,"private void select(ShortPoint2D pos){
  if (grid.isInBounds(pos)) {
    short x=pos.x;
    short y=pos.y;
    IGuiMovable m1=grid.getMovable((short)(x + 1),(short)(y + 1));
    IGuiMovable m2=grid.getMovable((x),(short)(y + 1));
    IGuiMovable m3=grid.getMovable(x,y);
    IGuiMovable m4=grid.getMovable((short)(x + 1),(short)(y + 2));
    if (m1 != null) {
      setSelection(new SelectionSet(m1));
    }
 else     if (m2 != null) {
      setSelection(new SelectionSet(m2));
    }
 else     if (m3 != null) {
      setSelection(new SelectionSet(m3));
    }
 else     if (m4 != null) {
      setSelection(new SelectionSet(m4));
    }
 else {
      IBuilding building=getBuildingAround(pos);
      if (building != null) {
        setSelection(new SelectionSet(building));
      }
 else {
        setSelection(new SelectionSet());
      }
    }
  }
}","private void select(ShortPoint2D pos){
  if (grid.isInBounds(pos)) {
    short x=pos.x;
    short y=pos.y;
    IGuiMovable m1=grid.getMovable(x,y);
    IGuiMovable m3=grid.getMovable((short)(x + 1),(short)(y + 1));
    IGuiMovable m2=grid.getMovable((x),(short)(y + 1));
    IGuiMovable m4=grid.getMovable((short)(x + 1),(short)(y + 2));
    if (m1 != null) {
      setSelection(new SelectionSet(m1));
      System.out.println(""String_Node_Str"" + pos);
    }
 else     if (m2 != null) {
      setSelection(new SelectionSet(m2));
    }
 else     if (m3 != null) {
      setSelection(new SelectionSet(m3));
    }
 else     if (m4 != null) {
      setSelection(new SelectionSet(m4));
    }
 else {
      IBuilding building=getBuildingAround(pos);
      if (building != null) {
        setSelection(new SelectionSet(building));
      }
 else {
        setSelection(new SelectionSet());
      }
    }
  }
}"
56352,"private void handleSelectPointAction(PointAction action){
  ShortPoint2D pos=action.getPosition();
  System.out.println(""String_Node_Str"" + pos.x + ""String_Node_Str""+ pos.y+ ""String_Node_Str"");
  if (activeAction == null) {
    select(pos);
  }
 else {
switch (activeAction.getActionType()) {
case BUILD:
      EBuildingType type=previewBuilding;
    ShortPoint2D pos2=grid.getConstructablePositionAround(pos,type);
  if (pos2 != null) {
    cancelBuildingCreation();
    scheduleTask(new GeneralGuiTask(EGuiAction.BUILD,pos2,type));
    break;
  }
 else {
    return;
  }
default :
break;
}
setActiveAction(null);
}
}","private void handleSelectPointAction(PointAction action){
  ShortPoint2D pos=action.getPosition();
  grid.postionClicked(pos.x,pos.y);
  if (activeAction == null) {
    select(pos);
  }
 else {
switch (activeAction.getActionType()) {
case BUILD:
      EBuildingType type=previewBuilding;
    ShortPoint2D pos2=grid.getConstructablePositionAround(pos,type);
  if (pos2 != null) {
    cancelBuildingCreation();
    scheduleTask(new GeneralGuiTask(EGuiAction.BUILD,pos2,type));
    break;
  }
 else {
    return;
  }
default :
break;
}
setActiveAction(null);
}
}"
56353,"private final void appearAt(IBuildingsGrid grid,ShortPoint2D pos){
  this.state=STATE_CONSTRUCTED;
  positionAt(grid,pos);
  if (this.pos != null) {
    grid.setBlocked(getBuildingArea(),true);
    finishConstruction();
  }
  appearedEvent();
}","private final void appearAt(IBuildingsGrid grid,ShortPoint2D pos){
  this.state=STATE_CONSTRUCTED;
  boolean itWorked=positionAt(grid,pos);
  if (itWorked) {
    grid.setBlocked(getBuildingArea(),true);
    finishConstruction();
    appearedEvent();
  }
 else {
    kill();
  }
}"
56354,"@Override public final void setSelected(boolean selected){
  super.setSelected(selected);
  for (  TowerOccupyer curr : occupiers) {
    curr.getSoldier().setSelected(selected);
  }
  if (attackableTowerObject != null && attackableTowerObject.currDefender != null) {
    attackableTowerObject.currDefender.getSoldier().setSelected(selected);
  }
}","@Override public final void setSelected(boolean selected){
  super.setSelected(selected);
  for (  TowerOccupier curr : occupiers) {
    curr.getSoldier().setSelected(selected);
  }
  if (attackableTowerObject != null && attackableTowerObject.currDefender != null) {
    attackableTowerObject.currDefender.getSoldier().setSelected(selected);
  }
}"
56355,"/** 
 * Adds or removes the informable map object for the given soldier.
 * @param soldier
 * @param add if true, the object is added<br> if false, the object is removed.
 */
private void addInformableMapObject(TowerOccupyer soldier,boolean add){
  if (soldier.place.getType() == ESoldierType.BOWMAN) {
    ShortPoint2D position=getTowerBowmanSearchPosition(soldier.place);
    if (add) {
      super.getGrid().getMapObjectsManager().addInformableMapObjectAt(position,soldier.getSoldier().getMovable());
    }
 else {
      super.getGrid().getMapObjectsManager().removeMapObjectType(position.x,position.y,EMapObjectType.INFORMABLE_MAP_OBJECT);
    }
  }
}","/** 
 * Adds or removes the informable map object for the given soldier.
 * @param soldier
 * @param add if true, the object is added<br> if false, the object is removed.
 */
private void addInformableMapObject(TowerOccupier soldier,boolean add){
  if (soldier.place.getType() == ESoldierType.BOWMAN) {
    ShortPoint2D position=getTowerBowmanSearchPosition(soldier.place);
    if (add) {
      super.getGrid().getMapObjectsManager().addInformableMapObjectAt(position,soldier.getSoldier().getMovable());
    }
 else {
      super.getGrid().getMapObjectsManager().removeMapObjectType(position.x,position.y,EMapObjectType.INFORMABLE_MAP_OBJECT);
    }
  }
}"
56356,"@Override protected final void killedEvent(){
  setSelected(false);
  if (occupiedArea) {
    freeArea();
    int idx=0;
    FreeMapArea buildingArea=super.getBuildingArea();
    for (    TowerOccupyer curr : occupiers) {
      addInformableMapObject(curr,false);
      curr.getSoldier().leaveOccupyableBuilding(buildingArea.get(idx));
      idx++;
    }
    occupiers.clear();
  }
  setAttackableTowerObject(false);
}","@Override protected final void killedEvent(){
  setSelected(false);
  if (occupiedArea) {
    freeArea();
    int idx=0;
    FreeMapArea buildingArea=super.getBuildingArea();
    for (    TowerOccupier curr : occupiers) {
      addInformableMapObject(curr,false);
      curr.getSoldier().leaveOccupyableBuilding(buildingArea.get(idx));
      idx++;
    }
    occupiers.clear();
  }
  setAttackableTowerObject(false);
}"
56357,"private void initSoldierRequests(){
  final OccupyerPlace[] occupyerPlaces=super.getBuildingType().getOccupyerPlaces();
  if (occupyerPlaces.length > 0) {
    for (    OccupyerPlace currPlace : occupyerPlaces) {
      emptyPlaces.add(currPlace);
      searchedSoldiers.add(currPlace.getType() == ESoldierType.INFANTRY ? ESearchType.SOLDIER_SWORDSMAN : ESearchType.SOLDIER_BOWMAN);
    }
  }
}","private void initSoldierRequests(){
  final OccupyerPlace[] occupyerPlaces=super.getBuildingType().getOccupyerPlaces();
  if (occupyerPlaces.length > 0) {
    for (    OccupyerPlace currPlace : occupyerPlaces) {
      requestSoldierForPlace(currPlace);
    }
  }
}"
56358,"@Override public final OccupyerPlace addSoldier(IBuildingOccupyableMovable soldier){
  OccupyerPlace freePosition=findFreePositionFor(soldier.getSoldierType());
  emptyPlaces.remove(freePosition);
  currentlyCommingSoldiers[freePosition.getType().ordinal()]--;
  TowerOccupyer towerOccupier=new TowerOccupyer(freePosition,soldier);
  occupiers.add(towerOccupier);
  occupyAreaIfNeeded();
  soldier.setSelected(super.isSelected());
  addInformableMapObject(towerOccupier,true);
  return freePosition;
}","@Override public final OccupyerPlace addSoldier(IBuildingOccupyableMovable soldier){
  OccupyerPlace freePosition=findFreePositionFor(soldier.getSoldierType());
  emptyPlaces.remove(freePosition);
  currentlyCommingSoldiers[freePosition.getType().ordinal()]--;
  TowerOccupier towerOccupier=new TowerOccupier(freePosition,soldier);
  occupiers.add(towerOccupier);
  occupyAreaIfNeeded();
  soldier.setSelected(super.isSelected());
  addInformableMapObject(towerOccupier,true);
  return freePosition;
}"
56359,"@Override public void towerDefended(IBuildingOccupyableMovable soldier){
  inFight=false;
  if (attackableTowerObject.currDefender == null) {
    System.out.println();
  }
  occupiers.add(new TowerOccupyer(attackableTowerObject.currDefender.place,soldier));
  attackableTowerObject.currDefender=null;
}","@Override public void towerDefended(IBuildingOccupyableMovable soldier){
  inFight=false;
  if (attackableTowerObject.currDefender == null) {
    System.out.println();
  }
  occupiers.add(new TowerOccupier(attackableTowerObject.currDefender.place,soldier));
  attackableTowerObject.currDefender=null;
  doorHealth=0.1f;
}"
56360,"protected TowerOccupyer removeSoldier(){
  TowerOccupyer removedSoldier=occupiers.removeFirst();
  addInformableMapObject(removedSoldier,false);
  return removedSoldier;
}","protected TowerOccupier removeSoldier(){
  TowerOccupier removedSoldier=occupiers.removeFirst();
  addInformableMapObject(removedSoldier,false);
  return removedSoldier;
}"
56361,"public OccupyingBuilding(EBuildingType type,Player player){
  super(type,player);
  this.occupiers=new LinkedList<TowerOccupyer>();
  initSoldierRequests();
  delayCtr=(byte)RandomSingleton.getInt(0,3);
}","public OccupyingBuilding(EBuildingType type,Player player){
  super(type,player);
  this.occupiers=new LinkedList<TowerOccupier>();
  initSoldierRequests();
  delayCtr=(byte)RandomSingleton.getInt(0,3);
}"
56362,"@Override public final ShortPoint2D getPosition(IBuildingOccupyableMovable soldier){
  for (  TowerOccupyer curr : occupiers) {
    if (curr.getSoldier() == soldier) {
      return curr.place.getPosition().calculatePoint(super.getPos());
    }
  }
  return null;
}","@Override public final ShortPoint2D getPosition(IBuildingOccupyableMovable soldier){
  for (  TowerOccupier curr : occupiers) {
    if (curr.getSoldier() == soldier) {
      return curr.place.getPosition().calculatePoint(super.getPos());
    }
  }
  return null;
}"
56363,"@Override public final int getDebugColorAt(int x,int y){
  int value=partitionsGrid.getPartitionIdAt(x,y) + 1;
  return Color.getARGB((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
}","@Override public final int getDebugColorAt(int x,int y){
  int value=partitionsGrid.getTowerCountAt(x,y) + 1;
  return Color.getABGR((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
}"
56364,"@Override public void mergeInto(PartitionManager newManager){
  super.mergeInto(newManager);
  counter=0;
  xSum=0;
  ySum=0;
}","public void mergeInto(Partition newPartition){
  super.mergeInto(newPartition);
  newPartition.counter+=this.counter;
  newPartition.xSum+=xSum;
  newPartition.ySum+=ySum;
  counter=0;
  xSum=0;
  ySum=0;
}"
56365,"/** 
 * Checks if the given partitions is divided and the both given positions are on separated parts of the partition.
 * @param partition
 * @param pos1
 * @param pos2
 */
private void checkIfDividePartition(Short partition,ShortPoint2D pos1,ShortPoint2D pos2){
  System.out.println(""String_Node_Str"" + partition + ""String_Node_Str""+ pos1+ ""String_Node_Str""+ pos2);
  if (!PartitionsDividedTester.isPartitionNotDivided(this,pos1,pos2,partition)) {
    dividePartition(partition,pos1,pos2);
  }
}","/** 
 * Checks if the given partitions is divided and the both given positions are on separated parts of the partition.
 * @param partition
 * @param pos1
 * @param pos2
 */
private void checkIfDividePartition(Short partition,ShortPoint2D pos1,ShortPoint2D pos2){
  System.out.println(""String_Node_Str"" + partition + ""String_Node_Str""+ pos1+ ""String_Node_Str""+ pos2);
  if (partition != NO_PLAYER_PARTITION_ID && !PartitionsDividedTester.isPartitionNotDivided(this,pos1,pos2,partition)) {
    dividePartition(partition,pos1,pos2);
  }
}"
56366,"public void mergeInto(PartitionManager newManager){
  newManager.bricklayerRequests.addAll(this.bricklayerRequests);
  newManager.diggerRequests.addAll(this.diggerRequests);
  newManager.joblessBearer.addAll(this.joblessBearer);
  newManager.joblessBricklayers.addAll(this.joblessBricklayers);
  newManager.joblessDiggers.addAll(this.joblessDiggers);
  newManager.joblessWorkers.addAll(this.joblessWorkers);
  newManager.materialOffers.addAll(this.materialOffers);
  newManager.materialRequests.addAll(this.materialRequests);
  newManager.soilderCreationRequests.addAll(this.soilderCreationRequests);
  newManager.workerCreationRequests.addAll(this.workerCreationRequests);
  newManager.workerRequests.addAll(this.workerRequests);
  newManager.toolProductionRequests.addAll(toolProductionRequests);
  newManager.weaponProductionRequests.addAll(weaponProductionRequests);
  newManager.toolRequestingWorkerRequests.merge(this.toolRequestingWorkerRequests);
}","public final void mergeInto(PartitionManager newManager){
  newManager.bricklayerRequests.addAll(this.bricklayerRequests);
  newManager.diggerRequests.addAll(this.diggerRequests);
  newManager.joblessBearer.addAll(this.joblessBearer);
  newManager.joblessBricklayers.addAll(this.joblessBricklayers);
  newManager.joblessDiggers.addAll(this.joblessDiggers);
  newManager.joblessWorkers.addAll(this.joblessWorkers);
  newManager.materialOffers.addAll(this.materialOffers);
  newManager.materialRequests.addAll(this.materialRequests);
  newManager.soilderCreationRequests.addAll(this.soilderCreationRequests);
  newManager.workerCreationRequests.addAll(this.workerCreationRequests);
  newManager.workerRequests.addAll(this.workerRequests);
  newManager.toolProductionRequests.addAll(toolProductionRequests);
  newManager.weaponProductionRequests.addAll(weaponProductionRequests);
  newManager.toolRequestingWorkerRequests.merge(this.toolRequestingWorkerRequests);
}"
56367,"public ErrorsWindow(ErrorList list,IScrollToAble scrollTo){
  this.list=list;
  this.scrollTo=scrollTo;
  elist=new JList<ILocatable>(list);
  elist.addListSelectionListener(this);
  window=new JFrame(EditorLabels.getLabel(""String_Node_Str""));
  window.add(new JScrollPane(elist));
  window.setPreferredSize(new Dimension(500,300));
  window.pack();
  window.setVisible(true);
  window.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
}","public ErrorsWindow(ErrorList list,IScrollToAble scrollTo){
  this.list=list;
  this.scrollTo=scrollTo;
  elist=new JList(list);
  elist.addListSelectionListener(this);
  window=new JFrame(EditorLabels.getLabel(""String_Node_Str""));
  window.add(new JScrollPane(elist));
  window.setPreferredSize(new Dimension(500,300));
  window.pack();
  window.setVisible(true);
  window.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
}"
56368,"public StopWatch(){
  start();
}","public StopWatch(){
  restart();
}"
56369,"@Override public void run(){
  while (!canceled) {
    try {
synchronized (this) {
        while (buildingType == null) {
          this.wait();
        }
      }
      while (buildingType != null && !canceled) {
        if (!NetworkTimer.isPausing()) {
          StopWatch watch=new MilliStopWatch();
          watch.start();
          calculateConstructMarks();
          watch.stop(""String_Node_Str"");
        }
synchronized (this) {
          wait(AlgorithmConstants.CONSTRUCT_MARKS_MAX_REFRESH_TIME);
        }
      }
      removeConstructionMarks(lastArea);
      lastArea=null;
    }
 catch (    InterruptedException e) {
    }
catch (    Throwable t) {
      t.printStackTrace();
    }
  }
}","@Override public void run(){
  while (!canceled) {
    try {
synchronized (this) {
        while (buildingType == null) {
          this.wait();
        }
      }
      while (buildingType != null && !canceled) {
        if (!NetworkTimer.isPausing()) {
          StopWatch watch=new MilliStopWatch();
          watch.restart();
          calculateConstructMarks();
          watch.stop(""String_Node_Str"");
        }
synchronized (this) {
          wait(AlgorithmConstants.CONSTRUCT_MARKS_MAX_REFRESH_TIME);
        }
      }
      removeConstructionMarks(lastArea);
      lastArea=null;
    }
 catch (    InterruptedException e) {
    }
catch (    Throwable t) {
      t.printStackTrace();
    }
  }
}"
56370,"@Override public final void run(){
  mySleep(500);
  while (!canceled) {
    StopWatch watch=new MilliStopWatch();
    watch.start();
    if (enabled) {
      rebuildSight();
    }
    mySleep(800);
  }
}","@Override public final void run(){
  mySleep(500);
  while (!canceled) {
    StopWatch watch=new MilliStopWatch();
    watch.restart();
    if (enabled) {
      rebuildSight();
    }
    mySleep(800);
  }
}"
56371,"private final void occupyAreaIfNeeded(){
  if (!occupiedArea) {
    MapCircle occupying=getOccupyablePositions();
    super.getGrid().occupyAreaByTower(super.getPlayer(),occupying);
    occupiedArea=true;
  }
}","private final void occupyAreaIfNeeded(){
  if (!occupiedArea) {
    MapCircle occupying=new MapCircle(super.getPos(),CommonConstants.TOWER_RADIUS);
    super.getGrid().occupyAreaByTower(super.getPlayer(),occupying);
    occupiedArea=true;
  }
}"
56372,"private void initAdditionalGrids(){
  this.graphicsGrid=new GraphicsGrid();
  this.landmarksCorrection=new LandmarksCorrectingThread(new LandmarksGrid());
  this.constructionMarksGrid=new ConstructionMarksGrid();
  this.bordersThread=new BordersThread(new BordersThreadGrid());
  this.guiInputGrid=new GUIInputGrid();
}","private void initAdditionalGrids(){
  this.graphicsGrid=new GraphicsGrid();
  this.landmarksCorrection=new LandmarksCorrectingThread(new LandmarksThreadGrid());
  this.constructionMarksGrid=new ConstructionMarksGrid();
  this.bordersThread=new BordersThread(new BordersThreadGrid());
  this.guiInputGrid=new GUIInputGrid();
}"
56373,"/** 
 * sets this position blocked and protected.
 * @param x x coordinate
 * @param y y coordinate
 * @param blocked the position will be set to blocked and protected if blocked == true<br> otherwise it will be set to unblocked and unprotected.
 */
public void setBlockedAndProtected(short x,short y,boolean blocked){
  final int idx=x + y * width;
  this.blockedGrid.set(idx,blocked);
  this.protectedGrid.set(idx,blocked);
}","/** 
 * sets this position blocked and protected.
 * @param x x coordinate
 * @param y y coordinate
 * @param blocked the position will be set to blocked and protected if blocked == true<br> otherwise it will be set to unblocked and unprotected.
 */
public void setBlockedAndProtected(short x,short y,boolean blocked){
  final int idx=x + y * width;
  this.blockedGrid.set(idx,blocked);
  this.protectedGrid.set(idx,blocked);
  if (blockingChangedListener != null) {
    this.blockingChangedListener.blockingChanged(x,y,blocked);
  }
}"
56374,"/** 
 * @param pos1
 * @param pos2
 * @return The position with the bigger distance to the gravity center of this partition.
 */
public ShortPoint2D getPositionCloserToGravityCenter(ShortPoint2D pos1,ShortPoint2D pos2){
  int gravityX=xSum / counter;
  int gravityY=ySum / counter;
  int dist1=ShortPoint2D.getOnGridDist(gravityX - pos1.x,gravityY - pos1.y);
  int dist2=ShortPoint2D.getOnGridDist(gravityX - pos2.x,gravityY - pos2.y);
  return dist1 >= dist2 ? pos1 : pos2;
}","/** 
 * @param pos1
 * @param pos2
 * @return The position with the bigger distance to the gravity center of this partition.
 */
public ShortPoint2D getPositionCloserToGravityCenter(ShortPoint2D pos1,ShortPoint2D pos2){
  int gravityY;
  int gravityX;
  if (counter > 0) {
    gravityX=xSum / counter;
    gravityY=ySum / counter;
  }
 else {
    gravityX=0;
    gravityY=0;
  }
  int dist1=ShortPoint2D.getOnGridDist(gravityX - pos1.x,gravityY - pos1.y);
  int dist2=ShortPoint2D.getOnGridDist(gravityX - pos2.x,gravityY - pos2.y);
  return dist1 >= dist2 ? pos1 : pos2;
}"
56375,"public PartitionsGrid(short width,short height,byte numberOfPlayers,IBlockingProvider blockingProvider){
  this.width=width;
  this.height=height;
  this.blockingProvider=blockingProvider;
  this.players=new Player[numberOfPlayers];
  for (byte i=0; i < numberOfPlayers; i++) {
    Team team=new Team(i);
    this.players[i]=new Player(i,team);
  }
  this.partitions=new short[width * height];
  this.towers=new byte[width * height];
  this.partitionObjects[NO_PLAYER_PARTITION_ID]=new Partition((byte)-1,width * height);
  this.partitionRepresentative[NO_PLAYER_PARTITION_ID]=NO_PLAYER_PARTITION_ID;
  initAdditionalFields();
}","public PartitionsGrid(short width,short height,byte numberOfPlayers,IPartitionsGridBlockingProvider blockingProvider){
  this.width=width;
  this.height=height;
  this.blockingProvider=blockingProvider;
  blockingProvider.registerListener(this);
  this.players=new Player[numberOfPlayers];
  for (byte i=0; i < numberOfPlayers; i++) {
    Team team=new Team(i);
    this.players[i]=new Player(i,team);
  }
  this.partitions=new short[width * height];
  this.towers=new byte[width * height];
  this.partitionObjects[NO_PLAYER_PARTITION_ID]=new Partition((byte)-1,width * height);
  this.partitionRepresentative[NO_PLAYER_PARTITION_ID]=NO_PLAYER_PARTITION_ID;
  initAdditionalFields();
}"
56376,"@Override protected void constructionFinishedEvent(){
  placeFlag(true);
}","@Override protected void constructionFinishedEvent(){
}"
56377,"@Override public void timerEvent(){
  if (health <= 0) {
    return;
  }
switch (state) {
case SLEEPING:
    return;
case DOING_NOTHING:
  if (visible && enableNothingToDo) {
    doingNothingAction();
  }
break;
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
progressCurrentAction();
break;
case PATHING:
pathingAction();
break;
}
if (moveToRequest != null) {
switch (state) {
case PATHING:
if (progress < 1) {
break;
}
setState(ENewMovableState.DOING_NOTHING);
case DOING_NOTHING:
ShortPoint2D oldTargetPos;
if (path != null) {
oldTargetPos=path.getTargetPos();
}
 else {
oldTargetPos=null;
}
goToPos(moveToRequest);
moveToRequest=null;
if (path != null) {
this.strategy.moveToPathSet(oldTargetPos,path.getTargetPos());
}
break;
}
}
if (state == ENewMovableState.DOING_NOTHING) {
strategy.action();
}
}","@Override public void timerEvent(){
  if (health <= 0) {
    return;
  }
switch (state) {
case SLEEPING:
    return;
case DOING_NOTHING:
  if (visible && enableNothingToDo) {
    doingNothingAction();
  }
break;
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
progressCurrentAction();
break;
case PATHING:
pathingAction();
break;
default :
break;
}
if (moveToRequest != null) {
switch (state) {
case PATHING:
if (progress < 1) {
break;
}
setState(ENewMovableState.DOING_NOTHING);
case DOING_NOTHING:
ShortPoint2D oldTargetPos;
if (path != null) {
oldTargetPos=path.getTargetPos();
}
 else {
oldTargetPos=null;
}
goToPos(moveToRequest);
moveToRequest=null;
if (path != null) {
this.strategy.moveToPathSet(oldTargetPos,path.getTargetPos());
}
break;
default :
break;
}
}
if (state == ENewMovableState.DOING_NOTHING) {
strategy.action();
}
}"
56378,"private void handleJobFailed(boolean reportAsJobless){
switch (state) {
case INIT_CARRY_JOB:
case GOING_TO_OFFER:
    reoffer();
case TAKING:
  if (targetMovableType != null) {
    workerRequester.workerCreationRequestFailed(targetMovableType,super.getPos());
  }
case GOING_TO_REQUEST:
if (requester != null && requester.isDiggerRequestActive()) {
  requester.requestFailed();
}
break;
case INIT_BECOME_SOLDIER_JOB:
case GOING_TO_BARRACK:
barrack.bearerRequestFailed();
break;
case DROPPING:
break;
case INIT_CONVERT_WITH_TOOL_JOB:
reoffer();
case INIT_CONVERT_JOB:
workerRequester.workerCreationRequestFailed(targetMovableType,super.getPos());
break;
case DEAD_OBJECT:
break;
}
EMaterialType carriedMaterial=super.setMaterial(EMaterialType.NO_MATERIAL);
if (carriedMaterial != EMaterialType.NO_MATERIAL) {
super.getStrategyGrid().dropMaterial(super.getPos(),materialType,true);
}
offer=null;
requester=null;
materialType=null;
targetMovableType=null;
workerRequester=null;
state=EBearerState.JOBLESS;
if (reportAsJobless) {
reportAsJobless();
}
}","private void handleJobFailed(boolean reportAsJobless){
switch (state) {
case INIT_CARRY_JOB:
case GOING_TO_OFFER:
    reoffer();
case TAKING:
  if (targetMovableType != null) {
    workerRequester.workerCreationRequestFailed(targetMovableType,super.getPos());
  }
case GOING_TO_REQUEST:
if (requester != null && requester.isDiggerRequestActive()) {
  requester.requestFailed();
}
break;
case INIT_BECOME_SOLDIER_JOB:
case GOING_TO_BARRACK:
barrack.bearerRequestFailed();
break;
case DROPPING:
break;
case INIT_CONVERT_WITH_TOOL_JOB:
reoffer();
case INIT_CONVERT_JOB:
workerRequester.workerCreationRequestFailed(targetMovableType,super.getPos());
break;
case DEAD_OBJECT:
break;
case JOBLESS:
break;
default :
break;
}
EMaterialType carriedMaterial=super.setMaterial(EMaterialType.NO_MATERIAL);
if (carriedMaterial != EMaterialType.NO_MATERIAL) {
super.getStrategyGrid().dropMaterial(super.getPos(),materialType,true);
}
offer=null;
requester=null;
materialType=null;
targetMovableType=null;
workerRequester=null;
state=EBearerState.JOBLESS;
if (reportAsJobless) {
reportAsJobless();
}
}"
56379,"@Override protected short getSearchDistance(boolean isInTower){
  return isInTower ? Constants.TOWER_SEARCH_RADIUS : Constants.BOWMAN_ATTACK_RADIUS;
}","@Override protected short getSearchDistance(boolean isInTower){
  return isInTower ? Constants.TOWER_SEARCH_RADIUS : Constants.SOLDIER_SEARCH_RADIUS;
}"
56380,"@Override public void leaveOccupyableBuilding(ShortPoint2D newPosition){
  super.setPosition(newPosition);
  super.enableNothingToDoAction(true);
  super.setVisible(true);
  isInTower=false;
  state=ESoldierState.SEARCH_FOR_ENEMIES;
}","@Override public void leaveOccupyableBuilding(ShortPoint2D newPosition){
  super.setPosition(newPosition);
  super.enableNothingToDoAction(true);
  super.setVisible(true);
  isInTower=false;
  changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
}"
56381,"private void changeStateTo(ESoldierState state){
  this.state=state;
switch (state) {
case AGGRESSIVE:
    if (oldPathTarget != null) {
      super.goToPos(oldPathTarget);
      oldPathTarget=null;
    }
  break;
}
}","private void changeStateTo(ESoldierState state){
  this.state=state;
switch (state) {
case AGGRESSIVE:
    if (oldPathTarget != null) {
      super.goToPos(oldPathTarget);
      oldPathTarget=null;
    }
  break;
default :
break;
}
}"
56382,"@Override public void setDefendingAt(ShortPoint2D pos){
  super.setPosition(pos);
  state=ESoldierState.SEARCH_FOR_ENEMIES;
  defending=true;
}","@Override public void setDefendingAt(ShortPoint2D pos){
  super.setPosition(pos);
  changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
  defending=true;
}"
56383,"@Override public void informAboutAttackable(IAttackable other){
  if (state == ESoldierState.AGGRESSIVE && (!isInTower || getSoldierType() == ESoldierType.BOWMAN)) {
    state=ESoldierState.SEARCH_FOR_ENEMIES;
  }
}","@Override public void informAboutAttackable(IAttackable other){
  if (state == ESoldierState.AGGRESSIVE && (!isInTower || getSoldierType() == ESoldierType.BOWMAN)) {
    changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
  }
}"
56384,"@Override public void setOccupyableBuilding(IOccupyableBuilding building){
  this.building=building;
  this.state=ESoldierState.INIT_GOTO_TOWER;
  super.abortPath();
  this.oldPathTarget=null;
}","@Override public void setOccupyableBuilding(IOccupyableBuilding building){
  this.building=building;
  changeStateTo(ESoldierState.INIT_GOTO_TOWER);
  super.abortPath();
  this.oldPathTarget=null;
}"
56385,"@Override protected void action(){
switch (state) {
case AGGRESSIVE:
    break;
case HITTING:
  hitEnemy(enemy);
if (enemy.getHealth() <= 0) {
  enemy=null;
  state=ESoldierState.SEARCH_FOR_ENEMIES;
  break;
}
case SEARCH_FOR_ENEMIES:
IAttackable oldEnemy=enemy;
enemy=super.getStrategyGrid().getEnemyInSearchArea(getAttackPosition(),super.getMovable(),getSearchDistance(isInTower));
if (oldEnemy != null && oldEnemy != enemy) {
inSaveGotoMode=false;
}
if (enemy == null) {
if (defending) {
building.towerDefended(this);
defending=false;
}
changeStateTo(ESoldierState.AGGRESSIVE);
break;
}
if (isEnemyAttackable(enemy,isInTower)) {
super.lookInDirection(EDirection.getApproxDirection(super.getPos(),enemy.getPos()));
startAttackAnimation(enemy);
state=ESoldierState.HITTING;
}
 else if (!isInTower) {
state=ESoldierState.SEARCH_FOR_ENEMIES;
goToEnemy(enemy);
}
break;
case INIT_GOTO_TOWER:
super.goToPos(building.getDoor());
state=ESoldierState.GOING_TO_TOWER;
break;
case GOING_TO_TOWER:
if (building.isNotDestroyed() && building.getPlayer() == super.getPlayer()) {
OccupyerPlace place=building.addSoldier(this);
super.setPosition(place.getPosition().calculatePoint(building.getDoor()));
super.enableNothingToDoAction(false);
super.setVisible(false);
if (isBowman()) {
this.inTowerAttackPosition=building.getTowerBowmanSearchPosition(place);
}
state=ESoldierState.AGGRESSIVE;
isInTower=true;
}
 else {
state=ESoldierState.SEARCH_FOR_ENEMIES;
}
break;
}
}","@Override protected void action(){
switch (state) {
case AGGRESSIVE:
    break;
case HITTING:
  hitEnemy(enemy);
if (enemy.getHealth() <= 0) {
  enemy=null;
  changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
  break;
}
case SEARCH_FOR_ENEMIES:
IAttackable oldEnemy=enemy;
enemy=super.getStrategyGrid().getEnemyInSearchArea(getAttackPosition(),super.getMovable(),getSearchDistance(isInTower));
if (oldEnemy != null && oldEnemy != enemy) {
inSaveGotoMode=false;
}
if (enemy == null) {
if (defending) {
building.towerDefended(this);
defending=false;
}
changeStateTo(ESoldierState.AGGRESSIVE);
break;
}
if (isEnemyAttackable(enemy,isInTower)) {
super.lookInDirection(EDirection.getApproxDirection(super.getPos(),enemy.getPos()));
startAttackAnimation(enemy);
changeStateTo(ESoldierState.HITTING);
}
 else if (!isInTower) {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
goToEnemy(enemy);
}
break;
case INIT_GOTO_TOWER:
super.goToPos(building.getDoor());
changeStateTo(ESoldierState.GOING_TO_TOWER);
break;
case GOING_TO_TOWER:
if (building.isNotDestroyed() && building.getPlayer() == super.getPlayer()) {
OccupyerPlace place=building.addSoldier(this);
super.setPosition(place.getPosition().calculatePoint(building.getDoor()));
super.enableNothingToDoAction(false);
super.setVisible(false);
if (isBowman()) {
this.inTowerAttackPosition=building.getTowerBowmanSearchPosition(place);
}
changeStateTo(ESoldierState.AGGRESSIVE);
isInTower=true;
}
 else {
changeStateTo(ESoldierState.SEARCH_FOR_ENEMIES);
}
break;
}
}"
56386,"public void write() throws IOException {
  DataOutputStream out=new DataOutputStream(new FileOutputStream(file));
  shortBuffer.rewind();
  while (shortBuffer.hasRemaining()) {
    out.writeShort(shortBuffer.get());
  }
}","public void write() throws IOException {
  DataOutputStream out=new DataOutputStream(new FileOutputStream(file));
  shortBuffer.rewind();
  while (shortBuffer.hasRemaining()) {
    out.writeShort(shortBuffer.get());
  }
  out.close();
}"
56387,"@Override public void action(Action action){
switch (action.getActionType()) {
case MOVE_TO:
    movable.moveTo(((MoveToAction)action).getPosition());
  break;
case SPEED_FASTER:
NetworkTimer.multiplyGameSpeed(1.2f);
break;
case SPEED_SLOWER:
NetworkTimer.multiplyGameSpeed(1 / 1.2f);
break;
case FAST_FORWARD:
NetworkTimer.get().fastForward();
break;
}
}","@Override public void action(Action action){
switch (action.getActionType()) {
case MOVE_TO:
    movable.moveTo(((MoveToAction)action).getPosition());
  break;
case SPEED_FASTER:
NetworkTimer.multiplyGameSpeed(1.2f);
break;
case SPEED_SLOWER:
NetworkTimer.multiplyGameSpeed(1 / 1.2f);
break;
case FAST_FORWARD:
NetworkTimer.get().fastForward();
break;
default :
break;
}
}"
56388,"private MovableTestWindow() throws InterruptedException {
  NetworkTimer.get().schedule();
  RandomSingleton.load(1000);
  MovableTestsMap grid=new MovableTestsMap(100,100);
  MapInterfaceConnector connector=TestWindow.openTestWindow(grid);
  movable=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(49,50),(byte)0);
  movable.setSelected(true);
  connector.setSelection(new SelectionSet(movable));
  connector.addListener(new IMapInterfaceListener(){
    @Override public void action(    Action action){
switch (action.getActionType()) {
case MOVE_TO:
        movable.moveTo(((MoveToAction)action).getPosition());
      break;
case SPEED_FASTER:
    NetworkTimer.multiplyGameSpeed(1.2f);
  break;
case SPEED_SLOWER:
NetworkTimer.multiplyGameSpeed(1 / 1.2f);
break;
case FAST_FORWARD:
NetworkTimer.get().fastForward();
break;
}
}
}
);
grid.getMovableGrid().dropMaterial(new ShortPoint2D(40,40),EMaterialType.PLANK,true);
grid.getMovableGrid().dropMaterial(new ShortPoint2D(60,60),EMaterialType.STONE,true);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(30,30),(byte)0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(31,31),(byte)0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(32,32),(byte)0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(33,33),(byte)0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(50,50),(byte)0);
{
for (int x=30; x < 40; x++) {
for (int y=80; y < 90; y++) {
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(x,y),(byte)0);
}
}
}
{
Thread.sleep(3000);
NewMovable m1=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(50,65),(byte)0);
NewMovable m2=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(51,65),(byte)0);
NewMovable m3=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(50,64),(byte)0);
m1.moveTo(new ShortPoint2D(52,65));
m2.moveTo(new ShortPoint2D(49,63));
m3.moveTo(new ShortPoint2D(50,66));
}
}","private MovableTestWindow() throws InterruptedException {
  NetworkTimer.get().schedule();
  RandomSingleton.load(1000);
  MovableTestsMap grid=new MovableTestsMap(100,100);
  MapInterfaceConnector connector=TestWindow.openTestWindow(grid);
  movable=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(49,50),(byte)0);
  movable.setSelected(true);
  connector.setSelection(new SelectionSet(movable));
  connector.addListener(new IMapInterfaceListener(){
    @Override public void action(    Action action){
switch (action.getActionType()) {
case MOVE_TO:
        movable.moveTo(((MoveToAction)action).getPosition());
      break;
case SPEED_FASTER:
    NetworkTimer.multiplyGameSpeed(1.2f);
  break;
case SPEED_SLOWER:
NetworkTimer.multiplyGameSpeed(1 / 1.2f);
break;
case FAST_FORWARD:
NetworkTimer.get().fastForward();
break;
default :
break;
}
}
}
);
grid.getMovableGrid().dropMaterial(new ShortPoint2D(40,40),EMaterialType.PLANK,true);
grid.getMovableGrid().dropMaterial(new ShortPoint2D(60,60),EMaterialType.STONE,true);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(30,30),(byte)0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(31,31),(byte)0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(32,32),(byte)0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(33,33),(byte)0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(50,50),(byte)0);
{
for (int x=30; x < 40; x++) {
for (int y=80; y < 90; y++) {
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(x,y),(byte)0);
}
}
}
{
Thread.sleep(3000);
NewMovable m1=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(50,65),(byte)0);
NewMovable m2=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(51,65),(byte)0);
NewMovable m3=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(50,64),(byte)0);
m1.moveTo(new ShortPoint2D(52,65));
m2.moveTo(new ShortPoint2D(49,63));
m3.moveTo(new ShortPoint2D(50,66));
}
}"
56389,"@Override public EMovableType popWeaponForBearer(){
  for (  RequestStack stack : super.getStacks()) {
    if (stack.getMaterialType() == EMaterialType.BOW || stack.getMaterialType() == EMaterialType.SWORD || stack.getMaterialType() == EMaterialType.SPEAR) {
      stack.pop();
      requestedBearer--;
      return getSoldierType(stack.getMaterialType());
    }
  }
  return null;
}","@Override public EMovableType popWeaponForBearer(){
  List<RequestStack> stacks=super.getStacks();
  for (  RequestStack stack : stacks) {
    if (stack.getMaterialType() == EMaterialType.BOW || stack.getMaterialType() == EMaterialType.SWORD || stack.getMaterialType() == EMaterialType.SPEAR) {
      if (stack.hasMaterial()) {
        stack.pop();
        requestedBearer--;
        return getSoldierType(stack.getMaterialType());
      }
    }
  }
  return null;
}"
56390,"@Override protected void action(){
  if (isJobless())   return;
  if (!building.isNotDestroyed()) {
    buildingDestroyed();
    return;
  }
switch (currentJob.getType()) {
case GO_TO:
    gotoAction();
  break;
case IS_PRODUCTIVE:
if (isProductive()) {
  jobFinished();
}
 else {
  jobFailed();
}
break;
case WAIT:
waitSeconds();
break;
case WALK:
super.forceGoInDirection(currentJob.getDirection());
jobFinished();
break;
case SHOW:
ShortPoint2D pos=getCurrentJobPos();
super.setPosition(pos);
super.setVisible(true);
jobFinished();
break;
case HIDE:
super.setVisible(false);
jobFinished();
break;
case SET_MATERIAL:
super.setMaterial(currentJob.getMaterial());
jobFinished();
break;
case TAKE:
takeAction();
break;
case REMOTETAKE:
if (this.building.popMaterial(getCurrentJobPos(),currentJob.getMaterial())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case DROP:
dropAction(currentJob.getMaterial());
break;
case DROP_POPPED:
dropAction(poppedMaterial);
break;
case PRE_SEARCH:
preSearchPathAction(true);
break;
case PRE_SEARCH_IN_AREA:
preSearchPathAction(false);
break;
case FOLLOW_SEARCHED:
followPreSearchedAction();
break;
case LOOK_AT_SEARCHED:
lookAtSearched();
break;
case LOOK_AT:
super.lookInDirection(currentJob.getDirection());
jobFinished();
break;
case EXECUTE:
executeAction();
break;
case PLAY_ACTION1:
super.playAction(EAction.ACTION1,currentJob.getTime());
jobFinished();
break;
case PLAY_ACTION2:
super.playAction(EAction.ACTION2,currentJob.getTime());
jobFinished();
break;
case AVAILABLE:
if (super.getStrategyGrid().canPop(getCurrentJobPos(),currentJob.getMaterial())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case NOT_FULL:
if (super.getStrategyGrid().canPushMaterial(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case SMOKE_ON:
case SMOKE_OFF:
{
super.getStrategyGrid().placeSmoke(getCurrentJobPos(),currentJob.getType() == EBuildingJobType.SMOKE_ON);
jobFinished();
break;
}
case START_WORKING:
case STOP_WORKING:
if (building instanceof MillBuilding) {
((MillBuilding)building).setRotating(currentJob.getType() == EBuildingJobType.START_WORKING);
}
jobFinished();
break;
case PIG_IS_ADULT:
if (super.getStrategyGrid().isPigAdult(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_IS_THERE:
if (super.getStrategyGrid().hasPigAt(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_PLACE:
case PIG_REMOVE:
placeOrRemovePigAction();
break;
case POP_TOOL:
popToolRequestAction();
break;
}
}","@Override protected void action(){
  if (isJobless())   return;
  if (!building.isNotDestroyed()) {
    buildingDestroyed();
    return;
  }
switch (currentJob.getType()) {
case GO_TO:
    gotoAction();
  break;
case IS_PRODUCTIVE:
if (isProductive()) {
  jobFinished();
}
 else {
  jobFailed();
}
break;
case WAIT:
waitSeconds();
break;
case WALK:
super.forceGoInDirection(currentJob.getDirection());
jobFinished();
break;
case SHOW:
ShortPoint2D pos=getCurrentJobPos();
super.setPosition(pos);
super.setVisible(true);
jobFinished();
break;
case HIDE:
super.setVisible(false);
jobFinished();
break;
case SET_MATERIAL:
super.setMaterial(currentJob.getMaterial());
jobFinished();
break;
case TAKE:
takeAction();
break;
case REMOTETAKE:
if (this.building.popMaterial(getCurrentJobPos(),currentJob.getMaterial())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case DROP:
dropAction(currentJob.getMaterial());
break;
case DROP_POPPED:
dropAction(poppedMaterial);
break;
case PRE_SEARCH:
preSearchPathAction(true);
break;
case PRE_SEARCH_IN_AREA:
preSearchPathAction(false);
break;
case FOLLOW_SEARCHED:
followPreSearchedAction();
break;
case LOOK_AT_SEARCHED:
lookAtSearched();
break;
case LOOK_AT:
super.lookInDirection(currentJob.getDirection());
jobFinished();
break;
case EXECUTE:
executeAction();
break;
case PLAY_ACTION1:
super.playAction(EAction.ACTION1,currentJob.getTime());
jobFinished();
break;
case PLAY_ACTION2:
super.playAction(EAction.ACTION2,currentJob.getTime());
jobFinished();
break;
case AVAILABLE:
if (super.getStrategyGrid().canPop(getCurrentJobPos(),currentJob.getMaterial())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case NOT_FULL:
if (super.getStrategyGrid().canPushMaterial(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case SMOKE_ON:
case SMOKE_OFF:
{
super.getStrategyGrid().placeSmoke(getCurrentJobPos(),currentJob.getType() == EBuildingJobType.SMOKE_ON);
jobFinished();
break;
}
case START_WORKING:
case STOP_WORKING:
if (building instanceof MillBuilding) {
((MillBuilding)building).setRotating(currentJob.getType() == EBuildingJobType.START_WORKING);
}
jobFinished();
break;
case PIG_IS_ADULT:
if (super.getStrategyGrid().isPigAdult(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_IS_THERE:
if (super.getStrategyGrid().hasPigAt(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_PLACE:
case PIG_REMOVE:
placeOrRemovePigAction();
break;
case POP_TOOL:
popToolRequestAction();
break;
case POP_WEAPON:
popWeaponRequestAction();
break;
}
}"
56391,"private boolean isProductive(){
switch (building.getBuildingType()) {
case FISHER:
    return hasProductiveResources(super.getPos(),EResourceType.FISH);
case COALMINE:
  return hasProductiveResources(building.getDoor(),EResourceType.COAL);
case IRONMINE:
return hasProductiveResources(building.getDoor(),EResourceType.IRON);
case GOLDMINE:
return hasProductiveResources(building.getDoor(),EResourceType.GOLD);
}
return false;
}","private boolean isProductive(){
switch (building.getBuildingType()) {
case FISHER:
    EDirection fishDirection=super.getStrategyGrid().getDirectionOfSearched(super.getPos(),ESearchType.FISHABLE);
  if (fishDirection != null) {
    return hasProductiveResources(fishDirection.getNextHexPoint(super.getPos()),EResourceType.FISH);
  }
 else {
    return false;
  }
case COALMINE:
return hasProductiveResources(building.getDoor(),EResourceType.COAL);
case IRONMINE:
return hasProductiveResources(building.getDoor(),EResourceType.IRON);
case GOLDMINE:
return hasProductiveResources(building.getDoor(),EResourceType.GOLD);
default :
return false;
}
}"
56392,"@Override public final int getDebugColorAt(int x,int y){
  short value=(short)(partitionsGrid.getPartitionAt((short)x,(short)y) + 1);
  return Color.getARGB((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
}","@Override public final int getDebugColorAt(int x,int y){
  return landscapeGrid.getDebugColor(x,y);
}"
56393,"private final void checkLandmarks(ShortPoint2D startPos){
  short startX=startPos.getX();
  short startY=startPos.getY();
  if (grid.isBlocked(startX,startY))   return;
  short startPartition=grid.getPartitionAt(startPos.getX(),startPos.getY());
  for (  EDirection currDir : EDirection.values) {
    short currX=(short)(startX + currDir.gridDeltaX);
    short currY=(short)(startY + currDir.gridDeltaY);
    if (grid.isBlocked(currX,currY)) {
      if (needsRelabel(currX,currY,startPartition)) {
        System.out.println(""String_Node_Str"" + currX + ""String_Node_Str""+ currY+ ""String_Node_Str""+ startPartition);
        relabel(grid.getBlockedPartition(startX,startY),currX,currY,startPartition);
      }
    }
  }
}","private final void checkLandmarks(ShortPoint2D startPos){
  final short startX=startPos.getX();
  final short startY=startPos.getY();
  if (grid.isBlocked(startX,startY))   return;
  short startPartition=grid.getPartitionAt(startPos.getX(),startPos.getY());
  for (  EDirection currDir : EDirection.values) {
    short currX=(short)(startX + currDir.gridDeltaX);
    short currY=(short)(startY + currDir.gridDeltaY);
    if (grid.isBlocked(currX,currY)) {
      if (needsRelabel(currX,currY,startPartition)) {
        System.out.println(""String_Node_Str"" + currX + ""String_Node_Str""+ currY+ ""String_Node_Str""+ startPartition);
        relabel(grid.getBlockedPartition(startX,startY),currX,currY,startPartition);
      }
    }
  }
}"
56394,"@Override public final Path findPath(IPathCalculateable requester,final short sx,final short sy,final short tx,final short ty){
  final boolean blockedAtStart;
  if (!isInBounds(sx,sy)) {
    throw new InvalidStartPositionException(""String_Node_Str"",sx,sy);
  }
 else   if (!isInBounds(tx,ty) || isBlocked(requester,tx,ty)) {
    return null;
  }
 else   if (sx == tx && sy == ty) {
    return null;
  }
 else   if (isBlocked(requester,sx,sy)) {
    blockedAtStart=true;
  }
 else {
    blockedAtStart=false;
  }
  float temp=xFactor;
  xFactor=yFactor;
  yFactor=temp;
  final int targetFlatIdx=getFlatIdx(tx,ty);
  closedList.clear();
  openList.clear();
  open.clear();
  boolean found=false;
  initStartNode(sx,sy,tx,ty);
  while (!open.isEmpty()) {
    int currFlatIdx=open.deleteMin();
    short x=getX(currFlatIdx);
    short y=getY(currFlatIdx);
    setClosed(x,y);
    if (targetFlatIdx == currFlatIdx) {
      found=true;
      break;
    }
    for (int i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
      short neighborX=(short)(x + xDeltaArray[i]);
      short neighborY=(short)(y + yDeltaArray[i]);
      if (isValidPosition(requester,neighborX,neighborY,blockedAtStart)) {
        int flatNeighborIdx=getFlatIdx(neighborX,neighborY);
        if (!closedList.get(flatNeighborIdx)) {
          float newCosts=costsAndHeuristics[getCostsIdx(currFlatIdx)] + map.getCost(x,y,neighborX,neighborY);
          if (openList.get(flatNeighborIdx)) {
            if (costsAndHeuristics[getCostsIdx(flatNeighborIdx)] > newCosts) {
              costsAndHeuristics[getCostsIdx(flatNeighborIdx)]=newCosts;
              depthParentHeap[getDepthIdx(flatNeighborIdx)]=depthParentHeap[getDepthIdx(currFlatIdx)] + 1;
              depthParentHeap[getParentIdx(flatNeighborIdx)]=currFlatIdx;
              open.siftUp(flatNeighborIdx);
            }
          }
 else {
            costsAndHeuristics[getCostsIdx(flatNeighborIdx)]=newCosts;
            costsAndHeuristics[getHeuristicIdx(flatNeighborIdx)]=getHeuristicCost(neighborX,neighborY,tx,ty);
            depthParentHeap[getDepthIdx(flatNeighborIdx)]=depthParentHeap[getDepthIdx(currFlatIdx)] + 1;
            depthParentHeap[getParentIdx(flatNeighborIdx)]=currFlatIdx;
            openList.set(flatNeighborIdx);
            open.insert(flatNeighborIdx);
            map.markAsOpen(neighborX,neighborY);
          }
        }
      }
    }
  }
  if (found) {
    int pathlength=depthParentHeap[getDepthIdx(getFlatIdx(tx,ty))];
    Path path=new Path(pathlength);
    int idx=pathlength;
    int parentFlatIdx=targetFlatIdx;
    while (idx > 0) {
      idx--;
      path.insertAt(idx,getX(parentFlatIdx),getY(parentFlatIdx));
      parentFlatIdx=depthParentHeap[getParentIdx(parentFlatIdx)];
    }
    path.initPath();
    return path;
  }
  return null;
}","@Override public final Path findPath(IPathCalculateable requester,final short sx,final short sy,final short tx,final short ty){
  final boolean blockedAtStart;
  if (!isInBounds(sx,sy)) {
    throw new InvalidStartPositionException(""String_Node_Str"",sx,sy);
  }
 else   if (!isInBounds(tx,ty) || isBlocked(requester,tx,ty) || map.getBlockedPartition(sx,sy) != map.getBlockedPartition(tx,ty)) {
    return null;
  }
 else   if (sx == tx && sy == ty) {
    return null;
  }
 else   if (isBlocked(requester,sx,sy)) {
    blockedAtStart=true;
  }
 else {
    blockedAtStart=false;
  }
  float temp=xFactor;
  xFactor=yFactor;
  yFactor=temp;
  final int targetFlatIdx=getFlatIdx(tx,ty);
  closedList.clear();
  openList.clear();
  open.clear();
  boolean found=false;
  initStartNode(sx,sy,tx,ty);
  while (!open.isEmpty()) {
    int currFlatIdx=open.deleteMin();
    short x=getX(currFlatIdx);
    short y=getY(currFlatIdx);
    setClosed(x,y);
    if (targetFlatIdx == currFlatIdx) {
      found=true;
      break;
    }
    for (int i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
      short neighborX=(short)(x + xDeltaArray[i]);
      short neighborY=(short)(y + yDeltaArray[i]);
      if (isValidPosition(requester,neighborX,neighborY,blockedAtStart)) {
        int flatNeighborIdx=getFlatIdx(neighborX,neighborY);
        if (!closedList.get(flatNeighborIdx)) {
          float newCosts=costsAndHeuristics[getCostsIdx(currFlatIdx)] + map.getCost(x,y,neighborX,neighborY);
          if (openList.get(flatNeighborIdx)) {
            if (costsAndHeuristics[getCostsIdx(flatNeighborIdx)] > newCosts) {
              costsAndHeuristics[getCostsIdx(flatNeighborIdx)]=newCosts;
              depthParentHeap[getDepthIdx(flatNeighborIdx)]=depthParentHeap[getDepthIdx(currFlatIdx)] + 1;
              depthParentHeap[getParentIdx(flatNeighborIdx)]=currFlatIdx;
              open.siftUp(flatNeighborIdx);
            }
          }
 else {
            costsAndHeuristics[getCostsIdx(flatNeighborIdx)]=newCosts;
            costsAndHeuristics[getHeuristicIdx(flatNeighborIdx)]=getHeuristicCost(neighborX,neighborY,tx,ty);
            depthParentHeap[getDepthIdx(flatNeighborIdx)]=depthParentHeap[getDepthIdx(currFlatIdx)] + 1;
            depthParentHeap[getParentIdx(flatNeighborIdx)]=currFlatIdx;
            openList.set(flatNeighborIdx);
            open.insert(flatNeighborIdx);
            map.markAsOpen(neighborX,neighborY);
          }
        }
      }
    }
  }
  if (found) {
    int pathlength=depthParentHeap[getDepthIdx(getFlatIdx(tx,ty))];
    Path path=new Path(pathlength);
    int idx=pathlength;
    int parentFlatIdx=targetFlatIdx;
    while (idx > 0) {
      idx--;
      path.insertAt(idx,getX(parentFlatIdx),getY(parentFlatIdx));
      parentFlatIdx=depthParentHeap[getParentIdx(parentFlatIdx)];
    }
    path.initPath();
    return path;
  }
  return null;
}"
56395,"public void calculatePartitions(){
  for (int y=0; y < height; y++) {
    for (int x=0; x < width; x++) {
      int index=x + y * width;
      if (containing.get(index) ^ invertBitSet) {
        int westX=x + neighborX[0];
        int westY=y + neighborY[0];
        int northWestX=x + neighborX[1];
        int northWestY=y + neighborY[1];
        int northEastX=x + neighborX[2];
        int northEastY=y + neighborY[2];
        int partition=-1;
        int westPartition=-1;
        if (containing.get(westX + westY * width) ^ invertBitSet) {
          westPartition=partitionsGrid[westX + westY * width];
          partition=westPartition;
        }
        if (containing.get(northWestX + northWestY * width) ^ invertBitSet) {
          partition=partitionsGrid[northWestX + northWestY * width];
        }
        int northEastPartition=-1;
        if (containing.get(northEastX + northEastY * width) ^ invertBitSet) {
          northEastPartition=partitionsGrid[northEastX + northEastY * width];
          partition=northEastPartition;
        }
        if (westPartition != -1 && northEastPartition != -1 && partitions[westPartition] != partitions[northEastPartition]) {
          short newPartition=(short)Math.min(partitions[westPartition],partitions[northEastPartition]);
          partitions[westPartition]=newPartition;
          partitions[northEastPartition]=newPartition;
          partitionsGrid[index]=newPartition;
        }
 else         if (partition != -1) {
          partitionsGrid[index]=partitions[partition];
        }
 else {
          partitionsGrid[index]=nextFreePartition;
          partitions[nextFreePartition]=nextFreePartition;
          partitionBorderPositions[nextFreePartition]=new ShortPoint2D(x + minX,y + minY);
          nextFreePartition++;
          if (nextFreePartition >= partitions.length) {
            short[] oldPartitions=partitions;
            partitions=new short[oldPartitions.length * INCREASE_FACTOR];
            System.arraycopy(oldPartitions,0,partitions,0,oldPartitions.length);
            ShortPoint2D[] oldBorderPositions=partitionBorderPositions;
            partitionBorderPositions=new ShortPoint2D[oldBorderPositions.length * INCREASE_FACTOR];
            System.arraycopy(oldBorderPositions,0,partitionBorderPositions,0,oldBorderPositions.length);
          }
        }
      }
    }
  }
  short[] compacted=new short[partitions.length];
  short compactedCount=0;
  for (short i=1; i < nextFreePartition; i++) {
    short representative=i;
    short nextRep;
    while (representative != (nextRep=partitions[representative])) {
      representative=nextRep;
    }
    if (compacted[representative] == 0) {
      compacted[representative]=++compactedCount;
      partitionBorderPositions[compactedCount]=partitionBorderPositions[representative];
    }
    partitions[i]=representative;
    compacted[i]=compacted[representative];
  }
  partitions=compacted;
  neededPartitions=compactedCount;
}","/** 
 * Calculates the partitions. <br> The results can be accessed with the supplied getter methods.
 */
public void calculatePartitions(){
  for (int y=0; y < height; y++) {
    for (int x=0; x < width; x++) {
      int index=x + y * width;
      if (containing.get(index) ^ invertBitSet) {
        int westX=x + neighborX[0];
        int westY=y + neighborY[0];
        int northWestX=x + neighborX[1];
        int northWestY=y + neighborY[1];
        int northEastX=x + neighborX[2];
        int northEastY=y + neighborY[2];
        int partition=-1;
        int westPartition=-1;
        if (containing.get(westX + westY * width) ^ invertBitSet) {
          westPartition=partitionsGrid[westX + westY * width];
          partition=westPartition;
        }
        if (containing.get(northWestX + northWestY * width) ^ invertBitSet) {
          partition=partitionsGrid[northWestX + northWestY * width];
        }
        int northEastPartition=-1;
        if (containing.get(northEastX + northEastY * width) ^ invertBitSet) {
          northEastPartition=partitionsGrid[northEastX + northEastY * width];
          partition=northEastPartition;
        }
        if (westPartition != -1 && northEastPartition != -1 && partitions[westPartition] != partitions[northEastPartition]) {
          short newPartition=(short)Math.min(partitions[westPartition],partitions[northEastPartition]);
          partitions[westPartition]=newPartition;
          partitions[northEastPartition]=newPartition;
          partitionsGrid[index]=newPartition;
        }
 else         if (partition != -1) {
          partitionsGrid[index]=partitions[partition];
        }
 else {
          partitionsGrid[index]=nextFreePartition;
          partitions[nextFreePartition]=nextFreePartition;
          partitionBorderPositions[nextFreePartition]=new ShortPoint2D(x + minX,y + minY);
          nextFreePartition++;
          if (nextFreePartition >= partitions.length) {
            short[] oldPartitions=partitions;
            partitions=new short[oldPartitions.length * INCREASE_FACTOR];
            System.arraycopy(oldPartitions,0,partitions,0,oldPartitions.length);
            ShortPoint2D[] oldBorderPositions=partitionBorderPositions;
            partitionBorderPositions=new ShortPoint2D[oldBorderPositions.length * INCREASE_FACTOR];
            System.arraycopy(oldBorderPositions,0,partitionBorderPositions,0,oldBorderPositions.length);
          }
        }
      }
    }
  }
  short[] compacted=new short[partitions.length];
  short compactedCount=0;
  for (short i=1; i < nextFreePartition; i++) {
    short representative=i;
    short nextRep;
    while (representative != (nextRep=partitions[representative])) {
      representative=nextRep;
    }
    if (compacted[representative] == 0) {
      compacted[representative]=++compactedCount;
      partitionBorderPositions[compactedCount]=partitionBorderPositions[representative];
    }
    partitions[i]=representative;
    compacted[i]=compacted[representative];
  }
  partitions=compacted;
  neededPartitions=compactedCount;
}"
56396,"public PartitionCalculatorAlgorithm(int minX,int minY,int width,int height,BitSet containing,boolean invertBitSet){
  this.minX=minX;
  this.minY=minY;
  this.width=width;
  this.height=height;
  this.containing=containing;
  this.invertBitSet=invertBitSet;
  this.partitionsGrid=new short[width * height];
}","/** 
 * Creates a new   {@link PartitionCalculatorAlgorithm}. The given   {@link BitSet} defines the positions that need to be in the partitions and theones that mustn't.
 * @param minX The x offset of the  {@link BitSet}.
 * @param minY The y offset of the  {@link BitSet}.
 * @param width The width of the grid defined by the  {@link BitSet}.
 * @param height The height of the grid defined by the  {@link BitSet}.
 * @param containing The  {@link BitSet} defining the positions in the partitions and the ones not. <br>NOTE: The  {@link BitSet} must be indexed with x + y * width
 * @param invertBitSet If false: all positions returning TRUE are seen as in the partitions.<br> If true: all positions returning FALSE are seen as in the partitions.
 */
public PartitionCalculatorAlgorithm(int minX,int minY,int width,int height,BitSet containing,boolean invertBitSet){
  this.minX=minX;
  this.minY=minY;
  this.width=width;
  this.height=height;
  this.containing=containing;
  this.invertBitSet=invertBitSet;
  this.partitionsGrid=new short[width * height];
}"
56397,"protected Buffer getBuffer(int texture){
  for (int i=0; i < BUFFERS; i++) {
    if (drawBuffers[i].currentTexture == texture) {
      return drawBuffers[i];
    }
  }
  lastFreedBuffer++;
  if (lastFreedBuffer >= BUFFERS) {
    lastFreedBuffer=0;
  }
  Buffer buffer=drawBuffers[lastFreedBuffer];
  buffer.setForTexture(texture);
  return buffer;
}","public Buffer getBuffer(int texture){
  for (int i=0; i < BUFFERS; i++) {
    if (drawBuffers[i].currentTexture == texture) {
      return drawBuffers[i];
    }
  }
  lastFreedBuffer++;
  if (lastFreedBuffer >= BUFFERS) {
    lastFreedBuffer=0;
  }
  Buffer buffer=drawBuffers[lastFreedBuffer];
  buffer.setForTexture(texture);
  return buffer;
}"
56398,"private void drawWithConstructionMask(int x,int y,float maskState,Image unsafeimage,float color){
  if (!(unsafeimage instanceof SingleImage)) {
    return;
  }
  context.beginTileContext(x,y);
  SingleImage image=(SingleImage)unsafeimage;
  int tiles=6;
  float toplineBottom=(int)(maskState * image.getHeight()) / (float)image.getHeight();
  float toplineTop=Math.min(1,toplineBottom + .1f);
  float[] tris=new float[(tiles + 2) * 3 * 5];
  addPointToArray(tris,0,0,0,image);
  addPointToArray(tris,1,1,0,image);
  addPointToArray(tris,2,0,toplineBottom,image);
  addPointToArray(tris,3,1,0,image);
  addPointToArray(tris,4,1,toplineBottom,image);
  addPointToArray(tris,5,0,toplineBottom,image);
  for (int i=0; i < tiles; i++) {
    addPointToArray(tris,6 + i * 3,1.0f / tiles * i,toplineBottom,image);
    addPointToArray(tris,7 + i * 3,1.0f / tiles * (i + 1),toplineBottom,image);
    addPointToArray(tris,8 + i * 3,1.0f / tiles * (i + .5f),toplineTop,image);
  }
  GLDrawContext gl=context.getGl();
  gl.color(color,color,color,1);
  gl.drawTrianglesWithTexture(image.getTextureIndex(gl),tris);
  context.endTileContext();
}","private void drawWithConstructionMask(int x,int y,float maskState,Image unsafeimage,float color){
  if (!(unsafeimage instanceof SingleImage)) {
    return;
  }
  int height=context.getHeight(x,y);
  float viewX=context.getConverter().getViewX(x,y,height);
  float viewY=context.getConverter().getViewY(x,y,height);
  int iColor=Color.getABGR(color,color,color,1);
  SingleImage image=(SingleImage)unsafeimage;
  int tiles=6;
  float toplineBottom=1 - maskState;
  float toplineTop=Math.max(0,toplineBottom - .1f);
  image.drawTriangle(context.getGl(),buffer,viewX,viewY,0,1,1,1,0,toplineBottom,iColor);
  image.drawTriangle(context.getGl(),buffer,viewX,viewY,1,1,1,toplineBottom,0,toplineBottom,iColor);
  for (int i=0; i < tiles; i++) {
    image.drawTriangle(context.getGl(),buffer,viewX,viewY,1.0f / tiles * i,toplineBottom,1.0f / tiles * (i + 1),toplineBottom,1.0f / tiles * (i + .5f),toplineTop,iColor);
  }
}"
56399,"/** 
 * Draws a map object at a given position.
 * @param context The context.
 * @param map For these damned arrwos
 * @param pos THe position to draw the object.
 * @param object The object (tree, ...) to draw.
 */
public void drawMapObject(IGraphicsGrid map,int x,int y,IMapObject object){
  byte fogstatus=context.getVisibleStatus(x,y);
  if (fogstatus == 0) {
    return;
  }
  float color=getColor(fogstatus);
  EMapObjectType type=object.getObjectType();
  float progress=object.getStateProgress();
  if (type == EMapObjectType.ARROW) {
    drawArrow(context,(IArrowMapObject)object,color);
  }
 else {
switch (type) {
case TREE_ADULT:
      if (context.ENABLE_ORIGINAL) {
        drawTree(x,y,color);
      }
 else {
        drawTreeTest(x,y,color);
      }
    break;
case TREE_DEAD:
  playSound(object,4);
drawFallingTree(x,y,progress,color);
break;
case TREE_GROWING:
drawGrowingTree(x,y,progress,color);
break;
case CORN_GROWING:
drawGrowingCorn(x,y,object,color);
break;
case CORN_ADULT:
drawCorn(x,y,color);
break;
case CORN_DEAD:
drawDeadCorn(x,y,color);
break;
case WAVES:
drawWaves(x,y,color);
break;
case STONE:
drawStones(x,y,object,color);
break;
case GHOST:
drawPlayerableByProgress(x,y,12,27,object,color);
playSound(object,35);
break;
case BUILDING_DECONSTRUCTION_SMOKE:
drawByProgress(x,y,13,38,object.getStateProgress(),color);
playSound(object,35);
break;
case FOUND_COAL:
drawByProgress(x,y,FILE,94,object.getStateProgress(),color);
break;
case FOUND_GEMSTONE:
drawByProgress(x,y,FILE,95,object.getStateProgress(),color);
break;
case FOUND_GOLD:
drawByProgress(x,y,FILE,96,object.getStateProgress(),color);
break;
case FOUND_IRON:
drawByProgress(x,y,FILE,97,object.getStateProgress(),color);
break;
case FOUND_BRIMSTONE:
drawByProgress(x,y,FILE,98,object.getStateProgress(),color);
break;
case FOUND_NOTHING:
drawByProgress(x,y,FILE,99,object.getStateProgress(),color);
break;
case BUILDINGSITE_SIGN:
drawByProgress(x,y,FILE,93,object.getStateProgress(),color);
break;
case BUILDINGSITE_POST:
drawByProgress(x,y,FILE,92,object.getStateProgress(),color);
break;
case WORKAREA_MARK:
drawByProgress(x,y,FILE,91,object.getStateProgress(),color);
break;
case FLAG_DOOR:
drawPlayerableWaving(x,y,13,63,object,color);
break;
case CONSTRUCTION_MARK:
drawByProgress(x,y,4,6,object.getStateProgress(),color);
break;
case FLAG_ROOF:
float z=buffer.getZ();
buffer.setZ(.89f);
drawPlayerableWaving(x,y,13,64,object,color);
buffer.setZ(z);
break;
case BUILDING:
drawBuilding(x,y,(IBuilding)object,color);
break;
case STACK_OBJECT:
drawStack(x,y,(IStackMapObject)object,color);
break;
case SMOKE:
drawByProgress(x,y,13,42,progress,color);
break;
case WINE:
drawByProgress(x,y,1,25,progress,color);
break;
case PLANT_DECORATION:
{
int step=(x * 13 + y * 233) % 8;
Sequence<? extends Image> seq=this.imageProvider.getSettlerSequence(1,27);
draw(seq.getImageSafe(step),x,y,color);
}
break;
case DESERT_DECORATION:
{
int step=(x * 13 + y * 233) % 5 + 10;
Sequence<? extends Image> seq=this.imageProvider.getSettlerSequence(1,27);
draw(seq.getImageSafe(step),x,y,color);
}
break;
case PIG:
{
Sequence<? extends Image> seq=this.imageProvider.getSettlerSequence(ANIMALS_FILE,PIG_SEQ);
if (seq.length() > 0) {
int i=getAnimationStep(x,y) / 2;
int step=i % seq.length();
draw(seq.getImageSafe(step),x,y,color);
}
}
break;
case FISH_DECORATION:
{
int step=getAnimationStep(x,y);
Sequence<? extends Image> seq=this.imageProvider.getSettlerSequence(ANIMALS_FILE,FISH_SEQ);
int substep=step % 1024;
if (substep < 15) {
int subseq=(step / 1024) % 4;
draw(seq.getImageSafe(subseq * 15 + substep),x,y,color);
}
}
break;
case ATTACKABLE_TOWER:
{
IMovable movable=((IAttackableTowerMapObject)object).getMovable();
if (movable != null) {
Image image=this.imageMap.getImageForSettler(movable);
draw(image,x,y,color);
}
}
break;
default :
break;
}
}
if (object.getNextObject() != null) {
drawMapObject(map,x,y,object.getNextObject());
}
}","/** 
 * Draws a map object at a given position.
 * @param context The context.
 * @param map For these damned arrwos
 * @param pos THe position to draw the object.
 * @param object The object (tree, ...) to draw.
 */
public void drawMapObject(IGraphicsGrid map,int x,int y,IMapObject object){
  byte fogstatus=context.getVisibleStatus(x,y);
  if (fogstatus == 0) {
    return;
  }
  float color=getColor(fogstatus);
  EMapObjectType type=object.getObjectType();
  float progress=object.getStateProgress();
  if (type == EMapObjectType.ARROW) {
    drawArrow(context,(IArrowMapObject)object,color);
  }
 else {
switch (type) {
case TREE_ADULT:
      if (context.ENABLE_ORIGINAL) {
        drawTree(x,y,color);
      }
 else {
        drawTreeTest(x,y,color);
      }
    break;
case TREE_DEAD:
  playSound(object,4);
drawFallingTree(x,y,progress,color);
break;
case TREE_GROWING:
drawGrowingTree(x,y,progress,color);
break;
case CORN_GROWING:
drawGrowingCorn(x,y,object,color);
break;
case CORN_ADULT:
drawCorn(x,y,color);
break;
case CORN_DEAD:
drawDeadCorn(x,y,color);
break;
case WAVES:
drawWaves(x,y,color);
break;
case STONE:
drawStones(x,y,object,color);
break;
case GHOST:
drawPlayerableByProgress(x,y,12,27,object,color);
playSound(object,35);
break;
case BUILDING_DECONSTRUCTION_SMOKE:
drawByProgress(x,y,13,38,object.getStateProgress(),color);
playSound(object,35);
break;
case FOUND_COAL:
drawByProgress(x,y,FILE,94,object.getStateProgress(),color);
break;
case FOUND_GEMSTONE:
drawByProgress(x,y,FILE,95,object.getStateProgress(),color);
break;
case FOUND_GOLD:
drawByProgress(x,y,FILE,96,object.getStateProgress(),color);
break;
case FOUND_IRON:
drawByProgress(x,y,FILE,97,object.getStateProgress(),color);
break;
case FOUND_BRIMSTONE:
drawByProgress(x,y,FILE,98,object.getStateProgress(),color);
break;
case FOUND_NOTHING:
drawByProgress(x,y,FILE,99,object.getStateProgress(),color);
break;
case BUILDINGSITE_SIGN:
drawByProgress(x,y,FILE,93,object.getStateProgress(),color);
break;
case BUILDINGSITE_POST:
drawByProgress(x,y,FILE,92,object.getStateProgress(),color);
break;
case WORKAREA_MARK:
drawByProgress(x,y,FILE,91,object.getStateProgress(),color);
break;
case FLAG_DOOR:
drawPlayerableWaving(x,y,13,63,object,color);
break;
case CONSTRUCTION_MARK:
drawByProgress(x,y,4,6,object.getStateProgress(),color);
break;
case FLAG_ROOF:
float z=buffer.getZ();
buffer.setZ(.89f);
drawPlayerableWaving(x,y,13,64,object,color);
buffer.setZ(z);
break;
case BUILDING:
drawBuilding(x,y,(IBuilding)object,color);
break;
case STACK_OBJECT:
drawStack(x,y,(IStackMapObject)object,color);
break;
case SMOKE:
drawByProgress(x,y,13,42,progress,color);
break;
case WINE:
drawByProgress(x,y,1,25,progress,color);
break;
case PLANT_DECORATION:
{
int step=(x * 13 + y * 233) % 8;
Sequence<? extends Image> seq=this.imageProvider.getSettlerSequence(1,27);
draw(seq.getImageSafe(step),x,y,color);
}
break;
case DESERT_DECORATION:
{
int step=(x * 13 + y * 233) % 5 + 10;
Sequence<? extends Image> seq=this.imageProvider.getSettlerSequence(1,27);
draw(seq.getImageSafe(step),x,y,color);
}
break;
case PIG:
{
Sequence<? extends Image> seq=this.imageProvider.getSettlerSequence(ANIMALS_FILE,PIG_SEQ);
if (seq.length() > 0) {
int i=getAnimationStep(x,y) / 2;
int step=i % seq.length();
draw(seq.getImageSafe(step),x,y,color);
}
}
break;
case FISH_DECORATION:
{
int step=getAnimationStep(x,y);
Sequence<? extends Image> seq=this.imageProvider.getSettlerSequence(ANIMALS_FILE,FISH_SEQ);
int substep=step % 1024;
if (substep < 15) {
int subseq=(step / 1024) % 4;
draw(seq.getImageSafe(subseq * 15 + substep),x,y,color);
}
}
break;
case ATTACKABLE_TOWER:
{
IMovable movable=((IAttackableTowerMapObject)object).getMovable();
if (movable != null) {
Image image=this.imageMap.getImageForSettler(movable);
drawMovableAt(movable,image,x,y);
playMovableSound(movable);
}
}
break;
default :
break;
}
}
if (object.getNextObject() != null) {
drawMapObject(map,x,y,object.getNextObject());
}
}"
56400,"private void drawImage(IMovable movable,Image image){
  ShortPoint2D pos=movable.getPos();
  short x=pos.getX();
  short y=pos.getY();
  byte fogstatus=context.getVisibleStatus(x,y);
  if (fogstatus == 0) {
    return;
  }
  Color color=context.getPlayerColor(movable.getPlayer());
  float shade=MapObjectDrawer.getColor(fogstatus);
  float viewX;
  float viewY;
  if (movable.getAction() == EAction.WALKING) {
    int originx=x - movable.getDirection().getGridDeltaX();
    int originy=y - movable.getDirection().getGridDeltaY();
    viewX=betweenTilesX(originx,originy,x,y,movable.getMoveProgress());
    viewY=betweenTilesY;
  }
 else {
    int height=context.getHeight(x,y);
    viewX=context.getConverter().getViewX(x,y,height);
    viewY=context.getConverter().getViewY(x,y,height);
  }
  image.drawAt(context.getGl(),buffer,viewX,viewY,color,shade);
  if (movable.isSelected()) {
    drawSelectionMark(viewX,viewY,movable.getHealth());
  }
}","private void drawImage(IMovable movable,Image image){
  ShortPoint2D pos=movable.getPos();
  short x=pos.getX();
  short y=pos.getY();
  drawMovableAt(movable,image,x,y);
}"
56401,"protected void releaseRequestStacks(){
  for (  RequestStack curr : stacks) {
    curr.releaseRequests();
  }
  stacks=new LinkedList<RequestStack>();
}","protected void releaseRequestStacks(){
  if (stacks != null) {
    for (    RequestStack curr : stacks) {
      curr.releaseRequests();
    }
    stacks=new LinkedList<RequestStack>();
  }
}"
56402,"@Override public final void freeOccupiedArea(MapCircle occupied,ShortPoint2D pos){
  List<ShortPoint2D> totallyFreed=partitionsGrid.freeOccupiedArea(occupied,pos);
  if (!totallyFreed.isEmpty()) {
    StopWatch watch=new MilliStopWatch();
    watch.start();
    int maxSqDistance=6 * CommonConstants.TOWERRADIUS * CommonConstants.TOWERRADIUS;
    List<OccupyingDistanceCombi> occupyingInRange=new LinkedList<OccupyingDistanceCombi>();
    for (    OccupyingBuilding curr : OccupyingBuilding.getAllOccupyingBuildings()) {
      ShortPoint2D currPos=curr.getPos();
      int dx=currPos.getX() - pos.getX();
      int dy=currPos.getY() - pos.getY();
      int sqDistance=dx * dx + dy * dy;
      if (sqDistance <= maxSqDistance && sqDistance > 0) {
        occupyingInRange.add(new OccupyingDistanceCombi(sqDistance,curr));
      }
    }
    if (!occupyingInRange.isEmpty()) {
      Collections.sort(occupyingInRange);
      FreeMapArea freedArea=new FreeMapArea(totallyFreed);
      for (      OccupyingDistanceCombi currOcc : occupyingInRange) {
        MapCircle currOccArea=currOcc.building.getOccupyablePositions();
        Iterator<ShortPoint2D> iter=freedArea.iterator();
        for (ShortPoint2D currPos=iter.next(); iter.hasNext(); currPos=iter.next()) {
          if (currOccArea.contains(currPos)) {
            iter.remove();
            partitionsGrid.occupyAt(currPos.getX(),currPos.getY(),currOcc.building.getPlayer());
            bordersThread.checkPosition(currPos);
            landmarksCorrection.reTest(currPos.getX(),currPos.getY());
          }
        }
        if (freedArea.isEmpty()) {
          break;
        }
      }
    }
    watch.stop(""String_Node_Str"");
  }
}","@Override public final void freeOccupiedArea(MapCircle occupied,ShortPoint2D pos){
  List<ShortPoint2D> totallyFreed=partitionsGrid.freeOccupiedArea(occupied,pos);
  if (!totallyFreed.isEmpty()) {
    StopWatch watch=new MilliStopWatch();
    watch.start();
    final int maxSqDistance=6 * CommonConstants.TOWERRADIUS * CommonConstants.TOWERRADIUS;
    List<OccupyingDistanceCombi> occupyingInRange=new LinkedList<OccupyingDistanceCombi>();
    for (    OccupyingBuilding curr : OccupyingBuilding.getAllOccupyingBuildings()) {
      ShortPoint2D currPos=curr.getPos();
      int dx=currPos.getX() - pos.getX();
      int dy=currPos.getY() - pos.getY();
      int sqDistance=dx * dx + dy * dy;
      if (sqDistance <= maxSqDistance && sqDistance > 0) {
        occupyingInRange.add(new OccupyingDistanceCombi(sqDistance,curr));
      }
    }
    if (!occupyingInRange.isEmpty()) {
      Collections.sort(occupyingInRange);
      for (      OccupyingDistanceCombi currOcc : occupyingInRange) {
        MapCircle currOccArea=currOcc.building.getOccupyablePositions();
        Iterator<ShortPoint2D> iter=totallyFreed.iterator();
        for (ShortPoint2D currPos=iter.next(); iter.hasNext(); currPos=iter.next()) {
          if (currOccArea.contains(currPos)) {
            iter.remove();
            short x=currPos.getX();
            short y=currPos.getY();
            partitionsGrid.occupyAt(x,y,currOcc.building.getPlayer());
            bordersThread.checkPosition(currPos);
            landmarksCorrection.reTest(x,y);
            destroyBuildingOn(x,y,currOcc.building.getPlayer());
          }
        }
        if (totallyFreed.isEmpty()) {
          break;
        }
      }
    }
    watch.stop(""String_Node_Str"");
  }
}"
56403,"@Override public final void save() throws FileNotFoundException, IOException, InterruptedException {
  boolean pausing=NetworkTimer.isPausing();
  NetworkTimer.get().setPausing(true);
  try {
    Thread.sleep(30);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  MapList list=MapList.getDefaultList();
  list.saveMap(new UIState(0,new ShortPoint2D(0,0)),MainGrid.this);
  NetworkTimer.get().setPausing(pausing);
}","@Override public final void save() throws FileNotFoundException, IOException, InterruptedException {
  boolean pausing=NetworkTimer.isPausing();
  NetworkTimer.get().setPausing(true);
  try {
    Thread.sleep(100);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  MapList list=MapList.getDefaultList();
  list.saveMap(new UIState(0,new ShortPoint2D(0,0)),MainGrid.this);
  NetworkTimer.get().setPausing(pausing);
}"
56404,"@Override public final boolean setBuilding(ShortPoint2D position,Building newBuilding){
  if (MainGrid.this.isInBounds(position.getX(),position.getY())) {
    FreeMapArea area=new FreeMapArea(position,newBuilding.getBuildingType().getProtectedTiles());
    if (canConstructAt(area)) {
      setProtectedState(area,true);
      mapObjectsManager.addBuildingTo(position,newBuilding);
      return true;
    }
 else {
      return false;
    }
  }
 else {
    return false;
  }
}","@Override public final boolean setBuilding(ShortPoint2D position,Building newBuilding){
  if (MainGrid.this.isInBounds(position.getX(),position.getY())) {
    FreeMapArea area=new FreeMapArea(position,newBuilding.getBuildingType().getProtectedTiles());
    if (canConstructAt(area)) {
      setProtectedState(area,true);
      mapObjectsManager.addBuildingTo(position,newBuilding);
      objectsGrid.setBuildingArea(area,newBuilding);
      return true;
    }
 else {
      return false;
    }
  }
 else {
    return false;
  }
}"
56405,"@Override public final void occupyArea(MapCircle toBeOccupied,IMapArea groundArea,byte player){
  List<ShortPoint2D> occupiedPositions=partitionsGrid.occupyArea(toBeOccupied,groundArea,player);
  bordersThread.checkPositions(occupiedPositions);
  landmarksCorrection.addLandmarkedPositions(occupiedPositions);
}","@Override public final void occupyArea(MapCircle toBeOccupied,IMapArea groundArea,byte player){
  List<ShortPoint2D> occupiedPositions=partitionsGrid.occupyArea(toBeOccupied,groundArea,player);
  for (  ShortPoint2D curr : occupiedPositions) {
    destroyBuildingOn(curr.getX(),curr.getY(),player);
  }
  bordersThread.checkPositions(occupiedPositions);
  landmarksCorrection.addLandmarkedPositions(occupiedPositions);
}"
56406,"@Override public final void removeBuildingAt(ShortPoint2D pos){
  IBuilding building=(IBuilding)objectsGrid.getMapObjectAt(pos.getX(),pos.getY(),EMapObjectType.BUILDING);
  mapObjectsManager.removeMapObjectType(pos.getX(),pos.getY(),EMapObjectType.BUILDING);
  FreeMapArea area=new FreeMapArea(pos,building.getBuildingType().getProtectedTiles());
  for (  ShortPoint2D curr : area) {
    short x=curr.getX();
    short y=curr.getY();
    if (isInBounds(x,y)) {
      flagsGrid.setBlockedAndProtected(x,y,false);
    }
  }
}","@Override public final void removeBuildingAt(ShortPoint2D pos){
  IBuilding building=(IBuilding)objectsGrid.getMapObjectAt(pos.getX(),pos.getY(),EMapObjectType.BUILDING);
  mapObjectsManager.removeMapObjectType(pos.getX(),pos.getY(),EMapObjectType.BUILDING);
  FreeMapArea area=new FreeMapArea(pos,building.getBuildingType().getProtectedTiles());
  objectsGrid.setBuildingArea(area,null);
  for (  ShortPoint2D curr : area) {
    short x=curr.getX();
    short y=curr.getY();
    if (isInBounds(x,y)) {
      flagsGrid.setBlockedAndProtected(x,y,false);
    }
  }
}"
56407,"public ObjectsGrid(short width,short height){
  this.width=width;
  this.height=height;
  this.objectsGrid=new AbstractHexMapObject[width * height];
}","public ObjectsGrid(short width,short height){
  this.width=width;
  this.height=height;
  this.objectsGrid=new AbstractHexMapObject[width * height];
  this.buildingsGrid=new Building[width * height];
}"
56408,"public final List<ShortPoint2D> freeOccupiedArea(MapCircle occupied,ShortPoint2D occupiersPosition){
  short partiton=getPartition(occupiersPosition);
  List<ShortPoint2D> totallyFreePositions=new ArrayList<ShortPoint2D>();
  for (  ShortPoint2D curr : occupied) {
    short x=curr.getX();
    short y=curr.getY();
    if (isInBounds(x,y) && getPartitionAt(x,y) == partiton) {
      final int idx=getIdx(x,y);
      towers[idx]--;
      if (towers[idx] <= 0) {
        totallyFreePositions.add(curr);
        towers[idx]=0;
      }
    }
  }
  return totallyFreePositions;
}","public final List<ShortPoint2D> freeOccupiedArea(MapCircle occupied,ShortPoint2D occupiersPosition){
  short partiton=getPartition(occupiersPosition);
  List<ShortPoint2D> totallyFreePositions=new LinkedList<ShortPoint2D>();
  for (  ShortPoint2D curr : occupied) {
    short x=curr.getX();
    short y=curr.getY();
    if (isInBounds(x,y) && getPartitionAt(x,y) == partiton) {
      final int idx=getIdx(x,y);
      towers[idx]--;
      if (towers[idx] <= 0) {
        totallyFreePositions.add(curr);
        towers[idx]=0;
      }
    }
  }
  return totallyFreePositions;
}"
56409,"public void draw(GLDrawContext context){
synchronized (update_syncobj) {
    if (!imageIsValid) {
      if (imageIndex < 0) {
        context.deleteTexture(imageIndex);
      }
      ShortBuffer data=ByteBuffer.allocateDirect(width * height * 2).order(ByteOrder.nativeOrder()).asShortBuffer();
      for (int i=0; i < width * height; i++) {
        data.put((short)0x0001);
      }
      data.position(0);
      imageIndex=context.generateTexture(width,height,data);
      updatedLines.clear();
      imageIsValid=true;
    }
    if (!updatedLines.isEmpty()) {
      ShortBuffer currData=ByteBuffer.allocateDirect(width * 2).asShortBuffer();
      for (      Integer currLine : updatedLines) {
        currData.position(0);
        currData.put(buffer[currLine]);
        currData.position(0);
        context.updateTexture(imageIndex,0,currLine,width,1,currData);
      }
      updatedLines.clear();
    }
    update_syncobj.notifyAll();
  }
  context.color(1,1,1,1);
  context.drawQuadWithTexture(imageIndex,new float[]{0,0,0,0,0,width,0,0,1,0,(stride + 1) * width,height,0,1,1,stride * width,height,0,0,1});
  drawViewmark(context);
}","public void draw(GLDrawContext context){
synchronized (update_syncobj) {
    if (!imageIsValid) {
      if (imageIndex < 0) {
        context.deleteTexture(imageIndex);
      }
      ShortBuffer data=ByteBuffer.allocateDirect(width * height * 2).order(ByteOrder.nativeOrder()).asShortBuffer();
      for (int i=0; i < width * height; i++) {
        data.put((short)0x0001);
      }
      data.position(0);
      imageIndex=context.generateTexture(width,height,data);
      updatedLines.clear();
      imageIsValid=true;
    }
    if (!updatedLines.isEmpty()) {
      ShortBuffer currData=ByteBuffer.allocateDirect(width * 2).order(ByteOrder.nativeOrder()).asShortBuffer();
      for (      Integer currLine : updatedLines) {
        currData.position(0);
        currData.put(buffer[currLine]);
        currData.position(0);
        context.updateTexture(imageIndex,0,currLine,width,1,currData);
      }
      updatedLines.clear();
    }
    update_syncobj.notifyAll();
  }
  context.color(1,1,1,1);
  context.drawQuadWithTexture(imageIndex,new float[]{0,0,0,0,0,width,0,0,1,0,(stride + 1) * width,height,0,1,1,stride * width,height,0,0,1});
  drawViewmark(context);
}"
56410,"@Override public void action(Action action){
  if (action.getActionType() != EActionType.SCREEN_CHANGE) {
    System.out.println(""String_Node_Str"" + action.getActionType());
  }
switch (action.getActionType()) {
case BUILD:
    this.setSelection(new SelectionSet());
  EBuildingType buildingType=((BuildAction)action).getBuilding();
System.err.println(""String_Node_Str"" + buildingType);
this.previewBuilding=buildingType;
connector.setPreviewBuildingType(buildingType);
constructionMarksCalculator.setBuildingType(buildingType);
setActiveAction(action);
break;
case DEBUG_ACTION:
for (ISelectable curr : currentSelection) {
if (curr instanceof IDebugable) {
((IDebugable)curr).debug();
}
}
break;
case SPEED_TOGGLE_PAUSE:
NetworkTimer.get().invertPausing();
break;
case SPEED_SLOW:
if (!manager.isMultiplayer()) NetworkTimer.setGameSpeed(0.5f);
break;
case SPEED_FAST:
if (!manager.isMultiplayer()) NetworkTimer.setGameSpeed(2.0f);
break;
case SPEED_FASTER:
if (!manager.isMultiplayer()) NetworkTimer.multiplyGameSpeed(1.2f);
break;
case SPEED_SLOWER:
if (!manager.isMultiplayer()) NetworkTimer.multiplyGameSpeed(1 / 1.2f);
break;
case SPEED_NORMAL:
if (!manager.isMultiplayer()) NetworkTimer.setGameSpeed(1.0f);
break;
case FAST_FORWARD:
if (!manager.isMultiplayer()) {
NetworkTimer.get().fastForward();
}
break;
case SELECT_POINT:
handleSelectPointAction((SelectAction)action);
break;
case SELECT_AREA:
selectArea((SelectAreaAction)action);
break;
case MOVE_TO:
if (previewBuilding != null) {
cancelBuildingCreation();
setActiveAction(null);
}
 else {
MoveToAction moveToAction=(MoveToAction)action;
ShortPoint2D pos=moveToAction.getPosition();
moveTo(pos);
}
break;
case SET_WORK_AREA:
if (currentSelection.getSize() > 0) {
ISelectable selected=currentSelection.iterator().next();
if (selected instanceof Building) {
ShortPoint2D pos=((SelectAction)action).getPosition();
scheduleTask(new WorkAreaGuiTask(EGuiAction.SET_WORK_AREA,pos,((Building)selected).getPos()));
}
}
break;
case DESTROY:
destroySelected();
break;
case STOP_WORKING:
stopOrStartWorkingAction(true);
break;
case START_WORKING:
stopOrStartWorkingAction(false);
break;
case SHOW_SELECTION:
showSelection();
break;
case SCREEN_CHANGE:
constructionMarksCalculator.setScreen(((ScreenChangeAction)action).getScreenArea());
break;
case TOGGLE_DEBUG:
grid.resetDebugColors();
break;
case TOGGLE_FOG_OF_WAR:
grid.toggleFogOfWar();
break;
case SAVE:
manager.scheduleTask(new SimpleGuiTask(EGuiAction.QUICK_SAVE));
break;
case CONVERT:
sendConvertAction((ConvertAction)action);
break;
default :
System.err.println(""String_Node_Str"" + action.getActionType() + ""String_Node_Str"");
}
}","@Override public void action(Action action){
  if (action.getActionType() != EActionType.SCREEN_CHANGE) {
    System.out.println(""String_Node_Str"" + action.getActionType());
  }
switch (action.getActionType()) {
case BUILD:
    this.setSelection(new SelectionSet());
  EBuildingType buildingType=((BuildAction)action).getBuilding();
System.err.println(""String_Node_Str"" + buildingType);
this.previewBuilding=buildingType;
connector.setPreviewBuildingType(buildingType);
constructionMarksCalculator.setBuildingType(buildingType);
setActiveAction(action);
break;
case DEBUG_ACTION:
for (ISelectable curr : currentSelection) {
if (curr instanceof IDebugable) {
((IDebugable)curr).debug();
}
}
break;
case SPEED_TOGGLE_PAUSE:
NetworkTimer.get().invertPausing();
break;
case SPEED_SLOW:
if (!manager.isMultiplayer()) NetworkTimer.setGameSpeed(0.5f);
break;
case SPEED_FAST:
if (!manager.isMultiplayer()) NetworkTimer.setGameSpeed(2.0f);
break;
case SPEED_FASTER:
if (!manager.isMultiplayer()) NetworkTimer.multiplyGameSpeed(1.2f);
break;
case SPEED_SLOWER:
if (!manager.isMultiplayer()) NetworkTimer.multiplyGameSpeed(1 / 1.2f);
break;
case SPEED_NORMAL:
if (!manager.isMultiplayer()) NetworkTimer.setGameSpeed(1.0f);
break;
case FAST_FORWARD:
if (!manager.isMultiplayer()) {
NetworkTimer.get().fastForward();
}
break;
case SELECT_POINT:
handleSelectPointAction((SelectAction)action);
break;
case SELECT_AREA:
selectArea((SelectAreaAction)action);
break;
case MOVE_TO:
if (previewBuilding != null) {
cancelBuildingCreation();
setActiveAction(null);
}
 else {
MoveToAction moveToAction=(MoveToAction)action;
if (currentSelection.getSelectionType() == ESelectionType.BUILDING && currentSelection.getSize() == 1) {
setBuildingWorkArea(moveToAction.getPosition());
}
 else {
moveTo(moveToAction.getPosition());
}
}
break;
case SET_WORK_AREA:
if (currentSelection.getSize() > 0) {
setBuildingWorkArea(((SelectAction)action).getPosition());
}
break;
case DESTROY:
destroySelected();
break;
case STOP_WORKING:
stopOrStartWorkingAction(true);
break;
case START_WORKING:
stopOrStartWorkingAction(false);
break;
case SHOW_SELECTION:
showSelection();
break;
case SCREEN_CHANGE:
constructionMarksCalculator.setScreen(((ScreenChangeAction)action).getScreenArea());
break;
case TOGGLE_DEBUG:
grid.resetDebugColors();
break;
case TOGGLE_FOG_OF_WAR:
grid.toggleFogOfWar();
break;
case SAVE:
manager.scheduleTask(new SimpleGuiTask(EGuiAction.QUICK_SAVE));
break;
case CONVERT:
sendConvertAction((ConvertAction)action);
break;
default :
System.err.println(""String_Node_Str"" + action.getActionType() + ""String_Node_Str"");
}
}"
56411,"private IAttackable getEnemyInSearchArea(byte movablePlayer,HexGridArea area,boolean isBowman){
  for (  ShortPoint2D curr : area) {
    short x=curr.getX();
    short y=curr.getY();
    if (0 <= x && x < width && 0 <= y && y < height) {
      IAttackable currAttackable=movableGrid.getMovableAt(x,y);
      if (currAttackable == null && !isBowman) {
        currAttackable=(IAttackable)objectsGrid.getMapObjectAt(x,y,EMapObjectType.ATTACKABLE_TOWER);
      }
      if (currAttackable != null && MovableGrid.isEnemy(movablePlayer,currAttackable)) {
        return currAttackable;
      }
    }
  }
  return null;
}","private IAttackable getEnemyInSearchArea(byte searchingPlayer,HexGridArea area,boolean isBowman){
  for (  ShortPoint2D curr : area) {
    short x=curr.getX();
    short y=curr.getY();
    if (0 <= x && x < width && 0 <= y && y < height) {
      IAttackable currAttackable=movableGrid.getMovableAt(x,y);
      if (currAttackable == null && !isBowman) {
        currAttackable=(IAttackable)objectsGrid.getMapObjectAt(x,y,EMapObjectType.ATTACKABLE_TOWER);
      }
      if (currAttackable != null && MovableGrid.isEnemy(searchingPlayer,currAttackable)) {
        return currAttackable;
      }
    }
  }
  return null;
}"
56412,"@Override protected boolean isEnemyAttackable(IAttackable enemy){
  ShortPoint2D pos=super.getPos();
  ShortPoint2D enemyPos=enemy.getPos();
  final int dx=Math.abs(pos.getX() - enemyPos.getX());
  final int dy=Math.abs(pos.getY() - enemyPos.getY());
  final int squareDist=dx * dx + dy * dy;
  return squareDist <= SQUARE_BOWMAN_ATTACK_RADIUS;
}","@Override protected boolean isEnemyAttackable(IAttackable enemy,boolean isInTower){
  ShortPoint2D pos=super.getPos();
  ShortPoint2D enemyPos=enemy.getPos();
  final int dx=Math.abs(pos.getX() - enemyPos.getX());
  final int dy=Math.abs(pos.getY() - enemyPos.getY());
  final int squareDist=dx * dx + dy * dy;
  if (isInTower) {
    return squareDist <= SQUARE_BOWMAN_IN_TOWER_ATTACK_RADIUS;
  }
 else {
    return squareDist <= SQUARE_BOWMAN_ATTACK_RADIUS;
  }
}"
56413,"@Override protected boolean isEnemyAttackable(IAttackable enemy){
  return EDirection.getDirection(super.getPos(),enemy.getPos()) != null;
}","@Override protected boolean isEnemyAttackable(IAttackable enemy,boolean isInTower){
  return EDirection.getDirection(super.getPos(),enemy.getPos()) != null;
}"
56414,"@Override public void informAboutAttackable(IAttackable other){
  if (isInTower) {
    if (getSoldierType() == ESoldierType.BOWMAN) {
      state=ESoldierState.SEARCH_FOR_ENEMIES;
    }
  }
 else   if (state == ESoldierState.AGGRESSIVE) {
    state=ESoldierState.SEARCH_FOR_ENEMIES;
  }
}","@Override public void informAboutAttackable(IAttackable other){
  if (state == ESoldierState.AGGRESSIVE && (!isInTower || getSoldierType() == ESoldierType.BOWMAN)) {
    state=ESoldierState.SEARCH_FOR_ENEMIES;
  }
}"
56415,"@Override protected void action(){
switch (state) {
case AGGRESSIVE:
    break;
case HITTING:
  hitEnemy(enemy);
if (enemy.getHealth() <= 0) {
  enemy=null;
  state=ESoldierState.SEARCH_FOR_ENEMIES;
  break;
}
case SEARCH_FOR_ENEMIES:
IAttackable oldEnemy=enemy;
enemy=super.getStrategyGrid().getEnemyInSearchArea(getAttackPosition(),super.getMovable(),getSearchDistance(isInTower));
if (oldEnemy != null && oldEnemy != enemy) {
inSaveGotoMode=false;
}
if (enemy == null) {
if (defending) {
building.towerDefended(this);
defending=false;
}
changeStateTo(ESoldierState.AGGRESSIVE);
break;
}
if (isEnemyAttackable(enemy)) {
super.lookInDirection(EDirection.getApproxDirection(super.getPos(),enemy.getPos()));
startAttackAnimation(enemy);
state=ESoldierState.HITTING;
}
 else if (!isInTower) {
state=ESoldierState.SEARCH_FOR_ENEMIES;
goToEnemy(enemy);
}
break;
case INIT_GOTO_TOWER:
super.goToPos(building.getDoor());
state=ESoldierState.GOING_TO_TOWER;
break;
case GOING_TO_TOWER:
if (building.isNotDestroyed() && building.getPlayer() == super.getPlayer()) {
OccupyerPlace place=building.addSoldier(this);
super.setPosition(place.getPosition().calculatePoint(building.getDoor()));
super.enableNothingToDoAction(false);
super.setVisible(false);
if (isBowman()) {
this.inTowerAttackPosition=building.getTowerBowmanSearchPosition(place);
}
state=ESoldierState.AGGRESSIVE;
isInTower=true;
}
 else {
state=ESoldierState.SEARCH_FOR_ENEMIES;
}
break;
}
}","@Override protected void action(){
switch (state) {
case AGGRESSIVE:
    break;
case HITTING:
  hitEnemy(enemy);
if (enemy.getHealth() <= 0) {
  enemy=null;
  state=ESoldierState.SEARCH_FOR_ENEMIES;
  break;
}
case SEARCH_FOR_ENEMIES:
IAttackable oldEnemy=enemy;
enemy=super.getStrategyGrid().getEnemyInSearchArea(getAttackPosition(),super.getMovable(),getSearchDistance(isInTower));
if (oldEnemy != null && oldEnemy != enemy) {
inSaveGotoMode=false;
}
if (enemy == null) {
if (defending) {
building.towerDefended(this);
defending=false;
}
changeStateTo(ESoldierState.AGGRESSIVE);
break;
}
if (isEnemyAttackable(enemy,isInTower)) {
super.lookInDirection(EDirection.getApproxDirection(super.getPos(),enemy.getPos()));
startAttackAnimation(enemy);
state=ESoldierState.HITTING;
}
 else if (!isInTower) {
state=ESoldierState.SEARCH_FOR_ENEMIES;
goToEnemy(enemy);
}
break;
case INIT_GOTO_TOWER:
super.goToPos(building.getDoor());
state=ESoldierState.GOING_TO_TOWER;
break;
case GOING_TO_TOWER:
if (building.isNotDestroyed() && building.getPlayer() == super.getPlayer()) {
OccupyerPlace place=building.addSoldier(this);
super.setPosition(place.getPosition().calculatePoint(building.getDoor()));
super.enableNothingToDoAction(false);
super.setVisible(false);
if (isBowman()) {
this.inTowerAttackPosition=building.getTowerBowmanSearchPosition(place);
}
state=ESoldierState.AGGRESSIVE;
isInTower=true;
}
 else {
state=ESoldierState.SEARCH_FOR_ENEMIES;
}
break;
}
}"
56416,protected abstract boolean isEnemyAttackable(IAttackable enemy);,"protected abstract boolean isEnemyAttackable(IAttackable enemy,boolean isInTower);"
56417,"/** 
 * Draws a given buildng to the context.
 * @param context
 * @param building
 * @param color Gray color shade
 */
private void drawBuilding(int x,int y,IBuilding building,float color){
  EBuildingType type=building.getBuildingType();
  float state=building.getStateProgress();
  float maskState;
  if (state < 0.5f) {
    maskState=state * 2;
    for (    ImageLink link : type.getBuildImages()) {
      Image image=imageProvider.getImage(link);
      drawWithConstructionMask(x,y,maskState,image,color);
    }
  }
 else   if (state < 0.99) {
    maskState=state * 2 - 1;
    for (    ImageLink link : type.getBuildImages()) {
      Image image=imageProvider.getImage(link);
      draw(image,x,y,color);
    }
    for (    ImageLink link : type.getImages()) {
      Image image=imageProvider.getImage(link);
      drawWithConstructionMask(x,y,maskState,image,color);
    }
  }
 else {
    if (type == EBuildingType.MILL && ((IBuilding.IMill)building).isWorking()) {
      Sequence<? extends Image> seq=this.imageProvider.getSettlerSequence(MILL_FILE,MILL_SEQ);
      if (seq.length() > 0) {
        int i=getAnimationStep(x,y);
        int step=i % seq.length();
        draw(seq.getImageSafe(step),x,y,color);
      }
      playSound(building,42);
    }
 else {
      ImageLink[] images=type.getImages();
      if (images.length > 0) {
        Image image=imageProvider.getImage(images[0]);
        draw(image,x,y,color);
      }
      if (building instanceof IBuilding.IOccupyed) {
        drawOccupyers(x,y,(IBuilding.IOccupyed)building,color);
      }
      for (int i=1; i < images.length; i++) {
        Image image=imageProvider.getImage(images[i]);
        draw(image,x,y,color);
      }
    }
  }
  if (building.isSelected()) {
    drawBuildingSelectMarker(x,y);
  }
}","/** 
 * Draws a given buildng to the context.
 * @param context
 * @param building
 * @param color Gray color shade
 */
private void drawBuilding(int x,int y,IBuilding building,float color){
  EBuildingType type=building.getBuildingType();
  float state=building.getStateProgress();
  float maskState;
  if (state < 0.5f) {
    maskState=state * 2;
    for (    ImageLink link : type.getBuildImages()) {
      Image image=imageProvider.getImage(link);
      drawWithConstructionMask(x,y,maskState,image,color);
    }
  }
 else   if (state < 0.99) {
    maskState=state * 2 - 1;
    for (    ImageLink link : type.getBuildImages()) {
      Image image=imageProvider.getImage(link);
      draw(image,x,y,color);
    }
    for (    ImageLink link : type.getImages()) {
      Image image=imageProvider.getImage(link);
      drawWithConstructionMask(x,y,maskState,image,color);
    }
  }
 else {
    if (type == EBuildingType.MILL && ((IBuilding.IMill)building).isWorking()) {
      Sequence<? extends Image> seq=this.imageProvider.getSettlerSequence(MILL_FILE,MILL_SEQ);
      if (seq.length() > 0) {
        int i=getAnimationStep(x,y);
        int step=i % seq.length();
        draw(seq.getImageSafe(step),x,y,color);
      }
      playSound(building,42);
    }
 else {
      ImageLink[] images=type.getImages();
      if (images.length > 0) {
        Image image=imageProvider.getImage(images[0]);
        draw(image,x,y,color);
      }
      if (building instanceof IBuilding.IOccupyed) {
        drawOccupiers(x,y,(IBuilding.IOccupyed)building,color);
      }
      for (int i=1; i < images.length; i++) {
        Image image=imageProvider.getImage(images[i]);
        draw(image,x,y,color);
      }
    }
  }
  if (building.isSelected()) {
    drawBuildingSelectMarker(x,y);
  }
}"
56418,void leaveOccupyableBuilding();,void leaveOccupyableBuilding(ShortPoint2D newPosition);
56419,"@Override protected final void killedEvent(){
  setSelected(false);
  if (occupiedArea) {
    MapCircle occupied=getOccupyablePositions();
    super.getGrid().freeOccupiedArea(occupied,super.getPos());
    for (    TowerOccupyer curr : occupiers) {
      curr.soldier.leaveOccupyableBuilding();
    }
    occupiers.clear();
  }
  allOccupyingBuildings.remove(this);
  ShortPoint2D defenderPos=getDefenderPos();
  super.getGrid().getMapObjectsManager().removeMapObjectType(defenderPos.getX(),defenderPos.getY(),EMapObjectType.ATTACKABLE_TOWER);
}","@Override protected final void killedEvent(){
  setSelected(false);
  if (occupiedArea) {
    MapCircle occupied=getOccupyablePositions();
    super.getGrid().freeOccupiedArea(occupied,super.getPos());
    int idx=0;
    FreeMapArea buildingArea=super.getBuildingArea();
    for (    TowerOccupyer curr : occupiers) {
      curr.soldier.leaveOccupyableBuilding(buildingArea.get(idx));
      idx++;
    }
    occupiers.clear();
  }
  allOccupyingBuildings.remove(this);
  ShortPoint2D defenderPos=getDefenderPos();
  super.getGrid().getMapObjectsManager().removeMapObjectType(defenderPos.getX(),defenderPos.getY(),EMapObjectType.ATTACKABLE_TOWER);
}"
56420,"@Override public void leaveOccupyableBuilding(){
  super.enableNothingToDoAction(true);
  super.setVisible(true);
  state=ESoldierState.AGGRESSIVE;
}","@Override public void leaveOccupyableBuilding(ShortPoint2D newPosition){
  super.setPosition(newPosition);
  super.enableNothingToDoAction(true);
  super.setVisible(true);
  state=ESoldierState.ENEMY_FOUND;
}"
56421,"@Override protected void startAttackAnimation(IAttackable enemy){
  super.playAction(EAction.ACTION1,BOWMAN_ATTACK_DURATION);
  super.getStrategyGrid().addArrowObject(enemy.getPos(),super.getPos(),super.getPlayer(),0.1f);
}","@Override protected void startAttackAnimation(IAttackable enemy){
  super.playAction(EAction.ACTION1,BOWMAN_ATTACK_DURATION);
  super.getStrategyGrid().addArrowObject(enemy.getPos(),super.getPos(),super.getPlayer(),0.08f);
}"
56422,"@Override protected boolean checkPathStepPreconditions(ShortPoint2D pathTarget,int step){
  boolean result=!((state == ESoldierState.ENEMY_FOUND || state == ESoldierState.HITTING) && step >= 2);
  if (!result && oldPathTarget == null) {
    oldPathTarget=pathTarget;
  }
  return result;
}","@Override protected boolean checkPathStepPreconditions(ShortPoint2D pathTarget,int step){
  boolean result=!((state == ESoldierState.SEARCH_FOR_ENEMIES || state == ESoldierState.HITTING) && step >= 2);
  if (!result && oldPathTarget == null) {
    oldPathTarget=pathTarget;
  }
  if (state == ESoldierState.GOING_TO_TOWER && (!building.isNotDestroyed() || building.getPlayer() != super.getPlayer())) {
    result=false;
  }
  return result;
}"
56423,"@Override public void leaveOccupyableBuilding(ShortPoint2D newPosition){
  super.setPosition(newPosition);
  super.enableNothingToDoAction(true);
  super.setVisible(true);
  state=ESoldierState.ENEMY_FOUND;
}","@Override public void leaveOccupyableBuilding(ShortPoint2D newPosition){
  super.setPosition(newPosition);
  super.enableNothingToDoAction(true);
  super.setVisible(true);
  isInTower=false;
  state=ESoldierState.SEARCH_FOR_ENEMIES;
}"
56424,"@Override public void setDefendingAt(ShortPoint2D pos){
  super.setPosition(pos);
  state=ESoldierState.ENEMY_FOUND;
}","@Override public void setDefendingAt(ShortPoint2D pos){
  super.setPosition(pos);
  state=ESoldierState.SEARCH_FOR_ENEMIES;
}"
56425,"@Override public void informAboutAttackable(IAttackable other){
  if (state == ESoldierState.AGGRESSIVE && !isInTower) {
    state=ESoldierState.ENEMY_FOUND;
  }
}","@Override public void informAboutAttackable(IAttackable other){
  if (state == ESoldierState.AGGRESSIVE && !isInTower) {
    state=ESoldierState.SEARCH_FOR_ENEMIES;
  }
}"
56426,"@Override protected Path findWayAroundObstacle(EDirection direction,ShortPoint2D position,Path path){
  if (state == ESoldierState.ENEMY_FOUND) {
    IStrategyGrid grid=super.getStrategyGrid();
    EDirection leftDir=direction.getNeighbor(-1);
    ShortPoint2D leftPos=leftDir.getNextHexPoint(position);
    EDirection rightDir=direction.getNeighbor(1);
    ShortPoint2D rightPos=rightDir.getNextHexPoint(position);
    if (grid.isFreePosition(leftPos)) {
      return new Path(leftPos);
    }
 else     if (grid.isFreePosition(rightPos)) {
      return new Path(rightPos);
    }
 else {
      EDirection twoLeftDir=direction.getNeighbor(-2);
      ShortPoint2D twoLeftPos=twoLeftDir.getNextHexPoint(position);
      EDirection twoRightDir=direction.getNeighbor(2);
      ShortPoint2D twoRightPos=twoRightDir.getNextHexPoint(position);
      if (grid.isFreePosition(twoLeftPos)) {
        return new Path(twoLeftPos);
      }
 else       if (grid.isFreePosition(twoRightPos)) {
        return new Path(twoRightPos);
      }
 else {
        return path;
      }
    }
  }
 else {
    return super.findWayAroundObstacle(direction,position,path);
  }
}","@Override protected Path findWayAroundObstacle(EDirection direction,ShortPoint2D position,Path path){
  if (state == ESoldierState.SEARCH_FOR_ENEMIES) {
    IStrategyGrid grid=super.getStrategyGrid();
    EDirection leftDir=direction.getNeighbor(-1);
    ShortPoint2D leftPos=leftDir.getNextHexPoint(position);
    EDirection rightDir=direction.getNeighbor(1);
    ShortPoint2D rightPos=rightDir.getNextHexPoint(position);
    if (grid.isFreePosition(leftPos)) {
      return new Path(leftPos);
    }
 else     if (grid.isFreePosition(rightPos)) {
      return new Path(rightPos);
    }
 else {
      EDirection twoLeftDir=direction.getNeighbor(-2);
      ShortPoint2D twoLeftPos=twoLeftDir.getNextHexPoint(position);
      EDirection twoRightDir=direction.getNeighbor(2);
      ShortPoint2D twoRightPos=twoRightDir.getNextHexPoint(position);
      if (grid.isFreePosition(twoLeftPos)) {
        return new Path(twoLeftPos);
      }
 else       if (grid.isFreePosition(twoRightPos)) {
        return new Path(twoRightPos);
      }
 else {
        return path;
      }
    }
  }
 else {
    return super.findWayAroundObstacle(direction,position,path);
  }
}"
56427,"@Override protected void action(){
switch (state) {
case AGGRESSIVE:
    break;
case HITTING:
  hitEnemy(enemy);
if (enemy.getHealth() <= 0) {
  enemy=null;
  state=ESoldierState.ENEMY_FOUND;
  break;
}
case ENEMY_FOUND:
IAttackable oldEnemy=enemy;
enemy=super.getStrategyGrid().getEnemyInSearchArea(super.getMovable());
if (oldEnemy != null && oldEnemy != enemy) {
inSaveGotoMode=false;
}
if (enemy == null) {
if (isInTower) {
building.towerDefended(this);
}
changeStateTo(ESoldierState.AGGRESSIVE);
break;
}
if (isEnemyAttackable(enemy)) {
super.lookInDirection(EDirection.getApproxDirection(super.getPos(),enemy.getPos()));
startAttackAnimation(enemy);
state=ESoldierState.HITTING;
}
 else if (!isInTower) {
state=ESoldierState.ENEMY_FOUND;
goToEnemy(enemy);
}
break;
case INIT_GOTO_TOWER:
super.goToPos(building.getDoor());
state=ESoldierState.GOING_TO_TOWER;
break;
case GOING_TO_TOWER:
ShortPoint2D pos=building.addSoldier(this);
super.setPosition(pos);
super.enableNothingToDoAction(false);
super.setVisible(false);
state=ESoldierState.AGGRESSIVE;
isInTower=true;
break;
}
}","@Override protected void action(){
switch (state) {
case AGGRESSIVE:
    break;
case HITTING:
  hitEnemy(enemy);
if (enemy.getHealth() <= 0) {
  enemy=null;
  state=ESoldierState.SEARCH_FOR_ENEMIES;
  break;
}
case SEARCH_FOR_ENEMIES:
IAttackable oldEnemy=enemy;
enemy=super.getStrategyGrid().getEnemyInSearchArea(super.getMovable());
if (oldEnemy != null && oldEnemy != enemy) {
inSaveGotoMode=false;
}
if (enemy == null) {
if (isInTower) {
building.towerDefended(this);
}
changeStateTo(ESoldierState.AGGRESSIVE);
break;
}
if (isEnemyAttackable(enemy)) {
super.lookInDirection(EDirection.getApproxDirection(super.getPos(),enemy.getPos()));
startAttackAnimation(enemy);
state=ESoldierState.HITTING;
}
 else if (!isInTower) {
state=ESoldierState.SEARCH_FOR_ENEMIES;
goToEnemy(enemy);
}
break;
case INIT_GOTO_TOWER:
super.goToPos(building.getDoor());
state=ESoldierState.GOING_TO_TOWER;
break;
case GOING_TO_TOWER:
if (building.isNotDestroyed() && building.getPlayer() == super.getPlayer()) {
ShortPoint2D pos=building.addSoldier(this);
super.setPosition(pos);
super.enableNothingToDoAction(false);
super.setVisible(false);
state=ESoldierState.AGGRESSIVE;
isInTower=true;
}
 else {
state=ESoldierState.SEARCH_FOR_ENEMIES;
}
break;
}
}"
56428,"@Override public IAttackable getEnemyInSearchArea(IAttackable movable){
  IAttackable enemy=movableGrid.getEnemyInSearchArea(movable);
  IAttackable tower=null;
  if (tower == null || movable.getMovableType().getTool() == EMaterialType.BOW) {
    return enemy;
  }
 else   if (enemy == null) {
    return tower;
  }
 else {
    int enemyDist=movable.getPos().getOnGridDistTo(enemy.getPos());
    int towerDist=movable.getPos().getOnGridDistTo(tower.getPos());
    if (enemyDist < towerDist) {
      return enemy;
    }
 else {
      return tower;
    }
  }
}","private IAttackable getEnemyInSearchArea(NewMovable movable,HexGridArea area,boolean isBowman){
  byte movablePlayer=movable.getPlayer();
  for (  ShortPoint2D curr : area) {
    short x=curr.getX();
    short y=curr.getY();
    if (0 <= x && x < width && 0 <= y && y < height) {
      IAttackable currAttackable=movableGrid.getMovableAt(x,y);
      if (currAttackable == null && !isBowman) {
        currAttackable=(IAttackable)objectsGrid.getMapObjectAt(x,y,EMapObjectType.ATTACKABLE_TOWER);
      }
      if (currAttackable != null && MovableGrid.isEnemy(movablePlayer,currAttackable)) {
        return currAttackable;
      }
    }
  }
  return null;
}"
56429,"@Override public void enterPosition(ShortPoint2D position,NewMovable movable,boolean informFullArea){
  movableGrid.movableEntered(position,movable,informFullArea);
}","@Override public void enterPosition(ShortPoint2D position,NewMovable movable,boolean informFullArea){
  movableGrid.movableEntered(position,movable,informFullArea);
  if (movable.isAttackable()) {
    objectsGrid.informTowersAboutAttackble(position,movable,informFullArea,!EMovableType.isBowman(movable.getMovableType()));
  }
}"
56430,"@Override public void hitWithArrowAt(ArrowObject arrow){
  short x=arrow.getTargetX();
  short y=arrow.getTargetY();
  NewMovable movable=movableGrid.getMovableAt(x,y);
  if (movable != null) {
    movable.hit(arrow.getHitStrength());
    mapObjectsManager.removeMapObject(x,y,arrow);
  }
}","@Override public void hitWithArrowAt(ArrowObject arrow){
  short x=arrow.getTargetX();
  short y=arrow.getTargetY();
  NewMovable movable=movableGrid.getMovableAt(x,y);
  if (movable != null) {
    movable.receiveHit(arrow.getHitStrength());
    mapObjectsManager.removeMapObject(x,y,arrow);
  }
}"
56431,"@Override public final int getDebugColorAt(int x,int y){
  return landscapeGrid.getDebugColor(x,y);
}","@Override public final int getDebugColorAt(int x,int y){
  return flagsGrid.isMarked((short)x,(short)y) ? Color.GREEN.getARGB() : (objectsGrid.getMapObjectAt((short)x,(short)y,EMapObjectType.ATTACKABLE_TOWER) != null ? Color.RED.getARGB() : (flagsGrid.isBlocked((short)x,(short)y) ? Color.BLACK.getARGB() : (flagsGrid.isProtected((short)x,(short)y) ? Color.BLUE.getARGB() : 0)));
}"
56432,"private final boolean isEnemy(byte movablePlayer,IAttackable currMovable){
  return currMovable != null && currMovable.getPlayer() != movablePlayer && currMovable.isAttackable();
}","/** 
 * @param player The player id of the first player.
 * @param otherAttackable The other attackable. (Must not be null!)
 * @return
 */
public static boolean isEnemy(byte player,IAttackable otherAttackable){
  return otherAttackable.getPlayer() != player && otherAttackable.isAttackable();
}"
56433,"/** 
 * Lets the given movable enter the given position.
 * @param position Position to be entered.
 * @param movable Movable that enters the position.
 * @param informFullArea If true, the full soldier update area is informed if the given movable is attackable.<br> If false, only a circle is informed if the given movable is attackable.
 */
public final void movableEntered(ShortPoint2D position,NewMovable movable,boolean informFullArea){
  short x=position.getX();
  short y=position.getY();
  int idx=getIdx(x,y);
  if (idx < 0) {
    System.out.println(""String_Node_Str"");
  }
  this.movableGrid[idx]=movable;
  if (movable != null && movable.getMovableType() == EMovableType.BEARER) {
    ground.walkOn(x,y);
  }
  if (movable.isAttackable()) {
    IMapArea area;
    if (informFullArea) {
      area=new HexGridArea(x,y,(short)1,Constants.SOLDIER_SEARCH_RADIUS);
    }
 else {
      area=new HexBorderArea(x,y,(short)(Constants.SOLDIER_SEARCH_RADIUS - 1));
    }
    boolean foundOne=false;
    byte movablePlayer=movable.getPlayer();
    for (    ShortPoint2D curr : area) {
      short currX=curr.getX();
      short currY=curr.getY();
      if (0 <= currX && currX < width && 0 <= currY && currY < height) {
        NewMovable currMovable=getMovableAt(currX,currY);
        if (isEnemy(movablePlayer,currMovable)) {
          currMovable.informAboutAttackable(movable);
          if (!foundOne) {
            movable.informAboutAttackable(currMovable);
            foundOne=true;
          }
        }
      }
    }
  }
}","/** 
 * Lets the given movable enter the given position.
 * @param position Position to be entered.
 * @param movable Movable that enters the position.
 * @param informFullArea If true, the full soldier update area is informed if the given movable is attackable.<br> If false, only a circle is informed if the given movable is attackable.
 */
public final void movableEntered(ShortPoint2D position,NewMovable movable,boolean informFullArea){
  short x=position.getX();
  short y=position.getY();
  int idx=getIdx(x,y);
  if (idx < 0) {
    System.out.println(""String_Node_Str"");
  }
  this.movableGrid[idx]=movable;
  if (movable != null && movable.getMovableType() == EMovableType.BEARER) {
    ground.walkOn(x,y);
  }
  if (movable.isAttackable()) {
    IMapArea area;
    if (informFullArea) {
      area=new HexGridArea(x,y,(short)1,Constants.SOLDIER_SEARCH_RADIUS);
    }
 else {
      area=new HexBorderArea(x,y,(short)(Constants.SOLDIER_SEARCH_RADIUS - 1));
    }
    boolean foundOne=false;
    byte movablePlayer=movable.getPlayer();
    for (    ShortPoint2D curr : area) {
      short currX=curr.getX();
      short currY=curr.getY();
      if (0 <= currX && currX < width && 0 <= currY && currY < height) {
        NewMovable currMovable=getMovableAt(currX,currY);
        if (currMovable != null && isEnemy(movablePlayer,currMovable)) {
          currMovable.informAboutAttackable(movable);
          if (!foundOne) {
            movable.informAboutAttackable(currMovable);
            foundOne=true;
          }
        }
      }
    }
  }
}"
56434,"public NewMovable(INewMovableGrid grid,EMovableType movableType,ShortPoint2D position,byte player){
  this.grid=grid;
  this.position=position;
  this.player=player;
  this.strategy=NewMovableStrategy.getStrategy(this,movableType);
  this.movableType=movableType == EMovableType.TEST_MOVABLE ? EMovableType.SWORDSMAN_L1 : movableType;
  this.direction=EDirection.values[RandomSingleton.getInt(0,5)];
  MovableTimer.add(this);
  this.id=nextID++;
  movablesByID.put(this.id,this);
  allMovables.offer(this);
  grid.enterPosition(position,this,true);
}","public NewMovable(INewMovableGrid grid,EMovableType movableType,ShortPoint2D position,byte player){
  this.grid=grid;
  this.position=position;
  this.player=player;
  this.strategy=NewMovableStrategy.getStrategy(this,movableType);
  this.movableType=movableType;
  this.direction=EDirection.values[RandomSingleton.getInt(0,5)];
  MovableTimer.add(this);
  this.id=nextID++;
  movablesByID.put(this.id,this);
  allMovables.offer(this);
  grid.enterPosition(position,this,true);
}"
56435,"/** 
 * This method may only be called if this movable shall be informed about a movable that's in it's search radius.
 * @param other The other movable.
 */
public final void informAboutAttackable(NewMovable other){
  strategy.informAboutAttackable(other);
}","/** 
 * This method may only be called if this movable shall be informed about a movable that's in it's search radius.
 * @param other The other movable.
 */
@Override public final void informAboutAttackable(IAttackable other){
  strategy.informAboutAttackable(other);
}"
56436,"/** 
 * Searches for an enemy around the position of the given movable in it's search radius.
 * @param movable The movable searching an enemy.
 * @return The closest enemy or null if none exists in the search radius.
 */
IAttackable getEnemyInSearchArea(IAttackable movable);","/** 
 * Searches for an enemy around the position of the given movable in it's search radius.
 * @param movable The movable searching an enemy.
 * @return The closest enemy or null if none exists in the search radius.
 */
IAttackable getEnemyInSearchArea(NewMovable movable);"
56437,"@Override protected void hitEnemy(IAttackable enemy){
  enemy.hit(0.1f);
}","@Override protected void hitEnemy(IAttackable enemy){
  enemy.receiveHit(0.1f);
}"
56438,"private MovableTestWindow() throws InterruptedException {
  NetworkTimer.get().schedule();
  RandomSingleton.load(1000);
  MovableTestsMap grid=new MovableTestsMap(100,100);
  MapInterfaceConnector connector=TestWindow.openTestWindow(grid);
  movable=new NewMovable(grid.getMovableGrid(),EMovableType.TEST_MOVABLE,new ShortPoint2D(49,50),(byte)0);
  movable.setSelected(true);
  connector.setSelection(new SelectionSet(movable));
  connector.addListener(new IMapInterfaceListener(){
    @Override public void action(    Action action){
switch (action.getActionType()) {
case MOVE_TO:
        movable.moveTo(((MoveToAction)action).getPosition());
      break;
case SPEED_FASTER:
    NetworkTimer.multiplyGameSpeed(1.2f);
  break;
case SPEED_SLOWER:
NetworkTimer.multiplyGameSpeed(1 / 1.2f);
break;
case FAST_FORWARD:
NetworkTimer.get().fastForward();
break;
}
}
}
);
grid.getMovableGrid().dropMaterial(new ShortPoint2D(40,40),EMaterialType.PLANK,true);
grid.getMovableGrid().dropMaterial(new ShortPoint2D(60,60),EMaterialType.STONE,true);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(30,30),(byte)0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(31,31),(byte)0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(32,32),(byte)0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(33,33),(byte)0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(50,50),(byte)0);
{
for (int x=30; x < 40; x++) {
for (int y=80; y < 90; y++) {
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(x,y),(byte)0);
}
}
}
{
Thread.sleep(3000);
NewMovable m1=new NewMovable(grid.getMovableGrid(),EMovableType.TEST_MOVABLE,new ShortPoint2D(50,65),(byte)0);
NewMovable m2=new NewMovable(grid.getMovableGrid(),EMovableType.TEST_MOVABLE,new ShortPoint2D(51,65),(byte)0);
NewMovable m3=new NewMovable(grid.getMovableGrid(),EMovableType.TEST_MOVABLE,new ShortPoint2D(50,64),(byte)0);
m1.moveTo(new ShortPoint2D(52,65));
m2.moveTo(new ShortPoint2D(49,63));
m3.moveTo(new ShortPoint2D(50,66));
}
}","private MovableTestWindow() throws InterruptedException {
  NetworkTimer.get().schedule();
  RandomSingleton.load(1000);
  MovableTestsMap grid=new MovableTestsMap(100,100);
  MapInterfaceConnector connector=TestWindow.openTestWindow(grid);
  movable=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(49,50),(byte)0);
  movable.setSelected(true);
  connector.setSelection(new SelectionSet(movable));
  connector.addListener(new IMapInterfaceListener(){
    @Override public void action(    Action action){
switch (action.getActionType()) {
case MOVE_TO:
        movable.moveTo(((MoveToAction)action).getPosition());
      break;
case SPEED_FASTER:
    NetworkTimer.multiplyGameSpeed(1.2f);
  break;
case SPEED_SLOWER:
NetworkTimer.multiplyGameSpeed(1 / 1.2f);
break;
case FAST_FORWARD:
NetworkTimer.get().fastForward();
break;
}
}
}
);
grid.getMovableGrid().dropMaterial(new ShortPoint2D(40,40),EMaterialType.PLANK,true);
grid.getMovableGrid().dropMaterial(new ShortPoint2D(60,60),EMaterialType.STONE,true);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(30,30),(byte)0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(31,31),(byte)0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(32,32),(byte)0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(33,33),(byte)0);
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(50,50),(byte)0);
{
for (int x=30; x < 40; x++) {
for (int y=80; y < 90; y++) {
new NewMovable(grid.getMovableGrid(),EMovableType.BEARER,new ShortPoint2D(x,y),(byte)0);
}
}
}
{
Thread.sleep(3000);
NewMovable m1=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(50,65),(byte)0);
NewMovable m2=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(51,65),(byte)0);
NewMovable m3=new NewMovable(grid.getMovableGrid(),EMovableType.PIONEER,new ShortPoint2D(50,64),(byte)0);
m1.moveTo(new ShortPoint2D(52,65));
m2.moveTo(new ShortPoint2D(49,63));
m3.moveTo(new ShortPoint2D(50,66));
}
}"
56439,"@Override public NewMovable getEnemyInSearchArea(IAttackable movable){
  return null;
}","@Override public NewMovable getEnemyInSearchArea(NewMovable movable){
  return null;
}"
56440,"@Override public void hitWithArrowAt(short x,short y,float hitStrength){
  NewMovable movable=movableGrid.getMovableAt(x,y);
  if (movable != null) {
    movable.hit(hitStrength);
  }
}","@Override public void hitWithArrowAt(ArrowObject arrow){
  short x=arrow.getTargetX();
  short y=arrow.getTargetY();
  NewMovable movable=movableGrid.getMovableAt(x,y);
  if (movable != null) {
    movable.hit(arrow.getHitStrength());
    mapObjectsManager.removeMapObject(x,y,arrow);
  }
}"
56441,"/** 
 * Adds an arrow object to the map flying from
 * @param attackedPos Attacked position.
 * @param shooterPos Position of the shooter.
 * @param hitStrength Strength of the hit.
 */
public void addArrowObject(ShortPoint2D attackedPos,ShortPoint2D shooterPos,float hitStrength){
  ArrowObject arrow=new ArrowObject(grid,attackedPos,shooterPos,hitStrength);
  addMapObject(attackedPos,arrow);
  timingQueue.offer(new TimeEvent(arrow,arrow.getEndTime(),false));
  timingQueue.offer(new TimeEvent(arrow,arrow.getEndTime() + ArrowObject.DECOMPOSE_DELAY,true));
}","/** 
 * Adds an arrow object to the map flying from
 * @param attackedPos Attacked position.
 * @param shooterPos Position of the shooter.
 * @param hitStrength Strength of the hit.
 */
public void addArrowObject(ShortPoint2D attackedPos,ShortPoint2D shooterPos,float hitStrength){
  ArrowObject arrow=new ArrowObject(grid,attackedPos,shooterPos,hitStrength);
  addMapObject(attackedPos,arrow);
  timingQueue.offer(new TimeEvent(arrow,arrow.getEndTime(),false));
  timingQueue.offer(new TimeEvent(arrow,arrow.getEndTime() + ArrowObject.MIN_DECOMPOSE_DELAY * (1 + RandomSingleton.nextF()),true));
}"
56442,"@Override protected void startAttackAnimation(IAttackable enemy){
  super.playAction(EAction.ACTION1,BOWMAN_ATTACK_DURATION);
  super.getStrategyGrid().addArrowObject(enemy.getPos(),super.getPos(),0.7f);
}","@Override protected void startAttackAnimation(IAttackable enemy){
  super.playAction(EAction.ACTION1,BOWMAN_ATTACK_DURATION);
  super.getStrategyGrid().addArrowObject(enemy.getPos(),super.getPos(),0.1f);
}"
56443,"@Override protected void changeState(){
  grid.hitWithArrowAt(super.getX(),super.getY(),hitStrength);
}","@Override protected void changeState(){
  grid.hitWithArrowAt(this);
}"
56444,"/** 
 * If a movable is currently standing on the given position, it will be hit with the given hitStrength.
 * @param x X coordinate of the position.
 * @param y Y coordinate of the position.
 * @param hitStrength Strength of the hit.
 */
void hitWithArrowAt(short x,short y,float hitStrength);","/** 
 * If a movable is currently standing on the given position, it will be hit with the given arrow.
 * @param the arrow hitting the position.
 */
void hitWithArrowAt(ArrowObject arrowObject);"
56445,"/** 
 * Draws a player border at a given position.
 * @param player The player.
 */
public void drawPlayerBorderObject(int x,int y,byte player){
  int color=context.getPlayerColor(player).getABGR();
  draw(imageProvider.getSettlerSequence(FILE_BORDERPOST,65).getImageSafe(0),x,y,color);
}","/** 
 * Draws a player border at a given position.
 * @param player The player.
 */
public void drawPlayerBorderObject(int x,int y,byte player){
  byte fogstatus=context.getVisibleStatus(x,y);
  if (fogstatus == 0) {
    return;
  }
  float base=getColor(fogstatus);
  Color color=context.getPlayerColor(player);
  draw(imageProvider.getSettlerSequence(FILE_BORDERPOST,65).getImageSafe(0),x,y,color,base);
}"
56446,"@Override public void onDrawFrame(GL10 gl){
  GLES10.glClearColor(0,0,0,1);
  GLES10.glClear(GL10.GL_DEPTH_BUFFER_BIT | GL10.GL_COLOR_BUFFER_BIT);
  area.drawArea(drawcontext);
}","@Override public void onDrawFrame(GL10 gl){
  GLES10.glClearColor(0,0,0,1);
  GLES10.glClear(GL10.GL_DEPTH_BUFFER_BIT | GL10.GL_COLOR_BUFFER_BIT);
  GLES10.glScalef(1,1,.5f);
  area.drawArea(drawcontext);
}"
56447,void leaveOccupyableBuilding(ShortPoint2D pos);,void leaveOccupyableBuilding();
56448,void setSoldier(IBuildingOccupyableMovable soldier);,ShortPoint2D setSoldier(IBuildingOccupyableMovable soldier);
56449,"@Override protected final void killedEvent(){
  setSelected(false);
  if (occupiedArea) {
    MapCircle occupied=getOccupyablePositions();
    super.getGrid().freeOccupiedArea(occupied,super.getPos());
    int idx=0;
    for (    TowerOccupyer curr : occupiers) {
      curr.soldier.leaveOccupyableBuilding(super.getBuildingArea().get(idx));
      idx++;
    }
    occupiers.clear();
  }
  allOccupyingBuildings.remove(this);
}","@Override protected final void killedEvent(){
  setSelected(false);
  if (occupiedArea) {
    MapCircle occupied=getOccupyablePositions();
    super.getGrid().freeOccupiedArea(occupied,super.getPos());
    for (    TowerOccupyer curr : occupiers) {
      curr.soldier.leaveOccupyableBuilding();
    }
    occupiers.clear();
  }
  allOccupyingBuildings.remove(this);
}"
56450,"@Override public final void setSoldier(IBuildingOccupyableMovable soldier){
  for (  OccupyerPlace curr : emptyPlaces) {
    if (curr.getType() == soldier.getSoldierType()) {
      emptyPlaces.remove(curr);
      occupiers.add(new TowerOccupyer(curr,soldier));
      break;
    }
  }
  occupyArea();
  soldier.setSelected(super.isSelected());
}","@Override public final ShortPoint2D setSoldier(IBuildingOccupyableMovable soldier){
  OccupyerPlace freePosition=findFreePositionFor(soldier.getSoldierType());
  emptyPlaces.remove(freePosition);
  occupiers.add(new TowerOccupyer(freePosition,soldier));
  occupyArea();
  soldier.setSelected(super.isSelected());
  return freePosition.getPosition().calculatePoint(super.getPos());
}"
56451,"@Override protected final void constructionFinishedEvent(){
  for (  RelativePoint curr : super.getBuildingType().getAttackers()) {
    super.getGrid().getMapObjectsManager().addSimpleMapObject(curr.calculatePoint(super.getPos()),EMapObjectType.ATTACKABLE_TOWER,false,super.getPlayer());
  }
}","@Override protected final void constructionFinishedEvent(){
  super.getGrid().getMapObjectsManager().addAttackableTowerObject(super.getDoor(),this);
}"
56452,"@Override public NewMovable getEnemyInSearchArea(IAttackable movable){
  return movableGrid.getEnemyInSearchArea(movable);
}","@Override public IAttackable getEnemyInSearchArea(IAttackable movable){
  IAttackable enemy=movableGrid.getEnemyInSearchArea(movable);
  IAttackable tower=null;
  if (enemy == null) {
    return tower;
  }
 else   if (tower == null) {
    return enemy;
  }
 else {
    int enemyDist=movable.getPos().getOnGridDistTo(enemy.getPos());
    int towerDist=movable.getPos().getOnGridDistTo(tower.getPos());
    if (enemyDist < towerDist) {
      return enemy;
    }
 else {
      return tower;
    }
  }
}"
56453,"@Override public final int getDebugColorAt(int x,int y){
  short value=(short)(partitionsGrid.getPartitionAt((short)x,(short)y) + 1);
  return Color.getARGB((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
}","@Override public final int getDebugColorAt(int x,int y){
  return flagsGrid.isMarked((short)x,(short)y) ? Color.GREEN.getARGB() : (objectsGrid.getMapObjectAt((short)x,(short)y,EMapObjectType.ATTACKABLE_TOWER) != null ? Color.RED.getARGB() : (flagsGrid.isBlocked((short)x,(short)y) ? Color.BLACK.getARGB() : (flagsGrid.isProtected((short)x,(short)y) ? Color.BLUE.getARGB() : 0)));
}"
56454,"/** 
 * Lets the given movable enter the given position.
 * @param position Position to be entered.
 * @param movable Movable that enters the position.
 * @param informFullArea If true, the full soldier update area is informed if the given movable is attackable.<br> If false, only a circle is informed if the given movable is attackable.
 */
public final void movableEntered(ShortPoint2D position,NewMovable movable,boolean informFullArea){
  short x=position.getX();
  short y=position.getY();
  int idx=getIdx(x,y);
  if (idx < 0) {
    System.out.println(""String_Node_Str"");
  }
  this.movableGrid[idx]=movable;
  if (movable != null && movable.getMovableType() == EMovableType.BEARER) {
    ground.walkOn(x,y);
  }
  if (movable.isAttackable()) {
    IMapArea area;
    if (informFullArea) {
      area=new HexGridArea(x,y,(short)1,Constants.SOLDIER_SEARCH_RADIUS);
    }
 else {
      area=new HexBorderArea(x,y,(short)(Constants.SOLDIER_SEARCH_RADIUS - 1));
    }
    boolean foundOne=false;
    byte movablePlayer=movable.getPlayer();
    for (    ShortPoint2D curr : area) {
      short currX=curr.getX();
      short currY=curr.getY();
      if (0 <= currX && currX < width && 0 <= currY && currY < height) {
        NewMovable currMovable=getMovableAt(currX,currY);
        if (currMovable != null && currMovable.getPlayer() != movablePlayer) {
          currMovable.informAboutAttackable(movable);
          if (!foundOne) {
            movable.informAboutAttackable(currMovable);
            foundOne=true;
          }
        }
      }
    }
  }
}","/** 
 * Lets the given movable enter the given position.
 * @param position Position to be entered.
 * @param movable Movable that enters the position.
 * @param informFullArea If true, the full soldier update area is informed if the given movable is attackable.<br> If false, only a circle is informed if the given movable is attackable.
 */
public final void movableEntered(ShortPoint2D position,NewMovable movable,boolean informFullArea){
  short x=position.getX();
  short y=position.getY();
  int idx=getIdx(x,y);
  if (idx < 0) {
    System.out.println(""String_Node_Str"");
  }
  this.movableGrid[idx]=movable;
  if (movable != null && movable.getMovableType() == EMovableType.BEARER) {
    ground.walkOn(x,y);
  }
  if (movable.isAttackable()) {
    IMapArea area;
    if (informFullArea) {
      area=new HexGridArea(x,y,(short)1,Constants.SOLDIER_SEARCH_RADIUS);
    }
 else {
      area=new HexBorderArea(x,y,(short)(Constants.SOLDIER_SEARCH_RADIUS - 1));
    }
    boolean foundOne=false;
    byte movablePlayer=movable.getPlayer();
    for (    ShortPoint2D curr : area) {
      short currX=curr.getX();
      short currY=curr.getY();
      if (0 <= currX && currX < width && 0 <= currY && currY < height) {
        NewMovable currMovable=getMovableAt(currX,currY);
        if (isEnemy(movablePlayer,currMovable)) {
          currMovable.informAboutAttackable(movable);
          if (!foundOne) {
            movable.informAboutAttackable(currMovable);
            foundOne=true;
          }
        }
      }
    }
  }
}"
56455,"public NewMovable getEnemyInSearchArea(IAttackable movable){
  ShortPoint2D pos=movable.getPos();
  HexGridArea area=new HexGridArea(pos.getX(),pos.getY(),(short)1,Constants.SOLDIER_SEARCH_RADIUS);
  byte movablePlayer=movable.getPlayer();
  for (  ShortPoint2D curr : area) {
    short x=curr.getX();
    short y=curr.getY();
    if (0 <= x && x < width && 0 <= y && y < height) {
      NewMovable currMovable=getMovableAt(x,y);
      if (currMovable != null && currMovable.getPlayer() != movablePlayer) {
        return currMovable;
      }
    }
  }
  return null;
}","public IAttackable getEnemyInSearchArea(IAttackable movable){
  ShortPoint2D pos=movable.getPos();
  HexGridArea area=new HexGridArea(pos.getX(),pos.getY(),(short)1,Constants.SOLDIER_SEARCH_RADIUS);
  byte movablePlayer=movable.getPlayer();
  for (  ShortPoint2D curr : area) {
    short x=curr.getX();
    short y=curr.getY();
    if (0 <= x && x < width && 0 <= y && y < height) {
      IAttackable currMovable=getMovableAt(x,y);
      if (isEnemy(movablePlayer,currMovable)) {
        return currMovable;
      }
    }
  }
  return null;
}"
56456,"public ObjectsGrid(short width,short height){
  this.width=width;
  this.objectsGrid=new AbstractHexMapObject[width * height];
}","public ObjectsGrid(short width,short height){
  this.width=width;
  this.height=height;
  this.objectsGrid=new AbstractHexMapObject[width * height];
}"
56457,"@Override public void leaveOccupyableBuilding(ShortPoint2D pos){
  super.enableNothingToDoAction(true);
  super.setPosition(pos);
  super.setVisible(true);
  state=ESoldierState.AGGRESSIVE;
}","@Override public void leaveOccupyableBuilding(){
  super.enableNothingToDoAction(true);
  super.setVisible(true);
  state=ESoldierState.AGGRESSIVE;
}"
56458,"@Override protected void action(){
switch (state) {
case AGGRESSIVE:
    break;
case HITTING:
  hitEnemy(enemy);
if (enemy.getHealth() <= 0) {
  enemy=null;
  state=ESoldierState.ENEMY_FOUND;
  break;
}
case ENEMY_FOUND:
enemy=super.getStrategyGrid().getEnemyInSearchArea(super.getMovable());
if (enemy == null) {
changeStateTo(ESoldierState.AGGRESSIVE);
break;
}
if (isEnemyAttackable(enemy)) {
super.lookInDirection(EDirection.getApproxDirection(super.getPos(),enemy.getPos()));
startAttackAnimation(enemy);
state=ESoldierState.HITTING;
}
 else {
super.goToPos(enemy.getPos());
}
break;
case INIT_GOTO_TOWER:
super.goToPos(building.getDoor());
state=ESoldierState.GOING_TO_TOWER;
break;
case GOING_TO_TOWER:
super.enableNothingToDoAction(false);
super.setVisible(false);
building.setSoldier(this);
state=ESoldierState.IN_TOWER;
break;
case IN_TOWER:
break;
}
}","@Override protected void action(){
switch (state) {
case AGGRESSIVE:
    break;
case HITTING:
  hitEnemy(enemy);
if (enemy.getHealth() <= 0) {
  enemy=null;
  state=ESoldierState.ENEMY_FOUND;
  break;
}
case ENEMY_FOUND:
enemy=super.getStrategyGrid().getEnemyInSearchArea(super.getMovable());
if (enemy == null) {
changeStateTo(ESoldierState.AGGRESSIVE);
break;
}
if (isEnemyAttackable(enemy)) {
super.lookInDirection(EDirection.getApproxDirection(super.getPos(),enemy.getPos()));
startAttackAnimation(enemy);
state=ESoldierState.HITTING;
}
 else {
super.goToPos(enemy.getPos());
}
break;
case INIT_GOTO_TOWER:
super.goToPos(building.getDoor());
state=ESoldierState.GOING_TO_TOWER;
break;
case GOING_TO_TOWER:
ShortPoint2D pos=building.setSoldier(this);
super.setPosition(pos);
super.enableNothingToDoAction(false);
super.setVisible(false);
state=ESoldierState.IN_TOWER;
break;
case IN_TOWER:
break;
}
}"
56459,"public final boolean isAttackable(){
  return movableType.isMoveToAble();
}","@Override public final boolean isAttackable(){
  return movableType.isMoveToAble();
}"
56460,"@Override public void setOccupyableBuilding(IOccupyableBuilding building){
  this.building=building;
  this.state=ESoldierState.INIT_GOTO_TOWER;
}","@Override public void setOccupyableBuilding(IOccupyableBuilding building){
  this.building=building;
  this.state=ESoldierState.INIT_GOTO_TOWER;
  super.abortPath();
}"
56461,"private void finishConstruction(){
  constructionProgress=1;
  this.state=STATE_CONSTRUCTED;
  stacks=createWorkStacks();
  constructionFinishedEvent();
}","private void finishConstruction(){
  constructionProgress=1;
  this.state=STATE_CONSTRUCTED;
  if (getFlagType() == EMapObjectType.FLAG_DOOR) {
    createWorkStacks();
  }
  constructionFinishedEvent();
}"
56462,"private List<RequestStack> createWorkStacks(){
  RelativeStack[] requestStacks=type.getRequestStacks();
  List<RequestStack> result=new LinkedList<RequestStack>();
  for (int i=0; i < requestStacks.length; i++) {
    RelativeStack currStack=requestStacks[i];
    if (currStack.requiredForBuild() == 0) {
      result.add(new RequestStack(grid.getRequestStackGrid(),currStack.calculatePoint(this.pos),currStack.getType()));
    }
  }
  return result;
}","protected void createWorkStacks(){
  RelativeStack[] requestStacks=type.getRequestStacks();
  List<RequestStack> result=new LinkedList<RequestStack>();
  for (int i=0; i < requestStacks.length; i++) {
    RelativeStack currStack=requestStacks[i];
    if (currStack.requiredForBuild() == 0) {
      result.add(new RequestStack(grid.getRequestStackGrid(),currStack.calculatePoint(this.pos),currStack.getType()));
    }
  }
  this.stacks=result;
}"
56463,"private void requestDiggers(){
  if (shouldBeFlatened()) {
    RelativePoint[] blocked=getBuildingType().getBlockedTiles();
    int heightSum=0;
    for (    RelativePoint curr : blocked) {
      ShortPoint2D currPos=curr.calculatePoint(this.pos);
      heightSum+=this.grid.getHeightAt(currPos);
    }
    this.heightAvg=(byte)(heightSum / blocked.length);
    byte numberOfDiggers=(byte)Math.ceil(((float)blocked.length) / Constants.TILES_PER_DIGGER);
    grid.requestDiggers(this,numberOfDiggers);
  }
}","private void requestDiggers(){
  if (shouldBeFlatened()) {
    RelativePoint[] protectedTiles=getBuildingType().getProtectedTiles();
    int heightSum=0;
    for (    RelativePoint curr : protectedTiles) {
      ShortPoint2D currPos=curr.calculatePoint(this.pos);
      heightSum+=this.grid.getHeightAt(currPos);
    }
    this.heightAvg=(byte)(heightSum / protectedTiles.length);
    byte numberOfDiggers=(byte)Math.ceil(((float)protectedTiles.length) / Constants.TILES_PER_DIGGER);
    grid.requestDiggers(this,numberOfDiggers);
  }
}"
56464,"private void releaseRequestStacks(){
  for (  RequestStack curr : stacks) {
    curr.releaseRequests();
  }
  stacks=new LinkedList<RequestStack>();
}","protected void releaseRequestStacks(){
  for (  RequestStack curr : stacks) {
    curr.releaseRequests();
  }
  stacks=new LinkedList<RequestStack>();
}"
56465,"@Override protected final void constructionFinishedEvent(){
  super.getGrid().requestBuildingWorker(super.getBuildingType().getWorkerType(),this);
}","@Override protected final void constructionFinishedEvent(){
  requestWorker();
}"
56466,"@Override public final void occupyBuilding(IManageableWorker worker){
  if (super.isNotDestroyed()) {
    this.worker=worker;
    super.placeFlag(true);
  }
}","@Override public final void occupyBuilding(IManageableWorker worker){
  if (super.isNotDestroyed()) {
    this.worker=worker;
    super.placeFlag(true);
    super.createWorkStacks();
  }
}"
56467,"private void dropCurrMaterial(){
  if (super.getMaterial() != EMaterialType.NO_MATERIAL) {
    super.getStrategyGrid().dropMaterial(super.getPos(),super.getMaterial(),true);
    super.setMaterial(EMaterialType.NO_MATERIAL);
  }
}","private void dropCurrMaterial(){
  EMaterialType material=super.getMaterial();
  if (material.isDroppable()) {
    super.getStrategyGrid().dropMaterial(super.getPos(),material,true);
    super.setMaterial(EMaterialType.NO_MATERIAL);
  }
}"
56468,"@Override protected void strategyKilledEvent(ShortPoint2D pathTarget){
  dropCurrMaterial();
  if (isJobless()) {
    super.getStrategyGrid().removeJobless(this);
  }
}","@Override protected void strategyKilledEvent(ShortPoint2D pathTarget){
  dropCurrMaterial();
  if (building != null) {
    building.leaveBuilding(this);
  }
  if (isJobless()) {
    super.getStrategyGrid().removeJobless(this);
  }
}"
56469,"public void stopWatchdog(){
  if (executingTimerTask != null) {
    executingTimerTask.cancel();
  }
}","public void stopWatchdog(){
  if (watchdogTimerTask != null) {
    watchdogTimerTask.cancel();
  }
}"
56470,"public void setBlockingListener(ActionThreadBlockingListener listener){
  this.listener=listener;
}","/** 
 * Sets the listener to be notified on blocking state changes.
 * @param listener
 */
public void setBlockingListener(ActionThreadBlockingListener listener){
synchronized (blockingListenerMutex) {
    this.blockingListener=listener;
  }
}"
56471,"@Override public void fireAction(Action action){
  toFire.offer(action);
  fireStartTime.add(System.currentTimeMillis());
}","/** 
 * Schedules an action to be fired.
 */
@Override public void fireAction(Action action){
  toFire.offer(new FireringAction(action,System.currentTimeMillis()));
}"
56472,"protected void startWatchdog(long startTime){
  long destTime=startTime + ACTION_FIRERER_TIMEOUT;
  long timeUntilFreezeState=System.currentTimeMillis() - destTime;
  if (timeUntilFreezeState <= 0) {
    sendIsBlocking(true);
  }
 else {
    executingTimerTask=new TimerTask(){
      @Override public void run(){
        sendIsBlocking(true);
      }
    }
;
    watchdogTimer.schedule(executingTimerTask,timeUntilFreezeState);
  }
}","protected void startWatchdog(long startTime){
  long destTime=startTime + ACTION_FIRERER_TIMEOUT;
  long timeUntilFreezeState=System.currentTimeMillis() - destTime;
  if (timeUntilFreezeState <= 0) {
    sendIsBlocking(true);
  }
 else {
    watchdogTimerTask=new TimerTask(){
      @Override public void run(){
        sendIsBlocking(true);
      }
    }
;
    watchdogTimer.schedule(watchdogTimerTask,timeUntilFreezeState);
  }
}"
56473,"private void sendIsBlocking(boolean blocking){
  if (isBlockingSent != blocking && listener != null) {
    listener.actionThreadSlow(blocking);
  }
  isBlockingSent=blocking;
}","private void sendIsBlocking(boolean blocking){
synchronized (blockingListenerMutex) {
    if (isBlockingSent != blocking && blockingListener != null) {
      blockingListener.actionThreadSlow(blocking);
    }
    isBlockingSent=blocking;
  }
}"
56474,"public ActionFirerer(ActionFireable fireTo){
  this.fireTo=fireTo;
  this.thread=new ActionFirererThread();
  this.thread.setDaemon(true);
  this.thread.start();
}","/** 
 * Creates a new action firerer and starts it.
 * @param fireTo The object we should fire to.
 */
public ActionFirerer(ActionFireable fireTo){
  this.fireTo=fireTo;
  this.thread=new ActionFirererThread();
  this.thread.setDaemon(true);
  this.thread.start();
}"
56475,"/** 
 * Tests if this movable can receive moveTo requests and if so, directs it to go to the given position.
 * @param targetPosition
 */
public final void moveTo(ShortPoint2D targetPosition){
  if (movableType.isMoveToAble() && state != ENewMovableState.SLEEPING) {
    this.moveToRequest=targetPosition;
  }
}","/** 
 * Tests if this movable can receive moveTo requests and if so, directs it to go to the given position.
 * @param targetPosition
 */
public final void moveTo(ShortPoint2D targetPosition){
  if (movableType.isMoveToAble() && state != ENewMovableState.SLEEPING && strategy.isMoveToAble()) {
    this.moveToRequest=targetPosition;
  }
}"
56476,"/** 
 * @param duration in seconds<br> NOTE: duration MAY NEVER BE 0.0f
 */
protected final void setDuration(float duration){
  this.duration=(int)(duration * 1000);
  this.startTime=NetworkTimer.getGameTime();
}","/** 
 * @param duration in seconds<br> NOTE: duration MAY NEVER BE LESS OR EQUAL TO 0.0f
 */
protected final void setDuration(float duration){
}"
56477,"@Override protected float getGrowthDuration(){
  return 0;
}","@Override protected float getGrowthDuration(){
  return 0.01f;
}"
56478,"@Override protected void action(){
switch (state) {
case AGGRESSIVE:
    break;
case HITTING:
  hitEnemy(enemy);
case ENEMY_FOUND:
enemy=super.getStrategyGrid().getEnemyInSearchArea(super.getMovable());
if (enemy == null) {
state=ESoldierState.AGGRESSIVE;
break;
}
if (isEnemyAttackable(enemy)) {
super.lookInDirection(EDirection.getApproxDirection(super.getPos(),enemy.getPos()));
startAttackAnimation(enemy);
state=ESoldierState.HITTING;
}
 else {
super.goToPos(enemy.getPos());
}
break;
case INIT_GOTO_TOWER:
super.goToPos(building.getDoor());
state=ESoldierState.GOING_TO_TOWER;
break;
case GOING_TO_TOWER:
super.enableNothingToDoAction(false);
super.setVisible(false);
building.setSoldier(this);
state=ESoldierState.IN_TOWER;
break;
case IN_TOWER:
break;
}
}","@Override protected void action(){
switch (state) {
case AGGRESSIVE:
    break;
case HITTING:
  hitEnemy(enemy);
if (enemy.getHealth() <= 0) {
  enemy=null;
  state=ESoldierState.ENEMY_FOUND;
  break;
}
case ENEMY_FOUND:
enemy=super.getStrategyGrid().getEnemyInSearchArea(super.getMovable());
if (enemy == null) {
state=ESoldierState.AGGRESSIVE;
break;
}
if (isEnemyAttackable(enemy)) {
super.lookInDirection(EDirection.getApproxDirection(super.getPos(),enemy.getPos()));
startAttackAnimation(enemy);
state=ESoldierState.HITTING;
}
 else {
super.goToPos(enemy.getPos());
}
break;
case INIT_GOTO_TOWER:
super.goToPos(building.getDoor());
state=ESoldierState.GOING_TO_TOWER;
break;
case GOING_TO_TOWER:
super.enableNothingToDoAction(false);
super.setVisible(false);
building.setSoldier(this);
state=ESoldierState.IN_TOWER;
break;
case IN_TOWER:
break;
}
}"
56479,"@Override public boolean hasNoMovableAt(short x,short y){
  return movableGrid.getMovableAt(x,y) == null;
}","@Override public boolean hasNoMovableAt(short x,short y){
  return movableGrid.hasNoMovableAt(x,y);
}"
56480,"@Override public final int getDebugColorAt(int x,int y){
  return flagsGrid.isMarked((short)x,(short)y) ? Color.GREEN.getARGB() : (objectsGrid.getMapObjectAt((short)x,(short)y,EMapObjectType.ATTACKABLE_TOWER) != null ? Color.RED.getARGB() : (flagsGrid.isBlocked((short)x,(short)y) ? Color.BLACK.getARGB() : (flagsGrid.isProtected((short)x,(short)y) ? Color.BLUE.getARGB() : 0)));
}","@Override public final int getDebugColorAt(int x,int y){
  return Color.BLACK.getARGB();
}"
56481,"/** 
 * Lets the given movable enter the given position.
 * @param position Position to be entered.
 * @param movable Movable that enters the position.
 * @param informFullArea If true, the full soldier update area is informed if the given movable is attackable.<br> If false, only a circle is informed if the given movable is attackable.
 */
public final void movableEntered(ShortPoint2D position,NewMovable movable,boolean informFullArea){
  short x=position.getX();
  short y=position.getY();
  this.movableGrid[getIdx(x,y)]=movable;
  if (movable != null && movable.getMovableType() == EMovableType.BEARER) {
    ground.walkOn(x,y);
  }
  if (movable.isAttackable()) {
    IMapArea area;
    if (informFullArea) {
      area=new HexGridArea(x,y,(short)1,Constants.SOLDIER_SEARCH_RADIUS);
    }
 else {
      area=new HexBorderArea(x,y,(short)(Constants.SOLDIER_SEARCH_RADIUS - 1));
    }
    boolean foundOne=false;
    byte movablePlayer=movable.getPlayer();
    for (    ShortPoint2D curr : area) {
      NewMovable currMovable=getMovableAt(curr.getX(),curr.getY());
      if (currMovable != null && currMovable.getPlayer() != movablePlayer) {
        currMovable.informAboutAttackable(movable);
        if (!foundOne) {
          movable.informAboutAttackable(currMovable);
          foundOne=true;
        }
      }
    }
  }
}","/** 
 * Lets the given movable enter the given position.
 * @param position Position to be entered.
 * @param movable Movable that enters the position.
 * @param informFullArea If true, the full soldier update area is informed if the given movable is attackable.<br> If false, only a circle is informed if the given movable is attackable.
 */
public final void movableEntered(ShortPoint2D position,NewMovable movable,boolean informFullArea){
  short x=position.getX();
  short y=position.getY();
  int idx=getIdx(x,y);
  if (idx < 0) {
    System.out.println(""String_Node_Str"");
  }
  this.movableGrid[idx]=movable;
  if (movable != null && movable.getMovableType() == EMovableType.BEARER) {
    ground.walkOn(x,y);
  }
  if (movable.isAttackable()) {
    IMapArea area;
    if (informFullArea) {
      area=new HexGridArea(x,y,(short)1,Constants.SOLDIER_SEARCH_RADIUS);
    }
 else {
      area=new HexBorderArea(x,y,(short)(Constants.SOLDIER_SEARCH_RADIUS - 1));
    }
    boolean foundOne=false;
    byte movablePlayer=movable.getPlayer();
    for (    ShortPoint2D curr : area) {
      short currX=curr.getX();
      short currY=curr.getY();
      if (0 <= currX && currX < width && 0 <= currY && currY < height) {
        NewMovable currMovable=getMovableAt(currX,currY);
        if (currMovable != null && currMovable.getPlayer() != movablePlayer) {
          currMovable.informAboutAttackable(movable);
          if (!foundOne) {
            movable.informAboutAttackable(currMovable);
            foundOne=true;
          }
        }
      }
    }
  }
}"
56482,"public MovableGrid(short width,short height,IWalkableGround ground){
  this.width=width;
  this.ground=ground;
  this.movableGrid=new NewMovable[width * height];
}","public MovableGrid(short width,short height,IWalkableGround ground){
  this.width=width;
  this.height=height;
  this.ground=ground;
  this.movableGrid=new NewMovable[width * height];
}"
56483,"private void flockToDecentralize(){
  short x=position.getX(), y=position.getY();
  HexGridArea area=new HexGridArea(x,y,(short)1,NOTHING_TO_DO_MAX_RADIUS);
  float dx=0, dy=0;
  HexGridAreaIterator iter=area.iterator();
  while (iter.hasNext()) {
    short currX=iter.getNextX();
    short currY=iter.getNextY();
    int factor;
    if (!grid.isInBounds(currX,currY) || grid.isBlocked(currX,currY)) {
      factor=iter.getCurrRadius() == 1 ? 6 : 2;
    }
 else     if (grid.getMovableAt(currX,currY) != null) {
      factor=NOTHING_TO_DO_MAX_RADIUS - iter.getCurrRadius() + 1;
    }
 else {
      continue;
    }
    dx+=(short)(x - currX) * factor;
    dy+=(short)(y - currY) * factor;
  }
  dx+=direction.gridDeltaX;
  dy+=direction.gridDeltaY;
  if (Math.abs(dx) + Math.abs(dy) >= 4f) {
    this.goInDirection(EDirection.getApproxDirection(0,0,(int)dx,(int)dy));
    doingNothingProbablity=Math.min(doingNothingProbablity + 0.02f,0.1f);
  }
 else {
    doingNothingProbablity=Math.max(doingNothingProbablity - 0.02f,0.06f);
  }
}","private void flockToDecentralize(){
  short x=position.getX(), y=position.getY();
  HexGridArea area=new HexGridArea(x,y,(short)1,NOTHING_TO_DO_MAX_RADIUS);
  int dx=0, dy=0;
  HexGridAreaIterator iter=area.iterator();
  while (iter.hasNext()) {
    short currX=iter.getNextX();
    short currY=iter.getNextY();
    int factor;
    if (!grid.isInBounds(currX,currY) || grid.isBlocked(currX,currY)) {
      factor=iter.getCurrRadius() == 1 ? 6 : 2;
    }
 else     if (!grid.hasNoMovableAt(currX,currY)) {
      factor=NOTHING_TO_DO_MAX_RADIUS - iter.getCurrRadius() + 1;
    }
 else {
      continue;
    }
    dx+=(x - currX) * factor;
    dy+=(y - currY) * factor;
  }
  dx+=direction.gridDeltaX;
  dy+=direction.gridDeltaY;
  if (Math.abs(dx) + Math.abs(dy) >= 4f) {
    this.goInDirection(EDirection.getApproxDirection(0,0,dx,dy));
    doingNothingProbablity=Math.min(doingNothingProbablity + 0.02f,0.1f);
  }
 else {
    doingNothingProbablity=Math.max(doingNothingProbablity - 0.02f,0.06f);
  }
}"
56484,"@Override public void timerEvent(){
switch (state) {
case SLEEPING:
    return;
case DOING_NOTHING:
  if (visible && enableNothingToDo) {
    doingNothingAction();
  }
break;
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
progressCurrentAction();
break;
case PATHING:
pathingAction();
break;
}
if (moveToRequest != null) {
switch (state) {
case PATHING:
if (progress < 1) {
break;
}
setState(ENewMovableState.DOING_NOTHING);
case DOING_NOTHING:
ShortPoint2D oldTargetPos;
if (path != null) {
oldTargetPos=path.getTargetPos();
}
 else {
oldTargetPos=null;
}
goToPos(moveToRequest);
moveToRequest=null;
if (path != null) {
this.strategy.moveToPathSet(oldTargetPos,path.getTargetPos());
}
break;
}
}
if (state == ENewMovableState.DOING_NOTHING) {
strategy.action();
}
}","@Override public void timerEvent(){
  if (health <= 0) {
    return;
  }
switch (state) {
case SLEEPING:
    return;
case DOING_NOTHING:
  if (visible && enableNothingToDo) {
    doingNothingAction();
  }
break;
case GOING_SINGLE_STEP:
case PLAYING_ACTION:
progressCurrentAction();
break;
case PATHING:
pathingAction();
break;
}
if (moveToRequest != null) {
switch (state) {
case PATHING:
if (progress < 1) {
break;
}
setState(ENewMovableState.DOING_NOTHING);
case DOING_NOTHING:
ShortPoint2D oldTargetPos;
if (path != null) {
oldTargetPos=path.getTargetPos();
}
 else {
oldTargetPos=null;
}
goToPos(moveToRequest);
moveToRequest=null;
if (path != null) {
this.strategy.moveToPathSet(oldTargetPos,path.getTargetPos());
}
break;
}
}
if (state == ENewMovableState.DOING_NOTHING) {
strategy.action();
}
}"
56485,"private void followPath(Path path){
  this.path=path;
  setState(ENewMovableState.PATHING);
  this.movableAction=EAction.NO_ACTION;
  progress=1;
}","private void followPath(Path path){
  this.path=path;
  setState(ENewMovableState.PATHING);
  this.movableAction=EAction.NO_ACTION;
  progress=1;
  pathingAction();
}"
56486,"/** 
 * Forces the movable to go a step in the given direction (if it is not blocked).
 * @param direction direction to go
 */
final void forceGoInDirection(EDirection direction){
  ShortPoint2D targetPos=direction.getNextHexPoint(position);
  this.direction=direction;
  this.followPath(new Path(targetPos));
  this.goSinglePathStep();
  setState(ENewMovableState.PATHING);
}","/** 
 * Forces the movable to go a step in the given direction (if it is not blocked).
 * @param direction direction to go
 */
final void forceGoInDirection(EDirection direction){
  ShortPoint2D targetPos=direction.getNextHexPoint(position);
  this.direction=direction;
  this.followPath(new Path(targetPos));
  setState(ENewMovableState.PATHING);
}"
56487,"private <T extends Image>void drawSequences(GLDrawContext gl2,int width,int height,SequenceList<T> sequences){
  gl2.glTranslatef(offsetX,offsetY,0);
  int y=0;
  int seqIndex=0;
  TextDrawer drawer=JOGLTextDrawer.getTextDrawer(EFontSize.NORMAL,null);
  for (int i=0; i < sequences.size(); i++) {
    Sequence<T> seq=sequences.get(i);
    int maxheight;
    maxheight=drawSequence(gl2,width,height,y,seq);
    gl2.color(0,0,0,1);
    drawer.drawString(20,y + 20,seqIndex + ""String_Node_Str"");
    seqIndex++;
    y-=maxheight + 40;
  }
}","private <T extends Image>void drawSequences(GLDrawContext gl2,int width,int height,SequenceList<T> sequences){
  gl2.glTranslatef(offsetX,offsetY,0);
  int y=0;
  int seqIndex=0;
  TextDrawer drawer=gl2.getTextDrawer(EFontSize.NORMAL);
  for (int i=0; i < sequences.size(); i++) {
    Sequence<T> seq=sequences.get(i);
    int maxheight;
    maxheight=drawSequence(gl2,width,height,y,seq);
    gl2.color(0,0,0,1);
    drawer.drawString(20,y + 20,seqIndex + ""String_Node_Str"");
    seqIndex++;
    y-=maxheight + 40;
  }
}"
56488,"private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException {
  ois.defaultReadObject();
}","private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException {
  ois.defaultReadObject();
  enabled=true;
}"
56489,"public void mergeInto(PartitionManager newManager){
  newManager.bricklayerRequests.addAll(this.bricklayerRequests);
  newManager.diggerRequests.addAll(this.diggerRequests);
  newManager.joblessBearer.addAll(this.joblessBearer);
  newManager.joblessBricklayers.addAll(this.joblessBricklayers);
  newManager.joblessDiggers.addAll(this.joblessDiggers);
  newManager.joblessWorkers.addAll(this.joblessWorkers);
  newManager.materialOffers.addAll(this.materialOffers);
  newManager.materialRequests.addAll(this.materialRequests);
  newManager.soilderCreationRequests.addAll(this.soilderCreationRequests);
  newManager.workerCreationRequests.addAll(this.workerCreationRequests);
  newManager.workerRequests.addAll(this.workerRequests);
  newManager.toolProductionRequests.addAll(toolProductionRequests);
  newManager.weaponProductionRequests.addAll(weaponProductionRequests);
}","public void mergeInto(PartitionManager newManager){
  newManager.bricklayerRequests.addAll(this.bricklayerRequests);
  newManager.diggerRequests.addAll(this.diggerRequests);
  newManager.joblessBearer.addAll(this.joblessBearer);
  newManager.joblessBricklayers.addAll(this.joblessBricklayers);
  newManager.joblessDiggers.addAll(this.joblessDiggers);
  newManager.joblessWorkers.addAll(this.joblessWorkers);
  newManager.materialOffers.addAll(this.materialOffers);
  newManager.materialRequests.addAll(this.materialRequests);
  newManager.soilderCreationRequests.addAll(this.soilderCreationRequests);
  newManager.workerCreationRequests.addAll(this.workerCreationRequests);
  newManager.workerRequests.addAll(this.workerRequests);
  newManager.toolProductionRequests.addAll(toolProductionRequests);
  newManager.weaponProductionRequests.addAll(weaponProductionRequests);
  newManager.toolRequestingWorkerRequests.merge(this.toolRequestingWorkerRequests);
}"
56490,"private void handleWorkerCreationRequest(){
  WorkerCreationRequest workerRequest=workerCreationRequests.poll();
  if (workerRequest != null && workerRequest.movableType == EMovableType.SMITH) {
    System.err.println(""String_Node_Str"");
  }
  if (workerRequest != null) {
    EMaterialType tool=workerRequest.movableType.getTool();
    if (tool != EMaterialType.NO_MATERIAL) {
      this.materialTypeAcceptor.materialType=tool;
      Offer offer=this.materialOffers.getObjectNextTo(workerRequest.position,this.materialTypeAcceptor);
      if (offer != null) {
        IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(workerRequest.position);
        if (manageableBearer != null) {
          manageableBearer.becomeWorker(this,workerRequest.movableType,offer.position);
          reduceOfferAmount(offer);
        }
 else {
          workerCreationRequests.addLast(workerRequest);
        }
      }
 else {
        if (!workerRequest.produceToolRequested) {
          requestToolProduction(tool,workerRequest.position);
          workerRequest.produceToolRequested=true;
        }
        workerCreationRequests.addLast(workerRequest);
      }
    }
 else {
      IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(workerRequest.position);
      if (manageableBearer != null) {
        manageableBearer.becomeWorker(this,workerRequest.movableType);
      }
 else {
        workerCreationRequests.addLast(workerRequest);
      }
    }
  }
}","private void handleWorkerCreationRequest(){
  EMaterialType[] slotTypes=toolRequestingWorkerRequests.getSlotTypes();
  for (int slot=0; slot < slotTypes.length; slot++) {
    WorkerCreationRequest request=toolRequestingWorkerRequests.popFront(slot);
    if (request != null) {
      this.materialTypeAcceptor.materialType=slotTypes[slot];
      Offer offer=this.materialOffers.getObjectNextTo(request.position,this.materialTypeAcceptor);
      if (offer != null) {
        IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(request.position);
        if (manageableBearer != null) {
          manageableBearer.becomeWorker(this,request.movableType,offer.position);
          reduceOfferAmount(offer);
        }
 else {
          toolRequestingWorkerRequests.pushLast(slot,request);
        }
      }
 else {
        toolRequestingWorkerRequests.pushLast(slot,request);
      }
    }
  }
  WorkerCreationRequest workerRequest=workerCreationRequests.poll();
  if (workerRequest != null) {
    EMaterialType tool=workerRequest.movableType.getTool();
    if (tool != EMaterialType.NO_MATERIAL) {
      if (toolRequestingWorkerRequests.isSlotEmpty(workerRequest.movableType.getTool())) {
        this.materialTypeAcceptor.materialType=tool;
        Offer offer=this.materialOffers.getObjectNextTo(workerRequest.position,this.materialTypeAcceptor);
        if (offer != null) {
          IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(workerRequest.position);
          if (manageableBearer != null) {
            manageableBearer.becomeWorker(this,workerRequest.movableType,offer.position);
            reduceOfferAmount(offer);
          }
 else {
            workerCreationRequests.addLast(workerRequest);
          }
        }
 else {
          toolProductionRequests.add(tool,new ProductionRequest(tool,workerRequest.position));
          toolRequestingWorkerRequests.pushLast(tool,workerRequest);
        }
      }
 else {
        workerCreationRequests.addLast(workerRequest);
      }
    }
 else {
      IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(workerRequest.position);
      if (manageableBearer != null) {
        manageableBearer.becomeWorker(this,workerRequest.movableType);
      }
 else {
        workerCreationRequests.addLast(workerRequest);
      }
    }
  }
}"
56491,"private void popToolRequestAction(){
  if (poppedMaterial != null) {
    System.err.println(""String_Node_Str"");
  }
  ShortPoint2D pos=building.getDoor();
  poppedMaterial=super.getStrategyGrid().popToolProductionRequest(pos);
  if (poppedMaterial != null) {
    jobFinished();
  }
 else {
    jobFailed();
  }
}","private void popToolRequestAction(){
  ShortPoint2D pos=building.getDoor();
  poppedMaterial=super.getStrategyGrid().popToolProductionRequest(pos);
  if (poppedMaterial != null) {
    jobFinished();
  }
 else {
    jobFailed();
  }
}"
56492,"@Override protected void action(){
  if (isJobless())   return;
  if (!building.isNotDestroyed()) {
    buildingDestroyed();
    return;
  }
switch (currentJob.getType()) {
case GO_TO:
    gotoAction();
  break;
case IS_PRODUCTIVE:
if (isProductive()) {
  jobFinished();
}
 else {
  jobFailed();
}
break;
case WAIT:
waitSeconds();
break;
case WALK:
super.forceGoInDirection(currentJob.getDirection());
jobFinished();
break;
case SHOW:
ShortPoint2D pos=getCurrentJobPos();
super.setPosition(pos);
super.setVisible(true);
jobFinished();
break;
case HIDE:
super.setVisible(false);
jobFinished();
break;
case SET_MATERIAL:
super.setMaterial(currentJob.getMaterial());
jobFinished();
break;
case TAKE:
takeAction();
break;
case REMOTETAKE:
if (this.building.popMaterial(getCurrentJobPos(),currentJob.getMaterial())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case DROP:
dropAction(currentJob.getMaterial());
break;
case DROP_POPPED:
boolean oldDone=done;
dropAction(poppedMaterial);
if (oldDone) poppedMaterial=null;
break;
case PRE_SEARCH:
preSearchPathAction(true);
break;
case PRE_SEARCH_IN_AREA:
preSearchPathAction(false);
break;
case FOLLOW_SEARCHED:
followPreSearchedAction();
break;
case LOOK_AT_SEARCHED:
lookAtSearched();
break;
case LOOK_AT:
super.lookInDirection(currentJob.getDirection());
jobFinished();
break;
case EXECUTE:
executeAction();
break;
case PLAY_ACTION1:
super.playAction(EAction.ACTION1,currentJob.getTime());
jobFinished();
break;
case PLAY_ACTION2:
super.playAction(EAction.ACTION2,currentJob.getTime());
jobFinished();
break;
case AVAILABLE:
if (super.getStrategyGrid().canPop(getCurrentJobPos(),currentJob.getMaterial())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case NOT_FULL:
if (super.getStrategyGrid().canPushMaterial(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case SMOKE_ON:
case SMOKE_OFF:
{
super.getStrategyGrid().placeSmoke(getCurrentJobPos(),currentJob.getType() == EBuildingJobType.SMOKE_ON);
jobFinished();
break;
}
case START_WORKING:
case STOP_WORKING:
if (building instanceof MillBuilding) {
((MillBuilding)building).setRotating(currentJob.getType() == EBuildingJobType.START_WORKING);
}
jobFinished();
break;
case PIG_IS_ADULT:
if (super.getStrategyGrid().isPigAdult(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_IS_THERE:
if (super.getStrategyGrid().hasPigAt(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_PLACE:
case PIG_REMOVE:
placeOrRemovePigAction();
break;
case POP_TOOL:
popToolRequestAction();
break;
}
}","@Override protected void action(){
  if (isJobless())   return;
  if (!building.isNotDestroyed()) {
    buildingDestroyed();
    return;
  }
switch (currentJob.getType()) {
case GO_TO:
    gotoAction();
  break;
case IS_PRODUCTIVE:
if (isProductive()) {
  jobFinished();
}
 else {
  jobFailed();
}
break;
case WAIT:
waitSeconds();
break;
case WALK:
super.forceGoInDirection(currentJob.getDirection());
jobFinished();
break;
case SHOW:
ShortPoint2D pos=getCurrentJobPos();
super.setPosition(pos);
super.setVisible(true);
jobFinished();
break;
case HIDE:
super.setVisible(false);
jobFinished();
break;
case SET_MATERIAL:
super.setMaterial(currentJob.getMaterial());
jobFinished();
break;
case TAKE:
takeAction();
break;
case REMOTETAKE:
if (this.building.popMaterial(getCurrentJobPos(),currentJob.getMaterial())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case DROP:
dropAction(currentJob.getMaterial());
break;
case DROP_POPPED:
dropAction(poppedMaterial);
break;
case PRE_SEARCH:
preSearchPathAction(true);
break;
case PRE_SEARCH_IN_AREA:
preSearchPathAction(false);
break;
case FOLLOW_SEARCHED:
followPreSearchedAction();
break;
case LOOK_AT_SEARCHED:
lookAtSearched();
break;
case LOOK_AT:
super.lookInDirection(currentJob.getDirection());
jobFinished();
break;
case EXECUTE:
executeAction();
break;
case PLAY_ACTION1:
super.playAction(EAction.ACTION1,currentJob.getTime());
jobFinished();
break;
case PLAY_ACTION2:
super.playAction(EAction.ACTION2,currentJob.getTime());
jobFinished();
break;
case AVAILABLE:
if (super.getStrategyGrid().canPop(getCurrentJobPos(),currentJob.getMaterial())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case NOT_FULL:
if (super.getStrategyGrid().canPushMaterial(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case SMOKE_ON:
case SMOKE_OFF:
{
super.getStrategyGrid().placeSmoke(getCurrentJobPos(),currentJob.getType() == EBuildingJobType.SMOKE_ON);
jobFinished();
break;
}
case START_WORKING:
case STOP_WORKING:
if (building instanceof MillBuilding) {
((MillBuilding)building).setRotating(currentJob.getType() == EBuildingJobType.START_WORKING);
}
jobFinished();
break;
case PIG_IS_ADULT:
if (super.getStrategyGrid().isPigAdult(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_IS_THERE:
if (super.getStrategyGrid().hasPigAt(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_PLACE:
case PIG_REMOVE:
placeOrRemovePigAction();
break;
case POP_TOOL:
popToolRequestAction();
break;
}
}"
56493,"@Override public final void occupyBuilding(IManageableWorker worker){
  this.worker=worker;
  super.placeFlag(true);
}","@Override public final void occupyBuilding(IManageableWorker worker){
  if (super.isNotDestroyed()) {
    this.worker=worker;
    super.placeFlag(true);
  }
}"
56494,"private void handleWorkerCreationRequest(){
  WorkerCreationRequest workerRequest=workerCreationRequests.poll();
  if (workerRequest != null) {
    EMaterialType tool=workerRequest.movableType.getTool();
    if (tool != EMaterialType.NO_MATERIAL) {
      this.materialTypeAcceptor.materialType=tool;
      Offer offer=this.materialOffers.getObjectNextTo(workerRequest.position,this.materialTypeAcceptor);
      if (offer != null) {
        IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(workerRequest.position);
        if (manageableBearer != null) {
          manageableBearer.becomeWorker(this,workerRequest.movableType,offer.position);
          reduceOfferAmount(offer);
        }
 else {
          workerCreationRequests.addLast(workerRequest);
        }
      }
 else {
        if (!workerRequest.produceToolRequested) {
          requestToolProduction(tool,workerRequest.position);
          workerRequest.produceToolRequested=true;
        }
        workerCreationRequests.addLast(workerRequest);
      }
    }
 else {
      IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(workerRequest.position);
      if (manageableBearer != null) {
        manageableBearer.becomeWorker(this,workerRequest.movableType);
      }
 else {
        workerCreationRequests.addLast(workerRequest);
      }
    }
  }
}","private void handleWorkerCreationRequest(){
  WorkerCreationRequest workerRequest=workerCreationRequests.poll();
  if (workerRequest != null && workerRequest.movableType == EMovableType.SMITH) {
    System.err.println(""String_Node_Str"");
  }
  if (workerRequest != null) {
    EMaterialType tool=workerRequest.movableType.getTool();
    if (tool != EMaterialType.NO_MATERIAL) {
      this.materialTypeAcceptor.materialType=tool;
      Offer offer=this.materialOffers.getObjectNextTo(workerRequest.position,this.materialTypeAcceptor);
      if (offer != null) {
        IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(workerRequest.position);
        if (manageableBearer != null) {
          manageableBearer.becomeWorker(this,workerRequest.movableType,offer.position);
          reduceOfferAmount(offer);
        }
 else {
          workerCreationRequests.addLast(workerRequest);
        }
      }
 else {
        if (!workerRequest.produceToolRequested) {
          requestToolProduction(tool,workerRequest.position);
          workerRequest.produceToolRequested=true;
        }
        workerCreationRequests.addLast(workerRequest);
      }
    }
 else {
      IManageableBearer manageableBearer=joblessBearer.removeObjectNextTo(workerRequest.position);
      if (manageableBearer != null) {
        manageableBearer.becomeWorker(this,workerRequest.movableType);
      }
 else {
        workerCreationRequests.addLast(workerRequest);
      }
    }
  }
}"
56495,"@Override public void setWorkerJob(IWorkerRequestBuilding building){
  this.building=building;
  building.occupyBuilding(this);
  this.currentJob=building.getBuildingType().getStartJob();
  super.enableNothingToDoAction(false);
  this.done=false;
}","@Override public void setWorkerJob(IWorkerRequestBuilding building){
  this.building=building;
  this.currentJob=building.getBuildingType().getStartJob();
  super.enableNothingToDoAction(false);
  this.done=false;
  building.occupyBuilding(this);
}"
56496,"private void popToolRequestAction(){
  ShortPoint2D pos=building.getDoor();
  poppedMaterial=super.getStrategyGrid().popToolProductionRequest(pos);
  if (poppedMaterial != null) {
    jobFinished();
  }
 else {
    jobFailed();
  }
}","private void popToolRequestAction(){
  if (poppedMaterial != null) {
    System.err.println(""String_Node_Str"");
  }
  ShortPoint2D pos=building.getDoor();
  poppedMaterial=super.getStrategyGrid().popToolProductionRequest(pos);
  if (poppedMaterial != null) {
    jobFinished();
  }
 else {
    jobFailed();
  }
}"
56497,"@Override protected void action(){
  if (isJobless())   return;
switch (currentJob.getType()) {
case GO_TO:
    gotoAction();
  break;
case IS_PRODUCTIVE:
if (isProductive()) {
  jobFinished();
}
 else {
  jobFailed();
}
break;
case WAIT:
waitSeconds();
break;
case WALK:
super.forceGoInDirection(currentJob.getDirection());
jobFinished();
break;
case SHOW:
ShortPoint2D pos=getCurrentJobPos();
super.setPosition(pos);
super.setVisible(true);
jobFinished();
break;
case HIDE:
super.setVisible(false);
jobFinished();
break;
case SET_MATERIAL:
super.setMaterial(currentJob.getMaterial());
jobFinished();
break;
case TAKE:
takeAction();
break;
case REMOTETAKE:
if (this.building.popMaterial(getCurrentJobPos(),currentJob.getMaterial())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case DROP:
dropAction(currentJob.getMaterial());
break;
case DROP_POPPED:
dropAction(poppedMaterial);
break;
case PRE_SEARCH:
preSearchPathAction(true);
break;
case PRE_SEARCH_IN_AREA:
preSearchPathAction(false);
break;
case FOLLOW_SEARCHED:
followPreSearchedAction();
break;
case LOOK_AT_SEARCHED:
lookAtSearched();
break;
case LOOK_AT:
super.lookInDirection(currentJob.getDirection());
jobFinished();
break;
case EXECUTE:
executeAction();
break;
case PLAY_ACTION1:
super.playAction(EAction.ACTION1,currentJob.getTime());
jobFinished();
break;
case PLAY_ACTION2:
super.playAction(EAction.ACTION2,currentJob.getTime());
jobFinished();
break;
case AVAILABLE:
if (super.getStrategyGrid().canPop(getCurrentJobPos(),currentJob.getMaterial())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case NOT_FULL:
if (super.getStrategyGrid().canPushMaterial(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case SMOKE_ON:
case SMOKE_OFF:
{
super.getStrategyGrid().placeSmoke(getCurrentJobPos(),currentJob.getType() == EBuildingJobType.SMOKE_ON);
jobFinished();
break;
}
case START_WORKING:
case STOP_WORKING:
if (building instanceof MillBuilding) {
((MillBuilding)building).setRotating(currentJob.getType() == EBuildingJobType.START_WORKING);
}
jobFinished();
break;
case PIG_IS_ADULT:
if (super.getStrategyGrid().isPigAdult(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_IS_THERE:
if (super.getStrategyGrid().hasPigAt(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_PLACE:
case PIG_REMOVE:
placeOrRemovePigAction();
break;
case POP_TOOL:
popToolRequestAction();
break;
}
}","@Override protected void action(){
  if (isJobless())   return;
  if (!building.isNotDestroyed()) {
    buildingDestroyed();
    return;
  }
switch (currentJob.getType()) {
case GO_TO:
    gotoAction();
  break;
case IS_PRODUCTIVE:
if (isProductive()) {
  jobFinished();
}
 else {
  jobFailed();
}
break;
case WAIT:
waitSeconds();
break;
case WALK:
super.forceGoInDirection(currentJob.getDirection());
jobFinished();
break;
case SHOW:
ShortPoint2D pos=getCurrentJobPos();
super.setPosition(pos);
super.setVisible(true);
jobFinished();
break;
case HIDE:
super.setVisible(false);
jobFinished();
break;
case SET_MATERIAL:
super.setMaterial(currentJob.getMaterial());
jobFinished();
break;
case TAKE:
takeAction();
break;
case REMOTETAKE:
if (this.building.popMaterial(getCurrentJobPos(),currentJob.getMaterial())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case DROP:
dropAction(currentJob.getMaterial());
break;
case DROP_POPPED:
boolean oldDone=done;
dropAction(poppedMaterial);
if (oldDone) poppedMaterial=null;
break;
case PRE_SEARCH:
preSearchPathAction(true);
break;
case PRE_SEARCH_IN_AREA:
preSearchPathAction(false);
break;
case FOLLOW_SEARCHED:
followPreSearchedAction();
break;
case LOOK_AT_SEARCHED:
lookAtSearched();
break;
case LOOK_AT:
super.lookInDirection(currentJob.getDirection());
jobFinished();
break;
case EXECUTE:
executeAction();
break;
case PLAY_ACTION1:
super.playAction(EAction.ACTION1,currentJob.getTime());
jobFinished();
break;
case PLAY_ACTION2:
super.playAction(EAction.ACTION2,currentJob.getTime());
jobFinished();
break;
case AVAILABLE:
if (super.getStrategyGrid().canPop(getCurrentJobPos(),currentJob.getMaterial())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case NOT_FULL:
if (super.getStrategyGrid().canPushMaterial(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case SMOKE_ON:
case SMOKE_OFF:
{
super.getStrategyGrid().placeSmoke(getCurrentJobPos(),currentJob.getType() == EBuildingJobType.SMOKE_ON);
jobFinished();
break;
}
case START_WORKING:
case STOP_WORKING:
if (building instanceof MillBuilding) {
((MillBuilding)building).setRotating(currentJob.getType() == EBuildingJobType.START_WORKING);
}
jobFinished();
break;
case PIG_IS_ADULT:
if (super.getStrategyGrid().isPigAdult(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_IS_THERE:
if (super.getStrategyGrid().hasPigAt(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_PLACE:
case PIG_REMOVE:
placeOrRemovePigAction();
break;
case POP_TOOL:
popToolRequestAction();
break;
}
}"
56498,"public void addImage(int texture,float x1,float y1,float x2,float y2,float u1,float v1,float u2,float v2,int activeColor){
  setZ(getZ() + .0001f);
  getBuffer(texture).addImage(x1,y1,x2,y2,u1,v1,u2,v2,activeColor);
}","public void addImage(int texture,float x1,float y1,float x2,float y2,float u1,float v1,float u2,float v2,int activeColor){
  setZ(getZ() + .00001f);
  getBuffer(texture).addImage(x1,y1,x2,y2,u1,v1,u2,v2,activeColor);
}"
56499,"public void leavePosition(){
  int offset=RandomSingleton.getInt(0,EDirection.NUMBER_OF_DIRECTIONS - 1);
  for (int i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
    EDirection currDir=EDirection.values[(i + offset) % EDirection.NUMBER_OF_DIRECTIONS];
    if (goInDirection(currDir)) {
      break;
    }
 else {
      NewMovable movableAtPos=grid.getMovableAt(currDir.getNextTileX(position.getX()),currDir.getNextTileY(position.getY()));
      if (movableAtPos != null) {
        movableAtPos.push(this);
      }
    }
  }
}","public void leavePosition(){
  if (!enableNothingToDo) {
    return;
  }
  int offset=RandomSingleton.getInt(0,EDirection.NUMBER_OF_DIRECTIONS - 1);
  for (int i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
    EDirection currDir=EDirection.values[(i + offset) % EDirection.NUMBER_OF_DIRECTIONS];
    if (goInDirection(currDir)) {
      break;
    }
 else {
      NewMovable movableAtPos=grid.getMovableAt(currDir.getNextTileX(position.getX()),currDir.getNextTileY(position.getY()));
      if (movableAtPos != null) {
        movableAtPos.push(this);
      }
    }
  }
}"
56500,"/** 
 * Forces the movable to go a step in the given direction (if it is not blocked).
 * @param direction direction to go
 */
final void forceGoInDirection(EDirection direction){
  ShortPoint2D targetPos=direction.getNextHexPoint(position);
  this.direction=direction;
  this.followPath(new Path(targetPos));
  this.goSinglePathStep();
}","/** 
 * Forces the movable to go a step in the given direction (if it is not blocked).
 * @param direction direction to go
 */
final void forceGoInDirection(EDirection direction){
  ShortPoint2D targetPos=direction.getNextHexPoint(position);
  this.direction=direction;
  this.followPath(new Path(targetPos));
  this.goSinglePathStep();
  setState(ENewMovableState.PATHING);
}"
56501,"/** 
 * Sets the state to the given one and resets the movable to a clean start of this state.
 * @param newState
 */
private void setState(ENewMovableState newState){
  this.state=newState;
}","/** 
 * Sets the state to the given one and resets the movable to a clean start of this state.
 * @param newState
 */
private void setState(ENewMovableState newState){
  this.formerState=this.state;
  this.state=newState;
}"
56502,"public final boolean pushMaterial(ShortPoint2D position,EMaterialType materialType){
  return getPartitionObject(position.getX(),position.getY()).pushMaterial(position,materialType);
}","public final boolean pushMaterial(ShortPoint2D position,EMaterialType materialType){
  return getPartitionObject(position.getX(),position.getY()).addOffer(position,materialType);
}"
56503,"public IManageableBearer removeJobless(ShortPoint2D position){
  return joblessBearer.removeObjectAt(position);
}","public void removeJobless(IManageableWorker worker){
  joblessWorkers.remove(worker);
}"
56504,"private void reportAsJobless(){
  super.getStrategyGrid().addJoblessBearer(this);
}","private void reportAsJobless(){
  super.getStrategyGrid().addJobless(this);
}"
56505,"@Override protected void strategyKilledEvent(ShortPoint2D pathTarget){
  handleJobFailed(false);
  state=EBearerState.DEAD_OBJECT;
}","@Override protected void strategyKilledEvent(ShortPoint2D pathTarget){
  if (state == EBearerState.JOBLESS) {
    super.getStrategyGrid().removeJobless(this);
  }
 else {
    handleJobFailed(false);
  }
  state=EBearerState.DEAD_OBJECT;
}"
56506,"/** 
 * creates a new area conaainer
 * @param area The area to display
 */
public AreaContainer(Area area){
  this.area=area;
  this.setLayout(new BorderLayout());
  GLProfile profile=GLProfile.getDefault();
  GLCapabilities cap=new GLCapabilities(profile);
  cap.setStencilBits(1);
  canvas=new GLCanvas(cap);
  new GOSwingEventConverter(canvas,this);
  canvas.addGLEventListener(new GLEventListener(){
    @Override public void reshape(    GLAutoDrawable gl,    int x,    int y,    int width,    int height){
      resizeArea(gl.getGL().getGL2(),x,y,width,height);
    }
    @Override public void init(    GLAutoDrawable arg0){
      arg0.getGL().setSwapInterval(0);
    }
    @Override public void dispose(    GLAutoDrawable arg0){
    }
    @Override public void display(    GLAutoDrawable glDrawable){
      draw(glDrawable.getGL().getGL2());
    }
  }
);
  this.add(canvas);
  area.addRedrawListener(this);
}","/** 
 * creates a new area conaainer
 * @param area The area to display
 */
public AreaContainer(Area area,boolean forceLightweight){
  this.area=area;
  this.setLayout(new BorderLayout());
  GLProfile profile=GLProfile.getDefault();
  GLCapabilities cap=new GLCapabilities(profile);
  cap.setStencilBits(1);
  GLEventListener glEventListener=new GLEventListener(){
    @Override public void reshape(    GLAutoDrawable gl,    int x,    int y,    int width,    int height){
      resizeArea(gl.getGL().getGL2(),x,y,width,height);
    }
    @Override public void init(    GLAutoDrawable arg0){
      arg0.getGL().setSwapInterval(0);
    }
    @Override public void dispose(    GLAutoDrawable arg0){
    }
    @Override public void display(    GLAutoDrawable glDrawable){
      draw(glDrawable.getGL().getGL2());
    }
  }
;
  if (forceLightweight) {
    GLJPanel panel=new GLJPanel(cap);
    panel.addGLEventListener(glEventListener);
    canvas=panel;
  }
 else {
    GLCanvas glCanvas=new GLCanvas(cap);
    glCanvas.addGLEventListener(glEventListener);
    canvas=glCanvas;
  }
  new GOSwingEventConverter(canvas,this);
  area.addRedrawListener(this);
  this.add(canvas);
}"
56507,"/** 
 * Draws the content area on the OpenGl object.
 * @param gl2 Where to draw on.
 */
protected void draw(GL2 gl2){
  gl2.glClear(GL2.GL_COLOR_BUFFER_BIT);
  gl2.glLoadIdentity();
  if (context == null) {
    context=new JOGLDrawContext(gl2);
  }
  context.startFrame();
  area.drawArea(context);
}","/** 
 * Draws the content area on the OpenGl object.
 * @param gl2 Where to draw on.
 */
protected void draw(GL2 gl2){
  gl2.glClear(GL2.GL_COLOR_BUFFER_BIT);
  gl2.glLoadIdentity();
  if (context == null || context.getGl2() != gl2) {
    context=new JOGLDrawContext(gl2);
  }
  context.startFrame();
  area.drawArea(context);
}"
56508,"@Override public TextDrawer getTextDrawer(EFontSize size){
  return JOGLTextDrawer.getTextDrawer(size,this);
}","/** 
 * Gets a text drawer for the given text size.
 * @param size The size for the drawer.
 * @return An instance of a drawer for that size.
 */
@Override public TextDrawer getTextDrawer(EFontSize size){
  if (textDrawers[size.ordinal()] == null) {
    textDrawers[size.ordinal()]=new JOGLTextDrawer(size,this);
  }
  return textDrawers[size.ordinal()];
}"
56509,"/** 
 * Creates a new text drawer.
 * @param size The size of the text.
 * @param drawContext 
 */
private JOGLTextDrawer(EFontSize size,JOGLDrawContext drawContext){
  this.drawContext=drawContext;
  Font font=new Font(FONTNAME,Font.TRUETYPE_FONT,size.getSize());
  this.renderer=new TextRenderer(font,true,true,null,true);
}","/** 
 * Creates a new text drawer.
 * @param size The size of the text.
 * @param drawContext 
 */
public JOGLTextDrawer(EFontSize size,JOGLDrawContext drawContext){
  this.drawContext=drawContext;
  Font font=new Font(FONTNAME,Font.TRUETYPE_FONT,size.getSize());
  this.renderer=new TextRenderer(font,true,true,null,true);
}"
56510,"/** 
 * @param inX
 * @param inY
 * @param oldPartition
 * @param newPartition
 * @param justRelabel if true, only the partition will be changed.<br> if false, the partition will be changed and for every changed position the contents of that position in the old manager will be moved to the new manager.
 */
private final void relabelPartition(short inX,short inY,short oldPartition,short newPartition,boolean justRelabel){
  final short MAX_LENGTH=1000;
  final short[] pointsBuffer=new short[MAX_LENGTH];
  pointsBuffer[0]=inX;
  pointsBuffer[1]=inY;
  short length=2;
  while (length > 0) {
    short y=pointsBuffer[--length];
    short x=pointsBuffer[--length];
    if (partitions[getIdx(x,y)] != oldPartition) {
      continue;
    }
    if (justRelabel) {
      this.partitions[getIdx(x,y)]=newPartition;
    }
 else {
      setPartition(x,y,newPartition);
    }
    boolean currIsBlocked=grid.isBlocked(x,y);
    for (byte i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
      short currX=(short)(x + neighborX[i]);
      short currY=(short)(y + neighborY[i]);
      if (isInBounds(currX,currY) && partitions[getIdx(currX,currY)] == oldPartition && (!currIsBlocked || grid.isBlocked(currX,currY))) {
        if (length < MAX_LENGTH) {
          pointsBuffer[length++]=currX;
          pointsBuffer[length++]=currY;
        }
 else {
          relabelPartition(currX,currY,oldPartition,newPartition,justRelabel);
        }
      }
    }
  }
}","/** 
 * @param inX
 * @param inY
 * @param oldPartition
 * @param newPartition
 * @param justRelabel if true, only the partition will be changed.<br> if false, the partition will be changed and for every changed position the contents of that position in the old manager will be moved to the new manager.
 */
private final void relabelPartition(short inX,short inY,short oldPartition,short newPartition,boolean justRelabel){
  final short MAX_LENGTH=10000;
  final short[] pointsBuffer=new short[MAX_LENGTH];
  pointsBuffer[0]=inX;
  pointsBuffer[1]=inY;
  short length=2;
  while (length > 0) {
    short y=pointsBuffer[--length];
    short x=pointsBuffer[--length];
    if (partitions[getIdx(x,y)] != oldPartition) {
      continue;
    }
    if (justRelabel) {
      this.partitions[getIdx(x,y)]=newPartition;
    }
 else {
      setPartition(x,y,newPartition);
    }
    boolean currIsBlocked=grid.isBlocked(x,y);
    for (byte i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
      short currX=(short)(x + neighborX[i]);
      short currY=(short)(y + neighborY[i]);
      if (isInBounds(currX,currY) && partitions[getIdx(currX,currY)] == oldPartition && (!currIsBlocked || grid.isBlocked(currX,currY))) {
        if (length < MAX_LENGTH) {
          pointsBuffer[length++]=currX;
          pointsBuffer[length++]=currY;
        }
 else {
          relabelPartition(currX,currY,oldPartition,newPartition,justRelabel);
        }
      }
    }
  }
}"
56511,"private void progressCurrentAction(){
  progress+=progressIncrease;
  if (progress >= 1.01) {
    setState(ENewMovableState.DOING_NOTHING);
    this.movableAction=EAction.NO_ACTION;
  }
}","private void progressCurrentAction(){
  progress+=progressIncrease;
  if (progress >= 1) {
    setState(ENewMovableState.DOING_NOTHING);
    this.movableAction=EAction.NO_ACTION;
  }
}"
56512,"/** 
 * Forces the movable to go a step in the given direction (if it is not blocked).
 * @param direction direction to go
 * @return true if the step can and will immediately be executed. <br>false if the target position is blocked for this movable.
 */
final boolean forceGoInDirection(EDirection direction){
  ShortPoint2D targetPos=direction.getNextHexPoint(position);
  if (grid.isValidPosition(this,targetPos)) {
    this.followPath(new Path(targetPos));
    return true;
  }
 else {
    return false;
  }
}","/** 
 * Forces the movable to go a step in the given direction (if it is not blocked).
 * @param direction direction to go
 */
final void forceGoInDirection(EDirection direction){
  ShortPoint2D targetPos=direction.getNextHexPoint(position);
  this.direction=direction;
  this.followPath(new Path(targetPos));
  this.goSinglePathStep();
}"
56513,"/** 
 * Forces the movable to go a step in the given direction (if it is not blocked).
 * @param direction direction to go
 * @return true if the step can and will immediately be executed. <br>false if the target position is blocked for this movable.
 */
protected final boolean forceGoInDirection(EDirection direction){
  return movable.forceGoInDirection(direction);
}","/** 
 * Forces the movable to go a step in the given direction (if it is not blocked).
 * @param direction direction to go
 */
protected final void forceGoInDirection(EDirection direction){
  movable.forceGoInDirection(direction);
}"
56514,"@Override protected void action(){
  if (currentJob == null)   return;
switch (currentJob.getType()) {
case GO_TO:
    gotoAction();
  break;
case IS_PRODUCTIVE:
if (isProductive()) {
  jobFinished();
}
 else {
  jobFailed();
}
break;
case WAIT:
waitSeconds();
break;
case WALK:
if (super.forceGoInDirection(currentJob.getDirection())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case SHOW:
ShortPoint2D pos=getCurrentJobPos();
super.setPosition(pos);
super.setVisible(true);
jobFinished();
break;
case HIDE:
super.setVisible(false);
jobFinished();
break;
case SET_MATERIAL:
super.setMaterial(currentJob.getMaterial());
jobFinished();
break;
case TAKE:
takeAction();
break;
case REMOTETAKE:
if (this.building.popMaterial(getCurrentJobPos(),currentJob.getMaterial())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case DROP:
dropAction(currentJob.getMaterial());
break;
case DROP_POPPED:
dropAction(poppedMaterial);
break;
case PRE_SEARCH:
preSearchPathAction(true);
break;
case PRE_SEARCH_IN_AREA:
preSearchPathAction(false);
break;
case FOLLOW_SEARCHED:
followPreSearchedAction();
break;
case LOOK_AT_SEARCHED:
lookAtSearched();
break;
case LOOK_AT:
super.lookInDirection(currentJob.getDirection());
jobFinished();
break;
case EXECUTE:
executeAction();
break;
case PLAY_ACTION1:
super.playAction(EAction.ACTION1,currentJob.getTime());
jobFinished();
break;
case PLAY_ACTION2:
super.playAction(EAction.ACTION2,currentJob.getTime());
jobFinished();
break;
case AVAILABLE:
if (super.getStrategyGrid().canPop(getCurrentJobPos(),currentJob.getMaterial())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case NOT_FULL:
if (super.getStrategyGrid().canPushMaterial(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case SMOKE_ON:
case SMOKE_OFF:
{
super.getStrategyGrid().placeSmoke(getCurrentJobPos(),currentJob.getType() == EBuildingJobType.SMOKE_ON);
jobFinished();
break;
}
case START_WORKING:
case STOP_WORKING:
if (building instanceof MillBuilding) {
((MillBuilding)building).setRotating(currentJob.getType() == EBuildingJobType.START_WORKING);
}
jobFinished();
break;
case PIG_IS_ADULT:
if (super.getStrategyGrid().isPigAdult(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_IS_THERE:
if (super.getStrategyGrid().hasPigAt(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_PLACE:
case PIG_REMOVE:
placeOrRemovePigAction();
break;
case POP_TOOL:
popToolRequestAction();
break;
}
}","@Override protected void action(){
  if (currentJob == null)   return;
switch (currentJob.getType()) {
case GO_TO:
    gotoAction();
  break;
case IS_PRODUCTIVE:
if (isProductive()) {
  jobFinished();
}
 else {
  jobFailed();
}
break;
case WAIT:
waitSeconds();
break;
case WALK:
super.forceGoInDirection(currentJob.getDirection());
jobFinished();
break;
case SHOW:
ShortPoint2D pos=getCurrentJobPos();
super.setPosition(pos);
super.setVisible(true);
jobFinished();
break;
case HIDE:
super.setVisible(false);
jobFinished();
break;
case SET_MATERIAL:
super.setMaterial(currentJob.getMaterial());
jobFinished();
break;
case TAKE:
takeAction();
break;
case REMOTETAKE:
if (this.building.popMaterial(getCurrentJobPos(),currentJob.getMaterial())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case DROP:
dropAction(currentJob.getMaterial());
break;
case DROP_POPPED:
dropAction(poppedMaterial);
break;
case PRE_SEARCH:
preSearchPathAction(true);
break;
case PRE_SEARCH_IN_AREA:
preSearchPathAction(false);
break;
case FOLLOW_SEARCHED:
followPreSearchedAction();
break;
case LOOK_AT_SEARCHED:
lookAtSearched();
break;
case LOOK_AT:
super.lookInDirection(currentJob.getDirection());
jobFinished();
break;
case EXECUTE:
executeAction();
break;
case PLAY_ACTION1:
super.playAction(EAction.ACTION1,currentJob.getTime());
jobFinished();
break;
case PLAY_ACTION2:
super.playAction(EAction.ACTION2,currentJob.getTime());
jobFinished();
break;
case AVAILABLE:
if (super.getStrategyGrid().canPop(getCurrentJobPos(),currentJob.getMaterial())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case NOT_FULL:
if (super.getStrategyGrid().canPushMaterial(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case SMOKE_ON:
case SMOKE_OFF:
{
super.getStrategyGrid().placeSmoke(getCurrentJobPos(),currentJob.getType() == EBuildingJobType.SMOKE_ON);
jobFinished();
break;
}
case START_WORKING:
case STOP_WORKING:
if (building instanceof MillBuilding) {
((MillBuilding)building).setRotating(currentJob.getType() == EBuildingJobType.START_WORKING);
}
jobFinished();
break;
case PIG_IS_ADULT:
if (super.getStrategyGrid().isPigAdult(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_IS_THERE:
if (super.getStrategyGrid().hasPigAt(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_PLACE:
case PIG_REMOVE:
placeOrRemovePigAction();
break;
case POP_TOOL:
popToolRequestAction();
break;
}
}"
56515,"@Override protected void action(){
  if (currentJob == null)   return;
switch (currentJob.getType()) {
case GO_TO:
    gotoAction();
  break;
case IS_PRODUCTIVE:
if (isProductive()) {
  jobFinished();
}
 else {
  jobFailed();
}
break;
case WAIT:
waitSeconds();
break;
case WALK:
if (super.forceGoInDirection(currentJob.getDirection())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case SHOW:
ShortPoint2D pos=getCurrentJobPos();
super.setPosition(pos);
super.setVisible(true);
jobFinished();
break;
case HIDE:
super.setVisible(false);
jobFinished();
break;
case SET_MATERIAL:
super.setMaterial(currentJob.getMaterial());
jobFinished();
break;
case TAKE:
takeAction();
break;
case REMOTETAKE:
if (this.building.popMaterial(getCurrentJobPos(),currentJob.getMaterial())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case DROP:
dropAction(super.getMaterial());
break;
case DROP_POPPED:
dropAction(poppedMaterial);
break;
case PRE_SEARCH:
preSearchPathAction(true);
break;
case PRE_SEARCH_IN_AREA:
preSearchPathAction(false);
break;
case FOLLOW_SEARCHED:
followPreSearchedAction();
break;
case LOOK_AT_SEARCHED:
lookAtSearched();
break;
case LOOK_AT:
super.lookInDirection(currentJob.getDirection());
jobFinished();
break;
case EXECUTE:
executeAction();
break;
case PLAY_ACTION1:
super.playAction(EAction.ACTION1,currentJob.getTime());
jobFinished();
break;
case PLAY_ACTION2:
super.playAction(EAction.ACTION2,currentJob.getTime());
jobFinished();
break;
case AVAILABLE:
if (super.getStrategyGrid().canPop(getCurrentJobPos(),currentJob.getMaterial())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case NOT_FULL:
if (super.getStrategyGrid().canPushMaterial(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case SMOKE_ON:
case SMOKE_OFF:
{
super.getStrategyGrid().placeSmoke(getCurrentJobPos(),currentJob.getType() == EBuildingJobType.SMOKE_ON);
jobFinished();
break;
}
case START_WORKING:
case STOP_WORKING:
if (building instanceof MillBuilding) {
((MillBuilding)building).setRotating(currentJob.getType() == EBuildingJobType.START_WORKING);
}
jobFinished();
break;
case PIG_IS_ADULT:
if (super.getStrategyGrid().isPigAdult(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_IS_THERE:
if (super.getStrategyGrid().hasPigAt(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_PLACE:
case PIG_REMOVE:
placeOrRemovePigAction();
break;
case POP_TOOL:
popToolRequestAction();
break;
}
}","@Override protected void action(){
  if (currentJob == null)   return;
switch (currentJob.getType()) {
case GO_TO:
    gotoAction();
  break;
case IS_PRODUCTIVE:
if (isProductive()) {
  jobFinished();
}
 else {
  jobFailed();
}
break;
case WAIT:
waitSeconds();
break;
case WALK:
if (super.forceGoInDirection(currentJob.getDirection())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case SHOW:
ShortPoint2D pos=getCurrentJobPos();
super.setPosition(pos);
super.setVisible(true);
jobFinished();
break;
case HIDE:
super.setVisible(false);
jobFinished();
break;
case SET_MATERIAL:
super.setMaterial(currentJob.getMaterial());
jobFinished();
break;
case TAKE:
takeAction();
break;
case REMOTETAKE:
if (this.building.popMaterial(getCurrentJobPos(),currentJob.getMaterial())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case DROP:
dropAction(currentJob.getMaterial());
break;
case DROP_POPPED:
dropAction(poppedMaterial);
break;
case PRE_SEARCH:
preSearchPathAction(true);
break;
case PRE_SEARCH_IN_AREA:
preSearchPathAction(false);
break;
case FOLLOW_SEARCHED:
followPreSearchedAction();
break;
case LOOK_AT_SEARCHED:
lookAtSearched();
break;
case LOOK_AT:
super.lookInDirection(currentJob.getDirection());
jobFinished();
break;
case EXECUTE:
executeAction();
break;
case PLAY_ACTION1:
super.playAction(EAction.ACTION1,currentJob.getTime());
jobFinished();
break;
case PLAY_ACTION2:
super.playAction(EAction.ACTION2,currentJob.getTime());
jobFinished();
break;
case AVAILABLE:
if (super.getStrategyGrid().canPop(getCurrentJobPos(),currentJob.getMaterial())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case NOT_FULL:
if (super.getStrategyGrid().canPushMaterial(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case SMOKE_ON:
case SMOKE_OFF:
{
super.getStrategyGrid().placeSmoke(getCurrentJobPos(),currentJob.getType() == EBuildingJobType.SMOKE_ON);
jobFinished();
break;
}
case START_WORKING:
case STOP_WORKING:
if (building instanceof MillBuilding) {
((MillBuilding)building).setRotating(currentJob.getType() == EBuildingJobType.START_WORKING);
}
jobFinished();
break;
case PIG_IS_ADULT:
if (super.getStrategyGrid().isPigAdult(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_IS_THERE:
if (super.getStrategyGrid().hasPigAt(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_PLACE:
case PIG_REMOVE:
placeOrRemovePigAction();
break;
case POP_TOOL:
popToolRequestAction();
break;
}
}"
56516,"private void dropAction(EMaterialType materialType){
  if (!done) {
    super.playAction(EAction.DROP,Constants.MOVABLE_TAKE_DROP_DURATION);
    done=true;
  }
 else {
    super.getStrategyGrid().dropMaterial(super.getPos(),materialType,true);
    jobFinished();
  }
}","private void dropAction(EMaterialType materialType){
  if (!done) {
    super.playAction(EAction.DROP,Constants.MOVABLE_TAKE_DROP_DURATION);
    if (materialType == EMaterialType.NO_MATERIAL) {
      jobFinished();
    }
 else {
      done=true;
    }
  }
 else {
    super.getStrategyGrid().dropMaterial(super.getPos(),materialType,true);
    jobFinished();
  }
}"
56517,"@Override public void action(Action action){
  if (action.getActionType() != EActionType.SCREEN_CHANGE) {
    System.out.println(""String_Node_Str"" + action.getActionType());
  }
switch (action.getActionType()) {
case BUILD:
    EBuildingType buildingType=((BuildAction)action).getBuilding();
  System.err.println(""String_Node_Str"" + buildingType);
this.previewBuilding=buildingType;
connector.setPreviewBuildingType(buildingType);
constructionMarksCalculator.setBuildingType(buildingType);
setActiveAction(action);
break;
case DEBUG_ACTION:
for (ISelectable curr : currentSelection) {
if (curr instanceof IDebugable) {
((IDebugable)curr).debug();
}
}
break;
case SPEED_TOGGLE_PAUSE:
NetworkTimer.get().invertPausing();
break;
case SPEED_SLOW:
if (!manager.isMultiplayer()) NetworkTimer.setGameSpeed(0.5f);
break;
case SPEED_FAST:
if (!manager.isMultiplayer()) NetworkTimer.setGameSpeed(2.0f);
break;
case SPEED_FASTER:
if (!manager.isMultiplayer()) NetworkTimer.multiplyGameSpeed(1.2f);
break;
case SPEED_SLOWER:
if (!manager.isMultiplayer()) NetworkTimer.multiplyGameSpeed(1 / 1.2f);
break;
case SPEED_NORMAL:
if (!manager.isMultiplayer()) NetworkTimer.setGameSpeed(1.0f);
break;
case FAST_FORWARD:
if (!manager.isMultiplayer()) {
NetworkTimer.get().fastForward();
}
break;
case SELECT_POINT:
handleSelectPointAction((SelectAction)action);
break;
case SELECT_AREA:
selectArea((SelectAreaAction)action);
break;
case MOVE_TO:
if (previewBuilding != null) {
cancelBuildingCreation();
setActiveAction(null);
}
 else {
MoveToAction moveToAction=(MoveToAction)action;
ShortPoint2D pos=moveToAction.getPosition();
moveTo(pos);
}
break;
case SET_WORK_AREA:
if (currentSelection.getSize() > 0) {
ISelectable selected=currentSelection.iterator().next();
if (selected instanceof Building) {
ShortPoint2D pos=((SelectAction)action).getPosition();
scheduleTask(new WorkAreaGuiTask(EGuiAction.SET_WORK_AREA,pos,((Building)selected).getPos()));
}
}
break;
case DESTROY:
destroySelected();
break;
case STOP_WORKING:
stopOrStartWorkingAction(true);
break;
case START_WORKING:
stopOrStartWorkingAction(false);
break;
case SHOW_SELECTION:
showSelection();
break;
case SCREEN_CHANGE:
constructionMarksCalculator.setScreen(((ScreenChangeAction)action).getScreenArea());
break;
case TOGGLE_DEBUG:
grid.resetDebugColors();
break;
case TOGGLE_FOG_OF_WAR:
grid.toggleFogOfWar();
break;
case SAVE:
manager.scheduleTask(new SimpleGuiTask(EGuiAction.QUICK_SAVE));
break;
case CONVERT:
sendConvertAction((ConvertAction)action);
break;
default :
System.err.println(""String_Node_Str"" + action.getActionType() + ""String_Node_Str"");
}
}","@Override public void action(Action action){
  if (action.getActionType() != EActionType.SCREEN_CHANGE) {
    System.out.println(""String_Node_Str"" + action.getActionType());
  }
switch (action.getActionType()) {
case BUILD:
    this.setSelection(new SelectionSet());
  EBuildingType buildingType=((BuildAction)action).getBuilding();
System.err.println(""String_Node_Str"" + buildingType);
this.previewBuilding=buildingType;
connector.setPreviewBuildingType(buildingType);
constructionMarksCalculator.setBuildingType(buildingType);
setActiveAction(action);
break;
case DEBUG_ACTION:
for (ISelectable curr : currentSelection) {
if (curr instanceof IDebugable) {
((IDebugable)curr).debug();
}
}
break;
case SPEED_TOGGLE_PAUSE:
NetworkTimer.get().invertPausing();
break;
case SPEED_SLOW:
if (!manager.isMultiplayer()) NetworkTimer.setGameSpeed(0.5f);
break;
case SPEED_FAST:
if (!manager.isMultiplayer()) NetworkTimer.setGameSpeed(2.0f);
break;
case SPEED_FASTER:
if (!manager.isMultiplayer()) NetworkTimer.multiplyGameSpeed(1.2f);
break;
case SPEED_SLOWER:
if (!manager.isMultiplayer()) NetworkTimer.multiplyGameSpeed(1 / 1.2f);
break;
case SPEED_NORMAL:
if (!manager.isMultiplayer()) NetworkTimer.setGameSpeed(1.0f);
break;
case FAST_FORWARD:
if (!manager.isMultiplayer()) {
NetworkTimer.get().fastForward();
}
break;
case SELECT_POINT:
handleSelectPointAction((SelectAction)action);
break;
case SELECT_AREA:
selectArea((SelectAreaAction)action);
break;
case MOVE_TO:
if (previewBuilding != null) {
cancelBuildingCreation();
setActiveAction(null);
}
 else {
MoveToAction moveToAction=(MoveToAction)action;
ShortPoint2D pos=moveToAction.getPosition();
moveTo(pos);
}
break;
case SET_WORK_AREA:
if (currentSelection.getSize() > 0) {
ISelectable selected=currentSelection.iterator().next();
if (selected instanceof Building) {
ShortPoint2D pos=((SelectAction)action).getPosition();
scheduleTask(new WorkAreaGuiTask(EGuiAction.SET_WORK_AREA,pos,((Building)selected).getPos()));
}
}
break;
case DESTROY:
destroySelected();
break;
case STOP_WORKING:
stopOrStartWorkingAction(true);
break;
case START_WORKING:
stopOrStartWorkingAction(false);
break;
case SHOW_SELECTION:
showSelection();
break;
case SCREEN_CHANGE:
constructionMarksCalculator.setScreen(((ScreenChangeAction)action).getScreenArea());
break;
case TOGGLE_DEBUG:
grid.resetDebugColors();
break;
case TOGGLE_FOG_OF_WAR:
grid.toggleFogOfWar();
break;
case SAVE:
manager.scheduleTask(new SimpleGuiTask(EGuiAction.QUICK_SAVE));
break;
case CONVERT:
sendConvertAction((ConvertAction)action);
break;
default :
System.err.println(""String_Node_Str"" + action.getActionType() + ""String_Node_Str"");
}
}"
56518,"private void cutStone(ShortPoint2D pos){
  short x=(short)(pos.getX() - 1);
  short y=(short)(pos.getY() + 1);
  AbstractHexMapObject stone=grid.getMapObject(x,y,EMapObjectType.STONE);
  stone.cutOff();
  if (!stone.canBeCut()) {
    addSelfDeletingMapObject(pos,EMapObjectType.CUT_OFF_STONE,Stone.DECOMPOSE_DELAY,(byte)-1);
    removeMapObjectType(x,y,EMapObjectType.STONE);
  }
}","private void cutStone(ShortPoint2D pos){
  short x=(short)(pos.getX() - 1);
  short y=(short)(pos.getY() + 1);
  AbstractHexMapObject stone=grid.getMapObject(x,y,EMapObjectType.STONE);
  if (stone != null) {
    stone.cutOff();
    if (!stone.canBeCut()) {
      addSelfDeletingMapObject(pos,EMapObjectType.CUT_OFF_STONE,Stone.DECOMPOSE_DELAY,(byte)-1);
      removeMapObjectType(x,y,EMapObjectType.STONE);
    }
  }
}"
56519,"private boolean cutCorn(ShortPoint2D pos){
  short x=pos.getX();
  short y=pos.getY();
  if (grid.isInBounds(x,y)) {
    AbstractObjectsManagerObject corn=(AbstractObjectsManagerObject)grid.getMapObject(x,y,EMapObjectType.CORN_ADULT);
    if (corn.cutOff()) {
      timingQueue.offer(new TimeEvent(corn,Corn.REMOVE_DURATION,true));
      return true;
    }
  }
  return false;
}","private boolean cutCorn(ShortPoint2D pos){
  short x=pos.getX();
  short y=pos.getY();
  if (grid.isInBounds(x,y)) {
    AbstractObjectsManagerObject corn=(AbstractObjectsManagerObject)grid.getMapObject(x,y,EMapObjectType.CORN_ADULT);
    if (corn != null && corn.cutOff()) {
      timingQueue.offer(new TimeEvent(corn,Corn.REMOVE_DURATION,true));
      return true;
    }
  }
  return false;
}"
56520,"private boolean cutTree(ShortPoint2D pos){
  short x=(short)(pos.getX() - 1);
  short y=(short)(pos.getY() - 1);
  if (grid.isInBounds(x,y)) {
    AbstractObjectsManagerObject tree=(AbstractObjectsManagerObject)grid.getMapObject(x,y,EMapObjectType.TREE_ADULT);
    if (tree.cutOff()) {
      timingQueue.offer(new TimeEvent(tree,Tree.DECOMPOSE_DURATION,true));
      return true;
    }
  }
  return false;
}","private boolean cutTree(ShortPoint2D pos){
  short x=(short)(pos.getX() - 1);
  short y=(short)(pos.getY() - 1);
  if (grid.isInBounds(x,y)) {
    AbstractObjectsManagerObject tree=(AbstractObjectsManagerObject)grid.getMapObject(x,y,EMapObjectType.TREE_ADULT);
    if (tree != null && tree.cutOff()) {
      timingQueue.offer(new TimeEvent(tree,Tree.DECOMPOSE_DURATION,true));
      return true;
    }
  }
  return false;
}"
56521,"@Override protected void action(){
  if (currentJob == null)   return;
switch (currentJob.getType()) {
case GO_TO:
    gotoAction();
  break;
case IS_PRODUCTIVE:
if (isProductive()) {
  jobFinished();
}
 else {
  jobFailed();
}
break;
case WAIT:
waitSeconds();
break;
case WALK:
if (super.forceGoInDirection(currentJob.getDirection())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case SHOW:
ShortPoint2D pos=getCurrentJobPos();
super.setPosition(pos);
super.setVisible(true);
jobFinished();
break;
case HIDE:
super.setVisible(false);
jobFinished();
break;
case SET_MATERIAL:
super.setMaterial(currentJob.getMaterial());
jobFinished();
break;
case TAKE:
takeAction();
break;
case REMOTETAKE:
if (this.building.popMaterial(getCurrentJobPos(),currentJob.getMaterial())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case DROP:
dropAction(super.getMaterial());
break;
case DROP_POPPED:
dropAction(poppedMaterial);
break;
case PRE_SEARCH:
preSearchPathAction(true);
break;
case PRE_SEARCH_IN_AREA:
preSearchPathAction(false);
break;
case FOLLOW_SEARCHED:
super.followPresearchedPath();
jobFinished();
break;
case LOOK_AT_SEARCHED:
lookAtSearched();
break;
case LOOK_AT:
super.lookInDirection(currentJob.getDirection());
jobFinished();
break;
case EXECUTE:
executeAction();
break;
case PLAY_ACTION1:
super.playAction(EAction.ACTION1,currentJob.getTime());
jobFinished();
break;
case PLAY_ACTION2:
super.playAction(EAction.ACTION2,currentJob.getTime());
jobFinished();
break;
case AVAILABLE:
if (super.getStrategyGrid().canPop(getCurrentJobPos(),currentJob.getMaterial())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case NOT_FULL:
if (super.getStrategyGrid().canPushMaterial(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case SMOKE_ON:
case SMOKE_OFF:
{
super.getStrategyGrid().placeSmoke(getCurrentJobPos(),currentJob.getType() == EBuildingJobType.SMOKE_ON);
jobFinished();
break;
}
case START_WORKING:
case STOP_WORKING:
if (building instanceof MillBuilding) {
((MillBuilding)building).setRotating(currentJob.getType() == EBuildingJobType.START_WORKING);
}
jobFinished();
break;
case PIG_IS_ADULT:
if (super.getStrategyGrid().isPigAdult(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_IS_THERE:
if (super.getStrategyGrid().hasPigAt(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_PLACE:
case PIG_REMOVE:
placeOrRemovePigAction();
break;
case POP_TOOL:
popToolRequestAction();
break;
}
}","@Override protected void action(){
  if (currentJob == null)   return;
switch (currentJob.getType()) {
case GO_TO:
    gotoAction();
  break;
case IS_PRODUCTIVE:
if (isProductive()) {
  jobFinished();
}
 else {
  jobFailed();
}
break;
case WAIT:
waitSeconds();
break;
case WALK:
if (super.forceGoInDirection(currentJob.getDirection())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case SHOW:
ShortPoint2D pos=getCurrentJobPos();
super.setPosition(pos);
super.setVisible(true);
jobFinished();
break;
case HIDE:
super.setVisible(false);
jobFinished();
break;
case SET_MATERIAL:
super.setMaterial(currentJob.getMaterial());
jobFinished();
break;
case TAKE:
takeAction();
break;
case REMOTETAKE:
if (this.building.popMaterial(getCurrentJobPos(),currentJob.getMaterial())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case DROP:
dropAction(super.getMaterial());
break;
case DROP_POPPED:
dropAction(poppedMaterial);
break;
case PRE_SEARCH:
preSearchPathAction(true);
break;
case PRE_SEARCH_IN_AREA:
preSearchPathAction(false);
break;
case FOLLOW_SEARCHED:
followPreSearchedAction();
break;
case LOOK_AT_SEARCHED:
lookAtSearched();
break;
case LOOK_AT:
super.lookInDirection(currentJob.getDirection());
jobFinished();
break;
case EXECUTE:
executeAction();
break;
case PLAY_ACTION1:
super.playAction(EAction.ACTION1,currentJob.getTime());
jobFinished();
break;
case PLAY_ACTION2:
super.playAction(EAction.ACTION2,currentJob.getTime());
jobFinished();
break;
case AVAILABLE:
if (super.getStrategyGrid().canPop(getCurrentJobPos(),currentJob.getMaterial())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case NOT_FULL:
if (super.getStrategyGrid().canPushMaterial(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case SMOKE_ON:
case SMOKE_OFF:
{
super.getStrategyGrid().placeSmoke(getCurrentJobPos(),currentJob.getType() == EBuildingJobType.SMOKE_ON);
jobFinished();
break;
}
case START_WORKING:
case STOP_WORKING:
if (building instanceof MillBuilding) {
((MillBuilding)building).setRotating(currentJob.getType() == EBuildingJobType.START_WORKING);
}
jobFinished();
break;
case PIG_IS_ADULT:
if (super.getStrategyGrid().isPigAdult(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_IS_THERE:
if (super.getStrategyGrid().hasPigAt(getCurrentJobPos())) {
jobFinished();
}
 else {
jobFailed();
}
break;
case PIG_PLACE:
case PIG_REMOVE:
placeOrRemovePigAction();
break;
case POP_TOOL:
popToolRequestAction();
break;
}
}"
56522,"@Override public void buildingDestroyed(){
  super.setVisible(true);
  reportAsJobless();
  if (super.getMaterial() != EMaterialType.NO_MATERIAL) {
    super.getStrategyGrid().dropMaterial(super.getPos(),super.getMaterial(),true);
    super.setMaterial(EMaterialType.NO_MATERIAL);
  }
}","@Override public void buildingDestroyed(){
  super.setVisible(true);
  reportAsJobless();
  dropCurrMaterial();
}"
56523,"/** 
 * To be called after the parition of (x,y) changed.
 * @param x
 * @param y
 */
public void reTest(short x,short y){
  if (!map.isBlocked(x,y)) {
    short destPartition=map.getPartitionAt(x,y);
    for (    EDirection dir : EDirection.valuesCached()) {
      short nx=dir.getNextTileX(x);
      short ny=dir.getNextTileY(y);
      if (map.isInBounds(nx,ny) && map.isBlocked(nx,ny)) {
        System.out.println(""String_Node_Str"" + nx + ""String_Node_Str""+ ny);
        startRelabel(nx,ny,destPartition,dir.getInverseDirection());
      }
    }
  }
}","/** 
 * To be called after the parition of (x,y) changed.
 * @param x
 * @param y
 */
public void reTest(short x,short y){
  if (!map.isBlocked(x,y)) {
    short destPartition=map.getPartitionAt(x,y);
    for (    EDirection dir : EDirection.values) {
      short nx=dir.getNextTileX(x);
      short ny=dir.getNextTileY(y);
      if (map.isInBounds(nx,ny) && map.isBlocked(nx,ny)) {
        System.out.println(""String_Node_Str"" + nx + ""String_Node_Str""+ ny);
        startRelabel(nx,ny,destPartition,dir.getInverseDirection());
      }
    }
  }
}"
56524,"@Override public void action(Action action){
  if (action.getActionType() != EActionType.SCREEN_CHANGE) {
    System.out.println(""String_Node_Str"" + action.getActionType());
  }
switch (action.getActionType()) {
case BUILD:
    EBuildingType buildingType=((BuildAction)action).getBuilding();
  System.err.println(""String_Node_Str"" + buildingType);
this.previewBuilding=buildingType;
connector.setPreviewBuildingType(buildingType);
constructionMarksCalculator.setBuildingType(buildingType);
setActiveAction(action);
break;
case DEBUG_ACTION:
for (ISelectable curr : currentSelection) {
if (curr instanceof IDebugable) {
((IDebugable)curr).debug();
}
}
break;
case SPEED_TOGGLE_PAUSE:
NetworkTimer.get().invertPausing();
break;
case SPEED_SLOW:
if (!manager.isMultiplayer()) NetworkTimer.setGameSpeed(0.5f);
break;
case SPEED_FAST:
if (!manager.isMultiplayer()) NetworkTimer.setGameSpeed(2.0f);
break;
case SPEED_FASTER:
if (!manager.isMultiplayer()) NetworkTimer.multiplyGameSpeed(1.2f);
break;
case SPEED_SLOWER:
if (!manager.isMultiplayer()) NetworkTimer.multiplyGameSpeed(1 / 1.2f);
break;
case SPEED_NORMAL:
if (!manager.isMultiplayer()) NetworkTimer.setGameSpeed(1.0f);
break;
case FAST_FORWARD:
if (!manager.isMultiplayer()) {
NetworkTimer.get().fastForward();
}
break;
case SELECT_POINT:
handleSelectPointAction((SelectAction)action);
break;
case SELECT_AREA:
selectArea((SelectAreaAction)action);
break;
case MOVE_TO:
if (previewBuilding != null) {
cancelBuildingCreation();
setActiveAction(null);
}
 else {
MoveToAction moveToAction=(MoveToAction)action;
ISPosition2D pos=moveToAction.getPosition();
moveTo(pos);
}
break;
case SET_WORK_AREA:
if (currentSelection.getSize() > 0) {
ISelectable selected=currentSelection.iterator().next();
if (selected instanceof Building) {
ISPosition2D pos=((SelectAction)action).getPosition();
scheduleTask(new WorkAreaGuiTask(EGuiAction.SET_WORK_AREA,pos,((Building)selected).getPos()));
}
}
break;
case DESTROY:
destroySelected();
break;
case STOP_WORKING:
stopOrStartWorkingAction(true);
break;
case START_WORKING:
stopOrStartWorkingAction(false);
break;
case SHOW_SELECTION:
showSelection();
break;
case SCREEN_CHANGE:
constructionMarksCalculator.setScreen(((ScreenChangeAction)action).getScreenArea());
break;
case TOGGLE_DEBUG:
break;
case TOGGLE_FOG_OF_WAR:
grid.toggleFogOfWar();
break;
case SAVE:
manager.scheduleTask(new SimpleGuiTask(EGuiAction.QUICK_SAVE));
break;
case CONVERT:
sendConvertAction((ConvertAction)action);
break;
default :
System.err.println(""String_Node_Str"" + action.getActionType() + ""String_Node_Str"");
}
}","@Override public void action(Action action){
  if (action.getActionType() != EActionType.SCREEN_CHANGE) {
    System.out.println(""String_Node_Str"" + action.getActionType());
  }
switch (action.getActionType()) {
case BUILD:
    EBuildingType buildingType=((BuildAction)action).getBuilding();
  System.err.println(""String_Node_Str"" + buildingType);
this.previewBuilding=buildingType;
connector.setPreviewBuildingType(buildingType);
constructionMarksCalculator.setBuildingType(buildingType);
setActiveAction(action);
break;
case DEBUG_ACTION:
for (ISelectable curr : currentSelection) {
if (curr instanceof IDebugable) {
((IDebugable)curr).debug();
}
}
break;
case SPEED_TOGGLE_PAUSE:
NetworkTimer.get().invertPausing();
break;
case SPEED_SLOW:
if (!manager.isMultiplayer()) NetworkTimer.setGameSpeed(0.5f);
break;
case SPEED_FAST:
if (!manager.isMultiplayer()) NetworkTimer.setGameSpeed(2.0f);
break;
case SPEED_FASTER:
if (!manager.isMultiplayer()) NetworkTimer.multiplyGameSpeed(1.2f);
break;
case SPEED_SLOWER:
if (!manager.isMultiplayer()) NetworkTimer.multiplyGameSpeed(1 / 1.2f);
break;
case SPEED_NORMAL:
if (!manager.isMultiplayer()) NetworkTimer.setGameSpeed(1.0f);
break;
case FAST_FORWARD:
if (!manager.isMultiplayer()) {
NetworkTimer.get().fastForward();
}
break;
case SELECT_POINT:
handleSelectPointAction((SelectAction)action);
break;
case SELECT_AREA:
selectArea((SelectAreaAction)action);
break;
case MOVE_TO:
if (previewBuilding != null) {
cancelBuildingCreation();
setActiveAction(null);
}
 else {
MoveToAction moveToAction=(MoveToAction)action;
ISPosition2D pos=moveToAction.getPosition();
moveTo(pos);
}
break;
case SET_WORK_AREA:
if (currentSelection.getSize() > 0) {
ISelectable selected=currentSelection.iterator().next();
if (selected instanceof Building) {
ISPosition2D pos=((SelectAction)action).getPosition();
scheduleTask(new WorkAreaGuiTask(EGuiAction.SET_WORK_AREA,pos,((Building)selected).getPos()));
}
}
break;
case DESTROY:
destroySelected();
break;
case STOP_WORKING:
stopOrStartWorkingAction(true);
break;
case START_WORKING:
stopOrStartWorkingAction(false);
break;
case SHOW_SELECTION:
showSelection();
break;
case SCREEN_CHANGE:
constructionMarksCalculator.setScreen(((ScreenChangeAction)action).getScreenArea());
break;
case TOGGLE_DEBUG:
grid.resetDebugColors();
break;
case TOGGLE_FOG_OF_WAR:
grid.toggleFogOfWar();
break;
case SAVE:
manager.scheduleTask(new SimpleGuiTask(EGuiAction.QUICK_SAVE));
break;
case CONVERT:
sendConvertAction((ConvertAction)action);
break;
default :
System.err.println(""String_Node_Str"" + action.getActionType() + ""String_Node_Str"");
}
}"
56525,"/** 
 * move the selected movables to the given position.
 * @param pos position to move to
 * @param list
 */
private void moveSelectedTo(ISPosition2D pos,List<Integer> list){
  if (list.size() == 1) {
    Movable currMovable=Movable.getMovableByID(list.get(0));
    currMovable.setGotoJob(new GotoJob(pos));
  }
 else {
    float radius=(float)(Math.sqrt(list.size() / 3.14f)) * 2;
    MapCircle mapCircle=new MapCircle(pos,radius);
    Iterator<ISPosition2D> circleIter=mapCircle.iterator();
    for (    Integer currID : list) {
      Movable currMovable=Movable.getMovableByID(currID);
      if (currMovable != null) {
        GotoJob job=new GotoJob(circleIter.next());
        circleIter.next();
        currMovable.setGotoJob(job);
      }
    }
  }
}","/** 
 * move the selected movables to the given position.
 * @param pos position to move to
 * @param list
 */
private void moveSelectedTo(ISPosition2D pos,List<Integer> list){
  if (list.size() == 1) {
    Movable currMovable=Movable.getMovableByID(list.get(0));
    if (currMovable != null)     currMovable.setGotoJob(new GotoJob(pos));
  }
 else {
    float radius=(float)(Math.sqrt(list.size() / 3.14f)) * 2;
    MapCircle mapCircle=new MapCircle(pos,radius);
    Iterator<ISPosition2D> circleIter=mapCircle.iterator();
    for (    Integer currID : list) {
      Movable currMovable=Movable.getMovableByID(currID);
      if (currMovable != null) {
        GotoJob job=new GotoJob(circleIter.next());
        circleIter.next();
        currMovable.setGotoJob(job);
      }
    }
  }
}"
56526,"private void killSelectedMovables(List<Integer> selectedMovables){
  for (  Integer currID : selectedMovables) {
    Movable.getMovableByID(currID).kill();
  }
}","private void killSelectedMovables(List<Integer> selectedMovables){
  for (  Integer currID : selectedMovables) {
    Movable curr=Movable.getMovableByID(currID);
    if (curr != null)     curr.kill();
  }
}"
56527,"@Override protected void executeAction(){
  for (  ITimerable s : timerables) {
    s.timerEvent();
  }
}","@Override protected void executeAction(){
  for (  ITimerable s : timerables) {
    try {
      s.timerEvent();
    }
 catch (    Throwable t) {
      System.out.println(""String_Node_Str"");
      t.printStackTrace();
      s.kill();
    }
  }
}"
56528,"public final int getDebugColor(int x,int y){
  return debugColor[getIdx(x,y)];
}","public final int getDebugColor(int x,int y){
  if (CommonConstants.ENABLE_DEBUG_COLORS) {
    return debugColors[getIdx(x,y)];
  }
 else {
    return 0;
  }
}"
56529,"public final void resetDebugColors(){
  for (int i=0; i < debugColor.length; i++) {
    debugColor[i]=-1;
  }
}","public final void resetDebugColors(){
  if (CommonConstants.ENABLE_DEBUG_COLORS) {
    for (int i=0; i < debugColors.length; i++) {
      debugColors[i]=0;
    }
  }
}"
56530,"public LandscapeGrid(short width,short height){
  this.width=width;
  this.height=height;
  this.heightGrid=new byte[width * height];
  this.landscapeGrid=new byte[width * height];
  this.resourceAmount=new byte[width * height];
  this.resourceType=new byte[width * height];
  this.temporaryFlatened=new byte[width * height];
  this.debugColor=new int[width * height];
  resetDebugColors();
  this.flattenedResetter=new FlattenedResetter(this);
  setBackgroundListener(null);
}","public LandscapeGrid(short width,short height){
  this.width=width;
  this.height=height;
  this.heightGrid=new byte[width * height];
  this.landscapeGrid=new byte[width * height];
  this.resourceAmount=new byte[width * height];
  this.resourceType=new byte[width * height];
  this.temporaryFlatened=new byte[width * height];
  initDebugColors();
  this.flattenedResetter=new FlattenedResetter(this);
  setBackgroundListener(null);
}"
56531,"private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
  ois.defaultReadObject();
  setBackgroundListener(null);
  resetDebugColors();
}","private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
  ois.defaultReadObject();
  setBackgroundListener(null);
  initDebugColors();
}"
56532,"public final void setDebugColor(short x,short y,int rgba){
  debugColor[getIdx(x,y)]=rgba;
}","public final void setDebugColor(short x,short y,int argb){
  if (CommonConstants.ENABLE_DEBUG_COLORS) {
    debugColors[getIdx(x,y)]=argb;
  }
}"
56533,"private boolean drawTile(int x,int y){
  IMapObject object=map.getMapObjectsAt(x,y);
  if (object != null) {
    this.objectDrawer.drawMapObject(this.context,this.map,x,y,object);
  }
  IMovable movable=map.getMovableAt(x,y);
  if (movable != null) {
    if (movable.getAction() == EAction.WALKING) {
      int originx=x - movable.getDirection().getGridDeltaX();
      int originy=y - movable.getDirection().getGridDeltaY();
      this.context.beginBetweenTileContext(originx,originy,x,y,movable.getMoveProgress());
      this.movableDrawer.draw(this.context,movable);
      this.context.endTileContext();
    }
 else {
      this.context.beginTileContext(x,y);
      this.movableDrawer.draw(this.context,movable);
      this.context.endTileContext();
    }
  }
  if (map.isBorder(x,y)) {
    this.context.beginTileContext(x,y);
    byte player=map.getPlayerAt(x,y);
    objectDrawer.drawPlayerBorderObject(context,player);
    this.context.endTileContext();
  }
  return ENABLE_DEBUG && map.getDebugColorAt(x,y) >= 0;
}","private boolean drawTile(int x,int y){
  IMapObject object=map.getMapObjectsAt(x,y);
  if (object != null) {
    this.objectDrawer.drawMapObject(this.context,this.map,x,y,object);
  }
  IMovable movable=map.getMovableAt(x,y);
  if (movable != null) {
    if (movable.getAction() == EAction.WALKING) {
      int originx=x - movable.getDirection().getGridDeltaX();
      int originy=y - movable.getDirection().getGridDeltaY();
      this.context.beginBetweenTileContext(originx,originy,x,y,movable.getMoveProgress());
      this.movableDrawer.draw(this.context,movable);
      this.context.endTileContext();
    }
 else {
      this.context.beginTileContext(x,y);
      this.movableDrawer.draw(this.context,movable);
      this.context.endTileContext();
    }
  }
  if (map.isBorder(x,y)) {
    this.context.beginTileContext(x,y);
    byte player=map.getPlayerAt(x,y);
    objectDrawer.drawPlayerBorderObject(context,player);
    this.context.endTileContext();
  }
  return ENABLE_DEBUG && map.getDebugColorAt(x,y) != 0;
}"
56534,"private void drawDebugColors(){
  IMapArea tiles=new MapShapeFilter(context.getScreenArea(),map.getWidth(),map.getHeight());
  GLDrawContext gl=this.context.getGl();
  float[] shape=new float[]{0,4,.5f,0,0,-3,2,.5f,0,0,-3,-2,.5f,0,0,0,-4,.5f,0,0,0,-4,.5f,0,0,3,-2,.5f,0,0,3,2,.5f,0,0,0,4,.5f,0,0};
  for (  ISPosition2D pos : tiles) {
    short x=pos.getX();
    short y=pos.getY();
    int argb=map.getDebugColorAt(x,y);
    if (argb >= 0) {
      this.context.beginTileContext(x,y);
      gl.color(((argb >> 16) & 0xff) / 255f,((argb >> 8) & 0xff) / 255f,((argb >> 0) & 0xff) / 255f,((argb >> 24) & 0xff) / 255f);
      gl.drawQuadWithTexture(0,shape);
      context.endTileContext();
    }
  }
}","private void drawDebugColors(){
  IMapArea tiles=new MapShapeFilter(context.getScreenArea(),map.getWidth(),map.getHeight());
  GLDrawContext gl=this.context.getGl();
  float[] shape=new float[]{0,4,.5f,0,0,-3,2,.5f,0,0,-3,-2,.5f,0,0,0,-4,.5f,0,0,0,-4,.5f,0,0,3,-2,.5f,0,0,3,2,.5f,0,0,0,4,.5f,0,0};
  for (  ISPosition2D pos : tiles) {
    short x=pos.getX();
    short y=pos.getY();
    int argb=map.getDebugColorAt(x,y);
    if (argb != 0) {
      this.context.beginTileContext(x,y);
      gl.color(((argb >> 16) & 0xff) / 255f,((argb >> 8) & 0xff) / 255f,((argb >> 0) & 0xff) / 255f,((argb >> 24) & 0xff) / 255f);
      gl.drawQuadWithTexture(0,shape);
      context.endTileContext();
    }
  }
}"
56535,"NewFoWThread(){
  super(""String_Node_Str"");
  this.buffer=new byte[width][height];
  super.setDaemon(true);
}","NewFoWThread(){
  super(""String_Node_Str"");
  this.buffer=new byte[width][height];
  super.setDaemon(true);
  drawer=new CircleDrawer();
}"
56536,"private final void applyViewDistances(ConcurrentLinkedQueue<? extends IViewDistancable> objects){
  for (  IViewDistancable curr : objects) {
    if (isPlayerOK(curr)) {
      short distance=curr.getViewDistance();
      if (distance > 0) {
        ISPosition2D pos=curr.getPos();
        drawer.drawCircleToBuffer(pos.getX(),pos.getY(),distance);
      }
    }
  }
}","private final void applyViewDistances(ConcurrentLinkedQueue<? extends IViewDistancable> objects){
  for (  IViewDistancable curr : objects) {
    if (isPlayerOK(curr)) {
      short distance=curr.getViewDistance();
      if (distance > 0) {
        ISPosition2D pos=curr.getPos();
        if (pos != null)         drawer.drawCircleToBuffer(pos.getX(),pos.getY(),distance);
      }
    }
  }
}"
56537,"public boolean isProtected(short x,short y){
  return this.protectedGrid.get(x * width + y);
}","public boolean isProtected(short x,short y){
  return this.protectedGrid.get(getIdx(x,y));
}"
56538,"public void setMarked(short x,short y,boolean marked){
  this.markedGrid.set(x * width + y,marked);
}","public void setMarked(short x,short y,boolean marked){
  this.markedGrid.set(getIdx(x,y),marked);
}"
56539,"public void setProtected(short x,short y,boolean setProtected){
  this.protectedGrid.set(x * width + y,setProtected);
}","public void setProtected(short x,short y,boolean setProtected){
  this.protectedGrid.set(getIdx(x,y),setProtected);
}"
56540,"public boolean isBlocked(short x,short y){
  return blockedGrid.get(x * width + y);
}","public boolean isBlocked(short x,short y){
  return blockedGrid.get(getIdx(x,y));
}"
56541,"/** 
 * sets this position blocked and protected.
 * @param x x coordinate
 * @param y y coordinate
 * @param blocked the position will be set to blocked and protected if blocked == true<br> otherwise it will be set to unblocked and unprotected.
 */
public void setBlockedAndProtected(short x,short y,boolean blocked){
  this.blockedGrid.set(x * width + y,blocked);
  this.setProtected(x,y,blocked);
}","/** 
 * sets this position blocked and protected.
 * @param x x coordinate
 * @param y y coordinate
 * @param blocked the position will be set to blocked and protected if blocked == true<br> otherwise it will be set to unblocked and unprotected.
 */
public void setBlockedAndProtected(short x,short y,boolean blocked){
  final int idx=getIdx(x,y);
  this.blockedGrid.set(idx,blocked);
  this.protectedGrid.set(idx,blocked);
}"
56542,"public boolean isMarked(short x,short y){
  return this.markedGrid.get(x * width + y);
}","public boolean isMarked(short x,short y){
  return this.markedGrid.get(getIdx(x,y));
}"
56543,"public final byte getHeightAt(short x,short y){
  return heightGrid[x][y];
}","public final byte getHeightAt(short x,short y){
  return heightGrid[getIdx(x,y)];
}"
56544,"public final void setLandscapeTypeAt(short x,short y,ELandscapeType landscapeType){
  if (landscapeType == ELandscapeType.FLATTENED && this.landscapeGrid[x][y] != ELandscapeType.FLATTENED) {
    flattenedResetter.addPosition(x,y);
  }
  this.landscapeGrid[x][y]=landscapeType;
  backgroundListener.backgroundChangedAt(x,y);
}","public final void setLandscapeTypeAt(short x,short y,ELandscapeType landscapeType){
  if (landscapeType == ELandscapeType.FLATTENED && this.landscapeGrid[getIdx(x,y)] != ELandscapeType.FLATTENED) {
    flattenedResetter.addPosition(x,y);
  }
  this.landscapeGrid[getIdx(x,y)]=landscapeType;
  backgroundListener.backgroundChangedAt(x,y);
}"
56545,"public float getResourceAmountAround(short x,short y,EResourceType type){
  int minx=Math.max(x - 1,0);
  int maxx=Math.max(x + 1,width - 1);
  int miny=Math.max(y - 1,0);
  int maxy=Math.max(y + 1,resourceAmount[0].length - 1);
  int found=0;
  for (int currentx=minx; currentx <= maxx; currentx++) {
    for (int currenty=miny; currenty <= maxy; currenty++) {
      if (resourceType[currentx][currenty] == type) {
        found+=resourceAmount[currentx][currenty];
      }
    }
  }
  return (float)found / Byte.MAX_VALUE / 9;
}","public float getResourceAmountAround(short x,short y,EResourceType type){
  int minx=Math.max(x - 1,0);
  int maxx=Math.max(x + 1,width - 1);
  int miny=Math.max(y - 1,0);
  int maxy=Math.max(y + 1,height - 1);
  int found=0;
  for (int currentx=minx; currentx <= maxx; currentx++) {
    for (int currenty=miny; currenty <= maxy; currenty++) {
      if (resourceType[getIdx(currentx,currenty)] == type) {
        found+=resourceAmount[getIdx(x,y)];
      }
    }
  }
  return (float)found / Byte.MAX_VALUE / 9;
}"
56546,"public LandscapeGrid(short width,short height){
  this.width=width;
  this.heightGrid=new byte[width][height];
  this.landscapeGrid=new ELandscapeType[width][height];
  this.resourceAmount=new byte[width][height];
  this.resourceType=new EResourceType[width][height];
  this.temporaryFlatened=new byte[width * height];
  flattenedResetter=new FlattenedResetter(this);
  setBackgroundListener(null);
}","public LandscapeGrid(short width,short height){
  this.width=width;
  this.height=height;
  this.heightGrid=new byte[width * height];
  this.landscapeGrid=new ELandscapeType[width * height];
  this.resourceAmount=new byte[width * height];
  this.resourceType=new EResourceType[width * height];
  this.temporaryFlatened=new byte[width * height];
  flattenedResetter=new FlattenedResetter(this);
  setBackgroundListener(null);
}"
56547,"public final void pickResourceAt(short x,short y){
  resourceAmount[x][y]--;
}","public final void pickResourceAt(short x,short y){
  resourceAmount[getIdx(x,y)]--;
}"
56548,"/** 
 * gets the resource amount at the given position
 * @param x
 * @param y
 * @return The amount of resources, where 0 is no resources and {@link Byte.MAX_VALUE} means full resources.
 */
public final byte getResourceAmountAt(short x,short y){
  return resourceAmount[x][y];
}","/** 
 * gets the resource amount at the given position
 * @param x
 * @param y
 * @return The amount of resources, where 0 is no resources and {@link Byte.MAX_VALUE} means full resources.
 */
public final byte getResourceAmountAt(short x,short y){
  return resourceAmount[getIdx(x,y)];
}"
56549,"@Override public boolean countFlattenedDown(short x,short y){
  int i=getFlatIndex(x,y);
  temporaryFlatened[i]--;
  if (temporaryFlatened[i] <= -30) {
    temporaryFlatened[i]=0;
    setLandscapeTypeAt(x,y,ELandscapeType.GRASS);
    return true;
  }
 else {
    return false;
  }
}","@Override public boolean countFlattenedDown(short x,short y){
  int i=getIdx(x,y);
  temporaryFlatened[i]--;
  if (temporaryFlatened[i] <= -30) {
    temporaryFlatened[i]=0;
    setLandscapeTypeAt(x,y,ELandscapeType.GRASS);
    return true;
  }
 else {
    return false;
  }
}"
56550,"@Override public final void walkOn(int x,int y){
  int i=getFlatIndex(x,y);
  if (temporaryFlatened[i] < 100) {
    temporaryFlatened[i]+=3;
    if (temporaryFlatened[i] > 20) {
      flaten(x,y);
    }
  }
}","@Override public final void walkOn(int x,int y){
  int i=getIdx(x,y);
  if (temporaryFlatened[i] < 100) {
    temporaryFlatened[i]+=3;
    if (temporaryFlatened[i] > 20) {
      flaten(x,y);
    }
  }
}"
56551,"public final void setResourceAt(short x,short y,EResourceType resourceType,byte amount){
  this.resourceType[x][y]=resourceType;
  this.resourceAmount[x][y]=amount;
}","public final void setResourceAt(short x,short y,EResourceType resourceType,byte amount){
  this.resourceType[getIdx(x,y)]=resourceType;
  this.resourceAmount[getIdx(x,y)]=amount;
}"
56552,"public final void setHeightAt(short x,short y,byte height){
  this.heightGrid[x][y]=height;
  backgroundListener.backgroundChangedAt(x,y);
}","public final void setHeightAt(short x,short y,byte height){
  this.heightGrid[getIdx(x,y)]=height;
  backgroundListener.backgroundChangedAt(x,y);
}"
56553,"public final boolean hasResourceAt(short x,short y,EResourceType resourceType){
  return getResourceTypeAt(x,y) == resourceType && resourceAmount[x][y] > 0;
}","public final boolean hasResourceAt(short x,short y,EResourceType resourceType){
  return getResourceTypeAt(x,y) == resourceType && resourceAmount[getIdx(x,y)] > 0;
}"
56554,"public final void changeHeightAt(short x,short y,byte delta){
  this.heightGrid[x][y]+=delta;
  backgroundListener.backgroundChangedAt(x,y);
}","public final void changeHeightAt(short x,short y,byte delta){
  this.heightGrid[getIdx(x,y)]+=delta;
  backgroundListener.backgroundChangedAt(x,y);
}"
56555,"public final EResourceType getResourceTypeAt(short x,short y){
  return resourceType[x][y];
}","public final EResourceType getResourceTypeAt(short x,short y){
  return resourceType[getIdx(x,y)];
}"
56556,"public final ELandscapeType getLandscapeTypeAt(short x,short y){
  return landscapeGrid[x][y];
}","public final ELandscapeType getLandscapeTypeAt(short x,short y){
  return landscapeGrid[getIdx(x,y)];
}"
56557,"@Override public final Color getDebugColorAt(int x,int y){
  return debugColors[x][y];
}","@Override public final Color getDebugColorAt(int x,int y){
  return isLandscapeBlocking((short)x,(short)y) ? new Color(0,0,0,1) : (flagsGrid.isProtected((short)x,(short)y) ? new Color(0,0,1,1) : (flagsGrid.isMarked((short)x,(short)y) ? new Color(0,1,0,1) : null));
}"
56558,"private final void takeOverBlockedLand(LinkedList<ISPosition2D> blockedBorder,short startPartition){
  for (  ISPosition2D curr : blockedBorder) {
    short y=curr.getY();
    for (short x=curr.getX(); ; x++) {
      if (grid.isInBounds(x,y) && grid.isBlocked(x,y)) {
        grid.setPartitionAndPlayerAt(x,y,startPartition);
      }
 else {
        break;
      }
    }
  }
}","private final void takeOverBlockedLand(LinkedList<ISPosition2D> blockedBorder,short startPartition){
  for (  ISPosition2D curr : blockedBorder) {
    short y=curr.getY();
    for (short x=curr.getX(); ; x++) {
      if (grid.isInBounds(x,y) && grid.isBlocked(x,y)) {
        grid.setPartitionAndPlayerAt(x,y,startPartition);
      }
 else {
        break;
      }
    }
    for (short x=(short)(curr.getX() - 1); ; x--) {
      if (grid.isInBounds(x,y) && grid.isBlocked(x,y)) {
        grid.setPartitionAndPlayerAt(x,y,startPartition);
      }
 else {
        break;
      }
    }
  }
}"
56559,"private final void checkLandmarks(ISPosition2D startPos,short startPartition,EDirection startDirection){
  EDirection blockedDir=startDirection;
  ISPosition2D blocked=blockedDir.getNextHexPoint(startPos);
  ISPosition2D currBase=startPos;
  LinkedList<ISPosition2D> blockedBorder=new LinkedList<ISPosition2D>();
  blockedBorder.add(blocked);
  for (byte i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
    EDirection neighborDir=blockedDir.getNeighbor(-1);
    ISPosition2D neighborPos=neighborDir.getNextHexPoint(currBase);
    if (!grid.isInBounds(neighborPos.getX(),neighborPos.getY())) {
      takeOverBlockedLand(blockedBorder,startPartition);
      break;
    }
 else     if (grid.isBlocked(neighborPos.getX(),neighborPos.getY())) {
      blocked=neighborPos;
      blockedDir=neighborDir;
      blockedBorder.add(blocked);
      i=0;
    }
 else     if (grid.getPartitionAt(neighborPos.getX(),neighborPos.getY()) == startPartition) {
      currBase=neighborPos;
      blockedDir=EDirection.getDirection(currBase,blocked);
      i=0;
      if (neighborPos.equals(startPos)) {
        takeOverBlockedLand(blockedBorder,startPartition);
        break;
      }
    }
 else {
      break;
    }
  }
}","private final void checkLandmarks(ISPosition2D startPos,short startPartition,EDirection startDirection){
  EDirection blockedDir=startDirection;
  ISPosition2D blocked=blockedDir.getNextHexPoint(startPos);
  ISPosition2D currBase=startPos;
  LinkedList<ISPosition2D> blockedBorder=new LinkedList<ISPosition2D>();
  blockedBorder.add(blocked);
  int length;
  for (byte i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
    length=blockedBorder.size();
    EDirection neighborDir=blockedDir.getNeighbor(-1);
    ISPosition2D neighborPos=neighborDir.getNextHexPoint(currBase);
    if (!grid.isInBounds(neighborPos.getX(),neighborPos.getY())) {
      takeOverBlockedLand(blockedBorder,startPartition);
      break;
    }
 else     if (grid.isBlocked(neighborPos.getX(),neighborPos.getY())) {
      blocked=neighborPos;
      if (blocked.equals(blockedBorder.getFirst())) {
        takeOverBlockedLand(blockedBorder,startPartition);
        break;
      }
 else {
        blockedDir=neighborDir;
        blockedBorder.add(blocked);
        i=0;
      }
    }
 else     if (grid.getPartitionAt(neighborPos.getX(),neighborPos.getY()) == startPartition) {
      currBase=neighborPos;
      blockedDir=EDirection.getDirection(currBase,blocked);
      i=0;
      if (neighborPos.equals(startPos)) {
        takeOverBlockedLand(blockedBorder,startPartition);
        break;
      }
    }
 else {
      break;
    }
  }
}"
56560,"/** 
 * Gets a list of matches. <p> The list should be immutable to prevent problems with concurrent modification exceptions.
 * @return The list.
 */
public List<IMatch> getMatches();","/** 
 * Gets an array of matches. <br> NOTE: elements of the array might be null!!
 * @return the array of matches
 */
public IMatch[] getMatches();"
56561,"@Override public void drawAt(GLDrawContext gl){
  if (listIsOld) {
    ArrayList<DisplayableMatch> displaymatches=new ArrayList<DisplayableMatch>();
    for (    IMatch m : networkConnector.getMatches()) {
      displaymatches.add(new DisplayableMatch(m));
    }
    list=new UIList<DisplayableMatch>(displaymatches,.1f);
    this.addChild(list,0,.15f,1,1);
    listIsOld=false;
  }
  super.drawAt(gl);
}","@Override public void drawAt(GLDrawContext gl){
  if (listIsOld) {
    ArrayList<DisplayableMatch> displaymatches=new ArrayList<DisplayableMatch>();
    for (    IMatch m : networkConnector.getMatches()) {
      if (m != null)       displaymatches.add(new DisplayableMatch(m));
    }
    list=new UIList<DisplayableMatch>(displaymatches,.1f);
    this.addChild(list,0,.15f,1,1);
    listIsOld=false;
  }
  super.drawAt(gl);
}"
56562,"private void reloadPlayerList(){
  if (!playerListValid) {
    playerListValid=true;
    listContainer.removeAll();
    ArrayList<PlayerItem> players=new ArrayList<PlayerItem>();
    for (    INetworkPlayer player : networkScreen.getPlayerList()) {
      players.add(new PlayerItem(player));
    }
    UIList<PlayerItem> list=new UIList<PlayerItem>(players,.2f);
    listContainer.addChild(list,0,0,1,1);
  }
}","private void reloadPlayerList(){
  if (!playerListValid) {
    playerListValid=true;
    listContainer.removeAll();
    ArrayList<PlayerItem> players=new ArrayList<PlayerItem>();
    if (networkScreen.getPlayers() != null) {
      for (      INetworkPlayer player : networkScreen.getPlayers()) {
        players.add(new PlayerItem(player));
      }
    }
    UIList<PlayerItem> list=new UIList<PlayerItem>(players,.2f);
    listContainer.addChild(list,0,0,1,1);
  }
}"
56563,"@Override public INetworkConnector getNetworkConnector(){
  if (networkConnector == null) {
    networkConnector=new NetworkConnector();
  }
  return networkConnector;
}","@Override public INetworkConnector getNetworkConnector(){
  if (networkConnector == null) {
    networkConnector=new NetworkMatchRetriever();
  }
  return networkConnector;
}"
56564,"@Override public boolean isReady(){
  return false;
}","@Override public boolean isReady(){
  return matchPlayer.isReady();
}"
56565,"@Override public String getPlayerName(){
  return name;
}","@Override public String getPlayerName(){
  return matchPlayer.getName();
}"
56566,"public NetworkScreenAdapter(ClientThread clientThread,MatchDescription description){
  this.clientThread=clientThread;
  this.description=description;
}","public NetworkScreenAdapter(ClientThread clientThread,MatchDescription description){
  this.clientThread=clientThread;
  this.description=description;
  clientThread.setListener(new ScreenAdapterClientThreadListener());
}"
56567,"public NetworkPlayer(int i){
  name=""String_Node_Str"" + i;
}","public NetworkPlayer(MatchPlayer matchPlayer){
  this.matchPlayer=matchPlayer;
}"
56568,"private final void takeOverBlockedLand(LinkedList<ISPosition2D> blockedBorder,short startPartition){
  for (  ISPosition2D curr : blockedBorder) {
    short y=curr.getY();
    for (short x=curr.getX(); ; x++) {
      if (grid.isBlocked(x,y)) {
        grid.setPartitionAndPlayerAt(x,y,startPartition);
      }
 else {
        break;
      }
    }
  }
}","private final void takeOverBlockedLand(LinkedList<ISPosition2D> blockedBorder,short startPartition){
  for (  ISPosition2D curr : blockedBorder) {
    short y=curr.getY();
    for (short x=curr.getX(); ; x++) {
      if (grid.isInBounds(x,y) && grid.isBlocked(x,y)) {
        grid.setPartitionAndPlayerAt(x,y,startPartition);
      }
 else {
        break;
      }
    }
  }
}"
56569,"@Override public long getItemId(int arg0){
  return playerList.get(arg0).hashCode();
}","@Override public long getItemId(int idx){
  return getItem(idx).hashCode();
}"
56570,"public PlayerList(Context context,INetworkScreenAdapter networkScreen){
  this.context=context;
  this.networkScreen=networkScreen;
  playerList=networkScreen.getPlayerList();
}","public PlayerList(Context context,INetworkScreenAdapter networkScreen){
  this.context=context;
  this.networkScreen=networkScreen;
  playerList=networkScreen.getPlayers();
}"
56571,"@Override public Object getItem(int arg0){
  return playerList.get(arg0);
}","@Override public INetworkPlayer getItem(int idx){
  return playerList[idx];
}"
56572,"@Override public int getCount(){
  return playerList.size();
}","@Override public int getCount(){
  if (playerList != null) {
    return playerList.length;
  }
 else {
    return 0;
  }
}"
56573,"@Override public View getView(int arg0,View arg1,ViewGroup arg2){
  TextView view=new TextView(context);
  view.setText(playerList.get(arg0).getPlayerName());
  return view;
}","@Override public View getView(int idx,View arg1,ViewGroup arg2){
  TextView view=new TextView(context);
  view.setText(getItem(idx).getPlayerName());
  return view;
}"
56574,"public void changed(){
  playerList=networkScreen.getPlayerList();
  notifyDataSetChanged();
}","public void changed(){
  playerList=networkScreen.getPlayers();
  notifyDataSetChanged();
}"
56575,"public LandmarksCorrectingThread(ILandmarksThreadMap map){
  super(""String_Node_Str"");
  this.map=map;
  this.setDaemon(true);
  this.start();
}","public LandmarksCorrectingThread(ILandmarksThreadGrid map){
  super(""String_Node_Str"");
  this.grid=map;
  this.setDaemon(true);
  this.start();
}"
56576,"private final LinkedList<EDirection> getBlockedDirection(ISPosition2D position){
  LinkedList<EDirection> blockedDirections=new LinkedList<EDirection>();
  for (  EDirection currDir : EDirection.values()) {
    short currX=currDir.getNextTileX(position.getX());
    short currY=currDir.getNextTileY(position.getY());
    if (map.isInBounds(currX,currY) && map.isBlocked(currX,currY)) {
      blockedDirections.add(currDir);
    }
  }
  return blockedDirections;
}","private final LinkedList<EDirection> getBlockedDirection(ISPosition2D position){
  LinkedList<EDirection> blockedDirections=new LinkedList<EDirection>();
  for (  EDirection currDir : EDirection.values()) {
    short currX=currDir.getNextTileX(position.getX());
    short currY=currDir.getNextTileY(position.getY());
    if (grid.isInBounds(currX,currY) && grid.isBlocked(currX,currY)) {
      blockedDirections.add(currDir);
    }
  }
  return blockedDirections;
}"
56577,"private final void takeOverBlockedLand(LinkedList<ISPosition2D> blockedBorder,short startPartition){
  for (  ISPosition2D curr : blockedBorder) {
    short y=curr.getY();
    for (short x=curr.getX(); ; x++) {
      if (map.isBlocked(x,y)) {
        map.setPartitionAndPlayerAt(x,y,startPartition);
      }
 else {
        break;
      }
    }
  }
}","private final void takeOverBlockedLand(LinkedList<ISPosition2D> blockedBorder,short startPartition){
  for (  ISPosition2D curr : blockedBorder) {
    short y=curr.getY();
    for (short x=curr.getX(); ; x++) {
      if (grid.isBlocked(x,y)) {
        grid.setPartitionAndPlayerAt(x,y,startPartition);
      }
 else {
        break;
      }
    }
  }
}"
56578,"private final void checkLandmarks(ISPosition2D startPos,short startPartition,EDirection startDirection){
  EDirection blockedDir=startDirection;
  ISPosition2D blocked=blockedDir.getNextHexPoint(startPos);
  ISPosition2D currBase=startPos;
  LinkedList<ISPosition2D> blockedBorder=new LinkedList<ISPosition2D>();
  blockedBorder.add(blocked);
  for (byte i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
    EDirection neighborDir=blockedDir.getNeighbor(-1);
    ISPosition2D neighborPos=neighborDir.getNextHexPoint(currBase);
    if (!map.isInBounds(neighborPos.getX(),neighborPos.getY())) {
      takeOverBlockedLand(blockedBorder,startPartition);
      break;
    }
 else     if (map.isBlocked(neighborPos.getX(),neighborPos.getY())) {
      blocked=neighborPos;
      blockedDir=neighborDir;
      blockedBorder.add(blocked);
      i=0;
    }
 else     if (map.getPartitionAt(neighborPos.getX(),neighborPos.getY()) == startPartition) {
      currBase=neighborPos;
      blockedDir=EDirection.getDirection(currBase,blocked);
      i=0;
      if (neighborPos.equals(startPos)) {
        takeOverBlockedLand(blockedBorder,startPartition);
        break;
      }
    }
 else {
      break;
    }
  }
}","private final void checkLandmarks(ISPosition2D startPos,short startPartition,EDirection startDirection){
  EDirection blockedDir=startDirection;
  ISPosition2D blocked=blockedDir.getNextHexPoint(startPos);
  ISPosition2D currBase=startPos;
  LinkedList<ISPosition2D> blockedBorder=new LinkedList<ISPosition2D>();
  blockedBorder.add(blocked);
  for (byte i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
    EDirection neighborDir=blockedDir.getNeighbor(-1);
    ISPosition2D neighborPos=neighborDir.getNextHexPoint(currBase);
    if (!grid.isInBounds(neighborPos.getX(),neighborPos.getY())) {
      takeOverBlockedLand(blockedBorder,startPartition);
      break;
    }
 else     if (grid.isBlocked(neighborPos.getX(),neighborPos.getY())) {
      blocked=neighborPos;
      blockedDir=neighborDir;
      blockedBorder.add(blocked);
      i=0;
    }
 else     if (grid.getPartitionAt(neighborPos.getX(),neighborPos.getY()) == startPartition) {
      currBase=neighborPos;
      blockedDir=EDirection.getDirection(currBase,blocked);
      i=0;
      if (neighborPos.equals(startPos)) {
        takeOverBlockedLand(blockedBorder,startPartition);
        break;
      }
    }
 else {
      break;
    }
  }
}"
56579,"@Override public void run(){
  try {
    while (!stopped) {
      waitTime(300);
      if (stopped) {
        break;
      }
      MapRectangle screen=map.getScreenArea();
      if (screen == null) {
        continue;
      }
      int line=(int)(Math.random() * screen.getLines());
      int x=screen.getLineStartX(line) + (int)(Math.random() * screen.getLineLength());
      int y=screen.getLineY(line);
      if (hasTree(x,y)) {
        if (Math.random() < .5) {
          sound.playSound(INDEX_BIRDS1,VOLUME,VOLUME);
        }
 else {
          sound.playSound(INDEX_BIRDS2,VOLUME,VOLUME);
        }
        waitTime(800);
      }
 else       if (hasWater(x,y)) {
        sound.playSound(INDEX_WATER,VOLUME,VOLUME);
        waitTime(200);
      }
 else       if (hasDesert(x,y)) {
        sound.playSound(INDEX_DESERT,VOLUME,VOLUME);
        waitTime(500);
      }
    }
  }
 catch (  Throwable e) {
    System.out.println(""String_Node_Str"");
  }
}","@Override public void run(){
  try {
    while (!stopped) {
      waitTime(300);
      if (stopped) {
        break;
      }
      MapRectangle screen=map.getScreenArea();
      if (screen == null) {
        continue;
      }
      int line=(int)(Math.random() * screen.getLines());
      int x=screen.getLineStartX(line) + (int)(Math.random() * screen.getLineLength());
      int y=screen.getLineY(line);
      if (hasTree(x,y)) {
        if (Math.random() < .5) {
          sound.playSound(INDEX_BIRDS1,VOLUME,VOLUME);
        }
 else {
          sound.playSound(INDEX_BIRDS2,VOLUME,VOLUME);
        }
        waitTime(800);
      }
 else       if (hasWater(x,y)) {
        sound.playSound(INDEX_WATER,VOLUME,VOLUME);
        waitTime(200);
      }
 else       if (hasDesert(x,y)) {
        sound.playSound(INDEX_DESERT,VOLUME,VOLUME);
        waitTime(500);
      }
    }
  }
 catch (  Throwable e) {
    System.out.println(""String_Node_Str"");
    e.printStackTrace();
  }
}"
56580,"private boolean checkGotoJob(){
  if (gotoJob != null) {
    calculatePathTo(gotoJob.getPosition());
    gotoJob=null;
    return true;
  }
 else {
    return false;
  }
}","private boolean checkGotoJob(){
  if (gotoJob != null) {
    executingGotoJobAction();
    calculatePathTo(gotoJob.getPosition());
    gotoJob=null;
    return true;
  }
 else {
    return false;
  }
}"
56581,"@Override protected void killedEvent(){
  if (requester != null) {
    requester.requestFailed();
  }
}","@Override protected void killedEvent(){
  if (requester != null) {
    requester.requestFailed();
  }
  if (super.getMaterial() != EMaterialType.NO_MATERIAL) {
    super.getGrid().pushMaterial(super.getPos(),super.getMaterial(),true);
    super.setMaterial(EMaterialType.NO_MATERIAL);
  }
}"
56582,"protected AbstractSoldierStrategy(IMovableGrid grid,Movable movable,EMovableType type){
  super(grid,movable);
  this.type=type;
  this.behavior=SoldierBehavior.getDefaultSoldierBehavior(this);
}","protected AbstractSoldierStrategy(IMovableGrid grid,Movable movable,EMovableType type){
  super(grid,movable);
  this.type=type;
  this.behavior=SoldierBehavior.getDefaultSoldierBehavior(this);
  super.setAction(EAction.NO_ACTION,-1);
}"
56583,"WatchingBehavior(ISoldierBehaviorable soldier){
  super(soldier);
  initActions();
}","WatchingBehavior(ISoldierBehaviorable soldier){
  super(soldier);
  super.setAction(EAction.NO_ACTION,-1);
}"
56584,"@Override public void run(){
  NetworkManager manager=new NetworkManager();
  ProgressConnector progress=content.showProgress();
  RandomSingleton.load(randomSheed);
  Timer100Milli.start();
  NetworkTimer.get().setPausing(true);
  progress.setProgressState(EProgressState.LOADING_MAP);
  ImageProvider.getInstance().startPreloading();
  MainGrid grid;
  UIState uiState;
  try {
    grid=mapcreator.getMainGrid();
    uiState=mapcreator.getUISettings(0);
  }
 catch (  MapLoadException e1) {
    e1.printStackTrace();
    listener.gameEnded();
    return;
  }
  NetworkTimer.get().setPausing(false);
  progress.setProgressState(EProgressState.LOADING_IMAGES);
  final MapInterfaceConnector connector=content.showGameMap(grid.getGraphicsGrid(),null);
  new GuiInterface(connector,manager,grid.getGuiInputGrid(),(byte)0);
  connector.addListener(this);
  connector.loadUIState(uiState);
  manager.startGameTimer();
  gameConnector=connector;
synchronized (stopMutex) {
    while (!stopped) {
      try {
        stopMutex.wait();
      }
 catch (      InterruptedException e) {
      }
    }
  }
  listener.gameEnded();
}","@Override public void run(){
  NetworkManager manager=new NetworkManager();
  ProgressConnector progress=content.showProgress();
  RandomSingleton.load(randomSheed);
  NetworkTimer.get().setPausing(true);
  Timer100Milli.start();
  progress.setProgressState(EProgressState.LOADING_MAP);
  ImageProvider.getInstance().startPreloading();
  MainGrid grid;
  UIState uiState;
  try {
    grid=mapcreator.getMainGrid();
    uiState=mapcreator.getUISettings(0);
  }
 catch (  MapLoadException e1) {
    e1.printStackTrace();
    listener.gameEnded();
    return;
  }
  NetworkTimer.get().setPausing(false);
  progress.setProgressState(EProgressState.LOADING_IMAGES);
  final MapInterfaceConnector connector=content.showGameMap(grid.getGraphicsGrid(),null);
  new GuiInterface(connector,manager,grid.getGuiInputGrid(),(byte)0);
  connector.addListener(this);
  connector.loadUIState(uiState);
  manager.startGameTimer();
  gameConnector=connector;
synchronized (stopMutex) {
    while (!stopped) {
      try {
        stopMutex.wait();
      }
 catch (      InterruptedException e) {
      }
    }
  }
  listener.gameEnded();
}"
56585,"@Override public final void hit(float strength){
  if (health > 0) {
    health-=strength * 0.1f;
    if (health <= 0) {
      this.kill();
    }
 else {
      strategy.gotHitEvent();
    }
  }
}","@Override public final void hit(float strength){
  if (health >= 0) {
    health-=strength * 0.1f;
    if (health <= 0) {
      this.kill();
      health=-1;
    }
 else {
      strategy.gotHitEvent();
    }
  }
}"
56586,"@Override public void action(Action action){
  System.out.println(""String_Node_Str"" + action.getActionType());
  if (action.getActionType() == EActionType.SELECT_AREA) {
  }
 else   if (action instanceof DrawLineAction) {
    if (tool != null) {
      DrawLineAction lineAction=(DrawLineAction)action;
      ShapeType shape=getActiveShape();
      tool.apply(data,shape,lineAction.getStart(),lineAction.getEnd(),lineAction.getUidy());
      dataTester.retest();
    }
  }
 else   if (action instanceof StartDrawingAction) {
    if (tool != null) {
      StartDrawingAction lineAction=(StartDrawingAction)action;
      ShapeType shape=getActiveShape();
      tool.start(data,shape,lineAction.getPos());
      dataTester.retest();
    }
  }
 else   if (action instanceof EndDrawingAction) {
    endUseStep();
    dataTester.retest();
  }
 else   if (action instanceof AbortDrawingAction) {
    MapDataDelta delta=data.getUndoDelta();
    data.apply(delta);
    data.resetUndoDelta();
    dataTester.retest();
  }
}","@Override public void action(Action action){
  System.out.println(""String_Node_Str"" + action.getActionType());
  if (action.getActionType() == EActionType.SELECT_AREA) {
  }
 else   if (action instanceof DrawLineAction) {
    if (tool != null) {
      DrawLineAction lineAction=(DrawLineAction)action;
      ShapeType shape=getActiveShape();
      tool.apply(data,shape,lineAction.getStart(),lineAction.getEnd(),lineAction.getUidy());
      dataTester.retest();
    }
  }
 else   if (action instanceof StartDrawingAction) {
    if (tool != null) {
      StartDrawingAction lineAction=(StartDrawingAction)action;
      ShapeType shape=getActiveShape();
      tool.start(data,shape,lineAction.getPos());
      dataTester.retest();
    }
  }
 else   if (action instanceof EndDrawingAction) {
    endUseStep();
    dataTester.retest();
  }
 else   if (action instanceof AbortDrawingAction) {
    MapDataDelta delta=data.getUndoDelta();
    data.apply(delta);
    data.resetUndoDelta();
    dataTester.retest();
  }
 else   if (action instanceof SelectAction) {
    if (tool != null) {
      SelectAction lineAction=(SelectAction)action;
      ShapeType shape=getActiveShape();
      tool.start(data,shape,lineAction.getPosition());
      tool.apply(data,shape,lineAction.getPosition(),lineAction.getPosition(),0);
      endUseStep();
      dataTester.retest();
    }
  }
}"
56587,"@Override public boolean containsPoint(UIPoint position){
  return true;
}","@Override public boolean containsPoint(UIPoint position){
  return false;
}"
56588,"protected final boolean isLandscapeBlocking(short x,short y){
  ELandscapeType landscape=landscapeGrid.getLandscapeTypeAt(x,y);
  return landscape.isWater() || landscape == ELandscapeType.MOOR || landscape == ELandscapeType.SNOW;
}","protected final boolean isLandscapeBlocking(short x,short y){
  ELandscapeType landscape=landscapeGrid.getLandscapeTypeAt(x,y);
  return landscape.isWater() || landscape == ELandscapeType.MOOR || landscape == ELandscapeType.MOORINNER || landscape == ELandscapeType.SNOW;
}"
56589,"@SuppressWarnings(""String_Node_Str"") public SlotQueue(T[] slottypes,int[] slotpriority){
  int slotCount=slotpriority.length;
  if (slotCount != slottypes.length) {
    throw new IllegalArgumentException();
  }
  this.slotTypes=slottypes;
  this.slotPriority=slotpriority;
  this.slots=(ElementHolder<E>[])new ElementHolder[slotCount];
  this.tails=(ElementHolder<E>[])new ElementHolder[slotCount];
  this.count=new int[slotCount];
  this.slotOrder=new int[slotCount];
  for (int i=0; i < slotCount; i++) {
    slotOrder[i]=i;
  }
  reorderSlots();
}","@SuppressWarnings(""String_Node_Str"") public SlotQueue(T[] slottypes,int[] slotpriority){
  int slotCount=slotpriority.length;
  if (slotCount != slottypes.length) {
    throw new IllegalArgumentException();
  }
  this.slotTypes=slottypes;
  this.slotPriority=slotpriority;
  this.slots=new ElementHolder[slotCount];
  this.tails=new ElementHolder[slotCount];
  this.count=new int[slotCount];
  this.slotOrder=new int[slotCount];
  for (int i=0; i < slotCount; i++) {
    slotOrder[i]=i;
  }
  reorderSlots();
}"
56590,"@Override public final void run(){
  while (true) {
    ISPosition2D startPos=null;
    while (startPos == null) {
      try {
        startPos=queue.take();
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    checkLandmarks(startPos);
  }
}","@Override public final void run(){
  try {
    Thread.sleep(1000);
  }
 catch (  InterruptedException e) {
  }
  while (true) {
    try {
      Thread.sleep(1);
    }
 catch (    InterruptedException e) {
    }
    ISPosition2D startPos=null;
    while (startPos == null) {
      try {
        startPos=queue.take();
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    checkLandmarks(startPos);
  }
}"
56591,"@Override public float getRank(){
  return heuristic + cost;
}","@Override public final float getRank(){
  return heuristic + cost;
}"
56592,"private void drawOccupyers(MapDrawContext context,IOccupyed building){
  for (  IBuildingOccupyer occupyer : building.getOccupyers()) {
    OccupyerPlace place=occupyer.getPlace();
    GLDrawContext gl=context.getGl();
    gl.glPushMatrix();
    gl.glTranslatef(place.getOffsetX(),place.getOffsetY(),0);
    if (place.getType() == ESoldierType.INFANTARY) {
      ImageLink image=place.looksRight() ? INSIDE_BUILDING_RIGHT : INSIDE_BUILDING_LEFT;
      Color color=context.getPlayerColor(occupyer.getMovable().getPlayer());
      imageProvider.getImage(image).draw(gl,color);
    }
 else {
      movableDrawer.draw(context,occupyer.getMovable());
    }
    gl.glPopMatrix();
  }
}","private void drawOccupyers(MapDrawContext context,IOccupyed building){
  try {
    for (    IBuildingOccupyer occupyer : building.getOccupyers()) {
      OccupyerPlace place=occupyer.getPlace();
      GLDrawContext gl=context.getGl();
      gl.glPushMatrix();
      gl.glTranslatef(place.getOffsetX(),place.getOffsetY(),0);
      if (place.getType() == ESoldierType.INFANTARY) {
        ImageLink image=place.looksRight() ? INSIDE_BUILDING_RIGHT : INSIDE_BUILDING_LEFT;
        Color color=context.getPlayerColor(occupyer.getMovable().getPlayer());
        imageProvider.getImage(image).draw(gl,color);
      }
 else {
        movableDrawer.draw(context,occupyer.getMovable());
      }
      gl.glPopMatrix();
    }
  }
 catch (  ConcurrentModificationException e) {
  }
}"
56593,"@Override public final Color getDebugColorAt(int x,int y){
  short value=(short)(partitionsGrid.getPartitionAt((short)x,(short)y) + 1);
  return new Color((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
}","@Override public final Color getDebugColorAt(int x,int y){
  return flagsGrid.isBlocked((short)x,(short)y) ? new Color(0,0,0,1) : (flagsGrid.isProtected((short)x,(short)y) ? new Color(0,0,1,1) : (flagsGrid.isMarked((short)x,(short)y) ? new Color(0,1,0,1) : null));
}"
56594,"public BuildingWorkerStrategy(IMovableGrid grid,Movable movable,EMovableType movableType){
  super(grid,movable);
  this.movableType=movableType;
  grid.addJobless(this);
}","public BuildingWorkerStrategy(IMovableGrid grid,Movable movable,EMovableType movableType){
  super(grid,movable);
  this.movableType=movableType;
  makeJobless();
}"
56595,"@Override public void setWorkerJob(IWorkerRequestBuilding building){
  if (building.isNotDestroyed()) {
    this.building=building;
    this.currentJob=building.getBuildingType().getStartJob();
    this.done=false;
    this.building.occupyBuilding(this);
  }
 else {
    super.getGrid().addJobless(this);
  }
}","@Override public void setWorkerJob(IWorkerRequestBuilding building){
  if (building.isNotDestroyed()) {
    this.building=building;
    this.currentJob=building.getBuildingType().getStartJob();
    this.done=false;
    this.building.occupyBuilding(this);
    recordedJobless=false;
  }
 else {
    super.getGrid().addJobless(this);
  }
}"
56596,"@Override protected void pathRequestFailed(){
  super.setAction(EAction.NO_ACTION,-1);
  path=null;
  if (currentJob != null)   jobFailed();
}","@Override protected void pathRequestFailed(){
  super.setAction(EAction.NO_ACTION,-1);
  this.path=null;
  if (currentJob != null)   jobFailed();
}"
56597,"private void checkForDroppingMaterial(){
  EMaterialType material;
  material=super.getMaterial();
  if (material != null && material != EMaterialType.NO_MATERIAL) {
    super.setAction(EAction.DROP,Constants.MOVABLE_TAKE_DROP_DURATION);
    super.setMaterial(EMaterialType.NO_MATERIAL);
    super.getGrid().pushMaterial(super.getPos(),material,true);
  }
  super.getGrid().addJobless(this);
}","private void checkForDroppingMaterial(){
  EMaterialType material;
  material=super.getMaterial();
  if (material != null && material != EMaterialType.NO_MATERIAL) {
    super.setAction(EAction.DROP,Constants.MOVABLE_TAKE_DROP_DURATION);
    super.setMaterial(EMaterialType.NO_MATERIAL);
    super.getGrid().pushMaterial(super.getPos(),material,true);
  }
  makeJobless();
}"
56598,"@Override public void buildingDestroyed(){
  this.currentJob=null;
  if (super.isFollowingPath()) {
    super.getGrid().setMarked(super.getTargetPos(),false);
    super.abortPath();
  }
  this.done=false;
  super.setVisible(true);
}","@Override public void buildingDestroyed(){
  this.currentJob=null;
  this.building=null;
  this.path=null;
  if (super.isFollowingPath()) {
    super.getGrid().setMarked(super.getTargetPos(),false);
    super.abortPath();
  }
  this.done=false;
  super.setVisible(true);
}"
56599,"/** 
 * this method removes the enforcement in the given area
 * @param occupied
 * @param pos
 */
void freeOccupiedArea(MapShapeFilter occupied,ISPosition2D pos);","/** 
 * this method removes the enforcement in the given area
 * @param occupied
 * @param pos
 */
void freeOccupiedArea(MapCircle occupied,ISPosition2D pos);"
56600,"void occupyArea(MapShapeFilter toBeOccupied,ISPosition2D occupiersPosition,byte player);","void occupyArea(MapCircle toBeOccupied,ISPosition2D occupiersPosition,byte player);"
56601,"@Override protected final void killedEvent(){
  setSelected(false);
  if (occupiedArea) {
    MapShapeFilter occupied=getOccupyablePositions();
    super.getGrid().freeOccupiedArea(occupied,super.getPos());
    int idx=0;
    for (    TowerOccupyer curr : occupiers) {
      curr.soldier.leaveOccupyableBuilding(super.getBuildingArea().get(idx));
      idx++;
    }
    occupiers.clear();
  }
  allOccupyingBuildings.remove(this);
}","@Override protected final void killedEvent(){
  setSelected(false);
  if (occupiedArea) {
    MapCircle occupied=getOccupyablePositions();
    super.getGrid().freeOccupiedArea(occupied,super.getPos());
    int idx=0;
    for (    TowerOccupyer curr : occupiers) {
      curr.soldier.leaveOccupyableBuilding(super.getBuildingArea().get(idx));
      idx++;
    }
    occupiers.clear();
  }
  allOccupyingBuildings.remove(this);
}"
56602,"public final MapShapeFilter getOccupyablePositions(){
  return new MapShapeFilter(new MapCircle(super.getPos(),CommonConstants.TOWERRADIUS),super.getGrid().getWidth(),super.getGrid().getHeight());
}","public final MapCircle getOccupyablePositions(){
  return new MapCircle(super.getPos(),CommonConstants.TOWERRADIUS);
}"
56603,"private final void occupyArea(){
  if (!occupiedArea) {
    MapShapeFilter occupying=getOccupyablePositions();
    super.getGrid().occupyArea(occupying,super.getPos(),super.getPlayer());
    occupiedArea=true;
  }
}","private final void occupyArea(){
  if (!occupiedArea) {
    MapCircle occupying=getOccupyablePositions();
    super.getGrid().occupyArea(occupying,super.getPos(),super.getPlayer());
    occupiedArea=true;
  }
}"
56604,"@Override public final void freeOccupiedArea(MapShapeFilter occupied,ISPosition2D pos){
  List<ISPosition2D> totallyFreed=partitionsGrid.freeOccupiedArea(occupied,pos);
  if (!totallyFreed.isEmpty()) {
    StopWatch watch=new MilliStopWatch();
    watch.start();
    List<OccupyingBuilding> allOccupying=OccupyingBuilding.getAllOccupyingBuildings();
    int maxSqDistance=6 * CommonConstants.TOWERRADIUS * CommonConstants.TOWERRADIUS;
    List<OccupyingDistanceCombi> occupyingInRange=new LinkedList<OccupyingDistanceCombi>();
    for (    OccupyingBuilding curr : allOccupying) {
      ISPosition2D currPos=curr.getPos();
      int dx=currPos.getX() - pos.getX();
      int dy=currPos.getY() - pos.getY();
      int sqDistance=dx * dx + dy * dy;
      if (sqDistance <= maxSqDistance && sqDistance > 0) {
        occupyingInRange.add(new OccupyingDistanceCombi(sqDistance,curr));
      }
    }
    if (!occupyingInRange.isEmpty()) {
      Collections.sort(occupyingInRange);
      FreeMapArea freedArea=new FreeMapArea(totallyFreed);
      for (      OccupyingDistanceCombi currOcc : occupyingInRange) {
        MapShapeFilter currOccArea=currOcc.building.getOccupyablePositions();
        Iterator<ISPosition2D> iter=freedArea.iterator();
        for (ISPosition2D currPos=iter.next(); iter.hasNext(); currPos=iter.next()) {
          if (currOccArea.contains(currPos)) {
            iter.remove();
            partitionsGrid.occupyAt(currPos.getX(),currPos.getY(),currOcc.building.getPlayer());
          }
        }
        if (freedArea.isEmpty()) {
          break;
        }
      }
    }
    watch.stop(""String_Node_Str"");
  }
}","@Override public final void freeOccupiedArea(MapCircle occupied,ISPosition2D pos){
  List<ISPosition2D> totallyFreed=partitionsGrid.freeOccupiedArea(occupied,pos);
  if (!totallyFreed.isEmpty()) {
    StopWatch watch=new MilliStopWatch();
    watch.start();
    List<OccupyingBuilding> allOccupying=OccupyingBuilding.getAllOccupyingBuildings();
    int maxSqDistance=6 * CommonConstants.TOWERRADIUS * CommonConstants.TOWERRADIUS;
    List<OccupyingDistanceCombi> occupyingInRange=new LinkedList<OccupyingDistanceCombi>();
    for (    OccupyingBuilding curr : allOccupying) {
      ISPosition2D currPos=curr.getPos();
      int dx=currPos.getX() - pos.getX();
      int dy=currPos.getY() - pos.getY();
      int sqDistance=dx * dx + dy * dy;
      if (sqDistance <= maxSqDistance && sqDistance > 0) {
        occupyingInRange.add(new OccupyingDistanceCombi(sqDistance,curr));
      }
    }
    if (!occupyingInRange.isEmpty()) {
      Collections.sort(occupyingInRange);
      FreeMapArea freedArea=new FreeMapArea(totallyFreed);
      for (      OccupyingDistanceCombi currOcc : occupyingInRange) {
        MapCircle currOccArea=currOcc.building.getOccupyablePositions();
        Iterator<ISPosition2D> iter=freedArea.iterator();
        for (ISPosition2D currPos=iter.next(); iter.hasNext(); currPos=iter.next()) {
          if (currOccArea.contains(currPos)) {
            iter.remove();
            partitionsGrid.occupyAt(currPos.getX(),currPos.getY(),currOcc.building.getPlayer());
          }
        }
        if (freedArea.isEmpty()) {
          break;
        }
      }
    }
    watch.stop(""String_Node_Str"");
  }
}"
56605,"@Override public final void occupyArea(MapShapeFilter toBeOccupied,ISPosition2D occupiersPosition,byte player){
  List<ISPosition2D> occupiedPositions=partitionsGrid.occupyArea(toBeOccupied,occupiersPosition,player);
  bordersThread.checkPositions(occupiedPositions);
  landmarksCorrectionThread.addLandmarkedPositions(occupiedPositions);
}","@Override public final void occupyArea(MapCircle toBeOccupied,ISPosition2D occupiersPosition,byte player){
  List<ISPosition2D> occupiedPositions=partitionsGrid.occupyArea(toBeOccupied,occupiersPosition,player);
  bordersThread.checkPositions(occupiedPositions);
  landmarksCorrectionThread.addLandmarkedPositions(occupiedPositions);
}"
56606,"private MainGrid(IMapData mapGrid){
  this((short)mapGrid.getWidth(),(short)mapGrid.getHeight());
  for (short y=0; y < height; y++) {
    for (short x=0; x < width; x++) {
      ELandscapeType landscape=mapGrid.getLandscape(x,y);
      landscapeGrid.setLandscapeTypeAt(x,y,landscape);
      landscapeGrid.setHeightAt(x,y,mapGrid.getLandscapeHeight(x,y));
      if (landscape == ELandscapeType.MOUNTAIN) {
        landscapeGrid.setResourceAt(x,y,EResourceType.values()[RandomSingleton.getInt(0,2)],(byte)RandomSingleton.getInt(-100,127));
      }
 else       if (landscape.isWater()) {
        landscapeGrid.setResourceAt(x,y,EResourceType.FISH,(byte)RandomSingleton.getInt(-100,127));
      }
    }
  }
  for (short y=0; y < height; y++) {
    for (short x=0; x < width; x++) {
      MapObject object=mapGrid.getMapObject(x,y);
      if (object != null && !(object instanceof MovableObject)) {
        addMapObject(x,y,object);
      }
      if ((x + y / 2) % 4 == 0 && y % 4 == 0 && isInsideWater(x,y)) {
        mapObjectsManager.addWaves(x,y);
        if (landscapeGrid.getResourceAmountAt(x,y) > 50) {
          mapObjectsManager.addFish(x,y);
        }
      }
    }
  }
  for (short y=0; y < height; y++) {
    for (short x=0; x < width; x++) {
      MapObject object=mapGrid.getMapObject(x,y);
      if (object != null && object instanceof MovableObject) {
        addMapObject(x,y,object);
      }
    }
  }
  System.out.println(""String_Node_Str"");
}","private MainGrid(IMapData mapGrid){
  this((short)mapGrid.getWidth(),(short)mapGrid.getHeight());
  for (short y=0; y < height; y++) {
    for (short x=0; x < width; x++) {
      ELandscapeType landscape=mapGrid.getLandscape(x,y);
      landscapeGrid.setLandscapeTypeAt(x,y,landscape);
      landscapeGrid.setHeightAt(x,y,mapGrid.getLandscapeHeight(x,y));
      if (landscape == ELandscapeType.MOUNTAIN) {
        landscapeGrid.setResourceAt(x,y,EResourceType.values()[RandomSingleton.getInt(0,2)],(byte)RandomSingleton.getInt(-100,127));
      }
 else       if (landscape.isWater()) {
        landscapeGrid.setResourceAt(x,y,EResourceType.FISH,(byte)RandomSingleton.getInt(-100,127));
      }
    }
  }
  for (short y=0; y < height; y++) {
    for (short x=0; x < width; x++) {
      MapObject object=mapGrid.getMapObject(x,y);
      if (object != null && (object instanceof BuildingObject) && isTower(((BuildingObject)object).getType())) {
        addMapObject(x,y,object);
      }
      if ((x + y / 2) % 4 == 0 && y % 4 == 0 && isInsideWater(x,y)) {
        mapObjectsManager.addWaves(x,y);
        if (landscapeGrid.getResourceAmountAt(x,y) > 50) {
          mapObjectsManager.addFish(x,y);
        }
      }
    }
  }
  for (short y=0; y < height; y++) {
    for (short x=0; x < width; x++) {
      MapObject object=mapGrid.getMapObject(x,y);
      if (object != null && !((object instanceof BuildingObject) && isTower(((BuildingObject)object).getType()))) {
        addMapObject(x,y,object);
      }
    }
  }
  System.out.println(""String_Node_Str"");
}"
56607,"@Override public final Color getDebugColorAt(int x,int y){
  short value=(short)(partitionsGrid.getTowerCounterAt((short)x,(short)y) + 1);
  return new Color((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
}","@Override public final Color getDebugColorAt(int x,int y){
  short value=(short)(partitionsGrid.getPartitionAt((short)x,(short)y) + 1);
  return new Color((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
}"
56608,"public final List<ISPosition2D> freeOccupiedArea(MapShapeFilter occupied,ISPosition2D occupiersPosition){
  short partiton=getPartition(occupiersPosition);
  List<ISPosition2D> totallyFreePositions=new ArrayList<ISPosition2D>();
  for (  ISPosition2D curr : occupied) {
    short x=curr.getX();
    short y=curr.getY();
    if (getPartitionAt(x,y) == partiton) {
      towers[x][y]--;
      if (towers[x][y] <= 0) {
        totallyFreePositions.add(curr);
        towers[x][y]=0;
      }
    }
  }
  return totallyFreePositions;
}","public final List<ISPosition2D> freeOccupiedArea(MapCircle occupied,ISPosition2D occupiersPosition){
  short partiton=getPartition(occupiersPosition);
  List<ISPosition2D> totallyFreePositions=new ArrayList<ISPosition2D>();
  for (  ISPosition2D curr : occupied) {
    short x=curr.getX();
    short y=curr.getY();
    if (isInBounds(x,y) && getPartitionAt(x,y) == partiton) {
      towers[x][y]--;
      if (towers[x][y] <= 0) {
        totallyFreePositions.add(curr);
        towers[x][y]=0;
      }
    }
  }
  return totallyFreePositions;
}"
56609,"public final List<ISPosition2D> occupyArea(MapShapeFilter toBeOccupied,ISPosition2D occupiersPosition,byte newPlayer){
  changePlayerAt(occupiersPosition.getX(),occupiersPosition.getY(),newPlayer);
  short newPartition=getPartition(occupiersPosition);
  List<ISPosition2D> occupiedPositions=new ArrayList<ISPosition2D>();
  for (  ISPosition2D curr : toBeOccupied) {
    short x=curr.getX();
    short y=curr.getY();
    short partitionAt=getPartitionAt(x,y);
    if (partitionAt != newPartition && towers[x][y] <= 0) {
      if (partitionAt < 0) {
        setPartition(x,y,newPartition);
        occupiedPositions.add(curr);
      }
 else       if (partitionObjects[partitionAt].getPlayer() == newPlayer) {
        newPartition=this.mergePartitions(x,y,occupiersPosition.getX(),occupiersPosition.getY());
      }
 else {
        occupiedPositions.add(curr);
        this.partitionsAlgorithm.calculateNewPartition(x,y,newPlayer);
      }
    }
    if (getPlayerAt(x,y) == newPlayer) {
      towers[x][y]++;
    }
  }
  return occupiedPositions;
}","public final List<ISPosition2D> occupyArea(MapCircle toBeOccupied,ISPosition2D occupiersPosition,byte newPlayer){
  MilliStopWatch watch=new MilliStopWatch();
  watch.start();
  changePlayerAt(occupiersPosition.getX(),occupiersPosition.getY(),newPlayer);
  short newPartition=getPartition(occupiersPosition);
  List<ISPosition2D> occupiedPositions=new ArrayList<ISPosition2D>();
  List<ISPosition2D> checkForMerge=new ArrayList<ISPosition2D>();
  ISPosition2D unblockedOccupied=null;
  for (  ISPosition2D curr : toBeOccupied) {
    short x=curr.getX();
    short y=curr.getY();
    if (!isInBounds(x,y)) {
      continue;
    }
    short currPartition=getPartitionAt(x,y);
    if (currPartition != newPartition) {
      if (towers[x][y] <= 0) {
        if (currPartition < 0) {
          setPartition(x,y,newPartition);
          occupiedPositions.add(curr);
          if (unblockedOccupied == null && !grid.isBlocked(x,y)) {
            unblockedOccupied=curr;
          }
        }
 else         if (partitionObjects[currPartition].getPlayer() == newPlayer) {
          checkForMerge.add(curr);
        }
      }
 else {
        if (partitionObjects[currPartition].getPlayer() == newPlayer) {
          checkForMerge.add(curr);
        }
      }
    }
    if (getPlayerAt(x,y) == newPlayer) {
      towers[x][y]++;
      for (      ISPosition2D neighbor : new MapNeighboursArea(curr)) {
        if (isInBounds(neighbor) && !toBeOccupied.contains(neighbor)) {
          checkForMerge.add(neighbor);
        }
      }
    }
  }
  ISPosition2D[] foundPartions=new ISPosition2D[partitionObjects.length];
  for (  ISPosition2D curr : checkForMerge) {
    foundPartions[getPartition(curr) + 1]=curr;
  }
  for (short i=0; i < foundPartions.length; i++) {
    ISPosition2D pos=foundPartions[i];
    if (pos != null && (i - 1) != newPartition) {
      if (getPartitionObject((short)(i - 1)).getPlayer() == newPlayer) {
        this.mergePartitions(pos.getX(),pos.getY(),unblockedOccupied.getX(),unblockedOccupied.getY());
      }
    }
  }
  watch.stop(""String_Node_Str"");
  return occupiedPositions;
}"
56610,"private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException {
  ois.defaultReadObject();
  Timer100Milli.add(this);
}","private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException {
  ois.defaultReadObject();
  allBuildings.add(this);
  Timer100Milli.add(this);
}"
56611,"/** 
 * This method overrides the standard deserialize method to restore the movablesByID map and the nextID.
 * @param ois
 * @throws IOException
 * @throws ClassNotFoundException
 */
private final void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
  ois.defaultReadObject();
  movablesByID.put(this.id,this);
  nextID=Math.max(nextID,this.id + 1);
  MovableTimer.add(this);
}","/** 
 * This method overrides the standard deserialize method to restore the movablesByID map and the nextID.
 * @param ois
 * @throws IOException
 * @throws ClassNotFoundException
 */
private final void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
  ois.defaultReadObject();
  movablesByID.put(this.id,this);
  allMovables.add(this);
  nextID=Math.max(nextID,this.id + 1);
  MovableTimer.add(this);
}"
56612,"private static final boolean checkPosition(short offsetX,short offsetY,BitSet areaSet,short areaWidth,BuildingSet buildingSet){
  for (short x=0; x < buildingSet.width; x++) {
    for (short y=0; y < buildingSet.height; y++) {
      if (buildingSet.getWithoutOffset(x,y)) {
        if (!areaSet.get((x + offsetX + buildingSet.minX) + (y + offsetY + buildingSet.minY) * areaWidth)) {
          return false;
        }
      }
    }
  }
  return true;
}","private static final boolean checkPosition(int offsetX,int offsetY,BitSet areaSet,short areaWidth,BuildingAreaBitSet buildingSet){
  for (short x=0; x < buildingSet.width; x++) {
    for (short y=0; y < buildingSet.height; y++) {
      if (buildingSet.getWithoutOffset(x,y)) {
        if (!areaSet.get((x + offsetX) + (y + offsetY) * areaWidth)) {
          return false;
        }
      }
    }
  }
  return true;
}"
56613,"private void calculateConstructMarks(){
  MapRectangle area=this.mapArea;
  EBuildingType currBuildingType=this.buildingType;
  if (currBuildingType == null || area == null) {
    return;
  }
  if (lastArea != null) {
    removeConstructionMarks(lastArea,area);
  }
  final short minX=(short)(area.getLineStartX(0));
  final short maxX=(short)(area.getLineEndX(area.getLines() - 1));
  final short minY=(area.getMinY());
  final short width=(short)(maxX - minX + 1);
  final short height=area.getHeight();
  final short setWidth=(short)(width + buildingSet.width);
  final short setHeight=(short)(height + buildingSet.height);
  BitSet areaSet=new BitSet(setWidth * setHeight);
  final ELandscapeType[] landscapeTypes=buildingType.getGroundtypes();
  for (short y=0; y < setHeight; y++) {
    for (short x=0; x < setWidth; x++) {
      boolean canConstruct=map.canUsePositionForConstruction((short)(minX + x),(short)(y + minY),landscapeTypes,player);
      areaSet.set(x + y * setWidth,canConstruct);
    }
  }
  for (short y=(short)-buildingSet.minY; y < height; y++) {
    for (short x=(short)-buildingSet.minX; x < width; x++) {
      final short mapX=(short)(minX + x);
      final short mapY=(short)(minY + y);
      if (map.isInBounds(mapX,mapY)) {
        byte value;
        if (checkPosition(x,y,areaSet,setWidth,buildingSet)) {
          value=(byte)1;
        }
 else {
          value=-1;
        }
        map.setConstructMarking(mapX,mapY,value);
      }
    }
  }
  lastArea=area;
}","private void calculateConstructMarks(){
  MapRectangle area=this.mapArea;
  EBuildingType currBuildingType=this.buildingType;
  if (currBuildingType == null || area == null) {
    return;
  }
  if (lastArea != null) {
    removeConstructionMarks(lastArea,area);
  }
  final BuildingAreaBitSet buildingSet=buildingType.getBuildingAreaBitSet();
  final short minX=(short)(area.getLineStartX(0));
  final short maxX=(short)(area.getLineEndX(area.getLines() - 1));
  final short minY=(area.getMinY());
  final short width=(short)(maxX - minX + 1);
  final short height=area.getHeight();
  final short setWidth=(short)(width + buildingSet.width);
  final short setHeight=(short)(height + buildingSet.height);
  BitSet areaSet=new BitSet(setWidth * setHeight);
  final ELandscapeType[] landscapeTypes=buildingType.getGroundtypes();
  for (short y=0; y < setHeight; y++) {
    for (short x=0; x < setWidth; x++) {
      boolean canConstruct=map.canUsePositionForConstruction((short)(minX + buildingSet.minX + x),(short)(y + buildingSet.minY + minY),landscapeTypes,player);
      areaSet.set(x + y * setWidth,canConstruct);
    }
  }
  for (short line=0; line < area.getLines(); line++) {
    final short mapY=(short)area.getLineY(line);
    final int endX=area.getLineEndX(line);
    for (short mapX=(short)area.getLineStartX(line); mapX < endX; mapX++) {
      if (map.isInBounds(mapX,mapY)) {
        byte value;
        if (checkPosition(mapX - minX,mapY - minY,areaSet,setWidth,buildingSet)) {
          value=(byte)1;
        }
 else {
          value=-1;
        }
        map.setConstructMarking(mapX,mapY,value);
      }
    }
  }
  lastArea=area;
}"
56614,"public void setBuildingType(EBuildingType type){
  this.buildingType=type;
  if (type != null) {
    this.buildingSet=new BuildingSet(type);
  }
 else {
    this.buildingSet=null;
  }
  refreshMarkings();
}","public void setBuildingType(EBuildingType type){
  this.buildingType=type;
  refreshMarkings();
}"
56615,"@Override public void draw(GLDrawContext gl,Color color,float multiply){
  if (color == null) {
    gl.color(multiply,multiply,multiply,1);
  }
 else {
    gl.color(color.getRed() * multiply,color.getGreen() * multiply,color.getBlue() * multiply,color.getAlpha());
  }
  gl.drawTrianglesWithTexture(getTextureIndex(gl),getGeometryIndex(gl),2);
  return;
}","@Override public void draw(GLDrawContext gl,Color color,float multiply){
  if (color == null) {
    gl.color(multiply,multiply,multiply,1);
  }
 else {
    gl.color(color.getRed() * multiply,color.getGreen() * multiply,color.getBlue() * multiply,color.getAlpha());
  }
  int textureIndex=getTextureIndex(gl);
  int geometryIndex2=getGeometryIndex(gl);
  gl.drawTrianglesWithTexture(textureIndex,geometryIndex2,2);
}"
56616,"public void drawImageAtRect(GLDrawContext gl,float left,float bottom,float right,float top){
  tmpBuffer[0]=left;
  tmpBuffer[1]=top;
  tmpBuffer[5]=left;
  tmpBuffer[6]=bottom;
  tmpBuffer[9]=(float)height / textureHeight;
  tmpBuffer[10]=right;
  tmpBuffer[11]=bottom;
  tmpBuffer[13]=(float)width / textureWidth;
  tmpBuffer[14]=(float)height / textureHeight;
  tmpBuffer[15]=right;
  tmpBuffer[16]=top;
  tmpBuffer[18]=(float)width / textureWidth;
  gl.drawQuadWithTexture(getTextureIndex(gl),tmpBuffer);
}","public void drawImageAtRect(GLDrawContext gl,float left,float bottom,float right,float top){
  int textureIndex=getTextureIndex(gl);
  tmpBuffer[0]=left;
  tmpBuffer[1]=top;
  tmpBuffer[5]=left;
  tmpBuffer[6]=bottom;
  tmpBuffer[9]=(float)height / textureHeight;
  tmpBuffer[10]=right;
  tmpBuffer[11]=bottom;
  tmpBuffer[13]=(float)width / textureWidth;
  tmpBuffer[14]=(float)height / textureHeight;
  tmpBuffer[15]=right;
  tmpBuffer[16]=top;
  tmpBuffer[18]=(float)width / textureWidth;
  gl.drawQuadWithTexture(textureIndex,tmpBuffer);
}"
56617,"private void calculateConstructMarks(){
  MapRectangle area=this.mapArea;
  EBuildingType currBuildingType=this.buildingType;
  if (currBuildingType == null || area == null) {
    return;
  }
  RelativePoint[] usedPositions=currBuildingType.getProtectedTiles();
  if (lastArea != null) {
    removeConstructionMarks(lastArea,area);
  }
  for (  ISPosition2D pos : area) {
    short x=pos.getX();
    short y=pos.getY();
    byte value;
    if (map.canConstructAt(x,y,currBuildingType,player)) {
      value=calculateConstrMarkVal(x,y,usedPositions);
    }
 else {
      value=-1;
    }
    map.setConstructMarking(pos,value);
  }
  lastArea=area;
}","private void calculateConstructMarks(){
  MapRectangle area=this.mapArea;
  EBuildingType currBuildingType=this.buildingType;
  if (currBuildingType == null || area == null) {
    return;
  }
  if (lastArea != null) {
    removeConstructionMarks(lastArea,area);
  }
  final short minX=(short)(area.getLineStartX(0));
  final short maxX=(short)(area.getLineEndX(area.getLines() - 1));
  final short minY=(area.getMinY());
  final short width=(short)(maxX - minX + 1);
  final short height=area.getHeight();
  final short setWidth=(short)(width + buildingSet.width);
  final short setHeight=(short)(height + buildingSet.height);
  BitSet areaSet=new BitSet(setWidth * setHeight);
  final ELandscapeType[] landscapeTypes=buildingType.getGroundtypes();
  for (short y=0; y < setHeight; y++) {
    for (short x=0; x < setWidth; x++) {
      boolean canConstruct=map.canUsePositionForConstruction((short)(minX + x),(short)(y + minY),landscapeTypes,player);
      areaSet.set(x + y * setWidth,canConstruct);
    }
  }
  for (short y=(short)-buildingSet.minY; y < height; y++) {
    for (short x=(short)-buildingSet.minX; x < width; x++) {
      final short mapX=(short)(minX + x);
      final short mapY=(short)(minY + y);
      if (map.isInBounds(mapX,mapY)) {
        byte value;
        if (checkPosition(x,y,areaSet,setWidth,buildingSet)) {
          value=(byte)1;
        }
 else {
          value=-1;
        }
        map.setConstructMarking(mapX,mapY,value);
      }
    }
  }
  lastArea=area;
}"
56618,"/** 
 * Removes all construction marks in the given area.
 * @param area The area to remove the marks
 * @param notIn The area of marks that should be skipped.
 */
private void removeConstructionMarks(IMapArea area,IMapArea notIn){
  for (  ISPosition2D pos : area) {
    if (!notIn.contains(pos)) {
      map.setConstructMarking(pos,(byte)-1);
    }
  }
}","/** 
 * Removes all construction marks in the given area.
 * @param area The area to remove the marks
 * @param notIn The area of marks that should be skipped.
 */
private void removeConstructionMarks(IMapArea area,IMapArea notIn){
  for (  ISPosition2D pos : new MapShapeFilter(area,map.getWidth(),map.getHeight())) {
    if (!notIn.contains(pos)) {
      map.setConstructMarking(pos.getX(),pos.getY(),(byte)-1);
    }
  }
}"
56619,"public void setBuildingType(EBuildingType type){
  buildingType=type;
  refreshMarkings();
}","public void setBuildingType(EBuildingType type){
  this.buildingType=type;
  if (type != null) {
    this.buildingSet=new BuildingSet(type);
  }
 else {
    this.buildingSet=null;
  }
  refreshMarkings();
}"
56620,"/** 
 * Sets the given value to the given position.
 * @param pos position the value will be set to
 * @param value value to be set as construction mark value.
 */
void setConstructMarking(ISPosition2D pos,byte value);","/** 
 * Sets the given value to the given position.
 * @param x x coordinate
 * @param y y coordinate
 * @param value value to be set as construction mark value.
 */
void setConstructMarking(short x,short y,byte value);"
56621,"@Override public void action(Action action){
  if (action.getActionType() != EActionType.SCREEN_CHANGE) {
    System.out.println(""String_Node_Str"" + action.getActionType());
  }
switch (action.getActionType()) {
case BUILD:
    EBuildingType buildingType=((BuildAction)action).getBuilding();
  System.err.println(""String_Node_Str"" + buildingType);
this.previewBuilding=buildingType;
connector.setPreviewBuildingType(buildingType);
grid.setBuildingType(buildingType);
setActiveAction(action);
break;
case DEBUG_ACTION:
for (ISelectable curr : currentSelection) {
if (curr instanceof IDebugable) {
((IDebugable)curr).debug();
}
}
break;
case SPEED_TOGGLE_PAUSE:
NetworkTimer.get().invertPausing();
break;
case SPEED_SLOW:
if (!manager.isMultiplayer()) NetworkTimer.setGameSpeed(0.5f);
break;
case SPEED_FAST:
if (!manager.isMultiplayer()) NetworkTimer.setGameSpeed(2.0f);
break;
case SPEED_FASTER:
if (!manager.isMultiplayer()) NetworkTimer.multiplyGameSpeed(1.2f);
break;
case SPEED_SLOWER:
if (!manager.isMultiplayer()) NetworkTimer.multiplyGameSpeed(1 / 1.2f);
break;
case SPEED_NORMAL:
if (!manager.isMultiplayer()) NetworkTimer.setGameSpeed(1.0f);
break;
case FAST_FORWARD:
if (!manager.isMultiplayer()) {
NetworkTimer.get().fastForward();
}
break;
case SELECT_POINT:
handleSelectPointAction((SelectAction)action);
break;
case SELECT_AREA:
selectArea((SelectAreaAction)action);
break;
case MOVE_TO:
if (previewBuilding != null) {
cancelBuildingCreation();
setActiveAction(null);
}
 else {
MoveToAction moveToAction=(MoveToAction)action;
ISPosition2D pos=moveToAction.getPosition();
moveTo(pos);
}
break;
case SET_WORK_AREA:
setActiveAction(action);
break;
case DESTROY:
destroySelected();
break;
case STOP_WORKING:
stopOrStartWorkingAction(true);
break;
case START_WORKING:
stopOrStartWorkingAction(false);
break;
case SHOW_SELECTION:
showSelection();
break;
case SCREEN_CHANGE:
grid.setScreen(((ScreenChangeAction)action).getScreenArea());
break;
case TOGGLE_DEBUG:
break;
case SAVE:
manager.scheduleTask(new SimpleGuiTask(EGuiAction.QUICK_SAVE));
break;
default :
System.err.println(""String_Node_Str"" + action.getActionType() + ""String_Node_Str"");
}
}","@Override public void action(Action action){
  if (action.getActionType() != EActionType.SCREEN_CHANGE) {
    System.out.println(""String_Node_Str"" + action.getActionType());
  }
switch (action.getActionType()) {
case BUILD:
    EBuildingType buildingType=((BuildAction)action).getBuilding();
  System.err.println(""String_Node_Str"" + buildingType);
this.previewBuilding=buildingType;
connector.setPreviewBuildingType(buildingType);
grid.setBuildingType(buildingType);
setActiveAction(action);
break;
case DEBUG_ACTION:
for (ISelectable curr : currentSelection) {
if (curr instanceof IDebugable) {
((IDebugable)curr).debug();
}
}
break;
case SPEED_TOGGLE_PAUSE:
NetworkTimer.get().invertPausing();
break;
case SPEED_SLOW:
if (!manager.isMultiplayer()) NetworkTimer.setGameSpeed(0.5f);
break;
case SPEED_FAST:
if (!manager.isMultiplayer()) NetworkTimer.setGameSpeed(2.0f);
break;
case SPEED_FASTER:
if (!manager.isMultiplayer()) NetworkTimer.multiplyGameSpeed(1.2f);
break;
case SPEED_SLOWER:
if (!manager.isMultiplayer()) NetworkTimer.multiplyGameSpeed(1 / 1.2f);
break;
case SPEED_NORMAL:
if (!manager.isMultiplayer()) NetworkTimer.setGameSpeed(1.0f);
break;
case FAST_FORWARD:
if (!manager.isMultiplayer()) {
NetworkTimer.get().fastForward();
}
break;
case SELECT_POINT:
handleSelectPointAction((SelectAction)action);
break;
case SELECT_AREA:
selectArea((SelectAreaAction)action);
break;
case MOVE_TO:
if (previewBuilding != null) {
cancelBuildingCreation();
setActiveAction(null);
}
 else {
MoveToAction moveToAction=(MoveToAction)action;
ISPosition2D pos=moveToAction.getPosition();
moveTo(pos);
}
break;
case SET_WORK_AREA:
setActiveAction(action);
break;
case DESTROY:
destroySelected();
break;
case STOP_WORKING:
stopOrStartWorkingAction(true);
break;
case START_WORKING:
stopOrStartWorkingAction(false);
break;
case SHOW_SELECTION:
showSelection();
break;
case SCREEN_CHANGE:
grid.setScreen(((ScreenChangeAction)action).getScreenArea());
break;
case TOGGLE_DEBUG:
break;
case TOGGLE_FOG_OF_WAR:
grid.toggleFogOfWar();
case SAVE:
manager.scheduleTask(new SimpleGuiTask(EGuiAction.QUICK_SAVE));
break;
default :
System.err.println(""String_Node_Str"" + action.getActionType() + ""String_Node_Str"");
}
}"
56622,"private boolean isAllowedLandscape(short x,short y,ELandscapeType[] landscapes){
  ELandscapeType landscapeAt=landscapeGrid.getLandscapeTypeAt(x,y);
  for (byte i=0; i < landscapes.length; i++) {
    if (landscapeAt == landscapes[i]) {
      return true;
    }
  }
  return false;
}","private final boolean isAllowedLandscape(short x,short y,ELandscapeType[] landscapes){
  ELandscapeType landscapeAt=landscapeGrid.getLandscapeTypeAt(x,y);
  for (byte i=0; i < landscapes.length; i++) {
    if (landscapeAt == landscapes[i]) {
      return true;
    }
  }
  return false;
}"
56623,"@Override public void setConstructMarking(ISPosition2D pos,byte value){
  mapObjectsManager.setConstructionMarking(pos,value);
}","@Override public final void setConstructMarking(short x,short y,byte value){
  mapObjectsManager.setConstructionMarking(x,y,value);
}"
56624,"private boolean addMapObject(ISPosition2D pos,AbstractHexMapObject mapObject){
  for (  RelativePoint point : mapObject.getBlockedTiles()) {
    short x=point.calculateX(pos.getX());
    short y=point.calculateY(pos.getY());
    if (!grid.isInBounds(x,y) || grid.isBlocked(x,y)) {
      return false;
    }
  }
  grid.addMapObject(pos.getX(),pos.getY(),mapObject);
  setBlockedForObject(pos.getX(),pos.getY(),mapObject,true);
  return true;
}","private final boolean addMapObject(short x,short y,AbstractHexMapObject mapObject){
  for (  RelativePoint point : mapObject.getBlockedTiles()) {
    short currX=point.calculateX(x);
    short currY=point.calculateY(y);
    if (!grid.isInBounds(currX,currY) || grid.isBlocked(currX,currY)) {
      return false;
    }
  }
  grid.addMapObject(x,y,mapObject);
  setBlockedForObject(x,y,mapObject,true);
  return true;
}"
56625,"public void setConstructionMarking(ISPosition2D pos,byte value){
  if (value >= 0) {
    ConstructionMarkObject markObject=(ConstructionMarkObject)grid.getMapObject(pos.getX(),pos.getY(),EMapObjectType.CONSTRUCTION_MARK);
    if (markObject == null) {
      addMapObject(pos,new ConstructionMarkObject(value));
    }
 else {
      markObject.setConstructionValue(value);
    }
  }
 else {
    removeMapObjectType(pos.getX(),pos.getY(),EMapObjectType.CONSTRUCTION_MARK);
  }
}","public void setConstructionMarking(short x,short y,byte value){
  if (value >= 0) {
    ConstructionMarkObject markObject=(ConstructionMarkObject)grid.getMapObject(x,y,EMapObjectType.CONSTRUCTION_MARK);
    if (markObject == null) {
      addMapObject(x,y,new ConstructionMarkObject(value));
    }
 else {
      markObject.setConstructionValue(value);
    }
  }
 else {
    removeMapObjectType(x,y,EMapObjectType.CONSTRUCTION_MARK);
  }
}"
56626,void setScreen(IMapArea screenArea);,void setScreen(MapRectangle screenArea);
56627,"@Override public final void setScreen(IMapArea screenArea){
  constructionMarksCalculator.setScreen(screenArea);
}","@Override public final void setScreen(MapRectangle screenArea){
  constructionMarksCalculator.setScreen(screenArea);
}"
56628,"private void calculateConstructMarks(){
  IMapArea currMapArea=this.mapArea;
  EBuildingType currBuildingType=this.buildingType;
  if (currBuildingType == null || currMapArea == null) {
    return;
  }
  RelativePoint[] usedPositions=currBuildingType.getProtectedTiles();
  if (lastArea != null) {
    removeConstructionMarks(lastArea,currMapArea);
  }
  for (  ISPosition2D pos : currMapArea) {
    short x=pos.getX();
    short y=pos.getY();
    byte value;
    if (map.canConstructAt(x,y,currBuildingType,player)) {
      value=calculateConstrMarkVal(x,y,usedPositions);
    }
 else {
      value=-1;
    }
    map.setConstructMarking(pos,value);
  }
  lastArea=currMapArea;
}","private void calculateConstructMarks(){
  MapRectangle area=this.mapArea;
  EBuildingType currBuildingType=this.buildingType;
  if (currBuildingType == null || area == null) {
    return;
  }
  RelativePoint[] usedPositions=currBuildingType.getProtectedTiles();
  if (lastArea != null) {
    removeConstructionMarks(lastArea,area);
  }
  for (  ISPosition2D pos : area) {
    short x=pos.getX();
    short y=pos.getY();
    byte value;
    if (map.canConstructAt(x,y,currBuildingType,player)) {
      value=calculateConstrMarkVal(x,y,usedPositions);
    }
 else {
      value=-1;
    }
    map.setConstructMarking(pos,value);
  }
  lastArea=area;
}"
56629,"public void setScreen(IMapArea mapArea){
  this.mapArea=new MapShapeFilter(mapArea,map.getWidth(),map.getHeight());
  refreshMarkings();
}","public void setScreen(MapRectangle mapArea){
  this.mapArea=mapArea;
  refreshMarkings();
}"
56630,"/** 
 * Draws a circle to the buffer line. Each point is only brightened and onlydrawn if its x coordinate is in [0, mapWidth - 1] and its computed y coordinate is bigger than 0.
 */
final void drawCircleToBuffer(int bufferx,int buffery,int viewDistance,byte offset){
  MapCircle circle=new MapCircle(bufferx,buffery,Math.min(viewDistance + PADDING,MAX_VIEWDISTANCE));
  final int squaredViewDistance=viewDistance * viewDistance;
  CircleIterator iterator=circle.iterator();
  while (iterator.hasNext()) {
    final int currentY=iterator.nextY();
    final int currentX=iterator.nextX();
    int currentBufferY;
    if (currentX >= 0 && currentX < width && (currentBufferY=convertY(currentY)) >= 0) {
      if (buffer[currentX][currentBufferY] < CommonConstants.FOG_OF_WAR_VISIBLE + offset) {
        double squaredDistance=circle.squaredDistanceToCenter(currentX,currentY);
        byte newSight;
        if (squaredDistance < squaredViewDistance) {
          newSight=CommonConstants.FOG_OF_WAR_VISIBLE;
        }
 else {
          newSight=(byte)(CommonConstants.FOG_OF_WAR_VISIBLE - (Math.sqrt(squaredDistance) - viewDistance) / PADDING * CommonConstants.FOG_OF_WAR_VISIBLE);
        }
        increaseBufferAt(currentX,currentBufferY,(byte)(newSight + offset));
      }
    }
  }
}","/** 
 * Draws a circle to the buffer line. Each point is only brightened and onlydrawn if its x coordinate is in [0, mapWidth - 1] and its computed y coordinate is bigger than 0.
 */
final void drawCircleToBuffer(int bufferx,int buffery,int viewDistance){
  MapCircle circle=new MapCircle(bufferx,buffery,Math.min(viewDistance + PADDING,MAX_VIEWDISTANCE));
  final int squaredViewDistance=viewDistance * viewDistance;
  CircleIterator iterator=circle.iterator();
  while (iterator.hasNext()) {
    final int currentY=iterator.nextY();
    final int currentX=iterator.nextX();
    int currentBufferY;
    if (currentX >= 0 && currentX < width && (currentBufferY=convertY(currentY)) >= 0) {
      if (buffer[currentX][currentBufferY] < CommonConstants.FOG_OF_WAR_VISIBLE) {
        double squaredDistance=circle.squaredDistanceToCenter(currentX,currentY);
        byte newSight;
        if (squaredDistance < squaredViewDistance) {
          newSight=CommonConstants.FOG_OF_WAR_VISIBLE;
        }
 else {
          newSight=(byte)(CommonConstants.FOG_OF_WAR_VISIBLE - (Math.sqrt(squaredDistance) - viewDistance) / PADDING * CommonConstants.FOG_OF_WAR_VISIBLE);
        }
        increaseBufferAt(currentX,currentBufferY,newSight);
      }
    }
  }
}"
56631,"@Override public void run(){
  while (true) {
    StopWatch watch=new MilliStopWatch();
    watch.start();
    loadFirstBuffer();
    for (short sweepline=(short)(BUFFER_HEIGHT / 2); sweepline < height - BUFFER_HEIGHT / 2; sweepline++) {
      doNextLine(sweepline);
      if (sweepline % 32 == 0) {
        try {
          Thread.sleep(100);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
    loadLastBuffer();
    watch.stop(""String_Node_Str"");
    try {
      Thread.sleep(200);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
}","@Override public void run(){
  while (true) {
    StopWatch watch=new MilliStopWatch();
    watch.start();
    loadFirstBuffer();
    for (short sweepline=(short)(BUFFER_HEIGHT / 2); sweepline < height - BUFFER_HEIGHT / 2; sweepline++) {
      doNextLine(sweepline);
      if (sweepline % 32 == 0) {
      }
    }
    loadLastBuffer();
    watch.stop(""String_Node_Str"");
    try {
      Thread.sleep(700);
    }
 catch (    InterruptedException e) {
      e.printStackTrace();
    }
  }
}"
56632,"/** 
 * Adds everything that can see to the buffer.
 * @param buffery
 * @param mapy
 */
private final void applyBufferLine(short mapy){
  for (short x=0; x < width; x++) {
    int distance=getViewDistanceForPosition(x,mapy);
    if (distance > 0) {
      bufferdrawer.drawCircleToBuffer(x,mapy,distance,(byte)0);
    }
  }
}","/** 
 * Adds everything that can see to the buffer.
 * @param buffery
 * @param mapy
 */
private final void applyBufferLine(short mapy){
  for (short x=0; x < width; x++) {
    int distance=getViewDistanceForPosition(x,mapy);
    if (distance > 0) {
      bufferdrawer.drawCircleToBuffer(x,mapy,distance);
    }
  }
}"
56633,"public void startThread(IFogOfWarGrid grid){
  this.grid=grid;
  if (height > 3 * MAX_VIEWDISTANCE) {
    NewFoWThread thread=new NewFoWThread();
    thread.start();
  }
 else {
    SimpleCorrectionTread thread=new SimpleCorrectionTread();
    thread.start();
  }
  rebuildAll(sight);
}","@Override public void startThread(IFogOfWarGrid grid){
  this.grid=grid;
  if (height > 3 * MAX_VIEWDISTANCE) {
    FogCorrectionThread thread=new FogCorrectionThread();
    thread.start();
  }
 else {
    SimpleCorrectionTread thread=new SimpleCorrectionTread();
    thread.start();
  }
  rebuildAll(sight);
}"
56634,"final void rebuildAll(byte[][] buffer){
  CircleDrawer drawer=new CircleDrawer(buffer);
  for (short x=0; x < width; x++) {
    for (short y=0; y < height; y++) {
      buffer[x][y]=dimDown(buffer[x][y]);
    }
  }
  for (short x=0; x < width; x++) {
    for (short y=0; y < height; y++) {
      int distance=getViewDistanceForPosition(x,y);
      if (distance > 0) {
        drawer.drawCircleToBuffer(x,y,distance,(byte)0);
      }
    }
  }
}","final void rebuildAll(byte[][] buffer){
  CircleDrawer drawer=new CircleDrawer(buffer);
  for (short x=0; x < width; x++) {
    for (short y=0; y < height; y++) {
      buffer[x][y]=dimDown(buffer[x][y]);
    }
  }
  for (short x=0; x < width; x++) {
    for (short y=0; y < height; y++) {
      int distance=getViewDistanceForPosition(x,y);
      if (distance > 0) {
        drawer.drawCircleToBuffer(x,y,distance);
      }
    }
  }
}"
56635,"public final boolean isVisible(int centerx,int centery){
  return sight[centerx][centery] >= CommonConstants.FOG_OF_WAR_VISIBLE;
}","@Override public final boolean isVisible(int centerx,int centery){
  return sight[centerx][centery] >= CommonConstants.FOG_OF_WAR_VISIBLE;
}"
56636,"/** 
 * Gets the visible status of a map pint
 * @param x The x coordinate of the point in 0..(mapWidth - 1)
 * @param y The y coordinate of the point in 0..(mapHeight - 1)
 * @return The status from 0 to visible.
 */
public final byte getVisibleStatus(int x,int y){
  if (enabled) {
    return (byte)Math.min(sight[x][y],CommonConstants.FOG_OF_WAR_VISIBLE);
  }
 else {
    return CommonConstants.FOG_OF_WAR_VISIBLE;
  }
}","/** 
 * Gets the visible status of a map pint
 * @param x The x coordinate of the point in 0..(mapWidth - 1)
 * @param y The y coordinate of the point in 0..(mapHeight - 1)
 * @return The status from 0 to visible.
 */
@Override public final byte getVisibleStatus(int x,int y){
  if (enabled) {
    return (byte)Math.min(sight[x][y],CommonConstants.FOG_OF_WAR_VISIBLE);
  }
 else {
    return CommonConstants.FOG_OF_WAR_VISIBLE;
  }
}"
56637,"public final void toggleEnabled(){
  enabled=!enabled;
}","@Override public final void toggleEnabled(){
  enabled=!enabled;
}"
56638,"@Override public ISPosition2D next(){
  if (relativey < height && width > 0) {
    int x=getLineStartX(relativey) + relativex;
    int y=getLineY(relativey);
    ShortPoint2D pos=new ShortPoint2D(x,y);
    relativex++;
    if (relativex >= width) {
      relativex=0;
      relativey++;
    }
    return pos;
  }
 else {
    throw new NoSuchElementException(""String_Node_Str"");
  }
}","@Override public ISPosition2D next(){
  if (relativeY < height && width > 0) {
    int x=getLineStartX(relativeY) + relativeX;
    int y=getLineY(relativeY);
    ShortPoint2D pos=new ShortPoint2D(x,y);
    relativeX++;
    if (relativeX >= width) {
      relativeX=0;
      relativeY++;
    }
    return pos;
  }
 else {
    throw new NoSuchElementException(""String_Node_Str"");
  }
}"
56639,"public final boolean containsLine(int y){
  return y >= miny && y < miny + height;
}","public final boolean containsLine(int y){
  return y >= getMinY() && y < getMinY() + height;
}"
56640,"@Override public boolean hasNext(){
  return relativey < height && width > 0;
}","@Override public boolean hasNext(){
  return relativeY < height && width > 0;
}"
56641,"public MapRectangle(short minx,short miny,short width,short height){
  if (width < 0 || height < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.minx=minx;
  this.miny=miny;
  this.width=width;
  this.height=height;
}","public MapRectangle(short minx,short miny,short width,short height){
  if (width < 0 || height < 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.minX=minx;
  this.minY=miny;
  this.width=width;
  this.height=height;
}"
56642,"public final int getLineY(int line){
  return miny + line;
}","public final int getLineY(int line){
  return getMinY() + line;
}"
56643,"public final boolean contains(int x,int y){
  if (!containsLine(y)) {
    return false;
  }
  if (x < getLineStartX(y - miny) || x > getLineEndX(y - miny)) {
    return false;
  }
  return true;
}","public final boolean contains(int x,int y){
  if (!containsLine(y)) {
    return false;
  }
  if (x < getLineStartX(y - getMinY()) || x > getLineEndX(y - getMinY())) {
    return false;
  }
  return true;
}"
56644,"/** 
 * Gets the first x coordinate contained by a line.
 * @param line The line relative to the first line of this rectangle.
 */
public final int getLineStartX(int line){
  return minx + getOffsetForLine(line);
}","/** 
 * Gets the first x coordinate contained by a line.
 * @param line The line relative to the first line of this rectangle.
 */
public final int getLineStartX(int line){
  return getMinX() + getOffsetForLine(line);
}"
56645,"/** 
 * Generates the texture data.
 * @param data The texture data buffer.
 * @throws IOException
 */
private static void addTextures(short[] data) throws IOException {
  AdvancedDatFileReader reader=ImageProvider.getInstance().getFileReader(LAND_FILE);
  ImageWriter imageWriter=new ImageWriter();
  imageWriter.data=data;
  ImageMetadata meta=new ImageMetadata();
  for (int index=0; index < TEXTURE_POSITIONS.length; index++) {
    int[] position=TEXTURE_POSITIONS[index];
    int x=position[0] * TEXTURE_GRID;
    int y=position[1] * TEXTURE_GRID;
    int start=y * TEXTURE_SIZE + x;
    int cellsize=position[2] * TEXTURE_GRID;
    imageWriter.arrayoffset=start;
    imageWriter.cellsize=cellsize;
    int end=(y + cellsize) * TEXTURE_SIZE + x;
    DatBitmapReader.uncompressImage(reader.getReaderForLandscape(index),AdvancedDatFileReader.LANDSCAPE_TRANSLATOR,meta,imageWriter);
    int arrayoffset=imageWriter.arrayoffset;
    int l=arrayoffset - start;
    while (arrayoffset < end) {
      for (int i=0; i < cellsize; i++) {
        data[arrayoffset + i]=data[arrayoffset - l + i];
      }
      arrayoffset+=TEXTURE_SIZE;
    }
  }
}","/** 
 * Generates the texture data.
 * @param data The texture data buffer.
 * @throws IOException
 */
private static void addTextures(short[] data) throws IOException {
  AdvancedDatFileReader reader=ImageProvider.getInstance().getFileReader(LAND_FILE);
  ImageWriter imageWriter=new ImageWriter();
  imageWriter.data=data;
  ImageMetadata meta=new ImageMetadata();
  for (int index=0; index < TEXTURE_POSITIONS.length; index++) {
    int[] position=TEXTURE_POSITIONS[index];
    int x=position[0] * TEXTURE_GRID;
    int y=position[1] * TEXTURE_GRID;
    int start=y * TEXTURE_SIZE + x;
    int cellsize=position[2] * TEXTURE_GRID;
    int end=(y + cellsize) * TEXTURE_SIZE + x;
    imageWriter.arrayoffset=start;
    imageWriter.cellsize=cellsize;
    imageWriter.maxoffset=end;
    DatBitmapReader.uncompressImage(reader.getReaderForLandscape(index),AdvancedDatFileReader.LANDSCAPE_TRANSLATOR,meta,imageWriter);
    int arrayoffset=imageWriter.arrayoffset;
    int l=arrayoffset - start;
    while (arrayoffset < end) {
      for (int i=0; i < cellsize; i++) {
        data[arrayoffset + i]=data[arrayoffset - l + i];
      }
      arrayoffset+=TEXTURE_SIZE;
    }
  }
}"
56646,"@Override public void writeLine(short[] data,int length) throws IOException {
  for (int i=0; i < cellsize; i++) {
    this.data[arrayoffset + i]=data[i % length];
  }
  arrayoffset+=TEXTURE_SIZE;
}","@Override public void writeLine(short[] data,int length) throws IOException {
  if (arrayoffset < maxoffset) {
    for (int i=0; i < cellsize; i++) {
      this.data[arrayoffset + i]=data[i % length];
    }
    arrayoffset+=TEXTURE_SIZE;
  }
}"
56647,"private void updateFiles(DefaultHttpClient httpClient) throws IOException, ClientProtocolException {
  final String url=SERVER_ROOT + ""String_Node_Str"";
  HttpGet httpRequest=new HttpGet(url);
  HttpResponse response=httpClient.execute(httpRequest);
  ZipInputStream inputStream=new ZipInputStream(response.getEntity().getContent());
  setUpdating(true);
  int files=0;
  byte[] buffer=new byte[1024];
  ZipEntry entry;
  while ((entry=inputStream.getNextEntry()) != null) {
    String name=entry.getName();
    if (name.startsWith(RESOURCE_PREFIX)) {
      String outfilename=destdir.getAbsolutePath() + ""String_Node_Str"" + name.substring(RESOURCE_PREFIX.length());
      File outfile=new File(outfilename);
      if (entry.isDirectory()) {
        if (outfile.exists() && !outfile.isDirectory()) {
          outfile.delete();
        }
        if (!outfile.isDirectory()) {
          outfile.mkdirs();
        }
      }
 else {
        File tmpfile=new File(outfilename + ""String_Node_Str"");
        tmpfile.deleteOnExit();
        FileOutputStream out=new FileOutputStream(tmpfile);
        while (true) {
          int len=inputStream.read(buffer);
          if (len <= 0) {
            break;
          }
          out.write(buffer,0,len);
        }
        out.close();
        tmpfile.renameTo(outfile);
        files++;
      }
    }
  }
  System.out.println(""String_Node_Str"" + files + ""String_Node_Str"");
  setUpdating(false);
}","private void updateFiles(DefaultHttpClient httpClient) throws IOException, ClientProtocolException {
  final String url=SERVER_ROOT + ""String_Node_Str"";
  HttpGet httpRequest=new HttpGet(url);
  HttpResponse response=httpClient.execute(httpRequest);
  ZipInputStream inputStream=new ZipInputStream(response.getEntity().getContent());
  setUpdating(true);
  int files=0;
  byte[] buffer=new byte[1024];
  ZipEntry entry;
  while ((entry=inputStream.getNextEntry()) != null) {
    String name=entry.getName();
    if (name.startsWith(RESOURCE_PREFIX)) {
      String outfilename=destdir.getAbsolutePath() + ""String_Node_Str"" + name.substring(RESOURCE_PREFIX.length());
      File outfile=new File(outfilename);
      if (entry.isDirectory()) {
        if (outfile.exists() && !outfile.isDirectory()) {
          outfile.delete();
        }
        if (!outfile.isDirectory()) {
          outfile.mkdirs();
        }
      }
 else {
        File tmpFile=new File(outfilename + ""String_Node_Str"");
        tmpFile.getParentFile().mkdirs();
        tmpFile.deleteOnExit();
        FileOutputStream out=new FileOutputStream(tmpFile);
        while (true) {
          int len=inputStream.read(buffer);
          if (len <= 0) {
            break;
          }
          out.write(buffer,0,len);
        }
        out.close();
        tmpFile.renameTo(outfile);
        files++;
      }
    }
  }
  System.out.println(""String_Node_Str"" + files + ""String_Node_Str"");
  setUpdating(false);
}"
56648,"@Override protected void subTimerEvent(){
  delayCtr++;
  if (delayCtr > 5) {
    delayCtr=0;
    if (!searchedSoldiers.isEmpty()) {
      if (request == null) {
        request=new DijkstraContinuableRequest(this,super.getPos().getX(),super.getPos().getY(),(short)1,Constants.TOWER_SOLDIER_SEARCH_AREA);
        request.setSearchType(searchedSoldiers.peek());
      }
      Path path=super.getGrid().getDijkstra().find(request);
      if (path != null) {
        System.out.println(""String_Node_Str"");
        IHexMovable soldier=super.getGrid().getMovable(path.getTargetPos());
        if (soldier != null && soldier.setOccupyableBuilding(this)) {
          searchedSoldiers.pop();
        }
      }
    }
  }
}","@Override protected void subTimerEvent(){
  delayCtr++;
  if (delayCtr > 5) {
    delayCtr=0;
    if (!searchedSoldiers.isEmpty()) {
      if (request == null) {
        request=new DijkstraContinuableRequest(this,super.getPos().getX(),super.getPos().getY(),(short)1,Constants.TOWER_SOLDIER_SEARCH_AREA);
      }
      request.setSearchType(searchedSoldiers.peek());
      Path path=super.getGrid().getDijkstra().find(request);
      if (path != null) {
        System.out.println(""String_Node_Str"");
        IHexMovable soldier=super.getGrid().getMovable(path.getTargetPos());
        if (soldier != null && soldier.setOccupyableBuilding(this)) {
          searchedSoldiers.pop();
        }
      }
    }
  }
}"
56649,"private boolean isSoldierAt(short x,short y,ESearchType searchType){
  IMovable movable=movableGrid.getMovableAt(x,y);
  if (movable == null) {
    return false;
  }
 else {
    EMovableType type=movable.getMovableType();
switch (searchType) {
case SOLDIER_BOWMAN:
      return type == EMovableType.BOWMAN_L1 || type == EMovableType.BOWMAN_L2 || type == EMovableType.BOWMAN_L3;
case SOLDIER_SWORDSMAN:
    return type == EMovableType.SWORDSMAN_L1 || type == EMovableType.SWORDSMAN_L2 || type == EMovableType.SWORDSMAN_L3;
case SOLDIER_PIKEMAN:
  return type == EMovableType.PIKEMAN_L1 || type == EMovableType.PIKEMAN_L2 || type == EMovableType.PIKEMAN_L3;
default :
return false;
}
}
}","private boolean isSoldierAt(short x,short y,ESearchType searchType,byte player){
  IHexMovable movable=movableGrid.getMovableAt(x,y);
  if (movable == null) {
    return false;
  }
 else {
    if (movable.getPlayer() == player && movable.canOccupyBuilding()) {
      EMovableType type=movable.getMovableType();
switch (searchType) {
case SOLDIER_BOWMAN:
        return type == EMovableType.BOWMAN_L1 || type == EMovableType.BOWMAN_L2 || type == EMovableType.BOWMAN_L3;
case SOLDIER_SWORDSMAN:
      return type == EMovableType.SWORDSMAN_L1 || type == EMovableType.SWORDSMAN_L2 || type == EMovableType.SWORDSMAN_L3;
case SOLDIER_PIKEMAN:
    return type == EMovableType.PIKEMAN_L1 || type == EMovableType.PIKEMAN_L2 || type == EMovableType.PIKEMAN_L3;
default :
  return false;
}
}
 else {
return false;
}
}
}"
56650,"public final void appearAt(IBuildingsGrid grid,ISPosition2D pos){
  this.state=EBuildingState.CONSTRUCTED;
  positionAt(grid,pos);
  if (this.pos != null) {
    grid.setBlocked(buildingArea,true);
    finishConstruction();
  }
}","public final void appearAt(IBuildingsGrid grid,ISPosition2D pos){
  this.state=EBuildingState.CONSTRUCTED;
  positionAt(grid,pos);
  if (this.pos != null) {
    grid.setBlocked(buildingArea,true);
    finishConstruction();
  }
  appearedEvent();
}"
56651,"@Override protected void killedEvent(){
  if (!occupiers.isEmpty()) {
    MapShapeFilter occupied=getOccupyablePositions();
    super.getGrid().freeOccupiedArea(occupied,super.getPos());
  }
}","@Override protected void killedEvent(){
  if (occupiedArea) {
    MapShapeFilter occupied=getOccupyablePositions();
    super.getGrid().freeOccupiedArea(occupied,super.getPos());
  }
}"
56652,"@Override public void setSoldier(IBuildingOccupyableMovable soldier){
  for (  OccupyerPlace curr : emptyPlaces) {
    if (curr.getType() == soldier.getSoldierType()) {
      emptyPlaces.remove(curr);
      occupiers.add(new TowerOccupyer(curr,soldier));
      break;
    }
  }
  MapShapeFilter occupying=getOccupyablePositions();
  super.getGrid().occupyArea(occupying,super.getPos(),super.getPlayer());
}","@Override public void setSoldier(IBuildingOccupyableMovable soldier){
  for (  OccupyerPlace curr : emptyPlaces) {
    if (curr.getType() == soldier.getSoldierType()) {
      emptyPlaces.remove(curr);
      occupiers.add(new TowerOccupyer(curr,soldier));
      break;
    }
  }
  occupyArea();
}"
56653,"private boolean lookAtSearched(){
  if (currentJob.getSearchType() == ESearchType.FISHABLE) {
    for (    EDirection direction : EDirection.values()) {
      ISPosition2D pos=direction.getNextHexPoint(super.getPos());
      if (super.getGrid().isInBounds(pos) && super.getGrid().getLandscapeTypeAt(pos) == ELandscapeType.WATER) {
        super.setDirection(direction);
        return true;
      }
    }
    return false;
  }
 else   if (currentJob.getSearchType() == ESearchType.CUTTABLE_STONE) {
    super.setDirection(EDirection.NORTH_EAST);
    return true;
  }
 else   if (currentJob.getSearchType() == ESearchType.RIVER) {
    for (    EDirection direction : EDirection.values()) {
      ISPosition2D pos=direction.getNextHexPoint(super.getPos());
      if (super.getGrid().isInBounds(pos) && (super.getGrid().getLandscapeTypeAt(pos) == ELandscapeType.RIVER1 || super.getGrid().getLandscapeTypeAt(pos) == ELandscapeType.RIVER2 || super.getGrid().getLandscapeTypeAt(pos) == ELandscapeType.RIVER3 || super.getGrid().getLandscapeTypeAt(pos) == ELandscapeType.RIVER4)) {
        super.setDirection(direction);
        return true;
      }
    }
    return true;
  }
 else {
    return false;
  }
}","private boolean lookAtSearched(){
  if (currentJob.getSearchType() == ESearchType.FISHABLE) {
    for (    EDirection direction : EDirection.values()) {
      ISPosition2D pos=direction.getNextHexPoint(super.getPos());
      if (super.getGrid().isInBounds(pos) && super.getGrid().getLandscapeTypeAt(pos) == ELandscapeType.WATER) {
        super.setDirection(direction);
        return true;
      }
    }
    return false;
  }
 else   if (currentJob.getSearchType() == ESearchType.CUTTABLE_STONE) {
    super.setDirection(EDirection.NORTH_WEST);
    return true;
  }
 else   if (currentJob.getSearchType() == ESearchType.RIVER) {
    for (    EDirection direction : EDirection.values()) {
      ISPosition2D pos=direction.getNextHexPoint(super.getPos());
      if (super.getGrid().isInBounds(pos) && (super.getGrid().getLandscapeTypeAt(pos) == ELandscapeType.RIVER1 || super.getGrid().getLandscapeTypeAt(pos) == ELandscapeType.RIVER2 || super.getGrid().getLandscapeTypeAt(pos) == ELandscapeType.RIVER3 || super.getGrid().getLandscapeTypeAt(pos) == ELandscapeType.RIVER4)) {
        super.setDirection(direction);
        return true;
      }
    }
    return true;
  }
 else {
    return false;
  }
}"
56654,"private PanToAction getForMinimap(float relativex,float relativey){
  float minimapx=(relativex - constants.MINIMAP_BOTTOMLEFT_X) / constants.MINIMAP_WIDTH;
  float minimapy=((relativey - constants.UI_CENTERY) / (1 - constants.UI_CENTERY) - constants.MINIMAP_BOTTOM_Y) / constants.MINIMAP_HEIGHT;
  ISPosition2D clickPosition=minimap.getClickPosition(minimapx,minimapy);
  if (minimap.getContext().checkMapCoordinates(clickPosition.getX(),clickPosition.getY())) {
    return new PanToAction(clickPosition);
  }
 else {
    return null;
  }
}","private PanToAction getForMinimap(float relativex,float relativey){
  float minimapx=(relativex - constants.MINIMAP_BOTTOMLEFT_X) / constants.MINIMAP_WIDTH;
  float minimapy=((relativey - constants.UI_CENTERY) / (1 - constants.UI_CENTERY) - constants.MINIMAP_BOTTOM_Y) / constants.MINIMAP_HEIGHT;
  ISPosition2D clickPosition=minimap.getClickPositionIfOnMap(minimapx,minimapy);
  if (clickPosition != null) {
    return new PanToAction(clickPosition);
  }
 else {
    return null;
  }
}"
56655,"@Override public Action getActionFor(UIPoint position){
  float relativex=(float)position.getX() / this.uiBase.getPosition().getWidth();
  float relativey=(float)position.getY() / this.uiBase.getPosition().getHeight();
  Action action;
  if (relativey > constants.UI_CENTERY) {
    action=getForMinimap(relativex,relativey);
  }
 else {
    action=uiBase.getAction(relativex,relativey);
  }
  if (action != null && action.getActionType() == EActionType.CHANGE_PANEL) {
    mainPanel.setContent(((ChangePanelAction)action).getContent());
    return null;
  }
 else {
    return action;
  }
}","@Override public Action getActionFor(UIPoint position){
  float relativex=(float)position.getX() / this.uiBase.getPosition().getWidth();
  float relativey=(float)position.getY() / this.uiBase.getPosition().getHeight();
  Action action;
  if (relativey > constants.UI_CENTERY) {
    action=getForMinimap(relativex,relativey);
    startMapPosition=null;
  }
 else {
    action=uiBase.getAction(relativex,relativey);
  }
  if (action != null && action.getActionType() == EActionType.CHANGE_PANEL) {
    mainPanel.setContent(((ChangePanelAction)action).getContent());
    return null;
  }
 else {
    return action;
  }
}"
56656,"private Action getForMinimap(float relativex,float relativey){
  float minimapx=(relativex - constants.MINIMAP_BOTTOMLEFT_X) / constants.MINIMAP_WIDTH;
  float minimapy=((relativey - constants.UI_CENTERY) / (1 - constants.UI_CENTERY) - constants.MINIMAP_BOTTOM_Y) / constants.MINIMAP_HEIGHT;
  ISPosition2D clickPosition=minimap.getClickPosition(minimapx,minimapy);
  return new PanToAction(clickPosition);
}","private PanToAction getForMinimap(float relativex,float relativey){
  float minimapx=(relativex - constants.MINIMAP_BOTTOMLEFT_X) / constants.MINIMAP_WIDTH;
  float minimapy=((relativey - constants.UI_CENTERY) / (1 - constants.UI_CENTERY) - constants.MINIMAP_BOTTOM_Y) / constants.MINIMAP_HEIGHT;
  ISPosition2D clickPosition=minimap.getClickPosition(minimapx,minimapy);
  if (minimap.getContext().checkMapCoordinates(clickPosition.getX(),clickPosition.getY())) {
    return new PanToAction(clickPosition);
  }
 else {
    return null;
  }
}"
56657,"@Override public boolean handleDrawEvent(GODrawEvent event){
  return false;
}","@Override public boolean handleDrawEvent(GODrawEvent event){
  if (!containsPoint(event.getDrawPosition())) {
    return false;
  }
  Action action=getActionForDraw(event);
  if (action != null) {
    MapDrawContext context=minimap.getContext();
    float y=context.getScreen().getHeight() / 2;
    float x=context.getScreen().getWidth() / 2;
    startMapPosition=context.getPositionOnScreen(x,y);
    event.setHandler(new DrawMinimapHandler());
    return true;
  }
 else {
    return false;
  }
}"
56658,"@Override public void run(){
  while (true) {
    try {
synchronized (this) {
        while (buildingType == null) {
          this.wait();
        }
      }
      while (buildingType != null) {
        if (!NetworkTimer.isPausing()) {
          StopWatch watch=new MilliStopWatch();
          watch.start();
          calculateConstructMarks();
          watch.stop(""String_Node_Str"");
        }
synchronized (this) {
          wait(AlgorithmConstants.CONSTRUCT_MARKS_MAX_REFRESH_TIME);
        }
      }
      removeConstructionMarks(mapArea);
      lastArea=null;
      Thread.sleep(30);
    }
 catch (    Throwable e) {
      e.printStackTrace();
    }
  }
}","@Override public void run(){
  while (true) {
    try {
synchronized (this) {
        while (buildingType == null) {
          this.wait();
        }
      }
      while (buildingType != null) {
        if (!NetworkTimer.isPausing()) {
          StopWatch watch=new MilliStopWatch();
          watch.start();
          calculateConstructMarks();
          watch.stop(""String_Node_Str"");
        }
synchronized (this) {
          wait(AlgorithmConstants.CONSTRUCT_MARKS_MAX_REFRESH_TIME);
        }
      }
      removeConstructionMarks(lastArea);
      lastArea=null;
    }
 catch (    Throwable e) {
      e.printStackTrace();
    }
  }
}"
56659,"private void calculateConstructMarks(){
  IMapArea localMapArea=this.mapArea;
  if (buildingType == null || localMapArea == null) {
    return;
  }
  RelativePoint[] usedPositions=buildingType.getProtectedTiles();
  if (lastArea != null) {
    removeConstructionMarks(lastArea,localMapArea);
  }
  for (  ISPosition2D pos : localMapArea) {
    short x=pos.getX();
    short y=pos.getY();
    byte value;
    if (map.canConstructAt(x,y,buildingType,player)) {
      value=calculateConstrMarkVal(x,y,usedPositions);
    }
 else {
      value=-1;
    }
    map.setConstructMarking(pos,value);
  }
  lastArea=localMapArea;
}","private void calculateConstructMarks(){
  IMapArea currMapArea=this.mapArea;
  EBuildingType currBuildingType=this.buildingType;
  if (currBuildingType == null || currMapArea == null) {
    return;
  }
  RelativePoint[] usedPositions=currBuildingType.getProtectedTiles();
  if (lastArea != null) {
    removeConstructionMarks(lastArea,currMapArea);
  }
  for (  ISPosition2D pos : currMapArea) {
    short x=pos.getX();
    short y=pos.getY();
    byte value;
    if (map.canConstructAt(x,y,currBuildingType,player)) {
      value=calculateConstrMarkVal(x,y,usedPositions);
    }
 else {
      value=-1;
    }
    map.setConstructMarking(pos,value);
  }
  lastArea=currMapArea;
}"
56660,"@Override public Color getDebugColorAt(int x,int y){
  return debugColors[x][y];
}","@Override public Color getDebugColorAt(int x,int y){
  short value=(short)(partitionsGrid.getPartitionAt((short)x,(short)y) + 1);
  return new Color((value % 3) * 0.33f,((value / 3) % 3) * 0.33f,((value / 9) % 3) * 0.33f,1);
}"
56661,"public boolean isBlockedForPeople(short x,short y){
  return grid.isBlocked(x,y);
}","@Override public boolean isBlockedForPeople(short x,short y){
  return grid.isBlocked(x,y);
}"
56662,"private void relabelPartition(short inX,short inY,short oldPartition,short newPartition){
  final short MAX_LENGTH=1000;
  final short[] pointsBuffer=new short[MAX_LENGTH];
  pointsBuffer[0]=inX;
  pointsBuffer[1]=inY;
  short length=2;
  while (length > 0) {
    short y=pointsBuffer[--length];
    short x=pointsBuffer[--length];
    if (partitions[x][y] != oldPartition) {
      continue;
    }
    setPartition(x,y,newPartition);
    for (byte i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
      short currX=(short)(x + neighborX[i]);
      short currY=(short)(y + neighborY[i]);
      if (isInBounds(currX,currY) && partitions[currX][currY] == oldPartition && !grid.isBlocked(currX,currY)) {
        if (length < MAX_LENGTH) {
          pointsBuffer[length++]=currX;
          pointsBuffer[length++]=currY;
        }
 else {
          relabelPartition(currX,currY,oldPartition,newPartition);
        }
      }
    }
  }
}","private void relabelPartition(short inX,short inY,short oldPartition,short newPartition){
  final short MAX_LENGTH=1000;
  final short[] pointsBuffer=new short[MAX_LENGTH];
  pointsBuffer[0]=inX;
  pointsBuffer[1]=inY;
  short length=2;
  while (length > 0) {
    short y=pointsBuffer[--length];
    short x=pointsBuffer[--length];
    if (partitions[x][y] != oldPartition) {
      continue;
    }
    setPartition(x,y,newPartition);
    boolean currIsBlocked=grid.isBlocked(x,y);
    for (byte i=0; i < EDirection.NUMBER_OF_DIRECTIONS; i++) {
      short currX=(short)(x + neighborX[i]);
      short currY=(short)(y + neighborY[i]);
      if (isInBounds(currX,currY) && partitions[currX][currY] == oldPartition && (!currIsBlocked || grid.isBlocked(currX,currY))) {
        if (length < MAX_LENGTH) {
          pointsBuffer[length++]=currX;
          pointsBuffer[length++]=currY;
        }
 else {
          relabelPartition(currX,currY,oldPartition,newPartition);
        }
      }
    }
  }
}"
56663,"public boolean isInBounds(short x,short y){
  return 0 <= x && x < width && 0 <= y && y < height;
}","@Override public boolean isInBounds(short x,short y){
  return 0 <= x && x < width && 0 <= y && y < height;
}"
56664,"@Override public void timerEvent(){
switch (state) {
case NO_ACTION:
    nothingTodoAction();
  if (state == EMovableState.NO_ACTION)   strategy.noActionEvent();
break;
case PUSHED_AND_WAITING:
case WAITING_FOR_FREE_TILE:
IHexMovable movableOnNextTile=grid.getMovable(nextTile);
if (movableOnNextTile == null) {
initGoingToNextTile();
}
 else {
movableOnNextTile.push(this);
break;
}
case EXECUTING_ACTION:
progress+=progressIncrease;
if (progress >= 1) {
state=EMovableState.FINISHED_ACTION;
strategy.actionFinished();
if (state == EMovableState.FINISHED_ACTION) {
System.out.println(""String_Node_Str"");
strategy.actionFinished();
}
}
break;
case FINISHED_ACTION:
System.out.println(""String_Node_Str"");
break;
}
}","@Override public void timerEvent(){
switch (state) {
case NO_ACTION:
    nothingTodoAction();
  if (state == EMovableState.NO_ACTION)   strategy.noActionEvent();
break;
case PUSHED_AND_WAITING:
case WAITING_FOR_FREE_TILE:
IHexMovable movableOnNextTile=grid.getMovable(nextPos);
if (movableOnNextTile == null) {
initGoingToNextTile();
}
 else {
movableOnNextTile.push(this);
break;
}
case EXECUTING_ACTION:
progress+=progressIncrease;
if (progress >= 1) {
state=EMovableState.FINISHED_ACTION;
strategy.actionFinished();
if (state == EMovableState.FINISHED_ACTION) {
System.out.println(""String_Node_Str"");
strategy.actionFinished();
}
}
break;
case FINISHED_ACTION:
System.out.println(""String_Node_Str"");
break;
}
}"
56665,"@Override public void kill(){
  MovableTimer.remove(this);
  this.health=0;
  grid.movableLeft(pos,this);
  movablesByID.remove(this.getID());
  grid.getMapObjectsManager().addSelfDeletingMapObject(pos,EMapObjectType.GHOST,1,player);
}","@Override public void kill(){
  MovableTimer.remove(this);
  strategy.killedEvent();
  grid.setMarked(pos,false);
  if (nextPos != null)   grid.setMarked(nextPos,false);
  this.health=0;
  grid.movableLeft(pos,this);
  movablesByID.remove(this.getID());
  grid.getMapObjectsManager().addSelfDeletingMapObject(pos,EMapObjectType.GHOST,1,player);
}"
56666,"@Override public void push(IHexMovable from){
  if (from == null) {
    if (state == EMovableState.NO_ACTION) {
      goToRandomDirection(null);
    }
    return;
  }
switch (state) {
case NO_ACTION:
    goToRandomDirection(from);
  break;
case WAITING_FOR_FREE_TILE:
if (from.getPos().equals(this.nextTile)) {
  if (from.getNextTile() != null) {
    initGoingToNextTile();
    from.initGoingToNextTile();
  }
}
 else {
  IHexMovable movableOnNextTile=grid.getMovable(nextTile);
  if (movableOnNextTile != null) {
    state=EMovableState.PUSHED_AND_WAITING;
    pushedFrom=from;
    movableOnNextTile.push(this);
    pushedFrom=null;
    if (state == EMovableState.PUSHED_AND_WAITING)     state=EMovableState.WAITING_FOR_FREE_TILE;
  }
}
break;
case PUSHED_AND_WAITING:
if (pushedFrom.getPos().equals(from.getPos())) {
while (from != this) {
from.initGoingToNextTile();
from=from.getPushedFrom();
}
this.initGoingToNextTile();
}
 else {
pushedFrom=from;
}
break;
case EXECUTING_ACTION:
case FINISHED_ACTION:
break;
}
}","@Override public void push(IHexMovable from){
  if (from == null) {
    if (state == EMovableState.NO_ACTION) {
      goToRandomDirection(null);
    }
    return;
  }
switch (state) {
case NO_ACTION:
    goToRandomDirection(from);
  break;
case WAITING_FOR_FREE_TILE:
if (from.getPos().equals(this.nextPos)) {
  if (from.getNextTile() != null) {
    initGoingToNextTile();
    from.initGoingToNextTile();
  }
}
 else {
  IHexMovable movableOnNextTile=grid.getMovable(nextPos);
  if (movableOnNextTile != null) {
    state=EMovableState.PUSHED_AND_WAITING;
    pushedFrom=from;
    movableOnNextTile.push(this);
    pushedFrom=null;
    if (state == EMovableState.PUSHED_AND_WAITING)     state=EMovableState.WAITING_FOR_FREE_TILE;
  }
}
break;
case PUSHED_AND_WAITING:
if (pushedFrom.getPos().equals(from.getPos())) {
while (from != this) {
from.initGoingToNextTile();
from=from.getPushedFrom();
}
this.initGoingToNextTile();
}
 else {
pushedFrom=from;
}
break;
case EXECUTING_ACTION:
case FINISHED_ACTION:
break;
}
}"
56667,"@Override public void initGoingToNextTile(){
  grid.movableLeft(pos,this);
  grid.movableEntered(this.nextTile,this);
  this.pos=this.nextTile;
  this.nextTile=null;
  this.progress=0;
  this.action=EAction.WALKING;
  this.state=EMovableState.EXECUTING_ACTION;
  this.progressIncrease=getProgressIncrease(Constants.MOVABLE_STEP_DURATION);
  isRightstep=!isRightstep;
}","@Override public void initGoingToNextTile(){
  grid.movableLeft(pos,this);
  grid.movableEntered(this.nextPos,this);
  this.pos=this.nextPos;
  this.nextPos=null;
  this.progress=0;
  this.action=EAction.WALKING;
  this.state=EMovableState.EXECUTING_ACTION;
  this.progressIncrease=getProgressIncrease(Constants.MOVABLE_STEP_DURATION);
  isRightstep=!isRightstep;
}"
56668,"@Override public ISPosition2D getNextTile(){
  return nextTile;
}","@Override public ISPosition2D getNextTile(){
  return nextPos;
}"
56669,"@Override public void leaveBlockedPosition(){
  calculateDijkstraPath(super.getPos(),(short)200,ESearchType.NON_BLOCKED_OR_PROTECTED);
}","@Override protected void leaveBlockedPosition(){
  calculateDijkstraPath(super.getPos(),(short)200,ESearchType.NON_BLOCKED_OR_PROTECTED);
}"
56670,"private void checkForEnemies(){
  if (enemyPos != null || delayCtr > Constants.MOVABLE_INTERRUPTS_PER_SECOND * 2) {
    delayCtr=0;
    Path path=super.getGrid().getDijkstra().find(this,super.getPos().getX(),super.getPos().getY(),(short)1,getSearchRadius(),ESearchType.ENEMY);
    if (path != null)     enemyPos=path.getLastTile();
 else     enemyPos=null;
  }
 else {
    delayCtr++;
    enemyPos=null;
  }
}","private void checkForEnemies(){
  if (enemyPos != null || delayCtr > Constants.MOVABLE_INTERRUPTS_PER_SECOND * 2) {
    delayCtr=0;
    Path path=super.getGrid().getDijkstra().find(this,super.getPos().getX(),super.getPos().getY(),(short)1,getSearchRadius(),ESearchType.ENEMY);
    if (path != null)     enemyPos=path.getTargetPos();
 else     enemyPos=null;
  }
 else {
    delayCtr++;
    enemyPos=null;
  }
}"
56671,"@Override protected void setCalculatedPath(Path path){
  super.getGrid().setMarked(super.getPos(),false);
  super.setCalculatedPath(path);
}","@Override protected void setCalculatedPath(Path path){
  super.getGrid().setMarked(path.getTargetPos(),false);
  super.setCalculatedPath(path);
}"
56672,"@Override protected void setCalculatedPath(Path path){
  if (currentJob != null && (currentJob.getType() == EBuildingJobType.PRE_SEARCH || currentJob.getType() == EBuildingJobType.PRE_SEARCH_IN_AREA)) {
    this.path=path;
    super.getGrid().setMarked(path.getLastTile(),true);
    jobFinished();
  }
 else {
    super.setCalculatedPath(path);
  }
}","@Override protected void setCalculatedPath(Path path){
  if (currentJob != null && (currentJob.getType() == EBuildingJobType.PRE_SEARCH || currentJob.getType() == EBuildingJobType.PRE_SEARCH_IN_AREA)) {
    this.path=path;
    super.getGrid().setMarked(path.getTargetPos(),true);
    jobFinished();
  }
 else {
    super.setCalculatedPath(path);
  }
}"
56673,"private void rebuildAll(byte[][] buffer){
  CircleDrawer drawer=new CircleDrawer(buffer){
    @Override protected int convertY(    int mapy){
      if (mapy < map.getHeight()) {
        return mapy;
      }
 else {
        return -1;
      }
    }
  }
;
  for (int x=0; x < map.getWidth(); x++) {
    for (int y=0; y < map.getWidth(); y++) {
      buffer[x][y]=dimDown(buffer[x][y]);
    }
  }
  for (int x=0; x < map.getWidth(); x++) {
    for (int y=0; y < map.getWidth(); y++) {
      int distance=getViewDistanceForPosition(x,y);
      if (distance > 0) {
        drawer.drawCircleToBuffer(x,y,distance);
      }
    }
  }
}","private void rebuildAll(byte[][] buffer){
  CircleDrawer drawer=new CircleDrawer(buffer){
    @Override protected int convertY(    int mapy){
      if (mapy < map.getHeight()) {
        return mapy;
      }
 else {
        return -1;
      }
    }
  }
;
  for (int x=0; x < map.getWidth(); x++) {
    for (int y=0; y < map.getHeight(); y++) {
      buffer[x][y]=dimDown(buffer[x][y]);
    }
  }
  for (int x=0; x < map.getWidth(); x++) {
    for (int y=0; y < map.getHeight(); y++) {
      int distance=getViewDistanceForPosition(x,y);
      if (distance > 0) {
        drawer.drawCircleToBuffer(x,y,distance);
      }
    }
  }
}"
56674,"/** 
 * This method checks if one of the neighbors of the given position is from the same player to find a matching partition.<br> If multiple neighbors are from the same player but have different partitions, a merge of the partitions is done.
 * @param changedPosition position that needs to get a new partition
 * @param newPlayer player that is now occupying the position
 */
private void addToNewPartiton(final short x,final short y,final byte newPlayer){
  short newPartition=-1;
  for (  ISPosition2D currPos : new MapNeighboursArea(x,y)) {
    if (map.getPlayerAt(currPos) == newPlayer && !this.map.isBlockedForPeople(currPos.getX(),currPos.getY())) {
      if (newPartition == -1) {
        newPartition=map.getPartition(currPos);
        map.setPartition(x,y,newPartition);
        if (this.map.isBlockedForPeople(x,y)) {
          break;
        }
      }
 else {
        if (map.getPartition(currPos) != newPartition) {
          newPartition=map.mergePartitions(currPos.getX(),currPos.getY(),x,y);
        }
      }
    }
  }
  if (newPartition == -1) {
    map.createPartition(x,y,newPlayer);
  }
}","/** 
 * This method checks if one of the neighbors of the given position is from the same player to find a matching partition.<br> If multiple neighbors are from the same player but have different partitions, a merge of the partitions is done.
 * @param changedPosition position that needs to get a new partition
 * @param newPlayer player that is now occupying the position
 */
private void addToNewPartiton(final short x,final short y,final byte newPlayer){
  short newPartition=-1;
  for (  ISPosition2D currPos : new MapNeighboursArea(x,y)) {
    if (map.getPlayerAt(currPos) == newPlayer) {
      if (newPartition == -1) {
        newPartition=map.getPartition(currPos);
        map.setPartition(x,y,newPartition);
        if (this.map.isBlockedForPeople(x,y)) {
          break;
        }
      }
 else       if (!this.map.isBlockedForPeople(currPos.getX(),currPos.getY())) {
        if (map.getPartition(currPos) != newPartition) {
          newPartition=map.mergePartitions(currPos.getX(),currPos.getY(),x,y);
        }
      }
    }
  }
  if (newPartition == -1) {
    map.createPartition(x,y,newPlayer);
  }
}"
56675,"@Override public float getCost(short sx,short sy,short tx,short ty){
  return Constants.TILE_PATHFINDER_COST;
}","@Override public float getCost(short sx,short sy,short tx,short ty){
  return Constants.TILE_PATHFINDER_COST * (blockedGrid.isProtected(sx,sy) ? 1.7f : 1);
}"
56676,"@Override public Color getDebugColorAt(int x,int y){
  return blockedGrid.isBlocked((short)x,(short)y) ? new Color(0,0,0,1) : (blockedGrid.isProtected((short)x,(short)y) ? new Color(0,0,1,1) : null);
}","@Override public Color getDebugColorAt(int x,int y){
  return debugColors[x][y];
}"
56677,"@Override public void leaveBlockedPosition(){
  calculateDijkstraPath(super.getPos(),(short)200,ESearchType.NON_BLOCKED);
}","@Override public void leaveBlockedPosition(){
  calculateDijkstraPath(super.getPos(),(short)200,ESearchType.NON_BLOCKED_OR_PROTECTED);
}"
56678,"/** 
 * This method checks if one of the neighbors of the given position is from the same player to find a matching partition.<br> If multiple neighbors are from the same player but have different partitions, a merge of the partitions is done.
 * @param changedPosition position that needs to get a new partition
 * @param newPlayer player that is now occupying the position
 */
private void addToNewPartiton(final short x,final short y,final byte newPlayer){
  short newPartition=-1;
  for (  ISPosition2D currPos : new MapNeighboursArea(x,y)) {
    if (map.getPlayerAt(currPos) == newPlayer) {
      if (newPartition == -1) {
        newPartition=map.getPartition(currPos);
        map.setPartition(x,y,newPartition);
        if (this.map.isBlockedForPeople(x,y)) {
          break;
        }
      }
 else       if (!this.map.isBlockedForPeople(currPos.getX(),currPos.getY())) {
        if (map.getPartition(currPos) != newPartition) {
          newPartition=map.mergePartitions(currPos.getX(),currPos.getY(),x,y);
        }
      }
    }
  }
  if (newPartition == -1) {
    map.createPartition(x,y,newPlayer);
  }
}","/** 
 * This method checks if one of the neighbors of the given position is from the same player to find a matching partition.<br> If multiple neighbors are from the same player but have different partitions, a merge of the partitions is done.
 * @param changedPosition position that needs to get a new partition
 * @param newPlayer player that is now occupying the position
 */
private void addToNewPartiton(final short x,final short y,final byte newPlayer){
  short newPartition=-1;
  for (  ISPosition2D currPos : new MapNeighboursArea(x,y)) {
    if (grid.getPlayerAt(currPos) == newPlayer) {
      if (newPartition == -1) {
        newPartition=grid.getPartition(currPos);
        grid.setPartition(x,y,newPartition);
        if (this.grid.isBlockedForPeople(x,y)) {
          break;
        }
      }
 else       if (!this.grid.isBlockedForPeople(currPos.getX(),currPos.getY())) {
        if (grid.getPartition(currPos) != newPartition) {
          newPartition=grid.mergePartitions(currPos.getX(),currPos.getY(),x,y);
        }
      }
    }
  }
  if (newPartition == -1) {
    grid.createPartition(x,y,newPlayer);
  }
}"
56679,"/** 
 * Checks if the old partition is separated by removing the given position and if so, it lets divided the partition in new partitions.
 * @param position position that has been removed
 * @param oldPartition old partition of the removed position
 */
private void removeFromOldPartition(final short x,final short y,final short oldPartition){
  ISPosition2D[] disconnected=new ISPosition2D[3];
  byte disconnectedCtr=0;
  boolean lastWasOldPartition=false;
  for (  EDirection dir : EDirection.values()) {
    ISPosition2D currPos=dir.getNextHexPoint(x,y);
    if (!map.isInBounds(currPos.getX(),currPos.getY())) {
      continue;
    }
    short currPartition=map.getPartition(currPos);
    if (lastWasOldPartition) {
      if (currPartition == oldPartition) {
      }
 else {
        lastWasOldPartition=false;
      }
    }
 else {
      if (currPartition == oldPartition) {
        lastWasOldPartition=true;
        disconnected[disconnectedCtr]=currPos;
        disconnectedCtr++;
      }
    }
  }
  ISPosition2D lastPosition=EDirection.values()[5].getNextHexPoint(x,y);
  if (map.getPartition(lastPosition) == oldPartition) {
    disconnectedCtr--;
  }
  if (disconnectedCtr > 1) {
    byte oldPlayer=map.getPlayerAt(disconnected[0]);
    if (!existsPathBetween(disconnected[1],disconnected[0],oldPlayer)) {
      map.dividePartition(x,y,disconnected[1],disconnected[0]);
      if (disconnectedCtr == 3) {
        if (!existsPathBetween(disconnected[2],disconnected[1],oldPlayer)) {
          map.dividePartition(x,y,disconnected[2],disconnected[1]);
          if (existsPathBetween(disconnected[2],disconnected[0],oldPlayer)) {
            map.dividePartition(x,y,disconnected[2],disconnected[0]);
          }
 else {
          }
        }
 else {
        }
      }
 else {
      }
    }
 else {
      if (disconnectedCtr == 3) {
        if (!existsPathBetween(disconnected[2],disconnected[1],oldPlayer)) {
          map.dividePartition(x,y,disconnected[2],disconnected[1]);
        }
 else {
        }
      }
 else {
      }
    }
  }
 else {
  }
}","/** 
 * Checks if the old partition is separated by removing the given position and if so, it lets divided the partition in new partitions.
 * @param position position that has been removed
 * @param oldPartition old partition of the removed position
 */
private void removeFromOldPartition(final short x,final short y,final short oldPartition){
  ISPosition2D[] disconnected=new ISPosition2D[3];
  byte disconnectedCtr=0;
  boolean lastWasOldPartition=false;
  for (  EDirection dir : EDirection.values()) {
    ISPosition2D currPos=dir.getNextHexPoint(x,y);
    if (!grid.isInBounds(currPos.getX(),currPos.getY())) {
      continue;
    }
    short currPartition=grid.getPartition(currPos);
    if (lastWasOldPartition) {
      if (currPartition == oldPartition) {
      }
 else {
        lastWasOldPartition=false;
      }
    }
 else {
      if (currPartition == oldPartition && !grid.isBlockedForPeople(x,y)) {
        lastWasOldPartition=true;
        disconnected[disconnectedCtr]=currPos;
        disconnectedCtr++;
      }
    }
  }
  ISPosition2D lastPosition=EDirection.values()[5].getNextHexPoint(x,y);
  if (grid.getPartition(lastPosition) == oldPartition) {
    disconnectedCtr--;
  }
  if (disconnectedCtr > 1) {
    byte oldPlayer=grid.getPlayerAt(disconnected[0]);
    if (!existsPathBetween(disconnected[1],disconnected[0],oldPlayer)) {
      grid.dividePartition(x,y,disconnected[1],disconnected[0]);
      if (disconnectedCtr == 3) {
        if (!existsPathBetween(disconnected[2],disconnected[1],oldPlayer)) {
          grid.dividePartition(x,y,disconnected[2],disconnected[1]);
          if (existsPathBetween(disconnected[2],disconnected[0],oldPlayer)) {
            grid.dividePartition(x,y,disconnected[2],disconnected[0]);
          }
 else {
          }
        }
 else {
        }
      }
 else {
      }
    }
 else {
      if (disconnectedCtr == 3) {
        if (!existsPathBetween(disconnected[2],disconnected[1],oldPlayer)) {
          grid.dividePartition(x,y,disconnected[2],disconnected[1]);
        }
 else {
        }
      }
 else {
      }
    }
  }
 else {
  }
}"
56680,"/** 
 * Constructor of   {@link PartitionsAlgorithm}.
 * @param partitionsMap The  {@link PartitionsAlgorithm} is operating on this map.
 * @param aStarMap This is the map the AStar operates on
 */
public PartitionsAlgorithm(final IPartionsAlgorithmMap partitionsMap,final IAStarPathMap aStarMap){
  this.map=partitionsMap;
  this.aStar=new HexAStar(aStarMap);
  this.aStarPathable=new AStarPathable();
}","/** 
 * Constructor of   {@link PartitionsAlgorithm}.
 * @param partitionsMap The  {@link PartitionsAlgorithm} is operating on this map.
 * @param aStarMap This is the map the AStar operates on
 */
public PartitionsAlgorithm(final IPartionsAlgorithmMap partitionsMap,final IAStarPathMap aStarMap){
  this.grid=partitionsMap;
  this.aStar=new HexAStar(aStarMap);
  this.aStarPathable=new AStarPathable();
}"
56681,"/** 
 * Calculates the new partition for the given position.<br> It also merges or divides partitions if it became necessary by the given change to position.
 * @param x x coordinate
 * @param y y coordinate
 * @param newPlayer the player that is now occupying the given position.
 */
public void calculateNewPartition(short x,short y,byte newPlayer){
  short oldPartition=map.getPartition(x,y);
  if (newPlayer != -1) {
    addToNewPartiton(x,y,newPlayer);
  }
  if (oldPartition != -1) {
    removeFromOldPartition(x,y,oldPartition);
  }
}","/** 
 * Calculates the new partition for the given position.<br> It also merges or divides partitions if it became necessary by the given change to position.
 * @param x x coordinate
 * @param y y coordinate
 * @param newPlayer the player that is now occupying the given position.
 */
public void calculateNewPartition(short x,short y,byte newPlayer){
  short oldPartition=grid.getPartition(x,y);
  if (newPlayer != -1) {
    addToNewPartiton(x,y,newPlayer);
  }
  if (oldPartition != -1) {
    removeFromOldPartition(x,y,oldPartition);
  }
}"
56682,"private void nothingTodoAction(){
  if (RandomSingleton.nextF() < Constants.MOVABLE_TURN_PROBABILITY) {
    this.setDirection(direction.getNeighbor(RandomSingleton.getInt(-1,1)));
  }
 else   if (RandomSingleton.nextF() < Constants.MOVABLE_NO_ACTION_STEP_PROBABILITY) {
    for (    EDirection curr : EDirection.values()) {
      IHexMovable movable=grid.getMovable(curr.getNextHexPoint(pos));
      if (movable != null) {
        movable.push(this);
      }
    }
  }
}","private void nothingTodoAction(){
  if (RandomSingleton.nextF() < Constants.MOVABLE_TURN_PROBABILITY) {
    this.setDirection(direction.getNeighbor(RandomSingleton.getInt(-1,1)));
  }
 else   if (RandomSingleton.nextF() < Constants.MOVABLE_NO_ACTION_STEP_PROBABILITY) {
    for (    EDirection curr : EDirection.values()) {
      ISPosition2D point=curr.getNextHexPoint(pos);
      if (grid.isInBounds(point)) {
        IHexMovable movable=grid.getMovable(point);
        if (movable != null) {
          movable.push(this);
        }
      }
    }
  }
}"
56683,"protected void convertTo(EMovableType movableType){
  this.movable.setStrategy(getTypeStrategy(grid,movableType,movable));
}","protected void convertTo(EMovableType movableType){
  this.movable.setMaterial(EMaterialType.NO_MATERIAL);
  this.movable.setStrategy(getTypeStrategy(grid,movableType,movable));
}"
56684,"public synchronized Path find(final IPathCalculateable requester,final short cX,final short cY,final short minRadius,final short maxRadius,final ESearchType type){
  if (!isInBounds(cX,cY)) {
    throw new InvalidStartPositionException(cX,cY);
  }
  for (short radius=minRadius; radius < maxRadius; radius++) {
    short x=cX, y=(short)(cY + radius);
    for (byte direction=0; direction < 6; direction++) {
      byte dx=directionIncreaseX[direction];
      byte dy=directionIncreaseY[direction];
      for (short length=0; length < radius; length++) {
        x+=dx;
        y+=dy;
        if (isInBounds(x,y)) {
          map.setDijkstraSearched(x,y);
          if (map.fitsSearchType(x,y,type,requester)) {
            Path path=findPath(requester,x,y);
            if (path != null)             return path;
          }
        }
      }
    }
  }
  return null;
}","public synchronized Path find(final IPathCalculateable requester,final short cX,final short cY,final short minRadius,final short maxRadius,final ESearchType type){
  if (!isInBounds(cX,cY)) {
    throw new InvalidStartPositionException(cX,cY);
  }
  for (short radius=minRadius; radius < maxRadius; radius++) {
    short x=cX, y=(short)(cY - radius);
    for (byte direction=0; direction < 6; direction++) {
      byte dx=directionIncreaseX[direction];
      byte dy=directionIncreaseY[direction];
      for (short length=0; length < radius; length++) {
        x+=dx;
        y+=dy;
        if (isInBounds(x,y)) {
          map.setDijkstraSearched(x,y);
          if (map.fitsSearchType(x,y,type,requester)) {
            Path path=findPath(requester,x,y);
            if (path != null)             return path;
          }
        }
      }
    }
  }
  return null;
}"
56685,"@Override public Color getDebugColorAt(int x,int y){
  return new Color(partitionsGrid.getPartition((short)x,(short)y) * 0.2f,0,0,1);
}","@Override public Color getDebugColorAt(int x,int y){
  return debugColors[x][y];
}"
56686,"@Override public Color getDebugColorAt(int x,int y){
  return debugColors[x][y];
}","@Override public Color getDebugColorAt(int x,int y){
  return new Color(partitionsGrid.getPartition((short)x,(short)y) * 0.2f,0,0,1);
}"
56687,"@Override public void setPartition(ISPosition2D position,short newPartition){
  Partition newPartitionObject=getPartitionObject(newPartition);
  getPartitionObject(position.getX(),position.getY()).removePositionTo(position,newPartitionObject);
  this.partitions[position.getX()][position.getY()]=newPartition;
}","@Override public void setPartition(ISPosition2D position,short newPartition){
  Partition newPartitionObject=getPartitionObject(newPartition);
  short oldPartition=getPartition(position);
  getPartitionObject(position.getX(),position.getY()).removePositionTo(position,newPartitionObject);
  this.partitions[position.getX()][position.getY()]=newPartition;
}"
56688,"private void relabelPartition(short inX,short inY,short oldPartition,short newPartition){
  final short MAX_LENGTH=1000;
  final short[] pointsBuffer=new short[MAX_LENGTH];
  pointsBuffer[0]=inX;
  pointsBuffer[1]=inY;
  short length=2;
  while (length > 0) {
    short y=pointsBuffer[--length];
    short x=pointsBuffer[--length];
    setPartition(new ShortPoint2D(x,y),newPartition);
    for (byte i=0; i < 12; i+=2) {
      short currX=(short)(x + neighborhoodMatrix[i]);
      short currY=(short)(y + neighborhoodMatrix[i + 1]);
      if (isInBounds(currX,currY) && partitions[currX][currY] == oldPartition) {
        if (length < MAX_LENGTH) {
          pointsBuffer[length++]=currX;
          pointsBuffer[length++]=currY;
        }
 else {
          relabelPartition(currX,currY,oldPartition,newPartition);
        }
      }
    }
  }
}","private void relabelPartition(short inX,short inY,short oldPartition,short newPartition){
  final short MAX_LENGTH=1000;
  final short[] pointsBuffer=new short[MAX_LENGTH];
  pointsBuffer[0]=inX;
  pointsBuffer[1]=inY;
  short length=2;
  while (length > 0) {
    short y=pointsBuffer[--length];
    short x=pointsBuffer[--length];
    if (partitions[x][y] != oldPartition) {
      continue;
    }
    setPartition(new ShortPoint2D(x,y),newPartition);
    for (byte i=0; i < 12; i+=2) {
      short currX=(short)(x + neighborhoodMatrix[i]);
      short currY=(short)(y + neighborhoodMatrix[i + 1]);
      if (isInBounds(currX,currY) && partitions[currX][currY] == oldPartition) {
        if (length < MAX_LENGTH) {
          pointsBuffer[length++]=currX;
          pointsBuffer[length++]=currY;
        }
 else {
          relabelPartition(currX,currY,oldPartition,newPartition);
        }
      }
    }
  }
}"
56689,"@Override public void run(){
  while (!canceled) {
    if (!positionsQueue.isEmpty()) {
      ISPosition2D position=positionsQueue.poll();
      byte player=grid.getPlayer(position.getX(),position.getY());
      boolean isBorder=false;
      for (      EDirection currDir : EDirection.values()) {
        short currNeighborX=currDir.getNextTileX(position.getX());
        short currNeighborY=currDir.getNextTileY(position.getY());
        if (!grid.isInBounds(currNeighborX,currNeighborY)) {
          continue;
        }
        byte neighborPlayer=grid.getPlayer(currNeighborX,currNeighborY);
        boolean neighborIsBorder=false;
        if (neighborPlayer >= 0) {
          if (neighborPlayer != player) {
            isBorder=true;
          }
          for (          EDirection currNeighborDir : EDirection.values()) {
            short nextX=currNeighborDir.getNextTileX(currNeighborX);
            short nextY=currNeighborDir.getNextTileY(currNeighborY);
            if (grid.isInBounds(nextX,nextY) && grid.getPlayer(nextX,nextY) != neighborPlayer) {
              neighborIsBorder=true;
              break;
            }
          }
        }
        grid.setBorder(currNeighborX,currNeighborY,neighborIsBorder);
      }
      grid.setBorder(position.getX(),position.getY(),isBorder && player >= 0);
    }
 else {
      try {
        Thread.sleep(50);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
}","@Override public void run(){
  while (!canceled) {
    if (!positionsQueue.isEmpty()) {
      ISPosition2D position=positionsQueue.poll();
      byte player=grid.getPlayer(position.getX(),position.getY());
      boolean isBorder=false;
      for (      EDirection currDir : EDirection.values()) {
        short currNeighborX=currDir.getNextTileX(position.getX());
        short currNeighborY=currDir.getNextTileY(position.getY());
        if (!grid.isInBounds(currNeighborX,currNeighborY)) {
          continue;
        }
        byte neighborPlayer=grid.getPlayer(currNeighborX,currNeighborY);
        boolean neighborIsBorder=false;
        if (neighborPlayer != player) {
          isBorder=true;
        }
        if (neighborPlayer >= 0) {
          for (          EDirection currNeighborDir : EDirection.values()) {
            short nextX=currNeighborDir.getNextTileX(currNeighborX);
            short nextY=currNeighborDir.getNextTileY(currNeighborY);
            if (grid.isInBounds(nextX,nextY) && grid.getPlayer(nextX,nextY) != neighborPlayer) {
              neighborIsBorder=true;
              break;
            }
          }
        }
        grid.setBorder(currNeighborX,currNeighborY,neighborIsBorder);
      }
      grid.setBorder(position.getX(),position.getY(),isBorder && player >= 0);
    }
 else {
      try {
        Thread.sleep(50);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
}"
56690,"@Override public void keyPressed(KeyEvent e){
  startKeyEvent(KeyEvent.getKeyText(e.getKeyCode()));
}","@Override public void keyPressed(KeyEvent e){
  String text=KeyEvent.getKeyText(e.getKeyCode());
  if (text == null || text.length() != 1) {
switch (e.getKeyCode()) {
case KeyEvent.VK_LEFT:
      text=""String_Node_Str"";
    break;
case KeyEvent.VK_RIGHT:
  text=""String_Node_Str"";
break;
case KeyEvent.VK_DOWN:
text=""String_Node_Str"";
break;
case KeyEvent.VK_UP:
text=""String_Node_Str"";
break;
case KeyEvent.VK_PAUSE:
text=""String_Node_Str"";
break;
default :
text=""String_Node_Str"";
}
}
startKeyEvent(text);
}"
56691,"protected void endKeyEvent(){
  if (ongoingKeyEvent != null) {
    ongoingKeyEvent.released();
    ongoingKeyEvent=null;
  }
}","protected void endKeyEvent(){
  if (ongoingKeyEvent != null) {
    boolean replaced=replaceKeyEvent(ongoingKeyEvent);
    if (replaced) {
      ongoingKeyEvent.aborted();
      ongoingKeyEvent=null;
    }
 else {
      ongoingKeyEvent.released();
      ongoingKeyEvent=null;
    }
  }
}"
56692,"@Override public UIPoint getPanDistance(){
  UIPoint real=(this.baseEvent).getPanDistance();
  return new UIPoint(real.getX() - this.displacement.getX(),real.getY() - this.displacement.getY());
}","@Override public UIPoint getPanDistance(){
  UIPoint real=(this.baseEvent).getPanDistance();
  return real;
}"
56693,"private void drawWithConstructionMask(MapDrawContext context,float maskState,Image image){
  int tiles=6;
  float toplineBottom=maskState;
  float toplineTop=Math.min(1,toplineBottom + .1f);
  float[] tris=new float[(tiles + 2) * 3 * 5];
  addToArray(tris,0,0,0,image);
  addToArray(tris,1,1,0,image);
  addToArray(tris,2,0,toplineBottom,image);
  addToArray(tris,3,1,0,image);
  addToArray(tris,2,1,toplineBottom,image);
  addToArray(tris,2,0,toplineBottom,image);
  for (int i=0; i < tiles; i++) {
    addToArray(tris,6 + i * 3,1.0f / tiles * i,toplineBottom,image);
    addToArray(tris,7 + i * 3,1.0f / tiles * (i + 1),toplineBottom,image);
    addToArray(tris,8 + i * 3,1.0f / tiles * (i + .5f),toplineTop,image);
  }
  GLDrawContext gl=context.getGl();
  gl.drawTrianglesWithTexture(image.getTextureIndex(gl),tris);
}","private void drawWithConstructionMask(MapDrawContext context,float maskState,Image image){
  int tiles=6;
  float toplineBottom=maskState;
  float toplineTop=Math.min(1,toplineBottom + .1f);
  float[] tris=new float[(tiles + 2) * 3 * 5];
  addToArray(tris,0,0,0,image);
  addToArray(tris,1,1,0,image);
  addToArray(tris,2,0,toplineBottom,image);
  addToArray(tris,3,1,0,image);
  addToArray(tris,4,1,toplineBottom,image);
  addToArray(tris,5,0,toplineBottom,image);
  for (int i=0; i < tiles; i++) {
    addToArray(tris,6 + i * 3,1.0f / tiles * i,toplineBottom,image);
    addToArray(tris,7 + i * 3,1.0f / tiles * (i + 1),toplineBottom,image);
    addToArray(tris,8 + i * 3,1.0f / tiles * (i + .5f),toplineTop,image);
  }
  GLDrawContext gl=context.getGl();
  gl.drawTrianglesWithTexture(image.getTextureIndex(gl),tris);
}"
56694,"protected void changeMousePosition(Point position){
  mousePosition=position;
}","protected void changeMousePosition(Point position){
  mousePosition=position;
  if (controls.containsPoint(position)) {
    tooltipString=controls.getDescriptionFor(position);
    if (tooltipString == null) {
      tooltipString=""String_Node_Str"";
    }
  }
 else {
    tooltipString=""String_Node_Str"";
  }
}"
56695,"@Override public void handleEvent(GOEvent event){
  if (event instanceof GOPanEvent) {
    event.setHandler(new PanHandler(this.context.getScreen()));
  }
 else   if (event instanceof GOCommandEvent) {
    GOCommandEvent commandEvent=(GOCommandEvent)event;
    Action action=handleCommand(commandEvent);
    if (action != null) {
      fireAction(event,action);
    }
  }
 else   if (event instanceof GOKeyEvent) {
    Action actionForKeyboard=getActionForKeyboard(((GOKeyEvent)event).getKeyCode());
    if (actionForKeyboard != null) {
      fireAction(event,actionForKeyboard);
    }
  }
 else   if (event instanceof GODrawEvent) {
    GODrawEvent drawEvent=(GODrawEvent)event;
    handleDraw(drawEvent);
  }
 else   if (event instanceof GOHoverEvent) {
    GOHoverEvent hoverEvent=(GOHoverEvent)event;
    handleHover(hoverEvent);
  }
}","@Override public void handleEvent(GOEvent event){
  if (event instanceof GOPanEvent) {
    event.setHandler(new PanHandler(this.context.getScreen()));
  }
 else   if (event instanceof GOCommandEvent) {
    GOCommandEvent commandEvent=(GOCommandEvent)event;
    Action action=handleCommand(commandEvent);
    if (action != null) {
      fireActionEvent(event,action);
    }
  }
 else   if (event instanceof GOKeyEvent) {
    Action actionForKeyboard=getActionForKeyboard(((GOKeyEvent)event).getKeyCode());
    if (actionForKeyboard != null) {
      fireActionEvent(event,actionForKeyboard);
    }
  }
 else   if (event instanceof GODrawEvent) {
    GODrawEvent drawEvent=(GODrawEvent)event;
    handleDraw(drawEvent);
  }
 else   if (event instanceof GOHoverEvent) {
    GOHoverEvent hoverEvent=(GOHoverEvent)event;
    handleHover(hoverEvent);
  }
}"
56696,"@Override public void drawContent(GLDrawContext gl,int newWidth,int newHeight){
  if (newWidth != this.context.getScreen().getWidth() || newHeight != this.context.getScreen().getHeight()) {
    resizeTo(newWidth,newHeight);
  }
  IntRectangle newScreen=context.getScreen().getPosition();
  if (!newScreen.equals(oldScreen)) {
    getInterfaceConnector().fireAction(new ScreenChangeAction(context.getScreenArea()));
  }
  oldScreen=newScreen;
  this.context.begin(gl);
  this.context.debugTime(""String_Node_Str"");
  this.objectDrawer.increaseAnimationStep();
  drawBackground();
  this.context.debugTime(""String_Node_Str"");
  drawMain();
  this.context.end();
  gl.glTranslatef(0,0,.5f);
  drawSelectionHint(gl);
  controls.drawAt(gl);
  this.context.debugTime(""String_Node_Str"");
  drawFramerate();
  drawTooltip();
}","@Override public void drawContent(GLDrawContext gl,int newWidth,int newHeight){
  adaptScreenSize(newWidth,newHeight);
  this.objectDrawer.increaseAnimationStep();
  this.context.begin(gl);
  drawBackground();
  drawMain();
  this.context.end();
  gl.glTranslatef(0,0,.5f);
  drawSelectionHint(gl);
  controls.drawAt(gl);
  this.context.debugTime(""String_Node_Str"");
  drawFramerate();
  drawTooltip();
}"
56697,"/** 
 * Creates a new map content for the given map.
 * @param map The map.
 */
public MapContent(IGraphicsGrid map){
  this.map=map;
  this.context=new MapDrawContext(map);
  controls=new OriginalControls(map);
  this.connector=new MapInterfaceConnector(this);
}","/** 
 * Creates a new map content for the given map.
 * @param map The map.
 */
public MapContent(IGraphicsGrid map){
  this.map=map;
  this.context=new MapDrawContext(map);
  controls=new OriginalControls(map);
  this.connector=new MapInterfaceConnector(this);
  this.connector.addListener(this);
}"
56698,"/** 
 * Draws the main content (buildings, settlers, ...), assuming the context is set up.
 */
private void drawMain(){
  boolean needDrawDebug=false;
  IMapArea tiles=new MapShapeFilter(this.context.getConverter().getMapForScreen(this.context.getScreen().getPosition().bigger(30)),map.getWidth(),map.getHeight());
  for (  ISPosition2D pos : tiles) {
    short x=pos.getX();
    short y=pos.getY();
    IMapObject object=map.getMapObjectsAt(x,y);
    if (object != null) {
      this.objectDrawer.drawMapObject(this.context,this.map,pos,object);
    }
    IMovable movable=map.getMovableAt(x,y);
    if (movable != null) {
      if (movable.getAction() == EAction.WALKING) {
        ISPosition2D origin=movable.getDirection().getInverseDirection().getNextHexPoint(pos);
        if (origin == null) {
          origin=pos;
        }
        this.context.beginBetweenTileContext(origin,pos,movable.getMoveProgress());
        this.movableDrawer.draw(this.context,movable);
        this.context.endTileContext();
      }
 else {
        this.context.beginTileContext(pos);
        this.movableDrawer.draw(this.context,movable);
        this.context.endTileContext();
      }
    }
    if (ENABLE_DEBUG && map.getDebugColorAt(x,y) != null) {
      needDrawDebug=true;
    }
    if (map.isBorder(x,y)) {
      this.context.beginTileContext(pos);
      byte player=map.getPlayerAt(x,y);
      objectDrawer.drawPlayerBorderObject(context,player);
      this.context.endTileContext();
    }
  }
  this.context.debugTime(""String_Node_Str"");
  if (needDrawDebug) {
    drawDebugColors();
  }
  this.context.debugTime(""String_Node_Str"");
}","/** 
 * Draws the main content (buildings, settlers, ...), assuming the context is set up.
 */
private void drawMain(){
  boolean needDrawDebug=false;
  IMapArea tiles=new MapShapeFilter(this.context.getConverter().getMapForScreen(this.context.getScreen().getPosition().bigger(30)),map.getWidth(),map.getHeight());
  for (  ISPosition2D pos : tiles) {
    short x=pos.getX();
    short y=pos.getY();
    IMapObject object=map.getMapObjectsAt(x,y);
    if (object != null) {
      this.objectDrawer.drawMapObject(this.context,this.map,pos,object);
    }
    IMovable movable=map.getMovableAt(x,y);
    if (movable != null) {
      if (movable.getAction() == EAction.WALKING) {
        ISPosition2D origin=movable.getDirection().getInverseDirection().getNextHexPoint(pos);
        if (origin == null) {
          origin=pos;
        }
        this.context.beginBetweenTileContext(origin,pos,movable.getMoveProgress());
        this.movableDrawer.draw(this.context,movable);
        this.context.endTileContext();
      }
 else {
        this.context.beginTileContext(pos);
        this.movableDrawer.draw(this.context,movable);
        this.context.endTileContext();
      }
    }
    if (ENABLE_DEBUG && map.getDebugColorAt(x,y) != null) {
      needDrawDebug=true;
    }
    if (map.isBorder(x,y)) {
      this.context.beginTileContext(pos);
      byte player=map.getPlayerAt(x,y);
      objectDrawer.drawPlayerBorderObject(context,player);
      this.context.endTileContext();
    }
  }
  if (needDrawDebug) {
    drawDebugColors();
  }
}"
56699,"private Action getActionForKeyboard(int keyCode){
switch (keyCode) {
case KeyEvent.VK_F12:
    return new Action(EActionType.FAST_FORWARD);
case KeyEvent.VK_PAUSE:
case KeyEvent.VK_P:
  return new Action(EActionType.SPEED_TOGGLE_PAUSE);
case KeyEvent.VK_PLUS:
return new Action(EActionType.SPEED_FASTER);
case KeyEvent.VK_MINUS:
return new Action(EActionType.SPEED_SLOWER);
case KeyEvent.VK_SPACE:
return new Action(EActionType.SHOW_SELECTION);
case KeyEvent.VK_D:
return new Action(EActionType.DEBUG_ACTION);
case KeyEvent.VK_S:
return new Action(EActionType.STOP_WORKING);
case KeyEvent.VK_Q:
ENABLE_DEBUG=!ENABLE_DEBUG;
break;
}
return null;
}","private Action getActionForKeyboard(int keyCode){
switch (keyCode) {
case KeyEvent.VK_F12:
    return new Action(EActionType.FAST_FORWARD);
case KeyEvent.VK_PAUSE:
case KeyEvent.VK_P:
  return new Action(EActionType.SPEED_TOGGLE_PAUSE);
case KeyEvent.VK_PLUS:
return new Action(EActionType.SPEED_FASTER);
case KeyEvent.VK_MINUS:
return new Action(EActionType.SPEED_SLOWER);
case KeyEvent.VK_SPACE:
return new Action(EActionType.SHOW_SELECTION);
case KeyEvent.VK_D:
return new Action(EActionType.DEBUG_ACTION);
case KeyEvent.VK_S:
return new Action(EActionType.STOP_WORKING);
case KeyEvent.VK_Q:
return new Action(EActionType.TOGGLE_DEBUG);
}
return null;
}"
56700,"public OriginalControls(IGraphicsGrid map){
  this.map=map;
  constants=new SmallOriginalConstants();
  uiBase=createInterface();
  mainPanel.useConstants(constants);
}","public OriginalControls(IGraphicsGrid map){
  this.map=map;
  minimap=new Minimap(map);
  constants=new SmallOriginalConstants();
  uiBase=createInterface();
  mainPanel.useConstants(constants);
}"
56701,"private void drawWithConstructionMask(MapDrawContext context,float maskState,Image image){
  int tiles=6;
  float toplineBottom=maskState;
  float toplineTop=Math.min(1,toplineBottom + .2f * image.getHeight());
  float[] tris=new float[(tiles + 2) * 3 * 5];
  addToArray(tris,0,0,0,image);
  addToArray(tris,1,1,0,image);
  addToArray(tris,2,0,toplineBottom,image);
  addToArray(tris,3,1,0,image);
  addToArray(tris,2,1,toplineBottom,image);
  addToArray(tris,2,0,toplineBottom,image);
  for (int i=0; i < tiles; i++) {
    addToArray(tris,6 + i * 3,1.0f / tiles * i,toplineBottom,image);
    addToArray(tris,7 + i * 3,1.0f / tiles * (i + 1),toplineBottom,image);
    addToArray(tris,8 + i * 3,1.0f / tiles * (i + .5f),toplineTop,image);
  }
  GLDrawContext gl=context.getGl();
  gl.drawTrianglesWithTexture(image.getTextureIndex(gl),tris);
}","private void drawWithConstructionMask(MapDrawContext context,float maskState,Image image){
  int tiles=6;
  float toplineBottom=maskState;
  float toplineTop=Math.min(1,toplineBottom + .1f);
  float[] tris=new float[(tiles + 2) * 3 * 5];
  addToArray(tris,0,0,0,image);
  addToArray(tris,1,1,0,image);
  addToArray(tris,2,0,toplineBottom,image);
  addToArray(tris,3,1,0,image);
  addToArray(tris,2,1,toplineBottom,image);
  addToArray(tris,2,0,toplineBottom,image);
  for (int i=0; i < tiles; i++) {
    addToArray(tris,6 + i * 3,1.0f / tiles * i,toplineBottom,image);
    addToArray(tris,7 + i * 3,1.0f / tiles * (i + 1),toplineBottom,image);
    addToArray(tris,8 + i * 3,1.0f / tiles * (i + .5f),toplineTop,image);
  }
  GLDrawContext gl=context.getGl();
  gl.drawTrianglesWithTexture(image.getTextureIndex(gl),tris);
}"
56702,"public ConstructMarksThread(IConstructionMarkableMap map,byte player){
  super(""String_Node_Str"");
  this.map=map;
  this.player=player;
}","public ConstructMarksThread(IConstructionMarkableMap map,byte player){
  super(""String_Node_Str"");
  this.map=map;
  this.player=player;
  this.start();
}"
56703,"public void setWorkAreaCenter(ISPosition2D workAreaCenter){
}","public void setWorkAreaCenter(@SuppressWarnings(""String_Node_Str"") ISPosition2D workAreaCenter){
}"
56704,"@Override public boolean pushMaterial(ISPosition2D position,EMaterialType materialType){
  if (mapObjectsManager.pushMaterial(position,materialType)) {
    partitionsGrid.pushMaterial(position,materialType);
    return true;
  }
 else   return false;
}","@Override public boolean pushMaterial(ISPosition2D position,EMaterialType materialType,boolean offer){
  if (mapObjectsManager.pushMaterial(position,materialType)) {
    if (offer) {
      partitionsGrid.pushMaterial(position,materialType);
    }
    return true;
  }
 else   return false;
}"
56705,"public Partition(final byte player){
  this.player=player;
  this.manager=new PartitionManager();
}","public Partition(byte player,int size){
  this(player);
  this.counter=size;
}"
56706,"public void decrement(){
  counter--;
}","private void decrement(){
  counter--;
}"
56707,"public void increment(){
  counter++;
}","private void increment(){
  counter++;
}"
56708,"public void request(ISPosition2D position,EMaterialType materialType,byte priority){
  getPartitionObject(position).request(position,materialType,priority);
}","public void request(ISPosition2D position,EMaterialType materialType,byte priority){
  getPartitionObject(position.getX(),position.getY()).request(position,materialType,priority);
}"
56709,"public PartitionsGrid(final short width,final short height,IAStarPathMap pathfinderMap){
  this.width=width;
  this.height=height;
  this.partitions=new short[width][height];
  this.player=new byte[width][height];
  this.borders=new boolean[width][height];
  this.partitionsManager=new PartitionsAlgorithm(this,pathfinderMap);
  for (short x=0; x < width; x++) {
    for (short y=0; y < height; y++) {
      this.partitions[x][y]=-1;
      this.player[x][y]=-1;
    }
  }
}","public PartitionsGrid(final short width,final short height,IAStarPathMap pathfinderMap){
  this.width=width;
  this.height=height;
  this.partitions=new short[width][height];
  this.player=new byte[width][height];
  this.borders=new boolean[width][height];
  this.partitionsManager=new PartitionsAlgorithm(this,pathfinderMap);
  this.nullPartition=new Partition((byte)-1,height * width);
  for (short x=0; x < width; x++) {
    for (short y=0; y < height; y++) {
      this.partitions[x][y]=-1;
      this.player[x][y]=-1;
    }
  }
}"
56710,"public void addJobless(IManageableBearer manageable){
  getPartitionObject(manageable.getPos()).addJobless(manageable);
}","public void addJobless(IManageableBearer manageable){
  getPartitionObject(manageable.getPos().getX(),manageable.getPos().getY()).addJobless(manageable);
}"
56711,"private Partition getPartitionObject(ISPosition2D pos){
  short partition=getPartition(pos);
  if (partition >= 0)   return this.partitionObjects[partition];
 else   return nullPartition;
}","private Partition getPartitionObject(short partition){
  if (partition >= 0)   return this.partitionObjects[partition];
 else   return nullPartition;
}"
56712,"private void setPartition(short x,short y,short partition){
  decrement(getPartition(x,y));
  this.partitions[x][y]=partition;
  increment(partition);
}","@Override public void setPartition(ISPosition2D position,short newPartition){
  Partition newPartitionObject=getPartitionObject(newPartition);
  getPartitionObject(position.getX(),position.getY()).removePositionTo(position,newPartitionObject);
  this.partitions[position.getX()][position.getY()]=newPartition;
}"
56713,"private void relabelPartition(short inX,short inY,short oldPartition,short newPartition){
  final short MAX_LENGTH=1000;
  final short[] points=new short[MAX_LENGTH];
  points[0]=inX;
  points[1]=inY;
  short length=2;
  while (length > 0) {
    short y=points[--length];
    short x=points[--length];
    setPartition(x,y,newPartition);
    for (byte i=0; i < 12; i+=2) {
      short currX=(short)(x + neighborhoodMatrix[i]);
      short currY=(short)(y + neighborhoodMatrix[i + 1]);
      if (isInBounds(currX,currY) && partitions[currX][currY] == oldPartition) {
        if (length < MAX_LENGTH) {
          points[length++]=currX;
          points[length++]=currY;
        }
 else {
          relabelPartition(currX,currY,oldPartition,newPartition);
        }
      }
    }
  }
}","private void relabelPartition(short inX,short inY,short oldPartition,short newPartition){
  final short MAX_LENGTH=1000;
  final short[] pointsBuffer=new short[MAX_LENGTH];
  pointsBuffer[0]=inX;
  pointsBuffer[1]=inY;
  short length=2;
  while (length > 0) {
    short y=pointsBuffer[--length];
    short x=pointsBuffer[--length];
    setPartition(new ShortPoint2D(x,y),newPartition);
    for (byte i=0; i < 12; i+=2) {
      short currX=(short)(x + neighborhoodMatrix[i]);
      short currY=(short)(y + neighborhoodMatrix[i + 1]);
      if (isInBounds(currX,currY) && partitions[currX][currY] == oldPartition) {
        if (length < MAX_LENGTH) {
          pointsBuffer[length++]=currX;
          pointsBuffer[length++]=currY;
        }
 else {
          relabelPartition(currX,currY,oldPartition,newPartition);
        }
      }
    }
  }
}"
56714,"public boolean pushMaterial(ISPosition2D position,EMaterialType materialType){
  return getPartitionObject(position).pushMaterial(position,materialType);
}","public boolean pushMaterial(ISPosition2D position,EMaterialType materialType){
  return getPartitionObject(position.getX(),position.getY()).pushMaterial(position,materialType);
}"
56715,"/** 
 * @param position position to be removed from this manager and added to the given manager
 * @param newManager new manager of the given position <br> NOTE: the new manager MUST NOT be null!
 */
public void removePositionTo(IMapArea area,PartitionManager newManager){
  Iterator<Offer> offerIter=offers.iterator();
  while (offerIter.hasNext()) {
    Offer currOffer=offerIter.next();
    if (area.contains(currOffer.position)) {
      newManager.offers.set(currOffer.position,currOffer);
    }
  }
  Iterator<Request> requestIter=requests.iterator();
  while (requestIter.hasNext()) {
    if (area.contains(requestIter.next().position)) {
      requestIter.remove();
    }
  }
}","/** 
 * @param position position to be removed from this manager and added to the given manager
 * @param newManager new manager of the given position <br> NOTE: the new manager MUST NOT be null!
 */
public void removePositionTo(ISPosition2D position,PartitionManager newManager){
  Offer removedOffer=offers.removeObjectAt(position);
  if (removedOffer != null) {
    newManager.offers.set(position,removedOffer);
  }
  java.util.Iterator<Request> requestIter=requests.iterator();
  while (requestIter.hasNext()) {
    if (requestIter.next().position.equals(position)) {
      requestIter.remove();
    }
  }
}"
56716,"/** 
 * Places the given material at the given position.
 * @param position position the material should be placed
 * @param materialType {@link EMaterialType} of the material to be placed
 * @return true if the material had been placed,<br>false otherwise.
 */
boolean pushMaterial(ISPosition2D position,EMaterialType materialType);","/** 
 * Places the given material at the given position.
 * @param position position the material should be placed
 * @param materialType {@link EMaterialType} of the material to be placed
 * @param offer if true, the pushed material will be offered to the manager<br> if false it won't be offered to the manager
 * @return true if the material had been placed,<br>false otherwise.
 */
boolean pushMaterial(ISPosition2D position,EMaterialType materialType,boolean offer);"
56717,"@Override protected void pathRequestFailed(){
switch (state) {
case CARRY_TAKE:
    super.getGrid().pushMaterial(super.getPos(),materialType);
case CARRY_DROP:
}
}","@Override protected void pathRequestFailed(){
switch (state) {
case CARRY_TAKE:
    super.getGrid().pushMaterial(super.getPos(),materialType,true);
case CARRY_DROP:
}
}"
56718,"@Override protected boolean actionFinished(){
  if (!super.actionFinished()) {
switch (state) {
case CARRY_TAKE:
      super.getGrid().popMaterial(super.getPos(),materialType);
    super.calculatePathTo(request);
  state=EBearerState.CARRY_DROP;
break;
case CARRY_DROP:
super.getGrid().pushMaterial(super.getPos(),materialType);
this.state=EBearerState.JOBLESS;
super.setAction(EAction.NO_ACTION,-1);
super.setMaterial(EMaterialType.NO_MATERIAL);
super.getGrid().addJobless(this);
break;
case CARRY_INIT:
super.setAction(EAction.NO_ACTION,-1);
default :
super.setAction(EAction.NO_ACTION,-1);
}
}
return true;
}","@Override protected boolean actionFinished(){
  if (!super.actionFinished()) {
switch (state) {
case CARRY_TAKE:
      super.getGrid().popMaterial(super.getPos(),materialType);
    super.calculatePathTo(request);
  state=EBearerState.CARRY_DROP;
break;
case CARRY_DROP:
super.getGrid().pushMaterial(super.getPos(),materialType,false);
this.state=EBearerState.JOBLESS;
super.setAction(EAction.NO_ACTION,-1);
super.setMaterial(EMaterialType.NO_MATERIAL);
super.getGrid().addJobless(this);
break;
case CARRY_INIT:
super.setAction(EAction.NO_ACTION,-1);
default :
super.setAction(EAction.NO_ACTION,-1);
}
}
return true;
}"
56719,"@Override protected boolean actionFinished(){
  if (!super.actionFinished()) {
    if (currentJob != null) {
      boolean success=true;
      if (currentJob.getType() == EBuildingJobType.DROP && currentJob.getMaterial() != EMaterialType.NO_MATERIAL) {
        success=super.getGrid().pushMaterial(super.getPos(),currentJob.getMaterial());
      }
      if (success) {
        jobFinished();
      }
 else {
        jobFailed();
      }
    }
 else {
      super.setAction(EAction.NO_ACTION,-1);
    }
  }
  return true;
}","@Override protected boolean actionFinished(){
  if (!super.actionFinished()) {
    if (currentJob != null) {
      boolean success=true;
      if (currentJob.getType() == EBuildingJobType.DROP && currentJob.getMaterial() != EMaterialType.NO_MATERIAL) {
        success=super.getGrid().pushMaterial(super.getPos(),currentJob.getMaterial(),true);
      }
      if (success) {
        jobFinished();
      }
 else {
        jobFailed();
      }
    }
 else {
      super.setAction(EAction.NO_ACTION,-1);
    }
  }
  return true;
}"
56720,"@Override public boolean isBuildingPlaceable(ISPosition2D position,byte player){
  return !blockedGrid.isBlocked(position.getX(),position.getY()) && partitionsGrid.getPlayerAt(position) == player;
}","@Override public boolean isBuildingPlaceable(ISPosition2D position,byte player){
  short x=position.getX(), y=position.getY();
  return MainGrid.this.isInBounds(x,y) && !blockedGrid.isBlocked(x,y) && partitionsGrid.getPlayerAt(x,y) == player;
}"
56721,"@Override public IMapObjectsManagerTile getTile(final short x,final short y){
  return new IMapObjectsManagerTile(){
    @Override public void setLandscape(    ELandscapeType landscapeType){
      landscapeGrid.setLandscapeTypeAt(x,y,landscapeType);
    }
    @Override public void setBlocked(    boolean blocked){
      blockedGrid.setBlocked(x,y,blocked);
    }
    @Override public AbstractHexMapObject removeMapObjectType(    EMapObjectType mapObjectType){
      return objectsGrid.removeMapObjectType(x,y,mapObjectType);
    }
    @Override public boolean removeMapObject(    AbstractHexMapObject mapObject){
      return objectsGrid.removeMapObjectType(x,y,mapObject);
    }
    @Override public boolean isBlocked(){
      return blockedGrid.isBlocked(x,y);
    }
    @Override public AbstractHexMapObject getMapObject(    EMapObjectType mapObjectType){
      return objectsGrid.getMapObjectAt(x,y,mapObjectType);
    }
    @Override public void addMapObject(    AbstractHexMapObject mapObject){
      objectsGrid.addMapObjectAt(x,y,mapObject);
    }
  }
;
}","@Override public IMapObjectsManagerTile getTile(final short x,final short y){
  return new IMapObjectsManagerTile(){
    @Override public void setLandscape(    ELandscapeType landscapeType){
      landscapeGrid.setLandscapeTypeAt(x,y,landscapeType);
    }
    @Override public void setBlocked(    boolean blocked){
      blockedGrid.setBlocked(x,y,blocked);
    }
    @Override public AbstractHexMapObject removeMapObjectType(    EMapObjectType mapObjectType){
      return objectsGrid.removeMapObjectType(x,y,mapObjectType);
    }
    @Override public boolean removeMapObject(    AbstractHexMapObject mapObject){
      return objectsGrid.removeMapObject(x,y,mapObject);
    }
    @Override public boolean isBlocked(){
      return blockedGrid.isBlocked(x,y);
    }
    @Override public AbstractHexMapObject getMapObject(    EMapObjectType mapObjectType){
      return objectsGrid.getMapObjectAt(x,y,mapObjectType);
    }
    @Override public void addMapObject(    AbstractHexMapObject mapObject){
      objectsGrid.addMapObjectAt(x,y,mapObject);
    }
  }
;
}"
56722,"@Override public boolean removeMapObject(AbstractHexMapObject mapObject){
  return objectsGrid.removeMapObjectType(x,y,mapObject);
}","@Override public boolean removeMapObject(AbstractHexMapObject mapObject){
  return objectsGrid.removeMapObject(x,y,mapObject);
}"
56723,"public boolean removeMapObjectType(short x,short y,AbstractHexMapObject mapObject){
  AbstractHexMapObject mapObjectHead=objectsGrid[x][y];
  if (mapObjectHead != null) {
    boolean removed;
    if (mapObjectHead == mapObject) {
      mapObjectHead=mapObjectHead.getNextObject();
      removed=true;
    }
 else {
      removed=mapObjectHead.removeMapObject(mapObject);
    }
    return removed;
  }
 else   return false;
}","public AbstractHexMapObject removeMapObjectType(short x,short y,EMapObjectType mapObjectType){
  AbstractHexMapObject mapObjectHead=objectsGrid[x][y];
  AbstractHexMapObject removed=null;
  if (mapObjectHead != null) {
    if (mapObjectHead.getObjectType() == mapObjectType) {
      removed=mapObjectHead;
      objectsGrid[x][y]=mapObjectHead.getNextObject();
    }
 else {
      removed=mapObjectHead.removeMapObjectType(mapObjectType);
    }
  }
  return removed;
}"
56724,"public void removeMapObjectType(ISPosition2D pos,EMapObjectType mapObjectType){
  AbstractHexMapObject removed=getTile(pos).removeMapObjectType(mapObjectType);
  if (removed != null) {
    setBlockedForObject(pos,removed,false);
  }
}","public void removeMapObjectType(ISPosition2D pos,EMapObjectType mapObjectType){
  AbstractHexMapObject removed=getTile(pos).removeMapObjectType(mapObjectType);
  if (removed != null) {
    setBlockedForObject(pos,removed,false);
    AbstractHexMapObject object=getTile(pos).getMapObject(mapObjectType);
    System.out.println(""String_Node_Str"");
  }
}"
56725,"@Override public void run(){
  while (!canceled) {
    if (!positionsQueue.isEmpty()) {
      ISPosition2D position=positionsQueue.poll();
      byte player=grid.getPlayer(position.getX(),position.getY());
      boolean isBorder=false;
      for (      EDirection currDir : EDirection.values()) {
        short currNeighborX=currDir.getNextTileX(position.getX());
        short currNeighborY=currDir.getNextTileY(position.getY());
        byte neighborPlayer=grid.getPlayer(currNeighborX,currNeighborY);
        boolean neighborIsBorder=false;
        if (neighborPlayer >= 0) {
          if (neighborPlayer != player) {
            isBorder=true;
          }
          for (          EDirection currNeighborDir : EDirection.values()) {
            if (grid.getPlayer(currNeighborDir.getNextTileX(currNeighborX),currNeighborDir.getNextTileY(currNeighborY)) != neighborPlayer) {
              neighborIsBorder=true;
              break;
            }
          }
        }
        grid.setBorder(currNeighborX,currNeighborY,neighborIsBorder);
      }
      grid.setBorder(position.getX(),position.getY(),isBorder && player >= 0);
    }
 else {
      try {
        Thread.sleep(50);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
}","@Override public void run(){
  while (!canceled) {
    if (!positionsQueue.isEmpty()) {
      ISPosition2D position=positionsQueue.poll();
      byte player=grid.getPlayer(position.getX(),position.getY());
      boolean isBorder=false;
      for (      EDirection currDir : EDirection.values()) {
        short currNeighborX=currDir.getNextTileX(position.getX());
        short currNeighborY=currDir.getNextTileY(position.getY());
        if (!grid.isInBounds(currNeighborX,currNeighborY)) {
          continue;
        }
        byte neighborPlayer=grid.getPlayer(currNeighborX,currNeighborY);
        boolean neighborIsBorder=false;
        if (neighborPlayer >= 0) {
          if (neighborPlayer != player) {
            isBorder=true;
          }
          for (          EDirection currNeighborDir : EDirection.values()) {
            short nextX=currNeighborDir.getNextTileX(currNeighborX);
            short nextY=currNeighborDir.getNextTileY(currNeighborY);
            if (grid.isInBounds(nextX,nextY) && grid.getPlayer(nextX,nextY) != neighborPlayer) {
              neighborIsBorder=true;
              break;
            }
          }
        }
        grid.setBorder(currNeighborX,currNeighborY,neighborIsBorder);
      }
      grid.setBorder(position.getX(),position.getY(),isBorder && player >= 0);
    }
 else {
      try {
        Thread.sleep(50);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
}"
56726,"public void addMapObjectAt(short x,short y,AbstractHexMapObject mapObject){
  AbstractHexMapObject mapObjectHead=objectsGrid[x][y];
  if (mapObjectHead == null) {
    mapObjectHead=mapObject;
  }
 else {
    mapObjectHead.addMapObject(mapObject);
  }
}","public void addMapObjectAt(short x,short y,AbstractHexMapObject mapObject){
  AbstractHexMapObject mapObjectHead=objectsGrid[x][y];
  if (mapObjectHead == null) {
    objectsGrid[x][y]=mapObject;
  }
 else {
    mapObjectHead.addMapObject(mapObject);
  }
}"
56727,"@Override public byte getHeightAt(short x,short y){
  return 0;
}","@Override public byte getHeightAt(int x,int y){
  return 0;
}"
56728,"@Override public byte getPlayerAt(short x,short y){
  return 0;
}","@Override public byte getPlayerAt(int x,int y){
  return 0;
}"
56729,"@Override public IMapObject getMapObjectsAt(short x,short y){
  return tiles[x][y].getHeadMapObject();
}","@Override public IMapObject getMapObjectsAt(int x,int y){
  return tiles[x][y].getHeadMapObject();
}"
56730,"@Override public Color getDebugColorAt(short x,short y){
  return tiles[x][y].getDebugColor();
}","@Override public Color getDebugColorAt(int x,int y){
  return tiles[x][y].getDebugColor();
}"
56731,"@Override public IMovable getMovableAt(short x,short y){
  return null;
}","@Override public IMovable getMovableAt(int x,int y){
  return null;
}"
56732,"@Override public ELandscapeType getLandscapeTypeAt(short x,short y){
  return ELandscapeType.GRASS;
}","@Override public ELandscapeType getLandscapeTypeAt(int x,int y){
  return ELandscapeType.GRASS;
}"
56733,"@Override public boolean isBorder(short x,short y){
  return false;
}","@Override public boolean isBorder(int x,int y){
  return false;
}"
56734,"public boolean pushMaterial(ISPosition2D position,EMaterialType materialType){
  StackMapObject stackObject=(StackMapObject)grid.getTile(position.getX(),position.getY()).getMapObject(EMapObjectType.STACK_OBJECT);
  if (stackObject == null) {
    stackObject=new StackMapObject(materialType,(byte)1);
    return true;
  }
 else {
    if (stackObject.getMaterialType() != materialType || stackObject.isFull()) {
      return false;
    }
 else {
      stackObject.increment();
      return true;
    }
  }
}","public boolean pushMaterial(ISPosition2D position,EMaterialType materialType){
  StackMapObject stackObject=(StackMapObject)grid.getTile(position.getX(),position.getY()).getMapObject(EMapObjectType.STACK_OBJECT);
  if (stackObject == null) {
    grid.getTile(position.getX(),position.getY()).addMapObject(new StackMapObject(materialType,(byte)1));
    return true;
  }
 else {
    if (stackObject.getMaterialType() != materialType || stackObject.isFull()) {
      return false;
    }
 else {
      stackObject.increment();
      return true;
    }
  }
}"
56735,"@Override public void run(){
  while (!canceled) {
    if (!positionsQueue.isEmpty()) {
      ISPosition2D position=positionsQueue.poll();
      byte player=grid.getPlayer(position.getX(),position.getY());
      boolean isBorder=false;
      for (      EDirection currDir : EDirection.values()) {
        short currNeighborX=currDir.getNextTileX(position.getX());
        short currNeighborY=currDir.getNextTileY(position.getY());
        byte neighborPlayer=grid.getPlayer(currNeighborX,currNeighborY);
        boolean neighborIsBorder=false;
        if (neighborPlayer != player) {
          isBorder=true;
        }
        for (        EDirection currNeighborDir : EDirection.values()) {
          if (grid.getPlayer(currNeighborDir.getNextTileX(currNeighborX),currNeighborDir.getNextTileY(currNeighborY)) != neighborPlayer) {
            neighborIsBorder=true;
            break;
          }
        }
        grid.setBorder(currNeighborX,currNeighborY,neighborIsBorder);
      }
      grid.setBorder(position.getX(),position.getY(),isBorder);
    }
 else {
      try {
        Thread.sleep(50);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
}","@Override public void run(){
  while (!canceled) {
    if (!positionsQueue.isEmpty()) {
      ISPosition2D position=positionsQueue.poll();
      byte player=grid.getPlayer(position.getX(),position.getY());
      boolean isBorder=false;
      for (      EDirection currDir : EDirection.values()) {
        short currNeighborX=currDir.getNextTileX(position.getX());
        short currNeighborY=currDir.getNextTileY(position.getY());
        byte neighborPlayer=grid.getPlayer(currNeighborX,currNeighborY);
        boolean neighborIsBorder=false;
        if (neighborPlayer >= 0) {
          if (neighborPlayer != player) {
            isBorder=true;
          }
          for (          EDirection currNeighborDir : EDirection.values()) {
            if (grid.getPlayer(currNeighborDir.getNextTileX(currNeighborX),currNeighborDir.getNextTileY(currNeighborY)) != neighborPlayer) {
              neighborIsBorder=true;
              break;
            }
          }
        }
        grid.setBorder(currNeighborX,currNeighborY,neighborIsBorder);
      }
      grid.setBorder(position.getX(),position.getY(),isBorder && player >= 0);
    }
 else {
      try {
        Thread.sleep(50);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
}"
56736,"@Override public byte getHeightAt(short x,short y){
  return getTile(x,y).getHeight();
}","@Override public byte getHeightAt(int x,int y){
  return getTile(x,y).getHeight();
}"
56737,"@Override public boolean isBorder(short x,short y){
  return false;
}","@Override public boolean isBorder(int x,int y){
  return false;
}"
56738,"@Override public IMapObject getMapObjectsAt(short x,short y){
  return getTile(x,y).getHeadMapObject();
}","@Override public IMapObject getMapObjectsAt(int x,int y){
  return getTile(x,y).getHeadMapObject();
}"
56739,"@Override public byte getPlayerAt(short x,short y){
  return 0;
}","@Override public byte getPlayerAt(int x,int y){
  return 0;
}"
56740,"@Override public Color getDebugColorAt(short x,short y){
  return null;
}","@Override public Color getDebugColorAt(int x,int y){
  return null;
}"
56741,"@Override public IMovable getMovableAt(short x,short y){
  return getTile(x,y).getMovable();
}","@Override public IMovable getMovableAt(int x,int y){
  return getTile(x,y).getMovable();
}"
56742,"@Override public ELandscapeType getLandscapeTypeAt(short x,short y){
  return getTile(x,y).getLandscapeType();
}","@Override public ELandscapeType getLandscapeTypeAt(int x,int y){
  return getTile(x,y).getLandscapeType();
}"
56743,"private void setPositionsToMap(boolean[][] areaMap,List<ISPosition2D> positions2){
  for (  ISPosition2D curr : positions) {
    areaMap[getMapX(curr)][getMapY(curr)]=true;
  }
}","private void setPositionsToMap(boolean[][] areaMap,List<ISPosition2D> positions){
  for (  ISPosition2D curr : positions) {
    areaMap[getMapX(curr)][getMapY(curr)]=true;
  }
}"
56744,"protected ScalingOperationReport processCloudwatchMetrics(Map<KinesisOperationType,Map<StreamMetric,Map<Datapoint,Double>>> currentUtilisationMetrics,Map<KinesisOperationType,StreamMetrics> streamMaxCapacity,int cwSampleDuration,DateTime now){
  ScalingOperationReport report=null;
  ScaleDirection finalScaleDirection=null;
  Map<KinesisOperationType,ScaleDirection> scaleVotes=new HashMap<>();
  for (  Map.Entry<KinesisOperationType,Map<StreamMetric,Map<Datapoint,Double>>> entry : currentUtilisationMetrics.entrySet()) {
    scaleVotes.put(entry.getKey(),ScaleDirection.NONE);
    Map<StreamMetric,Triplet<Integer,Integer,Double>> perMetricSamples=new HashMap<>();
    StreamMetric higherUtilisationMetric;
    Double higherUtilisationPct;
    for (    StreamMetric metric : StreamMetric.values()) {
      double currentMax=0D;
      double currentPct=0D;
      double latestPct=0d;
      double latestMax=0d;
      double latestAvg=0d;
      DateTime lastTime=null;
      int lowSamples=0;
      int highSamples=0;
      Map<Datapoint,Double> metrics=new HashMap<>();
      if (!currentUtilisationMetrics.containsKey(entry.getKey()) || !entry.getValue().containsKey(metric)) {
      }
 else {
        metrics=entry.getValue().get(metric);
      }
      if (metrics.size() == 0) {
        lowSamples=this.config.getScaleDown().getScaleAfterMins();
      }
      for (      Map.Entry<Datapoint,Double> datapointEntry : metrics.entrySet()) {
        currentMax=datapointEntry.getValue();
        currentPct=currentMax / streamMaxCapacity.get(entry.getKey()).get(metric);
        if (lastTime == null || new DateTime(datapointEntry.getKey().getTimestamp()).isAfter(lastTime)) {
          latestPct=currentPct;
          latestMax=currentMax;
          latestAvg=latestAvg == 0d ? currentPct : (latestAvg + currentPct) / 2;
        }
        lastTime=new DateTime(datapointEntry.getKey().getTimestamp());
        if (currentPct > new Double(this.config.getScaleUp().getScaleThresholdPct()) / 100) {
          LOG.debug(String.format(""String_Node_Str"",entry.getKey(),metric,currentMax,metric,currentPct * 100));
          highSamples++;
        }
 else         if (currentPct < new Double(this.config.getScaleDown().getScaleThresholdPct()) / 100) {
          LOG.debug(String.format(""String_Node_Str"",entry.getKey(),metric,currentMax,metric,currentPct * 100));
          lowSamples++;
        }
      }
      if (metrics.size() < cwSampleDuration) {
        lowSamples+=cwSampleDuration - metrics.size();
      }
      LOG.info(String.format(metric + ""String_Node_Str"" + metric+ ""String_Node_Str"",config.getStreamName(),entry.getKey(),metric,latestAvg * 100,latestMax,streamMaxCapacity.get(entry.getKey()).get(metric)));
      if (!perMetricSamples.containsKey(metric)) {
        perMetricSamples.put(metric,new Triplet<>(highSamples,lowSamples,latestAvg));
      }
 else {
        Triplet<Integer,Integer,Double> previousHighLow=perMetricSamples.get(metric);
        Triplet<Integer,Integer,Double> newHighLow=new Triplet<>(previousHighLow.getValue0() + highSamples,previousHighLow.getValue1() + lowSamples,(previousHighLow.getValue2() + latestAvg) / 2);
        perMetricSamples.put(metric,newHighLow);
      }
    }
    if (perMetricSamples.get(StreamMetric.Bytes).getValue2() >= perMetricSamples.get(StreamMetric.Records).getValue2()) {
      higherUtilisationMetric=StreamMetric.Bytes;
      higherUtilisationPct=perMetricSamples.get(StreamMetric.Bytes).getValue2();
    }
 else {
      higherUtilisationMetric=StreamMetric.Records;
      higherUtilisationPct=perMetricSamples.get(StreamMetric.Records).getValue2();
    }
    LOG.info(String.format(""String_Node_Str"",entry.getKey(),higherUtilisationMetric,higherUtilisationPct * 100));
    if (perMetricSamples.get(higherUtilisationMetric).getValue0() >= config.getScaleUp().getScaleAfterMins()) {
      scaleVotes.put(entry.getKey(),ScaleDirection.UP);
    }
 else     if (perMetricSamples.get(higherUtilisationMetric).getValue1() >= config.getScaleDown().getScaleAfterMins()) {
      scaleVotes.put(entry.getKey(),ScaleDirection.DOWN);
    }
  }
  ScaleDirection getVote=scaleVotes.get(KinesisOperationType.GET);
  ScaleDirection putVote=scaleVotes.get(KinesisOperationType.PUT);
  if (getVote != null && putVote != null) {
    if (getVote == ScaleDirection.UP || putVote == ScaleDirection.UP) {
      finalScaleDirection=ScaleDirection.UP;
    }
 else     if (getVote == ScaleDirection.NONE && putVote == ScaleDirection.NONE) {
      finalScaleDirection=ScaleDirection.NONE;
    }
 else {
      finalScaleDirection=ScaleDirection.DOWN;
    }
  }
 else {
    finalScaleDirection=(getVote == null ? putVote : getVote);
  }
  try {
    int currentShardCount=this.scaler.getOpenShardCount(this.config.getStreamName());
    if (finalScaleDirection.equals(ScaleDirection.UP)) {
      Integer scaleUpCount=this.config.getScaleUp().getScaleCount();
      LOG.info(String.format(""String_Node_Str"",this.config.getStreamName(),(scaleUpCount != null) ? scaleUpCount : this.config.getScaleUp().getScalePct() + ""String_Node_Str"",this.config.getScaleOnOperations().toString(),this.config.getScaleUp().getScaleThresholdPct(),this.config.getScaleUp().getScaleAfterMins()));
      if (scaleUpCount != null) {
        report=this.scaler.updateShardCount(this.config.getStreamName(),currentShardCount,currentShardCount + scaleUpCount,this.config.getMinShards(),this.config.getMaxShards());
      }
 else {
        report=this.scaler.updateShardCount(this.config.getStreamName(),currentShardCount,new Double(currentShardCount * (new Double(this.config.getScaleUp().getScalePct()) / 100)).intValue(),this.config.getMinShards(),this.config.getMaxShards());
      }
      if (report != null && this.config.getScaleUp().getNotificationARN() != null && this.snsClient != null) {
        StreamScalingUtils.sendNotification(this.snsClient,this.config.getScaleUp().getNotificationARN(),""String_Node_Str"",(report == null ? ""String_Node_Str"" : report.asJson()));
      }
    }
 else     if (finalScaleDirection.equals(ScaleDirection.DOWN)) {
      if (lastScaleDown != null && now.minusMinutes(this.config.getScaleDown().getCoolOffMins()).isBefore(lastScaleDown)) {
        LOG.info(String.format(""String_Node_Str"",this.config.getStreamName(),this.config.getScaleDown().getCoolOffMins()));
      }
 else {
        Integer scaleDownCount=this.config.getScaleDown().getScaleCount();
        LOG.info(String.format(""String_Node_Str"",this.config.getStreamName(),(scaleDownCount != null) ? scaleDownCount : this.config.getScaleDown().getScalePct() + ""String_Node_Str"",config.getScaleOnOperations().toString(),this.config.getScaleDown().getScaleThresholdPct(),this.config.getScaleDown().getScaleAfterMins()));
        try {
          if (scaleDownCount != null) {
            report=this.scaler.updateShardCount(this.config.getStreamName(),currentShardCount,currentShardCount - scaleDownCount,this.config.getMinShards(),this.config.getMaxShards());
          }
 else {
            report=this.scaler.updateShardCount(this.config.getStreamName(),currentShardCount,new Double(currentShardCount - (new Double(this.config.getScaleDown().getScalePct()) / 100)).intValue(),this.config.getMinShards(),this.config.getMaxShards());
          }
          lastScaleDown=new DateTime(System.currentTimeMillis());
          if (report != null && this.config.getScaleDown().getNotificationARN() != null && this.snsClient != null) {
            StreamScalingUtils.sendNotification(this.snsClient,this.config.getScaleDown().getNotificationARN(),""String_Node_Str"",(report == null ? ""String_Node_Str"" : report.asJson()));
          }
        }
 catch (        AlreadyOneShardException aose) {
          LOG.info(String.format(""String_Node_Str"",this.config.getStreamName()));
        }
      }
    }
 else {
      LOG.info(""String_Node_Str"");
      return this.scaler.reportFor(ScalingCompletionStatus.NoActionRequired,this.config.getStreamName(),0,finalScaleDirection);
    }
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"" + this.config.getStreamName(),e);
  }
  return report;
}","protected ScalingOperationReport processCloudwatchMetrics(Map<KinesisOperationType,Map<StreamMetric,Map<Datapoint,Double>>> currentUtilisationMetrics,Map<KinesisOperationType,StreamMetrics> streamMaxCapacity,int cwSampleDuration,DateTime now){
  ScalingOperationReport report=null;
  ScaleDirection finalScaleDirection=null;
  Map<KinesisOperationType,ScaleDirection> scaleVotes=new HashMap<>();
  for (  Map.Entry<KinesisOperationType,Map<StreamMetric,Map<Datapoint,Double>>> entry : currentUtilisationMetrics.entrySet()) {
    scaleVotes.put(entry.getKey(),ScaleDirection.NONE);
    Map<StreamMetric,Triplet<Integer,Integer,Double>> perMetricSamples=new HashMap<>();
    StreamMetric higherUtilisationMetric;
    Double higherUtilisationPct;
    for (    StreamMetric metric : StreamMetric.values()) {
      double currentMax=0D;
      double currentPct=0D;
      double latestPct=0d;
      double latestMax=0d;
      double latestAvg=0d;
      DateTime lastTime=null;
      int lowSamples=0;
      int highSamples=0;
      Map<Datapoint,Double> metrics=new HashMap<>();
      if (!currentUtilisationMetrics.containsKey(entry.getKey()) || !entry.getValue().containsKey(metric)) {
      }
 else {
        metrics=entry.getValue().get(metric);
      }
      if (metrics.size() == 0) {
        lowSamples=this.config.getScaleDown().getScaleAfterMins();
      }
      for (      Map.Entry<Datapoint,Double> datapointEntry : metrics.entrySet()) {
        currentMax=datapointEntry.getValue();
        currentPct=currentMax / streamMaxCapacity.get(entry.getKey()).get(metric);
        if (lastTime == null || new DateTime(datapointEntry.getKey().getTimestamp()).isAfter(lastTime)) {
          latestPct=currentPct;
          latestMax=currentMax;
          latestAvg=latestAvg == 0d ? currentPct : (latestAvg + currentPct) / 2;
        }
        lastTime=new DateTime(datapointEntry.getKey().getTimestamp());
        if (currentPct > new Double(this.config.getScaleUp().getScaleThresholdPct()) / 100) {
          LOG.debug(String.format(""String_Node_Str"",entry.getKey(),metric,currentMax,metric,currentPct * 100));
          highSamples++;
        }
 else         if (currentPct < new Double(this.config.getScaleDown().getScaleThresholdPct()) / 100) {
          LOG.debug(String.format(""String_Node_Str"",entry.getKey(),metric,currentMax,metric,currentPct * 100));
          lowSamples++;
        }
      }
      if (metrics.size() < cwSampleDuration) {
        lowSamples+=cwSampleDuration - metrics.size();
      }
      LOG.info(String.format(metric + ""String_Node_Str"" + metric+ ""String_Node_Str"",config.getStreamName(),entry.getKey(),metric,latestAvg * 100,latestMax,streamMaxCapacity.get(entry.getKey()).get(metric)));
      if (!perMetricSamples.containsKey(metric)) {
        perMetricSamples.put(metric,new Triplet<>(highSamples,lowSamples,latestAvg));
      }
 else {
        Triplet<Integer,Integer,Double> previousHighLow=perMetricSamples.get(metric);
        Triplet<Integer,Integer,Double> newHighLow=new Triplet<>(previousHighLow.getValue0() + highSamples,previousHighLow.getValue1() + lowSamples,(previousHighLow.getValue2() + latestAvg) / 2);
        perMetricSamples.put(metric,newHighLow);
      }
    }
    if (perMetricSamples.get(StreamMetric.Bytes).getValue2() >= perMetricSamples.get(StreamMetric.Records).getValue2()) {
      higherUtilisationMetric=StreamMetric.Bytes;
      higherUtilisationPct=perMetricSamples.get(StreamMetric.Bytes).getValue2();
    }
 else {
      higherUtilisationMetric=StreamMetric.Records;
      higherUtilisationPct=perMetricSamples.get(StreamMetric.Records).getValue2();
    }
    LOG.info(String.format(""String_Node_Str"",entry.getKey(),higherUtilisationMetric,higherUtilisationPct * 100));
    if (perMetricSamples.get(higherUtilisationMetric).getValue0() >= config.getScaleUp().getScaleAfterMins()) {
      scaleVotes.put(entry.getKey(),ScaleDirection.UP);
    }
 else     if (perMetricSamples.get(higherUtilisationMetric).getValue1() >= config.getScaleDown().getScaleAfterMins()) {
      scaleVotes.put(entry.getKey(),ScaleDirection.DOWN);
    }
  }
  ScaleDirection getVote=scaleVotes.get(KinesisOperationType.GET);
  ScaleDirection putVote=scaleVotes.get(KinesisOperationType.PUT);
  if (getVote != null && putVote != null) {
    if (getVote == ScaleDirection.UP || putVote == ScaleDirection.UP) {
      finalScaleDirection=ScaleDirection.UP;
    }
 else     if (getVote == ScaleDirection.NONE && putVote == ScaleDirection.NONE) {
      finalScaleDirection=ScaleDirection.NONE;
    }
 else {
      finalScaleDirection=ScaleDirection.DOWN;
    }
  }
 else {
    finalScaleDirection=(getVote == null ? putVote : getVote);
  }
  try {
    int currentShardCount=this.scaler.getOpenShardCount(this.config.getStreamName());
    if (finalScaleDirection.equals(ScaleDirection.UP)) {
      Integer scaleUpCount=this.config.getScaleUp().getScaleCount();
      LOG.info(String.format(""String_Node_Str"",this.config.getStreamName(),(scaleUpCount != null) ? scaleUpCount : this.config.getScaleUp().getScalePct() + ""String_Node_Str"",this.config.getScaleOnOperations().toString(),this.config.getScaleUp().getScaleThresholdPct(),this.config.getScaleUp().getScaleAfterMins()));
      if (scaleUpCount != null) {
        report=this.scaler.updateShardCount(this.config.getStreamName(),currentShardCount,currentShardCount + scaleUpCount,this.config.getMinShards(),this.config.getMaxShards());
      }
 else {
        report=this.scaler.updateShardCount(this.config.getStreamName(),currentShardCount,new Double(currentShardCount * (new Double(this.config.getScaleUp().getScalePct()) / 100)).intValue(),this.config.getMinShards(),this.config.getMaxShards());
      }
      if (report != null && this.config.getScaleUp().getNotificationARN() != null && this.snsClient != null) {
        StreamScalingUtils.sendNotification(this.snsClient,this.config.getScaleUp().getNotificationARN(),""String_Node_Str"",(report == null ? ""String_Node_Str"" : report.asJson()));
      }
    }
 else     if (finalScaleDirection.equals(ScaleDirection.DOWN)) {
      if (lastScaleDown != null && now.minusMinutes(this.config.getScaleDown().getCoolOffMins()).isBefore(lastScaleDown)) {
        LOG.info(String.format(""String_Node_Str"",this.config.getStreamName(),this.config.getScaleDown().getCoolOffMins()));
      }
 else {
        Integer scaleDownCount=this.config.getScaleDown().getScaleCount();
        LOG.info(String.format(""String_Node_Str"",this.config.getStreamName(),(scaleDownCount != null) ? scaleDownCount : this.config.getScaleDown().getScalePct() + ""String_Node_Str"",config.getScaleOnOperations().toString(),this.config.getScaleDown().getScaleThresholdPct(),this.config.getScaleDown().getScaleAfterMins()));
        try {
          if (scaleDownCount != null) {
            report=this.scaler.updateShardCount(this.config.getStreamName(),currentShardCount,currentShardCount - scaleDownCount,this.config.getMinShards(),this.config.getMaxShards());
          }
 else {
            report=this.scaler.updateShardCount(this.config.getStreamName(),currentShardCount,new Double(currentShardCount * (new Double(this.config.getScaleDown().getScalePct()) / 100)).intValue(),this.config.getMinShards(),this.config.getMaxShards());
          }
          lastScaleDown=new DateTime(System.currentTimeMillis());
          if (report != null && this.config.getScaleDown().getNotificationARN() != null && this.snsClient != null) {
            StreamScalingUtils.sendNotification(this.snsClient,this.config.getScaleDown().getNotificationARN(),""String_Node_Str"",(report == null ? ""String_Node_Str"" : report.asJson()));
          }
        }
 catch (        AlreadyOneShardException aose) {
          LOG.info(String.format(""String_Node_Str"",this.config.getStreamName()));
        }
      }
    }
 else {
      LOG.info(""String_Node_Str"");
      return this.scaler.reportFor(ScalingCompletionStatus.NoActionRequired,this.config.getStreamName(),0,finalScaleDirection);
    }
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"" + this.config.getStreamName(),e);
  }
  return report;
}"
56745,"public void stopAll() throws Exception {
  for (  Integer i : runningMonitors.keySet()) {
    LOG.debug(""String_Node_Str"");
    runningMonitors.get(i).stop();
    monitorFutures.get(i).get();
  }
}","public void stopAll() throws Exception {
  for (  Integer i : runningMonitors.keySet()) {
    StreamMonitor monitor=runningMonitors.get(i);
    LOG.debug(""String_Node_Str"" + monitor.getConfig().getStreamName() + ""String_Node_Str"");
    monitor.stop();
    monitorFutures.get(i).get();
    LOG.debug(""String_Node_Str"" + monitor.getConfig().getStreamName() + ""String_Node_Str"");
  }
}"
56746,"public void startMonitors(){
  try {
    int i=0;
    for (    AutoscalingConfiguration c : this.config) {
      StreamMonitor monitor;
      try {
        LOG.info(String.format(""String_Node_Str"",c.getStreamName()));
        monitor=new StreamMonitor(c,executor);
        runningMonitors.put(i,monitor);
        monitorFutures.put(i,executor.submit(monitor));
        i++;
      }
 catch (      Exception e) {
        LOG.error(e);
      }
    }
    while (true) {
      for (      Integer n : monitorFutures.keySet()) {
        if (monitorFutures.get(n) == null) {
          throw new InterruptedException(""String_Node_Str"");
        }
 else {
          if (monitorFutures.get(n).isDone()) {
            if (runningMonitors.get(n).getException() != null) {
              throw new InterruptedException(runningMonitors.get(n).getException().getMessage());
            }
          }
        }
      }
      Thread.sleep(60000);
    }
  }
 catch (  InterruptedException e) {
    try {
      stopAll();
      LOG.error(e);
      LOG.error(""String_Node_Str"");
      executor.shutdown();
    }
 catch (    Exception e1) {
      LOG.error(e);
    }
  }
}","public void startMonitors(){
  try {
    int i=0;
    for (    AutoscalingConfiguration c : this.config) {
      StreamMonitor monitor;
      try {
        LOG.info(String.format(""String_Node_Str"",c.getStreamName()));
        monitor=new StreamMonitor(c,executor);
        runningMonitors.put(i,monitor);
        monitorFutures.put(i,executor.submit(monitor));
        i++;
      }
 catch (      Exception e) {
        LOG.error(e);
      }
    }
    while (true) {
      for (      Integer n : monitorFutures.keySet()) {
        if (monitorFutures.get(n) == null) {
          throw new InterruptedException(""String_Node_Str"");
        }
 else {
          if (monitorFutures.get(n).isDone()) {
            if (runningMonitors.get(n).getException() != null) {
              throw new InterruptedException(runningMonitors.get(n).getException().getMessage());
            }
          }
        }
      }
      Thread.sleep(60000);
    }
  }
 catch (  InterruptedException e) {
    try {
      stopAll();
      LOG.debug(e);
      LOG.info(""String_Node_Str"");
      executor.shutdown();
    }
 catch (    Exception e1) {
      LOG.error(e);
    }
  }
}"
56747,"public void stop(){
  this.keepRunning=false;
  LOG.info(String.format(""String_Node_Str"",config.getStreamName()));
}","public void stop(){
  this.keepRunning=false;
  this.kinesisClient.shutdown();
  this.cloudWatchClient.shutdown();
  IdleConnectionReaper.shutdown();
  LOG.info(String.format(""String_Node_Str"",config.getStreamName()));
}"
56748,"@Override public void run(){
  LOG.info(String.format(""String_Node_Str"",config.getStreamName()));
  DateTime lastShardCapacityRefreshTime=new DateTime(System.currentTimeMillis());
  StreamMetrics streamMaxCapacity;
  try {
    streamMaxCapacity=getStreamMaxCapacity();
  }
 catch (  Exception e) {
    this.exception=e;
    return;
  }
  int cwSampleDuration=Math.max(config.getScaleUp().getScaleAfterMins(),config.getScaleDown().getScaleAfterMins());
  List<GetMetricStatisticsRequest> cwRequests=getCloudwatchRequests(config.getScaleOnOperation());
  try {
    ScalingOperationReport report=null;
    do {
      DateTime now=new DateTime(System.currentTimeMillis());
      DateTime metricEndTime=new DateTime(System.currentTimeMillis());
      DateTime metricStartTime=metricEndTime.minusMinutes(cwSampleDuration);
      Map<StreamMetric,Map<Datapoint,Double>> metricsMap=new HashMap<StreamMetric,Map<Datapoint,Double>>();
      for (      StreamMetric m : StreamMetric.values()) {
        metricsMap.put(m,new HashMap<Datapoint,Double>());
      }
      for (      GetMetricStatisticsRequest req : cwRequests) {
        double sampleMetric=0D;
        req.withStartTime(metricStartTime.toDate()).withEndTime(metricEndTime.toDate());
        LOG.debug(String.format(""String_Node_Str"",cwSampleDuration,req.getMetricName()));
        GetMetricStatisticsResult cloudWatchMetrics=cloudWatchClient.getMetricStatistics(req);
        for (        Datapoint d : cloudWatchMetrics.getDatapoints()) {
          StreamMetric metric=StreamMetric.fromUnit(d.getUnit());
          Map<Datapoint,Double> metrics=metricsMap.get(metric);
          if (metrics.containsKey(d)) {
            sampleMetric=metrics.get(d);
          }
 else {
            sampleMetric=0d;
          }
          sampleMetric+=(d.getSum() / CLOUDWATCH_PERIOD);
          metrics.put(d,sampleMetric);
        }
      }
      report=processCloudwatchMetrics(metricsMap,streamMaxCapacity,cwSampleDuration,now);
      if (report != null) {
        streamMaxCapacity=getStreamMaxCapacity();
        lastShardCapacityRefreshTime=now;
      }
      if (report != null) {
        if (this.config.getScalingOperationReportListener() != null) {
          this.config.getScalingOperationReportListener().onReport(report);
        }
        LOG.info(report.toString());
        report=null;
      }
      if (now.minusMinutes(this.config.getRefreshShardsNumberAfterMin()).isAfter(lastShardCapacityRefreshTime)) {
        streamMaxCapacity=getStreamMaxCapacity();
        lastShardCapacityRefreshTime=now;
      }
      try {
        LOG.debug(""String_Node_Str"");
        Thread.sleep(TIMEOUT_SECONDS * 1000);
      }
 catch (      InterruptedException e) {
        LOG.error(e);
        break;
      }
    }
 while (keepRunning=true);
    LOG.info(String.format(""String_Node_Str"",this.config.getStreamName(),this.config.getRegion()));
  }
 catch (  Exception e) {
    this.exception=e;
  }
}","@Override public void run(){
  LOG.info(String.format(""String_Node_Str"",config.getStreamName()));
  DateTime lastShardCapacityRefreshTime=new DateTime(System.currentTimeMillis());
  StreamMetrics streamMaxCapacity;
  try {
    streamMaxCapacity=getStreamMaxCapacity();
  }
 catch (  Exception e) {
    this.exception=e;
    return;
  }
  int cwSampleDuration=Math.max(config.getScaleUp().getScaleAfterMins(),config.getScaleDown().getScaleAfterMins());
  List<GetMetricStatisticsRequest> cwRequests=getCloudwatchRequests(config.getScaleOnOperation());
  try {
    ScalingOperationReport report=null;
    do {
      DateTime now=new DateTime(System.currentTimeMillis());
      DateTime metricEndTime=new DateTime(System.currentTimeMillis());
      DateTime metricStartTime=metricEndTime.minusMinutes(cwSampleDuration);
      Map<StreamMetric,Map<Datapoint,Double>> metricsMap=new HashMap<StreamMetric,Map<Datapoint,Double>>();
      for (      StreamMetric m : StreamMetric.values()) {
        metricsMap.put(m,new HashMap<Datapoint,Double>());
      }
      for (      GetMetricStatisticsRequest req : cwRequests) {
        double sampleMetric=0D;
        req.withStartTime(metricStartTime.toDate()).withEndTime(metricEndTime.toDate());
        LOG.debug(String.format(""String_Node_Str"",cwSampleDuration,req.getMetricName()));
        GetMetricStatisticsResult cloudWatchMetrics=cloudWatchClient.getMetricStatistics(req);
        for (        Datapoint d : cloudWatchMetrics.getDatapoints()) {
          StreamMetric metric=StreamMetric.fromUnit(d.getUnit());
          Map<Datapoint,Double> metrics=metricsMap.get(metric);
          if (metrics.containsKey(d)) {
            sampleMetric=metrics.get(d);
          }
 else {
            sampleMetric=0d;
          }
          sampleMetric+=(d.getSum() / CLOUDWATCH_PERIOD);
          metrics.put(d,sampleMetric);
        }
      }
      report=processCloudwatchMetrics(metricsMap,streamMaxCapacity,cwSampleDuration,now);
      if (report != null) {
        streamMaxCapacity=getStreamMaxCapacity();
        lastShardCapacityRefreshTime=now;
      }
      if (report != null) {
        if (this.config.getScalingOperationReportListener() != null) {
          this.config.getScalingOperationReportListener().onReport(report);
        }
        LOG.info(report.toString());
        report=null;
      }
      if (now.minusMinutes(this.config.getRefreshShardsNumberAfterMin()).isAfter(lastShardCapacityRefreshTime)) {
        streamMaxCapacity=getStreamMaxCapacity();
        lastShardCapacityRefreshTime=now;
      }
      try {
        LOG.debug(""String_Node_Str"");
        Thread.sleep(TIMEOUT_SECONDS * 1000);
      }
 catch (      InterruptedException e) {
        LOG.error(e);
        break;
      }
    }
 while (keepRunning);
    LOG.info(String.format(""String_Node_Str"",this.config.getStreamName(),this.config.getRegion()));
  }
 catch (  Exception e) {
    this.exception=e;
  }
}"
56749,"@Override public void contextDestroyed(ServletContextEvent arg0){
  streamMonitorController.interrupt();
}","@Override public void contextDestroyed(ServletContextEvent arg0){
  streamMonitorController.interrupt();
  try {
    streamMonitorController.join();
  }
 catch (  InterruptedException e) {
  }
}"
56750,"public static Double getPctOfKeyspace(BigInteger hashWidth){
  return new BigDecimal(hashWidth).divide(new BigDecimal(maxHash),6,RoundingMode.HALF_UP).doubleValue();
}","public static Double getPctOfKeyspace(BigInteger hashWidth){
  return new BigDecimal(hashWidth).divide(new BigDecimal(maxHash),StreamScalingUtils.PCT_COMPARISON_SCALE,StreamScalingUtils.ROUNDING_MODE).doubleValue();
}"
56751,"/** 
 * Method to do a fuzzy comparison between two doubles, so that we can make generalisations about allocation of keyspace to shards. For example, when we have a stream of 3 shards, we'll have shards of 33, 33, and 34% of the keyspace - these must all be treated as equal
 * @param a
 * @param b
 * @return
 */
public static int softCompare(double a,double b){
  final int pctComparisonScale=4;
  final RoundingMode roundingMode=RoundingMode.HALF_DOWN;
  final BigDecimal acceptedVariation=BigDecimal.valueOf(1d).divide(BigDecimal.valueOf(10d).pow(pctComparisonScale - 1));
  BigDecimal first=new BigDecimal(a).setScale(pctComparisonScale,roundingMode);
  BigDecimal second=new BigDecimal(b).setScale(pctComparisonScale,roundingMode);
  BigDecimal variation=first.subtract(second).abs();
  if (variation.compareTo(acceptedVariation) < 0) {
    return 0;
  }
 else {
    return first.compareTo(second);
  }
}","/** 
 * Method to do a fuzzy comparison between two doubles, so that we can make generalisations about allocation of keyspace to shards. For example, when we have a stream of 3 shards, we'll have shards of 33, 33, and 34% of the keyspace - these must all be treated as equal
 * @param a
 * @param b
 * @return
 */
public static int softCompare(double a,double b){
  final BigDecimal acceptedVariation=BigDecimal.valueOf(1d).divide(BigDecimal.valueOf(10d).pow(PCT_COMPARISON_SCALE - 1));
  BigDecimal first=new BigDecimal(a).setScale(PCT_COMPARISON_SCALE,ROUNDING_MODE);
  BigDecimal second=new BigDecimal(b).setScale(PCT_COMPARISON_SCALE,ROUNDING_MODE);
  BigDecimal variation=first.subtract(second).abs();
  if (variation.compareTo(acceptedVariation) < 0) {
    return 0;
  }
 else {
    return first.compareTo(second);
  }
}"
56752,"/** 
 * @return      a calculated split factor value which is equal to numerator divided by denumerator
 */
public BigDecimal getSplitFactor(){
  return numerator.divide(denumerator);
}","/** 
 * @return      a calculated split factor value which is equal to numerator divided by denominator
 */
public BigDecimal getSplitFactor(){
  return numerator.divide(denominator,10,RoundingMode.HALF_UP);
}"
56753,"public HistoricalSplit(String symbol,Calendar date,BigDecimal numerator,BigDecimal denumerator){
  this.symbol=symbol;
  this.date=date;
  this.numerator=numerator;
  this.denumerator=denumerator;
}","public HistoricalSplit(String symbol,Calendar date,BigDecimal numerator,BigDecimal denominator){
  this.symbol=symbol;
  this.date=date;
  this.numerator=numerator;
  this.denominator=denominator;
}"
56754,"@Override public String toString(){
  SimpleDateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
  String dateStr=dateFormat.format(this.date.getTime());
  return ""String_Node_Str"" + this.symbol + ""String_Node_Str""+ dateStr+ ""String_Node_Str""+ this.numerator+ ""String_Node_Str""+ this.denumerator;
}","@Override public String toString(){
  SimpleDateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
  String dateStr=dateFormat.format(this.date.getTime());
  return ""String_Node_Str"" + this.symbol + ""String_Node_Str""+ dateStr+ ""String_Node_Str""+ this.numerator+ ""String_Node_Str""+ this.denominator;
}"
56755,"private static void setCookie() throws IOException {
  if (YahooFinance.HISTQUOTES2_COOKIE != null && !YahooFinance.HISTQUOTES2_COOKIE.isEmpty()) {
    cookie=YahooFinance.HISTQUOTES2_COOKIE;
    log.debug(""String_Node_Str"",cookie);
    return;
  }
  URL request=new URL(YahooFinance.HISTQUOTES2_SCRAPE_URL);
  RedirectableRequest redirectableRequest=new RedirectableRequest(request,5);
  redirectableRequest.setConnectTimeout(YahooFinance.CONNECTION_TIMEOUT);
  redirectableRequest.setReadTimeout(YahooFinance.CONNECTION_TIMEOUT);
  URLConnection connection=redirectableRequest.openConnection();
  for (  String headerKey : connection.getHeaderFields().keySet()) {
    if (""String_Node_Str"".equalsIgnoreCase(headerKey)) {
      for (      String cookieField : connection.getHeaderFields().get(headerKey)) {
        for (        String cookieValue : cookieField.split(""String_Node_Str"")) {
          if (cookieValue.matches(""String_Node_Str"")) {
            cookie=cookieValue;
            log.debug(""String_Node_Str"",cookie);
            return;
          }
        }
      }
    }
  }
  log.warn(""String_Node_Str"");
}","private static void setCookie() throws IOException {
  if (YahooFinance.HISTQUOTES2_COOKIE != null && !YahooFinance.HISTQUOTES2_COOKIE.isEmpty()) {
    cookie=YahooFinance.HISTQUOTES2_COOKIE;
    log.debug(""String_Node_Str"",cookie);
    return;
  }
  URL request=new URL(YahooFinance.HISTQUOTES2_SCRAPE_URL);
  RedirectableRequest redirectableRequest=new RedirectableRequest(request,5);
  redirectableRequest.setConnectTimeout(YahooFinance.CONNECTION_TIMEOUT);
  redirectableRequest.setReadTimeout(YahooFinance.CONNECTION_TIMEOUT);
  URLConnection connection=redirectableRequest.openConnection();
  for (  String headerKey : connection.getHeaderFields().keySet()) {
    if (""String_Node_Str"".equalsIgnoreCase(headerKey)) {
      for (      String cookieField : connection.getHeaderFields().get(headerKey)) {
        for (        String cookieValue : cookieField.split(""String_Node_Str"")) {
          if (cookieValue.matches(""String_Node_Str"")) {
            cookie=cookieValue;
            log.debug(""String_Node_Str"",cookie);
            return;
          }
        }
      }
    }
  }
  InputStreamReader is=new InputStreamReader(connection.getInputStream());
  BufferedReader br=new BufferedReader(is);
  String line;
  Pattern patternPostForm=Pattern.compile(""String_Node_Str"");
  Pattern patternInput=Pattern.compile(""String_Node_Str"");
  Matcher matcher;
  Map<String,String> datas=new HashMap<String,String>();
  boolean postFind=false;
  while ((line=br.readLine()) != null) {
    matcher=patternPostForm.matcher(line);
    if (matcher.find()) {
      postFind=true;
    }
    if (postFind) {
      matcher=patternInput.matcher(line);
      if (matcher.find()) {
        String name=matcher.group(3);
        String value=matcher.group(5);
        datas.put(name,value);
      }
    }
  }
  if (datas.size() > 0) {
    datas.put(""String_Node_Str"",YahooFinance.HISTQUOTES2_COOKIE_NAMESPACE);
    datas.put(""String_Node_Str"",YahooFinance.HISTQUOTES2_COOKIE_AGREE);
    datas.put(""String_Node_Str"",YahooFinance.HISTQUOTES2_SCRAPE_URL);
    datas.put(""String_Node_Str"",YahooFinance.HISTQUOTES2_COOKIE_OATH_DONEURL + datas.get(""String_Node_Str"") + ""String_Node_Str""+ datas.get(""String_Node_Str"")+ ""String_Node_Str""+ datas.get(""String_Node_Str""));
    URL requestOath=new URL(YahooFinance.HISTQUOTES2_COOKIE_OATH_URL);
    HttpURLConnection connectionOath=null;
    connectionOath=(HttpURLConnection)requestOath.openConnection();
    connectionOath.setConnectTimeout(YahooFinance.CONNECTION_TIMEOUT);
    connectionOath.setReadTimeout(YahooFinance.CONNECTION_TIMEOUT);
    connectionOath.setRequestMethod(""String_Node_Str"");
    connectionOath.setDoOutput(true);
    connectionOath.setRequestProperty(""String_Node_Str"",connection.getURL().toString());
    connectionOath.setRequestProperty(""String_Node_Str"",YahooFinance.HISTQUOTES2_COOKIE_OATH_HOST);
    connectionOath.setRequestProperty(""String_Node_Str"",YahooFinance.HISTQUOTES2_COOKIE_OATH_ORIGIN);
    connectionOath.setRequestProperty(""String_Node_Str"",""String_Node_Str"");
    StringBuilder params=new StringBuilder(""String_Node_Str"");
    for (    String key : datas.keySet()) {
      if (params.length() == 0) {
        params.append(key);
        params.append(""String_Node_Str"");
        params.append(URLEncoder.encode(datas.get(key),""String_Node_Str""));
      }
 else {
        params.append(""String_Node_Str"");
        params.append(key);
        params.append(""String_Node_Str"");
        params.append(URLEncoder.encode(datas.get(key),""String_Node_Str""));
      }
    }
    log.debug(""String_Node_Str"" + params.toString());
    connectionOath.setRequestProperty(""String_Node_Str"",Integer.toString(params.toString().length()));
    OutputStreamWriter outputStreamWriter=new OutputStreamWriter(connectionOath.getOutputStream());
    outputStreamWriter.write(params.toString());
    outputStreamWriter.flush();
    connectionOath.setInstanceFollowRedirects(true);
    connectionOath.getResponseCode();
  }
  CookieStore cookieJar=((CookieManager)CookieHandler.getDefault()).getCookieStore();
  List<HttpCookie> cookies=cookieJar.getCookies();
  for (  HttpCookie hcookie : cookies) {
    if (hcookie.toString().matches(""String_Node_Str"")) {
      cookie=hcookie.toString();
      log.debug(""String_Node_Str"",cookie);
      return;
    }
  }
  log.warn(""String_Node_Str"");
}"
56756,"public List<HistoricalQuote> getResult() throws IOException {
  List<HistoricalQuote> result=new ArrayList<HistoricalQuote>();
  if (this.from.equals(this.to) || this.from.after(this.to)) {
    YahooFinance.logger.log(Level.WARNING,""String_Node_Str"" + ""String_Node_Str"" + this.from.getTime() + ""String_Node_Str""+ this.to.getTime());
    return result;
  }
  Map<String,String> params=new LinkedHashMap<String,String>();
  params.put(""String_Node_Str"",this.symbol);
  params.put(""String_Node_Str"",String.valueOf(this.from.get(Calendar.MONTH)));
  params.put(""String_Node_Str"",String.valueOf(this.from.get(Calendar.DAY_OF_MONTH)));
  params.put(""String_Node_Str"",String.valueOf(this.from.get(Calendar.YEAR)));
  params.put(""String_Node_Str"",String.valueOf(this.to.get(Calendar.MONTH)));
  params.put(""String_Node_Str"",String.valueOf(this.to.get(Calendar.DAY_OF_MONTH)));
  params.put(""String_Node_Str"",String.valueOf(this.to.get(Calendar.YEAR)));
  params.put(""String_Node_Str"",this.interval.getTag());
  params.put(""String_Node_Str"",""String_Node_Str"");
  String url=YahooFinance.HISTQUOTES_BASE_URL + ""String_Node_Str"" + Utils.getURLParameters(params);
  YahooFinance.logger.log(Level.INFO,(""String_Node_Str"" + url));
  URL request=new URL(url);
  URLConnection connection=request.openConnection();
  connection.setConnectTimeout(YahooFinance.CONNECTION_TIMEOUT);
  connection.setReadTimeout(YahooFinance.CONNECTION_TIMEOUT);
  InputStreamReader is=new InputStreamReader(connection.getInputStream());
  BufferedReader br=new BufferedReader(is);
  br.readLine();
  for (String line=br.readLine(); line != null; line=br.readLine()) {
    YahooFinance.logger.log(Level.INFO,(""String_Node_Str"" + Utils.unescape(line)));
    HistoricalQuote quote=this.parseCSVLine(line);
    result.add(quote);
  }
  return result;
}","public List<HistoricalQuote> getResult() throws IOException {
  List<HistoricalQuote> result=new ArrayList<HistoricalQuote>();
  if (this.from.after(this.to)) {
    YahooFinance.logger.log(Level.WARNING,""String_Node_Str"" + ""String_Node_Str"" + this.from.getTime() + ""String_Node_Str""+ this.to.getTime());
    return result;
  }
  Map<String,String> params=new LinkedHashMap<String,String>();
  params.put(""String_Node_Str"",this.symbol);
  params.put(""String_Node_Str"",String.valueOf(this.from.get(Calendar.MONTH)));
  params.put(""String_Node_Str"",String.valueOf(this.from.get(Calendar.DAY_OF_MONTH)));
  params.put(""String_Node_Str"",String.valueOf(this.from.get(Calendar.YEAR)));
  params.put(""String_Node_Str"",String.valueOf(this.to.get(Calendar.MONTH)));
  params.put(""String_Node_Str"",String.valueOf(this.to.get(Calendar.DAY_OF_MONTH)));
  params.put(""String_Node_Str"",String.valueOf(this.to.get(Calendar.YEAR)));
  params.put(""String_Node_Str"",this.interval.getTag());
  params.put(""String_Node_Str"",""String_Node_Str"");
  String url=YahooFinance.HISTQUOTES_BASE_URL + ""String_Node_Str"" + Utils.getURLParameters(params);
  YahooFinance.logger.log(Level.INFO,(""String_Node_Str"" + url));
  URL request=new URL(url);
  URLConnection connection=request.openConnection();
  connection.setConnectTimeout(YahooFinance.CONNECTION_TIMEOUT);
  connection.setReadTimeout(YahooFinance.CONNECTION_TIMEOUT);
  InputStreamReader is=new InputStreamReader(connection.getInputStream());
  BufferedReader br=new BufferedReader(is);
  br.readLine();
  for (String line=br.readLine(); line != null; line=br.readLine()) {
    YahooFinance.logger.log(Level.INFO,(""String_Node_Str"" + Utils.unescape(line)));
    HistoricalQuote quote=this.parseCSVLine(line);
    result.add(quote);
  }
  return result;
}"
56757,"public static BigDecimal getBigDecimal(String data){
  BigDecimal result=BigDecimal.ZERO;
  if (!Utils.isParseable(data)) {
    return result;
  }
  try {
    data=Utils.cleanNumberString(data);
    char lastChar=data.charAt(data.length() - 1);
    BigDecimal multiplier=BigDecimal.ONE;
switch (lastChar) {
case 'B':
      data=data.substring(0,data.length() - 1);
    multiplier=new BigDecimal(1000000000);
  break;
case 'M':
data=data.substring(0,data.length() - 1);
multiplier=new BigDecimal(1000000);
break;
case 'K':
data=data.substring(0,data.length() - 1);
multiplier=new BigDecimal(1000);
break;
}
result=new BigDecimal(data).multiply(multiplier);
}
 catch (NumberFormatException e) {
YahooFinance.logger.log(Level.INFO,""String_Node_Str"" + data,e);
}
return result;
}","public static BigDecimal getBigDecimal(String data){
  BigDecimal result=BigDecimal.ZERO;
  if (!Utils.isParseable(data)) {
    return result;
  }
  try {
    data=Utils.cleanNumberString(data);
    char lastChar=data.charAt(data.length() - 1);
    BigDecimal multiplier=BigDecimal.ONE;
switch (lastChar) {
case 'B':
      data=data.substring(0,data.length() - 1);
    multiplier=BILLION;
  break;
case 'M':
data=data.substring(0,data.length() - 1);
multiplier=MILLION;
break;
case 'K':
data=data.substring(0,data.length() - 1);
multiplier=THOUSAND;
break;
}
result=new BigDecimal(data).multiply(multiplier);
}
 catch (NumberFormatException e) {
YahooFinance.logger.log(Level.INFO,""String_Node_Str"" + data,e);
}
return result;
}"
56758,"public static double getPercent(double numerator,double denominator){
  if (denominator == 0) {
    return 0;
  }
  return numerator / denominator;
}","public static double getPercent(double numerator,double denominator){
  if (denominator == 0) {
    return 0;
  }
  return (numerator / denominator) * 100;
}"
56759,"private Object loadProperty(String stringValue){
  Object boundValue;
  try {
    boundValue=Long.parseLong(stringValue);
  }
 catch (  NumberFormatException ex1) {
    try {
      boundValue=Double.parseDouble(stringValue);
    }
 catch (    NumberFormatException ex2) {
      try {
        boundValue=Boolean.parseBoolean(stringValue);
      }
 catch (      NumberFormatException ex3) {
        boundValue=stringValue;
      }
    }
  }
  return boundValue;
}","private Object loadProperty(String stringValue){
  Object boundValue=stringValue;
  try {
    boundValue=Long.parseLong(stringValue);
  }
 catch (  NumberFormatException ex1) {
    try {
      boundValue=Double.parseDouble(stringValue);
    }
 catch (    NumberFormatException ex2) {
      if (stringValue.equalsIgnoreCase(""String_Node_Str"")) {
        boundValue=Boolean.TRUE;
      }
 else       if (stringValue.equalsIgnoreCase(""String_Node_Str"")) {
        boundValue=Boolean.FALSE;
      }
    }
  }
  return boundValue;
}"
56760,"public static String unescape(CharSequence escaped){
switch (escaped.charAt(0)) {
case '""':
    return ""String_Node_Str"";
case '\\':
  return ""String_Node_Str"";
case '/':
return ""String_Node_Str"";
case 'b':
return ""String_Node_Str"";
case 'n':
return ""String_Node_Str"";
case 'r':
return ""String_Node_Str"";
case 't':
return ""String_Node_Str"";
case 'f':
return ""String_Node_Str"";
case 'u':
return Character.toString((char)parseInt(escaped.subSequence(2,escaped.length()).toString(),16));
default :
throw new UnsupportedOperationException();
}
}","public static String unescape(CharSequence escaped){
switch (escaped.charAt(0)) {
case '""':
    return ""String_Node_Str"";
case '\\':
  return ""String_Node_Str"";
case '/':
return ""String_Node_Str"";
case 'b':
return ""String_Node_Str"";
case 'n':
return ""String_Node_Str"";
case 'r':
return ""String_Node_Str"";
case 't':
return ""String_Node_Str"";
case 'f':
return ""String_Node_Str"";
case 'u':
return Character.toString((char)parseInt(escaped.subSequence(1,escaped.length()).toString(),16));
default :
throw new UnsupportedOperationException();
}
}"
56761,"@Test public void canHandleEscapedCharacters() throws Exception {
  assertThat(Grammar.ESCAPED_CHARACTER.parse(""String_Node_Str"").value(),is(""String_Node_Str""));
  assertThat(Grammar.ESCAPED_CHARACTER.parse(""String_Node_Str"").value(),is(""String_Node_Str""));
  assertThat(Grammar.ESCAPED_CHARACTER.parse(""String_Node_Str"").value(),is(""String_Node_Str""));
  assertThat(Grammar.ESCAPED_CHARACTER.parse(""String_Node_Str"").value(),is(""String_Node_Str""));
  assertThat(Grammar.ESCAPED_CHARACTER.parse(""String_Node_Str"").value(),is(""String_Node_Str""));
  assertThat(Grammar.ESCAPED_CHARACTER.parse(""String_Node_Str"").value(),is(""String_Node_Str""));
  assertThat(Grammar.ESCAPED_CHARACTER.parse(""String_Node_Str"").value(),is(""String_Node_Str""));
  assertThat(Grammar.ESCAPED_CHARACTER.parse(""String_Node_Str"").value(),is(""String_Node_Str""));
  assertThat(Grammar.ESCAPED_CHARACTER.parse(""String_Node_Str"").value(),is(""String_Node_Str""));
  assertThat(Grammar.ESCAPED_CHARACTER.parse(""String_Node_Str"").failure(),is(true));
}","@Test public void canHandleEscapedCharacters() throws Exception {
  assertThat(Grammar.ESCAPED_CHARACTER.parse(""String_Node_Str"").value(),is(""String_Node_Str""));
  assertThat(Grammar.ESCAPED_CHARACTER.parse(""String_Node_Str"").value(),is(""String_Node_Str""));
  assertThat(Grammar.ESCAPED_CHARACTER.parse(""String_Node_Str"").value(),is(""String_Node_Str""));
  assertThat(Grammar.ESCAPED_CHARACTER.parse(""String_Node_Str"").value(),is(""String_Node_Str""));
  assertThat(Grammar.ESCAPED_CHARACTER.parse(""String_Node_Str"").value(),is(""String_Node_Str""));
  assertThat(Grammar.ESCAPED_CHARACTER.parse(""String_Node_Str"").value(),is(""String_Node_Str""));
  assertThat(Grammar.ESCAPED_CHARACTER.parse(""String_Node_Str"").value(),is(""String_Node_Str""));
  assertThat(Grammar.ESCAPED_CHARACTER.parse(""String_Node_Str"").value(),is(""String_Node_Str""));
  assertThat(Grammar.ESCAPED_CHARACTER.parse(""String_Node_Str"").failure(),is(true));
}"
56762,"public Templates extension(String value){
  return new Templates((s,r) -> missing.apply(s + ""String_Node_Str"" + value,r));
}","public Templates extension(String value){
  return new Templates((s,r) -> missing.apply(s + ""String_Node_Str"" + value,r),renderers,implicits);
}"
56763,"public static Templates templates(Function2<? super String,? super Renderers,? extends Renderer<?>> missing){
  return new Templates(missing);
}","public static Templates templates(Function2<? super String,? super Renderers,? extends Renderer<?>> missing){
  return new Templates(missing,new ConcurrentHashMap<>(),CompositeRenderer.compositeRenderer());
}"
56764,"public Templates logger(Appendable logger){
  return new Templates((s,r) -> {
    try {
      return missing.apply(s,r);
    }
 catch (    Exception e) {
      logger.append(format(""String_Node_Str"",s,e.getMessage()));
      return (instance,appendable) -> appendable;
    }
  }
);
}","public Templates logger(Appendable logger){
  return new Templates((s,r) -> {
    try {
      return missing.apply(s,r);
    }
 catch (    Exception e) {
      logger.append(format(""String_Node_Str"",s,e.getMessage()));
      return (instance,appendable) -> appendable;
    }
  }
,renderers,implicits);
}"
56765,"private Templates(Function2<? super String,? super Renderers,? extends Renderer<?>> missing){
  this.missing=missing;
}","public Templates(Function2<? super String,? super Renderers,? extends Renderer<?>> missing,ConcurrentMap<String,Renderer<Object>> renderers,CompositeRenderer implicits){
  this.missing=missing;
  this.renderers=renderers;
  this.implicits=implicits;
}"
56766,"@Test public void doesNotThrowWhenASubTemplateIsNotFoundButReturnsEmptyStringAndLogs() throws Exception {
  StringBuilder builder=new StringBuilder();
  Templates templates=templates(getClass()).logger(builder).extension(""String_Node_Str"").add(""String_Node_Str"",ignore -> ""String_Node_Str"");
  String result=templates.get(""String_Node_Str"").render(map());
  assertThat(result,is(""String_Node_Str""));
  String log=builder.toString();
  assertThat(log,startsWith(""String_Node_Str""));
  assertThat(log,not(contains(""String_Node_Str"")));
}","@Test public void doesNotThrowWhenASubTemplateIsNotFoundButReturnsEmptyStringAndLogs() throws Exception {
  StringBuilder builder=new StringBuilder();
  Templates templates=templates(getClass()).add(""String_Node_Str"",ignore -> ""String_Node_Str"").logger(builder);
  String result=templates.get(""String_Node_Str"").render(map());
  assertThat(result,is(""String_Node_Str""));
  String log=builder.toString();
  assertThat(log,startsWith(""String_Node_Str""));
  assertThat(log,not(contains(""String_Node_Str"")));
}"
56767,"static <T>FirstOptionTransducer<T> firstOptionTransducer(){
  AtomicBoolean complete=new AtomicBoolean(false);
  return receiver -> Receiver.receiver(receiver,item -> {
    receiver.next(Option.some(item));
    receiver.finish();
    return Stop;
  }
,() -> {
    if (!complete.get())     receiver.next(Option.none());
    receiver.finish();
  }
);
}","static <T>FirstOptionTransducer<T> firstOptionTransducer(){
  AtomicBoolean complete=new AtomicBoolean(false);
  return receiver -> Receiver.receiver(receiver,item -> {
    receiver.next(Option.some(item));
    receiver.finish();
    complete.set(true);
    return Stop;
  }
,() -> {
    if (!complete.get()) {
      receiver.next(Option.none());
      receiver.finish();
    }
  }
);
}"
56768,"@Override default Receiver<T> apply(Receiver<Group<K,T>> receiver){
  return new Receiver<T>(){
    private final Map<K,Group<K,T>> groups=new ConcurrentHashMap<>();
    @Override public State start(){
      receivers().each(Receiver::start);
      return receiver.start();
    }
    @Override public State next(    T item){
      groups.computeIfAbsent(keyExtractor().apply(item),k -> {
        Group<K,T> group=new Group<>(k);
        receiver.next(group);
        return group;
      }
).next(item);
      return State.Continue;
    }
    @Override public void error(    Throwable throwable){
      receivers().each(o -> o.error(throwable));
      receiver.error(throwable);
    }
    @Override public void finish(){
      receivers().each(Receiver::finish);
      receiver.finish();
    }
    private Sequence<Receiver<T>> receivers(){
      return Sequences.sequence(groups.values());
    }
  }
;
}","@Override default Receiver<T> apply(Receiver<Group<K,T>> receiver){
  return new Receiver<T>(){
    private final Map<K,Group<K,T>> groups=new ConcurrentHashMap<>();
    @Override public State start(){
      receivers().each(Receiver::start);
      return receiver.start();
    }
    @Override public State next(    T item){
      groups.computeIfAbsent(keyExtractor().apply(item),k -> {
        Group<K,T> group=new Group<>(k);
        receiver.next(group);
        return group;
      }
).next(item);
      return State.Continue;
    }
    @Override public State error(    Throwable throwable){
      receivers().each(o -> o.error(throwable));
      return receiver.error(throwable);
    }
    @Override public void finish(){
      receivers().each(Receiver::finish);
      receiver.finish();
    }
    private Sequence<Receiver<T>> receivers(){
      return Sequences.sequence(groups.values());
    }
  }
;
}"
56769,"@Override public void error(Throwable throwable){
  receivers().each(o -> o.error(throwable));
  receiver.error(throwable);
}","@Override public State error(Throwable throwable){
  receivers().each(o -> o.error(throwable));
  return receiver.error(throwable);
}"
56770,"@Override public void error(Throwable throwable){
  for (  Receiver<T> receiver : receivers) {
    receiver.error(throwable);
  }
}","@Override public State error(Throwable throwable){
  for (  Receiver<T> receiver : receivers) {
    if (receiver.error(throwable).equals(Stop))     receivers.remove(receiver);
  }
  return receivers.isEmpty() ? Stop : Continue;
}"
56771,"@Override default void error(Throwable throwable){
  delegate().error(throwable);
}","@Override default State error(Throwable throwable){
  return delegate().error(throwable);
}"
56772,"@Override public void error(Throwable throwable){
  error.set(throwable);
}","@Override public State error(Throwable throwable){
  error.set(throwable);
  return State.Stop;
}"
56773,"static <T>LastTransducer<T> lastTransducer(){
  AtomicReference<T> reference=new AtomicReference<>();
  return receiver -> Receiver.receiver(receiver,item -> {
    reference.set(item);
    return Continue;
  }
,() -> {
    T t=reference.get();
    if (t != null) {
      receiver.next(t);
      receiver.finish();
    }
  }
);
}","static <T>LastTransducer<T> lastTransducer(){
  AtomicReference<T> reference=new AtomicReference<>();
  return receiver -> Receiver.receiver(receiver,item -> {
    reference.set(item);
    return Continue;
  }
,() -> {
    T t=reference.get();
    if (t != null) {
      receiver.next(t);
    }
 else {
      receiver.error(new NoSuchElementException());
    }
    receiver.finish();
  }
);
}"
56774,"public static Sequence<Number> range(final Number start,final Number end,final Number step){
  if (lessThan(end,start))   return iterate(add(step),start).takeWhile(greaterThanOrEqualTo(end));
  return iterate(add(step),start).takeWhile(lessThanOrEqualTo(end));
}","public static Sequence<Number> range(final Number start,final Number end,final Number step){
  Number absoluteStep=Numbers.absolute(step);
  if (lessThan(end,start))   return iterate(subtract(absoluteStep),start).takeWhile(greaterThanOrEqualTo(end));
  return iterate(add(absoluteStep),start).takeWhile(lessThanOrEqualTo(end));
}"
56775,"private CompositeRenderer create(String name){
  return compositeRenderer(parent.get(name));
}","private CompositeRenderer create(String name){
  return compositeRenderer(Renderer.lazy(() -> parent.get(name)));
}"
56776,"private Node children(Node parent) throws XMLStreamException {
  while (reader.hasNext()) {
    XMLEvent event=reader.nextEvent();
    if (event instanceof EndElement)     return parent;
    if (event instanceof StartElement)     children(child(parent,(StartElement)event));
  }
  return parent;
}","private Node children(Node parent) throws XMLStreamException {
  while (reader.hasNext()) {
    XMLEvent event=reader.nextEvent();
    if (event instanceof EndElement)     return parent;
    if (event instanceof CharacterEvent) {
      parent.setTextContent(((CharacterEvent)event).getData());
      return parent;
    }
    if (event instanceof StartElement)     children(child(parent,(StartElement)event));
  }
  return parent;
}"
56777,"private Node children(Node parent) throws XMLStreamException {
  while (reader.hasNext()) {
    XMLEvent event=reader.nextEvent();
    if (event instanceof EndElement)     return parent;
    if (event instanceof CharacterEvent) {
      parent.setTextContent(((CharacterEvent)event).getData());
      return parent;
    }
    if (event instanceof StartElement)     children(child(parent,(StartElement)event));
  }
  return parent;
}","private Node children(Node parent) throws XMLStreamException {
  while (reader.hasNext()) {
    XMLEvent event=reader.nextEvent();
    if (event instanceof EndElement)     return parent;
    if (event instanceof Characters)     parent.appendChild(parent.getOwnerDocument().createTextNode(((Characters)event).getData()));
    if (event instanceof StartElement)     children(child(parent,(StartElement)event));
  }
  return parent;
}"
56778,"public static Sequence<String> lines(Reader reader){
  return repeat(readLine(new BufferedReader(reader))).takeWhile(notNullValue(String.class)).memorise();
}","public static Sequence<String> lines(Reader reader){
  return Streams.lines(reader).memorise();
}"
56779,"public static Function<String> readLine(final BufferedReader reader){
  return new Function<String>(){
    public String call() throws Exception {
      String result=reader.readLine();
      if (result == null) {
        reader.close();
      }
      return result;
    }
  }
;
}","public static Function<String> readLine(final BufferedReader reader){
  return Streams.readLine(reader);
}"
56780,"public static <T>Sequence<Sequence<T>> windowed(final Iterable<? extends T> sequence,int size){
  return internalWindowed(memorise(sequence),size).toSequence();
}","public static <T>Sequence<Sequence<T>> windowed(final Iterable<? extends T> sequence,int size){
  return new Sequence<Sequence<T>>(){
    @Override public Iterator<Sequence<T>> iterator(){
      return Iterators.<T>windowed(sequence.iterator(),size);
    }
  }
;
}"
56781,"public static String toString(Iterable<? extends Pair<String,String>> pairs){
  StringBuilder builder=new StringBuilder();
  boolean first=true;
  for (  Pair<String,String> pair : pairs) {
    if (first) {
      first=false;
    }
 else {
      builder.append(""String_Node_Str"");
    }
    builder.append(encode(pair.first())).append(""String_Node_Str"").append(encode(pair.second()));
  }
  return builder.toString();
}","public static String toString(Iterable<? extends Pair<String,String>> pairs){
  return sequence(pairs).map(new Mapper<Pair<String,String>,String>(){
    @Override public String call(    Pair<String,String> pair) throws Exception {
      if (pair.second() == null)       return encode(pair.first());
      return encode(pair.first()) + ""String_Node_Str"" + encode(pair.second());
    }
  }
).toString(""String_Node_Str"");
}"
56782,"public static List<Pair<String,String>> parse(String value){
  List<Pair<String,String>> result=new ArrayList<Pair<String,String>>();
  if (Strings.isEmpty(value)) {
    return result;
  }
  for (  String pair : value.split(""String_Node_Str"")) {
    String[] nameValue=pair.split(""String_Node_Str"");
    if (nameValue.length == 1) {
      result.add(pair(decode(nameValue[0]),""String_Node_Str""));
    }
    if (nameValue.length == 2) {
      result.add(pair(decode(nameValue[0]),decode(nameValue[1])));
    }
  }
  return result;
}","public static List<Pair<String,String>> parse(String value){
  List<Pair<String,String>> result=new ArrayList<Pair<String,String>>();
  if (Strings.isEmpty(value)) {
    return result;
  }
  for (  String pair : value.split(""String_Node_Str"")) {
    if (!pair.contains(""String_Node_Str"")) {
      result.add(Pair.<String,String>pair(decode(pair),null));
      continue;
    }
    String[] nameValue=pair.split(""String_Node_Str"");
    if (nameValue.length == 1) {
      result.add(Pair.<String,String>pair(decode(nameValue[0]),""String_Node_Str""));
      continue;
    }
    if (nameValue.length == 2) {
      result.add(pair(decode(nameValue[0]),decode(nameValue[1])));
    }
  }
  return result;
}"
56783,"public Uri dropHost(){
  return dropAuthority();
}","public Uri dropHost(){
  return host(null);
}"
56784,"public static Mapper<Uri,Uri> host(final String newHost){
  return new Mapper<Uri,Uri>(){
    @Override public Uri call(    Uri uri) throws Exception {
      return uri.host(newHost);
    }
  }
;
}","Authority host(String value){
  return authority(userInfo,value,port);
}"
56785,"public Uri authority(String value){
  return new Uri(scheme,value,path,query,fragment);
}","static Authority authority(String userInfo,String host,int port){
  return new Authority(userInfo,host,port);
}"
56786,"@Override public String toString(){
  if (JAR_SCHEME.equals(scheme)) {
    return String.format(""String_Node_Str"",JAR_SCHEME,authority,path);
  }
  return standardToString();
}","@Override public String toString(){
  if (isEmpty(host))   return null;
  StringBuilder builder=new StringBuilder();
  if (!isEmpty(userInfo)) {
    builder.append(userInfo).append(""String_Node_Str"");
  }
  builder.append(host);
  if (port != -1) {
    builder.append(""String_Node_Str"").append(port);
  }
  return builder.toString();
}"
56787,"@Override public T next(){
  if (!hasNext())   throw new NoSuchElementException();
  if (lastDirection.contains(Direction.next))   zipper.nextOption().each(update);
  lastDirection=some(Direction.next);
  return zipper.value();
}","@Override public T next(){
  if (lastDirection.contains(Direction.next))   zipper=zipper.next();
  lastDirection=some(Direction.next);
  return zipper.value();
}"
56788,"@Override public T previous(){
  if (!hasPrevious())   throw new NoSuchElementException();
  if (lastDirection.contains(Direction.previous))   zipper.previousOption().each(update);
  lastDirection=some(Direction.previous);
  return zipper.value();
}","@Override public T previous(){
  if (lastDirection.contains(Direction.previous))   zipper=zipper.previous();
  lastDirection=some(Direction.previous);
  return zipper.value();
}"
56789,"@Override public int nextIndex(){
  throw new UnsupportedOperationException();
}","@Override public int nextIndex(){
  return zipper.index() + (lastDirection.contains(Direction.next) ? 1 : 0);
}"
56790,"@Override public int previousIndex(){
  throw new UnsupportedOperationException();
}","@Override public int previousIndex(){
  return zipper.index() - (lastDirection.contains(Direction.next) ? 0 : 1);
}"
56791,"@Test public void canGoBackwardsAndForwards() throws Exception {
  PersistentList<Character> values=list('a','b','c','d','e');
  ListIterator<Character> listIterator=new ZipperListIterator<Character>(zipper(values));
  assertThat(listIterator.next(),is('a'));
  assertThat(listIterator.next(),is('b'));
  assertThat(listIterator.next(),is('c'));
  assertThat(listIterator.previous(),is('c'));
  assertThat(listIterator.next(),is('c'));
  assertThat(listIterator.previous(),is('c'));
  assertThat(listIterator.previous(),is('b'));
  assertThat(listIterator.previous(),is('a'));
}","@Test public void canGoBackwardsAndForwards() throws Exception {
  PersistentList<Character> values=list('a','b','c');
  ListIterator<Character> listIterator=new ZipperListIterator<Character>(zipper(values));
  assertThat(listIterator.next(),is('a'));
  assertThat(listIterator.next(),is('b'));
  assertThat(listIterator.next(),is('c'));
  assertThat(listIterator.previous(),is('c'));
  assertThat(listIterator.next(),is('c'));
  assertThat(listIterator.previous(),is('c'));
  assertThat(listIterator.previous(),is('b'));
  assertThat(listIterator.previous(),is('a'));
}"
56792,"@Test public void canGoBackwards() throws Exception {
  PersistentList<Character> values=list('a','b','c','d','e');
  Iterator<Character> expected=values.reverse().iterator();
  ListIterator<Character> listIterator=new ZipperListIterator<Character>(zipper(values).last());
  for (int i=0; i < values.size(); i++) {
    System.out.println(""String_Node_Str"" + i);
    assertThat(listIterator.hasPrevious(),is(expected.hasNext()));
    assertThat(listIterator.previous(),is(expected.next()));
  }
  assertThat(listIterator.hasPrevious(),is(expected.hasNext()));
}","@Test public void canGoBackwards() throws Exception {
  PersistentList<Character> values=list('a','b','c','d','e');
  Iterator<Character> expected=values.reverse().iterator();
  ListIterator<Character> listIterator=new ZipperListIterator<Character>(zipper(values).last());
  for (int i=0; i < values.size(); i++) {
    assertThat(listIterator.hasPrevious(),is(expected.hasNext()));
    assertThat(listIterator.previous(),is(expected.next()));
  }
  assertThat(listIterator.hasPrevious(),is(expected.hasNext()));
}"
56793,"@Test public void canGoForward() throws Exception {
  PersistentList<Character> values=list('a','b','c','d','e');
  Iterator<Character> expected=values.iterator();
  ListIterator<Character> listIterator=new ZipperListIterator<Character>(zipper(values));
  for (int i=0; i < values.size(); i++) {
    System.out.println(""String_Node_Str"" + i);
    assertThat(listIterator.hasNext(),is(expected.hasNext()));
    assertThat(listIterator.next(),is(expected.next()));
  }
  assertThat(listIterator.hasNext(),is(expected.hasNext()));
}","@Test public void canGoForward() throws Exception {
  PersistentList<Character> values=list('a','b','c','d','e');
  Iterator<Character> expected=values.iterator();
  ListIterator<Character> listIterator=new ZipperListIterator<Character>(zipper(values));
  for (int i=0; i < values.size(); i++) {
    assertThat(listIterator.hasNext(),is(expected.hasNext()));
    assertThat(listIterator.next(),is(expected.next()));
  }
  assertThat(listIterator.hasNext(),is(expected.hasNext()));
}"
56794,"private static Operators<? extends Number> internalOperatorsFor(Class<? extends Number> numberClass){
  if (numberClass == Integer.class)   return IntegerOperators.Instance;
  if (numberClass == Long.class)   return LongOperators.Instance;
  if (numberClass == BigInteger.class)   return BigIntegerOperators.Instance;
  if (numberClass == BigDecimal.class)   return BigDecimalOperators.Instance;
  if (numberClass == Ratio.class)   return RatioOperators.Instance;
  if (numberClass == Float.class)   return FloatOperators.Instance;
  if (numberClass == Double.class)   return DoubleOperators.Instance;
  if (numberClass == Double.class)   return DoubleOperators.Instance;
  throw new UnsupportedOperationException(""String_Node_Str"" + numberClass);
}","private static Operators<? extends Number> internalOperatorsFor(Class<? extends Number> numberClass){
  if (numberClass == Short.class)   return ShortOperators.Instance;
  if (numberClass == Integer.class)   return IntegerOperators.Instance;
  if (numberClass == Long.class)   return LongOperators.Instance;
  if (numberClass == BigInteger.class)   return BigIntegerOperators.Instance;
  if (numberClass == BigDecimal.class)   return BigDecimalOperators.Instance;
  if (numberClass == Ratio.class)   return RatioOperators.Instance;
  if (numberClass == Float.class)   return FloatOperators.Instance;
  if (numberClass == Double.class)   return DoubleOperators.Instance;
  throw new UnsupportedOperationException(""String_Node_Str"" + numberClass);
}"
56795,"private void init(boolean zeroBytes) throws IOException {
  if (init) {
    ZipEntry entry=new ZipEntry(filename);
    entry.setTime(modified.getTime());
    if (zeroBytes) {
      entry.setMethod(ZipEntry.STORED);
      entry.setSize(0);
      entry.setCrc(0);
    }
    this.out.putNextEntry(entry);
  }
}","private void init(boolean zeroBytes) throws IOException {
  if (init) {
    init=false;
    ZipEntry entry=new ZipEntry(filename);
    entry.setTime(modified.getTime());
    if (zeroBytes) {
      entry.setMethod(ZipEntry.STORED);
      entry.setSize(0);
      entry.setCrc(0);
    }
    this.out.putNextEntry(entry);
  }
}"
56796,"@Test public void shouldFailIfAllValidatorsFail(){
  Validator<String> validator=validateThat(is(""String_Node_Str"")).or(validateThat(is(""String_Node_Str""))).assigningFailuresTo(""String_Node_Str"");
  assertThat(validator.validate(""String_Node_Str"").messages(""String_Node_Str""),hasExactly(AnyOfValidator.DEFAULT_MESSAGE));
}","@Test public void shouldFailIfAllValidatorsFail(){
  LogicalValidator<String> validator=validateThat(is(""String_Node_Str"")).or(validateThat(is(""String_Node_Str""))).assigningFailuresTo(""String_Node_Str"");
  assertThat(validator.validate(""String_Node_Str"").messages(""String_Node_Str""),hasExactly(AnyOfValidator.DEFAULT_MESSAGE));
}"
56797,"@Test public void shouldPassIfAnyValidatorPasses(){
  Validator<String> validator=validateThat(is(""String_Node_Str"")).or(validateThat(is(""String_Node_Str""))).assigningFailuresTo(""String_Node_Str"");
  assertThat(validator.validate(""String_Node_Str"").messages(""String_Node_Str""),isEmpty(String.class));
  assertThat(validator.validate(""String_Node_Str"").messages(""String_Node_Str""),isEmpty(String.class));
}","@Test public void shouldPassIfAnyValidatorPasses(){
  LogicalValidator<String> validator=validateThat(is(""String_Node_Str"")).or(validateThat(is(""String_Node_Str""))).assigningFailuresTo(""String_Node_Str"");
  assertThat(validator.validate(""String_Node_Str"").messages(""String_Node_Str""),isEmpty(String.class));
  assertThat(validator.validate(""String_Node_Str"").messages(""String_Node_Str""),isEmpty(String.class));
}"
56798,"@Test public void shouldFailIfAllValidatorsFail(){
  LogicalValidator<String> validator=validateThat(is(""String_Node_Str"")).or(validateThat(is(""String_Node_Str""))).assigningFailuresTo(""String_Node_Str"");
  assertThat(validator.validate(""String_Node_Str"").messages(""String_Node_Str""),hasExactly(AnyOfValidator.DEFAULT_MESSAGE));
}","@Test public void shouldFailIfAllValidatorsFail(){
  LogicalValidator<String> validator=validateThat(is(""String_Node_Str"")).or(validateThat(is(""String_Node_Str""))).assigningFailuresTo(""String_Node_Str"").castValidator();
  assertThat(validator.validate(""String_Node_Str"").messages(""String_Node_Str""),hasExactly(AnyOfValidator.DEFAULT_MESSAGE));
}"
56799,"@Test public void shouldPassIfAnyValidatorPasses(){
  LogicalValidator<String> validator=validateThat(is(""String_Node_Str"")).or(validateThat(is(""String_Node_Str""))).assigningFailuresTo(""String_Node_Str"");
  assertThat(validator.validate(""String_Node_Str"").messages(""String_Node_Str""),isEmpty(String.class));
  assertThat(validator.validate(""String_Node_Str"").messages(""String_Node_Str""),isEmpty(String.class));
}","@Test public void shouldPassIfAnyValidatorPasses(){
  LogicalValidator<String> validator=validateThat(is(""String_Node_Str"")).or(validateThat(is(""String_Node_Str""))).assigningFailuresTo(""String_Node_Str"").castValidator();
  assertThat(validator.validate(""String_Node_Str"").messages(""String_Node_Str""),isEmpty(String.class));
  assertThat(validator.validate(""String_Node_Str"").messages(""String_Node_Str""),isEmpty(String.class));
}"
56800,"private Integer daysBetween(Date start,Date end){
  return abs((int)(end.getTime() - start.getTime())) / (24 * 60 * 60* 1000);
}","private int daysBetween(Date start,Date end){
  return (int)abs((end.getTime() - start.getTime()) / 1000);
}"
56801,"@Override protected Date getNext() throws Exception {
  return stripTime(Days.add(bounds.first(),between(0,daysBetween(bounds.first(),bounds.second())).head()));
}","@Override protected Date getNext() throws Exception {
  return Seconds.add(bounds.first(),between(0,daysBetween(bounds.first(),bounds.second())).head());
}"
56802,"public static Sequence<Date> between(final Date start,final Date end){
  final Pair<Date,Date> bounds=bounds(start,end);
  return Sequences.forwardOnly(new StatefulIterator<Date>(){
    @Override protected Date getNext() throws Exception {
      return stripTime(Days.add(bounds.first(),between(0,daysBetween(bounds.first(),bounds.second())).head()));
    }
    private Integer daysBetween(    Date start,    Date end){
      return abs((int)(end.getTime() - start.getTime())) / (24 * 60 * 60* 1000);
    }
  }
);
}","public static Sequence<Date> between(final Date start,final Date end){
  final Pair<Date,Date> bounds=bounds(start,end);
  return Sequences.forwardOnly(new StatefulIterator<Date>(){
    @Override protected Date getNext() throws Exception {
      return Seconds.add(bounds.first(),between(0,daysBetween(bounds.first(),bounds.second())).head());
    }
    private int daysBetween(    Date start,    Date end){
      return (int)abs((end.getTime() - start.getTime()) / 1000);
    }
  }
);
}"
56803,"@Test public void betweenDates(){
  Date yesterday=Days.subtract(NOW,1);
  Date tomorrow=Days.add(NOW,1);
  assertThat(Randoms.between(yesterday,tomorrow).take(TESTS),matcher(Predicates.<Date>forAll(between(yesterday,tomorrow))));
  assertThat(Randoms.between(tomorrow,yesterday).take(TESTS),matcher(Predicates.<Date>forAll(between(yesterday,tomorrow))));
  assertThat(Randoms.between(NOW,NOW).take(TESTS),matcher(Predicates.<Date>forAll(between(NOW,NOW))));
}","@Test public void betweenDates(){
  Date yesterday=Days.subtract(NOW,1);
  Date theFuture=Dates.MAX_VALUE;
  assertThat(Randoms.between(yesterday,theFuture).take(TESTS),matcher(Predicates.<Date>forAll(between(yesterday,theFuture))));
  assertThat(Randoms.between(theFuture,yesterday).take(TESTS),matcher(Predicates.<Date>forAll(between(yesterday,theFuture))));
  assertThat(Randoms.between(NOW,NOW).take(TESTS),matcher(Predicates.<Date>forAll(between(NOW,NOW))));
}"
56804,"@Override public Number identity(){
  return weighted(0);
}","@Override public Number identity(){
  return weighted(0,0);
}"
56805,"public static Weighted weighted(Number number){
  if (number instanceof Weighted)   return (Weighted)number;
  return weighted(number,isZero(number) ? 0 : 1);
}","public static Weighted weighted(Number number){
  if (number instanceof Weighted)   return (Weighted)number;
  return weighted(number,1);
}"
56806,"@Test public void supportsAverage() throws Exception {
  assertThat(numbers(1,2,3,4).reduce(average),NumberMatcher.is(divide(5,2)));
  assertThat(numbers(1,2,3).reduce(average),NumberMatcher.is(2));
  assertThat(numbers(1,2).reduce(average),NumberMatcher.is(1.5));
  assertThat(numbers(1).reduce(average),NumberMatcher.is(1));
  assertThat(numbers().reduce(average),NumberMatcher.is(0));
}","@Test public void supportsAverage() throws Exception {
  assertThat(numbers(1,2,3,4).reduce(average),NumberMatcher.is(divide(5,2)));
  assertThat(numbers(1,2,3).reduce(average),NumberMatcher.is(2));
  assertThat(numbers(1,2).reduce(average),NumberMatcher.is(1.5));
  assertThat(numbers(1,0).reduce(average),NumberMatcher.is(.5));
  assertThat(numbers(1).reduce(average),NumberMatcher.is(1));
  assertThat(numbers().reduce(average),NumberMatcher.is(0));
}"
56807,"public int compare(T m1,T m2){
  for (  Comparator<? super T> comparator : comparators) {
    int comparisonResult=comparator.compare(m1,m2);
    if (comparisonResult != 0)     return comparisonResult;
  }
  return 0;
}","public int compare(Comparable a,Comparable b){
  return b.compareTo(a);
}"
56808,"@Override public boolean equals(Object o){
  return o instanceof Left && ((Left)o).value.equals(value);
}","@Override public boolean equals(Object o){
  return o instanceof Left && equalTo(((Left)o).value,value);
}"
56809,"@Override public boolean equals(Object o){
  return o instanceof Right && ((Right)o).value.equals(value);
}","@Override public boolean equals(Object o){
  return o instanceof Right && equalTo(((Right)o).value,value);
}"
56810,"public static <T,S>Sequence<T> unique(final Iterable<? extends T> iterable,final Callable1<? super T,? extends S> callable){
  return sequence(iterable).filter(new UniquePredicate<T,S>(callable));
}","public static <T,S>Sequence<T> unique(final Iterable<? extends T> iterable,final Callable1<? super T,? extends S> callable){
  return new Sequence<T>(){
    @Override public Iterator<T> iterator(){
      return Iterators.filter(iterable.iterator(),new UniquePredicate<T,S>(callable));
    }
  }
;
}"
56811,"public void checkin(){
  checkoutCount--;
}","public int checkin(){
  return --checkoutCount;
}"
56812,"public static <T>LogicalPredicate<T> instanceOf(final Class t){
  return new InstanceOf<T>(t);
}","public static <T>LogicalPredicate<T> instanceOf(final Class<?> t){
  return new InstanceOf<T>(t);
}"
56813,"public static LogicalPredicate<Object> assignableTo(final Class aClass){
  return new LogicalPredicate<Object>(){
    public boolean matches(    Object o){
      return isAssignableTo(o,aClass);
    }
  }
;
}","public static LogicalPredicate<Object> assignableTo(final Class<?> aClass){
  return new LogicalPredicate<Object>(){
    public boolean matches(    Object o){
      return isAssignableTo(o,aClass);
    }
  }
;
}"
56814,"public static boolean isAssignableTo(Object o,Class aClass){
  if (o == null)   return false;
  return aClass.isAssignableFrom(o.getClass());
}","public static boolean isAssignableTo(Object o,Class<?> aClass){
  if (o == null)   return false;
  return aClass.isAssignableFrom(o.getClass());
}"
56815,"public final int compareTo(Object o){
  Number other=(Number)o;
  return Numbers.compare(this,other);
}","public final int compareTo(Number other){
  return Numbers.compare(this,other);
}"
56816,"public static <T>Class<T> getGenericSuperclassType(Class aClass,int index){
  ParameterizedType type=(ParameterizedType)aClass.getGenericSuperclass();
  Type[] actualTypeArguments=type.getActualTypeArguments();
  return (Class<T>)actualTypeArguments[index];
}","public static <T>Class<T> getGenericSuperclassType(Class<?> aClass,int index){
  ParameterizedType type=(ParameterizedType)aClass.getGenericSuperclass();
  Type[] actualTypeArguments=type.getActualTypeArguments();
  return (Class<T>)actualTypeArguments[index];
}"
56817,"public static <T>T createProxy(Class<T> aCLass,InvocationHandler invocationHandler){
  return (T)new Proxy().createInstance(aCLass,invocationHandler);
}","public static <T>T createProxy(Class<T> aCLass,InvocationHandler invocationHandler){
  return new Proxy().createInstance(aCLass,invocationHandler);
}"
56818,"public Object createInstance(final Class aClass,final Callback invocationHandler){
  Callback[] callbacks={invocationHandler,NoOp.INSTANCE};
  ObjectInstantiator instantiator=get(aClass,callbacks);
  Object instance=instantiator.newInstance();
  Factory factory=(Factory)instance;
  factory.setCallbacks(callbacks);
  return instance;
}","public <T>T createInstance(final Class<T> aClass,final Callback invocationHandler){
  Callback[] callbacks={invocationHandler,NoOp.INSTANCE};
  ObjectInstantiator instantiator=get(aClass,callbacks);
  Object instance=instantiator.newInstance();
  Factory factory=(Factory)instance;
  factory.setCallbacks(callbacks);
  return (T)instance;
}"
56819,"private ObjectInstantiator get(final Class aClass,final Callback[] callbacks){
synchronized (cache) {
    if (!cache.containsKey(aClass)) {
      cache.put(aClass,createInstantiator(aClass,callbacks));
    }
    return cache.get(aClass);
  }
}","private ObjectInstantiator get(final Class<?> aClass,final Callback[] callbacks){
synchronized (cache) {
    if (!cache.containsKey(aClass)) {
      cache.put(aClass,createInstantiator(aClass,callbacks));
    }
    return cache.get(aClass);
  }
}"
56820,"private ObjectInstantiator createInstantiator(Class aClass,Callback[] callbacks){
  IgnoreConstructorsEnhancer enhancer=new IgnoreConstructorsEnhancer();
  enhancer.setSuperclass(aClass);
  enhancer.setCallbackTypes(sequence(callbacks).map(toClass()).toArray(Class.class));
  enhancer.setCallbackFilter(new ToStringFilter());
  enhancer.setUseFactory(true);
  Class enhancedClass=enhancer.createClass();
  return objenesis.getInstantiatorOf(enhancedClass);
}","private ObjectInstantiator createInstantiator(Class<?> aClass,Callback[] callbacks){
  IgnoreConstructorsEnhancer enhancer=new IgnoreConstructorsEnhancer();
  enhancer.setSuperclass(aClass);
  enhancer.setCallbackTypes(sequence(callbacks).map(toClass()).toArray(Class.class));
  enhancer.setCallbackFilter(new ToStringFilter());
  enhancer.setUseFactory(true);
  Class enhancedClass=enhancer.createClass();
  return objenesis.getInstantiatorOf(enhancedClass);
}"
56821,"@Override public Number remove(Keyword recordName){
  Record head=get(recordName).map(SelectCallable.select(Keywords.keyword(""String_Node_Str"",String.class))).head();
  Number result=Numbers.valueOf(head.get(Keywords.keyword(""String_Node_Str"",String.class)));
  List<Keyword<?>> undefine=undefine(recordName);
  define(recordName,undefine.toArray(new Keyword[0]));
  return result;
}","@Override public Number remove(Keyword recordName){
  Record head=get(recordName).map(select(Keywords.keyword(""String_Node_Str"",String.class))).head();
  Number result=Numbers.valueOf(head.get(Keywords.keyword(""String_Node_Str"",String.class)));
  List<Keyword<?>> undefine=undefine(recordName);
  define(recordName,undefine.toArray(new Keyword[0]));
  return result;
}"
56822,"public static SetFunctionType setFunctionType(Callable2<?,?,?> callable,Keyword column){
  return new SetFunctionType(callable,column);
}","public static SetFunctionType setFunctionType(Callable2<?,?,?> callable,Keyword<?> column){
  return new SetFunctionType(callable,column);
}"
56823,"public static String functionName(final Class<? extends Callable2> aClass,Keyword column){
  if (!names.containsKey(aClass)) {
    throw new UnsupportedOperationException();
  }
  return format(""String_Node_Str"",names.get(aClass),column);
}","public static String functionName(final Class<? extends Callable2> aClass,Keyword<?> column){
  if (!names.containsKey(aClass)) {
    throw new UnsupportedOperationException();
  }
  return format(""String_Node_Str"",names.get(aClass),column);
}"
56824,"public SetFunctionType(Callable2<?,?,?> callable,Keyword column){
  super(functionName(callable.getClass(),column));
}","public SetFunctionType(Callable2<?,?,?> callable,Keyword<?> column){
  super(functionName(callable.getClass(),column));
}"
56825,"@Override protected boolean matchesSafely(Iterable iterable){
  return size.equals(sequence(iterable).size());
}","@Override protected boolean matchesSafely(Iterable<T> iterable){
  return size.equals(sequence(iterable).size());
}"
56826,"public Object invoke(Object proxy,Method method,Object[] arguments) throws Throwable {
  invocation.set(new Invocation(proxy,method,arguments));
  return null;
}","public Object invoke(Object proxy,Method method,Object[] arguments) throws Throwable {
  invocation.set(new Invocation<T,R>(proxy,method,arguments));
  return null;
}"
56827,"public S call(T t) throws Exception {
  return (S)invocation.call(t);
}","public S call(T t) throws Exception {
  return invocation.call(t);
}"
56828,"public Invocation invocation(){
  return invocation;
}","public Invocation<T,S> invocation(){
  return invocation;
}"
56829,"public Object invoke(Object proxy,Method method,Object[] arguments) throws Throwable {
  invocation=new Invocation(proxy,method,arguments);
  return null;
}","public Object invoke(Object proxy,Method method,Object[] arguments) throws Throwable {
  invocation=new Invocation<T,S>(proxy,method,arguments);
  return null;
}"
56830,"@Override public void set(Invocation value){
  if (get() != null) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  super.set(value);
}","@Override public void set(Invocation<T,R> value){
  if (get() != null) {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  super.set(value);
}"
56831,"@Override public Invocation get(){
  final Invocation result=super.get();
  super.set(null);
  return result;
}","@Override public Invocation<T,R> get(){
  final Invocation<T,R> result=super.get();
  super.set(null);
  return result;
}"
56832,"@Test public void canSortByProxy() throws Exception {
  User matt=user(""String_Node_Str"",""String_Node_Str"");
  User dan=user(""String_Node_Str"",""String_Node_Str"");
  User bob=user(""String_Node_Str"",""String_Node_Str"");
  Sequence<User> unsorted=sequence(matt,dan,bob);
  Sequence<User> sorted=unsorted.sortBy(Call.<User,String>method(on(User.class).firstName()));
  assertThat(sorted,hasExactly(bob,dan,matt));
}","@Test public void canSortByProxy() throws Exception {
  User matt=user(""String_Node_Str"",""String_Node_Str"");
  User dan=user(""String_Node_Str"",""String_Node_Str"");
  User bob=user(""String_Node_Str"",""String_Node_Str"");
  Sequence<User> unsorted=sequence(matt,dan,bob);
  Sequence<User> sorted=unsorted.sortBy(method(on(User.class).firstName()));
  assertThat(sorted,hasExactly(bob,dan,matt));
}"
56833,"public void define(Keyword recordName,Keyword<?>... fields){
  memory.put(recordName,new ArrayList<Record>());
}","public void define(Keyword recordName,Keyword<?>... fields){
}"
56834,"private List<Record> recordsFor(Keyword recordName){
  return memory.get(recordName);
}","private List<Record> recordsFor(Keyword recordName){
  if (!memory.containsKey(recordName)) {
    memory.put(recordName,new ArrayList<Record>());
  }
  return memory.get(recordName);
}"
56835,"public Number remove(Keyword recordName){
  int count=memory.get(recordName).size();
  recordsFor(recordName).clear();
  return count;
}","public Number remove(Keyword recordName){
  List<Record> records=recordsFor(recordName);
  int count=records.size();
  memory.remove(recordName);
  return count;
}"
56836,"public Number add(Keyword recordName,Sequence<Keyword> fields,Sequence<Record> records){
  if (records.isEmpty()) {
    return 0;
  }
  List<Record> list=getRecordsFor(recordName);
  Number count=0;
  for (  Record record : records.map(select(fields))) {
    list.add(record);
    count=increment(count);
  }
  return count;
}","public Number add(Keyword recordName,Sequence<Keyword> fields,Sequence<Record> records){
  if (records.isEmpty()) {
    return 0;
  }
  List<Record> list=recordsFor(recordName);
  Number count=0;
  for (  Record record : records.map(select(fields))) {
    list.add(record);
    count=increment(count);
  }
  return count;
}"
56837,"@SuppressWarnings({""String_Node_Str""}) public Number set(Keyword recordName,Predicate<? super Record> predicate,Sequence<Keyword> fields,Record record){
  List<Record> records=getRecordsFor(recordName);
  Number count=0;
  Sequence<Integer> indexes=get(recordName).zipWithIndex().filter(where(second(Record.class),is(predicate))).map(first(Number.class)).safeCast(Integer.class);
  for (  Integer index : indexes) {
    records.set(index,record.fields().fold(records.get(index),updateValues()));
  }
  count=Numbers.add(count,indexes.size());
  return count;
}","@SuppressWarnings({""String_Node_Str""}) public Number set(Keyword recordName,Predicate<? super Record> predicate,Sequence<Keyword> fields,Record record){
  List<Record> records=recordsFor(recordName);
  Number count=0;
  Sequence<Integer> indexes=get(recordName).zipWithIndex().filter(where(second(Record.class),is(predicate))).map(first(Number.class)).safeCast(Integer.class);
  for (  Integer index : indexes) {
    records.set(index,record.fields().fold(records.get(index),updateValues()));
  }
  count=Numbers.add(count,indexes.size());
  return count;
}"
56838,"public Sequence<Record> get(Keyword recordName){
  return sequence(getRecordsFor(recordName));
}","public Sequence<Record> get(Keyword recordName){
  return sequence(recordsFor(recordName));
}"
56839,"public void define(Keyword recordName,Keyword<?>... fields){
}","public void define(Keyword recordName,Keyword<?>... fields){
  memory.put(recordName,new ArrayList<Record>());
}"
56840,"public Number remove(Keyword recordName){
  int count=memory.get(recordName).size();
  memory.remove(recordName);
  return count;
}","public Number remove(Keyword recordName){
  int count=memory.get(recordName).size();
  recordsFor(recordName).clear();
  return count;
}"
56841,"@Test public void supportsRemove() throws Exception {
  assertThat(records.remove(user,where(age,is(greaterThan(10)))),equalTo(2));
  assertThat(records.remove(user,where(age,is(greaterThan(10)))),equalTo(0));
  assertThat(records.get(user).size(),equalTo(1));
  assertThat(records.remove(user),equalTo(1));
  assertThat(records.get(user).size(),equalTo(0));
  addUsers(records);
}","@Test public void supportsRemove() throws Exception {
  assertThat(records.remove(user,where(age,is(greaterThan(10)))),equalTo(2));
  assertThat(records.remove(user,where(age,is(greaterThan(10)))),equalTo(0));
  assertThat(records.get(user).size(),equalTo(1));
  assertThat(records.remove(user),equalTo(1));
  Sequence<Record> recordSequence=records.get(user);
  assertThat(recordSequence.size(),equalTo(0));
  addUsers(records);
}"
56842,"@BeforeClass public static void createRecords() throws SQLException {
  AbstractRecordsTests.addRecords(new SqlRecords(getConnection(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
}","@BeforeClass public static void createRecords() throws SQLException {
  addRecords(new SqlRecords(getConnection(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
}"
56843,"public static <K,V>HashMap<K,V> map(Class<K> key,Class<V> value,Pair<K,V>... entries){
  return map(entries);
}","public static <K,V>HashMap<K,V> map(Class<K> key,Class<V> value,Pair<? extends K,? extends V>... entries){
  return map(entries);
}"
56844,"public static <K,V>HashMap<K,V> map(Class<K> key,Class<V> value,Pair<K,V>... entries){
  return map(entries);
}","public static <K,V>HashMap<K,V> map(Class<K> key,Class<V> value,Pair<? extends K,? extends V>... entries){
  return map(entries);
}"
56845,"public Number add(Keyword recordName,Sequence<Record> records){
  return add(recordName,records.first().keywords(),records);
}","public Number add(Keyword recordName,Sequence<Record> records){
  if (records.isEmpty())   return 0;
  return add(recordName,records.first().keywords(),records);
}"
56846,"public static <T>Iterator<T> remove(final Iterator<T> iterator,final T t){
  return filter(iterator,not(t));
}","public static <T>Iterator<T> remove(final Iterator<T> iterator,final T t){
  return filter(iterator,not(onlyOnce(is(t))));
}"
56847,"@Test public void supportsRemove() throws Exception {
  final Sequence<Integer> numbers=sequence(1,2,3).remove(2);
  assertThat(numbers,hasExactly(1,3));
}","@Test public void supportsRemove() throws Exception {
  final Sequence<Integer> numbers=sequence(1,2,3,2).remove(2);
  assertThat(numbers,hasExactly(1,3,2));
}"
56848,"@Override public void execute(InterpretContext ctx) throws InterpretException {
  JetWriter os=ctx.getWriter();
  if (encoder == null) {
    if (os.isStreaming()) {
      encoder=new ByteArrayEncoder(text,os.getCharset());
    }
 else {
      if (JdkUtils.IS_AT_LEAST_JAVA_7) {
        encoder=new Jdk7CharArrayEncoder(text);
      }
 else {
        encoder=new Jdk6CharArrayEncoder(text);
      }
    }
    text=null;
  }
  try {
    encoder.writeTo(os);
  }
 catch (  IOException e) {
    throw new IllegalStateException(e);
  }
}","@Override public void execute(InterpretContext ctx) throws InterpretException {
  JetWriter os=ctx.getWriter();
  if (encoder == null) {
synchronized (this) {
      if (encoder == null) {
        if (os.isStreaming()) {
          encoder=new ByteArrayEncoder(text,os.getCharset());
        }
 else {
          if (JdkUtils.IS_AT_LEAST_JAVA_7) {
            encoder=new Jdk7CharArrayEncoder(text);
          }
 else {
            encoder=new Jdk6CharArrayEncoder(text);
          }
        }
        text=null;
      }
    }
  }
  try {
    encoder.writeTo(os);
  }
 catch (  IOException e) {
    throw new IllegalStateException(e);
  }
}"
56849,"private void mergeConfigs(Properties props){
  for (  String key : DEFAULT_CONFIGS.keySet()) {
    if (props.containsKey(key) == false) {
      String value=DEFAULT_CONFIGS.get(key);
      props.put(key,value);
    }
  }
}","private void mergeConfigs(JetTemplateProperties properties){
  if (properties.getConfig() == null) {
    properties.setConfig(new Properties());
  }
  for (  String key : DEFAULT_CONFIGS.keySet()) {
    if (properties.getConfig().containsKey(key) == false) {
      String value=DEFAULT_CONFIGS.get(key);
      properties.getConfig().put(key,value);
    }
  }
}"
56850,"@Bean @ConditionalOnMissingBean(JetTemplateViewResolver.class) public JetTemplateViewResolver jetTemplateViewResolver(JetTemplateProperties properties){
  mergeConfigs(properties.getConfig());
  JetTemplateViewResolver resolver=new JetTemplateViewResolver();
  resolver.setPrefix(properties.getPrefix());
  resolver.setSuffix(properties.getSuffix());
  resolver.setCache(properties.isCache());
  resolver.setViewNames(properties.getViewNames());
  resolver.setContentType(properties.getContentType().toString());
  resolver.setOrder(properties.getOrder());
  resolver.setConfigProperties(properties.getConfig());
  resolver.setConfigLocation(properties.getConfigLocation());
  return resolver;
}","@Bean @ConditionalOnMissingBean(JetTemplateViewResolver.class) public JetTemplateViewResolver jetTemplateViewResolver(JetTemplateProperties properties){
  mergeConfigs(properties);
  JetTemplateViewResolver resolver=new JetTemplateViewResolver();
  resolver.setPrefix(properties.getPrefix());
  resolver.setSuffix(properties.getSuffix());
  resolver.setCache(properties.isCache());
  resolver.setViewNames(properties.getViewNames());
  resolver.setContentType(properties.getContentType().toString());
  resolver.setOrder(properties.getOrder());
  resolver.setConfigProperties(properties.getConfig());
  resolver.setConfigLocation(properties.getConfigLocation());
  return resolver;
}"
56851,"@Override public Object execute(InterpretContext ctx) throws InterpretException {
  Object o1=lhs.execute(ctx);
  Object o2=(rhs != null) ? rhs.execute(ctx) : null;
  Object value;
switch (operator) {
case Tokens.IDENTICALLY_EQUAL:
    value=(o1 == o2);
  break;
case Tokens.IDENTICALLY_EQUAL_NOT:
value=(o1 != o2);
break;
case Tokens.EQ:
value=ALU.equals(o1,o2);
break;
case Tokens.NE:
value=ALU.equals(o1,o2).booleanValue() ? Boolean.FALSE : Boolean.TRUE;
break;
case Tokens.AND:
value=ALU.isTrue(o1) && ALU.isTrue(o2) ? Boolean.TRUE : Boolean.FALSE;
break;
case Tokens.OR:
value=ALU.isTrue(o1) || ALU.isTrue(o2) ? Boolean.TRUE : Boolean.FALSE;
break;
case Tokens.NOT:
value=ALU.isTrue(o1) ? Boolean.FALSE : Boolean.TRUE;
break;
default :
throw new UnsupportedOperationException();
}
return value;
}","@Override public Object execute(InterpretContext ctx) throws InterpretException {
  Object o1=lhs.execute(ctx);
  Object value;
switch (operator) {
case Tokens.IDENTICALLY_EQUAL:
    value=(o1 == rhs.execute(ctx));
  break;
case Tokens.IDENTICALLY_EQUAL_NOT:
value=(o1 != rhs.execute(ctx));
break;
case Tokens.EQ:
value=ALU.equals(o1,rhs.execute(ctx));
break;
case Tokens.NE:
value=ALU.equals(o1,rhs.execute(ctx)).booleanValue() ? Boolean.FALSE : Boolean.TRUE;
break;
case Tokens.AND:
value=ALU.isTrue(o1) && ALU.isTrue(rhs.execute(ctx)) ? Boolean.TRUE : Boolean.FALSE;
break;
case Tokens.OR:
value=ALU.isTrue(o1) || ALU.isTrue(rhs.execute(ctx)) ? Boolean.TRUE : Boolean.FALSE;
break;
case Tokens.NOT:
value=ALU.isTrue(o1) ? Boolean.FALSE : Boolean.TRUE;
break;
default :
throw new UnsupportedOperationException();
}
return value;
}"
56852,"private void trimDirectiveWhitespacesAndComments(ListIterator<AstStatement> it,int block,ParserContext ctx){
  boolean trimDirectiveWhitespaces=ctx.isTrimDirectiveWhitespaces();
  boolean trimDirectiveComments=ctx.isTrimDirectiveComments();
  String trimDirectiveCommentsPrefix=ctx.getTrimDirectiveCommentsPrefix();
  String trimDirectiveCommentsSuffix=ctx.getTrimDirectiveCommentsSuffix();
  if (!trimDirectiveWhitespaces && !trimDirectiveComments) {
    return;
  }
  it.reset();
  while (it.has()) {
    AstStatement stmt=it.peek();
    if (!(stmt instanceof AstText)) {
      it.move();
      continue;
    }
    AstText text=(AstText)stmt;
    boolean trimLeft;
    boolean keepLeftNewLine=false;
    if (it.hasPrevious()) {
      trimLeft=isAstDirective(it.peek(-1));
      if (trimLeft) {
        AstStatement prev=it.peek(-1);
        if (prev != null) {
          if (prev instanceof AstDirective) {
            if (prev instanceof AstDirectiveTag) {
              keepLeftNewLine=true;
            }
 else {
              keepLeftNewLine=((AstDirective)prev).getPosition().getLine() == text.getLine();
            }
          }
        }
      }
    }
 else {
      trimLeft=(block != Tokens.AST_BLOCK_TEMPLATE);
    }
    boolean trimRight;
    if (it.hasNext()) {
      trimRight=isAstDirective(it.peek(1));
    }
 else {
      trimRight=(block != Tokens.AST_BLOCK_TEMPLATE);
    }
    if (trimDirectiveComments) {
      text.trimDirectiveComments(trimLeft,trimRight,trimDirectiveCommentsPrefix,trimDirectiveCommentsSuffix);
    }
    if (trimDirectiveWhitespaces) {
      text.trimDirectiveWhitespaces(trimLeft,trimRight,keepLeftNewLine);
    }
    if (!it.hasNext()) {
      if (block == Tokens.AST_BLOCK_TAG || block == Tokens.AST_BLOCK_MACRO) {
        text.trimLastNewLine();
      }
    }
    if (text.isEmpty()) {
      it.remove();
    }
 else {
      it.move();
    }
  }
}","private void trimDirectiveWhitespacesAndComments(ListIterator<AstStatement> it,int block,ParserContext ctx){
  boolean trimDirectiveWhitespaces=ctx.isTrimDirectiveWhitespaces();
  boolean trimDirectiveComments=ctx.isTrimDirectiveComments();
  String trimDirectiveCommentsPrefix=ctx.getTrimDirectiveCommentsPrefix();
  String trimDirectiveCommentsSuffix=ctx.getTrimDirectiveCommentsSuffix();
  if (!trimDirectiveWhitespaces && !trimDirectiveComments) {
    return;
  }
  it.reset();
  while (it.has()) {
    AstStatement stmt=it.peek();
    if (!(stmt instanceof AstText)) {
      it.move();
      continue;
    }
    AstText text=(AstText)stmt;
    boolean trimWhitespacesLeft, trimCommentsLeft;
    boolean keepLeftNewLine=false;
    if (it.hasPrevious()) {
      trimWhitespacesLeft=isAstDirective(it.peek(-1),false);
      trimCommentsLeft=isAstDirective(it.peek(-1),true);
      if (trimWhitespacesLeft) {
        AstStatement prev=it.peek(-1);
        if (prev != null) {
          if (prev instanceof AstDirective) {
            if (prev instanceof AstDirectiveTag) {
              keepLeftNewLine=true;
            }
 else {
              keepLeftNewLine=((AstDirective)prev).getPosition().getLine() == text.getLine();
            }
          }
        }
      }
    }
 else {
      trimWhitespacesLeft=(block != Tokens.AST_BLOCK_TEMPLATE);
      trimCommentsLeft=trimWhitespacesLeft;
    }
    boolean trimWhitespacesRight, trimCommentsRight;
    if (it.hasNext()) {
      trimWhitespacesRight=isAstDirective(it.peek(1),false);
      trimCommentsRight=isAstDirective(it.peek(1),true);
    }
 else {
      trimWhitespacesRight=(block != Tokens.AST_BLOCK_TEMPLATE);
      trimCommentsRight=trimWhitespacesRight;
    }
    if (trimDirectiveComments) {
      text.trimDirectiveComments(trimCommentsLeft,trimCommentsRight,trimDirectiveCommentsPrefix,trimDirectiveCommentsSuffix);
    }
    if (trimDirectiveWhitespaces) {
      text.trimDirectiveWhitespaces(trimWhitespacesLeft,trimWhitespacesRight,keepLeftNewLine);
    }
    if (!it.hasNext()) {
      if (block == Tokens.AST_BLOCK_TAG || block == Tokens.AST_BLOCK_MACRO) {
        text.trimLastNewLine();
      }
    }
    if (text.isEmpty()) {
      it.remove();
    }
 else {
      it.move();
    }
  }
}"
56853,"private boolean isAstDirective(AstNode node){
  return (node instanceof AstDirective) && !(node instanceof AstDirectiveInclude || node instanceof AstDirectiveCall);
}","private boolean isAstDirective(AstNode node,boolean includeInlineDirective){
  if (node instanceof AstDirective) {
    if (includeInlineDirective) {
      return true;
    }
    return !(node instanceof AstDirectiveInclude || node instanceof AstDirectiveCall);
  }
  return false;
}"
56854,"@Override public Object execute(InterpretContext ctx) throws InterpretException {
  Object o1=lhs.execute(ctx);
  Object o2=rhs.execute(ctx);
  if (o1 == null) {
    if (o2 instanceof String) {
      return o2;
    }
    throw new InterpretException(Errors.EXPRESSION_LHS_IS_NULL).set(lhs.getPosition());
  }
  if (o2 == null) {
    if (o1 instanceof String) {
      return o1;
    }
    throw new InterpretException(Errors.EXPRESSION_RHS_IS_NULL).set(lhs.getPosition());
  }
  try {
    Object value;
switch (operator) {
case Tokens.PLUS:
      value=ALU.plus(o1,o2);
    break;
case Tokens.MINUS:
  value=ALU.minus(o1,o2);
break;
case Tokens.MUL:
value=ALU.mul(o1,o2);
break;
case Tokens.DIV:
value=ALU.div(o1,o2);
break;
case Tokens.MOD:
value=ALU.mod(o1,o2);
break;
case Tokens.BIT_AND:
value=ALU.bitAnd(o1,o2);
break;
case Tokens.BIT_OR:
value=ALU.bitOr(o1,o2);
break;
case Tokens.BIT_XOR:
value=ALU.bitXor(o1,o2);
break;
case Tokens.BIT_SHL:
value=ALU.shl(o1,o2);
break;
case Tokens.BIT_SHR:
value=ALU.shr(o1,o2);
break;
case Tokens.BIT_USHR:
value=ALU.ushr(o1,o2);
break;
case Tokens.LT:
value=ALU.lt(o1,o2);
break;
case Tokens.LE:
value=ALU.le(o1,o2);
break;
case Tokens.GT:
value=ALU.gt(o1,o2);
break;
case Tokens.GE:
value=ALU.ge(o1,o2);
break;
default :
throw new UnsupportedOperationException();
}
return value;
}
 catch (IllegalStateException e) {
throw new InterpretException(e).set(position);
}
}","@Override public Object execute(InterpretContext ctx) throws InterpretException {
  Object o1=lhs.execute(ctx);
  Object o2=rhs.execute(ctx);
  if (o1 == null) {
    if (o2 instanceof String && operator == Tokens.PLUS) {
      return o2;
    }
    throw new InterpretException(Errors.EXPRESSION_LHS_IS_NULL).set(lhs.getPosition());
  }
  if (o2 == null) {
    if (o1 instanceof String && operator == Tokens.PLUS) {
      return o1;
    }
    throw new InterpretException(Errors.EXPRESSION_RHS_IS_NULL).set(rhs.getPosition());
  }
  try {
    Object value;
switch (operator) {
case Tokens.PLUS:
      value=ALU.plus(o1,o2);
    break;
case Tokens.MINUS:
  value=ALU.minus(o1,o2);
break;
case Tokens.MUL:
value=ALU.mul(o1,o2);
break;
case Tokens.DIV:
value=ALU.div(o1,o2);
break;
case Tokens.MOD:
value=ALU.mod(o1,o2);
break;
case Tokens.BIT_AND:
value=ALU.bitAnd(o1,o2);
break;
case Tokens.BIT_OR:
value=ALU.bitOr(o1,o2);
break;
case Tokens.BIT_XOR:
value=ALU.bitXor(o1,o2);
break;
case Tokens.BIT_SHL:
value=ALU.shl(o1,o2);
break;
case Tokens.BIT_SHR:
value=ALU.shr(o1,o2);
break;
case Tokens.BIT_USHR:
value=ALU.ushr(o1,o2);
break;
case Tokens.LT:
value=ALU.lt(o1,o2);
break;
case Tokens.LE:
value=ALU.le(o1,o2);
break;
case Tokens.GT:
value=ALU.gt(o1,o2);
break;
case Tokens.GE:
value=ALU.ge(o1,o2);
break;
default :
throw new UnsupportedOperationException();
}
return value;
}
 catch (IllegalStateException e) {
throw new InterpretException(e).set(position);
}
}"
56855,"/** 
 * 生成方法调用的实际参数
 */
public static Object[] getActualArguments(Object[] arguments,int actualLength,boolean isVarArgs,int offset){
  if (isVarArgs) {
    Object[] args=new Object[actualLength];
    int fixedArgsLen=actualLength - offset - 1;
    if (fixedArgsLen > 0) {
      System.arraycopy(arguments,0,args,offset,fixedArgsLen);
    }
    int varArgsLen=arguments.length - fixedArgsLen;
    if (varArgsLen == 0) {
      args[actualLength - 1]=ArrayUtils.EMPTY_OBJECT_ARRAY;
    }
 else {
      Object[] varArgs=null;
      if (varArgsLen == 1) {
        Object arg=arguments[fixedArgsLen];
        if (arg == null) {
          varArgs=ArrayUtils.EMPTY_OBJECT_ARRAY;
        }
 else         if (Object[].class.isAssignableFrom(arg.getClass())) {
          varArgs=(Object[])arg;
        }
      }
      if (varArgs == null) {
        varArgs=new Object[varArgsLen];
        System.arraycopy(arguments,fixedArgsLen,varArgs,0,varArgsLen);
      }
      args[actualLength - 1]=varArgs;
    }
    return args;
  }
  if (offset > 0) {
    Object[] args=new Object[actualLength];
    int length=actualLength - offset;
    if (length > 0) {
      System.arraycopy(arguments,0,args,offset,length);
    }
    return args;
  }
  return arguments;
}","/** 
 * 生成方法调用的实际参数
 */
public static Object[] getActualArguments(Object[] arguments,int actualLength,Class<?> varArgsClass,int offset){
  if (varArgsClass != null) {
    Object[] args=new Object[actualLength];
    int fixedArgsLen=actualLength - offset - 1;
    if (fixedArgsLen > 0) {
      System.arraycopy(arguments,0,args,offset,fixedArgsLen);
    }
    int varArgsLen=arguments.length - fixedArgsLen;
    if (varArgsLen == 0) {
      args[actualLength - 1]=Array.newInstance(varArgsClass,0);
    }
 else {
      Object varArgs=null;
      if (varArgsLen == 1) {
        Object arg=arguments[fixedArgsLen];
        if (arg == null) {
          varArgs=Array.newInstance(varArgsClass,0);
        }
 else         if (Object[].class.isAssignableFrom(arg.getClass())) {
          varArgs=arg;
        }
      }
      if (varArgs == null) {
        varArgs=Array.newInstance(varArgsClass,varArgsLen);
        System.arraycopy(arguments,fixedArgsLen,varArgs,0,varArgsLen);
      }
      args[actualLength - 1]=varArgs;
    }
    return args;
  }
  if (offset > 0) {
    Object[] args=new Object[actualLength];
    int length=actualLength - offset;
    if (length > 0) {
      System.arraycopy(arguments,0,args,offset,length);
    }
    return args;
  }
  return arguments;
}"
56856,"public ExtensionFunctionInvoker(MethodInfo method){
  this.method=method;
  this.length=method.getParameterCount();
  this.isVarArgs=method.isVarArgs();
}","public ExtensionFunctionInvoker(MethodInfo method){
  this.method=method;
  this.length=method.getParameterCount();
  if (method.isVarArgs()) {
    Class<?>[] types=method.getParameterTypes();
    this.varArgsClass=types[types.length - 1].getComponentType();
  }
 else {
    this.varArgsClass=null;
  }
}"
56857,"@Override public Object invoke(Object[] arguments){
  arguments=ParameterUtils.getActualArguments(arguments,length,isVarArgs,0);
  return method.invoke(null,arguments);
}","@Override public Object invoke(Object[] arguments){
  arguments=ParameterUtils.getActualArguments(arguments,length,varArgsClass,0);
  return method.invoke(null,arguments);
}"
56858,"public ClassBuildinMethodInvoker(MethodInfo method){
  this.method=method;
  this.length=method.getParameterCount();
  this.isVarArgs=method.isVarArgs();
}","public ClassBuildinMethodInvoker(MethodInfo method){
  this.method=method;
  this.length=method.getParameterCount();
  if (method.isVarArgs()) {
    Class<?>[] types=method.getParameterTypes();
    this.varArgsClass=types[types.length - 1].getComponentType();
  }
 else {
    this.varArgsClass=null;
  }
}"
56859,"@Override public Object invoke(Object object,Object[] arguments){
  arguments=ParameterUtils.getActualArguments(arguments,length,isVarArgs,0);
  return method.invoke(object,arguments);
}","@Override public Object invoke(Object object,Object[] arguments){
  arguments=ParameterUtils.getActualArguments(arguments,length,varArgsClass,0);
  return method.invoke(object,arguments);
}"
56860,"@Override public Object invoke(Object object,Object[] arguments){
  arguments=ParameterUtils.getActualArguments(arguments,length,isVarArgs,1);
  arguments[0]=object;
  return method.invoke(object,arguments);
}","@Override public Object invoke(Object object,Object[] arguments){
  arguments=ParameterUtils.getActualArguments(arguments,length,varArgsClass,1);
  arguments[0]=object;
  return method.invoke(null,arguments);
}"
56861,"public ExtensionMethodInvoker(MethodInfo method){
  this.method=method;
  this.length=method.getParameterCount();
  this.isVarArgs=method.isVarArgs();
}","public ExtensionMethodInvoker(MethodInfo method){
  this.method=method;
  this.length=method.getParameterCount();
  if (method.isVarArgs()) {
    Class<?>[] types=method.getParameterTypes();
    this.varArgsClass=types[types.length - 1].getComponentType();
  }
 else {
    this.varArgsClass=null;
  }
}"
56862,"public void invoke(JetTagContext ctx,Object[] arguments){
  arguments=ParameterUtils.getActualArguments(arguments,length,isVarArgs,1);
  arguments[0]=ctx;
  method.invoke(null,arguments);
}","public void invoke(JetTagContext ctx,Object[] arguments){
  arguments=ParameterUtils.getActualArguments(arguments,length,varArgsClass,1);
  arguments[0]=ctx;
  method.invoke(null,arguments);
}"
56863,"public TagInvoker(MethodInfo method){
  this.method=method;
  this.length=method.getParameterCount();
  this.isVarArgs=method.isVarArgs();
}","public TagInvoker(MethodInfo method){
  this.method=method;
  this.length=method.getParameterCount();
  if (method.isVarArgs()) {
    Class<?>[] types=method.getParameterTypes();
    this.varArgsClass=types[types.length - 1].getComponentType();
  }
 else {
    this.varArgsClass=null;
  }
}"
56864,"@Override public void initializeEngine(){
  engine.getGlobalResolver().registerMethods(StringUtils.class);
  engine.getGlobalResolver().registerMethods(String.class);
}","@Override public void initializeEngine(){
  engine.getGlobalResolver().registerMethods(StringUtils.class);
  engine.getGlobalResolver().registerMethods(StrUtils.class);
  engine.getGlobalResolver().registerMethods(String.class);
}"
56865,"private Object doInvoke(InterpretContext ctx,FunctionInvoker fn,Object[] arguments) throws InterpretException {
  boolean useLatest=(fn != null);
  if (fn == null) {
    Class<?>[] argumentTypes=ParameterUtils.getParameterTypes(arguments);
    fn=ctx.getGlobalResolver().resolveFunction(name,argumentTypes);
    if (fn == null) {
      String signature=SignatureUtils.getFunctionSignature(name,argumentTypes);
      throw new InterpretException(Errors.FUNCTION_NOT_FOUND,signature).set(position);
    }
    this.last=fn;
  }
  if (unsafe) {
    JetSecurityManager securityManager=ctx.getSecurityManager();
    if (securityManager != null) {
      try {
        fn.checkAccess(securityManager);
      }
 catch (      RuntimeException e) {
        throw new InterpretException(e).set(position);
      }
    }
    unsafe=false;
  }
  try {
    return fn.invoke(arguments);
  }
 catch (  InterpretException e) {
    throw e;
  }
catch (  RuntimeException e) {
    if (useLatest && Errors.isReflectIllegalArgument(e)) {
      return doInvoke(ctx,null,arguments);
    }
    throw new InterpretException(Errors.FUNCTION_INVOKE_ERROR).cause(e).set(position);
  }
}","private Object doInvoke(InterpretContext ctx,FunctionInvoker fn,Object[] arguments) throws InterpretException {
  boolean useLatest=(fn != null);
  if (fn == null) {
    Class<?>[] argumentTypes=ParameterUtils.getParameterTypes(arguments);
    fn=ctx.getGlobalResolver().resolveFunction(name,argumentTypes);
    if (fn == null) {
      String signature=SignatureUtils.getFunctionSignature(name,argumentTypes);
      throw new InterpretException(Errors.FUNCTION_NOT_FOUND,signature).set(position);
    }
    this.last=fn;
  }
  if (unsafe) {
    JetSecurityManager securityManager=ctx.getSecurityManager();
    if (securityManager != null) {
      try {
        fn.checkAccess(securityManager);
      }
 catch (      RuntimeException e) {
        throw new InterpretException(e).set(position);
      }
    }
    unsafe=false;
  }
  try {
    return fn.invoke(arguments);
  }
 catch (  InterpretException e) {
    throw e;
  }
catch (  RuntimeException e) {
    if (useLatest && Errors.isReflectIllegalArgument(e)) {
      return doInvoke(ctx,null,arguments);
    }
    throw new InterpretException(Errors.FUNCTION_INVOKE_ERROR,fn.getSignature()).cause(e).set(position);
  }
}"
56866,"@Override public void execute(InterpretContext ctx) throws InterpretException {
  JetWriter os=ctx.getWriter();
  if (encoder == null) {
    if (os.isStreaming()) {
      encoder=new ByteArrayEncoder(text,os.getCharset());
    }
 else {
      if (JdkUtils.IS_AT_LEAST_JAVA_7) {
        encoder=new Jdk7CharArrayEncoder(text);
      }
 else {
        encoder=new Jdk7CharArrayEncoder(text);
      }
    }
    text=null;
  }
  try {
    encoder.writeTo(os);
  }
 catch (  IOException e) {
    throw new IllegalStateException(e);
  }
}","@Override public void execute(InterpretContext ctx) throws InterpretException {
  JetWriter os=ctx.getWriter();
  if (encoder == null) {
    if (os.isStreaming()) {
      encoder=new ByteArrayEncoder(text,os.getCharset());
    }
 else {
      if (JdkUtils.IS_AT_LEAST_JAVA_7) {
        encoder=new Jdk7CharArrayEncoder(text);
      }
 else {
        encoder=new Jdk6CharArrayEncoder(text);
      }
    }
    text=null;
  }
  try {
    encoder.writeTo(os);
  }
 catch (  IOException e) {
    throw new IllegalStateException(e);
  }
}"
56867,"private void trimDirectiveWhitespacesAndComments(ListIterator<AstStatement> it,int block,ParserContext ctx){
  boolean trimDirectiveWhitespaces=ctx.isTrimDirectiveWhitespaces();
  boolean trimDirectiveComments=ctx.isTrimDirectiveComments();
  String trimDirectiveCommentsPrefix=ctx.getTrimDirectiveCommentsPrefix();
  String trimDirectiveCommentsSuffix=ctx.getTrimDirectiveCommentsSuffix();
  if (!trimDirectiveWhitespaces && !trimDirectiveComments) {
    return;
  }
  it.reset();
  while (it.has()) {
    AstStatement stmt=it.peek();
    if (!(stmt instanceof AstText)) {
      it.move();
      continue;
    }
    AstText text=(AstText)stmt;
    boolean trimLeft;
    boolean keepLeftNewLine=false;
    if (it.hasPrevious()) {
      trimLeft=(it.peek(-1) instanceof AstDirective);
      if (trimLeft) {
        int offset=-1;
        while (it.has(offset)) {
          AstStatement prev=it.peek(offset);
          if (prev instanceof AstText) {
            keepLeftNewLine=((AstText)prev).getLineStop() == text.getLineStart();
            break;
          }
          offset--;
        }
      }
    }
 else {
      trimLeft=(block != Tokens.AST_BLOCK_TEMPLATE);
    }
    boolean trimRight;
    if (it.hasNext()) {
      trimRight=(it.peek(1) instanceof AstDirective);
    }
 else {
      trimRight=(block != Tokens.AST_BLOCK_TEMPLATE);
    }
    if (trimDirectiveComments) {
      text.trimDirectiveComments(trimLeft,trimRight,trimDirectiveCommentsPrefix,trimDirectiveCommentsSuffix);
    }
    if (trimDirectiveWhitespaces) {
      text.trimDirectiveWhitespaces(trimLeft,trimRight,keepLeftNewLine);
    }
    if (!it.hasNext()) {
      if (block == Tokens.AST_BLOCK_TAG || block == Tokens.AST_BLOCK_MACRO) {
        text.trimLastNewLine();
      }
    }
    if (text.isEmpty()) {
      it.remove();
    }
 else {
      it.move();
    }
  }
}","private void trimDirectiveWhitespacesAndComments(ListIterator<AstStatement> it,int block,ParserContext ctx){
  boolean trimDirectiveWhitespaces=ctx.isTrimDirectiveWhitespaces();
  boolean trimDirectiveComments=ctx.isTrimDirectiveComments();
  String trimDirectiveCommentsPrefix=ctx.getTrimDirectiveCommentsPrefix();
  String trimDirectiveCommentsSuffix=ctx.getTrimDirectiveCommentsSuffix();
  if (!trimDirectiveWhitespaces && !trimDirectiveComments) {
    return;
  }
  it.reset();
  while (it.has()) {
    AstStatement stmt=it.peek();
    if (!(stmt instanceof AstText)) {
      it.move();
      continue;
    }
    AstText text=(AstText)stmt;
    boolean trimLeft;
    boolean keepLeftNewLine=false;
    if (it.hasPrevious()) {
      trimLeft=(it.peek(-1) instanceof AstDirective);
      if (trimLeft) {
        if (!it.hasNext() && block == Tokens.AST_BLOCK_TEMPLATE) {
          keepLeftNewLine=true;
        }
 else {
          int offset=-1;
          while (it.has(offset)) {
            AstStatement prev=it.peek(offset);
            if (prev instanceof AstText) {
              keepLeftNewLine=((AstText)prev).getLineStop() == text.getLineStart();
              break;
            }
            offset--;
          }
        }
      }
    }
 else {
      trimLeft=(block != Tokens.AST_BLOCK_TEMPLATE);
    }
    boolean trimRight;
    if (it.hasNext()) {
      trimRight=(it.peek(1) instanceof AstDirective);
    }
 else {
      trimRight=(block != Tokens.AST_BLOCK_TEMPLATE);
    }
    if (trimDirectiveComments) {
      text.trimDirectiveComments(trimLeft,trimRight,trimDirectiveCommentsPrefix,trimDirectiveCommentsSuffix);
    }
    if (trimDirectiveWhitespaces) {
      text.trimDirectiveWhitespaces(trimLeft,trimRight,keepLeftNewLine);
    }
    if (!it.hasNext()) {
      if (block == Tokens.AST_BLOCK_TAG || block == Tokens.AST_BLOCK_MACRO) {
        text.trimLastNewLine();
      }
    }
    if (text.isEmpty()) {
      it.remove();
    }
 else {
      it.move();
    }
  }
}"
56868,"public AstStatementList(List<AstStatement> statements,int block,ParserContext ctx){
  if (statements == null || statements.isEmpty()) {
    this.statements=EMPTY_ARRAY;
  }
 else {
    if (statements.size() > 0 && block != Tokens.AST_BLOCK_SET) {
      ListIterator<AstStatement> it=new ListIterator<AstStatement>(statements);
      combinedContinuousTexts(it);
      trimDirectiveWhitespacesAndComments(it,block,ctx);
      removeAndSplitDirective(it);
      combinedContinuousTexts(it);
    }
    this.statements=statements.toArray(EMPTY_ARRAY);
  }
}","public AstStatementList(List<AstStatement> statements,int block,ParserContext ctx){
  if (statements == null || statements.isEmpty()) {
    this.statements=EMPTY_ARRAY;
  }
 else {
    if (statements.size() > 0 && block != Tokens.AST_BLOCK_SET) {
      ListIterator<AstStatement> it=new ListIterator<AstStatement>(statements);
      splitStatementList(it);
      combinedContinuousTexts(it);
      trimDirectiveWhitespacesAndComments(it,block,ctx);
      removeNoopDirective(it);
      combinedContinuousTexts(it);
    }
    this.statements=statements.toArray(EMPTY_ARRAY);
  }
}"
56869,"public int getLineStop(){
  int line=lineStart;
  if (text != null) {
    int len=text.length();
    for (int i=0; i < len; i++) {
      char c=text.charAt(i);
      if (c == '\r') {
        int n=i + 1;
        if (n < len && text.charAt(n) == '\n') {
          i++;
        }
        line++;
      }
 else       if (c == '\n') {
        line++;
      }
    }
  }
  return line;
}","public int getLineStop(){
  int line=lineStart;
  if (text != null) {
    int len=text.length();
    for (int i=0; i < len; i++) {
      char c=text.charAt(i);
      if (c == '\r') {
        int n=i + 1;
        if (n < len && text.charAt(n) == '\n') {
          i++;
        }
        if (i + 1 < len) {
          line++;
        }
      }
 else       if (c == '\n') {
        if (i + 1 < len) {
          line++;
        }
      }
    }
  }
  return line;
}"
56870,"@Override public Object execute(InterpretContext ctx){
  Object value;
  try {
    value=objectExpression.execute(ctx);
  }
 catch (  InterpretException e) {
    if (!Errors.EXPRESSION_OBJECT_IS_NULL.equals(e.getMessage())) {
      value=null;
    }
 else {
      throw e;
    }
  }
  if (value != null) {
    return value;
  }
 else {
    return defaultExpression.execute(ctx);
  }
}","@Override public Object execute(InterpretContext ctx){
  Object value;
  try {
    value=objectExpression.execute(ctx);
  }
 catch (  InterpretException e) {
    if (Errors.EXPRESSION_OBJECT_IS_NULL.equals(e.getMessage())) {
      value=null;
    }
 else {
      throw e;
    }
  }
  if (value != null) {
    return value;
  }
 else {
    return defaultExpression.execute(ctx);
  }
}"
56871,"@SuppressWarnings(""String_Node_Str"") @Override public void execute(InterpretContext ctx) throws InterpretException {
  Object file=fileExpression.execute(ctx);
  if (file == null) {
    throw new InterpretException(Errors.EXPRESSION_NTH_ARGUMENT_IS_NULL,""String_Node_Str"").set(fileExpression.getPosition());
  }
  if (!(file instanceof String)) {
    throw new InterpretException(Errors.VARIABLE_TYPE_MISMATCH,""String_Node_Str"",file.getClass(),""String_Node_Str"").set(fileExpression.getPosition());
  }
  Object parameters;
  if (parametersExpression == null) {
    parameters=Collections.emptyMap();
  }
 else {
    parameters=parametersExpression.execute(ctx);
    if (parameters == null) {
      parameters=Collections.emptyMap();
    }
 else     if (!(parameters instanceof Map)) {
      throw new InterpretException(Errors.VARIABLE_TYPE_MISMATCH,""String_Node_Str"",parameters.getClass(),""String_Node_Str"").set(parametersExpression.getPosition());
    }
  }
  ctx.doIncludeCall((String)file,(Map<String,Object>)parameters,returnName);
}","@SuppressWarnings(""String_Node_Str"") @Override public void execute(InterpretContext ctx) throws InterpretException {
  Object file=fileExpression.execute(ctx);
  if (file == null) {
    throw new InterpretException(Errors.EXPRESSION_NTH_ARGUMENT_IS_NULL,""String_Node_Str"").set(fileExpression.getPosition());
  }
  if (!(file instanceof String)) {
    throw new InterpretException(Errors.VARIABLE_TYPE_MISMATCH,""String_Node_Str"",file.getClass(),""String_Node_Str"").set(fileExpression.getPosition());
  }
  Object parameters;
  if (parametersExpression == null) {
    parameters=Collections.emptyMap();
  }
 else {
    parameters=parametersExpression.execute(ctx);
    if (parameters == null) {
      parameters=Collections.emptyMap();
    }
 else     if (!(parameters instanceof Map)) {
      throw new InterpretException(Errors.VARIABLE_TYPE_MISMATCH,""String_Node_Str"",parameters.getClass(),""String_Node_Str"").set(parametersExpression.getPosition());
    }
  }
  try {
    String fileName=PathUtils.getRelativePath(ctx.getTemplate().getName(),(String)file);
    ctx.doIncludeCall(fileName,(Map<String,Object>)parameters,returnName);
  }
 catch (  ResourceNotFoundException e) {
    throw new InterpretException(Errors.INCLUDE_FILE_NOT_FOUND,file).set(fileExpression.getPosition());
  }
}"
56872,"private void combinedContinuousTexts(ListIterator<AstStatement> it){
  StringBuilder sb=null;
  it.reset();
  while (it.has()) {
    AstStatement stmt=it.peek();
    if (!(stmt instanceof AstText)) {
      it.move();
      continue;
    }
    if (it.hasNext()) {
      AstStatement next=it.peek(1);
      if (!(next instanceof AstText)) {
        it.move(2);
        continue;
      }
      if (sb == null) {
        sb=new StringBuilder(256);
      }
 else {
        sb.setLength(0);
      }
      sb.append(((AstText)stmt).getText());
      it.remove();
      sb.append(((AstText)next).getText());
      it.remove();
      while (it.has()) {
        next=it.peek();
        if (next instanceof AstText) {
          sb.append(((AstText)next).getText());
          it.remove();
        }
 else {
          break;
        }
      }
      it.add(new AstText(sb.toString(),((AstText)stmt).getLineStart()));
    }
    it.move();
  }
}","private void combinedContinuousTexts(ListIterator<AstStatement> it){
  StringBuilder sb=null;
  it.reset();
  while (it.has()) {
    AstStatement stmt=it.peek();
    if (!(stmt instanceof AstText)) {
      it.move();
      continue;
    }
    if (it.hasNext()) {
      AstStatement next=it.peek(1);
      if (!(next instanceof AstText)) {
        it.move(2);
        continue;
      }
      if (sb == null) {
        sb=new StringBuilder(256);
      }
 else {
        sb.setLength(0);
      }
      sb.append(((AstText)stmt).getText());
      it.remove();
      sb.append(((AstText)next).getText());
      it.remove();
      while (it.has()) {
        next=it.peek();
        if (next instanceof AstText) {
          sb.append(((AstText)next).getText());
          it.remove();
        }
 else {
          break;
        }
      }
      it.add(new AstText(sb.toString(),((AstText)stmt).getLine()));
    }
    it.move();
  }
}"
56873,"private void trimDirectiveWhitespacesAndComments(ListIterator<AstStatement> it,int block,ParserContext ctx){
  boolean trimDirectiveWhitespaces=ctx.isTrimDirectiveWhitespaces();
  boolean trimDirectiveComments=ctx.isTrimDirectiveComments();
  String trimDirectiveCommentsPrefix=ctx.getTrimDirectiveCommentsPrefix();
  String trimDirectiveCommentsSuffix=ctx.getTrimDirectiveCommentsSuffix();
  if (!trimDirectiveWhitespaces && !trimDirectiveComments) {
    return;
  }
  it.reset();
  while (it.has()) {
    AstStatement stmt=it.peek();
    if (!(stmt instanceof AstText)) {
      it.move();
      continue;
    }
    AstText text=(AstText)stmt;
    boolean trimLeft;
    boolean keepLeftNewLine=false;
    if (it.hasPrevious()) {
      trimLeft=(it.peek(-1) instanceof AstDirective);
      if (trimLeft) {
        if (!it.hasNext() && block == Tokens.AST_BLOCK_TEMPLATE) {
          keepLeftNewLine=true;
        }
 else {
          int offset=-1;
          while (it.has(offset)) {
            AstStatement prev=it.peek(offset);
            if (prev instanceof AstText) {
              keepLeftNewLine=((AstText)prev).getLineStop() == text.getLineStart();
              break;
            }
            offset--;
          }
        }
      }
    }
 else {
      trimLeft=(block != Tokens.AST_BLOCK_TEMPLATE);
    }
    boolean trimRight;
    if (it.hasNext()) {
      trimRight=(it.peek(1) instanceof AstDirective);
    }
 else {
      trimRight=(block != Tokens.AST_BLOCK_TEMPLATE);
    }
    if (trimDirectiveComments) {
      text.trimDirectiveComments(trimLeft,trimRight,trimDirectiveCommentsPrefix,trimDirectiveCommentsSuffix);
    }
    if (trimDirectiveWhitespaces) {
      text.trimDirectiveWhitespaces(trimLeft,trimRight,keepLeftNewLine);
    }
    if (!it.hasNext()) {
      if (block == Tokens.AST_BLOCK_TAG || block == Tokens.AST_BLOCK_MACRO) {
        text.trimLastNewLine();
      }
    }
    if (text.isEmpty()) {
      it.remove();
    }
 else {
      it.move();
    }
  }
}","private void trimDirectiveWhitespacesAndComments(ListIterator<AstStatement> it,int block,ParserContext ctx){
  boolean trimDirectiveWhitespaces=ctx.isTrimDirectiveWhitespaces();
  boolean trimDirectiveComments=ctx.isTrimDirectiveComments();
  String trimDirectiveCommentsPrefix=ctx.getTrimDirectiveCommentsPrefix();
  String trimDirectiveCommentsSuffix=ctx.getTrimDirectiveCommentsSuffix();
  if (!trimDirectiveWhitespaces && !trimDirectiveComments) {
    return;
  }
  it.reset();
  while (it.has()) {
    AstStatement stmt=it.peek();
    if (!(stmt instanceof AstText)) {
      it.move();
      continue;
    }
    AstText text=(AstText)stmt;
    boolean trimLeft;
    boolean keepLeftNewLine=false;
    if (it.hasPrevious()) {
      trimLeft=isAstDirective(it.peek(-1));
      if (trimLeft) {
        if (!it.hasNext() && block == Tokens.AST_BLOCK_TEMPLATE) {
          keepLeftNewLine=true;
        }
 else         if (text.getLine() == 1) {
          keepLeftNewLine=true;
        }
 else {
          AstStatement prev=it.peek(-1);
          if (prev != null) {
            if (prev instanceof AstDirective) {
              if (prev instanceof AstDirectiveTag) {
                keepLeftNewLine=true;
              }
 else {
                keepLeftNewLine=((AstDirective)prev).getPosition().getLine() == text.getLine();
              }
            }
          }
        }
      }
    }
 else {
      trimLeft=(block != Tokens.AST_BLOCK_TEMPLATE);
    }
    boolean trimRight;
    if (it.hasNext()) {
      trimRight=isAstDirective(it.peek(1));
    }
 else {
      trimRight=(block != Tokens.AST_BLOCK_TEMPLATE);
    }
    if (trimDirectiveComments) {
      text.trimDirectiveComments(trimLeft,trimRight,trimDirectiveCommentsPrefix,trimDirectiveCommentsSuffix);
    }
    if (trimDirectiveWhitespaces) {
      text.trimDirectiveWhitespaces(trimLeft,trimRight,keepLeftNewLine);
    }
    if (!it.hasNext()) {
      if (block == Tokens.AST_BLOCK_TAG || block == Tokens.AST_BLOCK_MACRO) {
        text.trimLastNewLine();
      }
    }
    if (text.isEmpty()) {
      it.remove();
    }
 else {
      it.move();
    }
  }
}"
56874,"public AstText(String text,int lineStart){
  this.text=text;
  this.lineStart=lineStart;
}","public AstText(String text,int line){
  this.text=text;
  this.line=line;
}"
56875,"protected void trimDirectiveWhitespaces(boolean trimLeft,boolean trimRight,boolean keepLeftNewLine){
  if (text == null || text.length() == 0) {
    return;
  }
  int len=text.length();
  int lpos=0;
  boolean trimedNewLine=false;
  if (trimLeft) {
    for (int i=0; i < len; i++) {
      char c=text.charAt(i);
      if (c == ' ' || c == '\t') {
        continue;
      }
 else       if (c == '\r') {
        if (keepLeftNewLine) {
          lpos=i;
          break;
        }
 else {
          trimedNewLine=true;
          int n=i + 1;
          if (n < len && text.charAt(n) == '\n') {
            lpos=n + 1;
          }
 else {
            lpos=n;
          }
          break;
        }
      }
 else       if (c == '\n') {
        if (keepLeftNewLine) {
          lpos=i;
        }
 else {
          trimedNewLine=true;
          lpos=i + 1;
        }
        break;
      }
 else {
        break;
      }
    }
  }
  int rpos=len;
  if (trimRight) {
    for (int i=len - 1; i >= 0; i--) {
      char c=text.charAt(i);
      if (c == ' ' || c == '\t') {
        continue;
      }
 else       if (c == '\n' || c == '\r') {
        rpos=i + 1;
        break;
      }
 else {
        break;
      }
    }
  }
  if (lpos < rpos) {
    text=text.substring(lpos,rpos);
  }
 else {
    text=null;
  }
  if (trimedNewLine) {
    lineStart++;
  }
}","protected void trimDirectiveWhitespaces(boolean trimLeft,boolean trimRight,boolean keepLeftNewLine){
  if (text == null || text.length() == 0) {
    return;
  }
  int len=text.length();
  int lpos=0;
  boolean trimedNewLine=false;
  if (trimLeft) {
    for (int i=0; i < len; i++) {
      char c=text.charAt(i);
      if (c == ' ' || c == '\t') {
        continue;
      }
 else       if (c == '\r') {
        if (keepLeftNewLine) {
          lpos=i;
          break;
        }
 else {
          trimedNewLine=true;
          int n=i + 1;
          if (n < len && text.charAt(n) == '\n') {
            lpos=n + 1;
          }
 else {
            lpos=n;
          }
          break;
        }
      }
 else       if (c == '\n') {
        if (keepLeftNewLine) {
          lpos=i;
        }
 else {
          trimedNewLine=true;
          lpos=i + 1;
        }
        break;
      }
 else {
        break;
      }
    }
  }
  int rpos=len;
  if (trimRight) {
    for (int i=len - 1; i >= 0; i--) {
      char c=text.charAt(i);
      if (c == ' ' || c == '\t') {
        continue;
      }
 else       if (c == '\n' || c == '\r') {
        rpos=i + 1;
        break;
      }
 else {
        break;
      }
    }
  }
  if (lpos < rpos) {
    text=text.substring(lpos,rpos);
  }
 else {
    text=null;
  }
  if (trimedNewLine) {
    line++;
  }
}"
56876,"public JetTemplateMacro resolveMacro(String name,Class<?>[] argumentTypes);","public JetTemplateMacro resolveMacro(String name,Class<?>[] argumentTypes,boolean root);"
56877,"@Override public JetTemplateMacro resolveMacro(String name,Class<?>[] argumentTypes){
  return macroResolver.resolve(name,argumentTypes);
}","@Override public JetTemplateMacro resolveMacro(String name,Class<?>[] argumentTypes,boolean root){
  JetTemplateMacro macro=macroResolver.resolve(name,argumentTypes);
  if (macro == null && root) {
    macro=engine.getGlobalResolver().resolveMacro(name,argumentTypes);
  }
  return macro;
}"
56878,"public JetTemplateImpl(JetEngine engine,Resource resource,boolean reloadable,JetSecurityManager securityManager){
  this.engine=engine;
  this.resource=resource;
  this.securityManager=securityManager;
  this.config=engine.getConfig();
  this.reloadable=reloadable;
  this.lastModified=0;
  this.macroResolver=new MacroResolver(engine.getGlobalResolver());
}","public JetTemplateImpl(JetEngine engine,Resource resource,boolean reloadable,JetSecurityManager securityManager){
  this.engine=engine;
  this.resource=resource;
  this.securityManager=securityManager;
  this.config=engine.getConfig();
  this.reloadable=reloadable;
  this.lastModified=0;
  this.macroResolver=new MacroResolver();
}"
56879,"@Override public void execute(InterpretContext ctx) throws InterpretException {
  Object[] arguments;
  if (argumentList == null) {
    arguments=ArrayUtils.EMPTY_OBJECT_ARRAY;
  }
 else {
    arguments=argumentList.execute(ctx);
  }
  JetTemplateMacro macro=last;
  if (macro == null) {
    Class<?>[] argumentTypes=ParameterUtils.getParameterTypes(arguments);
    macro=ctx.getTemplate().resolveMacro(name,argumentTypes);
    if (macro == null) {
      throw new InterpretException(Errors.MACRO_NOT_FOUND,name).set(position);
    }
    this.last=macro;
  }
  ctx.doMacroCall(macro,arguments);
}","@Override public void execute(InterpretContext ctx) throws InterpretException {
  Object[] arguments;
  if (argumentList == null) {
    arguments=ArrayUtils.EMPTY_OBJECT_ARRAY;
  }
 else {
    arguments=argumentList.execute(ctx);
  }
  JetTemplateMacro macro=last;
  if (macro == null) {
    Class<?>[] argumentTypes=ParameterUtils.getParameterTypes(arguments);
    macro=ctx.getTemplate().resolveMacro(name,argumentTypes,true);
    if (macro == null) {
      throw new InterpretException(Errors.MACRO_NOT_FOUND,name).set(position);
    }
    this.last=macro;
  }
  ctx.doMacroCall(macro,arguments);
}"
56880,"public JetTemplateMacro resolve(String name,Class<?>[] argumentTypes){
  JetTemplateMacro macro;
  if (decleardMacros != null) {
    macro=decleardMacros.get(name);
    if (macro != null) {
      return macro;
    }
  }
  if (loadedTemplates != null) {
    for (    JetTemplate template : loadedTemplates) {
      macro=template.resolveMacro(name,argumentTypes);
      if (macro != null) {
        return macro;
      }
    }
  }
  if (globalResolver != null) {
    return globalResolver.resolveMacro(name,argumentTypes);
  }
  return null;
}","public JetTemplateMacro resolve(String name,Class<?>[] argumentTypes){
  JetTemplateMacro macro;
  if (decleardMacros != null) {
    macro=decleardMacros.get(name);
    if (macro != null) {
      return macro;
    }
  }
  if (loadedTemplates != null) {
    for (    JetTemplate template : loadedTemplates) {
      macro=template.resolveMacro(name,argumentTypes,false);
      if (macro != null) {
        return macro;
      }
    }
  }
  return null;
}"
56881,"public static String macroGet(String name,Object... arguments){
  InterpretContext ctx=InterpretContext.current();
  Class<?>[] argumentTypes=ParameterUtils.getParameterTypes(arguments);
  JetTemplateMacro macro=ctx.getTemplate().resolveMacro(name,argumentTypes);
  if (macro == null) {
    throw new IllegalStateException(Errors.format(Errors.MACRO_NOT_FOUND,name));
  }
  JetWriter originWriter=ctx.getWriter();
  UnsafeCharArrayWriter out=new UnsafeCharArrayWriter(128);
  ctx.setWriter(JetWriter.create(out,originWriter.getCharset(),false,false));
  ctx.doMacroCall(macro,arguments);
  ctx.setWriter(originWriter);
  return out.toString();
}","public static String macroGet(String name,Object... arguments){
  InterpretContext ctx=InterpretContext.current();
  Class<?>[] argumentTypes=ParameterUtils.getParameterTypes(arguments);
  JetTemplateMacro macro=ctx.getTemplate().resolveMacro(name,argumentTypes,true);
  if (macro == null) {
    throw new IllegalStateException(Errors.format(Errors.MACRO_NOT_FOUND,name));
  }
  JetWriter originWriter=ctx.getWriter();
  UnsafeCharArrayWriter out=new UnsafeCharArrayWriter(128);
  ctx.setWriter(JetWriter.create(out,originWriter.getCharset(),false,false));
  ctx.doMacroCall(macro,arguments);
  ctx.setWriter(originWriter);
  return out.toString();
}"
56882,"protected void trimDirectiveWhitespaces(boolean trimLeft,boolean trimRight,boolean keepLeftNewLine){
  if (text == null || text.length() == 0) {
    return;
  }
  int len=text.length();
  int lpos=0;
  boolean trimedNewLine=false;
  if (trimLeft) {
    for (int i=0; i < len; i++) {
      char c=text.charAt(i);
      if (c == ' ' || c == '\t') {
        continue;
      }
 else       if (c == '\r') {
        if (keepLeftNewLine) {
          lpos=i;
          break;
        }
 else {
          trimedNewLine=true;
          int n=i + 1;
          if (n < len && text.charAt(n) == '\n') {
            lpos=n;
          }
 else {
            lpos=i;
          }
          break;
        }
      }
 else       if (c == '\n') {
        if (keepLeftNewLine) {
          lpos=i;
        }
 else {
          trimedNewLine=true;
          lpos=i + 1;
        }
        break;
      }
 else {
        break;
      }
    }
  }
  int rpos=len;
  if (trimRight) {
    for (int i=len - 1; i >= 0; i--) {
      char c=text.charAt(i);
      if (c == ' ' || c == '\t') {
        continue;
      }
 else       if (c == '\n' || c == '\r') {
        rpos=i + 1;
        break;
      }
 else {
        break;
      }
    }
  }
  if (lpos < rpos) {
    text=text.substring(lpos,rpos);
  }
 else {
    text=null;
  }
  if (trimedNewLine) {
    lineStart++;
  }
}","protected void trimDirectiveWhitespaces(boolean trimLeft,boolean trimRight,boolean keepLeftNewLine){
  if (text == null || text.length() == 0) {
    return;
  }
  int len=text.length();
  int lpos=0;
  boolean trimedNewLine=false;
  if (trimLeft) {
    for (int i=0; i < len; i++) {
      char c=text.charAt(i);
      if (c == ' ' || c == '\t') {
        continue;
      }
 else       if (c == '\r') {
        if (keepLeftNewLine) {
          lpos=i;
          break;
        }
 else {
          trimedNewLine=true;
          int n=i + 1;
          if (n < len && text.charAt(n) == '\n') {
            lpos=n + 1;
          }
 else {
            lpos=n;
          }
          break;
        }
      }
 else       if (c == '\n') {
        if (keepLeftNewLine) {
          lpos=i;
        }
 else {
          trimedNewLine=true;
          lpos=i + 1;
        }
        break;
      }
 else {
        break;
      }
    }
  }
  int rpos=len;
  if (trimRight) {
    for (int i=len - 1; i >= 0; i--) {
      char c=text.charAt(i);
      if (c == ' ' || c == '\t') {
        continue;
      }
 else       if (c == '\n' || c == '\r') {
        rpos=i + 1;
        break;
      }
 else {
        break;
      }
    }
  }
  if (lpos < rpos) {
    text=text.substring(lpos,rpos);
  }
 else {
    text=null;
  }
  if (trimedNewLine) {
    lineStart++;
  }
}"
56883,"private static JetEngine doCreateWebEngine(ServletContext sc,Properties config,String configLocation){
  Properties options=new Properties();
  options.setProperty(JetConfig.IO_SKIPERRORS,""String_Node_Str"");
  options.setProperty(JetConfig.TEMPLATE_LOADERS,ServletResourceLoader.class.getName());
  if (config != null) {
    options.putAll(config);
  }
  if (configLocation == null) {
    configLocation=sc.getInitParameter(CONFIG_LOCATION_PARAMETER);
    if (configLocation == null || configLocation.length() == 0) {
      configLocation=JetConfig.DEFAULT_CONFIG_FILE;
    }
  }
  JetEngine engine=JetEngine.create(options,configLocation);
  JetGlobalContext ctx=engine.getGlobalContext();
  ctx.define(javax.servlet.ServletContext.class,JetWebContext.APPLICATION);
  ctx.define(javax.servlet.http.HttpSession.class,JetWebContext.SESSION);
  ctx.define(javax.servlet.http.HttpServletRequest.class,JetWebContext.REQUEST);
  ctx.define(javax.servlet.http.HttpServletResponse.class,JetWebContext.RESPONSE);
  ctx.define(java.util.Map.class,JetWebContext.APPLICATION_SCOPE);
  ctx.define(java.util.Map.class,JetWebContext.SESSION_SCOPE);
  ctx.define(java.util.Map.class,JetWebContext.REQUEST_SCOPE);
  ctx.define(java.util.Map.class,JetWebContext.PARAMETER);
  ctx.define(java.util.Map.class,JetWebContext.PARAMETER_VALUES);
  ctx.set(JetWebContext.APPLICATION,sc);
  ctx.set(JetWebContext.APPLICATION_SCOPE,new ServletContextAttributeMap(sc));
  engine.getGlobalResolver().registerTags(JetWebTags.class);
  return engine;
}","private static JetEngine doCreateWebEngine(ServletContext sc,Properties config,String configLocation){
  Properties options=new Properties();
  options.setProperty(JetConfig.IO_SKIPERRORS,""String_Node_Str"");
  options.setProperty(JetConfig.TEMPLATE_LOADERS,ServletResourceLoader.class.getName());
  if (config != null) {
    options.putAll(config);
  }
  if (configLocation == null) {
    configLocation=sc.getInitParameter(CONFIG_LOCATION_PARAMETER);
    if (configLocation == null || configLocation.length() == 0) {
      configLocation=JetConfig.DEFAULT_CONFIG_FILE;
    }
  }
  JetEngine engine=JetEngine.create(options,configLocation);
  JetGlobalContext ctx=engine.getGlobalContext();
  ctx.define(javax.servlet.ServletContext.class,JetWebContext.APPLICATION);
  ctx.define(javax.servlet.http.HttpSession.class,JetWebContext.SESSION);
  ctx.define(javax.servlet.http.HttpServletRequest.class,JetWebContext.REQUEST);
  ctx.define(javax.servlet.http.HttpServletResponse.class,JetWebContext.RESPONSE);
  ctx.define(java.util.Map.class,JetWebContext.APPLICATION_SCOPE);
  ctx.define(java.util.Map.class,JetWebContext.SESSION_SCOPE);
  ctx.define(java.util.Map.class,JetWebContext.REQUEST_SCOPE);
  ctx.define(java.util.Map.class,JetWebContext.PARAM);
  ctx.define(java.util.Map.class,JetWebContext.PARAM_VALUES);
  ctx.set(JetWebContext.APPLICATION,sc);
  ctx.set(JetWebContext.APPLICATION_SCOPE,new ServletContextAttributeMap(sc));
  engine.getGlobalResolver().registerTags(JetWebTags.class);
  return engine;
}"
56884,"private void doInvoke(InterpretContext ctx,TagInvoker invoker,Object[] arguments) throws InterpretException {
  boolean useLatest=(invoker != null);
  if (invoker == null) {
    Class<?>[] argumentTypes=ParameterUtils.getParameterTypes(arguments);
    invoker=ctx.getGlobalResolver().resolveTag(name,argumentTypes);
    if (invoker == null) {
      String signature=SignatureUtils.getFunctionSignature(name,argumentTypes);
      throw new InterpretException(Errors.TAG_NOT_FOUND,signature).set(position);
    }
    this.last=invoker;
  }
  try {
    invoker.invoke(tagContext,arguments);
  }
 catch (  RuntimeException e) {
    if (useLatest && Errors.isReflectIllegalArgument(e)) {
      doInvoke(ctx,null,arguments);
    }
    throw new InterpretException(e).set(position);
  }
}","private void doInvoke(InterpretContext ctx,TagInvoker invoker,Object[] arguments) throws InterpretException {
  boolean useLatest=(invoker != null);
  if (invoker == null) {
    Class<?>[] argumentTypes=ParameterUtils.getParameterTypes(arguments);
    invoker=ctx.getGlobalResolver().resolveTag(name,argumentTypes);
    if (invoker == null) {
      String signature=SignatureUtils.getFunctionSignature(name,argumentTypes);
      throw new InterpretException(Errors.TAG_NOT_FOUND,signature).set(position);
    }
    this.last=invoker;
  }
  try {
    invoker.invoke(tagContext,arguments);
  }
 catch (  InterpretException e) {
    throw e;
  }
catch (  RuntimeException e) {
    if (useLatest && Errors.isReflectIllegalArgument(e)) {
      doInvoke(ctx,null,arguments);
    }
    throw new InterpretException(e).set(position);
  }
}"
56885,"private Object doInvoke(InterpretContext ctx,FunctionInvoker fn,Object[] arguments) throws InterpretException {
  boolean useLatest=(fn != null);
  if (fn == null) {
    Class<?>[] argumentTypes=ParameterUtils.getParameterTypes(arguments);
    fn=resolveFunction(ctx,argumentTypes);
    if (fn == null) {
      String signature=SignatureUtils.getFunctionSignature(name,argumentTypes);
      throw new InterpretException(Errors.FUNCTION_NOT_FOUND,signature).set(position);
    }
    this.last=fn;
  }
  try {
    return fn.invoke(arguments);
  }
 catch (  RuntimeException e) {
    if (useLatest && Errors.isReflectIllegalArgument(e)) {
      return doInvoke(ctx,null,arguments);
    }
    throw new InterpretException(Errors.FUNCTION_INVOKE_ERROR).cause(e).set(position);
  }
}","private Object doInvoke(InterpretContext ctx,FunctionInvoker fn,Object[] arguments) throws InterpretException {
  boolean useLatest=(fn != null);
  if (fn == null) {
    Class<?>[] argumentTypes=ParameterUtils.getParameterTypes(arguments);
    fn=resolveFunction(ctx,argumentTypes);
    if (fn == null) {
      String signature=SignatureUtils.getFunctionSignature(name,argumentTypes);
      throw new InterpretException(Errors.FUNCTION_NOT_FOUND,signature).set(position);
    }
    this.last=fn;
  }
  try {
    return fn.invoke(arguments);
  }
 catch (  InterpretException e) {
    throw e;
  }
catch (  RuntimeException e) {
    if (useLatest && Errors.isReflectIllegalArgument(e)) {
      return doInvoke(ctx,null,arguments);
    }
    throw new InterpretException(Errors.FUNCTION_INVOKE_ERROR).cause(e).set(position);
  }
}"
56886,"private Object doInvoke(InterpretContext ctx,MethodInvoker invoker,Object object,Object[] arguments) throws InterpretException {
  boolean useLatest=(invoker != null);
  if (invoker == null) {
    Class<?> objectClass=objectExpression.getResultType(ctx.getValueStack(),object);
    Class<?>[] argumentTypes=ParameterUtils.getParameterTypes(arguments);
    invoker=ctx.getGlobalResolver().resolveMethod(objectClass,name,argumentTypes,false);
    if (invoker == null) {
      String signature=SignatureUtils.getMethodSignature(objectClass,name,argumentTypes);
      throw new InterpretException(Errors.METHOD_NOT_FOUND,signature).set(position);
    }
    this.last=invoker;
  }
  try {
    Object result=invoker.invoke(object,arguments);
    if (result != null) {
      return result;
    }
 else {
      return (invoker.isVoidResult()) ? ALU.VOID : null;
    }
  }
 catch (  RuntimeException e) {
    if (useLatest && Errors.isReflectIllegalArgument(e)) {
      return doInvoke(ctx,null,object,arguments);
    }
    throw new InterpretException(Errors.METHOD_INVOKE_ERROR).cause(e).set(position);
  }
}","private Object doInvoke(InterpretContext ctx,MethodInvoker invoker,Object object,Object[] arguments) throws InterpretException {
  boolean useLatest=(invoker != null);
  if (invoker == null) {
    Class<?> objectClass=objectExpression.getResultType(ctx.getValueStack(),object);
    Class<?>[] argumentTypes=ParameterUtils.getParameterTypes(arguments);
    invoker=ctx.getGlobalResolver().resolveMethod(objectClass,name,argumentTypes,false);
    if (invoker == null) {
      String signature=SignatureUtils.getMethodSignature(objectClass,name,argumentTypes);
      throw new InterpretException(Errors.METHOD_NOT_FOUND,signature).set(position);
    }
    this.last=invoker;
  }
  try {
    Object result=invoker.invoke(object,arguments);
    if (result != null) {
      return result;
    }
 else {
      return (invoker.isVoidResult()) ? ALU.VOID : null;
    }
  }
 catch (  InterpretException e) {
    throw e;
  }
catch (  RuntimeException e) {
    if (useLatest && Errors.isReflectIllegalArgument(e)) {
      return doInvoke(ctx,null,object,arguments);
    }
    throw new InterpretException(Errors.METHOD_INVOKE_ERROR).cause(e).set(position);
  }
}"
56887,"@Override public void execute(InterpretContext ctx) throws InterpretException {
  Object[] arguments;
  if (argumentList == null) {
    arguments=ArrayUtils.EMPTY_OBJECT_ARRAY;
  }
 else {
    arguments=argumentList.execute(ctx);
  }
  JetTemplateMacro macro=last;
  if (macro == null) {
    Class<?>[] argumentTypes=ParameterUtils.getParameterTypes(arguments);
    macro=ctx.getTemplate().resolveMacro(name,argumentTypes);
    if (macro == null) {
      throw new IllegalStateException(Errors.format(Errors.MACRO_NOT_FOUND,name));
    }
    this.last=macro;
  }
  ctx.doMacroCall(macro,arguments);
}","@Override public void execute(InterpretContext ctx) throws InterpretException {
  Object[] arguments;
  if (argumentList == null) {
    arguments=ArrayUtils.EMPTY_OBJECT_ARRAY;
  }
 else {
    arguments=argumentList.execute(ctx);
  }
  JetTemplateMacro macro=last;
  if (macro == null) {
    Class<?>[] argumentTypes=ParameterUtils.getParameterTypes(arguments);
    macro=ctx.getTemplate().resolveMacro(name,argumentTypes);
    if (macro == null) {
      throw new InterpretException(Errors.MACRO_NOT_FOUND,name).set(position);
    }
    this.last=macro;
  }
  ctx.doMacroCall(macro,arguments);
}"
56888,"@Override public void execute(InterpretContext ctx) throws InterpretException {
  Object result=expression.execute(ctx);
  JetForIterator it=new JetForIterator(result);
  if (it.getSize() > 0) {
    ValueStack valueStack=ctx.getValueStack();
    Object old=valueStack.getValue(Symbols.FOR);
    valueStack.setLocal(Symbols.FOR,it);
    while (it.hasNext()) {
      Object item=it.next();
      try {
        valueStack.setLocal(identifier,item);
      }
 catch (      IllegalStateException e) {
        throw new InterpretException(Errors.FOR_ITERATOR_ERROR,it.getIndex()).cause(e).set(expression.getPosition());
      }
      statements.execute(ctx);
      int signal=ctx.getSignal();
      if (signal != InterpretContext.SIGNAL_NONE) {
        if (signal == InterpretContext.SIGNAL_BREAK) {
          ctx.setSignal(InterpretContext.SIGNAL_NONE);
          break;
        }
 else         if (signal == InterpretContext.SIGNAL_CONTINUE) {
          ctx.setSignal(InterpretContext.SIGNAL_NONE);
          continue;
        }
 else {
          return;
        }
      }
    }
    valueStack.setLocal(Symbols.FOR,old);
  }
 else   if (elseStatements != null) {
    elseStatements.execute(ctx);
  }
}","@Override public void execute(InterpretContext ctx) throws InterpretException {
  Object result=expression.execute(ctx);
  JetForIterator it=new JetForIterator(result);
  if (it.getSize() > 0) {
    ValueStack valueStack=ctx.getValueStack();
    Object outsideIdentifier=valueStack.getValue(identifier);
    Object outsideFor=valueStack.getValue(Symbols.FOR);
    valueStack.setLocal(Symbols.FOR,it);
    while (it.hasNext()) {
      Object item=it.next();
      try {
        valueStack.setLocal(identifier,item);
      }
 catch (      IllegalStateException e) {
        throw new InterpretException(Errors.FOR_ITERATOR_ERROR,it.getIndex()).cause(e).set(expression.getPosition());
      }
      statements.execute(ctx);
      int signal=ctx.getSignal();
      if (signal != InterpretContext.SIGNAL_NONE) {
        if (signal == InterpretContext.SIGNAL_BREAK) {
          ctx.setSignal(InterpretContext.SIGNAL_NONE);
          break;
        }
 else         if (signal == InterpretContext.SIGNAL_CONTINUE) {
          ctx.setSignal(InterpretContext.SIGNAL_NONE);
          continue;
        }
 else {
          return;
        }
      }
    }
    valueStack.setLocal(Symbols.FOR,outsideFor);
    valueStack.setLocal(identifier,outsideIdentifier);
  }
 else   if (elseStatements != null) {
    elseStatements.execute(ctx);
  }
}"
56889,"public void defineSymbol(String name,Class<?> type,boolean allowSameRedefine) throws IllegalStateException {
  if (type == null && strict) {
    throw new IllegalStateException(Errors.format(Errors.PARAM_TYPE_MISSING,name));
  }
  if (currentSymbols.containsKey(name)) {
    Class<?> old=currentSymbols.get(name);
    if (allowSameRedefine && type == old) {
      return;
    }
    throw new IllegalStateException(Errors.format(Errors.VAR_TYPE_REDEFINE,name));
  }
  currentSymbols.put(name,type);
}","public void defineSymbol(String name,Class<?> type,boolean allowSameRedefine) throws IllegalStateException {
  if (type == null && strict) {
    throw new IllegalStateException(Errors.format(Errors.PARAM_TYPE_MISSING,name));
  }
  if (currentSymbols.containsKey(name)) {
    Class<?> old=currentSymbols.get(name);
    if (allowSameRedefine && type == old) {
      return;
    }
    if (old == null) {
      throw new IllegalStateException(Errors.format(Errors.VAR_TYPE_DEFAINE_AFTER_USE,name));
    }
 else {
      throw new IllegalStateException(Errors.format(Errors.VAR_TYPE_REDEFINE,name));
    }
  }
  currentSymbols.put(name,type);
}"
56890,"private void doInvoke(InterpretContext ctx,TagInvoker invoker,Object[] arguments) throws InterpretException {
  boolean useLatest=(invoker != null);
  if (invoker == null) {
    Class<?>[] argumentTypes=ParameterUtils.getParameterTypes(arguments);
    invoker=ctx.getGlobalResolver().resolveTag(name,argumentTypes);
    if (invoker == null) {
      String signature=SignatureUtils.getFunctionSignature(name,argumentTypes);
      throw new InterpretException(Errors.TAG_NOT_FOUND,signature).set(position);
    }
    this.last=invoker;
  }
  try {
    invoker.invoke(tagContext,arguments);
  }
 catch (  IllegalArgumentException e) {
    if (useLatest && Errors.isReflectArgumentNotMatch(e)) {
      doInvoke(ctx,null,arguments);
    }
    throw new InterpretException(e).set(position);
  }
}","private void doInvoke(InterpretContext ctx,TagInvoker invoker,Object[] arguments) throws InterpretException {
  boolean useLatest=(invoker != null);
  if (invoker == null) {
    Class<?>[] argumentTypes=ParameterUtils.getParameterTypes(arguments);
    invoker=ctx.getGlobalResolver().resolveTag(name,argumentTypes);
    if (invoker == null) {
      String signature=SignatureUtils.getFunctionSignature(name,argumentTypes);
      throw new InterpretException(Errors.TAG_NOT_FOUND,signature).set(position);
    }
    this.last=invoker;
  }
  try {
    invoker.invoke(tagContext,arguments);
  }
 catch (  RuntimeException e) {
    if (useLatest && Errors.isReflectIllegalArgument(e)) {
      doInvoke(ctx,null,arguments);
    }
    throw new InterpretException(e).set(position);
  }
}"
56891,"private Object doInvokeGetter(InterpretContext ctx,Getter getter,Object object) throws InterpretException {
  boolean useLatest=(getter != null);
  if (getter == null) {
    Class<?> objectClass=objectExpression.getResultType(ctx.getValueStack(),object);
    getter=ctx.getGlobalResolver().resolveGetter(objectClass,name);
    if (getter == null) {
      String signature=SignatureUtils.getFieldSignature(objectClass,name);
      throw new InterpretException(Errors.PROPERTY_NOT_FOUND,signature).set(position);
    }
    this.last=getter;
  }
  try {
    return getter.get(object);
  }
 catch (  IllegalArgumentException e) {
    if (useLatest && Errors.isReflectArgumentNotMatch(e)) {
      return doInvokeGetter(ctx,null,object);
    }
    throw new InterpretException(Errors.PROPERTY_GET_ERROR).cause(e).set(position);
  }
}","private Object doInvokeGetter(InterpretContext ctx,Getter getter,Object object) throws InterpretException {
  boolean useLatest=(getter != null);
  if (getter == null) {
    Class<?> objectClass=objectExpression.getResultType(ctx.getValueStack(),object);
    getter=ctx.getGlobalResolver().resolveGetter(objectClass,name);
    if (getter == null) {
      String signature=SignatureUtils.getFieldSignature(objectClass,name);
      throw new InterpretException(Errors.PROPERTY_NOT_FOUND,signature).set(position);
    }
    this.last=getter;
  }
  try {
    return getter.get(object);
  }
 catch (  RuntimeException e) {
    if (useLatest && Errors.isReflectIllegalArgument(e)) {
      return doInvokeGetter(ctx,null,object);
    }
    throw new InterpretException(Errors.PROPERTY_GET_ERROR).cause(e).set(position);
  }
}"
56892,"private Object doInvoke(InterpretContext ctx,FunctionInvoker fn,Object[] arguments) throws InterpretException {
  boolean useLatest=(fn != null);
  if (fn == null) {
    Class<?>[] argumentTypes=ParameterUtils.getParameterTypes(arguments);
    fn=resolveFunction(ctx,argumentTypes);
    if (fn == null) {
      String signature=SignatureUtils.getFunctionSignature(name,argumentTypes);
      throw new InterpretException(Errors.FUNCTION_NOT_FOUND,signature).set(position);
    }
    this.last=fn;
  }
  try {
    return fn.invoke(arguments);
  }
 catch (  IllegalArgumentException e) {
    if (useLatest && Errors.isReflectArgumentNotMatch(e)) {
      return doInvoke(ctx,null,arguments);
    }
    throw new InterpretException(Errors.FUNCTION_INVOKE_ERROR).cause(e).set(position);
  }
}","private Object doInvoke(InterpretContext ctx,FunctionInvoker fn,Object[] arguments) throws InterpretException {
  boolean useLatest=(fn != null);
  if (fn == null) {
    Class<?>[] argumentTypes=ParameterUtils.getParameterTypes(arguments);
    fn=resolveFunction(ctx,argumentTypes);
    if (fn == null) {
      String signature=SignatureUtils.getFunctionSignature(name,argumentTypes);
      throw new InterpretException(Errors.FUNCTION_NOT_FOUND,signature).set(position);
    }
    this.last=fn;
  }
  try {
    return fn.invoke(arguments);
  }
 catch (  RuntimeException e) {
    if (useLatest && Errors.isReflectIllegalArgument(e)) {
      return doInvoke(ctx,null,arguments);
    }
    throw new InterpretException(Errors.FUNCTION_INVOKE_ERROR).cause(e).set(position);
  }
}"
56893,"private Object doInvoke(InterpretContext ctx,MethodInvoker invoker,Object object,Object[] arguments) throws InterpretException {
  boolean useLatest=(invoker != null);
  if (invoker == null) {
    Class<?> objectClass=objectExpression.getResultType(ctx.getValueStack(),object);
    Class<?>[] argumentTypes=ParameterUtils.getParameterTypes(arguments);
    invoker=ctx.getGlobalResolver().resolveMethod(objectClass,name,argumentTypes,false);
    if (invoker == null) {
      String signature=SignatureUtils.getMethodSignature(objectClass,name,argumentTypes);
      throw new InterpretException(Errors.METHOD_NOT_FOUND,signature).set(position);
    }
    this.last=invoker;
  }
  try {
    Object result=invoker.invoke(object,arguments);
    if (result != null) {
      return result;
    }
 else {
      return (invoker.isVoidResult()) ? ALU.VOID : null;
    }
  }
 catch (  IllegalArgumentException e) {
    if (useLatest && Errors.isReflectArgumentNotMatch(e)) {
      return doInvoke(ctx,null,object,arguments);
    }
    throw new InterpretException(Errors.METHOD_INVOKE_ERROR).cause(e).set(position);
  }
}","private Object doInvoke(InterpretContext ctx,MethodInvoker invoker,Object object,Object[] arguments) throws InterpretException {
  boolean useLatest=(invoker != null);
  if (invoker == null) {
    Class<?> objectClass=objectExpression.getResultType(ctx.getValueStack(),object);
    Class<?>[] argumentTypes=ParameterUtils.getParameterTypes(arguments);
    invoker=ctx.getGlobalResolver().resolveMethod(objectClass,name,argumentTypes,false);
    if (invoker == null) {
      String signature=SignatureUtils.getMethodSignature(objectClass,name,argumentTypes);
      throw new InterpretException(Errors.METHOD_NOT_FOUND,signature).set(position);
    }
    this.last=invoker;
  }
  try {
    Object result=invoker.invoke(object,arguments);
    if (result != null) {
      return result;
    }
 else {
      return (invoker.isVoidResult()) ? ALU.VOID : null;
    }
  }
 catch (  RuntimeException e) {
    if (useLatest && Errors.isReflectIllegalArgument(e)) {
      return doInvoke(ctx,null,object,arguments);
    }
    throw new InterpretException(Errors.METHOD_INVOKE_ERROR).cause(e).set(position);
  }
}"
56894,"private Object doInvoke(InterpretContext ctx,MethodInvoker invoker,Object[] arguments) throws InterpretException {
  boolean useLatest=(invoker != null);
  if (invoker == null) {
    Class<?>[] argumentTypes=ParameterUtils.getParameterTypes(arguments);
    invoker=ctx.getGlobalResolver().resolveMethod(cls,name,argumentTypes,true);
    if (invoker == null) {
      String signature=SignatureUtils.getMethodSignature(cls,name,argumentTypes);
      throw new InterpretException(Errors.METHOD_STATIC_NOT_FOUND,signature).set(position);
    }
    this.last=invoker;
  }
  try {
    Object result=invoker.invoke(null,arguments);
    if (result != null) {
      return result;
    }
 else {
      return (invoker.isVoidResult()) ? ALU.VOID : null;
    }
  }
 catch (  IllegalArgumentException e) {
    if (useLatest && Errors.isReflectArgumentNotMatch(e)) {
      return doInvoke(ctx,null,arguments);
    }
    throw new InterpretException(Errors.STATIC_METHOD_INVOKE_ERROR).cause(e).set(position);
  }
}","private Object doInvoke(InterpretContext ctx,MethodInvoker invoker,Object[] arguments) throws InterpretException {
  boolean useLatest=(invoker != null);
  if (invoker == null) {
    Class<?>[] argumentTypes=ParameterUtils.getParameterTypes(arguments);
    invoker=ctx.getGlobalResolver().resolveMethod(cls,name,argumentTypes,true);
    if (invoker == null) {
      String signature=SignatureUtils.getMethodSignature(cls,name,argumentTypes);
      throw new InterpretException(Errors.METHOD_STATIC_NOT_FOUND,signature).set(position);
    }
    this.last=invoker;
  }
  try {
    Object result=invoker.invoke(null,arguments);
    if (result != null) {
      return result;
    }
 else {
      return (invoker.isVoidResult()) ? ALU.VOID : null;
    }
  }
 catch (  RuntimeException e) {
    if (useLatest && Errors.isReflectIllegalArgument(e)) {
      return doInvoke(ctx,null,arguments);
    }
    throw new InterpretException(Errors.STATIC_METHOD_INVOKE_ERROR).cause(e).set(position);
  }
}"
56895,"@Override public Object getConvertedValue(FacesContext fc,UIComponent c,Object sval) throws ConverterException {
  Converter cnv=resolveConverter(fc,c);
  if (cnv != null) {
    return cnv.getAsObject(fc,c,(String)sval);
  }
 else {
    cnv=new DoubleConverter();
    return cnv.getAsObject(fc,c,(String)sval);
  }
}","@Override public Object getConvertedValue(FacesContext fc,UIComponent c,Object sval) throws ConverterException {
  Converter cnv=resolveConverter(fc,c,sval);
  if (cnv != null) {
    return cnv.getAsObject(fc,c,(String)sval);
  }
 else {
    cnv=new DoubleConverter();
    return cnv.getAsObject(fc,c,(String)sval);
  }
}"
56896,"protected Converter resolveConverter(FacesContext context,UIComponent c){
  if (!(c instanceof ValueHolder)) {
    return null;
  }
  Converter cnv=((ValueHolder)c).getConverter();
  if (cnv != null) {
    return cnv;
  }
 else {
    ValueExpression ve=c.getValueExpression(""String_Node_Str"");
    if (ve != null) {
      Class<?> valType=ve.getType(context.getELContext());
      if (valType != null && (!valType.isPrimitive())) {
        return context.getApplication().createConverter(valType);
      }
    }
    return null;
  }
}","protected Converter resolveConverter(FacesContext context,UIComponent c,Object value){
  if (!(c instanceof ValueHolder)) {
    return null;
  }
  Converter cnv=((ValueHolder)c).getConverter();
  if (cnv != null) {
    return cnv;
  }
 else {
    ValueExpression ve=c.getValueExpression(""String_Node_Str"");
    if (ve != null) {
      Class<?> valType=ve.getType(context.getELContext());
      if (valType != null && (!valType.isPrimitive())) {
        return context.getApplication().createConverter(valType);
      }
 else       if (valType != null && (value instanceof String)) {
        return context.getApplication().createConverter(valType);
      }
    }
    return null;
  }
}"
56897,"/** 
 * This method is called by the JSF framework to get the type-safe value of the attribute. Do not delete this method.
 */
@Override public Object getConvertedValue(FacesContext fc,UIComponent c,Object sval) throws ConverterException {
  Converter cnv=resolveConverter(fc,c);
  if (cnv != null) {
    if (sval == null || sval instanceof String) {
      return cnv.getAsObject(fc,c,(String)sval);
    }
 else {
      return cnv.getAsObject(fc,c,String.valueOf(sval));
    }
  }
 else {
    return sval;
  }
}","/** 
 * This method is called by the JSF framework to get the type-safe value of the attribute. Do not delete this method.
 */
@Override public Object getConvertedValue(FacesContext fc,UIComponent c,Object sval) throws ConverterException {
  Converter cnv=resolveConverter(fc,c,sval);
  if (cnv != null) {
    if (sval == null || sval instanceof String) {
      return cnv.getAsObject(fc,c,(String)sval);
    }
 else {
      return cnv.getAsObject(fc,c,String.valueOf(sval));
    }
  }
 else {
    return sval;
  }
}"
56898,"/** 
 * This methods generates the HTML code of the current b:dataTable. <code>encodeBegin</code> generates the start of the component. After the, the JSF framework calls <code>encodeChildren()</code> to generate the HTML code between the beginning and the end of the component. For instance, in the case of a panel component the content of the panel is generated by <code>encodeChildren()</code>. After that, <code>encodeEnd()</code> is called to generate the rest of the HTML code.
 * @param context the FacesContext.
 * @param component the current b:dataTable.
 * @throws IOException thrown if something goes wrong when writing the HTML code.
 */
@Override public void encodeEnd(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  DataTable dataTable=(DataTable)component;
  Map<Integer,String> columnSortOrder=dataTable.getColumnSortOrderMap();
  int pageLength=dataTable.getPageLength();
  String orderString=""String_Node_Str"";
  if (columnSortOrder != null) {
    StringBuilder sb=new StringBuilder();
    int i=0;
    for (    Map.Entry<Integer,String> entry : columnSortOrder.entrySet()) {
      String separator=(i > 0) ? ""String_Node_Str"" : ""String_Node_Str"";
      sb.append(separator).append(""String_Node_Str"").append(entry.getKey()).append(""String_Node_Str"").append(""String_Node_Str"").append(entry.getValue()).append(""String_Node_Str"").append(""String_Node_Str"");
      i++;
    }
    orderString=sb.toString();
  }
  ResponseWriter rw=context.getResponseWriter();
  String clientIdRaw=dataTable.getClientId();
  String clientId=clientIdRaw.replace(""String_Node_Str"",""String_Node_Str"");
  String widgetVar=dataTable.getWidgetVar();
  if (null == widgetVar) {
    widgetVar=BsfUtils.widgetVarName(clientIdRaw);
  }
  String lang=determineLanguage(context,dataTable);
  rw.endElement(""String_Node_Str"");
  endDisabledFieldset(dataTable,rw);
  String responsiveStyle=Responsive.getResponsiveStyleClass(dataTable,false);
  if (null != responsiveStyle && responsiveStyle.trim().length() > 0) {
    rw.endElement(""String_Node_Str"");
  }
  if (dataTable.isScrollHorizontally()) {
    rw.endElement(""String_Node_Str"");
  }
  Tooltip.activateTooltips(context,dataTable);
  rw.startElement(""String_Node_Str"",component);
  rw.writeText(""String_Node_Str"",null);
  String options=""String_Node_Str"";
  options=addOptions(""String_Node_Str"" + dataTable.isFixedHeader(),options);
  options=addOptions(""String_Node_Str"" + dataTable.isResponsive(),options);
  options=addOptions(""String_Node_Str"" + dataTable.isPaginated(),options);
  if (!dataTable.isInfo()) {
    options=addOptions(""String_Node_Str"",options);
  }
  options=addOptions(""String_Node_Str"" + pageLength,options);
  options=addOptions(""String_Node_Str"" + getPageLengthMenu(dataTable),options);
  options=addOptions(""String_Node_Str"" + dataTable.isSearching(),options);
  options=addOptions(""String_Node_Str"" + orderString,options);
  options=addOptions(""String_Node_Str"" + dataTable.isSaveState(),options);
  options=addOptions(""String_Node_Str"",options);
  if (dataTable.isSelect()) {
    String json=""String_Node_Str"";
    String items=dataTable.getSelectedItems();
    if (""String_Node_Str"".equals(items) || ""String_Node_Str"".equals(items)) {
      json+=""String_Node_Str"";
    }
 else     if (""String_Node_Str"".equals(items) || ""String_Node_Str"".equals(items)) {
      json+=""String_Node_Str"";
    }
    if (""String_Node_Str"".equalsIgnoreCase(dataTable.getSelectionMode())) {
      json+=""String_Node_Str"";
    }
 else {
      json+=""String_Node_Str"";
    }
    if (!dataTable.isSelectionInfo()) {
      json+=""String_Node_Str"";
    }
    if (dataTable.isDeselectOnBackdropClick()) {
      json+=""String_Node_Str"";
    }
    if (json.length() > 1) {
      json=""String_Node_Str"" + json.substring(0,json.length() - 1) + ""String_Node_Str"";
    }
 else {
      json=""String_Node_Str"";
    }
    options=addOptions(json,options);
  }
  options=addOptions(generateScrollOptions(dataTable),options);
  options=addOptions((BsfUtils.isStringValued(lang) ? ""String_Node_Str"" + lang + ""String_Node_Str"" : null),options);
  options=addOptions(generateColumnInfos(dataTable.getColumnInfo()),options);
  options=addOptions(dataTable.getCustomOptions(),options);
  options=addOptions(getButtons(dataTable),options);
  String selectCommand=""String_Node_Str"";
  Object selectedRow=dataTable.getSelectedRow();
  if (null != selectedRow) {
    String selector=""String_Node_Str"";
    if (selectedRow instanceof String) {
      try {
        Integer.parseInt((String)selectedRow);
        selector=(String)selectedRow;
      }
 catch (      NumberFormatException itIsAString) {
        selector=""String_Node_Str"" + selectedRow + ""String_Node_Str"";
      }
    }
 else     if (selectedRow instanceof Number) {
      selector=selectedRow.toString();
    }
    selectCommand=widgetVar + ""String_Node_Str"" + selector+ ""String_Node_Str"";
  }
  Object selectedColumn=dataTable.getSelectedColumn();
  if (null != selectedColumn) {
    String selector=""String_Node_Str"";
    if (selectedColumn instanceof String) {
      try {
        Integer.parseInt((String)selectedColumn);
        selector=(String)selectedColumn;
      }
 catch (      NumberFormatException itIsAString) {
        selector=""String_Node_Str"" + selectedColumn + ""String_Node_Str"";
      }
    }
 else     if (selectedColumn instanceof Number) {
      selector=selectedColumn.toString();
    }
    selectCommand+=widgetVar + ""String_Node_Str"" + selector+ ""String_Node_Str"";
  }
  if (selectCommand.length() > 0) {
    options=addOptions(""String_Node_Str"" + selectCommand + ""String_Node_Str"",options);
  }
  if (dataTable.getRowGroup() != null) {
    String rowGroup=dataTable.getRowGroup();
    try {
      Integer.parseInt(rowGroup);
      options=addOptions(""String_Node_Str"" + rowGroup + ""String_Node_Str"",options);
      rowGroup=""String_Node_Str"" + rowGroup + ""String_Node_Str"";
    }
 catch (    NumberFormatException itsJson) {
    }
    options=addOptions(rowGroup,options);
  }
  rw.writeText(widgetVar + ""String_Node_Str"" + clientId+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ clientIdRaw.replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ widgetVar+ ""String_Node_Str""+ ""String_Node_Str""+ widgetVar+ ""String_Node_Str""+ options+ ""String_Node_Str"",null);
  if (dataTable.isMultiColumnSearch()) {
    String filter=""String_Node_Str"";
    filter+=""String_Node_Str"";
    filter+=""String_Node_Str"";
    filter+=""String_Node_Str"";
    rw.writeText(widgetVar + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ filter+ ""String_Node_Str""+ ""String_Node_Str"",null);
    rw.writeText(""String_Node_Str"" + widgetVar + ""String_Node_Str"",null);
    rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
    rw.writeText(""String_Node_Str"",null);
    int col=0;
    for (    UIComponent column : dataTable.getChildren()) {
      if (!column.isRendered()) {
        continue;
      }
      String searchValue=null;
      if ((column instanceof DataTableColumn)) {
        searchValue=((DataTableColumn)column).getSearchValue();
      }
 else {
        Object sv=column.getAttributes().get(""String_Node_Str"");
        if (sv != null && (!""String_Node_Str"".equals(sv))) {
          searchValue=sv.toString();
        }
      }
      if (null != searchValue) {
        rw.writeText(""String_Node_Str"" + col + ""String_Node_Str""+ searchValue+ ""String_Node_Str"",null);
        rw.writeText(""String_Node_Str"" + col + ""String_Node_Str""+ searchValue+ ""String_Node_Str"",null);
      }
      col++;
    }
  }
  rw.writeText(""String_Node_Str"",null);
  rw.endElement(""String_Node_Str"");
}","/** 
 * This methods generates the HTML code of the current b:dataTable. <code>encodeBegin</code> generates the start of the component. After the, the JSF framework calls <code>encodeChildren()</code> to generate the HTML code between the beginning and the end of the component. For instance, in the case of a panel component the content of the panel is generated by <code>encodeChildren()</code>. After that, <code>encodeEnd()</code> is called to generate the rest of the HTML code.
 * @param context the FacesContext.
 * @param component the current b:dataTable.
 * @throws IOException thrown if something goes wrong when writing the HTML code.
 */
@Override public void encodeEnd(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  DataTable dataTable=(DataTable)component;
  Map<Integer,String> columnSortOrder=dataTable.getColumnSortOrderMap();
  int pageLength=dataTable.getPageLength();
  String orderString=""String_Node_Str"";
  if (columnSortOrder != null) {
    StringBuilder sb=new StringBuilder();
    int i=0;
    for (    Map.Entry<Integer,String> entry : columnSortOrder.entrySet()) {
      String separator=(i > 0) ? ""String_Node_Str"" : ""String_Node_Str"";
      sb.append(separator).append(""String_Node_Str"").append(entry.getKey()).append(""String_Node_Str"").append(""String_Node_Str"").append(entry.getValue()).append(""String_Node_Str"").append(""String_Node_Str"");
      i++;
    }
    orderString=sb.toString();
  }
  ResponseWriter rw=context.getResponseWriter();
  String clientIdRaw=dataTable.getClientId();
  String clientId=clientIdRaw.replace(""String_Node_Str"",""String_Node_Str"");
  String widgetVar=dataTable.getWidgetVar();
  if (null == widgetVar) {
    widgetVar=BsfUtils.widgetVarName(clientIdRaw);
  }
  String lang=determineLanguage(context,dataTable);
  rw.endElement(""String_Node_Str"");
  endDisabledFieldset(dataTable,rw);
  String responsiveStyle=Responsive.getResponsiveStyleClass(dataTable,false);
  if (null != responsiveStyle && responsiveStyle.trim().length() > 0) {
    rw.endElement(""String_Node_Str"");
  }
  if (dataTable.isScrollHorizontally()) {
    rw.endElement(""String_Node_Str"");
  }
  Tooltip.activateTooltips(context,dataTable);
  rw.startElement(""String_Node_Str"",component);
  rw.writeText(""String_Node_Str"",null);
  String options=""String_Node_Str"";
  options=addOptions(""String_Node_Str"" + dataTable.isFixedHeader(),options);
  options=addOptions(""String_Node_Str"" + dataTable.isResponsive(),options);
  options=addOptions(""String_Node_Str"" + dataTable.isPaginated(),options);
  if (!dataTable.isInfo()) {
    options=addOptions(""String_Node_Str"",options);
  }
  options=addOptions(""String_Node_Str"" + pageLength,options);
  options=addOptions(""String_Node_Str"" + getPageLengthMenu(dataTable),options);
  options=addOptions(""String_Node_Str"" + dataTable.isSearching(),options);
  options=addOptions(""String_Node_Str"" + orderString,options);
  options=addOptions(""String_Node_Str"" + dataTable.isSaveState(),options);
  options=addOptions(""String_Node_Str"",options);
  if (dataTable.isSelect()) {
    String json=""String_Node_Str"";
    String items=dataTable.getSelectedItems();
    if (""String_Node_Str"".equals(items) || ""String_Node_Str"".equals(items)) {
      json+=""String_Node_Str"";
    }
 else     if (""String_Node_Str"".equals(items) || ""String_Node_Str"".equals(items)) {
      json+=""String_Node_Str"";
    }
    if (""String_Node_Str"".equalsIgnoreCase(dataTable.getSelectionMode())) {
      json+=""String_Node_Str"";
    }
 else {
      json+=""String_Node_Str"";
    }
    if (!dataTable.isSelectionInfo()) {
      json+=""String_Node_Str"";
    }
    if (dataTable.isDeselectOnBackdropClick()) {
      json+=""String_Node_Str"";
    }
    if (json.length() > 1) {
      json=""String_Node_Str"" + json.substring(0,json.length() - 1) + ""String_Node_Str"";
    }
 else {
      json=""String_Node_Str"";
    }
    options=addOptions(json,options);
  }
  options=addOptions(generateScrollOptions(dataTable),options);
  options=addOptions((BsfUtils.isStringValued(lang) ? ""String_Node_Str"" + lang + ""String_Node_Str"" : null),options);
  options=addOptions(generateColumnInfos(dataTable.getColumnInfo()),options);
  options=addOptions(dataTable.getCustomOptions(),options);
  options=addOptions(getButtons(dataTable),options);
  String selectCommand=""String_Node_Str"";
  Object selectedRow=dataTable.getSelectedRow();
  if (null != selectedRow) {
    String selector=""String_Node_Str"";
    if (selectedRow instanceof String) {
      try {
        Integer.parseInt((String)selectedRow);
        selector=(String)selectedRow;
      }
 catch (      NumberFormatException itIsAString) {
        selector=""String_Node_Str"" + selectedRow + ""String_Node_Str"";
      }
    }
 else     if (selectedRow instanceof Number) {
      selector=selectedRow.toString();
    }
    selectCommand=widgetVar + ""String_Node_Str"" + selector+ ""String_Node_Str"";
  }
  Object selectedColumn=dataTable.getSelectedColumn();
  if (null != selectedColumn) {
    String selector=""String_Node_Str"";
    if (selectedColumn instanceof String) {
      try {
        Integer.parseInt((String)selectedColumn);
        selector=(String)selectedColumn;
      }
 catch (      NumberFormatException itIsAString) {
        selector=""String_Node_Str"" + selectedColumn + ""String_Node_Str"";
      }
    }
 else     if (selectedColumn instanceof Number) {
      selector=selectedColumn.toString();
    }
    selectCommand+=widgetVar + ""String_Node_Str"" + selector+ ""String_Node_Str"";
  }
  if (selectCommand.length() > 0) {
    options=addOptions(""String_Node_Str"" + selectCommand + ""String_Node_Str"",options);
  }
  if (dataTable.getRowGroup() != null) {
    String rowGroup=dataTable.getRowGroup();
    try {
      Integer.parseInt(rowGroup);
      options=addOptions(""String_Node_Str"" + rowGroup + ""String_Node_Str"",options);
      rowGroup=""String_Node_Str"" + rowGroup + ""String_Node_Str"";
    }
 catch (    NumberFormatException itsJson) {
    }
    options=addOptions(rowGroup,options);
  }
  rw.writeText(widgetVar + ""String_Node_Str"" + clientId+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ clientIdRaw.replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ widgetVar+ ""String_Node_Str""+ ""String_Node_Str""+ widgetVar+ ""String_Node_Str""+ options+ ""String_Node_Str"",null);
  if (dataTable.isMultiColumnSearch()) {
    String filter=""String_Node_Str"";
    filter+=""String_Node_Str"";
    filter+=""String_Node_Str"";
    filter+=""String_Node_Str"";
    rw.writeText(widgetVar + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ filter+ ""String_Node_Str""+ ""String_Node_Str"",null);
    rw.writeText(""String_Node_Str"" + widgetVar + ""String_Node_Str"",null);
    rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
    rw.writeText(""String_Node_Str"",null);
    int col=0;
    for (    UIComponent column : dataTable.getChildren()) {
      if (!column.isRendered()) {
        continue;
      }
      String searchValue=null;
      if ((column instanceof DataTableColumn)) {
        searchValue=((DataTableColumn)column).getSearchValue();
        if (!((DataTableColumn)column).isSearchable()) {
          continue;
        }
      }
 else {
        Object sv=column.getAttributes().get(""String_Node_Str"");
        if (sv != null && (!""String_Node_Str"".equals(sv))) {
          searchValue=sv.toString();
        }
      }
      if (null != searchValue && searchValue.length() > 0) {
        rw.writeText(""String_Node_Str"" + col + ""String_Node_Str""+ searchValue+ ""String_Node_Str"",null);
        rw.writeText(""String_Node_Str"" + col + ""String_Node_Str""+ searchValue+ ""String_Node_Str"",null);
      }
      col++;
    }
  }
  rw.writeText(""String_Node_Str"",null);
  rw.endElement(""String_Node_Str"");
}"
56899,"/** 
 * Encode the javascript code
 * @throws IOException
 */
private void encodeJS(FacesContext fc,ResponseWriter rw,DateTimePicker dtp,String datePickerId) throws IOException {
  String clientId=dtp.getClientId();
  String fieldId=dtp.getFieldId();
  if (null == fieldId) {
    fieldId=clientId + ""String_Node_Str"";
  }
 else   if (fieldId.equals(dtp.getId())) {
    throw new FacesException(""String_Node_Str"");
  }
  String mode=dtp.getMode();
  Object v=dtp.getSubmittedValue();
  if (v == null) {
    v=dtp.getValue();
  }
  if (dtp.isShowButtonPanel()) {
    dtp.setShowClearButton(true);
    dtp.setShowCloseButton(true);
    dtp.setShowTodayButton(true);
  }
  Locale sloc=BsfUtils.selectLocale(fc.getViewRoot().getLocale(),dtp.getLocale(),dtp);
  String format=BsfUtils.selectMomentJSDateTimeFormat(sloc,dtp.getFormat(),dtp.isShowDate(),dtp.isShowTime());
  String displayFormat=""String_Node_Str"" + format + ""String_Node_Str"";
  String inlineDisplayDate=""String_Node_Str"" + getValueAsString(v,fc,dtp) + ""String_Node_Str"";
  String fullSelector=""String_Node_Str"" + BsfUtils.escapeJQuerySpecialCharsInSelector(datePickerId);
  String defaultDate=BsfUtils.isStringValued(dtp.getInitialDate()) ? dtp.getInitialDate().contains(""String_Node_Str"") ? dtp.getInitialDate() : ""String_Node_Str"" + dtp.getInitialDate() + ""String_Node_Str"" : ""String_Node_Str"";
  String minDate=BsfUtils.isStringValued(dtp.getMinDate()) ? dtp.getMinDate().contains(""String_Node_Str"") ? dtp.getMinDate() : ""String_Node_Str"" + dtp.getMinDate() + ""String_Node_Str"" : ""String_Node_Str"";
  String maxDate=BsfUtils.isStringValued(dtp.getMaxDate()) ? dtp.getMinDate().contains(""String_Node_Str"") ? dtp.getMaxDate() : ""String_Node_Str"" + dtp.getMaxDate() + ""String_Node_Str"" : ""String_Node_Str"";
  rw.startElement(""String_Node_Str"",dtp);
  rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + fullSelector + ""String_Node_Str""+ ""String_Node_Str""+ (dtp.isAllowInputToggle() ? ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isCollapse() ? ""String_Node_Str"" + dtp.isCollapse() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDayViewHeaderFormat()) ? ""String_Node_Str"" + dtp.getDayViewHeaderFormat() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDisabledDates()) ? ""String_Node_Str"" + dtp.getDisabledDates() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDisableTimeInterval()) ? ""String_Node_Str"" + dtp.getDisableTimeInterval() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getEnabledDates()) ? ""String_Node_Str"" + dtp.getDisableTimeInterval() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isFocusOnShow() ? ""String_Node_Str"" + dtp.isFocusOnShow() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getInitialDate()) ? ""String_Node_Str"" + defaultDate + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isKeepInvalid() ? ""String_Node_Str"" + dtp.isKeepInvalid() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isKeepOpen() ? ""String_Node_Str"" + dtp.isKeepOpen() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(minDate) ? ""String_Node_Str"" + minDate + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(maxDate) ? ""String_Node_Str"" + maxDate + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowWeek() ? ""String_Node_Str"" + dtp.isShowWeek() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowClearButton() ? ""String_Node_Str"" + dtp.isShowClearButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowCloseButton() ? ""String_Node_Str"" + dtp.isShowCloseButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowTodayButton() ? ""String_Node_Str"" + dtp.isShowTodayButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isSideBySide() || ""String_Node_Str"".equals(mode) ? ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.getTimeStepping() > 0 ? ""String_Node_Str"" + dtp.getTimeStepping() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getToolbarPlacement()) ? ""String_Node_Str"" + dtp.getToolbarPlacement() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getViewMode()) ? ""String_Node_Str"" + dtp.getViewMode() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isUseCurrent() ? ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isUseStrict() ? ""String_Node_Str"" + dtp.isUseStrict() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getWidgetParent()) ? ""String_Node_Str"" + BsfUtils.resolveSearchExpressions(dtp.getWidgetParent()) + ""String_Node_Str"" : ""String_Node_Str"")+ (""String_Node_Str"".equals(mode) ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ inlineDisplayDate+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str""+ sloc.getLanguage()+ ""String_Node_Str""+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str"",null);
  if (""String_Node_Str"".equals(mode)) {
    rw.writeText(""String_Node_Str"" + fullSelector + ""String_Node_Str""+ ""String_Node_Str""+ BsfUtils.escapeJQuerySpecialCharsInSelector(fieldId)+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str"",null);
  }
  rw.endElement(""String_Node_Str"");
  new AJAXRenderer().generateBootsFacesAJAXAndJavaScriptForJQuery(fc,dtp,rw,fullSelector,null,true);
}","/** 
 * Encode the javascript code
 * @throws IOException
 */
private void encodeJS(FacesContext fc,ResponseWriter rw,DateTimePicker dtp,String datePickerId) throws IOException {
  String clientId=dtp.getClientId();
  String fieldId=dtp.getFieldId();
  if (null == fieldId) {
    fieldId=clientId + ""String_Node_Str"";
  }
 else   if (fieldId.equals(dtp.getId())) {
    throw new FacesException(""String_Node_Str"");
  }
  String mode=dtp.getMode();
  Object v=dtp.getSubmittedValue();
  if (v == null) {
    v=dtp.getValue();
  }
  if (dtp.isShowButtonPanel()) {
    dtp.setShowClearButton(true);
    dtp.setShowCloseButton(true);
    dtp.setShowTodayButton(true);
  }
  Locale sloc=BsfUtils.selectLocale(fc.getViewRoot().getLocale(),dtp.getLocale(),dtp);
  String format=BsfUtils.selectMomentJSDateTimeFormat(sloc,dtp.getFormat(),dtp.isShowDate(),dtp.isShowTime());
  String displayFormat=""String_Node_Str"" + format + ""String_Node_Str"";
  String inlineDisplayDate=""String_Node_Str"" + getValueAsString(v,fc,dtp) + ""String_Node_Str"";
  String fullSelector=""String_Node_Str"" + BsfUtils.escapeJQuerySpecialCharsInSelector(datePickerId);
  String defaultDate=BsfUtils.isStringValued(dtp.getInitialDate()) ? dtp.getInitialDate().contains(""String_Node_Str"") ? dtp.getInitialDate() : ""String_Node_Str"" + dtp.getInitialDate() + ""String_Node_Str"" : ""String_Node_Str"";
  String minDate=BsfUtils.isStringValued(dtp.getMinDate()) ? dtp.getMinDate().contains(""String_Node_Str"") ? dtp.getMinDate() : ""String_Node_Str"" + dtp.getMinDate() + ""String_Node_Str"" : ""String_Node_Str"";
  String maxDate=BsfUtils.isStringValued(dtp.getMaxDate()) ? dtp.getMaxDate().contains(""String_Node_Str"") ? dtp.getMaxDate() : ""String_Node_Str"" + dtp.getMaxDate() + ""String_Node_Str"" : ""String_Node_Str"";
  rw.startElement(""String_Node_Str"",dtp);
  rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + fullSelector + ""String_Node_Str""+ ""String_Node_Str""+ (dtp.isAllowInputToggle() ? ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isCollapse() ? ""String_Node_Str"" + dtp.isCollapse() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDayViewHeaderFormat()) ? ""String_Node_Str"" + dtp.getDayViewHeaderFormat() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDisabledDates()) ? ""String_Node_Str"" + dtp.getDisabledDates() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDisableTimeInterval()) ? ""String_Node_Str"" + dtp.getDisableTimeInterval() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getEnabledDates()) ? ""String_Node_Str"" + dtp.getDisableTimeInterval() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isFocusOnShow() ? ""String_Node_Str"" + dtp.isFocusOnShow() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getInitialDate()) ? ""String_Node_Str"" + defaultDate + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isKeepInvalid() ? ""String_Node_Str"" + dtp.isKeepInvalid() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isKeepOpen() ? ""String_Node_Str"" + dtp.isKeepOpen() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(minDate) ? ""String_Node_Str"" + minDate + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(maxDate) ? ""String_Node_Str"" + maxDate + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowWeek() ? ""String_Node_Str"" + dtp.isShowWeek() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowClearButton() ? ""String_Node_Str"" + dtp.isShowClearButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowCloseButton() ? ""String_Node_Str"" + dtp.isShowCloseButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowTodayButton() ? ""String_Node_Str"" + dtp.isShowTodayButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isSideBySide() || ""String_Node_Str"".equals(mode) ? ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.getTimeStepping() > 0 ? ""String_Node_Str"" + dtp.getTimeStepping() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getToolbarPlacement()) ? ""String_Node_Str"" + dtp.getToolbarPlacement() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getViewMode()) ? ""String_Node_Str"" + dtp.getViewMode() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isUseCurrent() ? ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isUseStrict() ? ""String_Node_Str"" + dtp.isUseStrict() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getWidgetParent()) ? ""String_Node_Str"" + BsfUtils.resolveSearchExpressions(dtp.getWidgetParent()) + ""String_Node_Str"" : ""String_Node_Str"")+ (""String_Node_Str"".equals(mode) ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ inlineDisplayDate+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str""+ sloc.getLanguage()+ ""String_Node_Str""+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str"",null);
  if (""String_Node_Str"".equals(mode)) {
    rw.writeText(""String_Node_Str"" + fullSelector + ""String_Node_Str""+ ""String_Node_Str""+ BsfUtils.escapeJQuerySpecialCharsInSelector(fieldId)+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str"",null);
  }
  rw.endElement(""String_Node_Str"");
  new AJAXRenderer().generateBootsFacesAJAXAndJavaScriptForJQuery(fc,dtp,rw,fullSelector,null,true);
}"
56900,"/** 
 * This methods generates the HTML code of the current b:breadcrumbs. <code>encodeBegin</code> generates the start of the component. After the, the JSF framework calls <code>encodeChildren()</code> to generate the HTML code between the beginning and the end of the component. For instance, in the case of a panel component the content of the panel is generated by <code>encodeChildren()</code>. After that, <code>encodeEnd()</code> is called to generate the rest of the HTML code.
 * @param context the FacesContext.
 * @param component the current b:breadcrumbs.
 * @throws IOException thrown if something goes wrong when writing the HTML code.
 */
@Override public void encodeEnd(FacesContext context,UIComponent component) throws IOException {
}","/** 
 * This methods generates the HTML code of the current b:breadcrumbs. <code>encodeBegin</code> generates the start of the component. After the, the JSF framework calls <code>encodeChildren()</code> to generate the HTML code between the beginning and the end of the component. For instance, in the case of a panel component the content of the panel is generated by <code>encodeChildren()</code>. After that, <code>encodeEnd()</code> is called to generate the rest of the HTML code.
 * @param context the FacesContext.
 * @param component the current b:breadcrumbs.
 * @throws IOException thrown if something goes wrong when writing the HTML code.
 */
@Override public void encodeEnd(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  ResponseWriter rw=context.getResponseWriter();
  rw.endElement(""String_Node_Str"");
  Tooltip.activateTooltips(context,component);
}"
56901,"private void renderOption(FacesContext context,SelectOneMenu menu,ResponseWriter rw,int index,String itemLabel,final String description,final Object itemValue,boolean isDisabledOption,boolean isEscape,UIComponent itemComponent) throws IOException {
  Object submittedValue=menu.getSubmittedValue();
  Object selectedOption;
  Object optionValue;
  Converter converter=menu.getConverter();
  String itemValueAsString=getOptionAsString(context,menu,itemValue,converter);
  if (submittedValue != null) {
    selectedOption=submittedValue;
    optionValue=itemValueAsString;
  }
 else {
    selectedOption=menu.getValue();
    optionValue=itemValue;
  }
  boolean isSelected=false;
  if (itemValue != null) {
    if (isSelected(context,menu,selectedOption,optionValue,converter)) {
      isSelected=true;
    }
  }
 else   if (itemLabel.equals(selectedOption)) {
    isSelected=true;
  }
  if (menu.isDisabled() || menu.isReadonly()) {
    if (!isSelected) {
      return;
    }
  }
  boolean isItemLabelBlank=itemLabel == null || itemLabel.trim().isEmpty();
  itemLabel=isItemLabelBlank ? itemValueAsString : itemLabel;
  rw.startElement(""String_Node_Str"",itemComponent);
  rw.writeAttribute(""String_Node_Str"",itemLabel,null);
  if (description != null) {
    rw.writeAttribute(""String_Node_Str"",description,null);
  }
  if (itemValue != null) {
    String value;
    if (null != converter) {
      value=converter.getAsString(context,menu,itemValue);
    }
 else     if (itemValue instanceof String) {
      value=(String)itemValue;
    }
 else {
      value=String.valueOf(index);
    }
    rw.writeAttribute(""String_Node_Str"",value,""String_Node_Str"");
  }
  if (isSelected) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (isDisabledOption)   rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  if (isEscape && !isItemLabelBlank) {
    rw.writeText(itemLabel,null);
  }
 else {
    rw.write(itemLabel);
  }
  rw.endElement(""String_Node_Str"");
}","private void renderOption(FacesContext context,SelectOneMenu menu,ResponseWriter rw,int index,String itemLabel,final String description,final Object itemValue,boolean isDisabledOption,boolean isEscape,UIComponent itemComponent) throws IOException {
  Object submittedValue=menu.getSubmittedValue();
  Object selectedOption;
  Object optionValue;
  Converter converter=menu.getConverter();
  String itemValueAsString=getOptionAsString(context,menu,itemValue,converter);
  if (submittedValue != null) {
    selectedOption=submittedValue;
    optionValue=itemValueAsString;
  }
 else {
    selectedOption=menu.getValue();
    optionValue=itemValue;
  }
  boolean isSelected=false;
  if (itemValue != null) {
    if (isSelected(context,menu,selectedOption,optionValue,converter)) {
      isSelected=true;
    }
  }
 else   if (itemLabel.equals(selectedOption)) {
    isSelected=true;
  }
  boolean isItemLabelBlank=itemLabel == null || itemLabel.trim().isEmpty();
  itemLabel=isItemLabelBlank ? itemValueAsString : itemLabel;
  rw.startElement(""String_Node_Str"",itemComponent);
  rw.writeAttribute(""String_Node_Str"",itemLabel,null);
  if (description != null) {
    rw.writeAttribute(""String_Node_Str"",description,null);
  }
  if (itemValue != null) {
    String value;
    if (null != converter) {
      value=converter.getAsString(context,menu,itemValue);
    }
 else     if (itemValue instanceof String) {
      value=(String)itemValue;
    }
 else {
      value=String.valueOf(index);
    }
    rw.writeAttribute(""String_Node_Str"",value,""String_Node_Str"");
  }
  if (isSelected) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (isDisabledOption)   rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  if (isEscape && !isItemLabelBlank) {
    rw.writeText(itemLabel,null);
  }
 else {
    rw.write(itemLabel);
  }
  rw.endElement(""String_Node_Str"");
}"
56902,"/** 
 * This method is used by RadioButtons and SelectOneMenus to limit the list of legal values. If another value is sent, the input field is considered empty. This comes in useful the the back-end attribute is a primitive type like int, which doesn't support null values.
 * @param context
 * @param component
 * @param legalValues an optional list of legal values. May be null.
 * @param The real attribute name of the request parameter. By default, BootsFaces guesses the attribute namefrom the client ID or the name attribute of the input field. However, in some cases such as radio buttons, this detection fails.
 */
public void decode(FacesContext context,UIComponent component,List<String> legalValues,String realEventSourceName){
  InputText inputText=(InputText)component;
  if (inputText.isDisabled() || inputText.isReadonly()) {
    return;
  }
  decodeBehaviors(context,inputText);
  String clientId=inputText.getClientId(context);
  String name=inputText.getName();
  if (realEventSourceName == null) {
    realEventSourceName=""String_Node_Str"" + clientId;
  }
  if (null == name) {
    name=""String_Node_Str"" + clientId;
  }
  String submittedValue=(String)context.getExternalContext().getRequestParameterMap().get(name);
  if (null != legalValues && null != submittedValue) {
    boolean found=false;
    for (    String option : legalValues) {
      found|=submittedValue.equals(option);
    }
    if (!found) {
      submittedValue=""String_Node_Str"";
    }
  }
  if (submittedValue != null) {
    inputText.setSubmittedValue(submittedValue);
  }
  new AJAXRenderer().decode(context,component,realEventSourceName);
}","/** 
 * This method is used by RadioButtons and SelectOneMenus to limit the list of legal values. If another value is sent, the input field is considered empty. This comes in useful the the back-end attribute is a primitive type like int, which doesn't support null values.
 * @param context
 * @param component
 * @param legalValues an optional list of legal values. May be null.
 * @param realEventSourceName The real attribute name of the request parameter. By default, BootsFaces guesses the attribute namefrom the client ID or the name attribute of the input field. However, in some cases such as radio buttons, this detection fails.
 */
public void decode(FacesContext context,UIComponent component,List<String> legalValues,String realEventSourceName){
  InputText inputText=(InputText)component;
  if (inputText.isDisabled() || inputText.isReadonly()) {
    return;
  }
  decodeBehaviors(context,inputText);
  String clientId=inputText.getClientId(context);
  String name=inputText.getName();
  if (realEventSourceName == null) {
    realEventSourceName=""String_Node_Str"" + clientId;
  }
  if (null == name) {
    name=""String_Node_Str"" + clientId;
  }
  String submittedValue=(String)context.getExternalContext().getRequestParameterMap().get(name);
  if (null != legalValues && null != submittedValue) {
    boolean found=false;
    for (    String option : legalValues) {
      found|=submittedValue.equals(option);
    }
    if (!found) {
      submittedValue=""String_Node_Str"";
    }
  }
  if (submittedValue != null) {
    inputText.setSubmittedValue(submittedValue);
  }
  new AJAXRenderer().decode(context,component,realEventSourceName);
}"
56903,"@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  FormGroup formGroup=(FormGroup)component;
  ResponseWriter rw=context.getResponseWriter();
  String clientId=formGroup.getClientId();
  rw.startElement(""String_Node_Str"",formGroup);
  Tooltip.generateTooltip(context,formGroup,rw);
  String dir=formGroup.getDir();
  if (null != dir) {
    rw.writeAttribute(""String_Node_Str"",dir,""String_Node_Str"");
  }
  String s=""String_Node_Str"";
  String sclass=formGroup.getStyleClass();
  if (sclass != null) {
    s+=""String_Node_Str"" + sclass;
  }
  rw.writeAttribute(""String_Node_Str"",clientId,""String_Node_Str"");
  String style=formGroup.getStyle();
  if (style != null) {
    rw.writeAttribute(""String_Node_Str"",style,""String_Node_Str"");
  }
  rw.writeAttribute(""String_Node_Str"",s,""String_Node_Str"");
  Tooltip.activateTooltips(context,formGroup);
  beginDisabledFieldset(formGroup,rw);
}","@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  if (getSurroundingForm(component,true) == null || !isHorizontalForm(component)) {
    throw new FacesException(""String_Node_Str"" + FormGroup.COMPONENT_TYPE + ""String_Node_Str""+ component.getClientId()+ ""String_Node_Str""+ Form.COMPONENT_TYPE);
  }
  FormGroup formGroup=(FormGroup)component;
  ResponseWriter rw=context.getResponseWriter();
  String clientId=formGroup.getClientId();
  rw.startElement(""String_Node_Str"",formGroup);
  Tooltip.generateTooltip(context,formGroup,rw);
  String dir=formGroup.getDir();
  if (null != dir) {
    rw.writeAttribute(""String_Node_Str"",dir,""String_Node_Str"");
  }
  String s=""String_Node_Str"";
  String sclass=formGroup.getStyleClass();
  if (sclass != null) {
    s+=""String_Node_Str"" + sclass;
  }
  rw.writeAttribute(""String_Node_Str"",clientId,""String_Node_Str"");
  String style=formGroup.getStyle();
  if (style != null) {
    rw.writeAttribute(""String_Node_Str"",style,""String_Node_Str"");
  }
  rw.writeAttribute(""String_Node_Str"",s,""String_Node_Str"");
  Tooltip.activateTooltips(context,formGroup);
  beginDisabledFieldset(formGroup,rw);
}"
56904,"/** 
 * <p>Check whether the input needs to be wrapped on a div containing the ""form-group"" class.</p> This method return true in the following cases: <ul> <li>The direct parent of the component passed as argument is an instance of   {@link FormGroup}</li> </ul> In any other case, this method will return false.
 * @param component
 * @return 
 */
protected boolean hasToRenderFormGroup(UIComponent component){
  return component.getParent() instanceof FormGroup;
}","/** 
 * <p>Check whether the input needs to be wrapped on a div containing the ""form-group"" class.</p> This method return true in the following cases: <ul> <li>The direct parent of the component passed as argument is an instance of   {@link FormGroup}</li> </ul> In any other case, this method will return false.
 * @param component
 * @return 
 */
protected boolean hasToRenderFormGroup(UIComponent component){
  return !(component.getParent() instanceof FormGroup);
}"
56905,"/** 
 * Internal method to do translations
 * @param formatString
 * @param mapping
 * @return
 */
private static String translateFormat(String formatString,Map<String,String> mapping,String escapeStart,String escapeEnd,String targetEscapeStart,String targetEscapeEnd){
  int beginIndex=0;
  int i=0;
  char lastChar=0;
  char currentChar=0;
  String resultString=""String_Node_Str"";
  char esc1=escapeStart.charAt(0);
  char esc2=escapeEnd.charAt(0);
  for (; i < formatString.length(); i++) {
    currentChar=formatString.charAt(i);
    if (i > 0 && lastChar != currentChar) {
      resultString+=mapSubformat(formatString,mapping,beginIndex,i,escapeStart,escapeEnd,targetEscapeStart,targetEscapeEnd);
      beginIndex=i;
    }
    lastChar=currentChar;
    if (currentChar == esc1) {
      i++;
      while (i < formatString.length() && formatString.charAt(i) != esc2) {
        i++;
      }
      resultString+=targetEscapeStart;
      resultString+=formatString.substring(beginIndex + 1,i);
      resultString+=targetEscapeEnd;
      i++;
      if (i < formatString.length()) {
        lastChar=formatString.charAt(i);
      }
      beginIndex=i;
    }
  }
  return resultString + mapSubformat(formatString,mapping,beginIndex,i,escapeStart,escapeEnd,targetEscapeStart,targetEscapeEnd);
}","/** 
 * Internal method to do translations
 * @param formatString
 * @param mapping
 * @return
 */
private static String translateFormat(String formatString,Map<String,String> mapping,String escapeStart,String escapeEnd,String targetEscapeStart,String targetEscapeEnd){
  int beginIndex=0;
  int i=0;
  char lastChar=0;
  char currentChar=0;
  String resultString=""String_Node_Str"";
  char esc1=escapeStart.charAt(0);
  char esc2=escapeEnd.charAt(0);
  for (; i < formatString.length(); i++) {
    currentChar=formatString.charAt(i);
    if (i > 0 && lastChar != currentChar) {
      resultString+=mapSubformat(formatString,mapping,beginIndex,i,escapeStart,escapeEnd,targetEscapeStart,targetEscapeEnd);
      beginIndex=i;
    }
    lastChar=currentChar;
    if (currentChar == esc1) {
      i++;
      while (i < formatString.length() && formatString.charAt(i) != esc2) {
        i++;
      }
      resultString+=targetEscapeStart;
      resultString+=formatString.substring(beginIndex + 1,i);
      resultString+=targetEscapeEnd;
      i++;
      if (i < formatString.length()) {
        lastChar=formatString.charAt(i);
      }
      beginIndex=i;
    }
  }
  if (beginIndex < formatString.length() && i <= formatString.length()) {
    return resultString + mapSubformat(formatString,mapping,beginIndex,i,escapeStart,escapeEnd,targetEscapeStart,targetEscapeEnd);
  }
 else {
    return resultString;
  }
}"
56906,"@Override public Object getConvertedValue(FacesContext context,Object submittedValue) throws ConverterException {
  if (submittedValue == null) {
    return null;
  }
  String val=(String)submittedValue;
  if (val.trim().length() == 0) {
    return null;
  }
  Converter converter=this.getConverter();
  if (converter != null) {
    return converter.getAsObject(context,this,val);
  }
  Locale sloc=BsfUtils.selectLocale(context.getViewRoot().getLocale(),this.getLocale(),this);
  String componentFormat=BsfUtils.selectDateTimeFormat(sloc,this.getFormat(),this.isShowDate(),this.isShowTime());
  String sdf=BsfUtils.selectDateFormat(sloc,componentFormat);
  sdf=LocaleUtils.momentToJavaFormat(sdf);
  Calendar cal=Calendar.getInstance(sloc);
  SimpleDateFormat format=new SimpleDateFormat(sdf,sloc);
  format.setTimeZone(cal.getTimeZone());
  try {
    cal.setTime(format.parse(val));
    return cal.getTime();
  }
 catch (  ParseException e) {
    try {
      cal.setTime(LocaleUtils.autoParseDateFormat(val));
      return cal.getTime();
    }
 catch (    Exception pe) {
      e.printStackTrace();
      this.setValid(false);
      throw new ConverterException(BsfUtils.getMessage(""String_Node_Str"",val,sdf,BsfUtils.getLabel(context,this)));
    }
  }
}","/** 
 * Converts the date from the moment.js format to a java.util.Date.
 */
@Override public Object getConvertedValue(FacesContext context,Object submittedValue) throws ConverterException {
  if (submittedValue == null) {
    return null;
  }
  String val=(String)submittedValue;
  if (val.trim().length() == 0) {
    return null;
  }
  Converter converter=this.getConverter();
  if (converter != null) {
    return converter.getAsObject(context,this,val);
  }
  Locale sloc=BsfUtils.selectLocale(context.getViewRoot().getLocale(),this.getLocale(),this);
  String momentJSFormat=BsfUtils.selectMomentJSDateTimeFormat(sloc,this.getFormat(),this.isShowDate(),this.isShowTime());
  String javaFormat=LocaleUtils.momentToJavaFormat(momentJSFormat);
  Calendar cal=Calendar.getInstance(sloc);
  SimpleDateFormat format=new SimpleDateFormat(javaFormat,sloc);
  format.setTimeZone(cal.getTimeZone());
  try {
    cal.setTime(format.parse(val));
    return cal.getTime();
  }
 catch (  ParseException e) {
    try {
      cal.setTime(LocaleUtils.autoParseDateFormat(val));
      return cal.getTime();
    }
 catch (    Exception pe) {
      e.printStackTrace();
      this.setValid(false);
      throw new ConverterException(BsfUtils.getMessage(""String_Node_Str"",val,javaFormat,BsfUtils.getLabel(context,this)));
    }
  }
}"
56907,"/** 
 * Encode the javascript code
 * @throws IOException
 */
private void encodeJS(FacesContext fc,ResponseWriter rw,DateTimePicker dtp,String datePickerId) throws IOException {
  String clientId=dtp.getClientId();
  String fieldId=dtp.getFieldId();
  if (null == fieldId) {
    fieldId=clientId + ""String_Node_Str"";
  }
 else   if (fieldId.equals(dtp.getId())) {
    throw new FacesException(""String_Node_Str"");
  }
  String mode=dtp.getMode();
  Object v=dtp.getSubmittedValue();
  if (v == null) {
    v=dtp.getValue();
  }
  if (dtp.isShowButtonPanel()) {
    dtp.setShowClearButton(true);
    dtp.setShowCloseButton(true);
    dtp.setShowTodayButton(true);
  }
  Locale sloc=BsfUtils.selectLocale(fc.getViewRoot().getLocale(),dtp.getLocale(),dtp);
  String format=BsfUtils.selectDateTimeFormat(sloc,dtp.getFormat(),dtp.isShowDate(),dtp.isShowTime());
  String displayFormat=""String_Node_Str"" + (dtp.getFormat() == null ? LocaleUtils.javaToMomentFormat(format) : format) + ""String_Node_Str"";
  String inlineDisplayDate=""String_Node_Str"" + (dtp.getFormat() == null ? getDateAsString(fc,dtp,v,format,sloc) : getDateAsString(fc,dtp,v,LocaleUtils.momentToJavaFormat(format),sloc)) + ""String_Node_Str"";
  String fullSelector=""String_Node_Str"" + BsfUtils.escapeJQuerySpecialCharsInSelector(datePickerId);
  String defaultDate=BsfUtils.isStringValued(dtp.getInitialDate()) ? dtp.getInitialDate().contains(""String_Node_Str"") ? dtp.getInitialDate() : ""String_Node_Str"" + dtp.getInitialDate() + ""String_Node_Str"" : ""String_Node_Str"";
  String minDate=BsfUtils.isStringValued(dtp.getMinDate()) ? dtp.getMinDate().contains(""String_Node_Str"") ? dtp.getMinDate() : ""String_Node_Str"" + dtp.getMinDate() + ""String_Node_Str"" : ""String_Node_Str"";
  String maxDate=BsfUtils.isStringValued(dtp.getMaxDate()) ? dtp.getMinDate().contains(""String_Node_Str"") ? dtp.getMaxDate() : ""String_Node_Str"" + dtp.getMaxDate() + ""String_Node_Str"" : ""String_Node_Str"";
  rw.startElement(""String_Node_Str"",dtp);
  rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + fullSelector + ""String_Node_Str""+ ""String_Node_Str""+ (dtp.isAllowInputToggle() ? ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isCollapse() ? ""String_Node_Str"" + dtp.isCollapse() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDayViewHeaderFormat()) ? ""String_Node_Str"" + dtp.getDayViewHeaderFormat() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDisabledDates()) ? ""String_Node_Str"" + dtp.getDisabledDates() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDisableTimeInterval()) ? ""String_Node_Str"" + dtp.getDisableTimeInterval() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getEnabledDates()) ? ""String_Node_Str"" + dtp.getDisableTimeInterval() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isFocusOnShow() ? ""String_Node_Str"" + dtp.isFocusOnShow() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getInitialDate()) ? ""String_Node_Str"" + defaultDate + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isKeepInvalid() ? ""String_Node_Str"" + dtp.isKeepInvalid() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isKeepOpen() ? ""String_Node_Str"" + dtp.isKeepOpen() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(minDate) ? ""String_Node_Str"" + minDate + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(maxDate) ? ""String_Node_Str"" + maxDate + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowWeek() ? ""String_Node_Str"" + dtp.isShowWeek() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowClearButton() ? ""String_Node_Str"" + dtp.isShowClearButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowCloseButton() ? ""String_Node_Str"" + dtp.isShowCloseButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowTodayButton() ? ""String_Node_Str"" + dtp.isShowTodayButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isSideBySide() || ""String_Node_Str"".equals(mode) ? ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.getTimeStepping() > 0 ? ""String_Node_Str"" + dtp.getTimeStepping() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getToolbarPlacement()) ? ""String_Node_Str"" + dtp.getToolbarPlacement() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getViewMode()) ? ""String_Node_Str"" + dtp.getViewMode() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isUseCurrent() ? ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isUseStrict() ? ""String_Node_Str"" + dtp.isUseStrict() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getWidgetParent()) ? ""String_Node_Str"" + BsfUtils.resolveSearchExpressions(dtp.getWidgetParent()) + ""String_Node_Str"" : ""String_Node_Str"")+ (""String_Node_Str"".equals(mode) ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ inlineDisplayDate+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str""+ sloc.getLanguage()+ ""String_Node_Str""+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str"",null);
  if (""String_Node_Str"".equals(mode)) {
    rw.writeText(""String_Node_Str"" + fullSelector + ""String_Node_Str""+ ""String_Node_Str""+ BsfUtils.escapeJQuerySpecialCharsInSelector(fieldId)+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str"",null);
  }
  rw.endElement(""String_Node_Str"");
  new AJAXRenderer().generateBootsFacesAJAXAndJavaScriptForJQuery(fc,dtp,rw,fullSelector,null,true);
}","/** 
 * Encode the javascript code
 * @throws IOException
 */
private void encodeJS(FacesContext fc,ResponseWriter rw,DateTimePicker dtp,String datePickerId) throws IOException {
  String clientId=dtp.getClientId();
  String fieldId=dtp.getFieldId();
  if (null == fieldId) {
    fieldId=clientId + ""String_Node_Str"";
  }
 else   if (fieldId.equals(dtp.getId())) {
    throw new FacesException(""String_Node_Str"");
  }
  String mode=dtp.getMode();
  Object v=dtp.getSubmittedValue();
  if (v == null) {
    v=dtp.getValue();
  }
  if (dtp.isShowButtonPanel()) {
    dtp.setShowClearButton(true);
    dtp.setShowCloseButton(true);
    dtp.setShowTodayButton(true);
  }
  Locale sloc=BsfUtils.selectLocale(fc.getViewRoot().getLocale(),dtp.getLocale(),dtp);
  String format=BsfUtils.selectMomentJSDateTimeFormat(sloc,dtp.getFormat(),dtp.isShowDate(),dtp.isShowTime());
  String displayFormat=""String_Node_Str"" + format + ""String_Node_Str"";
  String inlineDisplayDate=""String_Node_Str"" + getValueAsString(v,fc,dtp) + ""String_Node_Str"";
  String fullSelector=""String_Node_Str"" + BsfUtils.escapeJQuerySpecialCharsInSelector(datePickerId);
  String defaultDate=BsfUtils.isStringValued(dtp.getInitialDate()) ? dtp.getInitialDate().contains(""String_Node_Str"") ? dtp.getInitialDate() : ""String_Node_Str"" + dtp.getInitialDate() + ""String_Node_Str"" : ""String_Node_Str"";
  String minDate=BsfUtils.isStringValued(dtp.getMinDate()) ? dtp.getMinDate().contains(""String_Node_Str"") ? dtp.getMinDate() : ""String_Node_Str"" + dtp.getMinDate() + ""String_Node_Str"" : ""String_Node_Str"";
  String maxDate=BsfUtils.isStringValued(dtp.getMaxDate()) ? dtp.getMinDate().contains(""String_Node_Str"") ? dtp.getMaxDate() : ""String_Node_Str"" + dtp.getMaxDate() + ""String_Node_Str"" : ""String_Node_Str"";
  rw.startElement(""String_Node_Str"",dtp);
  rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + fullSelector + ""String_Node_Str""+ ""String_Node_Str""+ (dtp.isAllowInputToggle() ? ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isCollapse() ? ""String_Node_Str"" + dtp.isCollapse() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDayViewHeaderFormat()) ? ""String_Node_Str"" + dtp.getDayViewHeaderFormat() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDisabledDates()) ? ""String_Node_Str"" + dtp.getDisabledDates() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDisableTimeInterval()) ? ""String_Node_Str"" + dtp.getDisableTimeInterval() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getEnabledDates()) ? ""String_Node_Str"" + dtp.getDisableTimeInterval() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isFocusOnShow() ? ""String_Node_Str"" + dtp.isFocusOnShow() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getInitialDate()) ? ""String_Node_Str"" + defaultDate + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isKeepInvalid() ? ""String_Node_Str"" + dtp.isKeepInvalid() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isKeepOpen() ? ""String_Node_Str"" + dtp.isKeepOpen() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(minDate) ? ""String_Node_Str"" + minDate + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(maxDate) ? ""String_Node_Str"" + maxDate + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowWeek() ? ""String_Node_Str"" + dtp.isShowWeek() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowClearButton() ? ""String_Node_Str"" + dtp.isShowClearButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowCloseButton() ? ""String_Node_Str"" + dtp.isShowCloseButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowTodayButton() ? ""String_Node_Str"" + dtp.isShowTodayButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isSideBySide() || ""String_Node_Str"".equals(mode) ? ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.getTimeStepping() > 0 ? ""String_Node_Str"" + dtp.getTimeStepping() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getToolbarPlacement()) ? ""String_Node_Str"" + dtp.getToolbarPlacement() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getViewMode()) ? ""String_Node_Str"" + dtp.getViewMode() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isUseCurrent() ? ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isUseStrict() ? ""String_Node_Str"" + dtp.isUseStrict() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getWidgetParent()) ? ""String_Node_Str"" + BsfUtils.resolveSearchExpressions(dtp.getWidgetParent()) + ""String_Node_Str"" : ""String_Node_Str"")+ (""String_Node_Str"".equals(mode) ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ inlineDisplayDate+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str""+ sloc.getLanguage()+ ""String_Node_Str""+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str"",null);
  if (""String_Node_Str"".equals(mode)) {
    rw.writeText(""String_Node_Str"" + fullSelector + ""String_Node_Str""+ ""String_Node_Str""+ BsfUtils.escapeJQuerySpecialCharsInSelector(fieldId)+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str"",null);
  }
  rw.endElement(""String_Node_Str"");
  new AJAXRenderer().generateBootsFacesAJAXAndJavaScriptForJQuery(fc,dtp,rw,fullSelector,null,true);
}"
56908,"public static String getInternalDateAsString(Object dt,String format,Locale locale){
  if (dt == null) {
    return null;
  }
  if (dt instanceof String) {
    return (String)dt;
  }
 else   if (dt instanceof Date) {
    return TestSingleton.getInstance().formatDate((Date)dt,format);
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}","public static String getInternalDateAsString(Object dt,String javaFormatString,Locale locale){
  if (dt == null) {
    return null;
  }
  if (dt instanceof String) {
    return (String)dt;
  }
 else   if (dt instanceof Date) {
    SimpleDateFormat dtFormat=new SimpleDateFormat(javaFormatString,locale);
    String result=dtFormat.format((Date)dt);
    return result;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
}"
56909,"@Override public void decode(FacesContext context,UIComponent component){
  DateTimePicker dtp=(DateTimePicker)component;
  String clientId=dtp.getClientId();
  String subVal=context.getExternalContext().getRequestParameterMap().get(dtp.getClientId());
  if (dtp.isDisabled() || dtp.isReadonly()) {
    return;
  }
  if (subVal != null) {
    dtp.setSubmittedValue(subVal);
    dtp.setValid(true);
  }
  String fieldId=dtp.getFieldId();
  if (null == fieldId) {
    fieldId=clientId + ""String_Node_Str"";
  }
  new AJAXRenderer().decode(context,dtp,fieldId);
  new AJAXRenderer().decode(context,dtp,clientId);
}","@Override public void decode(FacesContext context,UIComponent component){
  DateTimePicker dtp=(DateTimePicker)component;
  String clientId=dtp.getClientId();
  String subVal=context.getExternalContext().getRequestParameterMap().get(dtp.getClientId());
  if (dtp.isDisabled() || dtp.isReadonly()) {
    return;
  }
  if (subVal != null) {
    dtp.setSubmittedValue(subVal);
    dtp.setValid(true);
  }
  String fieldId=dtp.getFieldId();
  if (null == fieldId) {
    fieldId=clientId + ""String_Node_Str"";
  }
  new AJAXRenderer().decode(context,dtp,fieldId);
}"
56910,"/** 
 * Get value displayable
 * @param ctx
 * @param dtp
 * @return
 */
public static String getValueAsString(Object value,FacesContext ctx,DateTimePicker dtp){
  if (value == null) {
    return null;
  }
  Locale sloc=BsfUtils.selectLocale(ctx.getViewRoot().getLocale(),dtp.getLocale(),dtp);
  String sdf=BsfUtils.selectDateFormat(sloc,dtp.getFormat());
  sdf=LocaleUtils.momentToJavaFormat(sdf);
  return getDateAsString(ctx,dtp,value,sdf,sloc);
}","/** 
 * Yields the value which is displayed in the input field of the date picker.
 * @param ctx
 * @param dtp
 * @return
 */
public static String getValueAsString(Object value,FacesContext ctx,DateTimePicker dtp){
  if (value == null) {
    return null;
  }
  Locale sloc=BsfUtils.selectLocale(ctx.getViewRoot().getLocale(),dtp.getLocale(),dtp);
  String javaFormatString=BsfUtils.selectJavaDateTimeFormatFromMomentJSFormatOrDefault(sloc,dtp.getFormat(),dtp.isShowDate(),dtp.isShowTime());
  return getDateAsString(ctx,dtp,value,javaFormatString,sloc);
}"
56911,"/** 
 * Get date in string format
 * @param value
 * @param format
 * @param locale
 * @return
 */
public static String getDateAsString(FacesContext fc,DateTimePicker dtp,Object value,String format,Locale locale){
  if (value == null) {
    return null;
  }
  Converter converter=dtp.getConverter();
  return converter == null ? getInternalDateAsString(value,format,locale) : converter.getAsString(fc,dtp,value);
}","/** 
 * Get date in string format
 * @param value
 * @param format
 * @param locale
 * @return
 */
public static String getDateAsString(FacesContext fc,DateTimePicker dtp,Object value,String javaFormatString,Locale locale){
  if (value == null) {
    return null;
  }
  Converter converter=dtp.getConverter();
  return converter == null ? getInternalDateAsString(value,javaFormatString,locale) : converter.getAsString(fc,dtp,value);
}"
56912,"/** 
 * Append the new mapping
 * @param formatString
 * @param mapping
 * @param beginIndex
 * @param currentIndex
 * @param resultString
 * @return
 */
private static String mapSubformat(String formatString,Map<String,String> mapping,int beginIndex,int currentIndex,String escapeStart,String escapeEnd){
  String subformat=formatString.substring(beginIndex,currentIndex);
  if (subformat.equals(escapeStart) || subformat.equals(escapeEnd)) {
    return escapeStart + ""String_Node_Str"" + escapeEnd;
  }
  if (mapping.containsKey(subformat)) {
    String result=mapping.get(subformat);
    if (result == null || result.length() == 0) {
      return escapeStart + ""String_Node_Str"" + subformat+ ""String_Node_Str""+ escapeEnd;
    }
    return result;
  }
  return subformat;
}","/** 
 * Append the new mapping
 * @param formatString
 * @param mapping
 * @param beginIndex
 * @param currentIndex
 * @param resultString
 * @return
 */
private static String mapSubformat(String formatString,Map<String,String> mapping,int beginIndex,int currentIndex,String escapeStart,String escapeEnd,String targetEscapeStart,String targetEscapeEnd){
  String subformat=formatString.substring(beginIndex,currentIndex);
  if (subformat.equals(escapeStart) || subformat.equals(escapeEnd)) {
    return targetEscapeStart + ""String_Node_Str"" + targetEscapeEnd;
  }
  if (mapping.containsKey(subformat)) {
    String result=mapping.get(subformat);
    if (result == null || result.length() == 0) {
      return targetEscapeStart + ""String_Node_Str"" + subformat+ ""String_Node_Str""+ targetEscapeEnd;
    }
    return result;
  }
  return subformat;
}"
56913,"/** 
 * Internal method to do translations
 * @param formatString
 * @param mapping
 * @return
 */
private static String translateFormat(String formatString,Map<String,String> mapping,String escapeStart,String escapeEnd,String targetEscapeStart,String targetEscapeEnd){
  int beginIndex=0;
  int i=0;
  char lastChar=0;
  char currentChar=0;
  String resultString=""String_Node_Str"";
  char esc1=escapeStart.charAt(0);
  char esc2=escapeEnd.charAt(0);
  for (; i < formatString.length(); i++) {
    currentChar=formatString.charAt(i);
    if (i > 0 && lastChar != currentChar) {
      resultString+=mapSubformat(formatString,mapping,beginIndex,i,targetEscapeStart,targetEscapeEnd);
      beginIndex=i;
    }
    lastChar=currentChar;
    if (currentChar == esc1) {
      i++;
      while (i < formatString.length() && formatString.charAt(i) != esc2) {
        i++;
      }
      resultString+=targetEscapeStart;
      resultString+=formatString.substring(beginIndex + 1,i);
      resultString+=targetEscapeEnd;
      i++;
      if (i < formatString.length()) {
        lastChar=formatString.charAt(i);
      }
      beginIndex=i;
    }
  }
  return resultString + mapSubformat(formatString,mapping,beginIndex,i,escapeStart,escapeEnd);
}","/** 
 * Internal method to do translations
 * @param formatString
 * @param mapping
 * @return
 */
private static String translateFormat(String formatString,Map<String,String> mapping,String escapeStart,String escapeEnd,String targetEscapeStart,String targetEscapeEnd){
  int beginIndex=0;
  int i=0;
  char lastChar=0;
  char currentChar=0;
  String resultString=""String_Node_Str"";
  char esc1=escapeStart.charAt(0);
  char esc2=escapeEnd.charAt(0);
  for (; i < formatString.length(); i++) {
    currentChar=formatString.charAt(i);
    if (i > 0 && lastChar != currentChar) {
      resultString+=mapSubformat(formatString,mapping,beginIndex,i,escapeStart,escapeEnd,targetEscapeStart,targetEscapeEnd);
      beginIndex=i;
    }
    lastChar=currentChar;
    if (currentChar == esc1) {
      i++;
      while (i < formatString.length() && formatString.charAt(i) != esc2) {
        i++;
      }
      resultString+=targetEscapeStart;
      resultString+=formatString.substring(beginIndex + 1,i);
      resultString+=targetEscapeEnd;
      i++;
      if (i < formatString.length()) {
        lastChar=formatString.charAt(i);
      }
      beginIndex=i;
    }
  }
  return resultString + mapSubformat(formatString,mapping,beginIndex,i,escapeStart,escapeEnd,targetEscapeStart,targetEscapeEnd);
}"
56914,"/** 
 * Integer value to specify how many columns to span on small screens (≥768p pixels wide). The number may optionally be followed by ""column"" or ""columns"". Alternative legal values: half, one-third, two-thirds, one-fourth, three-fourths. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public String getColSm(){
  return (String)getStateHelper().eval(PropertyKeys.colSm,""String_Node_Str"");
}","/** 
 * Integer value to specify how many columns to span on small screens (≥768p pixels wide). The number may optionally be followed by ""column"" or ""columns"". Alternative legal values: half, one-third, two-thirds, one-fourth, three-fourths. <P>
 * @return Returns the value of the attribute, or ""-1"", if it hasn't been set by the JSF file.
 */
public String getColSm(){
  return (String)getStateHelper().eval(PropertyKeys.colSm,""String_Node_Str"");
}"
56915,"/** 
 * Alternative spelling to col-lg. Integer value to specify how many columns to span on large screens (≥1200 pixels wide). The number may optionally be followed by ""column"" or ""columns"". Alternative legal values: half, one-third, two-thirds, one-fourth, three-fourths. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public String getLargeScreen(){
  return (String)getStateHelper().eval(PropertyKeys.largeScreen,""String_Node_Str"");
}","/** 
 * Alternative spelling to col-lg. Integer value to specify how many columns to span on large screens (≥1200 pixels wide). The number may optionally be followed by ""column"" or ""columns"". Alternative legal values: half, one-third, two-thirds, one-fourth, three-fourths. <P>
 * @return Returns the value of the attribute, or ""-1"", if it hasn't been set by the JSF file.
 */
public String getLargeScreen(){
  return (String)getStateHelper().eval(PropertyKeys.largeScreen,""String_Node_Str"");
}"
56916,"/** 
 * If set to false, this feature completely disables the search functionality of the datatable (i.e. both the UI and the JavaScript API). <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public boolean isSearching(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.searching,true);
}","/** 
 * If set to false, this feature completely disables the search functionality of the datatable (i.e. both the UI and the JavaScript API). <P>
 * @return Returns the value of the attribute, or true, if it hasn't been set by the JSF file.
 */
public boolean isSearching(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.searching,true);
}"
56917,"/** 
 * Boolean value to specify if the button is disabled. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public boolean isDisabled(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.disabled,false);
}","/** 
 * Boolean value to specify if the button is disabled. <P>
 * @return Returns the value of the attribute, or , false, if it hasn't been set by the JSF file.
 */
public boolean isDisabled(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.disabled,false);
}"
56918,"/** 
 * Integer value to specify how many columns to span on large screens (≥1200 pixels wide). The number may optionally be followed by ""column"" or ""columns"". Alternative legal values: half, one-third, two-thirds, one-fourth, three-fourths. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public String getColLg(){
  return (String)getStateHelper().eval(PropertyKeys.colLg,""String_Node_Str"");
}","/** 
 * Integer value to specify how many columns to span on large screens (≥1200 pixels wide). The number may optionally be followed by ""column"" or ""columns"". Alternative legal values: half, one-third, two-thirds, one-fourth, three-fourths. <P>
 * @return Returns the value of the attribute, or ""-1"", if it hasn't been set by the JSF file.
 */
public String getColLg(){
  return (String)getStateHelper().eval(PropertyKeys.colLg,""String_Node_Str"");
}"
56919,"/** 
 * If set, this will have the container match the height of the rows shown in the table if that height is smaller than that given height by the scroll-size. Default: true. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public boolean isScrollCollapse(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.scrollCollapse,true);
}","/** 
 * If set, this will have the container match the height of the rows shown in the table if that height is smaller than that given height by the scroll-size. Default: true. <P>
 * @return Returns the value of the attribute, or true, if it hasn't been set by the JSF file.
 */
public boolean isScrollCollapse(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.scrollCollapse,true);
}"
56920,"/** 
 * Alternative spelling to col-sm. Integer value to specify how many columns to span on small screens (≥768p pixels wide). The number may optionally be followed by ""column"" or ""columns"". Alternative legal values: half, one-third, two-thirds, one-fourth, three-fourths. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public String getSmallScreen(){
  return (String)getStateHelper().eval(PropertyKeys.smallScreen,""String_Node_Str"");
}","/** 
 * Alternative spelling to col-sm. Integer value to specify how many columns to span on small screens (≥768p pixels wide). The number may optionally be followed by ""column"" or ""columns"". Alternative legal values: half, one-third, two-thirds, one-fourth, three-fourths. <P>
 * @return Returns the value of the attribute, or ""-1"", if it hasn't been set by the JSF file.
 */
public String getSmallScreen(){
  return (String)getStateHelper().eval(PropertyKeys.smallScreen,""String_Node_Str"");
}"
56921,"/** 
 * Activates the fixed header plugin of the dataTable. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public boolean isFixedHeader(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.fixedHeader,false);
}","/** 
 * Activates the fixed header plugin of the dataTable. <P>
 * @return Returns the value of the attribute, or , false, if it hasn't been set by the JSF file.
 */
public boolean isFixedHeader(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.fixedHeader,false);
}"
56922,"/** 
 * Activates the pagination of the dataTable. Default value is 'true'. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public boolean isPaginated(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.paginated,true);
}","/** 
 * Activates the pagination of the dataTable. Default value is 'true'. <P>
 * @return Returns the value of the attribute, or true, if it hasn't been set by the JSF file.
 */
public boolean isPaginated(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.paginated,true);
}"
56923,"/** 
 * If set, this will surround the table by a border. Defaults to true. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public boolean isBorder(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.border,true);
}","/** 
 * If set, this will surround the table by a border. Defaults to true. <P>
 * @return Returns the value of the attribute, or true, if it hasn't been set by the JSF file.
 */
public boolean isBorder(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.border,true);
}"
56924,"/** 
 * The tooltip is shown and hidden with a delay. This value is the delay in milliseconds. Defaults to 0 (no delay). <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public int getTooltipDelay(){
  return (int)(Integer)getStateHelper().eval(PropertyKeys.tooltipDelay,0);
}","/** 
 * The tooltip is shown and hidden with a delay. This value is the delay in milliseconds. Defaults to 0 (no delay). <P>
 * @return Returns the value of the attribute, or 0, if it hasn't been set by the JSF file.
 */
public int getTooltipDelay(){
  return (int)(Integer)getStateHelper().eval(PropertyKeys.tooltipDelay,0);
}"
56925,"/** 
 * If set, this will show the row in alternating background colors (typically shades of gray). Defaults to true. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public boolean isStriped(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.striped,true);
}","/** 
 * If set, this will show the row in alternating background colors (typically shades of gray). Defaults to true. <P>
 * @return Returns the value of the attribute, or true, if it hasn't been set by the JSF file.
 */
public boolean isStriped(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.striped,true);
}"
56926,"/** 
 * The tooltip is hidden with a delay. This value is the delay in milliseconds. Defaults to 0 (no delay). <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public int getTooltipDelayHide(){
  return (int)(Integer)getStateHelper().eval(PropertyKeys.tooltipDelayHide,0);
}","/** 
 * The tooltip is hidden with a delay. This value is the delay in milliseconds. Defaults to 0 (no delay). <P>
 * @return Returns the value of the attribute, or 0, if it hasn't been set by the JSF file.
 */
public int getTooltipDelayHide(){
  return (int)(Integer)getStateHelper().eval(PropertyKeys.tooltipDelayHide,0);
}"
56927,"/** 
 * Alternative spelling to col-md. Integer value to specify how many columns to span on medium screens (≥992 pixels wide). The number may optionally be followed by ""column"" or ""columns"". Alternative legal values: half, one-third, two-thirds, one-fourth, three-fourths. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public String getMediumScreen(){
  return (String)getStateHelper().eval(PropertyKeys.mediumScreen,""String_Node_Str"");
}","/** 
 * Alternative spelling to col-md. Integer value to specify how many columns to span on medium screens (≥992 pixels wide). The number may optionally be followed by ""column"" or ""columns"". Alternative legal values: half, one-third, two-thirds, one-fourth, three-fourths. <P>
 * @return Returns the value of the attribute, or ""-1"", if it hasn't been set by the JSF file.
 */
public String getMediumScreen(){
  return (String)getStateHelper().eval(PropertyKeys.mediumScreen,""String_Node_Str"");
}"
56928,"/** 
 * Sets the default page length for paginated dataTable. The default value is 10. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public int getPageLength(){
  return (int)(Integer)getStateHelper().eval(PropertyKeys.pageLength,10);
}","/** 
 * Sets the default page length for paginated dataTable. The default value is 10. <P>
 * @return Returns the value of the attribute, or 10, if it hasn't been set by the JSF file.
 */
public int getPageLength(){
  return (int)(Integer)getStateHelper().eval(PropertyKeys.pageLength,10);
}"
56929,"/** 
 * If true, &lt;b:inputText /&gt; fields will be generated at the bottom of each column which allow you to perform per-column filtering. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public boolean isMultiColumnSearch(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.multiColumnSearch,false);
}","/** 
 * If true, &lt;b:inputText /&gt; fields will be generated at the bottom of each column which allow you to perform per-column filtering. <P>
 * @return Returns the value of the attribute, or , false, if it hasn't been set by the JSF file.
 */
public boolean isMultiColumnSearch(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.multiColumnSearch,false);
}"
56930,"/** 
 * Stores the state of the datatable on the client, so that after a page reload the same filters are active, the same page is shown etc. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public boolean isSaveState(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.saveState,true);
}","/** 
 * Stores the state of the datatable on the client, so that after a page reload the same filters are active, the same page is shown etc. <P>
 * @return Returns the value of the attribute, or true, if it hasn't been set by the JSF file.
 */
public boolean isSaveState(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.saveState,true);
}"
56931,"/** 
 * Enable the row highlight css. Default: true. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public boolean isRowHighlight(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.rowHighlight,true);
}","/** 
 * Enable the row highlight css. Default: true. <P>
 * @return Returns the value of the attribute, or true, if it hasn't been set by the JSF file.
 */
public boolean isRowHighlight(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.rowHighlight,true);
}"
56932,"/** 
 * Integer value to specify how many columns to span on tiny screens (≤ 767 pixels wide). The number may optionally be followed by ""column"" or ""columns"". Alternative legal values: half, one-third, two-thirds, one-fourth, three-fourths. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public String getColXs(){
  return (String)getStateHelper().eval(PropertyKeys.colXs,""String_Node_Str"");
}","/** 
 * Integer value to specify how many columns to span on tiny screens (≤ 767 pixels wide). The number may optionally be followed by ""column"" or ""columns"". Alternative legal values: half, one-third, two-thirds, one-fourth, three-fourths. <P>
 * @return Returns the value of the attribute, or ""-1"", if it hasn't been set by the JSF file.
 */
public String getColXs(){
  return (String)getStateHelper().eval(PropertyKeys.colXs,""String_Node_Str"");
}"
56933,"/** 
 * Sets the default page length for paginated dataTable. The default value is [10, 25, 50, 100]. The brackets are optional. Read https://www.datatables.net/examples/advanced_init/length_menu.html for details. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public String getPageLengthMenu(){
  return (String)getStateHelper().eval(PropertyKeys.pageLengthMenu,""String_Node_Str"");
}","/** 
 * Sets the default page length for paginated dataTable. The default value is [10, 25, 50, 100]. The brackets are optional. Read https://www.datatables.net/examples/advanced_init/length_menu.html for details. <P>
 * @return Returns the value of the attribute, or ""[ 10, 25, 50, 100 ]"", if it hasn't been set by the JSF file.
 */
public String getPageLengthMenu(){
  return (String)getStateHelper().eval(PropertyKeys.pageLengthMenu,""String_Node_Str"");
}"
56934,"/** 
 * The tooltip is shown with a delay. This value is the delay in milliseconds. Defaults to 0 (no delay). <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public int getTooltipDelayShow(){
  return (int)(Integer)getStateHelper().eval(PropertyKeys.tooltipDelayShow,0);
}","/** 
 * The tooltip is shown with a delay. This value is the delay in milliseconds. Defaults to 0 (no delay). <P>
 * @return Returns the value of the attribute, or 0, if it hasn't been set by the JSF file.
 */
public int getTooltipDelayShow(){
  return (int)(Integer)getStateHelper().eval(PropertyKeys.tooltipDelayShow,0);
}"
56935,"/** 
 * Integer value to specify how many columns to span on medium screens (≥992 pixels wide). The number may optionally be followed by ""column"" or ""columns"". Alternative legal values: half, one-third, two-thirds, one-fourth, three-fourths. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public String getColMd(){
  return (String)getStateHelper().eval(PropertyKeys.colMd,""String_Node_Str"");
}","/** 
 * Integer value to specify how many columns to span on medium screens (≥992 pixels wide). The number may optionally be followed by ""column"" or ""columns"". Alternative legal values: half, one-third, two-thirds, one-fourth, three-fourths. <P>
 * @return Returns the value of the attribute, or ""-1"", if it hasn't been set by the JSF file.
 */
public String getColMd(){
  return (String)getStateHelper().eval(PropertyKeys.colMd,""String_Node_Str"");
}"
56936,"/** 
 * Set this property to ""single"" if you want to prevent multiple selections. Default is ""multiple"". <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public String getSelectionMode(){
  return (String)getStateHelper().eval(PropertyKeys.selectionMode,""String_Node_Str"");
}","/** 
 * Set this property to ""single"" if you want to prevent multiple selections. Default is ""multiple"". <P>
 * @return Returns the value of the attribute, or ""multiple"", if it hasn't been set by the JSF file.
 */
public String getSelectionMode(){
  return (String)getStateHelper().eval(PropertyKeys.selectionMode,""String_Node_Str"");
}"
56937,"/** 
 * Activates AJAX. The default value is false (no AJAX). <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public boolean isAjax(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.ajax,false);
}","/** 
 * Activates AJAX. The default value is false (no AJAX). <P>
 * @return Returns the value of the attribute, or , false, if it hasn't been set by the JSF file.
 */
public boolean isAjax(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.ajax,false);
}"
56938,"/** 
 * Activates the responsive plugin of the dataTable <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public boolean isResponsive(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.responsive,false);
}","/** 
 * Activates the responsive plugin of the dataTable <P>
 * @return Returns the value of the attribute, or , false, if it hasn't been set by the JSF file.
 */
public boolean isResponsive(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.responsive,false);
}"
56939,"/** 
 * Where is the tooltip div generated? That's primarily a technical value that can be used to fix rendering errors in special cases. Also see data-container in the documentation of Bootstrap. The default value is body. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public String getTooltipContainer(){
  return (String)getStateHelper().eval(PropertyKeys.tooltipContainer,""String_Node_Str"");
}","/** 
 * Where is the tooltip div generated? That's primarily a technical value that can be used to fix rendering errors in special cases. Also see data-container in the documentation of Bootstrap. The default value is body. <P>
 * @return Returns the value of the attribute, or ""body"", if it hasn't been set by the JSF file.
 */
public String getTooltipContainer(){
  return (String)getStateHelper().eval(PropertyKeys.tooltipContainer,""String_Node_Str"");
}"
56940,"/** 
 * Flag indicating that, if this component is activated by the user, notifications should be delivered to interested listeners and actions immediately (that is, during Apply Request Values phase) rather than waiting until Invoke Application phase. Default is false. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public boolean isImmediate(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.immediate,false);
}","/** 
 * Flag indicating that, if this component is activated by the user, notifications should be delivered to interested listeners and actions immediately (that is, during Apply Request Values phase) rather than waiting until Invoke Application phase. Default is false. <P>
 * @return Returns the value of the attribute, or , false, if it hasn't been set by the JSF file.
 */
public boolean isImmediate(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.immediate,false);
}"
56941,"/** 
 * If set, the table can scroll horizontally. Defaults to false. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public boolean isScrollX(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.scrollX,false);
}","/** 
 * If set, the table can scroll horizontally. Defaults to false. <P>
 * @return Returns the value of the attribute, or , false, if it hasn't been set by the JSF file.
 */
public boolean isScrollX(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.scrollX,false);
}"
56942,"/** 
 * Allows the user to select rows. Defaults to false. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public boolean isSelect(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.select,false);
}","/** 
 * Allows the user to select rows. Defaults to false. <P>
 * @return Returns the value of the attribute, or , false, if it hasn't been set by the JSF file.
 */
public boolean isSelect(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.select,false);
}"
56943,"/** 
 * Alternative spelling to col-xs. Integer value to specify how many columns to span on tiny screens (≤ 767 pixels wide). The number may optionally be followed by ""column"" or ""columns"". Alternative legal values: half, one-third, two-thirds, one-fourth, three-fourths. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public String getTinyScreen(){
  return (String)getStateHelper().eval(PropertyKeys.tinyScreen,""String_Node_Str"");
}","/** 
 * Alternative spelling to col-xs. Integer value to specify how many columns to span on tiny screens (≤ 767 pixels wide). The number may optionally be followed by ""column"" or ""columns"". Alternative legal values: half, one-third, two-thirds, one-fourth, three-fourths. <P>
 * @return Returns the value of the attribute, or ""-1"", if it hasn't been set by the JSF file.
 */
public String getTinyScreen(){
  return (String)getStateHelper().eval(PropertyKeys.tinyScreen,""String_Node_Str"");
}"
56944,"/** 
 * If you use the ""visible"" attribute, the value of this attribute is added. Legal values: block, inline, inline-block. Default: block. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public String getDisplay(){
  return (String)getStateHelper().eval(PropertyKeys.display,""String_Node_Str"");
}","/** 
 * If you use the ""visible"" attribute, the value of this attribute is added. Legal values: block, inline, inline-block. Default: block. <P>
 * @return Returns the value of the attribute, or ""block"", if it hasn't been set by the JSF file.
 */
public String getDisplay(){
  return (String)getStateHelper().eval(PropertyKeys.display,""String_Node_Str"");
}"
56945,"/** 
 * Show or hide the calendar icon next to the input field. Legal values: 'true' and 'false'. Default value: 'true'. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public boolean isShowIcon(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.showIcon,false);
}","/** 
 * Show or hide the calendar icon next to the input field. Legal values: 'true' and 'false'. Default value: 'true'. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public boolean isShowIcon(){
  return (boolean)(Boolean)getStateHelper().eval(PropertyKeys.showIcon,true);
}"
56946,"/** 
 * Encode the javascript code
 * @throws IOException
 */
private void encodeJS(FacesContext fc,ResponseWriter rw,DateTimePicker dtp,String divPrefix) throws IOException {
  String clientId=dtp.getClientId();
  String fieldId=dtp.getFieldId();
  if (null == fieldId) {
    fieldId=clientId + ""String_Node_Str"";
  }
 else   if (fieldId.equals(dtp.getId())) {
    throw new FacesException(""String_Node_Str"");
  }
  String mode=dtp.getMode();
  Object v=dtp.getSubmittedValue();
  if (v == null) {
    v=dtp.getValue();
  }
  if (dtp.isShowButtonPanel()) {
    dtp.setShowClearButton(true);
    dtp.setShowCloseButton(true);
    dtp.setShowTodayButton(true);
  }
  Locale sloc=BsfUtils.selectLocale(fc.getViewRoot().getLocale(),dtp.getLocale(),dtp);
  String format=BsfUtils.selectDateTimeFormat(sloc,dtp.getFormat(),dtp.isShowDate(),dtp.isShowTime());
  String displayFormat=""String_Node_Str"" + (dtp.getFormat() == null ? LocaleUtils.javaToMomentFormat(format) : format) + ""String_Node_Str"";
  String inlineDisplayDate=""String_Node_Str"" + (dtp.getFormat() == null ? getDateAsString(fc,dtp,v,format,sloc) : getDateAsString(fc,dtp,v,LocaleUtils.momentToJavaFormat(format),sloc)) + ""String_Node_Str"";
  String fullSelector=""String_Node_Str"" + BsfUtils.escapeJQuerySpecialCharsInSelector(clientId);
  String defaultDate=BsfUtils.isStringValued(dtp.getInitialDate()) ? dtp.getInitialDate().contains(""String_Node_Str"") ? dtp.getInitialDate() : ""String_Node_Str"" + dtp.getInitialDate() + ""String_Node_Str"" : ""String_Node_Str"";
  String minDate=BsfUtils.isStringValued(dtp.getMinDate()) ? dtp.getMinDate().contains(""String_Node_Str"") ? dtp.getMinDate() : ""String_Node_Str"" + dtp.getMinDate() + ""String_Node_Str"" : ""String_Node_Str"";
  String maxDate=BsfUtils.isStringValued(dtp.getMaxDate()) ? dtp.getMinDate().contains(""String_Node_Str"") ? dtp.getMaxDate() : ""String_Node_Str"" + dtp.getMaxDate() + ""String_Node_Str"" : ""String_Node_Str"";
  rw.startElement(""String_Node_Str"",dtp);
  rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + fullSelector + ""String_Node_Str""+ ""String_Node_Str""+ (dtp.isAllowInputToggle() ? ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isCollapse() ? ""String_Node_Str"" + dtp.isCollapse() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDayViewHeaderFormat()) ? ""String_Node_Str"" + dtp.getDayViewHeaderFormat() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDisabledDates()) ? ""String_Node_Str"" + dtp.getDisabledDates() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDisableTimeInterval()) ? ""String_Node_Str"" + dtp.getDisableTimeInterval() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getEnabledDates()) ? ""String_Node_Str"" + dtp.getDisableTimeInterval() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isFocusOnShow() ? ""String_Node_Str"" + dtp.isFocusOnShow() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getInitialDate()) ? ""String_Node_Str"" + defaultDate + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isKeepInvalid() ? ""String_Node_Str"" + dtp.isKeepInvalid() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isKeepOpen() ? ""String_Node_Str"" + dtp.isKeepOpen() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(minDate) ? ""String_Node_Str"" + minDate + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(maxDate) ? ""String_Node_Str"" + maxDate + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowWeek() ? ""String_Node_Str"" + dtp.isShowWeek() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowClearButton() ? ""String_Node_Str"" + dtp.isShowClearButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowCloseButton() ? ""String_Node_Str"" + dtp.isShowCloseButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowTodayButton() ? ""String_Node_Str"" + dtp.isShowTodayButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isSideBySide() || ""String_Node_Str"".equals(mode) ? ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.getTimeStepping() > 0 ? ""String_Node_Str"" + dtp.getTimeStepping() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getToolbarPlacement()) ? ""String_Node_Str"" + dtp.getToolbarPlacement() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getViewMode()) ? ""String_Node_Str"" + dtp.getViewMode() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isUseCurrent() ? ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isUseStrict() ? ""String_Node_Str"" + dtp.isUseStrict() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getWidgetParent()) ? ""String_Node_Str"" + BsfUtils.resolveSearchExpressions(dtp.getWidgetParent()) + ""String_Node_Str"" : ""String_Node_Str"")+ (""String_Node_Str"".equals(mode) ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ inlineDisplayDate+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str""+ sloc.getLanguage()+ ""String_Node_Str""+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str"",null);
  if (""String_Node_Str"".equals(mode)) {
    rw.writeText(""String_Node_Str"" + fullSelector + ""String_Node_Str""+ ""String_Node_Str""+ BsfUtils.escapeJQuerySpecialCharsInSelector(fieldId)+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str"",null);
  }
  rw.endElement(""String_Node_Str"");
  new AJAXRenderer().generateBootsFacesAJAXAndJavaScriptForJQuery(fc,dtp,rw,fullSelector,null,true);
}","/** 
 * Encode the javascript code
 * @throws IOException
 */
private void encodeJS(FacesContext fc,ResponseWriter rw,DateTimePicker dtp,String divPrefix) throws IOException {
  String clientId=dtp.getClientId();
  String fieldId=dtp.getFieldId();
  if (null == fieldId) {
    fieldId=clientId + ""String_Node_Str"";
  }
 else   if (fieldId.equals(dtp.getId())) {
    throw new FacesException(""String_Node_Str"");
  }
  String mode=dtp.getMode();
  Object v=dtp.getSubmittedValue();
  if (v == null) {
    v=dtp.getValue();
  }
  if (dtp.isShowButtonPanel()) {
    dtp.setShowClearButton(true);
    dtp.setShowCloseButton(true);
    dtp.setShowTodayButton(true);
  }
  Locale sloc=BsfUtils.selectLocale(fc.getViewRoot().getLocale(),dtp.getLocale(),dtp);
  String format=BsfUtils.selectDateTimeFormat(sloc,dtp.getFormat(),dtp.isShowDate(),dtp.isShowTime());
  String displayFormat=""String_Node_Str"" + (dtp.getFormat() == null ? LocaleUtils.javaToMomentFormat(format) : format) + ""String_Node_Str"";
  String inlineDisplayDate=""String_Node_Str"" + (dtp.getFormat() == null ? getDateAsString(fc,dtp,v,format,sloc) : getDateAsString(fc,dtp,v,LocaleUtils.momentToJavaFormat(format),sloc)) + ""String_Node_Str"";
  String fullSelector=""String_Node_Str"" + BsfUtils.escapeJQuerySpecialCharsInSelector(fieldId);
  String defaultDate=BsfUtils.isStringValued(dtp.getInitialDate()) ? dtp.getInitialDate().contains(""String_Node_Str"") ? dtp.getInitialDate() : ""String_Node_Str"" + dtp.getInitialDate() + ""String_Node_Str"" : ""String_Node_Str"";
  String minDate=BsfUtils.isStringValued(dtp.getMinDate()) ? dtp.getMinDate().contains(""String_Node_Str"") ? dtp.getMinDate() : ""String_Node_Str"" + dtp.getMinDate() + ""String_Node_Str"" : ""String_Node_Str"";
  String maxDate=BsfUtils.isStringValued(dtp.getMaxDate()) ? dtp.getMinDate().contains(""String_Node_Str"") ? dtp.getMaxDate() : ""String_Node_Str"" + dtp.getMaxDate() + ""String_Node_Str"" : ""String_Node_Str"";
  rw.startElement(""String_Node_Str"",dtp);
  rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + fullSelector + ""String_Node_Str""+ ""String_Node_Str""+ (dtp.isAllowInputToggle() ? ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isCollapse() ? ""String_Node_Str"" + dtp.isCollapse() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDayViewHeaderFormat()) ? ""String_Node_Str"" + dtp.getDayViewHeaderFormat() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDisabledDates()) ? ""String_Node_Str"" + dtp.getDisabledDates() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDisableTimeInterval()) ? ""String_Node_Str"" + dtp.getDisableTimeInterval() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getEnabledDates()) ? ""String_Node_Str"" + dtp.getDisableTimeInterval() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isFocusOnShow() ? ""String_Node_Str"" + dtp.isFocusOnShow() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getInitialDate()) ? ""String_Node_Str"" + defaultDate + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isKeepInvalid() ? ""String_Node_Str"" + dtp.isKeepInvalid() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isKeepOpen() ? ""String_Node_Str"" + dtp.isKeepOpen() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(minDate) ? ""String_Node_Str"" + minDate + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(maxDate) ? ""String_Node_Str"" + maxDate + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowWeek() ? ""String_Node_Str"" + dtp.isShowWeek() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowClearButton() ? ""String_Node_Str"" + dtp.isShowClearButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowCloseButton() ? ""String_Node_Str"" + dtp.isShowCloseButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowTodayButton() ? ""String_Node_Str"" + dtp.isShowTodayButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isSideBySide() || ""String_Node_Str"".equals(mode) ? ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.getTimeStepping() > 0 ? ""String_Node_Str"" + dtp.getTimeStepping() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getToolbarPlacement()) ? ""String_Node_Str"" + dtp.getToolbarPlacement() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getViewMode()) ? ""String_Node_Str"" + dtp.getViewMode() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isUseCurrent() ? ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isUseStrict() ? ""String_Node_Str"" + dtp.isUseStrict() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getWidgetParent()) ? ""String_Node_Str"" + BsfUtils.resolveSearchExpressions(dtp.getWidgetParent()) + ""String_Node_Str"" : ""String_Node_Str"")+ (""String_Node_Str"".equals(mode) ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ inlineDisplayDate+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str""+ sloc.getLanguage()+ ""String_Node_Str""+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str"",null);
  if (""String_Node_Str"".equals(mode)) {
    rw.writeText(""String_Node_Str"" + fullSelector + ""String_Node_Str""+ ""String_Node_Str""+ BsfUtils.escapeJQuerySpecialCharsInSelector(fieldId)+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str"",null);
  }
  rw.endElement(""String_Node_Str"");
  new AJAXRenderer().generateBootsFacesAJAXAndJavaScriptForJQuery(fc,dtp,rw,fullSelector,null,true);
}"
56947,"/** 
 * Encode the javascript code
 * @throws IOException
 */
private void encodeJS(FacesContext fc,ResponseWriter rw,DateTimePicker dtp,String divPrefix) throws IOException {
  String clientId=dtp.getClientId();
  String fieldId=dtp.getFieldId();
  if (null == fieldId) {
    fieldId=clientId + ""String_Node_Str"";
  }
 else   if (fieldId.equals(dtp.getId())) {
    throw new FacesException(""String_Node_Str"");
  }
  String mode=dtp.getMode();
  Object v=dtp.getSubmittedValue();
  if (v == null) {
    v=dtp.getValue();
  }
  if (dtp.isShowButtonPanel()) {
    dtp.setShowClearButton(true);
    dtp.setShowCloseButton(true);
    dtp.setShowTodayButton(true);
  }
  Locale sloc=BsfUtils.selectLocale(fc.getViewRoot().getLocale(),dtp.getLocale(),dtp);
  String format=BsfUtils.selectDateTimeFormat(sloc,dtp.getFormat(),dtp.isShowDate(),dtp.isShowTime());
  String displayFormat=""String_Node_Str"" + (dtp.getFormat() == null ? LocaleUtils.javaToMomentFormat(format) : format) + ""String_Node_Str"";
  String inlineDisplayDate=""String_Node_Str"" + (dtp.getFormat() == null ? getDateAsString(fc,dtp,v,format,sloc) : getDateAsString(fc,dtp,v,LocaleUtils.momentToJavaFormat(format),sloc)) + ""String_Node_Str"";
  boolean openOnClick=!""String_Node_Str"".equals(mode) && !""String_Node_Str"".equals(mode);
  String fullSelector=""String_Node_Str"" + BsfUtils.escapeJQuerySpecialCharsInSelector(fieldId);
  String defaultDate=BsfUtils.isStringValued(dtp.getInitialDate()) ? dtp.getInitialDate().contains(""String_Node_Str"") ? dtp.getInitialDate() : ""String_Node_Str"" + dtp.getInitialDate() + ""String_Node_Str"" : ""String_Node_Str"";
  String minDate=BsfUtils.isStringValued(dtp.getMinDate()) ? dtp.getMinDate().contains(""String_Node_Str"") ? dtp.getMinDate() : ""String_Node_Str"" + dtp.getMinDate() + ""String_Node_Str"" : ""String_Node_Str"";
  String maxDate=BsfUtils.isStringValued(dtp.getMaxDate()) ? dtp.getMinDate().contains(""String_Node_Str"") ? dtp.getMaxDate() : ""String_Node_Str"" + dtp.getMaxDate() + ""String_Node_Str"" : ""String_Node_Str"";
  rw.startElement(""String_Node_Str"",dtp);
  rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + fullSelector + ""String_Node_Str""+ ""String_Node_Str""+ (dtp.isAllowInputToggle() || openOnClick ? ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isCollapse() ? ""String_Node_Str"" + dtp.isCollapse() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDayViewHeaderFormat()) ? ""String_Node_Str"" + dtp.getDayViewHeaderFormat() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDisabledDates()) ? ""String_Node_Str"" + dtp.getDisabledDates() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDisableTimeInterval()) ? ""String_Node_Str"" + dtp.getDisableTimeInterval() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getEnabledDates()) ? ""String_Node_Str"" + dtp.getDisableTimeInterval() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isFocusOnShow() ? ""String_Node_Str"" + dtp.isFocusOnShow() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getInitialDate()) ? ""String_Node_Str"" + defaultDate + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isKeepInvalid() ? ""String_Node_Str"" + dtp.isKeepInvalid() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isKeepOpen() ? ""String_Node_Str"" + dtp.isKeepOpen() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(minDate) ? ""String_Node_Str"" + minDate + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(maxDate) ? ""String_Node_Str"" + maxDate + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowWeek() ? ""String_Node_Str"" + dtp.isShowWeek() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowClearButton() ? ""String_Node_Str"" + dtp.isShowClearButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowCloseButton() ? ""String_Node_Str"" + dtp.isShowCloseButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowTodayButton() ? ""String_Node_Str"" + dtp.isShowTodayButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isSideBySide() || ""String_Node_Str"".equals(mode) ? ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.getTimeStepping() > 0 ? ""String_Node_Str"" + dtp.getTimeStepping() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getToolbarPlacement()) ? ""String_Node_Str"" + dtp.getToolbarPlacement() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getViewMode()) ? ""String_Node_Str"" + dtp.getViewMode() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isUseCurrent() ? ""String_Node_Str"" + dtp.isUseCurrent() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isUseStrict() ? ""String_Node_Str"" + dtp.isUseStrict() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getWidgetParent()) ? ""String_Node_Str"" + BsfUtils.resolveSearchExpressions(dtp.getWidgetParent()) + ""String_Node_Str"" : ""String_Node_Str"")+ (""String_Node_Str"".equals(mode) ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ inlineDisplayDate+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str""+ sloc.getLanguage()+ ""String_Node_Str""+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str"",null);
  if (""String_Node_Str"".equals(mode)) {
    rw.writeText(""String_Node_Str"" + fullSelector + ""String_Node_Str""+ ""String_Node_Str""+ BsfUtils.escapeJQuerySpecialCharsInSelector(fieldId)+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str"",null);
  }
  rw.endElement(""String_Node_Str"");
  new AJAXRenderer().generateBootsFacesAJAXAndJavaScriptForJQuery(fc,dtp,rw,fullSelector,null);
}","/** 
 * Encode the javascript code
 * @throws IOException
 */
private void encodeJS(FacesContext fc,ResponseWriter rw,DateTimePicker dtp,String divPrefix) throws IOException {
  String clientId=dtp.getClientId();
  String fieldId=dtp.getFieldId();
  if (null == fieldId) {
    fieldId=clientId + ""String_Node_Str"";
  }
 else   if (fieldId.equals(dtp.getId())) {
    throw new FacesException(""String_Node_Str"");
  }
  String mode=dtp.getMode();
  Object v=dtp.getSubmittedValue();
  if (v == null) {
    v=dtp.getValue();
  }
  if (dtp.isShowButtonPanel()) {
    dtp.setShowClearButton(true);
    dtp.setShowCloseButton(true);
    dtp.setShowTodayButton(true);
  }
  Locale sloc=BsfUtils.selectLocale(fc.getViewRoot().getLocale(),dtp.getLocale(),dtp);
  String format=BsfUtils.selectDateTimeFormat(sloc,dtp.getFormat(),dtp.isShowDate(),dtp.isShowTime());
  String displayFormat=""String_Node_Str"" + (dtp.getFormat() == null ? LocaleUtils.javaToMomentFormat(format) : format) + ""String_Node_Str"";
  String inlineDisplayDate=""String_Node_Str"" + (dtp.getFormat() == null ? getDateAsString(fc,dtp,v,format,sloc) : getDateAsString(fc,dtp,v,LocaleUtils.momentToJavaFormat(format),sloc)) + ""String_Node_Str"";
  boolean openOnClick=!""String_Node_Str"".equals(mode) && !""String_Node_Str"".equals(mode);
  String fullSelector=""String_Node_Str"" + BsfUtils.escapeJQuerySpecialCharsInSelector(clientId);
  String defaultDate=BsfUtils.isStringValued(dtp.getInitialDate()) ? dtp.getInitialDate().contains(""String_Node_Str"") ? dtp.getInitialDate() : ""String_Node_Str"" + dtp.getInitialDate() + ""String_Node_Str"" : ""String_Node_Str"";
  String minDate=BsfUtils.isStringValued(dtp.getMinDate()) ? dtp.getMinDate().contains(""String_Node_Str"") ? dtp.getMinDate() : ""String_Node_Str"" + dtp.getMinDate() + ""String_Node_Str"" : ""String_Node_Str"";
  String maxDate=BsfUtils.isStringValued(dtp.getMaxDate()) ? dtp.getMinDate().contains(""String_Node_Str"") ? dtp.getMaxDate() : ""String_Node_Str"" + dtp.getMaxDate() + ""String_Node_Str"" : ""String_Node_Str"";
  rw.startElement(""String_Node_Str"",dtp);
  rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + fullSelector + ""String_Node_Str""+ ""String_Node_Str""+ (dtp.isAllowInputToggle() || openOnClick ? ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isCollapse() ? ""String_Node_Str"" + dtp.isCollapse() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDayViewHeaderFormat()) ? ""String_Node_Str"" + dtp.getDayViewHeaderFormat() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDisabledDates()) ? ""String_Node_Str"" + dtp.getDisabledDates() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDisableTimeInterval()) ? ""String_Node_Str"" + dtp.getDisableTimeInterval() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getEnabledDates()) ? ""String_Node_Str"" + dtp.getDisableTimeInterval() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isFocusOnShow() ? ""String_Node_Str"" + dtp.isFocusOnShow() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getInitialDate()) ? ""String_Node_Str"" + defaultDate + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isKeepInvalid() ? ""String_Node_Str"" + dtp.isKeepInvalid() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isKeepOpen() ? ""String_Node_Str"" + dtp.isKeepOpen() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(minDate) ? ""String_Node_Str"" + minDate + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(maxDate) ? ""String_Node_Str"" + maxDate + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowWeek() ? ""String_Node_Str"" + dtp.isShowWeek() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowClearButton() ? ""String_Node_Str"" + dtp.isShowClearButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowCloseButton() ? ""String_Node_Str"" + dtp.isShowCloseButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowTodayButton() ? ""String_Node_Str"" + dtp.isShowTodayButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isSideBySide() || ""String_Node_Str"".equals(mode) ? ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.getTimeStepping() > 0 ? ""String_Node_Str"" + dtp.getTimeStepping() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getToolbarPlacement()) ? ""String_Node_Str"" + dtp.getToolbarPlacement() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getViewMode()) ? ""String_Node_Str"" + dtp.getViewMode() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isUseCurrent() ? ""String_Node_Str"" + dtp.isUseCurrent() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isUseStrict() ? ""String_Node_Str"" + dtp.isUseStrict() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getWidgetParent()) ? ""String_Node_Str"" + BsfUtils.resolveSearchExpressions(dtp.getWidgetParent()) + ""String_Node_Str"" : ""String_Node_Str"")+ (""String_Node_Str"".equals(mode) ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ inlineDisplayDate+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str""+ sloc.getLanguage()+ ""String_Node_Str""+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str"",null);
  if (""String_Node_Str"".equals(mode)) {
    rw.writeText(""String_Node_Str"" + fullSelector + ""String_Node_Str""+ ""String_Node_Str""+ BsfUtils.escapeJQuerySpecialCharsInSelector(fieldId)+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str"",null);
  }
  rw.endElement(""String_Node_Str"");
  new AJAXRenderer().generateBootsFacesAJAXAndJavaScriptForJQuery(fc,dtp,rw,fullSelector,null);
}"
56948,"/** 
 * Encode the javascript code
 * @throws IOException
 */
private void encodeJS(FacesContext fc,ResponseWriter rw,DateTimePicker dtp,String divPrefix) throws IOException {
  String clientId=dtp.getClientId();
  String mode=dtp.getMode();
  Object v=dtp.getSubmittedValue();
  if (v == null) {
    v=dtp.getValue();
  }
  if (dtp.isShowButtonPanel()) {
    dtp.setShowClearButton(true);
    dtp.setShowCloseButton(true);
    dtp.setShowTodayButton(true);
  }
  Locale sloc=BsfUtils.selectLocale(fc.getViewRoot().getLocale(),dtp.getLocale(),dtp);
  String format=BsfUtils.selectDateTimeFormat(sloc,dtp.getFormat(),dtp.isShowDate(),dtp.isShowTime());
  String displayFormat=""String_Node_Str"" + (dtp.getFormat() == null ? LocaleUtils.javaToMomentFormat(format) : format) + ""String_Node_Str"";
  String inlineDisplayDate=""String_Node_Str"" + (dtp.getFormat() == null ? getDateAsString(fc,dtp,v,format,sloc) : getDateAsString(fc,dtp,v,LocaleUtils.momentToJavaFormat(format),sloc)) + ""String_Node_Str"";
  boolean openOnClick=!""String_Node_Str"".equals(mode) && !""String_Node_Str"".equals(mode);
  String fullSelector=""String_Node_Str"" + BsfUtils.escapeJQuerySpecialCharsInSelector(divPrefix + clientId);
  String defaultDate=BsfUtils.isStringValued(dtp.getInitialDate()) ? dtp.getInitialDate().contains(""String_Node_Str"") ? dtp.getInitialDate() : ""String_Node_Str"" + dtp.getInitialDate() + ""String_Node_Str"" : ""String_Node_Str"";
  String minDate=BsfUtils.isStringValued(dtp.getMinDate()) ? dtp.getMinDate().contains(""String_Node_Str"") ? dtp.getMinDate() : ""String_Node_Str"" + dtp.getMinDate() + ""String_Node_Str"" : ""String_Node_Str"";
  String maxDate=BsfUtils.isStringValued(dtp.getMaxDate()) ? dtp.getMinDate().contains(""String_Node_Str"") ? dtp.getMaxDate() : ""String_Node_Str"" + dtp.getMaxDate() + ""String_Node_Str"" : ""String_Node_Str"";
  rw.startElement(""String_Node_Str"",dtp);
  rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + fullSelector + ""String_Node_Str""+ ""String_Node_Str""+ (dtp.isAllowInputToggle() || openOnClick ? ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isCollapse() ? ""String_Node_Str"" + dtp.isCollapse() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDayViewHeaderFormat()) ? ""String_Node_Str"" + dtp.getDayViewHeaderFormat() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDisabledDates()) ? ""String_Node_Str"" + dtp.getDisabledDates() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDisableTimeInterval()) ? ""String_Node_Str"" + dtp.getDisableTimeInterval() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getEnabledDates()) ? ""String_Node_Str"" + dtp.getDisableTimeInterval() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isFocusOnShow() ? ""String_Node_Str"" + dtp.isFocusOnShow() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getInitialDate()) ? ""String_Node_Str"" + defaultDate + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isKeepInvalid() ? ""String_Node_Str"" + dtp.isKeepInvalid() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isKeepOpen() ? ""String_Node_Str"" + dtp.isKeepOpen() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(minDate) ? ""String_Node_Str"" + minDate + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(maxDate) ? ""String_Node_Str"" + maxDate + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowWeek() ? ""String_Node_Str"" + dtp.isShowWeek() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowClearButton() ? ""String_Node_Str"" + dtp.isShowClearButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowCloseButton() ? ""String_Node_Str"" + dtp.isShowCloseButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowTodayButton() ? ""String_Node_Str"" + dtp.isShowTodayButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isSideBySide() || ""String_Node_Str"".equals(mode) ? ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.getTimeStepping() > 0 ? ""String_Node_Str"" + dtp.getTimeStepping() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getToolbarPlacement()) ? ""String_Node_Str"" + dtp.getToolbarPlacement() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getViewMode()) ? ""String_Node_Str"" + dtp.getViewMode() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isUseCurrent() ? ""String_Node_Str"" + dtp.isUseCurrent() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isUseStrict() ? ""String_Node_Str"" + dtp.isUseStrict() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getWidgetParent()) ? ""String_Node_Str"" + BsfUtils.resolveSearchExpressions(dtp.getWidgetParent()) + ""String_Node_Str"" : ""String_Node_Str"")+ (""String_Node_Str"".equals(mode) ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ inlineDisplayDate+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str""+ sloc.getLanguage()+ ""String_Node_Str""+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str"",null);
  if (""String_Node_Str"".equals(mode)) {
    rw.writeText(""String_Node_Str"" + fullSelector + ""String_Node_Str""+ ""String_Node_Str""+ BsfUtils.escapeJQuerySpecialCharsInSelector(clientId + ""String_Node_Str"")+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str"",null);
  }
  if (dtp.isDisabled() && !""String_Node_Str"".equals(mode)) {
    rw.writeText(""String_Node_Str"" + fullSelector + ""String_Node_Str"",null);
  }
  rw.endElement(""String_Node_Str"");
  new AJAXRenderer().generateBootsFacesAJAXAndJavaScriptForJQuery(fc,dtp,rw,fullSelector,null);
}","/** 
 * Encode the javascript code
 * @throws IOException
 */
private void encodeJS(FacesContext fc,ResponseWriter rw,DateTimePicker dtp,String divPrefix) throws IOException {
  String clientId=dtp.getClientId();
  String fieldId=dtp.getFieldId();
  if (null == fieldId) {
    fieldId=clientId + ""String_Node_Str"";
  }
 else   if (fieldId.equals(dtp.getId())) {
    throw new FacesException(""String_Node_Str"");
  }
  String mode=dtp.getMode();
  Object v=dtp.getSubmittedValue();
  if (v == null) {
    v=dtp.getValue();
  }
  if (dtp.isShowButtonPanel()) {
    dtp.setShowClearButton(true);
    dtp.setShowCloseButton(true);
    dtp.setShowTodayButton(true);
  }
  Locale sloc=BsfUtils.selectLocale(fc.getViewRoot().getLocale(),dtp.getLocale(),dtp);
  String format=BsfUtils.selectDateTimeFormat(sloc,dtp.getFormat(),dtp.isShowDate(),dtp.isShowTime());
  String displayFormat=""String_Node_Str"" + (dtp.getFormat() == null ? LocaleUtils.javaToMomentFormat(format) : format) + ""String_Node_Str"";
  String inlineDisplayDate=""String_Node_Str"" + (dtp.getFormat() == null ? getDateAsString(fc,dtp,v,format,sloc) : getDateAsString(fc,dtp,v,LocaleUtils.momentToJavaFormat(format),sloc)) + ""String_Node_Str"";
  boolean openOnClick=!""String_Node_Str"".equals(mode) && !""String_Node_Str"".equals(mode);
  String fullSelector=""String_Node_Str"" + BsfUtils.escapeJQuerySpecialCharsInSelector(fieldId);
  String defaultDate=BsfUtils.isStringValued(dtp.getInitialDate()) ? dtp.getInitialDate().contains(""String_Node_Str"") ? dtp.getInitialDate() : ""String_Node_Str"" + dtp.getInitialDate() + ""String_Node_Str"" : ""String_Node_Str"";
  String minDate=BsfUtils.isStringValued(dtp.getMinDate()) ? dtp.getMinDate().contains(""String_Node_Str"") ? dtp.getMinDate() : ""String_Node_Str"" + dtp.getMinDate() + ""String_Node_Str"" : ""String_Node_Str"";
  String maxDate=BsfUtils.isStringValued(dtp.getMaxDate()) ? dtp.getMinDate().contains(""String_Node_Str"") ? dtp.getMaxDate() : ""String_Node_Str"" + dtp.getMaxDate() + ""String_Node_Str"" : ""String_Node_Str"";
  rw.startElement(""String_Node_Str"",dtp);
  rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + fullSelector + ""String_Node_Str""+ ""String_Node_Str""+ (dtp.isAllowInputToggle() || openOnClick ? ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isCollapse() ? ""String_Node_Str"" + dtp.isCollapse() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDayViewHeaderFormat()) ? ""String_Node_Str"" + dtp.getDayViewHeaderFormat() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDisabledDates()) ? ""String_Node_Str"" + dtp.getDisabledDates() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getDisableTimeInterval()) ? ""String_Node_Str"" + dtp.getDisableTimeInterval() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getEnabledDates()) ? ""String_Node_Str"" + dtp.getDisableTimeInterval() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isFocusOnShow() ? ""String_Node_Str"" + dtp.isFocusOnShow() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getInitialDate()) ? ""String_Node_Str"" + defaultDate + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isKeepInvalid() ? ""String_Node_Str"" + dtp.isKeepInvalid() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isKeepOpen() ? ""String_Node_Str"" + dtp.isKeepOpen() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(minDate) ? ""String_Node_Str"" + minDate + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(maxDate) ? ""String_Node_Str"" + maxDate + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowWeek() ? ""String_Node_Str"" + dtp.isShowWeek() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowClearButton() ? ""String_Node_Str"" + dtp.isShowClearButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowCloseButton() ? ""String_Node_Str"" + dtp.isShowCloseButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isShowTodayButton() ? ""String_Node_Str"" + dtp.isShowTodayButton() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isSideBySide() || ""String_Node_Str"".equals(mode) ? ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.getTimeStepping() > 0 ? ""String_Node_Str"" + dtp.getTimeStepping() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getToolbarPlacement()) ? ""String_Node_Str"" + dtp.getToolbarPlacement() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getViewMode()) ? ""String_Node_Str"" + dtp.getViewMode() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isUseCurrent() ? ""String_Node_Str"" + dtp.isUseCurrent() + ""String_Node_Str"" : ""String_Node_Str"")+ (dtp.isUseStrict() ? ""String_Node_Str"" + dtp.isUseStrict() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.isStringValued(dtp.getWidgetParent()) ? ""String_Node_Str"" + BsfUtils.resolveSearchExpressions(dtp.getWidgetParent()) + ""String_Node_Str"" : ""String_Node_Str"")+ (""String_Node_Str"".equals(mode) ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ inlineDisplayDate+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str""+ sloc.getLanguage()+ ""String_Node_Str""+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str"",null);
  if (""String_Node_Str"".equals(mode)) {
    rw.writeText(""String_Node_Str"" + fullSelector + ""String_Node_Str""+ ""String_Node_Str""+ BsfUtils.escapeJQuerySpecialCharsInSelector(fieldId)+ ""String_Node_Str""+ displayFormat+ ""String_Node_Str""+ ""String_Node_Str"",null);
  }
  rw.endElement(""String_Node_Str"");
  new AJAXRenderer().generateBootsFacesAJAXAndJavaScriptForJQuery(fc,dtp,rw,fullSelector,null);
}"
56949,"@Override public void decode(FacesContext context,UIComponent component){
  DateTimePicker dtp=(DateTimePicker)component;
  String clientId=dtp.getClientId();
  String subVal=context.getExternalContext().getRequestParameterMap().get(dtp.getClientId());
  if (dtp.isDisabled() || dtp.isReadonly()) {
    return;
  }
  if (subVal != null) {
    dtp.setSubmittedValue(subVal);
    dtp.setValid(true);
  }
  new AJAXRenderer().decode(context,dtp,clientId + ""String_Node_Str"");
  new AJAXRenderer().decode(context,dtp,clientId);
}","@Override public void decode(FacesContext context,UIComponent component){
  DateTimePicker dtp=(DateTimePicker)component;
  String clientId=dtp.getClientId();
  String subVal=context.getExternalContext().getRequestParameterMap().get(dtp.getClientId());
  if (dtp.isDisabled() || dtp.isReadonly()) {
    return;
  }
  if (subVal != null) {
    dtp.setSubmittedValue(subVal);
    dtp.setValid(true);
  }
  String fieldId=dtp.getFieldId();
  if (null == fieldId) {
    fieldId=clientId + ""String_Node_Str"";
  }
  new AJAXRenderer().decode(context,dtp,fieldId);
  new AJAXRenderer().decode(context,dtp,clientId);
}"
56950,"/** 
 * Encodes the HTML for this context
 * @param fc
 * @throws IOException
 */
private String encodeHTML(FacesContext fc,ResponseWriter rw,DateTimePicker dtp) throws IOException {
  String clientId=dtp.getClientId();
  boolean clientIdHasBeenRendered=false;
  String mode=dtp.getMode();
  String styleClass=dtp.getStyleClass();
  if (styleClass == null)   styleClass=""String_Node_Str"";
  styleClass=styleClass.trim();
  String responsiveStyleClass=Responsive.getResponsiveStyleClass(dtp,false);
  String label=dtp.getLabel();
  if (!dtp.isRenderLabel()) {
    label=null;
  }
  String divPrefix=""String_Node_Str"";
  if (null != responsiveStyleClass && responsiveStyleClass.trim().length() > 0) {
    rw.startElement(""String_Node_Str"",dtp);
    if (!isHorizontalForm(dtp)) {
      rw.writeAttribute(""String_Node_Str"",responsiveStyleClass + ""String_Node_Str"",""String_Node_Str"");
    }
 else {
      rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    }
    rw.writeAttribute(""String_Node_Str"",clientId,null);
    Tooltip.generateTooltip(fc,dtp,rw);
    clientIdHasBeenRendered=true;
    divPrefix=DTP_CONTAINER_ID;
  }
 else   if (label != null) {
    rw.startElement(""String_Node_Str"",dtp);
    rw.writeAttribute(""String_Node_Str"",clientId,null);
    divPrefix=DTP_CONTAINER_ID;
    Tooltip.generateTooltip(fc,dtp,rw);
    clientIdHasBeenRendered=true;
  }
  if (label != null) {
    rw.startElement(""String_Node_Str"",dtp);
    rw.writeAttribute(""String_Node_Str"",clientId + ""String_Node_Str"",""String_Node_Str"");
    generateErrorAndRequiredClassForLabels(dtp,rw,clientId,dtp.getLabelStyleClass());
    writeAttribute(rw,""String_Node_Str"",dtp.getLabelStyle());
    rw.writeText(label,null);
    rw.endElement(""String_Node_Str"");
  }
  if (isHorizontalForm(dtp) && null != responsiveStyleClass && responsiveStyleClass.trim().length() > 0) {
    rw.startElement(""String_Node_Str"",dtp);
    rw.writeAttribute(""String_Node_Str"",responsiveStyleClass,""String_Node_Str"");
    if (!clientIdHasBeenRendered) {
      rw.writeAttribute(""String_Node_Str"",clientId,null);
      Tooltip.generateTooltip(fc,dtp,rw);
      clientIdHasBeenRendered=true;
      divPrefix=DTP_CONTAINER_ID2;
    }
  }
  Object v=dtp.getSubmittedValue();
  if (v == null) {
    v=dtp.getValue();
  }
  String icon=dtp.getIcon();
  String faicon=dtp.getIconAwesome();
  boolean fa=false;
  if (BsfUtils.isStringValued(faicon)) {
    icon=faicon;
    fa=true;
  }
  if (!BsfUtils.isStringValued(icon)) {
    icon=""String_Node_Str"";
    fa=false;
  }
  if (""String_Node_Str"".equals(mode)) {
    rw.startElement(""String_Node_Str"",dtp);
    if (styleClass.length() > 0) {
      rw.writeAttribute(""String_Node_Str"",styleClass,""String_Node_Str"");
    }
    rw.writeAttribute(""String_Node_Str"",divPrefix + clientId,null);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + styleClass,""String_Node_Str"");
    if (dtp.getStyle() != null)     rw.writeAttribute(""String_Node_Str"",dtp.getStyle(),""String_Node_Str"");
    rw.startElement(""String_Node_Str"",dtp);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
    rw.writeAttribute(""String_Node_Str"",clientId + ""String_Node_Str"",null);
    rw.writeAttribute(""String_Node_Str"",clientId,null);
    if (dtp.getTabindex() != null) {
      rw.writeAttribute(""String_Node_Str"",dtp.getTabindex(),null);
    }
    generateStyleClass(dtp,rw);
    if (BsfUtils.isStringValued(dtp.getPlaceholder()))     rw.writeAttribute(""String_Node_Str"",dtp.getPlaceholder(),null);
    if (dtp.isReadonly())     rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
    if (dtp.isDisabled())     rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
    if (v != null) {
      rw.writeAttribute(""String_Node_Str"",getValueAsString(v,fc,dtp),null);
    }
    Tooltip.generateTooltip(fc,dtp,rw);
    AJAXRenderer.generateBootsFacesAJAXAndJavaScript(FacesContext.getCurrentInstance(),dtp,rw,false);
    rw.endElement(""String_Node_Str"");
    rw.startElement(""String_Node_Str"",dtp);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    IconRenderer.encodeIcon(rw,dtp,icon,fa,null,null,null,false,null,null,dtp.isDisabled(),true,true,true);
    rw.endElement(""String_Node_Str"");
    rw.endElement(""String_Node_Str"");
  }
 else   if (""String_Node_Str"".equals(mode)) {
    rw.startElement(""String_Node_Str"",dtp);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + styleClass,""String_Node_Str"");
    if (dtp.getStyle() != null)     rw.writeAttribute(""String_Node_Str"",(dtp.isDisabled() ? ""String_Node_Str"" : ""String_Node_Str"") + dtp.getStyle(),""String_Node_Str"");
 else     if (dtp.isDisabled())     rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
    rw.writeAttribute(""String_Node_Str"",divPrefix + clientId,null);
    if (!clientIdHasBeenRendered) {
      Tooltip.generateTooltip(fc,dtp,rw);
      clientIdHasBeenRendered=true;
    }
    rw.endElement(""String_Node_Str"");
    rw.startElement(""String_Node_Str"",dtp);
    rw.writeAttribute(""String_Node_Str"",clientId + ""String_Node_Str"",null);
    rw.writeAttribute(""String_Node_Str"",clientId,null);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    if (dtp.getTabindex() != null) {
      rw.writeAttribute(""String_Node_Str"",dtp.getTabindex(),null);
    }
    if (dtp.isReadonly())     rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
    if (dtp.isDisabled())     rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
    if (v != null) {
      rw.writeAttribute(""String_Node_Str"",getValueAsString(v,fc,dtp),null);
    }
    rw.endElement(""String_Node_Str"");
  }
 else {
    rw.startElement(""String_Node_Str"",dtp);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + styleClass,""String_Node_Str"");
    if (dtp.getStyle() != null)     rw.writeAttribute(""String_Node_Str"",dtp.getStyle(),""String_Node_Str"");
    rw.writeAttribute(""String_Node_Str"",divPrefix + clientId,null);
    if (!clientIdHasBeenRendered) {
      Tooltip.generateTooltip(fc,dtp,rw);
      clientIdHasBeenRendered=true;
      divPrefix=DTP_CONTAINER_ID2;
    }
    rw.startElement(""String_Node_Str"",dtp);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
    rw.writeAttribute(""String_Node_Str"",clientId + ""String_Node_Str"",null);
    rw.writeAttribute(""String_Node_Str"",clientId,null);
    if (dtp.getTabindex() != null) {
      rw.writeAttribute(""String_Node_Str"",dtp.getTabindex(),null);
    }
    generateStyleClass(dtp,rw);
    if (BsfUtils.isStringValued(dtp.getPlaceholder()))     rw.writeAttribute(""String_Node_Str"",dtp.getPlaceholder(),null);
    if (dtp.isReadonly())     rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
    if (dtp.isDisabled())     rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
    if (v != null) {
      rw.writeAttribute(""String_Node_Str"",getValueAsString(v,fc,dtp),null);
    }
    AJAXRenderer.generateBootsFacesAJAXAndJavaScript(FacesContext.getCurrentInstance(),dtp,rw,false);
    rw.endElement(""String_Node_Str"");
    rw.startElement(""String_Node_Str"",dtp);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    IconRenderer.encodeIcon(rw,dtp,icon,fa,null,null,null,false,null,null,dtp.isDisabled(),true,true,true);
    rw.endElement(""String_Node_Str"");
    rw.endElement(""String_Node_Str"");
  }
  if (isHorizontalForm(dtp) && null != responsiveStyleClass && responsiveStyleClass.trim().length() > 0) {
    rw.endElement(""String_Node_Str"");
  }
  if (null != responsiveStyleClass && responsiveStyleClass.trim().length() > 0) {
    rw.endElement(""String_Node_Str"");
  }
 else   if (label != null) {
    rw.endElement(""String_Node_Str"");
  }
  Tooltip.activateTooltips(fc,dtp);
  return divPrefix;
}","/** 
 * Encodes the HTML for this context
 * @param fc
 * @throws IOException
 */
private String encodeHTML(FacesContext fc,ResponseWriter rw,DateTimePicker dtp) throws IOException {
  String clientId=dtp.getClientId();
  boolean clientIdHasBeenRendered=false;
  String mode=dtp.getMode();
  String styleClass=dtp.getStyleClass();
  if (styleClass == null)   styleClass=""String_Node_Str"";
  styleClass=styleClass.trim();
  String responsiveStyleClass=Responsive.getResponsiveStyleClass(dtp,false);
  String label=dtp.getLabel();
  if (!dtp.isRenderLabel()) {
    label=null;
  }
  String divPrefix=""String_Node_Str"";
  if (null != responsiveStyleClass && responsiveStyleClass.trim().length() > 0) {
    rw.startElement(""String_Node_Str"",dtp);
    if (!isHorizontalForm(dtp)) {
      rw.writeAttribute(""String_Node_Str"",responsiveStyleClass + ""String_Node_Str"",""String_Node_Str"");
    }
 else {
      rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    }
    rw.writeAttribute(""String_Node_Str"",clientId,null);
    Tooltip.generateTooltip(fc,dtp,rw);
    clientIdHasBeenRendered=true;
    divPrefix=DTP_CONTAINER_ID;
  }
 else   if (label != null) {
    rw.startElement(""String_Node_Str"",dtp);
    rw.writeAttribute(""String_Node_Str"",clientId,null);
    divPrefix=DTP_CONTAINER_ID;
    Tooltip.generateTooltip(fc,dtp,rw);
    clientIdHasBeenRendered=true;
  }
  String fieldId=dtp.getFieldId();
  if (null == fieldId) {
    fieldId=clientId + ""String_Node_Str"";
  }
 else   if (fieldId.equals(dtp.getId())) {
    throw new FacesException(""String_Node_Str"");
  }
  if (label != null) {
    rw.startElement(""String_Node_Str"",dtp);
    rw.writeAttribute(""String_Node_Str"",fieldId,""String_Node_Str"");
    generateErrorAndRequiredClassForLabels(dtp,rw,clientId,dtp.getLabelStyleClass());
    writeAttribute(rw,""String_Node_Str"",dtp.getLabelStyle());
    rw.writeText(label,null);
    rw.endElement(""String_Node_Str"");
  }
  if (isHorizontalForm(dtp) && null != responsiveStyleClass && responsiveStyleClass.trim().length() > 0) {
    rw.startElement(""String_Node_Str"",dtp);
    rw.writeAttribute(""String_Node_Str"",responsiveStyleClass,""String_Node_Str"");
    if (!clientIdHasBeenRendered) {
      rw.writeAttribute(""String_Node_Str"",clientId,null);
      Tooltip.generateTooltip(fc,dtp,rw);
      clientIdHasBeenRendered=true;
      divPrefix=DTP_CONTAINER_ID2;
    }
  }
  Object v=dtp.getSubmittedValue();
  if (v == null) {
    v=dtp.getValue();
  }
  String icon=dtp.getIcon();
  String faicon=dtp.getIconAwesome();
  boolean fa=false;
  if (BsfUtils.isStringValued(faicon)) {
    icon=faicon;
    fa=true;
  }
  if (!BsfUtils.isStringValued(icon)) {
    icon=""String_Node_Str"";
    fa=false;
  }
  if (""String_Node_Str"".equals(mode)) {
    rw.startElement(""String_Node_Str"",dtp);
    if (styleClass.length() > 0) {
      rw.writeAttribute(""String_Node_Str"",styleClass,""String_Node_Str"");
    }
    rw.writeAttribute(""String_Node_Str"",divPrefix + clientId,null);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + styleClass,""String_Node_Str"");
    if (dtp.getStyle() != null)     rw.writeAttribute(""String_Node_Str"",dtp.getStyle(),""String_Node_Str"");
    rw.startElement(""String_Node_Str"",dtp);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
    rw.writeAttribute(""String_Node_Str"",fieldId,null);
    rw.writeAttribute(""String_Node_Str"",clientId,null);
    if (dtp.getTabindex() != null) {
      rw.writeAttribute(""String_Node_Str"",dtp.getTabindex(),null);
    }
    generateStyleClass(dtp,rw);
    if (BsfUtils.isStringValued(dtp.getPlaceholder()))     rw.writeAttribute(""String_Node_Str"",dtp.getPlaceholder(),null);
    if (dtp.isReadonly())     rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
    if (dtp.isDisabled())     rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
    if (v != null) {
      rw.writeAttribute(""String_Node_Str"",getValueAsString(v,fc,dtp),null);
    }
    Tooltip.generateTooltip(fc,dtp,rw);
    AJAXRenderer.generateBootsFacesAJAXAndJavaScript(FacesContext.getCurrentInstance(),dtp,rw,false);
    rw.endElement(""String_Node_Str"");
    rw.startElement(""String_Node_Str"",dtp);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    IconRenderer.encodeIcon(rw,dtp,icon,fa,null,null,null,false,null,null,dtp.isDisabled(),true,true,true);
    rw.endElement(""String_Node_Str"");
    rw.endElement(""String_Node_Str"");
  }
 else   if (""String_Node_Str"".equals(mode)) {
    rw.startElement(""String_Node_Str"",dtp);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + styleClass,""String_Node_Str"");
    if (dtp.getStyle() != null)     rw.writeAttribute(""String_Node_Str"",(dtp.isDisabled() ? ""String_Node_Str"" : ""String_Node_Str"") + dtp.getStyle(),""String_Node_Str"");
 else     if (dtp.isDisabled())     rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
    rw.writeAttribute(""String_Node_Str"",divPrefix + clientId,null);
    if (!clientIdHasBeenRendered) {
      Tooltip.generateTooltip(fc,dtp,rw);
      clientIdHasBeenRendered=true;
    }
    rw.endElement(""String_Node_Str"");
    rw.startElement(""String_Node_Str"",dtp);
    rw.writeAttribute(""String_Node_Str"",fieldId,null);
    rw.writeAttribute(""String_Node_Str"",clientId,null);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    if (dtp.getTabindex() != null) {
      rw.writeAttribute(""String_Node_Str"",dtp.getTabindex(),null);
    }
    if (dtp.isReadonly())     rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
    if (dtp.isDisabled())     rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
    if (v != null) {
      rw.writeAttribute(""String_Node_Str"",getValueAsString(v,fc,dtp),null);
    }
    rw.endElement(""String_Node_Str"");
  }
 else {
    rw.startElement(""String_Node_Str"",dtp);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + styleClass,""String_Node_Str"");
    if (dtp.getStyle() != null)     rw.writeAttribute(""String_Node_Str"",dtp.getStyle(),""String_Node_Str"");
    rw.writeAttribute(""String_Node_Str"",divPrefix + clientId,null);
    if (!clientIdHasBeenRendered) {
      Tooltip.generateTooltip(fc,dtp,rw);
      clientIdHasBeenRendered=true;
      divPrefix=DTP_CONTAINER_ID2;
    }
    rw.startElement(""String_Node_Str"",dtp);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
    rw.writeAttribute(""String_Node_Str"",fieldId,null);
    rw.writeAttribute(""String_Node_Str"",clientId,null);
    if (dtp.getTabindex() != null) {
      rw.writeAttribute(""String_Node_Str"",dtp.getTabindex(),null);
    }
    generateStyleClass(dtp,rw);
    if (BsfUtils.isStringValued(dtp.getPlaceholder()))     rw.writeAttribute(""String_Node_Str"",dtp.getPlaceholder(),null);
    if (dtp.isReadonly())     rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
    if (dtp.isDisabled())     rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
    if (v != null) {
      rw.writeAttribute(""String_Node_Str"",getValueAsString(v,fc,dtp),null);
    }
    AJAXRenderer.generateBootsFacesAJAXAndJavaScript(FacesContext.getCurrentInstance(),dtp,rw,false);
    rw.endElement(""String_Node_Str"");
    rw.startElement(""String_Node_Str"",dtp);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    IconRenderer.encodeIcon(rw,dtp,icon,fa,null,null,null,false,null,null,dtp.isDisabled(),true,true,true);
    rw.endElement(""String_Node_Str"");
    rw.endElement(""String_Node_Str"");
  }
  if (isHorizontalForm(dtp) && null != responsiveStyleClass && responsiveStyleClass.trim().length() > 0) {
    rw.endElement(""String_Node_Str"");
  }
  if (null != responsiveStyleClass && responsiveStyleClass.trim().length() > 0) {
    rw.endElement(""String_Node_Str"");
  }
 else   if (label != null) {
    rw.endElement(""String_Node_Str"");
  }
  Tooltip.activateTooltips(fc,dtp);
  return divPrefix;
}"
56951,"private void encodeJS(FacesContext fc,ResponseWriter rw,String cId,String dpId) throws IOException {
  Map<String,Object> attrs=getAttributes();
  StringBuilder sb=new StringBuilder(150);
  sb.append(JQ.DTFORMAT).append(""String_Node_Str"").append(""String_Node_Str"" + convertFormat(sdf) + ""String_Node_Str"").append(""String_Node_Str"");
  if (A.toInt(attrs.get(JQ.NUMOFMONTHS)) > 0) {
    sb.append(JQ.NUMOFMONTHS).append(""String_Node_Str"").append(attrs.get(JQ.NUMOFMONTHS)).append(""String_Node_Str"");
  }
  if (A.toInt(attrs.get(JQ.FIRSTDAY)) > 0) {
    sb.append(JQ.FIRSTDAY).append(""String_Node_Str"").append(attrs.get(JQ.FIRSTDAY)).append(""String_Node_Str"");
  }
  if (A.toBool(attrs.get(JQ.SHOWBUTS))) {
    sb.append(JQ.SHOWBUTS).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  }
  if (A.toBool(attrs.get(JQ.CHNGMONTH))) {
    sb.append(JQ.CHNGMONTH).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  }
  if (A.toBool(attrs.get(JQ.CHNGYEAR))) {
    sb.append(JQ.CHNGYEAR).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  }
  if (A.toBool(attrs.get(JQ.SHOWWK))) {
    sb.append(JQ.SHOWWK).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  }
  if (mode.equals(""String_Node_Str"") || mode.equals(""String_Node_Str"")) {
    sb.append(JQ.SHOWON).append(""String_Node_Str"").append(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"").append(""String_Node_Str"");
  }
  if (A.toBool(attrs.get(JQ.DTDISABLED))) {
    sb.append(JQ.DTDISABLED).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  }
  if (attrs.get(JQ.MINDATE) != null) {
    sb.append(JQ.MINDATE + ""String_Node_Str"" + ""String_Node_Str"").append(getDateAsString(attrs.get(JQ.MINDATE),sdf,sloc)).append(""String_Node_Str"");
  }
  if (attrs.get(JQ.MAXDATE) != null) {
    sb.append(JQ.MAXDATE + ""String_Node_Str"" + ""String_Node_Str"").append(getDateAsString(attrs.get(JQ.MAXDATE),sdf,sloc)).append(""String_Node_Str"");
  }
  String l=A.asString(attrs.get(JQ.LANG));
  if (l == null) {
    l=sloc.getLanguage();
  }
  JQ.datePicker(rw,cId,dpId,sb.toString(),l);
}","private void encodeJS(FacesContext fc,ResponseWriter rw,String cId,String dpId) throws IOException {
  Map<String,Object> attrs=getAttributes();
  StringBuilder sb=new StringBuilder(150);
  sb.append(JQ.DTFORMAT).append(""String_Node_Str"").append(""String_Node_Str"" + convertFormat(sdf) + ""String_Node_Str"").append(""String_Node_Str"");
  if (A.toInt(attrs.get(JQ.NUMOFMONTHS)) > 0) {
    sb.append(JQ.NUMOFMONTHS).append(""String_Node_Str"").append(attrs.get(JQ.NUMOFMONTHS)).append(""String_Node_Str"");
  }
  if (A.toInt(attrs.get(JQ.FIRSTDAY)) > 0) {
    sb.append(JQ.FIRSTDAY).append(""String_Node_Str"").append(attrs.get(JQ.FIRSTDAY)).append(""String_Node_Str"");
  }
  if (A.toBool(attrs.get(JQ.SHOWBUTS))) {
    sb.append(JQ.SHOWBUTS).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  }
  if (A.toBool(attrs.get(JQ.CHNGMONTH))) {
    sb.append(JQ.CHNGMONTH).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  }
  if (A.toBool(attrs.get(JQ.CHNGYEAR))) {
    sb.append(JQ.CHNGYEAR).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  }
  if (A.toBool(attrs.get(JQ.SHOWWK))) {
    sb.append(JQ.SHOWWK).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  }
  if (mode.equals(""String_Node_Str"") || mode.equals(""String_Node_Str"")) {
    sb.append(JQ.SHOWON).append(""String_Node_Str"").append(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"").append(""String_Node_Str"");
  }
  if (A.toBool(attrs.get(JQ.DTDISABLED))) {
    sb.append(JQ.DTDISABLED).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  }
  if (attrs.get(JQ.MINDATE) != null) {
    sb.append(JQ.MINDATE + ""String_Node_Str"" + ""String_Node_Str"").append(getDateAsString(attrs.get(JQ.MINDATE),sdf,sloc)).append(""String_Node_Str"");
  }
  if (attrs.get(JQ.MAXDATE) != null) {
    sb.append(JQ.MAXDATE + ""String_Node_Str"" + ""String_Node_Str"").append(getDateAsString(attrs.get(JQ.MAXDATE),sdf,sloc)).append(""String_Node_Str"");
  }
  String l=A.asString(attrs.get(JQ.LANG));
  if (l == null) {
    l=sloc.getLanguage();
  }
  String options=sb.toString();
  if (options.endsWith(""String_Node_Str"")) {
    options=options.substring(0,options.length() - 1);
  }
  JQ.datePicker(rw,cId,dpId,options,l);
}"
56952,"public static final void datePicker(ResponseWriter rw,String cId,String dpId,String opts,String region) throws IOException {
  startInlineF(rw,cId);
  StringBuilder sb=new StringBuilder(150);
  String sel=DP_SEL_INPUT.replace(WID,dpId);
  if (region != null)   sb.append(DP_REGION.replace(SEL,sel).replace(""String_Node_Str"",region));
  if (!cId.equals(dpId)) {
    sel=DP_SEL_DIV.replace(WID,dpId);
    sb.append(DP_START.replace(SEL,sel)).append(opts);
    sb.append(DP_SELECT.replace(CID,cId));
  }
 else {
    sb.append(DP_START.replace(SEL,sel)).append(opts);
  }
  sb.append(END_F);
  rw.write(sb.toString());
  endInlineF(rw);
}","public static final void datePicker(ResponseWriter rw,String cId,String dpId,String opts,String region) throws IOException {
  startInlineF(rw,cId);
  StringBuilder sb=new StringBuilder(150);
  String sel=DP_SEL_INPUT.replace(WID,dpId);
  if (region != null)   sb.append(DP_REGION.replace(SEL,sel).replace(""String_Node_Str"",region));
  if (!cId.equals(dpId)) {
    sel=DP_SEL_DIV.replace(WID,dpId);
    sb.append(DP_START.replace(SEL,sel)).append(opts);
    if (sb.length() > 0 && sb.charAt(sb.length() - 1) != ',') {
      sb.append(',');
    }
    sb.append(DP_SELECT.replace(CID,cId));
  }
 else {
    sb.append(DP_START.replace(SEL,sel)).append(opts);
  }
  sb.append(END_F);
  rw.write(sb.toString());
  endInlineF(rw);
}"
56953,"private void encodeSeverityMessages(FacesContext facesContext,Messages uiMessages,String severity,List<FacesMessage> messages) throws IOException {
  ResponseWriter writer=facesContext.getResponseWriter();
  String styleClassPrefix=""String_Node_Str"";
  String stylePrefix=""String_Node_Str"";
  String iconStyleClass=""String_Node_Str"";
  if (""String_Node_Str"".equals(severity)) {
    styleClassPrefix=""String_Node_Str"" + uiMessages.getWarnClass();
    iconStyleClass=""String_Node_Str"";
    stylePrefix=uiMessages.getWarnStyle();
  }
 else   if (""String_Node_Str"".equals(severity)) {
    styleClassPrefix=""String_Node_Str"" + uiMessages.getFatalClass();
    stylePrefix=uiMessages.getFatalStyle();
    iconStyleClass=""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equals(severity)) {
    styleClassPrefix=""String_Node_Str"" + uiMessages.getErrorClass();
    stylePrefix=uiMessages.getErrorStyle();
    iconStyleClass=""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equals(severity)) {
    styleClassPrefix=""String_Node_Str"" + uiMessages.getInfoClass();
    stylePrefix=uiMessages.getInfoStyle();
    iconStyleClass=""String_Node_Str"";
  }
  writer.startElement(""String_Node_Str"",null);
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"" + styleClassPrefix,null);
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"" + stylePrefix,null);
  writer.startElement(""String_Node_Str"",null);
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  writer.write(""String_Node_Str"");
  writer.endElement(""String_Node_Str"");
  boolean firstMessage=true;
  for (  FacesMessage msg : messages) {
    if (!firstMessage && uiMessages.isLineBreak())     writer.append(uiMessages.getLineBreakTag());
    firstMessage=false;
    writer.startElement(""String_Node_Str"",null);
    writer.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
    if (uiMessages.isShowIcon()) {
      writer.startElement(""String_Node_Str"",null);
      writeAttribute(writer,""String_Node_Str"",iconStyleClass + ""String_Node_Str"");
      writeAttribute(writer,""String_Node_Str"",""String_Node_Str"");
      writer.endElement(""String_Node_Str"");
    }
    if (uiMessages.isShowSummary() && msg.getSummary() != null && !msg.getSummary().trim().isEmpty() && !msg.getSummary().equals(msg.getDetail())) {
      writer.startElement(""String_Node_Str"",null);
      writer.startElement(""String_Node_Str"",null);
      writeAttribute(writer,""String_Node_Str"",""String_Node_Str"");
      if (uiMessages.isEscape()) {
        writer.writeText(msg.getSummary(),null);
      }
 else {
        MessageRenderer.warnOnFirstUse();
        writer.write(msg.getSummary());
      }
      writer.endElement(""String_Node_Str"");
      writer.endElement(""String_Node_Str"");
    }
    if (uiMessages.isShowDetail() && msg.getDetail() != null) {
      writer.startElement(""String_Node_Str"",null);
      writeAttribute(writer,""String_Node_Str"",""String_Node_Str"");
      if (uiMessages.isEscape()) {
        writer.writeText(msg.getDetail(),null);
      }
 else {
        MessageRenderer.warnOnFirstUse();
        writer.write(msg.getDetail());
      }
      writer.endElement(""String_Node_Str"");
    }
    writer.endElement(""String_Node_Str"");
    msg.rendered();
  }
  writer.endElement(""String_Node_Str"");
}","private void encodeSeverityMessages(FacesContext facesContext,Messages uiMessages,String severity,List<FacesMessage> messages) throws IOException {
  ResponseWriter writer=facesContext.getResponseWriter();
  String styleClassPrefix=""String_Node_Str"";
  String stylePrefix=""String_Node_Str"";
  String iconStyleClass=""String_Node_Str"";
  if (""String_Node_Str"".equals(severity)) {
    String warnClass=uiMessages.getWarnClass();
    if (null == warnClass)     styleClassPrefix=""String_Node_Str"";
 else     styleClassPrefix=""String_Node_Str"" + warnClass;
    iconStyleClass=""String_Node_Str"";
    stylePrefix=uiMessages.getWarnStyle();
  }
 else   if (""String_Node_Str"".equals(severity)) {
    String fatalClass=uiMessages.getFatalClass();
    if (null == fatalClass) {
      styleClassPrefix=""String_Node_Str"";
    }
 else {
      styleClassPrefix=""String_Node_Str"" + fatalClass;
    }
    stylePrefix=uiMessages.getFatalStyle();
    iconStyleClass=""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equals(severity)) {
    String errorClass=uiMessages.getErrorClass();
    if (null == errorClass) {
      styleClassPrefix=""String_Node_Str"";
    }
 else {
      styleClassPrefix=""String_Node_Str"" + errorClass;
    }
    stylePrefix=uiMessages.getErrorStyle();
    iconStyleClass=""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equals(severity)) {
    String infoClass=uiMessages.getInfoClass();
    if (infoClass == null) {
      styleClassPrefix=""String_Node_Str"";
    }
 else {
      styleClassPrefix=""String_Node_Str"" + infoClass;
    }
    stylePrefix=uiMessages.getInfoStyle();
    iconStyleClass=""String_Node_Str"";
  }
  if (stylePrefix == null) {
    stylePrefix=""String_Node_Str"";
  }
  writer.startElement(""String_Node_Str"",null);
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"" + styleClassPrefix,null);
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"" + stylePrefix,null);
  writer.startElement(""String_Node_Str"",null);
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  writer.write(""String_Node_Str"");
  writer.endElement(""String_Node_Str"");
  boolean firstMessage=true;
  for (  FacesMessage msg : messages) {
    if (!firstMessage && uiMessages.isLineBreak())     writer.append(uiMessages.getLineBreakTag());
    firstMessage=false;
    writer.startElement(""String_Node_Str"",null);
    writer.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
    if (uiMessages.isShowIcon()) {
      writer.startElement(""String_Node_Str"",null);
      writeAttribute(writer,""String_Node_Str"",iconStyleClass + ""String_Node_Str"");
      writeAttribute(writer,""String_Node_Str"",""String_Node_Str"");
      writer.endElement(""String_Node_Str"");
    }
    if (uiMessages.isShowSummary() && msg.getSummary() != null && !msg.getSummary().trim().isEmpty() && !msg.getSummary().equals(msg.getDetail())) {
      writer.startElement(""String_Node_Str"",null);
      writer.startElement(""String_Node_Str"",null);
      writeAttribute(writer,""String_Node_Str"",""String_Node_Str"");
      if (uiMessages.isEscape()) {
        writer.writeText(msg.getSummary(),null);
      }
 else {
        MessageRenderer.warnOnFirstUse();
        writer.write(msg.getSummary());
      }
      writer.endElement(""String_Node_Str"");
      writer.endElement(""String_Node_Str"");
    }
    if (uiMessages.isShowDetail() && msg.getDetail() != null) {
      writer.startElement(""String_Node_Str"",null);
      writeAttribute(writer,""String_Node_Str"",""String_Node_Str"");
      if (uiMessages.isEscape()) {
        writer.writeText(msg.getDetail(),null);
      }
 else {
        MessageRenderer.warnOnFirstUse();
        writer.write(msg.getDetail());
      }
      writer.endElement(""String_Node_Str"");
    }
    writer.endElement(""String_Node_Str"");
    msg.rendered();
  }
  writer.endElement(""String_Node_Str"");
}"
56954,"/** 
 * Value of the item. Must be omitted if you use the traditional JSF approach using <f:selectItem /> or <f:selectItems />. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public String getItemValue(){
  return (String)getStateHelper().eval(PropertyKeys.itemValue);
}","/** 
 * Value of the item. Must be omitted if you use the traditional JSF approach using &lt;f:selectItem /&gt; or &lt;f:selectItems /&gt;. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public String getItemValue(){
  return (String)getStateHelper().eval(PropertyKeys.itemValue);
}"
56955,"/** 
 * Value of the item. Must be omitted if you use the traditional JSF approach using <f:selectItem /> or <f:selectItems />. <P> Usually this method is called internally by the JSF engine.
 */
public void setItemValue(String _itemValue){
  getStateHelper().put(PropertyKeys.itemValue,_itemValue);
}","/** 
 * Value of the item. Must be omitted if you use the traditional JSF approach using &lt;f:selectItem /&gt; or &lt;f:selectItems /&gt;. <P> Usually this method is called internally by the JSF engine.
 */
public void setItemValue(String _itemValue){
  getStateHelper().put(PropertyKeys.itemValue,_itemValue);
}"
56956,"/** 
 * The caption of the radio button. Alternatively you can use arbitrary captions by embedding them as child elements of the b:radiobutton. As a third alternative, you can follow the traditional JSF approach using <f:selectItem /> or <f:selectItems />. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public String getItemLabel(){
  return (String)getStateHelper().eval(PropertyKeys.itemLabel);
}","/** 
 * The caption of the radio button. Alternatively you can use arbitrary captions by embedding them as child elements of the b:radiobutton. As a third alternative, you can follow the traditional JSF approach using &lt;f:f:selectItem /&gt; or &lt;f:selectItems /&gt;. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public String getItemLabel(){
  return (String)getStateHelper().eval(PropertyKeys.itemLabel);
}"
56957,"/** 
 * The caption of the radio button. Alternatively you can use arbitrary captions by embedding them as child elements of the b:radiobutton. As a third alternative, you can follow the traditional JSF approach using <f:selectItem /> or <f:selectItems />. <P> Usually this method is called internally by the JSF engine.
 */
public void setItemLabel(String _itemLabel){
  getStateHelper().put(PropertyKeys.itemLabel,_itemLabel);
}","/** 
 * The caption of the radio button. Alternatively you can use arbitrary captions by embedding them as child elements of the b:radiobutton. As a third alternative, you can follow the traditional JSF approach using &lt;f:f:selectItem /&gt; or &lt;f:selectItems /&gt;. <P> Usually this method is called internally by the JSF engine.
 */
public void setItemLabel(String _itemLabel){
  getStateHelper().put(PropertyKeys.itemLabel,_itemLabel);
}"
56958,"/** 
 * This methods generates the HTML code of the current b:message.
 * @param context the FacesContext.
 * @param component the current b:message.
 * @throws IOException thrown if something goes wrong when writing the HTML code.
 */
@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  Message message=(Message)component;
  String forValue=message.getFor();
  if (null == forValue || forValue.length() == 0)   forValue=""String_Node_Str"";
  forValue=ExpressionResolver.getComponentIDs(context,message,forValue);
  List<FacesMessage> messageList=new ArrayList<FacesMessage>();
  Iterator<FacesMessage> messageIterator=FacesContext.getCurrentInstance().getMessages(forValue);
  while (messageIterator.hasNext()) {
    FacesMessage fm=messageIterator.next();
    messageList.add(fm);
  }
  ResponseWriter rw=context.getResponseWriter();
  String clientId=message.getClientId();
  rw.startElement(""String_Node_Str"",message);
  writeAttribute(rw,""String_Node_Str"",clientId);
  if (null != messageList && (!messageList.isEmpty())) {
    if (null != message.getDir()) {
      rw.writeAttribute(""String_Node_Str"",message.getDir(),""String_Node_Str"");
    }
    String styleClass=message.getStyleClass();
    if (null != styleClass && styleClass.length() > 0)     styleClass=styleClass + ""String_Node_Str"";
 else     styleClass=""String_Node_Str"";
    String severityClass=findHighestSeverityClass(messageList,message);
    styleClass+=""String_Node_Str"" + severityClass + ""String_Node_Str"";
    styleClass+=Responsive.getResponsiveStyleClass(message,false);
    writeAttribute(rw,""String_Node_Str"",styleClass.trim());
    writeAttribute(rw,""String_Node_Str"",findHighestSeverityStyle(messageList,message));
    writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
    boolean onlyMostSevere=message.isOnlyMostSevere();
    FacesMessage mostSevere=null;
    if (onlyMostSevere) {
      for (      FacesMessage msg : messageList) {
        if (null == mostSevere) {
          mostSevere=msg;
        }
 else         if (msg.getSeverity().getOrdinal() > mostSevere.getSeverity().getOrdinal()) {
          mostSevere=msg;
        }
      }
    }
    boolean firstMessage=true;
    for (    FacesMessage msg : messageList) {
      if (onlyMostSevere && msg != mostSevere) {
        continue;
      }
      if (!firstMessage) {
        if (message.isLineBreak()) {
          rw.append(message.getLineBreakTag());
        }
      }
      firstMessage=false;
      if (message.isShowIcon()) {
        rw.startElement(""String_Node_Str"",component);
        writeAttribute(rw,""String_Node_Str"",findHighestSeverityIcon(messageList,message) + ""String_Node_Str"");
        writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
        rw.endElement(""String_Node_Str"");
      }
      if (message.isShowSummary() && msg.getSummary() != null && !msg.getSummary().equals(msg.getDetail())) {
        rw.startElement(""String_Node_Str"",component);
        writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
        if (message.isEscape()) {
          rw.writeText(msg.getSummary(),null);
        }
 else {
          warnOnFirstUse();
          rw.write(msg.getSummary());
        }
        rw.endElement(""String_Node_Str"");
      }
      if (message.isShowDetail() && msg.getDetail() != null) {
        rw.startElement(""String_Node_Str"",component);
        writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
        if (message.isEscape()) {
          rw.writeText(msg.getDetail(),null);
        }
 else {
          warnOnFirstUse();
          rw.write(msg.getDetail());
        }
        rw.endElement(""String_Node_Str"");
      }
      msg.rendered();
    }
  }
  rw.endElement(""String_Node_Str"");
}","/** 
 * This methods generates the HTML code of the current b:message.
 * @param context the FacesContext.
 * @param component the current b:message.
 * @throws IOException thrown if something goes wrong when writing the HTML code.
 */
@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  Message message=(Message)component;
  String forValue=message.getFor();
  if (null == forValue || forValue.length() == 0)   forValue=""String_Node_Str"";
  forValue=ExpressionResolver.getComponentIDs(context,message,forValue);
  List<FacesMessage> messageList=new ArrayList<FacesMessage>();
  Iterator<FacesMessage> messageIterator=FacesContext.getCurrentInstance().getMessages(forValue);
  while (messageIterator.hasNext()) {
    FacesMessage fm=messageIterator.next();
    messageList.add(fm);
  }
  ResponseWriter rw=context.getResponseWriter();
  String clientId=message.getClientId();
  rw.startElement(""String_Node_Str"",message);
  writeAttribute(rw,""String_Node_Str"",clientId);
  if (null != messageList && (!messageList.isEmpty())) {
    if (null != message.getDir()) {
      rw.writeAttribute(""String_Node_Str"",message.getDir(),""String_Node_Str"");
    }
    String styleClass=message.getStyleClass();
    if (null != styleClass && styleClass.length() > 0)     styleClass=styleClass + ""String_Node_Str"";
 else     styleClass=""String_Node_Str"";
    String severityClass=findHighestSeverityClass(messageList,message);
    styleClass+=""String_Node_Str"" + severityClass + ""String_Node_Str"";
    styleClass+=Responsive.getResponsiveStyleClass(message,false);
    writeAttribute(rw,""String_Node_Str"",styleClass.trim());
    String style=message.getStyle();
    if (null == style)     style=""String_Node_Str"";
 else     if (!style.endsWith(""String_Node_Str""))     style+=""String_Node_Str"";
    String severityStyle=findHighestSeverityStyle(messageList,message);
    if (null == severityStyle)     severityStyle=""String_Node_Str"";
 else     if (!severityStyle.endsWith(""String_Node_Str""))     severityStyle+=""String_Node_Str"";
    writeAttribute(rw,""String_Node_Str"",style + severityStyle);
    writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
    boolean onlyMostSevere=message.isOnlyMostSevere();
    FacesMessage mostSevere=null;
    if (onlyMostSevere) {
      for (      FacesMessage msg : messageList) {
        if (null == mostSevere) {
          mostSevere=msg;
        }
 else         if (msg.getSeverity().getOrdinal() > mostSevere.getSeverity().getOrdinal()) {
          mostSevere=msg;
        }
      }
    }
    boolean firstMessage=true;
    for (    FacesMessage msg : messageList) {
      if (onlyMostSevere && msg != mostSevere) {
        continue;
      }
      if (!firstMessage) {
        if (message.isLineBreak()) {
          rw.append(message.getLineBreakTag());
        }
      }
      firstMessage=false;
      if (message.isShowIcon()) {
        rw.startElement(""String_Node_Str"",component);
        writeAttribute(rw,""String_Node_Str"",findHighestSeverityIcon(messageList,message) + ""String_Node_Str"");
        writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
        rw.endElement(""String_Node_Str"");
      }
      if (message.isShowSummary() && msg.getSummary() != null && !msg.getSummary().equals(msg.getDetail())) {
        rw.startElement(""String_Node_Str"",component);
        writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
        if (message.isEscape()) {
          rw.writeText(msg.getSummary(),null);
        }
 else {
          warnOnFirstUse();
          rw.write(msg.getSummary());
        }
        rw.endElement(""String_Node_Str"");
      }
      if (message.isShowDetail() && msg.getDetail() != null) {
        rw.startElement(""String_Node_Str"",component);
        writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
        if (message.isEscape()) {
          rw.writeText(msg.getDetail(),null);
        }
 else {
          warnOnFirstUse();
          rw.write(msg.getDetail());
        }
        rw.endElement(""String_Node_Str"");
      }
      msg.rendered();
    }
  }
  rw.endElement(""String_Node_Str"");
}"
56959,"private void encodeSeverityMessages(FacesContext facesContext,Messages uiMessages,String severity,List<FacesMessage> messages) throws IOException {
  ResponseWriter writer=facesContext.getResponseWriter();
  String styleClassPrefix=""String_Node_Str"";
  String stylePrefix=""String_Node_Str"";
  String iconStyleClass=""String_Node_Str"";
  if (""String_Node_Str"".equals(severity)) {
    String warnClass=uiMessages.getWarnClass();
    if (null == warnClass)     styleClassPrefix=""String_Node_Str"";
 else     styleClassPrefix=""String_Node_Str"" + warnClass;
    iconStyleClass=""String_Node_Str"";
    stylePrefix=uiMessages.getWarnStyle();
  }
 else   if (""String_Node_Str"".equals(severity)) {
    String fatalClass=uiMessages.getFatalClass();
    if (null == fatalClass) {
      styleClassPrefix=""String_Node_Str"";
    }
 else {
      styleClassPrefix=""String_Node_Str"" + fatalClass;
    }
    stylePrefix=uiMessages.getFatalStyle();
    iconStyleClass=""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equals(severity)) {
    String errorClass=uiMessages.getErrorClass();
    if (null == errorClass) {
      styleClassPrefix=""String_Node_Str"";
    }
 else {
      styleClassPrefix=""String_Node_Str"" + errorClass;
    }
    stylePrefix=uiMessages.getErrorStyle();
    iconStyleClass=""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equals(severity)) {
    String infoClass=uiMessages.getInfoClass();
    if (infoClass == null) {
      styleClassPrefix=""String_Node_Str"";
    }
 else {
      styleClassPrefix=""String_Node_Str"" + infoClass;
    }
    stylePrefix=uiMessages.getInfoStyle();
    iconStyleClass=""String_Node_Str"";
  }
  if (stylePrefix == null) {
    stylePrefix=""String_Node_Str"";
  }
  writer.startElement(""String_Node_Str"",null);
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"" + styleClassPrefix,null);
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"" + stylePrefix,null);
  writer.startElement(""String_Node_Str"",null);
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  writer.write(""String_Node_Str"");
  writer.endElement(""String_Node_Str"");
  boolean firstMessage=true;
  for (  FacesMessage msg : messages) {
    if (!firstMessage && uiMessages.isLineBreak())     writer.append(uiMessages.getLineBreakTag());
    firstMessage=false;
    writer.startElement(""String_Node_Str"",null);
    writer.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
    if (uiMessages.isShowIcon()) {
      writer.startElement(""String_Node_Str"",null);
      writeAttribute(writer,""String_Node_Str"",iconStyleClass + ""String_Node_Str"");
      writeAttribute(writer,""String_Node_Str"",""String_Node_Str"");
      writer.endElement(""String_Node_Str"");
    }
    if (uiMessages.isShowSummary() && msg.getSummary() != null && !msg.getSummary().trim().isEmpty() && !msg.getSummary().equals(msg.getDetail())) {
      writer.startElement(""String_Node_Str"",null);
      writer.startElement(""String_Node_Str"",null);
      writeAttribute(writer,""String_Node_Str"",""String_Node_Str"");
      if (uiMessages.isEscape()) {
        writer.writeText(msg.getSummary(),null);
      }
 else {
        MessageRenderer.warnOnFirstUse();
        writer.write(msg.getSummary());
      }
      writer.endElement(""String_Node_Str"");
      writer.endElement(""String_Node_Str"");
    }
    if (uiMessages.isShowDetail() && msg.getDetail() != null) {
      writer.startElement(""String_Node_Str"",null);
      writeAttribute(writer,""String_Node_Str"",""String_Node_Str"");
      if (uiMessages.isEscape()) {
        writer.writeText(msg.getDetail(),null);
      }
 else {
        MessageRenderer.warnOnFirstUse();
        writer.write(msg.getDetail());
      }
      writer.endElement(""String_Node_Str"");
    }
    writer.endElement(""String_Node_Str"");
    msg.rendered();
  }
  writer.endElement(""String_Node_Str"");
}","private void encodeSeverityMessages(FacesContext facesContext,Messages uiMessages,String severity,List<FacesMessage> messages) throws IOException {
  ResponseWriter writer=facesContext.getResponseWriter();
  String styleClassPrefix=""String_Node_Str"";
  String stylePrefix=uiMessages.getStyle();
  if (null == stylePrefix) {
    stylePrefix=""String_Node_Str"";
  }
 else   if (!styleClassPrefix.endsWith(""String_Node_Str"")) {
    stylePrefix+=""String_Node_Str"";
  }
  String iconStyleClass=""String_Node_Str"";
  if (""String_Node_Str"".equals(severity)) {
    String warnClass=uiMessages.getWarnClass();
    if (null == warnClass)     styleClassPrefix=""String_Node_Str"";
 else     styleClassPrefix=""String_Node_Str"" + warnClass;
    iconStyleClass=""String_Node_Str"";
    stylePrefix+=uiMessages.getWarnStyle();
  }
 else   if (""String_Node_Str"".equals(severity)) {
    String fatalClass=uiMessages.getFatalClass();
    if (null == fatalClass) {
      styleClassPrefix=""String_Node_Str"";
    }
 else {
      styleClassPrefix=""String_Node_Str"" + fatalClass;
    }
    stylePrefix+=uiMessages.getFatalStyle();
    iconStyleClass=""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equals(severity)) {
    String errorClass=uiMessages.getErrorClass();
    if (null == errorClass) {
      styleClassPrefix=""String_Node_Str"";
    }
 else {
      styleClassPrefix=""String_Node_Str"" + errorClass;
    }
    stylePrefix+=uiMessages.getErrorStyle();
    iconStyleClass=""String_Node_Str"";
  }
 else   if (""String_Node_Str"".equals(severity)) {
    String infoClass=uiMessages.getInfoClass();
    if (infoClass == null) {
      styleClassPrefix=""String_Node_Str"";
    }
 else {
      styleClassPrefix=""String_Node_Str"" + infoClass;
    }
    stylePrefix+=uiMessages.getInfoStyle();
    iconStyleClass=""String_Node_Str"";
  }
  writer.startElement(""String_Node_Str"",null);
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"" + styleClassPrefix,null);
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"" + stylePrefix,null);
  writer.startElement(""String_Node_Str"",null);
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  writer.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  writer.write(""String_Node_Str"");
  writer.endElement(""String_Node_Str"");
  boolean firstMessage=true;
  for (  FacesMessage msg : messages) {
    if (!firstMessage && uiMessages.isLineBreak())     writer.append(uiMessages.getLineBreakTag());
    firstMessage=false;
    writer.startElement(""String_Node_Str"",null);
    writer.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
    if (uiMessages.isShowIcon()) {
      writer.startElement(""String_Node_Str"",null);
      writeAttribute(writer,""String_Node_Str"",iconStyleClass + ""String_Node_Str"");
      writeAttribute(writer,""String_Node_Str"",""String_Node_Str"");
      writer.endElement(""String_Node_Str"");
    }
    if (uiMessages.isShowSummary() && msg.getSummary() != null && !msg.getSummary().trim().isEmpty() && !msg.getSummary().equals(msg.getDetail())) {
      writer.startElement(""String_Node_Str"",null);
      writer.startElement(""String_Node_Str"",null);
      writeAttribute(writer,""String_Node_Str"",""String_Node_Str"");
      if (uiMessages.isEscape()) {
        writer.writeText(msg.getSummary(),null);
      }
 else {
        MessageRenderer.warnOnFirstUse();
        writer.write(msg.getSummary());
      }
      writer.endElement(""String_Node_Str"");
      writer.endElement(""String_Node_Str"");
    }
    if (uiMessages.isShowDetail() && msg.getDetail() != null) {
      writer.startElement(""String_Node_Str"",null);
      writeAttribute(writer,""String_Node_Str"",""String_Node_Str"");
      if (uiMessages.isEscape()) {
        writer.writeText(msg.getDetail(),null);
      }
 else {
        MessageRenderer.warnOnFirstUse();
        writer.write(msg.getDetail());
      }
      writer.endElement(""String_Node_Str"");
    }
    writer.endElement(""String_Node_Str"");
    msg.rendered();
  }
  writer.endElement(""String_Node_Str"");
}"
56960,"public List<UIComponent> resolve(UIComponent component,List<UIComponent> parentComponents,String currentId,String originalExpression,String[] parameters){
  if (null == parameters || parameters.length != 1) {
    throw new FacesException(""String_Node_Str"" + originalExpression);
  }
  String propertyName=""String_Node_Str"" + parameters[0] + ""String_Node_Str"";
  List<UIComponent> result=findPropertyRecursively(component,propertyName);
  return result;
}","public List<UIComponent> resolve(UIComponent component,List<UIComponent> parentComponents,String currentId,String originalExpression,String[] parameters){
  if (null == parameters || parameters.length != 1) {
    throw new FacesException(""String_Node_Str"" + originalExpression);
  }
  String propertyName=""String_Node_Str"" + parameters[0] + ""String_Node_Str"";
  List<UIComponent> result=null;
  for (  UIComponent p : parentComponents) {
    List<UIComponent> r=findPropertyRecursively(p,propertyName);
    if (result == null) {
      result=r;
    }
 else     if (r != null) {
      result.addAll(r);
    }
  }
  return result;
}"
56961,"public List<UIComponent> resolve(UIComponent component,List<UIComponent> parentComponents,String currentId,String originalExpression,String[] parameters){
  if (null == parameters || parameters.length != 1) {
    throw new FacesException(""String_Node_Str"" + originalExpression);
  }
  List<UIComponent> result=findStyleClassRecursively(component,parameters[0]);
  return result;
}","public List<UIComponent> resolve(UIComponent component,List<UIComponent> parentComponents,String currentId,String originalExpression,String[] parameters){
  if (null == parameters || parameters.length != 1) {
    throw new FacesException(""String_Node_Str"" + originalExpression);
  }
  List<UIComponent> result=null;
  for (  UIComponent p : parentComponents) {
    List<UIComponent> r=findStyleClassRecursively(p,parameters[0]);
    if (result == null) {
      result=r;
    }
 else     if (r != null) {
      result.addAll(r);
    }
  }
  return result;
}"
56962,"/** 
 * This methods generates the HTML code of the current b:panel. <code>encodeBegin</code> generates the start of the component. After the, the JSF framework calls <code>encodeChildren()</code> to generate the HTML code between the beginning and the end of the component. For instance, in the case of a panel component the content of the panel is generated by <code>encodeChildren()</code>. After that, <code>encodeEnd()</code> is called to generate the rest of the HTML code.
 * @param context the FacesContext.
 * @param component the current b:panel.
 * @throws IOException thrown if something goes wrong when writing the HTML code.
 */
@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  Panel panel=(Panel)component;
  ResponseWriter rw=context.getResponseWriter();
  String clientId=panel.getClientId();
  String jQueryClientID=clientId.replace(""String_Node_Str"",""String_Node_Str"");
  boolean isCollapsible=panel.isCollapsible();
  String accordionParent=panel.getAccordionParent();
  if (isCollapsible && null == accordionParent) {
    rw.startElement(""String_Node_Str"",panel);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + Responsive.getResponsiveStyleClass(panel),null);
  }
  String _look=panel.getLook();
  String _title=panel.getTitle();
  String _titleClass=panel.getTitleClass();
  String _styleClass=panel.getStyleClass();
  if (null == _styleClass) {
    _styleClass=""String_Node_Str"";
  }
 else {
    _styleClass+=""String_Node_Str"";
  }
  rw.startElement(""String_Node_Str"",panel);
  rw.writeAttribute(""String_Node_Str"",clientId,""String_Node_Str"");
  writeAttribute(rw,""String_Node_Str"",panel.getDir(),""String_Node_Str"");
  renderPassThruAttributes(context,component,null,true);
  AJAXRenderer.generateBootsFacesAJAXAndJavaScript(context,panel,rw);
  Tooltip.generateTooltip(context,panel,rw);
  String _style=panel.getStyle();
  if (null != _style && _style.length() > 0) {
    rw.writeAttribute(""String_Node_Str"",_style,""String_Node_Str"");
  }
  if (_look != null) {
    rw.writeAttribute(""String_Node_Str"",_styleClass + ""String_Node_Str"" + _look,""String_Node_Str"");
  }
 else {
    rw.writeAttribute(""String_Node_Str"",_styleClass + ""String_Node_Str"",""String_Node_Str"");
  }
  UIComponent head=panel.getFacet(""String_Node_Str"");
  if (head != null || _title != null) {
    rw.startElement(""String_Node_Str"",panel);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    String _titleStyle=panel.getTitleStyle();
    if (null != _titleStyle) {
      rw.writeAttribute(""String_Node_Str"",_titleStyle,""String_Node_Str"");
    }
    if (_title != null) {
      rw.startElement(""String_Node_Str"",panel);
      if (_titleClass != null) {
        rw.writeAttribute(""String_Node_Str"",_titleClass,""String_Node_Str"");
      }
 else {
        rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
      if (isCollapsible) {
        writeTitleLink(panel,rw,jQueryClientID,accordionParent);
      }
      rw.writeText(_title,null);
      if (isCollapsible) {
        rw.endElement(""String_Node_Str"");
      }
      rw.endElement(""String_Node_Str"");
    }
 else {
      if (isCollapsible) {
        writeTitleLink(panel,rw,jQueryClientID,accordionParent);
      }
      head.encodeAll(context);
      if (isCollapsible) {
        rw.endElement(""String_Node_Str"");
      }
    }
    rw.endElement(""String_Node_Str"");
  }
  rw.startElement(""String_Node_Str"",panel);
  rw.writeAttribute(""String_Node_Str"",jQueryClientID + ""String_Node_Str"",null);
  writeAttribute(rw,""String_Node_Str"",panel.getDir(),""String_Node_Str"");
  String _contentClass=panel.getContentClass();
  if (null == _contentClass)   _contentClass=""String_Node_Str"";
  if (isCollapsible) {
    _contentClass+=""String_Node_Str"";
    if (!panel.isCollapsed())     _contentClass+=""String_Node_Str"";
  }
  _contentClass=_contentClass.trim();
  if (_contentClass.length() > 0)   rw.writeAttribute(""String_Node_Str"",_contentClass,""String_Node_Str"");
  String _contentStyle=panel.getContentStyle();
  if (null != _contentStyle && _contentStyle.length() > 0) {
    rw.writeAttribute(""String_Node_Str"",_contentStyle,""String_Node_Str"");
  }
  rw.startElement(""String_Node_Str"",panel);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","/** 
 * This methods generates the HTML code of the current b:panel. <code>encodeBegin</code> generates the start of the component. After the, the JSF framework calls <code>encodeChildren()</code> to generate the HTML code between the beginning and the end of the component. For instance, in the case of a panel component the content of the panel is generated by <code>encodeChildren()</code>. After that, <code>encodeEnd()</code> is called to generate the rest of the HTML code.
 * @param context the FacesContext.
 * @param component the current b:panel.
 * @throws IOException thrown if something goes wrong when writing the HTML code.
 */
@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  Panel panel=(Panel)component;
  ResponseWriter rw=context.getResponseWriter();
  String clientId=panel.getClientId();
  String jQueryClientID=clientId.replace(""String_Node_Str"",""String_Node_Str"");
  boolean isCollapsible=panel.isCollapsible();
  String accordionParent=panel.getAccordionParent();
  if (isCollapsible && null == accordionParent) {
    rw.startElement(""String_Node_Str"",panel);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + Responsive.getResponsiveStyleClass(panel),null);
    rw.writeAttribute(""String_Node_Str"",clientId,""String_Node_Str"");
  }
  String _look=panel.getLook();
  String _title=panel.getTitle();
  String _titleClass=panel.getTitleClass();
  String _styleClass=panel.getStyleClass();
  if (null == _styleClass) {
    _styleClass=""String_Node_Str"";
  }
 else {
    _styleClass+=""String_Node_Str"";
  }
  rw.startElement(""String_Node_Str"",panel);
  if (!(isCollapsible && null == accordionParent)) {
    rw.writeAttribute(""String_Node_Str"",clientId,""String_Node_Str"");
  }
  writeAttribute(rw,""String_Node_Str"",panel.getDir(),""String_Node_Str"");
  renderPassThruAttributes(context,component,null,true);
  AJAXRenderer.generateBootsFacesAJAXAndJavaScript(context,panel,rw);
  Tooltip.generateTooltip(context,panel,rw);
  String _style=panel.getStyle();
  if (null != _style && _style.length() > 0) {
    rw.writeAttribute(""String_Node_Str"",_style,""String_Node_Str"");
  }
  if (_look != null) {
    rw.writeAttribute(""String_Node_Str"",_styleClass + ""String_Node_Str"" + _look,""String_Node_Str"");
  }
 else {
    rw.writeAttribute(""String_Node_Str"",_styleClass + ""String_Node_Str"",""String_Node_Str"");
  }
  UIComponent head=panel.getFacet(""String_Node_Str"");
  if (head != null || _title != null) {
    rw.startElement(""String_Node_Str"",panel);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    String _titleStyle=panel.getTitleStyle();
    if (null != _titleStyle) {
      rw.writeAttribute(""String_Node_Str"",_titleStyle,""String_Node_Str"");
    }
    if (_title != null) {
      rw.startElement(""String_Node_Str"",panel);
      if (_titleClass != null) {
        rw.writeAttribute(""String_Node_Str"",_titleClass,""String_Node_Str"");
      }
 else {
        rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      }
      if (isCollapsible) {
        writeTitleLink(panel,rw,jQueryClientID,accordionParent);
      }
      rw.writeText(_title,null);
      if (isCollapsible) {
        rw.endElement(""String_Node_Str"");
      }
      rw.endElement(""String_Node_Str"");
    }
 else {
      if (isCollapsible) {
        writeTitleLink(panel,rw,jQueryClientID,accordionParent);
      }
      head.encodeAll(context);
      if (isCollapsible) {
        rw.endElement(""String_Node_Str"");
      }
    }
    rw.endElement(""String_Node_Str"");
  }
  rw.startElement(""String_Node_Str"",panel);
  rw.writeAttribute(""String_Node_Str"",jQueryClientID + ""String_Node_Str"",null);
  writeAttribute(rw,""String_Node_Str"",panel.getDir(),""String_Node_Str"");
  String _contentClass=panel.getContentClass();
  if (null == _contentClass)   _contentClass=""String_Node_Str"";
  if (isCollapsible) {
    _contentClass+=""String_Node_Str"";
    if (!panel.isCollapsed())     _contentClass+=""String_Node_Str"";
  }
  _contentClass=_contentClass.trim();
  if (_contentClass.length() > 0)   rw.writeAttribute(""String_Node_Str"",_contentClass,""String_Node_Str"");
  String _contentStyle=panel.getContentStyle();
  if (null != _contentStyle && _contentStyle.length() > 0) {
    rw.writeAttribute(""String_Node_Str"",_contentStyle,""String_Node_Str"");
  }
  rw.startElement(""String_Node_Str"",panel);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}"
56963,"private Tag createTags(Tag tag){
  String ns=tag.getNamespace();
  if (HTML_NAMESPACE.equals(ns)) {
    active=true;
    TagAttributes modifiedAttributes=tag.getAttributes();
    if (""String_Node_Str"".equals(tag.getLocalName())) {
      TagAttribute tagAttribute=modifiedAttributes.get(PASS_THROUGH_NAMESPACE,""String_Node_Str"");
      if (""String_Node_Str"".equals(tagAttribute.getValue())) {
        return convertElementToInputText(tag,modifiedAttributes);
      }
      if (""String_Node_Str"".equals(tagAttribute.getValue())) {
        return convertDivElementToPanelGroup(tag,modifiedAttributes,true);
      }
    }
    Tag newTag=relaxedDecorator.decorate(tag);
    if (newTag != null && newTag != tag) {
      return newTag;
    }
    if (""String_Node_Str"".equals(tag.getLocalName())) {
      return convertToInputText(tag,modifiedAttributes);
    }
    if (""String_Node_Str"".equals(tag.getLocalName())) {
      return convertDivTagToPanelGroup(tag,modifiedAttributes,true);
    }
    if (""String_Node_Str"".equals(tag.getLocalName())) {
      return convertDivTagToPanelGroup(tag,modifiedAttributes,false);
    }
    if (""String_Node_Str"".equals(tag.getLocalName())) {
      return convertTofSelectItemText(tag,modifiedAttributes);
    }
    tag=convertBootsFacesTag(tag);
  }
  return tag;
}","private Tag createTags(Tag tag){
  String ns=tag.getNamespace();
  if (HTML_NAMESPACE.equals(ns)) {
    active=true;
    TagAttributes modifiedAttributes=tag.getAttributes();
    if (""String_Node_Str"".equals(tag.getLocalName())) {
      TagAttribute tagAttribute=modifiedAttributes.get(PASS_THROUGH_NAMESPACE,""String_Node_Str"");
      if (""String_Node_Str"".equals(tagAttribute.getValue())) {
        return convertElementToInputTag(tag,modifiedAttributes);
      }
      if (""String_Node_Str"".equals(tagAttribute.getValue())) {
        return convertElementToSelectOneMenuTag(tag,modifiedAttributes);
      }
      if (""String_Node_Str"".equals(tagAttribute.getValue())) {
        return convertDivElementToPanelGroup(tag,modifiedAttributes,true);
      }
    }
    Tag newTag=relaxedDecorator.decorate(tag);
    if (newTag != null && newTag != tag) {
      return newTag;
    }
    if (""String_Node_Str"".equals(tag.getLocalName())) {
      return convertToInputTag(tag,modifiedAttributes);
    }
    if (""String_Node_Str"".equals(tag.getLocalName())) {
      return convertToSelectOneMenuTag(tag,modifiedAttributes);
    }
    if (""String_Node_Str"".equals(tag.getLocalName())) {
      return convertDivTagToPanelGroup(tag,modifiedAttributes,true);
    }
    if (""String_Node_Str"".equals(tag.getLocalName())) {
      return convertDivTagToPanelGroup(tag,modifiedAttributes,false);
    }
    if (""String_Node_Str"".equals(tag.getLocalName())) {
      return convertTofSelectItemText(tag,modifiedAttributes);
    }
    tag=convertBootsFacesTag(tag);
  }
  return tag;
}"
56964,"/** 
 * Converts &lt;option&gt;firstComboboxItem&lt;/option&gt; to &lt;f:selectItem itemValue=""firstComboxItem""&gt;.
 */
private Tag convertTofSelectItemText(Tag tag,TagAttributes attributeList){
  TagAttribute[] attributes=attributeList.getAll();
  AFTagAttributes more=new AFTagAttributes(attributes);
  Tag t=new Tag(tag.getLocation(),JSF_CORE_NAMESPACE,""String_Node_Str"",""String_Node_Str"",more);
  return t;
}","/** 
 * Converts &lt;option&gt;firstComboboxItem&lt;/option&gt; to &lt;f:selectItem itemValue=""firstComboxItem""&gt;.
 */
private Tag convertTofSelectItemText(Tag tag,TagAttributes attributeList){
  TagAttribute[] attributes=attributeList.getAll();
  AFTagAttributes more=new AFTagAttributes(attributes);
  more.replaceAttribute(""String_Node_Str"",""String_Node_Str"");
  more.replaceAttribute(""String_Node_Str"",""String_Node_Str"");
  Tag t=new Tag(tag.getLocation(),JSF_CORE_NAMESPACE,""String_Node_Str"",""String_Node_Str"",more);
  return t;
}"
56965,"/** 
 * This methods generates the HTML code of the current b:dataTable. <code>encodeBegin</code> generates the start of the component. After the, the JSF framework calls <code>encodeChildren()</code> to generate the HTML code between the beginning and the end of the component. For instance, in the case of a panel component the content of the panel is generated by <code>encodeChildren()</code>. After that, <code>encodeEnd()</code> is called to generate the rest of the HTML code.
 * @param context the FacesContext.
 * @param component the current b:dataTable.
 * @throws IOException thrown if something goes wrong when writing the HTML code.
 */
@Override public void encodeEnd(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  DataTable dataTable=(DataTable)component;
  Map<Integer,String> columnSortOrder=dataTable.getColumnSortOrderMap();
  int pageLength=dataTable.getPageLength();
  String orderString=""String_Node_Str"";
  if (columnSortOrder != null) {
    StringBuilder sb=new StringBuilder();
    int i=0;
    for (    Map.Entry<Integer,String> entry : columnSortOrder.entrySet()) {
      String separator=(i > 0) ? ""String_Node_Str"" : ""String_Node_Str"";
      sb.append(separator).append(""String_Node_Str"").append(entry.getKey()).append(""String_Node_Str"").append(""String_Node_Str"").append(entry.getValue()).append(""String_Node_Str"").append(""String_Node_Str"");
      i++;
    }
    orderString=sb.toString();
  }
  ResponseWriter rw=context.getResponseWriter();
  String clientIdRaw=dataTable.getClientId();
  String clientId=clientIdRaw.replace(""String_Node_Str"",""String_Node_Str"");
  String widgetVar=dataTable.getWidgetVar();
  if (null == widgetVar) {
    widgetVar=clientId + ""String_Node_Str"";
  }
  String lang=determineLanguage(context,dataTable);
  rw.endElement(""String_Node_Str"");
  String responsiveStyle=Responsive.getResponsiveStyleClass(dataTable,false);
  if (null != responsiveStyle && responsiveStyle.trim().length() > 0) {
    rw.endElement(""String_Node_Str"");
  }
  Tooltip.activateTooltips(context,dataTable);
  rw.startElement(""String_Node_Str"",component);
  rw.writeText(""String_Node_Str"",null);
  rw.writeText(widgetVar + ""String_Node_Str"" + clientId+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ clientIdRaw.replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ widgetVar+ ""String_Node_Str""+ ""String_Node_Str""+ widgetVar+ ""String_Node_Str""+ ""String_Node_Str""+ dataTable.isFixedHeader()+ ""String_Node_Str""+ ""String_Node_Str""+ dataTable.isResponsive()+ ""String_Node_Str""+ ""String_Node_Str""+ dataTable.isPaginated()+ ""String_Node_Str""+ ""String_Node_Str""+ pageLength+ ""String_Node_Str""+ ""String_Node_Str""+ getPageLengthMenu(dataTable)+ ""String_Node_Str""+ ""String_Node_Str""+ dataTable.isSearching()+ ""String_Node_Str""+ ""String_Node_Str""+ orderString+ ""String_Node_Str""+ ""String_Node_Str""+ dataTable.isSaveState()+ ""String_Node_Str""+ ""String_Node_Str""+ generateScrollOptions(dataTable)+ (BsfUtils.isStringValued(lang) ? ""String_Node_Str"" + lang + ""String_Node_Str"" : ""String_Node_Str"")+ generateColumnInfos(dataTable.getColumnInfo())+ ""String_Node_Str"",null);
  if (dataTable.isMultiColumnSearch()) {
    rw.writeText(""String_Node_Str"" + widgetVar + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
    rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + widgetVar + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
  }
  rw.writeText(""String_Node_Str"",null);
  rw.endElement(""String_Node_Str"");
}","/** 
 * This methods generates the HTML code of the current b:dataTable. <code>encodeBegin</code> generates the start of the component. After the, the JSF framework calls <code>encodeChildren()</code> to generate the HTML code between the beginning and the end of the component. For instance, in the case of a panel component the content of the panel is generated by <code>encodeChildren()</code>. After that, <code>encodeEnd()</code> is called to generate the rest of the HTML code.
 * @param context the FacesContext.
 * @param component the current b:dataTable.
 * @throws IOException thrown if something goes wrong when writing the HTML code.
 */
@Override public void encodeEnd(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  DataTable dataTable=(DataTable)component;
  Map<Integer,String> columnSortOrder=dataTable.getColumnSortOrderMap();
  int pageLength=dataTable.getPageLength();
  String orderString=""String_Node_Str"";
  if (columnSortOrder != null) {
    StringBuilder sb=new StringBuilder();
    int i=0;
    for (    Map.Entry<Integer,String> entry : columnSortOrder.entrySet()) {
      String separator=(i > 0) ? ""String_Node_Str"" : ""String_Node_Str"";
      sb.append(separator).append(""String_Node_Str"").append(entry.getKey()).append(""String_Node_Str"").append(""String_Node_Str"").append(entry.getValue()).append(""String_Node_Str"").append(""String_Node_Str"");
      i++;
    }
    orderString=sb.toString();
  }
  ResponseWriter rw=context.getResponseWriter();
  String clientIdRaw=dataTable.getClientId();
  String clientId=clientIdRaw.replace(""String_Node_Str"",""String_Node_Str"");
  String widgetVar=dataTable.getWidgetVar();
  if (null == widgetVar) {
    widgetVar=clientId + ""String_Node_Str"";
  }
  String lang=determineLanguage(context,dataTable);
  rw.endElement(""String_Node_Str"");
  String responsiveStyle=Responsive.getResponsiveStyleClass(dataTable,false);
  if (null != responsiveStyle && responsiveStyle.trim().length() > 0) {
    rw.endElement(""String_Node_Str"");
  }
  Tooltip.activateTooltips(context,dataTable);
  rw.startElement(""String_Node_Str"",component);
  rw.writeText(""String_Node_Str"",null);
  String options=""String_Node_Str"";
  options=addOptions(""String_Node_Str"" + dataTable.isFixedHeader(),options);
  options=addOptions(""String_Node_Str"" + dataTable.isResponsive(),options);
  options=addOptions(""String_Node_Str"" + dataTable.isPaginated(),options);
  options=addOptions(""String_Node_Str"" + pageLength,options);
  options=addOptions(""String_Node_Str"" + getPageLengthMenu(dataTable),options);
  options=addOptions(""String_Node_Str"" + dataTable.isSearching(),options);
  options=addOptions(""String_Node_Str"" + orderString,options);
  options=addOptions(""String_Node_Str"" + dataTable.isSaveState(),options);
  options=addOptions(""String_Node_Str"",options);
  options=addOptions(generateScrollOptions(dataTable),options);
  options=addOptions((BsfUtils.isStringValued(lang) ? ""String_Node_Str"" + lang + ""String_Node_Str"" : null),options);
  options=addOptions(generateColumnInfos(dataTable.getColumnInfo()),options);
  options=addOptions(dataTable.getCustomOptions(),options);
  rw.writeText(widgetVar + ""String_Node_Str"" + clientId+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ clientIdRaw.replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ widgetVar+ ""String_Node_Str""+ ""String_Node_Str""+ widgetVar+ ""String_Node_Str""+ options+ ""String_Node_Str"",null);
  if (dataTable.isMultiColumnSearch()) {
    rw.writeText(""String_Node_Str"" + widgetVar + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
    rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + widgetVar + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
  }
  rw.writeText(""String_Node_Str"",null);
  rw.endElement(""String_Node_Str"");
}"
56966,"private void generateHeader(FacesContext context,DataTable dataTable,ResponseWriter rw) throws IOException {
  rw.startElement(""String_Node_Str"",dataTable);
  rw.startElement(""String_Node_Str"",dataTable);
  int index=0;
  List<UIComponent> columns=dataTable.getChildren();
  for (  UIComponent column : columns) {
    if (!column.isRendered()) {
      continue;
    }
    rw.startElement(""String_Node_Str"",dataTable);
    Object headerStyle=column.getAttributes().get(""String_Node_Str"");
    if (headerStyle != null) {
      rw.writeAttribute(""String_Node_Str"",headerStyle,null);
    }
    Object headerStyleClass=column.getAttributes().get(""String_Node_Str"");
    if (headerStyleClass != null) {
      rw.writeAttribute(""String_Node_Str"",headerStyleClass,null);
    }
    if (column.getFacet(""String_Node_Str"") != null) {
      UIComponent facet=column.getFacet(""String_Node_Str"");
      facet.encodeAll(context);
    }
 else     if (column.getAttributes().get(""String_Node_Str"") != null) {
      rw.writeText(column.getAttributes().get(""String_Node_Str""),null);
    }
 else {
      boolean labelHasBeenRendered=false;
      for (      UIComponent c : column.getChildren()) {
        if (c.getAttributes().get(""String_Node_Str"") != null) {
          rw.writeText(c.getAttributes().get(""String_Node_Str""),null);
          labelHasBeenRendered=true;
          break;
        }
      }
      if (!labelHasBeenRendered) {
        for (        UIComponent c : column.getChildren()) {
          if (c.getAttributes().get(""String_Node_Str"") != null) {
            rw.writeText(c.getAttributes().get(""String_Node_Str""),null);
            labelHasBeenRendered=true;
            break;
          }
        }
      }
      if (!labelHasBeenRendered) {
        ValueExpression ve=column.getValueExpression(""String_Node_Str"");
        if (null != ve) {
          String exp=ve.getExpressionString();
          int pos=exp.lastIndexOf('.');
          if (pos > 0) {
            exp=exp.substring(pos + 1);
          }
          exp=exp.substring(0,1).toUpperCase() + exp.substring(1);
          rw.writeText(exp.substring(0,exp.length() - 1),null);
          labelHasBeenRendered=true;
        }
      }
      if (!labelHasBeenRendered) {
        rw.writeText(""String_Node_Str"" + index,null);
      }
    }
    String order=null;
    if (column.getFacet(""String_Node_Str"") != null) {
      UIComponent facet=column.getFacet(""String_Node_Str"");
      order=facet.toString();
    }
 else     if (column.getAttributes().get(""String_Node_Str"") != null) {
      order=(String)column.getAttributes().get(""String_Node_Str"");
    }
    if (null != order) {
      order=order.trim();
      if ((!""String_Node_Str"".equals(order)) && (!""String_Node_Str"".equals(order))) {
        throw new FacesException(""String_Node_Str"");
      }
      Map<Integer,String> columnSortOrder;
      if (dataTable.getColumnSortOrderMap() == null) {
        dataTable.initColumnSortOrderMap();
      }
      columnSortOrder=dataTable.getColumnSortOrderMap();
      columnSortOrder.put(index,order);
    }
    if (column.getAttributes().get(""String_Node_Str"") != null) {
      String orderBy=(String)column.getAttributes().get(""String_Node_Str"");
      if (dataTable.getColumnInfo() == null) {
        List<String> infos=new ArrayList<String>(dataTable.getChildren().size());
        for (int k=0; k < dataTable.getChildren().size(); k++) {
          infos.add(null);
        }
        dataTable.setColumnInfo(infos);
      }
      List<String> infos=dataTable.getColumnInfo();
      String s=infos.get(index);
      if (s == null) {
        infos.set(index,""String_Node_Str"" + orderBy + ""String_Node_Str"");
      }
 else {
        infos.set(index,s + ""String_Node_Str"" + orderBy+ ""String_Node_Str"");
      }
    }
    if (column.getAttributes().get(""String_Node_Str"") != null) {
      String type=(String)column.getAttributes().get(""String_Node_Str"");
      if (dataTable.getColumnInfo() == null) {
        List<String> infos=new ArrayList<String>(dataTable.getChildren().size());
        for (int k=0; k < dataTable.getChildren().size(); k++) {
          infos.add(null);
        }
        dataTable.setColumnInfo(infos);
      }
      List<String> infos=dataTable.getColumnInfo();
      String s=infos.get(index);
      if (s == null) {
        infos.set(index,""String_Node_Str"" + type + ""String_Node_Str"");
      }
 else       infos.set(index,s + ""String_Node_Str"" + type+ ""String_Node_Str"");
    }
    if (column.getAttributes().get(""String_Node_Str"") != null) {
      String orderable=column.getAttributes().get(""String_Node_Str"").toString();
      if (""String_Node_Str"".equalsIgnoreCase(orderable)) {
        if (dataTable.getColumnInfo() == null) {
          List<String> infos=new ArrayList<String>(dataTable.getChildren().size());
          for (int k=0; k < dataTable.getChildren().size(); k++) {
            infos.add(null);
          }
          dataTable.setColumnInfo(infos);
        }
        List<String> infos=dataTable.getColumnInfo();
        String s=infos.get(index);
        if (s == null) {
          infos.set(index,""String_Node_Str"");
        }
 else         infos.set(index,s + ""String_Node_Str"");
      }
    }
    rw.endElement(""String_Node_Str"");
    index++;
  }
  rw.endElement(""String_Node_Str"");
  if (false) {
  }
  rw.endElement(""String_Node_Str"");
}","private void generateHeader(FacesContext context,DataTable dataTable,ResponseWriter rw) throws IOException {
  rw.startElement(""String_Node_Str"",dataTable);
  rw.startElement(""String_Node_Str"",dataTable);
  int index=0;
  List<UIComponent> columns=dataTable.getChildren();
  for (  UIComponent column : columns) {
    if (!column.isRendered()) {
      continue;
    }
    rw.startElement(""String_Node_Str"",dataTable);
    Object headerStyle=column.getAttributes().get(""String_Node_Str"");
    if (headerStyle != null) {
      rw.writeAttribute(""String_Node_Str"",headerStyle,null);
    }
    Object headerStyleClass=column.getAttributes().get(""String_Node_Str"");
    if (headerStyleClass != null) {
      rw.writeAttribute(""String_Node_Str"",headerStyleClass,null);
    }
    if (column.getFacet(""String_Node_Str"") != null) {
      UIComponent facet=column.getFacet(""String_Node_Str"");
      facet.encodeAll(context);
    }
 else     if (column.getAttributes().get(""String_Node_Str"") != null) {
      rw.writeText(column.getAttributes().get(""String_Node_Str""),null);
    }
 else {
      boolean labelHasBeenRendered=false;
      for (      UIComponent c : column.getChildren()) {
        if (c.getAttributes().get(""String_Node_Str"") != null) {
          rw.writeText(c.getAttributes().get(""String_Node_Str""),null);
          labelHasBeenRendered=true;
          break;
        }
      }
      if (!labelHasBeenRendered) {
        for (        UIComponent c : column.getChildren()) {
          if (c.getAttributes().get(""String_Node_Str"") != null) {
            rw.writeText(c.getAttributes().get(""String_Node_Str""),null);
            labelHasBeenRendered=true;
            break;
          }
        }
      }
      if (!labelHasBeenRendered) {
        ValueExpression ve=column.getValueExpression(""String_Node_Str"");
        if (null != ve) {
          String exp=ve.getExpressionString();
          int pos=exp.lastIndexOf('.');
          if (pos > 0) {
            exp=exp.substring(pos + 1);
          }
          exp=exp.substring(0,1).toUpperCase() + exp.substring(1);
          rw.writeText(exp.substring(0,exp.length() - 1),null);
          labelHasBeenRendered=true;
        }
      }
      if (!labelHasBeenRendered) {
        rw.writeText(""String_Node_Str"" + index,null);
      }
    }
    String order=null;
    if (column.getFacet(""String_Node_Str"") != null) {
      UIComponent facet=column.getFacet(""String_Node_Str"");
      order=facet.toString();
    }
 else     if (column.getAttributes().get(""String_Node_Str"") != null) {
      order=(String)column.getAttributes().get(""String_Node_Str"");
    }
    if (null != order) {
      order=order.trim();
      if ((!""String_Node_Str"".equals(order)) && (!""String_Node_Str"".equals(order))) {
        throw new FacesException(""String_Node_Str"");
      }
      Map<Integer,String> columnSortOrder;
      if (dataTable.getColumnSortOrderMap() == null) {
        dataTable.initColumnSortOrderMap();
      }
      columnSortOrder=dataTable.getColumnSortOrderMap();
      columnSortOrder.put(index,order);
    }
    if (column.getAttributes().get(""String_Node_Str"") != null) {
      String orderBy=(String)column.getAttributes().get(""String_Node_Str"");
      if (dataTable.getColumnInfo() == null) {
        List<String> infos=new ArrayList<String>(dataTable.getChildren().size());
        for (int k=0; k < dataTable.getChildren().size(); k++) {
          infos.add(null);
        }
        dataTable.setColumnInfo(infos);
      }
      List<String> infos=dataTable.getColumnInfo();
      String s=infos.get(index);
      if (s == null) {
        infos.set(index,""String_Node_Str"" + orderBy + ""String_Node_Str"");
      }
 else {
        infos.set(index,s + ""String_Node_Str"" + orderBy+ ""String_Node_Str"");
      }
    }
    if (column.getAttributes().get(""String_Node_Str"") != null) {
      String type=(String)column.getAttributes().get(""String_Node_Str"");
      if (dataTable.getColumnInfo() == null) {
        List<String> infos=new ArrayList<String>(dataTable.getChildren().size());
        for (int k=0; k < dataTable.getChildren().size(); k++) {
          infos.add(null);
        }
        dataTable.setColumnInfo(infos);
      }
      List<String> infos=dataTable.getColumnInfo();
      String s=infos.get(index);
      if (s == null) {
        infos.set(index,""String_Node_Str"" + type + ""String_Node_Str"");
      }
 else       infos.set(index,s + ""String_Node_Str"" + type+ ""String_Node_Str"");
    }
    if (column.getAttributes().get(""String_Node_Str"") != null) {
      String orderable=column.getAttributes().get(""String_Node_Str"").toString();
      if (""String_Node_Str"".equalsIgnoreCase(orderable)) {
        if (dataTable.getColumnInfo() == null) {
          List<String> infos=new ArrayList<String>(dataTable.getChildren().size());
          for (int k=0; k < dataTable.getChildren().size(); k++) {
            infos.add(null);
          }
          dataTable.setColumnInfo(infos);
        }
        List<String> infos=dataTable.getColumnInfo();
        String s=infos.get(index);
        if (s == null) {
          infos.set(index,""String_Node_Str"");
        }
 else         infos.set(index,s + ""String_Node_Str"");
      }
    }
    if (column.getAttributes().get(""String_Node_Str"") != null) {
      String customOptions=column.getAttributes().get(""String_Node_Str"").toString();
      if (customOptions != null && customOptions.length() > 0) {
        if (dataTable.getColumnInfo() == null) {
          List<String> infos=new ArrayList<String>(dataTable.getChildren().size());
          for (int k=0; k < dataTable.getChildren().size(); k++) {
            infos.add(null);
          }
          dataTable.setColumnInfo(infos);
        }
        List<String> infos=dataTable.getColumnInfo();
        String s=infos.get(index);
        if (s == null) {
          infos.set(index,customOptions);
        }
 else         infos.set(index,s + ""String_Node_Str"" + customOptions);
      }
    }
    rw.endElement(""String_Node_Str"");
    index++;
  }
  rw.endElement(""String_Node_Str"");
  if (false) {
  }
  rw.endElement(""String_Node_Str"");
}"
56967,"private String generateScrollOptions(DataTable dataTable){
  String scrollY=dataTable.getScrollSize();
  boolean scrollX=dataTable.isScrollX();
  if (null == scrollY && (!scrollX)) {
    return ""String_Node_Str"";
  }
  String result=""String_Node_Str"";
  if (null != scrollY) {
    if (!NUMERIC_PATTERN.matcher(scrollY).matches()) {
      scrollY=""String_Node_Str"" + scrollY + ""String_Node_Str"";
    }
    result+=""String_Node_Str"" + scrollY + ""String_Node_Str"";
  }
  if (scrollX) {
    result+=""String_Node_Str"";
  }
  return result + ""String_Node_Str"" + dataTable.isScrollCollapse()+ ""String_Node_Str"";
}","private String generateScrollOptions(DataTable dataTable){
  String scrollY=dataTable.getScrollSize();
  boolean scrollX=dataTable.isScrollX();
  if (null == scrollY && (!scrollX)) {
    return ""String_Node_Str"";
  }
  String result=""String_Node_Str"";
  if (null != scrollY) {
    if (!NUMERIC_PATTERN.matcher(scrollY).matches()) {
      scrollY=""String_Node_Str"" + scrollY + ""String_Node_Str"";
    }
    result+=""String_Node_Str"" + scrollY + ""String_Node_Str"";
  }
  if (scrollX) {
    result+=""String_Node_Str"";
  }
  return result + ""String_Node_Str"" + dataTable.isScrollCollapse();
}"
56968,"public Modal(){
  AddResourcesListener.addThemedCSSResource(""String_Node_Str"");
  AddResourcesListener.addThemedCSSResource(""String_Node_Str"");
  setRendererType(DEFAULT_RENDERER);
}","public Modal(){
  AddResourcesListener.addThemedCSSResource(""String_Node_Str"");
  AddResourcesListener.addThemedCSSResource(""String_Node_Str"");
  AddResourcesListener.addThemedCSSResource(""String_Node_Str"");
  setRendererType(DEFAULT_RENDERER);
}"
56969,"/** 
 * This methods generates the HTML code of the current b:modal. <code>encodeBegin</code> generates the start of the component. After the, the JSF framework calls <code>encodeChildren()</code> to generate the HTML code between the beginning and the end of the component. For instance, in the case of a panel component the content of the panel is generated by <code>encodeChildren()</code>. After that, <code>encodeEnd()</code> is called to generate the rest of the HTML code.
 * @param context the FacesContext.
 * @param component the current b:modal.
 * @throws IOException thrown if something goes wrong when writing the HTML code.
 */
@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  ResponseWriter rw=context.getResponseWriter();
  Modal modal=(Modal)component;
  String title=modal.getTitle();
  rw.startElement(""String_Node_Str"",component);
  rw.writeAttribute(""String_Node_Str"",component.getClientId(context),""String_Node_Str"");
  String styleClasses=""String_Node_Str"";
  if (modal.getStyleClass() != null) {
    styleClasses=modal.getStyleClass() + ""String_Node_Str"" + styleClasses;
  }
  if (!modal.isBackdrop()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  if (!modal.isCloseOnEscape()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  rw.writeAttribute(""String_Node_Str"",styleClasses,""String_Node_Str"");
  if (modal.getStyle() != null) {
    rw.writeAttribute(""String_Node_Str"",modal.getStyle(),""String_Node_Str"");
  }
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  rw.writeAttribute(""String_Node_Str"",component.getClientId(context) + ""String_Node_Str"",null);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  rw.startElement(""String_Node_Str"",component);
  String modalStyleClass=""String_Node_Str"" + ""String_Node_Str"";
  if (modal.getSize() != null) {
    modalStyleClass=modalStyleClass + ""String_Node_Str"" + modal.getSize();
  }
  rw.writeAttribute(""String_Node_Str"",modalStyleClass,""String_Node_Str"");
  rw.startElement(""String_Node_Str"",component);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  rw.startElement(""String_Node_Str"",component);
  String headerStyleClasses=""String_Node_Str"";
  if (modal.getHeaderClass() != null) {
    headerStyleClasses+=""String_Node_Str"" + modal.getHeaderClass();
  }
  rw.writeAttribute(""String_Node_Str"",headerStyleClasses,""String_Node_Str"");
  String headerStyle=""String_Node_Str"";
  if (modal.getHeaderStyle() != null) {
    headerStyle+=""String_Node_Str"" + modal.getHeaderStyle();
  }
  rw.writeAttribute(""String_Node_Str"",headerStyle,""String_Node_Str"");
  if (modal.isClosable()) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    rw.write(""String_Node_Str"");
    rw.endElement(""String_Node_Str"");
  }
  if (title != null) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",component.getClientId(context) + ""String_Node_Str"",""String_Node_Str"");
    rw.writeText(title,null);
    rw.endElement(""String_Node_Str"");
  }
  rw.endElement(""String_Node_Str"");
  rw.startElement(""String_Node_Str"",component);
  if (modal.getContentClass() != null) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + modal.getContentClass(),""String_Node_Str"");
  }
 else {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (modal.getContentStyle() != null) {
    rw.writeAttribute(""String_Node_Str"",modal.getContentStyle(),""String_Node_Str"");
  }
}","/** 
 * This methods generates the HTML code of the current b:modal. <code>encodeBegin</code> generates the start of the component. After the, the JSF framework calls <code>encodeChildren()</code> to generate the HTML code between the beginning and the end of the component. For instance, in the case of a panel component the content of the panel is generated by <code>encodeChildren()</code>. After that, <code>encodeEnd()</code> is called to generate the rest of the HTML code.
 * @param context the FacesContext.
 * @param component the current b:modal.
 * @throws IOException thrown if something goes wrong when writing the HTML code.
 */
@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  ResponseWriter rw=context.getResponseWriter();
  Modal modal=(Modal)component;
  String title=modal.getTitle();
  rw.startElement(""String_Node_Str"",component);
  rw.writeAttribute(""String_Node_Str"",component.getClientId(context),""String_Node_Str"");
  String styleClasses=""String_Node_Str"";
  if (modal.getStyleClass() != null) {
    styleClasses=modal.getStyleClass() + ""String_Node_Str"" + styleClasses;
  }
  if (!modal.isBackdrop()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  if (!modal.isCloseOnEscape()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  rw.writeAttribute(""String_Node_Str"",styleClasses,""String_Node_Str"");
  if (modal.getStyle() != null) {
    rw.writeAttribute(""String_Node_Str"",modal.getStyle(),""String_Node_Str"");
  }
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  rw.writeAttribute(""String_Node_Str"",component.getClientId(context) + ""String_Node_Str"",null);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  rw.startElement(""String_Node_Str"",component);
  String modalStyleClass=""String_Node_Str"" + ""String_Node_Str"";
  if (modal.getSize() != null) {
    modalStyleClass=modalStyleClass + ""String_Node_Str"" + modal.getSize();
  }
  rw.writeAttribute(""String_Node_Str"",modalStyleClass,""String_Node_Str"");
  rw.startElement(""String_Node_Str"",component);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  rw.startElement(""String_Node_Str"",component);
  String headerStyleClasses=""String_Node_Str"";
  if (modal.getHeaderClass() != null) {
    headerStyleClasses+=""String_Node_Str"" + modal.getHeaderClass();
  }
  rw.writeAttribute(""String_Node_Str"",headerStyleClasses,""String_Node_Str"");
  if (modal.getHeaderStyle() != null) {
    rw.writeAttribute(""String_Node_Str"",modal.getHeaderStyle(),""String_Node_Str"");
  }
  if (modal.isClosable()) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    rw.write(""String_Node_Str"");
    rw.endElement(""String_Node_Str"");
  }
  if (title != null) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",component.getClientId(context) + ""String_Node_Str"",""String_Node_Str"");
    rw.writeText(title,null);
    rw.endElement(""String_Node_Str"");
  }
  rw.endElement(""String_Node_Str"");
  rw.startElement(""String_Node_Str"",component);
  if (modal.getContentClass() != null) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + modal.getContentClass(),""String_Node_Str"");
  }
 else {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (modal.getContentStyle() != null) {
    rw.writeAttribute(""String_Node_Str"",modal.getContentStyle(),""String_Node_Str"");
  }
}"
56970,"/** 
 * Get the style class
 * @param sb
 * @return
 */
private String getStyleClass(SocialButton sb){
  String sClass=sb.getStyleClass();
  if (sClass == null)   sClass=""String_Node_Str"";
  sClass+=""String_Node_Str"";
  if (sb.isOnlyIcon())   sClass+=""String_Node_Str"";
  sClass+=(""String_Node_Str"" + sb.getSocial());
  sClass+=Responsive.getResponsiveStyleClass(sb,false);
  return sClass;
}","/** 
 * Get the style class
 * @param sb
 * @return
 */
private String getStyleClass(SocialButton sb){
  String sClass=sb.getStyleClass();
  if (sClass == null)   sClass=""String_Node_Str"";
  sClass+=""String_Node_Str"";
  if (sb.isIconOnly())   sClass+=""String_Node_Str"";
  sClass+=(""String_Node_Str"" + sb.getSocial());
  sClass+=Responsive.getResponsiveStyleClass(sb,false);
  return sClass;
}"
56971,"/** 
 * This methods generates the HTML code of the current b:socialButton.
 * @param context the FacesContext.
 * @param component the current b:socialButton.
 * @throws IOException thrown if something goes wrong when writing the HTML code.
 */
@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  SocialButton socialButton=(SocialButton)component;
  ResponseWriter rw=context.getResponseWriter();
  String clientId=socialButton.getClientId();
  rw.startElement(""String_Node_Str"",socialButton);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  rw.writeAttribute(""String_Node_Str"",clientId,""String_Node_Str"");
  if (BsfUtils.isStringValued(socialButton.getHref()))   rw.writeAttribute(""String_Node_Str"",socialButton.getHref(),""String_Node_Str"");
  if (BsfUtils.isStringValued(socialButton.getStyle()))   rw.writeAttribute(""String_Node_Str"",socialButton.getStyle(),""String_Node_Str"");
  rw.writeAttribute(""String_Node_Str"",getStyleClass(socialButton),""String_Node_Str"");
  Tooltip.generateTooltip(context,socialButton,rw);
  IconRenderer.encodeIcon(rw,socialButton,socialButton.getSocial(),true);
  if (!socialButton.isOnlyIcon() && BsfUtils.isStringValued(socialButton.getValue())) {
    rw.writeText(socialButton.getValue(),null);
  }
  rw.endElement(""String_Node_Str"");
  Tooltip.activateTooltips(context,socialButton);
}","/** 
 * This methods generates the HTML code of the current b:socialButton.
 * @param context the FacesContext.
 * @param component the current b:socialButton.
 * @throws IOException thrown if something goes wrong when writing the HTML code.
 */
@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  SocialButton socialButton=(SocialButton)component;
  ResponseWriter rw=context.getResponseWriter();
  String clientId=socialButton.getClientId();
  rw.startElement(""String_Node_Str"",socialButton);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  rw.writeAttribute(""String_Node_Str"",clientId,""String_Node_Str"");
  if (BsfUtils.isStringValued(socialButton.getHref()))   rw.writeAttribute(""String_Node_Str"",socialButton.getHref(),""String_Node_Str"");
  if (BsfUtils.isStringValued(socialButton.getStyle()))   rw.writeAttribute(""String_Node_Str"",socialButton.getStyle(),""String_Node_Str"");
  rw.writeAttribute(""String_Node_Str"",getStyleClass(socialButton),""String_Node_Str"");
  Tooltip.generateTooltip(context,socialButton,rw);
  IconRenderer.encodeIcon(rw,socialButton,socialButton.getSocial(),true);
  if (!socialButton.isIconOnly() && BsfUtils.isStringValued(socialButton.getValue())) {
    rw.writeText(socialButton.getValue(),null);
  }
  rw.endElement(""String_Node_Str"");
  Tooltip.activateTooltips(context,socialButton);
}"
56972,"public void encodeHeader(FacesContext context,String h,UIComponent navlink) throws IOException {
  ResponseWriter rw=context.getResponseWriter();
  String htmlTag=""String_Node_Str"";
  UIComponent parent=navlink.getParent();
  if (parent != null) {
    if (parent instanceof DropButton || parent instanceof NavBar || parent instanceof TabLinks|| parent instanceof PillLinks|| parent instanceof ListLinks|| parent instanceof NavBarLinks|| parent instanceof DropMenu) {
      htmlTag=""String_Node_Str"";
    }
  }
  rw.startElement(htmlTag,navlink);
  writeAttribute(rw,""String_Node_Str"",navlink.getClientId(context),""String_Node_Str"");
  String styleClass=((AbstractNavLink)navlink).getStyleClass();
  if (null == styleClass) {
    styleClass=""String_Node_Str"";
  }
  styleClass=""String_Node_Str"" + styleClass + ""String_Node_Str""+ Responsive.getResponsiveStyleClass((AbstractNavLink)navlink,false);
  writeAttribute(rw,""String_Node_Str"",styleClass,""String_Node_Str"");
  writeAttribute(rw,""String_Node_Str"",((AbstractNavLink)navlink).getStyle(),""String_Node_Str"");
  writeAttribute(rw,""String_Node_Str"",""String_Node_Str"",null);
  rw.writeText(h,null);
  rw.endElement(htmlTag);
}","public void encodeHeader(FacesContext context,String h,UIComponent navlink) throws IOException {
  ResponseWriter rw=context.getResponseWriter();
  String htmlTag=""String_Node_Str"";
  UIComponent parent=navlink.getParent();
  if (parent != null) {
    if (parent instanceof DropButton || parent instanceof NavBar || parent instanceof TabLinks|| parent instanceof PillLinks|| parent instanceof ListLinks|| parent instanceof NavBarLinks|| parent instanceof DropMenu|| parent instanceof FlyOutMenu) {
      htmlTag=""String_Node_Str"";
    }
  }
  rw.startElement(htmlTag,navlink);
  writeAttribute(rw,""String_Node_Str"",navlink.getClientId(context),""String_Node_Str"");
  String styleClass=((AbstractNavLink)navlink).getStyleClass();
  if (null == styleClass) {
    styleClass=""String_Node_Str"";
  }
  styleClass=""String_Node_Str"" + styleClass + ""String_Node_Str""+ Responsive.getResponsiveStyleClass((AbstractNavLink)navlink,false);
  writeAttribute(rw,""String_Node_Str"",styleClass,""String_Node_Str"");
  writeAttribute(rw,""String_Node_Str"",((AbstractNavLink)navlink).getStyle(),""String_Node_Str"");
  writeAttribute(rw,""String_Node_Str"",""String_Node_Str"",null);
  rw.writeText(h,null);
  rw.endElement(htmlTag);
}"
56973,"/** 
 * Decode ajax behaviours specific to the components
 */
@Override public void decode(FacesContext context,UIComponent component){
  Tree tree=(Tree)component;
  super.decode(context,tree);
  final TreeNodeEventListener nodeSelectionListener=tree.getNodeSelectionListener();
  String params=context.getExternalContext().getRequestParameterMap().get(""String_Node_Str"");
  if (params != null && nodeSelectionListener != null) {
    if (params != null) {
      params=params.replace(""String_Node_Str"",""String_Node_Str"");
      String[] pair=params.split(""String_Node_Str"",2);
      String key=pair[0];
      String value=null;
      if (pair.length == 2) {
        value=pair[1];
      }
      if (value != null && !""String_Node_Str"".equals(value.trim())) {
        Node n=TreeModelUtils.mapDataToModel(value);
        TreeModelUtils.updateNodeById(tree.getValue(),n.getNodeId(),n);
        if (""String_Node_Str"".equals(key)) {
          Node n2=checkNodeIsSelected(tree.getValue(),tree);
          nodeSelectionListener.processValueChange(new TreeNodeSelectionEvent(n2,n));
        }
 else         if (""String_Node_Str"".equals(key)) {
          nodeSelectionListener.processValueChecked(new TreeNodeCheckedEvent(n,true));
        }
 else         if (""String_Node_Str"".equals(key)) {
          nodeSelectionListener.processValueUnchecked(new TreeNodeCheckedEvent(n,false));
        }
      }
    }
  }
}","/** 
 * Decode ajax behaviours specific to the components
 */
@Override public void decode(FacesContext context,UIComponent component){
  Tree tree=(Tree)component;
  super.decode(context,tree);
  final TreeNodeEventListener nodeSelectionListener=tree.getNodeSelectionListener();
  String params=context.getExternalContext().getRequestParameterMap().get(""String_Node_Str"");
  if (params != null) {
    params=params.replace(""String_Node_Str"",""String_Node_Str"");
    String[] pair=params.split(""String_Node_Str"",2);
    String key=pair[0];
    String value=null;
    if (pair.length == 2) {
      value=pair[1];
    }
    if (value != null && !""String_Node_Str"".equals(value.trim())) {
      Node n=TreeModelUtils.mapDataToModel(value);
      TreeModelUtils.updateNodeById(tree.getValue(),n.getNodeId(),n);
      if (nodeSelectionListener != null) {
        if (""String_Node_Str"".equals(key)) {
          Node n2=checkNodeIsSelected(tree.getValue(),tree);
          nodeSelectionListener.processValueChange(new TreeNodeSelectionEvent(n2,n));
        }
 else         if (""String_Node_Str"".equals(key)) {
          nodeSelectionListener.processValueChecked(new TreeNodeCheckedEvent(n,true));
        }
 else         if (""String_Node_Str"".equals(key)) {
          nodeSelectionListener.processValueUnchecked(new TreeNodeCheckedEvent(n,false));
        }
      }
    }
  }
}"
56974,"public void encodeHeader(FacesContext context,String h,UIComponent navlink) throws IOException {
  ResponseWriter rw=context.getResponseWriter();
  String htmlTag=""String_Node_Str"";
  UIComponent parent=navlink.getParent();
  if (parent != null) {
    if (parent instanceof DropButton || parent instanceof NavBar || parent instanceof TabLinks|| parent instanceof PillLinks|| parent instanceof ListLinks) {
      htmlTag=""String_Node_Str"";
    }
 else {
      System.out.println(parent.getClass().getName());
    }
  }
  rw.startElement(htmlTag,navlink);
  writeAttribute(rw,""String_Node_Str"",navlink.getClientId(context),""String_Node_Str"");
  String styleClass=((AbstractNavLink)navlink).getStyleClass();
  if (null == styleClass)   writeAttribute(rw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
 else   writeAttribute(rw,""String_Node_Str"",""String_Node_Str"" + styleClass,""String_Node_Str"");
  writeAttribute(rw,""String_Node_Str"",((AbstractNavLink)navlink).getStyle(),""String_Node_Str"");
  writeAttribute(rw,""String_Node_Str"",""String_Node_Str"",null);
  rw.writeText(h,null);
  rw.endElement(htmlTag);
}","public void encodeHeader(FacesContext context,String h,UIComponent navlink) throws IOException {
  ResponseWriter rw=context.getResponseWriter();
  String htmlTag=""String_Node_Str"";
  UIComponent parent=navlink.getParent();
  if (parent != null) {
    if (parent instanceof DropButton || parent instanceof NavBar || parent instanceof TabLinks|| parent instanceof PillLinks|| parent instanceof ListLinks|| parent instanceof NavBarLinks|| parent instanceof DropMenu) {
      htmlTag=""String_Node_Str"";
    }
  }
  rw.startElement(htmlTag,navlink);
  writeAttribute(rw,""String_Node_Str"",navlink.getClientId(context),""String_Node_Str"");
  String styleClass=((AbstractNavLink)navlink).getStyleClass();
  if (null == styleClass)   writeAttribute(rw,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
 else   writeAttribute(rw,""String_Node_Str"",""String_Node_Str"" + styleClass,""String_Node_Str"");
  writeAttribute(rw,""String_Node_Str"",((AbstractNavLink)navlink).getStyle(),""String_Node_Str"");
  writeAttribute(rw,""String_Node_Str"",""String_Node_Str"",null);
  rw.writeText(h,null);
  rw.endElement(htmlTag);
}"
56975,"public void encodeHTML(FacesContext context,UIComponent navlink) throws IOException {
  ResponseWriter rw=context.getResponseWriter();
  String value=(String)((AbstractNavLink)navlink).getValue();
  String htmlTag=""String_Node_Str"";
  UIComponent parent=navlink.getParent();
  if (parent != null) {
    if (parent instanceof DropButton || parent instanceof NavBar || parent instanceof TabLinks|| parent instanceof PillLinks|| parent instanceof ListLinks) {
      htmlTag=""String_Node_Str"";
    }
 else {
      System.out.println(parent.getClass().getName());
    }
  }
  rw.startElement(htmlTag,navlink);
  writeAttribute(rw,""String_Node_Str"",navlink.getClientId(context),""String_Node_Str"");
  Tooltip.generateTooltip(context,navlink,rw);
  AJAXRenderer.generateBootsFacesAJAXAndJavaScript(context,(ClientBehaviorHolder)navlink,rw);
  R.encodeHTML4DHTMLAttrs(rw,navlink.getAttributes(),H.ALLBUTTON);
  writeAttribute(rw,""String_Node_Str"",getStyleClasses(((AbstractNavLink)navlink)));
  writeAttribute(rw,""String_Node_Str"",((AbstractNavLink)navlink).getStyle());
  rw.startElement(""String_Node_Str"",navlink);
  writeAttribute(rw,""String_Node_Str"",((AbstractNavLink)navlink).getContentStyle(),""String_Node_Str"");
  writeAttribute(rw,""String_Node_Str"",((AbstractNavLink)navlink).getContentClass(),""String_Node_Str"");
  boolean hasActionExpression=false;
  if (navlink instanceof NavCommandLink)   if (((NavCommandLink)navlink).getActionExpression() != null)   hasActionExpression=true;
  if (((AbstractNavLink)navlink).getUpdate() == null && (!((AbstractNavLink)navlink).isAjax()) && (!hasActionExpression)) {
    String url=encodeHref(context,((AbstractNavLink)navlink));
    if (url == null) {
      if (FacesContext.getCurrentInstance().getApplication().getProjectStage().equals(ProjectStage.Development)) {
        writeAttribute(rw,""String_Node_Str"",""String_Node_Str"",null);
        writeAttribute(rw,""String_Node_Str"",FacesContext.getCurrentInstance().getApplication().getProjectStage() + ""String_Node_Str"" + ""String_Node_Str"",null);
      }
      url=""String_Node_Str"";
    }
    writeAttribute(rw,""String_Node_Str"",url,null);
  }
  writeAttribute(rw,""String_Node_Str"",""String_Node_Str"",null);
  writeAttribute(rw,""String_Node_Str"",""String_Node_Str"",null);
  String icon=((AbstractNavLink)navlink).getIcon();
  String faicon=((AbstractNavLink)navlink).getIconAwesome();
  boolean fa=false;
  if (faicon != null) {
    icon=faicon;
    fa=true;
  }
  if (icon != null) {
    Object ialign=((AbstractNavLink)navlink).getIconAlign();
    if (ialign != null && ialign.equals(""String_Node_Str"")) {
      if (value != null)       rw.writeText(value + ""String_Node_Str"",null);
      if (navlink.getChildCount() > 0) {
        for (        UIComponent c : navlink.getChildren()) {
          c.encodeAll(context);
        }
      }
      IconRenderer.encodeIcon(rw,navlink,icon,fa);
    }
 else {
      IconRenderer.encodeIcon(rw,navlink,icon,fa);
      if (navlink.getChildCount() > 0) {
        for (        UIComponent c : navlink.getChildren()) {
          c.encodeAll(context);
        }
      }
      if (value != null)       rw.writeText(""String_Node_Str"" + value,null);
    }
  }
 else {
    if (value != null)     rw.writeText(value,null);
    if (navlink.getChildCount() > 0) {
      for (      UIComponent c : navlink.getChildren()) {
        c.encodeAll(context);
      }
    }
  }
  rw.endElement(""String_Node_Str"");
  rw.endElement(htmlTag);
}","public void encodeHTML(FacesContext context,UIComponent navlink) throws IOException {
  ResponseWriter rw=context.getResponseWriter();
  String value=(String)((AbstractNavLink)navlink).getValue();
  String htmlTag=""String_Node_Str"";
  UIComponent parent=navlink.getParent();
  if (parent != null) {
    if (parent instanceof DropButton || parent instanceof NavBar || parent instanceof TabLinks|| parent instanceof PillLinks|| parent instanceof ListLinks|| parent instanceof NavBarLinks|| parent instanceof DropMenu) {
      htmlTag=""String_Node_Str"";
    }
  }
  rw.startElement(htmlTag,navlink);
  writeAttribute(rw,""String_Node_Str"",navlink.getClientId(context),""String_Node_Str"");
  Tooltip.generateTooltip(context,navlink,rw);
  AJAXRenderer.generateBootsFacesAJAXAndJavaScript(context,(ClientBehaviorHolder)navlink,rw);
  R.encodeHTML4DHTMLAttrs(rw,navlink.getAttributes(),H.ALLBUTTON);
  writeAttribute(rw,""String_Node_Str"",getStyleClasses(((AbstractNavLink)navlink)));
  writeAttribute(rw,""String_Node_Str"",((AbstractNavLink)navlink).getStyle());
  rw.startElement(""String_Node_Str"",navlink);
  writeAttribute(rw,""String_Node_Str"",((AbstractNavLink)navlink).getContentStyle(),""String_Node_Str"");
  writeAttribute(rw,""String_Node_Str"",((AbstractNavLink)navlink).getContentClass(),""String_Node_Str"");
  boolean hasActionExpression=false;
  if (navlink instanceof NavCommandLink)   if (((NavCommandLink)navlink).getActionExpression() != null)   hasActionExpression=true;
  if (((AbstractNavLink)navlink).getUpdate() == null && (!((AbstractNavLink)navlink).isAjax()) && (!hasActionExpression)) {
    String url=encodeHref(context,((AbstractNavLink)navlink));
    if (url == null) {
      if (FacesContext.getCurrentInstance().getApplication().getProjectStage().equals(ProjectStage.Development)) {
        writeAttribute(rw,""String_Node_Str"",""String_Node_Str"",null);
        writeAttribute(rw,""String_Node_Str"",FacesContext.getCurrentInstance().getApplication().getProjectStage() + ""String_Node_Str"" + ""String_Node_Str"",null);
      }
      url=""String_Node_Str"";
    }
    writeAttribute(rw,""String_Node_Str"",url,null);
  }
  writeAttribute(rw,""String_Node_Str"",""String_Node_Str"",null);
  writeAttribute(rw,""String_Node_Str"",""String_Node_Str"",null);
  String icon=((AbstractNavLink)navlink).getIcon();
  String faicon=((AbstractNavLink)navlink).getIconAwesome();
  boolean fa=false;
  if (faicon != null) {
    icon=faicon;
    fa=true;
  }
  if (icon != null) {
    Object ialign=((AbstractNavLink)navlink).getIconAlign();
    if (ialign != null && ialign.equals(""String_Node_Str"")) {
      if (value != null)       rw.writeText(value + ""String_Node_Str"",null);
      if (navlink.getChildCount() > 0) {
        for (        UIComponent c : navlink.getChildren()) {
          c.encodeAll(context);
        }
      }
      IconRenderer.encodeIcon(rw,navlink,icon,fa);
    }
 else {
      IconRenderer.encodeIcon(rw,navlink,icon,fa);
      if (navlink.getChildCount() > 0) {
        for (        UIComponent c : navlink.getChildren()) {
          c.encodeAll(context);
        }
      }
      if (value != null)       rw.writeText(""String_Node_Str"" + value,null);
    }
  }
 else {
    if (value != null)     rw.writeText(value,null);
    if (navlink.getChildCount() > 0) {
      for (      UIComponent c : navlink.getChildren()) {
        c.encodeAll(context);
      }
    }
  }
  rw.endElement(""String_Node_Str"");
  rw.endElement(htmlTag);
}"
56976,"/** 
 * Comma separated list of child panel id that need to render expanded. <P>
 * @return Returns the value of the attribute, or null, if it hasn't beenset by the JSF file.
 */
public String getExpandedPanels(){
  String value=(String)getStateHelper().eval(PropertyKeys.expandedPanels);
  return value;
}","/** 
 * Comma separated list of child panel id that need to render expanded. <P>
 * @return Returns the value of the attribute, or null, if it hasn't been set by the JSF file.
 */
public String getExpandedPanels(){
  return (String)getStateHelper().eval(PropertyKeys.expandedPanels);
}"
56977,"private String findHighestSeverityClass(List<FacesMessage> messageList,Message message){
  boolean hasFatal=false;
  boolean hasError=false;
  boolean hasWarning=false;
  for (  FacesMessage msg : messageList) {
    Severity severity=msg.getSeverity();
    if (msg.isRendered() && !message.isRedisplay()) {
      continue;
    }
    if (severity.equals(FacesMessage.SEVERITY_WARN))     hasWarning=true;
 else     if (severity.equals(FacesMessage.SEVERITY_ERROR))     hasError=true;
 else     if (severity.equals(FacesMessage.SEVERITY_FATAL))     hasFatal=true;
  }
  if (hasFatal)   return ""String_Node_Str"";
  if (hasError)   return ""String_Node_Str"";
  if (hasWarning)   return ""String_Node_Str"";
  return ""String_Node_Str"";
}","private String findHighestSeverityClass(List<FacesMessage> messageList,Message message){
  boolean hasFatal=false;
  boolean hasError=false;
  boolean hasWarning=false;
  for (  FacesMessage msg : messageList) {
    Severity severity=msg.getSeverity();
    if (msg.isRendered() && !message.isRedisplay()) {
      continue;
    }
    if (severity.equals(FacesMessage.SEVERITY_WARN))     hasWarning=true;
 else     if (severity.equals(FacesMessage.SEVERITY_ERROR))     hasError=true;
 else     if (severity.equals(FacesMessage.SEVERITY_FATAL))     hasFatal=true;
  }
  if (hasFatal)   return (""String_Node_Str"" + message.getFatalClass());
  if (hasError)   return (""String_Node_Str"" + message.getErrorClass());
  if (hasWarning)   return (""String_Node_Str"" + message.getWarnClass());
  return (""String_Node_Str"" + message.getInfoClass());
}"
56978,"/** 
 * This methods generates the HTML code of the current b:message.
 * @param context the FacesContext.
 * @param component the current b:message.
 * @throws IOException thrown if something goes wrong when writing the HTML code.
 */
@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  Message message=(Message)component;
  String forValue=message.getFor();
  if (null == forValue || forValue.length() == 0)   forValue=""String_Node_Str"";
  forValue=ExpressionResolver.getComponentIDs(context,message,forValue);
  List<FacesMessage> messageList=new ArrayList<FacesMessage>();
  Iterator<FacesMessage> messageIterator=FacesContext.getCurrentInstance().getMessages(forValue);
  while (messageIterator.hasNext()) {
    FacesMessage fm=messageIterator.next();
    messageList.add(fm);
  }
  ResponseWriter rw=context.getResponseWriter();
  String clientId=message.getClientId();
  if (null != messageList && (!messageList.isEmpty())) {
    rw.startElement(""String_Node_Str"",message);
    writeAttribute(rw,""String_Node_Str"",clientId);
    if (null != message.getDir()) {
      rw.writeAttribute(""String_Node_Str"",message.getDir(),""String_Node_Str"");
    }
    String styleClass=message.getStyleClass();
    if (null != styleClass && styleClass.length() > 0)     styleClass=styleClass + ""String_Node_Str"";
 else     styleClass=""String_Node_Str"";
    String severityClass=findHighestSeverityClass(messageList,message);
    styleClass+=""String_Node_Str"" + severityClass + ""String_Node_Str"";
    writeAttribute(rw,""String_Node_Str"",styleClass);
    writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
    boolean firstMessage=true;
    for (    FacesMessage msg : messageList) {
      if (!firstMessage) {
        if (message.isLineBreak()) {
          rw.append(message.getLineBreakTag());
        }
      }
      firstMessage=false;
      if (message.isShowIcon()) {
        rw.startElement(""String_Node_Str"",component);
        writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
        writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
        rw.endElement(""String_Node_Str"");
      }
      if (message.isShowSummary()) {
        if (msg.getSummary() != null && (!msg.getSummary().equals(msg.getDetail()))) {
          rw.startElement(""String_Node_Str"",component);
          writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
          if (message.isEscape()) {
            rw.writeText(msg.getSummary(),null);
          }
 else {
            warnOnFirstUse();
            rw.write(msg.getSummary());
          }
          rw.endElement(""String_Node_Str"");
        }
      }
      if (message.isShowDetail()) {
        rw.startElement(""String_Node_Str"",component);
        writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
        if (message.isEscape()) {
          rw.writeText(msg.getDetail(),null);
        }
 else {
          warnOnFirstUse();
          rw.write(msg.getDetail());
        }
        rw.endElement(""String_Node_Str"");
      }
    }
    rw.endElement(""String_Node_Str"");
  }
}","/** 
 * This methods generates the HTML code of the current b:message.
 * @param context the FacesContext.
 * @param component the current b:message.
 * @throws IOException thrown if something goes wrong when writing the HTML code.
 */
@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  Message message=(Message)component;
  String forValue=message.getFor();
  if (null == forValue || forValue.length() == 0)   forValue=""String_Node_Str"";
  forValue=ExpressionResolver.getComponentIDs(context,message,forValue);
  List<FacesMessage> messageList=new ArrayList<FacesMessage>();
  Iterator<FacesMessage> messageIterator=FacesContext.getCurrentInstance().getMessages(forValue);
  while (messageIterator.hasNext()) {
    FacesMessage fm=messageIterator.next();
    messageList.add(fm);
  }
  ResponseWriter rw=context.getResponseWriter();
  String clientId=message.getClientId();
  if (null != messageList && (!messageList.isEmpty())) {
    rw.startElement(""String_Node_Str"",message);
    writeAttribute(rw,""String_Node_Str"",clientId);
    if (null != message.getDir()) {
      rw.writeAttribute(""String_Node_Str"",message.getDir(),""String_Node_Str"");
    }
    String styleClass=message.getStyleClass();
    if (null != styleClass && styleClass.length() > 0)     styleClass=styleClass + ""String_Node_Str"";
 else     styleClass=""String_Node_Str"";
    String severityClass=findHighestSeverityClass(messageList,message);
    styleClass+=""String_Node_Str"" + severityClass + ""String_Node_Str"";
    writeAttribute(rw,""String_Node_Str"",styleClass);
    writeAttribute(rw,""String_Node_Str"",findHighestSeverityStyle(messageList,message));
    writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
    boolean firstMessage=true;
    for (    FacesMessage msg : messageList) {
      if (!firstMessage) {
        if (message.isLineBreak()) {
          rw.append(message.getLineBreakTag());
        }
      }
      firstMessage=false;
      if (message.isShowIcon()) {
        rw.startElement(""String_Node_Str"",component);
        writeAttribute(rw,""String_Node_Str"",findHighestSeverityIcon(messageList,message) + ""String_Node_Str"");
        writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
        rw.endElement(""String_Node_Str"");
      }
      if (message.isShowSummary()) {
        if (msg.getSummary() != null && (!msg.getSummary().equals(msg.getDetail()))) {
          rw.startElement(""String_Node_Str"",component);
          writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
          if (message.isEscape()) {
            rw.writeText(msg.getSummary(),null);
          }
 else {
            warnOnFirstUse();
            rw.write(msg.getSummary());
          }
          rw.endElement(""String_Node_Str"");
        }
      }
      if (message.isShowDetail()) {
        rw.startElement(""String_Node_Str"",component);
        writeAttribute(rw,""String_Node_Str"",""String_Node_Str"");
        if (message.isEscape()) {
          rw.writeText(msg.getDetail(),null);
        }
 else {
          warnOnFirstUse();
          rw.write(msg.getDetail());
        }
        rw.endElement(""String_Node_Str"");
      }
    }
    rw.endElement(""String_Node_Str"");
  }
}"
56979,"@Override public void encodeEnd(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  InputText inputText=(InputText)component;
  ResponseWriter rw=context.getResponseWriter();
  String clientId=inputText.getClientId();
  int span=inputText.getSpan();
  if (span > 0) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + span,""String_Node_Str"");
  }
  UIComponent prep=inputText.getFacet(""String_Node_Str"");
  UIComponent app=inputText.getFacet(""String_Node_Str"");
  boolean prepend=(prep != null);
  boolean append=(app != null);
  String label=inputText.getLabel();
{
    if (!inputText.isRenderLabel()) {
      label=null;
    }
  }
  String t;
  if (component instanceof InputSecret) {
    t=""String_Node_Str"";
  }
 else {
    t=inputText.getType();
    if (t == null)     t=""String_Node_Str"";
  }
  rw.startElement(""String_Node_Str"",component);
  if (null != inputText.getDir()) {
    rw.writeAttribute(""String_Node_Str"",inputText.getDir(),""String_Node_Str"");
  }
  Tooltip.generateTooltip(context,inputText,rw);
  rw.writeAttribute(""String_Node_Str"",clientId,""String_Node_Str"");
  if (inputText.isInline()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (label != null) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,""String_Node_Str"");
    generateErrorAndRequiredClass(inputText,rw,clientId);
    rw.writeText(label,null);
    rw.endElement(""String_Node_Str"");
  }
  if (append || prepend) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (prepend) {
    R.decorateFacetComponent(inputText,prep,context,rw);
  }
  rw.startElement(""String_Node_Str"",inputText);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,null);
  rw.writeAttribute(""String_Node_Str"",clientId,null);
  rw.writeAttribute(""String_Node_Str"",t,null);
  generateStyleClass(inputText,rw);
  String ph=inputText.getPlaceholder();
  if (ph != null) {
    rw.writeAttribute(""String_Node_Str"",ph,null);
  }
  if (inputText.isDisabled()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  if (inputText.isReadonly()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  renderPassThruAttributes(context,component,H.INPUT_TEXT);
  String autocomplete=inputText.getAutocomplete();
  if ((autocomplete != null) && (autocomplete.equals(""String_Node_Str""))) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  String v=getValue2Render(context,component);
  rw.writeAttribute(""String_Node_Str"",v,null);
  AJAXRenderer.generateBootsFacesAJAXAndJavaScript(FacesContext.getCurrentInstance(),inputText,rw);
  rw.endElement(""String_Node_Str"");
  if (append) {
    R.decorateFacetComponent(inputText,app,context,rw);
  }
  if (append || prepend) {
    rw.endElement(""String_Node_Str"");
  }
  rw.endElement(""String_Node_Str"");
  if (span > 0) {
    rw.endElement(""String_Node_Str"");
  }
  Tooltip.activateTooltips(context,inputText);
}","@Override public void encodeEnd(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  InputText inputText=(InputText)component;
  ResponseWriter rw=context.getResponseWriter();
  String clientId=inputText.getClientId();
  int span=inputText.getSpan();
  if (span > 0) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + span,""String_Node_Str"");
  }
  UIComponent prep=inputText.getFacet(""String_Node_Str"");
  UIComponent app=inputText.getFacet(""String_Node_Str"");
  boolean prepend=(prep != null);
  boolean append=(app != null);
  String label=inputText.getLabel();
{
    if (!inputText.isRenderLabel()) {
      label=null;
    }
  }
  String t;
  if (component instanceof InputSecret) {
    t=""String_Node_Str"";
  }
 else {
    t=inputText.getType();
    if (t == null)     t=""String_Node_Str"";
  }
  rw.startElement(""String_Node_Str"",component);
  if (null != inputText.getDir()) {
    rw.writeAttribute(""String_Node_Str"",inputText.getDir(),""String_Node_Str"");
  }
  Tooltip.generateTooltip(context,inputText,rw);
  rw.writeAttribute(""String_Node_Str"",clientId,""String_Node_Str"");
  if (inputText.isInline()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (label != null) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,""String_Node_Str"");
    generateErrorAndRequiredClass(inputText,rw,clientId);
    rw.writeText(label,null);
    rw.endElement(""String_Node_Str"");
  }
  if (append || prepend) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (prepend) {
    R.decorateFacetComponent(inputText,prep,context,rw);
  }
  rw.startElement(""String_Node_Str"",inputText);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,null);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,null);
  rw.writeAttribute(""String_Node_Str"",t,null);
  generateStyleClass(inputText,rw);
  String ph=inputText.getPlaceholder();
  if (ph != null) {
    rw.writeAttribute(""String_Node_Str"",ph,null);
  }
  if (inputText.isDisabled()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  if (inputText.isReadonly()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  renderPassThruAttributes(context,component,H.INPUT_TEXT);
  String autocomplete=inputText.getAutocomplete();
  if ((autocomplete != null) && (autocomplete.equals(""String_Node_Str""))) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  String v=getValue2Render(context,component);
  rw.writeAttribute(""String_Node_Str"",v,null);
  AJAXRenderer.generateBootsFacesAJAXAndJavaScript(FacesContext.getCurrentInstance(),inputText,rw);
  rw.endElement(""String_Node_Str"");
  if (append) {
    R.decorateFacetComponent(inputText,app,context,rw);
  }
  if (append || prepend) {
    rw.endElement(""String_Node_Str"");
  }
  rw.endElement(""String_Node_Str"");
  if (span > 0) {
    rw.endElement(""String_Node_Str"");
  }
  Tooltip.activateTooltips(context,inputText);
}"
56980,"@Override public void encodeEnd(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  ColorPicker colorPicker=(ColorPicker)component;
  ResponseWriter rw=context.getResponseWriter();
  String clientId=colorPicker.getClientId();
  int span=colorPicker.getSpan();
  if (span > 0) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + span,""String_Node_Str"");
  }
  UIComponent prep=colorPicker.getFacet(""String_Node_Str"");
  UIComponent app=colorPicker.getFacet(""String_Node_Str"");
  boolean prepend=(prep != null);
  boolean append=(app != null);
  String label=colorPicker.getLabel();
{
    if (!colorPicker.isRenderLabel()) {
      label=null;
    }
  }
  String t=colorPicker.getType();
  if (t == null)   t=""String_Node_Str"";
  rw.startElement(""String_Node_Str"",component);
  if (null != colorPicker.getDir()) {
    rw.writeAttribute(""String_Node_Str"",colorPicker.getDir(),""String_Node_Str"");
  }
  Tooltip.generateTooltip(context,colorPicker,rw);
  rw.writeAttribute(""String_Node_Str"",clientId,""String_Node_Str"");
  if (colorPicker.isInline()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (label != null) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,""String_Node_Str"");
    generateErrorAndRequiredClass(colorPicker,rw,clientId);
    rw.writeText(label,null);
    rw.endElement(""String_Node_Str"");
  }
  if (append || prepend) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (prepend) {
    if (prep.getClass().getName().endsWith(""String_Node_Str"") || (prep.getChildCount() > 0 && prep.getChildren().get(0).getClass().getName().endsWith(""String_Node_Str""))) {
      rw.startElement(""String_Node_Str"",colorPicker);
      rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      prep.encodeAll(context);
      rw.endElement(""String_Node_Str"");
    }
 else {
      if (prep instanceof Icon)       ((Icon)prep).setAddon(true);
      rw.startElement(""String_Node_Str"",colorPicker);
      rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      prep.encodeAll(context);
      rw.endElement(""String_Node_Str"");
    }
  }
  rw.startElement(""String_Node_Str"",colorPicker);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,null);
  rw.writeAttribute(""String_Node_Str"",clientId,null);
  rw.writeAttribute(""String_Node_Str"",t,null);
  generateStyleClass(colorPicker,rw);
  String ph=colorPicker.getPlaceholder();
  if (ph != null) {
    rw.writeAttribute(""String_Node_Str"",ph,null);
  }
  if (colorPicker.isDisabled()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  if (colorPicker.isReadonly()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  renderPassThruAttributes(context,component,H.INPUT_TEXT);
  String autocomplete=colorPicker.getAutocomplete();
  if ((autocomplete != null) && (autocomplete.equals(""String_Node_Str""))) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  String v=getValue2Render(context,component);
  rw.writeAttribute(""String_Node_Str"",v,null);
  AJAXRenderer.generateBootsFacesAJAXAndJavaScript(FacesContext.getCurrentInstance(),colorPicker,rw);
  rw.endElement(""String_Node_Str"");
  if (append) {
    if (app.getClass().getName().endsWith(""String_Node_Str"") || (app.getChildCount() > 0 && app.getChildren().get(0).getClass().getName().endsWith(""String_Node_Str""))) {
      rw.startElement(""String_Node_Str"",colorPicker);
      rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      app.encodeAll(context);
      rw.endElement(""String_Node_Str"");
    }
 else {
      if (app instanceof Icon)       ((Icon)app).setAddon(true);
      rw.startElement(""String_Node_Str"",colorPicker);
      rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      app.encodeAll(context);
      rw.endElement(""String_Node_Str"");
    }
  }
  if (append || prepend) {
    rw.endElement(""String_Node_Str"");
  }
  rw.endElement(""String_Node_Str"");
  if (span > 0) {
    rw.endElement(""String_Node_Str"");
  }
  Tooltip.activateTooltips(context,colorPicker);
  String swatches=colorPicker.getAttributes().get(""String_Node_Str"") == null ? ""String_Node_Str"" : ((String)colorPicker.getAttributes().get(""String_Node_Str""));
  if (!""String_Node_Str"".equals(swatches)) {
    String[] colors=swatches.split(""String_Node_Str"");
    String swt=""String_Node_Str"";
    for (int i=0; i < Math.min(colors.length,7); i++) {
      swt=swt + ""String_Node_Str"" + colors[i]+ ""String_Node_Str"";
    }
    swt=swt + ""String_Node_Str"";
    swt=swt.replace(""String_Node_Str"",""String_Node_Str"");
    swatches=swt;
  }
  rw.startElement(""String_Node_Str"",colorPicker);
  rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + BsfUtils.EscapeJQuerySpecialCharsInSelector(clientId) + ""String_Node_Str""+ (colorPicker.getAttributes().get(""String_Node_Str"") != null ? ""String_Node_Str"" + colorPicker.getAttributes().get(""String_Node_Str"") + ""String_Node_Str"" : ""String_Node_Str"")+ (colorPicker.getAttributes().get(""String_Node_Str"") != null ? ""String_Node_Str"" + colorPicker.getAttributes().get(""String_Node_Str"") + ""String_Node_Str"" : ""String_Node_Str"")+ (colorPicker.getAttributes().get(""String_Node_Str"") != null ? ""String_Node_Str"" + colorPicker.getAttributes().get(""String_Node_Str"") + ""String_Node_Str"" : ""String_Node_Str"")+ (colorPicker.getAttributes().get(""String_Node_Str"") != null ? ""String_Node_Str"" + colorPicker.getAttributes().get(""String_Node_Str"") + ""String_Node_Str"" : ""String_Node_Str"")+ (!""String_Node_Str"".equals(swatches) ? ""String_Node_Str"" + swatches + ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
  rw.endElement(""String_Node_Str"");
}","@Override public void encodeEnd(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  ColorPicker colorPicker=(ColorPicker)component;
  ResponseWriter rw=context.getResponseWriter();
  String clientId=colorPicker.getClientId();
  int span=colorPicker.getSpan();
  if (span > 0) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + span,""String_Node_Str"");
  }
  UIComponent prep=colorPicker.getFacet(""String_Node_Str"");
  UIComponent app=colorPicker.getFacet(""String_Node_Str"");
  boolean prepend=(prep != null);
  boolean append=(app != null);
  String label=colorPicker.getLabel();
{
    if (!colorPicker.isRenderLabel()) {
      label=null;
    }
  }
  String t=colorPicker.getType();
  if (t == null)   t=""String_Node_Str"";
  rw.startElement(""String_Node_Str"",component);
  if (null != colorPicker.getDir()) {
    rw.writeAttribute(""String_Node_Str"",colorPicker.getDir(),""String_Node_Str"");
  }
  Tooltip.generateTooltip(context,colorPicker,rw);
  rw.writeAttribute(""String_Node_Str"",clientId,""String_Node_Str"");
  if (colorPicker.isInline()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (label != null) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,""String_Node_Str"");
    generateErrorAndRequiredClass(colorPicker,rw,clientId);
    rw.writeText(label,null);
    rw.endElement(""String_Node_Str"");
  }
  if (append || prepend) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (prepend) {
    R.decorateFacetComponent(colorPicker,prep,context,rw);
  }
  rw.startElement(""String_Node_Str"",colorPicker);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,null);
  rw.writeAttribute(""String_Node_Str"",clientId,null);
  rw.writeAttribute(""String_Node_Str"",t,null);
  generateStyleClass(colorPicker,rw);
  String ph=colorPicker.getPlaceholder();
  if (ph != null) {
    rw.writeAttribute(""String_Node_Str"",ph,null);
  }
  if (colorPicker.isDisabled()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  if (colorPicker.isReadonly()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  renderPassThruAttributes(context,component,H.INPUT_TEXT);
  String autocomplete=colorPicker.getAutocomplete();
  if ((autocomplete != null) && (autocomplete.equals(""String_Node_Str""))) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  String v=getValue2Render(context,component);
  rw.writeAttribute(""String_Node_Str"",v,null);
  AJAXRenderer.generateBootsFacesAJAXAndJavaScript(FacesContext.getCurrentInstance(),colorPicker,rw);
  rw.endElement(""String_Node_Str"");
  if (append) {
    R.decorateFacetComponent(colorPicker,app,context,rw);
  }
  if (append || prepend) {
    rw.endElement(""String_Node_Str"");
  }
  rw.endElement(""String_Node_Str"");
  if (span > 0) {
    rw.endElement(""String_Node_Str"");
  }
  Tooltip.activateTooltips(context,colorPicker);
  String swatches=colorPicker.getAttributes().get(""String_Node_Str"") == null ? ""String_Node_Str"" : ((String)colorPicker.getAttributes().get(""String_Node_Str""));
  if (!""String_Node_Str"".equals(swatches)) {
    String[] colors=swatches.split(""String_Node_Str"");
    String swt=""String_Node_Str"";
    for (int i=0; i < Math.min(colors.length,7); i++) {
      swt=swt + ""String_Node_Str"" + colors[i]+ ""String_Node_Str"";
    }
    swt=swt + ""String_Node_Str"";
    swt=swt.replace(""String_Node_Str"",""String_Node_Str"");
    swatches=swt;
  }
  rw.startElement(""String_Node_Str"",colorPicker);
  rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + BsfUtils.EscapeJQuerySpecialCharsInSelector(clientId) + ""String_Node_Str""+ (colorPicker.getAttributes().get(""String_Node_Str"") != null ? ""String_Node_Str"" + colorPicker.getAttributes().get(""String_Node_Str"") + ""String_Node_Str"" : ""String_Node_Str"")+ (colorPicker.getAttributes().get(""String_Node_Str"") != null ? ""String_Node_Str"" + colorPicker.getAttributes().get(""String_Node_Str"") + ""String_Node_Str"" : ""String_Node_Str"")+ (colorPicker.getAttributes().get(""String_Node_Str"") != null ? ""String_Node_Str"" + colorPicker.getAttributes().get(""String_Node_Str"") + ""String_Node_Str"" : ""String_Node_Str"")+ (colorPicker.getAttributes().get(""String_Node_Str"") != null ? ""String_Node_Str"" + colorPicker.getAttributes().get(""String_Node_Str"") + ""String_Node_Str"" : ""String_Node_Str"")+ (!""String_Node_Str"".equals(swatches) ? ""String_Node_Str"" + swatches + ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
  rw.endElement(""String_Node_Str"");
}"
56981,"@Override public void encodeEnd(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  InputText inputText=(InputText)component;
  ResponseWriter rw=context.getResponseWriter();
  String clientId=inputText.getClientId();
  int span=inputText.getSpan();
  if (span > 0) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + span,""String_Node_Str"");
  }
  UIComponent prep=inputText.getFacet(""String_Node_Str"");
  UIComponent app=inputText.getFacet(""String_Node_Str"");
  boolean prepend=(prep != null);
  boolean append=(app != null);
  String label=inputText.getLabel();
{
    if (!inputText.isRenderLabel()) {
      label=null;
    }
  }
  String t;
  if (component instanceof InputSecret) {
    t=""String_Node_Str"";
  }
 else {
    t=inputText.getType();
    if (t == null)     t=""String_Node_Str"";
  }
  rw.startElement(""String_Node_Str"",component);
  if (null != inputText.getDir()) {
    rw.writeAttribute(""String_Node_Str"",inputText.getDir(),""String_Node_Str"");
  }
  Tooltip.generateTooltip(context,inputText,rw);
  rw.writeAttribute(""String_Node_Str"",clientId,""String_Node_Str"");
  if (inputText.isInline()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (label != null) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,""String_Node_Str"");
    generateErrorAndRequiredClass(inputText,rw,clientId);
    rw.writeText(label,null);
    rw.endElement(""String_Node_Str"");
  }
  if (append || prepend) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (prepend) {
    if (prep.getClass().getName().endsWith(""String_Node_Str"") || (prep.getChildCount() > 0 && prep.getChildren().get(0).getClass().getName().endsWith(""String_Node_Str""))) {
      rw.startElement(""String_Node_Str"",inputText);
      rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      prep.encodeAll(context);
      rw.endElement(""String_Node_Str"");
    }
 else {
      if (prep instanceof Icon)       ((Icon)prep).setAddon(true);
      rw.startElement(""String_Node_Str"",inputText);
      rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      prep.encodeAll(context);
      rw.endElement(""String_Node_Str"");
    }
  }
  rw.startElement(""String_Node_Str"",inputText);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,null);
  rw.writeAttribute(""String_Node_Str"",clientId,null);
  rw.writeAttribute(""String_Node_Str"",t,null);
  generateStyleClass(inputText,rw);
  String ph=inputText.getPlaceholder();
  if (ph != null) {
    rw.writeAttribute(""String_Node_Str"",ph,null);
  }
  if (inputText.isDisabled()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  if (inputText.isReadonly()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  renderPassThruAttributes(context,component,H.INPUT_TEXT);
  String autocomplete=inputText.getAutocomplete();
  if ((autocomplete != null) && (autocomplete.equals(""String_Node_Str""))) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  String v=getValue2Render(context,component);
  rw.writeAttribute(""String_Node_Str"",v,null);
  AJAXRenderer.generateBootsFacesAJAXAndJavaScript(FacesContext.getCurrentInstance(),inputText,rw);
  rw.endElement(""String_Node_Str"");
  if (append) {
    if (app.getClass().getName().endsWith(""String_Node_Str"") || (app.getChildCount() > 0 && app.getChildren().get(0).getClass().getName().endsWith(""String_Node_Str""))) {
      rw.startElement(""String_Node_Str"",inputText);
      rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      app.encodeAll(context);
      rw.endElement(""String_Node_Str"");
    }
 else {
      if (app instanceof Icon)       ((Icon)app).setAddon(true);
      rw.startElement(""String_Node_Str"",inputText);
      rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      app.encodeAll(context);
      rw.endElement(""String_Node_Str"");
    }
  }
  if (append || prepend) {
    rw.endElement(""String_Node_Str"");
  }
  rw.endElement(""String_Node_Str"");
  if (span > 0) {
    rw.endElement(""String_Node_Str"");
  }
  Tooltip.activateTooltips(context,inputText);
}","@Override public void encodeEnd(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  InputText inputText=(InputText)component;
  ResponseWriter rw=context.getResponseWriter();
  String clientId=inputText.getClientId();
  int span=inputText.getSpan();
  if (span > 0) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + span,""String_Node_Str"");
  }
  UIComponent prep=inputText.getFacet(""String_Node_Str"");
  UIComponent app=inputText.getFacet(""String_Node_Str"");
  boolean prepend=(prep != null);
  boolean append=(app != null);
  String label=inputText.getLabel();
{
    if (!inputText.isRenderLabel()) {
      label=null;
    }
  }
  String t;
  if (component instanceof InputSecret) {
    t=""String_Node_Str"";
  }
 else {
    t=inputText.getType();
    if (t == null)     t=""String_Node_Str"";
  }
  rw.startElement(""String_Node_Str"",component);
  if (null != inputText.getDir()) {
    rw.writeAttribute(""String_Node_Str"",inputText.getDir(),""String_Node_Str"");
  }
  Tooltip.generateTooltip(context,inputText,rw);
  rw.writeAttribute(""String_Node_Str"",clientId,""String_Node_Str"");
  if (inputText.isInline()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (label != null) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,""String_Node_Str"");
    generateErrorAndRequiredClass(inputText,rw,clientId);
    rw.writeText(label,null);
    rw.endElement(""String_Node_Str"");
  }
  if (append || prepend) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (prepend) {
    R.decorateFacetComponent(inputText,prep,context,rw);
  }
  rw.startElement(""String_Node_Str"",inputText);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,null);
  rw.writeAttribute(""String_Node_Str"",clientId,null);
  rw.writeAttribute(""String_Node_Str"",t,null);
  generateStyleClass(inputText,rw);
  String ph=inputText.getPlaceholder();
  if (ph != null) {
    rw.writeAttribute(""String_Node_Str"",ph,null);
  }
  if (inputText.isDisabled()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  if (inputText.isReadonly()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  renderPassThruAttributes(context,component,H.INPUT_TEXT);
  String autocomplete=inputText.getAutocomplete();
  if ((autocomplete != null) && (autocomplete.equals(""String_Node_Str""))) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  String v=getValue2Render(context,component);
  rw.writeAttribute(""String_Node_Str"",v,null);
  AJAXRenderer.generateBootsFacesAJAXAndJavaScript(FacesContext.getCurrentInstance(),inputText,rw);
  rw.endElement(""String_Node_Str"");
  if (append) {
    R.decorateFacetComponent(inputText,app,context,rw);
  }
  if (append || prepend) {
    rw.endElement(""String_Node_Str"");
  }
  rw.endElement(""String_Node_Str"");
  if (span > 0) {
    rw.endElement(""String_Node_Str"");
  }
  Tooltip.activateTooltips(context,inputText);
}"
56982,"@Override public void encodeEnd(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  InputTextarea inputText=(InputTextarea)component;
  ResponseWriter rw=context.getResponseWriter();
  int span=inputText.getSpan();
  if (span > 0) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + span,""String_Node_Str"");
  }
  String clientId=inputText.getClientId();
  UIComponent prep=inputText.getFacet(""String_Node_Str"");
  UIComponent app=inputText.getFacet(""String_Node_Str"");
  boolean prepend=(prep != null);
  boolean append=(app != null);
  String label=inputText.getLabel();
{
    if (!inputText.isRenderLabel()) {
      label=null;
    }
  }
  String t;
  if (component instanceof InputSecret) {
    t=""String_Node_Str"";
  }
 else {
    t=inputText.getType();
    if (t == null)     t=""String_Node_Str"";
  }
  rw.startElement(""String_Node_Str"",component);
  if (null != inputText.getDir()) {
    rw.writeAttribute(""String_Node_Str"",inputText.getDir(),""String_Node_Str"");
  }
  Tooltip.generateTooltip(context,inputText,rw);
  rw.writeAttribute(""String_Node_Str"",clientId,""String_Node_Str"");
  if (inputText.isInline()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (label != null) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,""String_Node_Str"");
    generateErrorAndRequiredClass(inputText,rw,clientId);
    rw.writeText(label,null);
    rw.endElement(""String_Node_Str"");
  }
  if (append || prepend) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (prepend) {
    if (prep.getClass().getName().endsWith(""String_Node_Str"") || (prep.getChildCount() > 0 && prep.getChildren().get(0).getClass().getName().endsWith(""String_Node_Str""))) {
      rw.startElement(""String_Node_Str"",inputText);
      rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      prep.encodeAll(context);
      rw.endElement(""String_Node_Str"");
    }
 else {
      if (prep instanceof Icon)       ((Icon)prep).setAddon(true);
      rw.startElement(""String_Node_Str"",inputText);
      rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      prep.encodeAll(context);
      rw.endElement(""String_Node_Str"");
    }
  }
  rw.startElement(""String_Node_Str"",inputText);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,null);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,null);
  rw.writeAttribute(""String_Node_Str"",t,null);
  rw.writeAttribute(""String_Node_Str"",inputText.getRows(),""String_Node_Str"");
  generateStyleClass(inputText,rw);
  String ph=inputText.getPlaceholder();
  if (ph != null) {
    rw.writeAttribute(""String_Node_Str"",ph,null);
  }
  if (inputText.isDisabled()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  if (inputText.isReadonly()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  renderPassThruAttributes(context,component,H.INPUT_TEXT);
  String autocomplete=inputText.getAutocomplete();
  if ((autocomplete != null) && (autocomplete.equals(""String_Node_Str""))) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  AJAXRenderer.generateBootsFacesAJAXAndJavaScript(FacesContext.getCurrentInstance(),inputText,rw);
  String v=getValue2Render(context,component);
  if (null == v)   v=""String_Node_Str"";
  rw.writeText(v,null);
  rw.endElement(""String_Node_Str"");
  if (append) {
    if (app.getClass().getName().endsWith(""String_Node_Str"") || (app.getChildCount() > 0 && app.getChildren().get(0).getClass().getName().endsWith(""String_Node_Str""))) {
      rw.startElement(""String_Node_Str"",inputText);
      rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      app.encodeAll(context);
      rw.endElement(""String_Node_Str"");
    }
 else {
      if (app instanceof Icon)       ((Icon)app).setAddon(true);
      rw.startElement(""String_Node_Str"",inputText);
      rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
      app.encodeAll(context);
      rw.endElement(""String_Node_Str"");
    }
  }
  if (append || prepend) {
    rw.endElement(""String_Node_Str"");
  }
  rw.endElement(""String_Node_Str"");
  if (span > 0) {
    rw.endElement(""String_Node_Str"");
  }
  Tooltip.activateTooltips(context,inputText);
}","@Override public void encodeEnd(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  InputTextarea inputText=(InputTextarea)component;
  ResponseWriter rw=context.getResponseWriter();
  int span=inputText.getSpan();
  if (span > 0) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + span,""String_Node_Str"");
  }
  String clientId=inputText.getClientId();
  UIComponent prep=inputText.getFacet(""String_Node_Str"");
  UIComponent app=inputText.getFacet(""String_Node_Str"");
  boolean prepend=(prep != null);
  boolean append=(app != null);
  String label=inputText.getLabel();
{
    if (!inputText.isRenderLabel()) {
      label=null;
    }
  }
  String t;
  if (component instanceof InputSecret) {
    t=""String_Node_Str"";
  }
 else {
    t=inputText.getType();
    if (t == null)     t=""String_Node_Str"";
  }
  rw.startElement(""String_Node_Str"",component);
  if (null != inputText.getDir()) {
    rw.writeAttribute(""String_Node_Str"",inputText.getDir(),""String_Node_Str"");
  }
  Tooltip.generateTooltip(context,inputText,rw);
  rw.writeAttribute(""String_Node_Str"",clientId,""String_Node_Str"");
  if (inputText.isInline()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
 else {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (label != null) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,""String_Node_Str"");
    generateErrorAndRequiredClass(inputText,rw,clientId);
    rw.writeText(label,null);
    rw.endElement(""String_Node_Str"");
  }
  if (append || prepend) {
    rw.startElement(""String_Node_Str"",component);
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  if (prepend) {
    R.decorateFacetComponent(inputText,prep,context,rw);
  }
  rw.startElement(""String_Node_Str"",inputText);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,null);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,null);
  rw.writeAttribute(""String_Node_Str"",t,null);
  rw.writeAttribute(""String_Node_Str"",inputText.getRows(),""String_Node_Str"");
  generateStyleClass(inputText,rw);
  String ph=inputText.getPlaceholder();
  if (ph != null) {
    rw.writeAttribute(""String_Node_Str"",ph,null);
  }
  if (inputText.isDisabled()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  if (inputText.isReadonly()) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  renderPassThruAttributes(context,component,H.INPUT_TEXT);
  String autocomplete=inputText.getAutocomplete();
  if ((autocomplete != null) && (autocomplete.equals(""String_Node_Str""))) {
    rw.writeAttribute(""String_Node_Str"",""String_Node_Str"",null);
  }
  AJAXRenderer.generateBootsFacesAJAXAndJavaScript(FacesContext.getCurrentInstance(),inputText,rw);
  String v=getValue2Render(context,component);
  if (null == v)   v=""String_Node_Str"";
  rw.writeText(v,null);
  rw.endElement(""String_Node_Str"");
  if (append) {
    R.decorateFacetComponent(inputText,app,context,rw);
  }
  if (append || prepend) {
    rw.endElement(""String_Node_Str"");
  }
  rw.endElement(""String_Node_Str"");
  if (span > 0) {
    rw.endElement(""String_Node_Str"");
  }
  Tooltip.activateTooltips(context,inputText);
}"
56983,"/** 
 * Get the item to update after an ajax request
 * @return
 */
public String getUpdate(){
  String value=(String)getStateHelper().eval(PropertyKeys.update);
  return value;
}","/** 
 * Get the item to update after an ajax request
 * @return
 */
public String getUpdate(){
  String value=(String)getStateHelper().eval(PropertyKeys.update,null);
  return value;
}"
56984,"@Override public void encodeEnd(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  ScrollSpy scrollSpy=(ScrollSpy)component;
  ResponseWriter rw=context.getResponseWriter();
  String clientId=scrollSpy.getClientId();
  String container=scrollSpy.getContainer();
  if (!BsfUtils.StringIsValued(container)) {
    container=""String_Node_Str"";
  }
 else   container=""String_Node_Str"" + BsfUtils.EscapeJQuerySpecialCharsInSelector(container);
  String target=scrollSpy.getTarget();
  if (!BsfUtils.StringIsValued(target)) {
    target=""String_Node_Str"";
  }
 else   target=""String_Node_Str"" + BsfUtils.EscapeJQuerySpecialCharsInSelector(target);
  int offset=scrollSpy.getOffset();
  if (!BsfUtils.StringIsValued(target)) {
    offset=20;
  }
  boolean smooth=scrollSpy.isSmooth();
  boolean hasListeners=(scrollSpy.getSelectionListener() != null);
  String updateItems=BsfUtils.GetOrDefault(""String_Node_Str"" + scrollSpy.getUpdate() + ""String_Node_Str"",""String_Node_Str"");
  if (hasListeners) {
    final UIForm form=BsfUtils.getClosestForm(scrollSpy);
    if (form == null) {
      throw new FacesException(""String_Node_Str"",null);
    }
  }
  rw.startElement(""String_Node_Str"",component);
  rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + container + ""String_Node_Str""+ target+ ""String_Node_Str""+ offset+ ""String_Node_Str"",null);
  if (smooth) {
    rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + target + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
  }
  if (hasListeners) {
    rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + target + ""String_Node_Str""+ ""String_Node_Str""+ target+ ""String_Node_Str""+ ""String_Node_Str""+ updateItems+ ""String_Node_Str""+ clientId+ ""String_Node_Str""+ ""String_Node_Str"",null);
  }
  rw.writeText(""String_Node_Str"",null);
  rw.endElement(""String_Node_Str"");
}","@Override public void encodeEnd(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  ScrollSpy scrollSpy=(ScrollSpy)component;
  ResponseWriter rw=context.getResponseWriter();
  String clientId=scrollSpy.getClientId();
  String container=scrollSpy.getContainer();
  if (!BsfUtils.StringIsValued(container)) {
    container=""String_Node_Str"";
  }
 else   container=""String_Node_Str"" + decodeAndEscapeSelectors(context,component,container);
  String target=scrollSpy.getTarget();
  if (!BsfUtils.StringIsValued(target)) {
    target=""String_Node_Str"";
  }
 else   target=""String_Node_Str"" + decodeAndEscapeSelectors(context,component,target);
  int offset=scrollSpy.getOffset();
  if (!BsfUtils.StringIsValued(target)) {
    offset=20;
  }
  boolean smooth=scrollSpy.isSmooth();
  boolean hasListeners=(scrollSpy.getSelectionListener() != null);
  String updateItems=scrollSpy.getUpdate();
  if (updateItems != null)   updateItems=ExpressionResolver.getComponentIDs(context,component,updateItems);
  if (hasListeners) {
    final UIForm form=BsfUtils.getClosestForm(scrollSpy);
    if (form == null) {
      throw new FacesException(""String_Node_Str"",null);
    }
  }
  rw.startElement(""String_Node_Str"",component);
  rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + container + ""String_Node_Str""+ target+ ""String_Node_Str""+ offset+ ""String_Node_Str"",null);
  if (smooth) {
    rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + target + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
  }
  if (hasListeners) {
    rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + target + ""String_Node_Str""+ ""String_Node_Str""+ target+ ""String_Node_Str""+ ""String_Node_Str""+ updateItems+ ""String_Node_Str""+ clientId+ ""String_Node_Str""+ ""String_Node_Str"",null);
  }
  rw.writeText(""String_Node_Str"",null);
  rw.endElement(""String_Node_Str"");
}"
56985,"@Override public void encodeEnd(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  Tree tree=(Tree)component;
  String clientId=tree.getClientId();
  String jqClientId=BsfUtils.EscapeJQuerySpecialCharsInSelector(clientId);
  ResponseWriter rw=context.getResponseWriter();
  final UIForm form=BsfUtils.getClosestForm(tree);
  if (form == null) {
    throw new FacesException(""String_Node_Str"",null);
  }
  String updateItems=BsfUtils.GetOrDefault(""String_Node_Str"" + tree.getUpdate() + ""String_Node_Str"",""String_Node_Str"");
  rw.startElement(""String_Node_Str"",tree);
  rw.writeText(""String_Node_Str"",null);
  rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + TreeModelUtils.renderModelAsJson(tree.getValue(),tree.isRenderRoot()) + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ jqClientId+ ""String_Node_Str""+ (tree.isShowTags() ? ""String_Node_Str"" : ""String_Node_Str"")+ (tree.isShowIcon() ? ""String_Node_Str"" : ""String_Node_Str"")+ (tree.isShowCheckbox() ? ""String_Node_Str"" : ""String_Node_Str"")+ (tree.isEnableLinks() ? ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.StringIsValued(tree.getCollapseIcon()) ? ""String_Node_Str"" + tree.getCollapseIcon() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.StringIsValued(tree.getExpandIcon()) ? ""String_Node_Str"" + tree.getExpandIcon() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.StringIsValued(tree.getColor()) ? ""String_Node_Str"" + tree.getColor() + ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ jqClientId+ ""String_Node_Str""+ ""String_Node_Str""+ updateItems+ ""String_Node_Str""+ clientId+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ jqClientId+ ""String_Node_Str""+ ""String_Node_Str""+ updateItems+ ""String_Node_Str""+ clientId+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ jqClientId+ ""String_Node_Str""+ ""String_Node_Str""+ updateItems+ ""String_Node_Str""+ clientId+ ""String_Node_Str""+ ""String_Node_Str"",null);
  rw.writeText(""String_Node_Str"",null);
  rw.endElement(""String_Node_Str"");
}","@Override public void encodeEnd(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  Tree tree=(Tree)component;
  String clientId=tree.getClientId();
  String jqClientId=BsfUtils.EscapeJQuerySpecialCharsInSelector(clientId);
  ResponseWriter rw=context.getResponseWriter();
  final UIForm form=BsfUtils.getClosestForm(tree);
  if (form == null) {
    throw new FacesException(""String_Node_Str"",null);
  }
  String updateItems=tree.getUpdate();
  if (updateItems != null)   updateItems=ExpressionResolver.getComponentIDs(context,component,updateItems);
  rw.startElement(""String_Node_Str"",tree);
  rw.writeText(""String_Node_Str"",null);
  rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + TreeModelUtils.renderModelAsJson(tree.getValue(),tree.isRenderRoot()) + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ jqClientId+ ""String_Node_Str""+ (tree.isShowTags() ? ""String_Node_Str"" : ""String_Node_Str"")+ (tree.isShowIcon() ? ""String_Node_Str"" : ""String_Node_Str"")+ (tree.isShowCheckbox() ? ""String_Node_Str"" : ""String_Node_Str"")+ (tree.isEnableLinks() ? ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.StringIsValued(tree.getCollapseIcon()) ? ""String_Node_Str"" + tree.getCollapseIcon() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.StringIsValued(tree.getExpandIcon()) ? ""String_Node_Str"" + tree.getExpandIcon() + ""String_Node_Str"" : ""String_Node_Str"")+ (BsfUtils.StringIsValued(tree.getColor()) ? ""String_Node_Str"" + tree.getColor() + ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ jqClientId+ ""String_Node_Str""+ ""String_Node_Str""+ updateItems+ ""String_Node_Str""+ clientId+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ jqClientId+ ""String_Node_Str""+ ""String_Node_Str""+ updateItems+ ""String_Node_Str""+ clientId+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ jqClientId+ ""String_Node_Str""+ ""String_Node_Str""+ updateItems+ ""String_Node_Str""+ clientId+ ""String_Node_Str""+ ""String_Node_Str"",null);
  rw.writeText(""String_Node_Str"",null);
  rw.endElement(""String_Node_Str"");
}"
56986,"@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  Tree tree=(Tree)component;
  ResponseWriter rw=context.getResponseWriter();
  String clientId=tree.getClientId();
  final UIForm form=BsfUtils.getClosestForm(tree);
  if (form == null) {
    throw new FacesException(""String_Node_Str"",null);
  }
  rw.startElement(""String_Node_Str"",tree);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,""String_Node_Str"");
  rw.endElement(""String_Node_Str"");
}","@Override public void encodeBegin(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  Tree tree=(Tree)component;
  ResponseWriter rw=context.getResponseWriter();
  String clientId=tree.getClientId();
  final UIForm form=BsfUtils.getClosestForm(tree);
  if (form == null) {
    throw new FacesException(""String_Node_Str"",null);
  }
  rw.startElement(""String_Node_Str"",tree);
  rw.writeAttribute(""String_Node_Str"",""String_Node_Str"" + clientId,""String_Node_Str"");
  renderPassThruAttributes(context,component,H.HTML5_DATA_ATTRIBUTES,true);
  rw.endElement(""String_Node_Str"");
}"
56987,"private void encodeJS(FacesContext fc,ResponseWriter rw,String cId,String dpId) throws IOException {
  Map<String,Object> attrs=getAttributes();
  StringBuilder sb=new StringBuilder(150);
  sb.append(JQ.DTFORMAT).append(""String_Node_Str"").append(""String_Node_Str"" + convertFormat(sdf) + ""String_Node_Str"").append(""String_Node_Str"");
  if (A.toInt(attrs.get(JQ.NUMOFMONTHS)) > 0) {
    sb.append(JQ.NUMOFMONTHS).append(""String_Node_Str"").append(attrs.get(JQ.NUMOFMONTHS)).append(""String_Node_Str"");
  }
  if (A.toInt(attrs.get(JQ.FIRSTDAY)) > 0) {
    sb.append(JQ.FIRSTDAY).append(""String_Node_Str"").append(attrs.get(JQ.FIRSTDAY)).append(""String_Node_Str"");
  }
  if (A.toBool(attrs.get(JQ.SHOWBUTS))) {
    sb.append(JQ.SHOWBUTS).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  }
  if (A.toBool(attrs.get(JQ.CHNGMONTH))) {
    sb.append(JQ.CHNGMONTH).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  }
  if (A.toBool(attrs.get(JQ.CHNGYEAR))) {
    sb.append(JQ.CHNGYEAR).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  }
  if (A.toBool(attrs.get(JQ.SHOWWK))) {
    sb.append(JQ.SHOWWK).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  }
  if (mode.equals(""String_Node_Str"") || mode.equals(""String_Node_Str"")) {
    sb.append(JQ.SHOWON).append(""String_Node_Str"").append(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"").append(""String_Node_Str"");
  }
  if (attrs.get(JQ.MINDATE) != null) {
    sb.append(JQ.MINDATE + ""String_Node_Str"" + ""String_Node_Str"").append(getDateAsString(attrs.get(JQ.MINDATE),sdf,sloc)).append(""String_Node_Str"");
  }
  if (attrs.get(JQ.MAXDATE) != null) {
    sb.append(JQ.MAXDATE + ""String_Node_Str"" + ""String_Node_Str"").append(getDateAsString(attrs.get(JQ.MAXDATE),sdf,sloc)).append(""String_Node_Str"");
  }
  String l=A.asString(attrs.get(JQ.LANG));
  if (l == null) {
    l=sloc.getLanguage();
  }
  JQ.datePicker(rw,cId,dpId,sb.toString(),l);
}","private void encodeJS(FacesContext fc,ResponseWriter rw,String cId,String dpId) throws IOException {
  Map<String,Object> attrs=getAttributes();
  StringBuilder sb=new StringBuilder(150);
  sb.append(JQ.DTFORMAT).append(""String_Node_Str"").append(""String_Node_Str"" + convertFormat(sdf) + ""String_Node_Str"").append(""String_Node_Str"");
  if (A.toInt(attrs.get(JQ.NUMOFMONTHS)) > 0) {
    sb.append(JQ.NUMOFMONTHS).append(""String_Node_Str"").append(attrs.get(JQ.NUMOFMONTHS)).append(""String_Node_Str"");
  }
  if (A.toInt(attrs.get(JQ.FIRSTDAY)) > 0) {
    sb.append(JQ.FIRSTDAY).append(""String_Node_Str"").append(attrs.get(JQ.FIRSTDAY)).append(""String_Node_Str"");
  }
  if (A.toBool(attrs.get(JQ.SHOWBUTS))) {
    sb.append(JQ.SHOWBUTS).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  }
  if (A.toBool(attrs.get(JQ.CHNGMONTH))) {
    sb.append(JQ.CHNGMONTH).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  }
  if (A.toBool(attrs.get(JQ.CHNGYEAR))) {
    sb.append(JQ.CHNGYEAR).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  }
  if (A.toBool(attrs.get(JQ.SHOWWK))) {
    sb.append(JQ.SHOWWK).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  }
  if (mode.equals(""String_Node_Str"") || mode.equals(""String_Node_Str"")) {
    sb.append(JQ.SHOWON).append(""String_Node_Str"").append(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"").append(""String_Node_Str"");
  }
  if (A.toBool(attrs.get(JQ.DTDISABLED))) {
    sb.append(JQ.DTDISABLED).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
  }
  if (attrs.get(JQ.MINDATE) != null) {
    sb.append(JQ.MINDATE + ""String_Node_Str"" + ""String_Node_Str"").append(getDateAsString(attrs.get(JQ.MINDATE),sdf,sloc)).append(""String_Node_Str"");
  }
  if (attrs.get(JQ.MAXDATE) != null) {
    sb.append(JQ.MAXDATE + ""String_Node_Str"" + ""String_Node_Str"").append(getDateAsString(attrs.get(JQ.MAXDATE),sdf,sloc)).append(""String_Node_Str"");
  }
  String l=A.asString(attrs.get(JQ.LANG));
  if (l == null) {
    l=sloc.getLanguage();
  }
  JQ.datePicker(rw,cId,dpId,sb.toString(),l);
}"
56988,"/** 
 * Algorithm works as follows; - If it's an input component, submitted value is checked first since it'd be the value to be used in case validation errors terminates jsf lifecycle - Finally the value of the component is retrieved from backing bean and if there's a converter, converted value is returned
 * @param fc FacesContext instance
 * @param c UIComponent instance whose value will be returned
 * @return End text
 */
public String getValue2Render(FacesContext fc,UIComponent c){
  if (c instanceof ValueHolder) {
    if (c instanceof EditableValueHolder) {
      Object sv=((EditableValueHolder)c).getSubmittedValue();
      if (sv != null) {
        return sv.toString();
      }
    }
    ValueHolder vh=(ValueHolder)c;
    Object val=vh.getValue();
    if (val != null) {
      Converter converter=getConverter(fc,vh);
      if (converter != null)       return converter.getAsString(fc,c,val);
 else       return val.toString();
    }
 else {
      return null;
    }
  }
  return null;
}","/** 
 * Algorithm works as follows; - If it's an input component, submitted value is checked first since it'd be the value to be used in case validation errors terminates jsf lifecycle - Finally the value of the component is retrieved from backing bean and if there's a converter, converted value is returned
 * @param fc FacesContext instance
 * @param c UIComponent instance whose value will be returned
 * @return End text
 */
public String getValue2Render(FacesContext fc,UIComponent c){
  if (c instanceof ValueHolder) {
    if (c instanceof EditableValueHolder) {
      Object sv=((EditableValueHolder)c).getSubmittedValue();
      if (sv != null) {
        return sv.toString();
      }
    }
    ValueHolder vh=(ValueHolder)c;
    Object val=vh.getValue();
    if (val != null) {
      Converter converter=vh.getConverter();
      if (converter == null) {
        Class<?> valueType=val.getClass();
        if (valueType == String.class) {
          return (String)val;
        }
        converter=fc.getApplication().createConverter(valueType);
      }
      if (converter != null)       return converter.getAsString(fc,c,val);
 else       return val.toString();
    }
 else {
      return null;
    }
  }
  return null;
}"
56989,"private void encodeSeverityMessages(FacesContext facesContext,Growl uiGrowl,String severity,List<FacesMessage> messages) throws IOException {
  ResponseWriter writer=facesContext.getResponseWriter();
  for (  FacesMessage msg : messages) {
    String summary=msg.getSummary() != null ? msg.getSummary() : ""String_Node_Str"";
    String detail=msg.getDetail() != null ? msg.getDetail() : summary;
    if (uiGrowl.isEscape()) {
      summary=BsfUtils.escapeHtml(summary);
      detail=BsfUtils.escapeHtml(detail);
    }
    String messageType=""String_Node_Str"";
    if (""String_Node_Str"".equals(severity)) {
      messageType=""String_Node_Str"";
    }
 else     if (""String_Node_Str"".equals(severity)) {
      messageType=""String_Node_Str"";
    }
 else     if (""String_Node_Str"".equals(severity)) {
      messageType=""String_Node_Str"";
    }
 else     if (""String_Node_Str"".equals(severity)) {
      messageType=""String_Node_Str"";
    }
    String icon=uiGrowl.getIcon() != null ? ""String_Node_Str"" + uiGrowl.getIcon() : ""String_Node_Str"";
    String from=BsfUtils.StringOrDefault(uiGrowl.getPlacementFrom(),""String_Node_Str"");
    String align=BsfUtils.StringOrDefault(uiGrowl.getPlacementAlign(),""String_Node_Str"");
    writer.writeText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + (uiGrowl.isShowSummary() ? summary : ""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ (uiGrowl.isShowDetail() ? detail : ""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ icon+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ messageType+ ""String_Node_Str""+ ""String_Node_Str""+ uiGrowl.isAllowDismiss()+ ""String_Node_Str""+ ""String_Node_Str""+ uiGrowl.isNewestOnTop()+ ""String_Node_Str""+ ""String_Node_Str""+ uiGrowl.getDelay()+ ""String_Node_Str""+ ""String_Node_Str""+ uiGrowl.getTimer()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ from+ ""String_Node_Str""+ ""String_Node_Str""+ align+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
  }
}","private void encodeSeverityMessages(FacesContext facesContext,Growl uiGrowl,String severity,List<FacesMessage> messages) throws IOException {
  ResponseWriter writer=facesContext.getResponseWriter();
  for (  FacesMessage msg : messages) {
    String summary=msg.getSummary() != null ? msg.getSummary() : ""String_Node_Str"";
    String detail=msg.getDetail() != null ? msg.getDetail() : summary;
    if (uiGrowl.isEscape()) {
      summary=BsfUtils.escapeHtml(summary);
      detail=BsfUtils.escapeHtml(detail);
    }
    summary=summary.replace(""String_Node_Str"",""String_Node_Str"");
    detail=detail.replace(""String_Node_Str"",""String_Node_Str"");
    String messageType=""String_Node_Str"";
    if (""String_Node_Str"".equals(severity)) {
      messageType=""String_Node_Str"";
    }
 else     if (""String_Node_Str"".equals(severity)) {
      messageType=""String_Node_Str"";
    }
 else     if (""String_Node_Str"".equals(severity)) {
      messageType=""String_Node_Str"";
    }
 else     if (""String_Node_Str"".equals(severity)) {
      messageType=""String_Node_Str"";
    }
    String icon=uiGrowl.getIcon() != null ? ""String_Node_Str"" + uiGrowl.getIcon() : ""String_Node_Str"";
    String from=BsfUtils.StringOrDefault(uiGrowl.getPlacementFrom(),""String_Node_Str"");
    String align=BsfUtils.StringOrDefault(uiGrowl.getPlacementAlign(),""String_Node_Str"");
    writer.writeText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + (uiGrowl.isShowSummary() ? summary : ""String_Node_Str"") + ""String_Node_Str""+ ""String_Node_Str""+ (uiGrowl.isShowDetail() ? detail : ""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ icon+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ messageType+ ""String_Node_Str""+ ""String_Node_Str""+ uiGrowl.isAllowDismiss()+ ""String_Node_Str""+ ""String_Node_Str""+ uiGrowl.isNewestOnTop()+ ""String_Node_Str""+ ""String_Node_Str""+ uiGrowl.getDelay()+ ""String_Node_Str""+ ""String_Node_Str""+ uiGrowl.getTimer()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ from+ ""String_Node_Str""+ ""String_Node_Str""+ align+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
  }
}"
56990,"/** 
 * Set the map cntaining the DataTable properties for this instance.
 * @param _dataTableProperties The map
 */
public void setDataTableProperties(Map<DataTablePropertyType,Object> _dataTableProperties){
  getStateHelper().put(PropertyKeys.dataTableProperties,_dataTableProperties);
}","/** 
 * Set the map containing the DataTable properties for this instance. <p> EXPERIMENTAL: Does not support multiple DataTables on the same page.
 * @param _dataTableProperties The map
 */
public void setDataTableProperties(Map<DataTablePropertyType,Object> _dataTableProperties){
  getStateHelper().put(PropertyKeys.dataTableProperties,_dataTableProperties);
}"
56991,"/** 
 * This methods generates the HTML code of the current b:dataTable. <code>encodeBegin</code> generates the start of the component. After the, the JSF framework calls <code>encodeChildren()</code> to generate the HTML code between the beginning and the end of the component. For instance, in the case of a panel component the content of the panel is generated by <code>encodeChildren()</code>. After that, <code>encodeEnd()</code> is called to generate the rest of the HTML code.
 * @param context the FacesContext.
 * @param component the current b:dataTable.
 * @throws IOException thrown if something goes wrong when writing the HTML code.
 */
@Override public void encodeEnd(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  DataTable dataTable=(DataTable)component;
  Map<DataTablePropertyType,Object> dataTableProperties=dataTable.getDataTableProperties();
  Integer page=0;
  Integer pageLength=10;
  String searchTerm=""String_Node_Str"";
  if (dataTableProperties != null) {
    Object currentPage=dataTableProperties.get(DataTablePropertyType.currentPage);
    Object currentPageLength=dataTableProperties.get(DataTablePropertyType.pageLength);
    Object currentSearchTerm=dataTableProperties.get(DataTablePropertyType.searchTerm);
    if (currentPage != null) {
      page=(Integer)currentPage;
    }
    if (currentPageLength != null) {
      pageLength=(Integer)currentPageLength;
    }
    if (currentSearchTerm != null) {
      searchTerm=String.format(""String_Node_Str"",(String)currentSearchTerm);
    }
  }
  ResponseWriter rw=context.getResponseWriter();
  String clientId=dataTable.getClientId().replace(""String_Node_Str"",""String_Node_Str"");
  rw.endElement(""String_Node_Str"");
  Tooltip.activateTooltips(context,dataTable);
  rw.startElement(""String_Node_Str"",component);
  rw.writeText(""String_Node_Str"",null);
  rw.writeText(""String_Node_Str"" + clientId + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ clientId+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
  rw.writeText(""String_Node_Str"" + page + ""String_Node_Str""+ ""String_Node_Str""+ searchTerm+ ""String_Node_Str""+ ""String_Node_Str""+ pageLength+ ""String_Node_Str"",null);
  rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + DataTablePropertyType.currentPage + ""String_Node_Str""+ ""String_Node_Str"",null);
  rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + DataTablePropertyType.pageLength + ""String_Node_Str""+ ""String_Node_Str"",null);
  rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + DataTablePropertyType.searchTerm + ""String_Node_Str""+ ""String_Node_Str"",null);
  if (dataTable.isMultiColumnSearch()) {
    rw.writeText(""String_Node_Str"" + clientId + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
    rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
  }
  rw.writeText(""String_Node_Str"",null);
  rw.endElement(""String_Node_Str"");
}","/** 
 * This methods generates the HTML code of the current b:dataTable. <code>encodeBegin</code> generates the start of the component. After the, the JSF framework calls <code>encodeChildren()</code> to generate the HTML code between the beginning and the end of the component. For instance, in the case of a panel component the content of the panel is generated by <code>encodeChildren()</code>. After that, <code>encodeEnd()</code> is called to generate the rest of the HTML code.
 * @param context the FacesContext.
 * @param component the current b:dataTable.
 * @throws IOException thrown if something goes wrong when writing the HTML code.
 */
@Override public void encodeEnd(FacesContext context,UIComponent component) throws IOException {
  if (!component.isRendered()) {
    return;
  }
  DataTable dataTable=(DataTable)component;
  Map<DataTablePropertyType,Object> dataTableProperties=dataTable.getDataTableProperties();
  Integer page=0;
  Integer pageLength=10;
  String searchTerm=""String_Node_Str"";
  if (dataTableProperties != null) {
    Object currentPage=dataTableProperties.get(DataTablePropertyType.currentPage);
    Object currentPageLength=dataTableProperties.get(DataTablePropertyType.pageLength);
    Object currentSearchTerm=dataTableProperties.get(DataTablePropertyType.searchTerm);
    if (currentPage != null) {
      page=(Integer)currentPage;
    }
    if (currentPageLength != null) {
      pageLength=(Integer)currentPageLength;
    }
    if (currentSearchTerm != null) {
      searchTerm=String.format(""String_Node_Str"",(String)currentSearchTerm);
    }
  }
  ResponseWriter rw=context.getResponseWriter();
  String clientIdRaw=dataTable.getClientId();
  String clientId=clientIdRaw.replace(""String_Node_Str"",""String_Node_Str"");
  rw.endElement(""String_Node_Str"");
  Tooltip.activateTooltips(context,dataTable);
  rw.startElement(""String_Node_Str"",component);
  rw.writeText(""String_Node_Str"",null);
  rw.writeText(""String_Node_Str"" + clientId + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ clientIdRaw.replace(""String_Node_Str"",""String_Node_Str"")+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
  rw.writeText(""String_Node_Str"" + page + ""String_Node_Str""+ ""String_Node_Str""+ searchTerm+ ""String_Node_Str""+ ""String_Node_Str""+ pageLength+ ""String_Node_Str"",null);
  if (dataTableProperties != null) {
    rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + DataTablePropertyType.currentPage + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
    rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + DataTablePropertyType.pageLength + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
    rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + DataTablePropertyType.searchTerm + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
  }
  if (dataTable.isMultiColumnSearch()) {
    rw.writeText(""String_Node_Str"" + clientId + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
    rw.writeText(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",null);
  }
  rw.writeText(""String_Node_Str"",null);
  rw.endElement(""String_Node_Str"");
}"
56992,"@Override public Object put(String key,Object value){
  if (""String_Node_Str"".equals(key))   realMap.put(""String_Node_Str"",value);
  if ((""String_Node_Str"".equals(key)) || (""String_Node_Str"".equals(key)))   key=""String_Node_Str"";
  if ((""String_Node_Str"".equals(key)) || (""String_Node_Str"".equals(key)))   key=""String_Node_Str"";
  if ((""String_Node_Str"".equals(key)) || (""String_Node_Str"".equals(key)))   key=""String_Node_Str"";
  if ((""String_Node_Str"".equals(key)) || (""String_Node_Str"".equals(key)))   key=""String_Node_Str"";
  if (""String_Node_Str"".equals(key))   key=""String_Node_Str"";
  if (key != null && key.indexOf('-') > 0) {
    StringBuilder newKey=new StringBuilder(key.length());
    boolean toUpperCase=false;
    for (    char c : key.toCharArray()) {
      if (c == '-')       toUpperCase=true;
 else {
        if (toUpperCase) {
          toUpperCase=false;
          c=Character.toUpperCase(c);
        }
        newKey.append(c);
      }
    }
    Object newValue=value;
    if (key.startsWith(""String_Node_Str"")) {
      newValue=new Integer((String)value);
    }
    realMap.put(key,value);
    return realMap.put(newKey.toString(),newValue);
  }
  return realMap.put(key,value);
}","@Override public Object put(String key,Object value){
  try {
    if (""String_Node_Str"".equals(key))     realMap.put(""String_Node_Str"",value);
    if ((""String_Node_Str"".equals(key)) || (""String_Node_Str"".equals(key)))     key=""String_Node_Str"";
    if ((""String_Node_Str"".equals(key)) || (""String_Node_Str"".equals(key)))     key=""String_Node_Str"";
    if ((""String_Node_Str"".equals(key)) || (""String_Node_Str"".equals(key)))     key=""String_Node_Str"";
    if ((""String_Node_Str"".equals(key)) || (""String_Node_Str"".equals(key)))     key=""String_Node_Str"";
    if (""String_Node_Str"".equals(key))     key=""String_Node_Str"";
    if (key != null && key.indexOf('-') > 0) {
      StringBuilder newKey=new StringBuilder(key.length());
      boolean toUpperCase=false;
      for (      char c : key.toCharArray()) {
        if (c == '-')         toUpperCase=true;
 else {
          if (toUpperCase) {
            toUpperCase=false;
            c=Character.toUpperCase(c);
          }
          newKey.append(c);
        }
      }
      Object newValue=value;
      if (key.startsWith(""String_Node_Str"")) {
        newValue=new Integer((String)value);
      }
      if (newKey.toString().equals(""String_Node_Str"")) {
        newValue=new Boolean((String)value);
      }
 else       newValue=convertValueToType(newKey.toString(),value);
      realMap.put(key,value);
      return realMap.put(newKey.toString(),newValue);
    }
    return realMap.put(key,convertValueToType(key,value));
  }
 catch (  Exception e) {
    System.out.println(e);
  }
  return null;
}"
56993,"public AttributeMapWrapper(Map<String,Object> realMap){
  this.realMap=realMap;
}","public AttributeMapWrapper(Object component,Map<String,Object> realMap){
  this.realMap=realMap;
}"
56994,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
56995,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
56996,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
56997,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
56998,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
56999,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
57000,"@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(super.getAttributes());
  return attributes;
}","@Override public Map<String,Object> getAttributes(){
  if (attributes == null)   attributes=new AttributeMapWrapper(this,super.getAttributes());
  return attributes;
}"
