record_number,buggy_code,fixed_code
54001,"private void transitionAnnotation(List<SpanAlign> spans,AnnotationReplacementCallback annotationReplacementCallback){
  for (  SpanAlign spanAlign : spans) {
    List<AnnotationBo> annotationBoList;
    if (spanAlign.isSpan()) {
      annotationBoList=spanAlign.getSpan().getAnnotationBoList();
      annotationReplacementCallback.replacement(spanAlign,annotationBoList);
    }
 else {
      annotationBoList=spanAlign.getSubSpanBo().getAnnotationBoList();
      annotationReplacementCallback.replacement(spanAlign,annotationBoList);
    }
  }
}","private void transitionAnnotation(List<SpanAlign> spans,AnnotationReplacementCallback annotationReplacementCallback){
  for (  SpanAlign spanAlign : spans) {
    List<AnnotationBo> annotationBoList;
    if (spanAlign.isSpan()) {
      annotationBoList=spanAlign.getSpanBo().getAnnotationBoList();
      annotationReplacementCallback.replacement(spanAlign,annotationBoList);
    }
 else {
      annotationBoList=spanAlign.getSubSpanBo().getAnnotationBoList();
      annotationReplacementCallback.replacement(spanAlign,annotationBoList);
    }
  }
}"
54002,"private void addSpanRecord(List<SpanAlign> spanAligns){
  boolean marked=false;
  for (  SpanAlign sa : spanAligns) {
    if (sa.isSpan()) {
      SpanBo span=sa.getSpan();
      AnnotationUtils.sortAnnotationListByKey(span);
      String method=(String)AnnotationUtils.getDisplayMethod(span);
      String arguments=(String)AnnotationUtils.getDisplayArgument(span);
      long begin=span.getStartTime();
      long elapsed=span.getElapsed();
      if (!marked) {
        setStartTime(begin);
        setEndTime(begin + elapsed);
        applicationName=arguments;
        marked=true;
      }
      recordset.add(new Record(sa.getDepth(),true,method,arguments,begin,elapsed,span.getAgentId(),span.getServiceName()));
      addAnnotationRecord(sa.getDepth() + 1,span.getAnnotationBoList());
    }
 else {
      SubSpanBo subSpan=sa.getSubSpanBo();
      AnnotationUtils.sortAnnotationListByKey(subSpan);
      String method=(String)AnnotationUtils.getDisplayMethod(subSpan);
      Object arguments=AnnotationUtils.getDisplayArgument(subSpan);
      long begin=sa.getSpan().getStartTime() + subSpan.getStartElapsed();
      long elapsed=subSpan.getEndElapsed();
      if (!marked) {
        setStartTime(begin);
        setEndTime(begin + elapsed);
        marked=true;
      }
      recordset.add(new Record(sa.getDepth(),true,method,(arguments != null) ? arguments.toString() : ""String_Node_Str"",begin,elapsed,subSpan.getAgentId(),subSpan.getServiceName()));
      addAnnotationRecord(sa.getDepth() + 1,subSpan.getAnnotationBoList());
    }
  }
}","private void addSpanRecord(List<SpanAlign> spanAligns){
  boolean marked=false;
  for (  SpanAlign sa : spanAligns) {
    if (sa.isSpan()) {
      SpanBo span=sa.getSpanBo();
      AnnotationUtils.sortAnnotationListByKey(span);
      String method=(String)AnnotationUtils.getDisplayMethod(span);
      String arguments=(String)AnnotationUtils.getDisplayArgument(span);
      long begin=span.getStartTime();
      long elapsed=span.getElapsed();
      if (!marked) {
        setStartTime(begin);
        setEndTime(begin + elapsed);
        applicationName=arguments;
        marked=true;
      }
      recordset.add(new Record(sa.getDepth(),true,method,arguments,begin,elapsed,span.getAgentId(),span.getServiceName()));
      addAnnotationRecord(sa.getDepth() + 1,span.getAnnotationBoList());
    }
 else {
      SubSpanBo subSpan=sa.getSubSpanBo();
      AnnotationUtils.sortAnnotationListByKey(subSpan);
      String method=(String)AnnotationUtils.getDisplayMethod(subSpan);
      Object arguments=AnnotationUtils.getDisplayArgument(subSpan);
      long begin=sa.getSpanBo().getStartTime() + subSpan.getStartElapsed();
      long elapsed=subSpan.getEndElapsed();
      if (!marked) {
        setStartTime(begin);
        setEndTime(begin + elapsed);
        marked=true;
      }
      recordset.add(new Record(sa.getDepth(),true,method,(arguments != null) ? arguments.toString() : ""String_Node_Str"",begin,elapsed,subSpan.getAgentId(),subSpan.getServiceName()));
      addAnnotationRecord(sa.getDepth() + 1,subSpan.getAnnotationBoList());
    }
  }
}"
54003,"public SpanAligner2(List<SpanBo> spans){
  spanMap=new HashMap<Long,SpanBo>(spans.size());
  long rootSpanStartTime=Long.MAX_VALUE;
  for (  SpanBo span : spans) {
    if (spanMap.containsKey(Long.valueOf(span.getSpanId()))) {
      throw new IllegalStateException(""String_Node_Str"" + span.getSpanId());
    }
    if (span.getParentSpanId() == -1L) {
      rootSpanId=-1L;
      spanMap.put(-1L,span);
      continue;
    }
 else     if (rootSpanId != -1 && span.getStartTime() < rootSpanStartTime) {
      rootSpanId=(span.getParentSpanId() == -1) ? -1L : span.getSpanId();
      rootSpanStartTime=span.getStartTime();
    }
    spanMap.put(span.getSpanId(),span);
  }
}","public SpanAligner2(List<SpanBo> spans){
  spanMap=new HashMap<Long,SpanBo>(spans.size());
  long rootSpanStartTime=Long.MAX_VALUE;
  for (  SpanBo span : spans) {
    if (spanMap.containsKey(Long.valueOf(span.getSpanId()))) {
      throw new IllegalStateException(""String_Node_Str"" + span.getSpanId());
    }
    if (span.getParentSpanId() == -1L) {
      rootSpanId=-1L;
      spanMap.put(-1L,span);
      continue;
    }
 else     if ((rootSpanId == null || rootSpanId != -1) && span.getStartTime() < rootSpanStartTime) {
      rootSpanId=(span.getParentSpanId() == -1) ? -1L : span.getSpanId();
      rootSpanStartTime=span.getStartTime();
    }
    spanMap.put(span.getSpanId(),span);
  }
}"
54004,"/** 
 * makes call tree of  main view
 */
@Override public ServerCallTree selectServerCallTree(Set<TraceId> traceIds,String applicationName,long from,long to){
  final Map<String,ServiceType> terminalQueryParams=new HashMap<String,ServiceType>();
  final ServerCallTree tree=new ServerCallTree();
  StopWatch watch=new StopWatch();
  watch.start(""String_Node_Str"");
  List<List<SpanBo>> traces=this.traceDao.selectSpans(traceIds);
  watch.stop();
  int totalNonTerminalSpansCount=0;
  Set<String> endPoints=new HashSet<String>();
  for (  List<SpanBo> transaction : traces) {
    totalNonTerminalSpansCount+=transaction.size();
    markRecursiveCall(transaction);
    for (    SpanBo eachTransaction : transaction) {
      tree.addSpan(eachTransaction);
      terminalQueryParams.put(eachTransaction.getServiceName(),eachTransaction.getServiceType());
      endPoints.add(eachTransaction.getEndPoint());
    }
  }
  if (logger.isInfoEnabled()) {
    logger.info(""String_Node_Str"",new Object[]{watch.getLastTaskTimeMillis(),traces.size(),totalNonTerminalSpansCount});
  }
  watch.start(""String_Node_Str"");
  for (  Entry<String,ServiceType> param : terminalQueryParams.entrySet()) {
    ServiceType svcType=param.getValue();
    if (!svcType.isRpcClient() && !svcType.isUnknown() && !svcType.isTerminal()) {
      long start=System.currentTimeMillis();
      List<List<TerminalRequest>> terminals=terminalStatisticsDao.selectTerminal(param.getKey(),from,to);
      logger.info(""String_Node_Str"",param.getKey(),System.currentTimeMillis() - start);
      for (      List<TerminalRequest> terminal : terminals) {
        for (        TerminalRequest t : terminal) {
          if (!endPoints.contains(t.getTo())) {
            t.setToServiceType(ServiceType.UNKNOWN_CLOUD.getCode());
            tree.addTerminal(t);
          }
 else {
          }
        }
      }
    }
  }
  watch.stop();
  logger.info(""String_Node_Str"",watch.getLastTaskTimeMillis());
  return tree.build();
}","/** 
 * makes call tree of  main view
 */
@Override public ServerCallTree selectServerCallTree(Set<TraceId> traceIds,String applicationName,long from,long to){
  final Map<String,ServiceType> terminalQueryParams=new HashMap<String,ServiceType>();
  final ServerCallTree tree=new ServerCallTree();
  StopWatch watch=new StopWatch();
  watch.start(""String_Node_Str"");
  List<List<SpanBo>> traces=this.traceDao.selectSpans(traceIds);
  watch.stop();
  int totalNonTerminalSpansCount=0;
  Set<String> endPoints=new HashSet<String>();
  for (  List<SpanBo> transaction : traces) {
    totalNonTerminalSpansCount+=transaction.size();
    markRecursiveCall(transaction);
    for (    SpanBo eachTransaction : transaction) {
      tree.addSpan(eachTransaction);
      terminalQueryParams.put(eachTransaction.getServiceName(),eachTransaction.getServiceType());
      endPoints.add(eachTransaction.getEndPoint());
    }
  }
  if (logger.isInfoEnabled()) {
    logger.info(""String_Node_Str"",new Object[]{watch.getLastTaskTimeMillis(),traces.size(),totalNonTerminalSpansCount});
  }
  watch.start(""String_Node_Str"");
  for (  Entry<String,ServiceType> param : terminalQueryParams.entrySet()) {
    ServiceType svcType=param.getValue();
    if (!svcType.isRpcClient() && !svcType.isUnknown() && !svcType.isTerminal()) {
      long start=System.currentTimeMillis();
      List<List<TerminalRequest>> terminals=terminalStatisticsDao.selectTerminal(param.getKey(),from,to);
      logger.info(""String_Node_Str"",param.getKey(),System.currentTimeMillis() - start);
      for (      List<TerminalRequest> terminal : terminals) {
        for (        TerminalRequest t : terminal) {
          if (!endPoints.contains(t.getTo())) {
            if (ServiceType.parse(t.getToServiceType()).isRpcClient()) {
              t.setToServiceType(ServiceType.UNKNOWN_CLOUD.getCode());
            }
            tree.addTerminal(t);
          }
        }
      }
    }
  }
  watch.stop();
  logger.info(""String_Node_Str"",watch.getLastTaskTimeMillis());
  return tree.build();
}"
54005,"public void handler(TBase<?,?> tbase,DatagramPacket datagramPacket){
  assert(tbase instanceof Span);
  try {
    Span span=(Span)tbase;
    if (logger.isInfoEnabled()) {
      logger.info(""String_Node_Str"" + span);
    }
    String applicationName=agentIdApplicationIndexDao.selectApplicationName(span.getAgentId());
    if (applicationName == null) {
      logger.warn(""String_Node_Str"",applicationName);
      return;
    }
 else {
      logger.info(""String_Node_Str"",applicationName);
    }
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",applicationName);
    }
    ServiceType serviceType=ServiceType.parse(span.getServiceType());
    if (serviceType.isTerminal()) {
      traceDao.insertTerminalSpan(applicationName,span);
      terminalStatistics.update(applicationName,span.getServiceName(),serviceType.getCode(),span.getAgentId(),span.getElapsed());
    }
 else {
      traceDao.insert(applicationName,span);
    }
    if (span.getParentSpanId() == -1) {
      rootTraceIndexDao.insert(span);
    }
    if (serviceType.isIndexable()) {
      traceIndexDao.insert(span);
      applicationTraceIndexDao.insert(applicationName,span);
    }
 else {
      logger.debug(""String_Node_Str"",span);
    }
  }
 catch (  Exception e) {
    logger.warn(""String_Node_Str"" + e.getMessage(),e);
  }
}","public void handler(TBase<?,?> tbase,DatagramPacket datagramPacket){
  assert(tbase instanceof Span);
  try {
    Span span=(Span)tbase;
    if (logger.isInfoEnabled()) {
      logger.info(""String_Node_Str"" + span);
    }
    String applicationName=agentIdApplicationIndexDao.selectApplicationName(span.getAgentId());
    if (applicationName == null) {
      logger.warn(""String_Node_Str"",applicationName);
      return;
    }
 else {
      logger.info(""String_Node_Str"",applicationName);
    }
    if (logger.isDebugEnabled()) {
      logger.debug(""String_Node_Str"",applicationName);
    }
    ServiceType serviceType=ServiceType.parse(span.getServiceType());
    if (serviceType.isTerminal()) {
      traceDao.insertTerminalSpan(applicationName,span);
      terminalStatistics.update(applicationName,span.getServiceName(),serviceType.getCode(),span.getEndPoint(),span.getElapsed());
    }
 else {
      traceDao.insert(applicationName,span);
    }
    if (span.getParentSpanId() == -1) {
      rootTraceIndexDao.insert(span);
    }
    if (serviceType.isIndexable()) {
      traceIndexDao.insert(span);
      applicationTraceIndexDao.insert(applicationName,span);
    }
 else {
      logger.debug(""String_Node_Str"",span);
    }
  }
 catch (  Exception e) {
    logger.warn(""String_Node_Str"" + e.getMessage(),e);
  }
}"
54006,"public TerminalStatisticsBo(){
  histogramResolution=HistogramBo.DEFAULT_RESOLUTION;
  histogram=new HistogramBo(histogramResolution);
}","public TerminalStatisticsBo(){
  histogramResolution=HistogramBo.DEFAULT_RESOLUTION_MS;
  histogram=new HistogramBo(histogramResolution);
}"
54007,"public Server(String id,String applicationName,String endPoint,ServiceType serviceType){
  this.id=id;
  this.applicationName=applicationName;
  this.endPoint=endPoint;
  this.serviceType=serviceType;
}","public Server(String id,String applicationName,String endPoint,ServiceType serviceType,Set<String> agentIds){
  this.id=id;
  this.applicationName=applicationName;
  this.endPoint=endPoint;
  this.serviceType=serviceType;
  this.agentIds=agentIds;
}"
54008,"public ServerCallTree build(){
  if (isBuilt)   return this;
  for (  Entry<String,TerminalRequest> entry : terminalRequests.entrySet()) {
    TerminalRequest terminal=entry.getValue();
    Server server=new Server(terminal.getTo(),terminal.getTo(),""String_Node_Str"",ServiceType.parse(terminal.getToServiceType()));
    servers.put(server.getId(),server);
  }
  int i=0;
  for (  Entry<String,Server> entry : servers.entrySet()) {
    entry.getValue().setSequence(i++);
  }
  for (  Entry<String,TerminalRequest> entry : terminalRequests.entrySet()) {
    TerminalRequest terminal=entry.getValue();
    ServerRequest request=new ServerRequest(servers.get(terminal.getFrom()),servers.get(terminal.getTo()),terminal.getStatistics().getHistogram());
    serverRequests.put(request.getId(),request);
  }
  for (  SpanBo span : spans) {
    String from=String.valueOf(span.getParentSpanId());
    String to=String.valueOf(span.getSpanId());
    Server fromServer=servers.get(spanIdToServerId.get(from));
    Server toServer=servers.get(spanIdToServerId.get(to));
    if (fromServer == null) {
      fromServer=servers.get(spanIdToServerId.get(PREFIX_CLIENT + to));
    }
    if (fromServer == null) {
      logger.debug(""String_Node_Str"",from);
      continue;
    }
    ServerRequest serverRequest=new ServerRequest(fromServer,toServer);
    if (serverRequest.isSelfCalled()) {
      continue;
    }
    if (serverRequests.containsKey(serverRequest.getId())) {
      serverRequests.get(serverRequest.getId()).addRequest(span.getElapsed());
    }
 else {
      serverRequests.put(serverRequest.getId(),serverRequest);
    }
  }
  isBuilt=true;
  return this;
}","public ServerCallTree build(){
  if (isBuilt)   return this;
  for (  Entry<String,TerminalRequest> entry : terminalRequests.entrySet()) {
    TerminalRequest terminal=entry.getValue();
    Server server=new Server(terminal.getTo(),terminal.getTo(),""String_Node_Str"",ServiceType.parse(terminal.getToServiceType()),terminal.getStatistics().getAgentIds());
    servers.put(server.getId(),server);
  }
  int i=0;
  for (  Entry<String,Server> entry : servers.entrySet()) {
    entry.getValue().setSequence(i++);
  }
  for (  Entry<String,TerminalRequest> entry : terminalRequests.entrySet()) {
    TerminalRequest terminal=entry.getValue();
    ServerRequest request=new ServerRequest(servers.get(terminal.getFrom()),servers.get(terminal.getTo()),terminal.getStatistics().getHistogram());
    serverRequests.put(request.getId(),request);
  }
  for (  SpanBo span : spans) {
    String from=String.valueOf(span.getParentSpanId());
    String to=String.valueOf(span.getSpanId());
    Server fromServer=servers.get(spanIdToServerId.get(from));
    Server toServer=servers.get(spanIdToServerId.get(to));
    if (fromServer == null) {
      fromServer=servers.get(spanIdToServerId.get(PREFIX_CLIENT + to));
    }
    if (fromServer == null) {
      logger.debug(""String_Node_Str"",from);
      continue;
    }
    ServerRequest serverRequest=new ServerRequest(fromServer,toServer);
    if (serverRequest.isSelfCalled()) {
      continue;
    }
    if (serverRequests.containsKey(serverRequest.getId())) {
      serverRequests.get(serverRequest.getId()).addRequest(span.getElapsed());
    }
 else {
      serverRequests.put(serverRequest.getId(),serverRequest);
    }
  }
  isBuilt=true;
  return this;
}"
54009,"public void addSpan(SpanBo span){
  Server server=new Server(span.getAgentId(),span.getServiceName(),span.getEndPoint(),span.isTerminal(),span.getRecursiveCallCount());
  if (server.getId() == null) {
    return;
  }
  if (server.getId().contains(""String_Node_Str"") || server.getId().contains(""String_Node_Str"")) {
    return;
  }
  if (!servers.containsKey(server.getId())) {
    servers.put(server.getId(),server);
  }
 else {
    servers.get(server.getId()).mergeWith(server);
  }
  spanIdToServerId.put(String.valueOf(span.getSpanId()),server.getId());
  if (span.getParentSpanId() == -1) {
    businessTransactions.add(span);
  }
 else {
    spans.add(span);
  }
}","public void addSpan(SpanBo span){
  Server server=new Server(span.getAgentId(),span.getServiceName(),span.getEndPoint(),span.isTerminal(),span.getRecursiveCallCount());
  if (server.getId() == null) {
    return;
  }
  if (!servers.containsKey(server.getId())) {
    servers.put(server.getId(),server);
  }
 else {
    servers.get(server.getId()).mergeWith(server);
  }
  spanIdToServerId.put(String.valueOf(span.getSpanId()),server.getId());
  if (span.getParentSpanId() == -1) {
    businessTransactions.add(span);
  }
 else {
    spans.add(span);
  }
}"
54010,"@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ModelAndView flow(@RequestParam(value=""String_Node_Str"") String traceId){
  logger.debug(""String_Node_Str"",traceId);
  List<SpanAlign> spanAligns=spanService.selectSpan(traceId);
  ModelAndView mv=new ModelAndView(""String_Node_Str"");
  mv.addObject(""String_Node_Str"",spanAligns);
  mv.addObject(""String_Node_Str"",traceId);
  Set<TraceId> traceIds=new HashSet<TraceId>(1);
  traceIds.add(new TraceId(UUID.fromString(traceId)));
  ServerCallTree callTree=flow.selectServerCallTree(traceIds);
  mv.addObject(""String_Node_Str"",callTree.getNodes());
  mv.addObject(""String_Node_Str"",callTree.getLinks());
  return mv;
}","@RequestMapping(value=""String_Node_Str"",method=RequestMethod.GET) public ModelAndView flow(@RequestParam(value=""String_Node_Str"") String traceId){
  logger.debug(""String_Node_Str"",traceId);
  List<SpanAlign> spanAligns=spanService.selectSpan(traceId);
  ModelAndView mv=new ModelAndView(""String_Node_Str"");
  mv.addObject(""String_Node_Str"",spanAligns);
  mv.addObject(""String_Node_Str"",traceId);
  Set<TraceId> traceIds=new HashSet<TraceId>(1);
  traceIds.add(new TraceId(UUID.fromString(traceId)));
  ServerCallTree callTree=flow.selectServerCallTree(traceIds);
  mv.addObject(""String_Node_Str"",callTree.getNodes());
  mv.addObject(""String_Node_Str"",callTree.getLinks());
  RPCCallTree rpcTree=flow.selectRPCCallTree(traceIds);
  mv.addObject(""String_Node_Str"",rpcTree.getNodes());
  mv.addObject(""String_Node_Str"",rpcTree.getLinks());
  return mv;
}"
54011,"private List<SpanBo> refine(List<SpanBo> list){
  SpanBo removeSpan=null;
  boolean rescan=true;
  for (int i=0; i < list.size(); i++) {
    SpanBo span=list.get(i);
    String svcName=span.getServiceName();
    if (removeSpan != null) {
      if (span.getParentSpanId() == removeSpan.getSpanId()) {
        logger.debug(""String_Node_Str"",span);
        span.setParentSpanId(removeSpan.getParentSpanId());
        span.getAnnotationBoList().addAll(removeSpan.getAnnotationBoList());
        logger.debug(""String_Node_Str"",span);
        removeSpan=null;
      }
    }
    if (""String_Node_Str"".equals(svcName)) {
      removeSpan=list.get(i);
      logger.debug(""String_Node_Str"",removeSpan);
      list.remove(i);
    }
    if (removeSpan != null && i == list.size() - 1 && rescan) {
      logger.debug(""String_Node_Str"",removeSpan);
      i=-1;
      rescan=false;
      continue;
    }
  }
  return list;
}","private List<SpanBo> refine(final List<SpanBo> list){
  for (int i=0; i < list.size(); i++) {
    SpanBo span=list.get(i);
    String svcName=span.getServiceName();
    if (""String_Node_Str"".equals(svcName)) {
      SpanBo child=findChildSpan(list,span);
      if (child != null) {
        child.setParentSpanId(span.getParentSpanId());
        child.getAnnotationBoList().addAll(span.getAnnotationBoList());
      }
      list.remove(i);
      i--;
    }
  }
  return list;
}"
54012,"@Override public void before(Object target,String className,String methodName,String parameterDescription,Object[] args){
  if (logger.isLoggable(Level.INFO)) {
    logger.info(""String_Node_Str"" + StringUtils.toString(target) + ""String_Node_Str""+ className+ ""String_Node_Str""+ methodName+ parameterDescription+ ""String_Node_Str""+ Arrays.toString(args));
  }
  try {
    TraceContext traceContext=TraceContext.getTraceContext();
    traceContext.getActiveThreadCounter().start();
    HttpServletRequest request=(HttpServletRequest)args[0];
    String requestURL=request.getRequestURI();
    String clientIP=request.getRemoteAddr();
    String parameters=getRequestParameter(request);
    TraceID traceId=populateTraceIdFromRequest(request);
    if (traceId != null) {
      Trace.setTraceId(traceId);
    }
 else {
      TraceID newTraceID=TraceID.newTraceId();
      if (logger.isLoggable(Level.INFO)) {
        logger.info(""String_Node_Str"" + newTraceID);
        logger.log(Level.FINE,""String_Node_Str"" + requestURL + ""String_Node_Str""+ clientIP+ ""String_Node_Str""+ parameters);
      }
      Trace.setTraceId(newTraceID);
    }
    Trace.recordRpcName(""String_Node_Str"",requestURL);
    Trace.recordEndPoint(request.getProtocol() + ""String_Node_Str"" + request.getLocalName()+ ""String_Node_Str""+ request.getLocalPort());
    Trace.recordAttibute(""String_Node_Str"",request.getRequestURI());
    if (!org.apache.commons.lang.StringUtils.isEmpty(parameters)) {
      Trace.recordAttibute(""String_Node_Str"",parameters);
    }
    Trace.record(Annotation.ServerRecv);
    StopWatch.start(""String_Node_Str"");
  }
 catch (  Exception e) {
    if (logger.isLoggable(Level.WARNING)) {
      logger.log(Level.WARNING,""String_Node_Str"",e);
    }
  }
}","@Override public void before(Object target,String className,String methodName,String parameterDescription,Object[] args){
  if (logger.isLoggable(Level.INFO)) {
    logger.info(""String_Node_Str"" + StringUtils.toString(target) + ""String_Node_Str""+ className+ ""String_Node_Str""+ methodName+ parameterDescription+ ""String_Node_Str""+ Arrays.toString(args));
  }
  try {
    TraceContext traceContext=TraceContext.getTraceContext();
    traceContext.getActiveThreadCounter().start();
    HttpServletRequest request=(HttpServletRequest)args[0];
    String requestURL=request.getRequestURI();
    String clientIP=request.getRemoteAddr();
    String parameters=getRequestParameter(request);
    TraceID traceId=populateTraceIdFromRequest(request);
    if (traceId != null) {
      Trace.setTraceId(traceId);
    }
 else {
      TraceID newTraceID=TraceID.newTraceId();
      if (logger.isLoggable(Level.INFO)) {
        logger.info(""String_Node_Str"" + newTraceID);
        logger.log(Level.FINE,""String_Node_Str"" + requestURL + ""String_Node_Str""+ clientIP+ ""String_Node_Str""+ parameters);
      }
      Trace.setTraceId(newTraceID);
    }
    Trace.recordRpcName(""String_Node_Str"",requestURL);
    Trace.recordEndPoint(request.getProtocol() + ""String_Node_Str"" + request.getLocalName()+ ""String_Node_Str""+ request.getLocalPort());
    Trace.recordAttibute(""String_Node_Str"",request.getRequestURI());
    if (parameters != null && parameters.length() > 0) {
      Trace.recordAttibute(""String_Node_Str"",parameters);
    }
    Trace.record(Annotation.ServerRecv);
    StopWatch.start(""String_Node_Str"");
  }
 catch (  Exception e) {
    if (logger.isLoggable(Level.WARNING)) {
      logger.log(Level.WARNING,""String_Node_Str"",e);
    }
  }
}"
54013,"public void start(){
  logger.info(""String_Node_Str"");
  Trace.addTracer(new DefaultTracer());
  systemMonitor.start();
}","public void start(){
  logger.info(""String_Node_Str"");
  systemMonitor.start();
}"
54014,"private void logSpan(Span span){
  System.out.println(""String_Node_Str"" + span);
}","private void logSpan(Span span){
  System.out.println(""String_Node_Str"" + span.hashCode() + ""String_Node_Str""+ span+ ""String_Node_Str""+ spanMap.size()+ ""String_Node_Str""+ Thread.currentThread().getId());
}"
54015,"@Override public void before(Object target,String className,String methodName,Object[] args){
  try {
    HttpServletRequest request=(HttpServletRequest)args[0];
    String requestURL=request.getRequestURI();
    String clientIP=request.getRemoteAddr();
    String traceID=request.getHeader(Header.HTTP_TRACE_ID.toString());
    String parentSpanID=request.getHeader(Header.HTTP_PARENT_SPAN_ID.toString());
    String spanID=request.getHeader(Header.HTTP_SPAN_ID.toString());
    Boolean sampled=null;
    if (request.getHeader(Header.HTTP_SAMPLED.toString()) != null) {
      sampled=Boolean.valueOf(request.getHeader(Header.HTTP_SAMPLED.toString()));
    }
    Integer flags=null;
    if (request.getHeader(Header.HTTP_FLAGS.toString()) != null) {
      flags=Integer.valueOf(request.getHeader(Header.HTTP_FLAGS.toString()));
    }
    String parameters=getParameter(request);
    if (traceID != null) {
      Trace.setTraceId(new TraceID(traceID,parentSpanID,spanID,sampled,flags));
    }
 else {
      Trace.setTraceId(TraceID.newTraceId());
    }
    Trace.recordRpcName(""String_Node_Str"",requestURL);
    Trace.recordServerAddr(request.getLocalAddr(),request.getLocalPort());
    Trace.record(""String_Node_Str"" + parameters);
    Trace.record(new Annotation.ServerRecv());
    RequestTracer.startTransaction(requestURL,clientIP,System.currentTimeMillis(),parameters);
    start.set(System.currentTimeMillis());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","@Override public void before(Object target,String className,String methodName,Object[] args){
  try {
    HttpServletRequest request=(HttpServletRequest)args[0];
    String requestURL=request.getRequestURI();
    String clientIP=request.getRemoteAddr();
    String traceID=request.getHeader(Header.HTTP_TRACE_ID.toString());
    String parentSpanID=request.getHeader(Header.HTTP_PARENT_SPAN_ID.toString());
    String spanID=request.getHeader(Header.HTTP_SPAN_ID.toString());
    Boolean sampled=null;
    if (request.getHeader(Header.HTTP_SAMPLED.toString()) != null) {
      sampled=Boolean.valueOf(request.getHeader(Header.HTTP_SAMPLED.toString()));
    }
    Integer flags=null;
    if (request.getHeader(Header.HTTP_FLAGS.toString()) != null) {
      flags=Integer.valueOf(request.getHeader(Header.HTTP_FLAGS.toString()));
    }
    String parameters=getParameter(request);
    if (traceID != null) {
      Trace.setTraceId(new TraceID(traceID,parentSpanID,spanID,sampled,flags));
    }
 else {
      Trace.setTraceId(TraceID.newTraceId());
    }
    Trace.recordRpcName(""String_Node_Str"",requestURL);
    Trace.recordServerAddr(request.getLocalAddr(),request.getLocalPort());
    Trace.record(""String_Node_Str"" + parameters);
    Trace.record(new Annotation.ServerRecv());
    RequestTracer.startTransaction(requestURL,clientIP,System.currentTimeMillis(),parameters);
    start.set(System.currentTimeMillis());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    System.out.println(""String_Node_Str"");
  }
}"
54016,"@Override public void after(Object target,String className,String methodName,Object[] args,Object result){
  Trace.record(new Annotation.ServerSend(),System.currentTimeMillis() - start.get());
  start.remove();
  RequestTracer.endTransaction();
}","@Override public void after(Object target,String className,String methodName,Object[] args,Object result){
  Trace.record(new Annotation.ServerSend(),System.currentTimeMillis() - start.get());
  start.remove();
  System.out.println(""String_Node_Str"");
  RequestTracer.endTransaction();
}"
54017,"private Viewport computeScrollViewport(float x,float y){
  Viewport maxViewport=getMaximumViewport();
  Viewport currentViewport=getCurrentViewport();
  Viewport scrollViewport=new Viewport(currentViewport);
  if (maxViewport.contains(x,y)) {
    final float width=currentViewport.width();
    final float height=currentViewport.height();
    final float halfWidth=width / 2;
    final float halfHeight=height / 2;
    float left=x - halfWidth;
    float top=y + halfHeight;
    left=Math.max(maxViewport.left,Math.min(left,maxViewport.right - width));
    top=Math.max(maxViewport.bottom + height,Math.min(top,maxViewport.top));
    scrollViewport.set(left,top,left + height,top - height);
  }
  return scrollViewport;
}","private Viewport computeScrollViewport(float x,float y){
  Viewport maxViewport=getMaximumViewport();
  Viewport currentViewport=getCurrentViewport();
  Viewport scrollViewport=new Viewport(currentViewport);
  if (maxViewport.contains(x,y)) {
    final float width=currentViewport.width();
    final float height=currentViewport.height();
    final float halfWidth=width / 2;
    final float halfHeight=height / 2;
    float left=x - halfWidth;
    float top=y + halfHeight;
    left=Math.max(maxViewport.left,Math.min(left,maxViewport.right - width));
    top=Math.max(maxViewport.bottom + height,Math.min(top,maxViewport.top));
    scrollViewport.set(left,top,left + width,top - height);
  }
  return scrollViewport;
}"
54018,"private void initAxisMeasurements(Axis axis,int position){
  if (LEFT == position) {
    if (axis.isInside()) {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().left + axisMargin;
      nameBaselineTab[position]=computator.getContentRectMinusAxesMargins().left - axisMargin - labelTextDescentTab[position];
    }
 else {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().left - axisMargin;
      nameBaselineTab[position]=labelBaselineTab[position] - axisMargin - labelTextDescentTab[position]- labelDimensionForMarginsTab[position];
    }
    separationLineTab[position]=computator.getContentRectMinusAllMargins().left;
  }
 else   if (RIGHT == position) {
    if (axis.isInside()) {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().right - axisMargin;
      nameBaselineTab[position]=computator.getContentRectMinusAxesMargins().right + axisMargin + labelTextAscentTab[position];
    }
 else {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().right + axisMargin;
      nameBaselineTab[position]=labelBaselineTab[position] + axisMargin + labelTextAscentTab[position]+ labelDimensionForMarginsTab[position];
    }
    separationLineTab[position]=computator.getContentRectMinusAllMargins().right;
  }
 else   if (BOTTOM == position) {
    if (axis.isInside()) {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().bottom - axisMargin - labelTextDescentTab[position];
      nameBaselineTab[position]=computator.getContentRectMinusAxesMargins().bottom + axisMargin + labelTextAscentTab[position];
    }
 else {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().bottom + axisMargin + labelTextAscentTab[position];
      nameBaselineTab[position]=labelBaselineTab[position] + axisMargin + labelDimensionForMarginsTab[position];
    }
    separationLineTab[position]=computator.getContentRectMinusAllMargins().bottom;
  }
 else   if (TOP == position) {
    if (axis.isInside()) {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().top + axisMargin + labelTextAscentTab[position];
      nameBaselineTab[position]=computator.getContentRectMinusAxesMargins().top - axisMargin - labelTextDescentTab[position];
    }
 else {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().top - axisMargin - labelTextDescentTab[position];
      nameBaselineTab[position]=labelBaselineTab[position] - axisMargin - labelDimensionForMarginsTab[position];
    }
    separationLineTab[position]=computator.getContentRectMinusAllMargins().top;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + position);
  }
}","private void initAxisMeasurements(Axis axis,int position){
  if (LEFT == position) {
    if (axis.isInside()) {
      labelBaselineTab[position]=computator.getContentRectMinusAllMargins().left + axisMargin;
      nameBaselineTab[position]=computator.getContentRectMinusAxesMargins().left - axisMargin - labelTextDescentTab[position];
    }
 else {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().left - axisMargin;
      nameBaselineTab[position]=labelBaselineTab[position] - axisMargin - labelTextDescentTab[position]- labelDimensionForMarginsTab[position];
    }
    separationLineTab[position]=computator.getContentRectMinusAllMargins().left;
  }
 else   if (RIGHT == position) {
    if (axis.isInside()) {
      labelBaselineTab[position]=computator.getContentRectMinusAllMargins().right - axisMargin;
      nameBaselineTab[position]=computator.getContentRectMinusAxesMargins().right + axisMargin + labelTextAscentTab[position];
    }
 else {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().right + axisMargin;
      nameBaselineTab[position]=labelBaselineTab[position] + axisMargin + labelTextAscentTab[position]+ labelDimensionForMarginsTab[position];
    }
    separationLineTab[position]=computator.getContentRectMinusAllMargins().right;
  }
 else   if (BOTTOM == position) {
    if (axis.isInside()) {
      labelBaselineTab[position]=computator.getContentRectMinusAllMargins().bottom - axisMargin - labelTextDescentTab[position];
      nameBaselineTab[position]=computator.getContentRectMinusAxesMargins().bottom + axisMargin + labelTextAscentTab[position];
    }
 else {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().bottom + axisMargin + labelTextAscentTab[position];
      nameBaselineTab[position]=labelBaselineTab[position] + axisMargin + labelDimensionForMarginsTab[position];
    }
    separationLineTab[position]=computator.getContentRectMinusAllMargins().bottom;
  }
 else   if (TOP == position) {
    if (axis.isInside()) {
      labelBaselineTab[position]=computator.getContentRectMinusAllMargins().top + axisMargin + labelTextAscentTab[position];
      nameBaselineTab[position]=computator.getContentRectMinusAxesMargins().top - axisMargin - labelTextDescentTab[position];
    }
 else {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().top - axisMargin - labelTextDescentTab[position];
      nameBaselineTab[position]=labelBaselineTab[position] - axisMargin - labelDimensionForMarginsTab[position];
    }
    separationLineTab[position]=computator.getContentRectMinusAllMargins().top;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + position);
  }
}"
54019,"private void drawSeparationLines(Canvas canvas){
  final PieChartData data=dataProvider.getPieChartData();
  if (data.getValues().size() < 2) {
    return;
  }
  final float sliceScale=360f / maxSum;
  float lastAngle=rotation;
  final float circleRadius=originCircleOval.width() / 2f;
  final int sliceSpacing=ChartUtils.dp2px(density,data.getSlicesSpacing());
  separationLinesPaint.setStrokeWidth(sliceSpacing);
  for (  SliceValue sliceValue : data.getValues()) {
    final float angle=Math.abs(sliceValue.getValue()) * sliceScale;
    sliceVector.set((float)(Math.cos(Math.toRadians(lastAngle))),(float)(Math.sin(Math.toRadians(lastAngle))));
    normalizeVector(sliceVector);
    float x1=sliceVector.x * (circleRadius + touchAdditional) + originCircleOval.centerX();
    float y1=sliceVector.y * (circleRadius + touchAdditional) + originCircleOval.centerY();
    canvas.drawLine(originCircleOval.centerX(),originCircleOval.centerY(),x1,y1,separationLinesPaint);
    lastAngle+=angle;
  }
}","private void drawSeparationLines(Canvas canvas){
  final PieChartData data=dataProvider.getPieChartData();
  if (data.getValues().size() < 2) {
    return;
  }
  final float sliceScale=360f / maxSum;
  float lastAngle=rotation;
  final float circleRadius=originCircleOval.width() / 2f;
  final int sliceSpacing=ChartUtils.dp2px(density,data.getSlicesSpacing());
  separationLinesPaint.setStrokeWidth(sliceSpacing);
  for (  SliceValue sliceValue : data.getValues()) {
    final float angle=Math.abs(sliceValue.getValue()) * sliceScale;
    sliceVector.set((float)(Math.cos(Math.toRadians(lastAngle))),(float)(Math.sin(Math.toRadians(lastAngle))));
    normalizeVector(sliceVector);
    float x1=sliceVector.x * (circleRadius + touchAdditional) + originCircleOval.centerX();
    float y1=sliceVector.y * (circleRadius + touchAdditional) + originCircleOval.centerY();
    if (sliceSpacing > 0) {
      canvas.drawLine(originCircleOval.centerX(),originCircleOval.centerY(),x1,y1,separationLinesPaint);
    }
    lastAngle+=angle;
  }
}"
54020,"private void drawSeparationLines(Canvas canvas){
  final PieChartData data=dataProvider.getPieChartData();
  if (data.getValues().size() < 2) {
    return;
  }
  final float sliceScale=360f / maxSum;
  float lastAngle=rotation;
  final float circleRadius=originCircleOval.width() / 2f;
  final int sliceSpacing=ChartUtils.dp2px(density,data.getSlicesSpacing());
  separationLinesPaint.setStrokeWidth(sliceSpacing);
  for (  SliceValue sliceValue : data.getValues()) {
    final float angle=Math.abs(sliceValue.getValue()) * sliceScale;
    sliceVector.set((float)(Math.cos(Math.toRadians(lastAngle))),(float)(Math.sin(Math.toRadians(lastAngle))));
    normalizeVector(sliceVector);
    float x1=sliceVector.x * (circleRadius + touchAdditional) + originCircleOval.centerX();
    float y1=sliceVector.y * (circleRadius + touchAdditional) + originCircleOval.centerY();
    if (sliceSpacing > 0) {
      canvas.drawLine(originCircleOval.centerX(),originCircleOval.centerY(),x1,y1,separationLinesPaint);
    }
    lastAngle+=angle;
  }
}","private void drawSeparationLines(Canvas canvas){
  final PieChartData data=dataProvider.getPieChartData();
  if (data.getValues().size() < 2) {
    return;
  }
  final int sliceSpacing=ChartUtils.dp2px(density,data.getSlicesSpacing());
  if (sliceSpacing < 1) {
    return;
  }
  final float sliceScale=360f / maxSum;
  float lastAngle=rotation;
  final float circleRadius=originCircleOval.width() / 2f;
  separationLinesPaint.setStrokeWidth(sliceSpacing);
  for (  SliceValue sliceValue : data.getValues()) {
    final float angle=Math.abs(sliceValue.getValue()) * sliceScale;
    sliceVector.set((float)(Math.cos(Math.toRadians(lastAngle))),(float)(Math.sin(Math.toRadians(lastAngle))));
    normalizeVector(sliceVector);
    float x1=sliceVector.x * (circleRadius + touchAdditional) + originCircleOval.centerX();
    float y1=sliceVector.y * (circleRadius + touchAdditional) + originCircleOval.centerY();
    canvas.drawLine(originCircleOval.centerX(),originCircleOval.centerY(),x1,y1,separationLinesPaint);
    lastAngle+=angle;
  }
}"
54021,"public boolean fling(int velocityX,int velocityY,ChartComputator computator){
  computator.computeScrollSurfaceSize(surfaceSizeBuffer);
  scrollerStartViewport.set(computator.getCurrentViewport());
  int startX=(int)(surfaceSizeBuffer.x * (scrollerStartViewport.left - computator.getMaximumViewport().left) / computator.getMaximumViewport().width());
  int startY=(int)(surfaceSizeBuffer.y * (computator.getMaximumViewport().top - scrollerStartViewport.top) / computator.getMaximumViewport().height());
  scroller.abortAnimation();
  scroller.fling(startX,startY,velocityX,velocityY,0,surfaceSizeBuffer.x - computator.getContentRectMinusAllMargins().width(),0,surfaceSizeBuffer.y - computator.getContentRectMinusAllMargins().height());
  return true;
}","public boolean fling(int velocityX,int velocityY,ChartComputator computator){
  computator.computeScrollSurfaceSize(surfaceSizeBuffer);
  scrollerStartViewport.set(computator.getCurrentViewport());
  int startX=(int)(surfaceSizeBuffer.x * (scrollerStartViewport.left - computator.getMaximumViewport().left) / computator.getMaximumViewport().width());
  int startY=(int)(surfaceSizeBuffer.y * (computator.getMaximumViewport().top - scrollerStartViewport.top) / computator.getMaximumViewport().height());
  scroller.abortAnimation();
  final int width=computator.getContentRectMinusAllMargins().width();
  final int height=computator.getContentRectMinusAllMargins().height();
  scroller.fling(startX,startY,velocityX,velocityY,0,surfaceSizeBuffer.x - width + 1,0,surfaceSizeBuffer.y - height + 1);
  return true;
}"
54022,"private void initAxisMeasurements(Axis axis,int position){
  if (LEFT == position) {
    if (axis.isInside()) {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().left + axisMargin;
      nameBaselineTab[position]=computator.getContentRectMinusAxesMargins().left - axisMargin - labelTextDescentTab[position];
    }
 else {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().left - axisMargin;
      nameBaselineTab[position]=labelBaselineTab[position] - axisMargin - labelTextDescentTab[position]- labelDimensionForMarginsTab[position];
    }
    separationLineTab[position]=computator.getContentRectMinusAllMargins().left;
  }
 else   if (RIGHT == position) {
    if (axis.isInside()) {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().right - axisMargin;
      nameBaselineTab[position]=computator.getContentRectMinusAxesMargins().right + axisMargin + labelTextAscentTab[position];
    }
 else {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().right + axisMargin;
      nameBaselineTab[position]=labelBaselineTab[position] + axisMargin + labelTextAscentTab[position]+ labelDimensionForMarginsTab[position];
    }
    separationLineTab[position]=computator.getContentRectMinusAllMargins().right;
  }
 else   if (BOTTOM == position) {
    if (axis.isInside()) {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().bottom - axisMargin - labelTextDescentTab[position];
      nameBaselineTab[position]=computator.getContentRectMinusAxesMargins().bottom + axisMargin + labelTextAscentTab[position];
    }
 else {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().bottom + axisMargin + labelTextAscentTab[position];
      nameBaselineTab[position]=labelBaselineTab[position] + axisMargin + labelTextDescentTab[position]+ labelDimensionForMarginsTab[position];
    }
    separationLineTab[position]=computator.getContentRectMinusAllMargins().bottom;
  }
 else   if (TOP == position) {
    if (axis.isInside()) {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().top + axisMargin + labelTextAscentTab[position];
      nameBaselineTab[position]=computator.getContentRectMinusAxesMargins().top - axisMargin - labelTextDescentTab[position];
    }
 else {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().top - axisMargin - labelTextDescentTab[position];
      nameBaselineTab[position]=labelBaselineTab[position] - axisMargin - labelTextDescentTab[position]- labelDimensionForMarginsTab[position];
    }
    separationLineTab[position]=computator.getContentRectMinusAllMargins().top;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + position);
  }
}","private void initAxisMeasurements(Axis axis,int position){
  if (LEFT == position) {
    if (axis.isInside()) {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().left + axisMargin;
      nameBaselineTab[position]=computator.getContentRectMinusAxesMargins().left - axisMargin - labelTextDescentTab[position];
    }
 else {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().left - axisMargin;
      nameBaselineTab[position]=labelBaselineTab[position] - axisMargin - labelTextDescentTab[position]- labelDimensionForMarginsTab[position];
    }
    separationLineTab[position]=computator.getContentRectMinusAllMargins().left;
  }
 else   if (RIGHT == position) {
    if (axis.isInside()) {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().right - axisMargin;
      nameBaselineTab[position]=computator.getContentRectMinusAxesMargins().right + axisMargin + labelTextAscentTab[position];
    }
 else {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().right + axisMargin;
      nameBaselineTab[position]=labelBaselineTab[position] + axisMargin + labelTextAscentTab[position]+ labelDimensionForMarginsTab[position];
    }
    separationLineTab[position]=computator.getContentRectMinusAllMargins().right;
  }
 else   if (BOTTOM == position) {
    if (axis.isInside()) {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().bottom - axisMargin - labelTextDescentTab[position];
      nameBaselineTab[position]=computator.getContentRectMinusAxesMargins().bottom + axisMargin + labelTextAscentTab[position];
    }
 else {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().bottom + axisMargin + labelTextAscentTab[position];
      nameBaselineTab[position]=labelBaselineTab[position] + axisMargin + labelDimensionForMarginsTab[position];
    }
    separationLineTab[position]=computator.getContentRectMinusAllMargins().bottom;
  }
 else   if (TOP == position) {
    if (axis.isInside()) {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().top + axisMargin + labelTextAscentTab[position];
      nameBaselineTab[position]=computator.getContentRectMinusAxesMargins().top - axisMargin - labelTextDescentTab[position];
    }
 else {
      labelBaselineTab[position]=computator.getContentRectMinusAxesMargins().top - axisMargin - labelTextDescentTab[position];
      nameBaselineTab[position]=labelBaselineTab[position] - axisMargin - labelDimensionForMarginsTab[position];
    }
    separationLineTab[position]=computator.getContentRectMinusAllMargins().top;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + position);
  }
}"
54023,"public void setValues(List<PointValue> values){
  if (null == values) {
    this.values=Collections.emptyList();
  }
 else {
    this.values=values;
  }
}","public void setValues(List<PointValue> values){
  if (null == values) {
    this.values=new ArrayList<PointValue>();
  }
 else {
    this.values=values;
  }
}"
54024,"/** 
 * Checks if new viewport doesn't exceed max available viewport.
 */
public void constrainViewport(float left,float top,float right,float bottom){
  if (right - left < minViewportWidth) {
    right=left + minViewportWidth;
    if (left < maxViewport.left) {
      left=maxViewport.left;
      right=left + minViewportWidth;
    }
 else     if (right > maxViewport.right) {
      right=maxViewport.right;
      left=right - minViewportWidth;
    }
  }
  if (top - bottom < minViewportHeight) {
    bottom=top - minViewportHeight;
    if (top > maxViewport.top) {
      top=maxViewport.top;
      bottom=top - minViewportHeight;
    }
 else     if (bottom < maxViewport.bottom) {
      bottom=maxViewport.bottom;
      top=bottom + minViewportHeight;
    }
  }
  currentViewport.left=Math.max(maxViewport.left,left);
  currentViewport.top=Math.min(maxViewport.top,top);
  currentViewport.right=Math.min(maxViewport.right,right);
  currentViewport.bottom=Math.max(maxViewport.bottom,bottom);
}","/** 
 * Checks if new viewport doesn't exceed max available viewport.
 */
public void constrainViewport(float left,float top,float right,float bottom){
  if (Utils.almostEqual(maxViewport.left,left)) {
    left=maxViewport.left;
  }
  if (Utils.almostEqual(maxViewport.right,right)) {
    right=maxViewport.right;
  }
  if (Utils.almostEqual(maxViewport.top,top)) {
    top=maxViewport.top;
  }
  if (Utils.almostEqual(maxViewport.bottom,bottom)) {
    bottom=maxViewport.bottom;
  }
  if (right - left < minViewportWidth) {
    right=left + minViewportWidth;
    if (left < maxViewport.left) {
      left=maxViewport.left;
      right=left + minViewportWidth;
    }
 else     if (right > maxViewport.right) {
      right=maxViewport.right;
      left=right - minViewportWidth;
    }
  }
  if (top - bottom < minViewportHeight) {
    bottom=top - minViewportHeight;
    if (top > maxViewport.top) {
      top=maxViewport.top;
      bottom=top - minViewportHeight;
    }
 else     if (bottom < maxViewport.bottom) {
      bottom=maxViewport.bottom;
      top=bottom + minViewportHeight;
    }
  }
  currentViewport.left=Math.max(maxViewport.left,left);
  currentViewport.top=Math.min(maxViewport.top,top);
  currentViewport.right=Math.min(maxViewport.right,right);
  currentViewport.bottom=Math.max(maxViewport.bottom,bottom);
}"
54025,"public void setCenterText2(String centerText2){
  this.centerText2=centerText2;
}","/** 
 * Note that centerText2 will be drawn only if centerText1 is not empty/null.
 */
public void setCenterText2(String centerText2){
  this.centerText2=centerText2;
}"
54026,"/** 
 * Draw center circle with text if   {@link PieChartData#hasCenterCircle()} is set true.
 */
private void drawCenterCircle(Canvas canvas){
  final PieChartData data=dataProvider.getPieChartData();
  final float circleRadius=orginCircleOval.width() / 2f;
  final float centerRadius=circleRadius * data.getCenterCircleScale();
  final float centerX=orginCircleOval.centerX();
  final float centerY=orginCircleOval.centerY();
  canvas.drawCircle(centerX,centerY,centerRadius,centerCirclePaint);
  if (!TextUtils.isEmpty(data.getCenterText1())) {
    final int text1Bottom=Math.abs(centerCircleText1FontMetrics.bottom);
    if (!TextUtils.isEmpty(data.getCenterText2())) {
      final int text2Height=Math.abs(centerCircleText2FontMetrics.ascent);
      canvas.drawText(data.getCenterText1(),centerX,centerY - text1Bottom,centerCircleText1Paint);
      canvas.drawText(data.getCenterText2(),centerX,centerY + text2Height,centerCircleText2Paint);
    }
 else {
      canvas.drawText(data.getCenterText1(),centerX,centerY + text1Bottom,centerCircleText1Paint);
    }
  }
}","/** 
 * Draw center circle with text if   {@link PieChartData#hasCenterCircle()} is set true.
 */
private void drawCenterCircle(Canvas canvas){
  final PieChartData data=dataProvider.getPieChartData();
  final float circleRadius=orginCircleOval.width() / 2f;
  final float centerRadius=circleRadius * data.getCenterCircleScale();
  final float centerX=orginCircleOval.centerX();
  final float centerY=orginCircleOval.centerY();
  canvas.drawCircle(centerX,centerY,centerRadius,centerCirclePaint);
  if (!TextUtils.isEmpty(data.getCenterText1())) {
    final int text1Height=Math.abs(centerCircleText1FontMetrics.ascent);
    if (!TextUtils.isEmpty(data.getCenterText2())) {
      final int text2Height=Math.abs(centerCircleText2FontMetrics.ascent);
      canvas.drawText(data.getCenterText1(),centerX,centerY - text1Height * 0.2f,centerCircleText1Paint);
      canvas.drawText(data.getCenterText2(),centerX,centerY + text2Height,centerCircleText2Paint);
    }
 else {
      canvas.drawText(data.getCenterText1(),centerX,centerY + text1Height / 4,centerCircleText1Paint);
    }
  }
}"
54027,"public void set(SelectedValue selectedValue){
  this.firstIndex=selectedValue.getFirstIndex();
  this.secondIndex=selectedValue.getSecondIndex();
}","public void set(SelectedValue selectedValue){
  this.firstIndex=selectedValue.firstIndex;
  this.secondIndex=selectedValue.secondIndex;
  this.thirdIndex=selectedValue.thirdIndex;
}"
54028,"public boolean isSet(){
  if (getFirstIndex() >= 0 && getSecondIndex() >= 0) {
    return true;
  }
 else {
    return false;
  }
}","public boolean isSet(){
  if (firstIndex >= 0 && secondIndex >= 0 && thirdIndex >= 0) {
    return true;
  }
 else {
    return false;
  }
}"
54029,"public void clear(){
  set(Integer.MIN_VALUE,Integer.MIN_VALUE);
  this.dataType=Integer.MIN_VALUE;
}","public void clear(){
  set(Integer.MIN_VALUE,Integer.MIN_VALUE,Integer.MIN_VALUE);
}"
54030,"public SelectedValue(int firstIndex,int secondIndex){
  set(firstIndex,secondIndex);
}","public SelectedValue(int firstIndex,int secondIndex,int dataType){
  set(firstIndex,secondIndex,dataType);
}"
54031,"public void computePoint(float t,float[] startPoints,PointF outPoint){
  if (startPoints.length != pointsNumber) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  System.arraycopy(points[0],0,startPoints,0,pointsNumber);
  for (int i=1, pointsIndex=pointsNumber; i < curveDegree; ++i, pointsIndex-=2) {
    for (int indexX=0, indexY=1; indexY < pointsIndex; indexX+=2, indexY+=2) {
      points[i][indexX]=(1 - t) * points[i - 1][indexX] + t * points[i - 1][indexX + 2];
      points[i][indexY]=(1 - t) * points[i - 1][indexY] + t * points[i - 1][indexY + 2];
    }
  }
  outPoint.set(points[curveDegree - 1][0],points[curveDegree - 1][1]);
}","public void computePoint(float t,float[] startPoints,PointF outPoint){
  if (startPoints.length != pointsNumber) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  System.arraycopy(startPoints,0,points[0],0,pointsNumber);
  for (int i=1, pointsIndex=pointsNumber - 2; i < curveDegree; ++i, pointsIndex-=2) {
    for (int indexX=0, indexY=1; indexY <= pointsIndex; indexX+=2, indexY+=2) {
      points[i][indexX]=(1 - t) * points[i - 1][indexX] + t * points[i - 1][indexX + 2];
      points[i][indexY]=(1 - t) * points[i - 1][indexY] + t * points[i - 1][indexY + 2];
    }
  }
  outPoint.set(points[curveDegree - 1][0],points[curveDegree - 1][1]);
}"
54032,"public void setData(final ColumnChartData data){
  mData=data;
  mData.calculateBoundaries();
  mChartCalculator.calculateViewport();
  mChartCalculator.calculateContentArea(getWidth(),getHeight(),getPaddingLeft(),getPaddingTop(),getPaddingRight(),getPaddingBottom());
  mChartCalculator.setAxesMargin(mAxesRenderer.getAxisXHeight(0),mAxesRenderer.getAxisYWidth(0));
  ViewCompat.postInvalidateOnAnimation(ColumnChartView.this);
}","public void setData(final ColumnChartData data){
  mData=data;
  mData.calculateBoundaries();
  mChartCalculator.calculateViewport();
  mChartCalculator.calculateContentArea(getWidth(),getHeight(),getPaddingLeft(),getPaddingTop(),getPaddingRight(),getPaddingBottom());
  mAxesRenderer.initRenderer();
  mChartCalculator.setAxesMargin(mAxesRenderer.getAxisXHeight(),mAxesRenderer.getAxisYWidth());
  ViewCompat.postInvalidateOnAnimation(ColumnChartView.this);
}"
54033,"@Override protected void onSizeChanged(int width,int height,int oldWidth,int oldHeight){
  super.onSizeChanged(width,height,oldWidth,oldHeight);
  mChartCalculator.calculateViewport();
  mChartCalculator.calculateContentArea(getWidth(),getHeight(),getPaddingLeft(),getPaddingTop(),getPaddingRight(),getPaddingBottom());
  mChartCalculator.setAxesMargin(mAxesRenderer.getAxisXHeight(0),mAxesRenderer.getAxisYWidth(0));
}","@Override protected void onSizeChanged(int width,int height,int oldWidth,int oldHeight){
  super.onSizeChanged(width,height,oldWidth,oldHeight);
  mChartCalculator.calculateViewport();
  mChartCalculator.calculateContentArea(getWidth(),getHeight(),getPaddingLeft(),getPaddingTop(),getPaddingRight(),getPaddingBottom());
  mChartCalculator.setAxesMargin(mAxesRenderer.getAxisXHeight(),mAxesRenderer.getAxisYWidth());
}"
54034,"protected void onStart(){
  mDialogView.startAnimation(mModalInAnim);
  playAnimation();
}","protected void onStart(){
  getWindow().getDecorView().getBackground().setAlpha(255);
  mDialogView.startAnimation(mModalInAnim);
  playAnimation();
}"
54035,"public SweetAlertDialog(Context context,int alertType){
  super(context,R.style.alert_dialog);
  setCancelable(true);
  setCanceledOnTouchOutside(false);
  mAlertType=alertType;
  mErrorInAnim=OptAnimationLoader.loadAnimation(getContext(),R.anim.error_frame_in);
  mErrorXInAnim=OptAnimationLoader.loadAnimation(getContext(),R.anim.error_x_in);
  mSuccessBowAnim=OptAnimationLoader.loadAnimation(getContext(),R.anim.success_bow_roate);
  mSuccessLayoutAnimSet=(AnimationSet)OptAnimationLoader.loadAnimation(getContext(),R.anim.success_mask_layout);
  mScaleInAnim=(AnimationSet)OptAnimationLoader.loadAnimation(getContext(),R.anim.dialog_scale_in);
  mScaleOutAnim=(AnimationSet)OptAnimationLoader.loadAnimation(getContext(),R.anim.dialog_scale_out);
  mScaleOutAnim.setAnimationListener(new Animation.AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
    }
    @Override public void onAnimationEnd(    Animation animation){
      mDialogView.setVisibility(View.GONE);
      mDialogView.post(new Runnable(){
        @Override public void run(){
          SweetAlertDialog.super.dismiss();
        }
      }
);
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
  }
);
}","public SweetAlertDialog(Context context,int alertType){
  super(context,R.style.alert_dialog);
  setCancelable(true);
  setCanceledOnTouchOutside(false);
  mAlertType=alertType;
  mErrorInAnim=OptAnimationLoader.loadAnimation(getContext(),R.anim.error_frame_in);
  mErrorXInAnim=(AnimationSet)OptAnimationLoader.loadAnimation(getContext(),R.anim.error_x_in);
  if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.GINGERBREAD_MR1) {
    List<Animation> childAnims=mErrorXInAnim.getAnimations();
    int idx=0;
    for (; idx < childAnims.size(); idx++) {
      if (childAnims.get(idx) instanceof AlphaAnimation) {
        break;
      }
    }
    if (idx < childAnims.size()) {
      childAnims.remove(idx);
    }
  }
  mSuccessBowAnim=OptAnimationLoader.loadAnimation(getContext(),R.anim.success_bow_roate);
  mSuccessLayoutAnimSet=(AnimationSet)OptAnimationLoader.loadAnimation(getContext(),R.anim.success_mask_layout);
  mScaleInAnim=(AnimationSet)OptAnimationLoader.loadAnimation(getContext(),R.anim.dialog_scale_in);
  mScaleOutAnim=(AnimationSet)OptAnimationLoader.loadAnimation(getContext(),R.anim.dialog_scale_out);
  mScaleOutAnim.setAnimationListener(new Animation.AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
    }
    @Override public void onAnimationEnd(    Animation animation){
      mDialogView.setVisibility(View.GONE);
      mDialogView.post(new Runnable(){
        @Override public void run(){
          SweetAlertDialog.super.dismiss();
        }
      }
);
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
  }
);
}"
54036,"@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=TextUtils.isEmpty(getText()) ? closeButtonBitmaps[0] : clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? (baseColor & 0x00ffffff | 0x44000000) : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : (baseColor & 0x00ffffff | 0x44000000));
      canvas.save();
      canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : (baseColor & 0x00ffffff | 0x44000000),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=(int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (floatingLabelTextColor != -1 ? 1 : (0.74f * focusFraction + 0.26f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=TextUtils.isEmpty(getText()) ? closeButtonBitmaps[0] : clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? (baseColor & 0x00ffffff | 0x44000000) : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : (baseColor & 0x00ffffff | 0x44000000));
      canvas.save();
      if (isRTL()) {
        canvas.translate(endX - textLayout.getWidth(),lineStartY + bottomSpacing - bottomTextPadding);
      }
 else {
        canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      }
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : (baseColor & 0x00ffffff | 0x44000000),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=(int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (floatingLabelTextColor != -1 ? 1 : (0.74f * focusFraction + 0.26f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}"
54037,"public void setValidateOnFocusLost(boolean validateOnFocusLost){
  this.validateOnFocusLost=validateOnFocusLost;
}","public void setValidateOnFocusLost(boolean validate){
  this.validateOnFocusLost=validate;
}"
54038,"@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=TextUtils.isEmpty(getText()) ? closeButtonBitmaps[0] : clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? (baseColor & 0x00ffffff | 0x44000000) : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : (baseColor & 0x00ffffff | 0x44000000));
      canvas.save();
      canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : (baseColor & 0x00ffffff | 0x44000000),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=(int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (floatingLabelTextColor != -1 ? 1 : (0.74f * focusFraction + 0.26f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=TextUtils.isEmpty(getText()) ? closeButtonBitmaps[0] : clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? (baseColor & 0x00ffffff | 0x44000000) : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : (baseColor & 0x00ffffff | 0x44000000));
      canvas.save();
      if (isRTL()) {
        canvas.translate(endX - textLayout.getWidth(),lineStartY + bottomSpacing - bottomTextPadding);
      }
 else {
        canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      }
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : (baseColor & 0x00ffffff | 0x44000000),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=(int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (floatingLabelTextColor != -1 ? 1 : (0.74f * focusFraction + 0.26f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}"
54039,"@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=TextUtils.isEmpty(getText()) ? closeButtonBitmaps[0] : clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? (baseColor & 0x00ffffff | 0x44000000) : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : (baseColor & 0x00ffffff | 0x44000000));
      canvas.save();
      canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : (baseColor & 0x00ffffff | 0x44000000),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=(int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (floatingLabelTextColor != -1 ? 1 : (0.74f * focusFraction + 0.26f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=TextUtils.isEmpty(getText()) ? closeButtonBitmaps[0] : clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? (baseColor & 0x00ffffff | 0x44000000) : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : (baseColor & 0x00ffffff | 0x44000000));
      canvas.save();
      if (isRTL()) {
        canvas.translate(endX - textLayout.getWidth(),lineStartY + bottomSpacing - bottomTextPadding);
      }
 else {
        canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      }
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : (baseColor & 0x00ffffff | 0x44000000),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=(int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (floatingLabelTextColor != -1 ? 1 : (0.74f * focusFraction + 0.26f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}"
54040,"public void setValidateOnFocusLost(boolean validateOnFocusLost){
  this.validateOnFocusLost=validateOnFocusLost;
}","public void setValidateOnFocusLost(boolean validate){
  this.validateOnFocusLost=validate;
}"
54041,"@Override public boolean onTouchEvent(MotionEvent event){
  if (singleLineEllipsis && getScrollX() > 0 && event.getAction() == MotionEvent.ACTION_DOWN && event.getX() < getPixel(4 * 5) && event.getY() > getHeight() - extraPaddingBottom - innerPaddingBottom && event.getY() < getHeight() - innerPaddingBottom) {
    setSelection(0);
    return false;
  }
  if (hasFocus() && showClearButton) {
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
      if (insideClearButton(event)) {
        clearButtonTouched=true;
        clearButtonClicking=true;
      }
    return true;
case MotionEvent.ACTION_MOVE:
  if (clearButtonClicking && !insideClearButton(event)) {
    clearButtonClicking=false;
  }
if (clearButtonTouched) {
  return true;
}
break;
case MotionEvent.ACTION_UP:
if (clearButtonClicking) {
if (!TextUtils.isEmpty(getText())) {
setText(null);
}
clearButtonClicking=false;
}
if (clearButtonTouched) {
clearButtonTouched=false;
return true;
}
clearButtonTouched=false;
break;
case MotionEvent.ACTION_CANCEL:
clearButtonTouched=false;
clearButtonClicking=false;
break;
}
}
return super.onTouchEvent(event);
}","@Override public boolean onTouchEvent(MotionEvent event){
  if (singleLineEllipsis && getScrollX() > 0 && event.getAction() == MotionEvent.ACTION_DOWN && event.getX() < getPixel(4 * 5) && event.getY() > getHeight() - extraPaddingBottom - innerPaddingBottom && event.getY() < getHeight() - innerPaddingBottom) {
    setSelection(0);
    return false;
  }
  if (hasFocus() && showClearButton) {
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
      if (insideClearButton(event)) {
        clearButtonTouched=true;
        clearButtonClicking=true;
        return true;
      }
case MotionEvent.ACTION_MOVE:
    if (clearButtonClicking && !insideClearButton(event)) {
      clearButtonClicking=false;
    }
  if (clearButtonTouched) {
    return true;
  }
break;
case MotionEvent.ACTION_UP:
if (clearButtonClicking) {
if (!TextUtils.isEmpty(getText())) {
  setText(null);
}
clearButtonClicking=false;
}
if (clearButtonTouched) {
clearButtonTouched=false;
return true;
}
clearButtonTouched=false;
break;
case MotionEvent.ACTION_CANCEL:
clearButtonTouched=false;
clearButtonClicking=false;
break;
}
}
return super.onTouchEvent(event);
}"
54042,"@Override public boolean onTouchEvent(MotionEvent event){
  if (singleLineEllipsis && getScrollX() > 0 && event.getAction() == MotionEvent.ACTION_DOWN && event.getX() < getPixel(4 * 5) && event.getY() > getHeight() - extraPaddingBottom - innerPaddingBottom && event.getY() < getHeight() - innerPaddingBottom) {
    setSelection(0);
    return false;
  }
  if (hasFocus() && showClearButton) {
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
      if (insideClearButton(event)) {
        clearButtonTouched=true;
        clearButtonClicking=true;
      }
    return true;
case MotionEvent.ACTION_MOVE:
  if (clearButtonClicking && !insideClearButton(event)) {
    clearButtonClicking=false;
  }
if (clearButtonTouched) {
  return true;
}
break;
case MotionEvent.ACTION_UP:
if (clearButtonClicking) {
if (!TextUtils.isEmpty(getText())) {
setText(null);
}
clearButtonClicking=false;
}
if (clearButtonTouched) {
clearButtonTouched=false;
return true;
}
clearButtonTouched=false;
break;
case MotionEvent.ACTION_CANCEL:
clearButtonTouched=false;
clearButtonClicking=false;
break;
}
}
return super.onTouchEvent(event);
}","@Override public boolean onTouchEvent(MotionEvent event){
  if (singleLineEllipsis && getScrollX() > 0 && event.getAction() == MotionEvent.ACTION_DOWN && event.getX() < getPixel(4 * 5) && event.getY() > getHeight() - extraPaddingBottom - innerPaddingBottom && event.getY() < getHeight() - innerPaddingBottom) {
    setSelection(0);
    return false;
  }
  if (hasFocus() && showClearButton) {
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
      if (insideClearButton(event)) {
        clearButtonTouched=true;
        clearButtonClicking=true;
        return true;
      }
case MotionEvent.ACTION_MOVE:
    if (clearButtonClicking && !insideClearButton(event)) {
      clearButtonClicking=false;
    }
  if (clearButtonTouched) {
    return true;
  }
break;
case MotionEvent.ACTION_UP:
if (clearButtonClicking) {
if (!TextUtils.isEmpty(getText())) {
  setText(null);
}
clearButtonClicking=false;
}
if (clearButtonTouched) {
clearButtonTouched=false;
return true;
}
clearButtonTouched=false;
break;
case MotionEvent.ACTION_CANCEL:
clearButtonTouched=false;
clearButtonClicking=false;
break;
}
}
return super.onTouchEvent(event);
}"
54043,"@Override public boolean onTouchEvent(MotionEvent event){
  if (singleLineEllipsis && getScrollX() > 0 && event.getAction() == MotionEvent.ACTION_DOWN && event.getX() < getPixel(4 * 5) && event.getY() > getHeight() - extraPaddingBottom - innerPaddingBottom && event.getY() < getHeight() - innerPaddingBottom) {
    setSelection(0);
    return false;
  }
  if (hasFocus() && showClearButton) {
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
      if (insideClearButton(event)) {
        clearButtonTouched=true;
        clearButtonClicking=true;
      }
    return true;
case MotionEvent.ACTION_MOVE:
  if (clearButtonClicking && !insideClearButton(event)) {
    clearButtonClicking=false;
  }
if (clearButtonTouched) {
  return true;
}
break;
case MotionEvent.ACTION_UP:
if (clearButtonClicking) {
if (!TextUtils.isEmpty(getText())) {
setText(null);
}
clearButtonClicking=false;
}
if (clearButtonTouched) {
clearButtonTouched=false;
return true;
}
clearButtonTouched=false;
break;
case MotionEvent.ACTION_CANCEL:
clearButtonTouched=false;
clearButtonClicking=false;
break;
}
}
return super.onTouchEvent(event);
}","@Override public boolean onTouchEvent(MotionEvent event){
  if (singleLineEllipsis && getScrollX() > 0 && event.getAction() == MotionEvent.ACTION_DOWN && event.getX() < getPixel(4 * 5) && event.getY() > getHeight() - extraPaddingBottom - innerPaddingBottom && event.getY() < getHeight() - innerPaddingBottom) {
    setSelection(0);
    return false;
  }
  if (hasFocus() && showClearButton) {
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
      if (insideClearButton(event)) {
        clearButtonTouched=true;
        clearButtonClicking=true;
        return true;
      }
case MotionEvent.ACTION_MOVE:
    if (clearButtonClicking && !insideClearButton(event)) {
      clearButtonClicking=false;
    }
  if (clearButtonTouched) {
    return true;
  }
break;
case MotionEvent.ACTION_UP:
if (clearButtonClicking) {
if (!TextUtils.isEmpty(getText())) {
  setText(null);
}
clearButtonClicking=false;
}
if (clearButtonTouched) {
clearButtonTouched=false;
return true;
}
clearButtonTouched=false;
break;
case MotionEvent.ACTION_CANCEL:
clearButtonTouched=false;
clearButtonClicking=false;
break;
}
}
return super.onTouchEvent(event);
}"
54044,"@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton && !TextUtils.isEmpty(getText())) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharactersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? (baseColor & 0x00ffffff | 0x44000000) : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : (baseColor & 0x00ffffff | 0x44000000));
      canvas.save();
      if (isRTL()) {
        canvas.translate(endX - textLayout.getWidth(),lineStartY + bottomSpacing - bottomTextPadding);
      }
 else {
        canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      }
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : (baseColor & 0x00ffffff | 0x44000000),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int distance=floatingLabelPadding;
    int floatingLabelStartY=(int)(innerPaddingTop + floatingLabelTextSize + floatingLabelPadding - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction) + getScrollY());
    int alpha=((int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (0.74f * focusFraction + 0.26f)* (floatingLabelTextColor != -1 ? 1 : Color.alpha(floatingLabelTextColor) / 256f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,floatingLabelStartY,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(isInternalValid() ? primaryColor : errorColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton && !TextUtils.isEmpty(getText())) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharactersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? (baseColor & 0x00ffffff | 0x44000000) : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : (baseColor & 0x00ffffff | 0x44000000));
      canvas.save();
      if (isRTL()) {
        canvas.translate(endX - textLayout.getWidth(),lineStartY + bottomSpacing - bottomTextPadding);
      }
 else {
        canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      }
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction * (isEnabled() ? 1 : 0),floatingLabelTextColor != -1 ? floatingLabelTextColor : (baseColor & 0x00ffffff | 0x44000000),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int distance=floatingLabelPadding;
    int floatingLabelStartY=(int)(innerPaddingTop + floatingLabelTextSize + floatingLabelPadding - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction) + getScrollY());
    int alpha=((int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (0.74f * focusFraction * (isEnabled() ? 1 : 0) + 0.26f)* (floatingLabelTextColor != -1 ? 1 : Color.alpha(floatingLabelTextColor) / 256f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,floatingLabelStartY,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(isInternalValid() ? primaryColor : errorColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}"
54045,"@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton && !TextUtils.isEmpty(getText())&& isEnabled()) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharactersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? (baseColor & 0x00ffffff | 0x44000000) : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : (baseColor & 0x00ffffff | 0x44000000));
      canvas.save();
      if (isRTL()) {
        canvas.translate(endX - textLayout.getWidth(),lineStartY + bottomSpacing - bottomTextPadding);
      }
 else {
        canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      }
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction * (isEnabled() ? 1 : 0),floatingLabelTextColor != -1 ? floatingLabelTextColor : (baseColor & 0x00ffffff | 0x44000000),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int distance=floatingLabelPadding;
    int floatingLabelStartY=(int)(innerPaddingTop + floatingLabelTextSize + floatingLabelPadding - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction) + getScrollY());
    int alpha=((int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (0.74f * focusFraction * (isEnabled() ? 1 : 0) + 0.26f)* (floatingLabelTextColor != -1 ? 1 : Color.alpha(floatingLabelTextColor) / 256f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,floatingLabelStartY,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(isInternalValid() ? primaryColor : errorColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding)) + getPaddingLeft();
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding) - getPaddingRight();
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton && !TextUtils.isEmpty(getText())&& isEnabled()) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharactersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? (baseColor & 0x00ffffff | 0x44000000) : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : (baseColor & 0x00ffffff | 0x44000000));
      canvas.save();
      if (isRTL()) {
        canvas.translate(endX - textLayout.getWidth(),lineStartY + bottomSpacing - bottomTextPadding);
      }
 else {
        canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      }
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction * (isEnabled() ? 1 : 0),floatingLabelTextColor != -1 ? floatingLabelTextColor : (baseColor & 0x00ffffff | 0x44000000),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int distance=floatingLabelPadding;
    int floatingLabelStartY=(int)(innerPaddingTop + floatingLabelTextSize + floatingLabelPadding - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction) + getScrollY());
    int alpha=((int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (0.74f * focusFraction * (isEnabled() ? 1 : 0) + 0.26f)* (floatingLabelTextColor != -1 ? 1 : Color.alpha(floatingLabelTextColor) / 256f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,floatingLabelStartY,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(isInternalValid() ? primaryColor : errorColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}"
54046,"@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=TextUtils.isEmpty(getText()) ? closeButtonBitmaps[0] : clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? (baseColor & 0x00ffffff | 0x44000000) : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : (baseColor & 0x00ffffff | 0x44000000));
      canvas.save();
      if (isRTL()) {
        canvas.translate(endX - textLayout.getWidth(),lineStartY + bottomSpacing - bottomTextPadding);
      }
 else {
        canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      }
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : (baseColor & 0x00ffffff | 0x44000000),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=(int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (floatingLabelTextColor != -1 ? 1 : (0.74f * focusFraction + 0.26f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=TextUtils.isEmpty(getText()) ? closeButtonBitmaps[0] : clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? (baseColor & 0x00ffffff | 0x44000000) : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : (baseColor & 0x00ffffff | 0x44000000));
      canvas.save();
      if (isRTL()) {
        canvas.translate(endX - textLayout.getWidth(),lineStartY + bottomSpacing - bottomTextPadding);
      }
 else {
        canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      }
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : (baseColor & 0x00ffffff | 0x44000000),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=(int)((int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (0.74f * focusFraction + 0.26f)* (floatingLabelTextColor != -1 ? 1 : Color.alpha(floatingLabelTextColor) / 256f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}"
54047,"@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=TextUtils.isEmpty(getText()) ? closeButtonBitmaps[0] : clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? (baseColor & 0x00ffffff | 0x44000000) : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : (baseColor & 0x00ffffff | 0x44000000));
      canvas.save();
      if (isRTL()) {
        canvas.translate(endX - textLayout.getWidth(),lineStartY + bottomSpacing - bottomTextPadding);
      }
 else {
        canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      }
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : (baseColor & 0x00ffffff | 0x44000000),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=(int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (floatingLabelTextColor != -1 ? 1 : (0.74f * focusFraction + 0.26f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=TextUtils.isEmpty(getText()) ? closeButtonBitmaps[0] : clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? (baseColor & 0x00ffffff | 0x44000000) : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : (baseColor & 0x00ffffff | 0x44000000));
      canvas.save();
      if (isRTL()) {
        canvas.translate(endX - textLayout.getWidth(),lineStartY + bottomSpacing - bottomTextPadding);
      }
 else {
        canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      }
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : (baseColor & 0x00ffffff | 0x44000000),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=(int)((int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (0.74f * focusFraction + 0.26f)* (floatingLabelTextColor != -1 ? 1 : Color.alpha(floatingLabelTextColor) / 256f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}"
54048,"@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=TextUtils.isEmpty(getText()) ? closeButtonBitmaps[0] : clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? (baseColor & 0x00ffffff | 0x44000000) : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : (baseColor & 0x00ffffff | 0x44000000));
      canvas.save();
      if (isRTL()) {
        canvas.translate(endX - textLayout.getWidth(),lineStartY + bottomSpacing - bottomTextPadding);
      }
 else {
        canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      }
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : (baseColor & 0x00ffffff | 0x44000000),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=(int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (floatingLabelTextColor != -1 ? 1 : (0.74f * focusFraction + 0.26f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=TextUtils.isEmpty(getText()) ? closeButtonBitmaps[0] : clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? (baseColor & 0x00ffffff | 0x44000000) : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : (baseColor & 0x00ffffff | 0x44000000));
      canvas.save();
      if (isRTL()) {
        canvas.translate(endX - textLayout.getWidth(),lineStartY + bottomSpacing - bottomTextPadding);
      }
 else {
        canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      }
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : (baseColor & 0x00ffffff | 0x44000000),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=(int)((int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (0.74f * focusFraction + 0.26f)* (floatingLabelTextColor != -1 ? 1 : Color.alpha(floatingLabelTextColor) / 256f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}"
54049,"@Override public void afterTextChanged(Editable s){
  if (floatingLabelEnabled) {
    if (s.length() == 0) {
      if (floatingLabelShown) {
        floatingLabelShown=false;
        getLabelAnimator().reverse();
      }
    }
 else     if (!floatingLabelShown) {
      floatingLabelShown=true;
      if (getLabelAnimator().isStarted()) {
        getLabelAnimator().reverse();
      }
 else {
        getLabelAnimator().start();
      }
    }
  }
}","@Override public void afterTextChanged(Editable s){
  if (floatingLabelEnabled) {
    if (s.length() == 0) {
      if (floatingLabelShown) {
        floatingLabelShown=false;
        getLabelAnimator().reverse();
      }
    }
 else     if (!floatingLabelShown) {
      floatingLabelShown=true;
      getLabelAnimator().start();
    }
  }
}"
54050,"private void initFloatingLabel(){
  addTextChangedListener(new TextWatcher(){
    @Override public void beforeTextChanged(    CharSequence s,    int start,    int count,    int after){
    }
    @Override public void onTextChanged(    CharSequence s,    int start,    int before,    int count){
    }
    @Override public void afterTextChanged(    Editable s){
      if (floatingLabelEnabled) {
        if (s.length() == 0) {
          if (floatingLabelShown) {
            floatingLabelShown=false;
            getLabelAnimator().reverse();
          }
        }
 else         if (!floatingLabelShown) {
          floatingLabelShown=true;
          if (getLabelAnimator().isStarted()) {
            getLabelAnimator().reverse();
          }
 else {
            getLabelAnimator().start();
          }
        }
      }
    }
  }
);
  innerFocusChangeListener=new OnFocusChangeListener(){
    @Override public void onFocusChange(    View v,    boolean hasFocus){
      if (floatingLabelEnabled && highlightFloatingLabel) {
        if (hasFocus) {
          if (getLabelFocusAnimator().isStarted()) {
            getLabelFocusAnimator().reverse();
          }
 else {
            getLabelFocusAnimator().start();
          }
        }
 else {
          getLabelFocusAnimator().reverse();
        }
      }
      if (validateOnFocusLost && !hasFocus) {
        validate();
      }
      if (outerFocusChangeListener != null) {
        outerFocusChangeListener.onFocusChange(v,hasFocus);
      }
    }
  }
;
  super.setOnFocusChangeListener(innerFocusChangeListener);
}","private void initFloatingLabel(){
  addTextChangedListener(new TextWatcher(){
    @Override public void beforeTextChanged(    CharSequence s,    int start,    int count,    int after){
    }
    @Override public void onTextChanged(    CharSequence s,    int start,    int before,    int count){
    }
    @Override public void afterTextChanged(    Editable s){
      if (floatingLabelEnabled) {
        if (s.length() == 0) {
          if (floatingLabelShown) {
            floatingLabelShown=false;
            getLabelAnimator().reverse();
          }
        }
 else         if (!floatingLabelShown) {
          floatingLabelShown=true;
          getLabelAnimator().start();
        }
      }
    }
  }
);
  innerFocusChangeListener=new OnFocusChangeListener(){
    @Override public void onFocusChange(    View v,    boolean hasFocus){
      if (floatingLabelEnabled && highlightFloatingLabel) {
        if (hasFocus) {
          getLabelFocusAnimator().start();
        }
 else {
          getLabelFocusAnimator().reverse();
        }
      }
      if (validateOnFocusLost && !hasFocus) {
        validate();
      }
      if (outerFocusChangeListener != null) {
        outerFocusChangeListener.onFocusChange(v,hasFocus);
      }
    }
  }
;
  super.setOnFocusChangeListener(innerFocusChangeListener);
}"
54051,"@Override public void onFocusChange(View v,boolean hasFocus){
  if (floatingLabelEnabled && highlightFloatingLabel) {
    if (hasFocus) {
      if (getLabelFocusAnimator().isStarted()) {
        getLabelFocusAnimator().reverse();
      }
 else {
        getLabelFocusAnimator().start();
      }
    }
 else {
      getLabelFocusAnimator().reverse();
    }
  }
  if (validateOnFocusLost && !hasFocus) {
    validate();
  }
  if (outerFocusChangeListener != null) {
    outerFocusChangeListener.onFocusChange(v,hasFocus);
  }
}","@Override public void onFocusChange(View v,boolean hasFocus){
  if (floatingLabelEnabled && highlightFloatingLabel) {
    if (hasFocus) {
      getLabelFocusAnimator().start();
    }
 else {
      getLabelFocusAnimator().reverse();
    }
  }
  if (validateOnFocusLost && !hasFocus) {
    validate();
  }
  if (outerFocusChangeListener != null) {
    outerFocusChangeListener.onFocusChange(v,hasFocus);
  }
}"
54052,"@Override public void afterTextChanged(Editable s){
  if (floatingLabelEnabled) {
    if (s.length() == 0) {
      if (floatingLabelShown) {
        floatingLabelShown=false;
        getLabelAnimator().reverse();
      }
    }
 else     if (!floatingLabelShown) {
      floatingLabelShown=true;
      if (getLabelAnimator().isStarted()) {
        getLabelAnimator().reverse();
      }
 else {
        getLabelAnimator().start();
      }
    }
  }
}","@Override public void afterTextChanged(Editable s){
  if (floatingLabelEnabled) {
    if (s.length() == 0) {
      if (floatingLabelShown) {
        floatingLabelShown=false;
        getLabelAnimator().reverse();
      }
    }
 else     if (!floatingLabelShown) {
      floatingLabelShown=true;
      getLabelAnimator().start();
    }
  }
}"
54053,"private void initFloatingLabel(){
  addTextChangedListener(new TextWatcher(){
    @Override public void beforeTextChanged(    CharSequence s,    int start,    int count,    int after){
    }
    @Override public void onTextChanged(    CharSequence s,    int start,    int before,    int count){
    }
    @Override public void afterTextChanged(    Editable s){
      if (floatingLabelEnabled) {
        if (s.length() == 0) {
          if (floatingLabelShown) {
            floatingLabelShown=false;
            getLabelAnimator().reverse();
          }
        }
 else         if (!floatingLabelShown) {
          floatingLabelShown=true;
          if (getLabelAnimator().isStarted()) {
            getLabelAnimator().reverse();
          }
 else {
            getLabelAnimator().start();
          }
        }
      }
    }
  }
);
  innerFocusChangeListener=new OnFocusChangeListener(){
    @Override public void onFocusChange(    View v,    boolean hasFocus){
      if (floatingLabelEnabled && highlightFloatingLabel) {
        if (hasFocus) {
          if (getLabelFocusAnimator().isStarted()) {
            getLabelFocusAnimator().reverse();
          }
 else {
            getLabelFocusAnimator().start();
          }
        }
 else {
          getLabelFocusAnimator().reverse();
        }
      }
      if (validateOnFocusLost && !hasFocus) {
        validate();
      }
      if (outerFocusChangeListener != null) {
        outerFocusChangeListener.onFocusChange(v,hasFocus);
      }
    }
  }
;
  super.setOnFocusChangeListener(innerFocusChangeListener);
}","private void initFloatingLabel(){
  addTextChangedListener(new TextWatcher(){
    @Override public void beforeTextChanged(    CharSequence s,    int start,    int count,    int after){
    }
    @Override public void onTextChanged(    CharSequence s,    int start,    int before,    int count){
    }
    @Override public void afterTextChanged(    Editable s){
      if (floatingLabelEnabled) {
        if (s.length() == 0) {
          if (floatingLabelShown) {
            floatingLabelShown=false;
            getLabelAnimator().reverse();
          }
        }
 else         if (!floatingLabelShown) {
          floatingLabelShown=true;
          getLabelAnimator().start();
        }
      }
    }
  }
);
  innerFocusChangeListener=new OnFocusChangeListener(){
    @Override public void onFocusChange(    View v,    boolean hasFocus){
      if (floatingLabelEnabled && highlightFloatingLabel) {
        if (hasFocus) {
          getLabelFocusAnimator().start();
        }
 else {
          getLabelFocusAnimator().reverse();
        }
      }
      if (validateOnFocusLost && !hasFocus) {
        validate();
      }
      if (outerFocusChangeListener != null) {
        outerFocusChangeListener.onFocusChange(v,hasFocus);
      }
    }
  }
;
  super.setOnFocusChangeListener(innerFocusChangeListener);
}"
54054,"@Override public void onFocusChange(View v,boolean hasFocus){
  if (floatingLabelEnabled && highlightFloatingLabel) {
    if (hasFocus) {
      if (getLabelFocusAnimator().isStarted()) {
        getLabelFocusAnimator().reverse();
      }
 else {
        getLabelFocusAnimator().start();
      }
    }
 else {
      getLabelFocusAnimator().reverse();
    }
  }
  if (validateOnFocusLost && !hasFocus) {
    validate();
  }
  if (outerFocusChangeListener != null) {
    outerFocusChangeListener.onFocusChange(v,hasFocus);
  }
}","@Override public void onFocusChange(View v,boolean hasFocus){
  if (floatingLabelEnabled && highlightFloatingLabel) {
    if (hasFocus) {
      getLabelFocusAnimator().start();
    }
 else {
      getLabelFocusAnimator().reverse();
    }
  }
  if (validateOnFocusLost && !hasFocus) {
    validate();
  }
  if (outerFocusChangeListener != null) {
    outerFocusChangeListener.onFocusChange(v,hasFocus);
  }
}"
54055,"@Override public void afterTextChanged(Editable s){
  if (floatingLabelEnabled) {
    if (s.length() == 0) {
      if (floatingLabelShown) {
        floatingLabelShown=false;
        getLabelAnimator().reverse();
      }
    }
 else     if (!floatingLabelShown) {
      floatingLabelShown=true;
      if (getLabelAnimator().isStarted()) {
        getLabelAnimator().reverse();
      }
 else {
        getLabelAnimator().start();
      }
    }
  }
}","@Override public void afterTextChanged(Editable s){
  if (floatingLabelEnabled) {
    if (s.length() == 0) {
      if (floatingLabelShown) {
        floatingLabelShown=false;
        getLabelAnimator().reverse();
      }
    }
 else     if (!floatingLabelShown) {
      floatingLabelShown=true;
      getLabelAnimator().start();
    }
  }
}"
54056,"private void initFloatingLabel(){
  addTextChangedListener(new TextWatcher(){
    @Override public void beforeTextChanged(    CharSequence s,    int start,    int count,    int after){
    }
    @Override public void onTextChanged(    CharSequence s,    int start,    int before,    int count){
    }
    @Override public void afterTextChanged(    Editable s){
      if (floatingLabelEnabled) {
        if (s.length() == 0) {
          if (floatingLabelShown) {
            floatingLabelShown=false;
            getLabelAnimator().reverse();
          }
        }
 else         if (!floatingLabelShown) {
          floatingLabelShown=true;
          if (getLabelAnimator().isStarted()) {
            getLabelAnimator().reverse();
          }
 else {
            getLabelAnimator().start();
          }
        }
      }
    }
  }
);
  innerFocusChangeListener=new OnFocusChangeListener(){
    @Override public void onFocusChange(    View v,    boolean hasFocus){
      if (floatingLabelEnabled && highlightFloatingLabel) {
        if (hasFocus) {
          if (getLabelFocusAnimator().isStarted()) {
            getLabelFocusAnimator().reverse();
          }
 else {
            getLabelFocusAnimator().start();
          }
        }
 else {
          getLabelFocusAnimator().reverse();
        }
      }
      if (validateOnFocusLost && !hasFocus) {
        validate();
      }
      if (outerFocusChangeListener != null) {
        outerFocusChangeListener.onFocusChange(v,hasFocus);
      }
    }
  }
;
  super.setOnFocusChangeListener(innerFocusChangeListener);
}","private void initFloatingLabel(){
  addTextChangedListener(new TextWatcher(){
    @Override public void beforeTextChanged(    CharSequence s,    int start,    int count,    int after){
    }
    @Override public void onTextChanged(    CharSequence s,    int start,    int before,    int count){
    }
    @Override public void afterTextChanged(    Editable s){
      if (floatingLabelEnabled) {
        if (s.length() == 0) {
          if (floatingLabelShown) {
            floatingLabelShown=false;
            getLabelAnimator().reverse();
          }
        }
 else         if (!floatingLabelShown) {
          floatingLabelShown=true;
          getLabelAnimator().start();
        }
      }
    }
  }
);
  innerFocusChangeListener=new OnFocusChangeListener(){
    @Override public void onFocusChange(    View v,    boolean hasFocus){
      if (floatingLabelEnabled && highlightFloatingLabel) {
        if (hasFocus) {
          getLabelFocusAnimator().start();
        }
 else {
          getLabelFocusAnimator().reverse();
        }
      }
      if (validateOnFocusLost && !hasFocus) {
        validate();
      }
      if (outerFocusChangeListener != null) {
        outerFocusChangeListener.onFocusChange(v,hasFocus);
      }
    }
  }
;
  super.setOnFocusChangeListener(innerFocusChangeListener);
}"
54057,"@Override public void onFocusChange(View v,boolean hasFocus){
  if (floatingLabelEnabled && highlightFloatingLabel) {
    if (hasFocus) {
      if (getLabelFocusAnimator().isStarted()) {
        getLabelFocusAnimator().reverse();
      }
 else {
        getLabelFocusAnimator().start();
      }
    }
 else {
      getLabelFocusAnimator().reverse();
    }
  }
  if (validateOnFocusLost && !hasFocus) {
    validate();
  }
  if (outerFocusChangeListener != null) {
    outerFocusChangeListener.onFocusChange(v,hasFocus);
  }
}","@Override public void onFocusChange(View v,boolean hasFocus){
  if (floatingLabelEnabled && highlightFloatingLabel) {
    if (hasFocus) {
      getLabelFocusAnimator().start();
    }
 else {
      getLabelFocusAnimator().reverse();
    }
  }
  if (validateOnFocusLost && !hasFocus) {
    validate();
  }
  if (outerFocusChangeListener != null) {
    outerFocusChangeListener.onFocusChange(v,hasFocus);
  }
}"
54058,"@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton && !TextUtils.isEmpty(getText())) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharactersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? (baseColor & 0x00ffffff | 0x44000000) : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : (baseColor & 0x00ffffff | 0x44000000));
      canvas.save();
      if (isRTL()) {
        canvas.translate(endX - textLayout.getWidth(),lineStartY + bottomSpacing - bottomTextPadding);
      }
 else {
        canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      }
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : (baseColor & 0x00ffffff | 0x44000000),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=((int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (0.74f * focusFraction + 0.26f)* (floatingLabelTextColor != -1 ? 1 : Color.alpha(floatingLabelTextColor) / 256f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(isInternalValid() ? primaryColor : errorColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton && !TextUtils.isEmpty(getText())) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharactersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? (baseColor & 0x00ffffff | 0x44000000) : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : (baseColor & 0x00ffffff | 0x44000000));
      canvas.save();
      if (isRTL()) {
        canvas.translate(endX - textLayout.getWidth(),lineStartY + bottomSpacing - bottomTextPadding);
      }
 else {
        canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      }
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : (baseColor & 0x00ffffff | 0x44000000),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int distance=floatingLabelPadding;
    int floatingLabelStartY=(int)(innerPaddingTop + floatingLabelTextSize + floatingLabelPadding - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction) + getScrollY());
    int alpha=((int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (0.74f * focusFraction + 0.26f)* (floatingLabelTextColor != -1 ? 1 : Color.alpha(floatingLabelTextColor) / 256f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,floatingLabelStartY,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(isInternalValid() ? primaryColor : errorColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}"
54059,"@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton && !TextUtils.isEmpty(getText())) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharactersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? (baseColor & 0x00ffffff | 0x44000000) : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : (baseColor & 0x00ffffff | 0x44000000));
      canvas.save();
      if (isRTL()) {
        canvas.translate(endX - textLayout.getWidth(),lineStartY + bottomSpacing - bottomTextPadding);
      }
 else {
        canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      }
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : (baseColor & 0x00ffffff | 0x44000000),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=((int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (0.74f * focusFraction + 0.26f)* (floatingLabelTextColor != -1 ? 1 : Color.alpha(floatingLabelTextColor) / 256f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(isInternalValid() ? primaryColor : errorColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton && !TextUtils.isEmpty(getText())) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharactersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? (baseColor & 0x00ffffff | 0x44000000) : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : (baseColor & 0x00ffffff | 0x44000000));
      canvas.save();
      if (isRTL()) {
        canvas.translate(endX - textLayout.getWidth(),lineStartY + bottomSpacing - bottomTextPadding);
      }
 else {
        canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      }
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : (baseColor & 0x00ffffff | 0x44000000),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int distance=floatingLabelPadding;
    int floatingLabelStartY=(int)(innerPaddingTop + floatingLabelTextSize + floatingLabelPadding - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction) + getScrollY());
    int alpha=((int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (0.74f * focusFraction + 0.26f)* (floatingLabelTextColor != -1 ? 1 : Color.alpha(floatingLabelTextColor) / 256f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,floatingLabelStartY,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(isInternalValid() ? primaryColor : errorColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}"
54060,"@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton && !TextUtils.isEmpty(getText())) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharactersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? (baseColor & 0x00ffffff | 0x44000000) : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : (baseColor & 0x00ffffff | 0x44000000));
      canvas.save();
      if (isRTL()) {
        canvas.translate(endX - textLayout.getWidth(),lineStartY + bottomSpacing - bottomTextPadding);
      }
 else {
        canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      }
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : (baseColor & 0x00ffffff | 0x44000000),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=((int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (0.74f * focusFraction + 0.26f)* (floatingLabelTextColor != -1 ? 1 : Color.alpha(floatingLabelTextColor) / 256f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(isInternalValid() ? primaryColor : errorColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton && !TextUtils.isEmpty(getText())) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharactersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? (baseColor & 0x00ffffff | 0x44000000) : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : (baseColor & 0x00ffffff | 0x44000000));
      canvas.save();
      if (isRTL()) {
        canvas.translate(endX - textLayout.getWidth(),lineStartY + bottomSpacing - bottomTextPadding);
      }
 else {
        canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      }
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : (baseColor & 0x00ffffff | 0x44000000),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int distance=floatingLabelPadding;
    int floatingLabelStartY=(int)(innerPaddingTop + floatingLabelTextSize + floatingLabelPadding - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction) + getScrollY());
    int alpha=((int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (0.74f * focusFraction + 0.26f)* (floatingLabelTextColor != -1 ? 1 : Color.alpha(floatingLabelTextColor) / 256f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,floatingLabelStartY,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(isInternalValid() ? primaryColor : errorColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}"
54061,"@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=TextUtils.isEmpty(getText()) ? closeButtonBitmaps[0] : clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? getCurrentHintTextColor() : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : getCurrentHintTextColor());
      canvas.save();
      canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : getCurrentHintTextColor(),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=(int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (0.74f * focusFraction + 0.26f));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=TextUtils.isEmpty(getText()) ? closeButtonBitmaps[0] : clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? getCurrentHintTextColor() : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : getCurrentHintTextColor());
      canvas.save();
      canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : getCurrentHintTextColor(),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=(int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (floatingLabelTextColor != -1 ? 1 : (0.74f * focusFraction + 0.26f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}"
54062,"@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=TextUtils.isEmpty(getText()) ? closeButtonBitmaps[0] : clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? getCurrentHintTextColor() : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : getCurrentHintTextColor());
      canvas.save();
      canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : getCurrentHintTextColor(),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=(int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (0.74f * focusFraction + 0.26f));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=TextUtils.isEmpty(getText()) ? closeButtonBitmaps[0] : clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? getCurrentHintTextColor() : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : getCurrentHintTextColor());
      canvas.save();
      canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : getCurrentHintTextColor(),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=(int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (floatingLabelTextColor != -1 ? 1 : (0.74f * focusFraction + 0.26f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}"
54063,"@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=TextUtils.isEmpty(getText()) ? closeButtonBitmaps[0] : clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? getCurrentHintTextColor() : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : getCurrentHintTextColor());
      canvas.save();
      canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : getCurrentHintTextColor(),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=(int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (0.74f * focusFraction + 0.26f));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=TextUtils.isEmpty(getText()) ? closeButtonBitmaps[0] : clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? getCurrentHintTextColor() : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : getCurrentHintTextColor());
      canvas.save();
      canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : getCurrentHintTextColor(),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=(int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (floatingLabelTextColor != -1 ? 1 : (0.74f * focusFraction + 0.26f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}"
54064,"private void resetTextColor(){
  if (textColorStateList == null) {
    textColorStateList=new ColorStateList(new int[][]{new int[]{android.R.attr.state_enabled},EMPTY_STATE_SET},new int[]{baseColor & 0x00ffffff | 0xdf000000,baseColor & 0x00ffffff | 0x44000000});
    super.setTextColor(textColorStateList);
  }
}","private void resetTextColor(){
  if (textColorStateList == null) {
    textColorStateList=new ColorStateList(new int[][]{new int[]{android.R.attr.state_enabled},EMPTY_STATE_SET},new int[]{baseColor & 0x00ffffff | 0xdf000000,baseColor & 0x00ffffff | 0x44000000});
    setTextColor(textColorStateList);
  }
 else {
    setTextColor(textColorStateList);
  }
}"
54065,"private void resetTextColor(){
  if (textColorStateList == null) {
    textColorStateList=new ColorStateList(new int[][]{new int[]{android.R.attr.state_enabled},EMPTY_STATE_SET},new int[]{baseColor & 0x00ffffff | 0xdf000000,baseColor & 0x00ffffff | 0x44000000});
    setTextColor(textColorStateList);
  }
}","private void resetTextColor(){
  if (textColorStateList == null) {
    textColorStateList=new ColorStateList(new int[][]{new int[]{android.R.attr.state_enabled},EMPTY_STATE_SET},new int[]{baseColor & 0x00ffffff | 0xdf000000,baseColor & 0x00ffffff | 0x44000000});
    setTextColor(textColorStateList);
  }
 else {
    setTextColor(textColorStateList);
  }
}"
54066,"private void resetTextColor(){
  if (textColorStateList == null) {
    textColorStateList=new ColorStateList(new int[][]{new int[]{android.R.attr.state_enabled},EMPTY_STATE_SET},new int[]{baseColor & 0x00ffffff | 0xdf000000,baseColor & 0x00ffffff | 0x44000000});
    super.setTextColor(textColorStateList);
  }
}","private void resetTextColor(){
  if (textColorStateList == null) {
    textColorStateList=new ColorStateList(new int[][]{new int[]{android.R.attr.state_enabled},EMPTY_STATE_SET},new int[]{baseColor & 0x00ffffff | 0xdf000000,baseColor & 0x00ffffff | 0x44000000});
    setTextColor(textColorStateList);
  }
 else {
    setTextColor(textColorStateList);
  }
}"
54067,"@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=TextUtils.isEmpty(getText()) ? closeButtonBitmaps[0] : clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? getCurrentHintTextColor() : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : getCurrentHintTextColor());
      canvas.save();
      canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : getCurrentHintTextColor(),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=(int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (floatingLabelTextColor != -1 ? 1 : (0.74f * focusFraction + 0.26f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=TextUtils.isEmpty(getText()) ? closeButtonBitmaps[0] : clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? (baseColor & 0x00ffffff | 0x44000000) : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : (baseColor & 0x00ffffff | 0x44000000));
      canvas.save();
      canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : (baseColor & 0x00ffffff | 0x44000000),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=(int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (floatingLabelTextColor != -1 ? 1 : (0.74f * focusFraction + 0.26f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}"
54068,"@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=TextUtils.isEmpty(getText()) ? closeButtonBitmaps[0] : clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? getCurrentHintTextColor() : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : getCurrentHintTextColor());
      canvas.save();
      canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : getCurrentHintTextColor(),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=(int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (floatingLabelTextColor != -1 ? 1 : (0.74f * focusFraction + 0.26f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=TextUtils.isEmpty(getText()) ? closeButtonBitmaps[0] : clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? (baseColor & 0x00ffffff | 0x44000000) : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : (baseColor & 0x00ffffff | 0x44000000));
      canvas.save();
      canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : (baseColor & 0x00ffffff | 0x44000000),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=(int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (floatingLabelTextColor != -1 ? 1 : (0.74f * focusFraction + 0.26f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}"
54069,"@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=TextUtils.isEmpty(getText()) ? closeButtonBitmaps[0] : clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? getCurrentHintTextColor() : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : getCurrentHintTextColor());
      canvas.save();
      canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : getCurrentHintTextColor(),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=(int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (floatingLabelTextColor != -1 ? 1 : (0.74f * focusFraction + 0.26f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (hasFocus() && showClearButton) {
    paint.setAlpha(255);
    int buttonLeft;
    if (isRTL()) {
      buttonLeft=startX;
    }
 else {
      buttonLeft=endX - iconOuterWidth;
    }
    Bitmap clearButtonBitmap=TextUtils.isEmpty(getText()) ? closeButtonBitmaps[0] : clearButtonBitmaps[0];
    buttonLeft+=(iconOuterWidth - clearButtonBitmap.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - clearButtonBitmap.getHeight()) / 2;
    canvas.drawBitmap(clearButtonBitmap,buttonLeft,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(underlineColor != -1 ? underlineColor : baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? (baseColor & 0x00ffffff | 0x44000000) : errorColor);
    String charactersCounterText=getCharactersCounterText();
    canvas.drawText(charactersCounterText,isRTL() ? startX : endX - textPaint.measureText(charactersCounterText),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || ((helperTextAlwaysShown || hasFocus()) && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : (baseColor & 0x00ffffff | 0x44000000));
      canvas.save();
      canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,floatingLabelTextColor != -1 ? floatingLabelTextColor : (baseColor & 0x00ffffff | 0x44000000),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelPadding;
    int distance=floatingLabelPadding;
    int position=(int)(floatingLabelStartY - distance * (floatingLabelAlwaysShown ? 1 : floatingLabelFraction));
    int alpha=(int)((floatingLabelAlwaysShown ? 1 : floatingLabelFraction) * 0xff * (floatingLabelTextColor != -1 ? 1 : (0.74f * focusFraction + 0.26f)));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}"
54070,"public void setBaseColor(int color,ColorStateList textColorStateList,ColorStateList textColorHintStateList){
  if (baseColor != color) {
    baseColor=color;
  }
  if (textColorStateList == null) {
    textColorStateList=new ColorStateList(new int[][]{new int[]{android.R.attr.state_enabled},EMPTY_STATE_SET},new int[]{baseColor & 0x00ffffff | 0xdf000000,baseColor & 0x00ffffff | 0x44000000});
    setTextColor(textColorStateList);
  }
  if (textColorHintStateList == null) {
    setHintTextColor(baseColor & 0x00ffffff | 0x44000000);
  }
 else {
    setHintTextColor(textColorHintStateList);
  }
  postInvalidate();
}","public void setBaseColor(int color){
  if (baseColor != color) {
    baseColor=color;
  }
  resetTextColor();
  resetHintTextColor();
  postInvalidate();
}"
54071,"private void init(Context context,AttributeSet attrs){
  iconSize=getPixel(32);
  iconOuterWidth=getPixel(48);
  iconOuterHeight=getPixel(32);
  bottomSpacing=getResources().getDimensionPixelSize(R.dimen.inner_components_spacing);
  bottomEllipsisSize=getResources().getDimensionPixelSize(R.dimen.bottom_ellipsis_height);
  int[] textColorsAttrs=new int[]{android.R.attr.textColor,android.R.attr.textColorHint};
  TypedArray textColorsTypedArray=context.obtainStyledAttributes(attrs,textColorsAttrs);
  ColorStateList textColorStateList=textColorsTypedArray.getColorStateList(0);
  ColorStateList textColorHintStateList=textColorsTypedArray.getColorStateList(1);
  textColorsTypedArray.recycle();
  int defaultBaseColor;
  TypedValue baseColorTypedValue=new TypedValue();
  context.getTheme().resolveAttribute(android.R.attr.windowBackground,baseColorTypedValue,true);
  defaultBaseColor=Colors.getBaseColor(baseColorTypedValue.data);
  TypedArray typedArray=context.obtainStyledAttributes(attrs,R.styleable.MaterialEditText);
  baseColor=typedArray.getColor(R.styleable.MaterialEditText_met_baseColor,defaultBaseColor);
  setBaseColor(baseColor,textColorStateList,textColorHintStateList);
  int defaultPrimaryColor;
  TypedValue primaryColorTypedValue=new TypedValue();
  try {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      context.getTheme().resolveAttribute(android.R.attr.colorPrimary,primaryColorTypedValue,true);
      defaultPrimaryColor=primaryColorTypedValue.data;
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    try {
      int colorPrimaryId=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",getContext().getPackageName());
      if (colorPrimaryId != 0) {
        context.getTheme().resolveAttribute(colorPrimaryId,primaryColorTypedValue,true);
        defaultPrimaryColor=primaryColorTypedValue.data;
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
 catch (    Exception e1) {
      defaultPrimaryColor=baseColor;
    }
  }
  primaryColor=typedArray.getColor(R.styleable.MaterialEditText_met_primaryColor,defaultPrimaryColor);
  setFloatingLabelInternal(typedArray.getInt(R.styleable.MaterialEditText_met_floatingLabel,0));
  errorColor=typedArray.getColor(R.styleable.MaterialEditText_met_errorColor,Color.parseColor(""String_Node_Str""));
  minCharacters=typedArray.getInt(R.styleable.MaterialEditText_met_minCharacters,0);
  maxCharacters=typedArray.getInt(R.styleable.MaterialEditText_met_maxCharacters,0);
  singleLineEllipsis=typedArray.getBoolean(R.styleable.MaterialEditText_met_singleLineEllipsis,false);
  helperText=typedArray.getString(R.styleable.MaterialEditText_met_helperText);
  helperTextColor=typedArray.getColor(R.styleable.MaterialEditText_met_helperTextColor,-1);
  minBottomTextLines=typedArray.getInt(R.styleable.MaterialEditText_met_minBottomTextLines,0);
  String fontPathForAccent=typedArray.getString(R.styleable.MaterialEditText_met_accentTypeface);
  if (fontPathForAccent != null && !isInEditMode()) {
    accentTypeface=getCustomTypeface(fontPathForAccent);
    textPaint.setTypeface(accentTypeface);
  }
  String fontPathForView=typedArray.getString(R.styleable.MaterialEditText_met_typeface);
  if (fontPathForView != null && !isInEditMode()) {
    typeface=getCustomTypeface(fontPathForView);
    setTypeface(typeface);
  }
  floatingLabelText=typedArray.getString(R.styleable.MaterialEditText_met_floatingLabelText);
  if (floatingLabelText == null) {
    floatingLabelText=getHint();
  }
  floatingLabelSpacing=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_floatingLabelSpacing,bottomSpacing);
  floatingLabelTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_floatingLabelTextSize,getResources().getDimensionPixelSize(R.dimen.floating_label_text_size));
  floatingLabelTextColor=typedArray.getColor(R.styleable.MaterialEditText_met_floatingLabelTextColor,-1);
  bottomTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_bottomTextSize,getResources().getDimensionPixelSize(R.dimen.bottom_text_size));
  hideUnderline=typedArray.getBoolean(R.styleable.MaterialEditText_met_hideUnderline,false);
  underlineColor=typedArray.getColor(R.styleable.MaterialEditText_met_underlineColor,-1);
  autoValidate=typedArray.getBoolean(R.styleable.MaterialEditText_met_autoValidate,false);
  iconLeftBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_met_iconLeft,-1));
  iconRightBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_met_iconRight,-1));
  showClearButton=typedArray.getBoolean(R.styleable.MaterialEditText_met_clearButton,false);
  clearButtonBitmaps=generateIconBitmaps(R.drawable.met_ic_clear);
  closeButtonBitmaps=generateIconBitmaps(R.drawable.met_ic_close);
  iconPadding=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_iconPadding,getPixel(16));
  floatingLabelAlwaysShown=typedArray.getBoolean(R.styleable.MaterialEditText_met_floatingLabelAlwaysShown,false);
  helperTextAlwaysShown=typedArray.getBoolean(R.styleable.MaterialEditText_met_helperTextAlwaysShown,false);
  typedArray.recycle();
  int[] paddings=new int[]{android.R.attr.padding,android.R.attr.paddingLeft,android.R.attr.paddingTop,android.R.attr.paddingRight,android.R.attr.paddingBottom};
  TypedArray paddingsTypedArray=context.obtainStyledAttributes(attrs,paddings);
  int padding=paddingsTypedArray.getDimensionPixelSize(0,0);
  innerPaddingLeft=paddingsTypedArray.getDimensionPixelSize(1,padding);
  innerPaddingTop=paddingsTypedArray.getDimensionPixelSize(2,padding);
  innerPaddingRight=paddingsTypedArray.getDimensionPixelSize(3,padding);
  innerPaddingBottom=paddingsTypedArray.getDimensionPixelSize(4,padding);
  paddingsTypedArray.recycle();
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
    setBackground(null);
  }
 else {
    setBackgroundDrawable(null);
  }
  if (singleLineEllipsis) {
    TransformationMethod transformationMethod=getTransformationMethod();
    setSingleLine();
    setTransformationMethod(transformationMethod);
  }
  initMinBottomLines();
  initPadding();
  initText(textColorHintStateList);
  initFloatingLabel();
  initTextWatcher();
  checkCharactersCount();
}","private void init(Context context,AttributeSet attrs){
  iconSize=getPixel(32);
  iconOuterWidth=getPixel(48);
  iconOuterHeight=getPixel(32);
  bottomSpacing=getResources().getDimensionPixelSize(R.dimen.inner_components_spacing);
  bottomEllipsisSize=getResources().getDimensionPixelSize(R.dimen.bottom_ellipsis_height);
  int[] textColorsAttrs=new int[]{android.R.attr.textColor,android.R.attr.textColorHint};
  TypedArray textColorsTypedArray=context.obtainStyledAttributes(attrs,textColorsAttrs);
  textColorStateList=textColorsTypedArray.getColorStateList(0);
  textColorHintStateList=textColorsTypedArray.getColorStateList(1);
  textColorsTypedArray.recycle();
  int defaultBaseColor;
  TypedValue baseColorTypedValue=new TypedValue();
  context.getTheme().resolveAttribute(android.R.attr.windowBackground,baseColorTypedValue,true);
  defaultBaseColor=Colors.getBaseColor(baseColorTypedValue.data);
  TypedArray typedArray=context.obtainStyledAttributes(attrs,R.styleable.MaterialEditText);
  setBaseColor(typedArray.getColor(R.styleable.MaterialEditText_met_baseColor,defaultBaseColor));
  int defaultPrimaryColor;
  TypedValue primaryColorTypedValue=new TypedValue();
  try {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      context.getTheme().resolveAttribute(android.R.attr.colorPrimary,primaryColorTypedValue,true);
      defaultPrimaryColor=primaryColorTypedValue.data;
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    try {
      int colorPrimaryId=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",getContext().getPackageName());
      if (colorPrimaryId != 0) {
        context.getTheme().resolveAttribute(colorPrimaryId,primaryColorTypedValue,true);
        defaultPrimaryColor=primaryColorTypedValue.data;
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
 catch (    Exception e1) {
      defaultPrimaryColor=baseColor;
    }
  }
  primaryColor=typedArray.getColor(R.styleable.MaterialEditText_met_primaryColor,defaultPrimaryColor);
  setFloatingLabelInternal(typedArray.getInt(R.styleable.MaterialEditText_met_floatingLabel,0));
  errorColor=typedArray.getColor(R.styleable.MaterialEditText_met_errorColor,Color.parseColor(""String_Node_Str""));
  minCharacters=typedArray.getInt(R.styleable.MaterialEditText_met_minCharacters,0);
  maxCharacters=typedArray.getInt(R.styleable.MaterialEditText_met_maxCharacters,0);
  singleLineEllipsis=typedArray.getBoolean(R.styleable.MaterialEditText_met_singleLineEllipsis,false);
  helperText=typedArray.getString(R.styleable.MaterialEditText_met_helperText);
  helperTextColor=typedArray.getColor(R.styleable.MaterialEditText_met_helperTextColor,-1);
  minBottomTextLines=typedArray.getInt(R.styleable.MaterialEditText_met_minBottomTextLines,0);
  String fontPathForAccent=typedArray.getString(R.styleable.MaterialEditText_met_accentTypeface);
  if (fontPathForAccent != null && !isInEditMode()) {
    accentTypeface=getCustomTypeface(fontPathForAccent);
    textPaint.setTypeface(accentTypeface);
  }
  String fontPathForView=typedArray.getString(R.styleable.MaterialEditText_met_typeface);
  if (fontPathForView != null && !isInEditMode()) {
    typeface=getCustomTypeface(fontPathForView);
    setTypeface(typeface);
  }
  floatingLabelText=typedArray.getString(R.styleable.MaterialEditText_met_floatingLabelText);
  if (floatingLabelText == null) {
    floatingLabelText=getHint();
  }
  floatingLabelSpacing=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_floatingLabelSpacing,bottomSpacing);
  floatingLabelTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_floatingLabelTextSize,getResources().getDimensionPixelSize(R.dimen.floating_label_text_size));
  floatingLabelTextColor=typedArray.getColor(R.styleable.MaterialEditText_met_floatingLabelTextColor,-1);
  bottomTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_bottomTextSize,getResources().getDimensionPixelSize(R.dimen.bottom_text_size));
  hideUnderline=typedArray.getBoolean(R.styleable.MaterialEditText_met_hideUnderline,false);
  underlineColor=typedArray.getColor(R.styleable.MaterialEditText_met_underlineColor,-1);
  autoValidate=typedArray.getBoolean(R.styleable.MaterialEditText_met_autoValidate,false);
  iconLeftBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_met_iconLeft,-1));
  iconRightBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_met_iconRight,-1));
  showClearButton=typedArray.getBoolean(R.styleable.MaterialEditText_met_clearButton,false);
  clearButtonBitmaps=generateIconBitmaps(R.drawable.met_ic_clear);
  closeButtonBitmaps=generateIconBitmaps(R.drawable.met_ic_close);
  iconPadding=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_iconPadding,getPixel(16));
  floatingLabelAlwaysShown=typedArray.getBoolean(R.styleable.MaterialEditText_met_floatingLabelAlwaysShown,false);
  helperTextAlwaysShown=typedArray.getBoolean(R.styleable.MaterialEditText_met_helperTextAlwaysShown,false);
  typedArray.recycle();
  int[] paddings=new int[]{android.R.attr.padding,android.R.attr.paddingLeft,android.R.attr.paddingTop,android.R.attr.paddingRight,android.R.attr.paddingBottom};
  TypedArray paddingsTypedArray=context.obtainStyledAttributes(attrs,paddings);
  int padding=paddingsTypedArray.getDimensionPixelSize(0,0);
  innerPaddingLeft=paddingsTypedArray.getDimensionPixelSize(1,padding);
  innerPaddingTop=paddingsTypedArray.getDimensionPixelSize(2,padding);
  innerPaddingRight=paddingsTypedArray.getDimensionPixelSize(3,padding);
  innerPaddingBottom=paddingsTypedArray.getDimensionPixelSize(4,padding);
  paddingsTypedArray.recycle();
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
    setBackground(null);
  }
 else {
    setBackgroundDrawable(null);
  }
  if (singleLineEllipsis) {
    TransformationMethod transformationMethod=getTransformationMethod();
    setSingleLine();
    setTransformationMethod(transformationMethod);
  }
  initMinBottomLines();
  initPadding();
  initText();
  initFloatingLabel();
  initTextWatcher();
  checkCharactersCount();
}"
54072,"private void initText(ColorStateList textColorHintStateList){
  if (!TextUtils.isEmpty(getText())) {
    CharSequence text=getText();
    setText(null);
    if (textColorHintStateList != null) {
      setHintTextColor(textColorHintStateList);
    }
 else {
      setHintTextColor(baseColor & 0x00ffffff | 0x44000000);
    }
    setText(text);
    setSelection(text.length());
    floatingLabelFraction=1;
    floatingLabelShown=true;
  }
 else {
    if (textColorHintStateList != null) {
      setHintTextColor(textColorHintStateList);
    }
 else {
      setHintTextColor(baseColor & 0x00ffffff | 0x44000000);
    }
  }
}","private void initText(){
  if (!TextUtils.isEmpty(getText())) {
    CharSequence text=getText();
    setText(null);
    if (textColorHintStateList != null) {
      setHintTextColor(textColorHintStateList);
    }
 else {
      setHintTextColor(baseColor & 0x00ffffff | 0x44000000);
    }
    setText(text);
    setSelection(text.length());
    floatingLabelFraction=1;
    floatingLabelShown=true;
  }
 else {
    if (textColorHintStateList != null) {
      setHintTextColor(textColorHintStateList);
    }
 else {
      setHintTextColor(baseColor & 0x00ffffff | 0x44000000);
    }
  }
}"
54073,"public void setBaseColor(int color,ColorStateList textColorStateList,ColorStateList textColorHintStateList){
  if (baseColor != color) {
    baseColor=color;
  }
  if (textColorStateList == null) {
    textColorStateList=new ColorStateList(new int[][]{new int[]{android.R.attr.state_enabled},EMPTY_STATE_SET},new int[]{baseColor & 0x00ffffff | 0xdf000000,baseColor & 0x00ffffff | 0x44000000});
    setTextColor(textColorStateList);
  }
  if (textColorHintStateList == null) {
    setHintTextColor(baseColor & 0x00ffffff | 0x44000000);
  }
 else {
    setHintTextColor(textColorHintStateList);
  }
  postInvalidate();
}","public void setBaseColor(int color){
  if (baseColor != color) {
    baseColor=color;
  }
  resetTextColor();
  resetHintTextColor();
  postInvalidate();
}"
54074,"private void init(Context context,AttributeSet attrs){
  iconSize=getPixel(32);
  iconOuterWidth=getPixel(48);
  iconOuterHeight=getPixel(32);
  bottomSpacing=getResources().getDimensionPixelSize(R.dimen.inner_components_spacing);
  bottomEllipsisSize=getResources().getDimensionPixelSize(R.dimen.bottom_ellipsis_height);
  int[] textColorsAttrs=new int[]{android.R.attr.textColor,android.R.attr.textColorHint};
  TypedArray textColorsTypedArray=context.obtainStyledAttributes(attrs,textColorsAttrs);
  ColorStateList textColorStateList=textColorsTypedArray.getColorStateList(0);
  ColorStateList textColorHintStateList=textColorsTypedArray.getColorStateList(1);
  textColorsTypedArray.recycle();
  int defaultBaseColor;
  TypedValue baseColorTypedValue=new TypedValue();
  context.getTheme().resolveAttribute(android.R.attr.windowBackground,baseColorTypedValue,true);
  defaultBaseColor=Colors.getBaseColor(baseColorTypedValue.data);
  TypedArray typedArray=context.obtainStyledAttributes(attrs,R.styleable.MaterialEditText);
  baseColor=typedArray.getColor(R.styleable.MaterialEditText_met_baseColor,defaultBaseColor);
  setBaseColor(baseColor,textColorStateList,textColorHintStateList);
  int defaultPrimaryColor;
  TypedValue primaryColorTypedValue=new TypedValue();
  try {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      context.getTheme().resolveAttribute(android.R.attr.colorPrimary,primaryColorTypedValue,true);
      defaultPrimaryColor=primaryColorTypedValue.data;
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    try {
      int colorPrimaryId=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",getContext().getPackageName());
      if (colorPrimaryId != 0) {
        context.getTheme().resolveAttribute(colorPrimaryId,primaryColorTypedValue,true);
        defaultPrimaryColor=primaryColorTypedValue.data;
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
 catch (    Exception e1) {
      defaultPrimaryColor=baseColor;
    }
  }
  primaryColor=typedArray.getColor(R.styleable.MaterialEditText_met_primaryColor,defaultPrimaryColor);
  setFloatingLabelInternal(typedArray.getInt(R.styleable.MaterialEditText_met_floatingLabel,0));
  errorColor=typedArray.getColor(R.styleable.MaterialEditText_met_errorColor,Color.parseColor(""String_Node_Str""));
  minCharacters=typedArray.getInt(R.styleable.MaterialEditText_met_minCharacters,0);
  maxCharacters=typedArray.getInt(R.styleable.MaterialEditText_met_maxCharacters,0);
  singleLineEllipsis=typedArray.getBoolean(R.styleable.MaterialEditText_met_singleLineEllipsis,false);
  helperText=typedArray.getString(R.styleable.MaterialEditText_met_helperText);
  helperTextColor=typedArray.getColor(R.styleable.MaterialEditText_met_helperTextColor,-1);
  minBottomTextLines=typedArray.getInt(R.styleable.MaterialEditText_met_minBottomTextLines,0);
  String fontPathForAccent=typedArray.getString(R.styleable.MaterialEditText_met_accentTypeface);
  if (fontPathForAccent != null && !isInEditMode()) {
    accentTypeface=getCustomTypeface(fontPathForAccent);
    textPaint.setTypeface(accentTypeface);
  }
  String fontPathForView=typedArray.getString(R.styleable.MaterialEditText_met_typeface);
  if (fontPathForView != null && !isInEditMode()) {
    typeface=getCustomTypeface(fontPathForView);
    setTypeface(typeface);
  }
  floatingLabelText=typedArray.getString(R.styleable.MaterialEditText_met_floatingLabelText);
  if (floatingLabelText == null) {
    floatingLabelText=getHint();
  }
  floatingLabelSpacing=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_floatingLabelSpacing,bottomSpacing);
  floatingLabelTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_floatingLabelTextSize,getResources().getDimensionPixelSize(R.dimen.floating_label_text_size));
  floatingLabelTextColor=typedArray.getColor(R.styleable.MaterialEditText_met_floatingLabelTextColor,-1);
  bottomTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_bottomTextSize,getResources().getDimensionPixelSize(R.dimen.bottom_text_size));
  hideUnderline=typedArray.getBoolean(R.styleable.MaterialEditText_met_hideUnderline,false);
  underlineColor=typedArray.getColor(R.styleable.MaterialEditText_met_underlineColor,-1);
  autoValidate=typedArray.getBoolean(R.styleable.MaterialEditText_met_autoValidate,false);
  iconLeftBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_met_iconLeft,-1));
  iconRightBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_met_iconRight,-1));
  showClearButton=typedArray.getBoolean(R.styleable.MaterialEditText_met_clearButton,false);
  clearButtonBitmaps=generateIconBitmaps(R.drawable.met_ic_clear);
  closeButtonBitmaps=generateIconBitmaps(R.drawable.met_ic_close);
  iconPadding=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_iconPadding,getPixel(16));
  floatingLabelAlwaysShown=typedArray.getBoolean(R.styleable.MaterialEditText_met_floatingLabelAlwaysShown,false);
  helperTextAlwaysShown=typedArray.getBoolean(R.styleable.MaterialEditText_met_helperTextAlwaysShown,false);
  typedArray.recycle();
  int[] paddings=new int[]{android.R.attr.padding,android.R.attr.paddingLeft,android.R.attr.paddingTop,android.R.attr.paddingRight,android.R.attr.paddingBottom};
  TypedArray paddingsTypedArray=context.obtainStyledAttributes(attrs,paddings);
  int padding=paddingsTypedArray.getDimensionPixelSize(0,0);
  innerPaddingLeft=paddingsTypedArray.getDimensionPixelSize(1,padding);
  innerPaddingTop=paddingsTypedArray.getDimensionPixelSize(2,padding);
  innerPaddingRight=paddingsTypedArray.getDimensionPixelSize(3,padding);
  innerPaddingBottom=paddingsTypedArray.getDimensionPixelSize(4,padding);
  paddingsTypedArray.recycle();
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
    setBackground(null);
  }
 else {
    setBackgroundDrawable(null);
  }
  if (singleLineEllipsis) {
    TransformationMethod transformationMethod=getTransformationMethod();
    setSingleLine();
    setTransformationMethod(transformationMethod);
  }
  initMinBottomLines();
  initPadding();
  initText(textColorHintStateList);
  initFloatingLabel();
  initTextWatcher();
  checkCharactersCount();
}","private void init(Context context,AttributeSet attrs){
  iconSize=getPixel(32);
  iconOuterWidth=getPixel(48);
  iconOuterHeight=getPixel(32);
  bottomSpacing=getResources().getDimensionPixelSize(R.dimen.inner_components_spacing);
  bottomEllipsisSize=getResources().getDimensionPixelSize(R.dimen.bottom_ellipsis_height);
  int[] textColorsAttrs=new int[]{android.R.attr.textColor,android.R.attr.textColorHint};
  TypedArray textColorsTypedArray=context.obtainStyledAttributes(attrs,textColorsAttrs);
  textColorStateList=textColorsTypedArray.getColorStateList(0);
  textColorHintStateList=textColorsTypedArray.getColorStateList(1);
  textColorsTypedArray.recycle();
  int defaultBaseColor;
  TypedValue baseColorTypedValue=new TypedValue();
  context.getTheme().resolveAttribute(android.R.attr.windowBackground,baseColorTypedValue,true);
  defaultBaseColor=Colors.getBaseColor(baseColorTypedValue.data);
  TypedArray typedArray=context.obtainStyledAttributes(attrs,R.styleable.MaterialEditText);
  setBaseColor(typedArray.getColor(R.styleable.MaterialEditText_met_baseColor,defaultBaseColor));
  int defaultPrimaryColor;
  TypedValue primaryColorTypedValue=new TypedValue();
  try {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      context.getTheme().resolveAttribute(android.R.attr.colorPrimary,primaryColorTypedValue,true);
      defaultPrimaryColor=primaryColorTypedValue.data;
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    try {
      int colorPrimaryId=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",getContext().getPackageName());
      if (colorPrimaryId != 0) {
        context.getTheme().resolveAttribute(colorPrimaryId,primaryColorTypedValue,true);
        defaultPrimaryColor=primaryColorTypedValue.data;
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
 catch (    Exception e1) {
      defaultPrimaryColor=baseColor;
    }
  }
  primaryColor=typedArray.getColor(R.styleable.MaterialEditText_met_primaryColor,defaultPrimaryColor);
  setFloatingLabelInternal(typedArray.getInt(R.styleable.MaterialEditText_met_floatingLabel,0));
  errorColor=typedArray.getColor(R.styleable.MaterialEditText_met_errorColor,Color.parseColor(""String_Node_Str""));
  minCharacters=typedArray.getInt(R.styleable.MaterialEditText_met_minCharacters,0);
  maxCharacters=typedArray.getInt(R.styleable.MaterialEditText_met_maxCharacters,0);
  singleLineEllipsis=typedArray.getBoolean(R.styleable.MaterialEditText_met_singleLineEllipsis,false);
  helperText=typedArray.getString(R.styleable.MaterialEditText_met_helperText);
  helperTextColor=typedArray.getColor(R.styleable.MaterialEditText_met_helperTextColor,-1);
  minBottomTextLines=typedArray.getInt(R.styleable.MaterialEditText_met_minBottomTextLines,0);
  String fontPathForAccent=typedArray.getString(R.styleable.MaterialEditText_met_accentTypeface);
  if (fontPathForAccent != null && !isInEditMode()) {
    accentTypeface=getCustomTypeface(fontPathForAccent);
    textPaint.setTypeface(accentTypeface);
  }
  String fontPathForView=typedArray.getString(R.styleable.MaterialEditText_met_typeface);
  if (fontPathForView != null && !isInEditMode()) {
    typeface=getCustomTypeface(fontPathForView);
    setTypeface(typeface);
  }
  floatingLabelText=typedArray.getString(R.styleable.MaterialEditText_met_floatingLabelText);
  if (floatingLabelText == null) {
    floatingLabelText=getHint();
  }
  floatingLabelSpacing=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_floatingLabelSpacing,bottomSpacing);
  floatingLabelTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_floatingLabelTextSize,getResources().getDimensionPixelSize(R.dimen.floating_label_text_size));
  floatingLabelTextColor=typedArray.getColor(R.styleable.MaterialEditText_met_floatingLabelTextColor,-1);
  bottomTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_bottomTextSize,getResources().getDimensionPixelSize(R.dimen.bottom_text_size));
  hideUnderline=typedArray.getBoolean(R.styleable.MaterialEditText_met_hideUnderline,false);
  underlineColor=typedArray.getColor(R.styleable.MaterialEditText_met_underlineColor,-1);
  autoValidate=typedArray.getBoolean(R.styleable.MaterialEditText_met_autoValidate,false);
  iconLeftBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_met_iconLeft,-1));
  iconRightBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_met_iconRight,-1));
  showClearButton=typedArray.getBoolean(R.styleable.MaterialEditText_met_clearButton,false);
  clearButtonBitmaps=generateIconBitmaps(R.drawable.met_ic_clear);
  closeButtonBitmaps=generateIconBitmaps(R.drawable.met_ic_close);
  iconPadding=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_iconPadding,getPixel(16));
  floatingLabelAlwaysShown=typedArray.getBoolean(R.styleable.MaterialEditText_met_floatingLabelAlwaysShown,false);
  helperTextAlwaysShown=typedArray.getBoolean(R.styleable.MaterialEditText_met_helperTextAlwaysShown,false);
  typedArray.recycle();
  int[] paddings=new int[]{android.R.attr.padding,android.R.attr.paddingLeft,android.R.attr.paddingTop,android.R.attr.paddingRight,android.R.attr.paddingBottom};
  TypedArray paddingsTypedArray=context.obtainStyledAttributes(attrs,paddings);
  int padding=paddingsTypedArray.getDimensionPixelSize(0,0);
  innerPaddingLeft=paddingsTypedArray.getDimensionPixelSize(1,padding);
  innerPaddingTop=paddingsTypedArray.getDimensionPixelSize(2,padding);
  innerPaddingRight=paddingsTypedArray.getDimensionPixelSize(3,padding);
  innerPaddingBottom=paddingsTypedArray.getDimensionPixelSize(4,padding);
  paddingsTypedArray.recycle();
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
    setBackground(null);
  }
 else {
    setBackgroundDrawable(null);
  }
  if (singleLineEllipsis) {
    TransformationMethod transformationMethod=getTransformationMethod();
    setSingleLine();
    setTransformationMethod(transformationMethod);
  }
  initMinBottomLines();
  initPadding();
  initText();
  initFloatingLabel();
  initTextWatcher();
  checkCharactersCount();
}"
54075,"private void initText(ColorStateList textColorHintStateList){
  if (!TextUtils.isEmpty(getText())) {
    CharSequence text=getText();
    setText(null);
    if (textColorHintStateList != null) {
      setHintTextColor(textColorHintStateList);
    }
 else {
      setHintTextColor(baseColor & 0x00ffffff | 0x44000000);
    }
    setText(text);
    setSelection(text.length());
    floatingLabelFraction=1;
    floatingLabelShown=true;
  }
 else {
    if (textColorHintStateList != null) {
      setHintTextColor(textColorHintStateList);
    }
 else {
      setHintTextColor(baseColor & 0x00ffffff | 0x44000000);
    }
  }
}","private void initText(){
  if (!TextUtils.isEmpty(getText())) {
    CharSequence text=getText();
    setText(null);
    if (textColorHintStateList != null) {
      setHintTextColor(textColorHintStateList);
    }
 else {
      setHintTextColor(baseColor & 0x00ffffff | 0x44000000);
    }
    setText(text);
    setSelection(text.length());
    floatingLabelFraction=1;
    floatingLabelShown=true;
  }
 else {
    if (textColorHintStateList != null) {
      setHintTextColor(textColorHintStateList);
    }
 else {
      setHintTextColor(baseColor & 0x00ffffff | 0x44000000);
    }
  }
}"
54076,"public void setBaseColor(int color,ColorStateList textColorStateList,ColorStateList textColorHintStateList){
  if (baseColor != color) {
    baseColor=color;
  }
  if (textColorStateList == null) {
    textColorStateList=new ColorStateList(new int[][]{new int[]{android.R.attr.state_enabled},EMPTY_STATE_SET},new int[]{baseColor & 0x00ffffff | 0xdf000000,baseColor & 0x00ffffff | 0x44000000});
    setTextColor(textColorStateList);
  }
  if (textColorHintStateList == null) {
    setHintTextColor(baseColor & 0x00ffffff | 0x44000000);
  }
 else {
    setHintTextColor(textColorHintStateList);
  }
  postInvalidate();
}","public void setBaseColor(int color){
  if (baseColor != color) {
    baseColor=color;
  }
  resetTextColor();
  resetHintTextColor();
  postInvalidate();
}"
54077,"private void init(Context context,AttributeSet attrs){
  iconSize=getPixel(32);
  iconOuterWidth=getPixel(48);
  iconOuterHeight=getPixel(32);
  bottomSpacing=getResources().getDimensionPixelSize(R.dimen.inner_components_spacing);
  bottomEllipsisSize=getResources().getDimensionPixelSize(R.dimen.bottom_ellipsis_height);
  int[] textColorsAttrs=new int[]{android.R.attr.textColor,android.R.attr.textColorHint};
  TypedArray textColorsTypedArray=context.obtainStyledAttributes(attrs,textColorsAttrs);
  ColorStateList textColorStateList=textColorsTypedArray.getColorStateList(0);
  ColorStateList textColorHintStateList=textColorsTypedArray.getColorStateList(1);
  textColorsTypedArray.recycle();
  int defaultBaseColor;
  TypedValue baseColorTypedValue=new TypedValue();
  context.getTheme().resolveAttribute(android.R.attr.windowBackground,baseColorTypedValue,true);
  defaultBaseColor=Colors.getBaseColor(baseColorTypedValue.data);
  TypedArray typedArray=context.obtainStyledAttributes(attrs,R.styleable.MaterialEditText);
  baseColor=typedArray.getColor(R.styleable.MaterialEditText_met_baseColor,defaultBaseColor);
  setBaseColor(baseColor,textColorStateList,textColorHintStateList);
  int defaultPrimaryColor;
  TypedValue primaryColorTypedValue=new TypedValue();
  try {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      context.getTheme().resolveAttribute(android.R.attr.colorPrimary,primaryColorTypedValue,true);
      defaultPrimaryColor=primaryColorTypedValue.data;
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    try {
      int colorPrimaryId=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",getContext().getPackageName());
      if (colorPrimaryId != 0) {
        context.getTheme().resolveAttribute(colorPrimaryId,primaryColorTypedValue,true);
        defaultPrimaryColor=primaryColorTypedValue.data;
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
 catch (    Exception e1) {
      defaultPrimaryColor=baseColor;
    }
  }
  primaryColor=typedArray.getColor(R.styleable.MaterialEditText_met_primaryColor,defaultPrimaryColor);
  setFloatingLabelInternal(typedArray.getInt(R.styleable.MaterialEditText_met_floatingLabel,0));
  errorColor=typedArray.getColor(R.styleable.MaterialEditText_met_errorColor,Color.parseColor(""String_Node_Str""));
  minCharacters=typedArray.getInt(R.styleable.MaterialEditText_met_minCharacters,0);
  maxCharacters=typedArray.getInt(R.styleable.MaterialEditText_met_maxCharacters,0);
  singleLineEllipsis=typedArray.getBoolean(R.styleable.MaterialEditText_met_singleLineEllipsis,false);
  helperText=typedArray.getString(R.styleable.MaterialEditText_met_helperText);
  helperTextColor=typedArray.getColor(R.styleable.MaterialEditText_met_helperTextColor,-1);
  minBottomTextLines=typedArray.getInt(R.styleable.MaterialEditText_met_minBottomTextLines,0);
  String fontPathForAccent=typedArray.getString(R.styleable.MaterialEditText_met_accentTypeface);
  if (fontPathForAccent != null && !isInEditMode()) {
    accentTypeface=getCustomTypeface(fontPathForAccent);
    textPaint.setTypeface(accentTypeface);
  }
  String fontPathForView=typedArray.getString(R.styleable.MaterialEditText_met_typeface);
  if (fontPathForView != null && !isInEditMode()) {
    typeface=getCustomTypeface(fontPathForView);
    setTypeface(typeface);
  }
  floatingLabelText=typedArray.getString(R.styleable.MaterialEditText_met_floatingLabelText);
  if (floatingLabelText == null) {
    floatingLabelText=getHint();
  }
  floatingLabelSpacing=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_floatingLabelSpacing,bottomSpacing);
  floatingLabelTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_floatingLabelTextSize,getResources().getDimensionPixelSize(R.dimen.floating_label_text_size));
  floatingLabelTextColor=typedArray.getColor(R.styleable.MaterialEditText_met_floatingLabelTextColor,-1);
  bottomTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_bottomTextSize,getResources().getDimensionPixelSize(R.dimen.bottom_text_size));
  hideUnderline=typedArray.getBoolean(R.styleable.MaterialEditText_met_hideUnderline,false);
  underlineColor=typedArray.getColor(R.styleable.MaterialEditText_met_underlineColor,-1);
  autoValidate=typedArray.getBoolean(R.styleable.MaterialEditText_met_autoValidate,false);
  iconLeftBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_met_iconLeft,-1));
  iconRightBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_met_iconRight,-1));
  showClearButton=typedArray.getBoolean(R.styleable.MaterialEditText_met_clearButton,false);
  clearButtonBitmaps=generateIconBitmaps(R.drawable.met_ic_clear);
  closeButtonBitmaps=generateIconBitmaps(R.drawable.met_ic_close);
  iconPadding=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_iconPadding,getPixel(16));
  floatingLabelAlwaysShown=typedArray.getBoolean(R.styleable.MaterialEditText_met_floatingLabelAlwaysShown,false);
  helperTextAlwaysShown=typedArray.getBoolean(R.styleable.MaterialEditText_met_helperTextAlwaysShown,false);
  typedArray.recycle();
  int[] paddings=new int[]{android.R.attr.padding,android.R.attr.paddingLeft,android.R.attr.paddingTop,android.R.attr.paddingRight,android.R.attr.paddingBottom};
  TypedArray paddingsTypedArray=context.obtainStyledAttributes(attrs,paddings);
  int padding=paddingsTypedArray.getDimensionPixelSize(0,0);
  innerPaddingLeft=paddingsTypedArray.getDimensionPixelSize(1,padding);
  innerPaddingTop=paddingsTypedArray.getDimensionPixelSize(2,padding);
  innerPaddingRight=paddingsTypedArray.getDimensionPixelSize(3,padding);
  innerPaddingBottom=paddingsTypedArray.getDimensionPixelSize(4,padding);
  paddingsTypedArray.recycle();
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
    setBackground(null);
  }
 else {
    setBackgroundDrawable(null);
  }
  if (singleLineEllipsis) {
    TransformationMethod transformationMethod=getTransformationMethod();
    setSingleLine();
    setTransformationMethod(transformationMethod);
  }
  initMinBottomLines();
  initPadding();
  initText(textColorHintStateList);
  initFloatingLabel();
  initTextWatcher();
  checkCharactersCount();
}","private void init(Context context,AttributeSet attrs){
  iconSize=getPixel(32);
  iconOuterWidth=getPixel(48);
  iconOuterHeight=getPixel(32);
  bottomSpacing=getResources().getDimensionPixelSize(R.dimen.inner_components_spacing);
  bottomEllipsisSize=getResources().getDimensionPixelSize(R.dimen.bottom_ellipsis_height);
  int[] textColorsAttrs=new int[]{android.R.attr.textColor,android.R.attr.textColorHint};
  TypedArray textColorsTypedArray=context.obtainStyledAttributes(attrs,textColorsAttrs);
  textColorStateList=textColorsTypedArray.getColorStateList(0);
  textColorHintStateList=textColorsTypedArray.getColorStateList(1);
  textColorsTypedArray.recycle();
  int defaultBaseColor;
  TypedValue baseColorTypedValue=new TypedValue();
  context.getTheme().resolveAttribute(android.R.attr.windowBackground,baseColorTypedValue,true);
  defaultBaseColor=Colors.getBaseColor(baseColorTypedValue.data);
  TypedArray typedArray=context.obtainStyledAttributes(attrs,R.styleable.MaterialEditText);
  setBaseColor(typedArray.getColor(R.styleable.MaterialEditText_met_baseColor,defaultBaseColor));
  int defaultPrimaryColor;
  TypedValue primaryColorTypedValue=new TypedValue();
  try {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      context.getTheme().resolveAttribute(android.R.attr.colorPrimary,primaryColorTypedValue,true);
      defaultPrimaryColor=primaryColorTypedValue.data;
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    try {
      int colorPrimaryId=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",getContext().getPackageName());
      if (colorPrimaryId != 0) {
        context.getTheme().resolveAttribute(colorPrimaryId,primaryColorTypedValue,true);
        defaultPrimaryColor=primaryColorTypedValue.data;
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
 catch (    Exception e1) {
      defaultPrimaryColor=baseColor;
    }
  }
  primaryColor=typedArray.getColor(R.styleable.MaterialEditText_met_primaryColor,defaultPrimaryColor);
  setFloatingLabelInternal(typedArray.getInt(R.styleable.MaterialEditText_met_floatingLabel,0));
  errorColor=typedArray.getColor(R.styleable.MaterialEditText_met_errorColor,Color.parseColor(""String_Node_Str""));
  minCharacters=typedArray.getInt(R.styleable.MaterialEditText_met_minCharacters,0);
  maxCharacters=typedArray.getInt(R.styleable.MaterialEditText_met_maxCharacters,0);
  singleLineEllipsis=typedArray.getBoolean(R.styleable.MaterialEditText_met_singleLineEllipsis,false);
  helperText=typedArray.getString(R.styleable.MaterialEditText_met_helperText);
  helperTextColor=typedArray.getColor(R.styleable.MaterialEditText_met_helperTextColor,-1);
  minBottomTextLines=typedArray.getInt(R.styleable.MaterialEditText_met_minBottomTextLines,0);
  String fontPathForAccent=typedArray.getString(R.styleable.MaterialEditText_met_accentTypeface);
  if (fontPathForAccent != null && !isInEditMode()) {
    accentTypeface=getCustomTypeface(fontPathForAccent);
    textPaint.setTypeface(accentTypeface);
  }
  String fontPathForView=typedArray.getString(R.styleable.MaterialEditText_met_typeface);
  if (fontPathForView != null && !isInEditMode()) {
    typeface=getCustomTypeface(fontPathForView);
    setTypeface(typeface);
  }
  floatingLabelText=typedArray.getString(R.styleable.MaterialEditText_met_floatingLabelText);
  if (floatingLabelText == null) {
    floatingLabelText=getHint();
  }
  floatingLabelSpacing=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_floatingLabelSpacing,bottomSpacing);
  floatingLabelTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_floatingLabelTextSize,getResources().getDimensionPixelSize(R.dimen.floating_label_text_size));
  floatingLabelTextColor=typedArray.getColor(R.styleable.MaterialEditText_met_floatingLabelTextColor,-1);
  bottomTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_bottomTextSize,getResources().getDimensionPixelSize(R.dimen.bottom_text_size));
  hideUnderline=typedArray.getBoolean(R.styleable.MaterialEditText_met_hideUnderline,false);
  underlineColor=typedArray.getColor(R.styleable.MaterialEditText_met_underlineColor,-1);
  autoValidate=typedArray.getBoolean(R.styleable.MaterialEditText_met_autoValidate,false);
  iconLeftBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_met_iconLeft,-1));
  iconRightBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_met_iconRight,-1));
  showClearButton=typedArray.getBoolean(R.styleable.MaterialEditText_met_clearButton,false);
  clearButtonBitmaps=generateIconBitmaps(R.drawable.met_ic_clear);
  closeButtonBitmaps=generateIconBitmaps(R.drawable.met_ic_close);
  iconPadding=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_met_iconPadding,getPixel(16));
  floatingLabelAlwaysShown=typedArray.getBoolean(R.styleable.MaterialEditText_met_floatingLabelAlwaysShown,false);
  helperTextAlwaysShown=typedArray.getBoolean(R.styleable.MaterialEditText_met_helperTextAlwaysShown,false);
  typedArray.recycle();
  int[] paddings=new int[]{android.R.attr.padding,android.R.attr.paddingLeft,android.R.attr.paddingTop,android.R.attr.paddingRight,android.R.attr.paddingBottom};
  TypedArray paddingsTypedArray=context.obtainStyledAttributes(attrs,paddings);
  int padding=paddingsTypedArray.getDimensionPixelSize(0,0);
  innerPaddingLeft=paddingsTypedArray.getDimensionPixelSize(1,padding);
  innerPaddingTop=paddingsTypedArray.getDimensionPixelSize(2,padding);
  innerPaddingRight=paddingsTypedArray.getDimensionPixelSize(3,padding);
  innerPaddingBottom=paddingsTypedArray.getDimensionPixelSize(4,padding);
  paddingsTypedArray.recycle();
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
    setBackground(null);
  }
 else {
    setBackgroundDrawable(null);
  }
  if (singleLineEllipsis) {
    TransformationMethod transformationMethod=getTransformationMethod();
    setSingleLine();
    setTransformationMethod(transformationMethod);
  }
  initMinBottomLines();
  initPadding();
  initText();
  initFloatingLabel();
  initTextWatcher();
  checkCharactersCount();
}"
54078,"private void initText(ColorStateList textColorHintStateList){
  if (!TextUtils.isEmpty(getText())) {
    CharSequence text=getText();
    setText(null);
    if (textColorHintStateList != null) {
      setHintTextColor(textColorHintStateList);
    }
 else {
      setHintTextColor(baseColor & 0x00ffffff | 0x44000000);
    }
    setText(text);
    setSelection(text.length());
    floatingLabelFraction=1;
    floatingLabelShown=true;
  }
 else {
    if (textColorHintStateList != null) {
      setHintTextColor(textColorHintStateList);
    }
 else {
      setHintTextColor(baseColor & 0x00ffffff | 0x44000000);
    }
  }
}","private void initText(){
  if (!TextUtils.isEmpty(getText())) {
    CharSequence text=getText();
    setText(null);
    if (textColorHintStateList != null) {
      setHintTextColor(textColorHintStateList);
    }
 else {
      setHintTextColor(baseColor & 0x00ffffff | 0x44000000);
    }
    setText(text);
    setSelection(text.length());
    floatingLabelFraction=1;
    floatingLabelShown=true;
  }
 else {
    if (textColorHintStateList != null) {
      setHintTextColor(textColorHintStateList);
    }
 else {
      setHintTextColor(baseColor & 0x00ffffff | 0x44000000);
    }
  }
}"
54079,"private void initText(){
  if (!TextUtils.isEmpty(getText())) {
    CharSequence text=getText();
    setText(null);
    resetHintTextColor();
    setText(text);
    setSelection(text.length());
    floatingLabelFraction=1;
    floatingLabelShown=true;
  }
 else {
    resetHintTextColor();
  }
}","private void initText(){
  if (!TextUtils.isEmpty(getText())) {
    CharSequence text=getText();
    setText(null);
    resetHintTextColor();
    setText(text);
    setSelection(text.length());
    floatingLabelFraction=1;
    floatingLabelShown=true;
  }
 else {
    resetHintTextColor();
  }
  resetTextColor();
}"
54080,"private void initText(){
  if (!TextUtils.isEmpty(getText())) {
    CharSequence text=getText();
    setText(null);
    resetHintTextColor();
    setText(text);
    setSelection(text.length());
    floatingLabelFraction=1;
    floatingLabelShown=true;
  }
 else {
    resetHintTextColor();
  }
}","private void initText(){
  if (!TextUtils.isEmpty(getText())) {
    CharSequence text=getText();
    setText(null);
    resetHintTextColor();
    setText(text);
    setSelection(text.length());
    floatingLabelFraction=1;
    floatingLabelShown=true;
  }
 else {
    resetHintTextColor();
  }
  resetTextColor();
}"
54081,"private void initText(){
  if (!TextUtils.isEmpty(getText())) {
    CharSequence text=getText();
    setText(null);
    resetHintTextColor();
    setText(text);
    setSelection(text.length());
    floatingLabelFraction=1;
    floatingLabelShown=true;
  }
 else {
    resetHintTextColor();
  }
}","private void initText(){
  if (!TextUtils.isEmpty(getText())) {
    CharSequence text=getText();
    setText(null);
    resetHintTextColor();
    setText(text);
    setSelection(text.length());
    floatingLabelFraction=1;
    floatingLabelShown=true;
  }
 else {
    resetHintTextColor();
  }
  resetTextColor();
}"
54082,"@Override public void onFocusChange(View v,boolean hasFocus){
  if (floatingLabelEnabled && highlightFloatingLabel) {
    if (hasFocus) {
      if (getLabelFocusAnimator().isStarted()) {
        getLabelFocusAnimator().reverse();
      }
 else {
        getLabelFocusAnimator().start();
      }
    }
 else {
      getLabelFocusAnimator().reverse();
    }
    if (outerFocusChangeListener != null) {
      outerFocusChangeListener.onFocusChange(v,hasFocus);
    }
  }
}","@Override public void onFocusChange(View v,boolean hasFocus){
  if (floatingLabelEnabled && highlightFloatingLabel) {
    if (hasFocus) {
      if (getLabelFocusAnimator().isStarted()) {
        getLabelFocusAnimator().reverse();
      }
 else {
        getLabelFocusAnimator().start();
      }
    }
 else {
      getLabelFocusAnimator().reverse();
    }
  }
  if (outerFocusChangeListener != null) {
    outerFocusChangeListener.onFocusChange(v,hasFocus);
  }
}"
54083,"private void initFloatingLabel(){
  addTextChangedListener(new TextWatcher(){
    @Override public void beforeTextChanged(    CharSequence s,    int start,    int count,    int after){
    }
    @Override public void onTextChanged(    CharSequence s,    int start,    int before,    int count){
    }
    @Override public void afterTextChanged(    Editable s){
      if (floatingLabelEnabled) {
        if (s.length() == 0) {
          if (floatingLabelShown) {
            floatingLabelShown=false;
            getLabelAnimator().reverse();
          }
        }
 else         if (!floatingLabelShown) {
          floatingLabelShown=true;
          if (getLabelAnimator().isStarted()) {
            getLabelAnimator().reverse();
          }
 else {
            getLabelAnimator().start();
          }
        }
      }
    }
  }
);
  innerFocusChangeListener=new OnFocusChangeListener(){
    @Override public void onFocusChange(    View v,    boolean hasFocus){
      if (floatingLabelEnabled && highlightFloatingLabel) {
        if (hasFocus) {
          if (getLabelFocusAnimator().isStarted()) {
            getLabelFocusAnimator().reverse();
          }
 else {
            getLabelFocusAnimator().start();
          }
        }
 else {
          getLabelFocusAnimator().reverse();
        }
        if (outerFocusChangeListener != null) {
          outerFocusChangeListener.onFocusChange(v,hasFocus);
        }
      }
    }
  }
;
  super.setOnFocusChangeListener(innerFocusChangeListener);
}","private void initFloatingLabel(){
  addTextChangedListener(new TextWatcher(){
    @Override public void beforeTextChanged(    CharSequence s,    int start,    int count,    int after){
    }
    @Override public void onTextChanged(    CharSequence s,    int start,    int before,    int count){
    }
    @Override public void afterTextChanged(    Editable s){
      if (floatingLabelEnabled) {
        if (s.length() == 0) {
          if (floatingLabelShown) {
            floatingLabelShown=false;
            getLabelAnimator().reverse();
          }
        }
 else         if (!floatingLabelShown) {
          floatingLabelShown=true;
          if (getLabelAnimator().isStarted()) {
            getLabelAnimator().reverse();
          }
 else {
            getLabelAnimator().start();
          }
        }
      }
    }
  }
);
  innerFocusChangeListener=new OnFocusChangeListener(){
    @Override public void onFocusChange(    View v,    boolean hasFocus){
      if (floatingLabelEnabled && highlightFloatingLabel) {
        if (hasFocus) {
          if (getLabelFocusAnimator().isStarted()) {
            getLabelFocusAnimator().reverse();
          }
 else {
            getLabelFocusAnimator().start();
          }
        }
 else {
          getLabelFocusAnimator().reverse();
        }
      }
      if (outerFocusChangeListener != null) {
        outerFocusChangeListener.onFocusChange(v,hasFocus);
      }
    }
  }
;
  super.setOnFocusChangeListener(innerFocusChangeListener);
}"
54084,"@Override public void onFocusChange(View v,boolean hasFocus){
  if (floatingLabelEnabled && highlightFloatingLabel) {
    if (hasFocus) {
      if (getLabelFocusAnimator().isStarted()) {
        getLabelFocusAnimator().reverse();
      }
 else {
        getLabelFocusAnimator().start();
      }
    }
 else {
      getLabelFocusAnimator().reverse();
    }
    if (outerFocusChangeListener != null) {
      outerFocusChangeListener.onFocusChange(v,hasFocus);
    }
  }
}","@Override public void onFocusChange(View v,boolean hasFocus){
  if (floatingLabelEnabled && highlightFloatingLabel) {
    if (hasFocus) {
      if (getLabelFocusAnimator().isStarted()) {
        getLabelFocusAnimator().reverse();
      }
 else {
        getLabelFocusAnimator().start();
      }
    }
 else {
      getLabelFocusAnimator().reverse();
    }
  }
  if (outerFocusChangeListener != null) {
    outerFocusChangeListener.onFocusChange(v,hasFocus);
  }
}"
54085,"private void initFloatingLabel(){
  addTextChangedListener(new TextWatcher(){
    @Override public void beforeTextChanged(    CharSequence s,    int start,    int count,    int after){
    }
    @Override public void onTextChanged(    CharSequence s,    int start,    int before,    int count){
    }
    @Override public void afterTextChanged(    Editable s){
      if (floatingLabelEnabled) {
        if (s.length() == 0) {
          if (floatingLabelShown) {
            floatingLabelShown=false;
            getLabelAnimator().reverse();
          }
        }
 else         if (!floatingLabelShown) {
          floatingLabelShown=true;
          if (getLabelAnimator().isStarted()) {
            getLabelAnimator().reverse();
          }
 else {
            getLabelAnimator().start();
          }
        }
      }
    }
  }
);
  innerFocusChangeListener=new OnFocusChangeListener(){
    @Override public void onFocusChange(    View v,    boolean hasFocus){
      if (floatingLabelEnabled && highlightFloatingLabel) {
        if (hasFocus) {
          if (getLabelFocusAnimator().isStarted()) {
            getLabelFocusAnimator().reverse();
          }
 else {
            getLabelFocusAnimator().start();
          }
        }
 else {
          getLabelFocusAnimator().reverse();
        }
        if (outerFocusChangeListener != null) {
          outerFocusChangeListener.onFocusChange(v,hasFocus);
        }
      }
    }
  }
;
  super.setOnFocusChangeListener(innerFocusChangeListener);
}","private void initFloatingLabel(){
  addTextChangedListener(new TextWatcher(){
    @Override public void beforeTextChanged(    CharSequence s,    int start,    int count,    int after){
    }
    @Override public void onTextChanged(    CharSequence s,    int start,    int before,    int count){
    }
    @Override public void afterTextChanged(    Editable s){
      if (floatingLabelEnabled) {
        if (s.length() == 0) {
          if (floatingLabelShown) {
            floatingLabelShown=false;
            getLabelAnimator().reverse();
          }
        }
 else         if (!floatingLabelShown) {
          floatingLabelShown=true;
          if (getLabelAnimator().isStarted()) {
            getLabelAnimator().reverse();
          }
 else {
            getLabelAnimator().start();
          }
        }
      }
    }
  }
);
  innerFocusChangeListener=new OnFocusChangeListener(){
    @Override public void onFocusChange(    View v,    boolean hasFocus){
      if (floatingLabelEnabled && highlightFloatingLabel) {
        if (hasFocus) {
          if (getLabelFocusAnimator().isStarted()) {
            getLabelFocusAnimator().reverse();
          }
 else {
            getLabelFocusAnimator().start();
          }
        }
 else {
          getLabelFocusAnimator().reverse();
        }
      }
      if (outerFocusChangeListener != null) {
        outerFocusChangeListener.onFocusChange(v,hasFocus);
      }
    }
  }
;
  super.setOnFocusChangeListener(innerFocusChangeListener);
}"
54086,"private void adjustBottomLines(){
  int destBottomLines;
  textPaint.setTextSize(bottomTextSize);
  if (tempErrorText != null) {
    textLayout=new StaticLayout(tempErrorText,textPaint,getWidth() - getBottomTextLeftOffset() - getBottomTextRightOffset()- getPaddingLeft()- getPaddingRight(),Layout.Alignment.ALIGN_NORMAL,1.0f,0.0f,true);
    destBottomLines=Math.max(textLayout.getLineCount(),minBottomTextLines);
  }
 else   if (helperText != null) {
    textLayout=new StaticLayout(helperText,textPaint,getWidth() - getBottomTextLeftOffset() - getBottomTextRightOffset()- getPaddingLeft()- getPaddingRight(),Layout.Alignment.ALIGN_NORMAL,1.0f,0.0f,true);
    destBottomLines=Math.max(textLayout.getLineCount(),minBottomTextLines);
  }
 else {
    destBottomLines=minBottomLines;
  }
  if (bottomLines != destBottomLines) {
    getBottomLinesAnimator(destBottomLines).start();
  }
  bottomLines=destBottomLines;
}","private void adjustBottomLines(){
  int destBottomLines;
  textPaint.setTextSize(bottomTextSize);
  if (tempErrorText != null) {
    textLayout=new StaticLayout(tempErrorText,textPaint,getMeasuredWidth() - getBottomTextLeftOffset() - getBottomTextRightOffset()- getPaddingLeft()- getPaddingRight(),Layout.Alignment.ALIGN_NORMAL,1.0f,0.0f,true);
    destBottomLines=Math.max(textLayout.getLineCount(),minBottomTextLines);
  }
 else   if (helperText != null) {
    textLayout=new StaticLayout(helperText,textPaint,getMeasuredWidth() - getBottomTextLeftOffset() - getBottomTextRightOffset()- getPaddingLeft()- getPaddingRight(),Layout.Alignment.ALIGN_NORMAL,1.0f,0.0f,true);
    destBottomLines=Math.max(textLayout.getLineCount(),minBottomTextLines);
  }
 else {
    destBottomLines=minBottomLines;
  }
  if (bottomLines != destBottomLines) {
    getBottomLinesAnimator(destBottomLines).start();
  }
  bottomLines=destBottomLines;
}"
54087,"private void adjustBottomLines(){
  int destBottomLines;
  textPaint.setTextSize(bottomTextSize);
  if (tempErrorText != null) {
    textLayout=new StaticLayout(tempErrorText,textPaint,getWidth() - getBottomTextLeftOffset() - getBottomTextRightOffset()- getPaddingLeft()- getPaddingRight(),Layout.Alignment.ALIGN_NORMAL,1.0f,0.0f,true);
    destBottomLines=Math.max(textLayout.getLineCount(),minBottomTextLines);
  }
 else   if (helperText != null) {
    textLayout=new StaticLayout(helperText,textPaint,getWidth() - getBottomTextLeftOffset() - getBottomTextRightOffset()- getPaddingLeft()- getPaddingRight(),Layout.Alignment.ALIGN_NORMAL,1.0f,0.0f,true);
    destBottomLines=Math.max(textLayout.getLineCount(),minBottomTextLines);
  }
 else {
    destBottomLines=minBottomLines;
  }
  if (bottomLines != destBottomLines) {
    getBottomLinesAnimator(destBottomLines).start();
  }
  bottomLines=destBottomLines;
}","private void adjustBottomLines(){
  int destBottomLines;
  textPaint.setTextSize(bottomTextSize);
  if (tempErrorText != null) {
    textLayout=new StaticLayout(tempErrorText,textPaint,getMeasuredWidth() - getBottomTextLeftOffset() - getBottomTextRightOffset()- getPaddingLeft()- getPaddingRight(),Layout.Alignment.ALIGN_NORMAL,1.0f,0.0f,true);
    destBottomLines=Math.max(textLayout.getLineCount(),minBottomTextLines);
  }
 else   if (helperText != null) {
    textLayout=new StaticLayout(helperText,textPaint,getMeasuredWidth() - getBottomTextLeftOffset() - getBottomTextRightOffset()- getPaddingLeft()- getPaddingRight(),Layout.Alignment.ALIGN_NORMAL,1.0f,0.0f,true);
    destBottomLines=Math.max(textLayout.getLineCount(),minBottomTextLines);
  }
 else {
    destBottomLines=minBottomLines;
  }
  if (bottomLines != destBottomLines) {
    getBottomLinesAnimator(destBottomLines).start();
  }
  bottomLines=destBottomLines;
}"
54088,"private void adjustBottomLines(){
  int destBottomLines;
  textPaint.setTextSize(bottomTextSize);
  if (tempErrorText != null) {
    textLayout=new StaticLayout(tempErrorText,textPaint,getWidth() - getBottomTextLeftOffset() - getBottomTextRightOffset()- getPaddingLeft()- getPaddingRight(),Layout.Alignment.ALIGN_NORMAL,1.0f,0.0f,true);
    destBottomLines=Math.max(textLayout.getLineCount(),minBottomTextLines);
  }
 else   if (helperText != null) {
    textLayout=new StaticLayout(helperText,textPaint,getWidth() - getBottomTextLeftOffset() - getBottomTextRightOffset()- getPaddingLeft()- getPaddingRight(),Layout.Alignment.ALIGN_NORMAL,1.0f,0.0f,true);
    destBottomLines=Math.max(textLayout.getLineCount(),minBottomTextLines);
  }
 else {
    destBottomLines=minBottomLines;
  }
  if (bottomLines != destBottomLines) {
    getBottomLinesAnimator(destBottomLines).start();
  }
  bottomLines=destBottomLines;
}","private void adjustBottomLines(){
  int destBottomLines;
  textPaint.setTextSize(bottomTextSize);
  if (tempErrorText != null) {
    textLayout=new StaticLayout(tempErrorText,textPaint,getMeasuredWidth() - getBottomTextLeftOffset() - getBottomTextRightOffset()- getPaddingLeft()- getPaddingRight(),Layout.Alignment.ALIGN_NORMAL,1.0f,0.0f,true);
    destBottomLines=Math.max(textLayout.getLineCount(),minBottomTextLines);
  }
 else   if (helperText != null) {
    textLayout=new StaticLayout(helperText,textPaint,getMeasuredWidth() - getBottomTextLeftOffset() - getBottomTextRightOffset()- getPaddingLeft()- getPaddingRight(),Layout.Alignment.ALIGN_NORMAL,1.0f,0.0f,true);
    destBottomLines=Math.max(textLayout.getLineCount(),minBottomTextLines);
  }
 else {
    destBottomLines=minBottomLines;
  }
  if (bottomLines != destBottomLines) {
    getBottomLinesAnimator(destBottomLines).start();
  }
  bottomLines=destBottomLines;
}"
54089,"public void setFloatingLabel(@FloatingLabelType int mode){
  setFloatingLabelInternal(mode);
  postInvalidate();
}","public void setFloatingLabel(@FloatingLabelType int mode){
  setFloatingLabelInternal(mode);
  initPadding();
}"
54090,"public void setBaseColor(int color){
  baseColor=color;
  postInvalidate();
}","public void setBaseColor(int color){
  if (baseColor != color) {
    baseColor=color;
  }
  ColorStateList colorStateList=new ColorStateList(new int[][]{new int[]{android.R.attr.state_enabled},EMPTY_STATE_SET},new int[]{baseColor & 0x00ffffff | 0xdf000000,baseColor & 0x00ffffff | 0x44000000});
  setTextColor(colorStateList);
  setHintTextColor(baseColor & 0x00ffffff | 0x44000000);
  postInvalidate();
}"
54091,"private void init(Context context,AttributeSet attrs){
  iconSize=getPixel(32);
  iconOuterWidth=getPixel(48);
  iconOuterHeight=getPixel(32);
  bottomSpacing=getResources().getDimensionPixelSize(R.dimen.inner_components_spacing);
  bottomEllipsisSize=getResources().getDimensionPixelSize(R.dimen.bottom_ellipsis_height);
  int defaultBaseColor;
  TypedValue baseColorTypedValue=new TypedValue();
  context.getTheme().resolveAttribute(android.R.attr.windowBackground,baseColorTypedValue,true);
  defaultBaseColor=Colors.getBaseColor(baseColorTypedValue.data);
  TypedArray typedArray=context.obtainStyledAttributes(attrs,R.styleable.MaterialEditText);
  baseColor=typedArray.getColor(R.styleable.MaterialEditText_baseColor,defaultBaseColor);
  ColorStateList colorStateList=new ColorStateList(new int[][]{new int[]{android.R.attr.state_enabled},EMPTY_STATE_SET},new int[]{baseColor & 0x00ffffff | 0xdf000000,baseColor & 0x00ffffff | 0x44000000});
  setTextColor(colorStateList);
  int defaultPrimaryColor;
  TypedValue primaryColorTypedValue=new TypedValue();
  try {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      context.getTheme().resolveAttribute(android.R.attr.colorPrimary,primaryColorTypedValue,true);
      defaultPrimaryColor=primaryColorTypedValue.data;
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    try {
      int colorPrimaryId=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",getContext().getPackageName());
      if (colorPrimaryId != 0) {
        context.getTheme().resolveAttribute(colorPrimaryId,primaryColorTypedValue,true);
        defaultPrimaryColor=primaryColorTypedValue.data;
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
 catch (    Exception e1) {
      defaultPrimaryColor=baseColor;
    }
  }
  primaryColor=typedArray.getColor(R.styleable.MaterialEditText_primaryColor,defaultPrimaryColor);
  setFloatingLabelInternal(typedArray.getInt(R.styleable.MaterialEditText_floatingLabel,0));
  errorColor=typedArray.getColor(R.styleable.MaterialEditText_errorColor,Color.parseColor(""String_Node_Str""));
  minCharacters=typedArray.getInt(R.styleable.MaterialEditText_minCharacters,0);
  maxCharacters=typedArray.getInt(R.styleable.MaterialEditText_maxCharacters,0);
  singleLineEllipsis=typedArray.getBoolean(R.styleable.MaterialEditText_singleLineEllipsis,false);
  helperText=typedArray.getString(R.styleable.MaterialEditText_helperText);
  helperTextColor=typedArray.getColor(R.styleable.MaterialEditText_helperTextColor,-1);
  minBottomTextLines=typedArray.getInt(R.styleable.MaterialEditText_minBottomTextLines,0);
  String fontPath=typedArray.getString(R.styleable.MaterialEditText_accentTypeface);
  if (fontPath != null && !isInEditMode()) {
    accentTypeface=getCustomTypeface(fontPath);
    textPaint.setTypeface(accentTypeface);
  }
  floatingLabelText=typedArray.getString(R.styleable.MaterialEditText_floatingLabelText);
  if (floatingLabelText == null) {
    floatingLabelText=getHint();
  }
  floatingLabelSpacing=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_floatingLabelSpacing,bottomSpacing);
  floatingLabelTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_floatingLabelTextSize,getResources().getDimensionPixelSize(R.dimen.floating_label_text_size));
  bottomTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_bottomTextSize,getResources().getDimensionPixelSize(R.dimen.bottom_text_size));
  hideUnderline=typedArray.getBoolean(R.styleable.MaterialEditText_hideUnderline,false);
  autoValidate=typedArray.getBoolean(R.styleable.MaterialEditText_autoValidate,false);
  iconLeftBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_iconLeft,-1));
  iconRightBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_iconRight,-1));
  iconPadding=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_iconPadding,getPixel(8));
  int[] paddings=new int[]{android.R.attr.padding,android.R.attr.paddingLeft,android.R.attr.paddingTop,android.R.attr.paddingRight,android.R.attr.paddingBottom};
  TypedArray paddingsTypedArray=context.obtainStyledAttributes(attrs,paddings);
  int padding=paddingsTypedArray.getDimensionPixelSize(0,0);
  innerPaddingLeft=paddingsTypedArray.getDimensionPixelSize(1,padding);
  innerPaddingTop=paddingsTypedArray.getDimensionPixelSize(2,padding);
  innerPaddingRight=paddingsTypedArray.getDimensionPixelSize(3,padding);
  innerPaddingBottom=paddingsTypedArray.getDimensionPixelSize(4,padding);
  typedArray.recycle();
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
    setBackground(null);
  }
 else {
    setBackgroundDrawable(null);
  }
  if (singleLineEllipsis) {
    TransformationMethod transformationMethod=getTransformationMethod();
    setSingleLine();
    setTransformationMethod(transformationMethod);
  }
  initMinBottomLines();
  initPadding();
  initText();
  initFloatingLabel();
  initTextWatcher();
  checkCharactersCount();
}","private void init(Context context,AttributeSet attrs){
  iconSize=getPixel(32);
  iconOuterWidth=getPixel(48);
  iconOuterHeight=getPixel(32);
  bottomSpacing=getResources().getDimensionPixelSize(R.dimen.inner_components_spacing);
  bottomEllipsisSize=getResources().getDimensionPixelSize(R.dimen.bottom_ellipsis_height);
  int defaultBaseColor;
  TypedValue baseColorTypedValue=new TypedValue();
  context.getTheme().resolveAttribute(android.R.attr.windowBackground,baseColorTypedValue,true);
  defaultBaseColor=Colors.getBaseColor(baseColorTypedValue.data);
  TypedArray typedArray=context.obtainStyledAttributes(attrs,R.styleable.MaterialEditText);
  baseColor=typedArray.getColor(R.styleable.MaterialEditText_baseColor,defaultBaseColor);
  setBaseColor(baseColor);
  int defaultPrimaryColor;
  TypedValue primaryColorTypedValue=new TypedValue();
  try {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      context.getTheme().resolveAttribute(android.R.attr.colorPrimary,primaryColorTypedValue,true);
      defaultPrimaryColor=primaryColorTypedValue.data;
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    try {
      int colorPrimaryId=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",getContext().getPackageName());
      if (colorPrimaryId != 0) {
        context.getTheme().resolveAttribute(colorPrimaryId,primaryColorTypedValue,true);
        defaultPrimaryColor=primaryColorTypedValue.data;
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
 catch (    Exception e1) {
      defaultPrimaryColor=baseColor;
    }
  }
  primaryColor=typedArray.getColor(R.styleable.MaterialEditText_primaryColor,defaultPrimaryColor);
  setFloatingLabelInternal(typedArray.getInt(R.styleable.MaterialEditText_floatingLabel,0));
  errorColor=typedArray.getColor(R.styleable.MaterialEditText_errorColor,Color.parseColor(""String_Node_Str""));
  minCharacters=typedArray.getInt(R.styleable.MaterialEditText_minCharacters,0);
  maxCharacters=typedArray.getInt(R.styleable.MaterialEditText_maxCharacters,0);
  singleLineEllipsis=typedArray.getBoolean(R.styleable.MaterialEditText_singleLineEllipsis,false);
  helperText=typedArray.getString(R.styleable.MaterialEditText_helperText);
  helperTextColor=typedArray.getColor(R.styleable.MaterialEditText_helperTextColor,-1);
  minBottomTextLines=typedArray.getInt(R.styleable.MaterialEditText_minBottomTextLines,0);
  String fontPath=typedArray.getString(R.styleable.MaterialEditText_accentTypeface);
  if (fontPath != null && !isInEditMode()) {
    accentTypeface=getCustomTypeface(fontPath);
    textPaint.setTypeface(accentTypeface);
  }
  floatingLabelText=typedArray.getString(R.styleable.MaterialEditText_floatingLabelText);
  if (floatingLabelText == null) {
    floatingLabelText=getHint();
  }
  floatingLabelSpacing=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_floatingLabelSpacing,bottomSpacing);
  floatingLabelTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_floatingLabelTextSize,getResources().getDimensionPixelSize(R.dimen.floating_label_text_size));
  bottomTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_bottomTextSize,getResources().getDimensionPixelSize(R.dimen.bottom_text_size));
  hideUnderline=typedArray.getBoolean(R.styleable.MaterialEditText_hideUnderline,false);
  autoValidate=typedArray.getBoolean(R.styleable.MaterialEditText_autoValidate,false);
  iconLeftBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_iconLeft,-1));
  iconRightBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_iconRight,-1));
  iconPadding=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_iconPadding,getPixel(8));
  int[] paddings=new int[]{android.R.attr.padding,android.R.attr.paddingLeft,android.R.attr.paddingTop,android.R.attr.paddingRight,android.R.attr.paddingBottom};
  TypedArray paddingsTypedArray=context.obtainStyledAttributes(attrs,paddings);
  int padding=paddingsTypedArray.getDimensionPixelSize(0,0);
  innerPaddingLeft=paddingsTypedArray.getDimensionPixelSize(1,padding);
  innerPaddingTop=paddingsTypedArray.getDimensionPixelSize(2,padding);
  innerPaddingRight=paddingsTypedArray.getDimensionPixelSize(3,padding);
  innerPaddingBottom=paddingsTypedArray.getDimensionPixelSize(4,padding);
  typedArray.recycle();
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
    setBackground(null);
  }
 else {
    setBackgroundDrawable(null);
  }
  if (singleLineEllipsis) {
    TransformationMethod transformationMethod=getTransformationMethod();
    setSingleLine();
    setTransformationMethod(transformationMethod);
  }
  initMinBottomLines();
  initPadding();
  initText();
  initFloatingLabel();
  initTextWatcher();
  checkCharactersCount();
}"
54092,"@Override public void afterTextChanged(Editable s){
  if (s.length() == 0) {
    if (floatingLabelShown) {
      floatingLabelShown=false;
      getLabelAnimator().reverse();
    }
  }
 else   if (!floatingLabelShown) {
    floatingLabelShown=true;
    if (getLabelAnimator().isStarted()) {
      getLabelAnimator().reverse();
    }
 else {
      getLabelAnimator().start();
    }
  }
}","@Override public void afterTextChanged(Editable s){
  if (floatingLabelEnabled) {
    if (s.length() == 0) {
      if (floatingLabelShown) {
        floatingLabelShown=false;
        getLabelAnimator().reverse();
      }
    }
 else     if (!floatingLabelShown) {
      floatingLabelShown=true;
      if (getLabelAnimator().isStarted()) {
        getLabelAnimator().reverse();
      }
 else {
        getLabelAnimator().start();
      }
    }
  }
}"
54093,"@Override public void onFocusChange(View v,boolean hasFocus){
  if (hasFocus) {
    if (getLabelFocusAnimator().isStarted()) {
      getLabelFocusAnimator().reverse();
    }
 else {
      getLabelFocusAnimator().start();
    }
  }
 else {
    getLabelFocusAnimator().reverse();
  }
  if (outerFocusChangeListener != null) {
    outerFocusChangeListener.onFocusChange(v,hasFocus);
  }
}","@Override public void onFocusChange(View v,boolean hasFocus){
  if (floatingLabelEnabled && highlightFloatingLabel) {
    if (hasFocus) {
      if (getLabelFocusAnimator().isStarted()) {
        getLabelFocusAnimator().reverse();
      }
 else {
        getLabelFocusAnimator().start();
      }
    }
 else {
      getLabelFocusAnimator().reverse();
    }
    if (outerFocusChangeListener != null) {
      outerFocusChangeListener.onFocusChange(v,hasFocus);
    }
  }
}"
54094,"private void initFloatingLabel(){
  if (floatingLabelEnabled) {
    addTextChangedListener(new TextWatcher(){
      @Override public void beforeTextChanged(      CharSequence s,      int start,      int count,      int after){
      }
      @Override public void onTextChanged(      CharSequence s,      int start,      int before,      int count){
      }
      @Override public void afterTextChanged(      Editable s){
        if (s.length() == 0) {
          if (floatingLabelShown) {
            floatingLabelShown=false;
            getLabelAnimator().reverse();
          }
        }
 else         if (!floatingLabelShown) {
          floatingLabelShown=true;
          if (getLabelAnimator().isStarted()) {
            getLabelAnimator().reverse();
          }
 else {
            getLabelAnimator().start();
          }
        }
      }
    }
);
    if (highlightFloatingLabel) {
      innerFocusChangeListener=new OnFocusChangeListener(){
        @Override public void onFocusChange(        View v,        boolean hasFocus){
          if (hasFocus) {
            if (getLabelFocusAnimator().isStarted()) {
              getLabelFocusAnimator().reverse();
            }
 else {
              getLabelFocusAnimator().start();
            }
          }
 else {
            getLabelFocusAnimator().reverse();
          }
          if (outerFocusChangeListener != null) {
            outerFocusChangeListener.onFocusChange(v,hasFocus);
          }
        }
      }
;
      super.setOnFocusChangeListener(innerFocusChangeListener);
    }
  }
}","private void initFloatingLabel(){
  addTextChangedListener(new TextWatcher(){
    @Override public void beforeTextChanged(    CharSequence s,    int start,    int count,    int after){
    }
    @Override public void onTextChanged(    CharSequence s,    int start,    int before,    int count){
    }
    @Override public void afterTextChanged(    Editable s){
      if (floatingLabelEnabled) {
        if (s.length() == 0) {
          if (floatingLabelShown) {
            floatingLabelShown=false;
            getLabelAnimator().reverse();
          }
        }
 else         if (!floatingLabelShown) {
          floatingLabelShown=true;
          if (getLabelAnimator().isStarted()) {
            getLabelAnimator().reverse();
          }
 else {
            getLabelAnimator().start();
          }
        }
      }
    }
  }
);
  innerFocusChangeListener=new OnFocusChangeListener(){
    @Override public void onFocusChange(    View v,    boolean hasFocus){
      if (floatingLabelEnabled && highlightFloatingLabel) {
        if (hasFocus) {
          if (getLabelFocusAnimator().isStarted()) {
            getLabelFocusAnimator().reverse();
          }
 else {
            getLabelFocusAnimator().start();
          }
        }
 else {
          getLabelFocusAnimator().reverse();
        }
        if (outerFocusChangeListener != null) {
          outerFocusChangeListener.onFocusChange(v,hasFocus);
        }
      }
    }
  }
;
  super.setOnFocusChangeListener(innerFocusChangeListener);
}"
54095,"@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(baseColor & 0x00ffffff | 0x44000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? getCurrentHintTextColor() : errorColor);
    String text;
    if (minCharacters <= 0) {
      text=isRTL() ? maxCharacters + ""String_Node_Str"" + getText().length() : getText().length() + ""String_Node_Str"" + maxCharacters;
    }
 else     if (maxCharacters <= 0) {
      text=isRTL() ? ""String_Node_Str"" + minCharacters + ""String_Node_Str""+ getText().length() : getText().length() + ""String_Node_Str"" + minCharacters+ ""String_Node_Str"";
    }
 else {
      text=isRTL() ? maxCharacters + ""String_Node_Str"" + minCharacters+ ""String_Node_Str""+ getText().length() : getText().length() + ""String_Node_Str"" + minCharacters+ ""String_Node_Str""+ maxCharacters;
    }
    canvas.drawText(text,isRTL() ? startX : endX - textPaint.measureText(text),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || (hasFocus() && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : getCurrentHintTextColor());
      canvas.save();
      canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,getCurrentHintTextColor(),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelSpacing;
    int distance=floatingLabelSpacing;
    int position=(int)(floatingLabelStartY - distance * floatingLabelFraction);
    int alpha=(int)(floatingLabelFraction * 0xff * (0.74f * focusFraction + 0.26f));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? getCurrentHintTextColor() : errorColor);
    String text;
    if (minCharacters <= 0) {
      text=isRTL() ? maxCharacters + ""String_Node_Str"" + getText().length() : getText().length() + ""String_Node_Str"" + maxCharacters;
    }
 else     if (maxCharacters <= 0) {
      text=isRTL() ? ""String_Node_Str"" + minCharacters + ""String_Node_Str""+ getText().length() : getText().length() + ""String_Node_Str"" + minCharacters+ ""String_Node_Str"";
    }
 else {
      text=isRTL() ? maxCharacters + ""String_Node_Str"" + minCharacters+ ""String_Node_Str""+ getText().length() : getText().length() + ""String_Node_Str"" + minCharacters+ ""String_Node_Str""+ maxCharacters;
    }
    canvas.drawText(text,isRTL() ? startX : endX - textPaint.measureText(text),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || (hasFocus() && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : getCurrentHintTextColor());
      canvas.save();
      canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,getCurrentHintTextColor(),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelSpacing;
    int distance=floatingLabelSpacing;
    int position=(int)(floatingLabelStartY - distance * floatingLabelFraction);
    int alpha=(int)(floatingLabelFraction * 0xff * (0.74f * focusFraction + 0.26f));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}"
54096,"private void initText(){
  if (!TextUtils.isEmpty(getText())) {
    CharSequence text=getText();
    setText(null);
    setHintTextColor(baseColor & 0x00ffffff | 0x44000000);
    setText(text);
    floatingLabelFraction=1;
    floatingLabelShown=true;
  }
 else {
    setHintTextColor(baseColor & 0x00ffffff | 0x44000000);
  }
}","private void initText(){
  if (!TextUtils.isEmpty(getText())) {
    CharSequence text=getText();
    setText(null);
    setText(text);
    floatingLabelFraction=1;
    floatingLabelShown=true;
  }
}"
54097,"private void initPadding(){
  extraPaddingTop=floatingLabelEnabled ? floatingLabelTextSize + floatingLabelSpacing : floatingLabelSpacing;
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  extraPaddingBottom=(int)((textMetrics.descent - textMetrics.ascent) * currentBottomLines) + (hideUnderline ? bottomSpacing : bottomSpacing * 2);
  extraPaddingLeft=iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding);
  extraPaddingRight=iconRightBitmaps == null ? 0 : (iconOuterWidth + iconPadding);
  System.out.println(""String_Node_Str"" + getPaddingLeft() + ""String_Node_Str""+ extraPaddingLeft);
  System.out.println(""String_Node_Str"" + getPaddingRight() + ""String_Node_Str""+ extraPaddingRight);
  System.out.println(""String_Node_Str"" + getPaddingTop() + ""String_Node_Str""+ extraPaddingTop);
  System.out.println(""String_Node_Str"" + getPaddingBottom() + ""String_Node_Str""+ extraPaddingBottom);
  setPaddings(innerPaddingLeft,innerPaddingTop,innerPaddingRight,innerPaddingBottom);
}","private void initPadding(){
  extraPaddingTop=floatingLabelEnabled ? floatingLabelTextSize + floatingLabelSpacing : floatingLabelSpacing;
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  extraPaddingBottom=(int)((textMetrics.descent - textMetrics.ascent) * currentBottomLines) + (hideUnderline ? bottomSpacing : bottomSpacing * 2);
  extraPaddingLeft=iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding);
  extraPaddingRight=iconRightBitmaps == null ? 0 : (iconOuterWidth + iconPadding);
  setPaddings(innerPaddingLeft,innerPaddingTop,innerPaddingRight,innerPaddingBottom);
}"
54098,"public void setFloatingLabel(@FloatingLabelType int mode){
  setFloatingLabelInternal(mode);
  postInvalidate();
}","public void setFloatingLabel(@FloatingLabelType int mode){
  setFloatingLabelInternal(mode);
  initPadding();
}"
54099,"public void setBaseColor(int color){
  baseColor=color;
  postInvalidate();
}","public void setBaseColor(int color){
  if (baseColor != color) {
    baseColor=color;
  }
  ColorStateList colorStateList=new ColorStateList(new int[][]{new int[]{android.R.attr.state_enabled},EMPTY_STATE_SET},new int[]{baseColor & 0x00ffffff | 0xdf000000,baseColor & 0x00ffffff | 0x44000000});
  setTextColor(colorStateList);
  setHintTextColor(baseColor & 0x00ffffff | 0x44000000);
  postInvalidate();
}"
54100,"private void init(Context context,AttributeSet attrs){
  iconSize=getPixel(32);
  iconOuterWidth=getPixel(48);
  iconOuterHeight=getPixel(32);
  bottomSpacing=getResources().getDimensionPixelSize(R.dimen.inner_components_spacing);
  bottomEllipsisSize=getResources().getDimensionPixelSize(R.dimen.bottom_ellipsis_height);
  int defaultBaseColor;
  TypedValue baseColorTypedValue=new TypedValue();
  context.getTheme().resolveAttribute(android.R.attr.windowBackground,baseColorTypedValue,true);
  defaultBaseColor=Colors.getBaseColor(baseColorTypedValue.data);
  TypedArray typedArray=context.obtainStyledAttributes(attrs,R.styleable.MaterialEditText);
  baseColor=typedArray.getColor(R.styleable.MaterialEditText_baseColor,defaultBaseColor);
  ColorStateList colorStateList=new ColorStateList(new int[][]{new int[]{android.R.attr.state_enabled},EMPTY_STATE_SET},new int[]{baseColor & 0x00ffffff | 0xdf000000,baseColor & 0x00ffffff | 0x44000000});
  setTextColor(colorStateList);
  int defaultPrimaryColor;
  TypedValue primaryColorTypedValue=new TypedValue();
  try {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      context.getTheme().resolveAttribute(android.R.attr.colorPrimary,primaryColorTypedValue,true);
      defaultPrimaryColor=primaryColorTypedValue.data;
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    try {
      int colorPrimaryId=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",getContext().getPackageName());
      if (colorPrimaryId != 0) {
        context.getTheme().resolveAttribute(colorPrimaryId,primaryColorTypedValue,true);
        defaultPrimaryColor=primaryColorTypedValue.data;
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
 catch (    Exception e1) {
      defaultPrimaryColor=baseColor;
    }
  }
  primaryColor=typedArray.getColor(R.styleable.MaterialEditText_primaryColor,defaultPrimaryColor);
  setFloatingLabelInternal(typedArray.getInt(R.styleable.MaterialEditText_floatingLabel,0));
  errorColor=typedArray.getColor(R.styleable.MaterialEditText_errorColor,Color.parseColor(""String_Node_Str""));
  minCharacters=typedArray.getInt(R.styleable.MaterialEditText_minCharacters,0);
  maxCharacters=typedArray.getInt(R.styleable.MaterialEditText_maxCharacters,0);
  singleLineEllipsis=typedArray.getBoolean(R.styleable.MaterialEditText_singleLineEllipsis,false);
  helperText=typedArray.getString(R.styleable.MaterialEditText_helperText);
  helperTextColor=typedArray.getColor(R.styleable.MaterialEditText_helperTextColor,-1);
  minBottomTextLines=typedArray.getInt(R.styleable.MaterialEditText_minBottomTextLines,0);
  String fontPath=typedArray.getString(R.styleable.MaterialEditText_accentTypeface);
  if (fontPath != null && !isInEditMode()) {
    accentTypeface=getCustomTypeface(fontPath);
    textPaint.setTypeface(accentTypeface);
  }
  floatingLabelText=typedArray.getString(R.styleable.MaterialEditText_floatingLabelText);
  if (floatingLabelText == null) {
    floatingLabelText=getHint();
  }
  floatingLabelSpacing=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_floatingLabelSpacing,bottomSpacing);
  floatingLabelTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_floatingLabelTextSize,getResources().getDimensionPixelSize(R.dimen.floating_label_text_size));
  bottomTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_bottomTextSize,getResources().getDimensionPixelSize(R.dimen.bottom_text_size));
  hideUnderline=typedArray.getBoolean(R.styleable.MaterialEditText_hideUnderline,false);
  autoValidate=typedArray.getBoolean(R.styleable.MaterialEditText_autoValidate,false);
  iconLeftBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_iconLeft,-1));
  iconRightBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_iconRight,-1));
  iconPadding=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_iconPadding,getPixel(8));
  int[] paddings=new int[]{android.R.attr.padding,android.R.attr.paddingLeft,android.R.attr.paddingTop,android.R.attr.paddingRight,android.R.attr.paddingBottom};
  TypedArray paddingsTypedArray=context.obtainStyledAttributes(attrs,paddings);
  int padding=paddingsTypedArray.getDimensionPixelSize(0,0);
  innerPaddingLeft=paddingsTypedArray.getDimensionPixelSize(1,padding);
  innerPaddingTop=paddingsTypedArray.getDimensionPixelSize(2,padding);
  innerPaddingRight=paddingsTypedArray.getDimensionPixelSize(3,padding);
  innerPaddingBottom=paddingsTypedArray.getDimensionPixelSize(4,padding);
  typedArray.recycle();
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
    setBackground(null);
  }
 else {
    setBackgroundDrawable(null);
  }
  if (singleLineEllipsis) {
    TransformationMethod transformationMethod=getTransformationMethod();
    setSingleLine();
    setTransformationMethod(transformationMethod);
  }
  initMinBottomLines();
  initPadding();
  initText();
  initFloatingLabel();
  initTextWatcher();
  checkCharactersCount();
}","private void init(Context context,AttributeSet attrs){
  iconSize=getPixel(32);
  iconOuterWidth=getPixel(48);
  iconOuterHeight=getPixel(32);
  bottomSpacing=getResources().getDimensionPixelSize(R.dimen.inner_components_spacing);
  bottomEllipsisSize=getResources().getDimensionPixelSize(R.dimen.bottom_ellipsis_height);
  int defaultBaseColor;
  TypedValue baseColorTypedValue=new TypedValue();
  context.getTheme().resolveAttribute(android.R.attr.windowBackground,baseColorTypedValue,true);
  defaultBaseColor=Colors.getBaseColor(baseColorTypedValue.data);
  TypedArray typedArray=context.obtainStyledAttributes(attrs,R.styleable.MaterialEditText);
  baseColor=typedArray.getColor(R.styleable.MaterialEditText_baseColor,defaultBaseColor);
  setBaseColor(baseColor);
  int defaultPrimaryColor;
  TypedValue primaryColorTypedValue=new TypedValue();
  try {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      context.getTheme().resolveAttribute(android.R.attr.colorPrimary,primaryColorTypedValue,true);
      defaultPrimaryColor=primaryColorTypedValue.data;
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    try {
      int colorPrimaryId=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",getContext().getPackageName());
      if (colorPrimaryId != 0) {
        context.getTheme().resolveAttribute(colorPrimaryId,primaryColorTypedValue,true);
        defaultPrimaryColor=primaryColorTypedValue.data;
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
 catch (    Exception e1) {
      defaultPrimaryColor=baseColor;
    }
  }
  primaryColor=typedArray.getColor(R.styleable.MaterialEditText_primaryColor,defaultPrimaryColor);
  setFloatingLabelInternal(typedArray.getInt(R.styleable.MaterialEditText_floatingLabel,0));
  errorColor=typedArray.getColor(R.styleable.MaterialEditText_errorColor,Color.parseColor(""String_Node_Str""));
  minCharacters=typedArray.getInt(R.styleable.MaterialEditText_minCharacters,0);
  maxCharacters=typedArray.getInt(R.styleable.MaterialEditText_maxCharacters,0);
  singleLineEllipsis=typedArray.getBoolean(R.styleable.MaterialEditText_singleLineEllipsis,false);
  helperText=typedArray.getString(R.styleable.MaterialEditText_helperText);
  helperTextColor=typedArray.getColor(R.styleable.MaterialEditText_helperTextColor,-1);
  minBottomTextLines=typedArray.getInt(R.styleable.MaterialEditText_minBottomTextLines,0);
  String fontPath=typedArray.getString(R.styleable.MaterialEditText_accentTypeface);
  if (fontPath != null && !isInEditMode()) {
    accentTypeface=getCustomTypeface(fontPath);
    textPaint.setTypeface(accentTypeface);
  }
  floatingLabelText=typedArray.getString(R.styleable.MaterialEditText_floatingLabelText);
  if (floatingLabelText == null) {
    floatingLabelText=getHint();
  }
  floatingLabelSpacing=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_floatingLabelSpacing,bottomSpacing);
  floatingLabelTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_floatingLabelTextSize,getResources().getDimensionPixelSize(R.dimen.floating_label_text_size));
  bottomTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_bottomTextSize,getResources().getDimensionPixelSize(R.dimen.bottom_text_size));
  hideUnderline=typedArray.getBoolean(R.styleable.MaterialEditText_hideUnderline,false);
  autoValidate=typedArray.getBoolean(R.styleable.MaterialEditText_autoValidate,false);
  iconLeftBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_iconLeft,-1));
  iconRightBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_iconRight,-1));
  iconPadding=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_iconPadding,getPixel(8));
  int[] paddings=new int[]{android.R.attr.padding,android.R.attr.paddingLeft,android.R.attr.paddingTop,android.R.attr.paddingRight,android.R.attr.paddingBottom};
  TypedArray paddingsTypedArray=context.obtainStyledAttributes(attrs,paddings);
  int padding=paddingsTypedArray.getDimensionPixelSize(0,0);
  innerPaddingLeft=paddingsTypedArray.getDimensionPixelSize(1,padding);
  innerPaddingTop=paddingsTypedArray.getDimensionPixelSize(2,padding);
  innerPaddingRight=paddingsTypedArray.getDimensionPixelSize(3,padding);
  innerPaddingBottom=paddingsTypedArray.getDimensionPixelSize(4,padding);
  typedArray.recycle();
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
    setBackground(null);
  }
 else {
    setBackgroundDrawable(null);
  }
  if (singleLineEllipsis) {
    TransformationMethod transformationMethod=getTransformationMethod();
    setSingleLine();
    setTransformationMethod(transformationMethod);
  }
  initMinBottomLines();
  initPadding();
  initText();
  initFloatingLabel();
  initTextWatcher();
  checkCharactersCount();
}"
54101,"@Override public void afterTextChanged(Editable s){
  if (s.length() == 0) {
    if (floatingLabelShown) {
      floatingLabelShown=false;
      getLabelAnimator().reverse();
    }
  }
 else   if (!floatingLabelShown) {
    floatingLabelShown=true;
    if (getLabelAnimator().isStarted()) {
      getLabelAnimator().reverse();
    }
 else {
      getLabelAnimator().start();
    }
  }
}","@Override public void afterTextChanged(Editable s){
  if (floatingLabelEnabled) {
    if (s.length() == 0) {
      if (floatingLabelShown) {
        floatingLabelShown=false;
        getLabelAnimator().reverse();
      }
    }
 else     if (!floatingLabelShown) {
      floatingLabelShown=true;
      if (getLabelAnimator().isStarted()) {
        getLabelAnimator().reverse();
      }
 else {
        getLabelAnimator().start();
      }
    }
  }
}"
54102,"@Override public void onFocusChange(View v,boolean hasFocus){
  if (hasFocus) {
    if (getLabelFocusAnimator().isStarted()) {
      getLabelFocusAnimator().reverse();
    }
 else {
      getLabelFocusAnimator().start();
    }
  }
 else {
    getLabelFocusAnimator().reverse();
  }
  if (outerFocusChangeListener != null) {
    outerFocusChangeListener.onFocusChange(v,hasFocus);
  }
}","@Override public void onFocusChange(View v,boolean hasFocus){
  if (floatingLabelEnabled && highlightFloatingLabel) {
    if (hasFocus) {
      if (getLabelFocusAnimator().isStarted()) {
        getLabelFocusAnimator().reverse();
      }
 else {
        getLabelFocusAnimator().start();
      }
    }
 else {
      getLabelFocusAnimator().reverse();
    }
    if (outerFocusChangeListener != null) {
      outerFocusChangeListener.onFocusChange(v,hasFocus);
    }
  }
}"
54103,"private void initFloatingLabel(){
  if (floatingLabelEnabled) {
    addTextChangedListener(new TextWatcher(){
      @Override public void beforeTextChanged(      CharSequence s,      int start,      int count,      int after){
      }
      @Override public void onTextChanged(      CharSequence s,      int start,      int before,      int count){
      }
      @Override public void afterTextChanged(      Editable s){
        if (s.length() == 0) {
          if (floatingLabelShown) {
            floatingLabelShown=false;
            getLabelAnimator().reverse();
          }
        }
 else         if (!floatingLabelShown) {
          floatingLabelShown=true;
          if (getLabelAnimator().isStarted()) {
            getLabelAnimator().reverse();
          }
 else {
            getLabelAnimator().start();
          }
        }
      }
    }
);
    if (highlightFloatingLabel) {
      innerFocusChangeListener=new OnFocusChangeListener(){
        @Override public void onFocusChange(        View v,        boolean hasFocus){
          if (hasFocus) {
            if (getLabelFocusAnimator().isStarted()) {
              getLabelFocusAnimator().reverse();
            }
 else {
              getLabelFocusAnimator().start();
            }
          }
 else {
            getLabelFocusAnimator().reverse();
          }
          if (outerFocusChangeListener != null) {
            outerFocusChangeListener.onFocusChange(v,hasFocus);
          }
        }
      }
;
      super.setOnFocusChangeListener(innerFocusChangeListener);
    }
  }
}","private void initFloatingLabel(){
  addTextChangedListener(new TextWatcher(){
    @Override public void beforeTextChanged(    CharSequence s,    int start,    int count,    int after){
    }
    @Override public void onTextChanged(    CharSequence s,    int start,    int before,    int count){
    }
    @Override public void afterTextChanged(    Editable s){
      if (floatingLabelEnabled) {
        if (s.length() == 0) {
          if (floatingLabelShown) {
            floatingLabelShown=false;
            getLabelAnimator().reverse();
          }
        }
 else         if (!floatingLabelShown) {
          floatingLabelShown=true;
          if (getLabelAnimator().isStarted()) {
            getLabelAnimator().reverse();
          }
 else {
            getLabelAnimator().start();
          }
        }
      }
    }
  }
);
  innerFocusChangeListener=new OnFocusChangeListener(){
    @Override public void onFocusChange(    View v,    boolean hasFocus){
      if (floatingLabelEnabled && highlightFloatingLabel) {
        if (hasFocus) {
          if (getLabelFocusAnimator().isStarted()) {
            getLabelFocusAnimator().reverse();
          }
 else {
            getLabelFocusAnimator().start();
          }
        }
 else {
          getLabelFocusAnimator().reverse();
        }
        if (outerFocusChangeListener != null) {
          outerFocusChangeListener.onFocusChange(v,hasFocus);
        }
      }
    }
  }
;
  super.setOnFocusChangeListener(innerFocusChangeListener);
}"
54104,"@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(baseColor & 0x00ffffff | 0x44000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? getCurrentHintTextColor() : errorColor);
    String text;
    if (minCharacters <= 0) {
      text=isRTL() ? maxCharacters + ""String_Node_Str"" + getText().length() : getText().length() + ""String_Node_Str"" + maxCharacters;
    }
 else     if (maxCharacters <= 0) {
      text=isRTL() ? ""String_Node_Str"" + minCharacters + ""String_Node_Str""+ getText().length() : getText().length() + ""String_Node_Str"" + minCharacters+ ""String_Node_Str"";
    }
 else {
      text=isRTL() ? maxCharacters + ""String_Node_Str"" + minCharacters+ ""String_Node_Str""+ getText().length() : getText().length() + ""String_Node_Str"" + minCharacters+ ""String_Node_Str""+ maxCharacters;
    }
    canvas.drawText(text,isRTL() ? startX : endX - textPaint.measureText(text),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || (hasFocus() && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : getCurrentHintTextColor());
      canvas.save();
      canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,getCurrentHintTextColor(),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelSpacing;
    int distance=floatingLabelSpacing;
    int position=(int)(floatingLabelStartY - distance * floatingLabelFraction);
    int alpha=(int)(floatingLabelFraction * 0xff * (0.74f * focusFraction + 0.26f));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(baseColor & 0x00ffffff | 0x1E000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? getCurrentHintTextColor() : errorColor);
    String text;
    if (minCharacters <= 0) {
      text=isRTL() ? maxCharacters + ""String_Node_Str"" + getText().length() : getText().length() + ""String_Node_Str"" + maxCharacters;
    }
 else     if (maxCharacters <= 0) {
      text=isRTL() ? ""String_Node_Str"" + minCharacters + ""String_Node_Str""+ getText().length() : getText().length() + ""String_Node_Str"" + minCharacters+ ""String_Node_Str"";
    }
 else {
      text=isRTL() ? maxCharacters + ""String_Node_Str"" + minCharacters+ ""String_Node_Str""+ getText().length() : getText().length() + ""String_Node_Str"" + minCharacters+ ""String_Node_Str""+ maxCharacters;
    }
    canvas.drawText(text,isRTL() ? startX : endX - textPaint.measureText(text),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || (hasFocus() && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : getCurrentHintTextColor());
      canvas.save();
      canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,getCurrentHintTextColor(),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelSpacing;
    int distance=floatingLabelSpacing;
    int position=(int)(floatingLabelStartY - distance * floatingLabelFraction);
    int alpha=(int)(floatingLabelFraction * 0xff * (0.74f * focusFraction + 0.26f));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}"
54105,"private void initText(){
  if (!TextUtils.isEmpty(getText())) {
    CharSequence text=getText();
    setText(null);
    setHintTextColor(baseColor & 0x00ffffff | 0x44000000);
    setText(text);
    floatingLabelFraction=1;
    floatingLabelShown=true;
  }
 else {
    setHintTextColor(baseColor & 0x00ffffff | 0x44000000);
  }
}","private void initText(){
  if (!TextUtils.isEmpty(getText())) {
    CharSequence text=getText();
    setText(null);
    setText(text);
    floatingLabelFraction=1;
    floatingLabelShown=true;
  }
}"
54106,"private void initPadding(){
  extraPaddingTop=floatingLabelEnabled ? floatingLabelTextSize + floatingLabelSpacing : floatingLabelSpacing;
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  extraPaddingBottom=(int)((textMetrics.descent - textMetrics.ascent) * currentBottomLines) + (hideUnderline ? bottomSpacing : bottomSpacing * 2);
  extraPaddingLeft=iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding);
  extraPaddingRight=iconRightBitmaps == null ? 0 : (iconOuterWidth + iconPadding);
  System.out.println(""String_Node_Str"" + getPaddingLeft() + ""String_Node_Str""+ extraPaddingLeft);
  System.out.println(""String_Node_Str"" + getPaddingRight() + ""String_Node_Str""+ extraPaddingRight);
  System.out.println(""String_Node_Str"" + getPaddingTop() + ""String_Node_Str""+ extraPaddingTop);
  System.out.println(""String_Node_Str"" + getPaddingBottom() + ""String_Node_Str""+ extraPaddingBottom);
  setPaddings(innerPaddingLeft,innerPaddingTop,innerPaddingRight,innerPaddingBottom);
}","private void initPadding(){
  extraPaddingTop=floatingLabelEnabled ? floatingLabelTextSize + floatingLabelSpacing : floatingLabelSpacing;
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  extraPaddingBottom=(int)((textMetrics.descent - textMetrics.ascent) * currentBottomLines) + (hideUnderline ? bottomSpacing : bottomSpacing * 2);
  extraPaddingLeft=iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding);
  extraPaddingRight=iconRightBitmaps == null ? 0 : (iconOuterWidth + iconPadding);
  setPaddings(innerPaddingLeft,innerPaddingTop,innerPaddingRight,innerPaddingBottom);
}"
54107,"@TargetApi(Build.VERSION_CODES.LOLLIPOP) public MaterialAutoCompleteTextView(Context context,AttributeSet attrs,int style){
  super(context,attrs,style);
  setFocusable(true);
  setFocusableInTouchMode(true);
  setClickable(true);
  iconSize=getPixel(32);
  iconOuterWidth=getPixel(48);
  iconOuterHeight=getPixel(32);
  bottomSpacing=getResources().getDimensionPixelSize(R.dimen.inner_components_spacing);
  bottomEllipsisSize=getResources().getDimensionPixelSize(R.dimen.bottom_ellipsis_height);
  int defaultBaseColor;
  TypedValue baseColorTypedValue=new TypedValue();
  context.getTheme().resolveAttribute(android.R.attr.windowBackground,baseColorTypedValue,true);
  defaultBaseColor=Colors.getBaseColor(baseColorTypedValue.data);
  TypedArray typedArray=context.obtainStyledAttributes(attrs,R.styleable.MaterialEditText);
  baseColor=typedArray.getColor(R.styleable.MaterialEditText_baseColor,defaultBaseColor);
  ColorStateList colorStateList=new ColorStateList(new int[][]{new int[]{android.R.attr.state_enabled},EMPTY_STATE_SET},new int[]{baseColor & 0x00ffffff | 0xdf000000,baseColor & 0x00ffffff | 0x44000000});
  setTextColor(colorStateList);
  int defaultPrimaryColor;
  TypedValue primaryColorTypedValue=new TypedValue();
  try {
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
      throw new RuntimeException(""String_Node_Str"");
    }
    context.getTheme().resolveAttribute(android.R.attr.colorPrimary,primaryColorTypedValue,true);
    defaultPrimaryColor=primaryColorTypedValue.data;
  }
 catch (  Exception e) {
    try {
      int colorPrimaryId=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",getContext().getPackageName());
      if (colorPrimaryId != 0) {
        context.getTheme().resolveAttribute(colorPrimaryId,primaryColorTypedValue,true);
        defaultPrimaryColor=primaryColorTypedValue.data;
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
 catch (    Exception e1) {
      defaultPrimaryColor=baseColor;
    }
  }
  primaryColor=typedArray.getColor(R.styleable.MaterialEditText_primaryColor,defaultPrimaryColor);
  setFloatingLabelInternal(typedArray.getInt(R.styleable.MaterialEditText_floatingLabel,0));
  errorColor=typedArray.getColor(R.styleable.MaterialEditText_errorColor,Color.parseColor(""String_Node_Str""));
  minCharacters=typedArray.getInt(R.styleable.MaterialEditText_minCharacters,0);
  maxCharacters=typedArray.getInt(R.styleable.MaterialEditText_maxCharacters,0);
  singleLineEllipsis=typedArray.getBoolean(R.styleable.MaterialEditText_singleLineEllipsis,false);
  helperText=typedArray.getString(R.styleable.MaterialEditText_helperText);
  helperTextColor=typedArray.getColor(R.styleable.MaterialEditText_helperTextColor,-1);
  minBottomTextLines=typedArray.getInt(R.styleable.MaterialEditText_minBottomTextLines,0);
  String fontPath=typedArray.getString(R.styleable.MaterialEditText_accentTypeface);
  if (fontPath != null && !isInEditMode()) {
    accentTypeface=getCustomTypeface(fontPath);
    textPaint.setTypeface(accentTypeface);
  }
  floatingLabelText=typedArray.getString(R.styleable.MaterialEditText_floatingLabelText);
  if (floatingLabelText == null) {
    floatingLabelText=getHint();
  }
  floatingLabelSpacing=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_floatingLabelSpacing,bottomSpacing);
  floatingLabelTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_floatingLabelTextSize,getResources().getDimensionPixelSize(R.dimen.floating_label_text_size));
  bottomTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_bottomTextSize,getResources().getDimensionPixelSize(R.dimen.bottom_text_size));
  hideUnderline=typedArray.getBoolean(R.styleable.MaterialEditText_hideUnderline,false);
  autoValidate=typedArray.getBoolean(R.styleable.MaterialEditText_autoValidate,false);
  iconLeftBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_iconLeft,-1));
  iconRightBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_iconRight,-1));
  iconPadding=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_iconPadding,getPixel(8));
  typedArray.recycle();
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
    setBackground(null);
  }
 else {
    setBackgroundDrawable(null);
  }
  if (singleLineEllipsis) {
    TransformationMethod transformationMethod=getTransformationMethod();
    setSingleLine();
    setTransformationMethod(transformationMethod);
  }
  initMinBottomLines();
  initPadding();
  initText();
  initFloatingLabel();
  initTextWatcher();
  checkCharactersCount();
}","@TargetApi(Build.VERSION_CODES.LOLLIPOP) public MaterialAutoCompleteTextView(Context context,AttributeSet attrs,int style){
  super(context,attrs,style);
  init(context,attrs);
}"
54108,"@TargetApi(Build.VERSION_CODES.LOLLIPOP) public MaterialEditText(Context context,AttributeSet attrs,int style){
  super(context,attrs,style);
  setFocusable(true);
  setFocusableInTouchMode(true);
  setClickable(true);
  iconSize=getPixel(32);
  iconOuterWidth=getPixel(48);
  iconOuterHeight=getPixel(32);
  bottomSpacing=getResources().getDimensionPixelSize(R.dimen.inner_components_spacing);
  bottomEllipsisSize=getResources().getDimensionPixelSize(R.dimen.bottom_ellipsis_height);
  int defaultBaseColor;
  TypedValue baseColorTypedValue=new TypedValue();
  context.getTheme().resolveAttribute(android.R.attr.windowBackground,baseColorTypedValue,true);
  defaultBaseColor=Colors.getBaseColor(baseColorTypedValue.data);
  TypedArray typedArray=context.obtainStyledAttributes(attrs,R.styleable.MaterialEditText);
  baseColor=typedArray.getColor(R.styleable.MaterialEditText_baseColor,defaultBaseColor);
  ColorStateList colorStateList=new ColorStateList(new int[][]{new int[]{android.R.attr.state_enabled},EMPTY_STATE_SET},new int[]{baseColor & 0x00ffffff | 0xdf000000,baseColor & 0x00ffffff | 0x44000000});
  setTextColor(colorStateList);
  int defaultPrimaryColor;
  TypedValue primaryColorTypedValue=new TypedValue();
  try {
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
      throw new RuntimeException(""String_Node_Str"");
    }
    context.getTheme().resolveAttribute(android.R.attr.colorPrimary,primaryColorTypedValue,true);
    defaultPrimaryColor=primaryColorTypedValue.data;
  }
 catch (  Exception e) {
    try {
      int colorPrimaryId=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",getContext().getPackageName());
      if (colorPrimaryId != 0) {
        context.getTheme().resolveAttribute(colorPrimaryId,primaryColorTypedValue,true);
        defaultPrimaryColor=primaryColorTypedValue.data;
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
 catch (    Exception e1) {
      defaultPrimaryColor=baseColor;
    }
  }
  primaryColor=typedArray.getColor(R.styleable.MaterialEditText_primaryColor,defaultPrimaryColor);
  setFloatingLabelInternal(typedArray.getInt(R.styleable.MaterialEditText_floatingLabel,0));
  errorColor=typedArray.getColor(R.styleable.MaterialEditText_errorColor,Color.parseColor(""String_Node_Str""));
  minCharacters=typedArray.getInt(R.styleable.MaterialEditText_minCharacters,0);
  maxCharacters=typedArray.getInt(R.styleable.MaterialEditText_maxCharacters,0);
  singleLineEllipsis=typedArray.getBoolean(R.styleable.MaterialEditText_singleLineEllipsis,false);
  helperText=typedArray.getString(R.styleable.MaterialEditText_helperText);
  helperTextColor=typedArray.getColor(R.styleable.MaterialEditText_helperTextColor,-1);
  minBottomTextLines=typedArray.getInt(R.styleable.MaterialEditText_minBottomTextLines,0);
  String fontPath=typedArray.getString(R.styleable.MaterialEditText_accentTypeface);
  if (fontPath != null && !isInEditMode()) {
    accentTypeface=getCustomTypeface(fontPath);
    textPaint.setTypeface(accentTypeface);
  }
  floatingLabelText=typedArray.getString(R.styleable.MaterialEditText_floatingLabelText);
  if (floatingLabelText == null) {
    floatingLabelText=getHint();
  }
  floatingLabelSpacing=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_floatingLabelSpacing,bottomSpacing);
  floatingLabelTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_floatingLabelTextSize,getResources().getDimensionPixelSize(R.dimen.floating_label_text_size));
  bottomTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_bottomTextSize,getResources().getDimensionPixelSize(R.dimen.bottom_text_size));
  hideUnderline=typedArray.getBoolean(R.styleable.MaterialEditText_hideUnderline,false);
  autoValidate=typedArray.getBoolean(R.styleable.MaterialEditText_autoValidate,false);
  iconLeftBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_iconLeft,-1));
  iconRightBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_iconRight,-1));
  iconPadding=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_iconPadding,getPixel(8));
  typedArray.recycle();
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
    setBackground(null);
  }
 else {
    setBackgroundDrawable(null);
  }
  if (singleLineEllipsis) {
    TransformationMethod transformationMethod=getTransformationMethod();
    setSingleLine();
    setTransformationMethod(transformationMethod);
  }
  initMinBottomLines();
  initPadding();
  initText();
  initFloatingLabel();
  initTextWatcher();
  checkCharactersCount();
}","@TargetApi(Build.VERSION_CODES.LOLLIPOP) public MaterialEditText(Context context,AttributeSet attrs,int style){
  super(context,attrs,style);
  init(context,attrs);
}"
54109,"@TargetApi(Build.VERSION_CODES.LOLLIPOP) public MaterialMultiAutoCompleteTextView(Context context,AttributeSet attrs,int style){
  super(context,attrs,style);
  setFocusable(true);
  setFocusableInTouchMode(true);
  setClickable(true);
  iconSize=getPixel(32);
  iconOuterWidth=getPixel(48);
  iconOuterHeight=getPixel(32);
  bottomSpacing=getResources().getDimensionPixelSize(R.dimen.inner_components_spacing);
  bottomEllipsisSize=getResources().getDimensionPixelSize(R.dimen.bottom_ellipsis_height);
  int defaultBaseColor;
  TypedValue baseColorTypedValue=new TypedValue();
  context.getTheme().resolveAttribute(android.R.attr.windowBackground,baseColorTypedValue,true);
  defaultBaseColor=Colors.getBaseColor(baseColorTypedValue.data);
  TypedArray typedArray=context.obtainStyledAttributes(attrs,R.styleable.MaterialEditText);
  baseColor=typedArray.getColor(R.styleable.MaterialEditText_baseColor,defaultBaseColor);
  ColorStateList colorStateList=new ColorStateList(new int[][]{new int[]{android.R.attr.state_enabled},EMPTY_STATE_SET},new int[]{baseColor & 0x00ffffff | 0xdf000000,baseColor & 0x00ffffff | 0x44000000});
  setTextColor(colorStateList);
  int defaultPrimaryColor;
  TypedValue primaryColorTypedValue=new TypedValue();
  try {
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
      throw new RuntimeException(""String_Node_Str"");
    }
    context.getTheme().resolveAttribute(android.R.attr.colorPrimary,primaryColorTypedValue,true);
    defaultPrimaryColor=primaryColorTypedValue.data;
  }
 catch (  Exception e) {
    try {
      int colorPrimaryId=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",getContext().getPackageName());
      if (colorPrimaryId != 0) {
        context.getTheme().resolveAttribute(colorPrimaryId,primaryColorTypedValue,true);
        defaultPrimaryColor=primaryColorTypedValue.data;
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
 catch (    Exception e1) {
      defaultPrimaryColor=baseColor;
    }
  }
  primaryColor=typedArray.getColor(R.styleable.MaterialEditText_primaryColor,defaultPrimaryColor);
  setFloatingLabelInternal(typedArray.getInt(R.styleable.MaterialEditText_floatingLabel,0));
  errorColor=typedArray.getColor(R.styleable.MaterialEditText_errorColor,Color.parseColor(""String_Node_Str""));
  minCharacters=typedArray.getInt(R.styleable.MaterialEditText_minCharacters,0);
  maxCharacters=typedArray.getInt(R.styleable.MaterialEditText_maxCharacters,0);
  singleLineEllipsis=typedArray.getBoolean(R.styleable.MaterialEditText_singleLineEllipsis,false);
  helperText=typedArray.getString(R.styleable.MaterialEditText_helperText);
  helperTextColor=typedArray.getColor(R.styleable.MaterialEditText_helperTextColor,-1);
  minBottomTextLines=typedArray.getInt(R.styleable.MaterialEditText_minBottomTextLines,0);
  String fontPath=typedArray.getString(R.styleable.MaterialEditText_accentTypeface);
  if (fontPath != null && !isInEditMode()) {
    accentTypeface=getCustomTypeface(fontPath);
    textPaint.setTypeface(accentTypeface);
  }
  floatingLabelText=typedArray.getString(R.styleable.MaterialEditText_floatingLabelText);
  if (floatingLabelText == null) {
    floatingLabelText=getHint();
  }
  floatingLabelSpacing=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_floatingLabelSpacing,bottomSpacing);
  floatingLabelTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_floatingLabelTextSize,getResources().getDimensionPixelSize(R.dimen.floating_label_text_size));
  bottomTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_bottomTextSize,getResources().getDimensionPixelSize(R.dimen.bottom_text_size));
  hideUnderline=typedArray.getBoolean(R.styleable.MaterialEditText_hideUnderline,false);
  autoValidate=typedArray.getBoolean(R.styleable.MaterialEditText_autoValidate,false);
  iconLeftBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_iconLeft,-1));
  iconRightBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_iconRight,-1));
  iconPadding=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_iconPadding,getPixel(8));
  typedArray.recycle();
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
    setBackground(null);
  }
 else {
    setBackgroundDrawable(null);
  }
  if (singleLineEllipsis) {
    TransformationMethod transformationMethod=getTransformationMethod();
    setSingleLine();
    setTransformationMethod(transformationMethod);
  }
  initMinBottomLines();
  initPadding();
  initText();
  initFloatingLabel();
  initTextWatcher();
  checkCharactersCount();
}","@TargetApi(Build.VERSION_CODES.LOLLIPOP) public MaterialMultiAutoCompleteTextView(Context context,AttributeSet attrs,int style){
  super(context,attrs,style);
  init(context,attrs);
}"
54110,"private void init(Context context,AttributeSet attrs){
  iconSize=getPixel(32);
  iconOuterWidth=getPixel(48);
  iconOuterHeight=getPixel(32);
  bottomSpacing=getResources().getDimensionPixelSize(R.dimen.inner_components_spacing);
  bottomEllipsisSize=getResources().getDimensionPixelSize(R.dimen.bottom_ellipsis_height);
  int defaultBaseColor;
  TypedValue baseColorTypedValue=new TypedValue();
  context.getTheme().resolveAttribute(android.R.attr.windowBackground,baseColorTypedValue,true);
  defaultBaseColor=Colors.getBaseColor(baseColorTypedValue.data);
  TypedArray typedArray=context.obtainStyledAttributes(attrs,R.styleable.MaterialEditText);
  baseColor=typedArray.getColor(R.styleable.MaterialEditText_baseColor,defaultBaseColor);
  ColorStateList colorStateList=new ColorStateList(new int[][]{new int[]{android.R.attr.state_enabled},EMPTY_STATE_SET},new int[]{baseColor & 0x00ffffff | 0xdf000000,baseColor & 0x00ffffff | 0x44000000});
  setTextColor(colorStateList);
  int defaultPrimaryColor;
  TypedValue primaryColorTypedValue=new TypedValue();
  try {
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
      throw new RuntimeException(""String_Node_Str"");
    }
    context.getTheme().resolveAttribute(android.R.attr.colorPrimary,primaryColorTypedValue,true);
    defaultPrimaryColor=primaryColorTypedValue.data;
  }
 catch (  Exception e) {
    try {
      int colorPrimaryId=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",getContext().getPackageName());
      if (colorPrimaryId != 0) {
        context.getTheme().resolveAttribute(colorPrimaryId,primaryColorTypedValue,true);
        defaultPrimaryColor=primaryColorTypedValue.data;
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
 catch (    Exception e1) {
      defaultPrimaryColor=baseColor;
    }
  }
  primaryColor=typedArray.getColor(R.styleable.MaterialEditText_primaryColor,defaultPrimaryColor);
  setFloatingLabelInternal(typedArray.getInt(R.styleable.MaterialEditText_floatingLabel,0));
  errorColor=typedArray.getColor(R.styleable.MaterialEditText_errorColor,Color.parseColor(""String_Node_Str""));
  minCharacters=typedArray.getInt(R.styleable.MaterialEditText_minCharacters,0);
  maxCharacters=typedArray.getInt(R.styleable.MaterialEditText_maxCharacters,0);
  singleLineEllipsis=typedArray.getBoolean(R.styleable.MaterialEditText_singleLineEllipsis,false);
  helperText=typedArray.getString(R.styleable.MaterialEditText_helperText);
  helperTextColor=typedArray.getColor(R.styleable.MaterialEditText_helperTextColor,-1);
  minBottomTextLines=typedArray.getInt(R.styleable.MaterialEditText_minBottomTextLines,0);
  String fontPath=typedArray.getString(R.styleable.MaterialEditText_accentTypeface);
  if (fontPath != null && !isInEditMode()) {
    accentTypeface=getCustomTypeface(fontPath);
    textPaint.setTypeface(accentTypeface);
  }
  floatingLabelText=typedArray.getString(R.styleable.MaterialEditText_floatingLabelText);
  if (floatingLabelText == null) {
    floatingLabelText=getHint();
  }
  floatingLabelSpacing=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_floatingLabelSpacing,bottomSpacing);
  floatingLabelTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_floatingLabelTextSize,getResources().getDimensionPixelSize(R.dimen.floating_label_text_size));
  bottomTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_bottomTextSize,getResources().getDimensionPixelSize(R.dimen.bottom_text_size));
  hideUnderline=typedArray.getBoolean(R.styleable.MaterialEditText_hideUnderline,false);
  autoValidate=typedArray.getBoolean(R.styleable.MaterialEditText_autoValidate,false);
  iconLeftBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_iconLeft,-1));
  iconRightBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_iconRight,-1));
  iconPadding=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_iconPadding,getPixel(8));
  typedArray.recycle();
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
    setBackground(null);
  }
 else {
    setBackgroundDrawable(null);
  }
  if (singleLineEllipsis) {
    TransformationMethod transformationMethod=getTransformationMethod();
    setSingleLine();
    setTransformationMethod(transformationMethod);
  }
  initMinBottomLines();
  initPadding();
  initText();
  initFloatingLabel();
  initTextWatcher();
  checkCharactersCount();
}","private void init(Context context,AttributeSet attrs){
  iconSize=getPixel(32);
  iconOuterWidth=getPixel(48);
  iconOuterHeight=getPixel(32);
  bottomSpacing=getResources().getDimensionPixelSize(R.dimen.inner_components_spacing);
  bottomEllipsisSize=getResources().getDimensionPixelSize(R.dimen.bottom_ellipsis_height);
  int defaultBaseColor;
  TypedValue baseColorTypedValue=new TypedValue();
  context.getTheme().resolveAttribute(android.R.attr.windowBackground,baseColorTypedValue,true);
  defaultBaseColor=Colors.getBaseColor(baseColorTypedValue.data);
  TypedArray typedArray=context.obtainStyledAttributes(attrs,R.styleable.MaterialEditText);
  baseColor=typedArray.getColor(R.styleable.MaterialEditText_baseColor,defaultBaseColor);
  ColorStateList colorStateList=new ColorStateList(new int[][]{new int[]{android.R.attr.state_enabled},EMPTY_STATE_SET},new int[]{baseColor & 0x00ffffff | 0xdf000000,baseColor & 0x00ffffff | 0x44000000});
  setTextColor(colorStateList);
  int defaultPrimaryColor;
  TypedValue primaryColorTypedValue=new TypedValue();
  try {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      context.getTheme().resolveAttribute(android.R.attr.colorPrimary,primaryColorTypedValue,true);
      defaultPrimaryColor=primaryColorTypedValue.data;
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    try {
      int colorPrimaryId=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",getContext().getPackageName());
      if (colorPrimaryId != 0) {
        context.getTheme().resolveAttribute(colorPrimaryId,primaryColorTypedValue,true);
        defaultPrimaryColor=primaryColorTypedValue.data;
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
 catch (    Exception e1) {
      defaultPrimaryColor=baseColor;
    }
  }
  primaryColor=typedArray.getColor(R.styleable.MaterialEditText_primaryColor,defaultPrimaryColor);
  setFloatingLabelInternal(typedArray.getInt(R.styleable.MaterialEditText_floatingLabel,0));
  errorColor=typedArray.getColor(R.styleable.MaterialEditText_errorColor,Color.parseColor(""String_Node_Str""));
  minCharacters=typedArray.getInt(R.styleable.MaterialEditText_minCharacters,0);
  maxCharacters=typedArray.getInt(R.styleable.MaterialEditText_maxCharacters,0);
  singleLineEllipsis=typedArray.getBoolean(R.styleable.MaterialEditText_singleLineEllipsis,false);
  helperText=typedArray.getString(R.styleable.MaterialEditText_helperText);
  helperTextColor=typedArray.getColor(R.styleable.MaterialEditText_helperTextColor,-1);
  minBottomTextLines=typedArray.getInt(R.styleable.MaterialEditText_minBottomTextLines,0);
  String fontPath=typedArray.getString(R.styleable.MaterialEditText_accentTypeface);
  if (fontPath != null && !isInEditMode()) {
    accentTypeface=getCustomTypeface(fontPath);
    textPaint.setTypeface(accentTypeface);
  }
  floatingLabelText=typedArray.getString(R.styleable.MaterialEditText_floatingLabelText);
  if (floatingLabelText == null) {
    floatingLabelText=getHint();
  }
  floatingLabelSpacing=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_floatingLabelSpacing,bottomSpacing);
  floatingLabelTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_floatingLabelTextSize,getResources().getDimensionPixelSize(R.dimen.floating_label_text_size));
  bottomTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_bottomTextSize,getResources().getDimensionPixelSize(R.dimen.bottom_text_size));
  hideUnderline=typedArray.getBoolean(R.styleable.MaterialEditText_hideUnderline,false);
  autoValidate=typedArray.getBoolean(R.styleable.MaterialEditText_autoValidate,false);
  iconLeftBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_iconLeft,-1));
  iconRightBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_iconRight,-1));
  iconPadding=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_iconPadding,getPixel(8));
  int[] paddings=new int[]{android.R.attr.padding,android.R.attr.paddingLeft,android.R.attr.paddingTop,android.R.attr.paddingRight,android.R.attr.paddingBottom};
  TypedArray paddingsTypedArray=context.obtainStyledAttributes(attrs,paddings);
  int padding=paddingsTypedArray.getDimensionPixelSize(0,0);
  innerPaddingLeft=paddingsTypedArray.getDimensionPixelSize(1,padding);
  innerPaddingTop=paddingsTypedArray.getDimensionPixelSize(2,padding);
  innerPaddingRight=paddingsTypedArray.getDimensionPixelSize(3,padding);
  innerPaddingBottom=paddingsTypedArray.getDimensionPixelSize(4,padding);
  typedArray.recycle();
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
    setBackground(null);
  }
 else {
    setBackgroundDrawable(null);
  }
  if (singleLineEllipsis) {
    TransformationMethod transformationMethod=getTransformationMethod();
    setSingleLine();
    setTransformationMethod(transformationMethod);
  }
  initMinBottomLines();
  initPadding();
  initText();
  initFloatingLabel();
  initTextWatcher();
  checkCharactersCount();
}"
54111,"@Override public void setError(CharSequence errorText){
  tempErrorText=errorText == null ? null : errorText.toString();
  adjustBottomLines();
  postInvalidate();
}","@Override public void setError(CharSequence errorText){
  tempErrorText=errorText == null ? null : errorText.toString();
  if (adjustBottomLines()) {
    postInvalidate();
  }
}"
54112,"public void setHelperText(CharSequence helperText){
  this.helperText=helperText == null ? null : helperText.toString();
  adjustBottomLines();
  postInvalidate();
}","public void setHelperText(CharSequence helperText){
  this.helperText=helperText == null ? null : helperText.toString();
  if (adjustBottomLines()) {
    postInvalidate();
  }
}"
54113,"@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(baseColor & 0x00ffffff | 0x44000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? getCurrentHintTextColor() : errorColor);
    String text;
    if (minCharacters <= 0) {
      text=isRTL() ? maxCharacters + ""String_Node_Str"" + getText().length() : getText().length() + ""String_Node_Str"" + maxCharacters;
    }
 else     if (maxCharacters <= 0) {
      text=isRTL() ? ""String_Node_Str"" + minCharacters + ""String_Node_Str""+ getText().length() : getText().length() + ""String_Node_Str"" + minCharacters+ ""String_Node_Str"";
    }
 else {
      text=isRTL() ? maxCharacters + ""String_Node_Str"" + minCharacters+ ""String_Node_Str""+ getText().length() : getText().length() + ""String_Node_Str"" + minCharacters+ ""String_Node_Str""+ maxCharacters;
    }
    canvas.drawText(text,isRTL() ? startX : endX - textPaint.measureText(text),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    float bottomTextStartX=startX + getBottomTextLeftOffset();
    if (tempErrorText != null) {
      textPaint.setColor(errorColor);
      canvas.save();
      canvas.translate(bottomTextStartX,lineStartY + bottomSpacing - bottomTextPadding);
      textLayout.draw(canvas);
      canvas.restore();
    }
 else     if (hasFocus() && !TextUtils.isEmpty(helperText)) {
      textPaint.setColor(helperTextColor != -1 ? helperTextColor : getCurrentHintTextColor());
      canvas.save();
      canvas.translate(bottomTextStartX,lineStartY + bottomSpacing - bottomTextPadding);
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,getCurrentHintTextColor(),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelSpacing;
    int distance=floatingLabelSpacing;
    int position=(int)(floatingLabelStartY - distance * floatingLabelFraction);
    int alpha=(int)(floatingLabelFraction * 0xff * (0.74f * focusFraction + 0.26f));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(baseColor & 0x00ffffff | 0x44000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? getCurrentHintTextColor() : errorColor);
    String text;
    if (minCharacters <= 0) {
      text=isRTL() ? maxCharacters + ""String_Node_Str"" + getText().length() : getText().length() + ""String_Node_Str"" + maxCharacters;
    }
 else     if (maxCharacters <= 0) {
      text=isRTL() ? ""String_Node_Str"" + minCharacters + ""String_Node_Str""+ getText().length() : getText().length() + ""String_Node_Str"" + minCharacters+ ""String_Node_Str"";
    }
 else {
      text=isRTL() ? maxCharacters + ""String_Node_Str"" + minCharacters+ ""String_Node_Str""+ getText().length() : getText().length() + ""String_Node_Str"" + minCharacters+ ""String_Node_Str""+ maxCharacters;
    }
    canvas.drawText(text,isRTL() ? startX : endX - textPaint.measureText(text),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || (hasFocus() && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : getCurrentHintTextColor());
      canvas.save();
      canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,getCurrentHintTextColor(),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelSpacing;
    int distance=floatingLabelSpacing;
    int position=(int)(floatingLabelStartY - distance * floatingLabelFraction);
    int alpha=(int)(floatingLabelFraction * 0xff * (0.74f * focusFraction + 0.26f));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}"
54114,"private ObjectAnimator getBottomLinesAnimator(float destBottomLines){
  if (bottomLinesAnimator == null) {
    bottomLinesAnimator=ObjectAnimator.ofFloat(this,""String_Node_Str"",destBottomLines);
  }
 else {
    bottomLinesAnimator.end();
    bottomLinesAnimator.setFloatValues(destBottomLines);
  }
  return bottomLinesAnimator;
}","private ObjectAnimator getBottomLinesAnimator(float destBottomLines){
  if (bottomLinesAnimator == null) {
    bottomLinesAnimator=ObjectAnimator.ofFloat(this,""String_Node_Str"",destBottomLines);
  }
 else {
    bottomLinesAnimator.cancel();
    bottomLinesAnimator.setFloatValues(destBottomLines);
  }
  return bottomLinesAnimator;
}"
54115,"private void adjustBottomLines(){
  int destBottomLines;
  textPaint.setTextSize(bottomTextSize);
  if (tempErrorText != null) {
    textLayout=new StaticLayout(tempErrorText,textPaint,getMeasuredWidth() - getBottomTextLeftOffset() - getBottomTextRightOffset()- getPaddingLeft()- getPaddingRight(),Layout.Alignment.ALIGN_NORMAL,1.0f,0.0f,true);
    destBottomLines=Math.max(textLayout.getLineCount(),minBottomTextLines);
  }
 else   if (helperText != null) {
    textLayout=new StaticLayout(helperText,textPaint,getMeasuredWidth() - getBottomTextLeftOffset() - getBottomTextRightOffset()- getPaddingLeft()- getPaddingRight(),Layout.Alignment.ALIGN_NORMAL,1.0f,0.0f,true);
    destBottomLines=Math.max(textLayout.getLineCount(),minBottomTextLines);
  }
 else {
    destBottomLines=minBottomLines;
  }
  if (bottomLines != destBottomLines) {
    getBottomLinesAnimator(destBottomLines).start();
  }
  bottomLines=destBottomLines;
}","/** 
 * @return True, if adjustments were made that require the view to be invalidated.
 */
private boolean adjustBottomLines(){
  if (getWidth() == 0) {
    return false;
  }
  int destBottomLines;
  textPaint.setTextSize(bottomTextSize);
  if (tempErrorText != null || helperText != null) {
    Layout.Alignment alignment=(getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL() ? Layout.Alignment.ALIGN_OPPOSITE : (getGravity() & Gravity.LEFT) == Gravity.LEFT ? Layout.Alignment.ALIGN_NORMAL : Layout.Alignment.ALIGN_CENTER;
    textLayout=new StaticLayout(tempErrorText != null ? tempErrorText : helperText,textPaint,getWidth() - getBottomTextLeftOffset() - getBottomTextRightOffset()- getPaddingLeft()- getPaddingRight(),alignment,1.0f,0.0f,true);
    destBottomLines=Math.max(textLayout.getLineCount(),minBottomTextLines);
  }
 else {
    destBottomLines=minBottomLines;
  }
  if (bottomLines != destBottomLines) {
    getBottomLinesAnimator(destBottomLines).start();
  }
  bottomLines=destBottomLines;
  return true;
}"
54116,"private void initPadding(){
  int paddingTop=getPaddingTop() - extraPaddingTop;
  int paddingBottom=getPaddingBottom() - extraPaddingBottom;
  int paddingLeft=getPaddingLeft() - extraPaddingLeft;
  int paddingRight=getPaddingRight() - extraPaddingRight;
  extraPaddingTop=floatingLabelEnabled ? floatingLabelTextSize + floatingLabelSpacing : floatingLabelSpacing;
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  extraPaddingBottom=(int)((textMetrics.descent - textMetrics.ascent) * currentBottomLines) + (hideUnderline ? bottomSpacing : bottomSpacing * 2);
  extraPaddingLeft=iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding);
  extraPaddingRight=iconRightBitmaps == null ? 0 : (iconOuterWidth + iconPadding);
  setPaddings(paddingLeft,paddingTop,paddingRight,paddingBottom);
}","private void initPadding(){
  extraPaddingTop=floatingLabelEnabled ? floatingLabelTextSize + floatingLabelSpacing : floatingLabelSpacing;
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  extraPaddingBottom=(int)((textMetrics.descent - textMetrics.ascent) * currentBottomLines) + (hideUnderline ? bottomSpacing : bottomSpacing * 2);
  extraPaddingLeft=iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding);
  extraPaddingRight=iconRightBitmaps == null ? 0 : (iconOuterWidth + iconPadding);
  System.out.println(""String_Node_Str"" + getPaddingLeft() + ""String_Node_Str""+ extraPaddingLeft);
  System.out.println(""String_Node_Str"" + getPaddingRight() + ""String_Node_Str""+ extraPaddingRight);
  System.out.println(""String_Node_Str"" + getPaddingTop() + ""String_Node_Str""+ extraPaddingTop);
  System.out.println(""String_Node_Str"" + getPaddingBottom() + ""String_Node_Str""+ extraPaddingBottom);
  setPaddings(innerPaddingLeft,innerPaddingTop,innerPaddingRight,innerPaddingBottom);
}"
54117,"private void init(Context context,AttributeSet attrs){
  iconSize=getPixel(32);
  iconOuterWidth=getPixel(48);
  iconOuterHeight=getPixel(32);
  bottomSpacing=getResources().getDimensionPixelSize(R.dimen.inner_components_spacing);
  bottomEllipsisSize=getResources().getDimensionPixelSize(R.dimen.bottom_ellipsis_height);
  int defaultBaseColor;
  TypedValue baseColorTypedValue=new TypedValue();
  context.getTheme().resolveAttribute(android.R.attr.windowBackground,baseColorTypedValue,true);
  defaultBaseColor=Colors.getBaseColor(baseColorTypedValue.data);
  TypedArray typedArray=context.obtainStyledAttributes(attrs,R.styleable.MaterialEditText);
  baseColor=typedArray.getColor(R.styleable.MaterialEditText_baseColor,defaultBaseColor);
  ColorStateList colorStateList=new ColorStateList(new int[][]{new int[]{android.R.attr.state_enabled},EMPTY_STATE_SET},new int[]{baseColor & 0x00ffffff | 0xdf000000,baseColor & 0x00ffffff | 0x44000000});
  setTextColor(colorStateList);
  int defaultPrimaryColor;
  TypedValue primaryColorTypedValue=new TypedValue();
  try {
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
      throw new RuntimeException(""String_Node_Str"");
    }
    context.getTheme().resolveAttribute(android.R.attr.colorPrimary,primaryColorTypedValue,true);
    defaultPrimaryColor=primaryColorTypedValue.data;
  }
 catch (  Exception e) {
    try {
      int colorPrimaryId=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",getContext().getPackageName());
      if (colorPrimaryId != 0) {
        context.getTheme().resolveAttribute(colorPrimaryId,primaryColorTypedValue,true);
        defaultPrimaryColor=primaryColorTypedValue.data;
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
 catch (    Exception e1) {
      defaultPrimaryColor=baseColor;
    }
  }
  primaryColor=typedArray.getColor(R.styleable.MaterialEditText_primaryColor,defaultPrimaryColor);
  setFloatingLabelInternal(typedArray.getInt(R.styleable.MaterialEditText_floatingLabel,0));
  errorColor=typedArray.getColor(R.styleable.MaterialEditText_errorColor,Color.parseColor(""String_Node_Str""));
  minCharacters=typedArray.getInt(R.styleable.MaterialEditText_minCharacters,0);
  maxCharacters=typedArray.getInt(R.styleable.MaterialEditText_maxCharacters,0);
  singleLineEllipsis=typedArray.getBoolean(R.styleable.MaterialEditText_singleLineEllipsis,false);
  helperText=typedArray.getString(R.styleable.MaterialEditText_helperText);
  helperTextColor=typedArray.getColor(R.styleable.MaterialEditText_helperTextColor,-1);
  minBottomTextLines=typedArray.getInt(R.styleable.MaterialEditText_minBottomTextLines,0);
  String fontPath=typedArray.getString(R.styleable.MaterialEditText_accentTypeface);
  if (fontPath != null && !isInEditMode()) {
    accentTypeface=getCustomTypeface(fontPath);
    textPaint.setTypeface(accentTypeface);
  }
  floatingLabelText=typedArray.getString(R.styleable.MaterialEditText_floatingLabelText);
  if (floatingLabelText == null) {
    floatingLabelText=getHint();
  }
  floatingLabelSpacing=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_floatingLabelSpacing,bottomSpacing);
  floatingLabelTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_floatingLabelTextSize,getResources().getDimensionPixelSize(R.dimen.floating_label_text_size));
  bottomTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_bottomTextSize,getResources().getDimensionPixelSize(R.dimen.bottom_text_size));
  hideUnderline=typedArray.getBoolean(R.styleable.MaterialEditText_hideUnderline,false);
  autoValidate=typedArray.getBoolean(R.styleable.MaterialEditText_autoValidate,false);
  iconLeftBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_iconLeft,-1));
  iconRightBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_iconRight,-1));
  iconPadding=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_iconPadding,getPixel(8));
  typedArray.recycle();
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
    setBackground(null);
  }
 else {
    setBackgroundDrawable(null);
  }
  if (singleLineEllipsis) {
    TransformationMethod transformationMethod=getTransformationMethod();
    setSingleLine();
    setTransformationMethod(transformationMethod);
  }
  initMinBottomLines();
  initPadding();
  initText();
  initFloatingLabel();
  initTextWatcher();
  checkCharactersCount();
}","private void init(Context context,AttributeSet attrs){
  iconSize=getPixel(32);
  iconOuterWidth=getPixel(48);
  iconOuterHeight=getPixel(32);
  bottomSpacing=getResources().getDimensionPixelSize(R.dimen.inner_components_spacing);
  bottomEllipsisSize=getResources().getDimensionPixelSize(R.dimen.bottom_ellipsis_height);
  int defaultBaseColor;
  TypedValue baseColorTypedValue=new TypedValue();
  context.getTheme().resolveAttribute(android.R.attr.windowBackground,baseColorTypedValue,true);
  defaultBaseColor=Colors.getBaseColor(baseColorTypedValue.data);
  TypedArray typedArray=context.obtainStyledAttributes(attrs,R.styleable.MaterialEditText);
  baseColor=typedArray.getColor(R.styleable.MaterialEditText_baseColor,defaultBaseColor);
  ColorStateList colorStateList=new ColorStateList(new int[][]{new int[]{android.R.attr.state_enabled},EMPTY_STATE_SET},new int[]{baseColor & 0x00ffffff | 0xdf000000,baseColor & 0x00ffffff | 0x44000000});
  setTextColor(colorStateList);
  int defaultPrimaryColor;
  TypedValue primaryColorTypedValue=new TypedValue();
  try {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
      context.getTheme().resolveAttribute(android.R.attr.colorPrimary,primaryColorTypedValue,true);
      defaultPrimaryColor=primaryColorTypedValue.data;
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    try {
      int colorPrimaryId=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",getContext().getPackageName());
      if (colorPrimaryId != 0) {
        context.getTheme().resolveAttribute(colorPrimaryId,primaryColorTypedValue,true);
        defaultPrimaryColor=primaryColorTypedValue.data;
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
 catch (    Exception e1) {
      defaultPrimaryColor=baseColor;
    }
  }
  primaryColor=typedArray.getColor(R.styleable.MaterialEditText_primaryColor,defaultPrimaryColor);
  setFloatingLabelInternal(typedArray.getInt(R.styleable.MaterialEditText_floatingLabel,0));
  errorColor=typedArray.getColor(R.styleable.MaterialEditText_errorColor,Color.parseColor(""String_Node_Str""));
  minCharacters=typedArray.getInt(R.styleable.MaterialEditText_minCharacters,0);
  maxCharacters=typedArray.getInt(R.styleable.MaterialEditText_maxCharacters,0);
  singleLineEllipsis=typedArray.getBoolean(R.styleable.MaterialEditText_singleLineEllipsis,false);
  helperText=typedArray.getString(R.styleable.MaterialEditText_helperText);
  helperTextColor=typedArray.getColor(R.styleable.MaterialEditText_helperTextColor,-1);
  minBottomTextLines=typedArray.getInt(R.styleable.MaterialEditText_minBottomTextLines,0);
  String fontPath=typedArray.getString(R.styleable.MaterialEditText_accentTypeface);
  if (fontPath != null && !isInEditMode()) {
    accentTypeface=getCustomTypeface(fontPath);
    textPaint.setTypeface(accentTypeface);
  }
  floatingLabelText=typedArray.getString(R.styleable.MaterialEditText_floatingLabelText);
  if (floatingLabelText == null) {
    floatingLabelText=getHint();
  }
  floatingLabelSpacing=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_floatingLabelSpacing,bottomSpacing);
  floatingLabelTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_floatingLabelTextSize,getResources().getDimensionPixelSize(R.dimen.floating_label_text_size));
  bottomTextSize=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_bottomTextSize,getResources().getDimensionPixelSize(R.dimen.bottom_text_size));
  hideUnderline=typedArray.getBoolean(R.styleable.MaterialEditText_hideUnderline,false);
  autoValidate=typedArray.getBoolean(R.styleable.MaterialEditText_autoValidate,false);
  iconLeftBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_iconLeft,-1));
  iconRightBitmaps=generateIconBitmaps(typedArray.getResourceId(R.styleable.MaterialEditText_iconRight,-1));
  iconPadding=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_iconPadding,getPixel(8));
  int[] paddings=new int[]{android.R.attr.padding,android.R.attr.paddingLeft,android.R.attr.paddingTop,android.R.attr.paddingRight,android.R.attr.paddingBottom};
  TypedArray paddingsTypedArray=context.obtainStyledAttributes(attrs,paddings);
  int padding=paddingsTypedArray.getDimensionPixelSize(0,0);
  innerPaddingLeft=paddingsTypedArray.getDimensionPixelSize(1,padding);
  innerPaddingTop=paddingsTypedArray.getDimensionPixelSize(2,padding);
  innerPaddingRight=paddingsTypedArray.getDimensionPixelSize(3,padding);
  innerPaddingBottom=paddingsTypedArray.getDimensionPixelSize(4,padding);
  typedArray.recycle();
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
    setBackground(null);
  }
 else {
    setBackgroundDrawable(null);
  }
  if (singleLineEllipsis) {
    TransformationMethod transformationMethod=getTransformationMethod();
    setSingleLine();
    setTransformationMethod(transformationMethod);
  }
  initMinBottomLines();
  initPadding();
  initText();
  initFloatingLabel();
  initTextWatcher();
  checkCharactersCount();
}"
54118,"@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(baseColor & 0x00ffffff | 0x44000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? getCurrentHintTextColor() : errorColor);
    String text;
    if (minCharacters <= 0) {
      text=isRTL() ? maxCharacters + ""String_Node_Str"" + getText().length() : getText().length() + ""String_Node_Str"" + maxCharacters;
    }
 else     if (maxCharacters <= 0) {
      text=isRTL() ? ""String_Node_Str"" + minCharacters + ""String_Node_Str""+ getText().length() : getText().length() + ""String_Node_Str"" + minCharacters+ ""String_Node_Str"";
    }
 else {
      text=isRTL() ? maxCharacters + ""String_Node_Str"" + minCharacters+ ""String_Node_Str""+ getText().length() : getText().length() + ""String_Node_Str"" + minCharacters+ ""String_Node_Str""+ maxCharacters;
    }
    canvas.drawText(text,isRTL() ? startX : endX - textPaint.measureText(text),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    float bottomTextStartX=startX + getBottomTextLeftOffset();
    if (tempErrorText != null) {
      textPaint.setColor(errorColor);
      canvas.save();
      canvas.translate(bottomTextStartX,lineStartY + bottomSpacing - bottomTextPadding);
      textLayout.draw(canvas);
      canvas.restore();
    }
 else     if (hasFocus() && !TextUtils.isEmpty(helperText)) {
      textPaint.setColor(helperTextColor != -1 ? helperTextColor : getCurrentHintTextColor());
      canvas.save();
      canvas.translate(bottomTextStartX,lineStartY + bottomSpacing - bottomTextPadding);
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,getCurrentHintTextColor(),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelSpacing;
    int distance=floatingLabelSpacing;
    int position=(int)(floatingLabelStartY - distance * floatingLabelFraction);
    int alpha=(int)(floatingLabelFraction * 0xff * (0.74f * focusFraction + 0.26f));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}","@Override protected void onDraw(@NonNull Canvas canvas){
  int startX=getScrollX() + (iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding));
  int endX=getScrollX() + (iconRightBitmaps == null ? getWidth() : getWidth() - iconOuterWidth - iconPadding);
  int lineStartY=getScrollY() + getHeight() - getPaddingBottom();
  paint.setAlpha(255);
  if (iconLeftBitmaps != null) {
    Bitmap icon=iconLeftBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconLeft=startX - iconPadding - iconOuterWidth + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconLeft,iconTop,paint);
  }
  if (iconRightBitmaps != null) {
    Bitmap icon=iconRightBitmaps[!isInternalValid() ? 3 : !isEnabled() ? 2 : hasFocus() ? 1 : 0];
    int iconRight=endX + iconPadding + (iconOuterWidth - icon.getWidth()) / 2;
    int iconTop=lineStartY + bottomSpacing - iconOuterHeight + (iconOuterHeight - icon.getHeight()) / 2;
    canvas.drawBitmap(icon,iconRight,iconTop,paint);
  }
  if (!hideUnderline) {
    lineStartY+=bottomSpacing;
    if (!isInternalValid()) {
      paint.setColor(errorColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else     if (!isEnabled()) {
      paint.setColor(baseColor & 0x00ffffff | 0x44000000);
      float interval=getPixel(1);
      for (float xOffset=0; xOffset < getWidth(); xOffset+=interval * 3) {
        canvas.drawRect(startX + xOffset,lineStartY,startX + xOffset + interval,lineStartY + getPixel(1),paint);
      }
    }
 else     if (hasFocus()) {
      paint.setColor(primaryColor);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(2),paint);
    }
 else {
      paint.setColor(baseColor & 0x00ffffff | 0x44000000);
      canvas.drawRect(startX,lineStartY,endX,lineStartY + getPixel(1),paint);
    }
  }
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  float relativeHeight=-textMetrics.ascent - textMetrics.descent;
  float bottomTextPadding=bottomTextSize + textMetrics.ascent + textMetrics.descent;
  if ((hasFocus() && hasCharatersCounter()) || !isCharactersCountValid()) {
    textPaint.setColor(isCharactersCountValid() ? getCurrentHintTextColor() : errorColor);
    String text;
    if (minCharacters <= 0) {
      text=isRTL() ? maxCharacters + ""String_Node_Str"" + getText().length() : getText().length() + ""String_Node_Str"" + maxCharacters;
    }
 else     if (maxCharacters <= 0) {
      text=isRTL() ? ""String_Node_Str"" + minCharacters + ""String_Node_Str""+ getText().length() : getText().length() + ""String_Node_Str"" + minCharacters+ ""String_Node_Str"";
    }
 else {
      text=isRTL() ? maxCharacters + ""String_Node_Str"" + minCharacters+ ""String_Node_Str""+ getText().length() : getText().length() + ""String_Node_Str"" + minCharacters+ ""String_Node_Str""+ maxCharacters;
    }
    canvas.drawText(text,isRTL() ? startX : endX - textPaint.measureText(text),lineStartY + bottomSpacing + relativeHeight,textPaint);
  }
  if (textLayout != null) {
    if (tempErrorText != null || (hasFocus() && !TextUtils.isEmpty(helperText))) {
      textPaint.setColor(tempErrorText != null ? errorColor : helperTextColor != -1 ? helperTextColor : getCurrentHintTextColor());
      canvas.save();
      canvas.translate(startX + getBottomTextLeftOffset(),lineStartY + bottomSpacing - bottomTextPadding);
      textLayout.draw(canvas);
      canvas.restore();
    }
  }
  if (floatingLabelEnabled && !TextUtils.isEmpty(floatingLabelText)) {
    textPaint.setTextSize(floatingLabelTextSize);
    textPaint.setColor((Integer)focusEvaluator.evaluate(focusFraction,getCurrentHintTextColor(),primaryColor));
    float floatingLabelWidth=textPaint.measureText(floatingLabelText.toString());
    int floatingLabelStartX;
    if ((getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL()) {
      floatingLabelStartX=(int)(endX - floatingLabelWidth);
    }
 else     if ((getGravity() & Gravity.LEFT) == Gravity.LEFT) {
      floatingLabelStartX=startX;
    }
 else {
      floatingLabelStartX=startX + (int)(getInnerPaddingLeft() + (getWidth() - getInnerPaddingLeft() - getInnerPaddingRight()- floatingLabelWidth) / 2);
    }
    int floatingLabelStartY=innerPaddingTop + floatingLabelTextSize + floatingLabelSpacing;
    int distance=floatingLabelSpacing;
    int position=(int)(floatingLabelStartY - distance * floatingLabelFraction);
    int alpha=(int)(floatingLabelFraction * 0xff * (0.74f * focusFraction + 0.26f));
    textPaint.setAlpha(alpha);
    canvas.drawText(floatingLabelText.toString(),floatingLabelStartX,position,textPaint);
  }
  if (hasFocus() && singleLineEllipsis && getScrollX() != 0) {
    paint.setColor(primaryColor);
    float startY=lineStartY + bottomSpacing;
    int ellipsisStartX;
    if (isRTL()) {
      ellipsisStartX=endX;
    }
 else {
      ellipsisStartX=startX;
    }
    int signum=isRTL() ? -1 : 1;
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 5 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
    canvas.drawCircle(ellipsisStartX + signum * bottomEllipsisSize * 9 / 2,startY + bottomEllipsisSize / 2,bottomEllipsisSize / 2,paint);
  }
  super.onDraw(canvas);
}"
54119,"private ObjectAnimator getBottomLinesAnimator(float destBottomLines){
  if (bottomLinesAnimator == null) {
    bottomLinesAnimator=ObjectAnimator.ofFloat(this,""String_Node_Str"",destBottomLines);
  }
 else {
    bottomLinesAnimator.setFloatValues(destBottomLines);
  }
  return bottomLinesAnimator;
}","private ObjectAnimator getBottomLinesAnimator(float destBottomLines){
  if (bottomLinesAnimator == null) {
    bottomLinesAnimator=ObjectAnimator.ofFloat(this,""String_Node_Str"",destBottomLines);
  }
 else {
    bottomLinesAnimator.cancel();
    bottomLinesAnimator.setFloatValues(destBottomLines);
  }
  return bottomLinesAnimator;
}"
54120,"/** 
 * @return True, if adjustments were made that require the view to be invalidated.
 */
private boolean adjustBottomLines(){
  if (getWidth() == 0) {
    return false;
  }
  int destBottomLines;
  textPaint.setTextSize(bottomTextSize);
  if (tempErrorText != null) {
    textLayout=new StaticLayout(tempErrorText,textPaint,getWidth() - getBottomTextLeftOffset() - getBottomTextRightOffset()- getPaddingLeft()- getPaddingRight(),Layout.Alignment.ALIGN_NORMAL,1.0f,0.0f,true);
    destBottomLines=Math.max(textLayout.getLineCount(),minBottomTextLines);
  }
 else   if (helperText != null) {
    textLayout=new StaticLayout(helperText,textPaint,getWidth() - getBottomTextLeftOffset() - getBottomTextRightOffset()- getPaddingLeft()- getPaddingRight(),Layout.Alignment.ALIGN_NORMAL,1.0f,0.0f,true);
    destBottomLines=Math.max(textLayout.getLineCount(),minBottomTextLines);
  }
 else {
    destBottomLines=minBottomLines;
  }
  if (bottomLines != destBottomLines) {
    getBottomLinesAnimator(destBottomLines).start();
  }
  bottomLines=destBottomLines;
  return true;
}","/** 
 * @return True, if adjustments were made that require the view to be invalidated.
 */
private boolean adjustBottomLines(){
  if (getWidth() == 0) {
    return false;
  }
  int destBottomLines;
  textPaint.setTextSize(bottomTextSize);
  if (tempErrorText != null || helperText != null) {
    Layout.Alignment alignment=(getGravity() & Gravity.RIGHT) == Gravity.RIGHT || isRTL() ? Layout.Alignment.ALIGN_OPPOSITE : (getGravity() & Gravity.LEFT) == Gravity.LEFT ? Layout.Alignment.ALIGN_NORMAL : Layout.Alignment.ALIGN_CENTER;
    textLayout=new StaticLayout(tempErrorText != null ? tempErrorText : helperText,textPaint,getWidth() - getBottomTextLeftOffset() - getBottomTextRightOffset()- getPaddingLeft()- getPaddingRight(),alignment,1.0f,0.0f,true);
    destBottomLines=Math.max(textLayout.getLineCount(),minBottomTextLines);
  }
 else {
    destBottomLines=minBottomLines;
  }
  if (bottomLines != destBottomLines) {
    getBottomLinesAnimator(destBottomLines).start();
  }
  bottomLines=destBottomLines;
  return true;
}"
54121,"private void initPadding(){
  int paddingTop=getPaddingTop() - extraPaddingTop;
  int paddingBottom=getPaddingBottom() - extraPaddingBottom;
  int paddingLeft=getPaddingLeft() - extraPaddingLeft;
  int paddingRight=getPaddingRight() - extraPaddingRight;
  extraPaddingTop=floatingLabelEnabled ? floatingLabelTextSize + floatingLabelSpacing : floatingLabelSpacing;
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  extraPaddingBottom=(int)((textMetrics.descent - textMetrics.ascent) * currentBottomLines) + (hideUnderline ? bottomSpacing : bottomSpacing * 2);
  extraPaddingLeft=iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding);
  extraPaddingRight=iconRightBitmaps == null ? 0 : (iconOuterWidth + iconPadding);
  setPaddings(paddingLeft,paddingTop,paddingRight,paddingBottom);
}","private void initPadding(){
  extraPaddingTop=floatingLabelEnabled ? floatingLabelTextSize + floatingLabelSpacing : floatingLabelSpacing;
  textPaint.setTextSize(bottomTextSize);
  Paint.FontMetrics textMetrics=textPaint.getFontMetrics();
  extraPaddingBottom=(int)((textMetrics.descent - textMetrics.ascent) * currentBottomLines) + (hideUnderline ? bottomSpacing : bottomSpacing * 2);
  extraPaddingLeft=iconLeftBitmaps == null ? 0 : (iconOuterWidth + iconPadding);
  extraPaddingRight=iconRightBitmaps == null ? 0 : (iconOuterWidth + iconPadding);
  System.out.println(""String_Node_Str"" + getPaddingLeft() + ""String_Node_Str""+ extraPaddingLeft);
  System.out.println(""String_Node_Str"" + getPaddingRight() + ""String_Node_Str""+ extraPaddingRight);
  System.out.println(""String_Node_Str"" + getPaddingTop() + ""String_Node_Str""+ extraPaddingTop);
  System.out.println(""String_Node_Str"" + getPaddingBottom() + ""String_Node_Str""+ extraPaddingBottom);
  setPaddings(innerPaddingLeft,innerPaddingTop,innerPaddingRight,innerPaddingBottom);
}"
54122,"private ObjectAnimator getBottomLinesAnimator(float destBottomLines){
  if (bottomLinesAnimator == null) {
    bottomLinesAnimator=ObjectAnimator.ofFloat(this,""String_Node_Str"",destBottomLines);
  }
 else {
    bottomLinesAnimator.end();
    bottomLinesAnimator.setFloatValues(destBottomLines);
  }
  return bottomLinesAnimator;
}","private ObjectAnimator getBottomLinesAnimator(float destBottomLines){
  if (bottomLinesAnimator == null) {
    bottomLinesAnimator=ObjectAnimator.ofFloat(this,""String_Node_Str"",destBottomLines);
  }
 else {
    bottomLinesAnimator.setFloatValues(destBottomLines);
  }
  return bottomLinesAnimator;
}"
54123,"@TargetApi(Build.VERSION_CODES.LOLLIPOP) public MaterialEditText(Context context,AttributeSet attrs,int style){
  super(context,attrs,style);
  setFocusable(true);
  setFocusableInTouchMode(true);
  setClickable(true);
  floatingLabelTextSize=getResources().getDimensionPixelSize(R.dimen.floating_label_text_size);
  bottomSpacing=getResources().getDimensionPixelSize(R.dimen.inner_components_spacing);
  bottomEllipsisSize=getResources().getDimensionPixelSize(R.dimen.bottom_ellipsis_height);
  int defaultBaseColor;
  TypedValue baseColorTypedValue=new TypedValue();
  context.getTheme().resolveAttribute(android.R.attr.windowBackground,baseColorTypedValue,true);
  defaultBaseColor=Colors.getBaseColor(baseColorTypedValue.data);
  TypedArray typedArray=context.obtainStyledAttributes(attrs,R.styleable.MaterialEditText);
  baseColor=typedArray.getColor(R.styleable.MaterialEditText_baseColor,defaultBaseColor);
  ColorStateList colorStateList=new ColorStateList(new int[][]{new int[]{android.R.attr.state_enabled},EMPTY_STATE_SET},new int[]{baseColor & 0x00ffffff | 0xdf000000,baseColor & 0x00ffffff | 0x44000000});
  setTextColor(colorStateList);
  int defaultPrimaryColor;
  TypedValue primaryColorTypedValue=new TypedValue();
  try {
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
      throw new RuntimeException(""String_Node_Str"");
    }
    context.getTheme().resolveAttribute(android.R.attr.colorPrimary,primaryColorTypedValue,true);
    defaultPrimaryColor=primaryColorTypedValue.data;
  }
 catch (  Exception e) {
    try {
      int colorAccentId=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",getContext().getPackageName());
      if (colorAccentId != 0) {
        context.getTheme().resolveAttribute(colorAccentId,primaryColorTypedValue,true);
        defaultPrimaryColor=primaryColorTypedValue.data;
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
 catch (    Exception e1) {
      defaultPrimaryColor=baseColor;
    }
  }
  primaryColor=typedArray.getColor(R.styleable.MaterialEditText_primaryColor,defaultPrimaryColor);
  setFloatingLabelInternal(typedArray.getInt(R.styleable.MaterialEditText_floatingLabel,0));
  errorColor=typedArray.getColor(R.styleable.MaterialEditText_errorColor,Color.parseColor(""String_Node_Str""));
  minCharacters=typedArray.getInt(R.styleable.MaterialEditText_minCharacters,0);
  maxCharacters=typedArray.getInt(R.styleable.MaterialEditText_maxCharacters,0);
  singleLineEllipsis=typedArray.getBoolean(R.styleable.MaterialEditText_singleLineEllipsis,false);
  helperText=typedArray.getString(R.styleable.MaterialEditText_helperText);
  helperTextColor=typedArray.getColor(R.styleable.MaterialEditText_helperTextColor,-1);
  minBottomTextLines=typedArray.getInt(R.styleable.MaterialEditText_minBottomTextLines,0);
  String fontPath=typedArray.getString(R.styleable.MaterialEditText_accentTypeface);
  if (fontPath != null) {
    accentTypeface=getCustomTypeface(fontPath);
    textPaint.setTypeface(accentTypeface);
  }
  floatingLabelText=typedArray.getString(R.styleable.MaterialEditText_floatingLabelText);
  if (floatingLabelText == null) {
    floatingLabelText=getHint();
  }
  floatingLabelSpacing=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_floatingLabelSpacing,bottomSpacing);
  hideUnderline=typedArray.getBoolean(R.styleable.MaterialEditText_hideUnderline,false);
  typedArray.recycle();
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
    setBackground(null);
  }
 else {
    setBackgroundDrawable(null);
  }
  if (singleLineEllipsis) {
    TransformationMethod transformationMethod=getTransformationMethod();
    setSingleLine();
    setTransformationMethod(transformationMethod);
  }
  textPaint.setTextSize(floatingLabelTextSize);
  fontMetrics=textPaint.getFontMetrics();
  initMinBottomLines();
  initPadding();
  initText();
  initFloatingLabel();
  initErrorTextListener();
}","@TargetApi(Build.VERSION_CODES.LOLLIPOP) public MaterialEditText(Context context,AttributeSet attrs,int style){
  super(context,attrs,style);
  setFocusable(true);
  setFocusableInTouchMode(true);
  setClickable(true);
  if (isInEditMode()) {
    floatingLabelTextSize=24;
    bottomSpacing=16;
    bottomEllipsisSize=8;
  }
 else {
    floatingLabelTextSize=getResources().getDimensionPixelSize(R.dimen.floating_label_text_size);
    bottomSpacing=getResources().getDimensionPixelSize(R.dimen.inner_components_spacing);
    bottomEllipsisSize=getResources().getDimensionPixelSize(R.dimen.bottom_ellipsis_height);
  }
  int defaultBaseColor;
  TypedValue baseColorTypedValue=new TypedValue();
  context.getTheme().resolveAttribute(android.R.attr.windowBackground,baseColorTypedValue,true);
  defaultBaseColor=Colors.getBaseColor(baseColorTypedValue.data);
  TypedArray typedArray=context.obtainStyledAttributes(attrs,R.styleable.MaterialEditText);
  baseColor=typedArray.getColor(R.styleable.MaterialEditText_baseColor,defaultBaseColor);
  ColorStateList colorStateList=new ColorStateList(new int[][]{new int[]{android.R.attr.state_enabled},EMPTY_STATE_SET},new int[]{baseColor & 0x00ffffff | 0xdf000000,baseColor & 0x00ffffff | 0x44000000});
  setTextColor(colorStateList);
  int defaultPrimaryColor;
  TypedValue primaryColorTypedValue=new TypedValue();
  try {
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
      throw new RuntimeException(""String_Node_Str"");
    }
    context.getTheme().resolveAttribute(android.R.attr.colorPrimary,primaryColorTypedValue,true);
    defaultPrimaryColor=primaryColorTypedValue.data;
  }
 catch (  Exception e) {
    try {
      int colorAccentId=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",getContext().getPackageName());
      if (colorAccentId != 0) {
        context.getTheme().resolveAttribute(colorAccentId,primaryColorTypedValue,true);
        defaultPrimaryColor=primaryColorTypedValue.data;
      }
 else {
        throw new RuntimeException(""String_Node_Str"");
      }
    }
 catch (    Exception e1) {
      defaultPrimaryColor=baseColor;
    }
  }
  primaryColor=typedArray.getColor(R.styleable.MaterialEditText_primaryColor,defaultPrimaryColor);
  setFloatingLabelInternal(typedArray.getInt(R.styleable.MaterialEditText_floatingLabel,0));
  errorColor=typedArray.getColor(R.styleable.MaterialEditText_errorColor,Color.parseColor(""String_Node_Str""));
  minCharacters=typedArray.getInt(R.styleable.MaterialEditText_minCharacters,0);
  maxCharacters=typedArray.getInt(R.styleable.MaterialEditText_maxCharacters,0);
  singleLineEllipsis=typedArray.getBoolean(R.styleable.MaterialEditText_singleLineEllipsis,false);
  helperText=typedArray.getString(R.styleable.MaterialEditText_helperText);
  helperTextColor=typedArray.getColor(R.styleable.MaterialEditText_helperTextColor,-1);
  minBottomTextLines=typedArray.getInt(R.styleable.MaterialEditText_minBottomTextLines,0);
  String fontPath=typedArray.getString(R.styleable.MaterialEditText_accentTypeface);
  if (fontPath != null && !isInEditMode()) {
    accentTypeface=getCustomTypeface(fontPath);
    textPaint.setTypeface(accentTypeface);
  }
  floatingLabelText=typedArray.getString(R.styleable.MaterialEditText_floatingLabelText);
  if (floatingLabelText == null) {
    floatingLabelText=getHint();
  }
  floatingLabelSpacing=typedArray.getDimensionPixelSize(R.styleable.MaterialEditText_floatingLabelSpacing,bottomSpacing);
  hideUnderline=typedArray.getBoolean(R.styleable.MaterialEditText_hideUnderline,false);
  typedArray.recycle();
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
    setBackground(null);
  }
 else {
    setBackgroundDrawable(null);
  }
  if (singleLineEllipsis) {
    TransformationMethod transformationMethod=getTransformationMethod();
    setSingleLine();
    setTransformationMethod(transformationMethod);
  }
  textPaint.setTextSize(floatingLabelTextSize);
  fontMetrics=textPaint.getFontMetrics();
  initMinBottomLines();
  initPadding();
  initText();
  initFloatingLabel();
  initErrorTextListener();
}"
54124,"@Override public Animator createAnimator(final ViewGroup sceneRoot,TransitionValues startValues,TransitionValues endValues){
  if (startValues == null || endValues == null) {
    return null;
  }
  if (sRectEvaluator == null) {
    sRectEvaluator=new RectEvaluator();
  }
  Map<String,Object> startParentVals=startValues.values;
  Map<String,Object> endParentVals=endValues.values;
  ViewGroup startParent=(ViewGroup)startParentVals.get(PROPNAME_PARENT);
  ViewGroup endParent=(ViewGroup)endParentVals.get(PROPNAME_PARENT);
  if (startParent == null || endParent == null) {
    return null;
  }
  final View view=endValues.view;
  if (parentMatches(startParent,endParent)) {
    Rect startBounds=(Rect)startValues.values.get(PROPNAME_BOUNDS);
    Rect endBounds=(Rect)endValues.values.get(PROPNAME_BOUNDS);
    final int startLeft=startBounds.left;
    final int endLeft=endBounds.left;
    final int startTop=startBounds.top;
    final int endTop=endBounds.top;
    final int startRight=startBounds.right;
    final int endRight=endBounds.right;
    final int startBottom=startBounds.bottom;
    final int endBottom=endBounds.bottom;
    final int startWidth=startRight - startLeft;
    final int startHeight=startBottom - startTop;
    final int endWidth=endRight - endLeft;
    final int endHeight=endBottom - endTop;
    Rect startClip=(Rect)startValues.values.get(PROPNAME_CLIP);
    Rect endClip=(Rect)endValues.values.get(PROPNAME_CLIP);
    int numChanges=0;
    if ((startWidth != 0 && startHeight != 0) || (endWidth != 0 && endHeight != 0)) {
      if (startLeft != endLeft || startTop != endTop)       ++numChanges;
      if (startRight != endRight || startBottom != endBottom)       ++numChanges;
    }
    if ((startClip != null && !startClip.equals(endClip)) || (startClip == null && endClip != null)) {
      ++numChanges;
    }
    if (numChanges > 0) {
      Animator anim;
      if (!mResizeClip || (startClip == null && endClip == null)) {
        ViewUtils.setLeftTopRightBottom(view,startLeft,startTop,startRight,startBottom);
        if (numChanges == 2) {
          if (startWidth == endWidth && startHeight == endHeight) {
            anim=AnimatorUtils.ofPointF(view,POSITION_PROPERTY,getPathMotion(),startLeft,startTop,endLeft,endTop);
          }
 else {
            ViewBounds viewBounds=new ViewBounds(view);
            Animator topLeftAnimator=AnimatorUtils.ofPointF(viewBounds,TOP_LEFT_PROPERTY,getPathMotion(),startLeft,startTop,endLeft,endTop);
            Animator bottomRightAnimator=AnimatorUtils.ofPointF(viewBounds,BOTTOM_RIGHT_PROPERTY,getPathMotion(),startRight,startBottom,endRight,endBottom);
            AnimatorSet set=new AnimatorSet();
            set.playTogether(topLeftAnimator,bottomRightAnimator);
            set.addListener(viewBounds);
            anim=set;
          }
        }
 else         if (startLeft != endLeft || startTop != endTop) {
          anim=AnimatorUtils.ofPointF(view,TOP_LEFT_ONLY_PROPERTY,getPathMotion(),startLeft,startTop,endLeft,endTop);
        }
 else {
          anim=AnimatorUtils.ofPointF(view,BOTTOM_RIGHT_ONLY_PROPERTY,getPathMotion(),startRight,startBottom,endRight,endBottom);
        }
      }
 else {
        int maxWidth=Math.max(startWidth,endWidth);
        int maxHeight=Math.max(startHeight,endHeight);
        ViewUtils.setLeftTopRightBottom(view,startLeft,startTop,startLeft + maxWidth,startTop + maxHeight);
        Animator positionAnimator=null;
        if (startLeft != endLeft || startTop != endTop) {
          positionAnimator=AnimatorUtils.ofPointF(view,POSITION_PROPERTY,getPathMotion(),startLeft,startTop,endLeft,endTop);
        }
        final Rect finalClip=endClip;
        if (startClip == null) {
          startClip=new Rect(0,0,startWidth,startHeight);
        }
        if (endClip == null) {
          endClip=new Rect(0,0,endWidth,endHeight);
        }
        ObjectAnimator clipAnimator=null;
        if (!startClip.equals(endClip)) {
          ViewUtils.setClipBounds(view,startClip);
          clipAnimator=ObjectAnimator.ofObject(view,ChangeClipBounds.VIEW_CLIP_BOUNDS,sRectEvaluator,startClip,endClip);
          clipAnimator.addListener(new AnimatorListenerAdapter(){
            private boolean mIsCanceled;
            @Override public void onAnimationCancel(            Animator animation){
              mIsCanceled=true;
            }
            @Override public void onAnimationEnd(            Animator animation){
              if (!mIsCanceled) {
                ViewUtils.setClipBounds(view,finalClip);
                ViewUtils.setLeftTopRightBottom(view,endLeft,endTop,endRight,endBottom);
              }
            }
          }
);
        }
        anim=TransitionUtils.mergeAnimators(positionAnimator,clipAnimator);
      }
      if (view.getParent() instanceof ViewGroup) {
        final ViewGroup parent=(ViewGroup)view.getParent();
        ViewGroupUtils.suppressLayout(parent,true);
        TransitionListener transitionListener=new TransitionListenerAdapter(){
          boolean mCanceled=false;
          @Override public void onTransitionCancel(          Transition transition){
            ViewGroupUtils.suppressLayout(parent,false);
            mCanceled=true;
          }
          @Override public void onTransitionEnd(          Transition transition){
            if (!mCanceled) {
              ViewGroupUtils.suppressLayout(parent,false);
            }
          }
          @Override public void onTransitionPause(          Transition transition){
            ViewGroupUtils.suppressLayout(parent,false);
          }
          @Override public void onTransitionResume(          Transition transition){
            ViewGroupUtils.suppressLayout(parent,true);
          }
        }
;
        addListener(transitionListener);
      }
      return anim;
    }
  }
 else {
    int startX=(Integer)startValues.values.get(PROPNAME_WINDOW_X);
    int startY=(Integer)startValues.values.get(PROPNAME_WINDOW_Y);
    int endX=(Integer)endValues.values.get(PROPNAME_WINDOW_X);
    int endY=(Integer)endValues.values.get(PROPNAME_WINDOW_Y);
    if (startX != endX || startY != endY) {
      sceneRoot.getLocationInWindow(tempLocation);
      Bitmap bitmap=Bitmap.createBitmap(view.getWidth(),view.getHeight(),Bitmap.Config.ARGB_8888);
      Canvas canvas=new Canvas(bitmap);
      view.draw(canvas);
      final BitmapDrawable drawable=new BitmapDrawable(sceneRoot.getContext().getResources(),bitmap);
      Animator anim;
      anim=AnimatorUtils.ofPointF(drawable,DRAWABLE_ORIGIN_PROPERTY,getPathMotion(),startX - tempLocation[0],startY - tempLocation[1],endX - tempLocation[0],endY - tempLocation[1]);
      if (anim != null) {
        final float transitionAlpha=ViewUtils.getTransitionAlpha(view);
        ViewUtils.setTransitionAlpha(view,0);
        ViewOverlayUtils.addOverlay(sceneRoot,drawable);
        anim.addListener(new AnimatorListenerAdapter(){
          @Override public void onAnimationEnd(          Animator animation){
            ViewOverlayUtils.removeOverlay(sceneRoot,drawable);
            ViewUtils.setTransitionAlpha(view,transitionAlpha);
          }
        }
);
      }
      return anim;
    }
  }
  return null;
}","@Override public Animator createAnimator(final ViewGroup sceneRoot,TransitionValues startValues,TransitionValues endValues){
  if (startValues == null || endValues == null) {
    return null;
  }
  if (sRectEvaluator == null) {
    sRectEvaluator=new RectEvaluator();
  }
  Map<String,Object> startParentVals=startValues.values;
  Map<String,Object> endParentVals=endValues.values;
  ViewGroup startParent=(ViewGroup)startParentVals.get(PROPNAME_PARENT);
  ViewGroup endParent=(ViewGroup)endParentVals.get(PROPNAME_PARENT);
  if (startParent == null || endParent == null) {
    return null;
  }
  final View view=endValues.view;
  if (parentMatches(startParent,endParent)) {
    Rect startBounds=(Rect)startValues.values.get(PROPNAME_BOUNDS);
    Rect endBounds=(Rect)endValues.values.get(PROPNAME_BOUNDS);
    final int startLeft=startBounds.left;
    final int endLeft=endBounds.left;
    final int startTop=startBounds.top;
    final int endTop=endBounds.top;
    final int startRight=startBounds.right;
    final int endRight=endBounds.right;
    final int startBottom=startBounds.bottom;
    final int endBottom=endBounds.bottom;
    final int startWidth=startRight - startLeft;
    final int startHeight=startBottom - startTop;
    final int endWidth=endRight - endLeft;
    final int endHeight=endBottom - endTop;
    Rect startClip=(Rect)startValues.values.get(PROPNAME_CLIP);
    Rect endClip=(Rect)endValues.values.get(PROPNAME_CLIP);
    int numChanges=0;
    if ((startWidth != 0 && startHeight != 0) || (endWidth != 0 && endHeight != 0)) {
      if (startLeft != endLeft || startTop != endTop)       ++numChanges;
      if (startRight != endRight || startBottom != endBottom)       ++numChanges;
    }
    if ((startClip != null && !startClip.equals(endClip)) || (startClip == null && endClip != null)) {
      ++numChanges;
    }
    if (numChanges > 0) {
      Animator anim;
      if (!mResizeClip || (startClip == null && endClip == null)) {
        ViewUtils.setLeftTopRightBottom(view,startLeft,startTop,startRight,startBottom);
        if (numChanges == 2) {
          if (startWidth == endWidth && startHeight == endHeight) {
            anim=AnimatorUtils.ofPointF(view,POSITION_PROPERTY,getPathMotion(),startLeft,startTop,endLeft,endTop);
          }
 else {
            ViewBounds viewBounds=new ViewBounds(view);
            Animator topLeftAnimator=AnimatorUtils.ofPointF(viewBounds,TOP_LEFT_PROPERTY,getPathMotion(),startLeft,startTop,endLeft,endTop);
            Animator bottomRightAnimator=AnimatorUtils.ofPointF(viewBounds,BOTTOM_RIGHT_PROPERTY,getPathMotion(),startRight,startBottom,endRight,endBottom);
            AnimatorSet set=new AnimatorSet();
            set.playTogether(topLeftAnimator,bottomRightAnimator);
            set.addListener(viewBounds);
            anim=set;
          }
        }
 else         if (startLeft != endLeft || startTop != endTop) {
          anim=AnimatorUtils.ofPointF(view,TOP_LEFT_ONLY_PROPERTY,getPathMotion(),startLeft,startTop,endLeft,endTop);
        }
 else {
          anim=AnimatorUtils.ofPointF(view,BOTTOM_RIGHT_ONLY_PROPERTY,getPathMotion(),startRight,startBottom,endRight,endBottom);
        }
      }
 else {
        int maxWidth=Math.max(startWidth,endWidth);
        int maxHeight=Math.max(startHeight,endHeight);
        ViewUtils.setLeftTopRightBottom(view,startLeft,startTop,startLeft + maxWidth,startTop + maxHeight);
        Animator positionAnimator=null;
        if (startLeft != endLeft || startTop != endTop) {
          positionAnimator=AnimatorUtils.ofPointF(view,POSITION_PROPERTY,getPathMotion(),startLeft,startTop,endLeft,endTop);
        }
        final Rect finalClip=endClip;
        if (startClip == null) {
          startClip=new Rect(0,0,startWidth,startHeight);
        }
        if (endClip == null) {
          endClip=new Rect(0,0,endWidth,endHeight);
        }
        ObjectAnimator clipAnimator=null;
        if (!startClip.equals(endClip)) {
          ViewUtils.setClipBounds(view,startClip);
          clipAnimator=ObjectAnimator.ofObject(view,ChangeClipBounds.VIEW_CLIP_BOUNDS,sRectEvaluator,startClip,endClip);
          clipAnimator.addListener(new AnimatorListenerAdapter(){
            private boolean mIsCanceled;
            @Override public void onAnimationCancel(            Animator animation){
              mIsCanceled=true;
            }
            @Override public void onAnimationEnd(            Animator animation){
              if (!mIsCanceled) {
                ViewUtils.setClipBounds(view,finalClip);
                ViewUtils.setLeftTopRightBottom(view,endLeft,endTop,endRight,endBottom);
              }
            }
          }
);
        }
        anim=TransitionUtils.mergeAnimators(positionAnimator,clipAnimator);
      }
      if (view.getParent() instanceof ViewGroup) {
        final ViewGroup parent=(ViewGroup)view.getParent();
        ViewGroupUtils.suppressLayout(parent,true);
        TransitionListener transitionListener=new TransitionListenerAdapter(){
          boolean mCanceled=false;
          @Override public void onTransitionCancel(          Transition transition){
            ViewGroupUtils.suppressLayout(parent,false);
            mCanceled=true;
          }
          @Override public void onTransitionEnd(          Transition transition){
            if (!mCanceled) {
              ViewGroupUtils.suppressLayout(parent,false);
            }
          }
          @Override public void onTransitionPause(          Transition transition){
            ViewGroupUtils.suppressLayout(parent,false);
          }
          @Override public void onTransitionResume(          Transition transition){
            ViewGroupUtils.suppressLayout(parent,true);
          }
        }
;
        addListener(transitionListener);
      }
      return anim;
    }
  }
 else {
    int startX=(Integer)startValues.values.get(PROPNAME_WINDOW_X);
    int startY=(Integer)startValues.values.get(PROPNAME_WINDOW_Y);
    int endX=(Integer)endValues.values.get(PROPNAME_WINDOW_X);
    int endY=(Integer)endValues.values.get(PROPNAME_WINDOW_Y);
    if (startX != endX || startY != endY) {
      sceneRoot.getLocationInWindow(tempLocation);
      Bitmap bitmap=Bitmap.createBitmap(view.getWidth(),view.getHeight(),Bitmap.Config.ARGB_8888);
      Canvas canvas=new Canvas(bitmap);
      view.draw(canvas);
      final BitmapDrawable drawable=new BitmapDrawable(sceneRoot.getContext().getResources(),bitmap);
      drawable.setBounds(0,0,view.getWidth(),view.getHeight());
      Animator anim;
      anim=AnimatorUtils.ofPointF(drawable,DRAWABLE_ORIGIN_PROPERTY,getPathMotion(),startX - tempLocation[0],startY - tempLocation[1],endX - tempLocation[0],endY - tempLocation[1]);
      if (anim != null) {
        final float transitionAlpha=ViewUtils.getTransitionAlpha(view);
        ViewUtils.setTransitionAlpha(view,0);
        ViewOverlayUtils.addOverlay(sceneRoot,drawable);
        anim.addListener(new AnimatorListenerAdapter(){
          @Override public void onAnimationEnd(          Animator animation){
            ViewOverlayUtils.removeOverlay(sceneRoot,drawable);
            ViewUtils.setTransitionAlpha(view,transitionAlpha);
          }
        }
);
      }
      return anim;
    }
  }
  return null;
}"
54125,"@Override public Animator createAnimator(ViewGroup sceneRoot,TransitionValues startValues,TransitionValues endValues){
  if (startValues == null || endValues == null) {
    return null;
  }
  final View view=endValues.view;
  Drawable startBackground=(Drawable)startValues.values.get(PROPNAME_BACKGROUND);
  Drawable endBackground=(Drawable)endValues.values.get(PROPNAME_BACKGROUND);
  if (startBackground instanceof ColorDrawable && endBackground instanceof ColorDrawable) {
    ColorDrawable startColor=(ColorDrawable)startBackground;
    ColorDrawable endColor=(ColorDrawable)endBackground;
    if (startColor.getColor() != endColor.getColor()) {
      endColor.setColor(startColor.getColor());
      return ObjectAnimator.ofObject(endColor,COLORDRAWABLE_COLOR,new ArgbEvaluator(),startColor.getColor(),endColor.getColor());
    }
  }
  if (view instanceof TextView) {
    TextView textView=(TextView)view;
    int start=(Integer)startValues.values.get(PROPNAME_TEXT_COLOR);
    int end=(Integer)endValues.values.get(PROPNAME_TEXT_COLOR);
    if (start != end) {
      textView.setTextColor(end);
      return ObjectAnimator.ofObject(textView,TEXTVIEW_TEXT_COLOR,new ArgbEvaluator(),start,end);
    }
  }
  return null;
}","@Override public Animator createAnimator(ViewGroup sceneRoot,TransitionValues startValues,TransitionValues endValues){
  if (startValues == null || endValues == null) {
    return null;
  }
  final View view=endValues.view;
  Drawable startBackground=(Drawable)startValues.values.get(PROPNAME_BACKGROUND);
  Drawable endBackground=(Drawable)endValues.values.get(PROPNAME_BACKGROUND);
  if (startBackground instanceof ColorDrawable && endBackground instanceof ColorDrawable) {
    ColorDrawable startColor=(ColorDrawable)startBackground;
    ColorDrawable endColor=(ColorDrawable)endBackground;
    if (startColor.getColor() != endColor.getColor()) {
      final int finalColor=endColor.getColor();
      endColor.setColor(startColor.getColor());
      return ObjectAnimator.ofObject(endColor,COLORDRAWABLE_COLOR,new ArgbEvaluator(),startColor.getColor(),finalColor);
    }
  }
  if (view instanceof TextView) {
    TextView textView=(TextView)view;
    int start=(Integer)startValues.values.get(PROPNAME_TEXT_COLOR);
    int end=(Integer)endValues.values.get(PROPNAME_TEXT_COLOR);
    if (start != end) {
      textView.setTextColor(end);
      return ObjectAnimator.ofObject(textView,TEXTVIEW_TEXT_COLOR,new ArgbEvaluator(),start,end);
    }
  }
  return null;
}"
54126,"@Override public Animator createAnimator(final ViewGroup sceneRoot,TransitionValues startValues,TransitionValues endValues){
  if (startValues == null || endValues == null) {
    return null;
  }
  if (sRectEvaluator == null) {
    sRectEvaluator=new RectEvaluator();
  }
  Map<String,Object> startParentVals=startValues.values;
  Map<String,Object> endParentVals=endValues.values;
  ViewGroup startParent=(ViewGroup)startParentVals.get(PROPNAME_PARENT);
  ViewGroup endParent=(ViewGroup)endParentVals.get(PROPNAME_PARENT);
  if (startParent == null || endParent == null) {
    return null;
  }
  final View view=endValues.view;
  if (parentMatches(startParent,endParent)) {
    Rect startBounds=(Rect)startValues.values.get(PROPNAME_BOUNDS);
    Rect endBounds=(Rect)endValues.values.get(PROPNAME_BOUNDS);
    final int startLeft=startBounds.left;
    final int endLeft=endBounds.left;
    final int startTop=startBounds.top;
    final int endTop=endBounds.top;
    final int startRight=startBounds.right;
    final int endRight=endBounds.right;
    final int startBottom=startBounds.bottom;
    final int endBottom=endBounds.bottom;
    final int startWidth=startRight - startLeft;
    final int startHeight=startBottom - startTop;
    final int endWidth=endRight - endLeft;
    final int endHeight=endBottom - endTop;
    Rect startClip=(Rect)startValues.values.get(PROPNAME_CLIP);
    Rect endClip=(Rect)endValues.values.get(PROPNAME_CLIP);
    int numChanges=0;
    if ((startWidth != 0 && startHeight != 0) || (endWidth != 0 && endHeight != 0)) {
      if (startLeft != endLeft || startTop != endTop)       ++numChanges;
      if (startRight != endRight || startBottom != endBottom)       ++numChanges;
    }
    if ((startClip != null && !startClip.equals(endClip)) || (startClip == null && endClip != null)) {
      ++numChanges;
    }
    if (numChanges > 0) {
      Animator anim;
      if (!mResizeClip || (startClip == null && endClip == null)) {
        ViewUtils.setLeftTopRightBottom(view,startLeft,startTop,startRight,startBottom);
        if (numChanges == 2) {
          if (startWidth == endWidth && startHeight == endHeight) {
            anim=AnimatorUtils.ofPointF(view,POSITION_PROPERTY,getPathMotion(),startLeft,startTop,endLeft,endTop);
          }
 else {
            ViewBounds viewBounds=new ViewBounds(view);
            Animator topLeftAnimator=AnimatorUtils.ofPointF(viewBounds,TOP_LEFT_PROPERTY,getPathMotion(),startLeft,startTop,endLeft,endTop);
            Animator bottomRightAnimator=AnimatorUtils.ofPointF(viewBounds,BOTTOM_RIGHT_PROPERTY,getPathMotion(),startRight,startBottom,endRight,endBottom);
            AnimatorSet set=new AnimatorSet();
            set.playTogether(topLeftAnimator,bottomRightAnimator);
            set.addListener(viewBounds);
            anim=set;
          }
        }
 else         if (startLeft != endLeft || startTop != endTop) {
          anim=AnimatorUtils.ofPointF(view,TOP_LEFT_ONLY_PROPERTY,getPathMotion(),startLeft,startTop,endLeft,endTop);
        }
 else {
          anim=AnimatorUtils.ofPointF(view,BOTTOM_RIGHT_ONLY_PROPERTY,getPathMotion(),startRight,startBottom,endRight,endBottom);
        }
      }
 else {
        int maxWidth=Math.max(startWidth,endWidth);
        int maxHeight=Math.max(startHeight,endHeight);
        ViewUtils.setLeftTopRightBottom(view,startLeft,startTop,startLeft + maxWidth,startTop + maxHeight);
        Animator positionAnimator=null;
        if (startLeft != endLeft || startTop != endTop) {
          positionAnimator=AnimatorUtils.ofPointF(view,POSITION_PROPERTY,getPathMotion(),startLeft,startTop,endLeft,endTop);
        }
        final Rect finalClip=endClip;
        if (startClip == null) {
          startClip=new Rect(0,0,startWidth,startHeight);
        }
        if (endClip == null) {
          endClip=new Rect(0,0,endWidth,endHeight);
        }
        ObjectAnimator clipAnimator=null;
        if (!startClip.equals(endClip)) {
          ViewUtils.setClipBounds(view,startClip);
          clipAnimator=ObjectAnimator.ofObject(view,""String_Node_Str"",sRectEvaluator,startClip,endClip);
          clipAnimator.addListener(new AnimatorListenerAdapter(){
            private boolean mIsCanceled;
            @Override public void onAnimationCancel(            Animator animation){
              mIsCanceled=true;
            }
            @Override public void onAnimationEnd(            Animator animation){
              if (!mIsCanceled) {
                ViewUtils.setClipBounds(view,finalClip);
                ViewUtils.setLeftTopRightBottom(view,endLeft,endTop,endRight,endBottom);
              }
            }
          }
);
        }
        anim=TransitionUtils.mergeAnimators(positionAnimator,clipAnimator);
      }
      if (view.getParent() instanceof ViewGroup) {
        final ViewGroup parent=(ViewGroup)view.getParent();
        ViewGroupUtils.suppressLayout(parent,true);
        TransitionListener transitionListener=new TransitionListenerAdapter(){
          boolean mCanceled=false;
          @Override public void onTransitionCancel(          Transition transition){
            ViewGroupUtils.suppressLayout(parent,false);
            mCanceled=true;
          }
          @Override public void onTransitionEnd(          Transition transition){
            if (!mCanceled) {
              ViewGroupUtils.suppressLayout(parent,false);
            }
          }
          @Override public void onTransitionPause(          Transition transition){
            ViewGroupUtils.suppressLayout(parent,false);
          }
          @Override public void onTransitionResume(          Transition transition){
            ViewGroupUtils.suppressLayout(parent,true);
          }
        }
;
        addListener(transitionListener);
      }
      return anim;
    }
  }
 else {
    int startX=(Integer)startValues.values.get(PROPNAME_WINDOW_X);
    int startY=(Integer)startValues.values.get(PROPNAME_WINDOW_Y);
    int endX=(Integer)endValues.values.get(PROPNAME_WINDOW_X);
    int endY=(Integer)endValues.values.get(PROPNAME_WINDOW_Y);
    if (startX != endX || startY != endY) {
      sceneRoot.getLocationInWindow(tempLocation);
      Bitmap bitmap=Bitmap.createBitmap(view.getWidth(),view.getHeight(),Bitmap.Config.ARGB_8888);
      Canvas canvas=new Canvas(bitmap);
      view.draw(canvas);
      final BitmapDrawable drawable=new BitmapDrawable(sceneRoot.getContext().getResources(),bitmap);
      Animator anim;
      anim=AnimatorUtils.ofPointF(drawable,DRAWABLE_ORIGIN_PROPERTY,getPathMotion(),startX - tempLocation[0],startY - tempLocation[1],endX - tempLocation[0],endY - tempLocation[1]);
      if (anim != null) {
        final float transitionAlpha=ViewUtils.getTransitionAlpha(view);
        ViewUtils.setTransitionAlpha(view,0);
        ViewOverlayUtils.addOverlay(sceneRoot,drawable);
        anim.addListener(new AnimatorListenerAdapter(){
          @Override public void onAnimationEnd(          Animator animation){
            ViewOverlayUtils.removeOverlay(sceneRoot,drawable);
            ViewUtils.setTransitionAlpha(view,transitionAlpha);
          }
        }
);
      }
      return anim;
    }
  }
  return null;
}","@Override public Animator createAnimator(final ViewGroup sceneRoot,TransitionValues startValues,TransitionValues endValues){
  if (startValues == null || endValues == null) {
    return null;
  }
  if (sRectEvaluator == null) {
    sRectEvaluator=new RectEvaluator();
  }
  Map<String,Object> startParentVals=startValues.values;
  Map<String,Object> endParentVals=endValues.values;
  ViewGroup startParent=(ViewGroup)startParentVals.get(PROPNAME_PARENT);
  ViewGroup endParent=(ViewGroup)endParentVals.get(PROPNAME_PARENT);
  if (startParent == null || endParent == null) {
    return null;
  }
  final View view=endValues.view;
  if (parentMatches(startParent,endParent)) {
    Rect startBounds=(Rect)startValues.values.get(PROPNAME_BOUNDS);
    Rect endBounds=(Rect)endValues.values.get(PROPNAME_BOUNDS);
    final int startLeft=startBounds.left;
    final int endLeft=endBounds.left;
    final int startTop=startBounds.top;
    final int endTop=endBounds.top;
    final int startRight=startBounds.right;
    final int endRight=endBounds.right;
    final int startBottom=startBounds.bottom;
    final int endBottom=endBounds.bottom;
    final int startWidth=startRight - startLeft;
    final int startHeight=startBottom - startTop;
    final int endWidth=endRight - endLeft;
    final int endHeight=endBottom - endTop;
    Rect startClip=(Rect)startValues.values.get(PROPNAME_CLIP);
    Rect endClip=(Rect)endValues.values.get(PROPNAME_CLIP);
    int numChanges=0;
    if ((startWidth != 0 && startHeight != 0) || (endWidth != 0 && endHeight != 0)) {
      if (startLeft != endLeft || startTop != endTop)       ++numChanges;
      if (startRight != endRight || startBottom != endBottom)       ++numChanges;
    }
    if ((startClip != null && !startClip.equals(endClip)) || (startClip == null && endClip != null)) {
      ++numChanges;
    }
    if (numChanges > 0) {
      Animator anim;
      if (!mResizeClip || (startClip == null && endClip == null)) {
        ViewUtils.setLeftTopRightBottom(view,startLeft,startTop,startRight,startBottom);
        if (numChanges == 2) {
          if (startWidth == endWidth && startHeight == endHeight) {
            anim=AnimatorUtils.ofPointF(view,POSITION_PROPERTY,getPathMotion(),startLeft,startTop,endLeft,endTop);
          }
 else {
            ViewBounds viewBounds=new ViewBounds(view);
            Animator topLeftAnimator=AnimatorUtils.ofPointF(viewBounds,TOP_LEFT_PROPERTY,getPathMotion(),startLeft,startTop,endLeft,endTop);
            Animator bottomRightAnimator=AnimatorUtils.ofPointF(viewBounds,BOTTOM_RIGHT_PROPERTY,getPathMotion(),startRight,startBottom,endRight,endBottom);
            AnimatorSet set=new AnimatorSet();
            set.playTogether(topLeftAnimator,bottomRightAnimator);
            set.addListener(viewBounds);
            anim=set;
          }
        }
 else         if (startLeft != endLeft || startTop != endTop) {
          anim=AnimatorUtils.ofPointF(view,TOP_LEFT_ONLY_PROPERTY,getPathMotion(),startLeft,startTop,endLeft,endTop);
        }
 else {
          anim=AnimatorUtils.ofPointF(view,BOTTOM_RIGHT_ONLY_PROPERTY,getPathMotion(),startRight,startBottom,endRight,endBottom);
        }
      }
 else {
        int maxWidth=Math.max(startWidth,endWidth);
        int maxHeight=Math.max(startHeight,endHeight);
        ViewUtils.setLeftTopRightBottom(view,startLeft,startTop,startLeft + maxWidth,startTop + maxHeight);
        Animator positionAnimator=null;
        if (startLeft != endLeft || startTop != endTop) {
          positionAnimator=AnimatorUtils.ofPointF(view,POSITION_PROPERTY,getPathMotion(),startLeft,startTop,endLeft,endTop);
        }
        final Rect finalClip=endClip;
        if (startClip == null) {
          startClip=new Rect(0,0,startWidth,startHeight);
        }
        if (endClip == null) {
          endClip=new Rect(0,0,endWidth,endHeight);
        }
        ObjectAnimator clipAnimator=null;
        if (!startClip.equals(endClip)) {
          ViewUtils.setClipBounds(view,startClip);
          clipAnimator=ObjectAnimator.ofObject(view,ChangeClipBounds.VIEW_CLIP_BOUNDS,sRectEvaluator,startClip,endClip);
          clipAnimator.addListener(new AnimatorListenerAdapter(){
            private boolean mIsCanceled;
            @Override public void onAnimationCancel(            Animator animation){
              mIsCanceled=true;
            }
            @Override public void onAnimationEnd(            Animator animation){
              if (!mIsCanceled) {
                ViewUtils.setClipBounds(view,finalClip);
                ViewUtils.setLeftTopRightBottom(view,endLeft,endTop,endRight,endBottom);
              }
            }
          }
);
        }
        anim=TransitionUtils.mergeAnimators(positionAnimator,clipAnimator);
      }
      if (view.getParent() instanceof ViewGroup) {
        final ViewGroup parent=(ViewGroup)view.getParent();
        ViewGroupUtils.suppressLayout(parent,true);
        TransitionListener transitionListener=new TransitionListenerAdapter(){
          boolean mCanceled=false;
          @Override public void onTransitionCancel(          Transition transition){
            ViewGroupUtils.suppressLayout(parent,false);
            mCanceled=true;
          }
          @Override public void onTransitionEnd(          Transition transition){
            if (!mCanceled) {
              ViewGroupUtils.suppressLayout(parent,false);
            }
          }
          @Override public void onTransitionPause(          Transition transition){
            ViewGroupUtils.suppressLayout(parent,false);
          }
          @Override public void onTransitionResume(          Transition transition){
            ViewGroupUtils.suppressLayout(parent,true);
          }
        }
;
        addListener(transitionListener);
      }
      return anim;
    }
  }
 else {
    int startX=(Integer)startValues.values.get(PROPNAME_WINDOW_X);
    int startY=(Integer)startValues.values.get(PROPNAME_WINDOW_Y);
    int endX=(Integer)endValues.values.get(PROPNAME_WINDOW_X);
    int endY=(Integer)endValues.values.get(PROPNAME_WINDOW_Y);
    if (startX != endX || startY != endY) {
      sceneRoot.getLocationInWindow(tempLocation);
      Bitmap bitmap=Bitmap.createBitmap(view.getWidth(),view.getHeight(),Bitmap.Config.ARGB_8888);
      Canvas canvas=new Canvas(bitmap);
      view.draw(canvas);
      final BitmapDrawable drawable=new BitmapDrawable(sceneRoot.getContext().getResources(),bitmap);
      Animator anim;
      anim=AnimatorUtils.ofPointF(drawable,DRAWABLE_ORIGIN_PROPERTY,getPathMotion(),startX - tempLocation[0],startY - tempLocation[1],endX - tempLocation[0],endY - tempLocation[1]);
      if (anim != null) {
        final float transitionAlpha=ViewUtils.getTransitionAlpha(view);
        ViewUtils.setTransitionAlpha(view,0);
        ViewOverlayUtils.addOverlay(sceneRoot,drawable);
        anim.addListener(new AnimatorListenerAdapter(){
          @Override public void onAnimationEnd(          Animator animation){
            ViewOverlayUtils.removeOverlay(sceneRoot,drawable);
            ViewUtils.setTransitionAlpha(view,transitionAlpha);
          }
        }
);
      }
      return anim;
    }
  }
  return null;
}"
54127,"/** 
 * This is where all of the work of a transition/scene-change is orchestrated. This method captures the start values for the given transition, exits the current Scene, enters the new scene, captures the end values for the transition, and finally plays the resulting values-populated transition.
 * @param scene      The scene being entered
 * @param transition The transition to play for this scene change
 */
private static void changeScene(Scene scene,Transition transition){
  final ViewGroup sceneRoot=scene.getSceneRoot();
  if (!sPendingTransitions.contains(sceneRoot)) {
    sPendingTransitions.add(sceneRoot);
    Transition transitionClone=null;
    if (isTransitionsAllowed()) {
      if (transition != null) {
        transitionClone=transition.clone();
        transitionClone.setSceneRoot(sceneRoot);
      }
      Scene oldScene=Scene.getCurrentScene(sceneRoot);
      if (oldScene != null && transitionClone != null && oldScene.isCreatedFromLayoutResource()) {
        transitionClone.setCanRemoveViews(true);
      }
    }
    sceneChangeSetup(sceneRoot,transitionClone);
    scene.enter();
    sceneChangeRunTransition(sceneRoot,transitionClone);
  }
}","/** 
 * This is where all of the work of a transition/scene-change is orchestrated. This method captures the start values for the given transition, exits the current Scene, enters the new scene, captures the end values for the transition, and finally plays the resulting values-populated transition.
 * @param scene      The scene being entered
 * @param transition The transition to play for this scene change
 */
private static void changeScene(Scene scene,Transition transition){
  final ViewGroup sceneRoot=scene.getSceneRoot();
  if (!sPendingTransitions.contains(sceneRoot)) {
    Transition transitionClone=null;
    if (isTransitionsAllowed()) {
      sPendingTransitions.add(sceneRoot);
      if (transition != null) {
        transitionClone=transition.clone();
        transitionClone.setSceneRoot(sceneRoot);
      }
      Scene oldScene=Scene.getCurrentScene(sceneRoot);
      if (oldScene != null && transitionClone != null && oldScene.isCreatedFromLayoutResource()) {
        transitionClone.setCanRemoveViews(true);
      }
    }
    sceneChangeSetup(sceneRoot,transitionClone);
    scene.enter();
    sceneChangeRunTransition(sceneRoot,transitionClone);
  }
}"
54128,"@Override public Animator createAnimator(ViewGroup sceneRoot,TransitionValues startValues,TransitionValues endValues){
  if (startValues == null || endValues == null) {
    return null;
  }
  final View view=endValues.view;
  float startRotation=(Float)startValues.values.get(PROPNAME_ROTATION);
  float endRotation=(Float)endValues.values.get(PROPNAME_ROTATION);
  if (startRotation != endRotation) {
    view.setRotation(startRotation);
    return ObjectAnimator.ofFloat(view,""String_Node_Str"",startRotation,endRotation);
  }
  return null;
}","@Override public Animator createAnimator(ViewGroup sceneRoot,TransitionValues startValues,TransitionValues endValues){
  if (startValues == null || endValues == null) {
    return null;
  }
  final View view=endValues.view;
  float startRotation=(Float)startValues.values.get(PROPNAME_ROTATION);
  float endRotation=(Float)endValues.values.get(PROPNAME_ROTATION);
  if (startRotation != endRotation) {
    view.setRotation(startRotation);
    return ObjectAnimator.ofFloat(view,View.ROTATION,startRotation,endRotation);
  }
  return null;
}"
54129,"public static void initializeOverlay(View sceneRoot){
  IMPL.initializeOverlay(sceneRoot);
}","public static void initializeOverlay(ViewGroup sceneRoot){
  IMPL.initializeOverlay(sceneRoot);
}"
54130,"public static ViewOverlayPreJellybean getOverlay(View sceneRoot){
  View group=sceneRoot;
  while (group != null && !(group.getId() == android.R.id.content)) {
    group=(View)group.getParent();
  }
  ViewOverlayPreJellybean viewOverlayPreJellybean=null;
  if (group != null) {
    for (int i=0; i < ((FrameLayout)group).getChildCount(); i++) {
      View childAt=((FrameLayout)group).getChildAt(i);
      if (childAt instanceof ViewOverlayPreJellybean) {
        viewOverlayPreJellybean=(ViewOverlayPreJellybean)childAt;
        break;
      }
    }
    if (viewOverlayPreJellybean == null) {
      viewOverlayPreJellybean=new ViewOverlayPreJellybean(sceneRoot.getContext());
      final FrameLayout.LayoutParams params=new FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);
      params.gravity=Gravity.FILL;
      ((FrameLayout)group).addView(viewOverlayPreJellybean,params);
    }
  }
  return viewOverlayPreJellybean;
}","public static ViewOverlayPreJellybean getOverlay(ViewGroup sceneRoot){
  if (sceneRoot != null) {
    ViewGroup group=sceneRoot;
    while (group.getId() != android.R.id.content && group.getParent() != null && group.getParent() instanceof ViewGroup) {
      group=(ViewGroup)group.getParent();
    }
    for (int i=0; i < group.getChildCount(); i++) {
      View child=group.getChildAt(i);
      if (child instanceof ViewOverlayPreJellybean) {
        return (ViewOverlayPreJellybean)child;
      }
    }
    final FrameLayout.LayoutParams params=new FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);
    params.gravity=Gravity.FILL;
    ViewOverlayPreJellybean viewOverlay=new ViewOverlayPreJellybean(sceneRoot.getContext());
    group.addView(viewOverlay,params);
    return viewOverlay;
  }
 else {
    return null;
  }
}"
54131,"@Override public TransitionSet setInterpolator(TimeInterpolator interpolator){
  return (TransitionSet)super.setInterpolator(interpolator);
}","@Override public TransitionSet setInterpolator(TimeInterpolator interpolator){
  super.setInterpolator(interpolator);
  if (mInterpolator != null && mTransitions != null) {
    int numTransitions=mTransitions.size();
    for (int i=0; i < numTransitions; ++i) {
      mTransitions.get(i).setInterpolator(mInterpolator);
    }
  }
  return this;
}"
54132,"@Override public TransitionSet clone(){
  TransitionSet clone=(TransitionSet)super.clone();
  clone.mTransitions=new ArrayList<Transition>();
  int numTransitions=mTransitions.size();
  for (int i=0; i < numTransitions; ++i) {
    Transition transition=(Transition)mTransitions.get(i).clone();
    long duration=transition.getDuration();
    clone.addTransition(transition);
    transition.setDuration(duration);
  }
  return clone;
}","@Override public TransitionSet clone(){
  TransitionSet clone=(TransitionSet)super.clone();
  clone.mTransitions=new ArrayList<Transition>();
  int numTransitions=mTransitions.size();
  for (int i=0; i < numTransitions; ++i) {
    clone.addTransitionInternal(mTransitions.get(i).clone());
  }
  return clone;
}"
54133,"/** 
 * Adds child transition to this set. The order in which this child transition is added relative to other child transitions that are added, in addition to the   {@link #getOrdering() ordering} property, determines theorder in which the transitions are started. <p/> <p>If this transitionSet has a  {@link #getDuration() duration} set on it, thechild transition will inherit that duration. Transitions are assumed to have a maximum of one transitionSet parent.</p>
 * @param transition A non-null child transition to be added to this set.
 * @return This transitionSet object.
 */
public TransitionSet addTransition(Transition transition){
  if (transition != null) {
    mTransitions.add(transition);
    transition.mParent=this;
    if (mDuration >= 0) {
      transition.setDuration(mDuration);
    }
  }
  return this;
}","/** 
 * Adds child transition to this set. The order in which this child transition is added relative to other child transitions that are added, in addition to the   {@link #getOrdering() ordering} property, determines theorder in which the transitions are started. <p/> <p>If this transitionSet has a  {@link #getDuration() duration} set on it, thechild transition will inherit that duration. Transitions are assumed to have a maximum of one transitionSet parent.</p>
 * @param transition A non-null child transition to be added to this set.
 * @return This transitionSet object.
 */
public TransitionSet addTransition(Transition transition){
  if (transition != null) {
    addTransitionInternal(transition);
    if (mDuration >= 0) {
      transition.setDuration(mDuration);
    }
    if (mInterpolator != null) {
      transition.setInterpolator(mInterpolator);
    }
  }
  return this;
}"
54134,"/** 
 * This method, essentially a wrapper around all calls to createAnimator for all possible target views, is called with the entire set of start/end values. The implementation in Transition iterates through these lists and calls   {@link #createAnimator(ViewGroup,TransitionValues,TransitionValues)}with each set of start/end values on this transition. The TransitionSet subclass overrides this method and delegates it to each of its children in succession.
 * @hide
 */
protected void createAnimators(ViewGroup sceneRoot,TransitionValuesMaps startValues,TransitionValuesMaps endValues,ArrayList<TransitionValues> startValuesList,ArrayList<TransitionValues> endValuesList){
  if (DBG) {
    Log.d(LOG_TAG,""String_Node_Str"" + this);
  }
  ArrayMap<Animator,AnimationInfo> runningAnimators=getRunningAnimators();
  long minStartDelay=Long.MAX_VALUE;
  int minAnimator=mAnimators.size();
  SparseArray<Long> startDelays=new SparseArray<Long>();
  int startValuesListCount=startValuesList.size();
  for (int i=0; i < startValuesListCount; ++i) {
    TransitionValues start=startValuesList.get(i);
    TransitionValues end=endValuesList.get(i);
    if (start != null && !start.targetedTransitions.contains(this)) {
      start=null;
    }
    if (end != null && !end.targetedTransitions.contains(this)) {
      end=null;
    }
    if (start == null && end == null) {
      continue;
    }
    boolean isChanged=start == null || end == null || areValuesChanged(start,end);
    if (isChanged) {
      if (DBG) {
        View view=(end != null) ? end.view : start.view;
        Log.d(LOG_TAG,""String_Node_Str"" + view);
        if (start == null || end == null) {
          Log.d(LOG_TAG,""String_Node_Str"" + ((start == null) ? ""String_Node_Str"" : ""String_Node_Str""));
        }
 else {
          for (          String key : start.values.keySet()) {
            Object startValue=start.values.get(key);
            Object endValue=end.values.get(key);
            if (startValue != endValue && !startValue.equals(endValue)) {
              Log.d(LOG_TAG,""String_Node_Str"" + key + ""String_Node_Str""+ startValue+ ""String_Node_Str""+ endValue+ ""String_Node_Str"");
            }
          }
        }
      }
      Animator animator=createAnimator(sceneRoot,start,end);
      if (animator != null) {
        View view;
        TransitionValues infoValues=null;
        if (end != null) {
          view=end.view;
          String[] properties=getTransitionProperties();
          if (view != null && properties != null && properties.length > 0) {
            infoValues=new TransitionValues();
            infoValues.view=view;
            TransitionValues newValues=endValues.viewValues.get(view);
            if (newValues != null) {
              for (int j=0; j < properties.length; ++j) {
                infoValues.values.put(properties[j],newValues.values.get(properties[j]));
              }
            }
            int numExistingAnims=runningAnimators.size();
            for (int j=0; j < numExistingAnims; ++j) {
              Animator anim=runningAnimators.keyAt(j);
              AnimationInfo info=runningAnimators.get(anim);
              if (info.values != null && info.view == view && ((info.name == null && getName() == null) || (info.name != null && info.name.equals(getName())))) {
                if (info.values.equals(infoValues)) {
                  animator=null;
                  break;
                }
              }
            }
          }
        }
 else {
          view=start.view;
        }
        if (animator != null) {
          if (mPropagation != null) {
            long delay=mPropagation.getStartDelay(sceneRoot,this,start,end);
            startDelays.put(mAnimators.size(),delay);
            minStartDelay=Math.min(delay,minStartDelay);
          }
          AnimationInfo info=new AnimationInfo(view,getName(),this,ViewUtils.getWindowId(sceneRoot),infoValues);
          runningAnimators.put(animator,info);
          mAnimators.add(animator);
        }
      }
    }
  }
  if (minStartDelay != 0) {
    for (int i=0; i < startDelays.size(); i++) {
      int index=startDelays.keyAt(i);
      Animator animator=mAnimators.get(index);
      long delay=startDelays.valueAt(i) - minStartDelay + animator.getStartDelay();
      animator.setStartDelay(delay);
    }
  }
}","/** 
 * This method, essentially a wrapper around all calls to createAnimator for all possible target views, is called with the entire set of start/end values. The implementation in Transition iterates through these lists and calls   {@link #createAnimator(ViewGroup,TransitionValues,TransitionValues)}with each set of start/end values on this transition. The TransitionSet subclass overrides this method and delegates it to each of its children in succession.
 * @hide
 */
protected void createAnimators(ViewGroup sceneRoot,TransitionValuesMaps startValues,TransitionValuesMaps endValues,ArrayList<TransitionValues> startValuesList,ArrayList<TransitionValues> endValuesList){
  if (DBG) {
    Log.d(LOG_TAG,""String_Node_Str"" + this);
  }
  ArrayMap<Animator,AnimationInfo> runningAnimators=getRunningAnimators();
  long minStartDelay=Long.MAX_VALUE;
  int minAnimator=mAnimators.size();
  SparseArray<Long> startDelays=new SparseArray<Long>();
  int startValuesListCount=startValuesList.size();
  for (int i=0; i < startValuesListCount; ++i) {
    TransitionValues start=startValuesList.get(i);
    TransitionValues end=endValuesList.get(i);
    if (start != null && !start.targetedTransitions.contains(this)) {
      start=null;
    }
    if (end != null && !end.targetedTransitions.contains(this)) {
      end=null;
    }
    if (start == null && end == null) {
      continue;
    }
    boolean isChanged=start == null || end == null || areValuesChanged(start,end);
    if (isChanged) {
      if (DBG) {
        View view=(end != null) ? end.view : start.view;
        Log.d(LOG_TAG,""String_Node_Str"" + view);
        if (start == null || end == null) {
          Log.d(LOG_TAG,""String_Node_Str"" + ((start == null) ? ""String_Node_Str"" : ""String_Node_Str""));
        }
 else {
          for (          String key : start.values.keySet()) {
            Object startValue=start.values.get(key);
            Object endValue=end.values.get(key);
            if (startValue != endValue && !startValue.equals(endValue)) {
              Log.d(LOG_TAG,""String_Node_Str"" + key + ""String_Node_Str""+ startValue+ ""String_Node_Str""+ endValue+ ""String_Node_Str"");
            }
          }
        }
      }
      Animator animator=createAnimator(sceneRoot,start,end);
      if (animator != null) {
        View view;
        TransitionValues infoValues=null;
        if (end != null) {
          view=end.view;
          String[] properties=getTransitionProperties();
          if (view != null && properties != null && properties.length > 0) {
            infoValues=new TransitionValues();
            infoValues.view=view;
            TransitionValues newValues=endValues.viewValues.get(view);
            if (newValues != null) {
              for (int j=0; j < properties.length; ++j) {
                infoValues.values.put(properties[j],newValues.values.get(properties[j]));
              }
            }
synchronized (sRunningAnimators) {
              int numExistingAnims=runningAnimators.size();
              for (int j=0; j < numExistingAnims; ++j) {
                Animator anim=runningAnimators.keyAt(j);
                AnimationInfo info=runningAnimators.get(anim);
                if (info.values != null && info.view == view && ((info.name == null && getName() == null) || (info.name != null && info.name.equals(getName())))) {
                  if (info.values.equals(infoValues)) {
                    animator=null;
                    break;
                  }
                }
              }
            }
          }
        }
 else {
          view=start.view;
        }
        if (animator != null) {
          if (mPropagation != null) {
            long delay=mPropagation.getStartDelay(sceneRoot,this,start,end);
            startDelays.put(mAnimators.size(),delay);
            minStartDelay=Math.min(delay,minStartDelay);
          }
          AnimationInfo info=new AnimationInfo(view,getName(),this,ViewUtils.getWindowId(sceneRoot),infoValues);
          runningAnimators.put(animator,info);
          mAnimators.add(animator);
        }
      }
    }
  }
  if (minStartDelay != 0) {
    for (int i=0; i < startDelays.size(); i++) {
      int index=startDelays.keyAt(i);
      Animator animator=mAnimators.get(index);
      long delay=startDelays.valueAt(i) - minStartDelay + animator.getStartDelay();
      animator.setStartDelay(delay);
    }
  }
}"
54135,"/** 
 * Pauses this transition, sending out calls to   {@link TransitionListener#onTransitionPause(Transition)} to all listenersand pausing all running animators started by this transition.
 * @hide
 */
public void pause(View sceneRoot){
  if (!mEnded) {
    ArrayMap<Animator,AnimationInfo> runningAnimators=getRunningAnimators();
    int numOldAnims=runningAnimators.size();
    if (sceneRoot != null) {
      Object windowId=ViewUtils.getWindowId(sceneRoot);
      for (int i=numOldAnims - 1; i >= 0; i--) {
        AnimationInfo info=runningAnimators.valueAt(i);
        if (info.view != null && windowId != null && Objects.equal(windowId,info.windowId)) {
          Animator anim=runningAnimators.keyAt(i);
          AnimatorUtils.pause(anim);
        }
      }
    }
    if (mListeners != null && mListeners.size() > 0) {
      ArrayList<TransitionListener> tmpListeners=(ArrayList<TransitionListener>)mListeners.clone();
      int numListeners=tmpListeners.size();
      for (int i=0; i < numListeners; ++i) {
        tmpListeners.get(i).onTransitionPause(this);
      }
    }
    mPaused=true;
  }
}","/** 
 * Pauses this transition, sending out calls to   {@link TransitionListener#onTransitionPause(Transition)} to all listenersand pausing all running animators started by this transition.
 * @hide
 */
public void pause(View sceneRoot){
  if (!mEnded) {
synchronized (sRunningAnimators) {
      ArrayMap<Animator,AnimationInfo> runningAnimators=getRunningAnimators();
      int numOldAnims=runningAnimators.size();
      if (sceneRoot != null) {
        Object windowId=ViewUtils.getWindowId(sceneRoot);
        for (int i=numOldAnims - 1; i >= 0; i--) {
          AnimationInfo info=runningAnimators.valueAt(i);
          if (info.view != null && windowId != null && Objects.equal(windowId,info.windowId)) {
            Animator anim=runningAnimators.keyAt(i);
            AnimatorUtils.pause(anim);
          }
        }
      }
    }
    if (mListeners != null && mListeners.size() > 0) {
      ArrayList<TransitionListener> tmpListeners=(ArrayList<TransitionListener>)mListeners.clone();
      int numListeners=tmpListeners.size();
      for (int i=0; i < numListeners; ++i) {
        tmpListeners.get(i).onTransitionPause(this);
      }
    }
    mPaused=true;
  }
}"
54136,"/** 
 * Called by TransitionManager to play the transition. This calls createAnimators() to set things up and create all of the animations and then runAnimations() to actually start the animations.
 */
void playTransition(ViewGroup sceneRoot){
  mStartValuesList=new ArrayList<TransitionValues>();
  mEndValuesList=new ArrayList<TransitionValues>();
  matchStartAndEnd(mStartValues,mEndValues);
  ArrayMap<Animator,AnimationInfo> runningAnimators=getRunningAnimators();
  int numOldAnims=runningAnimators.size();
  Object windowId=ViewUtils.getWindowId(sceneRoot);
  for (int i=numOldAnims - 1; i >= 0; i--) {
    Animator anim=runningAnimators.keyAt(i);
    if (anim != null) {
      AnimationInfo oldInfo=runningAnimators.get(anim);
      if (oldInfo != null && oldInfo.view != null && oldInfo.windowId == windowId) {
        TransitionValues oldValues=oldInfo.values;
        View oldView=oldInfo.view;
        TransitionValues startValues=getTransitionValues(oldView,true);
        TransitionValues endValues=getMatchedTransitionValues(oldView,true);
        if (startValues == null && endValues == null) {
          endValues=mEndValues.viewValues.get(oldView);
        }
        boolean cancel=(startValues != null || endValues != null) && oldInfo.transition.areValuesChanged(oldValues,endValues);
        if (cancel) {
          if (anim.isRunning() || AnimatorUtils.isAnimatorStarted(anim)) {
            if (DBG) {
              Log.d(LOG_TAG,""String_Node_Str"" + anim);
            }
            anim.cancel();
          }
 else {
            if (DBG) {
              Log.d(LOG_TAG,""String_Node_Str"" + anim);
            }
            runningAnimators.remove(anim);
          }
        }
      }
    }
  }
  createAnimators(sceneRoot,mStartValues,mEndValues,mStartValuesList,mEndValuesList);
  runAnimators();
}","/** 
 * Called by TransitionManager to play the transition. This calls createAnimators() to set things up and create all of the animations and then runAnimations() to actually start the animations.
 */
void playTransition(ViewGroup sceneRoot){
  mStartValuesList=new ArrayList<TransitionValues>();
  mEndValuesList=new ArrayList<TransitionValues>();
  matchStartAndEnd(mStartValues,mEndValues);
  ArrayMap<Animator,AnimationInfo> runningAnimators=getRunningAnimators();
synchronized (sRunningAnimators) {
    int numOldAnims=runningAnimators.size();
    Object windowId=ViewUtils.getWindowId(sceneRoot);
    for (int i=numOldAnims - 1; i >= 0; i--) {
      Animator anim=runningAnimators.keyAt(i);
      if (anim != null) {
        AnimationInfo oldInfo=runningAnimators.get(anim);
        if (oldInfo != null && oldInfo.view != null && oldInfo.windowId == windowId) {
          TransitionValues oldValues=oldInfo.values;
          View oldView=oldInfo.view;
          TransitionValues startValues=getTransitionValues(oldView,true);
          TransitionValues endValues=getMatchedTransitionValues(oldView,true);
          if (startValues == null && endValues == null) {
            endValues=mEndValues.viewValues.get(oldView);
          }
          boolean cancel=(startValues != null || endValues != null) && oldInfo.transition.areValuesChanged(oldValues,endValues);
          if (cancel) {
            if (anim.isRunning() || AnimatorUtils.isAnimatorStarted(anim)) {
              if (DBG) {
                Log.d(LOG_TAG,""String_Node_Str"" + anim);
              }
              anim.cancel();
            }
 else {
              if (DBG) {
                Log.d(LOG_TAG,""String_Node_Str"" + anim);
              }
              runningAnimators.remove(anim);
            }
          }
        }
      }
    }
  }
  createAnimators(sceneRoot,mStartValues,mEndValues,mStartValuesList,mEndValuesList);
  runAnimators();
}"
54137,"private static void sceneChangeRunTransition(final ViewGroup sceneRoot,final Transition transition){
  if (transition != null && isTransitionsAllowed()) {
    ViewGroupOverlayUtils.initializeOverlay(sceneRoot);
    final ViewTreeObserver observer=sceneRoot.getViewTreeObserver();
    final ViewTreeObserver.OnPreDrawListener listener=new ViewTreeObserver.OnPreDrawListener(){
      public boolean onPreDraw(){
        sceneRoot.getViewTreeObserver().removeOnPreDrawListener(this);
        sPendingTransitions.remove(sceneRoot);
        final ArrayMap<ViewGroup,ArrayList<Transition>> runningTransitions=getRunningTransitions();
        ArrayList<Transition> currentTransitions=runningTransitions.get(sceneRoot);
        ArrayList<Transition> previousRunningTransitions=null;
        if (currentTransitions == null) {
          currentTransitions=new ArrayList<Transition>();
          runningTransitions.put(sceneRoot,currentTransitions);
        }
 else         if (currentTransitions.size() > 0) {
          previousRunningTransitions=new ArrayList<Transition>(currentTransitions);
        }
        currentTransitions.add(transition);
        transition.addListener(new Transition.TransitionListenerAdapter(){
          @Override public void onTransitionEnd(          Transition transition){
            ArrayList<Transition> currentTransitions=runningTransitions.get(sceneRoot);
            currentTransitions.remove(transition);
            transition.onEndOfAllTransitions();
          }
        }
);
        transition.captureValues(sceneRoot,false);
        if (previousRunningTransitions != null) {
          for (          Transition runningTransition : previousRunningTransitions) {
            runningTransition.resume(sceneRoot);
          }
        }
        transition.playTransition(sceneRoot);
        return true;
      }
    }
;
    observer.addOnPreDrawListener(listener);
  }
}","private static void sceneChangeRunTransition(final ViewGroup sceneRoot,final Transition transition){
  if (transition != null && isTransitionsAllowed()) {
    ViewGroupOverlayUtils.initializeOverlay(sceneRoot);
    final ViewTreeObserver observer=sceneRoot.getViewTreeObserver();
    final ViewTreeObserver.OnPreDrawListener listener=new ViewTreeObserver.OnPreDrawListener(){
      public boolean onPreDraw(){
        sceneRoot.getViewTreeObserver().removeOnPreDrawListener(this);
        sPendingTransitions.remove(sceneRoot);
        final ArrayMap<ViewGroup,ArrayList<Transition>> runningTransitions=getRunningTransitions();
        ArrayList<Transition> currentTransitions=runningTransitions.get(sceneRoot);
        ArrayList<Transition> previousRunningTransitions=null;
        if (currentTransitions == null) {
          currentTransitions=new ArrayList<Transition>();
          runningTransitions.put(sceneRoot,currentTransitions);
        }
 else         if (currentTransitions.size() > 0) {
          previousRunningTransitions=new ArrayList<Transition>(currentTransitions);
        }
        currentTransitions.add(transition);
        transition.addListener(new Transition.TransitionListenerAdapter(){
          @Override public void onTransitionEnd(          Transition transition){
            ArrayList<Transition> currentTransitions=runningTransitions.get(sceneRoot);
            currentTransitions.remove(transition);
          }
        }
);
        transition.captureValues(sceneRoot,false);
        if (previousRunningTransitions != null) {
          for (          Transition runningTransition : previousRunningTransitions) {
            runningTransition.resume(sceneRoot);
          }
        }
        transition.playTransition(sceneRoot);
        return true;
      }
    }
;
    observer.addOnPreDrawListener(listener);
  }
}"
54138,"@Override public void onTransitionEnd(Transition transition){
  ArrayList<Transition> currentTransitions=runningTransitions.get(sceneRoot);
  currentTransitions.remove(transition);
  transition.onEndOfAllTransitions();
}","@Override public void onTransitionEnd(Transition transition){
  ArrayList<Transition> currentTransitions=runningTransitions.get(sceneRoot);
  currentTransitions.remove(transition);
}"
54139,"public boolean onPreDraw(){
  sceneRoot.getViewTreeObserver().removeOnPreDrawListener(this);
  sPendingTransitions.remove(sceneRoot);
  final ArrayMap<ViewGroup,ArrayList<Transition>> runningTransitions=getRunningTransitions();
  ArrayList<Transition> currentTransitions=runningTransitions.get(sceneRoot);
  ArrayList<Transition> previousRunningTransitions=null;
  if (currentTransitions == null) {
    currentTransitions=new ArrayList<Transition>();
    runningTransitions.put(sceneRoot,currentTransitions);
  }
 else   if (currentTransitions.size() > 0) {
    previousRunningTransitions=new ArrayList<Transition>(currentTransitions);
  }
  currentTransitions.add(transition);
  transition.addListener(new Transition.TransitionListenerAdapter(){
    @Override public void onTransitionEnd(    Transition transition){
      ArrayList<Transition> currentTransitions=runningTransitions.get(sceneRoot);
      currentTransitions.remove(transition);
      transition.onEndOfAllTransitions();
    }
  }
);
  transition.captureValues(sceneRoot,false);
  if (previousRunningTransitions != null) {
    for (    Transition runningTransition : previousRunningTransitions) {
      runningTransition.resume(sceneRoot);
    }
  }
  transition.playTransition(sceneRoot);
  return true;
}","public boolean onPreDraw(){
  sceneRoot.getViewTreeObserver().removeOnPreDrawListener(this);
  sPendingTransitions.remove(sceneRoot);
  final ArrayMap<ViewGroup,ArrayList<Transition>> runningTransitions=getRunningTransitions();
  ArrayList<Transition> currentTransitions=runningTransitions.get(sceneRoot);
  ArrayList<Transition> previousRunningTransitions=null;
  if (currentTransitions == null) {
    currentTransitions=new ArrayList<Transition>();
    runningTransitions.put(sceneRoot,currentTransitions);
  }
 else   if (currentTransitions.size() > 0) {
    previousRunningTransitions=new ArrayList<Transition>(currentTransitions);
  }
  currentTransitions.add(transition);
  transition.addListener(new Transition.TransitionListenerAdapter(){
    @Override public void onTransitionEnd(    Transition transition){
      ArrayList<Transition> currentTransitions=runningTransitions.get(sceneRoot);
      currentTransitions.remove(transition);
    }
  }
);
  transition.captureValues(sceneRoot,false);
  if (previousRunningTransitions != null) {
    for (    Transition runningTransition : previousRunningTransitions) {
      runningTransition.resume(sceneRoot);
    }
  }
  transition.playTransition(sceneRoot);
  return true;
}"
54140,"@Override public void onAnimationEnd(Animator animation){
  if (!mCanceled) {
    if (!isForcedVisibility) {
      mFinalViewToKeep=finalViewToKeep;
      mFinalVisibility=finalVisibility;
    }
    ViewUtils.setTransitionAlpha(finalViewToKeep,0);
  }
}","@Override public void onAnimationEnd(Animator animation){
  if (!mCanceled) {
    if (isForcedVisibility) {
      ViewUtils.setTransitionAlpha(finalViewToKeep,0);
    }
 else {
      finalViewToKeep.setVisibility(finalVisibility);
    }
  }
}"
54141,"public static void suppressLayout(ViewGroup group,boolean suppress){
  IMPL.suppressLayout(group,suppress);
}","public static void suppressLayout(ViewGroup group,boolean suppress){
  if (group != null) {
    IMPL.suppressLayout(group,suppress);
  }
}"
54142,"private ObjectAnimator createMatrixAnimator(final ImageView imageView,Matrix startMatrix,final Matrix endMatrix){
  return AnimatorUtils.ofObject(new ImageAnimator(imageView),new TransitionUtils.MatrixEvaluator(),startMatrix,endMatrix);
}","private ObjectAnimator createMatrixAnimator(final ImageView imageView,Matrix startMatrix,final Matrix endMatrix){
  return AnimatorUtils.ofObject(new ImageAnimator(imageView),new MatrixUtils.MatrixEvaluator(),startMatrix,endMatrix);
}"
54143,"private ObjectAnimator createNullAnimator(ImageView imageView){
  return createMatrixAnimator(imageView,null,null);
}","private ObjectAnimator createNullAnimator(ImageView imageView){
  return AnimatorUtils.ofObject(new ImageAnimator(imageView),new MatrixUtils.NullMatrixEvaluator(),MatrixUtils.IDENTITY_MATRIX,MatrixUtils.IDENTITY_MATRIX);
}"
54144,"private ObjectAnimator createTransformAnimator(TransitionValues startValues,TransitionValues endValues,final boolean handleParentChange){
  Matrix startMatrix=(Matrix)startValues.values.get(PROPNAME_MATRIX);
  Matrix endMatrix=(Matrix)endValues.values.get(PROPNAME_MATRIX);
  if (startMatrix == null) {
    startMatrix=MatrixUtils.IDENTITY_MATRIX;
  }
  if (endMatrix == null) {
    endMatrix=MatrixUtils.IDENTITY_MATRIX;
  }
  if (startMatrix.equals(endMatrix)) {
    return null;
  }
  final Transforms transforms=(Transforms)endValues.values.get(PROPNAME_TRANSFORMS);
  final View view=endValues.view;
  setIdentityTransforms(view);
  ObjectAnimator animator=ObjectAnimator.ofObject(view,ANIMATION_MATRIX_PROPERTY,new TransitionUtils.MatrixEvaluator(),startMatrix,endMatrix);
  final Matrix finalEndMatrix=endMatrix;
  AnimatorListenerAdapter listener=new AnimatorListenerAdapter(){
    private boolean mIsCanceled;
    private Matrix mTempMatrix=new Matrix();
    @Override public void onAnimationCancel(    Animator animation){
      mIsCanceled=true;
    }
    @Override public void onAnimationEnd(    Animator animation){
      if (!mIsCanceled) {
        if (handleParentChange && mUseOverlay) {
          setCurrentMatrix(finalEndMatrix);
        }
 else {
          view.setTag(R.id.transitionTransform,null);
          view.setTag(R.id.parentMatrix,null);
        }
      }
      ANIMATION_MATRIX_PROPERTY.set(view,null);
      transforms.restore(view);
    }
    @Override public void onAnimationPause(    Animator animation){
      ValueAnimator animator=(ValueAnimator)animation;
      Matrix currentMatrix=(Matrix)animator.getAnimatedValue();
      setCurrentMatrix(currentMatrix);
    }
    @Override public void onAnimationResume(    Animator animation){
      setIdentityTransforms(view);
    }
    private void setCurrentMatrix(    Matrix currentMatrix){
      mTempMatrix.set(currentMatrix);
      view.setTag(R.id.transitionTransform,mTempMatrix);
      transforms.restore(view);
    }
  }
;
  animator.addListener(listener);
  animator.addPauseListener(listener);
  return animator;
}","private ObjectAnimator createTransformAnimator(TransitionValues startValues,TransitionValues endValues,final boolean handleParentChange){
  Matrix startMatrix=(Matrix)startValues.values.get(PROPNAME_MATRIX);
  Matrix endMatrix=(Matrix)endValues.values.get(PROPNAME_MATRIX);
  if (startMatrix == null) {
    startMatrix=MatrixUtils.IDENTITY_MATRIX;
  }
  if (endMatrix == null) {
    endMatrix=MatrixUtils.IDENTITY_MATRIX;
  }
  if (startMatrix.equals(endMatrix)) {
    return null;
  }
  final Transforms transforms=(Transforms)endValues.values.get(PROPNAME_TRANSFORMS);
  final View view=endValues.view;
  setIdentityTransforms(view);
  ObjectAnimator animator=ObjectAnimator.ofObject(view,ANIMATION_MATRIX_PROPERTY,new MatrixUtils.MatrixEvaluator(),startMatrix,endMatrix);
  final Matrix finalEndMatrix=endMatrix;
  AnimatorListenerAdapter listener=new AnimatorListenerAdapter(){
    private boolean mIsCanceled;
    private Matrix mTempMatrix=new Matrix();
    @Override public void onAnimationCancel(    Animator animation){
      mIsCanceled=true;
    }
    @Override public void onAnimationEnd(    Animator animation){
      if (!mIsCanceled) {
        if (handleParentChange && mUseOverlay) {
          setCurrentMatrix(finalEndMatrix);
        }
 else {
          view.setTag(R.id.transitionTransform,null);
          view.setTag(R.id.parentMatrix,null);
        }
      }
      ANIMATION_MATRIX_PROPERTY.set(view,null);
      transforms.restore(view);
    }
    @Override public void onAnimationPause(    Animator animation){
      ValueAnimator animator=(ValueAnimator)animation;
      Matrix currentMatrix=(Matrix)animator.getAnimatedValue();
      setCurrentMatrix(currentMatrix);
    }
    @Override public void onAnimationResume(    Animator animation){
      setIdentityTransforms(view);
    }
    private void setCurrentMatrix(    Matrix currentMatrix){
      mTempMatrix.set(currentMatrix);
      view.setTag(R.id.transitionTransform,mTempMatrix);
      transforms.restore(view);
    }
  }
;
  animator.addListener(listener);
  animator.addPauseListener(listener);
  return animator;
}"
54145,"public static void animateTransform(ImageView imageView,Matrix matrix){
  Drawable drawable=imageView.getDrawable();
  if (matrix == null) {
    drawable.setBounds(0,0,imageView.getWidth(),imageView.getHeight());
  }
 else {
    drawable.setBounds(0,0,drawable.getIntrinsicWidth(),drawable.getIntrinsicHeight());
    Matrix drawMatrix=imageView.getImageMatrix();
    drawMatrix.set(matrix);
    ReflectionUtils.setFieldValue(imageView,FIELD_DRAW_MATRIX,drawMatrix);
  }
  imageView.invalidate();
}","public static void animateTransform(ImageView imageView,Matrix matrix){
  Drawable drawable=imageView.getDrawable();
  if (matrix == null || drawable.getIntrinsicWidth() == -1 || drawable.getIntrinsicHeight() == -1) {
    drawable.setBounds(0,0,imageView.getWidth(),imageView.getHeight());
  }
 else {
    drawable.setBounds(0,0,drawable.getIntrinsicWidth(),drawable.getIntrinsicHeight());
    Matrix drawMatrix=imageView.getImageMatrix();
    drawMatrix.set(matrix);
    ReflectionUtils.setFieldValue(imageView,FIELD_DRAW_MATRIX,drawMatrix);
  }
  imageView.invalidate();
}"
54146,"/** 
 * Returns a Scene described by the resource file associated with the given <code>layoutId</code> parameter. If such a Scene has already been created, that same Scene will be returned. This caching of layoutId-based scenes enables sharing of common scenes between those created in code and those referenced by   {@link TransitionManager} XML resource files.
 * @param sceneRoot The root of the hierarchy in which scene changesand transitions will take place.
 * @param layoutId The id of a standard layout resource file.
 * @param context The context used in the process of inflatingthe layout resource.
 * @return
 */
public static Scene getSceneForLayout(ViewGroup sceneRoot,int layoutId,Context context){
  SparseArray<Scene> scenes=sScenes.get();
  if (scenes == null) {
    scenes=new SparseArray<Scene>();
    sScenes.set(scenes);
  }
  Scene scene=scenes.get(layoutId);
  if (scene != null) {
    return scene;
  }
 else {
    scene=new Scene(sceneRoot,layoutId,context);
    scenes.put(layoutId,scene);
    return scene;
  }
}","/** 
 * Returns a Scene described by the resource file associated with the given <code>layoutId</code> parameter. If such a Scene has already been created, that same Scene will be returned. This caching of layoutId-based scenes enables sharing of common scenes between those created in code and those referenced by   {@link TransitionManager} XML resource files.
 * @param sceneRoot The root of the hierarchy in which scene changesand transitions will take place.
 * @param layoutId The id of a standard layout resource file.
 * @param context The context used in the process of inflatingthe layout resource.
 * @return
 */
public static Scene getSceneForLayout(ViewGroup sceneRoot,int layoutId,Context context){
  SparseArray<Scene> scenes=sScenes.get();
  if (scenes == null) {
    scenes=new SparseArray<Scene>();
    sScenes.set(scenes);
  }
  Scene scene=scenes.get(layoutId);
  if (scene != null) {
    scene.mSceneRoot=sceneRoot;
    return scene;
  }
 else {
    scene=new Scene(sceneRoot,layoutId,context);
    scenes.put(layoutId,scene);
    return scene;
  }
}"
54147,"/** 
 * Perform inflation from XML and apply a class-specific base style from a theme attribute or style resource. This constructor of Transition allows subclasses to use their own base style when they are inflating.
 * @param context The Context the transition is running in, through which it canaccess the current theme, resources, etc.
 * @param attrs The attributes of the XML tag that is inflating the transition.
 */
public Transition(Context context,AttributeSet attrs){
  TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.Transition);
  long duration=a.getInt(R.styleable.Transition_duration,-1);
  if (duration >= 0) {
    setDuration(duration);
  }
  long startDelay=a.getInt(R.styleable.Transition_startDelay,-1);
  if (startDelay > 0) {
    setStartDelay(startDelay);
  }
  final int resID=a.getResourceId(R.styleable.Animator_interpolator,0);
  if (resID > 0) {
    setInterpolator(AnimationUtils.loadInterpolator(context,resID));
  }
  String matchOrder=a.getString(R.styleable.Transition_matchOrder);
  if (matchOrder != null) {
    setMatchOrder(parseMatchOrder(matchOrder));
  }
  a.recycle();
}","/** 
 * Perform inflation from XML and apply a class-specific base style from a theme attribute or style resource. This constructor of Transition allows subclasses to use their own base style when they are inflating.
 * @param context The Context the transition is running in, through which it canaccess the current theme, resources, etc.
 * @param attrs The attributes of the XML tag that is inflating the transition.
 */
public Transition(Context context,AttributeSet attrs){
  TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.Transition);
  long duration=a.getInt(R.styleable.Transition_android_duration,-1);
  if (duration >= 0) {
    setDuration(duration);
  }
  long startDelay=a.getInt(R.styleable.Transition_startDelay,-1);
  if (startDelay > 0) {
    setStartDelay(startDelay);
  }
  final int resID=a.getResourceId(R.styleable.Animator_android_interpolator,0);
  if (resID > 0) {
    setInterpolator(AnimationUtils.loadInterpolator(context,resID));
  }
  String matchOrder=a.getString(R.styleable.Transition_matchOrder);
  if (matchOrder != null) {
    setMatchOrder(parseMatchOrder(matchOrder));
  }
  a.recycle();
}"
54148,"private static void sceneChangeRunTransition(final ViewGroup sceneRoot,final Transition transition){
  if (transition != null && isTransitionsAllowed()) {
    ViewGroupOverlayUtils.addOverlayIfNeeded(sceneRoot);
    final ViewTreeObserver observer=sceneRoot.getViewTreeObserver();
    final ViewTreeObserver.OnPreDrawListener listener=new ViewTreeObserver.OnPreDrawListener(){
      public boolean onPreDraw(){
        sceneRoot.getViewTreeObserver().removeOnPreDrawListener(this);
        sPendingTransitions.remove(sceneRoot);
        final ArrayMap<ViewGroup,ArrayList<Transition>> runningTransitions=getRunningTransitions();
        ArrayList<Transition> currentTransitions=runningTransitions.get(sceneRoot);
        ArrayList<Transition> previousRunningTransitions=null;
        if (currentTransitions == null) {
          currentTransitions=new ArrayList<Transition>();
          runningTransitions.put(sceneRoot,currentTransitions);
        }
 else         if (currentTransitions.size() > 0) {
          previousRunningTransitions=new ArrayList<Transition>(currentTransitions);
        }
        currentTransitions.add(transition);
        transition.addListener(new Transition.TransitionListenerAdapter(){
          @Override public void onTransitionEnd(          Transition transition){
            ArrayList<Transition> currentTransitions=runningTransitions.get(sceneRoot);
            currentTransitions.remove(transition);
          }
        }
);
        transition.captureValues(sceneRoot,false);
        if (previousRunningTransitions != null) {
          for (          Transition runningTransition : previousRunningTransitions) {
            runningTransition.resume(sceneRoot);
          }
        }
        transition.playTransition(sceneRoot);
        return true;
      }
    }
;
    observer.addOnPreDrawListener(listener);
  }
}","private static void sceneChangeRunTransition(final ViewGroup sceneRoot,final Transition transition){
  if (transition != null && isTransitionsAllowed()) {
    ViewGroupOverlayUtils.addOverlayIfNeeded(sceneRoot);
    final ViewTreeObserver observer=sceneRoot.getViewTreeObserver();
    final ViewTreeObserver.OnPreDrawListener listener=new ViewTreeObserver.OnPreDrawListener(){
      public boolean onPreDraw(){
        sceneRoot.getViewTreeObserver().removeOnPreDrawListener(this);
        sPendingTransitions.remove(sceneRoot);
        final ArrayMap<ViewGroup,ArrayList<Transition>> runningTransitions=getRunningTransitions();
        ArrayList<Transition> currentTransitions=runningTransitions.get(sceneRoot);
        ArrayList<Transition> previousRunningTransitions=null;
        if (currentTransitions == null) {
          currentTransitions=new ArrayList<Transition>();
          runningTransitions.put(sceneRoot,currentTransitions);
        }
 else         if (currentTransitions.size() > 0) {
          previousRunningTransitions=new ArrayList<Transition>(currentTransitions);
        }
        currentTransitions.add(transition);
        transition.addListener(new Transition.TransitionListenerAdapter(){
          @Override public void onTransitionEnd(          Transition transition){
            ArrayList<Transition> currentTransitions=runningTransitions.get(sceneRoot);
            currentTransitions.remove(transition);
            transition.onEndOfAllTransitions();
          }
        }
);
        transition.captureValues(sceneRoot,false);
        if (previousRunningTransitions != null) {
          for (          Transition runningTransition : previousRunningTransitions) {
            runningTransition.resume(sceneRoot);
          }
        }
        transition.playTransition(sceneRoot);
        return true;
      }
    }
;
    observer.addOnPreDrawListener(listener);
  }
}"
54149,"@Override public void onTransitionEnd(Transition transition){
  ArrayList<Transition> currentTransitions=runningTransitions.get(sceneRoot);
  currentTransitions.remove(transition);
}","@Override public void onTransitionEnd(Transition transition){
  ArrayList<Transition> currentTransitions=runningTransitions.get(sceneRoot);
  currentTransitions.remove(transition);
  transition.onEndOfAllTransitions();
}"
54150,"public boolean onPreDraw(){
  sceneRoot.getViewTreeObserver().removeOnPreDrawListener(this);
  sPendingTransitions.remove(sceneRoot);
  final ArrayMap<ViewGroup,ArrayList<Transition>> runningTransitions=getRunningTransitions();
  ArrayList<Transition> currentTransitions=runningTransitions.get(sceneRoot);
  ArrayList<Transition> previousRunningTransitions=null;
  if (currentTransitions == null) {
    currentTransitions=new ArrayList<Transition>();
    runningTransitions.put(sceneRoot,currentTransitions);
  }
 else   if (currentTransitions.size() > 0) {
    previousRunningTransitions=new ArrayList<Transition>(currentTransitions);
  }
  currentTransitions.add(transition);
  transition.addListener(new Transition.TransitionListenerAdapter(){
    @Override public void onTransitionEnd(    Transition transition){
      ArrayList<Transition> currentTransitions=runningTransitions.get(sceneRoot);
      currentTransitions.remove(transition);
    }
  }
);
  transition.captureValues(sceneRoot,false);
  if (previousRunningTransitions != null) {
    for (    Transition runningTransition : previousRunningTransitions) {
      runningTransition.resume(sceneRoot);
    }
  }
  transition.playTransition(sceneRoot);
  return true;
}","public boolean onPreDraw(){
  sceneRoot.getViewTreeObserver().removeOnPreDrawListener(this);
  sPendingTransitions.remove(sceneRoot);
  final ArrayMap<ViewGroup,ArrayList<Transition>> runningTransitions=getRunningTransitions();
  ArrayList<Transition> currentTransitions=runningTransitions.get(sceneRoot);
  ArrayList<Transition> previousRunningTransitions=null;
  if (currentTransitions == null) {
    currentTransitions=new ArrayList<Transition>();
    runningTransitions.put(sceneRoot,currentTransitions);
  }
 else   if (currentTransitions.size() > 0) {
    previousRunningTransitions=new ArrayList<Transition>(currentTransitions);
  }
  currentTransitions.add(transition);
  transition.addListener(new Transition.TransitionListenerAdapter(){
    @Override public void onTransitionEnd(    Transition transition){
      ArrayList<Transition> currentTransitions=runningTransitions.get(sceneRoot);
      currentTransitions.remove(transition);
      transition.onEndOfAllTransitions();
    }
  }
);
  transition.captureValues(sceneRoot,false);
  if (previousRunningTransitions != null) {
    for (    Transition runningTransition : previousRunningTransitions) {
      runningTransition.resume(sceneRoot);
    }
  }
  transition.playTransition(sceneRoot);
  return true;
}"
54151,"@Override public void onAnimationEnd(Animator animation){
  if (!mCanceled) {
    if (isForcedVisibility) {
      ViewUtils.setTransitionAlpha(finalViewToKeep,0);
    }
 else {
      finalViewToKeep.setVisibility(finalVisibility);
    }
  }
}","@Override public void onAnimationEnd(Animator animation){
  if (!mCanceled) {
    if (!isForcedVisibility) {
      mFinalViewToKeep=finalViewToKeep;
      mFinalVisibility=finalVisibility;
    }
    ViewUtils.setTransitionAlpha(finalViewToKeep,0);
  }
}"
54152,"private void initDefaultHeaderOffset(Rect headerMargins,RecyclerView recyclerView,View header,View firstView,int orientation){
  int translationX, translationY;
  mDimensionCalculator.initMargins(mTempRect1,header);
  if (orientation == LinearLayoutManager.VERTICAL) {
    translationX=firstView.getLeft() + mTempRect1.left;
    translationY=Math.max(firstView.getTop() - header.getHeight() - mTempRect1.bottom,getListTop(recyclerView) + mTempRect1.top);
  }
 else {
    translationY=firstView.getTop() + mTempRect1.top;
    translationX=Math.max(firstView.getLeft() - header.getWidth() - mTempRect1.right,getListLeft(recyclerView) + mTempRect1.left);
  }
  headerMargins.set(translationX,translationY,translationX + header.getWidth(),translationY + header.getHeight());
}","private void initDefaultHeaderOffset(Rect headerMargins,RecyclerView recyclerView,View header,View firstView,int orientation){
  int translationX, translationY;
  mDimensionCalculator.initMargins(mTempRect1,header);
  ViewGroup.LayoutParams layoutParams=firstView.getLayoutParams();
  int leftMargin=0;
  int topMargin=0;
  if (layoutParams instanceof ViewGroup.MarginLayoutParams) {
    ViewGroup.MarginLayoutParams marginLayoutParams=(ViewGroup.MarginLayoutParams)layoutParams;
    leftMargin=marginLayoutParams.leftMargin;
    topMargin=marginLayoutParams.topMargin;
  }
  if (orientation == LinearLayoutManager.VERTICAL) {
    translationX=firstView.getLeft() - leftMargin + mTempRect1.left;
    translationY=Math.max(firstView.getTop() - topMargin - header.getHeight()- mTempRect1.bottom,getListTop(recyclerView) + mTempRect1.top);
  }
 else {
    translationY=firstView.getTop() - topMargin + mTempRect1.top;
    translationX=Math.max(firstView.getLeft() - leftMargin - header.getWidth()- mTempRect1.right,getListLeft(recyclerView) + mTempRect1.left);
  }
  headerMargins.set(translationX,translationY,translationX + header.getWidth(),translationY + header.getHeight());
}"
54153,"private void initDefaultHeaderOffset(Rect headerMargins,RecyclerView recyclerView,View header,View firstView,int orientation){
  int translationX, translationY;
  mDimensionCalculator.initMargins(mTempRect1,header);
  if (orientation == LinearLayoutManager.VERTICAL) {
    translationX=firstView.getLeft() + mTempRect1.left;
    translationY=Math.max(firstView.getTop() - header.getHeight() - mTempRect1.bottom,getListTop(recyclerView) + mTempRect1.top);
  }
 else {
    translationY=firstView.getTop() + mTempRect1.top;
    translationX=Math.max(firstView.getLeft() - header.getWidth() - mTempRect1.right,getListLeft(recyclerView) + mTempRect1.left);
  }
  headerMargins.set(translationX,translationY,translationX + header.getWidth(),translationY + header.getHeight());
}","private void initDefaultHeaderOffset(Rect headerMargins,RecyclerView recyclerView,View header,View firstView,int orientation){
  int translationX, translationY;
  mDimensionCalculator.initMargins(mTempRect1,header);
  ViewGroup.LayoutParams layoutParams=firstView.getLayoutParams();
  int leftMargin=0;
  int topMargin=0;
  if (layoutParams instanceof ViewGroup.MarginLayoutParams) {
    ViewGroup.MarginLayoutParams marginLayoutParams=(ViewGroup.MarginLayoutParams)layoutParams;
    leftMargin=marginLayoutParams.leftMargin;
    topMargin=marginLayoutParams.topMargin;
  }
  if (orientation == LinearLayoutManager.VERTICAL) {
    translationX=firstView.getLeft() - leftMargin + mTempRect1.left;
    translationY=Math.max(firstView.getTop() - topMargin - header.getHeight()- mTempRect1.bottom,getListTop(recyclerView) + mTempRect1.top);
  }
 else {
    translationY=firstView.getTop() - topMargin + mTempRect1.top;
    translationX=Math.max(firstView.getLeft() - leftMargin - header.getWidth()- mTempRect1.right,getListLeft(recyclerView) + mTempRect1.left);
  }
  headerMargins.set(translationX,translationY,translationX + header.getWidth(),translationY + header.getHeight());
}"
54154,"public void drawHorizontal(Canvas c,RecyclerView parent){
  final int top=parent.getPaddingTop();
  final int bottom=parent.getHeight() - parent.getPaddingBottom();
  final int childCount=parent.getChildCount();
  for (int i=0; i < childCount; i++) {
    final View child=parent.getChildAt(i);
    final RecyclerView.LayoutParams params=(RecyclerView.LayoutParams)child.getLayoutParams();
    final int left=child.getRight() + params.rightMargin;
    final int right=left + mDivider.getIntrinsicHeight();
    mDivider.setBounds(left,top,right,bottom);
    mDivider.draw(c);
  }
}","public void drawHorizontal(Canvas c,RecyclerView parent){
  final int top=parent.getPaddingTop();
  final int bottom=parent.getHeight() - parent.getPaddingBottom();
  final int recyclerViewLeft=parent.getPaddingLeft();
  final int recyclerViewRight=parent.getWidth() - parent.getPaddingRight();
  final int childCount=parent.getChildCount();
  for (int i=0; i < childCount; i++) {
    final View child=parent.getChildAt(i);
    final RecyclerView.LayoutParams params=(RecyclerView.LayoutParams)child.getLayoutParams();
    final int left=Math.max(recyclerViewLeft,child.getRight() + params.rightMargin);
    final int right=Math.min(recyclerViewRight,left + mDivider.getIntrinsicHeight());
    mDivider.setBounds(left,top,right,bottom);
    mDivider.draw(c);
  }
}"
54155,"public void drawVertical(Canvas c,RecyclerView parent){
  final int left=parent.getPaddingLeft();
  final int right=parent.getWidth() - parent.getPaddingRight();
  final int childCount=parent.getChildCount();
  for (int i=0; i < childCount; i++) {
    final View child=parent.getChildAt(i);
    final RecyclerView.LayoutParams params=(RecyclerView.LayoutParams)child.getLayoutParams();
    final int top=child.getBottom() + params.bottomMargin;
    final int bottom=top + mDivider.getIntrinsicHeight();
    mDivider.setBounds(left,top,right,bottom);
    mDivider.draw(c);
  }
}","public void drawVertical(Canvas c,RecyclerView parent){
  final int left=parent.getPaddingLeft();
  final int right=parent.getWidth() - parent.getPaddingRight();
  final int recyclerViewTop=parent.getPaddingTop();
  final int recyclerViewBottom=parent.getHeight() - parent.getPaddingBottom();
  final int childCount=parent.getChildCount();
  for (int i=0; i < childCount; i++) {
    final View child=parent.getChildAt(i);
    final RecyclerView.LayoutParams params=(RecyclerView.LayoutParams)child.getLayoutParams();
    final int top=Math.max(recyclerViewTop,child.getBottom() + params.bottomMargin);
    final int bottom=Math.min(recyclerViewBottom,top + mDivider.getIntrinsicHeight());
    mDivider.setBounds(left,top,right,bottom);
    mDivider.draw(c);
  }
}"
54156,"@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  float startAngle=270 - arcAngle / 2f;
  float finishedSweepAngle=progress / (float)getMax() * arcAngle;
  float finishedStartAngle=startAngle;
  paint.setColor(unfinishedStrokeColor);
  canvas.drawArc(rectF,startAngle,arcAngle,false,paint);
  paint.setColor(finishedStrokeColor);
  canvas.drawArc(rectF,finishedStartAngle,finishedSweepAngle,false,paint);
  String text=String.valueOf(getProgress());
  if (!TextUtils.isEmpty(text)) {
    textPaint.setColor(textColor);
    textPaint.setTextSize(textSize);
    float textHeight=textPaint.descent() + textPaint.ascent();
    float textBaseline=(getHeight() - textHeight) / 2.0f;
    canvas.drawText(text,(getWidth() - textPaint.measureText(text)) / 2.0f,textBaseline,textPaint);
    textPaint.setTextSize(suffixTextSize);
    float suffixHeight=textPaint.descent() + textPaint.ascent();
    canvas.drawText(suffixText,getWidth() / 2.0f + textPaint.measureText(text) + suffixTextPadding,textBaseline + textHeight - suffixHeight,textPaint);
  }
  if (!TextUtils.isEmpty(getBottomText())) {
    textPaint.setTextSize(bottomTextSize);
    float bottomTextBaseline=getHeight() - arcBottomHeight - (textPaint.descent() + textPaint.ascent()) / 2;
    canvas.drawText(getBottomText(),(getWidth() - textPaint.measureText(getBottomText())) / 2.0f,bottomTextBaseline,textPaint);
  }
}","@Override protected void onDraw(Canvas canvas){
  super.onDraw(canvas);
  float startAngle=270 - arcAngle / 2f;
  float finishedSweepAngle=progress / (float)getMax() * arcAngle;
  float finishedStartAngle=startAngle;
  paint.setColor(unfinishedStrokeColor);
  canvas.drawArc(rectF,startAngle,arcAngle,false,paint);
  paint.setColor(finishedStrokeColor);
  canvas.drawArc(rectF,finishedStartAngle,finishedSweepAngle,false,paint);
  String text=String.valueOf(getProgress());
  if (!TextUtils.isEmpty(text)) {
    textPaint.setColor(textColor);
    textPaint.setTextSize(textSize);
    float textHeight=textPaint.descent() + textPaint.ascent();
    float textBaseline=(getHeight() - textHeight) / 2.0f;
    canvas.drawText(text,(getWidth() - textPaint.measureText(text)) / 2.0f,textBaseline,textPaint);
    textPaint.setTextSize(suffixTextSize);
    float suffixHeight=textPaint.descent() + textPaint.ascent();
    canvas.drawText(suffixText,getWidth() / 2.0f + textPaint.measureText(text) + suffixTextPadding,textBaseline + textHeight - suffixHeight,textPaint);
  }
  if (arcBottomHeight == 0) {
    float radius=getWidth() / 2f;
    float angle=(360 - arcAngle) / 2f;
    arcBottomHeight=radius * (float)(1 - Math.cos(angle / 180 * Math.PI));
  }
  if (!TextUtils.isEmpty(getBottomText())) {
    textPaint.setTextSize(bottomTextSize);
    float bottomTextBaseline=getHeight() - arcBottomHeight - (textPaint.descent() + textPaint.ascent()) / 2;
    canvas.drawText(getBottomText(),(getWidth() - textPaint.measureText(getBottomText())) / 2.0f,bottomTextBaseline,textPaint);
  }
}"
54157,"@Override protected void onRestoreInstanceState(Parcelable state){
  if (state instanceof Bundle) {
    final Bundle bundle=(Bundle)state;
    textColor=bundle.getInt(INSTANCE_TEXT_COLOR);
    textSize=bundle.getFloat(INSTANCE_TEXT_SIZE);
    innerBottomTextSize=bundle.getFloat(INSTANCE_INNER_BOTTOM_TEXT_SIZE);
    innerBottomText=bundle.getString(INSTANCE_INNER_BOTTOM_TEXT);
    innerBottomTextColor=bundle.getInt(INSTANCE_INNER_BOTTOM_TEXT_COLOR);
    finishedStrokeColor=bundle.getInt(INSTANCE_FINISHED_STROKE_COLOR);
    unfinishedStrokeColor=bundle.getInt(INSTANCE_UNFINISHED_STROKE_COLOR);
    finishedStrokeWidth=bundle.getFloat(INSTANCE_FINISHED_STROKE_WIDTH);
    unfinishedStrokeWidth=bundle.getFloat(INSTANCE_UNFINISHED_STROKE_WIDTH);
    innerBackgroundColor=bundle.getInt(INSTANCE_BACKGROUND_COLOR);
    initPainters();
    setMax(bundle.getInt(INSTANCE_MAX));
    setProgress(bundle.getFloat(INSTANCE_PROGRESS));
    prefixText=bundle.getString(INSTANCE_PREFIX);
    suffixText=bundle.getString(INSTANCE_SUFFIX);
    text=bundle.getString(INSTANCE_TEXT);
    super.onRestoreInstanceState(bundle.getParcelable(INSTANCE_STATE));
    return;
  }
  super.onRestoreInstanceState(state);
}","@Override protected void onRestoreInstanceState(Parcelable state){
  if (state instanceof Bundle) {
    final Bundle bundle=(Bundle)state;
    textColor=bundle.getInt(INSTANCE_TEXT_COLOR);
    textSize=bundle.getFloat(INSTANCE_TEXT_SIZE);
    innerBottomTextSize=bundle.getFloat(INSTANCE_INNER_BOTTOM_TEXT_SIZE);
    innerBottomText=bundle.getString(INSTANCE_INNER_BOTTOM_TEXT);
    innerBottomTextColor=bundle.getInt(INSTANCE_INNER_BOTTOM_TEXT_COLOR);
    finishedStrokeColor=bundle.getInt(INSTANCE_FINISHED_STROKE_COLOR);
    unfinishedStrokeColor=bundle.getInt(INSTANCE_UNFINISHED_STROKE_COLOR);
    finishedStrokeWidth=bundle.getFloat(INSTANCE_FINISHED_STROKE_WIDTH);
    unfinishedStrokeWidth=bundle.getFloat(INSTANCE_UNFINISHED_STROKE_WIDTH);
    innerBackgroundColor=bundle.getInt(INSTANCE_BACKGROUND_COLOR);
    attributeResourceId=bundle.getInt(INSTANCE_INNER_DRAWABLE);
    initPainters();
    setMax(bundle.getInt(INSTANCE_MAX));
    setProgress(bundle.getFloat(INSTANCE_PROGRESS));
    prefixText=bundle.getString(INSTANCE_PREFIX);
    suffixText=bundle.getString(INSTANCE_SUFFIX);
    text=bundle.getString(INSTANCE_TEXT);
    super.onRestoreInstanceState(bundle.getParcelable(INSTANCE_STATE));
    return;
  }
  super.onRestoreInstanceState(state);
}"
54158,"protected void initByAttributes(TypedArray attributes){
  finishedStrokeColor=attributes.getColor(R.styleable.DonutProgress_donut_finished_color,default_finished_color);
  unfinishedStrokeColor=attributes.getColor(R.styleable.DonutProgress_donut_unfinished_color,default_unfinished_color);
  showText=attributes.getBoolean(R.styleable.DonutProgress_donut_show_text,true);
  attributeResourceId=attributes.getResourceId(R.styleable.DonutProgress_donut_inner_drawable,0);
  setMax(attributes.getInt(R.styleable.DonutProgress_donut_max,default_max));
  setProgress(attributes.getInt(R.styleable.DonutProgress_donut_progress,0));
  finishedStrokeWidth=attributes.getDimension(R.styleable.DonutProgress_donut_finished_stroke_width,default_stroke_width);
  unfinishedStrokeWidth=attributes.getDimension(R.styleable.DonutProgress_donut_unfinished_stroke_width,default_stroke_width);
  if (showText) {
    if (attributes.getString(R.styleable.DonutProgress_donut_prefix_text) != null) {
      prefixText=attributes.getString(R.styleable.DonutProgress_donut_prefix_text);
    }
    if (attributes.getString(R.styleable.DonutProgress_donut_suffix_text) != null) {
      suffixText=attributes.getString(R.styleable.DonutProgress_donut_suffix_text);
    }
    if (attributes.getString(R.styleable.DonutProgress_donut_text) != null) {
      text=attributes.getString(R.styleable.DonutProgress_donut_text);
    }
    textColor=attributes.getColor(R.styleable.DonutProgress_donut_text_color,default_text_color);
    textSize=attributes.getDimension(R.styleable.DonutProgress_donut_text_size,default_text_size);
    innerBottomTextSize=attributes.getDimension(R.styleable.DonutProgress_donut_inner_bottom_text_size,default_inner_bottom_text_size);
    innerBottomTextColor=attributes.getColor(R.styleable.DonutProgress_donut_inner_bottom_text_color,default_inner_bottom_text_color);
    innerBottomText=attributes.getString(R.styleable.DonutProgress_donut_inner_bottom_text);
  }
  innerBackgroundColor=attributes.getColor(R.styleable.DonutProgress_donut_background_color,default_inner_background_color);
}","protected void initByAttributes(TypedArray attributes){
  finishedStrokeColor=attributes.getColor(R.styleable.DonutProgress_donut_finished_color,default_finished_color);
  unfinishedStrokeColor=attributes.getColor(R.styleable.DonutProgress_donut_unfinished_color,default_unfinished_color);
  showText=attributes.getBoolean(R.styleable.DonutProgress_donut_show_text,true);
  attributeResourceId=attributes.getResourceId(R.styleable.DonutProgress_donut_inner_drawable,0);
  setMax(attributes.getInt(R.styleable.DonutProgress_donut_max,default_max));
  setProgress(attributes.getFloat(R.styleable.DonutProgress_donut_progress,0));
  finishedStrokeWidth=attributes.getDimension(R.styleable.DonutProgress_donut_finished_stroke_width,default_stroke_width);
  unfinishedStrokeWidth=attributes.getDimension(R.styleable.DonutProgress_donut_unfinished_stroke_width,default_stroke_width);
  if (showText) {
    if (attributes.getString(R.styleable.DonutProgress_donut_prefix_text) != null) {
      prefixText=attributes.getString(R.styleable.DonutProgress_donut_prefix_text);
    }
    if (attributes.getString(R.styleable.DonutProgress_donut_suffix_text) != null) {
      suffixText=attributes.getString(R.styleable.DonutProgress_donut_suffix_text);
    }
    if (attributes.getString(R.styleable.DonutProgress_donut_text) != null) {
      text=attributes.getString(R.styleable.DonutProgress_donut_text);
    }
    textColor=attributes.getColor(R.styleable.DonutProgress_donut_text_color,default_text_color);
    textSize=attributes.getDimension(R.styleable.DonutProgress_donut_text_size,default_text_size);
    innerBottomTextSize=attributes.getDimension(R.styleable.DonutProgress_donut_inner_bottom_text_size,default_inner_bottom_text_size);
    innerBottomTextColor=attributes.getColor(R.styleable.DonutProgress_donut_inner_bottom_text_color,default_inner_bottom_text_color);
    innerBottomText=attributes.getString(R.styleable.DonutProgress_donut_inner_bottom_text);
  }
  innerBackgroundColor=attributes.getColor(R.styleable.DonutProgress_donut_background_color,default_inner_background_color);
}"
54159,"@Override protected Parcelable onSaveInstanceState(){
  final Bundle bundle=new Bundle();
  bundle.putParcelable(INSTANCE_STATE,super.onSaveInstanceState());
  bundle.putInt(INSTANCE_TEXT_COLOR,getTextColor());
  bundle.putFloat(INSTANCE_TEXT_SIZE,getTextSize());
  bundle.putFloat(INSTANCE_INNER_BOTTOM_TEXT_SIZE,getInnerBottomTextSize());
  bundle.putFloat(INSTANCE_INNER_BOTTOM_TEXT_COLOR,getInnerBottomTextColor());
  bundle.putString(INSTANCE_INNER_BOTTOM_TEXT,getInnerBottomText());
  bundle.putInt(INSTANCE_INNER_BOTTOM_TEXT_COLOR,getInnerBottomTextColor());
  bundle.putInt(INSTANCE_FINISHED_STROKE_COLOR,getFinishedStrokeColor());
  bundle.putInt(INSTANCE_UNFINISHED_STROKE_COLOR,getUnfinishedStrokeColor());
  bundle.putInt(INSTANCE_MAX,getMax());
  bundle.putFloat(INSTANCE_PROGRESS,getProgress());
  bundle.putString(INSTANCE_SUFFIX,getSuffixText());
  bundle.putString(INSTANCE_PREFIX,getPrefixText());
  bundle.putString(INSTANCE_TEXT,getText());
  bundle.putFloat(INSTANCE_FINISHED_STROKE_WIDTH,getFinishedStrokeWidth());
  bundle.putFloat(INSTANCE_UNFINISHED_STROKE_WIDTH,getUnfinishedStrokeWidth());
  bundle.putInt(INSTANCE_BACKGROUND_COLOR,getInnerBackgroundColor());
  return bundle;
}","@Override protected Parcelable onSaveInstanceState(){
  final Bundle bundle=new Bundle();
  bundle.putParcelable(INSTANCE_STATE,super.onSaveInstanceState());
  bundle.putInt(INSTANCE_TEXT_COLOR,getTextColor());
  bundle.putFloat(INSTANCE_TEXT_SIZE,getTextSize());
  bundle.putFloat(INSTANCE_INNER_BOTTOM_TEXT_SIZE,getInnerBottomTextSize());
  bundle.putFloat(INSTANCE_INNER_BOTTOM_TEXT_COLOR,getInnerBottomTextColor());
  bundle.putString(INSTANCE_INNER_BOTTOM_TEXT,getInnerBottomText());
  bundle.putInt(INSTANCE_INNER_BOTTOM_TEXT_COLOR,getInnerBottomTextColor());
  bundle.putInt(INSTANCE_FINISHED_STROKE_COLOR,getFinishedStrokeColor());
  bundle.putInt(INSTANCE_UNFINISHED_STROKE_COLOR,getUnfinishedStrokeColor());
  bundle.putInt(INSTANCE_MAX,getMax());
  bundle.putFloat(INSTANCE_PROGRESS,getProgress());
  bundle.putString(INSTANCE_SUFFIX,getSuffixText());
  bundle.putString(INSTANCE_PREFIX,getPrefixText());
  bundle.putString(INSTANCE_TEXT,getText());
  bundle.putFloat(INSTANCE_FINISHED_STROKE_WIDTH,getFinishedStrokeWidth());
  bundle.putFloat(INSTANCE_UNFINISHED_STROKE_WIDTH,getUnfinishedStrokeWidth());
  bundle.putInt(INSTANCE_BACKGROUND_COLOR,getInnerBackgroundColor());
  bundle.putInt(INSTANCE_INNER_DRAWABLE,getAttributeResourceId());
  return bundle;
}"
54160,"protected void initByAttributes(TypedArray attributes){
  finishedStrokeColor=attributes.getColor(R.styleable.ArcProgress_arc_finished_color,default_finished_color);
  unfinishedStrokeColor=attributes.getColor(R.styleable.ArcProgress_arc_unfinished_color,default_unfinished_color);
  textColor=attributes.getColor(R.styleable.ArcProgress_arc_text_color,default_text_color);
  textSize=attributes.getDimension(R.styleable.ArcProgress_arc_text_size,default_text_size);
  arcAngle=attributes.getDimension(R.styleable.ArcProgress_arc_angle,default_arc_angle);
  setMax(attributes.getInt(R.styleable.ArcProgress_arc_max,default_max));
  setProgress(attributes.getInt(R.styleable.ArcProgress_arc_progress,0));
  strokeWidth=attributes.getDimension(R.styleable.ArcProgress_arc_stroke_width,default_stroke_width);
  suffixTextSize=attributes.getDimension(R.styleable.ArcProgress_arc_suffix_text_size,default_suffix_text_size);
  suffixText=TextUtils.isEmpty(attributes.getString(R.styleable.ArcProgress_arc_suffix_text)) ? default_suffix_text : attributes.getString(R.styleable.ArcProgress_arc_suffix_text);
  suffixTextPadding=attributes.getDimension(R.styleable.ArcProgress_arc_suffix_text_padding,default_suffix_padding);
  bottomTextSize=attributes.getDimension(R.styleable.ArcProgress_arc_bottom_text_size,default_bottom_text_size);
  bottomText=attributes.getString(R.styleable.ArcProgress_arc_bottom_text);
}","protected void initByAttributes(TypedArray attributes){
  finishedStrokeColor=attributes.getColor(R.styleable.ArcProgress_arc_finished_color,default_finished_color);
  unfinishedStrokeColor=attributes.getColor(R.styleable.ArcProgress_arc_unfinished_color,default_unfinished_color);
  textColor=attributes.getColor(R.styleable.ArcProgress_arc_text_color,default_text_color);
  textSize=attributes.getDimension(R.styleable.ArcProgress_arc_text_size,default_text_size);
  arcAngle=attributes.getFloat(R.styleable.ArcProgress_arc_angle,default_arc_angle);
  setMax(attributes.getInt(R.styleable.ArcProgress_arc_max,default_max));
  setProgress(attributes.getInt(R.styleable.ArcProgress_arc_progress,0));
  strokeWidth=attributes.getDimension(R.styleable.ArcProgress_arc_stroke_width,default_stroke_width);
  suffixTextSize=attributes.getDimension(R.styleable.ArcProgress_arc_suffix_text_size,default_suffix_text_size);
  suffixText=TextUtils.isEmpty(attributes.getString(R.styleable.ArcProgress_arc_suffix_text)) ? default_suffix_text : attributes.getString(R.styleable.ArcProgress_arc_suffix_text);
  suffixTextPadding=attributes.getDimension(R.styleable.ArcProgress_arc_suffix_text_padding,default_suffix_padding);
  bottomTextSize=attributes.getDimension(R.styleable.ArcProgress_arc_bottom_text_size,default_bottom_text_size);
  bottomText=attributes.getString(R.styleable.ArcProgress_arc_bottom_text);
}"
54161,"@Override public void generateConvertMethod(PsiElementFactory factory,PsiClass cls,ClassEntity classEntity){
  super.generateConvertMethod(factory,cls,classEntity);
  createMethod(factory,Constant.autoValueMethodTemplate.replace(""String_Node_Str"",cls.getName()).trim(),cls);
}","@Override public void generateConvertMethod(PsiElementFactory factory,PsiClass cls,ClassEntity classEntity){
  super.generateConvertMethod(factory,cls,classEntity);
  if (PsiClassUtil.isClassAvailableForProject(cls.getProject(),""String_Node_Str"")) {
    String qualifiedName=cls.getQualifiedName();
    String autoAdapter=qualifiedName.substring(mainPackage.length(),qualifiedName.length());
    createMethod(factory,Constant.autoValueMethodTemplate.replace(""String_Node_Str"",classEntity.getClassName()).replace(""String_Node_Str"",getAutoAdpaterClass(autoAdapter)).trim(),cls);
  }
}"
54162,"public void process(ClassEntity classEntity,PsiElementFactory factory,PsiClass cls,IProcessor visitor){
  if (cls.getChildren() != null) {
    for (    PsiElement e : cls.getChildren()) {
      logPsiElement(e);
    }
  }
  onStarProcess(classEntity,factory,cls,visitor);
  for (  FieldEntity fieldEntity : classEntity.getFields()) {
    generateField(factory,fieldEntity,cls,classEntity);
  }
  for (  ClassEntity innerClass : classEntity.getInnerClasss()) {
    generateClass(factory,innerClass,cls,visitor);
  }
  generateGetterAndSetter(factory,cls,classEntity);
  generateConvertMethod(factory,cls,classEntity);
  onEndProcess(classEntity,factory,cls,visitor);
}","public void process(ClassEntity classEntity,PsiElementFactory factory,PsiClass cls,IProcessor visitor){
  mainPackage=PsiClassUtil.getPackage(cls);
  onStarProcess(classEntity,factory,cls,visitor);
  for (  FieldEntity fieldEntity : classEntity.getFields()) {
    generateField(factory,fieldEntity,cls,classEntity);
  }
  for (  ClassEntity innerClass : classEntity.getInnerClasss()) {
    generateClass(factory,innerClass,cls,visitor);
  }
  generateGetterAndSetter(factory,cls,classEntity);
  generateConvertMethod(factory,cls,classEntity);
  onEndProcess(classEntity,factory,cls,visitor);
}"
54163,"protected void generateClass(PsiElementFactory factory,ClassEntity classEntity,PsiClass parentClass,IProcessor visitor){
  onStartGenerateClass(factory,classEntity,parentClass,visitor);
  PsiClass generateClass=null;
  if (classEntity.isGenerate()) {
    if (Config.getInstant().isSplitGenerate()) {
      try {
        generateClass=PsiClassUtil.getPsiClass(parentClass.getContainingFile(),parentClass.getProject(),classEntity.getQualifiedName());
      }
 catch (      Throwable throwable) {
        throwable.printStackTrace();
      }
    }
 else {
      String classContent=""String_Node_Str"" + classEntity.getClassName() + ""String_Node_Str"";
      generateClass=factory.createClassFromText(classContent,null).getInnerClasses()[0];
    }
    if (generateClass != null) {
      for (      FieldEntity fieldEntity : classEntity.getFields()) {
        generateField(factory,fieldEntity,generateClass,classEntity);
      }
      for (      ClassEntity innerClass : classEntity.getInnerClasss()) {
        generateClass(factory,innerClass,generateClass,visitor);
      }
      generateGetterAndSetter(factory,generateClass,classEntity);
      generateConvertMethod(factory,generateClass,classEntity);
      if (!Config.getInstant().isSplitGenerate()) {
        parentClass.add(generateClass);
      }
    }
  }
  onEndGenerateClass(factory,classEntity,parentClass,generateClass,visitor);
  if (Config.getInstant().isSplitGenerate()) {
    formatJavCode(generateClass);
  }
}","protected void generateClass(PsiElementFactory factory,ClassEntity classEntity,PsiClass parentClass,IProcessor visitor){
  onStartGenerateClass(factory,classEntity,parentClass,visitor);
  PsiClass generateClass=null;
  if (classEntity.isGenerate()) {
    if (Config.getInstant().isSplitGenerate()) {
      try {
        generateClass=PsiClassUtil.getPsiClass(parentClass.getContainingFile(),parentClass.getProject(),classEntity.getQualifiedName());
      }
 catch (      Throwable throwable) {
        throwable.printStackTrace();
      }
    }
 else {
      String classContent=""String_Node_Str"" + classEntity.getClassName() + ""String_Node_Str"";
      generateClass=factory.createClassFromText(classContent,null).getInnerClasses()[0];
    }
    if (generateClass != null) {
      for (      ClassEntity innerClass : classEntity.getInnerClasss()) {
        generateClass(factory,innerClass,generateClass,visitor);
      }
      if (!Config.getInstant().isSplitGenerate()) {
        generateClass=(PsiClass)parentClass.add(generateClass);
      }
      for (      FieldEntity fieldEntity : classEntity.getFields()) {
        generateField(factory,fieldEntity,generateClass,classEntity);
      }
      generateGetterAndSetter(factory,generateClass,classEntity);
      generateConvertMethod(factory,generateClass,classEntity);
    }
  }
  onEndGenerateClass(factory,classEntity,parentClass,generateClass,visitor);
  if (Config.getInstant().isSplitGenerate()) {
    formatJavCode(generateClass);
  }
}"
54164,"private void recursionInnerClass(ClassEntity classEntity){
  PsiClass[] innerClassArray=classEntity.getPsiClass().getAllInnerClasses();
  for (  PsiClass psiClass : innerClassArray) {
    ClassEntity item=new ClassEntity();
    item.setLock(true);
    declareClass.put(psiClass.getQualifiedName(),item);
    CheckUtil.getInstant().addDeclareClassName(psiClass.getQualifiedName());
    item.setClassName(psiClass.getName());
    item.addAllFields(collectDeclareFields(psiClass));
    item.setPsiClass(psiClass);
    item.setPackName(getPackName(psiClass));
    recursionInnerClass(item);
  }
}","private void recursionInnerClass(ClassEntity classEntity){
  PsiClass[] innerClassArray=classEntity.getPsiClass().getAllInnerClasses();
  for (  PsiClass psiClass : innerClassArray) {
    ClassEntity item=new ClassEntity();
    item.setLock(true);
    if (declareClass.containsKey(psiClass.getQualifiedName())) {
      return;
    }
    declareClass.put(psiClass.getQualifiedName(),item);
    CheckUtil.getInstant().addDeclareClassName(psiClass.getQualifiedName());
    item.setClassName(psiClass.getName());
    item.addAllFields(collectDeclareFields(psiClass));
    item.setPsiClass(psiClass);
    item.setPackName(getPackName(psiClass));
    recursionInnerClass(item);
  }
}"
54165,"@Override protected void run(){
  if (targetClass == null) {
    return;
  }
  generateClassList.clear();
  new ClassProcess(factory,cls).generate(targetClass,new IProcessor(){
    @Override public void onStarProcess(    ClassEntity classEntity,    PsiElementFactory factory,    PsiClass cls){
      generateClassList.add(cls.getQualifiedName());
    }
    @Override public void onEndProcess(    ClassEntity classEntity,    PsiElementFactory factory,    PsiClass cls){
    }
    @Override public void onStartGenerateClass(    PsiElementFactory factory,    ClassEntity classEntity,    PsiClass parentClass){
    }
    @Override public void onEndGenerateClass(    PsiElementFactory factory,    ClassEntity classEntity,    PsiClass parentClass,    PsiClass generateClass){
      generateClassList.add(generateClass.getQualifiedName());
    }
  }
);
}","@Override protected void run(){
  if (targetClass == null) {
    return;
  }
  generateClassList.clear();
  new ClassProcessor(factory,cls).generate(targetClass,new IProcessor(){
    @Override public void onStarProcess(    ClassEntity classEntity,    PsiElementFactory factory,    PsiClass cls){
      generateClassList.add(cls.getQualifiedName());
    }
    @Override public void onEndProcess(    ClassEntity classEntity,    PsiElementFactory factory,    PsiClass cls){
    }
    @Override public void onStartGenerateClass(    PsiElementFactory factory,    ClassEntity classEntity,    PsiClass parentClass){
    }
    @Override public void onEndGenerateClass(    PsiElementFactory factory,    ClassEntity classEntity,    PsiClass parentClass,    PsiClass generateClass){
      generateClassList.add(generateClass.getQualifiedName());
    }
  }
);
}"
54166,"public String handleArg(String arg){
  Pattern pattern=Pattern.compile(""String_Node_Str"");
  Matcher matcher=pattern.matcher(arg);
  if (matcher.find()) {
    return ""String_Node_Str"" + arg;
  }
 else {
    if (CheckUtil.getInstant().checkKeyWord(arg)) {
      return arg + ""String_Node_Str"";
    }
    return arg;
  }
}","public String handleArg(String arg){
  arg=arg.replaceAll(""String_Node_Str"",""String_Node_Str"");
  Matcher matcher=sPattern.matcher(arg);
  if (matcher.find()) {
    return Constant.DEFAULT_PREFIX + arg;
  }
 else {
    if (CheckUtil.getInstant().checkKeyWord(arg)) {
      return arg + ""String_Node_Str"";
    }
    return arg;
  }
}"
54167,"public void setClassName(String className){
  this.className=className;
}","public void setClassName(String className){
  this.className=CheckUtil.getInstant().handleArg(className);
}"
54168,"@Override public void generateField(PsiElementFactory factory,FieldEntity fieldEntity,PsiClass cls,ClassEntity classEntity){
  if (fieldEntity.isGenerate()) {
    StringBuilder fieldSb=new StringBuilder();
    String filedName=fieldEntity.getGenerateFieldName();
    if (!TextUtils.isEmpty(classEntity.getExtra())) {
      fieldSb.append(classEntity.getExtra()).append(""String_Node_Str"");
      classEntity.setExtra(null);
    }
    if (fieldEntity.getTargetClass() != null) {
      fieldEntity.getTargetClass().setGenerate(true);
    }
    fieldSb.append(String.format(""String_Node_Str"",fieldEntity.getFullNameType(),filedName));
    cls.add(factory.createMethodFromText(fieldSb.toString(),cls));
  }
}","@Override public void generateField(PsiElementFactory factory,FieldEntity fieldEntity,PsiClass cls,ClassEntity classEntity){
  if (fieldEntity.isGenerate()) {
    Try.run(new Try.TryListener(){
      @Override public void run(){
        cls.add(factory.createMethodFromText(generateFieldText(classEntity,fieldEntity,null),cls));
      }
      @Override public void runAgain(){
        fieldEntity.setFieldName(FieldHelper.generateLuckyFieldName(fieldEntity.getFieldName()));
        cls.add(factory.createMethodFromText(generateFieldText(classEntity,fieldEntity,Constant.FIXME),cls));
      }
      @Override public void error(){
        cls.addBefore(factory.createCommentFromText(""String_Node_Str"" + fieldEntity.getFieldName(),cls),cls.getChildren()[0]);
      }
    }
);
  }
}"
54169,"private void injectAutoAnnotation(PsiElementFactory factory,PsiClass cls){
  PsiModifierList modifierList=cls.getModifierList();
  PsiElement firstChild=modifierList.getFirstChild();
  Pattern pattern=Pattern.compile(""String_Node_Str"");
  if (firstChild != null && !pattern.matcher(firstChild.getText()).find()) {
    PsiAnnotation annotationFromText=factory.createAnnotationFromText(""String_Node_Str"",cls);
    modifierList.addBefore(annotationFromText,firstChild);
  }
  if (!modifierList.hasModifierProperty(PsiModifier.ABSTRACT)) {
    modifierList.setModifierProperty(PsiModifier.ABSTRACT,true);
  }
}","private void injectAutoAnnotation(PsiElementFactory factory,PsiClass cls){
  PsiModifierList modifierList=cls.getModifierList();
  if (modifierList != null) {
    PsiElement firstChild=modifierList.getFirstChild();
    Pattern pattern=Pattern.compile(""String_Node_Str"");
    if (firstChild != null && !pattern.matcher(firstChild.getText()).find()) {
      PsiAnnotation annotationFromText=factory.createAnnotationFromText(""String_Node_Str"",cls);
      modifierList.addBefore(annotationFromText,firstChild);
    }
    if (!modifierList.hasModifierProperty(PsiModifier.ABSTRACT)) {
      modifierList.setModifierProperty(PsiModifier.ABSTRACT,true);
    }
  }
}"
54170,"public void generateClass(PsiElementFactory mFactory,PsiClass parentClass){
  if (isGenerate()) {
    String classContent=""String_Node_Str"" + className + ""String_Node_Str"";
    PsiClass subClass=mFactory.createClassFromText(classContent,null).getInnerClasses()[0];
    for (    FieldEntity fieldEntity : getFields()) {
      if (fieldEntity instanceof InnerClassEntity) {
        ((InnerClassEntity)fieldEntity).generateSupperFiled(mFactory,subClass);
        ((InnerClassEntity)fieldEntity).setFieldTypeSuffix(getClassFieldType());
        ((InnerClassEntity)fieldEntity).generateClass(mFactory,subClass);
        fieldEntity.generateFiled(mFactory,subClass,this);
      }
 else {
        fieldEntity.generateFiled(mFactory,subClass,this);
      }
    }
    configGetterAndSetter(mFactory,subClass);
    createExtraMethod(mFactory,subClass);
    parentClass.add(subClass);
    if (Config.getInstant().getAnnotationStr().equals(Strings.jackAnnotation)) {
    }
 else     if (Config.getInstant().getAnnotationStr().equals(Strings.loganSquareAnnotation)) {
      subClass=parentClass.findInnerClassByName(className,false);
      if (subClass != null) {
        PsiModifierList modifierList=subClass.getModifierList();
        PsiAnnotation annotationFromText=mFactory.createAnnotationFromText(""String_Node_Str"",subClass);
        PsiElement firstChild=modifierList.getFirstChild();
        modifierList.addBefore(annotationFromText,firstChild);
      }
    }
 else     if (Config.getInstant().getAnnotationStr().equals(Strings.autoValueAnnotation)) {
      subClass=parentClass.findInnerClassByName(className,false);
      if (subClass != null) {
        hanleAutoValueAnnotation(mFactory,subClass);
      }
    }
  }
}","public void generateClass(PsiElementFactory mFactory,PsiClass parentClass){
  if (isGenerate()) {
    String classContent=""String_Node_Str"" + className + ""String_Node_Str"";
    PsiClass subClass=mFactory.createClassFromText(classContent,null).getInnerClasses()[0];
    for (    FieldEntity fieldEntity : getFields()) {
      if (fieldEntity instanceof InnerClassEntity) {
        ((InnerClassEntity)fieldEntity).generateSupperFiled(mFactory,subClass);
        ((InnerClassEntity)fieldEntity).setFieldTypeSuffix(getClassFieldType());
        ((InnerClassEntity)fieldEntity).generateClass(mFactory,subClass);
      }
 else {
        fieldEntity.generateFiled(mFactory,subClass,this);
      }
    }
    configGetterAndSetter(mFactory,subClass);
    createExtraMethod(mFactory,subClass);
    parentClass.add(subClass);
    if (Config.getInstant().getAnnotationStr().equals(Strings.jackAnnotation)) {
    }
 else     if (Config.getInstant().getAnnotationStr().equals(Strings.loganSquareAnnotation)) {
      subClass=parentClass.findInnerClassByName(className,false);
      if (subClass != null) {
        PsiModifierList modifierList=subClass.getModifierList();
        PsiAnnotation annotationFromText=mFactory.createAnnotationFromText(""String_Node_Str"",subClass);
        PsiElement firstChild=modifierList.getFirstChild();
        modifierList.addBefore(annotationFromText,firstChild);
      }
    }
 else     if (Config.getInstant().getAnnotationStr().equals(Strings.autoValueAnnotation)) {
      subClass=parentClass.findInnerClassByName(className,false);
      if (subClass != null) {
        hanleAutoValueAnnotation(mFactory,subClass);
      }
    }
  }
}"
54171,"public void generateFiled(PsiElementFactory mFactory,PsiClass mClass,InnerClassEntity classEntity){
  if (generate) {
    StringBuilder filedSb=new StringBuilder();
    String filedName=getGenerateFieldName();
    if (!TextUtils.isEmpty(classEntity.getExtra())) {
      filedSb.append(classEntity.getExtra()).append(""String_Node_Str"");
      classEntity.setExtra(null);
    }
    if (!filedName.equals(getKey()) || Config.getInstant().isUseSerializedName()) {
      filedSb.append(Config.getInstant().geFullNameAnnotation().replaceAll(""String_Node_Str"",getKey()));
    }
    if (Config.getInstant().isFieldPrivateMode()) {
      filedSb.append(""String_Node_Str"").append(getGenerType()).append(""String_Node_Str"").append(filedName).append(""String_Node_Str"");
    }
 else {
      filedSb.append(""String_Node_Str"").append(getGenerType()).append(""String_Node_Str"").append(filedName).append(""String_Node_Str"");
    }
    mClass.add(mFactory.createFieldFromText(filedSb.toString(),mClass));
  }
}","public void generateFiled(PsiElementFactory mFactory,PsiClass mClass,InnerClassEntity classEntity){
  if (generate) {
    StringBuilder filedSb=new StringBuilder();
    String filedName=getGenerateFieldName();
    if (!TextUtils.isEmpty(classEntity.getExtra())) {
      filedSb.append(classEntity.getExtra()).append(""String_Node_Str"");
      classEntity.setExtra(null);
    }
    if (!filedName.equals(getKey()) || Config.getInstant().isUseSerializedName()) {
      filedSb.append(Config.getInstant().geFullNameAnnotation().replaceAll(""String_Node_Str"",getKey()));
    }
    if (Config.getInstant().isFieldPrivateMode()) {
      filedSb.append(""String_Node_Str"").append(getFullNameType()).append(""String_Node_Str"").append(filedName).append(""String_Node_Str"");
    }
 else {
      filedSb.append(""String_Node_Str"").append(getFullNameType()).append(""String_Node_Str"").append(filedName).append(""String_Node_Str"");
    }
    mClass.add(mFactory.createFieldFromText(filedSb.toString(),mClass));
  }
}"
54172,"@Override public View getViewForTab(int position,View convertView,ViewGroup container){
  if (convertView == null) {
    convertView=(TextView)inflater.inflate(R.layout.tab_main,container,false);
  }
  TextView textView=(TextView)convertView;
  textView.setText(tabNames[position]);
  textView.setCompoundDrawablesWithIntrinsicBounds(0,tabIcons[position],0,0);
  return textView;
}","@Override public View getViewForTab(int position,View convertView,ViewGroup container){
  if (convertView == null) {
    convertView=inflater.inflate(R.layout.tab_main,container,false);
  }
  TextView textView=(TextView)convertView;
  textView.setText(tabNames[position]);
  textView.setCompoundDrawablesWithIntrinsicBounds(0,tabIcons[position],0,0);
  return textView;
}"
54173,"private View getItemOutView(int position){
  int count=getChildCount();
  Log.d(""String_Node_Str"",""String_Node_Str"" + position + ""String_Node_Str""+ count);
  if (centerView != null && position >= (count / 2)) {
    position++;
    Log.d(""String_Node_Str"",""String_Node_Str"" + position + ""String_Node_Str""+ count+ ""String_Node_Str""+ (count / 2));
  }
  return getChildAt(position);
}","private View getItemOutView(int position){
  if (centerView != null && position >= (getChildCount() - 1) / 2) {
    position++;
  }
  return getChildAt(position);
}"
54174,"private void measureTabs(){
  int count=getRealChildCount();
switch (splitMethod) {
case SPLITMETHOD_EQUALS:
    for (int i=0; i < count; i++) {
      View view=getItemOutView(i);
      LayoutParams layoutParams=(LayoutParams)view.getLayoutParams();
      layoutParams.width=0;
      layoutParams.weight=1;
      view.setLayoutParams(layoutParams);
    }
  break;
case SPLITMETHOD_WRAP:
for (int i=0; i < count; i++) {
  View view=getItemOutView(i);
  LayoutParams layoutParams=(LayoutParams)view.getLayoutParams();
  layoutParams.width=LayoutParams.WRAP_CONTENT;
  layoutParams.weight=0;
  view.setLayoutParams(layoutParams);
}
break;
case SPLITMETHOD_WEIGHT:
for (int i=0; i < count; i++) {
View view=getItemOutView(i);
LayoutParams layoutParams=(LayoutParams)view.getLayoutParams();
layoutParams.width=LayoutParams.WRAP_CONTENT;
layoutParams.weight=1;
view.setLayoutParams(layoutParams);
}
break;
}
}","private void measureTabs(){
  int count=getTabCountInLayout();
switch (splitMethod) {
case SPLITMETHOD_EQUALS:
    for (int i=0; i < count; i++) {
      View view=getItemOutView(i);
      LayoutParams layoutParams=(LayoutParams)view.getLayoutParams();
      layoutParams.width=0;
      layoutParams.weight=1;
      view.setLayoutParams(layoutParams);
    }
  break;
case SPLITMETHOD_WRAP:
for (int i=0; i < count; i++) {
  View view=getItemOutView(i);
  LayoutParams layoutParams=(LayoutParams)view.getLayoutParams();
  layoutParams.width=LayoutParams.WRAP_CONTENT;
  layoutParams.weight=0;
  view.setLayoutParams(layoutParams);
}
break;
case SPLITMETHOD_WEIGHT:
for (int i=0; i < count; i++) {
View view=getItemOutView(i);
LayoutParams layoutParams=(LayoutParams)view.getLayoutParams();
layoutParams.width=LayoutParams.WRAP_CONTENT;
layoutParams.weight=1;
view.setLayoutParams(layoutParams);
}
break;
}
}"
54175,"@Override public void onChange(){
  if (!inRun.isFinished()) {
    inRun.stop();
  }
  int count=getRealChildCount();
  int newCount=mAdapter.getCount();
  views.clear();
  for (int i=0; i < count && i < newCount; i++) {
    views.add((ViewGroup)getItemOutView(i));
  }
  removeAllViews();
  int size=views.size();
  for (int i=0; i < newCount; i++) {
    LinearLayout result=new LinearLayout(getContext());
    View view;
    if (i < size) {
      View temp=views.get(i).getChildAt(0);
      views.get(i).removeView(temp);
      view=mAdapter.getView(i,temp,result);
    }
 else {
      view=mAdapter.getView(i,null,result);
    }
    if (onTransitionListener != null) {
      onTransitionListener.onTransition(view,i,i == mSelectedTabIndex ? 1 : 0);
    }
    result.addView(view);
    result.setOnClickListener(onClickListener);
    result.setTag(i);
    addView(result,new LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.MATCH_PARENT));
  }
  if (centerView != null) {
    setCenterView(centerView,centerViewLayoutParams);
  }
  mPreSelectedTabIndex=-1;
  setCurrentItem(mSelectedTabIndex,false);
  measureTabs();
}","@Override public void onChange(){
  if (!inRun.isFinished()) {
    inRun.stop();
  }
  int count=getTabCountInLayout();
  int newCount=mAdapter.getCount();
  views.clear();
  for (int i=0; i < count && i < newCount; i++) {
    views.add((ViewGroup)getItemOutView(i));
  }
  removeAllViews();
  int size=views.size();
  for (int i=0; i < newCount; i++) {
    LinearLayout result=new LinearLayout(getContext());
    View view;
    if (i < size) {
      View temp=views.get(i).getChildAt(0);
      views.get(i).removeView(temp);
      view=mAdapter.getView(i,temp,result);
    }
 else {
      view=mAdapter.getView(i,null,result);
    }
    if (onTransitionListener != null) {
      onTransitionListener.onTransition(view,i,i == mSelectedTabIndex ? 1 : 0);
    }
    result.addView(view);
    result.setOnClickListener(onClickListener);
    result.setTag(i);
    addView(result,new LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.MATCH_PARENT));
  }
  if (centerView != null) {
    setCenterView(centerView,centerViewLayoutParams);
  }
  mPreSelectedTabIndex=-1;
  setCurrentItem(mSelectedTabIndex,false);
  measureTabs();
}"
54176,"@Override public void setCurrentItem(int item,boolean anim){
  int count=getCount();
  if (count == 0) {
    return;
  }
  if (item < 0) {
    item=0;
  }
 else   if (item > count - 1) {
    item=count - 1;
  }
  if (mSelectedTabIndex != item) {
    mPreSelectedTabIndex=mSelectedTabIndex;
    mSelectedTabIndex=item;
    if (!inRun.isFinished()) {
      inRun.stop();
    }
    if (state == ViewPager.SCROLL_STATE_IDLE) {
      updateTabSelectState(item);
      if (anim && getWidth() != 0 && mPreSelectedTabIndex >= 0 && mPreSelectedTabIndex < getRealChildCount()) {
        int sx=getItemOutView(mPreSelectedTabIndex).getLeft();
        int ex=getItemOutView(item).getLeft();
        final float pageDelta=(float)Math.abs(ex - sx) / (getItemOutView(item).getWidth());
        int duration=(int)((pageDelta + 1) * 100);
        duration=Math.min(duration,600);
        inRun.startScroll(sx,ex,duration);
      }
 else {
        notifyPageScrolled(item,0,0);
      }
    }
 else {
      if (onTransitionListener == null) {
        updateTabSelectState(item);
      }
    }
  }
}","@Override public void setCurrentItem(int item,boolean anim){
  int count=getCount();
  if (count == 0) {
    return;
  }
  if (item < 0) {
    item=0;
  }
 else   if (item > count - 1) {
    item=count - 1;
  }
  if (mSelectedTabIndex != item) {
    mPreSelectedTabIndex=mSelectedTabIndex;
    mSelectedTabIndex=item;
    if (!inRun.isFinished()) {
      inRun.stop();
    }
    if (state == ViewPager.SCROLL_STATE_IDLE) {
      updateTabSelectState(item);
      if (anim && getWidth() != 0 && mPreSelectedTabIndex >= 0 && mPreSelectedTabIndex < getTabCountInLayout()) {
        int sx=getItemOutView(mPreSelectedTabIndex).getLeft();
        int ex=getItemOutView(item).getLeft();
        final float pageDelta=(float)Math.abs(ex - sx) / (getItemOutView(item).getWidth());
        int duration=(int)((pageDelta + 1) * 100);
        duration=Math.min(duration,600);
        inRun.startScroll(sx,ex,duration);
      }
 else {
        notifyPageScrolled(item,0,0);
      }
    }
 else {
      if (onTransitionListener == null) {
        updateTabSelectState(item);
      }
    }
  }
}"
54177,"public static MonitorCfg load(String confPath){
  String cfgPath=confPath + ""String_Node_Str"";
  String log4jPath=confPath + ""String_Node_Str"";
  Properties conf=new Properties();
  File file=new File(cfgPath);
  InputStream is=null;
  try {
    is=new FileInputStream(file);
  }
 catch (  FileNotFoundException e) {
    throw new CfgException(""String_Node_Str"" + cfgPath);
  }
  try {
    conf.load(is);
  }
 catch (  IOException e) {
    throw new CfgException(""String_Node_Str"" + cfgPath + ""String_Node_Str"",e);
  }
  MonitorCfg cfg=new MonitorCfg();
  try {
    String registryAddress=conf.getProperty(""String_Node_Str"");
    Assert.hasText(registryAddress,""String_Node_Str"");
    cfg.setRegistryAddress(registryAddress);
    String clusterName=conf.getProperty(""String_Node_Str"");
    Assert.hasText(clusterName,""String_Node_Str"");
    cfg.setClusterName(clusterName);
    String bindIp=conf.getProperty(""String_Node_Str"");
    if (StringUtils.isNotEmpty(bindIp)) {
      cfg.setBindIp(bindIp);
    }
    String identity=conf.getProperty(""String_Node_Str"");
    if (StringUtils.isNotEmpty(identity)) {
      cfg.setBindIp(identity);
    }
    Map<String,String> configs=new HashMap<String,String>();
    for (    Map.Entry<Object,Object> entry : conf.entrySet()) {
      String key=entry.getKey().toString();
      if (key.startsWith(""String_Node_Str"")) {
        String value=entry.getValue() == null ? null : entry.getValue().toString();
        configs.put(key.replace(""String_Node_Str"",""String_Node_Str""),value);
      }
    }
    cfg.setConfigs(configs);
  }
 catch (  Exception e) {
    throw new CfgException(e);
  }
  if (FileUtils.exist(log4jPath)) {
    PropertyConfigurator.configure(log4jPath);
  }
  return cfg;
}","public static MonitorCfg load(String confPath){
  String cfgPath=confPath + ""String_Node_Str"";
  String log4jPath=confPath + ""String_Node_Str"";
  Properties conf=new Properties();
  File file=new File(cfgPath);
  InputStream is=null;
  try {
    is=new FileInputStream(file);
  }
 catch (  FileNotFoundException e) {
    throw new CfgException(""String_Node_Str"" + cfgPath);
  }
  try {
    conf.load(is);
  }
 catch (  IOException e) {
    throw new CfgException(""String_Node_Str"" + cfgPath + ""String_Node_Str"",e);
  }
  MonitorCfg cfg=new MonitorCfg();
  try {
    String registryAddress=conf.getProperty(""String_Node_Str"");
    Assert.hasText(registryAddress,""String_Node_Str"");
    cfg.setRegistryAddress(registryAddress);
    String clusterName=conf.getProperty(""String_Node_Str"");
    Assert.hasText(clusterName,""String_Node_Str"");
    cfg.setClusterName(clusterName);
    String bindIp=conf.getProperty(""String_Node_Str"");
    if (StringUtils.isNotEmpty(bindIp)) {
      cfg.setBindIp(bindIp);
    }
    String identity=conf.getProperty(""String_Node_Str"");
    if (StringUtils.isNotEmpty(identity)) {
      cfg.setIdentity(identity);
    }
    Map<String,String> configs=new HashMap<String,String>();
    for (    Map.Entry<Object,Object> entry : conf.entrySet()) {
      String key=entry.getKey().toString();
      if (key.startsWith(""String_Node_Str"")) {
        String value=entry.getValue() == null ? null : entry.getValue().toString();
        configs.put(key.replace(""String_Node_Str"",""String_Node_Str""),value);
      }
    }
    cfg.setConfigs(configs);
  }
 catch (  Exception e) {
    throw new CfgException(e);
  }
  if (FileUtils.exist(log4jPath)) {
    PropertyConfigurator.configure(log4jPath);
  }
  return cfg;
}"
54178,"public static void addRepeatJobForInterval(ExecutableJobQueue executableJobQueue,RepeatJobQueue repeatJobQueue,int scheduleIntervalMinute,final JobPo finalJobPo,Date lastGenerateTime){
  JobPo jobPo=JobUtils.copy(finalJobPo);
  long firstTriggerTime=Long.valueOf(jobPo.getInternalExtParam(Constants.FIRST_FIRE_TIME));
  Long repeatInterval=jobPo.getRepeatInterval();
  Integer repeatCount=jobPo.getRepeatCount();
  long endTime=DateUtils.addMinute(lastGenerateTime,scheduleIntervalMinute).getTime();
  if (endTime <= firstTriggerTime) {
    return;
  }
  int repeatedCount=Long.valueOf((lastGenerateTime.getTime() - firstTriggerTime) / jobPo.getRepeatInterval()).intValue();
  boolean stop=false;
  while (!stop) {
    Long nextTriggerTime=firstTriggerTime + repeatedCount * repeatInterval;
    if (nextTriggerTime <= endTime && (repeatCount == -1 || repeatedCount <= repeatCount)) {
      jobPo.setTriggerTime(nextTriggerTime);
      jobPo.setJobId(JobUtils.generateJobId());
      jobPo.setTaskId(finalJobPo.getTaskId() + ""String_Node_Str"" + DateUtils.format(new Date(nextTriggerTime),""String_Node_Str""));
      jobPo.setRepeatedCount(repeatedCount);
      jobPo.setInternalExtParam(Constants.ONCE,Boolean.TRUE.toString());
      try {
        jobPo.setInternalExtParam(Constants.EXE_SEQ_ID,JobUtils.generateExeSeqId(jobPo));
        executableJobQueue.add(jobPo);
      }
 catch (      DupEntryException e) {
        LOGGER.warn(""String_Node_Str"",jobPo.getTaskId(),jobPo.getTaskTrackerNodeGroup());
      }
      repeatedCount++;
    }
 else {
      stop=true;
    }
  }
  repeatJobQueue.updateLastGenerateTriggerTime(finalJobPo.getJobId(),endTime);
  if (LOGGER.isDebugEnabled()) {
    LOGGER.debug(""String_Node_Str"",jobPo,DateUtils.formatYMD_HMS(new Date(endTime)));
  }
}","public static void addRepeatJobForInterval(ExecutableJobQueue executableJobQueue,RepeatJobQueue repeatJobQueue,int scheduleIntervalMinute,final JobPo finalJobPo,Date lastGenerateTime){
  JobPo jobPo=JobUtils.copy(finalJobPo);
  long firstTriggerTime=Long.valueOf(jobPo.getInternalExtParam(Constants.FIRST_FIRE_TIME));
  Long repeatInterval=jobPo.getRepeatInterval();
  Integer repeatCount=jobPo.getRepeatCount();
  long endTime=DateUtils.addMinute(lastGenerateTime,scheduleIntervalMinute).getTime();
  if (endTime <= firstTriggerTime) {
    return;
  }
  int repeatedCount=Long.valueOf((lastGenerateTime.getTime() - firstTriggerTime) / jobPo.getRepeatInterval()).intValue();
  if (repeatedCount < 0) {
    repeatedCount=0;
  }
  boolean stop=false;
  while (!stop) {
    Long nextTriggerTime=firstTriggerTime + repeatedCount * repeatInterval;
    if (nextTriggerTime <= endTime && (repeatCount == -1 || repeatedCount <= repeatCount)) {
      jobPo.setTriggerTime(nextTriggerTime);
      jobPo.setJobId(JobUtils.generateJobId());
      jobPo.setTaskId(finalJobPo.getTaskId() + ""String_Node_Str"" + DateUtils.format(new Date(nextTriggerTime),""String_Node_Str""));
      jobPo.setRepeatedCount(repeatedCount);
      jobPo.setInternalExtParam(Constants.ONCE,Boolean.TRUE.toString());
      try {
        jobPo.setInternalExtParam(Constants.EXE_SEQ_ID,JobUtils.generateExeSeqId(jobPo));
        executableJobQueue.add(jobPo);
      }
 catch (      DupEntryException e) {
        LOGGER.warn(""String_Node_Str"",jobPo.getTaskId(),jobPo.getTaskTrackerNodeGroup());
      }
      repeatedCount++;
    }
 else {
      stop=true;
    }
  }
  repeatJobQueue.updateLastGenerateTriggerTime(finalJobPo.getJobId(),endTime);
  if (LOGGER.isDebugEnabled()) {
    LOGGER.debug(""String_Node_Str"",jobPo,DateUtils.formatYMD_HMS(new Date(endTime)));
  }
}"
54179,"public static MonitorCfg load(String confPath){
  String cfgPath=confPath + ""String_Node_Str"";
  String log4jPath=confPath + ""String_Node_Str"";
  Properties conf=new Properties();
  File file=new File(cfgPath);
  InputStream is=null;
  try {
    is=new FileInputStream(file);
  }
 catch (  FileNotFoundException e) {
    throw new CfgException(""String_Node_Str"" + cfgPath);
  }
  try {
    conf.load(is);
  }
 catch (  IOException e) {
    throw new CfgException(""String_Node_Str"" + cfgPath + ""String_Node_Str"",e);
  }
  MonitorCfg cfg=new MonitorCfg();
  try {
    String registryAddress=conf.getProperty(""String_Node_Str"");
    Assert.hasText(registryAddress,""String_Node_Str"");
    cfg.setRegistryAddress(registryAddress);
    String clusterName=conf.getProperty(""String_Node_Str"");
    Assert.hasText(clusterName,""String_Node_Str"");
    cfg.setClusterName(clusterName);
    String bindIp=conf.getProperty(""String_Node_Str"");
    if (StringUtils.isNotEmpty(bindIp)) {
      cfg.setBindIp(bindIp);
    }
    String identity=conf.getProperty(""String_Node_Str"");
    if (StringUtils.isNotEmpty(identity)) {
      cfg.setBindIp(identity);
    }
    Map<String,String> configs=new HashMap<String,String>();
    for (    Map.Entry<Object,Object> entry : conf.entrySet()) {
      String key=entry.getKey().toString();
      if (key.startsWith(""String_Node_Str"")) {
        String value=entry.getValue() == null ? null : entry.getValue().toString();
        configs.put(key.replace(""String_Node_Str"",""String_Node_Str""),value);
      }
    }
    cfg.setConfigs(configs);
  }
 catch (  Exception e) {
    throw new CfgException(e);
  }
  if (FileUtils.exist(log4jPath)) {
    PropertyConfigurator.configure(log4jPath);
  }
  return cfg;
}","public static MonitorCfg load(String confPath){
  String cfgPath=confPath + ""String_Node_Str"";
  String log4jPath=confPath + ""String_Node_Str"";
  Properties conf=new Properties();
  File file=new File(cfgPath);
  InputStream is=null;
  try {
    is=new FileInputStream(file);
  }
 catch (  FileNotFoundException e) {
    throw new CfgException(""String_Node_Str"" + cfgPath);
  }
  try {
    conf.load(is);
  }
 catch (  IOException e) {
    throw new CfgException(""String_Node_Str"" + cfgPath + ""String_Node_Str"",e);
  }
  MonitorCfg cfg=new MonitorCfg();
  try {
    String registryAddress=conf.getProperty(""String_Node_Str"");
    Assert.hasText(registryAddress,""String_Node_Str"");
    cfg.setRegistryAddress(registryAddress);
    String clusterName=conf.getProperty(""String_Node_Str"");
    Assert.hasText(clusterName,""String_Node_Str"");
    cfg.setClusterName(clusterName);
    String bindIp=conf.getProperty(""String_Node_Str"");
    if (StringUtils.isNotEmpty(bindIp)) {
      cfg.setBindIp(bindIp);
    }
    String identity=conf.getProperty(""String_Node_Str"");
    if (StringUtils.isNotEmpty(identity)) {
      cfg.setIdentity(identity);
    }
    Map<String,String> configs=new HashMap<String,String>();
    for (    Map.Entry<Object,Object> entry : conf.entrySet()) {
      String key=entry.getKey().toString();
      if (key.startsWith(""String_Node_Str"")) {
        String value=entry.getValue() == null ? null : entry.getValue().toString();
        configs.put(key.replace(""String_Node_Str"",""String_Node_Str""),value);
      }
    }
    cfg.setConfigs(configs);
  }
 catch (  Exception e) {
    throw new CfgException(e);
  }
  if (FileUtils.exist(log4jPath)) {
    PropertyConfigurator.configure(log4jPath);
  }
  return cfg;
}"
54180,"private void doNotify(Jedis jedis,String key){
  for (  Map.Entry<Node,Set<NotifyListener>> entry : new HashMap<Node,Set<NotifyListener>>(getSubscribed()).entrySet()) {
    doNotify(jedis,Collections.singletonList(key),new HashSet<NotifyListener>(entry.getValue()));
  }
}","private void doNotify(Jedis jedis,String key){
  for (  Map.Entry<Node,Set<NotifyListener>> entry : new HashMap<Node,Set<NotifyListener>>(getSubscribed()).entrySet()) {
    doNotify(jedis,Collections.singletonList(key),new HashSet<NotifyListener>(entry.getValue()),false);
  }
}"
54181,"@Override protected void doSubscribe(Node node,NotifyListener listener){
  List<NodeType> listenNodeTypes=node.getListenNodeTypes();
  if (CollectionUtils.isEmpty(listenNodeTypes)) {
    return;
  }
  for (  NodeType listenNodeType : listenNodeTypes) {
    String listenNodePath=NodeRegistryUtils.getNodeTypePath(clusterName,listenNodeType);
    Notifier notifier=notifiers.get(listenNodePath);
    if (notifier == null) {
      Notifier newNotifier=new Notifier(listenNodePath);
      notifiers.putIfAbsent(listenNodePath,newNotifier);
      notifier=notifiers.get(listenNodePath);
      if (notifier == newNotifier) {
        notifier.start();
      }
    }
    boolean success=false;
    NodeRegistryException exception=null;
    for (    Map.Entry<String,JedisPool> entry : jedisPools.entrySet()) {
      JedisPool jedisPool=entry.getValue();
      try {
        Jedis jedis=jedisPool.getResource();
        try {
          doNotify(jedis,Collections.singletonList(listenNodePath),Collections.singletonList(listener));
          success=true;
          break;
        }
  finally {
          jedis.close();
        }
      }
 catch (      Throwable t) {
        exception=new NodeRegistryException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ node+ ""String_Node_Str""+ t.getMessage(),t);
      }
    }
    if (exception != null) {
      if (success) {
        LOGGER.warn(exception.getMessage(),exception);
      }
 else {
        throw exception;
      }
    }
  }
}","@Override protected void doSubscribe(Node node,NotifyListener listener){
  List<NodeType> listenNodeTypes=node.getListenNodeTypes();
  if (CollectionUtils.isEmpty(listenNodeTypes)) {
    return;
  }
  for (  NodeType listenNodeType : listenNodeTypes) {
    String listenNodePath=NodeRegistryUtils.getNodeTypePath(clusterName,listenNodeType);
    Notifier notifier=notifiers.get(listenNodePath);
    if (notifier == null) {
      Notifier newNotifier=new Notifier(listenNodePath);
      notifiers.putIfAbsent(listenNodePath,newNotifier);
      notifier=notifiers.get(listenNodePath);
      if (notifier == newNotifier) {
        notifier.start();
      }
    }
    boolean success=false;
    NodeRegistryException exception=null;
    for (    Map.Entry<String,JedisPool> entry : jedisPools.entrySet()) {
      JedisPool jedisPool=entry.getValue();
      try {
        Jedis jedis=jedisPool.getResource();
        try {
          doNotify(jedis,Collections.singletonList(listenNodePath),Collections.singletonList(listener),true);
          success=true;
          break;
        }
  finally {
          jedis.close();
        }
      }
 catch (      Throwable t) {
        exception=new NodeRegistryException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ node+ ""String_Node_Str""+ t.getMessage(),t);
      }
    }
    if (exception != null) {
      if (success) {
        LOGGER.warn(exception.getMessage(),exception);
      }
 else {
        throw exception;
      }
    }
  }
}"
54182,"private void doNotify(Jedis jedis,String key){
  for (  Map.Entry<Node,Set<NotifyListener>> entry : new HashMap<Node,Set<NotifyListener>>(getSubscribed()).entrySet()) {
    doNotify(jedis,Collections.singletonList(key),new HashSet<NotifyListener>(entry.getValue()));
  }
}","private void doNotify(Jedis jedis,String key){
  for (  Map.Entry<Node,Set<NotifyListener>> entry : new HashMap<Node,Set<NotifyListener>>(getSubscribed()).entrySet()) {
    doNotify(jedis,Collections.singletonList(key),new HashSet<NotifyListener>(entry.getValue()),false);
  }
}"
54183,"@Override protected void doSubscribe(Node node,NotifyListener listener){
  List<NodeType> listenNodeTypes=node.getListenNodeTypes();
  if (CollectionUtils.isEmpty(listenNodeTypes)) {
    return;
  }
  for (  NodeType listenNodeType : listenNodeTypes) {
    String listenNodePath=NodeRegistryUtils.getNodeTypePath(clusterName,listenNodeType);
    Notifier notifier=notifiers.get(listenNodePath);
    if (notifier == null) {
      Notifier newNotifier=new Notifier(listenNodePath);
      notifiers.putIfAbsent(listenNodePath,newNotifier);
      notifier=notifiers.get(listenNodePath);
      if (notifier == newNotifier) {
        notifier.start();
      }
    }
    boolean success=false;
    NodeRegistryException exception=null;
    for (    Map.Entry<String,JedisPool> entry : jedisPools.entrySet()) {
      JedisPool jedisPool=entry.getValue();
      try {
        Jedis jedis=jedisPool.getResource();
        try {
          doNotify(jedis,Collections.singletonList(listenNodePath),Collections.singletonList(listener));
          success=true;
          break;
        }
  finally {
          jedis.close();
        }
      }
 catch (      Throwable t) {
        exception=new NodeRegistryException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ node+ ""String_Node_Str""+ t.getMessage(),t);
      }
    }
    if (exception != null) {
      if (success) {
        LOGGER.warn(exception.getMessage(),exception);
      }
 else {
        throw exception;
      }
    }
  }
}","@Override protected void doSubscribe(Node node,NotifyListener listener){
  List<NodeType> listenNodeTypes=node.getListenNodeTypes();
  if (CollectionUtils.isEmpty(listenNodeTypes)) {
    return;
  }
  for (  NodeType listenNodeType : listenNodeTypes) {
    String listenNodePath=NodeRegistryUtils.getNodeTypePath(clusterName,listenNodeType);
    Notifier notifier=notifiers.get(listenNodePath);
    if (notifier == null) {
      Notifier newNotifier=new Notifier(listenNodePath);
      notifiers.putIfAbsent(listenNodePath,newNotifier);
      notifier=notifiers.get(listenNodePath);
      if (notifier == newNotifier) {
        notifier.start();
      }
    }
    boolean success=false;
    NodeRegistryException exception=null;
    for (    Map.Entry<String,JedisPool> entry : jedisPools.entrySet()) {
      JedisPool jedisPool=entry.getValue();
      try {
        Jedis jedis=jedisPool.getResource();
        try {
          doNotify(jedis,Collections.singletonList(listenNodePath),Collections.singletonList(listener),true);
          success=true;
          break;
        }
  finally {
          jedis.close();
        }
      }
 catch (      Throwable t) {
        exception=new NodeRegistryException(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ node+ ""String_Node_Str""+ t.getMessage(),t);
      }
    }
    if (exception != null) {
      if (success) {
        LOGGER.warn(exception.getMessage(),exception);
      }
 else {
        throw exception;
      }
    }
  }
}"
54184,"/** 
 * 构建方法体实现
 */
private static String getMethodImplCode(Integer sequence,Class<?> sourceClass,Class<?> targetClass,boolean deepCopy,final Map<String,PropConverter<?,?>> propCvtMap) throws Exception {
  StringBuilder methodCode=new StringBuilder();
  methodCode.append(""String_Node_Str"").append(Object.class.getName()).append(""String_Node_Str"").append(Object.class.getName()).append(""String_Node_Str"");
  methodCode.append(sourceClass.getSimpleName()).append(""String_Node_Str"").append(""String_Node_Str"").append(sourceClass.getSimpleName()).append(""String_Node_Str"");
  methodCode.append(targetClass.getSimpleName()).append(""String_Node_Str"").append(""String_Node_Str"").append(targetClass.getSimpleName()).append(""String_Node_Str"");
  Field[] targetFields=ReflectionUtils.findFields(targetClass);
  for (  Field field : targetFields) {
    if (!Modifier.isStatic(field.getModifiers())) {
      String methodNameSuffix=capitalize(field.getName());
      Class<?> targetFieldClass=field.getType();
      Method setMethod=ReflectionUtils.findMethod(targetClass,""String_Node_Str"" + methodNameSuffix,targetFieldClass);
      if (setMethod == null) {
        setMethod=ReflectionUtils.findMethod(targetClass,""String_Node_Str"" + field.getName(),targetFieldClass);
        if (setMethod != null) {
          methodNameSuffix=field.getName();
        }
      }
      if (setMethod != null) {
        if (propCvtMap != null && propCvtMap.containsKey(field.getName())) {
          String converterName=field.getName() + ""String_Node_Str"";
          String converterType=PropConverter.class.getSimpleName();
          methodCode.append(converterType).append(""String_Node_Str"").append(converterName).append(""String_Node_Str"").append(converterType).append(""String_Node_Str"").append(BeanCopierFactory.class.getName()).append(""String_Node_Str"").append(sequence).append(""String_Node_Str"").append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
          methodCode.append(""String_Node_Str"").append(setMethod.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(targetFieldClass.getName()).append(""String_Node_Str"").append(converterName).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
          continue;
        }
        Method getMethod=ReflectionUtils.findMethod(sourceClass,""String_Node_Str"" + methodNameSuffix);
        if (getMethod == null && (targetFieldClass == boolean.class || targetFieldClass == Boolean.class)) {
          getMethod=ReflectionUtils.findMethod(sourceClass,""String_Node_Str"" + methodNameSuffix);
        }
        if (getMethod == null) {
          continue;
        }
        if (getMethod.getReturnType() == targetFieldClass) {
          if (!deepCopy) {
            methodCode.append(""String_Node_Str"").append(setMethod.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(getMethod.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
          }
 else {
            if (ClassHelper.isPrimitiveType(targetFieldClass) || ClassHelper.isPrimitiveWrapperType(targetFieldClass) || targetFieldClass == String.class) {
              methodCode.append(""String_Node_Str"").append(setMethod.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(getMethod.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
            }
 else {
              methodCode.append(""String_Node_Str"").append(setMethod.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(targetFieldClass.getName()).append(""String_Node_Str"").append(BeanUtils.class.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(getMethod.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
            }
          }
        }
 else         if (ClassHelper.isPrimitiveType(targetFieldClass) && ClassHelper.getPrimitiveTypeByWrapper(getMethod.getReturnType()) == targetFieldClass) {
          methodCode.append(""String_Node_Str"").append(setMethod.getName()).append(""String_Node_Str"");
          methodCode.append(""String_Node_Str"").append(getMethod.getName()).append(""String_Node_Str"").append(String.valueOf(ClassHelper.getPrimitiveDftValue(targetFieldClass))).append(""String_Node_Str"").append(""String_Node_Str"").append(getMethod.getName()).append(""String_Node_Str"");
          methodCode.append(""String_Node_Str"");
        }
 else         if (ClassHelper.isPrimitiveWrapperType(targetFieldClass) && ClassHelper.getWrapperTypeByPrimitive(getMethod.getReturnType()) == targetFieldClass) {
          methodCode.append(""String_Node_Str"").append(setMethod.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(getMethod.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
        }
      }
    }
  }
  methodCode.append(""String_Node_Str"");
  return methodCode.toString();
}","/** 
 * 构建方法体实现
 */
private static String getMethodImplCode(Integer sequence,Class<?> sourceClass,Class<?> targetClass,boolean deepCopy,final Map<String,PropConverter<?,?>> propCvtMap) throws Exception {
  StringBuilder methodCode=new StringBuilder();
  methodCode.append(""String_Node_Str"").append(Object.class.getName()).append(""String_Node_Str"").append(Object.class.getName()).append(""String_Node_Str"");
  methodCode.append(sourceClass.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(sourceClass.getName()).append(""String_Node_Str"");
  methodCode.append(targetClass.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(targetClass.getName()).append(""String_Node_Str"");
  Field[] targetFields=ReflectionUtils.findFields(targetClass);
  for (  Field field : targetFields) {
    if (!Modifier.isStatic(field.getModifiers())) {
      String methodNameSuffix=capitalize(field.getName());
      Class<?> targetFieldClass=field.getType();
      Method setMethod=ReflectionUtils.findMethod(targetClass,""String_Node_Str"" + methodNameSuffix,targetFieldClass);
      if (setMethod == null) {
        setMethod=ReflectionUtils.findMethod(targetClass,""String_Node_Str"" + field.getName(),targetFieldClass);
        if (setMethod != null) {
          methodNameSuffix=field.getName();
        }
      }
      if (setMethod != null) {
        if (propCvtMap != null && propCvtMap.containsKey(field.getName())) {
          String converterName=field.getName() + ""String_Node_Str"";
          String converterType=PropConverter.class.getName();
          methodCode.append(converterType).append(""String_Node_Str"").append(converterName).append(""String_Node_Str"").append(converterType).append(""String_Node_Str"").append(BeanCopierFactory.class.getName()).append(""String_Node_Str"").append(sequence).append(""String_Node_Str"").append(""String_Node_Str"").append(field.getName()).append(""String_Node_Str"");
          methodCode.append(""String_Node_Str"").append(setMethod.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(targetFieldClass.getName()).append(""String_Node_Str"").append(converterName).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
          continue;
        }
        Method getMethod=ReflectionUtils.findMethod(sourceClass,""String_Node_Str"" + methodNameSuffix);
        if (getMethod == null && (targetFieldClass == boolean.class || targetFieldClass == Boolean.class)) {
          getMethod=ReflectionUtils.findMethod(sourceClass,""String_Node_Str"" + methodNameSuffix);
        }
        if (getMethod == null) {
          continue;
        }
        if (getMethod.getReturnType() == targetFieldClass) {
          if (!deepCopy) {
            methodCode.append(""String_Node_Str"").append(setMethod.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(getMethod.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
          }
 else {
            if (ClassHelper.isPrimitiveType(targetFieldClass) || ClassHelper.isPrimitiveWrapperType(targetFieldClass) || targetFieldClass == String.class) {
              methodCode.append(""String_Node_Str"").append(setMethod.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(getMethod.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
            }
 else {
              methodCode.append(""String_Node_Str"").append(setMethod.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(targetFieldClass.getName()).append(""String_Node_Str"").append(BeanUtils.class.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(getMethod.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
            }
          }
        }
 else         if (ClassHelper.isPrimitiveType(targetFieldClass) && ClassHelper.getPrimitiveTypeByWrapper(getMethod.getReturnType()) == targetFieldClass) {
          methodCode.append(""String_Node_Str"").append(setMethod.getName()).append(""String_Node_Str"");
          methodCode.append(""String_Node_Str"").append(getMethod.getName()).append(""String_Node_Str"").append(String.valueOf(ClassHelper.getPrimitiveDftValue(targetFieldClass))).append(""String_Node_Str"").append(""String_Node_Str"").append(getMethod.getName()).append(""String_Node_Str"");
          methodCode.append(""String_Node_Str"");
        }
 else         if (ClassHelper.isPrimitiveWrapperType(targetFieldClass) && ClassHelper.getWrapperTypeByPrimitive(getMethod.getReturnType()) == targetFieldClass) {
          methodCode.append(""String_Node_Str"").append(setMethod.getName()).append(""String_Node_Str"").append(""String_Node_Str"").append(getMethod.getName()).append(""String_Node_Str"").append(""String_Node_Str"");
        }
      }
    }
  }
  methodCode.append(""String_Node_Str"");
  return methodCode.toString();
}"
54185,"/** 
 * 生成BeanCopier的实现类源码
 */
private static String getClassCode(Integer sequence,Class<?> sourceClass,Class<?> targetClass,boolean deepCopy,final Map<String,PropConverter<?,?>> propCvtMap) throws Exception {
  JavaSourceBean javaSourceBean=new JavaSourceBean();
  javaSourceBean.setPackageName(BeanCopierFactory.class.getPackage().getName());
  javaSourceBean.addImport(BeanCopierAdapter.class.getName());
  javaSourceBean.addImport(sourceClass.getName());
  javaSourceBean.addImport(targetClass.getName());
  javaSourceBean.addImport(PropConverter.class.getName());
  String beanCopierClassName=sourceClass.getSimpleName() + ""String_Node_Str"" + targetClass.getSimpleName()+ BeanCopier.class.getSimpleName()+ sequence;
  String classDefinitionCode=""String_Node_Str"" + beanCopierClassName + ""String_Node_Str""+ BeanCopierAdapter.class.getSimpleName();
  javaSourceBean.setClassDefinition(classDefinitionCode);
  javaSourceBean.addMethod(getMethodImplCode(sequence,sourceClass,targetClass,deepCopy,propCvtMap));
  if (LOGGER.isDebugEnabled()) {
    LOGGER.debug(javaSourceBean.toString());
  }
  return javaSourceBean.toString();
}","/** 
 * 生成BeanCopier的实现类源码
 */
private static String getClassCode(Integer sequence,Class<?> sourceClass,Class<?> targetClass,boolean deepCopy,final Map<String,PropConverter<?,?>> propCvtMap) throws Exception {
  JavaSourceBean javaSourceBean=new JavaSourceBean();
  javaSourceBean.setPackageName(BeanCopierFactory.class.getPackage().getName());
  javaSourceBean.addImport(BeanCopierAdapter.class.getName());
  javaSourceBean.addImport(sourceClass.getName());
  javaSourceBean.addImport(targetClass.getName());
  javaSourceBean.addImport(PropConverter.class.getName());
  String beanCopierClassName=sourceClass.getSimpleName() + ""String_Node_Str"" + targetClass.getSimpleName()+ BeanCopier.class.getSimpleName()+ sequence;
  String classDefinitionCode=""String_Node_Str"" + beanCopierClassName + ""String_Node_Str""+ BeanCopierAdapter.class.getName();
  javaSourceBean.setClassDefinition(classDefinitionCode);
  javaSourceBean.addMethod(getMethodImplCode(sequence,sourceClass,targetClass,deepCopy,propCvtMap));
  if (LOGGER.isDebugEnabled()) {
    LOGGER.debug(javaSourceBean.toString());
  }
  return javaSourceBean.toString();
}"
54186,"private List<JobPo> fetchJob(String taskTrackerNodeGroup,String taskTrackerIdentity,int size){
  List<JobPo> jobPos=new ArrayList<JobPo>(size);
  for (int i=0; i < size; i++) {
    final JobPo jobPo=appContext.getPreLoader().take(taskTrackerNodeGroup,taskTrackerIdentity);
    if (jobPo == null) {
      if (LOGGER.isDebugEnabled()) {
        LOGGER.debug(""String_Node_Str"" + taskTrackerNodeGroup + ""String_Node_Str""+ taskTrackerIdentity);
      }
      break;
    }
    try {
      jobPo.setGmtModified(SystemClock.now());
      appContext.getExecutingJobQueue().add(jobPo);
    }
 catch (    DupEntryException e) {
      LOGGER.warn(""String_Node_Str"" + JSON.toJSONString(jobPo));
      appContext.getExecutableJobQueue().resume(jobPo);
      continue;
    }
    appContext.getExecutableJobQueue().remove(jobPo.getTaskTrackerNodeGroup(),jobPo.getJobId());
    jobPos.add(jobPo);
  }
  return jobPos;
}","private List<JobPo> fetchJob(String taskTrackerNodeGroup,String taskTrackerIdentity,int size){
  List<JobPo> jobPos=new ArrayList<JobPo>(size);
  for (int i=0; i < size; i++) {
    final JobPo jobPo=appContext.getPreLoader().take(taskTrackerNodeGroup,taskTrackerIdentity);
    if (jobPo == null) {
      if (LOGGER.isDebugEnabled()) {
        LOGGER.debug(""String_Node_Str"" + taskTrackerNodeGroup + ""String_Node_Str""+ taskTrackerIdentity);
      }
      break;
    }
    try {
      appContext.getExecutingJobQueue().add(jobPo);
    }
 catch (    DupEntryException e) {
      LOGGER.warn(""String_Node_Str"" + JSON.toJSONString(jobPo));
      appContext.getExecutableJobQueue().resume(jobPo);
      continue;
    }
    appContext.getExecutableJobQueue().remove(jobPo.getTaskTrackerNodeGroup(),jobPo.getJobId());
    jobPos.add(jobPo);
  }
  return jobPos;
}"
54187,"public List<Node> search(NodePaginationReq request){
  WhereSql whereSql=new WhereSql().andOnNotEmpty(""String_Node_Str"",request.getIdentity()).andOnNotEmpty(""String_Node_Str"",request.getNodeGroup()).andOnNotNull(""String_Node_Str"",request.getNodeType() == null ? null : request.getNodeType().name()).andOnNotEmpty(""String_Node_Str"",request.getIp()).andOnNotNull(""String_Node_Str"",request.getAvailable()).andBetween(""String_Node_Str"",JdbcTypeUtils.toTimestamp(request.getStartDate()),JdbcTypeUtils.toTimestamp(request.getEndDate()));
  SelectSql selectSql=new SelectSql(getSqlTemplate()).select().all().from().table(getTableName()).whereSql(whereSql);
  if (StringUtils.isNotEmpty(request.getField())) {
    selectSql.orderBy().column(CharacterUtils.camelCase2Underscore(request.getField()),OrderByType.convert(request.getDirection()));
  }
  return selectSql.limit(request.getStart(),request.getLimit()).list(RshHandler.NODE_LIST_RSH);
}","public List<Node> search(NodePaginationReq request){
  SelectSql selectSql=new SelectSql(getSqlTemplate()).select().all().from().table(getTableName()).whereSql(buildWhereSql(request));
  if (StringUtils.isNotEmpty(request.getField())) {
    selectSql.orderBy().column(CharacterUtils.camelCase2Underscore(request.getField()),OrderByType.convert(request.getDirection()));
  }
  return selectSql.limit(request.getStart(),request.getLimit()).list(RshHandler.NODE_LIST_RSH);
}"
54188,"public List<Node> getNodeByNodeType(NodeType nodeType){
  NodePaginationReq nodePaginationReq=new NodePaginationReq();
  nodePaginationReq.setNodeType(nodeType);
  return search(nodePaginationReq);
}","public List<Node> getNodeByNodeType(NodeType nodeType){
  NodePaginationReq nodePaginationReq=new NodePaginationReq();
  nodePaginationReq.setNodeType(nodeType);
  nodePaginationReq.setLimit(Integer.MAX_VALUE);
  return search(nodePaginationReq);
}"
54189,"public List<Node> getOnlineNodes(NodePaginationReq request){
  return appContext.getNodeMemCacheAccess().search(request);
}","public PaginationRsp<Node> getOnlineNodes(NodePaginationReq request){
  return appContext.getNodeMemCacheAccess().pageSelect(request);
}"
54190,"@RequestMapping(""String_Node_Str"") public RestfulResponse getNodeList(NodePaginationReq request){
  RestfulResponse response=new RestfulResponse();
  List<Node> nodes=appContext.getBackendRegistrySrv().getOnlineNodes(request);
  response.setSuccess(true);
  response.setResults(CollectionUtils.sizeOf(nodes));
  response.setRows(nodes);
  return response;
}","@RequestMapping(""String_Node_Str"") public RestfulResponse getNodeList(NodePaginationReq request){
  RestfulResponse response=new RestfulResponse();
  request.setLimit(10000);
  PaginationRsp<Node> paginationRsp=appContext.getBackendRegistrySrv().getOnlineNodes(request);
  response.setSuccess(true);
  response.setResults(paginationRsp.getResults());
  response.setRows(paginationRsp.getRows());
  return response;
}"
54191,"/** 
 * 发送给客户端 返回是否发送成功还是失败
 */
private boolean send0(String nodeGroup,final List<JobRunResult> results){
  JobClientNode jobClientNode=appContext.getJobClientManager().getAvailableJobClient(nodeGroup);
  if (jobClientNode == null) {
    return false;
  }
  List<JobResult> jobResults=new ArrayList<JobResult>(results.size());
  for (  JobRunResult result : results) {
    JobResult jobResult=new JobResult();
    jobResult.setJob(result.getJobMeta().getJob());
    jobResult.setSuccess(Action.EXECUTE_SUCCESS.equals(result.getAction()));
    jobResult.setMsg(result.getMsg());
    jobResult.setTime(result.getTime());
    jobResults.add(jobResult);
  }
  JobFinishedRequest requestBody=appContext.getCommandBodyWrapper().wrapper(new JobFinishedRequest());
  requestBody.setJobResults(jobResults);
  RemotingCommand commandRequest=RemotingCommand.createRequestCommand(JobProtos.RequestCode.JOB_COMPLETED.code(),requestBody);
  final Holder<Boolean> result=new Holder<Boolean>();
  try {
    final CountDownLatch latch=new CountDownLatch(1);
    getRemotingServer().invokeAsync(jobClientNode.getChannel().getChannel(),commandRequest,new AsyncCallback(){
      @Override public void operationComplete(      ResponseFuture responseFuture){
        try {
          RemotingCommand commandResponse=responseFuture.getResponseCommand();
          if (commandResponse != null && commandResponse.getCode() == JobProtos.ResponseCode.JOB_NOTIFY_SUCCESS.code()) {
            clientNotifyHandler.handleSuccess(results);
            result.set(true);
          }
 else {
            result.set(false);
          }
        }
  finally {
          latch.countDown();
        }
      }
    }
);
    try {
      latch.await(Constants.LATCH_TIMEOUT_MILLIS,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      throw new RequestTimeoutException(e);
    }
  }
 catch (  RemotingSendException e) {
    LOGGER.error(""String_Node_Str"",e);
  }
  return result.get() == null ? false : result.get();
}","/** 
 * 发送给客户端 返回是否发送成功还是失败
 */
private boolean send0(String nodeGroup,final List<JobRunResult> results){
  JobClientNode jobClientNode=appContext.getJobClientManager().getAvailableJobClient(nodeGroup);
  if (jobClientNode == null) {
    return false;
  }
  List<JobResult> jobResults=new ArrayList<JobResult>(results.size());
  for (  JobRunResult result : results) {
    JobResult jobResult=new JobResult();
    Job job=JobUtils.copy(result.getJobMeta().getJob());
    job.setTaskId(result.getJobMeta().getRealTaskId());
    jobResult.setJob(job);
    jobResult.setSuccess(Action.EXECUTE_SUCCESS.equals(result.getAction()));
    jobResult.setMsg(result.getMsg());
    jobResult.setTime(result.getTime());
    jobResults.add(jobResult);
  }
  JobFinishedRequest requestBody=appContext.getCommandBodyWrapper().wrapper(new JobFinishedRequest());
  requestBody.setJobResults(jobResults);
  RemotingCommand commandRequest=RemotingCommand.createRequestCommand(JobProtos.RequestCode.JOB_COMPLETED.code(),requestBody);
  final Holder<Boolean> result=new Holder<Boolean>();
  try {
    final CountDownLatch latch=new CountDownLatch(1);
    getRemotingServer().invokeAsync(jobClientNode.getChannel().getChannel(),commandRequest,new AsyncCallback(){
      @Override public void operationComplete(      ResponseFuture responseFuture){
        try {
          RemotingCommand commandResponse=responseFuture.getResponseCommand();
          if (commandResponse != null && commandResponse.getCode() == JobProtos.ResponseCode.JOB_NOTIFY_SUCCESS.code()) {
            clientNotifyHandler.handleSuccess(results);
            result.set(true);
          }
 else {
            result.set(false);
          }
        }
  finally {
          latch.countDown();
        }
      }
    }
);
    try {
      latch.await(Constants.LATCH_TIMEOUT_MILLIS,TimeUnit.MILLISECONDS);
    }
 catch (    InterruptedException e) {
      throw new RequestTimeoutException(e);
    }
  }
 catch (  RemotingSendException e) {
    LOGGER.error(""String_Node_Str"",e);
  }
  return result.get() == null ? false : result.get();
}"
54192,"private DataSource createDruidDataSource(Config config){
  DruidDataSource dataSource=new DruidDataSource();
  Class<DruidDataSource> clazz=DruidDataSource.class;
  for (  Map.Entry<String,Class<?>> entry : FIELDS.entrySet()) {
    String field=entry.getKey();
    String value=config.getParameter(""String_Node_Str"" + field);
    if (StringUtils.isNotEmpty(value)) {
      Method setMethod=null;
      try {
        setMethod=clazz.getMethod(""String_Node_Str"" + (field.substring(0,1).toUpperCase() + field.substring(1)),entry.getValue());
        setMethod.invoke(dataSource,value);
      }
 catch (      Exception e) {
        LOGGER.warn(""String_Node_Str"",field,value);
      }
    }
  }
  String url=config.getParameter(ExtConfig.JDBC_URL);
  String username=config.getParameter(ExtConfig.JDBC_USERNAME);
  String password=config.getParameter(ExtConfig.JDBC_PASSWORD);
  dataSource.setUrl(url);
  dataSource.setUsername(username);
  dataSource.setPassword(password);
  return dataSource;
}","private DataSource createDruidDataSource(Config config){
  DruidDataSource dataSource=new DruidDataSource();
  Class<DruidDataSource> clazz=DruidDataSource.class;
  for (  Map.Entry<String,Class<?>> entry : FIELDS.entrySet()) {
    String field=entry.getKey();
    String value=config.getParameter(""String_Node_Str"" + field);
    if (StringUtils.isNotEmpty(value)) {
      Method setMethod=null;
      try {
        try {
          setMethod=clazz.getMethod(""String_Node_Str"" + (field.substring(0,1).toUpperCase() + field.substring(1)),entry.getValue());
        }
 catch (        NoSuchMethodException e) {
          setMethod=clazz.getMethod(""String_Node_Str"" + (field.substring(0,1).toUpperCase() + field.substring(1)),PrimitiveTypeUtils.getUnBoxType(entry.getValue()));
        }
        Object obj=PrimitiveTypeUtils.convert(value,entry.getValue());
        setMethod.invoke(dataSource,obj);
      }
 catch (      Exception e) {
        LOGGER.warn(""String_Node_Str"",field,value);
      }
    }
  }
  String url=config.getParameter(ExtConfig.JDBC_URL);
  String username=config.getParameter(ExtConfig.JDBC_USERNAME);
  String password=config.getParameter(ExtConfig.JDBC_PASSWORD);
  dataSource.setUrl(url);
  dataSource.setUsername(username);
  dataSource.setPassword(password);
  return dataSource;
}"
54193,"/** 
 * 添加Cron 任务
 */
private void addCronJob(JobPo jobPo) throws DupEntryException {
  Date nextTriggerTime=CronExpressionUtils.getNextTriggerTime(jobPo.getCronExpression());
  if (nextTriggerTime != null) {
    appContext.getCronJobQueue().add(jobPo);
    if (JobUtils.isRelyOnPrevCycle(jobPo)) {
      if (appContext.getExecutingJobQueue().getJob(jobPo.getTaskTrackerNodeGroup(),jobPo.getTaskId()) == null) {
        jobPo.setTriggerTime(nextTriggerTime.getTime());
        appContext.getExecutableJobQueue().add(jobPo);
      }
    }
 else {
      appContext.getNonRelyOnPrevCycleJobScheduler().addScheduleJobForOneHour(jobPo);
    }
  }
}","/** 
 * 添加Cron 任务
 */
private void addCronJob(JobPo jobPo) throws DupEntryException {
  Date nextTriggerTime=CronExpressionUtils.getNextTriggerTime(jobPo.getCronExpression());
  if (nextTriggerTime != null) {
    appContext.getCronJobQueue().add(jobPo);
    if (JobUtils.isRelyOnPrevCycle(jobPo)) {
      if (appContext.getExecutingJobQueue().getJob(jobPo.getTaskTrackerNodeGroup(),jobPo.getTaskId()) == null) {
        jobPo.setTriggerTime(nextTriggerTime.getTime());
        try {
          appContext.getExecutableJobQueue().add(jobPo);
        }
 catch (        DupEntryException e) {
          appContext.getCronJobQueue().remove(jobPo.getJobId());
          throw e;
        }
      }
    }
 else {
      appContext.getNonRelyOnPrevCycleJobScheduler().addScheduleJobForOneHour(jobPo);
    }
  }
}"
54194,"/** 
 * 更新任务
 */
private boolean replaceOnExist(Job job,JobPo jobPo){
  JobPo existJobPo=appContext.getExecutableJobQueue().getJob(job.getTaskTrackerNodeGroup(),job.getTaskId());
  if (existJobPo == null) {
    existJobPo=appContext.getCronJobQueue().getJob(job.getTaskTrackerNodeGroup(),job.getTaskId());
    if (existJobPo == null) {
      existJobPo=appContext.getRepeatJobQueue().getJob(job.getTaskTrackerNodeGroup(),job.getTaskId());
    }
  }
  if (existJobPo != null) {
    String jobId=existJobPo.getJobId();
    appContext.getExecutableJobQueue().remove(job.getTaskTrackerNodeGroup(),jobId);
    appContext.getCronJobQueue().remove(jobId);
    appContext.getRepeatJobQueue().remove(jobId);
    jobPo.setJobId(jobId);
  }
  try {
    addJob(job,jobPo);
  }
 catch (  DupEntryException e) {
    LOGGER.warn(""String_Node_Str"",job);
    return false;
  }
  return true;
}","/** 
 * 更新任务
 */
private boolean replaceOnExist(Job job,JobPo jobPo){
  JobPo existJobPo=appContext.getExecutableJobQueue().getJob(job.getTaskTrackerNodeGroup(),jobPo.getTaskId());
  if (existJobPo == null) {
    existJobPo=appContext.getCronJobQueue().getJob(job.getTaskTrackerNodeGroup(),job.getTaskId());
    if (existJobPo == null) {
      existJobPo=appContext.getRepeatJobQueue().getJob(job.getTaskTrackerNodeGroup(),job.getTaskId());
    }
  }
  if (existJobPo != null) {
    String jobId=existJobPo.getJobId();
    appContext.getExecutableJobQueue().removeBatch(jobPo.getRealTaskId(),jobPo.getTaskTrackerNodeGroup());
    appContext.getCronJobQueue().remove(jobId);
    appContext.getRepeatJobQueue().remove(jobId);
    jobPo.setJobId(jobId);
  }
  try {
    addJob(job,jobPo);
  }
 catch (  DupEntryException e) {
    LOGGER.warn(""String_Node_Str"",job);
    return false;
  }
  return true;
}"
54195,"/** 
 * 添加任务
 */
private void addJob(Job job,JobPo jobPo) throws DupEntryException {
  if (job.isCron()) {
    addCronJob(jobPo);
  }
 else   if (job.isRepeatable()) {
    addRepeatJob(jobPo);
  }
 else {
    boolean needAdd2ExecutableJobQueue=true;
    String ignoreAddOnExecuting=CollectionUtils.getValue(jobPo.getInternalExtParams(),""String_Node_Str"");
    if (ignoreAddOnExecuting != null && ""String_Node_Str"".equals(ignoreAddOnExecuting)) {
      if (appContext.getExecutingJobQueue().getJob(jobPo.getTaskTrackerNodeGroup(),jobPo.getTaskId()) != null) {
        needAdd2ExecutableJobQueue=false;
      }
    }
    if (needAdd2ExecutableJobQueue) {
      appContext.getExecutableJobQueue().add(jobPo);
    }
  }
}","/** 
 * 添加任务
 */
private void addJob(Job job,JobPo jobPo) throws DupEntryException {
  if (job.isCron()) {
    addCronJob(jobPo);
  }
 else   if (job.isRepeatable()) {
    addRepeatJob(jobPo);
  }
 else {
    addTriggerTimeJob(jobPo);
  }
}"
54196,"/** 
 * 添加Repeat 任务
 */
private void addRepeatJob(JobPo jobPo) throws DupEntryException {
  appContext.getRepeatJobQueue().add(jobPo);
  if (JobUtils.isRelyOnPrevCycle(jobPo)) {
    if (appContext.getExecutingJobQueue().getJob(jobPo.getTaskTrackerNodeGroup(),jobPo.getTaskId()) == null) {
      appContext.getExecutableJobQueue().add(jobPo);
    }
  }
 else {
    appContext.getNonRelyOnPrevCycleJobScheduler().addScheduleJobForOneHour(jobPo);
  }
}","/** 
 * 添加Repeat 任务
 */
private void addRepeatJob(JobPo jobPo) throws DupEntryException {
  appContext.getRepeatJobQueue().add(jobPo);
  if (JobUtils.isRelyOnPrevCycle(jobPo)) {
    if (appContext.getExecutingJobQueue().getJob(jobPo.getTaskTrackerNodeGroup(),jobPo.getTaskId()) == null) {
      try {
        appContext.getExecutableJobQueue().add(jobPo);
      }
 catch (      DupEntryException e) {
        appContext.getRepeatJobQueue().remove(jobPo.getJobId());
        throw e;
      }
    }
  }
 else {
    appContext.getNonRelyOnPrevCycleJobScheduler().addScheduleJobForOneHour(jobPo);
  }
}"
54197,"@RequestMapping(""String_Node_Str"") public RestfulResponse suspendJobRecovery(JobQueueReq request){
  if (StringUtils.isEmpty(request.getJobId())) {
    return Builder.build(false,""String_Node_Str"");
  }
  JobPo jobPo=appContext.getSuspendJobQueue().getJob(request.getJobId());
  if (jobPo == null) {
    return Builder.build(false,""String_Node_Str"");
  }
  if (jobPo.isCron()) {
    Date nextTriggerTime=CronExpressionUtils.getNextTriggerTime(jobPo.getCronExpression());
    if (nextTriggerTime != null) {
      jobPo.setGmtModified(SystemClock.now());
      try {
        appContext.getCronJobQueue().add(jobPo);
      }
 catch (      DupEntryException e) {
        return Builder.build(false,""String_Node_Str"");
      }
catch (      Exception e) {
        return Builder.build(false,""String_Node_Str"" + e.getMessage());
      }
      if (jobPo.getRelyOnPrevCycle()) {
        try {
          jobPo.setTriggerTime(nextTriggerTime.getTime());
          appContext.getExecutableJobQueue().add(jobPo);
        }
 catch (        DupEntryException e) {
          return Builder.build(false,""String_Node_Str"");
        }
catch (        Exception e) {
          return Builder.build(false,""String_Node_Str"" + e.getMessage());
        }
      }
 else {
        Long lastGenerateTriggerTime=jobPo.getLastGenerateTriggerTime();
        if (lastGenerateTriggerTime == null || lastGenerateTriggerTime == 0) {
          lastGenerateTriggerTime=SystemClock.now();
        }
        appContext.getNoRelyJobGenerator().generateCronJobForInterval(jobPo,new Date(lastGenerateTriggerTime));
      }
    }
 else {
      return Builder.build(false,""String_Node_Str"");
    }
  }
 else   if (jobPo.isRepeatable()) {
    if (jobPo.getRepeatCount() == -1 || jobPo.getRepeatedCount() < jobPo.getRepeatCount()) {
      jobPo.setGmtModified(SystemClock.now());
      try {
        appContext.getRepeatJobQueue().add(jobPo);
      }
 catch (      DupEntryException e) {
        return Builder.build(false,""String_Node_Str"");
      }
catch (      Exception e) {
        return Builder.build(false,""String_Node_Str"" + e.getMessage());
      }
      if (jobPo.getRelyOnPrevCycle()) {
        try {
          JobPo repeatJob=appContext.getRepeatJobQueue().getJob(request.getJobId());
          long nextTriggerTime=JobUtils.getRepeatNextTriggerTime(repeatJob);
          jobPo.setTriggerTime(nextTriggerTime);
          appContext.getExecutableJobQueue().add(jobPo);
        }
 catch (        DupEntryException e) {
          return Builder.build(false,""String_Node_Str"");
        }
catch (        Exception e) {
          return Builder.build(false,""String_Node_Str"" + e.getMessage());
        }
      }
 else {
        Long lastGenerateTriggerTime=jobPo.getLastGenerateTriggerTime();
        if (lastGenerateTriggerTime == null) {
          lastGenerateTriggerTime=SystemClock.now();
        }
        appContext.getNoRelyJobGenerator().generateRepeatJobForInterval(jobPo,new Date(lastGenerateTriggerTime));
      }
    }
 else {
      return Builder.build(false,""String_Node_Str"");
    }
  }
  if (!appContext.getSuspendJobQueue().remove(request.getJobId())) {
    return Builder.build(false,""String_Node_Str"");
  }
  JobLogUtils.log(LogType.RESUME,jobPo,appContext.getJobLogger());
  return Builder.build(true);
}","@RequestMapping(""String_Node_Str"") public RestfulResponse suspendJobRecovery(JobQueueReq request){
  if (StringUtils.isEmpty(request.getJobId())) {
    return Builder.build(false,""String_Node_Str"");
  }
  JobPo jobPo=appContext.getSuspendJobQueue().getJob(request.getJobId());
  if (jobPo == null) {
    return Builder.build(false,""String_Node_Str"");
  }
  if (jobPo.isCron()) {
    Date nextTriggerTime=CronExpressionUtils.getNextTriggerTime(jobPo.getCronExpression());
    if (nextTriggerTime != null) {
      jobPo.setGmtModified(SystemClock.now());
      try {
        appContext.getCronJobQueue().add(jobPo);
      }
 catch (      DupEntryException e) {
        return Builder.build(false,""String_Node_Str"");
      }
catch (      Exception e) {
        return Builder.build(false,""String_Node_Str"" + e.getMessage());
      }
      if (jobPo.getRelyOnPrevCycle()) {
        try {
          jobPo.setTriggerTime(nextTriggerTime.getTime());
          appContext.getExecutableJobQueue().add(jobPo);
        }
 catch (        DupEntryException e) {
          return Builder.build(false,""String_Node_Str"");
        }
catch (        Exception e) {
          return Builder.build(false,""String_Node_Str"" + e.getMessage());
        }
      }
 else {
        Long lastGenerateTriggerTime=jobPo.getLastGenerateTriggerTime();
        if (lastGenerateTriggerTime == null || lastGenerateTriggerTime == 0) {
          lastGenerateTriggerTime=SystemClock.now();
        }
        appContext.getNoRelyJobGenerator().generateCronJobForInterval(jobPo,new Date(lastGenerateTriggerTime));
      }
    }
 else {
      return Builder.build(false,""String_Node_Str"");
    }
  }
 else   if (jobPo.isRepeatable()) {
    if (jobPo.getRepeatCount() == -1 || jobPo.getRepeatedCount() < jobPo.getRepeatCount()) {
      jobPo.setGmtModified(SystemClock.now());
      try {
        appContext.getRepeatJobQueue().add(jobPo);
      }
 catch (      DupEntryException e) {
        return Builder.build(false,""String_Node_Str"");
      }
catch (      Exception e) {
        return Builder.build(false,""String_Node_Str"" + e.getMessage());
      }
      if (jobPo.getRelyOnPrevCycle()) {
        try {
          JobPo repeatJob=appContext.getRepeatJobQueue().getJob(request.getJobId());
          long nextTriggerTime=JobUtils.getRepeatNextTriggerTime(repeatJob);
          jobPo.setTriggerTime(nextTriggerTime);
          appContext.getExecutableJobQueue().add(jobPo);
        }
 catch (        DupEntryException e) {
          return Builder.build(false,""String_Node_Str"");
        }
catch (        Exception e) {
          return Builder.build(false,""String_Node_Str"" + e.getMessage());
        }
      }
 else {
        Long lastGenerateTriggerTime=jobPo.getLastGenerateTriggerTime();
        if (lastGenerateTriggerTime == null || lastGenerateTriggerTime == 0) {
          lastGenerateTriggerTime=SystemClock.now();
        }
        appContext.getNoRelyJobGenerator().generateRepeatJobForInterval(jobPo,new Date(lastGenerateTriggerTime));
      }
    }
 else {
      return Builder.build(false,""String_Node_Str"");
    }
  }
  if (!appContext.getSuspendJobQueue().remove(request.getJobId())) {
    return Builder.build(false,""String_Node_Str"");
  }
  JobLogUtils.log(LogType.RESUME,jobPo,appContext.getJobLogger());
  return Builder.build(true);
}"
54198,"public static void addRepeatJobForInterval(ExecutableJobQueue executableJobQueue,RepeatJobQueue repeatJobQueue,int scheduleIntervalMinute,final JobPo finalJobPo,Date lastGenerateTime){
  JobPo jobPo=JobUtils.copy(finalJobPo);
  long firstTriggerTime=Long.valueOf(jobPo.getInternalExtParam(Constants.FIRST_FIRE_TIME));
  int repeatedCount=Long.valueOf((lastGenerateTime.getTime() - firstTriggerTime) / jobPo.getRepeatInterval()).intValue();
  Long repeatInterval=jobPo.getRepeatInterval();
  Integer repeatCount=jobPo.getRepeatCount();
  long endTime=DateUtils.addMinute(lastGenerateTime,scheduleIntervalMinute).getTime();
  boolean stop=false;
  while (!stop) {
    Long nextTriggerTime=firstTriggerTime + repeatedCount * repeatInterval;
    if (nextTriggerTime <= endTime && (repeatCount == -1 || repeatedCount <= repeatCount)) {
      jobPo.setTriggerTime(nextTriggerTime);
      jobPo.setJobId(JobUtils.generateJobId());
      jobPo.setTaskId(finalJobPo.getTaskId() + ""String_Node_Str"" + DateUtils.format(new Date(nextTriggerTime),""String_Node_Str""));
      jobPo.setRepeatedCount(repeatedCount);
      jobPo.setInternalExtParam(Constants.ONCE,Boolean.TRUE.toString());
      try {
        executableJobQueue.add(jobPo);
      }
 catch (      DupEntryException e) {
        LOGGER.warn(""String_Node_Str"",jobPo.getTaskId(),jobPo.getTaskTrackerNodeGroup());
      }
      repeatedCount++;
    }
 else {
      stop=true;
    }
  }
  repeatJobQueue.updateLastGenerateTriggerTime(finalJobPo.getJobId(),endTime);
  if (LOGGER.isDebugEnabled()) {
    LOGGER.debug(""String_Node_Str"",jobPo,DateUtils.formatYMD_HMS(new Date(endTime)));
  }
}","public static void addRepeatJobForInterval(ExecutableJobQueue executableJobQueue,RepeatJobQueue repeatJobQueue,int scheduleIntervalMinute,final JobPo finalJobPo,Date lastGenerateTime){
  JobPo jobPo=JobUtils.copy(finalJobPo);
  long firstTriggerTime=Long.valueOf(jobPo.getInternalExtParam(Constants.FIRST_FIRE_TIME));
  Long repeatInterval=jobPo.getRepeatInterval();
  Integer repeatCount=jobPo.getRepeatCount();
  long endTime=DateUtils.addMinute(lastGenerateTime,scheduleIntervalMinute).getTime();
  if (endTime <= firstTriggerTime) {
    return;
  }
  int repeatedCount=Long.valueOf((lastGenerateTime.getTime() - firstTriggerTime) / jobPo.getRepeatInterval()).intValue();
  boolean stop=false;
  while (!stop) {
    Long nextTriggerTime=firstTriggerTime + repeatedCount * repeatInterval;
    if (nextTriggerTime <= endTime && (repeatCount == -1 || repeatedCount <= repeatCount)) {
      jobPo.setTriggerTime(nextTriggerTime);
      jobPo.setJobId(JobUtils.generateJobId());
      jobPo.setTaskId(finalJobPo.getTaskId() + ""String_Node_Str"" + DateUtils.format(new Date(nextTriggerTime),""String_Node_Str""));
      jobPo.setRepeatedCount(repeatedCount);
      jobPo.setInternalExtParam(Constants.ONCE,Boolean.TRUE.toString());
      try {
        executableJobQueue.add(jobPo);
      }
 catch (      DupEntryException e) {
        LOGGER.warn(""String_Node_Str"",jobPo.getTaskId(),jobPo.getTaskTrackerNodeGroup());
      }
      repeatedCount++;
    }
 else {
      stop=true;
    }
  }
  repeatJobQueue.updateLastGenerateTriggerTime(finalJobPo.getJobId(),endTime);
  if (LOGGER.isDebugEnabled()) {
    LOGGER.debug(""String_Node_Str"",jobPo,DateUtils.formatYMD_HMS(new Date(endTime)));
  }
}"
54199,"private void fixDeadJob(JobPo jobPo){
  try {
    if (appContext.getExecutingJobQueue().getJob(jobPo.getTaskTrackerNodeGroup(),jobPo.getTaskId()) == null) {
      return;
    }
    jobPo.setGmtModified(SystemClock.now());
    jobPo.setTaskTrackerIdentity(null);
    jobPo.setIsRunning(false);
    try {
      appContext.getExecutableJobQueue().add(jobPo);
    }
 catch (    DupEntryException e) {
      LOGGER.warn(""String_Node_Str"" + JSON.toJSONString(jobPo));
    }
    appContext.getExecutingJobQueue().remove(jobPo.getJobId());
    JobLogPo jobLogPo=JobDomainConverter.convertJobLog(jobPo);
    jobLogPo.setLogTime(SystemClock.now());
    jobLogPo.setSuccess(true);
    jobLogPo.setLevel(Level.WARN);
    jobLogPo.setLogType(LogType.FIXED_DEAD);
    appContext.getJobLogger().log(jobLogPo);
    stat.incFixExecutingJobNum();
  }
 catch (  Throwable t) {
    LOGGER.error(t.getMessage(),t);
  }
  LOGGER.info(""String_Node_Str"",JSON.toJSONString(jobPo));
}","private void fixDeadJob(JobPo jobPo){
  try {
    if (appContext.getExecutingJobQueue().getJob(jobPo.getJobId()) == null) {
      return;
    }
    jobPo.setGmtModified(SystemClock.now());
    jobPo.setTaskTrackerIdentity(null);
    jobPo.setIsRunning(false);
    try {
      appContext.getExecutableJobQueue().add(jobPo);
    }
 catch (    DupEntryException e) {
      LOGGER.warn(""String_Node_Str"" + JSON.toJSONString(jobPo));
    }
    appContext.getExecutingJobQueue().remove(jobPo.getJobId());
    JobLogPo jobLogPo=JobDomainConverter.convertJobLog(jobPo);
    jobLogPo.setLogTime(SystemClock.now());
    jobLogPo.setSuccess(true);
    jobLogPo.setLevel(Level.WARN);
    jobLogPo.setLogType(LogType.FIXED_DEAD);
    appContext.getJobLogger().log(jobLogPo);
    stat.incFixExecutingJobNum();
  }
 catch (  Throwable t) {
    LOGGER.error(t.getMessage(),t);
  }
  LOGGER.info(""String_Node_Str"",JSON.toJSONString(jobPo));
}"
54200,"public static Compiler getCompiler(){
  return AbstractCompiler.COMPILER;
}","public static Compiler getCompiler(){
  if (AbstractCompiler.COMPILER == null) {
    AbstractCompiler.COMPILER=new JavassistCompiler();
  }
  return AbstractCompiler.COMPILER;
}"
54201,"public static Node parse(String fullPath){
  Node node=new Node();
  String[] nodeDir=fullPath.split(""String_Node_Str"");
  NodeType nodeType=NodeType.valueOf(nodeDir[4]);
  node.setNodeType(nodeType);
  String url=nodeDir[5];
  url=url.substring(nodeType.name().length() + 3);
  String address=url.split(""String_Node_Str"")[0];
  String ip=address.split(""String_Node_Str"")[0];
  node.setIp(ip);
  if (address.contains(""String_Node_Str"")) {
    String port=address.split(""String_Node_Str"")[1];
    if (port != null && !""String_Node_Str"".equals(port.trim())) {
      node.setPort(Integer.valueOf(port));
    }
  }
  String params=url.split(""String_Node_Str"")[1];
  String[] paramArr=params.split(""String_Node_Str"");
  for (  String paramEntry : paramArr) {
    String key=paramEntry.split(""String_Node_Str"")[0];
    String value=paramEntry.split(""String_Node_Str"")[1];
    if (""String_Node_Str"".equals(key)) {
      node.setClusterName(value);
    }
 else     if (""String_Node_Str"".equals(key)) {
      node.setGroup(value);
    }
 else     if (""String_Node_Str"".equals(key)) {
      node.setThreads(Integer.valueOf(value));
    }
 else     if (""String_Node_Str"".equals(key)) {
      node.setIdentity(value);
    }
 else     if (""String_Node_Str"".equals(key)) {
      node.setCreateTime(Long.valueOf(value));
    }
 else     if (""String_Node_Str"".equals(key)) {
      node.setAvailable(Boolean.valueOf(value));
    }
 else     if (""String_Node_Str"".equals(key)) {
      node.setHostName(value);
    }
 else     if (""String_Node_Str"".equals(key)) {
      node.setHttpCmdPort(Integer.valueOf(value));
    }
  }
  return node;
}","public static Node parse(String fullPath){
  try {
    Node node=new Node();
    String[] nodeDir=fullPath.split(""String_Node_Str"");
    NodeType nodeType=NodeType.valueOf(nodeDir[4]);
    node.setNodeType(nodeType);
    String url=nodeDir[5];
    url=url.substring(nodeType.name().length() + 3);
    String address=url.split(""String_Node_Str"")[0];
    String ip=address.split(""String_Node_Str"")[0];
    node.setIp(ip);
    if (address.contains(""String_Node_Str"")) {
      String port=address.split(""String_Node_Str"")[1];
      if (port != null && !""String_Node_Str"".equals(port.trim())) {
        node.setPort(Integer.valueOf(port));
      }
    }
    String params=url.split(""String_Node_Str"")[1];
    String[] paramArr=params.split(""String_Node_Str"");
    for (    String paramEntry : paramArr) {
      if (StringUtils.isEmpty(paramEntry)) {
        continue;
      }
      String key=paramEntry.split(""String_Node_Str"")[0];
      String value=paramEntry.split(""String_Node_Str"")[1];
      if (""String_Node_Str"".equals(key)) {
        node.setClusterName(value);
      }
 else       if (""String_Node_Str"".equals(key)) {
        node.setGroup(value);
      }
 else       if (""String_Node_Str"".equals(key)) {
        node.setThreads(Integer.valueOf(value));
      }
 else       if (""String_Node_Str"".equals(key)) {
        node.setIdentity(value);
      }
 else       if (""String_Node_Str"".equals(key)) {
        node.setCreateTime(Long.valueOf(value));
      }
 else       if (""String_Node_Str"".equals(key)) {
        node.setAvailable(Boolean.valueOf(value));
      }
 else       if (""String_Node_Str"".equals(key)) {
        node.setHostName(value);
      }
 else       if (""String_Node_Str"".equals(key)) {
        node.setHttpCmdPort(Integer.valueOf(value));
      }
    }
    return node;
  }
 catch (  RuntimeException e) {
    LOGGER.error(""String_Node_Str"" + fullPath);
    throw e;
  }
}"
54202,"/** 
 * 更新任务
 */
private boolean replaceOnExist(Job job,JobPo jobPo){
  JobPo oldJobPo;
  if (job.isCron()) {
    oldJobPo=appContext.getCronJobQueue().getJob(job.getTaskTrackerNodeGroup(),job.getTaskId());
  }
 else   if (job.isRepeatable()) {
    oldJobPo=appContext.getRepeatJobQueue().getJob(job.getTaskTrackerNodeGroup(),job.getTaskId());
  }
 else {
    oldJobPo=appContext.getExecutableJobQueue().getJob(job.getTaskTrackerNodeGroup(),job.getTaskId());
  }
  if (oldJobPo != null) {
    String jobId=oldJobPo.getJobId();
    appContext.getExecutableJobQueue().remove(job.getTaskTrackerNodeGroup(),jobId);
    if (job.isCron()) {
      appContext.getCronJobQueue().remove(jobId);
    }
 else     if (job.isRepeatable()) {
      appContext.getRepeatJobQueue().remove(jobId);
    }
    jobPo.setJobId(jobId);
  }
  try {
    addJob(job,jobPo);
  }
 catch (  DupEntryException e) {
    LOGGER.warn(""String_Node_Str"",job);
    return false;
  }
  return true;
}","/** 
 * 更新任务
 */
private boolean replaceOnExist(Job job,JobPo jobPo){
  JobPo existJobPo=appContext.getExecutableJobQueue().getJob(job.getTaskTrackerNodeGroup(),job.getTaskId());
  if (existJobPo == null) {
    existJobPo=appContext.getCronJobQueue().getJob(job.getTaskTrackerNodeGroup(),job.getTaskId());
    if (existJobPo == null) {
      existJobPo=appContext.getRepeatJobQueue().getJob(job.getTaskTrackerNodeGroup(),job.getTaskId());
    }
  }
  if (existJobPo != null) {
    String jobId=existJobPo.getJobId();
    appContext.getExecutableJobQueue().remove(job.getTaskTrackerNodeGroup(),jobId);
    appContext.getCronJobQueue().remove(jobId);
    appContext.getRepeatJobQueue().remove(jobId);
    jobPo.setJobId(jobId);
  }
  try {
    addJob(job,jobPo);
  }
 catch (  DupEntryException e) {
    LOGGER.warn(""String_Node_Str"",job);
    return false;
  }
  return true;
}"
54203,"@Override public List<JobPo> getNeedGenerateJobPos(Long checkTime,int topSize){
  Query<JobPo> query=template.createQuery(JobPo.class);
  query.field(""String_Node_Str"").equal(true);
  query.field(""String_Node_Str"").equal(checkTime);
  query.offset(0).limit(topSize);
  return query.asList();
}","@Override public List<JobPo> getNeedGenerateJobPos(Long checkTime,int topSize){
  Query<JobPo> query=template.createQuery(JobPo.class);
  query.field(""String_Node_Str"").equal(false);
  query.field(""String_Node_Str"").equal(checkTime);
  query.offset(0).limit(topSize);
  return query.asList();
}"
54204,"@Override public boolean removeQueue(String jobClientNodeGroup){
  return new DropTableSql(getSqlTemplate()).drop(JobQueueUtils.getExecutableQueueName(jobClientNodeGroup)).doDrop();
}","@Override public boolean removeQueue(String jobClientNodeGroup){
  return new DropTableSql(getSqlTemplate()).drop(JobQueueUtils.getFeedbackQueueName(jobClientNodeGroup)).doDrop();
}"
54205,"/** 
 * 添加任务
 */
private void addJob(Job job,JobPo jobPo) throws DupEntryException {
  if (job.isSchedule()) {
    addCronJob(jobPo);
    LOGGER.info(""String_Node_Str"",job);
  }
 else {
    appContext.getExecutableJobQueue().add(jobPo);
    LOGGER.info(""String_Node_Str"",job);
  }
}","/** 
 * 添加任务
 */
private void addJob(Job job,JobPo jobPo) throws DupEntryException {
  if (job.isSchedule()) {
    addCronJob(jobPo);
  }
 else {
    boolean needAdd2ExecutableJobQueue=true;
    String ignoreAddOnExecuting=job.getParam(""String_Node_Str"");
    if (ignoreAddOnExecuting != null && ""String_Node_Str"".equals(ignoreAddOnExecuting)) {
      if (appContext.getExecutingJobQueue().getJob(jobPo.getTaskTrackerNodeGroup(),jobPo.getTaskId()) != null) {
        needAdd2ExecutableJobQueue=false;
      }
    }
    if (needAdd2ExecutableJobQueue) {
      appContext.getExecutableJobQueue().add(jobPo);
    }
  }
  LOGGER.info(""String_Node_Str"",job);
}"
54206,"/** 
 * 添加任务
 */
private void addJob(Job job,JobPo jobPo) throws DupEntryException {
  if (job.isSchedule()) {
    addCronJob(jobPo);
    LOGGER.info(""String_Node_Str"",job);
  }
 else {
    appContext.getExecutableJobQueue().add(jobPo);
    LOGGER.info(""String_Node_Str"",job);
  }
}","/** 
 * 添加任务
 */
private void addJob(Job job,JobPo jobPo) throws DupEntryException {
  if (job.isSchedule()) {
    addCronJob(jobPo);
  }
 else {
    boolean needAdd2ExecutableJobQueue=true;
    String ignoreAddOnExecuting=job.getParam(""String_Node_Str"");
    if (ignoreAddOnExecuting != null && ""String_Node_Str"".equals(ignoreAddOnExecuting)) {
      if (appContext.getExecutingJobQueue().getJob(jobPo.getTaskTrackerNodeGroup(),jobPo.getTaskId()) != null) {
        needAdd2ExecutableJobQueue=false;
      }
    }
    if (needAdd2ExecutableJobQueue) {
      appContext.getExecutableJobQueue().add(jobPo);
    }
  }
  LOGGER.info(""String_Node_Str"",job);
}"
54207,"public final void start(){
  monitorSite=config.getParameter(""String_Node_Str"");
  if (StringUtils.isEmpty(monitorSite)) {
    return;
  }
  monitorSite=removeLastSplit(monitorSite);
  interval=config.getParameter(""String_Node_Str"",1);
  try {
    if (start.compareAndSet(false,true)) {
      collectScheduledFuture=collectScheduleExecutor.scheduleWithFixedDelay(new Runnable(){
        @Override public void run(){
          Calendar calendar=Calendar.getInstance();
          int minute=calendar.get(Calendar.MINUTE);
          try {
            if (preMinute == null) {
              preMinute=minute;
              return;
            }
            int diff=minute - preMinute;
            diff=diff < 0 ? diff + 60 : diff;
            if (diff != 0 && diff % interval == 0) {
              try {
                MonitorData monitorData=collectMonitorData();
                long seconds=SystemClock.now() / 1000;
                seconds=seconds - (seconds % 60);
                seconds=seconds - interval * 60;
                monitorData.setTimestamp(seconds * 1000);
                monitorData.setJvmMonitorData(JVMCollector.collect());
                report(monitorData);
                checkSendJVMInfo();
              }
  finally {
                preMinute=minute;
              }
            }
          }
 catch (          Throwable t) {
            LOGGER.error(""String_Node_Str"",t);
          }
        }
      }
,1,1,TimeUnit.SECONDS);
      JVMMonitor.start();
      checkSendJVMInfo();
      LOGGER.info(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
  }
}","public final void start(){
  JVMMonitor.start();
  monitorSite=config.getParameter(""String_Node_Str"");
  if (StringUtils.isEmpty(monitorSite)) {
    return;
  }
  monitorSite=removeLastSplit(monitorSite);
  interval=config.getParameter(""String_Node_Str"",1);
  try {
    if (start.compareAndSet(false,true)) {
      collectScheduledFuture=collectScheduleExecutor.scheduleWithFixedDelay(new Runnable(){
        @Override public void run(){
          Calendar calendar=Calendar.getInstance();
          int minute=calendar.get(Calendar.MINUTE);
          try {
            if (preMinute == null) {
              preMinute=minute;
              return;
            }
            int diff=minute - preMinute;
            diff=diff < 0 ? diff + 60 : diff;
            if (diff != 0 && diff % interval == 0) {
              try {
                MonitorData monitorData=collectMonitorData();
                long seconds=SystemClock.now() / 1000;
                seconds=seconds - (seconds % 60);
                seconds=seconds - interval * 60;
                monitorData.setTimestamp(seconds * 1000);
                monitorData.setJvmMonitorData(JVMCollector.collect());
                report(monitorData);
                checkSendJVMInfo();
              }
  finally {
                preMinute=minute;
              }
            }
          }
 catch (          Throwable t) {
            LOGGER.error(""String_Node_Str"",t);
          }
        }
      }
,1,1,TimeUnit.SECONDS);
      checkSendJVMInfo();
      LOGGER.info(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
  }
}"
54208,"public static void main(String[] args){
  final TaskTracker taskTracker=new TaskTracker();
  taskTracker.setJobRunnerClass(TestJobRunner.class);
  taskTracker.setRegistryAddress(""String_Node_Str"");
  taskTracker.setNodeGroup(""String_Node_Str"");
  taskTracker.setClusterName(""String_Node_Str"");
  taskTracker.setWorkThreads(10);
  taskTracker.addMasterChangeListener(new MasterChangeListenerImpl());
  taskTracker.addConfig(""String_Node_Str"",""String_Node_Str"");
  taskTracker.addConfig(""String_Node_Str"",""String_Node_Str"");
  taskTracker.start();
  Runtime.getRuntime().addShutdownHook(new Thread(new Runnable(){
    @Override public void run(){
      taskTracker.stop();
    }
  }
));
}","public static void main(String[] args){
  final TaskTracker taskTracker=new TaskTracker();
  taskTracker.setJobRunnerClass(TestJobRunner.class);
  taskTracker.setRegistryAddress(""String_Node_Str"");
  taskTracker.setNodeGroup(""String_Node_Str"");
  taskTracker.setClusterName(""String_Node_Str"");
  taskTracker.setWorkThreads(10);
  taskTracker.addMasterChangeListener(new MasterChangeListenerImpl());
  taskTracker.addConfig(""String_Node_Str"",""String_Node_Str"");
  taskTracker.start();
  Runtime.getRuntime().addShutdownHook(new Thread(new Runnable(){
    @Override public void run(){
      taskTracker.stop();
    }
  }
));
}"
54209,"@Override public void delete(JvmDataReq request){
  new DeleteSql(getSqlTemplate()).delete(getTableName()).whereSql(buildWhereSql(request));
}","@Override public void delete(JvmDataReq request){
  new DeleteSql(getSqlTemplate()).delete(getTableName()).whereSql(buildWhereSql(request)).doDelete();
}"
54210,"@Override public void delete(JvmDataReq request){
  new DeleteSql(getSqlTemplate()).delete(getTableName()).whereSql(buildWhereSql(request));
}","@Override public void delete(JvmDataReq request){
  new DeleteSql(getSqlTemplate()).delete(getTableName()).whereSql(buildWhereSql(request)).doDelete();
}"
54211,"@Override public void delete(JvmDataReq request){
  new DeleteSql(getSqlTemplate()).delete(getTableName()).whereSql(buildWhereSql(request));
}","@Override public void delete(JvmDataReq request){
  new DeleteSql(getSqlTemplate()).delete(getTableName()).whereSql(buildWhereSql(request)).doDelete();
}"
54212,"@Override public void delete(NodeOnOfflineLogPaginationReq request){
  new DeleteSql(getSqlTemplate()).delete(getTableName()).whereSql(buildWhereSql(request));
}","@Override public void delete(NodeOnOfflineLogPaginationReq request){
  new DeleteSql(getSqlTemplate()).delete(getTableName()).whereSql(buildWhereSql(request)).doDelete();
}"
54213,"@Override public JobPo getJob(String taskTrackerNodeGroup,String taskId){
  return new SelectSql(getSqlTemplate()).select().from().table(getTableName()).where(""String_Node_Str"",taskId).and(""String_Node_Str"",taskTrackerNodeGroup).single(RshHolder.JOB_PO_RSH);
}","@Override public JobPo getJob(String taskTrackerNodeGroup,String taskId){
  return new SelectSql(getSqlTemplate()).select().all().from().table(getTableName()).where(""String_Node_Str"",taskId).and(""String_Node_Str"",taskTrackerNodeGroup).single(RshHolder.JOB_PO_RSH);
}"
54214,"@Override public JobPo getJob(String taskTrackerNodeGroup,String taskId){
  return new SelectSql(getSqlTemplate()).select().from().table(getTableName(taskTrackerNodeGroup)).where(""String_Node_Str"",taskId).and(""String_Node_Str"",taskTrackerNodeGroup).single(RshHolder.JOB_PO_RSH);
}","@Override public JobPo getJob(String taskTrackerNodeGroup,String taskId){
  return new SelectSql(getSqlTemplate()).select().all().from().table(getTableName(taskTrackerNodeGroup)).where(""String_Node_Str"",taskId).and(""String_Node_Str"",taskTrackerNodeGroup).single(RshHolder.JOB_PO_RSH);
}"
54215,"@Override public JobPo get(String jobId){
  return new SelectSql(getSqlTemplate()).select().from().table(getTableName()).where(""String_Node_Str"",jobId).single(RshHolder.JOB_PO_RSH);
}","@Override public JobPo get(String jobId){
  return new SelectSql(getSqlTemplate()).select().all().from().table(getTableName()).where(""String_Node_Str"",jobId).single(RshHolder.JOB_PO_RSH);
}"
54216,"@Override public List<JobPo> getJobs(String taskTrackerIdentity){
  return new SelectSql(getSqlTemplate()).select().from().table(getTableName()).where(""String_Node_Str"",taskTrackerIdentity).list(RshHolder.JOB_PO_LIST_RSH);
}","@Override public List<JobPo> getJobs(String taskTrackerIdentity){
  return new SelectSql(getSqlTemplate()).select().all().from().table(getTableName()).where(""String_Node_Str"",taskTrackerIdentity).list(RshHolder.JOB_PO_LIST_RSH);
}"
54217,"@Override public JobPo getJob(String jobId){
  return new SelectSql(getSqlTemplate()).select().from().table(getTableName()).where(""String_Node_Str"",jobId).single(RshHolder.JOB_PO_RSH);
}","@Override public JobPo getJob(String jobId){
  return new SelectSql(getSqlTemplate()).select().all().from().table(getTableName()).where(""String_Node_Str"",jobId).single(RshHolder.JOB_PO_RSH);
}"
54218,"/** 
 * 添加Cron 任务
 */
private void addCronJob(JobPo jobPo) throws DupEntryException {
  Date nextTriggerTime=CronExpressionUtils.getNextTriggerTime(jobPo.getCronExpression());
  if (nextTriggerTime != null) {
    appContext.getCronJobQueue().add(jobPo);
    jobPo.setTriggerTime(nextTriggerTime.getTime());
    appContext.getExecutableJobQueue().add(jobPo);
  }
}","/** 
 * 添加Cron 任务
 */
private void addCronJob(JobPo jobPo) throws DupEntryException {
  Date nextTriggerTime=CronExpressionUtils.getNextTriggerTime(jobPo.getCronExpression());
  if (nextTriggerTime != null) {
    appContext.getCronJobQueue().add(jobPo);
    if (appContext.getExecutingJobQueue().getJob(jobPo.getTaskTrackerNodeGroup(),jobPo.getTaskId()) == null) {
      jobPo.setTriggerTime(nextTriggerTime.getTime());
      appContext.getExecutableJobQueue().add(jobPo);
    }
  }
}"
54219,"/** 
 * 更新任务
 */
private boolean replaceOnExist(Job job,JobPo jobPo){
  JobPo oldJobPo;
  if (job.isSchedule()) {
    oldJobPo=appContext.getCronJobQueue().getJob(job.getTaskTrackerNodeGroup(),job.getTaskId());
  }
 else {
    oldJobPo=appContext.getExecutableJobQueue().getJob(job.getTaskTrackerNodeGroup(),job.getTaskId());
  }
  if (oldJobPo != null) {
    String jobId=oldJobPo.getJobId();
    appContext.getExecutableJobQueue().remove(job.getTaskTrackerNodeGroup(),jobId);
    if (job.isSchedule()) {
      appContext.getCronJobQueue().remove(jobId);
    }
    jobPo.setJobId(jobId);
  }
  try {
    addJob(job,jobPo);
  }
 catch (  DupEntryException e) {
    LOGGER.error(""String_Node_Str"",job);
    return false;
  }
  return true;
}","/** 
 * 更新任务
 */
private boolean replaceOnExist(Job job,JobPo jobPo){
  JobPo oldJobPo;
  if (job.isSchedule()) {
    oldJobPo=appContext.getCronJobQueue().getJob(job.getTaskTrackerNodeGroup(),job.getTaskId());
  }
 else {
    oldJobPo=appContext.getExecutableJobQueue().getJob(job.getTaskTrackerNodeGroup(),job.getTaskId());
  }
  if (oldJobPo != null) {
    String jobId=oldJobPo.getJobId();
    appContext.getExecutableJobQueue().remove(job.getTaskTrackerNodeGroup(),jobId);
    if (job.isSchedule()) {
      appContext.getCronJobQueue().remove(jobId);
    }
    jobPo.setJobId(jobId);
  }
  try {
    addJob(job,jobPo);
  }
 catch (  DupEntryException e) {
    LOGGER.warn(""String_Node_Str"",job);
    return false;
  }
  return true;
}"
54220,"public InsertSql columns(String... columns){
  if (columns == null || columns.length == 0) {
    throw new JdbcException(""String_Node_Str"");
  }
  if (columnsSize > 0) {
    throw new JdbcException(""String_Node_Str"");
  }
  columnsSize=columns.length;
  sql.append(""String_Node_Str"");
  String split=""String_Node_Str"";
  for (  String column : columns) {
    sql.append(split);
    split=""String_Node_Str"";
    sql.append(""String_Node_Str"").append(column.trim()).append(""String_Node_Str"");
  }
  sql.append(""String_Node_Str"");
  return this;
}","public InsertSql columns(String... columns){
  if (columns == null || columns.length == 0) {
    throw new JdbcException(""String_Node_Str"");
  }
  if (columnsSize > 0) {
    throw new JdbcException(""String_Node_Str"");
  }
  columnsSize=columns.length;
  sql.append(""String_Node_Str"");
  String split=""String_Node_Str"";
  for (  String column : columns) {
    sql.append(split);
    split=""String_Node_Str"";
    sql.append(""String_Node_Str"").append(column.trim()).append(""String_Node_Str"");
  }
  sql.append(""String_Node_Str"");
  sql.append(""String_Node_Str"");
  split=""String_Node_Str"";
  for (int i=0; i < columnsSize; i++) {
    sql.append(split);
    split=""String_Node_Str"";
    sql.append(""String_Node_Str"");
  }
  sql.append(""String_Node_Str"");
  return this;
}"
54221,"public InsertSql values(Object... values){
  if (values == null || values.length != columnsSize) {
    throw new JdbcException(""String_Node_Str"");
  }
  params.add(values);
  if (params.size() > 1) {
    sql.append(""String_Node_Str"");
  }
  sql.append(""String_Node_Str"");
  String split=""String_Node_Str"";
  for (int i=0; i < columnsSize; i++) {
    sql.append(split);
    split=""String_Node_Str"";
    sql.append(""String_Node_Str"");
  }
  sql.append(""String_Node_Str"");
  return this;
}","public InsertSql values(Object... values){
  if (values == null || values.length != columnsSize) {
    throw new JdbcException(""String_Node_Str"");
  }
  params.add(values);
  return this;
}"
54222,"public int[] doBatchInsert(){
  if (params.size() == 0) {
    throw new JdbcException(""String_Node_Str"");
  }
  String finalSQL=sql.toString();
  if (LOGGER.isDebugEnabled()) {
    LOGGER.debug(SQLFormatter.format(finalSQL));
  }
  try {
    Object[][] objects=new Object[params.size()][];
    for (int i=0; i < params.size(); i++) {
      objects[i]=params.get(i);
    }
    return sqlTemplate.batchInsert(finalSQL,objects);
  }
 catch (  SQLException e) {
    if (e.getMessage().contains(""String_Node_Str"")) {
      throw new DupEntryException(""String_Node_Str"" + SQLFormatter.format(finalSQL),e);
    }
 else     if (e.getMessage().contains(""String_Node_Str"")) {
      throw new TableNotExistException(""String_Node_Str"" + SQLFormatter.format(finalSQL),e);
    }
    throw new JdbcException(""String_Node_Str"" + SQLFormatter.format(finalSQL),e);
  }
catch (  Exception e) {
    throw new JdbcException(""String_Node_Str"" + SQLFormatter.format(finalSQL),e);
  }
}","public int[] doBatchInsert(){
  if (params.size() == 0) {
    throw new JdbcException(""String_Node_Str"");
  }
  String finalSQL=sql.toString();
  if (LOGGER.isDebugEnabled()) {
    LOGGER.debug(SQLFormatter.format(finalSQL));
  }
  try {
    Object[][] objects=new Object[params.size()][columnsSize];
    for (int i=0; i < params.size(); i++) {
      objects[i]=params.get(i);
    }
    return sqlTemplate.batchInsert(finalSQL,objects);
  }
 catch (  SQLException e) {
    if (e.getMessage().contains(""String_Node_Str"")) {
      throw new DupEntryException(""String_Node_Str"" + SQLFormatter.format(finalSQL),e);
    }
 else     if (e.getMessage().contains(""String_Node_Str"")) {
      throw new TableNotExistException(""String_Node_Str"" + SQLFormatter.format(finalSQL),e);
    }
    throw new JdbcException(""String_Node_Str"" + SQLFormatter.format(finalSQL),e);
  }
catch (  Exception e) {
    throw new JdbcException(""String_Node_Str"" + SQLFormatter.format(finalSQL),e);
  }
}"
54223,"public void remove(K key){
  StoreTxLogPosition storeTxLogPosition=storeTxLogEngine.append(Operation.REMOVE,key);
  IndexItem<K> indexItem=index.removeIndexItem(storeTxLogPosition,key);
  if (indexItem != null) {
    dataBlockEngine.remove(storeTxLogPosition,indexItem);
  }
  dataCache.remove(key);
}","public void remove(K key){
  dataCache.remove(key);
  StoreTxLogPosition storeTxLogPosition=storeTxLogEngine.append(Operation.REMOVE,key);
  IndexItem<K> indexItem=index.removeIndexItem(storeTxLogPosition,key);
  if (indexItem != null) {
    dataBlockEngine.remove(storeTxLogPosition,indexItem);
  }
}"
54224,"private void singleResultsProcess(List<TaskTrackerJobResult> results){
  TaskTrackerJobResult result=results.get(0);
  if (!needRetry(result)) {
    if (result.getJobWrapper().getJob().isNeedFeedback()) {
      clientNotifier.send(results);
    }
 else {
      jobFinishHandler.onComplete(results);
    }
  }
 else {
    jobFinishHandler.onComplete(results);
  }
}","private void singleResultsProcess(List<TaskTrackerJobResult> results){
  TaskTrackerJobResult result=results.get(0);
  if (!needRetry(result)) {
    if (result.getJobWrapper().getJob().isNeedFeedback()) {
      clientNotifier.send(results);
    }
 else {
      jobFinishHandler.onComplete(results);
    }
  }
 else {
    retryHandler.onComplete(results);
  }
}"
54225,"@Override public void afterPropertiesSet() throws Exception {
  List<TableSchema> tableSchemas=getTableSchema(""String_Node_Str"");
  for (  TableSchema tableSchema : tableSchemas) {
    commonRepo.executeSQL(tableSchema.table);
    if (CollectionUtils.isEmpty(tableSchema.indexes)) {
      continue;
    }
    for (    String index : tableSchema.indexes) {
      try {
        commonRepo.executeSQL(index);
      }
 catch (      BadSqlGrammarException e) {
        if (!e.getMessage().contains(""String_Node_Str"")) {
          throw e;
        }
      }
    }
  }
}","@Override public void afterPropertiesSet() throws Exception {
  List<TableSchema> tableSchemas=getTableSchema(""String_Node_Str"");
  for (  TableSchema tableSchema : tableSchemas) {
    commonRepo.executeSQL(tableSchema.table);
    if (CollectionUtils.isEmpty(tableSchema.indexes)) {
      continue;
    }
    for (    String index : tableSchema.indexes) {
      try {
        commonRepo.executeSQL(index);
      }
 catch (      BadSqlGrammarException e) {
        if (isDuplicateIndex(e)) {
        }
 else {
          throw e;
        }
      }
    }
  }
}"
54226,"public final void stop(){
  try {
    if (start.compareAndSet(true,false)) {
      monitorDataCollectScheduledFuture.cancel(true);
      monitorDataCollectScheduleExecutor.shutdown();
      JVMMonitor.stop();
      LOGGER.info(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
  }
}","public final void stop(){
  try {
    if (start.compareAndSet(true,false)) {
      collectScheduledFuture.cancel(true);
      collectScheduleExecutor.shutdown();
      JVMMonitor.stop();
      LOGGER.info(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
  }
}"
54227,"public final void start(){
  monitorSite=config.getParameter(""String_Node_Str"");
  if (StringUtils.isEmpty(monitorSite)) {
    return;
  }
  try {
    if (start.compareAndSet(false,true)) {
      monitorDataCollectScheduledFuture=monitorDataCollectScheduleExecutor.scheduleWithFixedDelay(new Runnable(){
        @Override public void run(){
          try {
            MonitorData monitorData=collectMonitorData();
            long seconds=SystemClock.now() / 1000;
            long residue=seconds % INTERVAL;
            seconds=seconds - residue;
            monitorData.setTimestamp(seconds * 1000);
            monitorData.setJvmMonitorData(JVMCollector.collect());
            report(monitorData);
            checkSendJVMInfo();
          }
 catch (          Throwable t) {
            LOGGER.error(""String_Node_Str"",t);
          }
        }
      }
,5,INTERVAL,TimeUnit.SECONDS);
      JVMMonitor.start();
      checkSendJVMInfo();
      LOGGER.info(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
  }
}","public final void start(){
  monitorSite=config.getParameter(""String_Node_Str"");
  if (StringUtils.isEmpty(monitorSite)) {
    return;
  }
  try {
    if (start.compareAndSet(false,true)) {
      collectScheduledFuture=collectScheduleExecutor.scheduleWithFixedDelay(new Runnable(){
        @Override public void run(){
          Calendar calendar=Calendar.getInstance();
          int minute=calendar.get(Calendar.MINUTE);
          try {
            if (preMinute == null) {
              preMinute=minute;
              return;
            }
            int diff=minute - preMinute;
            diff=diff < 0 ? diff + 60 : diff;
            if (diff >= interval) {
              MonitorData monitorData=collectMonitorData();
              long seconds=SystemClock.now() / 1000;
              seconds=seconds - (seconds % 60);
              seconds=seconds - interval * 60;
              monitorData.setTimestamp(seconds * 1000);
              monitorData.setJvmMonitorData(JVMCollector.collect());
              report(monitorData);
              checkSendJVMInfo();
              preMinute=minute;
            }
          }
 catch (          Throwable t) {
            LOGGER.error(""String_Node_Str"",t);
          }
        }
      }
,1,1,TimeUnit.SECONDS);
      JVMMonitor.start();
      checkSendJVMInfo();
      LOGGER.info(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    LOGGER.error(""String_Node_Str"",e);
  }
}"
54228,"@Override public void run(){
  try {
    MonitorData monitorData=collectMonitorData();
    long seconds=SystemClock.now() / 1000;
    long residue=seconds % INTERVAL;
    seconds=seconds - residue;
    monitorData.setTimestamp(seconds * 1000);
    monitorData.setJvmMonitorData(JVMCollector.collect());
    report(monitorData);
    checkSendJVMInfo();
  }
 catch (  Throwable t) {
    LOGGER.error(""String_Node_Str"",t);
  }
}","@Override public void run(){
  Calendar calendar=Calendar.getInstance();
  int minute=calendar.get(Calendar.MINUTE);
  try {
    if (preMinute == null) {
      preMinute=minute;
      return;
    }
    int diff=minute - preMinute;
    diff=diff < 0 ? diff + 60 : diff;
    if (diff >= interval) {
      MonitorData monitorData=collectMonitorData();
      long seconds=SystemClock.now() / 1000;
      seconds=seconds - (seconds % 60);
      seconds=seconds - interval * 60;
      monitorData.setTimestamp(seconds * 1000);
      monitorData.setJvmMonitorData(JVMCollector.collect());
      report(monitorData);
      checkSendJVMInfo();
      preMinute=minute;
    }
  }
 catch (  Throwable t) {
    LOGGER.error(""String_Node_Str"",t);
  }
}"
54229,"public AbstractPreLoader(final Application application){
  if (start.compareAndSet(false,true)) {
    loadSize=application.getConfig().getParameter(""String_Node_Str"",500);
    factor=application.getConfig().getParameter(""String_Node_Str"",0.5);
    scheduledFuture=LOAD_EXECUTOR_SERVICE.scheduleWithFixedDelay(new Runnable(){
      @Override public void run(){
        for (        String loadTaskTrackerNodeGroup : LOAD_SIGNAL) {
          JobPriorityBlockingQueue queue=JOB_MAP.get(loadTaskTrackerNodeGroup);
          if (queue.size() / loadSize < factor) {
            List<JobPo> loads=load(loadTaskTrackerNodeGroup,curSequence * (loadSize - queue.size()));
            if (CollectionUtils.isNotEmpty(loads)) {
              for (              JobPo load : loads) {
                if (!queue.offer(load)) {
                  break;
                }
              }
            }
          }
          LOAD_SIGNAL.remove(loadTaskTrackerNodeGroup);
        }
      }
    }
,500,500,TimeUnit.MILLISECONDS);
  }
  application.getEventCenter().subscribe(new EventSubscriber(application.getConfig().getIdentity() + ""String_Node_Str"",new Observer(){
    @Override public void onObserved(    EventInfo eventInfo){
      setCurSequence(application);
    }
  }
),EcTopic.NODE_ADD,EcTopic.NODE_REMOVE);
  setCurSequence(application);
}","public AbstractPreLoader(final Application application){
  if (start.compareAndSet(false,true)) {
    loadSize=application.getConfig().getParameter(""String_Node_Str"",300);
    factor=application.getConfig().getParameter(""String_Node_Str"",0.2);
    scheduledFuture=LOAD_EXECUTOR_SERVICE.scheduleWithFixedDelay(new Runnable(){
      @Override public void run(){
        for (        String loadTaskTrackerNodeGroup : LOAD_SIGNAL) {
          JobPriorityBlockingQueue queue=JOB_MAP.get(loadTaskTrackerNodeGroup);
          if (queue.size() / loadSize < factor) {
            List<JobPo> loads=load(loadTaskTrackerNodeGroup,curSequence * (loadSize - queue.size()));
            if (CollectionUtils.isNotEmpty(loads)) {
              for (              JobPo load : loads) {
                if (!queue.offer(load)) {
                  break;
                }
              }
            }
          }
          LOAD_SIGNAL.remove(loadTaskTrackerNodeGroup);
        }
      }
    }
,500,500,TimeUnit.MILLISECONDS);
  }
  application.getEventCenter().subscribe(new EventSubscriber(application.getConfig().getIdentity() + ""String_Node_Str"",new Observer(){
    @Override public void onObserved(    EventInfo eventInfo){
      setCurSequence(application);
    }
  }
),EcTopic.NODE_ADD,EcTopic.NODE_REMOVE);
  setCurSequence(application);
}"
54230,"public void stop(){
  FIXED_EXECUTOR_SERVICE.shutdown();
}","public void stop(){
  if (start) {
    start=false;
    scheduledFuture.cancel(true);
    FIXED_EXECUTOR_SERVICE.shutdown();
  }
}"
54231,"public void start(){
  ScheduledFuture<?> scheduledFuture=FIXED_EXECUTOR_SERVICE.scheduleWithFixedDelay(new Runnable(){
    @Override public void run(){
      try {
        List<JobPo> jobPos=getJobRepository().getDeadJob(MAX_DEAD_CHECK_TIME);
        if (jobPos != null && jobPos.size() > 0) {
          List<Node> nodes=application.getNodeManager().getNodeList(NodeType.TASK_TRACKER);
          HashSet<String> identities=new HashSet<String>();
          if (CollectionUtils.isNotEmpty(nodes)) {
            for (            Node node : nodes) {
              identities.add(node.getIdentity());
            }
          }
          Map<TaskTrackerNode,List<String>> timeoutMap=new HashMap<TaskTrackerNode,List<String>>();
          for (          JobPo jobPo : jobPos) {
            if (!identities.contains(jobPo.getTaskTracker())) {
              fixedDeadJob(jobPo);
            }
 else {
              if (System.currentTimeMillis() - jobPo.getGmtModify() > MAX_TIME_OUT) {
                TaskTrackerNode taskTrackerNode=new TaskTrackerNode(jobPo.getTaskTracker(),jobPo.getTaskTrackerNodeGroup());
                List<String> jobIds=timeoutMap.get(taskTrackerNode);
                if (jobIds == null) {
                  jobIds=new ArrayList<String>();
                  timeoutMap.put(taskTrackerNode,jobIds);
                }
                jobIds.add(jobPo.getJobId());
              }
            }
          }
          if (CollectionUtils.isNotEmpty(timeoutMap)) {
            RemotingServerDelegate remotingServer=application.getAttribute(Constants.REMOTING_SERVER);
            for (            Map.Entry<TaskTrackerNode,List<String>> entry : timeoutMap.entrySet()) {
              TaskTrackerNode taskTrackerNode=entry.getKey();
              ChannelWrapper channelWrapper=channelManager.getChannel(taskTrackerNode.getNodeGroup(),NodeType.TASK_TRACKER,taskTrackerNode.getIdentity());
              if (channelWrapper != null && channelWrapper.getChannel() != null && channelWrapper.isOpen()) {
                JobAskRequest requestBody=commandWrapper.wrapper(new JobAskRequest());
                requestBody.setJobIds(entry.getValue());
                RemotingCommand request=RemotingCommand.createRequestCommand(JobProtos.RequestCode.JOB_ASK.code(),requestBody);
                RemotingCommand response=remotingServer.invokeSync(channelWrapper.getChannel(),request);
                if (response != null && RemotingProtos.ResponseCode.SUCCESS.code() == response.getCode()) {
                  JobAskResponse responseBody=response.getBody();
                  List<String> deadJobIds=responseBody.getJobIds();
                  if (deadJobIds != null) {
                    Thread.sleep(1000L);
                    for (                    String deadJobId : deadJobIds) {
                      JobPo jobPo=new JobPo();
                      jobPo.setJobId(deadJobId);
                      fixedDeadJob(jobPo);
                    }
                  }
                }
              }
            }
          }
        }
      }
 catch (      Throwable t) {
        LOGGER.error(t.getMessage(),t);
      }
    }
  }
,2 * 60,3 * 60,TimeUnit.SECONDS);
}","public void start(){
  if (start) {
    return;
  }
  start=true;
  scheduledFuture=FIXED_EXECUTOR_SERVICE.scheduleWithFixedDelay(new Runnable(){
    @Override public void run(){
      try {
        List<JobPo> jobPos=getJobRepository().getDeadJob(MAX_DEAD_CHECK_TIME);
        if (jobPos != null && jobPos.size() > 0) {
          List<Node> nodes=application.getNodeManager().getNodeList(NodeType.TASK_TRACKER);
          HashSet<String> identities=new HashSet<String>();
          if (CollectionUtils.isNotEmpty(nodes)) {
            for (            Node node : nodes) {
              identities.add(node.getIdentity());
            }
          }
          Map<TaskTrackerNode,List<String>> timeoutMap=new HashMap<TaskTrackerNode,List<String>>();
          for (          JobPo jobPo : jobPos) {
            if (!identities.contains(jobPo.getTaskTracker())) {
              fixedDeadJob(jobPo);
            }
 else {
              if (System.currentTimeMillis() - jobPo.getGmtModify() > MAX_TIME_OUT) {
                TaskTrackerNode taskTrackerNode=new TaskTrackerNode(jobPo.getTaskTracker(),jobPo.getTaskTrackerNodeGroup());
                List<String> jobIds=timeoutMap.get(taskTrackerNode);
                if (jobIds == null) {
                  jobIds=new ArrayList<String>();
                  timeoutMap.put(taskTrackerNode,jobIds);
                }
                jobIds.add(jobPo.getJobId());
              }
            }
          }
          if (CollectionUtils.isNotEmpty(timeoutMap)) {
            RemotingServerDelegate remotingServer=application.getAttribute(Constants.REMOTING_SERVER);
            for (            Map.Entry<TaskTrackerNode,List<String>> entry : timeoutMap.entrySet()) {
              TaskTrackerNode taskTrackerNode=entry.getKey();
              ChannelWrapper channelWrapper=channelManager.getChannel(taskTrackerNode.getNodeGroup(),NodeType.TASK_TRACKER,taskTrackerNode.getIdentity());
              if (channelWrapper != null && channelWrapper.getChannel() != null && channelWrapper.isOpen()) {
                JobAskRequest requestBody=commandWrapper.wrapper(new JobAskRequest());
                requestBody.setJobIds(entry.getValue());
                RemotingCommand request=RemotingCommand.createRequestCommand(JobProtos.RequestCode.JOB_ASK.code(),requestBody);
                RemotingCommand response=remotingServer.invokeSync(channelWrapper.getChannel(),request);
                if (response != null && RemotingProtos.ResponseCode.SUCCESS.code() == response.getCode()) {
                  JobAskResponse responseBody=response.getBody();
                  List<String> deadJobIds=responseBody.getJobIds();
                  if (deadJobIds != null) {
                    Thread.sleep(1000L);
                    for (                    String deadJobId : deadJobIds) {
                      JobPo jobPo=new JobPo();
                      jobPo.setJobId(deadJobId);
                      fixedDeadJob(jobPo);
                    }
                  }
                }
              }
            }
          }
        }
      }
 catch (      Throwable t) {
        LOGGER.error(t.getMessage(),t);
      }
    }
  }
,2 * 60,3 * 60,TimeUnit.SECONDS);
}"
54232,"public void addNodes(List<Node> nodes){
  Node newMaster=null;
  for (  Node node : nodes) {
    if (newMaster == null) {
      newMaster=node;
    }
 else {
      if (newMaster.getCreateTime() > node.getCreateTime()) {
        newMaster=node;
      }
    }
  }
  if (master != newMaster) {
    master=newMaster;
    notifyListener();
  }
}","public void addNodes(List<Node> nodes){
  Node newMaster=null;
  for (  Node node : nodes) {
    if (newMaster == null) {
      newMaster=node;
    }
 else {
      if (newMaster.getCreateTime() > node.getCreateTime()) {
        newMaster=node;
      }
    }
  }
  if (master == null || !master.equals(newMaster)) {
    master=newMaster;
    notifyListener();
  }
}"
54233,"public void addNodes(List<Node> nodes){
  Node newMaster=null;
  for (  Node node : nodes) {
    if (newMaster == null) {
      newMaster=node;
    }
 else {
      if (newMaster.getCreateTime() > node.getCreateTime()) {
        newMaster=node;
      }
    }
  }
  if (master == null || !master.equals(newMaster)) {
    master=newMaster;
    notifyListener();
  }
}","public void addNodes(List<Node> nodes){
  Node newMaster=null;
  for (  Node node : nodes) {
    if (newMaster == null) {
      newMaster=node;
    }
 else {
      if (newMaster.getCreateTime() > node.getCreateTime()) {
        newMaster=node;
      }
    }
  }
  addNode(newMaster);
}"
54234,"public static void removeNode(Node removedNode){
  if (master != null) {
    if (master.getIdentity().equals(removedNode.getIdentity())) {
      List<Node> nodes=NodeManager.getNodeList(Application.Config.getNodeType());
      if (CollectionUtils.isNotEmpty(nodes)) {
        Node newMaster=null;
        for (        Node node : nodes) {
          if (newMaster == null) {
            newMaster=node;
          }
 else {
            if (newMaster.getCreateTime() > node.getCreateTime()) {
              newMaster=node;
            }
          }
        }
        master=newMaster;
        notifyListener();
      }
    }
  }
}","public static void removeNode(Node removedNode){
  if (master != null) {
    if (master.getIdentity().equals(removedNode.getIdentity())) {
      List<Node> nodes=NodeManager.getNodeList(Application.Config.getNodeType(),Application.Config.getNodeGroup());
      if (CollectionUtils.isNotEmpty(nodes)) {
        Node newMaster=null;
        for (        Node node : nodes) {
          if (newMaster == null) {
            newMaster=node;
          }
 else {
            if (newMaster.getCreateTime() > node.getCreateTime()) {
              newMaster=node;
            }
          }
        }
        master=newMaster;
        notifyListener();
      }
    }
  }
}"
54235,"@Override public Response submitJob(List<Job> jobs){
  Response response=super.submitJob(jobs);
  if (!response.isSuccess()) {
    List<Line> lines=new ArrayList<Line>();
    for (    Job job : response.getFailedJobs()) {
      String line=JsonUtils.objectToJsonString(job);
      lines.add(new Line(line));
    }
    try {
      if (fileAccessor == null) {
        throw new RuntimeException(""String_Node_Str"");
      }
      fileAccessor.addLines(lines);
      response.setSuccess(true);
      response.setCode(ResponseCode.FAILED_AND_SAVE_FILE);
    }
 catch (    FileException e) {
      response.setSuccess(false);
      response.setMsg(e.getMessage());
    }
  }
  return response;
}","@Override public Response submitJob(List<Job> jobs){
  Response response=superSubmitJob(jobs);
  if (!response.isSuccess()) {
    List<Line> lines=new ArrayList<Line>();
    for (    Job job : response.getFailedJobs()) {
      String line=JsonUtils.objectToJsonString(job);
      lines.add(new Line(line));
    }
    try {
      if (fileAccessor == null) {
        throw new RuntimeException(""String_Node_Str"");
      }
      fileAccessor.addLines(lines);
      response.setSuccess(true);
      response.setCode(ResponseCode.FAILED_AND_SAVE_FILE);
    }
 catch (    FileException e) {
      response.setSuccess(false);
      response.setMsg(e.getMessage());
    }
  }
  return response;
}"
54236,"@Override protected void nodeStart(){
  retryScheduler=new RetryScheduler<Job>(30){
    @Override protected boolean isRemotingEnable(){
      return isServerEnable();
    }
    @Override protected boolean retry(    List<Job> jobs){
      return submitJob(jobs).isSuccess();
    }
  }
;
  fileAccessor=retryScheduler.getFileAccessor();
  super.nodeStart();
  retryScheduler.start();
}","@Override protected void nodeStart(){
  retryScheduler=new RetryScheduler<Job>(30){
    @Override protected boolean isRemotingEnable(){
      return isServerEnable();
    }
    @Override protected boolean retry(    List<Job> jobs){
      return superSubmitJob(jobs).isSuccess();
    }
  }
;
  fileAccessor=retryScheduler.getFileAccessor();
  super.nodeStart();
  retryScheduler.start();
}"
54237,"@Override protected boolean retry(List<Job> jobs){
  return submitJob(jobs).isSuccess();
}","@Override protected boolean retry(List<Job> jobs){
  return superSubmitJob(jobs).isSuccess();
}"
54238,"public static void main(String[] args){
  final JobClient jobClient=new RetryJobClient();
  jobClient.setNodeGroup(""String_Node_Str"");
  jobClient.setClusterName(""String_Node_Str"");
  jobClient.setZookeeperAddress(""String_Node_Str"");
  jobClient.setJobInfoSavePath(Constants.USER_HOME + ""String_Node_Str"");
  jobClient.setJobFinishedHandler(new JobFinishedHandler(){
    @Override public void handle(    List<JobResult> jobResults){
    }
  }
);
  jobClient.addMasterNodeChangeListener(new MasterListener());
  jobClient.start();
  Job job=new Job();
  job.setTaskId(UUID.randomUUID().toString());
  job.setParam(""String_Node_Str"",1111);
  job.setTaskTrackerNodeGroup(""String_Node_Str"");
  Response response=jobClient.submitJob(job);
  try {
    Thread.sleep(2000L);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  new Thread(new Runnable(){
    @Override public void run(){
      Integer i=0;
      while (true) {
        try {
          try {
            Thread.sleep(5000L);
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
          Job job=new Job();
          job.setTaskId((i++) + ""String_Node_Str"");
          Map<String,String> extParams=new HashMap<String,String>();
          extParams.put(""String_Node_Str"",""String_Node_Str"");
          job.setExtParams(extParams);
          job.setTaskTrackerNodeGroup(""String_Node_Str"");
          Response response=jobClient.submitJob(job);
          System.out.println(response);
          if (i > 1000000) {
            break;
          }
        }
 catch (        Exception t) {
          t.printStackTrace();
        }
      }
    }
  }
).start();
  Runtime.getRuntime().addShutdownHook(new Thread(new Runnable(){
    @Override public void run(){
      jobClient.stop();
    }
  }
));
  try {
    System.in.read();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public static void main(String[] args){
  final JobClient jobClient=new RetryJobClient();
  jobClient.setNodeGroup(""String_Node_Str"");
  jobClient.setClusterName(""String_Node_Str"");
  jobClient.setZookeeperAddress(""String_Node_Str"");
  jobClient.setJobInfoSavePath(Constants.USER_HOME + ""String_Node_Str"");
  jobClient.setJobFinishedHandler(new JobFinishedHandler(){
    @Override public void handle(    List<JobResult> jobResults){
    }
  }
);
  jobClient.addMasterNodeChangeListener(new MasterListener());
  jobClient.start();
  Job job=new Job();
  job.setTaskId(UUID.randomUUID().toString());
  job.setParam(""String_Node_Str"",""String_Node_Str"");
  job.setTaskTrackerNodeGroup(""String_Node_Str"");
  Response response=jobClient.submitJob(job);
  try {
    Thread.sleep(2000L);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  new Thread(new Runnable(){
    @Override public void run(){
      Integer i=0;
      while (true) {
        try {
          try {
            Thread.sleep(5000L);
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
          Job job=new Job();
          job.setTaskId((i++) + ""String_Node_Str"");
          Map<String,String> extParams=new HashMap<String,String>();
          extParams.put(""String_Node_Str"",""String_Node_Str"");
          job.setExtParams(extParams);
          job.setTaskTrackerNodeGroup(""String_Node_Str"");
          Response response=jobClient.submitJob(job);
          System.out.println(response);
          if (i > 1000000) {
            break;
          }
        }
 catch (        Exception t) {
          t.printStackTrace();
        }
      }
    }
  }
).start();
  Runtime.getRuntime().addShutdownHook(new Thread(new Runnable(){
    @Override public void run(){
      jobClient.stop();
    }
  }
));
  try {
    System.in.read();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}"
54239,"public static void addNode(Node node){
  if ((Application.Config.getNodeType().equals(node.getNodeType()) && Application.Config.getNodeGroup().equals(node.getGroup())) || (NodeType.JOB_TRACKER.equals(Application.Config.getNodeType()))) {
    List<Node> nodeList=NODES.get(node.getNodeType());
    if (CollectionUtils.isEmpty(nodeList)) {
      nodeList=new CopyOnWriteArrayList<Node>();
      NODES.put(node.getNodeType(),nodeList);
    }
    nodeList.add(node);
    LOGGER.info(""String_Node_Str"" + node);
  }
}","public static void addNode(Node node){
  if ((NodeType.JOB_TRACKER.equals(node.getNodeType())) || ((Application.Config.getNodeType().equals(node.getNodeType()) && Application.Config.getNodeGroup().equals(node.getGroup())) || (NodeType.JOB_TRACKER.equals(Application.Config.getNodeType())))) {
    List<Node> nodeList=NODES.get(node.getNodeType());
    if (CollectionUtils.isEmpty(nodeList)) {
      nodeList=new CopyOnWriteArrayList<Node>();
      NODES.put(node.getNodeType(),nodeList);
    }
    nodeList.add(node);
    LOGGER.info(""String_Node_Str"" + node);
  }
}"
54240,"public static Node parse(String fullPath){
  Node node=new Node();
  node.setPath(fullPath);
  String nodeType=getMatcher(getBasePath() + ""String_Node_Str"",fullPath);
  node.setNodeType(NodeType.valueOf(nodeType));
  String url=getMatcher(getBasePath() + ""String_Node_Str"" + nodeType+ ""String_Node_Str""+ nodeType+ ""String_Node_Str"",fullPath);
  String address=url.split(""String_Node_Str"")[0];
  String ip=address.split(""String_Node_Str"")[0];
  node.setIp(ip);
  if (address.contains(""String_Node_Str"")) {
    String port=address.split(""String_Node_Str"")[1];
    if (port != null && ""String_Node_Str"".equals(port.trim())) {
      node.setPort(Integer.valueOf(port));
    }
  }
  String params=url.split(""String_Node_Str"")[1];
  String[] paramArr=params.split(""String_Node_Str"");
  for (  String paramEntry : paramArr) {
    String key=paramEntry.split(""String_Node_Str"")[0];
    String value=paramEntry.split(""String_Node_Str"")[1];
    if (""String_Node_Str"".equals(key)) {
      node.setGroup(value);
    }
 else     if (""String_Node_Str"".equals(key)) {
      node.setThreads(Integer.valueOf(value));
    }
 else     if (""String_Node_Str"".equals(key)) {
      node.setIdentity(value);
    }
 else     if (""String_Node_Str"".equals(key)) {
      node.setCreateTime(Long.valueOf(value));
    }
 else     if (""String_Node_Str"".equals(key)) {
      node.setAvailable(Boolean.valueOf(value));
    }
 else     if (""String_Node_Str"".equals(key)) {
      String[] nodeTypes=value.split(""String_Node_Str"");
      for (      String type : nodeTypes) {
        node.addListenNodeType(NodeType.valueOf(type));
      }
    }
  }
  return node;
}","public static Node parse(String fullPath){
  Node node=new Node();
  node.setPath(fullPath);
  String nodeType=getMatcher(getBasePath() + ""String_Node_Str"",fullPath);
  node.setNodeType(NodeType.valueOf(nodeType));
  String url=getMatcher(getBasePath() + ""String_Node_Str"" + nodeType+ ""String_Node_Str""+ nodeType+ ""String_Node_Str"",fullPath);
  String address=url.split(""String_Node_Str"")[0];
  String ip=address.split(""String_Node_Str"")[0];
  node.setIp(ip);
  if (address.contains(""String_Node_Str"")) {
    String port=address.split(""String_Node_Str"")[1];
    if (port != null && !""String_Node_Str"".equals(port.trim())) {
      node.setPort(Integer.valueOf(port));
    }
  }
  String params=url.split(""String_Node_Str"")[1];
  String[] paramArr=params.split(""String_Node_Str"");
  for (  String paramEntry : paramArr) {
    String key=paramEntry.split(""String_Node_Str"")[0];
    String value=paramEntry.split(""String_Node_Str"")[1];
    if (""String_Node_Str"".equals(key)) {
      node.setGroup(value);
    }
 else     if (""String_Node_Str"".equals(key)) {
      node.setThreads(Integer.valueOf(value));
    }
 else     if (""String_Node_Str"".equals(key)) {
      node.setIdentity(value);
    }
 else     if (""String_Node_Str"".equals(key)) {
      node.setCreateTime(Long.valueOf(value));
    }
 else     if (""String_Node_Str"".equals(key)) {
      node.setAvailable(Boolean.valueOf(value));
    }
 else     if (""String_Node_Str"".equals(key)) {
      String[] nodeTypes=value.split(""String_Node_Str"");
      for (      String type : nodeTypes) {
        node.addListenNodeType(NodeType.valueOf(type));
      }
    }
  }
  return node;
}"
54241,"@Override public boolean equals(Object o){
  if (o.getClass() != FuseBind.class)   return false;
  FuseBind b=(FuseBind)o;
  if (b.source != null) {
    if (!b.source.equals(this.source))     return false;
  }
 else   if (this.source != null)   return false;
  if (b.mountpoint != null) {
    if (!b.mountpoint.equals(this.mountpoint))     return false;
  }
 else   if (this.mountpoint != null)   return false;
  return true;
}","@Override public boolean equals(Object o){
  if (o == null || o.getClass() != FuseBind.class)   return false;
  FuseBind b=(FuseBind)o;
  if (b.source != null) {
    if (!b.source.equals(this.source))     return false;
  }
 else   if (this.source != null)   return false;
  if (b.mountpoint != null) {
    if (!b.mountpoint.equals(this.mountpoint))     return false;
  }
 else   if (this.mountpoint != null)   return false;
  return true;
}"
54242,"@Override public boolean equals(Object o){
  return o.getClass() == CVE.class && id.equals(((CVE)o).id);
}","@Override public boolean equals(Object o){
  if (o == null) {
    return false;
  }
  return o.getClass() == this.getClass() && id.equals(((CVE)o).id);
}"
54243,"@Override public boolean equals(Object o){
  return o.getClass() == Link.class && url.equals(((Link)o).url);
}","@Override public boolean equals(Object o){
  if (o == null) {
    return false;
  }
  return o.getClass() == this.getClass() && url.equals(((Link)o).url);
}"
54244,"@Override public boolean equals(Object o){
  return o.getClass() == OSVDB.class && id == ((OSVDB)o).id;
}","@Override public boolean equals(Object o){
  if (o == null) {
    return false;
  }
  return o.getClass() == this.getClass() && id == ((OSVDB)o).id;
}"
54245,"public static void initCore() throws DaemonException, SuException {
  if (mCoreInitialized)   return;
  String socket_path=getCorePath() + ""String_Node_Str"";
  if (!Client.isConnected()) {
    if (!Client.Connect(socket_path)) {
      startCoreDaemon();
      if (!Client.Connect(socket_path))       throw new DaemonException(""String_Node_Str"");
    }
  }
  if (!Client.isAuthenticated() && !Client.Login(""String_Node_Str"",""String_Node_Str"")) {
    throw new DaemonException(""String_Node_Str"");
  }
  if (!Client.LoadHandlers()) {
    throw new DaemonException(""String_Node_Str"");
  }
  ChildManager.storeHandlers();
  reloadTools();
  mCoreInitialized=true;
  Services.getNetworkRadar().onAutoScanChanged();
}","public static void initCore() throws DaemonException, SuException {
  if (mCoreInitialized)   return;
  String socket_path=getCorePath() + ""String_Node_Str"";
  if (!Client.isConnected()) {
    if (!Client.Connect(socket_path)) {
      startCoreDaemon();
      if (!Client.Connect(socket_path))       throw new DaemonException(""String_Node_Str"");
    }
  }
  if (!Client.isAuthenticated() && !Client.Login(""String_Node_Str"",""String_Node_Str"")) {
    throw new DaemonException(""String_Node_Str"");
  }
  if (!Client.LoadHandlers()) {
    throw new DaemonException(""String_Node_Str"");
  }
  ChildManager.storeHandlers();
  reloadTools();
  mCoreInitialized=true;
  Services.getNetworkRadar().onAutoScanChanged();
  getNetwork().onCoreAttached();
}"
54246,"private static void uncaughtReloadNetworkMapping() throws UnknownHostException, SocketException {
  mNetwork=new Network(mContext,mIfname);
  mIfname=mNetwork.getInterface().getName();
  reset();
  mInitialized=true;
  Network.watchForIssue480();
}","private static void uncaughtReloadNetworkMapping() throws UnknownHostException, SocketException {
  mNetwork=new Network(mContext,mIfname);
  mIfname=mNetwork.getInterface().getName();
  reset();
  mInitialized=true;
}"
54247,"public boolean initNetworkInterface(String iface){
  InterfaceAddress ifaceAddress=null;
  try {
    if (iface == null)     iface=getAvailableInterfaces().get(0);
    mInterface=NetworkInterface.getByName(iface);
    if (mInterface.getInterfaceAddresses().isEmpty()) {
      return false;
    }
    for (    InterfaceAddress ia : mInterface.getInterfaceAddresses()) {
      if (Patterns.IP_ADDRESS.matcher(ia.getAddress().getHostAddress()).matches()) {
        ifaceAddress=ia;
        Logger.warning(""String_Node_Str"" + ia.getAddress().getHostAddress() + ""String_Node_Str""+ Short.toString(ia.getNetworkPrefixLength()));
        break;
      }
 else       Logger.error(""String_Node_Str"" + ia.getAddress().getHostAddress() + ""String_Node_Str""+ Short.toString(ia.getNetworkPrefixLength()));
    }
    if (ifaceAddress == null) {
      return false;
    }
    SubnetUtils su=new SubnetUtils(ifaceAddress.getAddress().getHostAddress() + ""String_Node_Str"" + Short.toString(ifaceAddress.getNetworkPrefixLength()));
    mLocal=new IP4Address(su.getInfo().getAddress());
    mNetmask=new IP4Address(su.getInfo().getNetmask());
    mBase=new IP4Address(su.getInfo().getNetworkAddress());
    String gateway=getSystemGateway(mInterface.getDisplayName());
    if (gateway == null) {
      mGateway=null;
      Logger.debug(""String_Node_Str"");
    }
 else {
      mGateway=new IP4Address(gateway);
      Logger.debug(""String_Node_Str"" + gateway);
      Logger.debug(""String_Node_Str"" + mGateway);
    }
    return true;
  }
 catch (  Exception e) {
    Logger.error(""String_Node_Str"" + e.getLocalizedMessage());
  }
  return false;
}","public boolean initNetworkInterface(String iface){
  InterfaceAddress ifaceAddress=null;
  try {
    if (iface == null)     iface=getAvailableInterfaces().get(0);
    mInterface=NetworkInterface.getByName(iface);
    if (mInterface.getInterfaceAddresses().isEmpty()) {
      return false;
    }
    for (    InterfaceAddress ia : mInterface.getInterfaceAddresses()) {
      if (Patterns.IP_ADDRESS.matcher(ia.getAddress().getHostAddress()).matches()) {
        ifaceAddress=ia;
        Logger.warning(""String_Node_Str"" + ia.getAddress().getHostAddress() + ""String_Node_Str""+ Short.toString(ia.getNetworkPrefixLength()));
        break;
      }
 else       Logger.error(""String_Node_Str"" + ia.getAddress().getHostAddress() + ""String_Node_Str""+ Short.toString(ia.getNetworkPrefixLength()));
    }
    if (ifaceAddress == null) {
      return false;
    }
    SubnetUtils su=new SubnetUtils(ifaceAddress.getAddress().getHostAddress() + ""String_Node_Str"" + Short.toString(ifaceAddress.getNetworkPrefixLength()));
    mLocal=new IP4Address(su.getInfo().getAddress());
    mNetmask=new IP4Address(su.getInfo().getNetmask());
    mBase=new IP4Address(su.getInfo().getNetworkAddress());
    updateGateway();
    return true;
  }
 catch (  Exception e) {
    Logger.error(""String_Node_Str"" + e.getLocalizedMessage());
  }
  return false;
}"
54248,"public ToolBox(){
  raw=new Raw();
  shell=new Shell();
  ruby=new Ruby();
  nmap=new NMap();
  hydra=new Hydra();
  arpSpoof=new ArpSpoof();
  ettercap=new Ettercap();
  fusemounts=new Fusemounts();
  ipTables=new IPTables();
  tcpDump=new TcpDump();
  msf=new Msf();
  networkRadar=new NetworkRadar();
  msfrpcd=new MsfRpcd();
  logcat=new Logcat();
}","public ToolBox(){
  raw=new Raw();
  shell=new Shell();
  ruby=new Ruby();
  nmap=new NMap();
  hydra=new Hydra();
  arpSpoof=new ArpSpoof();
  ettercap=new Ettercap();
  fusemounts=new Fusemounts();
  ipTables=new IPTables();
  tcpDump=new TcpDump();
  msf=new Msf();
  networkRadar=new NetworkRadar();
  msfrpcd=new MsfRpcd();
  logcat=new Logcat();
  ip=new Ip();
}"
54249,"public void reload(){
  raw.setEnabled();
  shell.setEnabled();
  nmap.setEnabled();
  hydra.setEnabled();
  arpSpoof.setEnabled();
  ettercap.setEnabled();
  fusemounts.setEnabled();
  ipTables.setEnabled();
  tcpDump.setEnabled();
  networkRadar.setEnabled();
  logcat.setEnabled();
  ruby.init();
  msf.init();
  msfrpcd.init();
}","public void reload(){
  raw.setEnabled();
  shell.setEnabled();
  nmap.setEnabled();
  hydra.setEnabled();
  arpSpoof.setEnabled();
  ettercap.setEnabled();
  fusemounts.setEnabled();
  ipTables.setEnabled();
  tcpDump.setEnabled();
  networkRadar.setEnabled();
  logcat.setEnabled();
  ip.setEnabled();
  ruby.init();
  msf.init();
  msfrpcd.init();
}"
54250,"@Override public void onNewLine(String line){
  if (libcFingerprint == null) {
    if (!line.contains(""String_Node_Str"")) {
      return;
    }
    libcFingerprint=line.substring(0,line.indexOf(':' + 1));
  }
 else   if (!line.startsWith(libcFingerprint)) {
    return;
  }
  super.onNewLine(line);
}","@Override public void onNewLine(String line){
  if (libcFingerprint == null) {
    if (!line.contains(""String_Node_Str"")) {
      return;
    }
    libcFingerprint=line.substring(0,line.indexOf(':') + 1);
  }
 else   if (!line.startsWith(libcFingerprint)) {
    return;
  }
  super.onNewLine(line);
}"
54251,"public boolean canExecuteInDir(String dir){
  if (!user(dir) && !remount(dir)) {
    dir=getRealPath(dir);
    if (!root(dir)) {
      dir=null;
    }
  }
  if (dir != null) {
synchronized (this) {
      resolvedDir=dir;
    }
    return true;
  }
  return false;
}","public boolean canExecuteInDir(String dir){
  if (!user(dir) && !remount(dir)) {
    dir=getRealPath(dir);
    if (!root(dir)) {
      dir=null;
    }
  }
  if (dir != null) {
    if (System.getKnownIssues().isIssueFound(1)) {
      String corePath=System.getCorePath();
      String realCorePath=getRealPath(corePath);
      if (realCorePath != null)       corePath=realCorePath;
      dir=dir.replace(corePath,""String_Node_Str"");
    }
synchronized (this) {
      resolvedDir=dir;
    }
    return true;
  }
  return false;
}"
54252,"/** 
 * check if the dSploit user can create executable files inside a directory.
 * @param dir directory to check
 * @return true if can execute files into {@code dir}, false otherwise
 */
private boolean user(String dir){
  String tmpname;
  File tmpfile=null;
  if (dir == null)   return false;
  tmpfile=new File(dir);
  try {
    if (!tmpfile.exists())     tmpfile.mkdirs();
    do {
      tmpname=UUID.randomUUID().toString();
    }
 while ((tmpfile=new File(dir,tmpname)).exists());
    tmpfile.createNewFile();
    return (tmpfile.canExecute() || tmpfile.setExecutable(true,false));
  }
 catch (  IOException e) {
    Logger.warning(String.format(""String_Node_Str"",dir));
  }
 finally {
    if (tmpfile != null && tmpfile.exists())     tmpfile.delete();
  }
  return false;
}","/** 
 * check if the cSploit user can create executable files inside a directory.
 * @param dir directory to check
 * @return true if can execute files into {@code dir}, false otherwise
 */
private boolean user(String dir){
  String tmpname;
  File tmpfile=null;
  if (dir == null)   return false;
  tmpfile=new File(dir);
  try {
    if (!tmpfile.exists())     tmpfile.mkdirs();
    do {
      tmpname=UUID.randomUUID().toString();
    }
 while ((tmpfile=new File(dir,tmpname)).exists());
    tmpfile.createNewFile();
    return (tmpfile.canExecute() || tmpfile.setExecutable(true,false));
  }
 catch (  IOException e) {
    Logger.warning(String.format(""String_Node_Str"",dir));
  }
 finally {
    if (tmpfile != null && tmpfile.exists())     tmpfile.delete();
  }
  return false;
}"
54253,"public boolean canExecuteInDir(String dir){
  if (!user(dir) && !remount(dir)) {
    dir=getRealPath(dir);
    if (!root(dir)) {
      dir=null;
    }
  }
  if (dir != null) {
    if (System.getKnownIssues().isIssueFound(1)) {
      String corePath=System.getCorePath();
      String realCorePath=getRealPath(corePath);
      if (realCorePath != null)       corePath=realCorePath;
      dir=dir.replace(corePath,""String_Node_Str"");
    }
synchronized (this) {
      resolvedDir=dir;
    }
    return true;
  }
  return false;
}","public boolean canExecuteInDir(String dir){
  if (!user(dir) && !remount(dir)) {
    dir=getRealPath(dir);
    if (!root(dir)) {
      dir=null;
    }
  }
  if (dir != null) {
    if (System.getKnownIssues().isIssueFound(1)) {
      String corePath=System.getCorePath();
      dir=dir.replace(corePath,""String_Node_Str"");
      corePath=getRealPath(corePath);
      if (corePath != null)       dir=dir.replace(corePath,""String_Node_Str"");
    }
synchronized (this) {
      resolvedDir=dir;
    }
    return true;
  }
  return false;
}"
54254,"/** 
 * get version of installed MetaSploit Framework
 * @return the version of installed MetaSploit Framework
 */
public static String getLocalMsfVersion(){
  if (mLocalMsfVersion != null)   return mLocalMsfVersion;
  mLocalMsfVersion=readFirstLine(getMsfPath() + ""String_Node_Str"");
  return mLocalMsfVersion;
}","/** 
 * get version of installed MetaSploit Framework
 * @return the version of installed MetaSploit Framework
 */
public static String getLocalMsfVersion(){
  if (mLocalMsfVersion == null)   mLocalMsfVersion=readFirstLine(getMsfPath() + ""String_Node_Str"");
  return mLocalMsfVersion;
}"
54255,"/** 
 * get version of installed ruby
 * @return the installed version of ruby
 */
public static String getLocalRubyVersion(){
  if (mLocalRubyVersion != null)   return mLocalRubyVersion;
  String line=readFirstLine(getRubyPath() + ""String_Node_Str"");
  if (line != null)   return (mLocalRubyVersion=line);
  return null;
}","/** 
 * get version of installed ruby
 * @return the installed version of ruby
 */
public static String getLocalRubyVersion(){
  if (mLocalRubyVersion == null)   mLocalRubyVersion=readFirstLine(getRubyPath() + ""String_Node_Str"");
  return mLocalRubyVersion;
}"
54256,"/** 
 * is a MetaSploitFramework update available?
 * @return true if the framework can be updated, false otherwise
 */
public static boolean isMsfUpdateAvailable(){
  boolean exitForError=true;
  String branch=System.getSettings().getString(""String_Node_Str"",""String_Node_Str"");
  String localVersion=System.getLocalMsfVersion();
  try {
    String name=String.format(LOCAL_MSF_NAME,branch);
    String path=String.format(""String_Node_Str"",System.getStoragePath(),name);
    File local=new File(path);
synchronized (mMsfInfo) {
      if (local.exists() && local.isFile() && local.canRead()) {
        mMsfInfo.url=null;
        mMsfInfo.versionString=""String_Node_Str"";
      }
 else       if (mMsfInfo.url == null) {
        mMsfInfo.url=String.format(REMOTE_MSF_URL,branch);
synchronized (mMsfRepoParser) {
          mMsfInfo.versionString=mMsfRepoParser.getLastCommitSha();
        }
      }
      mMsfInfo.name=name;
      mMsfInfo.path=path;
      mMsfInfo.outputDir=System.getMsfPath();
      mMsfInfo.executableOutputDir=ExecChecker.msf().getRoot();
      mMsfInfo.archiver=archiveAlgorithm.zip;
      mMsfInfo.dirToExtract=""String_Node_Str"" + branch + ""String_Node_Str"";
      if (!mSettingReceiver.getFilter().contains(""String_Node_Str"")) {
        mSettingReceiver.addFilter(""String_Node_Str"");
      }
      if (!mSettingReceiver.getFilter().contains(""String_Node_Str"")) {
        mSettingReceiver.addFilter(""String_Node_Str"");
      }
      System.registerSettingListener(mSettingReceiver);
      exitForError=false;
      if (!mMsfInfo.version.equals(localVersion))       return true;
    }
  }
 catch (  Exception e) {
    System.errorLogging(e);
  }
 finally {
    if (exitForError)     mMsfInfo.reset();
  }
  return false;
}","/** 
 * is a MetaSploitFramework update available?
 * @return true if the framework can be updated, false otherwise
 */
public static boolean isMsfUpdateAvailable(){
  boolean exitForError=true;
  String branch=System.getSettings().getString(""String_Node_Str"",""String_Node_Str"");
  String localVersion=System.getLocalMsfVersion();
  try {
    String name=String.format(LOCAL_MSF_NAME,branch);
    String path=String.format(""String_Node_Str"",System.getStoragePath(),name);
    File local=new File(path);
synchronized (mMsfInfo) {
      if (local.exists() && local.isFile() && local.canRead()) {
        mMsfInfo.url=null;
        mMsfInfo.versionString=""String_Node_Str"";
      }
 else       if (mMsfInfo.url == null) {
        mMsfInfo.url=String.format(REMOTE_MSF_URL,branch);
synchronized (mMsfRepoParser) {
          mMsfInfo.versionString=mMsfRepoParser.getLastCommitSha();
        }
      }
      mMsfInfo.name=name;
      mMsfInfo.path=path;
      mMsfInfo.outputDir=System.getMsfPath();
      mMsfInfo.executableOutputDir=ExecChecker.msf().getRoot();
      mMsfInfo.archiver=archiveAlgorithm.zip;
      mMsfInfo.dirToExtract=""String_Node_Str"" + branch + ""String_Node_Str"";
      if (!mSettingReceiver.getFilter().contains(""String_Node_Str"")) {
        mSettingReceiver.addFilter(""String_Node_Str"");
      }
      if (!mSettingReceiver.getFilter().contains(""String_Node_Str"")) {
        mSettingReceiver.addFilter(""String_Node_Str"");
      }
      System.registerSettingListener(mSettingReceiver);
      exitForError=false;
      if (localVersion == null || !localVersion.equals(mMsfInfo.versionString))       return true;
    }
  }
 catch (  Exception e) {
    System.errorLogging(e);
  }
 finally {
    if (exitForError)     mMsfInfo.reset();
  }
  return false;
}"
54257,"public static void setMsfBranch(String branch){
  try {
synchronized (mMsfRepoParser) {
      mMsfRepoParser.setBranch(branch);
    }
  }
 catch (  Exception e) {
    Logger.error(e.getMessage());
  }
}","public static void setMsfBranch(String branch){
  try {
synchronized (mMsfRepoParser) {
      mMsfRepoParser.setBranch(branch);
    }
  }
 catch (  Exception e) {
    Logger.error(e.getClass().getName() + ""String_Node_Str"" + e.getMessage());
  }
}"
54258,"private void onMsfEnabled(){
  if (mReceiver != null)   return;
  onMsfPathChanged();
  OnPreferenceClickListener directoryPickerWithDefaultPath=new OnPreferenceClickListener(){
    @Override public boolean onPreferenceClick(    Preference preference){
      final String currentValue;
      final String defaultValue;
      final String key=preference.getKey();
      if (key.equals(""String_Node_Str"")) {
        currentValue=System.getRubyPath();
        defaultValue=System.getDefaultRubyPath();
      }
 else       if (key.equals(""String_Node_Str"")) {
        currentValue=System.getMsfPath();
        defaultValue=System.getDefaultMsfPath();
      }
 else       return true;
      if (!currentValue.equals(defaultValue)) {
        final Preference fPref=preference;
        (new ChoiceDialog(SettingsActivity.this,getString(R.string.choose_an_option),new String[]{getString(R.string.restore_default_path),getString(R.string.choose_a_custom_path)},new ChoiceDialog.ChoiceDialogListener(){
          @Override public void onChoice(          int choice){
            if (choice == 0) {
              File f=new File(defaultValue);
              if (!f.exists())               f.mkdirs();
              Intent i=new Intent();
              i.putExtra(DirectoryPicker.AFFECTED_PREF,key);
              i.putExtra(DirectoryPicker.CHOSEN_DIRECTORY,defaultValue);
              onActivityResult(DirectoryPicker.PICK_DIRECTORY,RESULT_OK,i);
            }
 else {
              startDirectoryPicker(fPref);
            }
          }
        }
)).show();
      }
 else {
        startDirectoryPicker(preference);
      }
      return true;
    }
  }
;
  mRubyDir.setDefaultValue(System.getDefaultRubyPath());
  mRubyDir.setOnPreferenceClickListener(directoryPickerWithDefaultPath);
  mMsfDir.setDefaultValue(System.getDefaultMsfPath());
  mMsfDir.setOnPreferenceClickListener(directoryPickerWithDefaultPath);
  mWipeMSF.setOnPreferenceClickListener(new OnPreferenceClickListener(){
    @Override public boolean onPreferenceClick(    Preference preference){
      wipe_prompt();
      return true;
    }
  }
);
  getMsfBranches();
  mReceiver=new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      if (intent.getAction().equals(SETTINGS_WIPE_DONE)) {
        System.updateLocalRubyVersion();
        System.updateLocalMsfVersion();
        mWipeMSF.setEnabled(new File(System.getRubyPath()).isDirectory());
      }
    }
  }
;
  registerReceiver(mReceiver,new IntentFilter(SETTINGS_WIPE_DONE));
}","private void onMsfEnabled(){
  if (mReceiver != null)   return;
  onMsfPathChanged();
  OnPreferenceClickListener directoryPickerWithDefaultPath=new OnPreferenceClickListener(){
    @Override public boolean onPreferenceClick(    Preference preference){
      final String currentValue;
      final String defaultValue;
      final String key=preference.getKey();
      if (key.equals(""String_Node_Str"")) {
        currentValue=System.getRubyPath();
        defaultValue=System.getDefaultRubyPath();
      }
 else       if (key.equals(""String_Node_Str"")) {
        currentValue=System.getMsfPath();
        defaultValue=System.getDefaultMsfPath();
      }
 else       return true;
      if (!currentValue.equals(defaultValue)) {
        final Preference fPref=preference;
        (new ChoiceDialog(SettingsActivity.this,getString(R.string.choose_an_option),new String[]{getString(R.string.restore_default_path),getString(R.string.choose_a_custom_path)},new ChoiceDialog.ChoiceDialogListener(){
          @Override public void onChoice(          int choice){
            if (choice == 0) {
              File f=new File(defaultValue);
              if (!f.exists())               f.mkdirs();
              Intent i=new Intent();
              i.putExtra(DirectoryPicker.AFFECTED_PREF,key);
              i.putExtra(DirectoryPicker.CHOSEN_DIRECTORY,defaultValue);
              onActivityResult(DirectoryPicker.PICK_DIRECTORY,RESULT_OK,i);
            }
 else {
              startDirectoryPicker(fPref);
            }
          }
        }
)).show();
      }
 else {
        startDirectoryPicker(preference);
      }
      return true;
    }
  }
;
  mRubyDir.setDefaultValue(System.getDefaultRubyPath());
  mRubyDir.setOnPreferenceClickListener(directoryPickerWithDefaultPath);
  mMsfDir.setDefaultValue(System.getDefaultMsfPath());
  mMsfDir.setOnPreferenceClickListener(directoryPickerWithDefaultPath);
  mWipeMSF.setOnPreferenceClickListener(new OnPreferenceClickListener(){
    @Override public boolean onPreferenceClick(    Preference preference){
      wipe_prompt();
      return true;
    }
  }
);
  getMsfBranches();
  mReceiver=new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      if (intent.getAction().equals(SETTINGS_WIPE_DONE)) {
        onMsfPathChanged();
      }
 else       if (intent.getAction().equals(SETTINGS_MSF_BRANCHES_AVAILABLE)) {
        onMsfBranchesAvailable();
      }
    }
  }
;
  registerReceiver(mReceiver,new IntentFilter(SETTINGS_WIPE_DONE));
}"
54259,"private void onMsfPathChanged(){
  measureMsfSize();
  mWipeMSF.setEnabled(new File(System.getRubyPath()).isDirectory() || new File(System.getMsfPath()).isDirectory());
}","private void onMsfPathChanged(){
  measureMsfSize();
  System.updateLocalRubyVersion();
  System.updateLocalMsfVersion();
  boolean haveMsf=false;
  File dir;
  File[] content;
  if ((dir=new File(System.getRubyPath())).isDirectory() || (dir=new File(System.getMsfPath())).isDirectory()) {
    content=dir.listFiles();
    haveMsf=content != null && content.length > 2;
  }
  mWipeMSF.setEnabled(haveMsf);
}"
54260,"@Override public void run(){
  String[] branches=UpdateService.getMsfBranches();
  boolean hasRelease=false;
  pref.setEntryValues(branches);
  pref.setEntries(branches);
  for (int i=0; !hasRelease && i < branches.length; i++) {
    hasRelease=branches[i].equals(""String_Node_Str"");
  }
  pref.setDefaultValue((hasRelease ? ""String_Node_Str"" : ""String_Node_Str""));
  pref.setEnabled(true);
}","@Override public void run(){
  UpdateService.getMsfBranches();
  sendBroadcast(new Intent(SETTINGS_MSF_BRANCHES_AVAILABLE));
}"
54261,"@Override public void onReceive(Context context,Intent intent){
  if (intent.getAction().equals(SETTINGS_WIPE_DONE)) {
    System.updateLocalRubyVersion();
    System.updateLocalMsfVersion();
    mWipeMSF.setEnabled(new File(System.getRubyPath()).isDirectory());
  }
}","@Override public void onReceive(Context context,Intent intent){
  if (intent.getAction().equals(SETTINGS_WIPE_DONE)) {
    onMsfPathChanged();
  }
 else   if (intent.getAction().equals(SETTINGS_MSF_BRANCHES_AVAILABLE)) {
    onMsfBranchesAvailable();
  }
}"
54262,"private void getMsfBranches(){
  if (mBranchesWaiter != null) {
    if (mBranchesWaiter.getState() == Thread.State.TERMINATED)     try {
      mBranchesWaiter.join();
    }
 catch (    InterruptedException e) {
      Logger.error(e.getMessage());
    }
    return;
  }
  final ListPreference pref=mMsfBranch;
  mMsfBranch.setEnabled(false);
  mBranchesWaiter=new Thread(new Runnable(){
    @Override public void run(){
      String[] branches=UpdateService.getMsfBranches();
      boolean hasRelease=false;
      pref.setEntryValues(branches);
      pref.setEntries(branches);
      for (int i=0; !hasRelease && i < branches.length; i++) {
        hasRelease=branches[i].equals(""String_Node_Str"");
      }
      pref.setDefaultValue((hasRelease ? ""String_Node_Str"" : ""String_Node_Str""));
      pref.setEnabled(true);
    }
  }
);
  mBranchesWaiter.start();
}","private void getMsfBranches(){
  if (mBranchesWaiter != null) {
    if (mBranchesWaiter.getState() == Thread.State.TERMINATED)     try {
      mBranchesWaiter.join();
    }
 catch (    InterruptedException e) {
      Logger.error(e.getMessage());
    }
    return;
  }
  final ListPreference pref=mMsfBranch;
  mMsfBranch.setEnabled(false);
  mBranchesWaiter=new Thread(new Runnable(){
    @Override public void run(){
      UpdateService.getMsfBranches();
      sendBroadcast(new Intent(SETTINGS_MSF_BRANCHES_AVAILABLE));
    }
  }
);
  mBranchesWaiter.start();
}"
54263,"@Override public void onCreate(Bundle savedInstanceState){
  SharedPreferences themePrefs=getSharedPreferences(""String_Node_Str"",0);
  Boolean isDark=themePrefs.getBoolean(""String_Node_Str"",false);
  if (isDark)   setTheme(R.style.Sherlock___Theme);
 else   setTheme(R.style.AppTheme);
  super.onCreate(savedInstanceState);
  mScanToggleButton=(ToggleButton)findViewById(R.id.scanToggleButton);
  mScanProgress=(ProgressBar)findViewById(R.id.scanActivity);
  mScanToggleButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      if (mRunning) {
        setStoppedState();
      }
 else {
        setStartedState();
      }
    }
  }
);
  ListView mScanList=(ListView)findViewById(R.id.scanListView);
  for (  Port port : System.getCurrentTarget().getOpenPorts()) {
    mPortList.add(port.number + ""String_Node_Str"" + port.protocol.toString().toLowerCase()+ ""String_Node_Str"");
  }
  mListAdapter=new ArrayAdapter<String>(this,android.R.layout.simple_list_item_1,mPortList);
  mScanList.setAdapter(mListAdapter);
  mScanList.setOnItemLongClickListener(new OnItemLongClickListener(){
    @Override public boolean onItemLongClick(    AdapterView<?> parent,    View view,    int position,    long id){
      int portNumber=System.getCurrentTarget().getOpenPorts().get(position).number;
      String url=""String_Node_Str"";
      if (portNumber == 80)       url=""String_Node_Str"" + System.getCurrentTarget().getCommandLineRepresentation() + ""String_Node_Str"";
 else       if (portNumber == 443)       url=""String_Node_Str"" + System.getCurrentTarget().getCommandLineRepresentation() + ""String_Node_Str"";
 else       if (portNumber == 21)       url=""String_Node_Str"" + System.getCurrentTarget().getCommandLineRepresentation();
 else       if (portNumber == 22)       url=""String_Node_Str"" + System.getCurrentTarget().getCommandLineRepresentation();
 else       url=""String_Node_Str"" + System.getCurrentTarget().getCommandLineRepresentation() + ""String_Node_Str""+ portNumber;
      final String furl=url;
      new ConfirmDialog(""String_Node_Str"",""String_Node_Str"" + url + ""String_Node_Str"",PortScanner.this,new ConfirmDialogListener(){
        @Override public void onConfirm(){
          try {
            Intent browser=new Intent(Intent.ACTION_VIEW,Uri.parse(furl));
            PortScanner.this.startActivity(browser);
          }
 catch (          ActivityNotFoundException e) {
            System.errorLogging(e);
            new ErrorDialog(getString(R.string.error),getString(R.string.no_activities_for_url),PortScanner.this).show();
          }
        }
        @Override public void onCancel(){
        }
      }
).show();
      return false;
    }
  }
);
}","@Override public void onCreate(Bundle savedInstanceState){
  SharedPreferences themePrefs=getSharedPreferences(""String_Node_Str"",0);
  Boolean isDark=themePrefs.getBoolean(""String_Node_Str"",false);
  if (isDark)   setTheme(R.style.Sherlock___Theme);
 else   setTheme(R.style.AppTheme);
  super.onCreate(savedInstanceState);
  mScanToggleButton=(ToggleButton)findViewById(R.id.scanToggleButton);
  mScanProgress=(ProgressBar)findViewById(R.id.scanActivity);
  mScanToggleButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      if (mRunning) {
        setStoppedState();
      }
 else {
        setStartedState();
      }
    }
  }
);
  ListView mScanList=(ListView)findViewById(R.id.scanListView);
  createPortList();
  mListAdapter=new ArrayAdapter<String>(this,android.R.layout.simple_list_item_1,mPortList);
  mScanList.setAdapter(mListAdapter);
  mScanList.setOnItemLongClickListener(new OnItemLongClickListener(){
    @Override public boolean onItemLongClick(    AdapterView<?> parent,    View view,    int position,    long id){
      int portNumber=System.getCurrentTarget().getOpenPorts().get(position).number;
      String url=""String_Node_Str"";
      if (portNumber == 80)       url=""String_Node_Str"" + System.getCurrentTarget().getCommandLineRepresentation() + ""String_Node_Str"";
 else       if (portNumber == 443)       url=""String_Node_Str"" + System.getCurrentTarget().getCommandLineRepresentation() + ""String_Node_Str"";
 else       if (portNumber == 21)       url=""String_Node_Str"" + System.getCurrentTarget().getCommandLineRepresentation();
 else       if (portNumber == 22)       url=""String_Node_Str"" + System.getCurrentTarget().getCommandLineRepresentation();
 else       url=""String_Node_Str"" + System.getCurrentTarget().getCommandLineRepresentation() + ""String_Node_Str""+ portNumber;
      final String furl=url;
      new ConfirmDialog(""String_Node_Str"",""String_Node_Str"" + url + ""String_Node_Str"",PortScanner.this,new ConfirmDialogListener(){
        @Override public void onConfirm(){
          try {
            Intent browser=new Intent(Intent.ACTION_VIEW,Uri.parse(furl));
            PortScanner.this.startActivity(browser);
          }
 catch (          ActivityNotFoundException e) {
            System.errorLogging(e);
            new ErrorDialog(getString(R.string.error),getString(R.string.no_activities_for_url),PortScanner.this).show();
          }
        }
        @Override public void onCancel(){
        }
      }
).show();
      return false;
    }
  }
);
}"
54264,"@Override public void onPortFound(String port,String protocol){
  final String openPort=port;
  final String portProto=protocol;
  PortScanner.this.runOnUiThread(new Runnable(){
    @Override public void run(){
      String proto=System.getProtocolByPort(openPort), entry=openPort;
      if (proto != null)       entry=openPort + ""String_Node_Str"" + proto+ ""String_Node_Str"";
 else       entry=portProto + ""String_Node_Str"" + openPort;
      mPortList.add(entry);
      mListAdapter.notifyDataSetChanged();
      System.addOpenPort(Integer.parseInt(openPort),Network.Protocol.fromString(portProto));
    }
  }
);
}","@Override public void onPortFound(String port,String protocol){
  final int portNumber=Integer.parseInt(port);
  final String portProtocol=protocol;
  final String resolvedProtocol=System.getProtocolByPort(port);
  System.addOpenPort(portNumber,Network.Protocol.fromString(protocol));
  PortScanner.this.runOnUiThread(new Runnable(){
    @Override public void run(){
      String entry;
      if (resolvedProtocol != null)       entry=portNumber + ""String_Node_Str"" + resolvedProtocol+ ""String_Node_Str"";
 else       entry=portProtocol + ""String_Node_Str"" + portNumber;
      if (!mPortList.contains(entry)) {
        mPortList.add(entry);
        mListAdapter.notifyDataSetChanged();
      }
    }
  }
);
}"
54265,"@Override public void run(){
  String proto=System.getProtocolByPort(openPort), entry=openPort;
  if (proto != null)   entry=openPort + ""String_Node_Str"" + proto+ ""String_Node_Str"";
 else   entry=portProto + ""String_Node_Str"" + openPort;
  mPortList.add(entry);
  mListAdapter.notifyDataSetChanged();
  System.addOpenPort(Integer.parseInt(openPort),Network.Protocol.fromString(portProto));
}","@Override public void run(){
  String entry;
  if (resolvedProtocol != null)   entry=portNumber + ""String_Node_Str"" + resolvedProtocol+ ""String_Node_Str"";
 else   entry=portProtocol + ""String_Node_Str"" + portNumber;
  if (!mPortList.contains(entry)) {
    mPortList.add(entry);
    mListAdapter.notifyDataSetChanged();
  }
}"
54266,"private void setStartedState(){
  mPortList.clear();
  System.getNMap().synScan(System.getCurrentTarget(),mScanReceiver,mCustomPorts).start();
  mRunning=true;
}","private void setStartedState(){
  createPortList();
  System.getNMap().synScan(System.getCurrentTarget(),mScanReceiver,mCustomPorts).start();
  mRunning=true;
}"
54267,"public void run(){
  try {
    String line=null;
    Logger.debug(""String_Node_Str"" + mFIFOPath + ""String_Node_Str""+ mFIFONum+ ""String_Node_Str"");
    while (!(new File(mFIFOPath).exists()))     Thread.sleep(200);
    Logger.debug(""String_Node_Str"");
    mReader=new BufferedReader(new FileReader(mFIFOPath));
    Logger.debug(""String_Node_Str"" + mFIFOPath + ""String_Node_Str"");
    while (true) {
      if (mReader.ready()) {
        Logger.debug(""String_Node_Str"");
        if ((line=mReader.readLine()) == null) {
          Logger.debug(""String_Node_Str"");
          continue;
        }
      }
 else {
        Logger.debug(""String_Node_Str"");
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException e) {
        }
        continue;
      }
      if (!line.isEmpty()) {
        Logger.debug(""String_Node_Str"" + line);
        if (line.startsWith(mToken)) {
          mExitCode=Integer.parseInt(line.substring(mToken.length()));
          if (mReceiver != null)           mReceiver.onEnd(mExitCode);
          break;
        }
 else         if (mReceiver != null) {
          mReceiver.onNewLine(line);
        }
      }
 else       Logger.debug(""String_Node_Str"");
    }
  }
 catch (  IOException e) {
    System.errorLogging(e);
  }
catch (  InterruptedException e) {
    System.errorLogging(e);
  }
 finally {
    try {
      if (mReader != null)       mReader.close();
synchronized (mFIFOS) {
        mFIFOS.remove(mFIFOS.indexOf(mFIFONum));
      }
    }
 catch (    IOException e) {
    }
  }
}","@Override public void run(){
  return;
}"
54268,"private void setStartedState(){
  mSearchProgress.setVisibility(View.VISIBLE);
  mRunning=true;
  mThread=new Thread(new Runnable(){
    @Override public void run(){
      boolean msf_only=System.getSettings().getBoolean(""String_Node_Str"",false);
      boolean found_something=false;
      for (      final Vulnerability vuln : System.getCurrentTarget().getVulnerabilities()) {
        if (!mRunning)         return;
        Exploit ex=null;
        results.clear();
        if (vuln.osvdb_id != 0) {
          if (vuln.has_msf_exploit)           ex=MSFDatabase.search_by_osvdb(vuln.osvdb_id);
          if (ex != null)           results.add(ex);
 else           if (!msf_only)           results.addAll(EXDatabase.search_by_osvdb(vuln.osvdb_id));
        }
        if (vuln.cve_id != null) {
          ex=MSFDatabase.search_by_cve(vuln.cve_id.substring(4));
          if (ex != null)           results.add(ex);
 else           if (!msf_only)           results.addAll(EXDatabase.search_by_cveid(vuln.cve_id.substring(4)));
        }
        if (!found_something && !results.isEmpty())         found_something=true;
        for (        final Exploit exp : results) {
          System.addExploit(vuln,exp);
          ExploitFinder.this.runOnUiThread(new Runnable(){
            @Override public void run(){
              mAdapter.add(exp);
            }
          }
);
        }
      }
      if (!found_something) {
        ExploitFinder.this.runOnUiThread(new Runnable(){
          @Override public void run(){
            new FinishDialog(""String_Node_Str"",""String_Node_Str"",ExploitFinder.this).show();
          }
        }
);
      }
      ExploitFinder.this.runOnUiThread(new Runnable(){
        @Override public void run(){
          setStoppedState();
        }
      }
);
    }
  }
);
  mThread.start();
}","private void setStartedState(){
  mSearchProgress.setVisibility(View.VISIBLE);
  mRunning=true;
  mThread=new Thread(new Runnable(){
    @Override public void run(){
      boolean msf_only=System.getSettings().getBoolean(""String_Node_Str"",false);
      boolean found_something=false;
      for (      final Vulnerability vuln : System.getCurrentTarget().getVulnerabilities()) {
        if (!mRunning)         return;
        Exploit ex=null;
        results.clear();
        if (vuln.osvdb_id != 0) {
          if (vuln.has_msf_exploit)           ex=MSFDatabase.search_by_osvdb(vuln.osvdb_id);
          if (ex != null) {
            results.add(ex);
          }
 else           if (!msf_only) {
            ArrayList<Exploit> exploits=EXDatabase.search_by_osvdb(vuln.osvdb_id);
            if (exploits != null)             results.addAll(exploits);
          }
        }
        if (vuln.cve_id != null) {
          ex=MSFDatabase.search_by_cve(vuln.cve_id.substring(4));
          if (ex != null)           results.add(ex);
 else           if (!msf_only)           results.addAll(EXDatabase.search_by_cveid(vuln.cve_id.substring(4)));
        }
        if (!found_something && !results.isEmpty())         found_something=true;
        for (        final Exploit exp : results) {
          System.addExploit(vuln,exp);
          ExploitFinder.this.runOnUiThread(new Runnable(){
            @Override public void run(){
              mAdapter.add(exp);
            }
          }
);
        }
      }
      if (!found_something) {
        ExploitFinder.this.runOnUiThread(new Runnable(){
          @Override public void run(){
            new FinishDialog(""String_Node_Str"",""String_Node_Str"",ExploitFinder.this).show();
          }
        }
);
      }
      ExploitFinder.this.runOnUiThread(new Runnable(){
        @Override public void run(){
          setStoppedState();
        }
      }
);
    }
  }
);
  mThread.start();
}"
54269,"public void run(){
  int read=-1, size=0, max=0;
  byte[] chunk=new byte[CHUNK_SIZE];
  try {
    max=Integer.parseInt(System.getSettings().getString(""String_Node_Str"",""String_Node_Str""));
  }
 catch (  NumberFormatException e) {
    max=10485760;
  }
  try {
    String location=null, contentType=null;
    while ((read=mReader.read(chunk,0,CHUNK_SIZE)) > 0 && size < max) {
      mBuffer.append(chunk,read);
      size+=read;
      location=location == null ? RequestParser.getHeaderValue(""String_Node_Str"",mBuffer) : location;
      contentType=contentType == null ? RequestParser.getHeaderValue(""String_Node_Str"",mBuffer) : contentType;
      if (contentType != null) {
        boolean isHandledContentType=false;
        for (        String handled : FILTERED_CONTENT_TYPES) {
          if (contentType.equals(handled) || contentType.contains(handled)) {
            isHandledContentType=true;
            break;
          }
        }
        if (isHandledContentType == false) {
          Log.d(TAG,""String_Node_Str"" + contentType + ""String_Node_Str"");
          mWriter.write(mBuffer.getData());
          mWriter.flush();
          while ((read=mReader.read(chunk,0,512)) > 0) {
            mWriter.write(chunk,0,read);
          }
          mWriter.flush();
          mWriter.close();
          mReader.close();
          return;
        }
      }
    }
    if (mBuffer.isEmpty() == false) {
      String data=mBuffer.toString();
      String[] split=data.split(HEAD_SEPARATOR,2);
      String headers=split[0];
      if (location != null && location.startsWith(""String_Node_Str"") && System.getSettings().getBoolean(""String_Node_Str"",true) == true) {
        Log.w(TAG,""String_Node_Str"" + location);
        mBuffer.replace(""String_Node_Str"".getBytes(),""String_Node_Str"".getBytes());
        data=mBuffer.toString();
        split=data.split(HEAD_SEPARATOR,2);
        headers=split[0];
        HTTPSMonitor.getInstance().addURL(mClient,location.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
      }
      String body=(split.length > 1 ? split[1] : ""String_Node_Str""), patched=""String_Node_Str"";
      body=mFilter.onDataReceived(headers,body);
      for (      String header : headers.split(""String_Node_Str"")) {
        if (header.toLowerCase().contains(""String_Node_Str"") == false)         patched+=header + ""String_Node_Str"";
      }
      headers=patched;
      mBuffer.setData((headers + HEAD_SEPARATOR + body).getBytes());
      mWriter.write(mBuffer.getData());
      mWriter.flush();
    }
  }
 catch (  OutOfMemoryError ome) {
    Log.e(TAG,ome.toString());
  }
catch (  Exception e) {
    System.errorLogging(TAG,e);
  }
 finally {
    try {
      mWriter.flush();
      mWriter.close();
      mReader.close();
    }
 catch (    IOException e) {
    }
  }
}","public void run(){
  int read=-1, size=0, max=0;
  byte[] chunk=new byte[CHUNK_SIZE];
  try {
    max=Integer.parseInt(System.getSettings().getString(""String_Node_Str"",""String_Node_Str""));
  }
 catch (  NumberFormatException e) {
    max=10485760;
  }
  try {
    String location=null, contentType=null;
    while ((read=mReader.read(chunk,0,CHUNK_SIZE)) > 0 && size < max) {
      mBuffer.append(chunk,read);
      size+=read;
      location=location == null ? RequestParser.getHeaderValue(""String_Node_Str"",mBuffer) : location;
      contentType=contentType == null ? RequestParser.getHeaderValue(""String_Node_Str"",mBuffer) : contentType;
      if (contentType != null) {
        boolean isHandledContentType=false;
        for (        String handled : FILTERED_CONTENT_TYPES) {
          if (contentType.contains(handled)) {
            isHandledContentType=true;
            break;
          }
        }
        if (isHandledContentType == false) {
          Log.d(TAG,""String_Node_Str"" + contentType + ""String_Node_Str"");
          mWriter.write(mBuffer.getData());
          mWriter.flush();
          while ((read=mReader.read(chunk,0,CHUNK_SIZE)) > 0) {
            mWriter.write(chunk,0,read);
            mWriter.flush();
          }
          mWriter.close();
          mReader.close();
          return;
        }
      }
    }
    if (mBuffer.isEmpty() == false) {
      String data=mBuffer.toString();
      String[] split=data.split(HEAD_SEPARATOR,2);
      String headers=split[0];
      if (location != null && location.startsWith(""String_Node_Str"") && System.getSettings().getBoolean(""String_Node_Str"",true) == true) {
        Log.w(TAG,""String_Node_Str"" + location);
        mBuffer.replace(""String_Node_Str"".getBytes(),""String_Node_Str"".getBytes());
        data=mBuffer.toString();
        split=data.split(HEAD_SEPARATOR,2);
        headers=split[0];
        HTTPSMonitor.getInstance().addURL(mClient,location.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
      }
      String body=(split.length > 1 ? split[1] : ""String_Node_Str""), patched=""String_Node_Str"";
      body=mFilter.onDataReceived(headers,body);
      for (      String header : headers.split(""String_Node_Str"")) {
        if (header.toLowerCase().contains(""String_Node_Str"") == false)         patched+=header + ""String_Node_Str"";
      }
      headers=patched;
      mBuffer.setData((headers + HEAD_SEPARATOR + body).getBytes());
      mWriter.write(mBuffer.getData());
      mWriter.flush();
    }
  }
 catch (  OutOfMemoryError ome) {
    Log.e(TAG,ome.toString());
  }
catch (  Exception e) {
    System.errorLogging(TAG,e);
  }
 finally {
    try {
      mWriter.flush();
      mWriter.close();
      mReader.close();
    }
 catch (    IOException e) {
    }
  }
}"
54270,"public ArrayList<File> filter(File[] file_list,boolean onlyDirs,boolean showHidden){
  ArrayList<File> files=new ArrayList<File>();
  for (  File file : file_list) {
    if (onlyDirs && !file.isDirectory())     continue;
    if (!showHidden && file.isHidden())     continue;
    files.add(file);
  }
  Collections.sort(files);
  return files;
}","public ArrayList<File> filter(File[] file_list,boolean onlyDirs,boolean showHidden){
  ArrayList<File> files=new ArrayList<File>();
  if (file_list != null) {
    for (    File file : file_list) {
      if (onlyDirs && !file.isDirectory())       continue;
      if (!showHidden && file.isHidden())       continue;
      files.add(file);
    }
    Collections.sort(files);
  }
  return files;
}"
54271,"@Override public void run(){
  new ErrorDialog(""String_Node_Str"",error,Hijacker.this).show();
  setStoppedState();
}","@Override public void run(){
  if (Hijacker.this.isFinishing() == false) {
    new ErrorDialog(""String_Node_Str"",error,Hijacker.this).show();
    setStoppedState();
  }
}"
54272,"private void setSpoofErrorState(final String error){
  Hijacker.this.runOnUiThread(new Runnable(){
    @Override public void run(){
      new ErrorDialog(""String_Node_Str"",error,Hijacker.this).show();
      setStoppedState();
    }
  }
);
}","private void setSpoofErrorState(final String error){
  Hijacker.this.runOnUiThread(new Runnable(){
    @Override public void run(){
      if (Hijacker.this.isFinishing() == false) {
        new ErrorDialog(""String_Node_Str"",error,Hijacker.this).show();
        setStoppedState();
      }
    }
  }
);
}"
54273,"public void onNewLine(String line){
  Matcher matcher=null;
  line=line.trim();
  if ((matcher=ATTEMPT_PATTERN.matcher(line)) != null && matcher.find()) {
    String login=matcher.group(1), password=matcher.group(2), progress=matcher.group(3), total=matcher.group(4);
    onNewAttempt(login,password,Integer.parseInt(progress),Integer.parseInt(total));
  }
 else   if ((matcher=ERROR_PATTERN.matcher(line)) != null && matcher.find())   onError(matcher.group(1));
 else   if ((matcher=FATAL_PATTERN.matcher(line)) != null && matcher.find())   onFatal(matcher.group(1));
 else   if ((matcher=ACCOUNT_PATTERN.matcher(line)) != null && matcher.find())   onAccountFound(matcher.group(1),matcher.group(2));
}","public void onNewLine(String line){
  Matcher matcher=null;
  line=line.trim();
  if ((matcher=ATTEMPT_PATTERN.matcher(line)) != null && matcher.find()) {
    String login=matcher.group(1), password=matcher.group(2), progress=matcher.group(3), total=matcher.group(4);
    int iprogress, itotal;
    try {
      iprogress=Integer.parseInt(progress);
      itotal=Integer.parseInt(total);
    }
 catch (    Exception e) {
      iprogress=0;
      itotal=Integer.MAX_VALUE;
    }
    onNewAttempt(login,password,iprogress,itotal);
  }
 else   if ((matcher=ERROR_PATTERN.matcher(line)) != null && matcher.find())   onError(matcher.group(1));
 else   if ((matcher=FATAL_PATTERN.matcher(line)) != null && matcher.find())   onFatal(matcher.group(1));
 else   if ((matcher=ACCOUNT_PATTERN.matcher(line)) != null && matcher.find())   onAccountFound(matcher.group(1),matcher.group(2));
}"
54274,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  checkForOpenPorts();
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_sniffer_48,new OnClickListener(){
    @Override public void onClick(    View v){
      setStoppedState();
      startActivity(new Intent(MITM.this,Sniffer.class));
      overridePendingTransition(R.anim.slide_in_left,R.anim.slide_out_left);
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_passwords_48,new OnClickListener(){
    @Override public void onClick(    View v){
      setStoppedState();
      startActivity(new Intent(MITM.this,PasswordSniffer.class));
      overridePendingTransition(R.anim.slide_in_left,R.anim.slide_out_left);
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_hijack_48,new OnClickListener(){
    @Override public void onClick(    View v){
      setStoppedState();
      startActivity(new Intent(MITM.this,Hijacker.class));
      overridePendingTransition(R.anim.slide_in_left,R.anim.slide_out_left);
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_kill_48,new OnClickListener(){
    @Override public void onClick(    View v){
      ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        if (System.getCurrentTarget().getType() != Target.Type.ENDPOINT)         new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
 else {
          setStoppedState();
          activity.setVisibility(View.VISIBLE);
          Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
          ConnectionKiller.start();
        }
      }
 else {
        ConnectionKiller.stop();
        activity.setVisibility(View.INVISIBLE);
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_redirect_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new RedirectionDialog(""String_Node_Str"",MITM.this,new RedirectionDialogListener(){
          @Override public void onInputEntered(          String address,          String port){
            if (address.isEmpty() == false && port.isEmpty() == false) {
              try {
                int iport=Integer.parseInt(port);
                if (iport <= 0 || iport > 65535)                 throw new Exception(""String_Node_Str"");
                URL url=new URL(address);
                address=url.getHost();
                activity.setVisibility(View.VISIBLE);
                Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                final String faddress=address;
                final int fport=iport;
                mSpoofSession=new SpoofSession();
                mSpoofSession.start(new OnSessionReadyListener(){
                  @Override public void onSessionReady(){
                    System.getProxy().setRedirection(faddress,fport);
                  }
                }
);
              }
 catch (              Exception e) {
                new ErrorDialog(""String_Node_Str"",e.getMessage(),MITM.this).show();
              }
            }
 else             new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
          }
        }
).show();
      }
 else       setStoppedState();
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_image_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new ChoiceDialog(MITM.this,""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new ChoiceDialogListener(){
          @Override public void onChoice(          int choice){
            if (choice == 0) {
              mCurrentActivity=activity;
              startActivityForResult(mImagePicker,SELECT_PICTURE);
            }
 else {
              new InputDialog(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,false,MITM.this,new InputDialogListener(){
                @Override public void onInputEntered(                String input){
                  String image=input.trim();
                  if (image.isEmpty() == false) {
                    image=image.startsWith(""String_Node_Str"") ? image : ""String_Node_Str"" + image;
                    activity.setVisibility(View.VISIBLE);
                    final String resource=image;
                    mSpoofSession=new SpoofSession();
                    mSpoofSession.start(new OnSessionReadyListener(){
                      @Override public void onSessionReady(){
                        System.getProxy().setFilter(new Proxy.ProxyFilter(){
                          @Override public String onDataReceived(                          String headers,                          String data){
                            data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + resource + ""String_Node_Str"");
                            data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + resource + ""String_Node_Str"");
                            return data;
                          }
                        }
);
                      }
                    }
);
                    Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                  }
 else                   new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
                }
              }
).show();
            }
          }
        }
).show();
      }
 else {
        mCurrentActivity=null;
        setStoppedState();
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_youtube_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new InputDialog(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,false,MITM.this,new InputDialogListener(){
          @Override public void onInputEntered(          String input){
            final String video=input.trim();
            Matcher matcher=YOUTUBE_PATTERN.matcher(input);
            if (video.isEmpty() == false && matcher != null && matcher.find()) {
              final String videoId=matcher.group(1);
              activity.setVisibility(View.VISIBLE);
              Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
              mSpoofSession=new SpoofSession();
              mSpoofSession.start(new OnSessionReadyListener(){
                @Override public void onSessionReady(){
                  System.getProxy().setFilter(new Proxy.ProxyFilter(){
                    @Override public String onDataReceived(                    String headers,                    String data){
                      if (data.matches(""String_Node_Str""))                       data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + videoId);
 else                       if (data.matches(""String_Node_Str""))                       data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + videoId);
 else                       if (data.matches(""String_Node_Str""))                       data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + videoId);
                      return data;
                    }
                  }
);
                }
              }
);
            }
 else             new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
          }
        }
).show();
      }
 else       setStoppedState();
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_injection_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new ChoiceDialog(MITM.this,""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new ChoiceDialogListener(){
          @Override public void onChoice(          int choice){
            if (choice == 0) {
              mCurrentActivity=activity;
              startActivityForResult(mScriptPicker,SELECT_SCRIPT);
            }
 else {
              new InputDialog(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",true,false,MITM.this,new InputDialogListener(){
                @Override public void onInputEntered(                String input){
                  final String js=input.trim();
                  if (js.isEmpty() == false || js.startsWith(""String_Node_Str"") == false) {
                    activity.setVisibility(View.VISIBLE);
                    Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                    mSpoofSession=new SpoofSession();
                    mSpoofSession.start(new OnSessionReadyListener(){
                      @Override public void onSessionReady(){
                        System.getProxy().setFilter(new Proxy.ProxyFilter(){
                          @Override public String onDataReceived(                          String headers,                          String data){
                            return data.replaceAll(""String_Node_Str"",js + ""String_Node_Str"");
                          }
                        }
);
                      }
                    }
);
                  }
 else                   new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
                }
              }
).show();
            }
          }
        }
).show();
      }
 else {
        mCurrentActivity=null;
        setStoppedState();
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new CustomFilterDialog(""String_Node_Str"",MITM.this,new CustomFilterDialogListener(){
          @Override public void onInputEntered(          final ArrayList<String> from,          final ArrayList<String> to){
            if (from.isEmpty() == false && to.isEmpty() == false) {
              try {
                for (                String exp : from) {
                  Pattern.compile(exp);
                }
                activity.setVisibility(View.VISIBLE);
                Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                mSpoofSession=new SpoofSession();
                mSpoofSession.start(new OnSessionReadyListener(){
                  @Override public void onSessionReady(){
                    System.getProxy().setFilter(new ProxyFilter(){
                      @Override public String onDataReceived(                      String headers,                      String data){
                        for (int i=0; i < from.size(); i++) {
                          data=data.replaceAll(from.get(i),to.get(i));
                        }
                        return data;
                      }
                    }
);
                  }
                }
);
              }
 catch (              PatternSyntaxException e) {
                new ErrorDialog(""String_Node_Str"",""String_Node_Str"" + e.getDescription() + ""String_Node_Str"",MITM.this).show();
              }
            }
 else             new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
          }
        }
).show();
      }
 else       setStoppedState();
    }
  }
));
  mActionListView=(ListView)findViewById(R.id.actionListView);
  mActionAdapter=new ActionAdapter(R.layout.plugin_mitm_list_item,mActions);
  mActionListView.setAdapter(mActionAdapter);
  mImagePicker=new Intent(Intent.ACTION_PICK,android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI);
  mImagePicker.setType(""String_Node_Str"");
  mImagePicker.putExtra(Intent.EXTRA_LOCAL_ONLY,true);
  mScriptPicker=new Intent();
  mScriptPicker.addCategory(Intent.CATEGORY_OPENABLE);
  mScriptPicker.setType(""String_Node_Str"");
  mScriptPicker.setAction(Intent.ACTION_GET_CONTENT);
  mScriptPicker.putExtra(Intent.EXTRA_LOCAL_ONLY,true);
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  checkForOpenPorts();
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_sniffer_48,new OnClickListener(){
    @Override public void onClick(    View v){
      setStoppedState();
      startActivity(new Intent(MITM.this,Sniffer.class));
      overridePendingTransition(R.anim.slide_in_left,R.anim.slide_out_left);
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_passwords_48,new OnClickListener(){
    @Override public void onClick(    View v){
      setStoppedState();
      startActivity(new Intent(MITM.this,PasswordSniffer.class));
      overridePendingTransition(R.anim.slide_in_left,R.anim.slide_out_left);
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_hijack_48,new OnClickListener(){
    @Override public void onClick(    View v){
      setStoppedState();
      startActivity(new Intent(MITM.this,Hijacker.class));
      overridePendingTransition(R.anim.slide_in_left,R.anim.slide_out_left);
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_kill_48,new OnClickListener(){
    @Override public void onClick(    View v){
      ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        if (System.getCurrentTarget().getType() != Target.Type.ENDPOINT)         new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
 else {
          setStoppedState();
          activity.setVisibility(View.VISIBLE);
          Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
          ConnectionKiller.start();
        }
      }
 else {
        ConnectionKiller.stop();
        activity.setVisibility(View.INVISIBLE);
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_redirect_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new RedirectionDialog(""String_Node_Str"",MITM.this,new RedirectionDialogListener(){
          @Override public void onInputEntered(          String address,          String port){
            if (address.isEmpty() == false && port.isEmpty() == false) {
              try {
                int iport=Integer.parseInt(port);
                if (iport <= 0 || iport > 65535)                 throw new Exception(""String_Node_Str"");
                address=address.startsWith(""String_Node_Str"") ? address : ""String_Node_Str"" + address;
                URL url=new URL(address);
                address=url.getHost();
                activity.setVisibility(View.VISIBLE);
                Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                final String faddress=address;
                final int fport=iport;
                mSpoofSession=new SpoofSession();
                mSpoofSession.start(new OnSessionReadyListener(){
                  @Override public void onSessionReady(){
                    System.getProxy().setRedirection(faddress,fport);
                  }
                }
);
              }
 catch (              Exception e) {
                new ErrorDialog(""String_Node_Str"",e.getMessage(),MITM.this).show();
              }
            }
 else             new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
          }
        }
).show();
      }
 else       setStoppedState();
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_image_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new ChoiceDialog(MITM.this,""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new ChoiceDialogListener(){
          @Override public void onChoice(          int choice){
            if (choice == 0) {
              mCurrentActivity=activity;
              startActivityForResult(mImagePicker,SELECT_PICTURE);
            }
 else {
              new InputDialog(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,false,MITM.this,new InputDialogListener(){
                @Override public void onInputEntered(                String input){
                  String image=input.trim();
                  if (image.isEmpty() == false) {
                    image=image.startsWith(""String_Node_Str"") ? image : ""String_Node_Str"" + image;
                    activity.setVisibility(View.VISIBLE);
                    final String resource=image;
                    mSpoofSession=new SpoofSession();
                    mSpoofSession.start(new OnSessionReadyListener(){
                      @Override public void onSessionReady(){
                        System.getProxy().setFilter(new Proxy.ProxyFilter(){
                          @Override public String onDataReceived(                          String headers,                          String data){
                            data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + resource + ""String_Node_Str"");
                            data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + resource + ""String_Node_Str"");
                            return data;
                          }
                        }
);
                      }
                    }
);
                    Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                  }
 else                   new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
                }
              }
).show();
            }
          }
        }
).show();
      }
 else {
        mCurrentActivity=null;
        setStoppedState();
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_youtube_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new InputDialog(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,false,MITM.this,new InputDialogListener(){
          @Override public void onInputEntered(          String input){
            final String video=input.trim();
            Matcher matcher=YOUTUBE_PATTERN.matcher(input);
            if (video.isEmpty() == false && matcher != null && matcher.find()) {
              final String videoId=matcher.group(1);
              activity.setVisibility(View.VISIBLE);
              Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
              mSpoofSession=new SpoofSession();
              mSpoofSession.start(new OnSessionReadyListener(){
                @Override public void onSessionReady(){
                  System.getProxy().setFilter(new Proxy.ProxyFilter(){
                    @Override public String onDataReceived(                    String headers,                    String data){
                      if (data.matches(""String_Node_Str""))                       data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + videoId);
 else                       if (data.matches(""String_Node_Str""))                       data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + videoId);
 else                       if (data.matches(""String_Node_Str""))                       data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + videoId);
                      return data;
                    }
                  }
);
                }
              }
);
            }
 else             new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
          }
        }
).show();
      }
 else       setStoppedState();
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_injection_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new ChoiceDialog(MITM.this,""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new ChoiceDialogListener(){
          @Override public void onChoice(          int choice){
            if (choice == 0) {
              mCurrentActivity=activity;
              startActivityForResult(mScriptPicker,SELECT_SCRIPT);
            }
 else {
              new InputDialog(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",true,false,MITM.this,new InputDialogListener(){
                @Override public void onInputEntered(                String input){
                  final String js=input.trim();
                  if (js.isEmpty() == false || js.startsWith(""String_Node_Str"") == false) {
                    activity.setVisibility(View.VISIBLE);
                    Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                    mSpoofSession=new SpoofSession();
                    mSpoofSession.start(new OnSessionReadyListener(){
                      @Override public void onSessionReady(){
                        System.getProxy().setFilter(new Proxy.ProxyFilter(){
                          @Override public String onDataReceived(                          String headers,                          String data){
                            return data.replaceAll(""String_Node_Str"",js + ""String_Node_Str"");
                          }
                        }
);
                      }
                    }
);
                  }
 else                   new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
                }
              }
).show();
            }
          }
        }
).show();
      }
 else {
        mCurrentActivity=null;
        setStoppedState();
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new CustomFilterDialog(""String_Node_Str"",MITM.this,new CustomFilterDialogListener(){
          @Override public void onInputEntered(          final ArrayList<String> from,          final ArrayList<String> to){
            if (from.isEmpty() == false && to.isEmpty() == false) {
              try {
                for (                String exp : from) {
                  Pattern.compile(exp);
                }
                activity.setVisibility(View.VISIBLE);
                Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                mSpoofSession=new SpoofSession();
                mSpoofSession.start(new OnSessionReadyListener(){
                  @Override public void onSessionReady(){
                    System.getProxy().setFilter(new ProxyFilter(){
                      @Override public String onDataReceived(                      String headers,                      String data){
                        for (int i=0; i < from.size(); i++) {
                          data=data.replaceAll(from.get(i),to.get(i));
                        }
                        return data;
                      }
                    }
);
                  }
                }
);
              }
 catch (              PatternSyntaxException e) {
                new ErrorDialog(""String_Node_Str"",""String_Node_Str"" + e.getDescription() + ""String_Node_Str"",MITM.this).show();
              }
            }
 else             new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
          }
        }
).show();
      }
 else       setStoppedState();
    }
  }
));
  mActionListView=(ListView)findViewById(R.id.actionListView);
  mActionAdapter=new ActionAdapter(R.layout.plugin_mitm_list_item,mActions);
  mActionListView.setAdapter(mActionAdapter);
  mImagePicker=new Intent(Intent.ACTION_PICK,android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI);
  mImagePicker.setType(""String_Node_Str"");
  mImagePicker.putExtra(Intent.EXTRA_LOCAL_ONLY,true);
  mScriptPicker=new Intent();
  mScriptPicker.addCategory(Intent.CATEGORY_OPENABLE);
  mScriptPicker.setType(""String_Node_Str"");
  mScriptPicker.setAction(Intent.ACTION_GET_CONTENT);
  mScriptPicker.putExtra(Intent.EXTRA_LOCAL_ONLY,true);
}"
54275,"@Override public void onReceive(Context context,Intent intent){
  if (mUpdateStatus != null && intent.getAction().equals(UpdateChecker.UPDATE_CHECKING) && mUpdateStatus != null) {
    mUpdateStatus.setText(NO_WIFI_UPDATE_MESSAGE.replace(""String_Node_Str"",""String_Node_Str""));
  }
 else   if (mUpdateStatus != null && intent.getAction().equals(UpdateChecker.UPDATE_NOT_AVAILABLE) && mUpdateStatus != null) {
    mUpdateStatus.setText(NO_WIFI_UPDATE_MESSAGE.replace(""String_Node_Str"",""String_Node_Str""));
  }
 else   if (intent.getAction().equals(UpdateChecker.UPDATE_AVAILABLE)) {
    final String remoteVersion=(String)intent.getExtras().get(UpdateChecker.AVAILABLE_VERSION);
    if (mUpdateStatus != null)     mUpdateStatus.setText(NO_WIFI_UPDATE_MESSAGE.replace(""String_Node_Str"",""String_Node_Str"" + remoteVersion + ""String_Node_Str""));
    MainActivity.this.runOnUiThread(new Runnable(){
      @Override public void run(){
        new ConfirmDialog(""String_Node_Str"",""String_Node_Str"" + remoteVersion + ""String_Node_Str"",MainActivity.this,new ConfirmDialogListener(){
          @Override public void onConfirm(){
            final ProgressDialog dialog=new ProgressDialog(MainActivity.this);
            dialog.setMessage(""String_Node_Str"");
            dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
            dialog.setMax(100);
            dialog.setCancelable(false);
            dialog.setButton(DialogInterface.BUTTON_NEGATIVE,""String_Node_Str"",new DialogInterface.OnClickListener(){
              @Override public void onClick(              DialogInterface dialog,              int which){
                dialog.dismiss();
              }
            }
);
            dialog.show();
            new Thread(new Runnable(){
              @Override public void run(){
                if (System.getUpdateManager().downloadUpdate(MainActivity.this,dialog) == false) {
                  MainActivity.this.runOnUiThread(new Runnable(){
                    @Override public void run(){
                      new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MainActivity.this).show();
                    }
                  }
);
                }
                dialog.dismiss();
              }
            }
).start();
          }
          @Override public void onCancel(){
          }
        }
).show();
      }
    }
);
  }
}","@Override public void onReceive(Context context,Intent intent){
  if (mUpdateStatus != null && intent.getAction().equals(UpdateChecker.UPDATE_CHECKING) && mUpdateStatus != null) {
    mUpdateStatus.setText(NO_WIFI_UPDATE_MESSAGE.replace(""String_Node_Str"",""String_Node_Str""));
  }
 else   if (mUpdateStatus != null && intent.getAction().equals(UpdateChecker.UPDATE_NOT_AVAILABLE) && mUpdateStatus != null) {
    mUpdateStatus.setText(NO_WIFI_UPDATE_MESSAGE.replace(""String_Node_Str"",""String_Node_Str""));
  }
 else   if (intent.getAction().equals(UpdateChecker.UPDATE_AVAILABLE)) {
    final String remoteVersion=(String)intent.getExtras().get(UpdateChecker.AVAILABLE_VERSION);
    if (mUpdateStatus != null)     mUpdateStatus.setText(NO_WIFI_UPDATE_MESSAGE.replace(""String_Node_Str"",""String_Node_Str"" + remoteVersion + ""String_Node_Str""));
    MainActivity.this.runOnUiThread(new Runnable(){
      @Override public void run(){
        new ConfirmDialog(""String_Node_Str"",""String_Node_Str"" + remoteVersion + ""String_Node_Str"",MainActivity.this,new ConfirmDialogListener(){
          @Override public void onConfirm(){
            final ProgressDialog dialog=new ProgressDialog(MainActivity.this);
            dialog.setTitle(""String_Node_Str"");
            dialog.setMessage(""String_Node_Str"");
            dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
            dialog.setMax(100);
            dialog.setCancelable(false);
            dialog.setButton(DialogInterface.BUTTON_NEGATIVE,""String_Node_Str"",new DialogInterface.OnClickListener(){
              @Override public void onClick(              DialogInterface dialog,              int which){
                dialog.dismiss();
              }
            }
);
            dialog.show();
            new Thread(new Runnable(){
              @Override public void run(){
                if (System.getUpdateManager().downloadUpdate(MainActivity.this,dialog) == false) {
                  MainActivity.this.runOnUiThread(new Runnable(){
                    @Override public void run(){
                      new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MainActivity.this).show();
                    }
                  }
);
                }
                dialog.dismiss();
              }
            }
).start();
          }
          @Override public void onCancel(){
          }
        }
).show();
      }
    }
);
  }
}"
54276,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  checkForOpenPorts();
  mActionListView=(ListView)findViewById(R.id.actionListView);
  mActionAdapter=new ActionAdapter(R.layout.plugin_mitm_list_item,mActions);
  mActionListView.setAdapter(mActionAdapter);
  mImagePicker=new Intent(Intent.ACTION_PICK,android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI);
  mImagePicker.setType(""String_Node_Str"");
  mImagePicker.putExtra(Intent.EXTRA_LOCAL_ONLY,true);
  mScriptPicker=new Intent();
  mScriptPicker.addCategory(Intent.CATEGORY_OPENABLE);
  mScriptPicker.setType(""String_Node_Str"");
  mScriptPicker.setAction(Intent.ACTION_GET_CONTENT);
  mScriptPicker.putExtra(Intent.EXTRA_LOCAL_ONLY,true);
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_sniffer_48,new OnClickListener(){
    @Override public void onClick(    View v){
      setStoppedState();
      startActivity(new Intent(MITM.this,Sniffer.class));
      overridePendingTransition(R.anim.slide_in_left,R.anim.slide_out_left);
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_passwords_48,new OnClickListener(){
    @Override public void onClick(    View v){
      setStoppedState();
      startActivity(new Intent(MITM.this,PasswordSniffer.class));
      overridePendingTransition(R.anim.slide_in_left,R.anim.slide_out_left);
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_hijack_48,new OnClickListener(){
    @Override public void onClick(    View v){
      setStoppedState();
      startActivity(new Intent(MITM.this,Hijacker.class));
      overridePendingTransition(R.anim.slide_in_left,R.anim.slide_out_left);
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_kill_48,new OnClickListener(){
    @Override public void onClick(    View v){
      ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        if (System.getCurrentTarget().getType() != Target.Type.ENDPOINT)         new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
 else {
          setStoppedState();
          activity.setVisibility(View.VISIBLE);
          Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
          ConnectionKiller.start();
        }
      }
 else {
        ConnectionKiller.stop();
        activity.setVisibility(View.INVISIBLE);
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_redirect_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new RedirectionDialog(""String_Node_Str"",MITM.this,new RedirectionDialogListener(){
          @Override public void onInputEntered(          String address,          String port){
            if (address.isEmpty() == false && port.isEmpty() == false) {
              try {
                int iport=Integer.parseInt(port);
                if (iport <= 0 || iport > 65535)                 throw new Exception(""String_Node_Str"");
                address=address.startsWith(""String_Node_Str"") ? address : ""String_Node_Str"" + address;
                URL url=new URL(address);
                address=url.getHost();
                activity.setVisibility(View.VISIBLE);
                Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                final String faddress=address;
                final int fport=iport;
                mSpoofSession=new SpoofSession();
                mSpoofSession.start(new OnSessionReadyListener(){
                  @Override public void onSessionReady(){
                    System.getProxy().setRedirection(faddress,fport);
                  }
                }
);
              }
 catch (              Exception e) {
                new ErrorDialog(""String_Node_Str"",e.getMessage(),MITM.this).show();
              }
            }
 else             new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
          }
        }
).show();
      }
 else       setStoppedState();
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_image_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new ChoiceDialog(MITM.this,""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new ChoiceDialogListener(){
          @Override public void onChoice(          int choice){
            if (choice == 0) {
              try {
                mCurrentActivity=activity;
                startActivityForResult(mImagePicker,SELECT_PICTURE);
              }
 catch (              ActivityNotFoundException e) {
                new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
              }
            }
 else {
              new InputDialog(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,false,MITM.this,new InputDialogListener(){
                @Override public void onInputEntered(                String input){
                  String image=input.trim();
                  if (image.isEmpty() == false) {
                    image=image.startsWith(""String_Node_Str"") ? image : ""String_Node_Str"" + image;
                    activity.setVisibility(View.VISIBLE);
                    final String resource=image;
                    mSpoofSession=new SpoofSession();
                    mSpoofSession.start(new OnSessionReadyListener(){
                      @Override public void onSessionReady(){
                        System.getProxy().setFilter(new Proxy.ProxyFilter(){
                          @Override public String onDataReceived(                          String headers,                          String data){
                            data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + resource + ""String_Node_Str"");
                            data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + resource + ""String_Node_Str"");
                            return data;
                          }
                        }
);
                      }
                    }
);
                    Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                  }
 else                   new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
                }
              }
).show();
            }
          }
        }
).show();
      }
 else {
        mCurrentActivity=null;
        setStoppedState();
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_youtube_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new InputDialog(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,false,MITM.this,new InputDialogListener(){
          @Override public void onInputEntered(          String input){
            final String video=input.trim();
            Matcher matcher=YOUTUBE_PATTERN.matcher(input);
            if (video.isEmpty() == false && matcher != null && matcher.find()) {
              final String videoId=matcher.group(1);
              activity.setVisibility(View.VISIBLE);
              Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
              mSpoofSession=new SpoofSession();
              mSpoofSession.start(new OnSessionReadyListener(){
                @Override public void onSessionReady(){
                  System.getProxy().setFilter(new Proxy.ProxyFilter(){
                    @Override public String onDataReceived(                    String headers,                    String data){
                      if (data.matches(""String_Node_Str""))                       data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + videoId);
 else                       if (data.matches(""String_Node_Str""))                       data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + videoId);
 else                       if (data.matches(""String_Node_Str""))                       data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + videoId);
                      return data;
                    }
                  }
);
                }
              }
);
            }
 else             new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
          }
        }
).show();
      }
 else       setStoppedState();
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_injection_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new ChoiceDialog(MITM.this,""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new ChoiceDialogListener(){
          @Override public void onChoice(          int choice){
            if (choice == 0) {
              try {
                mCurrentActivity=activity;
                startActivityForResult(mScriptPicker,SELECT_SCRIPT);
              }
 catch (              ActivityNotFoundException e) {
                new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
              }
            }
 else {
              new InputDialog(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",true,false,MITM.this,new InputDialogListener(){
                @Override public void onInputEntered(                String input){
                  final String js=input.trim();
                  if (js.isEmpty() == false || js.startsWith(""String_Node_Str"") == false) {
                    activity.setVisibility(View.VISIBLE);
                    Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                    mSpoofSession=new SpoofSession();
                    mSpoofSession.start(new OnSessionReadyListener(){
                      @Override public void onSessionReady(){
                        System.getProxy().setFilter(new Proxy.ProxyFilter(){
                          @Override public String onDataReceived(                          String headers,                          String data){
                            return data.replaceAll(""String_Node_Str"",js + ""String_Node_Str"");
                          }
                        }
);
                      }
                    }
);
                  }
 else                   new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
                }
              }
).show();
            }
          }
        }
).show();
      }
 else {
        mCurrentActivity=null;
        setStoppedState();
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new CustomFilterDialog(""String_Node_Str"",MITM.this,new CustomFilterDialogListener(){
          @Override public void onInputEntered(          final ArrayList<String> from,          final ArrayList<String> to){
            if (from.isEmpty() == false && to.isEmpty() == false) {
              try {
                for (                String exp : from) {
                  Pattern.compile(exp);
                }
                activity.setVisibility(View.VISIBLE);
                Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                mSpoofSession=new SpoofSession();
                mSpoofSession.start(new OnSessionReadyListener(){
                  @Override public void onSessionReady(){
                    System.getProxy().setFilter(new ProxyFilter(){
                      @Override public String onDataReceived(                      String headers,                      String data){
                        for (int i=0; i < from.size(); i++) {
                          data=data.replaceAll(from.get(i),to.get(i));
                        }
                        return data;
                      }
                    }
);
                  }
                }
);
              }
 catch (              PatternSyntaxException e) {
                new ErrorDialog(""String_Node_Str"",""String_Node_Str"" + e.getDescription() + ""String_Node_Str"",MITM.this).show();
              }
            }
 else             new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
          }
        }
).show();
      }
 else       setStoppedState();
    }
  }
));
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  new CheckForOpenPortsTask().execute();
  mActionListView=(ListView)findViewById(R.id.actionListView);
  mActionAdapter=new ActionAdapter(R.layout.plugin_mitm_list_item,mActions);
  mActionListView.setAdapter(mActionAdapter);
  mImagePicker=new Intent(Intent.ACTION_PICK,android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI);
  mImagePicker.setType(""String_Node_Str"");
  mImagePicker.putExtra(Intent.EXTRA_LOCAL_ONLY,true);
  mScriptPicker=new Intent();
  mScriptPicker.addCategory(Intent.CATEGORY_OPENABLE);
  mScriptPicker.setType(""String_Node_Str"");
  mScriptPicker.setAction(Intent.ACTION_GET_CONTENT);
  mScriptPicker.putExtra(Intent.EXTRA_LOCAL_ONLY,true);
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_sniffer_48,new OnClickListener(){
    @Override public void onClick(    View v){
      setStoppedState();
      startActivity(new Intent(MITM.this,Sniffer.class));
      overridePendingTransition(R.anim.slide_in_left,R.anim.slide_out_left);
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_passwords_48,new OnClickListener(){
    @Override public void onClick(    View v){
      setStoppedState();
      startActivity(new Intent(MITM.this,PasswordSniffer.class));
      overridePendingTransition(R.anim.slide_in_left,R.anim.slide_out_left);
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_hijack_48,new OnClickListener(){
    @Override public void onClick(    View v){
      setStoppedState();
      startActivity(new Intent(MITM.this,Hijacker.class));
      overridePendingTransition(R.anim.slide_in_left,R.anim.slide_out_left);
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_kill_48,new OnClickListener(){
    @Override public void onClick(    View v){
      ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        if (System.getCurrentTarget().getType() != Target.Type.ENDPOINT)         new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
 else {
          setStoppedState();
          activity.setVisibility(View.VISIBLE);
          Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
          ConnectionKiller.start();
        }
      }
 else {
        ConnectionKiller.stop();
        activity.setVisibility(View.INVISIBLE);
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_redirect_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new RedirectionDialog(""String_Node_Str"",MITM.this,new RedirectionDialogListener(){
          @Override public void onInputEntered(          String address,          String port){
            if (address.isEmpty() == false && port.isEmpty() == false) {
              try {
                int iport=Integer.parseInt(port);
                if (iport <= 0 || iport > 65535)                 throw new Exception(""String_Node_Str"");
                address=address.startsWith(""String_Node_Str"") ? address : ""String_Node_Str"" + address;
                URL url=new URL(address);
                address=url.getHost();
                activity.setVisibility(View.VISIBLE);
                Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                final String faddress=address;
                final int fport=iport;
                mSpoofSession=new SpoofSession();
                mSpoofSession.start(new OnSessionReadyListener(){
                  @Override public void onSessionReady(){
                    System.getProxy().setRedirection(faddress,fport);
                  }
                }
);
              }
 catch (              Exception e) {
                new ErrorDialog(""String_Node_Str"",e.getMessage(),MITM.this).show();
              }
            }
 else             new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
          }
        }
).show();
      }
 else       setStoppedState();
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_image_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new ChoiceDialog(MITM.this,""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new ChoiceDialogListener(){
          @Override public void onChoice(          int choice){
            if (choice == 0) {
              try {
                mCurrentActivity=activity;
                startActivityForResult(mImagePicker,SELECT_PICTURE);
              }
 catch (              ActivityNotFoundException e) {
                new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
              }
            }
 else {
              new InputDialog(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,false,MITM.this,new InputDialogListener(){
                @Override public void onInputEntered(                String input){
                  String image=input.trim();
                  if (image.isEmpty() == false) {
                    image=image.startsWith(""String_Node_Str"") ? image : ""String_Node_Str"" + image;
                    activity.setVisibility(View.VISIBLE);
                    final String resource=image;
                    mSpoofSession=new SpoofSession();
                    mSpoofSession.start(new OnSessionReadyListener(){
                      @Override public void onSessionReady(){
                        System.getProxy().setFilter(new Proxy.ProxyFilter(){
                          @Override public String onDataReceived(                          String headers,                          String data){
                            data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + resource + ""String_Node_Str"");
                            data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + resource + ""String_Node_Str"");
                            return data;
                          }
                        }
);
                      }
                    }
);
                    Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                  }
 else                   new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
                }
              }
).show();
            }
          }
        }
).show();
      }
 else {
        mCurrentActivity=null;
        setStoppedState();
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_youtube_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new InputDialog(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,false,MITM.this,new InputDialogListener(){
          @Override public void onInputEntered(          String input){
            final String video=input.trim();
            Matcher matcher=YOUTUBE_PATTERN.matcher(input);
            if (video.isEmpty() == false && matcher != null && matcher.find()) {
              final String videoId=matcher.group(1);
              activity.setVisibility(View.VISIBLE);
              Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
              mSpoofSession=new SpoofSession();
              mSpoofSession.start(new OnSessionReadyListener(){
                @Override public void onSessionReady(){
                  System.getProxy().setFilter(new Proxy.ProxyFilter(){
                    @Override public String onDataReceived(                    String headers,                    String data){
                      if (data.matches(""String_Node_Str""))                       data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + videoId);
 else                       if (data.matches(""String_Node_Str""))                       data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + videoId);
 else                       if (data.matches(""String_Node_Str""))                       data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + videoId);
                      return data;
                    }
                  }
);
                }
              }
);
            }
 else             new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
          }
        }
).show();
      }
 else       setStoppedState();
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_injection_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new ChoiceDialog(MITM.this,""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new ChoiceDialogListener(){
          @Override public void onChoice(          int choice){
            if (choice == 0) {
              try {
                mCurrentActivity=activity;
                startActivityForResult(mScriptPicker,SELECT_SCRIPT);
              }
 catch (              ActivityNotFoundException e) {
                new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
              }
            }
 else {
              new InputDialog(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",true,false,MITM.this,new InputDialogListener(){
                @Override public void onInputEntered(                String input){
                  final String js=input.trim();
                  if (js.isEmpty() == false || js.startsWith(""String_Node_Str"") == false) {
                    activity.setVisibility(View.VISIBLE);
                    Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                    mSpoofSession=new SpoofSession();
                    mSpoofSession.start(new OnSessionReadyListener(){
                      @Override public void onSessionReady(){
                        System.getProxy().setFilter(new Proxy.ProxyFilter(){
                          @Override public String onDataReceived(                          String headers,                          String data){
                            return data.replaceAll(""String_Node_Str"",js + ""String_Node_Str"");
                          }
                        }
);
                      }
                    }
);
                  }
 else                   new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
                }
              }
).show();
            }
          }
        }
).show();
      }
 else {
        mCurrentActivity=null;
        setStoppedState();
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new CustomFilterDialog(""String_Node_Str"",MITM.this,new CustomFilterDialogListener(){
          @Override public void onInputEntered(          final ArrayList<String> from,          final ArrayList<String> to){
            if (from.isEmpty() == false && to.isEmpty() == false) {
              try {
                for (                String exp : from) {
                  Pattern.compile(exp);
                }
                activity.setVisibility(View.VISIBLE);
                Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                mSpoofSession=new SpoofSession();
                mSpoofSession.start(new OnSessionReadyListener(){
                  @Override public void onSessionReady(){
                    System.getProxy().setFilter(new ProxyFilter(){
                      @Override public String onDataReceived(                      String headers,                      String data){
                        for (int i=0; i < from.size(); i++) {
                          data=data.replaceAll(from.get(i),to.get(i));
                        }
                        return data;
                      }
                    }
);
                  }
                }
);
              }
 catch (              PatternSyntaxException e) {
                new ErrorDialog(""String_Node_Str"",""String_Node_Str"" + e.getDescription() + ""String_Node_Str"",MITM.this).show();
              }
            }
 else             new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
          }
        }
).show();
      }
 else       setStoppedState();
    }
  }
));
}"
54277,"@Override protected void onActivityResult(int request,int result,Intent intent){
  super.onActivityResult(request,result,intent);
  if (request == SELECT_PICTURE && result == RESULT_OK) {
    try {
      Uri uri=intent.getData();
      String fileName=null, mimeType=null;
      if (uri != null) {
        String[] columns={MediaColumns.DATA};
        Cursor cursor=getContentResolver().query(uri,columns,null,null,null);
        cursor.moveToFirst();
        int index=cursor.getColumnIndex(MediaColumns.DATA);
        if (index != -1) {
          fileName=cursor.getString(index);
        }
        cursor.close();
      }
      if (fileName == null) {
        setStoppedState();
        new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
      }
 else {
        mimeType=System.getImageMimeType(fileName);
        mSpoofSession=new SpoofSession(true,true,fileName,mimeType);
        if (mCurrentActivity != null)         mCurrentActivity.setVisibility(View.VISIBLE);
        mSpoofSession.start(new OnSessionReadyListener(){
          @Override public void onSessionReady(){
            MITM.this.runOnUiThread(new Runnable(){
              @Override public void run(){
                System.getProxy().setFilter(new Proxy.ProxyFilter(){
                  @Override public String onDataReceived(                  String headers,                  String data){
                    String resource=System.getServer().getResourceURL();
                    data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + resource + ""String_Node_Str"");
                    data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + resource + ""String_Node_Str"");
                    return data;
                  }
                }
);
                Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
              }
            }
);
          }
        }
);
      }
    }
 catch (    Exception e) {
      System.errorLogging(TAG,e);
    }
  }
 else   if (request == SELECT_SCRIPT && result == RESULT_OK) {
    String fileName=null;
    if (intent != null && intent.getData() != null)     fileName=intent.getData().getPath();
    if (fileName == null) {
      new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
    }
 else {
      try {
        StringBuffer buffer=new StringBuffer();
        BufferedReader reader=new BufferedReader(new FileReader(fileName));
        char[] buf=new char[1024];
        int read=0;
        String js=""String_Node_Str"";
        while ((read=reader.read(buf)) != -1) {
          buffer.append(String.valueOf(buf,0,read));
        }
        reader.close();
        js=buffer.toString().trim();
        if (js.startsWith(""String_Node_Str"") == false && js.startsWith(""String_Node_Str"") == false)         js=""String_Node_Str"" + js + ""String_Node_Str"";
        mCurrentActivity.setVisibility(View.VISIBLE);
        Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
        final String code=js;
        mSpoofSession=new SpoofSession();
        mSpoofSession.start(new OnSessionReadyListener(){
          @Override public void onSessionReady(){
            System.getProxy().setFilter(new Proxy.ProxyFilter(){
              @Override public String onDataReceived(              String headers,              String data){
                return data.replaceAll(""String_Node_Str"",code + ""String_Node_Str"");
              }
            }
);
          }
        }
);
      }
 catch (      Exception e) {
        new ErrorDialog(""String_Node_Str"",""String_Node_Str"" + e.getMessage(),MITM.this).show();
      }
    }
  }
 else   if (request == SettingsActivity.SETTINGS_DONE) {
    checkForOpenPorts();
  }
}","@Override protected void onActivityResult(int request,int result,Intent intent){
  super.onActivityResult(request,result,intent);
  if (request == SELECT_PICTURE && result == RESULT_OK) {
    try {
      Uri uri=intent.getData();
      String fileName=null, mimeType=null;
      if (uri != null) {
        String[] columns={MediaColumns.DATA};
        Cursor cursor=getContentResolver().query(uri,columns,null,null,null);
        cursor.moveToFirst();
        int index=cursor.getColumnIndex(MediaColumns.DATA);
        if (index != -1) {
          fileName=cursor.getString(index);
        }
        cursor.close();
      }
      if (fileName == null) {
        setStoppedState();
        new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
      }
 else {
        mimeType=System.getImageMimeType(fileName);
        mSpoofSession=new SpoofSession(true,true,fileName,mimeType);
        if (mCurrentActivity != null)         mCurrentActivity.setVisibility(View.VISIBLE);
        mSpoofSession.start(new OnSessionReadyListener(){
          @Override public void onSessionReady(){
            MITM.this.runOnUiThread(new Runnable(){
              @Override public void run(){
                System.getProxy().setFilter(new Proxy.ProxyFilter(){
                  @Override public String onDataReceived(                  String headers,                  String data){
                    String resource=System.getServer().getResourceURL();
                    data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + resource + ""String_Node_Str"");
                    data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + resource + ""String_Node_Str"");
                    return data;
                  }
                }
);
                Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
              }
            }
);
          }
        }
);
      }
    }
 catch (    Exception e) {
      System.errorLogging(TAG,e);
    }
  }
 else   if (request == SELECT_SCRIPT && result == RESULT_OK) {
    String fileName=null;
    if (intent != null && intent.getData() != null)     fileName=intent.getData().getPath();
    if (fileName == null) {
      new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
    }
 else {
      try {
        StringBuffer buffer=new StringBuffer();
        BufferedReader reader=new BufferedReader(new FileReader(fileName));
        char[] buf=new char[1024];
        int read=0;
        String js=""String_Node_Str"";
        while ((read=reader.read(buf)) != -1) {
          buffer.append(String.valueOf(buf,0,read));
        }
        reader.close();
        js=buffer.toString().trim();
        if (js.startsWith(""String_Node_Str"") == false && js.startsWith(""String_Node_Str"") == false)         js=""String_Node_Str"" + js + ""String_Node_Str"";
        mCurrentActivity.setVisibility(View.VISIBLE);
        Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
        final String code=js;
        mSpoofSession=new SpoofSession();
        mSpoofSession.start(new OnSessionReadyListener(){
          @Override public void onSessionReady(){
            System.getProxy().setFilter(new Proxy.ProxyFilter(){
              @Override public String onDataReceived(              String headers,              String data){
                return data.replaceAll(""String_Node_Str"",code + ""String_Node_Str"");
              }
            }
);
          }
        }
);
      }
 catch (      Exception e) {
        new ErrorDialog(""String_Node_Str"",""String_Node_Str"" + e.getMessage(),MITM.this).show();
      }
    }
  }
 else   if (request == SettingsActivity.SETTINGS_DONE) {
    new CheckForOpenPortsTask().execute();
  }
}"
54278,"@Override protected void onListItemClick(ListView l,View v,int position,long id){
  super.onListItemClick(l,v,position,id);
  final ScanResult result=mAdapter.getItem(position);
  if (result != null) {
    final Keygen keygen=mWifiMatcher.getKeygen(result);
    if (keygen != null && (result.capabilities.contains(""String_Node_Str"") || result.capabilities.contains(""String_Node_Str""))) {
      mKeyList.clear();
      new WifiCrackDialog(""String_Node_Str"",""String_Node_Str"",this,new WifiCrackDialogListener(){
        @Override public void onManualConnect(        String key){
          mCurrentNetworkId=performConnection(result,key);
          if (mCurrentNetworkId != -1)           mConnectionReceiver.register(WifiScannerActivity.this);
 else           mConnectionReceiver.unregister();
        }
        @Override public void onCrack(){
          performCracking(keygen,result);
        }
      }
).show();
    }
 else {
      if (result.capabilities.contains(""String_Node_Str"") || result.capabilities.contains(""String_Node_Str"")) {
        new InputDialog(""String_Node_Str"",""String_Node_Str"",null,true,true,this,new InputDialogListener(){
          @Override public void onInputEntered(          String input){
            mCurrentNetworkId=performConnection(result,input);
            if (mCurrentNetworkId != -1)             mConnectionReceiver.register(WifiScannerActivity.this);
 else             mConnectionReceiver.unregister();
          }
        }
).show();
      }
 else       performConnection(result,null);
    }
  }
}","@Override protected void onListItemClick(ListView l,View v,int position,long id){
  super.onListItemClick(l,v,position,id);
  final ScanResult result=mAdapter.getItem(position);
  if (result != null) {
    final Keygen keygen=mWifiMatcher.getKeygen(result);
    if (keygen != null && (result.capabilities.contains(""String_Node_Str"") || result.capabilities.contains(""String_Node_Str""))) {
      mKeyList.clear();
      new WifiCrackDialog(result.SSID,""String_Node_Str"",this,new WifiCrackDialogListener(){
        @Override public void onManualConnect(        String key){
          mCurrentNetworkId=performConnection(result,key);
          if (mCurrentNetworkId != -1)           mConnectionReceiver.register(WifiScannerActivity.this);
 else           mConnectionReceiver.unregister();
        }
        @Override public void onCrack(){
          performCracking(keygen,result);
        }
      }
).show();
    }
 else {
      if (result.capabilities.contains(""String_Node_Str"") || result.capabilities.contains(""String_Node_Str"")) {
        new InputDialog(result.SSID,""String_Node_Str"",null,true,true,this,new InputDialogListener(){
          @Override public void onInputEntered(          String input){
            mCurrentNetworkId=performConnection(result,input);
            if (mCurrentNetworkId != -1)             mConnectionReceiver.register(WifiScannerActivity.this);
 else             mConnectionReceiver.unregister();
          }
        }
).show();
      }
 else       performConnection(result,null);
    }
  }
}"
54279,"@Override public void run(){
  Log.d(TAG,""String_Node_Str"");
  mStopped=false;
  int i, nhosts=0;
  IP4Address current=null;
  try {
    mNetwork=System.getNetwork();
    nhosts=mNetwork.getNumberOfAddresses();
  }
 catch (  Exception e) {
    System.errorLogging(TAG,e);
  }
  while (mStopped == false && mNetwork != null && nhosts > 0) {
    try {
      for (i=1, current=IP4Address.next(mNetwork.getStartAddress()); current != null && i <= nhosts; current=IP4Address.next(current), i++) {
        InetAddress address=current.toInetAddress();
        DatagramSocket socket=new DatagramSocket();
        DatagramPacket packet=new DatagramPacket(NETBIOS_REQUEST,NETBIOS_REQUEST.length,address,NETBIOS_UDP_PORT);
        socket.setSoTimeout(200);
        socket.send(packet);
        new NBResolver(address,socket).start();
      }
      Thread.sleep(1000);
    }
 catch (    Exception e) {
      System.errorLogging(TAG,e);
    }
  }
}","@Override public void run(){
  Log.d(TAG,""String_Node_Str"");
  mStopped=false;
  int i, nhosts=0;
  IP4Address current=null;
  try {
    mNetwork=System.getNetwork();
    nhosts=mNetwork.getNumberOfAddresses();
  }
 catch (  Exception e) {
    System.errorLogging(TAG,e);
  }
  while (mStopped == false && mNetwork != null && nhosts > 0) {
    try {
      for (i=1, current=IP4Address.next(mNetwork.getStartAddress()); current != null && i <= nhosts; current=IP4Address.next(current), i++) {
        if (current.equals(mNetwork.getGatewayAddress()) == false && current.equals(mNetwork.getLocalAddress()) == false) {
          InetAddress address=current.toInetAddress();
          DatagramSocket socket=new DatagramSocket();
          DatagramPacket packet=new DatagramPacket(NETBIOS_REQUEST,NETBIOS_REQUEST.length,address,NETBIOS_UDP_PORT);
          socket.setSoTimeout(200);
          socket.send(packet);
          new NBResolver(address,socket).start();
        }
      }
      Thread.sleep(1000);
    }
 catch (    Exception e) {
      System.errorLogging(TAG,e);
    }
  }
}"
54280,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  checkForOpenPorts();
  mActionListView=(ListView)findViewById(R.id.actionListView);
  mActionAdapter=new ActionAdapter(R.layout.plugin_mitm_list_item,mActions);
  mActionListView.setAdapter(mActionAdapter);
  mImagePicker=new Intent(Intent.ACTION_PICK,android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI);
  mImagePicker.setType(""String_Node_Str"");
  mImagePicker.putExtra(Intent.EXTRA_LOCAL_ONLY,true);
  mScriptPicker=new Intent();
  mScriptPicker.addCategory(Intent.CATEGORY_OPENABLE);
  mScriptPicker.setType(""String_Node_Str"");
  mScriptPicker.setAction(Intent.ACTION_GET_CONTENT);
  mScriptPicker.putExtra(Intent.EXTRA_LOCAL_ONLY,true);
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_sniffer_48,new OnClickListener(){
    @Override public void onClick(    View v){
      setStoppedState();
      startActivity(new Intent(MITM.this,Sniffer.class));
      overridePendingTransition(R.anim.slide_in_left,R.anim.slide_out_left);
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_passwords_48,new OnClickListener(){
    @Override public void onClick(    View v){
      setStoppedState();
      startActivity(new Intent(MITM.this,PasswordSniffer.class));
      overridePendingTransition(R.anim.slide_in_left,R.anim.slide_out_left);
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_hijack_48,new OnClickListener(){
    @Override public void onClick(    View v){
      setStoppedState();
      startActivity(new Intent(MITM.this,Hijacker.class));
      overridePendingTransition(R.anim.slide_in_left,R.anim.slide_out_left);
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_kill_48,new OnClickListener(){
    @Override public void onClick(    View v){
      ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        if (System.getCurrentTarget().getType() != Target.Type.ENDPOINT)         new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
 else {
          setStoppedState();
          activity.setVisibility(View.VISIBLE);
          Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
          ConnectionKiller.start();
        }
      }
 else {
        ConnectionKiller.stop();
        activity.setVisibility(View.INVISIBLE);
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_redirect_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new RedirectionDialog(""String_Node_Str"",MITM.this,new RedirectionDialogListener(){
          @Override public void onInputEntered(          String address,          String port){
            if (address.isEmpty() == false && port.isEmpty() == false) {
              try {
                int iport=Integer.parseInt(port);
                if (iport <= 0 || iport > 65535)                 throw new Exception(""String_Node_Str"");
                address=address.startsWith(""String_Node_Str"") ? address : ""String_Node_Str"" + address;
                URL url=new URL(address);
                address=url.getHost();
                activity.setVisibility(View.VISIBLE);
                Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                final String faddress=address;
                final int fport=iport;
                mSpoofSession=new SpoofSession();
                mSpoofSession.start(new OnSessionReadyListener(){
                  @Override public void onSessionReady(){
                    System.getProxy().setRedirection(faddress,fport);
                  }
                }
);
              }
 catch (              Exception e) {
                new ErrorDialog(""String_Node_Str"",e.getMessage(),MITM.this).show();
              }
            }
 else             new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
          }
        }
).show();
      }
 else       setStoppedState();
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_image_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new ChoiceDialog(MITM.this,""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new ChoiceDialogListener(){
          @Override public void onChoice(          int choice){
            if (choice == 0) {
              mCurrentActivity=activity;
              startActivityForResult(mImagePicker,SELECT_PICTURE);
            }
 else {
              new InputDialog(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,false,MITM.this,new InputDialogListener(){
                @Override public void onInputEntered(                String input){
                  String image=input.trim();
                  if (image.isEmpty() == false) {
                    image=image.startsWith(""String_Node_Str"") ? image : ""String_Node_Str"" + image;
                    activity.setVisibility(View.VISIBLE);
                    final String resource=image;
                    mSpoofSession=new SpoofSession();
                    mSpoofSession.start(new OnSessionReadyListener(){
                      @Override public void onSessionReady(){
                        System.getProxy().setFilter(new Proxy.ProxyFilter(){
                          @Override public String onDataReceived(                          String headers,                          String data){
                            data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + resource + ""String_Node_Str"");
                            data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + resource + ""String_Node_Str"");
                            return data;
                          }
                        }
);
                      }
                    }
);
                    Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                  }
 else                   new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
                }
              }
).show();
            }
          }
        }
).show();
      }
 else {
        mCurrentActivity=null;
        setStoppedState();
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_youtube_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new InputDialog(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,false,MITM.this,new InputDialogListener(){
          @Override public void onInputEntered(          String input){
            final String video=input.trim();
            Matcher matcher=YOUTUBE_PATTERN.matcher(input);
            if (video.isEmpty() == false && matcher != null && matcher.find()) {
              final String videoId=matcher.group(1);
              activity.setVisibility(View.VISIBLE);
              Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
              mSpoofSession=new SpoofSession();
              mSpoofSession.start(new OnSessionReadyListener(){
                @Override public void onSessionReady(){
                  System.getProxy().setFilter(new Proxy.ProxyFilter(){
                    @Override public String onDataReceived(                    String headers,                    String data){
                      if (data.matches(""String_Node_Str""))                       data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + videoId);
 else                       if (data.matches(""String_Node_Str""))                       data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + videoId);
 else                       if (data.matches(""String_Node_Str""))                       data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + videoId);
                      return data;
                    }
                  }
);
                }
              }
);
            }
 else             new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
          }
        }
).show();
      }
 else       setStoppedState();
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_injection_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new ChoiceDialog(MITM.this,""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new ChoiceDialogListener(){
          @Override public void onChoice(          int choice){
            if (choice == 0) {
              mCurrentActivity=activity;
              startActivityForResult(mScriptPicker,SELECT_SCRIPT);
            }
 else {
              new InputDialog(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",true,false,MITM.this,new InputDialogListener(){
                @Override public void onInputEntered(                String input){
                  final String js=input.trim();
                  if (js.isEmpty() == false || js.startsWith(""String_Node_Str"") == false) {
                    activity.setVisibility(View.VISIBLE);
                    Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                    mSpoofSession=new SpoofSession();
                    mSpoofSession.start(new OnSessionReadyListener(){
                      @Override public void onSessionReady(){
                        System.getProxy().setFilter(new Proxy.ProxyFilter(){
                          @Override public String onDataReceived(                          String headers,                          String data){
                            return data.replaceAll(""String_Node_Str"",js + ""String_Node_Str"");
                          }
                        }
);
                      }
                    }
);
                  }
 else                   new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
                }
              }
).show();
            }
          }
        }
).show();
      }
 else {
        mCurrentActivity=null;
        setStoppedState();
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new CustomFilterDialog(""String_Node_Str"",MITM.this,new CustomFilterDialogListener(){
          @Override public void onInputEntered(          final ArrayList<String> from,          final ArrayList<String> to){
            if (from.isEmpty() == false && to.isEmpty() == false) {
              try {
                for (                String exp : from) {
                  Pattern.compile(exp);
                }
                activity.setVisibility(View.VISIBLE);
                Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                mSpoofSession=new SpoofSession();
                mSpoofSession.start(new OnSessionReadyListener(){
                  @Override public void onSessionReady(){
                    System.getProxy().setFilter(new ProxyFilter(){
                      @Override public String onDataReceived(                      String headers,                      String data){
                        for (int i=0; i < from.size(); i++) {
                          data=data.replaceAll(from.get(i),to.get(i));
                        }
                        return data;
                      }
                    }
);
                  }
                }
);
              }
 catch (              PatternSyntaxException e) {
                new ErrorDialog(""String_Node_Str"",""String_Node_Str"" + e.getDescription() + ""String_Node_Str"",MITM.this).show();
              }
            }
 else             new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
          }
        }
).show();
      }
 else       setStoppedState();
    }
  }
));
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  checkForOpenPorts();
  mActionListView=(ListView)findViewById(R.id.actionListView);
  mActionAdapter=new ActionAdapter(R.layout.plugin_mitm_list_item,mActions);
  mActionListView.setAdapter(mActionAdapter);
  mImagePicker=new Intent(Intent.ACTION_PICK,android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI);
  mImagePicker.setType(""String_Node_Str"");
  mImagePicker.putExtra(Intent.EXTRA_LOCAL_ONLY,true);
  mScriptPicker=new Intent();
  mScriptPicker.addCategory(Intent.CATEGORY_OPENABLE);
  mScriptPicker.setType(""String_Node_Str"");
  mScriptPicker.setAction(Intent.ACTION_GET_CONTENT);
  mScriptPicker.putExtra(Intent.EXTRA_LOCAL_ONLY,true);
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_sniffer_48,new OnClickListener(){
    @Override public void onClick(    View v){
      setStoppedState();
      startActivity(new Intent(MITM.this,Sniffer.class));
      overridePendingTransition(R.anim.slide_in_left,R.anim.slide_out_left);
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_passwords_48,new OnClickListener(){
    @Override public void onClick(    View v){
      setStoppedState();
      startActivity(new Intent(MITM.this,PasswordSniffer.class));
      overridePendingTransition(R.anim.slide_in_left,R.anim.slide_out_left);
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_hijack_48,new OnClickListener(){
    @Override public void onClick(    View v){
      setStoppedState();
      startActivity(new Intent(MITM.this,Hijacker.class));
      overridePendingTransition(R.anim.slide_in_left,R.anim.slide_out_left);
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_kill_48,new OnClickListener(){
    @Override public void onClick(    View v){
      ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        if (System.getCurrentTarget().getType() != Target.Type.ENDPOINT)         new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
 else {
          setStoppedState();
          activity.setVisibility(View.VISIBLE);
          Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
          ConnectionKiller.start();
        }
      }
 else {
        ConnectionKiller.stop();
        activity.setVisibility(View.INVISIBLE);
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_redirect_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new RedirectionDialog(""String_Node_Str"",MITM.this,new RedirectionDialogListener(){
          @Override public void onInputEntered(          String address,          String port){
            if (address.isEmpty() == false && port.isEmpty() == false) {
              try {
                int iport=Integer.parseInt(port);
                if (iport <= 0 || iport > 65535)                 throw new Exception(""String_Node_Str"");
                address=address.startsWith(""String_Node_Str"") ? address : ""String_Node_Str"" + address;
                URL url=new URL(address);
                address=url.getHost();
                activity.setVisibility(View.VISIBLE);
                Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                final String faddress=address;
                final int fport=iport;
                mSpoofSession=new SpoofSession();
                mSpoofSession.start(new OnSessionReadyListener(){
                  @Override public void onSessionReady(){
                    System.getProxy().setRedirection(faddress,fport);
                  }
                }
);
              }
 catch (              Exception e) {
                new ErrorDialog(""String_Node_Str"",e.getMessage(),MITM.this).show();
              }
            }
 else             new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
          }
        }
).show();
      }
 else       setStoppedState();
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_image_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new ChoiceDialog(MITM.this,""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new ChoiceDialogListener(){
          @Override public void onChoice(          int choice){
            if (choice == 0) {
              try {
                mCurrentActivity=activity;
                startActivityForResult(mImagePicker,SELECT_PICTURE);
              }
 catch (              ActivityNotFoundException e) {
                new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
              }
            }
 else {
              new InputDialog(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,false,MITM.this,new InputDialogListener(){
                @Override public void onInputEntered(                String input){
                  String image=input.trim();
                  if (image.isEmpty() == false) {
                    image=image.startsWith(""String_Node_Str"") ? image : ""String_Node_Str"" + image;
                    activity.setVisibility(View.VISIBLE);
                    final String resource=image;
                    mSpoofSession=new SpoofSession();
                    mSpoofSession.start(new OnSessionReadyListener(){
                      @Override public void onSessionReady(){
                        System.getProxy().setFilter(new Proxy.ProxyFilter(){
                          @Override public String onDataReceived(                          String headers,                          String data){
                            data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + resource + ""String_Node_Str"");
                            data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + resource + ""String_Node_Str"");
                            return data;
                          }
                        }
);
                      }
                    }
);
                    Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                  }
 else                   new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
                }
              }
).show();
            }
          }
        }
).show();
      }
 else {
        mCurrentActivity=null;
        setStoppedState();
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_youtube_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new InputDialog(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,false,MITM.this,new InputDialogListener(){
          @Override public void onInputEntered(          String input){
            final String video=input.trim();
            Matcher matcher=YOUTUBE_PATTERN.matcher(input);
            if (video.isEmpty() == false && matcher != null && matcher.find()) {
              final String videoId=matcher.group(1);
              activity.setVisibility(View.VISIBLE);
              Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
              mSpoofSession=new SpoofSession();
              mSpoofSession.start(new OnSessionReadyListener(){
                @Override public void onSessionReady(){
                  System.getProxy().setFilter(new Proxy.ProxyFilter(){
                    @Override public String onDataReceived(                    String headers,                    String data){
                      if (data.matches(""String_Node_Str""))                       data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + videoId);
 else                       if (data.matches(""String_Node_Str""))                       data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + videoId);
 else                       if (data.matches(""String_Node_Str""))                       data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + videoId);
                      return data;
                    }
                  }
);
                }
              }
);
            }
 else             new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
          }
        }
).show();
      }
 else       setStoppedState();
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_injection_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new ChoiceDialog(MITM.this,""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""},new ChoiceDialogListener(){
          @Override public void onChoice(          int choice){
            if (choice == 0) {
              try {
                mCurrentActivity=activity;
                startActivityForResult(mScriptPicker,SELECT_SCRIPT);
              }
 catch (              ActivityNotFoundException e) {
                new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
              }
            }
 else {
              new InputDialog(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",true,false,MITM.this,new InputDialogListener(){
                @Override public void onInputEntered(                String input){
                  final String js=input.trim();
                  if (js.isEmpty() == false || js.startsWith(""String_Node_Str"") == false) {
                    activity.setVisibility(View.VISIBLE);
                    Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                    mSpoofSession=new SpoofSession();
                    mSpoofSession.start(new OnSessionReadyListener(){
                      @Override public void onSessionReady(){
                        System.getProxy().setFilter(new Proxy.ProxyFilter(){
                          @Override public String onDataReceived(                          String headers,                          String data){
                            return data.replaceAll(""String_Node_Str"",js + ""String_Node_Str"");
                          }
                        }
);
                      }
                    }
);
                  }
 else                   new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
                }
              }
).show();
            }
          }
        }
).show();
      }
 else {
        mCurrentActivity=null;
        setStoppedState();
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new CustomFilterDialog(""String_Node_Str"",MITM.this,new CustomFilterDialogListener(){
          @Override public void onInputEntered(          final ArrayList<String> from,          final ArrayList<String> to){
            if (from.isEmpty() == false && to.isEmpty() == false) {
              try {
                for (                String exp : from) {
                  Pattern.compile(exp);
                }
                activity.setVisibility(View.VISIBLE);
                Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                mSpoofSession=new SpoofSession();
                mSpoofSession.start(new OnSessionReadyListener(){
                  @Override public void onSessionReady(){
                    System.getProxy().setFilter(new ProxyFilter(){
                      @Override public String onDataReceived(                      String headers,                      String data){
                        for (int i=0; i < from.size(); i++) {
                          data=data.replaceAll(from.get(i),to.get(i));
                        }
                        return data;
                      }
                    }
);
                  }
                }
);
              }
 catch (              PatternSyntaxException e) {
                new ErrorDialog(""String_Node_Str"",""String_Node_Str"" + e.getDescription() + ""String_Node_Str"",MITM.this).show();
              }
            }
 else             new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
          }
        }
).show();
      }
 else       setStoppedState();
    }
  }
));
}"
54281,"@Override public void onChoice(int choice){
  if (choice == 0) {
    mCurrentActivity=activity;
    startActivityForResult(mScriptPicker,SELECT_SCRIPT);
  }
 else {
    new InputDialog(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",true,false,MITM.this,new InputDialogListener(){
      @Override public void onInputEntered(      String input){
        final String js=input.trim();
        if (js.isEmpty() == false || js.startsWith(""String_Node_Str"") == false) {
          activity.setVisibility(View.VISIBLE);
          Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
          mSpoofSession=new SpoofSession();
          mSpoofSession.start(new OnSessionReadyListener(){
            @Override public void onSessionReady(){
              System.getProxy().setFilter(new Proxy.ProxyFilter(){
                @Override public String onDataReceived(                String headers,                String data){
                  return data.replaceAll(""String_Node_Str"",js + ""String_Node_Str"");
                }
              }
);
            }
          }
);
        }
 else         new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
      }
    }
).show();
  }
}","@Override public void onChoice(int choice){
  if (choice == 0) {
    try {
      mCurrentActivity=activity;
      startActivityForResult(mScriptPicker,SELECT_SCRIPT);
    }
 catch (    ActivityNotFoundException e) {
      new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
    }
  }
 else {
    new InputDialog(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",true,false,MITM.this,new InputDialogListener(){
      @Override public void onInputEntered(      String input){
        final String js=input.trim();
        if (js.isEmpty() == false || js.startsWith(""String_Node_Str"") == false) {
          activity.setVisibility(View.VISIBLE);
          Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
          mSpoofSession=new SpoofSession();
          mSpoofSession.start(new OnSessionReadyListener(){
            @Override public void onSessionReady(){
              System.getProxy().setFilter(new Proxy.ProxyFilter(){
                @Override public String onDataReceived(                String headers,                String data){
                  return data.replaceAll(""String_Node_Str"",js + ""String_Node_Str"");
                }
              }
);
            }
          }
);
        }
 else         new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
      }
    }
).show();
  }
}"
54282,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
  requestWindowFeature(Window.FEATURE_PROGRESS);
  setTitle(System.getCurrentTarget() + ""String_Node_Str"");
  setContentView(R.layout.plugin_mitm_hijacker_webview);
  getSupportActionBar().setDisplayHomeAsUpEnabled(true);
  setSupportProgressBarIndeterminateVisibility(false);
  mWebView=(WebView)findViewById(R.id.webView);
  mSettings=mWebView.getSettings();
  mSettings.setJavaScriptEnabled(true);
  mSettings.setBuiltInZoomControls(true);
  mSettings.setAppCacheEnabled(false);
  mSettings.setUserAgentString(DEFAULT_USER_AGENT);
  mWebView.setWebViewClient(new WebViewClient(){
    @Override public boolean shouldOverrideUrlLoading(    WebView view,    String url){
      view.loadUrl(url);
      return true;
    }
  }
);
  mWebView.setWebChromeClient(new WebChromeClient(){
    public void onProgressChanged(    WebView view,    int progress){
      getSupportActionBar().setSubtitle(HijackerWebView.this.mWebView.getUrl());
      setSupportProgressBarIndeterminateVisibility(true);
      int mmprogress=(Window.PROGRESS_END - Window.PROGRESS_START) / 100 * progress;
      setSupportProgress(mmprogress);
      if (progress == 100)       setSupportProgressBarIndeterminateVisibility(false);
    }
  }
);
  CookieSyncManager.createInstance(this);
  CookieManager.getInstance().removeAllCookie();
  Session session=(Session)System.getCustomData();
  if (session != null) {
    String domain=null, rawcookie=null;
    for (    BasicClientCookie cookie : session.mCookies.values()) {
      domain=cookie.getDomain();
      rawcookie=cookie.getName() + ""String_Node_Str"" + cookie.getValue()+ ""String_Node_Str""+ domain+ ""String_Node_Str""+ (session.mHTTPS ? ""String_Node_Str"" : ""String_Node_Str"");
      CookieManager.getInstance().setCookie(domain,rawcookie);
    }
    CookieSyncManager.getInstance().sync();
    if (session.mUserAgent != null && session.mUserAgent.isEmpty() == false)     mSettings.setUserAgentString(session.mUserAgent);
    mWebView.loadUrl((session.mHTTPS ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + domain);
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
  requestWindowFeature(Window.FEATURE_PROGRESS);
  setTitle(System.getCurrentTarget() + ""String_Node_Str"");
  setContentView(R.layout.plugin_mitm_hijacker_webview);
  getSupportActionBar().setDisplayHomeAsUpEnabled(true);
  setSupportProgressBarIndeterminateVisibility(false);
  mWebView=(WebView)findViewById(R.id.webView);
  mSettings=mWebView.getSettings();
  mSettings.setJavaScriptEnabled(true);
  mSettings.setBuiltInZoomControls(true);
  mSettings.setAppCacheEnabled(false);
  mSettings.setUserAgentString(DEFAULT_USER_AGENT);
  mWebView.setWebViewClient(new WebViewClient(){
    @Override public boolean shouldOverrideUrlLoading(    WebView view,    String url){
      view.loadUrl(url);
      return true;
    }
  }
);
  mWebView.setWebChromeClient(new WebChromeClient(){
    public void onProgressChanged(    WebView view,    int progress){
      if (mWebView != null)       getSupportActionBar().setSubtitle(mWebView.getUrl());
      setSupportProgressBarIndeterminateVisibility(true);
      int mmprogress=(Window.PROGRESS_END - Window.PROGRESS_START) / 100 * progress;
      setSupportProgress(mmprogress);
      if (progress == 100)       setSupportProgressBarIndeterminateVisibility(false);
    }
  }
);
  CookieSyncManager.createInstance(this);
  CookieManager.getInstance().removeAllCookie();
  Session session=(Session)System.getCustomData();
  if (session != null) {
    String domain=null, rawcookie=null;
    for (    BasicClientCookie cookie : session.mCookies.values()) {
      domain=cookie.getDomain();
      rawcookie=cookie.getName() + ""String_Node_Str"" + cookie.getValue()+ ""String_Node_Str""+ domain+ ""String_Node_Str""+ (session.mHTTPS ? ""String_Node_Str"" : ""String_Node_Str"");
      CookieManager.getInstance().setCookie(domain,rawcookie);
    }
    CookieSyncManager.getInstance().sync();
    if (session.mUserAgent != null && session.mUserAgent.isEmpty() == false)     mSettings.setUserAgentString(session.mUserAgent);
    mWebView.loadUrl((session.mHTTPS ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + domain);
  }
}"
54283,"public void onProgressChanged(WebView view,int progress){
  getSupportActionBar().setSubtitle(HijackerWebView.this.mWebView.getUrl());
  setSupportProgressBarIndeterminateVisibility(true);
  int mmprogress=(Window.PROGRESS_END - Window.PROGRESS_START) / 100 * progress;
  setSupportProgress(mmprogress);
  if (progress == 100)   setSupportProgressBarIndeterminateVisibility(false);
}","public void onProgressChanged(WebView view,int progress){
  if (mWebView != null)   getSupportActionBar().setSubtitle(mWebView.getUrl());
  setSupportProgressBarIndeterminateVisibility(true);
  int mmprogress=(Window.PROGRESS_END - Window.PROGRESS_START) / 100 * progress;
  setSupportProgress(mmprogress);
  if (progress == 100)   setSupportProgressBarIndeterminateVisibility(false);
}"
54284,"@Override public void onBackPressed(){
  if (mWebView != null && mWebView.canGoBack())   mWebView.goBack();
 else {
    super.onBackPressed();
    overridePendingTransition(R.anim.slide_in_left,R.anim.slide_out_left);
  }
}","@Override public void onBackPressed(){
  if (mWebView != null && mWebView.canGoBack())   mWebView.goBack();
 else {
    if (mWebView != null)     mWebView.stopLoading();
    super.onBackPressed();
    overridePendingTransition(R.anim.slide_in_left,R.anim.slide_out_left);
  }
}"
54285,"public InetAddress getGatewayAddress(){
  try {
    return InetAddress.getByName((mInfo.gateway & 0xFF) + ""String_Node_Str"" + ((mInfo.gateway >> 8) & 0xFF)+ ""String_Node_Str""+ ((mInfo.gateway >> 16) & 0xFF)+ ""String_Node_Str""+ ((mInfo.gateway >> 24) & 0xFF));
  }
 catch (  UnknownHostException e) {
    System.errorLogging(TAG,e);
  }
  return null;
}","public InetAddress getGatewayAddress(){
  return mGateway.toInetAddress();
}"
54286,"public InetAddress getLocalAddress(){
  try {
    return InetAddress.getByName(getLocalAddressAsString());
  }
 catch (  UnknownHostException e) {
    System.errorLogging(TAG,e);
  }
  return null;
}","public InetAddress getLocalAddress(){
  return mLocal.toInetAddress();
}"
54287,"public boolean isInternal(String ip){
  try {
    byte[] gateway=getGatewayAddress().getAddress();
    byte[] address=InetAddress.getByName(ip).getAddress();
    byte[] mask=getNetmaskAddress().getAddress();
    for (int i=0; i < gateway.length; i++)     if ((gateway[i] & mask[i]) != (address[i] & mask[i]))     return false;
    return true;
  }
 catch (  UnknownHostException e) {
    System.errorLogging(TAG,e);
  }
  return false;
}","public boolean isInternal(String ip){
  try {
    byte[] gateway=mGateway.toByteArray();
    byte[] address=InetAddress.getByName(ip).getAddress();
    byte[] mask=mNetmask.toByteArray();
    for (int i=0; i < gateway.length; i++)     if ((gateway[i] & mask[i]) != (address[i] & mask[i]))     return false;
    return true;
  }
 catch (  UnknownHostException e) {
    System.errorLogging(TAG,e);
  }
  return false;
}"
54288,"public String getLocalAddressAsString(){
  return (mInfo.ipAddress & 0xFF) + ""String_Node_Str"" + ((mInfo.ipAddress >> 8) & 0xFF)+ ""String_Node_Str""+ ((mInfo.ipAddress >> 16) & 0xFF)+ ""String_Node_Str""+ ((mInfo.ipAddress >> 24) & 0xFF);
}","public String getLocalAddressAsString(){
  return mLocal.toString();
}"
54289,"public InetAddress getNetmaskAddress(){
  try {
    return InetAddress.getByName((mInfo.netmask & 0xFF) + ""String_Node_Str"" + ((mInfo.netmask >> 8) & 0xFF)+ ""String_Node_Str""+ ((mInfo.netmask >> 16) & 0xFF)+ ""String_Node_Str""+ ((mInfo.netmask >> 24) & 0xFF));
  }
 catch (  UnknownHostException e) {
    System.errorLogging(TAG,e);
  }
  return null;
}","public InetAddress getNetmaskAddress(){
  return mNetmask.toInetAddress();
}"
54290,"public Network(Context context) throws NoRouteToHostException, SocketException {
  mWifiManager=(WifiManager)context.getSystemService(Context.WIFI_SERVICE);
  mConnectivityManager=(ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);
  mInfo=mWifiManager.getDhcpInfo();
  mWifiInfo=mWifiManager.getConnectionInfo();
  if (isConnected() == false)   throw new NoRouteToHostException(""String_Node_Str"");
 else {
    try {
      mInterface=NetworkInterface.getByInetAddress(getLocalAddress());
    }
 catch (    SocketException e) {
      System.errorLogging(TAG,e);
      Enumeration<NetworkInterface> interfaces=NetworkInterface.getNetworkInterfaces();
      InetAddress ifaceAddress=getLocalAddress();
      while (interfaces != null && mInterface == null && interfaces.hasMoreElements()) {
        NetworkInterface iface=interfaces.nextElement();
        Enumeration<InetAddress> inetAddresses=iface.getInetAddresses();
        while (inetAddresses.hasMoreElements()) {
          InetAddress address=inetAddresses.nextElement();
          if (address.equals(ifaceAddress)) {
            mInterface=iface;
            break;
          }
        }
      }
    }
  }
}","public Network(Context context) throws NoRouteToHostException, SocketException, UnknownHostException {
  mWifiManager=(WifiManager)context.getSystemService(Context.WIFI_SERVICE);
  mConnectivityManager=(ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);
  mInfo=mWifiManager.getDhcpInfo();
  mWifiInfo=mWifiManager.getConnectionInfo();
  mGateway=new IP4Address(mInfo.gateway);
  mNetmask=new IP4Address(mInfo.netmask);
  mLocal=new IP4Address(mInfo.ipAddress);
  if (isConnected() == false)   throw new NoRouteToHostException(""String_Node_Str"");
 else {
    try {
      mInterface=NetworkInterface.getByInetAddress(getLocalAddress());
    }
 catch (    SocketException e) {
      System.errorLogging(TAG,e);
      Enumeration<NetworkInterface> interfaces=NetworkInterface.getNetworkInterfaces();
      InetAddress ifaceAddress=getLocalAddress();
      while (interfaces != null && mInterface == null && interfaces.hasMoreElements()) {
        NetworkInterface iface=interfaces.nextElement();
        Enumeration<InetAddress> inetAddresses=iface.getInetAddresses();
        while (inetAddresses.hasMoreElements()) {
          InetAddress address=inetAddresses.nextElement();
          if (address.equals(ifaceAddress)) {
            mInterface=iface;
            break;
          }
        }
      }
    }
  }
}"
54291,"public String getNetworkRepresentation(){
  return getNetworkMasked() + ""String_Node_Str"" + countBits(mInfo.netmask);
}","public String getNetworkRepresentation(){
  return getNetworkMasked() + ""String_Node_Str"" + mNetmask.countBits();
}"
54292,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.target_layout);
  if (mTargetAdapter == null) {
    isWifiAvailable=Network.isWifiConnected(this);
    isConnectivityAvailable=isWifiAvailable || Network.isConnectivityAvailable(this);
    if (isConnectivityAvailable == false) {
      new FatalDialog(""String_Node_Str"",""String_Node_Str"",this).show();
      return;
    }
    if (System.isInitialized() == false) {
      if (isWifiAvailable == true) {
        new FatalDialog(""String_Node_Str"",System.getLastError(),this).show();
        return;
      }
 else       createUpdateLayout();
    }
    final ProgressDialog dialog=ProgressDialog.show(this,""String_Node_Str"",""String_Node_Str"",true,false);
    new Thread(new Runnable(){
      @Override public void run(){
        dialog.show();
        String fatal=null;
        ToolsInstaller installer=new ToolsInstaller(MainActivity.this.getApplicationContext());
        if (Shell.isRootGranted() == false)         fatal=""String_Node_Str"";
 else         if (Shell.isBinaryAvailable(""String_Node_Str"") == false)         fatal=""String_Node_Str"";
 else         if (installer.needed() && installer.install() == false)         fatal=""String_Node_Str"";
        dialog.dismiss();
        if (fatal != null) {
          final String ffatal=fatal;
          MainActivity.this.runOnUiThread(new Runnable(){
            @Override public void run(){
              new FatalDialog(""String_Node_Str"",ffatal,MainActivity.this).show();
            }
          }
);
        }
 else         if (isWifiAvailable) {
          startService(new Intent(MainActivity.this,NetworkMonitorService.class));
        }
        MainActivity.this.runOnUiThread(new Runnable(){
          @Override public void run(){
            try {
              mTargetAdapter=new TargetAdapter(R.layout.target_list_item);
              if (isWifiAvailable) {
                setListAdapter(mTargetAdapter);
                getListView().setOnItemLongClickListener(new OnItemLongClickListener(){
                  @Override public boolean onItemLongClick(                  AdapterView<?> parent,                  View view,                  int position,                  long id){
                    final Target target=System.getTarget(position);
                    new InputDialog(""String_Node_Str"",""String_Node_Str"",target.hasAlias() ? target.getAlias() : ""String_Node_Str"",true,MainActivity.this,new InputDialogListener(){
                      @Override public void onInputEntered(                      String input){
                        target.setAlias(input);
                        mTargetAdapter.notifyDataSetChanged();
                      }
                    }
).show();
                    return false;
                  }
                }
);
              }
              mMessageReceiver=new BroadcastReceiver(){
                @Override public void onReceive(                Context context,                Intent intent){
                  if (isWifiAvailable && intent.getAction().equals(NetworkMonitorService.NEW_ENDPOINT)) {
                    String address=(String)intent.getExtras().get(NetworkMonitorService.ENDPOINT_ADDRESS), hardware=(String)intent.getExtras().get(NetworkMonitorService.ENDPOINT_HARDWARE);
                    final Target target=Target.getFromString(address);
                    target.getEndpoint().setHardware(Endpoint.parseMacAddress(hardware));
                    MainActivity.this.runOnUiThread(new Runnable(){
                      @Override public void run(){
                        if (System.addOrderedTarget(target) == true) {
                          mTargetAdapter.notifyDataSetChanged();
                        }
                      }
                    }
);
                  }
 else                   if (intent.getAction().equals(UpdateService.UPDATE_CHECKING) && mUpdateStatus != null) {
                    mUpdateStatus.setText(NO_WIFI_UPDATE_MESSAGE.replace(""String_Node_Str"",""String_Node_Str""));
                  }
 else                   if (intent.getAction().equals(UpdateService.UPDATE_NOT_AVAILABLE) && mUpdateStatus != null) {
                    mUpdateStatus.setText(NO_WIFI_UPDATE_MESSAGE.replace(""String_Node_Str"",""String_Node_Str""));
                  }
 else                   if (intent.getAction().equals(UpdateService.UPDATE_AVAILABLE)) {
                    final String remoteVersion=(String)intent.getExtras().get(UpdateService.AVAILABLE_VERSION);
                    if (mUpdateStatus != null)                     mUpdateStatus.setText(NO_WIFI_UPDATE_MESSAGE.replace(""String_Node_Str"",""String_Node_Str"" + remoteVersion + ""String_Node_Str""));
                    MainActivity.this.runOnUiThread(new Runnable(){
                      @Override public void run(){
                        new ConfirmDialog(""String_Node_Str"",""String_Node_Str"" + remoteVersion + ""String_Node_Str"",MainActivity.this,new ConfirmDialogListener(){
                          @Override public void onConfirm(){
                            final ProgressDialog dialog=new ProgressDialog(MainActivity.this);
                            dialog.setMessage(""String_Node_Str"");
                            dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
                            dialog.setMax(100);
                            dialog.setCancelable(false);
                            dialog.show();
                            new Thread(new Runnable(){
                              @Override public void run(){
                                if (System.getUpdateManager().downloadUpdate(MainActivity.this,dialog) == false) {
                                  MainActivity.this.runOnUiThread(new Runnable(){
                                    @Override public void run(){
                                      new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MainActivity.this).show();
                                    }
                                  }
);
                                }
                                dialog.dismiss();
                              }
                            }
).start();
                          }
                        }
).show();
                      }
                    }
);
                  }
                }
              }
;
              mIntentFilter=new IntentFilter();
              mIntentFilter.addAction(NetworkMonitorService.NEW_ENDPOINT);
              mIntentFilter.addAction(UpdateService.UPDATE_CHECKING);
              mIntentFilter.addAction(UpdateService.UPDATE_AVAILABLE);
              mIntentFilter.addAction(UpdateService.UPDATE_NOT_AVAILABLE);
              registerReceiver(mMessageReceiver,mIntentFilter);
              if (System.getSettings().getBoolean(""String_Node_Str"",true))               startService(new Intent(MainActivity.this,UpdateService.class));
            }
 catch (            Exception e) {
              new FatalDialog(""String_Node_Str"",e.getMessage(),MainActivity.this).show();
            }
          }
        }
);
      }
    }
).start();
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.target_layout);
  if (mTargetAdapter == null) {
    isWifiAvailable=Network.isWifiConnected(this);
    isConnectivityAvailable=isWifiAvailable || Network.isConnectivityAvailable(this);
    if (isConnectivityAvailable == false) {
      new FatalDialog(""String_Node_Str"",""String_Node_Str"",this).show();
      return;
    }
    if (System.isInitialized() == false) {
      if (isWifiAvailable == true) {
        new FatalDialog(""String_Node_Str"",System.getLastError(),this).show();
        return;
      }
 else       createUpdateLayout();
    }
    final ProgressDialog dialog=ProgressDialog.show(this,""String_Node_Str"",""String_Node_Str"",true,false);
    new Thread(new Runnable(){
      @Override public void run(){
        dialog.show();
        Context appContext=MainActivity.this.getApplicationContext();
        String fatal=null;
        ToolsInstaller installer=new ToolsInstaller(appContext);
        if (Shell.isRootGranted() == false)         fatal=""String_Node_Str"";
 else         if (Shell.isBinaryAvailable(""String_Node_Str"") == false)         fatal=""String_Node_Str"";
 else         if (installer.needed() && installer.install() == false)         fatal=""String_Node_Str"";
 else         if (Shell.isLibraryPathOverridable(appContext) == false)         fatal=""String_Node_Str"" + ""String_Node_Str"";
        dialog.dismiss();
        if (fatal != null) {
          final String ffatal=fatal;
          MainActivity.this.runOnUiThread(new Runnable(){
            @Override public void run(){
              new FatalDialog(""String_Node_Str"",ffatal,ffatal.contains(""String_Node_Str""),MainActivity.this).show();
            }
          }
);
        }
 else         if (isWifiAvailable) {
          startService(new Intent(MainActivity.this,NetworkMonitorService.class));
        }
        MainActivity.this.runOnUiThread(new Runnable(){
          @Override public void run(){
            try {
              mTargetAdapter=new TargetAdapter(R.layout.target_list_item);
              if (isWifiAvailable) {
                setListAdapter(mTargetAdapter);
                getListView().setOnItemLongClickListener(new OnItemLongClickListener(){
                  @Override public boolean onItemLongClick(                  AdapterView<?> parent,                  View view,                  int position,                  long id){
                    final Target target=System.getTarget(position);
                    new InputDialog(""String_Node_Str"",""String_Node_Str"",target.hasAlias() ? target.getAlias() : ""String_Node_Str"",true,MainActivity.this,new InputDialogListener(){
                      @Override public void onInputEntered(                      String input){
                        target.setAlias(input);
                        mTargetAdapter.notifyDataSetChanged();
                      }
                    }
).show();
                    return false;
                  }
                }
);
              }
              mMessageReceiver=new BroadcastReceiver(){
                @Override public void onReceive(                Context context,                Intent intent){
                  if (isWifiAvailable && intent.getAction().equals(NetworkMonitorService.NEW_ENDPOINT)) {
                    String address=(String)intent.getExtras().get(NetworkMonitorService.ENDPOINT_ADDRESS), hardware=(String)intent.getExtras().get(NetworkMonitorService.ENDPOINT_HARDWARE);
                    final Target target=Target.getFromString(address);
                    target.getEndpoint().setHardware(Endpoint.parseMacAddress(hardware));
                    MainActivity.this.runOnUiThread(new Runnable(){
                      @Override public void run(){
                        if (System.addOrderedTarget(target) == true) {
                          mTargetAdapter.notifyDataSetChanged();
                        }
                      }
                    }
);
                  }
 else                   if (intent.getAction().equals(UpdateService.UPDATE_CHECKING) && mUpdateStatus != null) {
                    mUpdateStatus.setText(NO_WIFI_UPDATE_MESSAGE.replace(""String_Node_Str"",""String_Node_Str""));
                  }
 else                   if (intent.getAction().equals(UpdateService.UPDATE_NOT_AVAILABLE) && mUpdateStatus != null) {
                    mUpdateStatus.setText(NO_WIFI_UPDATE_MESSAGE.replace(""String_Node_Str"",""String_Node_Str""));
                  }
 else                   if (intent.getAction().equals(UpdateService.UPDATE_AVAILABLE)) {
                    final String remoteVersion=(String)intent.getExtras().get(UpdateService.AVAILABLE_VERSION);
                    if (mUpdateStatus != null)                     mUpdateStatus.setText(NO_WIFI_UPDATE_MESSAGE.replace(""String_Node_Str"",""String_Node_Str"" + remoteVersion + ""String_Node_Str""));
                    MainActivity.this.runOnUiThread(new Runnable(){
                      @Override public void run(){
                        new ConfirmDialog(""String_Node_Str"",""String_Node_Str"" + remoteVersion + ""String_Node_Str"",MainActivity.this,new ConfirmDialogListener(){
                          @Override public void onConfirm(){
                            final ProgressDialog dialog=new ProgressDialog(MainActivity.this);
                            dialog.setMessage(""String_Node_Str"");
                            dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
                            dialog.setMax(100);
                            dialog.setCancelable(false);
                            dialog.show();
                            new Thread(new Runnable(){
                              @Override public void run(){
                                if (System.getUpdateManager().downloadUpdate(MainActivity.this,dialog) == false) {
                                  MainActivity.this.runOnUiThread(new Runnable(){
                                    @Override public void run(){
                                      new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MainActivity.this).show();
                                    }
                                  }
);
                                }
                                dialog.dismiss();
                              }
                            }
).start();
                          }
                        }
).show();
                      }
                    }
);
                  }
                }
              }
;
              mIntentFilter=new IntentFilter();
              mIntentFilter.addAction(NetworkMonitorService.NEW_ENDPOINT);
              mIntentFilter.addAction(UpdateService.UPDATE_CHECKING);
              mIntentFilter.addAction(UpdateService.UPDATE_AVAILABLE);
              mIntentFilter.addAction(UpdateService.UPDATE_NOT_AVAILABLE);
              registerReceiver(mMessageReceiver,mIntentFilter);
              if (System.getSettings().getBoolean(""String_Node_Str"",true))               startService(new Intent(MainActivity.this,UpdateService.class));
            }
 catch (            Exception e) {
              new FatalDialog(""String_Node_Str"",e.getMessage(),MainActivity.this).show();
            }
          }
        }
);
      }
    }
).start();
  }
}"
54293,"public FatalDialog(String title,String message,final Activity activity){
  super(activity);
  this.setTitle(title);
  this.setMessage(message);
  this.setCancelable(false);
  this.setButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      activity.finish();
      System.exit(0xFF);
    }
  }
);
}","public FatalDialog(String title,String message,final Activity activity){
  this(title,message,false,activity);
}"
54294,"public boolean isUpdateAvailable(){
  try {
    if (mInstalledVersion != null) {
      if (mRemoteVersion == null) {
        StrictMode.ThreadPolicy policy=new StrictMode.ThreadPolicy.Builder().permitAll().build();
        StrictMode.setThreadPolicy(policy);
        URL url=new URL(REMOTE_VERSION_FILE);
        HttpsURLConnection connection=(HttpsURLConnection)url.openConnection();
        BufferedReader reader=new BufferedReader(new InputStreamReader(connection.getInputStream()));
        String line=null, buffer=""String_Node_Str"";
        while ((line=reader.readLine()) != null) {
          buffer+=line + ""String_Node_Str"";
        }
        reader.close();
        mRemoteVersion=buffer.trim();
      }
      double installedVersionCode=getVersionCode(mInstalledVersion), remoteVersionCode=getVersionCode(mRemoteVersion);
      if (remoteVersionCode > installedVersionCode)       return true;
    }
  }
 catch (  Exception e) {
    System.errorLogging(TAG,e);
  }
  return false;
}","public boolean isUpdateAvailable(){
  try {
    if (mInstalledVersion != null) {
      if (mRemoteVersion == null) {
        URL url=new URL(REMOTE_VERSION_FILE);
        HttpsURLConnection connection=(HttpsURLConnection)url.openConnection();
        BufferedReader reader=new BufferedReader(new InputStreamReader(connection.getInputStream()));
        String line=null, buffer=""String_Node_Str"";
        while ((line=reader.readLine()) != null) {
          buffer+=line + ""String_Node_Str"";
        }
        reader.close();
        mRemoteVersion=buffer.trim();
      }
      double installedVersionCode=getVersionCode(mInstalledVersion), remoteVersionCode=getVersionCode(mRemoteVersion);
      if (remoteVersionCode > installedVersionCode)       return true;
    }
  }
 catch (  Exception e) {
    System.errorLogging(TAG,e);
  }
  return false;
}"
54295,"@Override public int onStartCommand(Intent intent,int flags,int startId){
  super.onStartCommand(intent,flags,startId);
  Log.d(TAG,""String_Node_Str"");
  if (System.getUpdateManager().isUpdateAvailable()) {
    Intent update=new Intent(UPDATE_AVAILABLE);
    update.putExtra(AVAILABLE_VERSION,System.getUpdateManager().getRemoteVersion());
    sendBroadcast(update);
  }
  Log.d(TAG,""String_Node_Str"");
  return START_NOT_STICKY;
}","@Override public int onStartCommand(Intent intent,int flags,int startId){
  super.onStartCommand(intent,flags,startId);
  new Thread(new Runnable(){
    @Override public void run(){
      Log.d(TAG,""String_Node_Str"");
      if (System.getUpdateManager().isUpdateAvailable()) {
        Intent update=new Intent(UPDATE_AVAILABLE);
        update.putExtra(AVAILABLE_VERSION,System.getUpdateManager().getRemoteVersion());
        sendBroadcast(update);
      }
      Log.d(TAG,""String_Node_Str"");
    }
  }
).start();
  return START_NOT_STICKY;
}"
54296,"public InetAddress getLocalAddress(){
  try {
    return InetAddress.getByName((mInfo.ipAddress & 0xFF) + ""String_Node_Str"" + ((mInfo.ipAddress >> 8) & 0xFF)+ ""String_Node_Str""+ ((mInfo.ipAddress >> 16) & 0xFF)+ ""String_Node_Str""+ ((mInfo.ipAddress >> 24) & 0xFF));
  }
 catch (  UnknownHostException e) {
    System.errorLogging(TAG,e);
  }
  return null;
}","public InetAddress getLocalAddress(){
  try {
    return InetAddress.getByName(getLocalAddressAsString());
  }
 catch (  UnknownHostException e) {
    System.errorLogging(TAG,e);
  }
  return null;
}"
54297,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (System.getProxy() == null)   new FatalDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_sniffer_48,new OnClickListener(){
    @Override public void onClick(    View v){
      setStoppedState();
      startActivity(new Intent(MITM.this,Sniffer.class));
      overridePendingTransition(R.anim.slide_in_left,R.anim.slide_out_left);
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_passwords_48,new OnClickListener(){
    @Override public void onClick(    View v){
      setStoppedState();
      startActivity(new Intent(MITM.this,PasswordSniffer.class));
      overridePendingTransition(R.anim.slide_in_left,R.anim.slide_out_left);
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_kill_48,new OnClickListener(){
    @Override public void onClick(    View v){
      ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        if (System.getCurrentTarget().getType() != Target.Type.ENDPOINT)         new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
 else {
          setStoppedState();
          activity.setVisibility(View.VISIBLE);
          Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
          ConnectionKiller.start();
        }
      }
 else {
        ConnectionKiller.stop();
        activity.setVisibility(View.INVISIBLE);
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_redirect_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new RedirectionDialog(""String_Node_Str"",MITM.this,new RedirectionDialogListener(){
          @Override public void onInputEntered(          String address,          String port){
            if (address.isEmpty() == false && port.isEmpty() == false) {
              try {
                int iport=Integer.parseInt(port);
                if (iport <= 0 || iport > 65535)                 throw new Exception();
                activity.setVisibility(View.VISIBLE);
                Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                final String faddress=address;
                final int fport=iport;
                System.getEttercap().spoof(System.getCurrentTarget(),new OnReadyListener(){
                  @Override public void onReady(){
                    Proxy proxy=System.getProxy();
                    proxy.setRedirection(faddress,fport);
                    System.setForwarding(true);
                    new Thread(proxy).start();
                    System.getIPTables().portRedirect(80,System.HTTP_PROXY_PORT);
                  }
                }
).start();
              }
 catch (              Exception e) {
                new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
              }
            }
 else             new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
          }
        }
).show();
      }
 else {
        setStoppedState();
        activity.setVisibility(View.INVISIBLE);
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_image_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        activity.setVisibility(View.VISIBLE);
        startActivityForResult(mImagePicker,SELECT_PICTURE);
      }
 else {
        HTTPFilter.stop(System.getProxy());
        activity.setVisibility(View.INVISIBLE);
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_youtube_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new InputDialog(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,MITM.this,new InputDialogListener(){
          @Override public void onInputEntered(          String input){
            final String video=input.trim();
            Matcher matcher=YOUTUBE_PATTERN.matcher(input);
            if (video.isEmpty() == false && matcher != null && matcher.find()) {
              final String videoId=matcher.group(1);
              final Proxy proxy=System.getProxy();
              activity.setVisibility(View.VISIBLE);
              Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
              System.getEttercap().spoof(System.getCurrentTarget(),new OnReadyListener(){
                @Override public void onReady(){
                  System.setForwarding(true);
                  proxy.setFilter(new Proxy.ProxyFilter(){
                    @Override public String onDataReceived(                    String headers,                    String data){
                      if (data.matches(""String_Node_Str""))                       data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + videoId);
 else                       if (data.matches(""String_Node_Str""))                       data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + videoId);
 else                       if (data.matches(""String_Node_Str""))                       data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + videoId);
                      return data;
                    }
                  }
);
                  new Thread(proxy).start();
                  System.getIPTables().portRedirect(80,System.HTTP_PROXY_PORT);
                }
              }
).start();
            }
 else             new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
          }
        }
).show();
      }
 else {
        HTTPFilter.stop(System.getProxy());
        activity.setVisibility(View.INVISIBLE);
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_injection_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new InputDialog(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",true,MITM.this,new InputDialogListener(){
          @Override public void onInputEntered(          String input){
            final String js=input.trim();
            if (js.isEmpty() == false || js.startsWith(""String_Node_Str"") == false) {
              activity.setVisibility(View.VISIBLE);
              Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
              HTTPFilter.start(System.getProxy(),""String_Node_Str"",js + ""String_Node_Str"");
            }
 else             new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
          }
        }
).show();
      }
 else {
        HTTPFilter.stop(System.getProxy());
        activity.setVisibility(View.INVISIBLE);
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new CustomFilterDialog(""String_Node_Str"",MITM.this,new CustomFilterDialogListener(){
          @Override public void onInputEntered(          ArrayList<String> from,          ArrayList<String> to){
            if (from.isEmpty() == false && to.isEmpty() == false) {
              try {
                for (                String exp : from) {
                  Pattern.compile(exp);
                }
                activity.setVisibility(View.VISIBLE);
                Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                HTTPFilter.start(System.getProxy(),from,to);
              }
 catch (              PatternSyntaxException e) {
                new ErrorDialog(""String_Node_Str"",""String_Node_Str"" + e.getDescription() + ""String_Node_Str"",MITM.this).show();
              }
            }
 else             new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
          }
        }
).show();
      }
 else {
        HTTPFilter.stop(System.getProxy());
        activity.setVisibility(View.INVISIBLE);
      }
    }
  }
));
  mActionListView=(ListView)findViewById(R.id.actionListView);
  mActionAdapter=new ActionAdapter(R.layout.plugin_mitm_list_item,mActions);
  mActionListView.setAdapter(mActionAdapter);
  mImagePicker=new Intent(Intent.ACTION_PICK,android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI);
  mImagePicker.setType(""String_Node_Str"");
  mImagePicker.putExtra(Intent.EXTRA_LOCAL_ONLY,true);
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (System.getProxy() == null)   new FatalDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_sniffer_48,new OnClickListener(){
    @Override public void onClick(    View v){
      setStoppedState();
      startActivity(new Intent(MITM.this,Sniffer.class));
      overridePendingTransition(R.anim.slide_in_left,R.anim.slide_out_left);
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_passwords_48,new OnClickListener(){
    @Override public void onClick(    View v){
      setStoppedState();
      startActivity(new Intent(MITM.this,PasswordSniffer.class));
      overridePendingTransition(R.anim.slide_in_left,R.anim.slide_out_left);
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_kill_48,new OnClickListener(){
    @Override public void onClick(    View v){
      ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        if (System.getCurrentTarget().getType() != Target.Type.ENDPOINT)         new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
 else {
          setStoppedState();
          activity.setVisibility(View.VISIBLE);
          Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
          ConnectionKiller.start();
        }
      }
 else {
        ConnectionKiller.stop();
        activity.setVisibility(View.INVISIBLE);
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_redirect_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new RedirectionDialog(""String_Node_Str"",MITM.this,new RedirectionDialogListener(){
          @Override public void onInputEntered(          String address,          String port){
            if (address.isEmpty() == false && port.isEmpty() == false) {
              try {
                int iport=Integer.parseInt(port);
                if (iport <= 0 || iport > 65535)                 throw new Exception();
                activity.setVisibility(View.VISIBLE);
                Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                final String faddress=address;
                final int fport=iport;
                System.getEttercap().spoof(System.getCurrentTarget(),new OnReadyListener(){
                  @Override public void onReady(){
                    Proxy proxy=System.getProxy();
                    proxy.setRedirection(faddress,fport);
                    System.setForwarding(true);
                    new Thread(proxy).start();
                    System.getIPTables().portRedirect(80,System.HTTP_PROXY_PORT);
                  }
                }
).start();
              }
 catch (              Exception e) {
                new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
              }
            }
 else             new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
          }
        }
).show();
      }
 else {
        setStoppedState();
        activity.setVisibility(View.INVISIBLE);
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_image_48,new OnClickListener(){
    @Override public void onClick(    View v){
      ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        mCurrentActivity=activity;
        startActivityForResult(mImagePicker,SELECT_PICTURE);
      }
 else {
        mCurrentActivity=null;
        HTTPFilter.stop(System.getProxy());
        activity.setVisibility(View.INVISIBLE);
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_youtube_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new InputDialog(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",true,MITM.this,new InputDialogListener(){
          @Override public void onInputEntered(          String input){
            final String video=input.trim();
            Matcher matcher=YOUTUBE_PATTERN.matcher(input);
            if (video.isEmpty() == false && matcher != null && matcher.find()) {
              final String videoId=matcher.group(1);
              final Proxy proxy=System.getProxy();
              activity.setVisibility(View.VISIBLE);
              Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
              System.getEttercap().spoof(System.getCurrentTarget(),new OnReadyListener(){
                @Override public void onReady(){
                  System.setForwarding(true);
                  proxy.setFilter(new Proxy.ProxyFilter(){
                    @Override public String onDataReceived(                    String headers,                    String data){
                      if (data.matches(""String_Node_Str""))                       data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + videoId);
 else                       if (data.matches(""String_Node_Str""))                       data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + videoId);
 else                       if (data.matches(""String_Node_Str""))                       data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + videoId);
                      return data;
                    }
                  }
);
                  new Thread(proxy).start();
                  System.getIPTables().portRedirect(80,System.HTTP_PROXY_PORT);
                }
              }
).start();
            }
 else             new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
          }
        }
).show();
      }
 else {
        HTTPFilter.stop(System.getProxy());
        activity.setVisibility(View.INVISIBLE);
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",R.drawable.action_injection_48,new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new InputDialog(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",true,MITM.this,new InputDialogListener(){
          @Override public void onInputEntered(          String input){
            final String js=input.trim();
            if (js.isEmpty() == false || js.startsWith(""String_Node_Str"") == false) {
              activity.setVisibility(View.VISIBLE);
              Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
              HTTPFilter.start(System.getProxy(),""String_Node_Str"",js + ""String_Node_Str"");
            }
 else             new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
          }
        }
).show();
      }
 else {
        HTTPFilter.stop(System.getProxy());
        activity.setVisibility(View.INVISIBLE);
      }
    }
  }
));
  mActions.add(new Action(""String_Node_Str"",""String_Node_Str"",new OnClickListener(){
    @Override public void onClick(    View v){
      final ProgressBar activity=(ProgressBar)v.findViewById(R.id.itemActivity);
      if (activity.getVisibility() == View.INVISIBLE) {
        setStoppedState();
        new CustomFilterDialog(""String_Node_Str"",MITM.this,new CustomFilterDialogListener(){
          @Override public void onInputEntered(          ArrayList<String> from,          ArrayList<String> to){
            if (from.isEmpty() == false && to.isEmpty() == false) {
              try {
                for (                String exp : from) {
                  Pattern.compile(exp);
                }
                activity.setVisibility(View.VISIBLE);
                Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
                HTTPFilter.start(System.getProxy(),from,to);
              }
 catch (              PatternSyntaxException e) {
                new ErrorDialog(""String_Node_Str"",""String_Node_Str"" + e.getDescription() + ""String_Node_Str"",MITM.this).show();
              }
            }
 else             new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
          }
        }
).show();
      }
 else {
        HTTPFilter.stop(System.getProxy());
        activity.setVisibility(View.INVISIBLE);
      }
    }
  }
));
  mActionListView=(ListView)findViewById(R.id.actionListView);
  mActionAdapter=new ActionAdapter(R.layout.plugin_mitm_list_item,mActions);
  mActionListView.setAdapter(mActionAdapter);
  mImagePicker=new Intent(Intent.ACTION_PICK,android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI);
  mImagePicker.setType(""String_Node_Str"");
  mImagePicker.putExtra(Intent.EXTRA_LOCAL_ONLY,true);
}"
54298,"@Override protected void onActivityResult(int request,int result,Intent intent){
  super.onActivityResult(request,result,intent);
  if (request == SELECT_PICTURE && result == RESULT_OK) {
    try {
      Uri uri=intent.getData();
      String fileName=null, mimeType=null;
      if (uri != null) {
        String[] columns={MediaColumns.DATA};
        Cursor cursor=getContentResolver().query(uri,columns,null,null,null);
        cursor.moveToFirst();
        int index=cursor.getColumnIndex(MediaColumns.DATA);
        if (index != -1) {
          fileName=cursor.getString(index);
        }
        cursor.close();
      }
      if (fileName == null) {
        setStoppedState();
        new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
      }
 else {
        mimeType=System.getImageMimeType(fileName);
        Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
        System.getServer().setResource(fileName,mimeType);
        new Thread(System.getServer()).start();
        final Proxy proxy=System.getProxy();
        System.getEttercap().spoof(System.getCurrentTarget(),new OnReadyListener(){
          @Override public void onReady(){
            System.setForwarding(true);
            proxy.setFilter(new Proxy.ProxyFilter(){
              @Override public String onDataReceived(              String headers,              String data){
                String resource=System.getServer().getResourceURL();
                data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + resource + ""String_Node_Str"");
                data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + resource + ""String_Node_Str"");
                return data;
              }
            }
);
            new Thread(proxy).start();
            System.getIPTables().portRedirect(80,System.HTTP_PROXY_PORT);
          }
        }
).start();
      }
    }
 catch (    Exception e) {
      System.errorLogging(TAG,e);
    }
  }
}","@Override protected void onActivityResult(int request,int result,Intent intent){
  super.onActivityResult(request,result,intent);
  if (request == SELECT_PICTURE && result == RESULT_OK) {
    try {
      Uri uri=intent.getData();
      String fileName=null, mimeType=null;
      if (uri != null) {
        String[] columns={MediaColumns.DATA};
        Cursor cursor=getContentResolver().query(uri,columns,null,null,null);
        cursor.moveToFirst();
        int index=cursor.getColumnIndex(MediaColumns.DATA);
        if (index != -1) {
          fileName=cursor.getString(index);
        }
        cursor.close();
      }
      if (fileName == null) {
        setStoppedState();
        new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MITM.this).show();
      }
 else {
        if (mCurrentActivity != null)         mCurrentActivity.setVisibility(View.VISIBLE);
        mimeType=System.getImageMimeType(fileName);
        Toast.makeText(MITM.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
        System.getServer().setResource(fileName,mimeType);
        new Thread(System.getServer()).start();
        final Proxy proxy=System.getProxy();
        System.getEttercap().spoof(System.getCurrentTarget(),new OnReadyListener(){
          @Override public void onReady(){
            System.setForwarding(true);
            proxy.setFilter(new Proxy.ProxyFilter(){
              @Override public String onDataReceived(              String headers,              String data){
                String resource=System.getServer().getResourceURL();
                data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + resource + ""String_Node_Str"");
                data=data.replaceAll(""String_Node_Str"",""String_Node_Str"" + resource + ""String_Node_Str"");
                return data;
              }
            }
);
            new Thread(proxy).start();
            System.getIPTables().portRedirect(80,System.HTTP_PROXY_PORT);
          }
        }
).start();
      }
    }
 catch (    Exception e) {
      System.errorLogging(TAG,e);
    }
  }
}"
54299,"public void portRedirect(int from,int to){
  Log.d(TAG,""String_Node_Str"" + from + ""String_Node_Str""+ to);
  try {
    super.run(""String_Node_Str"");
    super.run(""String_Node_Str"");
    super.run(""String_Node_Str"" + from + ""String_Node_Str""+ to);
  }
 catch (  Exception e) {
    System.errorLogging(TAG,e);
  }
}","public void portRedirect(int from,int to){
  Log.d(TAG,""String_Node_Str"" + from + ""String_Node_Str""+ to);
  try {
    super.run(""String_Node_Str"");
    super.run(""String_Node_Str"");
    super.run(""String_Node_Str"");
    super.run(""String_Node_Str"");
    super.run(""String_Node_Str"" + from + ""String_Node_Str""+ System.getNetwork().getLocalAddressAsString()+ ""String_Node_Str""+ to);
  }
 catch (  Exception e) {
    System.errorLogging(TAG,e);
  }
}"
54300,"public void undoPortRedirect(int from,int to){
  Log.d(TAG,""String_Node_Str"");
  try {
    super.run(""String_Node_Str"" + from + ""String_Node_Str""+ to);
    super.run(""String_Node_Str"");
  }
 catch (  Exception e) {
    System.errorLogging(TAG,e);
  }
}","public void undoPortRedirect(int from,int to){
  Log.d(TAG,""String_Node_Str"");
  try {
    super.run(""String_Node_Str"" + from + ""String_Node_Str""+ System.getNetwork().getLocalAddressAsString()+ ""String_Node_Str""+ to);
    super.run(""String_Node_Str"");
  }
 catch (  Exception e) {
    System.errorLogging(TAG,e);
  }
}"
54301,"public static void init(Context context) throws NoRouteToHostException, SocketException {
  mContext=context;
  mUpdateManager=new UpdateManager(mContext);
  mPlugins=new ArrayList<Plugin>();
  mTargets=new ArrayList<Target>();
  mTargets.add(new Target(System.getNetwork()));
  mTargets.add(new Target(System.getNetwork().getGatewayAddress(),System.getNetwork().getGatewayHardware()));
  mTargets.add(new Target(System.getNetwork().getLoacalAddress(),System.getNetwork().getLocalHardware()));
  mNmap=new NMap(mContext);
  mEttercap=new Ettercap(mContext);
  mIptables=new IPTables();
  mHydra=new Hydra(mContext);
  mTcpdump=new TcpDump(mContext);
  try {
    mServices=new HashMap<String,String>();
    mPorts=new HashMap<String,String>();
    FileInputStream fstream=new FileInputStream(mContext.getFilesDir().getAbsolutePath() + ""String_Node_Str"");
    DataInputStream in=new DataInputStream(fstream);
    BufferedReader reader=new BufferedReader(new InputStreamReader(in));
    String line;
    Matcher matcher;
    while ((line=reader.readLine()) != null) {
      line=line.trim();
      if ((matcher=SERVICE_PARSER.matcher(line)) != null && matcher.find()) {
        String proto=matcher.group(1), port=matcher.group(2);
        mServices.put(proto,port);
        mPorts.put(port,proto);
      }
    }
    in.close();
  }
 catch (  Exception e) {
    Log.e(TAG,e.toString());
  }
  try {
    mVendors=new HashMap<String,String>();
    FileInputStream fstream=new FileInputStream(mContext.getFilesDir().getAbsolutePath() + ""String_Node_Str"");
    DataInputStream in=new DataInputStream(fstream);
    BufferedReader reader=new BufferedReader(new InputStreamReader(in));
    String line;
    while ((line=reader.readLine()) != null) {
      line=line.trim();
      if (line.startsWith(""String_Node_Str"") == false && line.isEmpty() == false) {
        String[] tokens=line.split(""String_Node_Str"",2);
        if (tokens.length == 2)         mVendors.put(tokens[0],tokens[1]);
      }
    }
    in.close();
  }
 catch (  Exception e) {
    Log.e(TAG,e.toString());
  }
  mStoragePath=Environment.getExternalStorageDirectory().toString();
  mSessionName=""String_Node_Str"" + java.lang.System.currentTimeMillis();
  mInitialized=true;
}","public static void init(Context context) throws Exception {
  mContext=context;
  try {
    mUpdateManager=new UpdateManager(mContext);
    mPlugins=new ArrayList<Plugin>();
    mTargets=new ArrayList<Target>();
    mTargets.add(new Target(System.getNetwork()));
    mTargets.add(new Target(System.getNetwork().getGatewayAddress(),System.getNetwork().getGatewayHardware()));
    mTargets.add(new Target(System.getNetwork().getLoacalAddress(),System.getNetwork().getLocalHardware()));
    mNmap=new NMap(mContext);
    mEttercap=new Ettercap(mContext);
    mIptables=new IPTables();
    mHydra=new Hydra(mContext);
    mTcpdump=new TcpDump(mContext);
    mServices=new HashMap<String,String>();
    mPorts=new HashMap<String,String>();
    FileInputStream fstream=new FileInputStream(mContext.getFilesDir().getAbsolutePath() + ""String_Node_Str"");
    DataInputStream in=new DataInputStream(fstream);
    BufferedReader reader=new BufferedReader(new InputStreamReader(in));
    String line;
    Matcher matcher;
    while ((line=reader.readLine()) != null) {
      line=line.trim();
      if ((matcher=SERVICE_PARSER.matcher(line)) != null && matcher.find()) {
        String proto=matcher.group(1), port=matcher.group(2);
        mServices.put(proto,port);
        mPorts.put(port,proto);
      }
    }
    in.close();
    mVendors=new HashMap<String,String>();
    fstream=new FileInputStream(mContext.getFilesDir().getAbsolutePath() + ""String_Node_Str"");
    in=new DataInputStream(fstream);
    reader=new BufferedReader(new InputStreamReader(in));
    while ((line=reader.readLine()) != null) {
      line=line.trim();
      if (line.startsWith(""String_Node_Str"") == false && line.isEmpty() == false) {
        String[] tokens=line.split(""String_Node_Str"",2);
        if (tokens.length == 2)         mVendors.put(tokens[0],tokens[1]);
      }
    }
    in.close();
    mStoragePath=Environment.getExternalStorageDirectory().toString();
    mSessionName=""String_Node_Str"" + java.lang.System.currentTimeMillis();
    mInitialized=true;
  }
 catch (  Exception e) {
    Log.e(TAG,e.toString());
    throw e;
  }
}"
54302,"public static byte[] parseMacAddress(String macAddress){
  if (macAddress != null && macAddress.equals(""String_Node_Str"") == false) {
    String[] bytes=macAddress.split(""String_Node_Str"");
    byte[] parsed=new byte[bytes.length];
    for (int x=0; x < bytes.length; x++) {
      BigInteger temp=new BigInteger(bytes[x],16);
      byte[] raw=temp.toByteArray();
      parsed[x]=raw[raw.length - 1];
    }
    return parsed;
  }
  return null;
}","public static byte[] parseMacAddress(String macAddress){
  if (macAddress != null && macAddress.equals(""String_Node_Str"") == false && macAddress.isEmpty() == false) {
    String[] bytes=macAddress.split(""String_Node_Str"");
    byte[] parsed=new byte[bytes.length];
    for (int x=0; x < bytes.length; x++) {
      BigInteger temp=new BigInteger(bytes[x],16);
      byte[] raw=temp.toByteArray();
      parsed[x]=raw[raw.length - 1];
    }
    return parsed;
  }
  return null;
}"
54303,"private void sendNotification(String message){
  NotificationManager manager=(NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);
  Notification notification=new Notification(R.drawable.dsploit_icon_48,message,java.lang.System.currentTimeMillis());
  Context context=getApplicationContext();
  notification.flags|=Notification.FLAG_AUTO_CANCEL;
  notification.contentIntent=PendingIntent.getActivity(context,0,new Intent(),PendingIntent.FLAG_UPDATE_CURRENT);
  notification.setLatestEventInfo(context,""String_Node_Str"",message,null);
  manager.cancel(mNotificationId);
  manager.notify(++mNotificationId,notification);
}","private void sendNotification(String message){
  NotificationManager manager=(NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);
  Notification notification=new Notification(R.drawable.dsploit_icon_48,message,java.lang.System.currentTimeMillis());
  Context context=getApplicationContext();
  PendingIntent pending=PendingIntent.getActivity(context,0,new Intent(),PendingIntent.FLAG_UPDATE_CURRENT);
  notification.flags|=Notification.FLAG_AUTO_CANCEL;
  notification.setLatestEventInfo(context,""String_Node_Str"",message,pending);
  manager.cancel(mNotificationId);
  manager.notify(++mNotificationId,notification);
}"
54304,"private static double getVersionCode(String version){
  String[] padded=new String[3], parts=version.split(""String_Node_Str"");
  String item=""String_Node_Str"", digit=""String_Node_Str"";
  double code=0, coeff=0;
  int i, j;
  Arrays.fill(padded,0,3,""String_Node_Str"");
  for (i=0; i < Math.min(3,parts.length); i++) {
    padded[i]=parts[i];
  }
  for (i=padded.length - 1; i >= 0; i--) {
    item=padded[i];
    coeff=Math.pow(10,padded.length - i);
    for (j=0; j < item.length(); j++) {
      digit=""String_Node_Str"" + item.charAt(j);
      if (digit.matches(""String_Node_Str""))       code+=(Integer.parseInt(digit) + 1) * coeff;
 else       if (digit.matches(""String_Node_Str""))       code-=((VERSION_CHAR_MAP.indexOf(digit.toLowerCase()) + 1) / 100.0);
 else       code+=coeff;
    }
  }
  return code;
}","private static double getVersionCode(String version){
  String[] padded=new String[3], parts=version.split(""String_Node_Str"");
  String item=""String_Node_Str"", digit=""String_Node_Str"", letter=""String_Node_Str"";
  double code=0, coeff=0;
  int i, j;
  char c;
  Arrays.fill(padded,0,3,""String_Node_Str"");
  for (i=0; i < Math.min(3,parts.length); i++) {
    padded[i]=parts[i];
  }
  for (i=padded.length - 1; i >= 0; i--) {
    item=padded[i];
    coeff=Math.pow(10,padded.length - i);
    if (item.matches(""String_Node_Str"")) {
      digit=""String_Node_Str"";
      letter=""String_Node_Str"";
      for (j=0; j < item.length(); j++) {
        c=item.charAt(j);
        if (c >= '0' && c <= '9')         digit+=c;
 else         letter+=c;
      }
      code+=((Integer.parseInt(digit) + 1) * coeff) - ((VERSION_CHAR_MAP.indexOf(letter.toLowerCase()) + 1) / 100.0);
    }
 else     if (item.matches(""String_Node_Str""))     code+=(Integer.parseInt(item) + 1) * coeff;
 else     code+=coeff;
  }
  return code;
}"
54305,"public static String getProtocolByPort(String port){
  return mPorts.containsKey(port) ? mPorts.get(port) : null;
}","public static String getProtocolByPort(String port){
  preloadServices();
  return mPorts.containsKey(port) ? mPorts.get(port) : null;
}"
54306,"public static void init(Context context) throws Exception {
  mContext=context;
  try {
    mUpdateManager=new UpdateManager(mContext);
    mPlugins=new ArrayList<Plugin>();
    mTargets=new ArrayList<Target>();
    mTargets.add(new Target(System.getNetwork()));
    mTargets.add(new Target(System.getNetwork().getGatewayAddress(),System.getNetwork().getGatewayHardware()));
    mTargets.add(new Target(System.getNetwork().getLoacalAddress(),System.getNetwork().getLocalHardware()));
    mNmap=new NMap(mContext);
    mEttercap=new Ettercap(mContext);
    mIptables=new IPTables();
    mHydra=new Hydra(mContext);
    mTcpdump=new TcpDump(mContext);
    mServices=new HashMap<String,String>();
    mPorts=new HashMap<String,String>();
    FileInputStream fstream=new FileInputStream(mContext.getFilesDir().getAbsolutePath() + ""String_Node_Str"");
    DataInputStream in=new DataInputStream(fstream);
    BufferedReader reader=new BufferedReader(new InputStreamReader(in));
    String line;
    Matcher matcher;
    while ((line=reader.readLine()) != null) {
      line=line.trim();
      if ((matcher=SERVICE_PARSER.matcher(line)) != null && matcher.find()) {
        String proto=matcher.group(1), port=matcher.group(2);
        mServices.put(proto,port);
        mPorts.put(port,proto);
      }
    }
    in.close();
    mVendors=new HashMap<String,String>();
    fstream=new FileInputStream(mContext.getFilesDir().getAbsolutePath() + ""String_Node_Str"");
    in=new DataInputStream(fstream);
    reader=new BufferedReader(new InputStreamReader(in));
    while ((line=reader.readLine()) != null) {
      line=line.trim();
      if (line.startsWith(""String_Node_Str"") == false && line.isEmpty() == false) {
        String[] tokens=line.split(""String_Node_Str"",2);
        if (tokens.length == 2)         mVendors.put(tokens[0],tokens[1]);
      }
    }
    in.close();
    mStoragePath=Environment.getExternalStorageDirectory().toString();
    mSessionName=""String_Node_Str"" + java.lang.System.currentTimeMillis();
    mInitialized=true;
  }
 catch (  Exception e) {
    Log.e(TAG,e.toString());
    throw e;
  }
}","public static void init(Context context) throws Exception {
  mContext=context;
  try {
    mUpdateManager=new UpdateManager(mContext);
    mPlugins=new ArrayList<Plugin>();
    mTargets=new ArrayList<Target>();
    mTargets.add(new Target(System.getNetwork()));
    mTargets.add(new Target(System.getNetwork().getGatewayAddress(),System.getNetwork().getGatewayHardware()));
    mTargets.add(new Target(System.getNetwork().getLoacalAddress(),System.getNetwork().getLocalHardware()));
    mNmap=new NMap(mContext);
    mEttercap=new Ettercap(mContext);
    mIptables=new IPTables();
    mHydra=new Hydra(mContext);
    mTcpdump=new TcpDump(mContext);
    mStoragePath=Environment.getExternalStorageDirectory().toString();
    mSessionName=""String_Node_Str"" + java.lang.System.currentTimeMillis();
    mInitialized=true;
  }
 catch (  Exception e) {
    Log.e(TAG,e.toString());
    throw e;
  }
}"
54307,"public static String getMacVendor(byte[] mac){
  if (mac != null && mac.length >= 3)   return mVendors.get(String.format(""String_Node_Str"",mac[0],mac[1],mac[2]));
 else   return null;
}","public static String getMacVendor(byte[] mac){
  preloadVendors();
  if (mac != null && mac.length >= 3)   return mVendors.get(String.format(""String_Node_Str"",mac[0],mac[1],mac[2]));
 else   return null;
}"
54308,"public static int getPortByProtocol(String protocol){
  return mServices.containsKey(protocol) ? Integer.parseInt(mServices.get(protocol)) : 0;
}","public static int getPortByProtocol(String protocol){
  preloadServices();
  return mServices.containsKey(protocol) ? Integer.parseInt(mServices.get(protocol)) : 0;
}"
54309,"public void run(){
  int read=-1, size=0, max=Integer.parseInt(System.getSettings().getString(""String_Node_Str"",""String_Node_Str""));
  byte[] chunk=new byte[CHUNK_SIZE];
  try {
    while ((read=mReader.read(chunk,0,CHUNK_SIZE)) > 0) {
      mBuffer.append(chunk,read);
      size+=read;
      if (size >= max)       throw new RuntimeException(""String_Node_Str"");
    }
    if (mBuffer.isEmpty() == false) {
      if (mBuffer.indexOf(CONTENT_TEXT_HTML) != -1) {
        String data=mBuffer.toString();
        String[] split=data.split(HEAD_SEPARATOR,2);
        String headers=split[0], body=(split.length > 1 ? split[1] : ""String_Node_Str""), patched=""String_Node_Str"";
        body=mFilter.onHtmlReceived(body);
        for (        String header : headers.split(""String_Node_Str"")) {
          if (header.toLowerCase().contains(""String_Node_Str"") == false)           patched+=header + ""String_Node_Str"";
        }
        headers=patched;
        mBuffer.setData((headers + HEAD_SEPARATOR + body).getBytes());
      }
      mWriter.write(mBuffer.getData());
      mWriter.flush();
    }
  }
 catch (  Exception e) {
    Log.e(TAG,e.toString());
  }
 finally {
    try {
      mWriter.flush();
      mWriter.close();
      mReader.close();
    }
 catch (    IOException e) {
      Log.e(TAG,e.toString());
    }
  }
}","public void run(){
  int read=-1, size=0, max=Integer.parseInt(System.getSettings().getString(""String_Node_Str"",""String_Node_Str""));
  byte[] chunk=new byte[CHUNK_SIZE];
  try {
    while ((read=mReader.read(chunk,0,CHUNK_SIZE)) > 0) {
      mBuffer.append(chunk,read);
      size+=read;
      if (size >= max)       throw new RuntimeException(""String_Node_Str"");
    }
    if (mBuffer.isEmpty() == false) {
      if (mBuffer.indexOf(CONTENT_TEXT_HTML) != -1) {
        String data=mBuffer.toString();
        String[] split=data.split(HEAD_SEPARATOR,2);
        String headers=split[0], body=(split.length > 1 ? split[1] : ""String_Node_Str""), patched=""String_Node_Str"";
        body=mFilter.onHtmlReceived(body);
        for (        String header : headers.split(""String_Node_Str"")) {
          if (header.toLowerCase().contains(""String_Node_Str"") == false)           patched+=header + ""String_Node_Str"";
        }
        headers=patched;
        mBuffer.setData((headers + HEAD_SEPARATOR + body).getBytes());
      }
      mWriter.write(mBuffer.getData());
      mWriter.flush();
    }
  }
 catch (  OutOfMemoryError ome) {
    Log.e(TAG,ome.toString());
  }
catch (  Exception e) {
    Log.e(TAG,e.toString());
  }
 finally {
    try {
      mWriter.flush();
      mWriter.close();
      mReader.close();
    }
 catch (    IOException e) {
      Log.e(TAG,e.toString());
    }
  }
}"
54310,"public void run(){
  int read=-1;
  byte[] chunk=new byte[CHUNK_SIZE];
  try {
    while ((read=mReader.read(chunk,0,CHUNK_SIZE)) > 0) {
      mBuffer.append(chunk,read);
    }
    if (mBuffer.isEmpty() == false) {
      if (mBuffer.indexOf(CONTENT_TEXT_HTML) != -1) {
        String data=mBuffer.toString();
        String[] split=data.split(HEAD_SEPARATOR,2);
        String headers=split[0], body=(split.length > 1 ? split[1] : ""String_Node_Str""), patched=""String_Node_Str"";
        body=mFilter.onHtmlReceived(body);
        for (        String header : headers.split(""String_Node_Str"")) {
          if (header.toLowerCase().contains(""String_Node_Str"") == false)           patched+=header + ""String_Node_Str"";
        }
        headers=patched;
        mBuffer.setData((headers + HEAD_SEPARATOR + body).getBytes());
      }
      mWriter.write(mBuffer.getData());
      mWriter.flush();
    }
  }
 catch (  IOException e) {
    Log.e(TAG,e.toString());
  }
 finally {
    try {
      mWriter.flush();
      mWriter.close();
      mReader.close();
    }
 catch (    IOException e) {
      Log.e(TAG,e.toString());
    }
  }
}","public void run(){
  int read=-1, size=0;
  byte[] chunk=new byte[CHUNK_SIZE];
  try {
    while ((read=mReader.read(chunk,0,CHUNK_SIZE)) > 0) {
      mBuffer.append(chunk,read);
      size+=read;
      if (size >= MAX_BUFFER_SIZE)       throw new RuntimeException(""String_Node_Str"");
    }
    if (mBuffer.isEmpty() == false) {
      if (mBuffer.indexOf(CONTENT_TEXT_HTML) != -1) {
        String data=mBuffer.toString();
        String[] split=data.split(HEAD_SEPARATOR,2);
        String headers=split[0], body=(split.length > 1 ? split[1] : ""String_Node_Str""), patched=""String_Node_Str"";
        body=mFilter.onHtmlReceived(body);
        for (        String header : headers.split(""String_Node_Str"")) {
          if (header.toLowerCase().contains(""String_Node_Str"") == false)           patched+=header + ""String_Node_Str"";
        }
        headers=patched;
        mBuffer.setData((headers + HEAD_SEPARATOR + body).getBytes());
      }
      mWriter.write(mBuffer.getData());
      mWriter.flush();
    }
  }
 catch (  Exception e) {
    Log.e(TAG,e.toString());
  }
 finally {
    try {
      mWriter.flush();
      mWriter.close();
      mReader.close();
    }
 catch (    IOException e) {
      Log.e(TAG,e.toString());
    }
  }
}"
54311,"@Override public void onCreate(){
  ACRA.init(this);
  super.onCreate();
}","@Override public void onCreate(){
  ACRA.init(this);
  try {
    System.init(this);
    System.registerPlugin(new PortScanner());
    System.registerPlugin(new Inspector());
    System.registerPlugin(new ExploitFinder());
    System.registerPlugin(new LoginCracker());
    System.registerPlugin(new MITM());
    System.registerPlugin(new PacketForger());
  }
 catch (  Exception e) {
    System.setLastError(e.toString());
    Log.e(""String_Node_Str"",e.toString());
  }
  super.onCreate();
}"
54312,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(LAYOUT);
  if (System.isInitialized() == false) {
    final ProgressDialog dialog=ProgressDialog.show(MainActivity.this,""String_Node_Str"",""String_Node_Str"",true,false);
    new Thread(new Runnable(){
      @Override public void run(){
        dialog.show();
        String fatal=null;
        ToolsInstaller installer=new ToolsInstaller(MainActivity.this.getApplicationContext());
        if (Shell.isRootGranted() == false)         fatal=""String_Node_Str"";
 else         if (Shell.isBinaryAvailable(""String_Node_Str"") == false)         fatal=""String_Node_Str"";
 else         if (installer.needed() && installer.install() == false)         fatal=""String_Node_Str"";
        dialog.dismiss();
        if (fatal != null) {
          final String fatalMessage=fatal;
          MainActivity.this.runOnUiThread(new Runnable(){
            public void run(){
              new FatalDialog(""String_Node_Str"",fatalMessage,MainActivity.this).show();
            }
          }
);
        }
 else         if (Network.isWifiConnected(MainActivity.this)) {
          startService(new Intent(MainActivity.this,NetworkMonitorService.class));
        }
      }
    }
).start();
    try {
      System.init(getApplicationContext());
      System.registerPlugin(new PortScanner());
      System.registerPlugin(new Inspector());
      System.registerPlugin(new ExploitFinder());
      System.registerPlugin(new LoginCracker());
      System.registerPlugin(new MITM());
      System.registerPlugin(new PacketForger());
      mTargetAdapter=new TargetAdapter(R.layout.target_list_item);
      setListAdapter(mTargetAdapter);
      mMessageReceiver=new BroadcastReceiver(){
        @Override public void onReceive(        Context context,        Intent intent){
          if (intent.getAction().equals(NetworkMonitorService.NEW_ENDPOINT)) {
            String address=(String)intent.getExtras().get(NetworkMonitorService.ENDPOINT_ADDRESS), hardware=(String)intent.getExtras().get(NetworkMonitorService.ENDPOINT_HARDWARE);
            Target target=Target.getFromString(address);
            target.getEndpoint().setHardware(Endpoint.parseMacAddress(hardware));
            if (System.addOrderedTarget(target) == true) {
              MainActivity.this.runOnUiThread(new Runnable(){
                @Override public void run(){
                  mTargetAdapter.notifyDataSetChanged();
                }
              }
);
            }
          }
 else           if (intent.getAction().equals(UpdateService.UPDATE_AVAILABLE)) {
            final String remoteVersion=(String)intent.getExtras().get(UpdateService.AVAILABLE_VERSION);
            MainActivity.this.runOnUiThread(new Runnable(){
              @Override public void run(){
                new ConfirmDialog(""String_Node_Str"",""String_Node_Str"" + remoteVersion + ""String_Node_Str"",MainActivity.this,new ConfirmDialogListener(){
                  @Override public void onConfirm(){
                    final ProgressDialog dialog=ProgressDialog.show(MainActivity.this,""String_Node_Str"",""String_Node_Str"",true,false);
                    new Thread(new Runnable(){
                      @Override public void run(){
                        if (System.getUpdateManager().downloadUpdate() == false) {
                          MainActivity.this.runOnUiThread(new Runnable(){
                            @Override public void run(){
                              new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MainActivity.this).show();
                            }
                          }
);
                        }
                        dialog.dismiss();
                      }
                    }
).start();
                  }
                }
).show();
              }
            }
);
          }
        }
      }
;
      mIntentFilter=new IntentFilter();
      mIntentFilter.addAction(NetworkMonitorService.NEW_ENDPOINT);
      mIntentFilter.addAction(UpdateService.UPDATE_AVAILABLE);
      registerReceiver(mMessageReceiver,mIntentFilter);
      if (System.getSettings().getBoolean(""String_Node_Str"",true))       startService(new Intent(this,UpdateService.class));
    }
 catch (    Exception e) {
      new FatalDialog(""String_Node_Str"",e.getMessage(),this).show();
    }
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(LAYOUT);
  if (mTargetAdapter == null) {
    if (System.isInitialized() == false) {
      new FatalDialog(""String_Node_Str"",""String_Node_Str"" + System.getLastError(),this).show();
      return;
    }
    final ProgressDialog dialog=ProgressDialog.show(this,""String_Node_Str"",""String_Node_Str"",true,false);
    new Thread(new Runnable(){
      @Override public void run(){
        dialog.show();
        String fatal=null;
        ToolsInstaller installer=new ToolsInstaller(MainActivity.this.getApplicationContext());
        if (Shell.isRootGranted() == false)         fatal=""String_Node_Str"";
 else         if (Shell.isBinaryAvailable(""String_Node_Str"") == false)         fatal=""String_Node_Str"";
 else         if (installer.needed() && installer.install() == false)         fatal=""String_Node_Str"";
        dialog.dismiss();
        if (fatal != null) {
          final String ffatal=fatal;
          MainActivity.this.runOnUiThread(new Runnable(){
            @Override public void run(){
              new FatalDialog(""String_Node_Str"",ffatal,MainActivity.this).show();
            }
          }
);
        }
 else         if (Network.isWifiConnected(MainActivity.this)) {
          startService(new Intent(MainActivity.this,NetworkMonitorService.class));
        }
        MainActivity.this.runOnUiThread(new Runnable(){
          @Override public void run(){
            try {
              mTargetAdapter=new TargetAdapter(R.layout.target_list_item);
              setListAdapter(mTargetAdapter);
              mMessageReceiver=new BroadcastReceiver(){
                @Override public void onReceive(                Context context,                Intent intent){
                  if (intent.getAction().equals(NetworkMonitorService.NEW_ENDPOINT)) {
                    String address=(String)intent.getExtras().get(NetworkMonitorService.ENDPOINT_ADDRESS), hardware=(String)intent.getExtras().get(NetworkMonitorService.ENDPOINT_HARDWARE);
                    Target target=Target.getFromString(address);
                    target.getEndpoint().setHardware(Endpoint.parseMacAddress(hardware));
                    if (System.addOrderedTarget(target) == true) {
                      MainActivity.this.runOnUiThread(new Runnable(){
                        @Override public void run(){
                          mTargetAdapter.notifyDataSetChanged();
                        }
                      }
);
                    }
                  }
 else                   if (intent.getAction().equals(UpdateService.UPDATE_AVAILABLE)) {
                    final String remoteVersion=(String)intent.getExtras().get(UpdateService.AVAILABLE_VERSION);
                    MainActivity.this.runOnUiThread(new Runnable(){
                      @Override public void run(){
                        new ConfirmDialog(""String_Node_Str"",""String_Node_Str"" + remoteVersion + ""String_Node_Str"",MainActivity.this,new ConfirmDialogListener(){
                          @Override public void onConfirm(){
                            final ProgressDialog dialog=ProgressDialog.show(MainActivity.this,""String_Node_Str"",""String_Node_Str"",true,false);
                            new Thread(new Runnable(){
                              @Override public void run(){
                                if (System.getUpdateManager().downloadUpdate() == false) {
                                  MainActivity.this.runOnUiThread(new Runnable(){
                                    @Override public void run(){
                                      new ErrorDialog(""String_Node_Str"",""String_Node_Str"",MainActivity.this).show();
                                    }
                                  }
);
                                }
                                dialog.dismiss();
                              }
                            }
).start();
                          }
                        }
).show();
                      }
                    }
);
                  }
                }
              }
;
              mIntentFilter=new IntentFilter();
              mIntentFilter.addAction(NetworkMonitorService.NEW_ENDPOINT);
              mIntentFilter.addAction(UpdateService.UPDATE_AVAILABLE);
              registerReceiver(mMessageReceiver,mIntentFilter);
              if (System.getSettings().getBoolean(""String_Node_Str"",true))               startService(new Intent(MainActivity.this,UpdateService.class));
            }
 catch (            Exception e) {
              new FatalDialog(""String_Node_Str"",e.getMessage(),MainActivity.this).show();
            }
          }
        }
);
      }
    }
).start();
  }
}"
54313,"public static Proxy getProxy(){
  try {
    if (mProxy == null)     mProxy=new Proxy(getNetwork().getLoacalAddress(),HTTP_PROXY_PORT);
  }
 catch (  Exception e) {
    Log.e(TAG,e.toString());
  }
  return mProxy;
}","public static Proxy getProxy(){
  try {
    if (mProxy == null)     mProxy=new Proxy(getNetwork().getLocalAddress(),HTTP_PROXY_PORT);
  }
 catch (  Exception e) {
    Log.e(TAG,e.toString());
  }
  return mProxy;
}"
54314,"public static Server getServer(){
  try {
    if (mServer == null)     mServer=new Server(getNetwork().getLoacalAddress(),HTTP_SERVER_PORT);
  }
 catch (  Exception e) {
    Log.e(TAG,e.toString());
  }
  return mServer;
}","public static Server getServer(){
  try {
    if (mServer == null)     mServer=new Server(getNetwork().getLocalAddress(),HTTP_SERVER_PORT);
  }
 catch (  Exception e) {
    Log.e(TAG,e.toString());
  }
  return mServer;
}"
54315,"public static void init(Context context) throws Exception {
  mContext=context;
  try {
    mUpdateManager=new UpdateManager(mContext);
    mPlugins=new ArrayList<Plugin>();
    mTargets=new ArrayList<Target>();
    mTargets.add(new Target(System.getNetwork()));
    mTargets.add(new Target(System.getNetwork().getGatewayAddress(),System.getNetwork().getGatewayHardware()));
    mTargets.add(new Target(System.getNetwork().getLoacalAddress(),System.getNetwork().getLocalHardware()));
    mNmap=new NMap(mContext);
    mEttercap=new Ettercap(mContext);
    mIptables=new IPTables();
    mHydra=new Hydra(mContext);
    mTcpdump=new TcpDump(mContext);
    mStoragePath=Environment.getExternalStorageDirectory().toString();
    mSessionName=""String_Node_Str"" + java.lang.System.currentTimeMillis();
    mInitialized=true;
  }
 catch (  Exception e) {
    Log.e(TAG,e.toString());
    throw e;
  }
}","public static void init(Context context) throws Exception {
  mContext=context;
  try {
    mUpdateManager=new UpdateManager(mContext);
    mPlugins=new ArrayList<Plugin>();
    mTargets=new ArrayList<Target>();
    mTargets.add(new Target(System.getNetwork()));
    mTargets.add(new Target(System.getNetwork().getGatewayAddress(),System.getNetwork().getGatewayHardware()));
    mTargets.add(new Target(System.getNetwork().getLocalAddress(),System.getNetwork().getLocalHardware()));
    mNmap=new NMap(mContext);
    mEttercap=new Ettercap(mContext);
    mIptables=new IPTables();
    mHydra=new Hydra(mContext);
    mTcpdump=new TcpDump(mContext);
    mStoragePath=Environment.getExternalStorageDirectory().toString();
    mSessionName=""String_Node_Str"" + java.lang.System.currentTimeMillis();
    mInitialized=true;
  }
 catch (  Exception e) {
    Log.e(TAG,e.toString());
    throw e;
  }
}"
54316,"public static void reset() throws NoRouteToHostException, SocketException {
  mTargets.clear();
  mTargets.add(new Target(System.getNetwork()));
  mTargets.add(new Target(System.getNetwork().getGatewayAddress(),System.getNetwork().getGatewayHardware()));
  mTargets.add(new Target(System.getNetwork().getLoacalAddress(),System.getNetwork().getLocalHardware()));
  mCurrentTarget=0;
}","public static void reset() throws NoRouteToHostException, SocketException {
  mTargets.clear();
  mTargets.add(new Target(System.getNetwork()));
  mTargets.add(new Target(System.getNetwork().getGatewayAddress(),System.getNetwork().getGatewayHardware()));
  mTargets.add(new Target(System.getNetwork().getLocalAddress(),System.getNetwork().getLocalHardware()));
  mCurrentTarget=0;
}"
54317,"public Network(Context context) throws NoRouteToHostException, SocketException {
  mWifiManager=(WifiManager)context.getSystemService(Context.WIFI_SERVICE);
  mConnectivityManager=(ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);
  mInfo=mWifiManager.getDhcpInfo();
  mWifiInfo=mWifiManager.getConnectionInfo();
  if (isConnected() == false)   throw new NoRouteToHostException(""String_Node_Str"");
 else   mInterface=NetworkInterface.getByInetAddress(getLoacalAddress());
}","public Network(Context context) throws NoRouteToHostException, SocketException {
  mWifiManager=(WifiManager)context.getSystemService(Context.WIFI_SERVICE);
  mConnectivityManager=(ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);
  mInfo=mWifiManager.getDhcpInfo();
  mWifiInfo=mWifiManager.getConnectionInfo();
  if (isConnected() == false)   throw new NoRouteToHostException(""String_Node_Str"");
 else   mInterface=NetworkInterface.getByInetAddress(getLocalAddress());
}"
54318,"public boolean install(){
  Log.d(TAG,""String_Node_Str"");
  ZipInputStream zipInput;
  ZipEntry zipEntry;
  byte[] buffer=new byte[BUFFER_SIZE];
  int read;
  FileOutputStream fileOutput;
  File file;
  String fileName;
  try {
    zipInput=new ZipInputStream(new BufferedInputStream(mAppContext.getAssets().open(TOOLS_FILENAME)));
    while ((zipEntry=zipInput.getNextEntry()) != null) {
      fileName=mDestPath + ""String_Node_Str"" + zipEntry.getName();
      file=new File(mDestPath + ""String_Node_Str"" + zipEntry.getName());
      if (zipEntry.isDirectory())       file.mkdirs();
 else {
        fileOutput=new FileOutputStream(fileName);
        while ((read=zipInput.read(buffer,0,BUFFER_SIZE)) > -1) {
          fileOutput.write(buffer,0,read);
        }
        fileOutput.close();
        zipInput.closeEntry();
      }
    }
    zipInput.close();
    String cmd=""String_Node_Str"";
    for (    String install_cmd : INSTALL_COMMANDS) {
      cmd+=install_cmd.replace(""String_Node_Str"",mDestPath + ""String_Node_Str"") + ""String_Node_Str"";
    }
    Shell.exec(cmd);
    return true;
  }
 catch (  Exception e) {
    Log.e(""String_Node_Str"",e.getMessage());
    return false;
  }
}","public boolean install(){
  Log.d(TAG,""String_Node_Str"");
  System.clean();
  ZipInputStream zipInput;
  ZipEntry zipEntry;
  byte[] buffer=new byte[BUFFER_SIZE];
  int read;
  FileOutputStream fileOutput;
  File file;
  String fileName;
  try {
    zipInput=new ZipInputStream(new BufferedInputStream(mAppContext.getAssets().open(TOOLS_FILENAME)));
    while ((zipEntry=zipInput.getNextEntry()) != null) {
      fileName=mDestPath + ""String_Node_Str"" + zipEntry.getName();
      file=new File(mDestPath + ""String_Node_Str"" + zipEntry.getName());
      if (zipEntry.isDirectory())       file.mkdirs();
 else {
        fileOutput=new FileOutputStream(fileName);
        while ((read=zipInput.read(buffer,0,BUFFER_SIZE)) > -1) {
          fileOutput.write(buffer,0,read);
        }
        fileOutput.close();
        zipInput.closeEntry();
      }
    }
    zipInput.close();
    String cmd=""String_Node_Str"";
    for (    String install_cmd : INSTALL_COMMANDS) {
      cmd+=install_cmd.replace(""String_Node_Str"",mDestPath + ""String_Node_Str"") + ""String_Node_Str"";
    }
    Shell.exec(cmd);
    return true;
  }
 catch (  Exception e) {
    Log.e(""String_Node_Str"",e.getMessage());
    return false;
  }
}"
54319,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(LAYOUT);
  if (System.isInitialized() == false) {
    final ProgressDialog dialog=ProgressDialog.show(MainActivity.this,""String_Node_Str"",""String_Node_Str"",true,false);
    new Thread(new Runnable(){
      @Override public void run(){
        dialog.show();
        mToolsInstaller=new ToolsInstaller(MainActivity.this.getApplicationContext());
        if (Shell.isRootGranted() == false) {
          dialog.dismiss();
          MainActivity.this.runOnUiThread(new Runnable(){
            public void run(){
              new FatalDialog(""String_Node_Str"",""String_Node_Str"",MainActivity.this).show();
            }
          }
);
        }
 else         if (mToolsInstaller.needed() && mToolsInstaller.install() == false) {
          dialog.dismiss();
          MainActivity.this.runOnUiThread(new Runnable(){
            public void run(){
              new FatalDialog(""String_Node_Str"",""String_Node_Str"",MainActivity.this).show();
            }
          }
);
        }
        dialog.dismiss();
        startService(new Intent(MainActivity.this,NetworkMonitorService.class));
      }
    }
).start();
    try {
      System.init(getApplicationContext());
      System.registerPlugin(new PortScanner());
      System.registerPlugin(new Inspector());
      System.registerPlugin(new ExploitFinder());
      System.registerPlugin(new LoginCracker());
      System.registerPlugin(new MITM());
      CrashManager.register(getApplicationContext());
      mTargetAdapter=new TargetAdapter(R.layout.target_list_item);
      setListAdapter(mTargetAdapter);
      mMessageReceiver=new BroadcastReceiver(){
        @Override public void onReceive(        Context context,        Intent intent){
          if (intent.getAction().equals(NetworkMonitorService.NEW_ENDPOINT)) {
            String address=(String)intent.getExtras().get(NetworkMonitorService.ENDPOINT_ADDRESS), hardware=(String)intent.getExtras().get(NetworkMonitorService.ENDPOINT_HARDWARE);
            Target target=Target.getFromString(address);
            target.getEndpoint().setHardware(Endpoint.parseMacAddress(hardware));
            if (System.addOrderedTarget(target) == true) {
              MainActivity.this.runOnUiThread(new Runnable(){
                @Override public void run(){
                  mTargetAdapter.notifyDataSetChanged();
                }
              }
);
            }
          }
        }
      }
;
      mIntentFilter=new IntentFilter();
      mIntentFilter.addAction(NetworkMonitorService.NEW_ENDPOINT);
      registerReceiver(mMessageReceiver,mIntentFilter);
    }
 catch (    Exception e) {
      new FatalDialog(""String_Node_Str"",e.getMessage(),this).show();
    }
  }
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(LAYOUT);
  if (System.isInitialized() == false) {
    final ProgressDialog dialog=ProgressDialog.show(MainActivity.this,""String_Node_Str"",""String_Node_Str"",true,false);
    new Thread(new Runnable(){
      @Override public void run(){
        dialog.show();
        mToolsInstaller=new ToolsInstaller(MainActivity.this.getApplicationContext());
        if (Shell.isRootGranted() == false) {
          dialog.dismiss();
          MainActivity.this.runOnUiThread(new Runnable(){
            public void run(){
              new FatalDialog(""String_Node_Str"",""String_Node_Str"",MainActivity.this).show();
            }
          }
);
        }
 else         if (mToolsInstaller.needed() && mToolsInstaller.install() == false) {
          dialog.dismiss();
          MainActivity.this.runOnUiThread(new Runnable(){
            public void run(){
              new FatalDialog(""String_Node_Str"",""String_Node_Str"",MainActivity.this).show();
            }
          }
);
        }
        dialog.dismiss();
        if (Network.isWifiConnected(MainActivity.this))         startService(new Intent(MainActivity.this,NetworkMonitorService.class));
      }
    }
).start();
    try {
      System.init(getApplicationContext());
      System.registerPlugin(new PortScanner());
      System.registerPlugin(new Inspector());
      System.registerPlugin(new ExploitFinder());
      System.registerPlugin(new LoginCracker());
      System.registerPlugin(new MITM());
      CrashManager.register(getApplicationContext());
      mTargetAdapter=new TargetAdapter(R.layout.target_list_item);
      setListAdapter(mTargetAdapter);
      mMessageReceiver=new BroadcastReceiver(){
        @Override public void onReceive(        Context context,        Intent intent){
          if (intent.getAction().equals(NetworkMonitorService.NEW_ENDPOINT)) {
            String address=(String)intent.getExtras().get(NetworkMonitorService.ENDPOINT_ADDRESS), hardware=(String)intent.getExtras().get(NetworkMonitorService.ENDPOINT_HARDWARE);
            Target target=Target.getFromString(address);
            target.getEndpoint().setHardware(Endpoint.parseMacAddress(hardware));
            if (System.addOrderedTarget(target) == true) {
              MainActivity.this.runOnUiThread(new Runnable(){
                @Override public void run(){
                  mTargetAdapter.notifyDataSetChanged();
                }
              }
);
            }
          }
        }
      }
;
      mIntentFilter=new IntentFilter();
      mIntentFilter.addAction(NetworkMonitorService.NEW_ENDPOINT);
      registerReceiver(mMessageReceiver,mIntentFilter);
    }
 catch (    Exception e) {
      new FatalDialog(""String_Node_Str"",e.getMessage(),this).show();
    }
  }
}"
54320,"private int countBits(int n){
  int bits=0;
  while (n > 0) {
    bits+=n & 1;
    n>>=1;
  }
  return bits;
}","private static int countBits(int n){
  int bits, i;
  for (i=0, bits=(n & 1); i < 32; i++, n>>=1, bits+=n & 1)   ;
  return bits;
}"
54321,"public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (System.getCurrentTarget().hasOpenPorts() == false)   new FinishDialog(""String_Node_Str"",""String_Node_Str"",this).show();
 else   if (System.getCurrentTarget().hasOpenPortsWithService() == false)   new FinishDialog(""String_Node_Str"",""String_Node_Str"",this).show();
  mSearchToggleButton=(ToggleButton)findViewById(R.id.searchToggleButton);
  mSearchProgress=(ProgressBar)findViewById(R.id.searchActivity);
  mListView=(ExpandableListView)findViewById(R.id.searchListView);
  mAdapter=new ListViewAdapter(this);
  HashMap<String,ArrayList<Vulnerability>> vulnerabilities=System.getCurrentTarget().getVulnerabilities();
  for (  Port port : System.getCurrentTarget().getOpenPorts()) {
    if (port.service != null && port.service.isEmpty() == false) {
      mAdapter.addGroup(port.service);
      if (vulnerabilities.containsKey(port.toString())) {
        for (        Vulnerability v : vulnerabilities.get(port.toString())) {
          mAdapter.addChild(port.service,v);
        }
      }
    }
  }
  mListView.setAdapter(mAdapter);
  mListView.setOnChildClickListener(new OnChildClickListener(){
    @Override public boolean onChildClick(    ExpandableListView parent,    View v,    int groupPosition,    int childPosition,    long id){
      Vulnerability cve=(Vulnerability)mAdapter.getChild(groupPosition,childPosition);
      if (cve != null) {
        String uri=""String_Node_Str"" + cve.getIdentifier();
        Intent browser=new Intent(Intent.ACTION_VIEW,Uri.parse(uri));
        startActivity(browser);
      }
      return true;
    }
  }
);
  mSearchToggleButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      if (mRunning) {
        setStoppedState();
      }
 else {
        setStartedState();
      }
    }
  }
);
}","public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (System.getCurrentTarget().hasOpenPorts() == false)   new FinishDialog(""String_Node_Str"",""String_Node_Str"",this).show();
 else   if (System.getCurrentTarget().hasOpenPortsWithService() == false)   new FinishDialog(""String_Node_Str"",""String_Node_Str"",this).show();
  mSearchToggleButton=(ToggleButton)findViewById(R.id.searchToggleButton);
  mSearchProgress=(ProgressBar)findViewById(R.id.searchActivity);
  mListView=(ExpandableListView)findViewById(R.id.searchListView);
  mAdapter=new ListViewAdapter(this);
  HashMap<String,ArrayList<Vulnerability>> vulnerabilities=System.getCurrentTarget().getVulnerabilities();
  for (  Port port : System.getCurrentTarget().getOpenPorts()) {
    if (port.service != null && port.service.isEmpty() == false) {
      mAdapter.addGroup(port.service);
      if (vulnerabilities.containsKey(port.toString())) {
        for (        Vulnerability v : vulnerabilities.get(port.toString())) {
          mAdapter.addChild(port.service,v);
        }
      }
    }
  }
  mListView.setAdapter(mAdapter);
  mListView.setOnChildClickListener(new OnChildClickListener(){
    @Override public boolean onChildClick(    ExpandableListView parent,    View v,    int groupPosition,    int childPosition,    long id){
      Vulnerability cve=(Vulnerability)mAdapter.getChild(groupPosition,childPosition);
      if (cve != null) {
        String uri=""String_Node_Str"" + cve.getIdentifier();
        Intent browser=new Intent(Intent.ACTION_VIEW,Uri.parse(uri));
        startActivity(browser);
      }
      return true;
    }
  }
);
  for (int i=0; i < mAdapter.getGroupCount(); i++) {
    mListView.expandGroup(i);
  }
  mSearchToggleButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      if (mRunning) {
        setStoppedState();
      }
 else {
        setStartedState();
      }
    }
  }
);
}"
54322,"public void addChild(String group,Vulnerability child){
  if (!hasGroup(group))   addGroup(group);
  mGroups.get(group).add(child);
  Object[] keys=mGroups.keySet().toArray();
  int groups=keys.length;
  for (int i=0; i < groups; i++) {
    if (keys[i].toString().equals(group)) {
      mListView.expandGroup(i);
      break;
    }
  }
  notifyDataSetChanged();
}","public void addChild(String group,Vulnerability child){
  if (!hasGroup(group))   addGroup(group);
  mGroups.get(group).add(child);
  notifyDataSetChanged();
}"
54323,"public void run(){
  int read=-1;
  byte[] stream=null, buffer=new byte[BUFFER_SIZE];
  try {
    while (true) {
      try {
        if ((read=mReader.read(buffer,0,BUFFER_SIZE)) != -1) {
          stream=streamAppend(stream,buffer,read);
        }
 else         break;
      }
 catch (      SocketTimeoutException timeout) {
      }
    }
    if (streamIndexOf(stream,""String_Node_Str"".getBytes()) != -1) {
      String data=new String(stream);
      String[] split=data.split(""String_Node_Str"",2);
      String headers=split[0], body=(split.length > 1 ? split[1] : ""String_Node_Str""), patched=""String_Node_Str"";
      body=mFilter.onHtmlReceived(body);
      for (      String header : headers.split(""String_Node_Str"")) {
        if (header.toLowerCase().contains(""String_Node_Str"") == false)         patched+=header + ""String_Node_Str"";
      }
      headers=patched;
      stream=(headers + ""String_Node_Str"" + body).getBytes();
    }
    mWriter.write(stream);
    mWriter.flush();
  }
 catch (  IOException e) {
    Log.e(TAG,e.toString());
  }
 finally {
    try {
      mWriter.flush();
      mWriter.close();
      mReader.close();
    }
 catch (    IOException e) {
      Log.e(TAG,e.toString());
    }
  }
}","public void run(){
  int read=-1;
  byte[] stream=null, buffer=new byte[BUFFER_SIZE];
  try {
    while (true) {
      try {
        if ((read=mReader.read(buffer,0,BUFFER_SIZE)) != -1) {
          stream=streamAppend(stream,buffer,read);
        }
 else         break;
      }
 catch (      SocketTimeoutException timeout) {
      }
    }
    if (stream != null && stream.length > 0) {
      if (streamIndexOf(stream,""String_Node_Str"".getBytes()) != -1) {
        String data=new String(stream);
        String[] split=data.split(HEAD_SEPARATOR,2);
        String headers=split[0], body=(split.length > 1 ? split[1] : ""String_Node_Str""), patched=""String_Node_Str"";
        body=mFilter.onHtmlReceived(body);
        for (        String header : headers.split(""String_Node_Str"")) {
          if (header.toLowerCase().contains(""String_Node_Str"") == false)           patched+=header + ""String_Node_Str"";
        }
        headers=patched;
        stream=(headers + HEAD_SEPARATOR + body).getBytes();
      }
      mWriter.write(stream);
      mWriter.flush();
    }
  }
 catch (  IOException e) {
    Log.e(TAG,e.toString());
  }
 finally {
    try {
      mWriter.flush();
      mWriter.close();
      mReader.close();
    }
 catch (    IOException e) {
      Log.e(TAG,e.toString());
    }
  }
}"
54324,"public InputDialog(String title,String message,Activity activity,InputDialogListener inputDialogListener){
  super(activity);
  mEditText=new EditText(activity);
  this.setTitle(title);
  this.setMessage(message);
  this.setView(mEditText);
  final InputDialogListener listener=inputDialogListener;
  this.setButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      listener.onInputEntered(mEditText.getText().toString());
    }
  }
);
  this.setButton2(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      dialog.dismiss();
    }
  }
);
}","public InputDialog(String title,String message,String text,Activity activity,InputDialogListener inputDialogListener){
  super(activity);
  mEditText=new EditText(activity);
  if (text != null)   mEditText.setText(text);
  this.setTitle(title);
  this.setMessage(message);
  this.setView(mEditText);
  final InputDialogListener listener=inputDialogListener;
  this.setButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      listener.onInputEntered(mEditText.getText().toString());
    }
  }
);
  this.setButton2(""String_Node_Str"",new DialogInterface.OnClickListener(){
    public void onClick(    DialogInterface dialog,    int id){
      dialog.dismiss();
    }
  }
);
}"
54325,"public void stop(){
  mRunning=false;
}","public void stop(){
  Log.d(TAG,""String_Node_Str"");
  try {
    mSocket.close();
  }
 catch (  IOException e) {
  }
  mRunning=false;
  mSocket=null;
}"
54326,"public void run(){
  Log.d(TAG,""String_Node_Str"" + mAddress + ""String_Node_Str""+ mPort);
  mRunning=true;
  while (mRunning) {
    try {
      Socket client=mSocket.accept();
      new ProxyThread(client,mFilters).start();
    }
 catch (    IOException e) {
      Log.e(TAG,e.toString());
    }
  }
  try {
    mSocket.close();
  }
 catch (  IOException e) {
    Log.e(TAG,e.toString());
  }
}","public void run(){
  try {
    if (mSocket == null)     mSocket=new ServerSocket(mPort,BACKLOG,mAddress);
    Log.d(TAG,""String_Node_Str"" + mAddress + ""String_Node_Str""+ mPort);
    mRunning=true;
    while (mRunning) {
      try {
        Socket client=mSocket.accept();
        new ProxyThread(client,mFilters).start();
      }
 catch (      IOException e) {
        Log.e(TAG,e.toString());
      }
    }
    Log.d(TAG,""String_Node_Str"");
    try {
      mSocket.close();
    }
 catch (    IOException e) {
      Log.e(TAG,e.toString());
    }
  }
 catch (  IOException e) {
    Log.e(TAG,e.toString());
  }
}"
54327,"public void run(){
  Log.d(TAG,""String_Node_Str"" + mSocket.getLocalAddress());
  try {
    String request=readRequest(mReader);
    StringBuilder builder=new StringBuilder();
    for (    String line : request.split(""String_Node_Str"")) {
      if (line.startsWith(""String_Node_Str"") || line.startsWith(""String_Node_Str"")) {
        line=line.substring(0,line.indexOf(' ') + 1) + line.substring(line.indexOf('/',line.indexOf(""String_Node_Str"") + ""String_Node_Str"".length()));
      }
 else       if (line.contains(""String_Node_Str""))       line=line.replace(""String_Node_Str"",""String_Node_Str"");
      if (line.contains(""String_Node_Str""))       line=""String_Node_Str"";
 else       if (line.contains(""String_Node_Str""))       line=""String_Node_Str"";
 else       if (line.contains(HOST_TOKEN)) {
        mServerName=line.substring(line.indexOf(HOST_TOKEN) + HOST_TOKEN.length()).trim();
        mServer=new Socket(mServerName,SERVER_PORT);
        mServerReader=new BufferedInputStream(mServer.getInputStream());
        mServerWriter=new BufferedOutputStream(mServer.getOutputStream());
      }
      builder.append(line + ""String_Node_Str"");
    }
    if (mServer != null) {
      mServerWriter.write(builder.toString().getBytes());
      mServerWriter.flush();
      new StreamThread(mServer,mServerReader,mWriter,new Proxy.ProxyFilter(){
        @Override public String onHtmlReceived(        String html){
          for (          Proxy.ProxyFilter filter : mFilters) {
            html=filter.onHtmlReceived(html);
          }
          return html;
        }
      }
);
    }
  }
 catch (  IOException e) {
    Log.e(TAG,e.toString());
  }
}","public void run(){
  try {
    String request=readRequest(mReader);
    StringBuilder builder=new StringBuilder();
    for (    String line : request.split(""String_Node_Str"")) {
      if (line.contains(""String_Node_Str""))       line=""String_Node_Str"";
 else       if (line.contains(""String_Node_Str""))       line=""String_Node_Str"";
 else       if (line.contains(HOST_TOKEN)) {
        mServerName=line.substring(line.indexOf(HOST_TOKEN) + HOST_TOKEN.length()).trim();
        mServer=new Socket(mServerName,SERVER_PORT);
        mServerReader=new BufferedInputStream(mServer.getInputStream());
        mServerWriter=new BufferedOutputStream(mServer.getOutputStream());
        Log.d(TAG,mSocket.getLocalAddress() + ""String_Node_Str"" + mServerName);
      }
      builder.append(line + ""String_Node_Str"");
    }
    if (mServer != null) {
      mServerWriter.write(builder.toString().getBytes());
      mServerWriter.flush();
      new StreamThread(mServer,mServerReader,mWriter,new Proxy.ProxyFilter(){
        @Override public String onHtmlReceived(        String html){
          for (          Proxy.ProxyFilter filter : mFilters) {
            html=filter.onHtmlReceived(html);
          }
          return html;
        }
      }
);
    }
  }
 catch (  IOException e) {
    Log.e(TAG,e.toString());
  }
}"
54328,"public StreamThread(Socket socket,InputStream reader,OutputStream writer){
  this(socket,reader,writer,null);
}","public StreamThread(Socket socket,InputStream reader,OutputStream writer,Proxy.ProxyFilter filter){
  mSocket=socket;
  mReader=reader;
  mWriter=writer;
  mFilter=filter;
  try {
    mSocket.setSoTimeout(TIMEOUT);
  }
 catch (  SocketException e) {
    Log.e(TAG,e.toString());
  }
  new Thread(this).start();
}"
54329,"public void run(){
  int read=-1;
  StringBuilder builder=new StringBuilder();
  byte[] buffer=new byte[BUFFER_SIZE];
  try {
    while (true) {
      try {
        if ((read=mReader.read(buffer,0,BUFFER_SIZE)) != -1) {
          builder.append(new String(Arrays.copyOfRange(buffer,0,read)));
        }
 else         break;
      }
 catch (      SocketTimeoutException timeout) {
      }
    }
    String data=builder.toString();
    byte[] response=data.getBytes();
    if (data.toLowerCase().contains(""String_Node_Str"") && mFilter != null) {
      String[] split=data.split(""String_Node_Str"",2);
      String headers=split[0], body=(split.length > 1 ? split[1] : ""String_Node_Str"");
      int length=body.length(), clength=0;
      Matcher match=LENGTH_PATTERN.matcher(headers);
      body=mFilter.onHtmlReceived(body);
      if (match != null && match.find())       clength=Integer.parseInt(match.group(1));
 else       clength=length;
      if (body.length() != clength) {
        headers=headers.replaceAll(""String_Node_Str"",""String_Node_Str"" + clength);
      }
      response=(headers + ""String_Node_Str"" + body).getBytes();
    }
    mWriter.write(response);
    mWriter.flush();
  }
 catch (  IOException e) {
    Log.e(TAG,e.toString());
  }
 finally {
    try {
      mWriter.flush();
      mWriter.close();
      mReader.close();
    }
 catch (    IOException e) {
      Log.e(TAG,e.toString());
    }
  }
}","public void run(){
  int read=-1;
  byte[] stream=null, buffer=new byte[BUFFER_SIZE];
  try {
    while (true) {
      try {
        if ((read=mReader.read(buffer,0,BUFFER_SIZE)) != -1) {
          stream=streamAppend(stream,buffer,read);
        }
 else         break;
      }
 catch (      SocketTimeoutException timeout) {
      }
    }
    if (streamIndexOf(stream,""String_Node_Str"".getBytes()) != -1) {
      String data=new String(stream);
      String[] split=data.split(""String_Node_Str"",2);
      String headers=split[0], body=(split.length > 1 ? split[1] : ""String_Node_Str""), patched=""String_Node_Str"";
      body=mFilter.onHtmlReceived(body);
      for (      String header : headers.split(""String_Node_Str"")) {
        if (header.toLowerCase().contains(""String_Node_Str"") == false)         patched+=header + ""String_Node_Str"";
      }
      headers=patched;
      stream=(headers + ""String_Node_Str"" + body).getBytes();
    }
    mWriter.write(stream);
    mWriter.flush();
  }
 catch (  IOException e) {
    Log.e(TAG,e.toString());
  }
 finally {
    try {
      mWriter.flush();
      mWriter.close();
      mReader.close();
    }
 catch (    IOException e) {
      Log.e(TAG,e.toString());
    }
  }
}"
54330,"public void run(){
  try {
    if (mSocket == null)     mSocket=new ServerSocket(mPort,BACKLOG,mAddress);
    Log.d(TAG,""String_Node_Str"" + mAddress + ""String_Node_Str""+ mPort);
    mRunning=true;
    while (mRunning) {
      try {
        Socket client=mSocket.accept();
        new ProxyThread(client,mFilters).start();
      }
 catch (      IOException e) {
        Log.e(TAG,e.toString());
      }
    }
    Log.d(TAG,""String_Node_Str"");
    try {
      mSocket.close();
    }
 catch (    IOException e) {
      Log.e(TAG,e.toString());
    }
  }
 catch (  IOException e) {
    Log.e(TAG,e.toString());
  }
}","public void run(){
  try {
    if (mSocket == null)     mSocket=new ServerSocket(mPort,BACKLOG,mAddress);
    Log.d(TAG,""String_Node_Str"" + mAddress + ""String_Node_Str""+ mPort);
    mRunning=true;
    while (mRunning) {
      try {
        Socket client=mSocket.accept();
        new ProxyThread(client,mFilters).start();
      }
 catch (      IOException e) {
        Log.e(TAG,e.toString());
      }
    }
    Log.d(TAG,""String_Node_Str"");
  }
 catch (  IOException e) {
    Log.e(TAG,e.toString());
  }
}"
54331,"public void setUpActionBar(){
  findViewById(R.id.send_button).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      if (Compose.this instanceof ComposeDMActivity) {
        boolean close=doneClick();
        if (close) {
          onBackPressed();
        }
        return;
      }
      if (Integer.parseInt(charRemaining.getText().toString()) < 0 && settings.twitlonger) {
        new AlertDialog.Builder(context).setTitle(context.getResources().getString(R.string.tweet_to_long)).setMessage(context.getResources().getString(R.string.select_shortening_service)).setPositiveButton(R.string.twitlonger,new DialogInterface.OnClickListener(){
          @Override public void onClick(          DialogInterface dialogInterface,          int i){
            doneClick();
          }
        }
).setNeutralButton(R.string.pwiccer,new DialogInterface.OnClickListener(){
          @Override public void onClick(          DialogInterface dialogInterface,          int i){
            try {
              Intent pwiccer=new Intent(""String_Node_Str"");
              pwiccer.putExtra(""String_Node_Str"",reply.getText().toString());
              startActivityForResult(pwiccer,420);
            }
 catch (            Throwable e) {
              startActivity(new Intent(Intent.ACTION_VIEW,Uri.parse(""String_Node_Str"")));
            }
          }
        }
).setNegativeButton(R.string.split_tweet,new DialogInterface.OnClickListener(){
          @Override public void onClick(          DialogInterface dialogInterface,          int i){
            multiTweet=true;
            boolean close=doneClick();
            if (close) {
              onBackPressed();
            }
          }
        }
).create().show();
      }
 else {
        boolean close=doneClick();
        if (close) {
          onBackPressed();
        }
      }
    }
  }
);
  findViewById(R.id.discard_button).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      discardClicked=true;
      sharedPrefs.edit().putString(""String_Node_Str"",""String_Node_Str"").commit();
      if (emojiKeyboard.isShowing()) {
        onBackPressed();
      }
      onBackPressed();
    }
  }
);
}","public void setUpActionBar(){
  findViewById(R.id.send_button).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      if (Compose.this instanceof ComposeDMActivity) {
        boolean close=doneClick();
        if (close) {
          onBackPressed();
        }
        return;
      }
      if (Integer.parseInt(charRemaining.getText().toString()) < 0 && settings.twitlonger) {
        new AlertDialog.Builder(context).setTitle(context.getResources().getString(R.string.tweet_to_long)).setMessage(context.getResources().getString(R.string.select_shortening_service)).setPositiveButton(R.string.twitlonger,new DialogInterface.OnClickListener(){
          @Override public void onClick(          DialogInterface dialogInterface,          int i){
            boolean close=doneClick();
            if (close) {
              onBackPressed();
            }
          }
        }
).setNeutralButton(R.string.pwiccer,new DialogInterface.OnClickListener(){
          @Override public void onClick(          DialogInterface dialogInterface,          int i){
            try {
              Intent pwiccer=new Intent(""String_Node_Str"");
              pwiccer.putExtra(""String_Node_Str"",reply.getText().toString());
              startActivityForResult(pwiccer,420);
            }
 catch (            Throwable e) {
              startActivity(new Intent(Intent.ACTION_VIEW,Uri.parse(""String_Node_Str"")));
            }
          }
        }
).setNegativeButton(R.string.split_tweet,new DialogInterface.OnClickListener(){
          @Override public void onClick(          DialogInterface dialogInterface,          int i){
            multiTweet=true;
            boolean close=doneClick();
            if (close) {
              onBackPressed();
            }
          }
        }
).create().show();
      }
 else {
        boolean close=doneClick();
        if (close) {
          onBackPressed();
        }
      }
    }
  }
);
  findViewById(R.id.discard_button).setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      discardClicked=true;
      sharedPrefs.edit().putString(""String_Node_Str"",""String_Node_Str"").commit();
      if (emojiKeyboard.isShowing()) {
        onBackPressed();
      }
      onBackPressed();
    }
  }
);
}"
54332,"protected Boolean doInBackground(String... args){
  status=args[0];
  try {
    Twitter twitter=Utils.getTwitter(getApplicationContext(),settings);
    Twitter twitter2=Utils.getSecondTwitter(getApplicationContext());
    if (remaining < 0 && !pwiccer && !multiTweet) {
      boolean isDone=false;
      if (useAccOne) {
        isDone=tweetUsingTwitLonger(twitter);
      }
      if (useAccTwo) {
        isDone=tweetUsingTwitLonger(twitter2);
      }
      return isDone;
    }
 else     if (multiTweet && remaining < 0) {
      Pair<String,List<String>> multiTweets=getMultipeTweets(status);
      int noOfTweets=multiTweets.second.size();
      int tweetNo=1;
      for (int i=0; i < noOfTweets; i++) {
        status=multiTweets.first.length() != 0 ? multiTweets.first : ""String_Node_Str"";
        status+=multiTweets.second.get(i) + ""String_Node_Str"" + tweetNo+ ""String_Node_Str""+ noOfTweets+ ""String_Node_Str"";
        replyText=status.replace(""String_Node_Str"",""String_Node_Str"");
        tweetNo++;
        if (useAccOne) {
          tweetWithoutImages(twitter);
        }
        if (useAccTwo) {
          tweetWithoutImages(twitter2);
        }
      }
      multiTweet=false;
      return true;
    }
 else {
      if (imagesAttached == 0) {
        if (useAccOne) {
          tweetWithoutImages(twitter);
        }
        if (useAccTwo) {
          tweetWithoutImages(twitter2);
        }
        return true;
      }
 else {
        boolean autoPopulateMetadata=false;
        if (replyText != null && !replyText.contains(""String_Node_Str"")) {
          String replaceable=replyText.replaceAll(""String_Node_Str"",""String_Node_Str"");
          status=status.replaceAll(replaceable,""String_Node_Str"");
          autoPopulateMetadata=true;
        }
        StatusUpdate media=new StatusUpdate(status);
        media.setAutoPopulateReplyMetadata(autoPopulateMetadata);
        if (notiId != 0) {
          media.setInReplyToStatusId(notiId);
        }
        File[] files=new File[imagesAttached];
        File outputDir=context.getCacheDir();
        if (attachButton.isEnabled()) {
          for (int i=0; i < imagesAttached; i++) {
            files[i]=File.createTempFile(""String_Node_Str"",""String_Node_Str"" + i,outputDir);
            Bitmap bitmap=getBitmapToSend(Uri.parse(attachedUri[i]));
            ByteArrayOutputStream bos=new ByteArrayOutputStream();
            if (secondTry) {
              bitmap=Bitmap.createScaledBitmap(bitmap,bitmap.getWidth() / 2,bitmap.getHeight() / 2,true);
            }
            bitmap.compress(Bitmap.CompressFormat.JPEG,100,bos);
            byte[] bitmapdata=bos.toByteArray();
            FileOutputStream fos=new FileOutputStream(files[i]);
            fos.write(bitmapdata);
            fos.flush();
            fos.close();
          }
        }
        if (settings.twitpic && attachButton.isEnabled()) {
          boolean isDone=false;
          if (useAccOne) {
            for (int i=1; i < imagesAttached; i++) {
              TwitPicHelper helper=new TwitPicHelper(twitter,""String_Node_Str"",files[i],context);
              text+=""String_Node_Str"" + helper.uploadForUrl();
            }
            TwitPicHelper helper=new TwitPicHelper(twitter,text,files[0],context);
            if (addLocation) {
              if (waitForLocation()) {
                Location location=mLastLocation;
                GeoLocation geolocation=new GeoLocation(location.getLatitude(),location.getLongitude());
                media.setLocation(geolocation);
              }
            }
            if (helper.createPost() != 0) {
              isDone=true;
            }
          }
          if (useAccTwo) {
            for (int i=1; i < imagesAttached; i++) {
              TwitPicHelper helper=new TwitPicHelper(twitter2,""String_Node_Str"",files[i],context);
              text+=""String_Node_Str"" + helper.uploadForUrl();
            }
            TwitPicHelper helper=new TwitPicHelper(twitter2,text,files[0],context);
            if (addLocation) {
              if (waitForLocation()) {
                Location location=mLastLocation;
                GeoLocation geolocation=new GeoLocation(location.getLatitude(),location.getLongitude());
                media.setLocation(geolocation);
              }
            }
            if (helper.createPost() != 0) {
              isDone=true;
            }
          }
          return isDone;
        }
 else {
          if (attachButton.isEnabled()) {
            if (imagesAttached == 1) {
              media.setMedia(files[0]);
            }
 else {
              long[] mediaIds=new long[files.length];
              for (int i=0; i < files.length; i++) {
                UploadedMedia upload=twitter.uploadMedia(files[i]);
                mediaIds[i]=upload.getMediaId();
              }
              media.setMediaIds(mediaIds);
            }
          }
 else {
            Log.v(""String_Node_Str"",""String_Node_Str"" + attachmentType);
            media.setMedia(attachmentType,getContentResolver().openInputStream(Uri.parse(attachedUri[0])));
          }
          if (addLocation) {
            if (waitForLocation()) {
              Location location=mLastLocation;
              GeoLocation geolocation=new GeoLocation(location.getLatitude(),location.getLongitude());
              media.setLocation(geolocation);
            }
          }
          twitter4j.Status s=null;
          if (useAccOne) {
            s=twitter.updateStatus(media);
          }
          if (useAccTwo) {
            s=twitter2.updateStatus(media);
          }
          if (s != null) {
            final String[] hashtags=TweetLinkUtils.getLinksInStatus(s)[3].split(""String_Node_Str"");
            if (hashtags != null) {
              new Thread(new Runnable(){
                @Override public void run(){
                  ArrayList<String> tags=new ArrayList<String>();
                  if (hashtags != null) {
                    for (                    String s : hashtags) {
                      if (!s.equals(""String_Node_Str"")) {
                        tags.add(""String_Node_Str"" + s);
                      }
                    }
                  }
                  HashtagDataSource source=HashtagDataSource.getInstance(context);
                  for (                  String s : tags) {
                    if (s.contains(""String_Node_Str"")) {
                      source.deleteTag(s);
                      source.createTag(s);
                    }
                  }
                }
              }
).start();
            }
          }
          return true;
        }
      }
    }
  }
 catch (  final Exception e) {
    e.printStackTrace();
    runOnUiThread(new Runnable(){
      @Override public void run(){
        displayErrorNotification(e);
      }
    }
);
    if (e.getMessage() != null && e.getMessage().contains(""String_Node_Str"")) {
      tryingAgain=true;
      return false;
    }
  }
catch (  OutOfMemoryError e) {
    e.printStackTrace();
    outofmem=true;
  }
  return false;
}","protected Boolean doInBackground(String... args){
  status=args[0];
  try {
    Twitter twitter=Utils.getTwitter(getApplicationContext(),settings);
    Twitter twitter2=Utils.getSecondTwitter(getApplicationContext());
    if (remaining < 0 && !pwiccer && !multiTweet) {
      boolean isDone=false;
      if (useAccOne) {
        isDone=tweetUsingTwitLonger(twitter);
      }
      if (useAccTwo) {
        isDone=tweetUsingTwitLonger(twitter2);
      }
      return isDone;
    }
 else     if (multiTweet && remaining < 0) {
      Pair<String,List<String>> multiTweets=getMultipeTweets(status);
      int noOfTweets=multiTweets.second.size();
      int tweetNo=1;
      for (int i=0; i < noOfTweets; i++) {
        status=multiTweets.first.length() != 0 ? multiTweets.first : ""String_Node_Str"";
        status+=multiTweets.second.get(i) + ""String_Node_Str"" + tweetNo+ ""String_Node_Str""+ noOfTweets+ ""String_Node_Str"";
        tweetNo++;
        if (useAccOne) {
          tweetWithoutImages(twitter);
        }
        if (useAccTwo) {
          tweetWithoutImages(twitter2);
        }
      }
      multiTweet=false;
      return true;
    }
 else {
      if (imagesAttached == 0) {
        if (useAccOne) {
          tweetWithoutImages(twitter);
        }
        if (useAccTwo) {
          tweetWithoutImages(twitter2);
        }
        return true;
      }
 else {
        boolean autoPopulateMetadata=false;
        if (replyText != null && !replyText.contains(""String_Node_Str"")) {
          String replaceable=replyText.replaceAll(""String_Node_Str"",""String_Node_Str"");
          status=status.replaceAll(replaceable,""String_Node_Str"");
          autoPopulateMetadata=true;
        }
        StatusUpdate media=new StatusUpdate(status);
        media.setAutoPopulateReplyMetadata(autoPopulateMetadata);
        if (notiId != 0) {
          media.setInReplyToStatusId(notiId);
        }
        File[] files=new File[imagesAttached];
        File outputDir=context.getCacheDir();
        if (attachButton.isEnabled()) {
          for (int i=0; i < imagesAttached; i++) {
            files[i]=File.createTempFile(""String_Node_Str"",""String_Node_Str"" + i,outputDir);
            Bitmap bitmap=getBitmapToSend(Uri.parse(attachedUri[i]));
            ByteArrayOutputStream bos=new ByteArrayOutputStream();
            if (secondTry) {
              bitmap=Bitmap.createScaledBitmap(bitmap,bitmap.getWidth() / 2,bitmap.getHeight() / 2,true);
            }
            bitmap.compress(Bitmap.CompressFormat.JPEG,100,bos);
            byte[] bitmapdata=bos.toByteArray();
            FileOutputStream fos=new FileOutputStream(files[i]);
            fos.write(bitmapdata);
            fos.flush();
            fos.close();
          }
        }
        if (settings.twitpic && attachButton.isEnabled()) {
          boolean isDone=false;
          if (useAccOne) {
            for (int i=1; i < imagesAttached; i++) {
              TwitPicHelper helper=new TwitPicHelper(twitter,""String_Node_Str"",files[i],context);
              text+=""String_Node_Str"" + helper.uploadForUrl();
            }
            TwitPicHelper helper=new TwitPicHelper(twitter,text,files[0],context);
            if (addLocation) {
              if (waitForLocation()) {
                Location location=mLastLocation;
                GeoLocation geolocation=new GeoLocation(location.getLatitude(),location.getLongitude());
                media.setLocation(geolocation);
              }
            }
            if (helper.createPost() != 0) {
              isDone=true;
            }
          }
          if (useAccTwo) {
            for (int i=1; i < imagesAttached; i++) {
              TwitPicHelper helper=new TwitPicHelper(twitter2,""String_Node_Str"",files[i],context);
              text+=""String_Node_Str"" + helper.uploadForUrl();
            }
            TwitPicHelper helper=new TwitPicHelper(twitter2,text,files[0],context);
            if (addLocation) {
              if (waitForLocation()) {
                Location location=mLastLocation;
                GeoLocation geolocation=new GeoLocation(location.getLatitude(),location.getLongitude());
                media.setLocation(geolocation);
              }
            }
            if (helper.createPost() != 0) {
              isDone=true;
            }
          }
          return isDone;
        }
 else {
          if (attachButton.isEnabled()) {
            if (imagesAttached == 1) {
              media.setMedia(files[0]);
            }
 else {
              long[] mediaIds=new long[files.length];
              for (int i=0; i < files.length; i++) {
                UploadedMedia upload=twitter.uploadMedia(files[i]);
                mediaIds[i]=upload.getMediaId();
              }
              media.setMediaIds(mediaIds);
            }
          }
 else {
            Log.v(""String_Node_Str"",""String_Node_Str"" + attachmentType);
            media.setMedia(attachmentType,getContentResolver().openInputStream(Uri.parse(attachedUri[0])));
          }
          if (addLocation) {
            if (waitForLocation()) {
              Location location=mLastLocation;
              GeoLocation geolocation=new GeoLocation(location.getLatitude(),location.getLongitude());
              media.setLocation(geolocation);
            }
          }
          twitter4j.Status s=null;
          if (useAccOne) {
            s=twitter.updateStatus(media);
          }
          if (useAccTwo) {
            s=twitter2.updateStatus(media);
          }
          if (s != null) {
            final String[] hashtags=TweetLinkUtils.getLinksInStatus(s)[3].split(""String_Node_Str"");
            if (hashtags != null) {
              new Thread(new Runnable(){
                @Override public void run(){
                  ArrayList<String> tags=new ArrayList<String>();
                  if (hashtags != null) {
                    for (                    String s : hashtags) {
                      if (!s.equals(""String_Node_Str"")) {
                        tags.add(""String_Node_Str"" + s);
                      }
                    }
                  }
                  HashtagDataSource source=HashtagDataSource.getInstance(context);
                  for (                  String s : tags) {
                    if (s.contains(""String_Node_Str"")) {
                      source.deleteTag(s);
                      source.createTag(s);
                    }
                  }
                }
              }
).start();
            }
          }
          return true;
        }
      }
    }
  }
 catch (  final Exception e) {
    e.printStackTrace();
    runOnUiThread(new Runnable(){
      @Override public void run(){
        displayErrorNotification(e);
      }
    }
);
    if (e.getMessage() != null && e.getMessage().contains(""String_Node_Str"")) {
      tryingAgain=true;
      return false;
    }
  }
catch (  OutOfMemoryError e) {
    e.printStackTrace();
    outofmem=true;
  }
  return false;
}"
54333,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  sharedPrefs=getSharedPreferences(""String_Node_Str"",0);
  context=this;
  settings=AppSettings.getInstance(context);
  Utils.setUpTheme(context,settings);
  setContentView(R.layout.login_activity);
  ConfigurationBuilder builder=new ConfigurationBuilder();
  builder.setOAuthConsumerKey(settings.TWITTER_CONSUMER_KEY);
  builder.setOAuthConsumerSecret(settings.TWITTER_CONSUMER_SECRET);
  Configuration configuration=builder.build();
  TwitterFactory factory=new TwitterFactory(configuration);
  twitter=factory.getInstance();
  btnLoginTwitter=(Button)findViewById(R.id.btnLoginTwitter);
  noThanks=(Button)findViewById(R.id.dont_follow);
  title=(TextSwitcher)findViewById(R.id.welcome);
  summary=(TextSwitcher)findViewById(R.id.info);
  progDescription=(TextSwitcher)findViewById(R.id.progress_desc);
  progressBar=(ProgressBar)findViewById(R.id.progress_bar);
  main=(LinearLayout)findViewById(R.id.mainLayout);
  Animation in=AnimationUtils.loadAnimation(this,android.R.anim.slide_in_left);
  Animation out=AnimationUtils.loadAnimation(this,android.R.anim.slide_out_right);
  title.setFactory(new ViewSwitcher.ViewFactory(){
    public View makeView(){
      TextView myText=new TextView(LoginActivity.this);
      myText.setTextSize(30);
      return myText;
    }
  }
);
  title.setInAnimation(in);
  title.setOutAnimation(out);
  summary.setFactory(new ViewSwitcher.ViewFactory(){
    public View makeView(){
      TextView myText=new TextView(LoginActivity.this);
      myText.setTextSize(17);
      return myText;
    }
  }
);
  summary.setInAnimation(in);
  summary.setOutAnimation(out);
  progDescription.setFactory(new ViewSwitcher.ViewFactory(){
    public View makeView(){
      TextView myText=new TextView(LoginActivity.this);
      myText.setTextSize(17);
      return myText;
    }
  }
);
  progDescription.setInAnimation(in);
  progDescription.setOutAnimation(out);
  title.setText(getResources().getString(R.string.first_welcome));
  summary.setText(getResources().getString(R.string.first_info));
  progressBar.setProgress(100);
  CookieSyncManager.createInstance(this);
  CookieManager cookieManager=CookieManager.getInstance();
  cookieManager.removeAllCookie();
  mWebView=(WebView)findViewById(R.id.loginWebView);
  try {
    mWebView.getSettings().setJavaScriptEnabled(true);
  }
 catch (  Exception e) {
  }
  mWebView.getSettings().setAppCacheEnabled(false);
  mWebView.getSettings().setSavePassword(false);
  mWebView.getSettings().setSaveFormData(false);
  mWebView.setWebViewClient(new WebViewClient(){
    @Override public boolean shouldOverrideUrlLoading(    WebView webView,    String url){
      Log.v(""String_Node_Str"",""String_Node_Str"" + url);
      if (url != null && url.startsWith(""String_Node_Str"")) {
        handleTwitterCallback(url);
      }
 else       if (url.equals(""String_Node_Str"")) {
        webView.loadUrl(requestUrl);
      }
 else {
        webView.loadUrl(url);
      }
      return true;
    }
  }
);
  noThanks.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      new FollowMe().execute();
      btnLoginTwitter.setText(getResources().getString(R.string.back_to_timeline));
      noThanks.setVisibility(View.GONE);
      summary.setText(getResources().getString(R.string.third_info));
    }
  }
);
  btnLoginTwitter.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View arg0){
      if (btnLoginTwitter.getText().toString().contains(getResources().getString(R.string.login_to_twitter))) {
        if (Utils.hasInternetConnection(context)) {
          btnLoginTwitter.setEnabled(false);
          new AlertDialog.Builder(context).setMessage(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
            @Override public void onClick(            DialogInterface dialog,            int which){
              dialog.dismiss();
            }
          }
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
            @Override public void onClick(            DialogInterface dialog,            int which){
              startActivity(new Intent(Intent.ACTION_VIEW,Uri.parse(""String_Node_Str"")));
            }
          }
).show();
          new RetreiveFeedTask().execute();
        }
 else {
          Toast.makeText(context,getResources().getString(R.string.no_network) + ""String_Node_Str"",Toast.LENGTH_SHORT).show();
        }
      }
 else       if (btnLoginTwitter.getText().toString().contains(getResources().getString(R.string.initial_sync))) {
        new getTimeLine().execute();
      }
 else       if (btnLoginTwitter.getText().toString().contains(getResources().getString(R.string.no_thanks))) {
        btnLoginTwitter.setText(getResources().getString(R.string.back_to_timeline));
        noThanks.setVisibility(View.GONE);
        summary.setText(getResources().getString(R.string.third_info));
      }
 else {
        if (settings.timelineRefresh != 0) {
          AlarmManager am=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
          long now=new Date().getTime();
          long alarm=now + settings.timelineRefresh;
          PendingIntent pendingIntent=PendingIntent.getService(context,HomeFragment.HOME_REFRESH_ID,new Intent(context,TimelineRefreshService.class),0);
          am.setRepeating(AlarmManager.RTC_WAKEUP,alarm,settings.timelineRefresh,pendingIntent);
          now=new Date().getTime();
          alarm=now + settings.mentionsRefresh;
          PendingIntent pendingIntent2=PendingIntent.getService(context,MentionsFragment.MENTIONS_REFRESH_ID,new Intent(context,MentionsRefreshService.class),0);
          am.setRepeating(AlarmManager.RTC_WAKEUP,alarm,settings.mentionsRefresh,pendingIntent2);
          alarm=now + settings.dmRefresh;
          PendingIntent pendingIntent3=PendingIntent.getService(context,DMFragment.DM_REFRESH_ID,new Intent(context,DirectMessageRefreshService.class),0);
          am.setRepeating(AlarmManager.RTC_WAKEUP,alarm,settings.dmRefresh,pendingIntent3);
        }
        AlarmManager am=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
        long now=new Date().getTime();
        long alarm=now + AlarmManager.INTERVAL_DAY;
        Log.v(""String_Node_Str"",""String_Node_Str"" + new Date(alarm).toString());
        PendingIntent pendingIntent=PendingIntent.getService(context,161,new Intent(context,TrimDataService.class),0);
        am.set(AlarmManager.RTC_WAKEUP,alarm,pendingIntent);
        finish();
        Intent timeline=new Intent(context,MainActivity.class);
        timeline.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP);
        timeline.putExtra(""String_Node_Str"",true);
        sharedPrefs.edit().putBoolean(""String_Node_Str"",false).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",true).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",true).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",true).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",false).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",false).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",true).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",false).commit();
        AppSettings.invalidate();
        startActivity(timeline);
      }
    }
  }
);
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  sharedPrefs=getSharedPreferences(""String_Node_Str"",0);
  context=this;
  settings=AppSettings.getInstance(context);
  Utils.setUpTheme(context,settings);
  setContentView(R.layout.login_activity);
  ConfigurationBuilder builder=new ConfigurationBuilder();
  builder.setOAuthConsumerKey(settings.TWITTER_CONSUMER_KEY);
  builder.setOAuthConsumerSecret(settings.TWITTER_CONSUMER_SECRET);
  Configuration configuration=builder.build();
  TwitterFactory factory=new TwitterFactory(configuration);
  twitter=factory.getInstance();
  btnLoginTwitter=(Button)findViewById(R.id.btnLoginTwitter);
  noThanks=(Button)findViewById(R.id.dont_follow);
  title=(TextSwitcher)findViewById(R.id.welcome);
  summary=(TextSwitcher)findViewById(R.id.info);
  progDescription=(TextSwitcher)findViewById(R.id.progress_desc);
  progressBar=(ProgressBar)findViewById(R.id.progress_bar);
  main=(LinearLayout)findViewById(R.id.mainLayout);
  Animation in=AnimationUtils.loadAnimation(this,android.R.anim.slide_in_left);
  Animation out=AnimationUtils.loadAnimation(this,android.R.anim.slide_out_right);
  title.setFactory(new ViewSwitcher.ViewFactory(){
    public View makeView(){
      TextView myText=new TextView(LoginActivity.this);
      myText.setTextSize(30);
      return myText;
    }
  }
);
  title.setInAnimation(in);
  title.setOutAnimation(out);
  summary.setFactory(new ViewSwitcher.ViewFactory(){
    public View makeView(){
      TextView myText=new TextView(LoginActivity.this);
      myText.setTextSize(17);
      return myText;
    }
  }
);
  summary.setInAnimation(in);
  summary.setOutAnimation(out);
  progDescription.setFactory(new ViewSwitcher.ViewFactory(){
    public View makeView(){
      TextView myText=new TextView(LoginActivity.this);
      myText.setTextSize(17);
      return myText;
    }
  }
);
  progDescription.setInAnimation(in);
  progDescription.setOutAnimation(out);
  title.setText(getResources().getString(R.string.first_welcome));
  summary.setText(getResources().getString(R.string.first_info));
  progressBar.setProgress(100);
  CookieSyncManager.createInstance(this);
  CookieManager cookieManager=CookieManager.getInstance();
  cookieManager.removeAllCookie();
  mWebView=(WebView)findViewById(R.id.loginWebView);
  try {
    mWebView.getSettings().setJavaScriptEnabled(true);
  }
 catch (  Exception e) {
  }
  mWebView.getSettings().setAppCacheEnabled(false);
  mWebView.getSettings().setSavePassword(false);
  mWebView.getSettings().setSaveFormData(false);
  mWebView.setWebViewClient(new WebViewClient(){
    @Override public boolean shouldOverrideUrlLoading(    WebView webView,    String url){
      Log.v(""String_Node_Str"",""String_Node_Str"" + url);
      if (url != null && url.startsWith(OAUTH_CALLBACK)) {
        handleTwitterCallback(url);
      }
 else       if (url.equals(""String_Node_Str"")) {
        webView.loadUrl(requestUrl);
      }
 else {
        webView.loadUrl(url);
      }
      return true;
    }
  }
);
  noThanks.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      new FollowMe().execute();
      btnLoginTwitter.setText(getResources().getString(R.string.back_to_timeline));
      noThanks.setVisibility(View.GONE);
      summary.setText(getResources().getString(R.string.third_info));
    }
  }
);
  btnLoginTwitter.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View arg0){
      if (btnLoginTwitter.getText().toString().contains(getResources().getString(R.string.login_to_twitter))) {
        if (Utils.hasInternetConnection(context)) {
          btnLoginTwitter.setEnabled(false);
          new AlertDialog.Builder(context).setMessage(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
            @Override public void onClick(            DialogInterface dialog,            int which){
              dialog.dismiss();
            }
          }
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
            @Override public void onClick(            DialogInterface dialog,            int which){
              startActivity(new Intent(Intent.ACTION_VIEW,Uri.parse(""String_Node_Str"")));
            }
          }
).show();
          new RetreiveFeedTask().execute();
        }
 else {
          Toast.makeText(context,getResources().getString(R.string.no_network) + ""String_Node_Str"",Toast.LENGTH_SHORT).show();
        }
      }
 else       if (btnLoginTwitter.getText().toString().contains(getResources().getString(R.string.initial_sync))) {
        new getTimeLine().execute();
      }
 else       if (btnLoginTwitter.getText().toString().contains(getResources().getString(R.string.no_thanks))) {
        btnLoginTwitter.setText(getResources().getString(R.string.back_to_timeline));
        noThanks.setVisibility(View.GONE);
        summary.setText(getResources().getString(R.string.third_info));
      }
 else {
        if (settings.timelineRefresh != 0) {
          AlarmManager am=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
          long now=new Date().getTime();
          long alarm=now + settings.timelineRefresh;
          PendingIntent pendingIntent=PendingIntent.getService(context,HomeFragment.HOME_REFRESH_ID,new Intent(context,TimelineRefreshService.class),0);
          am.setRepeating(AlarmManager.RTC_WAKEUP,alarm,settings.timelineRefresh,pendingIntent);
          now=new Date().getTime();
          alarm=now + settings.mentionsRefresh;
          PendingIntent pendingIntent2=PendingIntent.getService(context,MentionsFragment.MENTIONS_REFRESH_ID,new Intent(context,MentionsRefreshService.class),0);
          am.setRepeating(AlarmManager.RTC_WAKEUP,alarm,settings.mentionsRefresh,pendingIntent2);
          alarm=now + settings.dmRefresh;
          PendingIntent pendingIntent3=PendingIntent.getService(context,DMFragment.DM_REFRESH_ID,new Intent(context,DirectMessageRefreshService.class),0);
          am.setRepeating(AlarmManager.RTC_WAKEUP,alarm,settings.dmRefresh,pendingIntent3);
        }
        AlarmManager am=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
        long now=new Date().getTime();
        long alarm=now + AlarmManager.INTERVAL_DAY;
        Log.v(""String_Node_Str"",""String_Node_Str"" + new Date(alarm).toString());
        PendingIntent pendingIntent=PendingIntent.getService(context,161,new Intent(context,TrimDataService.class),0);
        am.set(AlarmManager.RTC_WAKEUP,alarm,pendingIntent);
        finish();
        Intent timeline=new Intent(context,MainActivity.class);
        timeline.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP);
        timeline.putExtra(""String_Node_Str"",true);
        sharedPrefs.edit().putBoolean(""String_Node_Str"",false).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",true).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",true).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",true).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",false).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",false).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",true).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",false).commit();
        AppSettings.invalidate();
        startActivity(timeline);
      }
    }
  }
);
}"
54334,"@Override public boolean shouldOverrideUrlLoading(WebView webView,String url){
  Log.v(""String_Node_Str"",""String_Node_Str"" + url);
  if (url != null && url.startsWith(""String_Node_Str"")) {
    handleTwitterCallback(url);
  }
 else   if (url.equals(""String_Node_Str"")) {
    webView.loadUrl(requestUrl);
  }
 else {
    webView.loadUrl(url);
  }
  return true;
}","@Override public boolean shouldOverrideUrlLoading(WebView webView,String url){
  Log.v(""String_Node_Str"",""String_Node_Str"" + url);
  if (url != null && url.startsWith(OAUTH_CALLBACK)) {
    handleTwitterCallback(url);
  }
 else   if (url.equals(""String_Node_Str"")) {
    webView.loadUrl(requestUrl);
  }
 else {
    webView.loadUrl(url);
  }
  return true;
}"
54335,"private void loginToTwitter(){
  try {
    requestToken=twitter.getOAuthRequestToken(""String_Node_Str"");
  }
 catch (  TwitterException ex) {
    ex.printStackTrace();
    try {
      Looper.prepare();
    }
 catch (    Exception e) {
    }
    restartLogin();
  }
}","private void loginToTwitter(){
  try {
    requestToken=twitter.getOAuthRequestToken(OAUTH_CALLBACK);
  }
 catch (  TwitterException ex) {
    ex.printStackTrace();
    try {
      Looper.prepare();
    }
 catch (    Exception e) {
    }
    restartLogin();
  }
}"
54336,"public UserListMembersArrayAdapter(Context context,ArrayList<User> users,int listId){
  super(context,users);
  this.listId=listId;
}","public UserListMembersArrayAdapter(Context context,ArrayList<User> users,long listId){
  super(context,users);
  this.listId=listId;
}"
54337,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  overridePendingTransition(R.anim.activity_slide_up,R.anim.activity_slide_down);
  context=this;
  sharedPrefs=PreferenceManager.getDefaultSharedPreferences(context);
  settings=AppSettings.getInstance(this);
  listName=getIntent().getStringExtra(""String_Node_Str"");
  if (settings.advanceWindowed) {
    setUpWindow();
  }
  Utils.setUpPopupTheme(this,settings);
  actionBar=getActionBar();
  actionBar.setTitle(listName);
  setContentView(R.layout.list_view_activity);
  LinearLayout spinner=(LinearLayout)findViewById(R.id.list_progress);
  spinner.setVisibility(View.GONE);
  listView=(AsyncListView)findViewById(R.id.listView);
  listView.setOnScrollListener(new AbsListView.OnScrollListener(){
    @Override public void onScrollStateChanged(    AbsListView absListView,    int i){
    }
    @Override public void onScroll(    AbsListView absListView,    int firstVisibleItem,    int visibleItemCount,    int totalItemCount){
      final int lastItem=firstVisibleItem + visibleItemCount;
      if (lastItem == totalItemCount) {
        if (canRefresh && bigEnough) {
          new GetUsers().execute();
        }
        canRefresh=false;
        new Handler().postDelayed(new Runnable(){
          @Override public void run(){
            canRefresh=true;
          }
        }
,4000);
      }
    }
  }
);
  listId=getIntent().getIntExtra(""String_Node_Str"",0);
  new GetUsers().execute();
  Utils.setActionBar(context);
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  overridePendingTransition(R.anim.activity_slide_up,R.anim.activity_slide_down);
  context=this;
  sharedPrefs=PreferenceManager.getDefaultSharedPreferences(context);
  settings=AppSettings.getInstance(this);
  listName=getIntent().getStringExtra(""String_Node_Str"");
  if (settings.advanceWindowed) {
    setUpWindow();
  }
  Utils.setUpPopupTheme(this,settings);
  actionBar=getActionBar();
  actionBar.setTitle(listName);
  setContentView(R.layout.list_view_activity);
  LinearLayout spinner=(LinearLayout)findViewById(R.id.list_progress);
  spinner.setVisibility(View.GONE);
  listView=(AsyncListView)findViewById(R.id.listView);
  listView.setOnScrollListener(new AbsListView.OnScrollListener(){
    @Override public void onScrollStateChanged(    AbsListView absListView,    int i){
    }
    @Override public void onScroll(    AbsListView absListView,    int firstVisibleItem,    int visibleItemCount,    int totalItemCount){
      final int lastItem=firstVisibleItem + visibleItemCount;
      if (lastItem == totalItemCount) {
        if (canRefresh && bigEnough) {
          new GetUsers().execute();
        }
        canRefresh=false;
        new Handler().postDelayed(new Runnable(){
          @Override public void run(){
            canRefresh=true;
          }
        }
,4000);
      }
    }
  }
);
  listId=getIntent().getLongExtra(""String_Node_Str"",0);
  new GetUsers().execute();
  Utils.setActionBar(context);
}"
54338,"public void favoriteStatus(final TextView favs,final View favButton,final long tweetId,final int type){
  if (isFavorited) {
    Toast.makeText(context,getResources().getString(R.string.removing_favorite),Toast.LENGTH_SHORT).show();
  }
 else {
    Toast.makeText(context,getResources().getString(R.string.favoriting_status),Toast.LENGTH_SHORT).show();
  }
  new Thread(new Runnable(){
    @Override public void run(){
      try {
        Twitter twitter=null;
        Twitter secTwitter=null;
        if (type == TYPE_ACC_ONE) {
          twitter=Utils.getTwitter(context,settings);
        }
 else         if (type == TYPE_ACC_TWO) {
          secTwitter=Utils.getSecondTwitter(context);
        }
 else {
          twitter=Utils.getTwitter(context,settings);
          secTwitter=Utils.getSecondTwitter(context);
        }
        if (isFavorited && twitter != null) {
          twitter.destroyFavorite(tweetId);
        }
 else         if (twitter != null) {
          try {
            twitter.createFavorite(tweetId);
          }
 catch (          TwitterException e) {
          }
        }
        if (secTwitter != null) {
          secTwitter.createFavorite(tweetId);
        }
        ((Activity)context).runOnUiThread(new Runnable(){
          @Override public void run(){
            try {
              Toast.makeText(context,getResources().getString(R.string.success),Toast.LENGTH_SHORT).show();
              getFavoriteCount(favs,favButton,tweetId);
            }
 catch (            Exception e) {
            }
          }
        }
);
      }
 catch (      Exception e) {
      }
    }
  }
).start();
}","public void favoriteStatus(final TextView favs,final View favButton,final long tweetId,final int type){
  if (isFavorited) {
    Toast.makeText(context,getResources().getString(R.string.removing_favorite),Toast.LENGTH_SHORT).show();
  }
 else {
    Toast.makeText(context,getResources().getString(R.string.favoriting_status),Toast.LENGTH_SHORT).show();
  }
  new Thread(new Runnable(){
    @Override public void run(){
      try {
        Twitter twitter=null;
        Twitter secTwitter=null;
        if (type == TYPE_ACC_ONE) {
          twitter=Utils.getTwitter(context,settings);
        }
 else         if (type == TYPE_ACC_TWO) {
          secTwitter=Utils.getSecondTwitter(context);
        }
 else {
          twitter=Utils.getTwitter(context,settings);
          secTwitter=Utils.getSecondTwitter(context);
        }
        if (isFavorited && twitter != null) {
          twitter.destroyFavorite(tweetId);
        }
 else         if (twitter != null) {
          try {
            twitter.createFavorite(tweetId);
          }
 catch (          TwitterException e) {
          }
        }
        if (secTwitter != null) {
          try {
            secTwitter.createFavorite(tweetId);
          }
 catch (          TwitterException e) {
          }
        }
        ((Activity)context).runOnUiThread(new Runnable(){
          @Override public void run(){
            try {
              Toast.makeText(context,getResources().getString(R.string.success),Toast.LENGTH_SHORT).show();
              getFavoriteCount(favs,favButton,tweetId);
            }
 catch (            Exception e) {
            }
          }
        }
);
      }
 catch (      Exception e) {
      }
    }
  }
).start();
}"
54339,"public void retweetStatus(final TextView retweetCount,final long tweetId,final View retweetButton,final int type){
  Toast.makeText(context,getResources().getString(R.string.retweeting_status),Toast.LENGTH_SHORT).show();
  new Thread(new Runnable(){
    @Override public void run(){
      try {
        long idToRetweet=tweetId;
        if (status != null && status.isRetweet()) {
          idToRetweet=status.getRetweetedStatus().getId();
        }
        Twitter twitter=null;
        Twitter secTwitter=null;
        if (type == TYPE_ACC_ONE) {
          twitter=Utils.getTwitter(context,settings);
        }
 else         if (type == TYPE_ACC_TWO) {
          secTwitter=Utils.getSecondTwitter(context);
        }
 else {
          twitter=Utils.getTwitter(context,settings);
          secTwitter=Utils.getSecondTwitter(context);
        }
        if (twitter != null) {
          try {
            twitter.retweetStatus(tweetId);
          }
 catch (          TwitterException e) {
          }
        }
        if (secTwitter != null) {
          secTwitter.retweetStatus(tweetId);
        }
        ((Activity)context).runOnUiThread(new Runnable(){
          @Override public void run(){
            try {
              Toast.makeText(context,getResources().getString(R.string.retweet_success),Toast.LENGTH_SHORT).show();
              getRetweetCount(retweetCount,tweetId,retweetButton);
            }
 catch (            Exception e) {
            }
          }
        }
);
      }
 catch (      Exception e) {
      }
    }
  }
).start();
}","public void retweetStatus(final TextView retweetCount,final long tweetId,final View retweetButton,final int type){
  Toast.makeText(context,getResources().getString(R.string.retweeting_status),Toast.LENGTH_SHORT).show();
  new Thread(new Runnable(){
    @Override public void run(){
      try {
        long idToRetweet=tweetId;
        if (status != null && status.isRetweet()) {
          idToRetweet=status.getRetweetedStatus().getId();
        }
        Twitter twitter=null;
        Twitter secTwitter=null;
        if (type == TYPE_ACC_ONE) {
          twitter=Utils.getTwitter(context,settings);
        }
 else         if (type == TYPE_ACC_TWO) {
          secTwitter=Utils.getSecondTwitter(context);
        }
 else {
          twitter=Utils.getTwitter(context,settings);
          secTwitter=Utils.getSecondTwitter(context);
        }
        if (twitter != null) {
          try {
            twitter.retweetStatus(idToRetweet);
          }
 catch (          TwitterException e) {
          }
        }
        if (secTwitter != null) {
          try {
            secTwitter.retweetStatus(idToRetweet);
          }
 catch (          TwitterException e) {
          }
        }
        ((Activity)context).runOnUiThread(new Runnable(){
          @Override public void run(){
            try {
              Toast.makeText(context,getResources().getString(R.string.retweet_success),Toast.LENGTH_SHORT).show();
              getRetweetCount(retweetCount,tweetId,retweetButton);
            }
 catch (            Exception e) {
            }
          }
        }
);
      }
 catch (      Exception e) {
      }
    }
  }
).start();
}"
54340,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  sharedPrefs=getSharedPreferences(""String_Node_Str"",Context.MODE_WORLD_READABLE + Context.MODE_WORLD_WRITEABLE);
  context=this;
  settings=AppSettings.getInstance(context);
  Utils.setUpTheme(context,settings);
  setContentView(R.layout.login_activity);
  setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
  ConfigurationBuilder builder=new ConfigurationBuilder();
  builder.setOAuthConsumerKey(settings.TWITTER_CONSUMER_KEY);
  builder.setOAuthConsumerSecret(settings.TWITTER_CONSUMER_SECRET);
  Configuration configuration=builder.build();
  TwitterFactory factory=new TwitterFactory(configuration);
  twitter=factory.getInstance();
  btnLoginTwitter=(Button)findViewById(R.id.btnLoginTwitter);
  noThanks=(Button)findViewById(R.id.dont_follow);
  title=(TextSwitcher)findViewById(R.id.welcome);
  summary=(TextSwitcher)findViewById(R.id.info);
  progDescription=(TextSwitcher)findViewById(R.id.progress_desc);
  progressBar=(ProgressBar)findViewById(R.id.progress_bar);
  main=(LinearLayout)findViewById(R.id.mainLayout);
  Animation in=AnimationUtils.loadAnimation(this,android.R.anim.slide_in_left);
  Animation out=AnimationUtils.loadAnimation(this,android.R.anim.slide_out_right);
  title.setFactory(new ViewSwitcher.ViewFactory(){
    public View makeView(){
      TextView myText=new TextView(LoginActivity.this);
      myText.setTextSize(30);
      return myText;
    }
  }
);
  title.setInAnimation(in);
  title.setOutAnimation(out);
  summary.setFactory(new ViewSwitcher.ViewFactory(){
    public View makeView(){
      TextView myText=new TextView(LoginActivity.this);
      myText.setTextSize(17);
      return myText;
    }
  }
);
  summary.setInAnimation(in);
  summary.setOutAnimation(out);
  progDescription.setFactory(new ViewSwitcher.ViewFactory(){
    public View makeView(){
      TextView myText=new TextView(LoginActivity.this);
      myText.setTextSize(17);
      return myText;
    }
  }
);
  progDescription.setInAnimation(in);
  progDescription.setOutAnimation(out);
  title.setText(getResources().getString(R.string.first_welcome));
  summary.setText(getResources().getString(R.string.first_info));
  progressBar.setProgress(100);
  CookieSyncManager.createInstance(this);
  CookieManager cookieManager=CookieManager.getInstance();
  cookieManager.removeAllCookie();
  mWebView=(WebView)findViewById(R.id.loginWebView);
  try {
    mWebView.getSettings().setJavaScriptEnabled(true);
  }
 catch (  Exception e) {
  }
  mWebView.getSettings().setAppCacheEnabled(false);
  mWebView.getSettings().setSavePassword(false);
  mWebView.getSettings().setSaveFormData(false);
  mWebView.setWebViewClient(new WebViewClient(){
    @Override public boolean shouldOverrideUrlLoading(    WebView webView,    String url){
      if (url != null && url.startsWith(""String_Node_Str"")) {
        handleTwitterCallback(url);
      }
 else {
        webView.loadUrl(url);
      }
      return true;
    }
  }
);
  noThanks.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      new FollowMe().execute();
      btnLoginTwitter.setText(getResources().getString(R.string.back_to_timeline));
      noThanks.setVisibility(View.GONE);
      summary.setText(getResources().getString(R.string.third_info));
    }
  }
);
  btnLoginTwitter.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View arg0){
      if (btnLoginTwitter.getText().toString().contains(getResources().getString(R.string.login_to_twitter))) {
        if (Utils.hasInternetConnection(context)) {
          btnLoginTwitter.setEnabled(false);
          new RetreiveFeedTask().execute();
        }
 else {
          Toast.makeText(context,getResources().getString(R.string.no_network) + ""String_Node_Str"",Toast.LENGTH_SHORT).show();
        }
      }
 else       if (btnLoginTwitter.getText().toString().contains(getResources().getString(R.string.initial_sync))) {
        new getTimeLine().execute();
      }
 else       if (btnLoginTwitter.getText().toString().contains(getResources().getString(R.string.no_thanks))) {
        btnLoginTwitter.setText(getResources().getString(R.string.back_to_timeline));
        noThanks.setVisibility(View.GONE);
        summary.setText(getResources().getString(R.string.third_info));
      }
 else {
        if (settings.timelineRefresh != 0) {
          AlarmManager am=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
          long now=new Date().getTime();
          long alarm=now + settings.timelineRefresh;
          PendingIntent pendingIntent=PendingIntent.getService(context,HomeFragment.HOME_REFRESH_ID,new Intent(context,TimelineRefreshService.class),0);
          am.setRepeating(AlarmManager.RTC_WAKEUP,alarm,settings.timelineRefresh,pendingIntent);
          now=new Date().getTime();
          alarm=now + settings.mentionsRefresh;
          PendingIntent pendingIntent2=PendingIntent.getService(context,MentionsFragment.MENTIONS_REFRESH_ID,new Intent(context,MentionsRefreshService.class),0);
          am.setRepeating(AlarmManager.RTC_WAKEUP,alarm,settings.mentionsRefresh,pendingIntent2);
          alarm=now + settings.dmRefresh;
          PendingIntent pendingIntent3=PendingIntent.getService(context,DMFragment.DM_REFRESH_ID,new Intent(context,DirectMessageRefreshService.class),0);
          am.setRepeating(AlarmManager.RTC_WAKEUP,alarm,settings.dmRefresh,pendingIntent3);
        }
        AlarmManager am=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
        long now=new Date().getTime();
        long alarm=now + AlarmManager.INTERVAL_DAY;
        Log.v(""String_Node_Str"",""String_Node_Str"" + new Date(alarm).toString());
        PendingIntent pendingIntent=PendingIntent.getService(context,161,new Intent(context,TrimDataService.class),0);
        am.set(AlarmManager.RTC_WAKEUP,alarm,pendingIntent);
        finish();
        Intent timeline=new Intent(context,MainActivity.class);
        timeline.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP);
        timeline.putExtra(""String_Node_Str"",true);
        sharedPrefs.edit().putBoolean(""String_Node_Str"",false).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",true).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",true).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",true).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",false).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",false).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",true).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",false).commit();
        AppSettings.invalidate();
        startActivity(timeline);
      }
    }
  }
);
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  sharedPrefs=getSharedPreferences(""String_Node_Str"",Context.MODE_WORLD_READABLE + Context.MODE_WORLD_WRITEABLE);
  context=this;
  settings=AppSettings.getInstance(context);
  Utils.setUpTheme(context,settings);
  setContentView(R.layout.login_activity);
  setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
  ConfigurationBuilder builder=new ConfigurationBuilder();
  builder.setOAuthConsumerKey(settings.TWITTER_CONSUMER_KEY);
  builder.setOAuthConsumerSecret(settings.TWITTER_CONSUMER_SECRET);
  Configuration configuration=builder.build();
  TwitterFactory factory=new TwitterFactory(configuration);
  twitter=factory.getInstance();
  btnLoginTwitter=(Button)findViewById(R.id.btnLoginTwitter);
  noThanks=(Button)findViewById(R.id.dont_follow);
  title=(TextSwitcher)findViewById(R.id.welcome);
  summary=(TextSwitcher)findViewById(R.id.info);
  progDescription=(TextSwitcher)findViewById(R.id.progress_desc);
  progressBar=(ProgressBar)findViewById(R.id.progress_bar);
  main=(LinearLayout)findViewById(R.id.mainLayout);
  Animation in=AnimationUtils.loadAnimation(this,android.R.anim.slide_in_left);
  Animation out=AnimationUtils.loadAnimation(this,android.R.anim.slide_out_right);
  title.setFactory(new ViewSwitcher.ViewFactory(){
    public View makeView(){
      TextView myText=new TextView(LoginActivity.this);
      myText.setTextSize(30);
      return myText;
    }
  }
);
  title.setInAnimation(in);
  title.setOutAnimation(out);
  summary.setFactory(new ViewSwitcher.ViewFactory(){
    public View makeView(){
      TextView myText=new TextView(LoginActivity.this);
      myText.setTextSize(17);
      return myText;
    }
  }
);
  summary.setInAnimation(in);
  summary.setOutAnimation(out);
  progDescription.setFactory(new ViewSwitcher.ViewFactory(){
    public View makeView(){
      TextView myText=new TextView(LoginActivity.this);
      myText.setTextSize(17);
      return myText;
    }
  }
);
  progDescription.setInAnimation(in);
  progDescription.setOutAnimation(out);
  title.setText(getResources().getString(R.string.first_welcome));
  summary.setText(getResources().getString(R.string.first_info));
  progressBar.setProgress(100);
  CookieSyncManager.createInstance(this);
  CookieManager cookieManager=CookieManager.getInstance();
  cookieManager.removeAllCookie();
  mWebView=(WebView)findViewById(R.id.loginWebView);
  try {
    mWebView.getSettings().setJavaScriptEnabled(true);
  }
 catch (  Exception e) {
  }
  mWebView.getSettings().setAppCacheEnabled(false);
  mWebView.getSettings().setSavePassword(false);
  mWebView.getSettings().setSaveFormData(false);
  mWebView.setWebViewClient(new WebViewClient(){
    @Override public boolean shouldOverrideUrlLoading(    WebView webView,    String url){
      Log.v(""String_Node_Str"",""String_Node_Str"" + url);
      if (url != null && url.startsWith(""String_Node_Str"")) {
        handleTwitterCallback(url);
      }
 else       if (url.equals(""String_Node_Str"")) {
        webView.loadUrl(requestUrl);
      }
 else {
        webView.loadUrl(url);
      }
      return true;
    }
  }
);
  noThanks.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View view){
      new FollowMe().execute();
      btnLoginTwitter.setText(getResources().getString(R.string.back_to_timeline));
      noThanks.setVisibility(View.GONE);
      summary.setText(getResources().getString(R.string.third_info));
    }
  }
);
  btnLoginTwitter.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View arg0){
      if (btnLoginTwitter.getText().toString().contains(getResources().getString(R.string.login_to_twitter))) {
        if (Utils.hasInternetConnection(context)) {
          btnLoginTwitter.setEnabled(false);
          new AlertDialog.Builder(context).setMessage(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"").setPositiveButton(R.string.ok,new DialogInterface.OnClickListener(){
            @Override public void onClick(            DialogInterface dialog,            int which){
              dialog.dismiss();
            }
          }
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
            @Override public void onClick(            DialogInterface dialog,            int which){
              startActivity(new Intent(Intent.ACTION_VIEW,Uri.parse(""String_Node_Str"")));
            }
          }
).show();
          new RetreiveFeedTask().execute();
        }
 else {
          Toast.makeText(context,getResources().getString(R.string.no_network) + ""String_Node_Str"",Toast.LENGTH_SHORT).show();
        }
      }
 else       if (btnLoginTwitter.getText().toString().contains(getResources().getString(R.string.initial_sync))) {
        new getTimeLine().execute();
      }
 else       if (btnLoginTwitter.getText().toString().contains(getResources().getString(R.string.no_thanks))) {
        btnLoginTwitter.setText(getResources().getString(R.string.back_to_timeline));
        noThanks.setVisibility(View.GONE);
        summary.setText(getResources().getString(R.string.third_info));
      }
 else {
        if (settings.timelineRefresh != 0) {
          AlarmManager am=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
          long now=new Date().getTime();
          long alarm=now + settings.timelineRefresh;
          PendingIntent pendingIntent=PendingIntent.getService(context,HomeFragment.HOME_REFRESH_ID,new Intent(context,TimelineRefreshService.class),0);
          am.setRepeating(AlarmManager.RTC_WAKEUP,alarm,settings.timelineRefresh,pendingIntent);
          now=new Date().getTime();
          alarm=now + settings.mentionsRefresh;
          PendingIntent pendingIntent2=PendingIntent.getService(context,MentionsFragment.MENTIONS_REFRESH_ID,new Intent(context,MentionsRefreshService.class),0);
          am.setRepeating(AlarmManager.RTC_WAKEUP,alarm,settings.mentionsRefresh,pendingIntent2);
          alarm=now + settings.dmRefresh;
          PendingIntent pendingIntent3=PendingIntent.getService(context,DMFragment.DM_REFRESH_ID,new Intent(context,DirectMessageRefreshService.class),0);
          am.setRepeating(AlarmManager.RTC_WAKEUP,alarm,settings.dmRefresh,pendingIntent3);
        }
        AlarmManager am=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
        long now=new Date().getTime();
        long alarm=now + AlarmManager.INTERVAL_DAY;
        Log.v(""String_Node_Str"",""String_Node_Str"" + new Date(alarm).toString());
        PendingIntent pendingIntent=PendingIntent.getService(context,161,new Intent(context,TrimDataService.class),0);
        am.set(AlarmManager.RTC_WAKEUP,alarm,pendingIntent);
        finish();
        Intent timeline=new Intent(context,MainActivity.class);
        timeline.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP);
        timeline.putExtra(""String_Node_Str"",true);
        sharedPrefs.edit().putBoolean(""String_Node_Str"",false).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",true).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",true).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",true).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",false).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",false).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",true).commit();
        sharedPrefs.edit().putBoolean(""String_Node_Str"",false).commit();
        AppSettings.invalidate();
        startActivity(timeline);
      }
    }
  }
);
}"
54341,"@Override public boolean shouldOverrideUrlLoading(WebView webView,String url){
  if (url != null && url.startsWith(""String_Node_Str"")) {
    handleTwitterCallback(url);
  }
 else {
    webView.loadUrl(url);
  }
  return true;
}","@Override public boolean shouldOverrideUrlLoading(WebView webView,String url){
  Log.v(""String_Node_Str"",""String_Node_Str"" + url);
  if (url != null && url.startsWith(""String_Node_Str"")) {
    handleTwitterCallback(url);
  }
 else   if (url.equals(""String_Node_Str"")) {
    webView.loadUrl(requestUrl);
  }
 else {
    webView.loadUrl(url);
  }
  return true;
}"
54342,"@Override public void disableDataInsertMode(){
  this.dataImportMode=false;
}","@Override public void disableDataInsertMode(String schemaName){
  schemaImportMode.put(schemaName,Boolean.FALSE);
}"
54343,"@Override public boolean isOnDataInsertMode(){
  return dataImportMode;
}","@Override public boolean isOnDataInsertMode(String schemaName){
  Boolean importMode=schemaImportMode.get(schemaName);
  if (importMode == null) {
    return false;
  }
  return importMode;
}"
54344,"/** 
 * Configure the backend. <p>The contract specifies that any subclass must call initialize() method after properly constructing the object.
 * @param threadFactory the thread factory that will be used to create the startup and shutdownthreads
 */
public AbstractDbBackendService(@TorodbIdleService ThreadFactory threadFactory,ConfigurationT configuration,ErrorHandler errorHandler){
  super(threadFactory);
  this.configuration=configuration;
  this.errorHandler=errorHandler;
  this.dataImportMode=false;
  int connectionPoolSize=configuration.getConnectionPoolSize();
  int reservedReadPoolSize=configuration.getReservedReadPoolSize();
  Preconditions.checkState(connectionPoolSize >= MIN_CONNECTIONS_DATABASE,""String_Node_Str"" + MIN_CONNECTIONS_DATABASE + ""String_Node_Str"");
  Preconditions.checkState(reservedReadPoolSize >= MIN_READ_CONNECTIONS_DATABASE,""String_Node_Str"" + MIN_READ_CONNECTIONS_DATABASE + ""String_Node_Str"");
  Preconditions.checkState(connectionPoolSize - reservedReadPoolSize >= MIN_SESSION_CONNECTIONS_DATABASE,""String_Node_Str"" + MIN_SESSION_CONNECTIONS_DATABASE);
}","/** 
 * Configure the backend. <p>The contract specifies that any subclass must call initialize() method after properly constructing the object.
 * @param threadFactory the thread factory that will be used to create the startup and shutdownthreads
 */
public AbstractDbBackendService(@TorodbIdleService ThreadFactory threadFactory,ConfigurationT configuration,ErrorHandler errorHandler){
  super(threadFactory);
  this.configuration=configuration;
  this.errorHandler=errorHandler;
  int connectionPoolSize=configuration.getConnectionPoolSize();
  int reservedReadPoolSize=configuration.getReservedReadPoolSize();
  Preconditions.checkState(connectionPoolSize >= MIN_CONNECTIONS_DATABASE,""String_Node_Str"" + MIN_CONNECTIONS_DATABASE + ""String_Node_Str"");
  Preconditions.checkState(reservedReadPoolSize >= MIN_READ_CONNECTIONS_DATABASE,""String_Node_Str"" + MIN_READ_CONNECTIONS_DATABASE + ""String_Node_Str"");
  Preconditions.checkState(connectionPoolSize - reservedReadPoolSize >= MIN_SESSION_CONNECTIONS_DATABASE,""String_Node_Str"" + MIN_SESSION_CONNECTIONS_DATABASE);
}"
54345,"@Override public void enableDataInsertMode(){
  this.dataImportMode=true;
}","@Override public void enableDataInsertMode(String schemaName){
  schemaImportMode.put(schemaName,Boolean.TRUE);
}"
54346,"@Override public void addMetaIndexField(DSLContext dsl,MetaDatabase database,MetaCollection collection,MetaIndex index,MetaIndexField field){
  String statement=getAddMetaIndexFieldStatement(database.getName(),collection.getName(),index.getName(),field.getPosition(),field.getTableRef(),field.getName(),field.getOrdering());
  sqlHelper.executeUpdate(dsl,statement,Context.META_INSERT);
}","@Override public void addMetaIndexField(DSLContext dsl,MetaDatabase database,MetaCollection collection,MetaIndex index,MetaIndexField field){
  String statement=getAddMetaIndexFieldStatement(database.getName(),collection.getName(),index.getName(),field.getPosition(),field.getTableRef(),field.getFieldName(),field.getOrdering());
  sqlHelper.executeUpdate(dsl,statement,Context.META_INSERT);
}"
54347,"@Override public Stream<Function<DSLContext,String>> streamDataInsertFinishTasks(MetaSnapshot snapshot){
  return Collections.<Function<DSLContext,String>>emptySet().stream();
}","@Override public Stream<Function<DSLContext,String>> streamDataInsertFinishTasks(MetaDatabase db){
  return Collections.<Function<DSLContext,String>>emptySet().stream();
}"
54348,"@Override public Stream<Function<DSLContext,String>> streamDocPartTableIndexesCreation(String schemaName,String tableName,TableRef tableRef,String foreignTableName){
  List<Function<DSLContext,String>> result=new ArrayList<>(4);
  if (!dbBackend.isOnDataInsertMode()) {
    String primaryKeyStatement=getAddDocPartTablePrimaryKeyStatement(schemaName,tableName,metaDataReadInterface.getPrimaryKeyInternalFields(tableRef));
    result.add((dsl) -> {
      sqlHelper.executeStatement(dsl,primaryKeyStatement,Context.ADD_UNIQUE_INDEX);
      return ""String_Node_Str"";
    }
);
  }
  if (!dbBackend.isOnDataInsertMode()) {
    String readIndexStatement=getCreateDocPartTableIndexStatement(schemaName,tableName,metaDataReadInterface.getReadInternalFields(tableRef));
    result.add((dsl) -> {
      sqlHelper.executeStatement(dsl,readIndexStatement,Context.CREATE_INDEX);
      return metaDataReadInterface.getReadInternalFields(tableRef).stream().map(f -> f.getName()).collect(Collectors.joining(""String_Node_Str"")) + ""String_Node_Str"";
    }
);
  }
  if (!dbBackend.isOnDataInsertMode()) {
    if (dbBackend.includeForeignKeys()) {
      String foreignKeyStatement=getAddDocPartTableForeignKeyStatement(schemaName,tableName,metaDataReadInterface.getReferenceInternalFields(tableRef),foreignTableName,metaDataReadInterface.getForeignInternalFields(tableRef));
      result.add((dsl) -> {
        sqlHelper.executeStatement(dsl,foreignKeyStatement,Context.ADD_FOREIGN_KEY);
        return metaDataReadInterface.getReferenceInternalFields(tableRef).stream().map(f -> f.getName()).collect(Collectors.joining(""String_Node_Str"")) + ""String_Node_Str"";
      }
);
    }
 else {
      if (!tableRef.isRoot() && !tableRef.getParent().get().isRoot()) {
        String foreignKeyIndexStatement=getCreateDocPartTableIndexStatement(schemaName,tableName,metaDataReadInterface.getReferenceInternalFields(tableRef));
        result.add((dsl) -> {
          sqlHelper.executeStatement(dsl,foreignKeyIndexStatement,Context.CREATE_INDEX);
          return metaDataReadInterface.getReferenceInternalFields(tableRef).stream().map(f -> f.getName()).collect(Collectors.joining(""String_Node_Str"")) + ""String_Node_Str"";
        }
);
      }
    }
  }
  return result.stream();
}","@Override public Stream<Function<DSLContext,String>> streamDocPartTableIndexesCreation(String schemaName,String tableName,TableRef tableRef,String foreignTableName){
  List<Function<DSLContext,String>> result=new ArrayList<>(4);
  if (!dbBackend.isOnDataInsertMode(schemaName)) {
    String primaryKeyStatement=getAddDocPartTablePrimaryKeyStatement(schemaName,tableName,metaDataReadInterface.getPrimaryKeyInternalFields(tableRef));
    result.add((dsl) -> {
      sqlHelper.executeStatement(dsl,primaryKeyStatement,Context.ADD_UNIQUE_INDEX);
      return ""String_Node_Str"";
    }
);
  }
  if (!dbBackend.isOnDataInsertMode(schemaName)) {
    String readIndexStatement=getCreateDocPartTableIndexStatement(schemaName,tableName,metaDataReadInterface.getReadInternalFields(tableRef));
    result.add((dsl) -> {
      sqlHelper.executeStatement(dsl,readIndexStatement,Context.CREATE_INDEX);
      return metaDataReadInterface.getReadInternalFields(tableRef).stream().map(f -> f.getName()).collect(Collectors.joining(""String_Node_Str"")) + ""String_Node_Str"";
    }
);
  }
  if (!dbBackend.isOnDataInsertMode(schemaName)) {
    if (dbBackend.includeForeignKeys()) {
      String foreignKeyStatement=getAddDocPartTableForeignKeyStatement(schemaName,tableName,metaDataReadInterface.getReferenceInternalFields(tableRef),foreignTableName,metaDataReadInterface.getForeignInternalFields(tableRef));
      result.add((dsl) -> {
        sqlHelper.executeStatement(dsl,foreignKeyStatement,Context.ADD_FOREIGN_KEY);
        return metaDataReadInterface.getReferenceInternalFields(tableRef).stream().map(f -> f.getName()).collect(Collectors.joining(""String_Node_Str"")) + ""String_Node_Str"";
      }
);
    }
 else {
      if (!tableRef.isRoot() && !tableRef.getParent().get().isRoot()) {
        String foreignKeyIndexStatement=getCreateDocPartTableIndexStatement(schemaName,tableName,metaDataReadInterface.getReferenceInternalFields(tableRef));
        result.add((dsl) -> {
          sqlHelper.executeStatement(dsl,foreignKeyIndexStatement,Context.CREATE_INDEX);
          return metaDataReadInterface.getReferenceInternalFields(tableRef).stream().map(f -> f.getName()).collect(Collectors.joining(""String_Node_Str"")) + ""String_Node_Str"";
        }
);
      }
    }
  }
  return result.stream();
}"
54349,"@Override public void createIndex(DSLContext dsl,String indexName,String schemaName,String tableName,List<Tuple2<String,Boolean>> columnList,boolean unique) throws UserException {
  if (!dbBackend.isOnDataInsertMode()) {
    Preconditions.checkArgument(!columnList.isEmpty(),""String_Node_Str"");
    String statement=getCreateIndexStatement(indexName,schemaName,tableName,columnList,unique);
    sqlHelper.executeUpdateOrThrow(dsl,statement,unique ? Context.ADD_UNIQUE_INDEX : Context.CREATE_INDEX);
  }
}","@Override public void createIndex(DSLContext dsl,String indexName,String schemaName,String tableName,List<Tuple2<String,Boolean>> columnList,boolean unique) throws UserException {
  if (!dbBackend.isOnDataInsertMode(schemaName)) {
    Preconditions.checkArgument(!columnList.isEmpty(),""String_Node_Str"");
    String statement=getCreateIndexStatement(indexName,schemaName,tableName,columnList,unique);
    sqlHelper.executeUpdateOrThrow(dsl,statement,unique ? Context.ADD_UNIQUE_INDEX : Context.CREATE_INDEX);
  }
}"
54350,"@Override public Stream<Function<DSLContext,String>> streamRootDocPartTableIndexesCreation(String schemaName,String tableName,TableRef tableRef){
  List<Function<DSLContext,String>> result=new ArrayList<>(1);
  if (!dbBackend.isOnDataInsertMode()) {
    String primaryKeyStatement=getAddDocPartTablePrimaryKeyStatement(schemaName,tableName,metaDataReadInterface.getPrimaryKeyInternalFields(tableRef));
    result.add(dsl -> {
      sqlHelper.executeStatement(dsl,primaryKeyStatement,Context.ADD_UNIQUE_INDEX);
      return metaDataReadInterface.getPrimaryKeyInternalFields(tableRef).stream().map(f -> f.getName()).collect(Collectors.joining(""String_Node_Str"")) + ""String_Node_Str"";
    }
);
  }
  return result.stream();
}","@Override public Stream<Function<DSLContext,String>> streamRootDocPartTableIndexesCreation(String schemaName,String tableName,TableRef tableRef){
  List<Function<DSLContext,String>> result=new ArrayList<>(1);
  if (!dbBackend.isOnDataInsertMode(schemaName)) {
    String primaryKeyStatement=getAddDocPartTablePrimaryKeyStatement(schemaName,tableName,metaDataReadInterface.getPrimaryKeyInternalFields(tableRef));
    result.add(dsl -> {
      sqlHelper.executeStatement(dsl,primaryKeyStatement,Context.ADD_UNIQUE_INDEX);
      return metaDataReadInterface.getPrimaryKeyInternalFields(tableRef).stream().map(f -> f.getName()).collect(Collectors.joining(""String_Node_Str"")) + ""String_Node_Str"";
    }
);
  }
  return result.stream();
}"
54351,"@Override public void enableDataImportMode(MetaSnapshot snapshot) throws RollbackException {
  if (!sqlInterface.getDbBackend().isOnDataInsertMode()) {
    if (snapshot.streamMetaDatabases().findAny().isPresent()) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    sqlInterface.getDbBackend().enableDataInsertMode();
  }
}","@Override public CompletableFuture<Empty> enableDataImportMode(MetaDatabase db) throws RollbackException {
  if (!sqlInterface.getDbBackend().isOnDataInsertMode(db)) {
    sqlInterface.getDbBackend().enableDataInsertMode(db);
  }
  return CompletableFuture.completedFuture(Empty.getInstance());
}"
54352,"@Override public void disableDataImportMode(MetaSnapshot snapshot) throws RollbackException {
  if (sqlInterface.getDbBackend().isOnDataInsertMode()) {
    sqlInterface.getDbBackend().disableDataInsertMode();
    Stream<Consumer<DSLContext>> createInternalIndexesJobs=snapshot.streamMetaDatabases().flatMap(db -> db.streamMetaCollections().flatMap(col -> col.streamContainedMetaDocParts().flatMap(docPart -> enableInternalIndexJobs(db,col,docPart))));
    Stream<Consumer<DSLContext>> createIndexesJobs=snapshot.streamMetaDatabases().flatMap(db -> db.streamMetaCollections().flatMap(col -> enableIndexJobs(db,col)));
    Stream<Consumer<DSLContext>> backendSpecificJobs=sqlInterface.getStructureInterface().streamDataInsertFinishTasks(snapshot).map(job -> {
      return (Consumer<DSLContext>)dsl -> {
        String index=job.apply(dsl);
        LOGGER.info(""String_Node_Str"",index);
      }
;
    }
);
    Stream<Consumer<DSLContext>> jobs=Stream.concat(createInternalIndexesJobs,createIndexesJobs);
    jobs=Stream.concat(jobs,backendSpecificJobs);
    Stream<Runnable> runnables=jobs.map(this::dslConsumerToRunnable);
    streamExecutor.executeRunnables(runnables).join();
  }
}","@Override public CompletableFuture<Empty> disableDataImportMode(MetaDatabase db) throws RollbackException {
  if (!sqlInterface.getDbBackend().isOnDataInsertMode(db)) {
    LOGGER.debug(""String_Node_Str"",db.getIdentifier());
    return CompletableFuture.completedFuture(Empty.getInstance());
  }
  sqlInterface.getDbBackend().disableDataInsertMode(db);
  Stream<Consumer<DSLContext>> createInternalIndexesJobs=db.streamMetaCollections().flatMap(col -> col.streamContainedMetaDocParts().flatMap(docPart -> enableInternalIndexJobs(db,col,docPart)));
  Stream<Consumer<DSLContext>> createIndexesJobs=db.streamMetaCollections().flatMap(col -> enableIndexJobs(db,col));
  Stream<Consumer<DSLContext>> backendSpecificJobs=sqlInterface.getStructureInterface().streamDataInsertFinishTasks(db).map(job -> {
    return (Consumer<DSLContext>)dsl -> {
      String index=job.apply(dsl);
      LOGGER.info(""String_Node_Str"",index);
    }
;
  }
);
  Stream<Consumer<DSLContext>> jobs=Stream.concat(createInternalIndexesJobs,createIndexesJobs);
  jobs=Stream.concat(jobs,backendSpecificJobs);
  Stream<Runnable> runnables=jobs.map(this::dslConsumerToRunnable);
  return streamExecutor.executeRunnables(runnables);
}"
54353,public void disableDataInsertMode();,"public default void disableDataInsertMode(MetaDatabase db){
  disableDataInsertMode(db.getIdentifier());
}"
54354,public boolean isOnDataInsertMode();,"public default boolean isOnDataInsertMode(MetaDatabase db){
  return isOnDataInsertMode(db.getIdentifier());
}"
54355,public void enableDataInsertMode();,"public default void enableDataInsertMode(MetaDatabase db){
  enableDataInsertMode(db.getIdentifier());
}"
54356,"private void copyIndexFields(MetaIndex fromMetaIndex,MetaDatabase toMetaDb,MetaCollection toMetaColl,MutableMetaIndex toMetaIndex){
  Iterator<? extends MetaIndexField> fromMetaIndexFieldIterator=fromMetaIndex.iteratorFields();
  while (fromMetaIndexFieldIterator.hasNext()) {
    MetaIndexField fromMetaIndexField=fromMetaIndexFieldIterator.next();
    MetaIndexField toMetaIndexField=toMetaIndex.addMetaIndexField(fromMetaIndexField.getTableRef(),fromMetaIndexField.getName(),fromMetaIndexField.getOrdering());
    getSqlInterface().getMetaDataWriteInterface().addMetaIndexField(getDsl(),toMetaDb,toMetaColl,toMetaIndex,toMetaIndexField);
  }
}","private void copyIndexFields(MetaIndex fromMetaIndex,MetaDatabase toMetaDb,MetaCollection toMetaColl,MutableMetaIndex toMetaIndex){
  Iterator<? extends MetaIndexField> fromMetaIndexFieldIterator=fromMetaIndex.iteratorFields();
  while (fromMetaIndexFieldIterator.hasNext()) {
    MetaIndexField fromMetaIndexField=fromMetaIndexFieldIterator.next();
    MetaIndexField toMetaIndexField=toMetaIndex.addMetaIndexField(fromMetaIndexField.getTableRef(),fromMetaIndexField.getFieldName(),fromMetaIndexField.getOrdering());
    getSqlInterface().getMetaDataWriteInterface().addMetaIndexField(getDsl(),toMetaDb,toMetaColl,toMetaIndex,toMetaIndexField);
  }
}"
54357,"/** 
 * Returns a stream of functions that, when executed, executes backend specific tasks that should be done once the data insert mode finishes and return a label that indicate the type of operation executed. For example, PostgreSQL backend would like to run analyze on the modified tables to get some stadistics.
 * @param snapshot
 * @return
 */
public Stream<Function<DSLContext,String>> streamDataInsertFinishTasks(MetaSnapshot snapshot);","/** 
 * Returns a stream of functions that, when executed, executes backend specific tasks that should be done once the data insert mode finishes and return a label that indicate the type of operation executed. <p>For example, PostgreSQL backend would like to run analyze on the modified tables to get some stadistics.
 */
public Stream<Function<DSLContext,String>> streamDataInsertFinishTasks(MetaDatabase db);"
54358,"@Override public Stream<Function<DSLContext,String>> streamDataInsertFinishTasks(MetaSnapshot snapshot){
  return snapshot.streamMetaDatabases().flatMap(db -> db.streamMetaCollections().flatMap(col -> col.streamContainedMetaDocParts().map(docPart -> createAnalyzeConsumer(db,col,docPart))));
}","@Override public Stream<Function<DSLContext,String>> streamDataInsertFinishTasks(MetaDatabase db){
  return db.streamMetaCollections().flatMap(col -> col.streamContainedMetaDocParts().map(docPart -> createAnalyzeConsumer(db,col,docPart)));
}"
54359,"public static HeartbeatInfo unmarshall(BsonDocument bson) throws TypesMismatchException, NoSuchKeyException, BadValueException {
  BsonReaderTool.checkOnlyHasFields(""String_Node_Str"",bson,CHECK_EMPTY_FIELD_NAME.getFieldName(),PROTOCOL_VERSION_FIELD_NAME.getFieldName(),CONFIG_VERSION_FIELD_NAME.getFieldName(),SENDER_ID_FIELD_NAME.getFieldName(),SET_NAME_FIELD_NAME.getFieldName(),SENDER_HOST_FIELD_NAME.getFieldName());
  Boolean checkEmpty=null;
  if (bson.containsKey(CHECK_EMPTY_FIELD_NAME.getFieldName())) {
    checkEmpty=BsonReaderTool.getBoolean(bson,CHECK_EMPTY_FIELD_NAME);
  }
  long protocolVersion=BsonReaderTool.getLong(bson,PROTOCOL_VERSION_FIELD_NAME);
  long configVersion=BsonReaderTool.getLong(bson,CONFIG_VERSION_FIELD_NAME);
  Long senderId=null;
  if (bson.containsKey(SENDER_ID_FIELD_NAME.getFieldName())) {
    senderId=BsonReaderTool.getLong(bson,SENDER_ID_FIELD_NAME);
  }
  String setName=BsonReaderTool.getString(bson,SET_NAME_FIELD_NAME);
  String senderHostString=BsonReaderTool.getString(bson,SENDER_HOST_FIELD_NAME,null);
  HostAndPort senderHost=senderHostString != null ? BsonReaderTool.getHostAndPort(senderHostString) : null;
  return new HeartbeatInfo(protocolVersion,configVersion,setName,senderHost,senderId,checkEmpty);
}","public static HeartbeatInfo unmarshall(BsonDocument bson) throws TypesMismatchException, NoSuchKeyException, BadValueException {
  BsonReaderTool.checkOnlyHasFields(""String_Node_Str"",bson,CHECK_EMPTY_FIELD_NAME.getFieldName(),PROTOCOL_VERSION_FIELD_NAME.getFieldName(),CONFIG_VERSION_FIELD_NAME.getFieldName(),SENDER_ID_FIELD_NAME.getFieldName(),SET_NAME_FIELD_NAME.getFieldName(),SENDER_HOST_FIELD_NAME.getFieldName());
  Boolean checkEmpty=null;
  if (bson.containsKey(CHECK_EMPTY_FIELD_NAME.getFieldName())) {
    checkEmpty=BsonReaderTool.getBoolean(bson,CHECK_EMPTY_FIELD_NAME);
  }
  long protocolVersion=BsonReaderTool.getLong(bson,PROTOCOL_VERSION_FIELD_NAME,0);
  long configVersion=BsonReaderTool.getLong(bson,CONFIG_VERSION_FIELD_NAME);
  Long senderId=null;
  if (bson.containsKey(SENDER_ID_FIELD_NAME.getFieldName())) {
    senderId=BsonReaderTool.getLong(bson,SENDER_ID_FIELD_NAME);
  }
  String setName=BsonReaderTool.getString(bson,SET_NAME_FIELD_NAME);
  String senderHostString=BsonReaderTool.getString(bson,SENDER_HOST_FIELD_NAME,null);
  HostAndPort senderHost=senderHostString != null ? BsonReaderTool.getHostAndPort(senderHostString) : null;
  return new HeartbeatInfo(protocolVersion,configVersion,setName,senderHost,senderId,checkEmpty);
}"
54360,"public static ReplicaSetConfig fromDocument(@Nonnull BsonDocument bson) throws BadValueException, TypesMismatchException, NoSuchKeyException, FailedToParseException {
  BsonReaderTool.checkOnlyHasFields(""String_Node_Str"",bson,VALID_FIELD_NAMES);
  String id=BsonReaderTool.getString(bson,ID_FIELD);
  int version=BsonReaderTool.getInteger(bson,VERSION_FIELD);
  Builder builder=new Builder(id,version);
  BsonArray uncastedMembers=BsonReaderTool.getArray(bson,MEMBERS_FIELD);
  int i=0;
  for (  BsonValue uncastedMember : uncastedMembers) {
    if (uncastedMember == null || !uncastedMember.isDocument()) {
      throw new TypesMismatchException(Integer.toString(i),""String_Node_Str"",uncastedMember == null ? null : uncastedMember.getType());
    }
    builder.addMemberConfig(MemberConfig.fromDocument(uncastedMember.asDocument()));
    i++;
  }
  BsonDocument settings;
  try {
    settings=BsonReaderTool.getDocument(bson,SETTINGS_FIELD);
  }
 catch (  NoSuchKeyException ex) {
    settings=DefaultBsonValues.EMPTY_DOC;
  }
  builder.setHbTimeout(BsonReaderTool.getInteger(settings,HEARTHBEAT_TIMEOUT_FIELD,DEFAULT_HEARTBEAT_TIMEOUT_MILLIS)).setChainingAllowed(BsonReaderTool.getBoolean(settings,CHAINING_ALLOWED_FIELD,DEFAULT_CHAINING_ALLOWED));
  BsonDocument uncastedGetLastErrorDefaults=BsonReaderTool.getDocument(settings,GET_LAST_ERROR_DEFAULTS_FIELD);
  WriteConcern wc=WriteConcern.fromDocument(uncastedGetLastErrorDefaults);
  builder.setWriteConcern(wc);
  BsonDocument uncastedCustomWriteConcerns;
  try {
    uncastedCustomWriteConcerns=BsonReaderTool.getDocument(settings,GET_LAST_ERROR_MODES_FIELD);
  }
 catch (  NoSuchKeyException ex) {
    uncastedCustomWriteConcerns=DefaultBsonValues.EMPTY_DOC;
  }
  Map<String,ReplicaSetTagPattern> customWriteConcernsBuilder=parseCustomWriteConcerns(uncastedCustomWriteConcerns);
  for (  Map.Entry<String,ReplicaSetTagPattern> customWriteConcern : customWriteConcernsBuilder.entrySet()) {
    builder.putCustomWriteConcern(customWriteConcern.getKey(),customWriteConcern.getValue());
  }
  builder.setProtocolVersion(BsonReaderTool.getLong(bson,PROTOCOL_VERSION_FIELD));
  return builder.build();
}","public static ReplicaSetConfig fromDocument(@Nonnull BsonDocument bson) throws BadValueException, TypesMismatchException, NoSuchKeyException, FailedToParseException {
  BsonReaderTool.checkOnlyHasFields(""String_Node_Str"",bson,VALID_FIELD_NAMES);
  String id=BsonReaderTool.getString(bson,ID_FIELD);
  int version=BsonReaderTool.getInteger(bson,VERSION_FIELD);
  Builder builder=new Builder(id,version);
  BsonArray uncastedMembers=BsonReaderTool.getArray(bson,MEMBERS_FIELD);
  int i=0;
  for (  BsonValue uncastedMember : uncastedMembers) {
    if (uncastedMember == null || !uncastedMember.isDocument()) {
      throw new TypesMismatchException(Integer.toString(i),""String_Node_Str"",uncastedMember == null ? null : uncastedMember.getType());
    }
    builder.addMemberConfig(MemberConfig.fromDocument(uncastedMember.asDocument()));
    i++;
  }
  BsonDocument settings;
  try {
    settings=BsonReaderTool.getDocument(bson,SETTINGS_FIELD);
  }
 catch (  NoSuchKeyException ex) {
    settings=DefaultBsonValues.EMPTY_DOC;
  }
  builder.setHbTimeout(BsonReaderTool.getInteger(settings,HEARTHBEAT_TIMEOUT_FIELD,DEFAULT_HEARTBEAT_TIMEOUT_MILLIS)).setChainingAllowed(BsonReaderTool.getBoolean(settings,CHAINING_ALLOWED_FIELD,DEFAULT_CHAINING_ALLOWED));
  BsonDocument uncastedGetLastErrorDefaults=BsonReaderTool.getDocument(settings,GET_LAST_ERROR_DEFAULTS_FIELD);
  WriteConcern wc=WriteConcern.fromDocument(uncastedGetLastErrorDefaults);
  builder.setWriteConcern(wc);
  BsonDocument uncastedCustomWriteConcerns;
  try {
    uncastedCustomWriteConcerns=BsonReaderTool.getDocument(settings,GET_LAST_ERROR_MODES_FIELD);
  }
 catch (  NoSuchKeyException ex) {
    uncastedCustomWriteConcerns=DefaultBsonValues.EMPTY_DOC;
  }
  Map<String,ReplicaSetTagPattern> customWriteConcernsBuilder=parseCustomWriteConcerns(uncastedCustomWriteConcerns);
  for (  Map.Entry<String,ReplicaSetTagPattern> customWriteConcern : customWriteConcernsBuilder.entrySet()) {
    builder.putCustomWriteConcern(customWriteConcern.getKey(),customWriteConcern.getValue());
  }
  builder.setProtocolVersion(BsonReaderTool.getLong(bson,PROTOCOL_VERSION_FIELD,0));
  return builder.build();
}"
54361,"@Override public MongoDbCoreExtInt getExternalInterface(){
  return new MongoDbCoreExtInt(mongodServer);
}","@Override public MongoDbCoreExtInt getExternalInterface(){
  return new MongoDbCoreExtInt(mongodServer,commandLibrary);
}"
54362,"public MongoDbCoreBundle(MongoDbCoreConfig bundleConfig){
  super(bundleConfig);
  this.torodBundle=bundleConfig.getTorodBundle();
  Injector injector=bundleConfig.getEssentialInjector().createChildInjector(new MongodCoreModule(bundleConfig));
  mongodServer=injector.getInstance(MongodServer.class);
}","public MongoDbCoreBundle(MongoDbCoreConfig bundleConfig){
  super(bundleConfig);
  this.torodBundle=bundleConfig.getTorodBundle();
  this.commandLibrary=bundleConfig.getCommandsLibrary();
  Injector injector=bundleConfig.getEssentialInjector().createChildInjector(new MongodCoreModule(bundleConfig));
  mongodServer=injector.getInstance(MongodServer.class);
}"
54363,"public MongoDbCoreExtInt(MongodServer mongodServer){
  this.mongodServer=mongodServer;
}","public MongoDbCoreExtInt(MongodServer mongodServer,CommandLibrary commandLibrary){
  this.mongodServer=mongodServer;
  this.commandLibrary=commandLibrary;
}"
54364,"@Override public Collection<Service> getDependencies(){
  return Collections.singleton(torodBundle);
}","@Override public Collection<Service> getDependencies(){
  return Collections.singleton(coreBundle);
}"
54365,"public MongoDbWpBundle(MongoDbWpConfig config){
  super(config);
  Injector injector=Guice.createInjector(new MongoDbWpModule(config.getTorodBundle(),config.getPort()));
  this.nettyMongoServer=injector.getInstance(NettyMongoServer.class);
  this.torodBundle=config.getTorodBundle();
}","public MongoDbWpBundle(MongoDbWpConfig config){
  super(config);
  Injector injector=config.getEssentialInjector().createChildInjector(new MongoDbWpModule(config.getCoreBundle(),config.getPort()));
  this.nettyMongoServer=injector.getInstance(NettyMongoServer.class);
  this.coreBundle=config.getCoreBundle();
}"
54366,"@SuppressWarnings(""String_Node_Str"") public MongoDbWpConfig(TorodBundle torodBundle,int port,BundleConfig delegate){
  this.torodBundle=torodBundle;
  this.port=port;
  this.delegate=delegate;
}","@SuppressWarnings(""String_Node_Str"") public MongoDbWpConfig(MongoDbCoreBundle coreBundle,int port,BundleConfig delegate){
  this.coreBundle=coreBundle;
  this.port=port;
  this.delegate=delegate;
}"
54367,"public MongoDbWpConfig build(){
  return new MongoDbWpConfig(torodBundle,port,genericBundle);
}","public MongoDbWpConfig build(){
  return new MongoDbWpConfig(coreBundle,port,genericBundle);
}"
54368,"public MongoDbWpModule(TorodBundle torodBundle,int port){
  this.port=port;
}","public MongoDbWpModule(MongoDbCoreBundle coreBundle,int port){
  this.coreExtInt=coreBundle.getExternalInterface();
  this.port=port;
}"
54369,"@Override protected void configure(){
  bind(NettyMongoServer.class).in(Singleton.class);
  expose(NettyMongoServer.class);
  bind(MongoServerConfig.class).toInstance((MongoServerConfig)() -> port);
  expose(MongoServerConfig.class);
  bind(NettyStringReader.class).to(PooledNettyStringReader.class).in(Singleton.class);
  configureStringPool();
  bind(RequestIdGenerator.class).to(DefaultRequestIdGenerator.class);
  bind(ErrorHandler.class).to(ToroErrorHandler.class).in(Singleton.class);
  bind(RequestMessageByteHandler.class);
  bindMessageDecoder();
  bind(DefaultNettyBsonLowLevelReader.class).in(Singleton.class);
  bind(NettyBsonDocumentReader.class).in(Singleton.class);
  bind(OffHeapNettyBsonLowLevelReader.class).in(Singleton.class);
  bind(OffHeapValuesNettyBsonLowLevelReader.class).to(OffHeapNettyBsonLowLevelReader.class);
  bind(RequestMessageObjectHandler.class).in(Singleton.class);
  bind(ReplyMessageObjectHandler.class);
  bind(TorodbSafeRequestProcessor.class).in(Singleton.class);
  bind(ReplyMessageEncoder.class).in(Singleton.class);
  bind(MongodMetrics.class).in(Singleton.class);
  bind(NettyBsonDocumentWriter.class).in(Singleton.class);
}","@Override protected void configure(){
  expose(NettyMongoServer.class);
  expose(MongoServerConfig.class);
  bindCore();
  bind(NettyMongoServer.class).in(Singleton.class);
  bind(MongoServerConfig.class).toInstance((MongoServerConfig)() -> port);
  bind(NettyStringReader.class).to(PooledNettyStringReader.class).in(Singleton.class);
  configureStringPool();
  bind(RequestIdGenerator.class).to(DefaultRequestIdGenerator.class);
  bind(ErrorHandler.class).to(ToroErrorHandler.class).in(Singleton.class);
  bind(RequestMessageByteHandler.class);
  bindMessageDecoder();
  bind(DefaultNettyBsonLowLevelReader.class).in(Singleton.class);
  bind(NettyBsonDocumentReader.class).in(Singleton.class);
  bind(OffHeapNettyBsonLowLevelReader.class).in(Singleton.class);
  bind(OffHeapValuesNettyBsonLowLevelReader.class).to(OffHeapNettyBsonLowLevelReader.class);
  bind(RequestMessageObjectHandler.class).in(Singleton.class);
  bind(ReplyMessageObjectHandler.class);
  bind(TorodbSafeRequestProcessor.class).in(Singleton.class);
  bind(ReplyMessageEncoder.class).in(Singleton.class);
  bind(MongodMetrics.class).in(Singleton.class);
  bind(NettyBsonDocumentWriter.class).in(Singleton.class);
  bind(ThreadFactory.class).annotatedWith(MongoWp.class).to(ThreadFactory.class);
}"
54370,"private static ServerConfig createServerConfig(Config config){
  Clock clock=Clock.systemDefaultZone();
  MetricsConfig metricsConfig=() -> true;
  Backend backendConfig=config.getBackend();
  backendConfig.setConnectionPoolConfig(config.getGeneric());
  return new ServerConfig(Guice.createInjector(new EssentialModule(metricsConfig,clock)),generalConfig -> BundleFactory.createBackendBundle(backendConfig,generalConfig),(generalConfig,torodBundle) -> createMongoDbWpBundle(config,torodBundle,generalConfig));
}","private static ServerConfig createServerConfig(Config config){
  Clock clock=Clock.systemDefaultZone();
  MetricsConfig metricsConfig=() -> true;
  Backend backendConfig=config.getBackend();
  backendConfig.setConnectionPoolConfig(config.getGeneric());
  return new ServerConfig(Guice.createInjector(new EssentialModule(metricsConfig,clock)),generalConfig -> BundleFactory.createBackendBundle(backendConfig,generalConfig),getSelfHostAndPort(config),(generalConfig,coreBundle) -> createMongoDbWpBundle(config,coreBundle,generalConfig));
}"
54371,"private static MongoDbWpBundle createMongoDbWpBundle(Config config,TorodBundle torodBundle,BundleConfig generalConfig){
  int port=config.getProtocol().getMongo().getNet().getPort();
  return new MongoDbWpBundle(new MongoDbWpConfig(torodBundle,port,generalConfig));
}","private static MongoDbWpBundle createMongoDbWpBundle(Config config,MongoDbCoreBundle coreBundle,BundleConfig generalConfig){
  int port=config.getProtocol().getMongo().getNet().getPort();
  return new MongoDbWpBundle(new MongoDbWpConfig(coreBundle,port,generalConfig));
}"
54372,"public BiFunction<BundleConfig,TorodBundle,MongoDbWpBundle> getMongoDbWpBundleGenerator(){
  return mongoDbWpBundleGenerator;
}","@SuppressWarnings(""String_Node_Str"") public BiFunction<BundleConfig,MongoDbCoreBundle,MongoDbWpBundle> getMongoDbWpBundleGenerator(){
  return mongoDbWpBundleGenerator;
}"
54373,"public ServerConfig(Injector essentialInjector,Function<BundleConfig,BackendBundle> backendBundleGenerator,BiFunction<BundleConfig,TorodBundle,MongoDbWpBundle> wpBundleGenerator){
  this.essentialInjector=essentialInjector;
  this.backendBundleGenerator=backendBundleGenerator;
  this.mongoDbWpBundleGenerator=wpBundleGenerator;
}","public ServerConfig(Injector essentialInjector,Function<BundleConfig,BackendBundle> backendBundleGenerator,HostAndPort selfHostAndPort,BiFunction<BundleConfig,MongoDbCoreBundle,MongoDbWpBundle> mongoDbWpBundleGenerator){
  this.essentialInjector=essentialInjector;
  this.backendBundleGenerator=backendBundleGenerator;
  this.selfHostAndPort=selfHostAndPort;
  this.mongoDbWpBundleGenerator=mongoDbWpBundleGenerator;
}"
54374,"@Override protected void startUp() throws Exception {
  LOGGER.info(""String_Node_Str"");
  shutdowner.startAsync();
  shutdowner.awaitRunning();
  BackendBundle backendBundle=config.getBackendBundleGenerator().apply(generalBundleConfig);
  startBundle(backendBundle);
  TorodBundle torodBundle=createTorodBundle(backendBundle);
  startBundle(torodBundle);
  MongoDbWpBundle mongodbWpBundle=config.getMongoDbWpBundleGenerator().apply(generalBundleConfig,torodBundle);
  startBundle(mongodbWpBundle);
  LOGGER.info(""String_Node_Str"");
}","@Override protected void startUp() throws Exception {
  LOGGER.info(""String_Node_Str"");
  shutdowner.startAsync();
  shutdowner.awaitRunning();
  BackendBundle backendBundle=config.getBackendBundleGenerator().apply(generalBundleConfig);
  startBundle(backendBundle);
  TorodBundle torodBundle=createTorodBundle(backendBundle);
  startBundle(torodBundle);
  MongoDbCoreBundle mongoDbCoreBundle=createMongoDbCoreBundle(torodBundle);
  startBundle(mongoDbCoreBundle);
  MongoDbWpBundle mongodbWpBundle=config.getMongoDbWpBundleGenerator().apply(generalBundleConfig,mongoDbCoreBundle);
  startBundle(mongodbWpBundle);
  LOGGER.info(""String_Node_Str"");
}"
54375,"public ReplCommandsBuilder(BundleConfig generalConfig){
  Injector replCommandsInjector=generalConfig.getEssentialInjector().createChildInjector(new ReplCommandsGuiceModule(),new ExtraModule(generalConfig));
  replCommandsLibrary=replCommandsInjector.getInstance(ReplCommandLibrary.class);
  replCommandsExecutor=replCommandsInjector.getInstance(ReplCommandsExecutor.class);
}","public ReplCommandsBuilder(BundleConfig generalConfig){
  Injector replCommandsInjector=generalConfig.getEssentialInjector().createChildInjector(new ReplCommandsGuiceModule(),new ExtraModule(generalConfig));
  replCommandsLibrary=replCommandsInjector.getInstance(ReplCommandLibrary.class);
  replCommandsExecutor=replCommandsInjector.getInstance(ReplCommandExecutor.class);
}"
54376,"public ReplCommandsExecutor getReplCommandsExecutor(){
  return replCommandsExecutor;
}","public ReplCommandExecutor getReplCommandsExecutor(){
  return replCommandsExecutor;
}"
54377,"@Override protected void configure(){
  requireBinding(Key.get(Supervisor.class,MongoDbRepl.class));
  requireBinding(ReplicationFilters.class);
  expose(ReplCommandLibrary.class);
  expose(ReplCommandsExecutor.class);
  bind(ReplCommandLibrary.class).in(Singleton.class);
  bind(ReplCommandsExecutor.class).in(Singleton.class);
  bindImplementations();
}","@Override protected void configure(){
  requireBinding(Key.get(Supervisor.class,MongoDbRepl.class));
  requireBinding(ReplicationFilters.class);
  expose(ReplCommandLibrary.class);
  expose(ReplCommandExecutor.class);
  bind(ReplCommandLibrary.class).in(Singleton.class);
  bind(ReplCommandExecutor.class).in(Singleton.class);
  bindImplementations();
}"
54378,"public ReplCommandsExecutor getReplCommandsExecutor(){
  return replCommandsExecutor;
}","public ReplCommandExecutor getReplCommandsExecutor(){
  return replCommandsExecutor;
}"
54379,"public DefaultOplogApplierBundleConfig(ReplCoreBundle replCoreBundle,MongoDbCoreBundle mongoDbCorebundle,ReplCommandLibrary replCommandsLibrary,ReplCommandsExecutor replCommandsExecutor,BundleConfig delegate){
  this.replCoreBundle=replCoreBundle;
  this.mongoDbCorebundle=mongoDbCorebundle;
  this.replCommandsLibrary=replCommandsLibrary;
  this.replCommandsExecutor=replCommandsExecutor;
  this.delegate=delegate;
}","public DefaultOplogApplierBundleConfig(ReplCoreBundle replCoreBundle,MongoDbCoreBundle mongoDbCorebundle,ReplCommandLibrary replCommandsLibrary,ReplCommandExecutor replCommandsExecutor,BundleConfig delegate){
  this.replCoreBundle=replCoreBundle;
  this.mongoDbCorebundle=mongoDbCorebundle;
  this.replCommandsLibrary=replCommandsLibrary;
  this.replCommandsExecutor=replCommandsExecutor;
  this.delegate=delegate;
}"
54380,"private void bindConfig(){
  bind(ReplCommandLibrary.class).toInstance(config.getReplCommandsLibrary());
  bind(ReplCommandsExecutor.class).toInstance(config.getReplCommandsExecutor());
  bind(OplogManager.class).toInstance(config.getReplCoreBundle().getExternalInterface().getOplogManager());
  bind(MongodServer.class).toInstance(config.getMongoDbCoreBundle().getExternalInterface().getMongodServer());
}","private void bindConfig(){
  bind(ReplCommandLibrary.class).toInstance(config.getReplCommandsLibrary());
  bind(ReplCommandExecutor.class).toInstance(config.getReplCommandsExecutor());
  bind(OplogManager.class).toInstance(config.getReplCoreBundle().getExternalInterface().getOplogManager());
  bind(MongodServer.class).toInstance(config.getMongoDbCoreBundle().getExternalInterface().getMongodServer());
}"
54381,"@Inject public OplogOperationApplier(ReplCommandLibrary library,ReplCommandsExecutor executor){
  this.library=library;
  this.executor=executor;
}","@Inject public OplogOperationApplier(ReplCommandLibrary library,ReplCommandExecutor executor){
  this.library=library;
  this.executor=executor;
}"
54382,"protected Injector createFinalInjector(BackendBundle backendBundle){
  ToroDbRuntimeModule runtimeModule=new ToroDbRuntimeModule(backendBundle,this);
  return bootstrapInjector.createChildInjector(runtimeModule,new MongoDbWpModule(27018));
}","protected Injector createFinalInjector(BackendBundle backendBundle){
  int port=bootstrapInjector.getInstance(Config.class).getProtocol().getMongo().getNet().getPort();
  ToroDbRuntimeModule runtimeModule=new ToroDbRuntimeModule(backendBundle,this);
  return bootstrapInjector.createChildInjector(runtimeModule,new MongoDbWpModule(port));
}"
54383,"@Override protected void configure(){
  bind(NettyMongoServer.class).in(Singleton.class);
  expose(NettyMongoServer.class);
  bind(MongoServerConfig.class).toInstance((MongoServerConfig)() -> port);
  expose(MongoServerConfig.class);
  bind(NettyStringReader.class).to(PooledNettyStringReader.class).in(Singleton.class);
  configureStringPool();
  bind(RequestIdGenerator.class).to(DefaultRequestIdGenerator.class);
  bind(ErrorHandler.class).to(ToroErrorHandler.class).in(Singleton.class);
  bind(RequestMessageByteHandler.class).in(Singleton.class);
  bindMessageDecoder();
  bind(DefaultNettyBsonLowLevelReader.class).in(Singleton.class);
  bind(NettyBsonDocumentReader.class).in(Singleton.class);
  bind(OffHeapNettyBsonLowLevelReader.class).in(Singleton.class);
  bind(OffHeapValuesNettyBsonLowLevelReader.class).to(OffHeapNettyBsonLowLevelReader.class);
  bind(RequestMessageObjectHandler.class).in(Singleton.class);
  bind(ReplyMessageObjectHandler.class).in(Singleton.class);
  bind(TorodbSafeRequestProcessor.class).in(Singleton.class);
  bind(ReplyMessageEncoder.class).in(Singleton.class);
  bind(MongodMetrics.class).in(Singleton.class);
  bind(NettyBsonDocumentWriter.class).in(Singleton.class);
}","@Override protected void configure(){
  bind(NettyMongoServer.class).in(Singleton.class);
  expose(NettyMongoServer.class);
  bind(MongoServerConfig.class).toInstance((MongoServerConfig)() -> port);
  expose(MongoServerConfig.class);
  bind(NettyStringReader.class).to(PooledNettyStringReader.class).in(Singleton.class);
  configureStringPool();
  bind(RequestIdGenerator.class).to(DefaultRequestIdGenerator.class);
  bind(ErrorHandler.class).to(ToroErrorHandler.class).in(Singleton.class);
  bind(RequestMessageByteHandler.class);
  bindMessageDecoder();
  bind(DefaultNettyBsonLowLevelReader.class).in(Singleton.class);
  bind(NettyBsonDocumentReader.class).in(Singleton.class);
  bind(OffHeapNettyBsonLowLevelReader.class).in(Singleton.class);
  bind(OffHeapValuesNettyBsonLowLevelReader.class).to(OffHeapNettyBsonLowLevelReader.class);
  bind(RequestMessageObjectHandler.class).in(Singleton.class);
  bind(ReplyMessageObjectHandler.class);
  bind(TorodbSafeRequestProcessor.class).in(Singleton.class);
  bind(ReplyMessageEncoder.class).in(Singleton.class);
  bind(MongodMetrics.class).in(Singleton.class);
  bind(NettyBsonDocumentWriter.class).in(Singleton.class);
}"
54384,"public void setUpValues(@Nonnull Instant now,@Nonnull HostAndPort host,@Nonnull ReplSetHeartbeatReply hbResponse){
  health=Health.UP;
  if (upSince.equals(Instant.EPOCH)) {
    upSince=now;
  }
  authIssue=false;
  lastHeartbeat=now;
  ReplSetHeartbeatReplyBuilder lastResponseBuilder=new ReplSetHeartbeatReplyBuilder(hbResponse);
  if (!hbResponse.getState().isPresent()) {
    lastResponseBuilder.setState(MemberState.RS_UNKNOWN);
  }
  lastResponseBuilder.setElectionTime(lastResponse.getElectionTime());
  lastResponseBuilder.setAppliedOpTime(lastResponse.getAppliedOpTime());
  if (!lastResponse.getState().get().equals(hbResponse.getState().get())) {
    LOGGER.info(""String_Node_Str"",host,hbResponse.getState().get());
  }
  lastResponse=lastResponseBuilder.build();
}","public void setUpValues(@Nonnull Instant now,@Nonnull HostAndPort host,@Nonnull ReplSetHeartbeatReply hbResponse){
  health=Health.UP;
  if (upSince.equals(Instant.EPOCH)) {
    upSince=now;
  }
  authIssue=false;
  lastHeartbeat=now;
  ReplSetHeartbeatReplyBuilder lastResponseBuilder=new ReplSetHeartbeatReplyBuilder(hbResponse,lastResponse);
  if (!lastResponse.getState().get().equals(hbResponse.getState().get())) {
    LOGGER.info(""String_Node_Str"",host,hbResponse.getState().get());
  }
  lastResponse=lastResponseBuilder.build();
}"
54385,"@Override public Optional<Duration> getTime(){
  return time;
}","@Override public Optional<Duration> getTime(){
  return Optional.ofNullable(time);
}"
54386,"@Override public Optional<Boolean> getIsReplSet(){
  return isReplSet;
}","@Override public Optional<Boolean> getIsReplSet(){
  return Optional.ofNullable(isReplSet);
}"
54387,"@Override public Optional<OpTime> getAppliedOpTime(){
  return appliedOptime;
}","@Override public Optional<OpTime> getAppliedOpTime(){
  return Optional.ofNullable(appliedOptime);
}"
54388,"@Override public Optional<String> getSetName(){
  return setName;
}","@Override public Optional<String> getSetName(){
  return Optional.ofNullable(setName);
}"
54389,"@Override public Optional<ReplicaSetConfig> getConfig(){
  return config;
}","@Override public Optional<ReplicaSetConfig> getConfig(){
  return Optional.ofNullable(config);
}"
54390,"@Override public Optional<Boolean> getElectable(){
  return electable;
}","@Override public Optional<Boolean> getElectable(){
  return Optional.ofNullable(electable);
}"
54391,"@Override public Optional<OpTime> getDurableOptime(){
  return durableOptime;
}","@Override public Optional<OpTime> getDurableOptime(){
  return Optional.ofNullable(durableOptime);
}"
54392,"@Override public Optional<MemberState> getState(){
  return state;
}","@Override public Optional<MemberState> getState(){
  return Optional.ofNullable(state);
}"
54393,"@Override public Optional<BsonTimestamp> getElectionTime(){
  return electionTime;
}","@Override public Optional<BsonTimestamp> getElectionTime(){
  return Optional.ofNullable(electionTime);
}"
54394,"public CorrectReplSetHeartbeatReply(Optional<BsonTimestamp> electionTime,Optional<Duration> time,Optional<OpTime> appliedOptime,Optional<OpTime> durableOptime,Optional<Boolean> electable,Optional<Boolean> hasData,boolean mismatch,Optional<Boolean> isReplSet,boolean stateDisagreement,Optional<MemberState> state,long configVersion,Optional<String> setName,String hbmsg,Optional<HostAndPort> syncingTo,Optional<ReplicaSetConfig> config,OptionalInt primaryId,long term){
  this.electionTime=electionTime;
  this.time=time;
  this.appliedOptime=appliedOptime;
  this.durableOptime=durableOptime;
  this.electable=electable;
  this.hasData=hasData;
  this.mismatch=mismatch;
  this.isReplSet=isReplSet;
  this.stateDisagreement=stateDisagreement;
  this.state=state;
  this.configVersion=configVersion;
  this.setName=setName;
  this.hbmsg=hbmsg;
  this.syncingTo=syncingTo;
  this.config=config;
  this.primaryId=primaryId;
  this.term=term;
}","public CorrectReplSetHeartbeatReply(BsonTimestamp electionTime,Duration time,OpTime appliedOptime,OpTime durableOptime,Boolean electable,Boolean hasData,boolean mismatch,Boolean isReplSet,boolean stateDisagreement,MemberState state,long configVersion,String setName,String hbmsg,HostAndPort syncingTo,ReplicaSetConfig config,OptionalInt primaryId,long term){
  this.electionTime=electionTime;
  this.time=time;
  this.appliedOptime=appliedOptime;
  this.durableOptime=durableOptime;
  this.electable=electable;
  this.hasData=hasData;
  this.mismatch=mismatch;
  this.isReplSet=isReplSet;
  this.stateDisagreement=stateDisagreement;
  this.state=state;
  this.configVersion=configVersion;
  this.setName=setName;
  this.hbmsg=hbmsg;
  this.syncingTo=syncingTo;
  this.config=config;
  this.primaryId=primaryId;
  this.term=term;
}"
54395,"@Override public Optional<HostAndPort> getSyncingTo(){
  return syncingTo;
}","@Override public Optional<HostAndPort> getSyncingTo(){
  return Optional.ofNullable(syncingTo);
}"
54396,"@Override public Optional<Boolean> getHasData(){
  return hasData;
}","@Override public Optional<Boolean> getHasData(){
  return Optional.ofNullable(hasData);
}"
54397,"public ReplSetHeartbeatReplyBuilder setHasData(@Nullable Boolean hasData){
  this.hasData=Optional.ofNullable(hasData);
  return this;
}","public ReplSetHeartbeatReplyBuilder setHasData(@Nullable Boolean hasData){
  this.hasData=hasData;
  return this;
}"
54398,"public ReplSetHeartbeatReplyBuilder setSyncingTo(@Nullable HostAndPort syncingTo){
  this.syncingTo=Optional.ofNullable(syncingTo);
  return this;
}","public ReplSetHeartbeatReplyBuilder setSyncingTo(@Nullable HostAndPort syncingTo){
  this.syncingTo=syncingTo;
  return this;
}"
54399,"public ReplSetHeartbeatReplyBuilder setSetName(Optional<String> setName){
  this.setName=setName;
  return this;
}","public ReplSetHeartbeatReplyBuilder setSetName(Optional<String> setName){
  this.setName=setName.orElse(null);
  return this;
}"
54400,"public ReplSetHeartbeatReplyBuilder setIsReplSet(boolean isReplSet){
  this.isReplSet=Optional.of(isReplSet);
  return this;
}","public ReplSetHeartbeatReplyBuilder setIsReplSet(boolean isReplSet){
  this.isReplSet=isReplSet;
  return this;
}"
54401,"Optional<OpTime> getAppliedOpTime(){
  return appliedOpTime;
}","Optional<OpTime> getAppliedOpTime(){
  return Optional.ofNullable(appliedOpTime);
}"
54402,"public ReplSetHeartbeatReplyBuilder setDurableOpTime(@Nullable OpTime durableOpTime){
  this.durableOpTime=Optional.ofNullable(durableOpTime);
  return this;
}","public ReplSetHeartbeatReplyBuilder setDurableOpTime(@Nullable OpTime durableOpTime){
  this.durableOpTime=durableOpTime;
  return this;
}"
54403,"public ReplSetHeartbeatReplyBuilder setConfig(@Nullable ReplicaSetConfig config){
  this.config=Optional.ofNullable(config);
  return this;
}","public ReplSetHeartbeatReplyBuilder setConfig(@Nullable ReplicaSetConfig config){
  this.config=config;
  return this;
}"
54404,"public ReplSetHeartbeatReplyBuilder setElectable(boolean electable){
  this.electable=Optional.of(electable);
  return this;
}","public ReplSetHeartbeatReplyBuilder setElectable(boolean electable){
  this.electable=electable;
  return this;
}"
54405,"public ReplSetHeartbeatReplyBuilder(ReplSetHeartbeatReply other){
  this.electionTime=other.getElectionTime();
  this.time=other.getTime();
  this.appliedOpTime=other.getAppliedOpTime();
  this.electable=other.getElectable();
  this.hasData=other.getHasData();
  this.mismatch=other.isMismatch();
  this.isReplSet=other.getIsReplSet();
  this.stateDisagreement=other.isStateDisagreement();
  this.state=other.getState();
  this.configVersion=other.getConfigVersion();
  this.setName=other.getSetName();
  this.hbmsg=other.getHbmsg();
  this.syncingTo=other.getSyncingTo();
  this.config=other.getConfig();
  this.primaryId=other.getPrimaryId();
  this.term=other.getTerm();
}","public ReplSetHeartbeatReplyBuilder(ReplSetHeartbeatReply other,ReplSetHeartbeatReply lastResponse){
  this.electionTime=other.getElectionTime().orElseGet(() -> lastResponse.getElectionTime().orElse(null));
  this.time=other.getTime().orElse(null);
  this.appliedOpTime=other.getAppliedOpTime().orElseGet(() -> lastResponse.getAppliedOpTime().orElse(null));
  this.electable=other.getElectable().orElse(null);
  this.hasData=other.getHasData().orElse(null);
  this.mismatch=other.isMismatch();
  this.isReplSet=other.getIsReplSet().orElse(null);
  this.stateDisagreement=other.isStateDisagreement();
  this.state=other.getState().orElseGet(() -> lastResponse.getState().orElse(null));
  this.configVersion=other.getConfigVersion();
  this.setName=other.getSetName().orElse(null);
  this.hbmsg=other.getHbmsg();
  this.syncingTo=other.getSyncingTo().orElse(null);
  this.config=other.getConfig().orElse(null);
  this.primaryId=other.getPrimaryId();
  this.term=other.getTerm();
}"
54406,"public ReplSetHeartbeatReplyBuilder setState(@Nullable MemberState state){
  this.state=Optional.ofNullable(state);
  return this;
}","public ReplSetHeartbeatReplyBuilder setState(@Nullable MemberState state){
  this.state=state;
  return this;
}"
54407,"public ReplSetHeartbeatReplyBuilder setElectionTime(Optional<BsonTimestamp> electionTime){
  this.electionTime=electionTime;
  return this;
}","public ReplSetHeartbeatReplyBuilder setElectionTime(Optional<BsonTimestamp> electionTime){
  this.electionTime=electionTime.orElse(null);
  return this;
}"
54408,"public ReplSetHeartbeatReplyBuilder setTime(@Nullable Duration time){
  this.time=Optional.ofNullable(time);
  return this;
}","public ReplSetHeartbeatReplyBuilder setTime(@Nullable Duration time){
  this.time=time;
  return this;
}"
54409,"public ReplSetHeartbeatReplyBuilder setAppliedOpTime(Optional<OpTime> appliedOpTime){
  this.appliedOpTime=appliedOpTime;
  return this;
}","public ReplSetHeartbeatReplyBuilder setAppliedOpTime(Optional<OpTime> appliedOpTime){
  this.appliedOpTime=appliedOpTime.orElse(null);
  return this;
}"
54410,"@Override public boolean reciveHeartbeatError(Throwable t){
  SupervisorDecision decision=replSupervisor.onError(this,t);
  return decision == SupervisorDecision.IGNORE;
}","@Override public boolean reciveHeartbeatError(Throwable t){
  return true;
}"
54411,"@Override public boolean sendHeartbeatError(Throwable t){
  SupervisorDecision decision=replSupervisor.onError(this,t);
  return decision == SupervisorDecision.IGNORE;
}","@Override public boolean sendHeartbeatError(Throwable t){
  return true;
}"
54412,"@Inject public MongoClientHeartbeatNetworkHandler(MongoClientFactory mongoClientFactory,ConcurrentToolsFactory concurrentToolsFactory){
  this.mongoClientFactory=mongoClientFactory;
  executorService=concurrentToolsFactory.createExecutorServiceWithMaxThreads(""String_Node_Str"",1);
}","@Inject public MongoClientHeartbeatNetworkHandler(MongoClientFactory mongoClientFactory,ConcurrentToolsFactory concurrentToolsFactory){
  this.mongoClientFactory=mongoClientFactory;
  executorService=concurrentToolsFactory.createExecutorService(""String_Node_Str"",true);
}"
54413,"@GuardedBy(""String_Node_Str"") private void doHeartbeat(final TopologyCoordinator coord,final HostAndPort target){
  if (stopped) {
    LOGGER.trace(""String_Node_Str"" + ""String_Node_Str"",target);
    return;
  }
  RemoteCommandRequest<ReplSetHeartbeatArgument> request=coord.prepareHeartbeatRequest(clock.instant(),replSetName,target);
  CompletableFuture<RemoteCommandResponse<ReplSetHeartbeatReply>> hbHandle=networkHandler.sendHeartbeat(request).whenComplete((response,t) -> {
    if (t != null) {
      onRequestError(t,target);
    }
  }
);
  CompletableFuture<?> executeResponseFuture=executor.onCurrentVersion().andThenAcceptAsync(hbHandle,(coord2,response) -> handleHeartbeatResponse(coord2,target,request.getCmdObj(),response));
  executeResponseFuture.exceptionally(t -> {
    Throwable cause=CompletionExceptions.getFirstNonCompletionException(t);
    if (cause instanceof CancellationException) {
      LOGGER.trace(""String_Node_Str"" + ""String_Node_Str"",target,cause.getMessage());
    }
 else {
      LOGGER.debug(""String_Node_Str"" + target,t);
      if (errorHandler.reciveHeartbeatError(t)) {
        LOGGER.trace(""String_Node_Str"",target,POST_ERROR_HB_DELAY);
        scheduleHeartbeatToTarget(target,POST_ERROR_HB_DELAY);
      }
 else {
        stopAsync();
      }
    }
    return null;
  }
);
}","@GuardedBy(""String_Node_Str"") private void doHeartbeat(final TopologyCoordinator coord,final HostAndPort target){
  if (stopped) {
    LOGGER.trace(""String_Node_Str"" + ""String_Node_Str"",target);
    return;
  }
  RemoteCommandRequest<ReplSetHeartbeatArgument> request=coord.prepareHeartbeatRequest(clock.instant(),replSetName,target);
  CompletableFuture<RemoteCommandResponse<ReplSetHeartbeatReply>> hbHandle=networkHandler.sendHeartbeat(request);
  CompletableFuture<?> executeResponseFuture=executor.onCurrentVersion().andThenAcceptAsync(hbHandle,(coord2,response) -> handleHeartbeatResponse(coord2,target,request.getCmdObj(),response));
  executeResponseFuture.exceptionally(t -> {
    onNetworkError(t,target);
    return null;
  }
);
}"
54414,"private boolean checkHeartbeatStarted(Status<?> status,Throwable t){
  if (t == null) {
    if (status.isOk()) {
      LOGGER.trace(""String_Node_Str"");
      return true;
    }
 else {
      LOGGER.debug(""String_Node_Str"",status);
switch (status.getErrorCode()) {
case NO_REPLICATION_ENABLED:
        LOGGER.warn(""String_Node_Str"" + ""String_Node_Str"",seed);
      break;
case INCONSISTENT_REPLICA_SET_NAMES:
default :
    LOGGER.warn(status.getErrorMsg());
  break;
}
return false;
}
}
 else {
Throwable usefulThrowable=CompletionExceptions.getFirstNonCompletionException(t);
if (usefulThrowable instanceof UncheckedException) {
usefulThrowable=usefulThrowable.getCause() != null ? usefulThrowable.getCause() : usefulThrowable;
}
LOGGER.warn(""String_Node_Str"" + seed + ""String_Node_Str""+ usefulThrowable.getLocalizedMessage(),usefulThrowable);
return false;
}
}","@GuardedBy(""String_Node_Str"") private boolean checkHeartbeatStarted(Status<?> status,Throwable t){
  if (t == null) {
    if (status.isOk()) {
      LOGGER.trace(""String_Node_Str"");
      return true;
    }
 else {
      LOGGER.debug(""String_Node_Str"",status);
switch (status.getErrorCode()) {
case NO_REPLICATION_ENABLED:
        LOGGER.warn(""String_Node_Str"" + ""String_Node_Str"",seed);
      break;
case INCONSISTENT_REPLICA_SET_NAMES:
default :
    LOGGER.warn(status.getErrorMsg());
  break;
}
return false;
}
}
 else {
Throwable usefulThrowable=CompletionExceptions.getFirstNonCompletionException(t);
if (usefulThrowable instanceof UncheckedException) {
usefulThrowable=usefulThrowable.getCause() != null ? usefulThrowable.getCause() : usefulThrowable;
}
LOGGER.warn(""String_Node_Str"" + seed + ""String_Node_Str""+ usefulThrowable.getLocalizedMessage(),usefulThrowable);
return false;
}
}"
54415,"private CompletableFuture<?> scheduleHeartbeatToTarget(final HostAndPort target,Duration delay){
  LOGGER.trace(""String_Node_Str"",target,delay);
  return executor.onCurrentVersion().scheduleOnce((coord) -> doHeartbeat(coord,target),delay);
}","@GuardedBy(""String_Node_Str"") private CompletableFuture<?> scheduleHeartbeatToTarget(final HostAndPort target,Duration delay){
  LOGGER.trace(""String_Node_Str"",target,delay);
  return executor.onCurrentVersion().scheduleOnce((coord) -> doHeartbeat(coord,target),delay);
}"
54416,"private void updateConfig(TopologyCoordinator coord,ReplicaSetConfig config){
  validateConfig(coord,config);
  coord.updateConfig(config,clock.instant());
}","@GuardedBy(""String_Node_Str"") private void updateConfig(TopologyCoordinator coord,ReplicaSetConfig config){
  validateConfig(coord,config);
  coord.updateConfig(config,clock.instant());
}"
54417,"@Setup(Level.Trial) public void startup(){
  if (torod == null) {
    Config config=new Config();
    config.getBackend().as(Postgres.class).setPassword(""String_Node_Str"");
    TestService testService=ToroDbStandaloneTestUtil.createInjectors(config,Clock.systemDefaultZone());
    torod=testService.getInjector().getInstance(TorodServer.class);
    torod.startAsync();
    torod.awaitRunning();
  }
}","@Setup(Level.Trial) public void startup(){
  if (torod == null) {
    Config config=new Config();
    config.getBackend().as(AbstractPostgres.class).setPassword(""String_Node_Str"");
    TestService testService=ToroDbStandaloneTestUtil.createInjectors(config,Clock.systemDefaultZone());
    torod=testService.getInjector().getInstance(TorodServer.class);
    torod.startAsync();
    torod.awaitRunning();
  }
}"
54418,"@Override public boolean isValid(Derby value,ConstraintValidatorContext context){
  if (value != null && value.getInMemory() != null && value.getEmbedded() != null) {
    return !value.getInMemory() || value.getEmbedded();
  }
  return true;
}","@Override public boolean isValid(AbstractDerby value,ConstraintValidatorContext context){
  if (value != null && value.getInMemory() != null && value.getEmbedded() != null) {
    return !value.getInMemory() || value.getEmbedded();
  }
  return true;
}"
54419,"@Override public boolean isValid(List<Replication> value,ConstraintValidatorContext context){
  if (value != null) {
    Set<String> replNameSet=new HashSet<>();
    for (    Replication replication : value) {
      if (!replNameSet.add(replication.getReplSetName())) {
        return false;
      }
    }
  }
  return true;
}","@Override public boolean isValid(List<AbstractReplication> value,ConstraintValidatorContext context){
  if (value != null) {
    Set<String> replNameSet=new HashSet<>();
    for (    AbstractReplication replication : value) {
      if (!replNameSet.add(replication.getReplSetName())) {
        return false;
      }
    }
  }
  return true;
}"
54420,"@Override public boolean isValid(List<Replication> value,ConstraintValidatorContext context){
  if (value != null) {
    for (    Replication replication : value) {
      if (replication.getAuth().getMode() == AuthMode.x509) {
        SSL ssl=replication.getSsl();
        if (!ssl.getEnabled() || ssl.getKeyStoreFile() == null || ssl.getKeyPassword() == null) {
          return false;
        }
      }
    }
  }
  return true;
}","@Override public boolean isValid(List<AbstractReplication> value,ConstraintValidatorContext context){
  if (value != null) {
    for (    AbstractReplication replication : value) {
      if (replication.getAuth().getMode() == AuthMode.x509) {
        SSL ssl=replication.getSsl();
        if (!ssl.getEnabled() || ssl.getKeyStoreFile() == null || ssl.getKeyPassword() == null) {
          return false;
        }
      }
    }
  }
  return true;
}"
54421,public void visit(Derby value);,public void visit(AbstractDerby value);
54422,"@Inject public DerbyBackendConfigurationMapper(CursorConfig cursorConfig,ConnectionPoolConfig connectionPoolConfig,Derby derby){
  super(cursorConfig.getCursorTimeout(),connectionPoolConfig.getConnectionPoolTimeout(),connectionPoolConfig.getConnectionPoolSize(),connectionPoolConfig.getReservedReadPoolSize(),derby.getHost(),derby.getPort(),derby.getDatabase(),derby.getUser(),derby.getPassword(),derby.getIncludeForeignKeys());
  this.embedded=derby.getEmbedded();
  this.inMemory=derby.getInMemory();
}","@Inject public DerbyBackendConfigurationMapper(CursorConfig cursorConfig,ConnectionPoolConfig connectionPoolConfig,AbstractDerby derby){
  super(cursorConfig.getCursorTimeout(),connectionPoolConfig.getConnectionPoolTimeout(),connectionPoolConfig.getConnectionPoolSize(),connectionPoolConfig.getReservedReadPoolSize(),derby.getHost(),derby.getPort(),derby.getDatabase(),derby.getUser(),derby.getPassword(),derby.getIncludeForeignKeys());
  this.embedded=derby.getEmbedded();
  this.inMemory=derby.getInMemory();
}"
54423,"public BackendDerbyImplementationModule(){
  super(Derby.class,DerbyDbBackendConfiguration.class,DerbyBackendConfigurationMapper.class,() -> new DerbyBackendModule());
}","public BackendDerbyImplementationModule(){
  super(AbstractDerby.class,DerbyDbBackendConfiguration.class,DerbyBackendConfigurationMapper.class,() -> new DerbyBackendModule());
}"
54424,"public BackendPostgresImplementationModule(){
  super(Postgres.class,PostgreSQLBackendConfiguration.class,PostgresSQLDbBackendConfigurationMapper.class,() -> new PostgreSQLBackendModule());
}","public BackendPostgresImplementationModule(){
  super(AbstractPostgres.class,PostgreSQLBackendConfiguration.class,PostgresSQLDbBackendConfigurationMapper.class,() -> new PostgreSQLBackendModule());
}"
54425,"@Inject public PostgresSQLDbBackendConfigurationMapper(CursorConfig cursorConfig,ConnectionPoolConfig connectionPoolConfig,Postgres postgres){
  super(cursorConfig.getCursorTimeout(),connectionPoolConfig.getConnectionPoolTimeout(),connectionPoolConfig.getConnectionPoolSize(),connectionPoolConfig.getReservedReadPoolSize(),postgres.getHost(),postgres.getPort(),postgres.getDatabase(),postgres.getUser(),postgres.getPassword(),postgres.getIncludeForeignKeys());
}","@Inject public PostgresSQLDbBackendConfigurationMapper(CursorConfig cursorConfig,ConnectionPoolConfig connectionPoolConfig,AbstractPostgres postgres){
  super(cursorConfig.getCursorTimeout(),connectionPoolConfig.getConnectionPoolTimeout(),connectionPoolConfig.getConnectionPoolSize(),connectionPoolConfig.getReservedReadPoolSize(),postgres.getHost(),postgres.getPort(),postgres.getDatabase(),postgres.getUser(),postgres.getPassword(),postgres.getIncludeForeignKeys());
}"
54426,"public static MongoClientConfiguration getMongoClientConfiguration(Replication replication){
  HostAndPort syncSource=HostAndPort.fromString(replication.getSyncSource()).withDefaultPort(27017);
  MongoClientConfiguration.Builder mongoClientConfigurationBuilder=new MongoClientConfiguration.Builder(syncSource);
  SSL ssl=replication.getSsl();
  mongoClientConfigurationBuilder.setSslEnabled(ssl.getEnabled());
  if (ssl.getEnabled()) {
    try {
      mongoClientConfigurationBuilder.setSslAllowInvalidHostnames(ssl.getAllowInvalidHostnames());
      TrustManager[] tms=getTrustManagers(ssl);
      KeyManager[] kms=getKeyManagers(ssl);
      SSLContext sslContext;
      if (ssl.getFipsMode()) {
        sslContext=SSLContext.getInstance(""String_Node_Str"",""String_Node_Str"");
      }
 else {
        sslContext=SSLContext.getInstance(""String_Node_Str"");
      }
      sslContext.init(kms,tms,null);
      mongoClientConfigurationBuilder.setSocketFactory(sslContext.getSocketFactory());
    }
 catch (    CertificateException|KeyManagementException|KeyStoreException|UnrecoverableKeyException|NoSuchProviderException|NoSuchAlgorithmException|IOException exception) {
      throw new SystemException(exception);
    }
  }
  Auth auth=replication.getAuth();
  if (auth.getMode().isEnabled()) {
    MongoAuthenticationConfiguration mongoAuthenticationConfiguration=getMongoAuthenticationConfiguration(auth,ssl);
    mongoClientConfigurationBuilder.addAuthenticationConfiguration(mongoAuthenticationConfiguration);
  }
  return mongoClientConfigurationBuilder.build();
}","public static MongoClientConfiguration getMongoClientConfiguration(AbstractReplication replication){
  HostAndPort syncSource=HostAndPort.fromString(replication.getSyncSource()).withDefaultPort(27017);
  MongoClientConfiguration.Builder mongoClientConfigurationBuilder=new MongoClientConfiguration.Builder(syncSource);
  SSL ssl=replication.getSsl();
  mongoClientConfigurationBuilder.setSslEnabled(ssl.getEnabled());
  if (ssl.getEnabled()) {
    try {
      mongoClientConfigurationBuilder.setSslAllowInvalidHostnames(ssl.getAllowInvalidHostnames());
      TrustManager[] tms=getTrustManagers(ssl);
      KeyManager[] kms=getKeyManagers(ssl);
      SSLContext sslContext;
      if (ssl.getFipsMode()) {
        sslContext=SSLContext.getInstance(""String_Node_Str"",""String_Node_Str"");
      }
 else {
        sslContext=SSLContext.getInstance(""String_Node_Str"");
      }
      sslContext.init(kms,tms,null);
      mongoClientConfigurationBuilder.setSocketFactory(sslContext.getSocketFactory());
    }
 catch (    CertificateException|KeyManagementException|KeyStoreException|UnrecoverableKeyException|NoSuchProviderException|NoSuchAlgorithmException|IOException exception) {
      throw new SystemException(exception);
    }
  }
  Auth auth=replication.getAuth();
  if (auth.getMode().isEnabled()) {
    MongoAuthenticationConfiguration mongoAuthenticationConfiguration=getMongoAuthenticationConfiguration(auth,ssl);
    mongoClientConfigurationBuilder.addAuthenticationConfiguration(mongoAuthenticationConfiguration);
  }
  return mongoClientConfigurationBuilder.build();
}"
54427,"public static ReplicationFilters getReplicationFilters(Replication replication){
  ReplicationFilters replicationFilters=new ReplicationFilters(convertFilterList(replication.getInclude()),convertFilterList(replication.getExclude()));
  return replicationFilters;
}","public static ReplicationFilters getReplicationFilters(AbstractReplication replication){
  ReplicationFilters replicationFilters=new ReplicationFilters(convertFilterList(replication.getInclude()),convertFilterList(replication.getExclude()));
  return replicationFilters;
}"
54428,"@Override protected void doStop(){
}","@Override protected void doStop(){
  notifyStopped();
}"
54429,"@Override protected void doStart(){
}","@Override protected void doStart(){
  notifyStarted();
}"
54430,"@Override protected void postDependenciesStartUp() throws Exception {
  LOGGER.info(""String_Node_Str"");
  mongodServer.startAsync();
  mongodServer.awaitRunning();
  topologyService.startAsync();
  oplogManager.startAsync();
  topologyService.awaitRunning();
  oplogManager.awaitRunning();
  dbCloner.startAsync();
  dbCloner.awaitRunning();
  replCoordinator.startAsync();
  replCoordinator.awaitRunning();
  LOGGER.info(""String_Node_Str"");
}","@Override protected void postDependenciesStartUp() throws Exception {
  LOGGER.info(""String_Node_Str"");
  mongodServer.startAsync();
  mongodServer.awaitRunning();
  topologyService.startAsync();
  oplogManager.startAsync();
  topologyService.awaitRunning();
  oplogManager.awaitRunning();
  dbCloner.startAsync();
  dbCloner.awaitRunning();
  aobe.startAsync();
  aobe.awaitRunning();
  replCoordinator.startAsync();
  replCoordinator.awaitRunning();
  LOGGER.info(""String_Node_Str"");
}"
54431,"@Override protected void preDependenciesShutDown() throws Exception {
  LOGGER.info(""String_Node_Str"");
  LOGGER.debug(""String_Node_Str"");
  try {
    replCoordinator.stopAsync();
    replCoordinator.awaitTerminated();
  }
 catch (  IllegalStateException ex) {
    Preconditions.checkState(!replCoordinator.isRunning(),""String_Node_Str"",replCoordinator);
  }
  dbCloner.stopAsync();
  dbCloner.awaitTerminated();
  oplogManager.stopAsync();
  topologyService.stopAsync();
  try {
    oplogManager.awaitTerminated();
  }
 catch (  IllegalStateException ex) {
    Preconditions.checkState(!oplogManager.isRunning(),""String_Node_Str"",replCoordinator);
  }
  try {
    topologyService.awaitTerminated();
  }
 catch (  IllegalStateException ex) {
    Preconditions.checkState(!topologyService.isRunning(),""String_Node_Str"",replCoordinator);
  }
  LOGGER.debug(""String_Node_Str"");
  mongodServer.stopAsync();
  LOGGER.debug(""String_Node_Str"");
  cachedMongoClientFactory.invalidateAll();
  LOGGER.debug(""String_Node_Str"");
  try {
    mongodServer.awaitTerminated();
  }
 catch (  IllegalStateException ex) {
    Preconditions.checkState(!mongodServer.isRunning(),""String_Node_Str"",replCoordinator);
  }
  LOGGER.info(""String_Node_Str"");
}","@Override protected void preDependenciesShutDown() throws Exception {
  LOGGER.info(""String_Node_Str"");
  LOGGER.debug(""String_Node_Str"");
  try {
    replCoordinator.stopAsync();
    replCoordinator.awaitTerminated();
  }
 catch (  IllegalStateException ex) {
    Preconditions.checkState(!replCoordinator.isRunning(),""String_Node_Str"",replCoordinator);
  }
  aobe.stopAsync();
  aobe.awaitTerminated();
  dbCloner.stopAsync();
  dbCloner.awaitTerminated();
  oplogManager.stopAsync();
  topologyService.stopAsync();
  try {
    oplogManager.awaitTerminated();
  }
 catch (  IllegalStateException ex) {
    Preconditions.checkState(!oplogManager.isRunning(),""String_Node_Str"",replCoordinator);
  }
  try {
    topologyService.awaitTerminated();
  }
 catch (  IllegalStateException ex) {
    Preconditions.checkState(!topologyService.isRunning(),""String_Node_Str"",replCoordinator);
  }
  LOGGER.debug(""String_Node_Str"");
  mongodServer.stopAsync();
  LOGGER.debug(""String_Node_Str"");
  cachedMongoClientFactory.invalidateAll();
  LOGGER.debug(""String_Node_Str"");
  try {
    mongodServer.awaitTerminated();
  }
 catch (  IllegalStateException ex) {
    Preconditions.checkState(!mongodServer.isRunning(),""String_Node_Str"",replCoordinator);
  }
  LOGGER.info(""String_Node_Str"");
}"
54432,"public MongodbReplBundle(TorodBundle torodBundle,Supervisor supervisor,MongodbReplConfig config,Injector injector){
  super(injector.getInstance(Key.get(ThreadFactory.class,TorodbIdleService.class)),supervisor);
  Supervisor replSupervisor=new ReplSupervisor(supervisor);
  Injector replInjector=injector.createChildInjector(new MongoDbReplModule(config,replSupervisor));
  this.torodBundle=torodBundle;
  this.topologyService=replInjector.getInstance(TopologyService.class);
  this.replCoordinator=replInjector.getInstance(ReplCoordinator.class);
  this.oplogManager=replInjector.getInstance(OplogManager.class);
  this.mongodServer=replInjector.getInstance(MongodServer.class);
  this.cachedMongoClientFactory=replInjector.getInstance(CachedMongoClientFactory.class);
  this.dbCloner=replInjector.getInstance(Key.get(DbCloner.class,MongoDbRepl.class));
}","public MongodbReplBundle(TorodBundle torodBundle,Supervisor supervisor,MongodbReplConfig config,Injector injector){
  super(injector.getInstance(Key.get(ThreadFactory.class,TorodbIdleService.class)),supervisor);
  Supervisor replSupervisor=new ReplSupervisor(supervisor);
  Injector replInjector=injector.createChildInjector(new MongoDbReplModule(config,replSupervisor));
  this.torodBundle=torodBundle;
  this.topologyService=replInjector.getInstance(TopologyService.class);
  this.replCoordinator=replInjector.getInstance(ReplCoordinator.class);
  this.oplogManager=replInjector.getInstance(OplogManager.class);
  this.mongodServer=replInjector.getInstance(MongodServer.class);
  this.cachedMongoClientFactory=replInjector.getInstance(CachedMongoClientFactory.class);
  this.dbCloner=replInjector.getInstance(Key.get(DbCloner.class,MongoDbRepl.class));
  this.aobe=replInjector.getInstance(AnalyzedOplogBatchExecutor.class);
}"
54433,"@Override protected void configure(){
  expose(TopologyService.class);
  expose(ReplCoordinator.class);
  expose(OplogManager.class);
  bind(ReplCoordinator.class).in(Singleton.class);
  bind(OplogManager.class).in(Singleton.class);
  bind(ReplCoordinatorStateMachine.class).in(Singleton.class);
  install(new MongoClientWrapperModule());
  expose(CachedMongoClientFactory.class);
  bind(OplogReaderProvider.class).to(MongoOplogReaderProvider.class).asEagerSingleton();
  install(new FactoryModuleBuilder().implement(OplogApplierService.class,DefaultOplogApplierService.class).build(OplogApplierService.OplogApplierServiceFactory.class));
  install(new FactoryModuleBuilder().implement(RecoveryService.class,RecoveryService.class).build(RecoveryService.RecoveryServiceFactory.class));
  install(new FactoryModuleBuilder().implement(ContinuousOplogFetcher.class,ContinuousOplogFetcher.class).build(ContinuousOplogFetcher.ContinuousOplogFetcherFactory.class));
  bind(DbCloner.class).annotatedWith(MongoDbRepl.class).toProvider(AkkaDbClonerProvider.class).in(Singleton.class);
  expose(Key.get(DbCloner.class,MongoDbRepl.class));
  bind(OplogApplier.class).to(DefaultOplogApplier.class).in(Singleton.class);
  bind(DefaultOplogApplier.BatchLimits.class).toInstance(new BatchLimits(1000,Duration.ofSeconds(2)));
  bind(CommitHeuristic.class).to(DefaultCommitHeuristic.class).in(Singleton.class);
  bind(Integer.class).annotatedWith(DocsPerTransaction.class).toInstance(1000);
  bind(ConcurrentOplogBatchExecutor.class).in(Singleton.class);
  bind(AnalyzedOplogBatchExecutor.class).to(ConcurrentOplogBatchExecutor.class);
  bind(ConcurrentOplogBatchExecutor.ConcurrentOplogBatchExecutorMetrics.class).in(Singleton.class);
  bind(AnalyzedOplogBatchExecutor.AnalyzedOplogBatchExecutorMetrics.class).to(ConcurrentOplogBatchExecutorMetrics.class);
  bind(ConcurrentOplogBatchExecutor.SubBatchHeuristic.class).toInstance((  ConcurrentOplogBatchExecutorMetrics metrics) -> 100);
  install(new FactoryModuleBuilder().implement(BatchAnalyzer.class,BatchAnalyzer.class).build(BatchAnalyzer.BatchAnalyzerFactory.class));
  bind(AnalyzedOpReducer.class).toInstance(new AnalyzedOpReducer(false));
  install(new TopologyGuiceModule());
  bind(MongodbReplConfig.class).toInstance(config);
  bind(ReplMetrics.class).in(Singleton.class);
  bind(OplogApplierMetrics.class).in(Singleton.class);
  bind(OplogOperationApplier.class).in(Singleton.class);
  bind(NamespaceJobExecutor.class).in(Singleton.class);
  install(new ReplCommandsGuiceModule());
  install(new MongoLayerModule(new ReplCommandImplementionsModule()));
  expose(MongodServer.class);
}","@Override protected void configure(){
  expose(TopologyService.class);
  expose(ReplCoordinator.class);
  expose(OplogManager.class);
  bind(ReplCoordinator.class).in(Singleton.class);
  bind(OplogManager.class).in(Singleton.class);
  bind(ReplCoordinatorStateMachine.class).in(Singleton.class);
  install(new MongoClientWrapperModule());
  expose(CachedMongoClientFactory.class);
  bind(OplogReaderProvider.class).to(MongoOplogReaderProvider.class).asEagerSingleton();
  install(new FactoryModuleBuilder().implement(OplogApplierService.class,DefaultOplogApplierService.class).build(OplogApplierService.OplogApplierServiceFactory.class));
  install(new FactoryModuleBuilder().implement(RecoveryService.class,RecoveryService.class).build(RecoveryService.RecoveryServiceFactory.class));
  install(new FactoryModuleBuilder().implement(ContinuousOplogFetcher.class,ContinuousOplogFetcher.class).build(ContinuousOplogFetcher.ContinuousOplogFetcherFactory.class));
  bind(DbCloner.class).annotatedWith(MongoDbRepl.class).toProvider(AkkaDbClonerProvider.class).in(Singleton.class);
  expose(Key.get(DbCloner.class,MongoDbRepl.class));
  bind(OplogApplier.class).to(DefaultOplogApplier.class).in(Singleton.class);
  bind(DefaultOplogApplier.BatchLimits.class).toInstance(new BatchLimits(1000,Duration.ofSeconds(2)));
  bind(CommitHeuristic.class).to(DefaultCommitHeuristic.class).in(Singleton.class);
  bind(Integer.class).annotatedWith(DocsPerTransaction.class).toInstance(1000);
  bind(ConcurrentOplogBatchExecutor.class).in(Singleton.class);
  bind(AnalyzedOplogBatchExecutor.class).to(ConcurrentOplogBatchExecutor.class);
  expose(AnalyzedOplogBatchExecutor.class);
  bind(ConcurrentOplogBatchExecutor.ConcurrentOplogBatchExecutorMetrics.class).in(Singleton.class);
  bind(AnalyzedOplogBatchExecutor.AnalyzedOplogBatchExecutorMetrics.class).to(ConcurrentOplogBatchExecutorMetrics.class);
  bind(ConcurrentOplogBatchExecutor.SubBatchHeuristic.class).toInstance((  ConcurrentOplogBatchExecutorMetrics metrics) -> 100);
  install(new FactoryModuleBuilder().implement(BatchAnalyzer.class,BatchAnalyzer.class).build(BatchAnalyzer.BatchAnalyzerFactory.class));
  bind(AnalyzedOpReducer.class).toInstance(new AnalyzedOpReducer(false));
  install(new TopologyGuiceModule());
  bind(MongodbReplConfig.class).toInstance(config);
  bind(ReplMetrics.class).in(Singleton.class);
  bind(OplogApplierMetrics.class).in(Singleton.class);
  bind(OplogOperationApplier.class).in(Singleton.class);
  bind(NamespaceJobExecutor.class).in(Singleton.class);
  install(new ReplCommandsGuiceModule());
  install(new MongoLayerModule(new ReplCommandImplementionsModule()));
  expose(MongodServer.class);
}"
54434,"public OplogOperation apply(AnalyzedOplogBatch batch,ApplierContext replContext) throws RetrierGiveUpException, RetrierAbortException {
  return batch.accept(this,replContext);
}","public default OplogOperation apply(AnalyzedOplogBatch batch,ApplierContext replContext) throws RetrierGiveUpException, RetrierAbortException {
  return batch.accept(this,replContext);
}"
54435,"private void execute(NamespaceJob job,ApplierContext applierContext,MongodConnection connection,boolean optimisticDeleteAndCreate) throws RollbackException, UserException, NamespaceJobExecutionException, UniqueIndexViolationException {
  try (WriteMongodTransaction mongoTransaction=connection.openWriteTransaction()){
    namespaceJobExecutor.apply(job,mongoTransaction,applierContext,optimisticDeleteAndCreate);
    mongoTransaction.commit();
  }
 }","public void execute(CudAnalyzedOplogBatch cudBatch,ApplierContext context) throws RollbackException, UserException, NamespaceJobExecutionException ;"
54436,"@Inject public ConcurrentOplogBatchExecutor(OplogOperationApplier oplogOperationApplier,MongodServer server,Retrier retrier,ConcurrentToolsFactory concurrentToolsFactory,NamespaceJobExecutor namespaceJobExecutor,ConcurrentOplogBatchExecutorMetrics concurrentMetrics,SubBatchHeuristic subBatchHeuristic){
  super(concurrentMetrics,oplogOperationApplier,server,retrier,namespaceJobExecutor);
  this.streamExecutor=concurrentToolsFactory.createStreamExecutor(""String_Node_Str"",true);
  this.streamExecutor.startAsync();
  this.streamExecutor.awaitRunning();
  this.concurrentMetrics=concurrentMetrics;
  this.subBatchHeuristic=subBatchHeuristic;
}","@Inject public ConcurrentOplogBatchExecutor(OplogOperationApplier oplogOperationApplier,MongodServer server,Retrier retrier,ConcurrentToolsFactory concurrentToolsFactory,NamespaceJobExecutor namespaceJobExecutor,ConcurrentOplogBatchExecutorMetrics concurrentMetrics,SubBatchHeuristic subBatchHeuristic){
  super(concurrentMetrics,oplogOperationApplier,server,retrier,namespaceJobExecutor);
  this.streamExecutor=concurrentToolsFactory.createStreamExecutor(""String_Node_Str"",true);
  this.concurrentMetrics=concurrentMetrics;
  this.subBatchHeuristic=subBatchHeuristic;
}"
54437,"public Class<T[]> getArrayType(){
  return dataType.getArrayType();
}","@Override public Class<T[]> getArrayType(){
  return dataType.getArrayType();
}"
54438,"public SQLDialect getDialect(){
  return dataType.getDialect();
}","@Override public SQLDialect getDialect(){
  return dataType.getDialect();
}"
54439,"public boolean nullable(){
  return dataType.nullable();
}","@Override public boolean nullable(){
  return dataType.nullable();
}"
54440,"public Field<T> defaultValue(){
  return dataType.defaultValue();
}","@Override public Field<T> defaultValue(){
  return dataType.defaultValue();
}"
54441,"public DataType<T> getDataType(Configuration configuration){
  return dataType.getDataType(configuration);
}","@Override public DataType<T> getDataType(Configuration configuration){
  return dataType.getDataType(configuration);
}"
54442,"public int precision(){
  return dataType.precision();
}","@Override public int precision(){
  return dataType.precision();
}"
54443,"public boolean isLob(){
  return dataType.isLob();
}","@Override public boolean isLob(){
  return dataType.isLob();
}"
54444,"public int scale(){
  return dataType.scale();
}","@Override public int scale(){
  return dataType.scale();
}"
54445,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public <E extends EnumType>DataType<E> asEnumDataType(Class<E> enumDataType){
  DataType<E> dataType=this.dataType.asEnumDataType(enumDataType);
  return new DataTypeForKV(dataType,kvValueConverter);
}","@Override @SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public <E extends EnumType>DataType<E> asEnumDataType(Class<E> enumDataType){
  DataType<E> dataType=this.dataType.asEnumDataType(enumDataType);
  return new DataTypeForKV(dataType,kvValueConverter);
}"
54446,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public <U>DataType<U> asConvertedDataType(Binding<? super T,U> binding){
  DataType dataType=this.dataType.asConvertedDataType(binding);
  return new DataTypeForKV(dataType,kvValueConverter);
}","@Override @SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public <U>DataType<U> asConvertedDataType(Binding<? super T,U> binding){
  DataType dataType=this.dataType.asConvertedDataType(binding);
  return new DataTypeForKV(dataType,kvValueConverter);
}"
54447,"public List<T> convert(Collection<?> objects){
  return dataType.convert(objects);
}","@Override public List<T> convert(Collection<?> objects){
  return dataType.convert(objects);
}"
54448,"public Binding<?,T> getBinding(){
  return dataType.getBinding();
}","@Override public Binding<?,T> getBinding(){
  return dataType.getBinding();
}"
54449,"public boolean defaulted(){
  return dataType.defaulted();
}","@Override public boolean defaulted(){
  return dataType.defaulted();
}"
54450,"public boolean isTemporal(){
  return dataType.isTemporal();
}","@Override public boolean isTemporal(){
  return dataType.isTemporal();
}"
54451,"public boolean isString(){
  return dataType.isString();
}","@Override public boolean isString(){
  return dataType.isString();
}"
54452,"public String getTypeName(Configuration configuration){
  return dataType.getTypeName(configuration);
}","@Override public String getTypeName(Configuration configuration){
  return dataType.getTypeName(configuration);
}"
54453,"public boolean hasLength(){
  return dataType.hasLength();
}","@Override public boolean hasLength(){
  return dataType.hasLength();
}"
54454,"public DataType<T> getSQLDataType(){
  return dataType.getSQLDataType();
}","@Override public DataType<T> getSQLDataType(){
  return dataType.getSQLDataType();
}"
54455,"public boolean hasScale(){
  return dataType.hasScale();
}","@Override public boolean hasScale(){
  return dataType.hasScale();
}"
54456,"public DataType<T[]> getArrayDataType(){
  return dataType.getArrayDataType();
}","@Override public DataType<T[]> getArrayDataType(){
  return dataType.getArrayDataType();
}"
54457,"public int length(){
  return dataType.length();
}","@Override public int length(){
  return dataType.length();
}"
54458,"public boolean isBinary(){
  return dataType.isBinary();
}","@Override public boolean isBinary(){
  return dataType.isBinary();
}"
54459,"public String getCastTypeName(Configuration configuration){
  return dataType.getCastTypeName(configuration);
}","@Override public String getCastTypeName(Configuration configuration){
  return dataType.getCastTypeName(configuration);
}"
54460,"public Class<T> getType(){
  return dataType.getType();
}","@Override public Class<T> getType(){
  return dataType.getType();
}"
54461,"public boolean isNumeric(){
  return dataType.isNumeric();
}","@Override public boolean isNumeric(){
  return dataType.isNumeric();
}"
54462,"public boolean isDateTime(){
  return dataType.isDateTime();
}","@Override public boolean isDateTime(){
  return dataType.isDateTime();
}"
54463,"public boolean hasPrecision(){
  return dataType.hasPrecision();
}","@Override public boolean hasPrecision(){
  return dataType.hasPrecision();
}"
54464,"public boolean isInterval(){
  return dataType.isInterval();
}","@Override public boolean isInterval(){
  return dataType.isInterval();
}"
54465,"public boolean isArray(){
  return dataType.isArray();
}","@Override public boolean isArray(){
  return dataType.isArray();
}"
54466,"public int getSQLType(){
  return sqlType;
}","@SuppressFBWarnings(value=""String_Node_Str"",justification=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"") @Override public int getSQLType(){
  return sqlType;
}"
54467,"public Converter<?,T> getConverter(){
  return dataType.getConverter();
}","@Override public Converter<?,T> getConverter(){
  return dataType.getConverter();
}"
54468,"public static <T>CompletableFuture<T> toCompletableFuture(final ListenableFuture<T> listenableFuture){
  CompletableFuture<T> completable=new CompletableFuture<T>(){
    @Override public boolean cancel(    boolean mayInterruptIfRunning){
      boolean result=listenableFuture.cancel(mayInterruptIfRunning);
      super.cancel(mayInterruptIfRunning);
      return result;
    }
  }
;
  Futures.addCallback(listenableFuture,new FutureCallback<T>(){
    @Override public void onSuccess(    T result){
      completable.complete(result);
    }
    @Override public void onFailure(    Throwable t){
      completable.completeExceptionally(t);
    }
  }
);
  return completable;
}","public static <T>CompletableFuture<T> toCompletableFuture(final ListenableFuture<T> listenableFuture){
  CompletableFuture<T> completable=new CompletableFuture<T>(){
    @Override public boolean cancel(    boolean mayInterruptIfRunning){
      boolean result=listenableFuture.cancel(mayInterruptIfRunning);
      super.cancel(mayInterruptIfRunning);
      return result;
    }
  }
;
  Futures.addCallback(listenableFuture,new FutureCallback<T>(){
    @Override @SuppressFBWarnings(""String_Node_Str"") public void onSuccess(    T result){
      completable.complete(result);
    }
    @Override public void onFailure(    Throwable t){
      completable.completeExceptionally(t);
    }
  }
);
  return completable;
}"
54469,"@Override public void onSuccess(T result){
  completable.complete(result);
}","@Override @SuppressFBWarnings(""String_Node_Str"") public void onSuccess(T result){
  completable.complete(result);
}"
54470,"protected void executeSupervisorDecision(SupervisorDecision decision){
  getLogger().debug(""String_Node_Str"",decision);
switch (decision) {
case STOP:
{
      this.stopAsync();
    }
}
}","protected void executeSupervisorDecision(SupervisorDecision decision){
  getLogger().debug(""String_Node_Str"",decision);
switch (decision) {
case STOP:
{
      this.stopAsync();
      break;
    }
case IGNORE:
default :
}
}"
54471,"public ReplSetHeartbeatReply getReply(){
  return reply;
}","@Nullable public ReplSetHeartbeatReply getReply(){
  return reply;
}"
54472,"@Override protected void startUp() throws Exception {
  boolean finished=false;
  LOGGER.debug(""String_Node_Str"");
  heartbeatHandler.startAsync();
  heartbeatHandler.awaitRunning();
  boolean topologyReady;
  int attempts=0;
  do {
    topologyReady=calculateTopologyReady();
    if (!topologyReady) {
      LOGGER.debug(""String_Node_Str"");
      Thread.sleep(1000);
    }
    attempts++;
  }
 while (!topologyReady || attempts >= 30);
  if (!topologyReady) {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + attempts + ""String_Node_Str"");
  }
  LOGGER.info(""String_Node_Str"");
}","@Override protected void startUp() throws Exception {
  LOGGER.debug(""String_Node_Str"");
  heartbeatHandler.startAsync();
  heartbeatHandler.awaitRunning();
  boolean topologyReady;
  int attempts=0;
  do {
    topologyReady=calculateTopologyReady();
    if (!topologyReady) {
      LOGGER.debug(""String_Node_Str"");
      Thread.sleep(1000);
    }
    attempts++;
  }
 while (!topologyReady && attempts < 30);
  if (!topologyReady) {
    throw new RuntimeException(""String_Node_Str"" + ""String_Node_Str"" + attempts + ""String_Node_Str"");
  }
  LOGGER.info(""String_Node_Str"");
}"
54473,"private void readCollectionObject(JsonParser jp,ObjectNode collection,Map<String,List<IndexFilter>> collections) throws JsonProcessingException, JsonMappingException {
  Iterator<Entry<String,JsonNode>> collectionEntriesIterator=collection.fields();
  while (collectionEntriesIterator.hasNext()) {
    List<IndexFilter> indexFilters=new ArrayList<>();
    Map.Entry<String,JsonNode> collectionEntry=collectionEntriesIterator.next();
    try {
      if (collectionEntry.getValue() instanceof ObjectNode) {
        readIndexFilter(jp,collectionEntry.getValue(),indexFilters);
      }
 else       if (collectionEntry.getValue() instanceof ArrayNode) {
        Iterator<JsonNode> indexFiltersIterator=collectionEntry.getValue().elements();
        int position=0;
        while (indexFiltersIterator.hasNext()) {
          try {
            JsonNode indexFilter=indexFiltersIterator.next();
            if (indexFilter instanceof ObjectNode) {
              readIndexFilter(jp,indexFilter,indexFilters);
            }
 else {
              throw new JsonMappingException(""String_Node_Str"",jp.getCurrentLocation());
            }
            position++;
          }
 catch (          Exception e) {
            throw JsonMappingException.wrapWithPath(e,indexFilters,position);
          }
        }
      }
      collections.put(collectionEntry.getKey(),indexFilters);
    }
 catch (    Exception e) {
      throw JsonMappingException.wrapWithPath(e,collections,collectionEntry.getKey());
    }
  }
}","@SuppressFBWarnings(""String_Node_Str"") private void readCollectionObject(JsonParser jp,ObjectNode collection,Map<String,List<IndexFilter>> collections) throws JsonProcessingException, JsonMappingException {
  Iterator<Entry<String,JsonNode>> collectionEntriesIterator=collection.fields();
  while (collectionEntriesIterator.hasNext()) {
    List<IndexFilter> indexFilters=new ArrayList<>();
    Map.Entry<String,JsonNode> collectionEntry=collectionEntriesIterator.next();
    try {
      if (collectionEntry.getValue() instanceof ObjectNode) {
        readIndexFilter(jp,collectionEntry.getValue(),indexFilters);
      }
 else       if (collectionEntry.getValue() instanceof ArrayNode) {
        Iterator<JsonNode> indexFiltersIterator=collectionEntry.getValue().elements();
        int position=0;
        while (indexFiltersIterator.hasNext()) {
          try {
            JsonNode indexFilter=indexFiltersIterator.next();
            if (indexFilter instanceof ObjectNode) {
              readIndexFilter(jp,indexFilter,indexFilters);
            }
 else {
              throw new JsonMappingException(""String_Node_Str"",jp.getCurrentLocation());
            }
            position++;
          }
 catch (          Exception e) {
            throw JsonMappingException.wrapWithPath(e,indexFilters,position);
          }
        }
      }
      collections.put(collectionEntry.getKey(),indexFilters);
    }
 catch (    Exception e) {
      throw JsonMappingException.wrapWithPath(e,collections,collectionEntry.getKey());
    }
  }
}"
54474,"@Override public FilterList deserialize(JsonParser jp,DeserializationContext ctxt) throws IOException, JsonProcessingException {
  FilterList filterList=new FilterList();
  JsonNode node=jp.getCodec().readTree(jp);
  if (node instanceof ObjectNode) {
    Iterator<Entry<String,JsonNode>> databaseEntriesIterator=node.fields();
    while (databaseEntriesIterator.hasNext()) {
      Entry<String,JsonNode> databaseEntry=databaseEntriesIterator.next();
      try {
        Map<String,List<IndexFilter>> collections=new HashMap<>();
        if (databaseEntry.getValue() instanceof ObjectNode) {
          readCollectionObject(jp,(ObjectNode)databaseEntry.getValue(),collections);
        }
 else         if (databaseEntry.getValue() instanceof ArrayNode) {
          ArrayNode collectionsArray=(ArrayNode)databaseEntry.getValue();
          Iterator<JsonNode> collectionsIterator=collectionsArray.elements();
          int position=0;
          while (collectionsIterator.hasNext()) {
            try {
              JsonNode collection=collectionsIterator.next();
              if (collection instanceof ObjectNode) {
                readCollectionObject(jp,(ObjectNode)collection,collections);
              }
 else               if (collection instanceof ArrayNode) {
                throw new JsonMappingException(""String_Node_Str"",jp.getCurrentLocation());
              }
 else {
                collections.put(collection.asText(),new ArrayList<>());
              }
              position++;
            }
 catch (            Exception e) {
              throw JsonMappingException.wrapWithPath(e,collections,position);
            }
          }
        }
        filterList.put(databaseEntry.getKey(),collections);
      }
 catch (      Exception e) {
        throw JsonMappingException.wrapWithPath(e,filterList,databaseEntry.getKey());
      }
    }
  }
 else {
    throw new JsonMappingException(""String_Node_Str"",jp.getCurrentLocation());
  }
  return filterList;
}","@Override @SuppressFBWarnings(""String_Node_Str"") public FilterList deserialize(JsonParser jp,DeserializationContext ctxt) throws IOException, JsonProcessingException {
  FilterList filterList=new FilterList();
  JsonNode node=jp.getCodec().readTree(jp);
  if (node instanceof ObjectNode) {
    Iterator<Entry<String,JsonNode>> databaseEntriesIterator=node.fields();
    while (databaseEntriesIterator.hasNext()) {
      Entry<String,JsonNode> databaseEntry=databaseEntriesIterator.next();
      try {
        Map<String,List<IndexFilter>> collections=new HashMap<>();
        if (databaseEntry.getValue() instanceof ObjectNode) {
          readCollectionObject(jp,(ObjectNode)databaseEntry.getValue(),collections);
        }
 else         if (databaseEntry.getValue() instanceof ArrayNode) {
          ArrayNode collectionsArray=(ArrayNode)databaseEntry.getValue();
          Iterator<JsonNode> collectionsIterator=collectionsArray.elements();
          int position=0;
          while (collectionsIterator.hasNext()) {
            try {
              JsonNode collection=collectionsIterator.next();
              if (collection instanceof ObjectNode) {
                readCollectionObject(jp,(ObjectNode)collection,collections);
              }
 else               if (collection instanceof ArrayNode) {
                throw new JsonMappingException(""String_Node_Str"",jp.getCurrentLocation());
              }
 else {
                collections.put(collection.asText(),new ArrayList<>());
              }
              position++;
            }
 catch (            Exception e) {
              throw JsonMappingException.wrapWithPath(e,collections,position);
            }
          }
        }
        filterList.put(databaseEntry.getKey(),collections);
      }
 catch (      Exception e) {
        throw JsonMappingException.wrapWithPath(e,filterList,databaseEntry.getKey());
      }
    }
  }
 else {
    throw new JsonMappingException(""String_Node_Str"",jp.getCurrentLocation());
  }
  return filterList;
}"
54475,"protected List<Tuple2<MetaIndex,List<String>>> getMissingIndexesForNewField(Stream<? extends MetaIndex> containedMetaIndexes,MutableMetaDocPart docPart,MetaField newField){
  return containedMetaIndexes.filter(index -> index.getMetaIndexFieldByTableRefAndName(docPart.getTableRef(),newField.getName()) != null).flatMap(index -> Seq.seq(index.iteratorMetaDocPartIndexesIdentifiers(docPart)).filter(identifiers -> identifiers.contains(newField.getIdentifier())).map(identifiers -> new Tuple2<MetaIndex,List<String>>(index,identifiers))).collect(Collectors.toList());
}","protected List<Tuple2<MetaIndex,List<String>>> getMissingIndexesForNewField(Stream<? extends MetaIndex> containedMetaIndexes,MutableMetaDocPart docPart,MetaField newField){
  return containedMetaIndexes.filter(index -> index.getMetaIndexFieldByTableRefAndName(docPart.getTableRef(),newField.getName()) != null).flatMap(index -> Seq.seq(index.iteratorMetaDocPartIndexesIdentifiers(docPart)).filter(identifiers -> identifiers.contains(newField.getIdentifier())).map(identifiers -> new Tuple2<MetaIndex,List<String>>(index,identifiers))).collect(Collectors.groupingBy(missingIndexEntry -> missingIndexEntry.v2())).entrySet().stream().map(groupedMissingIndexEntries -> groupedMissingIndexEntries.getValue().get(0)).collect(Collectors.toList());
}"
54476,"/** 
 * @param newMillisFunction the first argument is the millis that it has wait on the lastiteration (or 0 for the first) and the second the attempts. The result is the number of millis that will wait or a negative number if it should give up.
 * @param delegate          the exception handler on which delegate when giving up.
 */
public IncrementalWaitExceptionHandler(IntBinaryOperator newMillisFunction,ExceptionHandler<Result,T> delegate){
  super(delegate);
  this.newMillisFunction=newMillisFunction;
  this.currentMillis=0;
}","/** 
 * @param newMillisFunction the first argument is the millis that it has wait on the lastiteration (or 0 for the first) and the second the attempts. The result is the number of millis that will wait or a negative number if it should give up.
 * @param delegate          the exception handler on which delegate when giving up.
 */
public IncrementalWaitExceptionHandler(IntBinaryOperator newMillisFunction,ExceptionHandler<Result,T> delegate){
  super(delegate);
  this.newMillisFunction=newMillisFunction;
  this.currentMillis=1;
}"
54477,"@Override protected void configure(){
  bind(TableRefFactory.class).to(TableRefFactoryImpl.class).asEagerSingleton();
  int maxCriticalAttempts=100;
  int maxInfrequentAttempts=5;
  int maxFrequentAttempts=100;
  int maxDefaultAttempts=10;
  bind(Retrier.class).toInstance(new SmartRetrier(attempts -> attempts >= maxCriticalAttempts,attempts -> attempts >= maxInfrequentAttempts,attempts -> attempts >= maxFrequentAttempts,attempts -> attempts >= maxDefaultAttempts));
}","@Override protected void configure(){
  bind(TableRefFactory.class).to(TableRefFactoryImpl.class).asEagerSingleton();
  int maxCriticalAttempts=100;
  int maxInfrequentAttempts=5;
  int maxFrequentAttempts=100;
  int maxDefaultAttempts=10;
  bind(Retrier.class).toInstance(new SmartRetrier(attempts -> attempts >= maxCriticalAttempts,attempts -> attempts >= maxInfrequentAttempts,attempts -> attempts >= maxFrequentAttempts,attempts -> attempts >= maxDefaultAttempts,CoreModule::millisToWait));
}"
54478,"public SmartRetrier(IntPredicate criticalGiveUpPredicate,IntPredicate infrequentGiveUpPredicate,IntPredicate frequentGiveUpPredicate,IntPredicate defaultGiveUpPredicate){
  this.infrequentGiveUpPredicate=infrequentGiveUpPredicate;
  this.frequentGiveUpPredicate=frequentGiveUpPredicate;
  this.defaultGiveUpPredicate=defaultGiveUpPredicate;
  this.criticalGiveUpPredicate=criticalGiveUpPredicate;
}","public SmartRetrier(IntPredicate criticalGiveUpPredicate,IntPredicate infrequentGiveUpPredicate,IntPredicate frequentGiveUpPredicate,IntPredicate defaultGiveUpPredicate,MillisToWaitFunction millisToWaitFunction){
  this.infrequentGiveUpPredicate=infrequentGiveUpPredicate;
  this.frequentGiveUpPredicate=frequentGiveUpPredicate;
  this.defaultGiveUpPredicate=defaultGiveUpPredicate;
  this.criticalGiveUpPredicate=criticalGiveUpPredicate;
  this.millisToWaitFunction=millisToWaitFunction;
}"
54479,"private <Result,T extends Exception>ExceptionHandler<Result,T> createWithTimeHandler(IntPredicate giveUpPredicate,ExceptionHandler<Result,T> delegateHandler){
  return new IncrementalWaitExceptionHandler<>((attepts,millis) -> getMillisToWait(attepts,millis,giveUpPredicate),delegateHandler);
}","private <Result,T extends Exception>ExceptionHandler<Result,T> createWithTimeHandler(IntPredicate giveUpPredicate,ExceptionHandler<Result,T> delegateHandler){
  return new IncrementalWaitExceptionHandler<>((millis,attempts) -> getMillisToWait(attempts,millis,giveUpPredicate),delegateHandler);
}"
54480,"private void cloneCollection(MongodServer localServer,MongoConnection remoteConnection,String toDb,CloneOptions opts,Materializer materializer,Entry collToClone) throws MongoException {
  String collName=collToClone.getCollectionName();
  MongoCursor<BsonDocument> cursor=openCursor(remoteConnection,collName,opts);
  CollectionIterator iterator=new CollectionIterator(cursor,retrier);
  Source<BsonDocument,NotUsed> source=Source.fromIterator(() -> iterator).buffer(cursorBatchBufferSize,OverflowStrategy.backpressure()).async();
  Flow<BsonDocument,Pair<Integer,Integer>,NotUsed> inserterFlow;
  if (maxParallelInsertTasks == 1) {
    inserterFlow=createCloneDocsWorker(localServer,toDb,collName);
  }
 else {
    Graph<FlowShape<BsonDocument,Pair<Integer,Integer>>,NotUsed> graph=GraphDSL.create(builder -> {
      UniformFanOutShape<BsonDocument,BsonDocument> balance=builder.add(Balance.create(maxParallelInsertTasks,false));
      UniformFanInShape<Pair<Integer,Integer>,Pair<Integer,Integer>> merge=builder.add(Merge.create(maxParallelInsertTasks,false));
      for (int i=0; i < maxParallelInsertTasks; i++) {
        builder.from(balance.out(i)).via(builder.add(createCloneDocsWorker(localServer,toDb,collName).async())).toInlet(merge.in(i));
      }
      return FlowShape.of(balance.in(),merge.out());
    }
);
    inserterFlow=Flow.fromGraph(graph);
  }
  try {
    retrier.retry(() -> {
      try {
        Pair<Integer,Integer> insertedDocs=source.via(inserterFlow).toMat(Sink.fold(new Pair<>(0,0),(        Pair<Integer,Integer> acum,        Pair<Integer,Integer> newBatch) -> new Pair<>(acum.first() + newBatch.first(),acum.second() + newBatch.second())),Keep.right()).run(materializer).toCompletableFuture().join();
        LOGGER.debug(""String_Node_Str"",insertedDocs.second(),insertedDocs.first());
        return Done.getInstance();
      }
 catch (      CompletionException ex) {
        Throwable cause=ex.getCause();
        if (cause != null && cause instanceof RollbackException) {
          throw (RollbackException)cause;
        }
        throw ex;
      }
    }
,Hint.TIME_SENSIBLE,Hint.INFREQUENT_ROLLBACK);
  }
 catch (  RetrierGiveUpException ex) {
    throw new CloningException(ex);
  }
}","private void cloneCollection(MongodServer localServer,MongoConnection remoteConnection,String toDb,CloneOptions opts,Materializer materializer,Entry collToClone) throws MongoException {
  String collName=collToClone.getCollectionName();
  MongoCursor<BsonDocument> cursor=openCursor(remoteConnection,collName,opts);
  CollectionIterator iterator=new CollectionIterator(cursor,retrier);
  Source<BsonDocument,NotUsed> source=Source.fromIterator(() -> iterator).buffer(cursorBatchBufferSize,OverflowStrategy.backpressure()).async();
  Flow<BsonDocument,Pair<Integer,Integer>,NotUsed> inserterFlow;
  if (maxParallelInsertTasks == 1) {
    inserterFlow=createCloneDocsWorker(localServer,toDb,collName);
  }
 else {
    Graph<FlowShape<BsonDocument,Pair<Integer,Integer>>,NotUsed> graph=GraphDSL.create(builder -> {
      UniformFanOutShape<BsonDocument,BsonDocument> balance=builder.add(Balance.create(maxParallelInsertTasks,false));
      UniformFanInShape<Pair<Integer,Integer>,Pair<Integer,Integer>> merge=builder.add(Merge.create(maxParallelInsertTasks,false));
      for (int i=0; i < maxParallelInsertTasks; i++) {
        builder.from(balance.out(i)).via(builder.add(createCloneDocsWorker(localServer,toDb,collName).async())).toInlet(merge.in(i));
      }
      return FlowShape.of(balance.in(),merge.out());
    }
);
    inserterFlow=Flow.fromGraph(graph);
  }
  try {
    source.via(inserterFlow).fold(new Tuple3<>(0,0,clock.instant()),(acum,batch) -> postInsertFold(toDb,collName,acum,batch)).toMat(Sink.foreach(tuple -> logCollectionCloning(toDb,collName,tuple.t1(),tuple.t2())),Keep.right()).run(materializer).toCompletableFuture().join();
  }
 catch (  CompletionException ex) {
    Throwable cause=ex.getCause();
    if (cause != null) {
      throw new CloningException(""String_Node_Str"" + toDb + ""String_Node_Str""+ collName,cause);
    }
    throw ex;
  }
}"
54481,"private Flow<BsonDocument,Pair<Integer,Integer>,NotUsed> createCloneDocsWorker(MongodServer localServer,String toDb,String collection){
  return Flow.of(BsonDocument.class).grouped(insertBufferSize).map(docs -> {
    return new Pair<>(insertDocuments(localServer,toDb,collection,docs),docs.size());
  }
);
}","private Flow<BsonDocument,Pair<Integer,Integer>,NotUsed> createCloneDocsWorker(MongodServer localServer,String toDb,String collection){
  return Flow.of(BsonDocument.class).grouped(commitHeuristic.getDocumentsPerCommit()).map(docs -> retrier.retry(() -> new Tuple3<>(clock.instant(),insertDocuments(localServer,toDb,collection,docs),docs.size()),Hint.FREQUENT_ROLLBACK,Hint.TIME_SENSIBLE)).map(tuple -> {
    commitHeuristic.notifyDocumentInsertionCommit(tuple.t2(),clock.millis() - tuple.t1().toEpochMilli());
    return new Pair<>(tuple.t2(),tuple.t3());
  }
);
}"
54482,"private int insertDocuments(MongodServer localServer,String toDb,String collection,List<BsonDocument> docsToInsert){
}","private int insertDocuments(MongodServer localServer,String toDb,String collection,List<BsonDocument> docsToInsert) throws RollbackException {
  try (WriteMongodTransaction transaction=createWriteMongodTransaction(localServer)){
    Status<InsertResult> insertResult=transaction.execute(new Request(toDb,null,true,null),InsertCommand.INSTANCE,new InsertArgument.Builder(collection).addDocuments(docsToInsert).setWriteConcern(WriteConcern.fsync()).setOrdered(true).build());
    if (!insertResult.isOk()) {
      throw new CloningException(""String_Node_Str"");
    }
    int insertedDocs=insertResult.getResult().getN();
    if (insertedDocs != docsToInsert.size()) {
      throw new CloningException(""String_Node_Str"" + docsToInsert.size() + ""String_Node_Str""+ insertResult+ ""String_Node_Str"");
    }
    transaction.commit();
    return insertedDocs;
  }
 catch (  UserException ex) {
    throw new CloningException(""String_Node_Str"",ex);
  }
}"
54483,"private boolean initialSync() throws TryAgainException, FatalErrorException {
  LOGGER.info(""String_Node_Str"");
  callback.setConsistentState(false);
  HostAndPort syncSource;
  try {
    syncSource=syncSourceProvider.newSyncSource();
    LOGGER.info(""String_Node_Str"" + syncSource + ""String_Node_Str"");
  }
 catch (  NoSyncSourceFoundException ex) {
    throw new TryAgainException(""String_Node_Str"");
  }
  MongoClient remoteClient;
  try {
    remoteClient=remoteClientFactory.createClient(syncSource);
  }
 catch (  UnreachableMongoServerException ex) {
    throw new TryAgainException(ex);
  }
  try {
    LOGGER.debug(""String_Node_Str"");
    MongoConnection remoteConnection=remoteClient.openConnection();
    try {
      OplogReader reader=oplogReaderProvider.newReader(remoteConnection);
      OplogOperation lastClonedOp=reader.getLastOp();
      OpTime lastRemoteOptime1=lastClonedOp.getOpTime();
      try (WriteOplogTransaction oplogTransaction=oplogManager.createWriteTransaction()){
        LOGGER.info(""String_Node_Str"");
        oplogTransaction.truncate();
        LOGGER.info(""String_Node_Str"");
        Status<?> status=dropDatabases();
        if (!status.isOk()) {
          throw new TryAgainException(""String_Node_Str"" + status);
        }
        LOGGER.info(""String_Node_Str"");
        if (!isRunning()) {
          LOGGER.warn(""String_Node_Str"");
          return false;
        }
        LOGGER.info(""String_Node_Str"");
        cloneDatabases(remoteClient);
        LOGGER.info(""String_Node_Str"");
        oplogTransaction.forceNewValue(lastClonedOp.getHash(),lastClonedOp.getOpTime());
      }
       if (!isRunning()) {
        LOGGER.warn(""String_Node_Str"");
        return false;
      }
      try (MongodConnection connection=server.openConnection();WriteMongodTransaction trans=connection.openWriteTransaction()){
        OpTime lastRemoteOptime2=reader.getLastOp().getOpTime();
        LOGGER.info(""String_Node_Str"");
        applyOplog(trans,reader,lastRemoteOptime1,lastRemoteOptime2);
        trans.commit();
        LOGGER.info(""String_Node_Str"");
        if (!isRunning()) {
          LOGGER.warn(""String_Node_Str"");
          return false;
        }
        OplogOperation lastOperation=reader.getLastOp();
        OpTime lastRemoteOptime3=lastOperation.getOpTime();
        LOGGER.info(""String_Node_Str"");
        applyOplog(trans,reader,lastRemoteOptime2,lastRemoteOptime3);
        trans.commit();
        LOGGER.info(""String_Node_Str"");
        if (!isRunning()) {
          LOGGER.warn(""String_Node_Str"");
          return false;
        }
        LOGGER.info(""String_Node_Str"");
        rebuildIndexes();
        trans.commit();
        LOGGER.info(""String_Node_Str"");
        if (!isRunning()) {
          LOGGER.warn(""String_Node_Str"");
          return false;
        }
        trans.commit();
      }
     }
 catch (    OplogStartMissingException ex) {
      throw new TryAgainException(ex);
    }
catch (    OplogOperationUnsupported ex) {
      throw new TryAgainException(ex);
    }
catch (    MongoException|RollbackException ex) {
      throw new TryAgainException(ex);
    }
catch (    OplogManagerPersistException ex) {
      throw new FatalErrorException();
    }
catch (    UserException ex) {
      throw new FatalErrorException(ex);
    }
    callback.setConsistentState(true);
    LOGGER.info(""String_Node_Str"");
  }
  finally {
    remoteClient.close();
  }
  return true;
}","private boolean initialSync() throws TryAgainException, FatalErrorException {
  LOGGER.info(""String_Node_Str"");
  callback.setConsistentState(false);
  HostAndPort syncSource;
  try {
    syncSource=syncSourceProvider.newSyncSource();
    LOGGER.info(""String_Node_Str"" + syncSource + ""String_Node_Str"");
  }
 catch (  NoSyncSourceFoundException ex) {
    throw new TryAgainException(""String_Node_Str"");
  }
  MongoClient remoteClient;
  try {
    remoteClient=remoteClientFactory.createClient(syncSource);
  }
 catch (  UnreachableMongoServerException ex) {
    throw new TryAgainException(ex);
  }
  try {
    LOGGER.debug(""String_Node_Str"");
    MongoConnection remoteConnection=remoteClient.openConnection();
    try (OplogReader reader=oplogReaderProvider.newReader(remoteConnection)){
      OplogOperation lastClonedOp=reader.getLastOp();
      OpTime lastRemoteOptime1=lastClonedOp.getOpTime();
      try (WriteOplogTransaction oplogTransaction=oplogManager.createWriteTransaction()){
        LOGGER.info(""String_Node_Str"");
        oplogTransaction.truncate();
        LOGGER.info(""String_Node_Str"");
        Status<?> status=dropDatabases();
        if (!status.isOk()) {
          throw new TryAgainException(""String_Node_Str"" + status);
        }
        LOGGER.info(""String_Node_Str"");
        if (!isRunning()) {
          LOGGER.warn(""String_Node_Str"");
          return false;
        }
        LOGGER.info(""String_Node_Str"");
        cloneDatabases(remoteClient);
        LOGGER.info(""String_Node_Str"");
        oplogTransaction.forceNewValue(lastClonedOp.getHash(),lastClonedOp.getOpTime());
      }
       if (!isRunning()) {
        LOGGER.warn(""String_Node_Str"");
        return false;
      }
      try (MongodConnection connection=server.openConnection();WriteMongodTransaction trans=connection.openWriteTransaction()){
        OpTime lastRemoteOptime2=reader.getLastOp().getOpTime();
        LOGGER.info(""String_Node_Str"");
        applyOplog(trans,reader,lastRemoteOptime1,lastRemoteOptime2);
        trans.commit();
        LOGGER.info(""String_Node_Str"");
        if (!isRunning()) {
          LOGGER.warn(""String_Node_Str"");
          return false;
        }
        OplogOperation lastOperation=reader.getLastOp();
        OpTime lastRemoteOptime3=lastOperation.getOpTime();
        LOGGER.info(""String_Node_Str"");
        applyOplog(trans,reader,lastRemoteOptime2,lastRemoteOptime3);
        trans.commit();
        LOGGER.info(""String_Node_Str"");
        if (!isRunning()) {
          LOGGER.warn(""String_Node_Str"");
          return false;
        }
        LOGGER.info(""String_Node_Str"");
        rebuildIndexes();
        trans.commit();
        LOGGER.info(""String_Node_Str"");
        if (!isRunning()) {
          LOGGER.warn(""String_Node_Str"");
          return false;
        }
        trans.commit();
      }
     }
 catch (    OplogStartMissingException ex) {
      throw new TryAgainException(ex);
    }
catch (    OplogOperationUnsupported ex) {
      throw new TryAgainException(ex);
    }
catch (    MongoException|RollbackException ex) {
      throw new TryAgainException(ex);
    }
catch (    OplogManagerPersistException ex) {
      throw new FatalErrorException();
    }
catch (    UserException ex) {
      throw new FatalErrorException(ex);
    }
    callback.setConsistentState(true);
    LOGGER.info(""String_Node_Str"");
  }
  finally {
    remoteClient.close();
  }
  return true;
}"
54484,"@Override public ExecutorService createExecutorService(String prefix,boolean blockerTasks,int maxThreads){
  ExecutorService executorService;
  if (blockerTasks) {
    ThreadFactory threadFactory=blockerThreadFactoryFunction.apply(prefix);
    ThreadPoolExecutor threadPoolExecutor=new ThreadPoolExecutor(maxThreads,maxThreads,10L,TimeUnit.MINUTES,new LinkedBlockingQueue<>(),threadFactory);
    threadPoolExecutor.allowCoreThreadTimeOut(true);
    executorService=threadPoolExecutor;
  }
 else {
    ForkJoinWorkerThreadFactory threadFactory=forkJoinThreadFactoryFunction.apply(prefix);
    executorService=new ForkJoinPool(maxThreads,threadFactory,null,true);
  }
  shutdownHelper.terminateOnShutdown(executorService);
  return executorService;
}","@Override @SuppressFBWarnings(value={""String_Node_Str""},justification=""String_Node_Str"") public ExecutorService createExecutorService(String prefix,boolean blockerTasks,int maxThreads){
  ExecutorService executorService;
  if (blockerTasks) {
    ThreadFactory threadFactory=blockerThreadFactoryFunction.apply(prefix);
    ThreadPoolExecutor threadPoolExecutor=new ThreadPoolExecutor(maxThreads,maxThreads,10L,TimeUnit.MINUTES,new LinkedBlockingQueue<>(),threadFactory);
    threadPoolExecutor.allowCoreThreadTimeOut(true);
    executorService=threadPoolExecutor;
  }
 else {
    ForkJoinWorkerThreadFactory threadFactory=forkJoinThreadFactoryFunction.apply(prefix);
    executorService=new ForkJoinPool(maxThreads,threadFactory,null,true);
  }
  shutdownHelper.terminateOnShutdown(executorService);
  return executorService;
}"
54485,"public void setMemberState(MemberState memberState){
  this.memberState=memberState;
  if (memberState != null) {
    metrics.getMemberState().setValue(memberState.name());
    metrics.getMemberStateCounters()[memberState.ordinal()].inc();
  }
 else {
    metrics.getMemberState().setValue(null);
  }
}","public void setMemberState(MemberState memberState){
  this.memberState=memberState;
  if (memberState != null) {
    metrics.getMemberState().setValue(memberState.name());
    metrics.getMemberStateCounters().get(memberState).inc();
  }
 else {
    metrics.getMemberState().setValue(null);
  }
}"
54486,"public Counter[] getMemberStateCounters(){
  return memberStateCounters;
}","public ImmutableMap<MemberState,Counter> getMemberStateCounters(){
  return memberStateCounters;
}"
54487,"@Inject public ReplMetrics(ToroMetricRegistry registry){
  memberState=registry.gauge(factory.createMetricName(""String_Node_Str""));
  memberStateCounters=new Counter[MemberState.values().length];
  for (  MemberState memberState : MemberState.values()) {
    memberStateCounters[memberState.ordinal()]=registry.counter(factory.createMetricName(memberState.name().substring(3).toLowerCase(Locale.US) + ""String_Node_Str""));
  }
  lastOpTimeFetched=registry.gauge(factory.createMetricName(""String_Node_Str""));
  lastOpTimeApplied=registry.gauge(factory.createMetricName(""String_Node_Str""));
}","@Inject public ReplMetrics(ToroMetricRegistry registry){
  memberState=registry.gauge(factory.createMetricName(""String_Node_Str""));
  ImmutableMap.Builder<MemberState,Counter> memberStateCountersBuilder=ImmutableMap.builder();
  for (  MemberState memberState : MemberState.values()) {
    memberStateCountersBuilder.put(memberState,registry.counter(factory.createMetricName(memberState.name().substring(3).toLowerCase(Locale.US) + ""String_Node_Str"")));
  }
  memberStateCounters=Maps.immutableEnumMap(memberStateCountersBuilder.build());
  lastOpTimeFetched=registry.gauge(factory.createMetricName(""String_Node_Str""));
  lastOpTimeApplied=registry.gauge(factory.createMetricName(""String_Node_Str""));
}"
54488,"@Override public void awaitUntilUnpaused() throws InterruptedException {
  mutex.lock();
  try {
    fetcherIsPaused=true;
    fetcherPausedCond.signalAll();
    fetcherCanContinueCond.await();
  }
  finally {
    mutex.unlock();
  }
}","@Override @SuppressFBWarnings(value={""String_Node_Str""},justification=""String_Node_Str"") public void awaitUntilUnpaused() throws InterruptedException {
  mutex.lock();
  try {
    fetcherIsPaused=true;
    fetcherPausedCond.signalAll();
    fetcherCanContinueCond.await();
  }
  finally {
    mutex.unlock();
  }
}"
54489,"private void updateState(List<OplogOperation> fetchedOps,long fetchTime){
  int fetchedOpsSize=fetchedOps.size();
  previousBatchSize=fetchedOpsSize;
  previousBatchTime=fetchTime;
  if (fetchedOpsSize == 0) {
    return;
  }
  opsReadCounter+=fetchedOpsSize;
  OplogOperation lastOp=fetchedOps.get(fetchedOpsSize - 1);
  lastFetchedHash=lastOp.getHash();
  lastFetchedOpTime=lastOp.getOpTime();
  metrics.getLastOpTimeFetched().setValue(state.lastFetchedOpTime.toString());
}","private void updateState(List<OplogOperation> fetchedOps,long fetchTime){
  int fetchedOpsSize=fetchedOps.size();
  if (fetchedOpsSize == 0) {
    return;
  }
  OplogOperation lastOp=fetchedOps.get(fetchedOpsSize - 1);
  lastFetchedHash=lastOp.getHash();
  lastFetchedOpTime=lastOp.getOpTime();
  metrics.getLastOpTimeFetched().setValue(state.lastFetchedOpTime.toString());
}"
54490,"private void checkRollback(OplogReader reader,@Nullable OplogOperation firstCursorOp) throws StopReplicationException, RollbackReplicationException {
}","private void checkRollback(OplogReader reader,@Nullable OplogOperation firstCursorOp) throws StopReplicationException, RollbackReplicationException {
  if (firstCursorOp == null) {
    try {
      OplogOperation lastOp=reader.getLastOp();
      if (lastOp.getOpTime().compareTo(state.lastFetchedOpTime) < 0) {
        throw new RollbackReplicationException(""String_Node_Str"");
      }
    }
 catch (    OplogStartMissingException ex) {
      throw new StopReplicationException(""String_Node_Str"");
    }
catch (    OplogOperationUnsupported ex) {
      throw new StopReplicationException(""String_Node_Str"",ex);
    }
catch (    MongoException ex) {
      throw new StopReplicationException(""String_Node_Str"" + ""String_Node_Str"",ex);
    }
  }
 else {
    if (firstCursorOp.getHash() != state.lastFetchedHash || !firstCursorOp.getOpTime().equals(state.lastFetchedOpTime)) {
      throw new RollbackReplicationException(""String_Node_Str"" + state.lastFetchedOpTime + ""String_Node_Str""+ state.lastFetchedHash+ ""String_Node_Str""+ firstCursorOp.getOpTime()+ ""String_Node_Str""+ firstCursorOp.getHash()+ ""String_Node_Str"");
    }
  }
}"
54491,"@Override public ForkJoinWorkerThreadFactory apply(String prefix){
  return new ForkJoinWorkerThreadFactory(){
    private volatile int idProvider=0;
    @Override public ForkJoinWorkerThread newThread(    ForkJoinPool pool){
      ForkJoinWorkerThread newThread=ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
      int id=idProvider++;
      newThread.setName(prefix + '-' + id);
      return newThread;
    }
  }
;
}","@Override public ForkJoinWorkerThreadFactory apply(String prefix){
  return new CustomForkJoinThreadFactory(prefix);
}"
54492,"@Override protected void configure(){
  bind(Integer.class).annotatedWith(ParallelLevel.class).toInstance(Runtime.getRuntime().availableProcessors());
  ThreadFactory threadFactory=new ThreadFactoryBuilder().setNameFormat(""String_Node_Str"").build();
  bind(ThreadFactory.class).toInstance(threadFactory);
  bind(ThreadFactory.class).annotatedWith(ToroDbIdleService.class).toInstance(threadFactory);
  bind(ThreadFactory.class).annotatedWith(ToroDbRunnableService.class).toInstance(threadFactory);
  bind(ThreadFactory.class).annotatedWith(MongoWP.class).toInstance(threadFactory);
  bind(ForkJoinWorkerThreadFactory.class).toInstance(ForkJoinPool.defaultForkJoinWorkerThreadFactory);
  bind(DefaultConcurrentToolsFactory.BlockerThreadFactoryFunction.class).toInstance(new BlockerThreadFactoryFunction(){
    @Override public ThreadFactory apply(    String prefix){
      return new ThreadFactoryBuilder().setNameFormat(prefix + ""String_Node_Str"").build();
    }
  }
);
  bind(DefaultConcurrentToolsFactory.ForkJoinThreadFactoryFunction.class).toInstance(new ForkJoinThreadFactoryFunction(){
    @Override public ForkJoinWorkerThreadFactory apply(    String prefix){
      return new ForkJoinWorkerThreadFactory(){
        private volatile int idProvider=0;
        @Override public ForkJoinWorkerThread newThread(        ForkJoinPool pool){
          ForkJoinWorkerThread newThread=ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
          int id=idProvider++;
          newThread.setName(prefix + '-' + id);
          return newThread;
        }
      }
;
    }
  }
);
}","@Override protected void configure(){
  bind(Integer.class).annotatedWith(ParallelLevel.class).toInstance(Runtime.getRuntime().availableProcessors());
  ThreadFactory threadFactory=new ThreadFactoryBuilder().setNameFormat(""String_Node_Str"").build();
  bind(ThreadFactory.class).toInstance(threadFactory);
  bind(ThreadFactory.class).annotatedWith(ToroDbIdleService.class).toInstance(threadFactory);
  bind(ThreadFactory.class).annotatedWith(ToroDbRunnableService.class).toInstance(threadFactory);
  bind(ThreadFactory.class).annotatedWith(MongoWP.class).toInstance(threadFactory);
  bind(ForkJoinWorkerThreadFactory.class).toInstance(ForkJoinPool.defaultForkJoinWorkerThreadFactory);
  bind(DefaultConcurrentToolsFactory.BlockerThreadFactoryFunction.class).toInstance(new CustomBlockerThreadFactoryFunction());
  bind(DefaultConcurrentToolsFactory.ForkJoinThreadFactoryFunction.class).toInstance(new CustomForkJoinThreadFactoryFunction());
}"
54493,"public static KeyStore getKeyStore(SSL ssl) throws FileNotFoundException, KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException {
  InputStream is=new FileInputStream(ssl.getKeyStoreFile());
  char[] storePassword=null;
  if (ssl.getKeyStorePassword() != null) {
    storePassword=ssl.getKeyStorePassword().toCharArray();
  }
  KeyStore ks=KeyStore.getInstance(KeyStore.getDefaultType());
  ks.load(is,storePassword);
  return ks;
}","public static KeyStore getKeyStore(SSL ssl) throws FileNotFoundException, KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException {
  try (InputStream is=new FileInputStream(ssl.getKeyStoreFile())){
    char[] storePassword=null;
    if (ssl.getKeyStorePassword() != null) {
      storePassword=ssl.getKeyStorePassword().toCharArray();
    }
    KeyStore ks=KeyStore.getInstance(KeyStore.getDefaultType());
    ks.load(is,storePassword);
    return ks;
  }
 }"
54494,"public static IllegalArgumentException transformJsonMappingException(JsonMappingException jsonMappingException){
  JsonPointer jsonPointer=JsonPointer.compile(""String_Node_Str"");
  for (  Reference reference : jsonMappingException.getPath()) {
    jsonPointer=jsonPointer.append(JsonPointer.compile(""String_Node_Str"" + reference.getFieldName()));
  }
  if (LOGGER.isDebugEnabled()) {
    return new IllegalArgumentException(""String_Node_Str"" + jsonPointer + ""String_Node_Str""+ jsonMappingException.getMessage(),jsonMappingException);
  }
  return new IllegalArgumentException(""String_Node_Str"" + jsonPointer + ""String_Node_Str""+ jsonMappingException.getMessage());
}","public static IllegalArgumentException transformJsonMappingException(JsonMappingException jsonMappingException){
  JsonPointer jsonPointer=JsonPointer.compile(""String_Node_Str"");
  for (  Reference reference : jsonMappingException.getPath()) {
    if (reference.getIndex() != -1) {
      jsonPointer=jsonPointer.append(JsonPointer.compile(""String_Node_Str"" + reference.getIndex()));
    }
    if (reference.getFieldName() != null) {
      jsonPointer=jsonPointer.append(JsonPointer.compile(""String_Node_Str"" + reference.getFieldName()));
    }
  }
  if (LOGGER.isDebugEnabled()) {
    return new IllegalArgumentException(""String_Node_Str"" + jsonPointer + ""String_Node_Str""+ jsonMappingException.getMessage(),jsonMappingException);
  }
  return new IllegalArgumentException(""String_Node_Str"" + jsonPointer + ""String_Node_Str""+ jsonMappingException.getMessage());
}"
54495,"public static JsonPointer toJsonPointer(Path path){
  JsonPointer pointer=JsonPointer.valueOf(null);
  for (  Path.Node pathNode : path) {
    if (pathNode.getIndex() != null) {
      pointer=pointer.append(JsonPointer.valueOf(""String_Node_Str"" + pathNode.getIndex()));
    }
 else     if (pathNode.getName() != null) {
      pointer=pointer.append(JsonPointer.valueOf(""String_Node_Str"" + pathNode.getName()));
    }
  }
  return pointer;
}","public static JsonPointer toJsonPointer(Path path){
  JsonPointer pointer=JsonPointer.valueOf(null);
  for (  Path.Node pathNode : path) {
    if (pathNode.getIndex() != null) {
      pointer=pointer.append(JsonPointer.valueOf(""String_Node_Str"" + pathNode.getIndex()));
    }
    if (pathNode.getName() != null) {
      pointer=pointer.append(JsonPointer.valueOf(""String_Node_Str"" + pathNode.getName()));
    }
  }
  return pointer;
}"
54496,"/** 
 * Creates a flow that batches and analyze a input of   {@link AnalyzedOplogBatch remote jobs}. This flow tries to accummulate several remote jobs into a bigger one and does not emit until: <ul> <li>A maximum number of operations are batched</li> <li>Or a maximum time has happen since the last emit</li> <li>Or the recived job is not   {@link AnalyzedOplogBatch#isReadyForMore()}</li> </ul>
 * @return
 */
private Flow<OplogBatch,AnalyzedStreamElement,NotUsed> createBatcherFlow(ApplierContext context){
  Predicate<OplogBatch> finishBatchPredicate=(  OplogBatch rawBatch) -> !rawBatch.isReadyForMore();
  Supplier<RawStreamElement> zeroFun=() -> RawStreamElement.INITIAL_ELEMENT;
  BiFunction<RawStreamElement,OplogBatch,RawStreamElement> acumFun=(streamElem,newBatch) -> streamElem.concat(newBatch);
  BatchAnalyzer batchAnalyzer=batchAnalyzerFactory.createBatchAnalyzer(context);
  return Flow.of(OplogBatch.class).via(new BatchFlow<>(batchLimits.maxSize,batchLimits.maxPeriod,finishBatchPredicate,zeroFun,acumFun)).filter(rawElem -> rawElem.rawBatch != null && !rawElem.rawBatch.isEmpty()).map(rawElem -> {
    List<OplogOperation> rawOps=rawElem.rawBatch.getOps();
    List<AnalyzedOplogBatch> analyzed=batchAnalyzer.apply(rawOps);
    return new AnalyzedStreamElement(rawElem,analyzed);
  }
);
}","/** 
 * Creates a flow that batches and analyze a input of   {@link AnalyzedOplogBatch remote jobs}. This flow tries to accummulate several remote jobs into a bigger one and does not emit until: <ul> <li>A maximum number of operations are batched</li> <li>Or a maximum time has happen since the last emit</li> <li>Or the recived job is not   {@link AnalyzedOplogBatch#isReadyForMore()}</li> </ul>
 * @return
 */
private Flow<OplogBatch,AnalyzedStreamElement,NotUsed> createBatcherFlow(ApplierContext context){
  Predicate<OplogBatch> finishBatchPredicate=(  OplogBatch rawBatch) -> !rawBatch.isReadyForMore();
  ToIntFunction<OplogBatch> costFunction=(rawBatch) -> rawBatch.count();
  Supplier<RawStreamElement> zeroFun=() -> RawStreamElement.INITIAL_ELEMENT;
  BiFunction<RawStreamElement,OplogBatch,RawStreamElement> acumFun=(streamElem,newBatch) -> streamElem.concat(newBatch);
  BatchAnalyzer batchAnalyzer=batchAnalyzerFactory.createBatchAnalyzer(context);
  return Flow.of(OplogBatch.class).via(new BatchFlow<>(batchLimits.maxSize,batchLimits.maxPeriod,finishBatchPredicate,costFunction,zeroFun,acumFun)).filter(rawElem -> rawElem.rawBatch != null && !rawElem.rawBatch.isEmpty()).map(rawElem -> {
    List<OplogOperation> rawOps=rawElem.rawBatch.getOps();
    List<AnalyzedOplogBatch> analyzed=batchAnalyzer.apply(rawOps);
    return new AnalyzedStreamElement(rawElem,analyzed);
  }
);
}"
54497,"public BatchFlow(int maxBatchSize,FiniteDuration period,Predicate<E> predicate,Supplier<A> zero,BiFunction<A,E,A> aggregate){
  this.maxBatchSize=maxBatchSize;
  this.period=period;
  this.predicate=predicate;
  this.zero=zero;
  this.aggregate=aggregate;
}","public BatchFlow(int maxBatchSize,FiniteDuration period,Predicate<E> predicate,ToIntFunction<E> costFunction,Supplier<A> zero,BiFunction<A,E,A> aggregate){
  this.maxBatchSize=maxBatchSize;
  this.period=period;
  this.predicate=predicate;
  this.costFunction=costFunction;
  this.zero=zero;
  this.aggregate=aggregate;
}"
54498,"private Status<CreateIndexesResult> insertIndex(BsonDocument indexDoc,String database,WriteMongodTransaction trans){
  try {
    CreateIndexesCommand command=CreateIndexesCommand.INSTANCE;
    CreateIndexesArgument arg=command.unmarshallArg(indexDoc);
    CreateIndexesResult result=executeCommand(database,command,arg,trans);
    return Status.ok(result);
  }
 catch (  MongoException ex) {
    return Status.from(ex);
  }
}","private Status<CreateIndexesResult> insertIndex(BsonDocument indexDoc,String database,WriteMongodTransaction trans){
  try {
    CreateIndexesCommand command=CreateIndexesCommand.INSTANCE;
    CreateIndexesArgument arg=command.unmarshallArg(indexDoc);
    return executeCommand(database,command,arg,trans);
  }
 catch (  MongoException ex) {
    return Status.from(ex);
  }
}"
54499,"private void applyUpdate(UpdateOplogOperation op,WriteMongodTransaction trans,ApplierContext applierContext) throws OplogApplyingException {
  boolean upsert=op.isUpsert() || applierContext.treatUpdateAsUpsert();
  UpdateResult result;
  try {
    result=executeCommand(op.getDatabase(),UpdateCommand.INSTANCE,new UpdateArgument(op.getCollection(),Collections.singletonList(new UpdateStatement(op.getFilter(),op.getModification(),upsert,true)),true,WriteConcern.fsync()),trans);
  }
 catch (  MongoException ex) {
    throw new OplogApplyingException(ex);
  }
  if (!result.isOk()) {
    throw new OplogApplyingException(new MongoException(result.getErrorMessage(),ErrorCode.UNKNOWN_ERROR));
  }
  if (!upsert && result.getModifiedCounter() != 0) {
    LOGGER.info(""String_Node_Str"" + ""String_Node_Str"",op.getOpTime(),op.getHash(),op.getFilter());
  }
  if (upsert && !result.getUpserts().isEmpty()) {
    LOGGER.warn(""String_Node_Str"" + op);
  }
}","private void applyUpdate(UpdateOplogOperation op,WriteMongodTransaction trans,ApplierContext applierContext) throws OplogApplyingException {
}"
54500,"private <Arg,Result>Result executeCommand(String db,Command<? super Arg,? super Result> command,Arg arg,WriteMongodTransaction trans) throws MongoException {
  Request req=new Request(db,null,true,null);
  Status<Result> result=trans.execute(req,command,arg);
  if (result == null) {
    throw new ConflictingOperationInProgressException(""String_Node_Str"" + command.getCommandName() + ""String_Node_Str"");
  }
  return result.getResult();
}","private <Arg,Result>Status<Result> executeCommand(String db,Command<? super Arg,? super Result> command,Arg arg,WriteMongodTransaction trans) throws MongoException {
  Request req=new Request(db,null,true,null);
  Status<Result> result=trans.execute(req,command,arg);
  if (result == null) {
    throw new ConflictingOperationInProgressException(""String_Node_Str"" + command.getCommandName() + ""String_Node_Str"");
  }
  return result;
}"
54501,"private void applyDelete(DeleteOplogOperation op,WriteMongodTransaction trans,ApplierContext applierContext) throws OplogApplyingException {
  try {
    Long result=executeCommand(op.getDatabase(),DeleteCommand.INSTANCE,new DeleteArgument(op.getCollection(),Collections.singletonList(new DeleteStatement(op.getFilter(),op.isJustOne())),true,WriteConcern.fsync()),trans);
    if (result == 0 && applierContext.treatUpdateAsUpsert()) {
      LOGGER.info(""String_Node_Str"" + ""String_Node_Str"",op.getOpTime(),op.getHash(),op.getFilter());
    }
  }
 catch (  MongoException ex) {
    throw new OplogApplyingException(ex);
  }
}","private void applyDelete(DeleteOplogOperation op,WriteMongodTransaction trans,ApplierContext applierContext) throws OplogApplyingException {
  try {
    Status<Long> status=executeCommand(op.getDatabase(),DeleteCommand.INSTANCE,new DeleteArgument(op.getCollection(),Collections.singletonList(new DeleteStatement(op.getFilter(),op.isJustOne())),true,WriteConcern.fsync()),trans);
    if (!status.isOK()) {
      throw new OplogApplyingException(new MongoException(status));
    }
    if (status.getResult() == 0 && applierContext.treatUpdateAsUpsert()) {
      LOGGER.info(""String_Node_Str"" + ""String_Node_Str"",op.getOpTime(),op.getHash(),op.getFilter());
    }
  }
 catch (  MongoException ex) {
    throw new OplogApplyingException(ex);
  }
}"
54502,"private OplogFetcher createOplogFetcher(Stream<OplogOperation> opsStream){
  return new LimitedOplogFetcher(new IteratorMongoCursor<>(""String_Node_Str"",""String_Node_Str"",1,false,HostAndPort.fromParts(""String_Node_Str"",27017),opsStream.iterator()));
}","private OplogFetcher createOplogFetcher(Stream<OplogOperation> opsStream){
  return new LimitedOplogFetcher(new IteratorMongoCursor<>(""String_Node_Str"",""String_Node_Str"",1,HostAndPort.fromParts(""String_Node_Str"",27017),opsStream.iterator()));
}"
54503,"@Inject public AkkaDbClonerProvider(ToroDbExecutorService executor,@ParallelLevel int parallelLevel,@DocsPerTransaction int docsPerTransaction,CommitHeuristic commitHeuristic,Clock clock){
  this.executor=executor;
  this.parallelLevel=parallelLevel;
  this.commitHeuristic=commitHeuristic;
  this.clock=clock;
  this.docsPerTransaction=docsPerTransaction;
}","/** 
 * @param executor
 * @param streamExecutor
 * @param parallelLevel
 * @param docsPerTransaction
 * @param commitHeuristic
 * @param clock
 * @param retrier
 */
@Inject public AkkaDbClonerProvider(ToroDbExecutorService executor,StreamExecutor streamExecutor,@ParallelLevel int parallelLevel,@DocsPerTransaction int docsPerTransaction,CommitHeuristic commitHeuristic,Clock clock,Retrier retrier){
  this.executor=executor;
  this.streamExecutor=streamExecutor;
  this.parallelLevel=parallelLevel;
  this.commitHeuristic=commitHeuristic;
  this.clock=clock;
  this.docsPerTransaction=docsPerTransaction;
  this.retrier=retrier;
}"
54504,"@Override public AkkaDbCloner get(){
  LOGGER.info(""String_Node_Str"",parallelLevel,docsPerTransaction);
  return new AkkaDbCloner(executor,parallelLevel - 1,parallelLevel * docsPerTransaction,docsPerTransaction,commitHeuristic,clock);
}","@Override public AkkaDbCloner get(){
  LOGGER.info(""String_Node_Str"",parallelLevel,docsPerTransaction);
  return new AkkaDbCloner(executor,parallelLevel - 1,streamExecutor,parallelLevel * docsPerTransaction,docsPerTransaction,commitHeuristic,clock,retrier);
}"
54505,"public static void mergeParam(ObjectMapper objectMapper,JsonNode configRootNode,String pathAndProp,String value) throws Exception {
  String path=pathAndProp.substring(0,pathAndProp.lastIndexOf(""String_Node_Str""));
  String prop=pathAndProp.substring(pathAndProp.lastIndexOf(""String_Node_Str"") + 1);
  JsonPointer pathPointer=JsonPointer.compile(path);
  JsonNode pathNode=configRootNode.at(pathPointer);
  if (pathNode.isMissingNode() || pathNode.isNull()) {
    JsonPointer currentPointer=pathPointer;
    JsonPointer childOfCurrentPointer=null;
    List<JsonPointer> missingPointers=new ArrayList<>();
    List<JsonPointer> childOfMissingPointers=new ArrayList<>();
    do {
      if (pathNode.isMissingNode() || pathNode.isNull()) {
        missingPointers.add(0,currentPointer);
        childOfMissingPointers.add(0,childOfCurrentPointer);
      }
      childOfCurrentPointer=currentPointer;
      currentPointer=currentPointer.head();
      pathNode=configRootNode.at(currentPointer);
    }
 while (pathNode.isMissingNode() || pathNode.isNull());
    for (int missingPointerIndex=0; missingPointerIndex < missingPointers.size(); missingPointerIndex++) {
      final JsonPointer missingPointer=missingPointers.get(missingPointerIndex);
      final JsonPointer childOfMissingPointer=childOfMissingPointers.get(missingPointerIndex);
      final List<JsonNode> newNodes=new ArrayList<>();
      if (pathNode.isObject()) {
        ((ObjectNode)pathNode).set(missingPointer.last().getMatchingProperty(),createNode(childOfMissingPointer,newNodes));
      }
 else       if (pathNode.isArray() && missingPointer.last().mayMatchElement()) {
        for (int index=((ArrayNode)pathNode).size(); index < missingPointer.last().getMatchingIndex() + 1; index++) {
          ((ArrayNode)pathNode).add(createNode(childOfMissingPointer,newNodes));
        }
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + pathAndProp + ""String_Node_Str""+ value);
      }
      pathNode=newNodes.get(newNodes.size() - 1);
    }
  }
  ObjectNode objectNode=(ObjectNode)pathNode;
  Object valueAsObject=objectMapper.readValue(value,Object.class);
  if (valueAsObject != null) {
    JsonNode valueNode=objectMapper.valueToTree(valueAsObject);
    objectNode.set(prop,valueNode);
  }
 else {
    objectNode.remove(prop);
  }
}","public static void mergeParam(ObjectMapper objectMapper,JsonNode configRootNode,String pathAndProp,String value) throws Exception {
  String path=pathAndProp.substring(0,pathAndProp.lastIndexOf(""String_Node_Str""));
  String prop=pathAndProp.substring(pathAndProp.lastIndexOf(""String_Node_Str"") + 1);
  JsonPointer pathPointer=JsonPointer.compile(path);
  JsonNode pathNode=configRootNode.at(pathPointer);
  if (pathNode.isMissingNode() || pathNode.isNull()) {
    JsonPointer currentPointer=pathPointer;
    JsonPointer childOfCurrentPointer=null;
    List<JsonPointer> missingPointers=new ArrayList<>();
    List<JsonPointer> childOfMissingPointers=new ArrayList<>();
    do {
      if (pathNode.isMissingNode() || pathNode.isNull()) {
        missingPointers.add(0,currentPointer);
        childOfMissingPointers.add(0,childOfCurrentPointer);
      }
      childOfCurrentPointer=currentPointer;
      currentPointer=currentPointer.head();
      pathNode=configRootNode.at(currentPointer);
    }
 while (pathNode.isMissingNode() || pathNode.isNull());
    for (int missingPointerIndex=0; missingPointerIndex < missingPointers.size(); missingPointerIndex++) {
      final JsonPointer missingPointer=missingPointers.get(missingPointerIndex);
      final JsonPointer childOfMissingPointer=childOfMissingPointers.get(missingPointerIndex);
      final List<JsonNode> newNodes=new ArrayList<>();
      if (pathNode.isObject()) {
        ((ObjectNode)pathNode).set(missingPointer.last().getMatchingProperty(),createNode(childOfMissingPointer,newNodes));
      }
 else       if (pathNode.isArray() && missingPointer.last().mayMatchElement()) {
        for (int index=((ArrayNode)pathNode).size(); index < missingPointer.last().getMatchingIndex() + 1; index++) {
          ((ArrayNode)pathNode).add(createNode(childOfMissingPointer,newNodes));
        }
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + pathAndProp + ""String_Node_Str""+ value);
      }
      pathNode=newNodes.get(newNodes.size() - 1);
    }
  }
  ObjectNode objectNode=(ObjectNode)pathNode;
  Object valueAsObject;
  try {
    valueAsObject=objectMapper.readValue(value,Object.class);
  }
 catch (  JsonMappingException jsonMappingException) {
    throw JsonMappingException.wrapWithPath(jsonMappingException,configRootNode,path.substring(1) + ""String_Node_Str"" + prop);
  }
  if (valueAsObject != null) {
    JsonNode valueNode=objectMapper.valueToTree(valueAsObject);
    objectNode.set(prop,valueNode);
  }
 else {
    objectNode.remove(prop);
  }
}"
54506,"public static IllegalArgumentException transformJsonMappingException(JsonMappingException jsonMappingException){
  JsonPointer jsonPointer=JsonPointer.compile(""String_Node_Str"");
  for (  Reference reference : jsonMappingException.getPath()) {
    jsonPointer=jsonPointer.append(JsonPointer.compile(""String_Node_Str"" + reference.getFieldName()));
  }
  return new IllegalArgumentException(""String_Node_Str"" + jsonPointer + ""String_Node_Str""+ jsonMappingException.getMessage());
}","public static IllegalArgumentException transformJsonMappingException(JsonMappingException jsonMappingException){
  JsonPointer jsonPointer=JsonPointer.compile(""String_Node_Str"");
  for (  Reference reference : jsonMappingException.getPath()) {
    jsonPointer=jsonPointer.append(JsonPointer.compile(""String_Node_Str"" + reference.getFieldName()));
  }
  if (LOGGER.isDebugEnabled()) {
    return new IllegalArgumentException(""String_Node_Str"" + jsonPointer + ""String_Node_Str""+ jsonMappingException.getMessage(),jsonMappingException);
  }
  return new IllegalArgumentException(""String_Node_Str"" + jsonPointer + ""String_Node_Str""+ jsonMappingException.getMessage());
}"
54507,"@Override public AkkaDbCloner get(){
  LOGGER.info(""String_Node_Str"",parallelLevel,docsPerTransaction);
  return new AkkaDbCloner(executor,parallelLevel - 1,streamExecutor,parallelLevel * docsPerTransaction,docsPerTransaction,commitHeuristic,clock,retrier);
}","@Override public AkkaDbCloner get(){
  LOGGER.info(""String_Node_Str"",parallelLevel,docsPerTransaction);
  return new AkkaDbCloner(executor,Math.max(1,parallelLevel - 1),streamExecutor,parallelLevel * docsPerTransaction,docsPerTransaction,commitHeuristic,clock,retrier);
}"
54508,"public PostgreSQLErrorHandler(){
  super(rule(""String_Node_Str""),rule(""String_Node_Str""),rule(""String_Node_Str""),rule(""String_Node_Str""),rule(""String_Node_Str""),rule(""String_Node_Str"",CREATE_SCHEMA,CREATE_TABLE,ADD_COLUMN,CREATE_INDEX,DROP_SCHEMA,DROP_TABLE,DROP_INDEX));
}","public PostgreSQLErrorHandler(){
  super(rule(""String_Node_Str""),rule(""String_Node_Str""),rule(""String_Node_Str""),rule(""String_Node_Str""),rule(""String_Node_Str""),rule(""String_Node_Str"",CREATE_SCHEMA,CREATE_TABLE,ADD_COLUMN,CREATE_INDEX,DROP_SCHEMA,DROP_TABLE,DROP_INDEX,META_INSERT));
}"
54509,"@Override public WriteBackendTransaction openWriteTransaction(){
  Preconditions.checkState(!closed,""String_Node_Str"");
  Preconditions.checkState(currentTransaction == null,""String_Node_Str"" + currentTransaction);
  WriteBackendTransactionImpl transaction=new WriteBackendTransactionImpl(sqlInterface,this,r2dTranslator,identifierFactory);
  currentTransaction=transaction;
  return transaction;
}","@Override public WriteBackendTransaction openWriteTransaction(){
  Preconditions.checkState(!closed,""String_Node_Str"");
  Preconditions.checkState(currentTransaction == null,""String_Node_Str"" + currentTransaction);
  WriteBackendTransactionImpl transaction=new WriteBackendTransactionImpl(sqlInterface,this,r2dTranslator,identifierFactory,ridGenerator);
  currentTransaction=transaction;
  return transaction;
}"
54510,"public BackendConnectionImpl(BackendImpl backend,SqlInterface sqlInterface,R2DTranslator r2dTranslator,IdentifierFactory identifierFactory){
  this.backend=backend;
  this.sqlInterface=sqlInterface;
  this.r2dTranslator=r2dTranslator;
  this.identifierFactory=identifierFactory;
}","public BackendConnectionImpl(BackendImpl backend,SqlInterface sqlInterface,R2DTranslator r2dTranslator,IdentifierFactory identifierFactory,RidGenerator ridGenerator){
  this.backend=backend;
  this.sqlInterface=sqlInterface;
  this.r2dTranslator=r2dTranslator;
  this.identifierFactory=identifierFactory;
  this.ridGenerator=ridGenerator;
}"
54511,"@Override public BackendConnection openConnection(){
  return new BackendConnectionImpl(this,sqlInterface,r2dTranslator,identifierFactory);
}","@Override public BackendConnection openConnection(){
  return new BackendConnectionImpl(this,sqlInterface,r2dTranslator,identifierFactory,ridGenerator);
}"
54512,"@Inject public BackendImpl(DbBackendService dbBackendService,SqlInterface sqlInterface,SqlHelper sqlHelper,SchemaUpdater schemaUpdater,MetainfoRepository metainfoRepository,TableRefFactory tableRefFactory,MaxRowIdFactory maxRowIdFactory,R2DTranslator r2dTranslator,IdentifierFactory identifierFactory){
  this.dbBackendService=dbBackendService;
  this.sqlInterface=sqlInterface;
  this.sqlHelper=sqlHelper;
  this.schemaUpdater=schemaUpdater;
  this.metainfoRepository=metainfoRepository;
  this.tableRefFactory=tableRefFactory;
  this.maxRowIdFactory=maxRowIdFactory;
  this.r2dTranslator=r2dTranslator;
  this.identifierFactory=identifierFactory;
}","@Inject public BackendImpl(DbBackendService dbBackendService,SqlInterface sqlInterface,SqlHelper sqlHelper,SchemaUpdater schemaUpdater,MetainfoRepository metainfoRepository,TableRefFactory tableRefFactory,MaxRowIdFactory maxRowIdFactory,R2DTranslator r2dTranslator,IdentifierFactory identifierFactory,RidGenerator ridGenerator){
  this.dbBackendService=dbBackendService;
  this.sqlInterface=sqlInterface;
  this.sqlHelper=sqlHelper;
  this.schemaUpdater=schemaUpdater;
  this.metainfoRepository=metainfoRepository;
  this.tableRefFactory=tableRefFactory;
  this.maxRowIdFactory=maxRowIdFactory;
  this.r2dTranslator=r2dTranslator;
  this.identifierFactory=identifierFactory;
  this.ridGenerator=ridGenerator;
}"
54513,"@Override public void renameCollection(MetaDatabase fromDb,MetaCollection fromColl,MutableMetaDatabase toDb,MutableMetaCollection toColl){
  Preconditions.checkState(!isClosed(),""String_Node_Str"");
  copyMetaCollection(fromColl,toDb,toColl);
  getSqlInterface().getStructureInterface().renameCollection(getDsl(),fromDb.getIdentifier(),fromColl,toDb.getIdentifier(),toColl);
  dropMetaCollection(fromDb.getName(),fromColl);
}","@Override public void renameCollection(MetaDatabase fromDb,MetaCollection fromColl,MutableMetaDatabase toDb,MutableMetaCollection toColl){
  Preconditions.checkState(!isClosed(),""String_Node_Str"");
  copyMetaCollection(fromDb,fromColl,toDb,toColl);
  getSqlInterface().getStructureInterface().renameCollection(getDsl(),fromDb.getIdentifier(),fromColl,toDb.getIdentifier(),toColl);
  dropMetaCollection(fromDb.getName(),fromColl);
}"
54514,"public WriteBackendTransactionImpl(SqlInterface sqlInterface,BackendConnectionImpl backendConnection,R2DTranslator r2dTranslator,IdentifierFactory identifierFactory){
  super(sqlInterface.getDbBackend().createWriteConnection(),sqlInterface,backendConnection,r2dTranslator);
  this.identifierFactory=identifierFactory;
}","public WriteBackendTransactionImpl(SqlInterface sqlInterface,BackendConnectionImpl backendConnection,R2DTranslator r2dTranslator,IdentifierFactory identifierFactory,RidGenerator ridGenerator){
  super(sqlInterface.getDbBackend().createWriteConnection(),sqlInterface,backendConnection,r2dTranslator);
  this.identifierFactory=identifierFactory;
  this.ridGenerator=ridGenerator;
}"
54515,"private void copyMetaCollection(MetaCollection fromColl,MutableMetaDatabase toDb,MutableMetaCollection toColl){
  Iterator<? extends MetaDocPart> fromMetaDocPartIterator=fromColl.streamContainedMetaDocParts().iterator();
  while (fromMetaDocPartIterator.hasNext()) {
    MetaDocPart fromMetaDocPart=fromMetaDocPartIterator.next();
    MutableMetaDocPart toMetaDocPart=toColl.addMetaDocPart(fromMetaDocPart.getTableRef(),identifierFactory.toDocPartIdentifier(toDb,toColl.getName(),fromMetaDocPart.getTableRef()));
    getSqlInterface().getMetaDataWriteInterface().addMetaDocPart(getDsl(),toDb.getName(),toColl.getName(),toMetaDocPart.getTableRef(),toMetaDocPart.getIdentifier());
    copyScalar(identifierFactory,fromMetaDocPart,toDb,toColl,toMetaDocPart);
    copyFields(identifierFactory,fromMetaDocPart,toDb,toColl,toMetaDocPart);
  }
}","private void copyMetaCollection(MetaDatabase fromDb,MetaCollection fromColl,MutableMetaDatabase toDb,MutableMetaCollection toColl){
  Iterator<? extends MetaDocPart> fromMetaDocPartIterator=fromColl.streamContainedMetaDocParts().iterator();
  while (fromMetaDocPartIterator.hasNext()) {
    MetaDocPart fromMetaDocPart=fromMetaDocPartIterator.next();
    MutableMetaDocPart toMetaDocPart=toColl.addMetaDocPart(fromMetaDocPart.getTableRef(),identifierFactory.toDocPartIdentifier(toDb,toColl.getName(),fromMetaDocPart.getTableRef()));
    getSqlInterface().getMetaDataWriteInterface().addMetaDocPart(getDsl(),toDb.getName(),toColl.getName(),toMetaDocPart.getTableRef(),toMetaDocPart.getIdentifier());
    copyScalar(identifierFactory,fromMetaDocPart,toDb,toColl,toMetaDocPart);
    copyFields(identifierFactory,fromMetaDocPart,toDb,toColl,toMetaDocPart);
    int nextRid=ridGenerator.getDocPartRidGenerator(fromDb.getName(),fromColl.getName()).nextRid(fromMetaDocPart.getTableRef());
    ridGenerator.getDocPartRidGenerator(toDb.getName(),toColl.getName()).setNextRid(toMetaDocPart.getTableRef(),nextRid - 1);
  }
}"
54516,"protected void executeSql(DSLContext dsl,String resourcePath,SqlHelper sqlHelper) throws IOException, SQLException {
  InputStream resourceAsStream=getClass().getClassLoader().getResourceAsStream(resourcePath);
  if (resourceAsStream == null) {
    throw new SystemException(""String_Node_Str"" + resourcePath + ""String_Node_Str"");
  }
  try {
    String statementAsString=CharStreams.toString(new BufferedReader(new InputStreamReader(resourceAsStream,Charset.forName(""String_Node_Str""))));
    sqlHelper.executeStatement(dsl,statementAsString,Context.UNKNOWN);
  }
  finally {
    resourceAsStream.close();
  }
}","@SuppressFBWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") protected void executeSql(DSLContext dsl,String resourcePath,SqlHelper sqlHelper) throws IOException, SQLException {
  InputStream resourceAsStream=getClass().getResourceAsStream(resourcePath);
  if (resourceAsStream == null) {
    throw new SystemException(""String_Node_Str"" + resourcePath + ""String_Node_Str"");
  }
  try {
    String statementAsString=CharStreams.toString(new BufferedReader(new InputStreamReader(resourceAsStream,Charset.forName(""String_Node_Str""))));
    sqlHelper.executeStatement(dsl,statementAsString,Context.UNKNOWN);
  }
  finally {
    resourceAsStream.close();
  }
}"
54517,"public void commit() throws RollbackException, UserException {
  try (MergerStage mergeStage=metainfoRepository.startMerge(metaSnapshot)){
    backendTransaction.commit();
    backendTransaction.close();
    mergeStage.commit();
  }
 }","public void commit() throws RollbackException, UserException {
  try (MergerStage mergeStage=metainfoRepository.startMerge(metaSnapshot)){
    backendTransaction.commit();
    mergeStage.commit();
  }
 }"
54518,"@Inject ConnectionCommandsExecutor(MapFactory mapFactory){
  ImmutableMap<Command<?,?>,CommandImplementation> supportedCommandsMap=mapFactory.get();
  supportedCommands=Collections.unmodifiableSet(supportedCommandsMap.entrySet().stream().filter((e) -> !(e.getValue() instanceof NotImplementedCommandImplementation)).map((e) -> e.getKey()).collect(Collectors.toSet()));
  delegate=MapBasedCommandsExecutor.<MongodConnection>builder().addImplementations(supportedCommandsMap.entrySet()).build();
}","@Inject ConnectionCommandsExecutor(MapFactory mapFactory){
  map=mapFactory.get();
  supportedCommands=Collections.unmodifiableSet(map.entrySet().stream().filter((e) -> !(e.getValue() instanceof NotImplementedCommandImplementation)).map((e) -> e.getKey()).collect(Collectors.toSet()));
}"
54519,"@Override public ImmutableMap<Command<?,?>,CommandImplementation> get(){
  MongoDb30CommandsImplementationBuilder implBuilder=new MongoDb30CommandsImplementationBuilder(adminBuilder,aggregationBuilder,authenticationCommandsImplementationsBuilder,diagnosticBuilder,generalBuilder,internalBuilder,replBuilder);
  ImmutableMap.Builder<Command<?,?>,CommandImplementation> builder=ImmutableMap.builder();
  for (  Entry<Command<?,?>,CommandImplementation> entry : implBuilder) {
    builder.put(entry.getKey(),entry.getValue());
  }
  return builder.build();
}","@Override public ImmutableMap<Command<?,?>,CommandImplementation<?,?,? super MongodConnection>> get(){
  MongoDb30CommandsImplementationBuilder<MongodConnection> implBuilder=new MongoDb30CommandsImplementationBuilder<>(adminBuilder,aggregationBuilder,authenticationCommandsImplementationsBuilder,diagnosticBuilder,generalBuilder,internalBuilder,replBuilder);
  ImmutableMap.Builder<Command<?,?>,CommandImplementation<?,?,? super MongodConnection>> builder=ImmutableMap.builder();
  for (  Entry<Command<?,?>,CommandImplementation<?,?,? super MongodConnection>> entry : implBuilder) {
    builder.put(entry.getKey(),entry.getValue());
  }
  return builder.build();
}"
54520,"@Locked(exclusive=true) private void loadState() throws OplogManagerPersistException {
  Status<? extends Object> result=retrier.retry(() -> {
    try (ReadOnlyMongodTransaction transaction=connection.openReadOnlyTransaction()){
      Status<FindResult> status=transaction.execute(new Request(OPLOG_DB,null,true,null),FindCommand.INSTANCE,new FindArgument.Builder().setComment(OPLOG_COL).setSlaveOk(true).build());
      if (!status.isOK()) {
        return status;
      }
      Iterator<BsonDocument> batch=status.getResult().getCursor().getFirstBatch();
      if (!batch.hasNext()) {
        lastAppliedHash=0;
        lastAppliedOpTime=OpTime.EPOCH;
      }
 else {
        BsonDocument doc=batch.next();
        BsonDocument subDoc=BsonReaderTool.getDocument(doc,KEY);
        lastAppliedHash=BsonReaderTool.getLong(subDoc,""String_Node_Str"");
        BsonDocument opTimeDoc=BsonReaderTool.getDocument(subDoc,""String_Node_Str"");
        lastAppliedOpTime=new OpTime(UnsignedInteger.valueOf(BsonReaderTool.getLong(opTimeDoc,""String_Node_Str"")),UnsignedInteger.valueOf(BsonReaderTool.getLong(opTimeDoc,""String_Node_Str"")));
      }
      return Status.ok();
    }
 catch (    MongoException ex) {
      return Status.from(ex);
    }
  }
);
  if (!result.isOK()) {
    throw new OplogManagerPersistException(result.getErrorCode(),result.getErrorMsg());
  }
}","@Locked(exclusive=true) private void loadState() throws OplogManagerPersistException {
  Status<? extends Object> result=retrier.retry(() -> {
    try (ReadOnlyMongodTransaction transaction=connection.openReadOnlyTransaction()){
      Status<FindResult> status=transaction.execute(new Request(OPLOG_DB,null,true,null),FindCommand.INSTANCE,new FindArgument.Builder().setCollection(OPLOG_COL).setSlaveOk(true).build());
      if (!status.isOK()) {
        return status;
      }
      Iterator<BsonDocument> batch=status.getResult().getCursor().getFirstBatch();
      if (!batch.hasNext()) {
        lastAppliedHash=0;
        lastAppliedOpTime=OpTime.EPOCH;
      }
 else {
        BsonDocument doc=batch.next();
        BsonDocument subDoc=BsonReaderTool.getDocument(doc,KEY);
        lastAppliedHash=BsonReaderTool.getLong(subDoc,""String_Node_Str"");
        lastAppliedOpTime=new OpTime(UnsignedInteger.valueOf(BsonReaderTool.getLong(subDoc,""String_Node_Str"")),UnsignedInteger.valueOf(BsonReaderTool.getLong(subDoc,""String_Node_Str"")));
      }
      return Status.ok();
    }
 catch (    MongoException ex) {
      return Status.from(ex);
    }
  }
);
  if (!result.isOK()) {
    throw new OplogManagerPersistException(result.getErrorCode(),result.getErrorMsg());
  }
}"
54521,"@Locked(exclusive=true) private void storeState(long hash,OpTime opTime) throws OplogManagerPersistException {
  Preconditions.checkState(isRunning(),""String_Node_Str"");
  Status<?> result=retrier.retry(() -> {
    try (WriteMongodTransaction transaction=connection.openWriteTransaction()){
      Status<Long> deleteResult=transaction.execute(new Request(OPLOG_DB,null,true,null),DeleteCommand.INSTANCE,new DeleteArgument.Builder(OPLOG_COL).addStatement(new DeleteStatement(DOC_QUERY,false)).build());
      if (!deleteResult.isOK()) {
        return deleteResult;
      }
      Status<InsertResult> insertResult=transaction.execute(new Request(""String_Node_Str"",null,true,null),InsertCommand.INSTANCE,new InsertArgument.Builder(""String_Node_Str"").addDocument(new BsonDocumentBuilder().appendUnsafe(KEY,new BsonDocumentBuilder().appendUnsafe(""String_Node_Str"",newLong(hash)).appendUnsafe(""String_Node_Str"",new BsonDocumentBuilder().appendUnsafe(""String_Node_Str"",newLong(opTime.getSecs().longValue())).appendUnsafe(""String_Node_Str"",newLong(opTime.getTerm().longValue())).build()).build()).build()).build());
      if (insertResult.isOK() && insertResult.getResult().getN() != 1) {
        return Status.from(ErrorCode.OPERATION_FAILED,""String_Node_Str"");
      }
      return insertResult;
    }
   }
);
  if (!result.isOK()) {
    throw new OplogManagerPersistException(result.getErrorCode(),result.getErrorMsg());
  }
}","@Locked(exclusive=true) private void storeState(long hash,OpTime opTime) throws OplogManagerPersistException {
  Preconditions.checkState(isRunning(),""String_Node_Str"");
  Status<?> result=retrier.retry(() -> {
    try (WriteMongodTransaction transaction=connection.openWriteTransaction()){
      Status<Long> deleteResult=transaction.execute(new Request(OPLOG_DB,null,true,null),DeleteCommand.INSTANCE,new DeleteArgument.Builder(OPLOG_COL).addStatement(new DeleteStatement(DOC_QUERY,false)).build());
      if (!deleteResult.isOK()) {
        return deleteResult;
      }
      Status<InsertResult> insertResult=transaction.execute(new Request(OPLOG_DB,null,true,null),InsertCommand.INSTANCE,new InsertArgument.Builder(OPLOG_COL).addDocument(new BsonDocumentBuilder().appendUnsafe(KEY,new BsonDocumentBuilder().appendUnsafe(""String_Node_Str"",newLong(hash)).appendUnsafe(""String_Node_Str"",newLong(opTime.getSecs().longValue())).appendUnsafe(""String_Node_Str"",newLong(opTime.getTerm().longValue())).build()).build()).build());
      if (insertResult.isOK() && insertResult.getResult().getN() != 1) {
        return Status.from(ErrorCode.OPERATION_FAILED,""String_Node_Str"");
      }
      transaction.commit();
      return insertResult;
    }
   }
);
  if (!result.isOK()) {
    throw new OplogManagerPersistException(result.getErrorCode(),result.getErrorMsg());
  }
}"
54522,"private void analyzeScalar(MutableMetaDatabase db,MutableMetaDocPart metaDocPart,MetaScalarRecord<?> scalar,SchemaValidator schemaValidator){
  String docPartIdentifier=metaDocPart.getIdentifier();
  String schemaName=db.getIdentifier();
  String dbName=db.getName();
  TableRef fieldTableRef=scalar.getTableRefValue(tableRefFactory);
  if (!metaDocPart.getTableRef().equals(fieldTableRef)) {
    return;
  }
  metaDocPart.addMetaScalar(scalar.getIdentifier(),scalar.getType());
  if (!schemaValidator.existsColumn(docPartIdentifier,scalar.getIdentifier())) {
    throw new InvalidDatabaseSchemaException(schemaName,""String_Node_Str"" + scalar.getCollection() + ""String_Node_Str""+ scalar.getTableRefValue(tableRefFactory)+ ""String_Node_Str""+ scalar.getType()+ ""String_Node_Str""+ dbName+ ""String_Node_Str""+ scalar.getIdentifier()+ ""String_Node_Str""+ schemaName+ ""String_Node_Str""+ docPartIdentifier);
  }
  if (!schemaValidator.existsColumnWithType(docPartIdentifier,scalar.getIdentifier(),sqlInterface.getDataTypeProvider().getDataType(scalar.getType()))) {
  }
}","private void analyzeScalar(MutableMetaDatabase db,MutableMetaDocPart metaDocPart,MetaScalarRecord<?> scalar,SchemaValidator schemaValidator){
  String docPartIdentifier=metaDocPart.getIdentifier();
  String schemaName=db.getIdentifier();
  String dbName=db.getName();
  TableRef fieldTableRef=scalar.getTableRefValue(tableRefFactory);
  if (!metaDocPart.getTableRef().equals(fieldTableRef)) {
    return;
  }
  metaDocPart.addMetaScalar(scalar.getIdentifier(),scalar.getType());
  if (!schemaValidator.existsColumn(docPartIdentifier,scalar.getIdentifier())) {
    throw new InvalidDatabaseSchemaException(schemaName,""String_Node_Str"" + scalar.getCollection() + ""String_Node_Str""+ scalar.getTableRefValue(tableRefFactory)+ ""String_Node_Str""+ scalar.getType()+ ""String_Node_Str""+ dbName+ ""String_Node_Str""+ scalar.getIdentifier()+ ""String_Node_Str""+ schemaName+ ""String_Node_Str""+ docPartIdentifier);
  }
}"
54523,"private void analyzeField(MutableMetaDatabase db,MutableMetaDocPart metaDocPart,MetaFieldRecord<?> field,SchemaValidator schemaValidator){
  String docPartIdentifier=metaDocPart.getIdentifier();
  String schemaName=db.getIdentifier();
  String dbName=db.getName();
  TableRef fieldTableRef=field.getTableRefValue(tableRefFactory);
  if (!metaDocPart.getTableRef().equals(fieldTableRef)) {
    return;
  }
  metaDocPart.addMetaField(field.getName(),field.getIdentifier(),field.getType());
  if (!schemaValidator.existsColumn(docPartIdentifier,field.getIdentifier())) {
    throw new InvalidDatabaseSchemaException(schemaName,""String_Node_Str"" + field.getCollection() + ""String_Node_Str""+ field.getTableRefValue(tableRefFactory)+ ""String_Node_Str""+ field.getName()+ ""String_Node_Str""+ field.getType()+ ""String_Node_Str""+ dbName+ ""String_Node_Str""+ field.getIdentifier()+ ""String_Node_Str""+ schemaName+ ""String_Node_Str""+ docPartIdentifier);
  }
  if (!schemaValidator.existsColumnWithType(docPartIdentifier,field.getIdentifier(),sqlInterface.getDataTypeProvider().getDataType(field.getType()))) {
  }
}","private void analyzeField(MutableMetaDatabase db,MutableMetaDocPart metaDocPart,MetaFieldRecord<?> field,SchemaValidator schemaValidator){
  String docPartIdentifier=metaDocPart.getIdentifier();
  String schemaName=db.getIdentifier();
  String dbName=db.getName();
  TableRef fieldTableRef=field.getTableRefValue(tableRefFactory);
  if (!metaDocPart.getTableRef().equals(fieldTableRef)) {
    return;
  }
  metaDocPart.addMetaField(field.getName(),field.getIdentifier(),field.getType());
  if (!schemaValidator.existsColumn(docPartIdentifier,field.getIdentifier())) {
    throw new InvalidDatabaseSchemaException(schemaName,""String_Node_Str"" + field.getCollection() + ""String_Node_Str""+ field.getTableRefValue(tableRefFactory)+ ""String_Node_Str""+ field.getName()+ ""String_Node_Str""+ field.getType()+ ""String_Node_Str""+ dbName+ ""String_Node_Str""+ field.getIdentifier()+ ""String_Node_Str""+ schemaName+ ""String_Node_Str""+ docPartIdentifier);
  }
}"
54524,"@Override public synchronized Exception getCause(){
  return (Exception)super.getCause();
}","@Override public synchronized Exception getCause(){
  Throwable cause=super.getCause();
  if (cause instanceof Exception) {
    return (Exception)cause;
  }
  return null;
}"
54525,"@Override public synchronized UserException getCause(){
  return (UserException)super.getCause();
}","@Override public synchronized UserException getCause(){
  Exception cause=super.getCause();
  if (cause instanceof UserException) {
    return (UserException)cause;
  }
  return null;
}"
54526,"@Override public List<KVDocument> createListFrom(InputStream is){
  return converter.convert((List<Map<String,Object>>)gson.fromJson(new InputStreamReader(is,Charsets.UTF_8),new TypeToken<List<HashMap<String,Object>>>(){
  }
.getType()));
}","@Override public List<KVDocument> createListFrom(InputStream is){
  return converter.convert((List<Map<String,Object>>)gson.fromJson(new InputStreamReader(is,Charsets.UTF_8),type));
}"
54527,"@Override public List<KVDocument> createListFromJson(String json){
  return converter.convert((List<Map<String,Object>>)gson.fromJson(json,new TypeToken<List<HashMap<String,Object>>>(){
  }
.getType()));
}","@Override public List<KVDocument> createListFromJson(String json){
  return converter.convert((List<Map<String,Object>>)gson.fromJson(json,type));
}"
54528,"@Override public List<KVDocument> createListFrom(InputStream is){
  try {
    return converter.convert((List<Map<String,Object>>)mapper.readValue(is,new TypeReference<List<HashMap<String,Object>>>(){
    }
));
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","@Override public List<KVDocument> createListFrom(InputStream is){
  try {
    return converter.convert((List<Map<String,Object>>)mapper.readValue(is,typeReference));
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}"
54529,"@Override public List<KVDocument> createListFromJson(String json){
  try {
    return converter.convert((List<Map<String,Object>>)mapper.readValue(json,new TypeReference<List<HashMap<String,Object>>>(){
    }
));
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"" + json);
  }
}","@Override public List<KVDocument> createListFromJson(String json){
  try {
    return converter.convert((List<Map<String,Object>>)mapper.readValue(json,typeReference));
  }
 catch (  IOException e) {
    throw new RuntimeException(""String_Node_Str"" + json);
  }
}"
54530,"@Override protected void shutDown() throws Exception {
  writeDataSource.close();
  systemDataSource.close();
  readOnlyDataSource.close();
}","@Override @SuppressFBWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") protected void shutDown() throws Exception {
  writeDataSource.close();
  systemDataSource.close();
  readOnlyDataSource.close();
}"
54531,"@Override public byte[] get(ResultSet resultSet,int columnIndex) throws SQLException {
  byte[] value=resultSet.getBytes(columnIndex);
  if (resultSet.wasNull()) {
    return null;
  }
  return value;
}","@Override @SuppressFBWarnings(value=""String_Node_Str"",justification=""String_Node_Str"") public byte[] get(ResultSet resultSet,int columnIndex) throws SQLException {
  byte[] value=resultSet.getBytes(columnIndex);
  if (resultSet.wasNull()) {
    return null;
  }
  return value;
}"
54532,"private static String sqlMessage(DataAccessException cause){
  if (cause.getCause() instanceof SQLException) {
    return sqlMessage((SQLException)cause.getCause());
  }
  return cause.getMessage();
}","private static String sqlMessage(DataAccessException cause){
  Throwable causeThroawle=cause.getCause();
  if (causeThroawle instanceof SQLException) {
    return sqlMessage((SQLException)causeThroawle);
  }
  return cause.getMessage();
}"
54533,"protected void executeSql(DSLContext dsl,String resourcePath,SqlHelper sqlHelper) throws IOException, SQLException {
  InputStream resourceAsStream=getClass().getResourceAsStream(resourcePath);
  if (resourceAsStream == null) {
    throw new SystemException(""String_Node_Str"" + resourcePath + ""String_Node_Str"");
  }
  try {
    String statementAsString=CharStreams.toString(new BufferedReader(new InputStreamReader(resourceAsStream,Charset.forName(""String_Node_Str""))));
    sqlHelper.executeStatement(dsl,statementAsString,Context.UNKNOWN);
  }
  finally {
    resourceAsStream.close();
  }
}","protected void executeSql(DSLContext dsl,String resourcePath,SqlHelper sqlHelper) throws IOException, SQLException {
  InputStream resourceAsStream=getClass().getClassLoader().getResourceAsStream(resourcePath);
  if (resourceAsStream == null) {
    throw new SystemException(""String_Node_Str"" + resourcePath + ""String_Node_Str"");
  }
  try {
    String statementAsString=CharStreams.toString(new BufferedReader(new InputStreamReader(resourceAsStream,Charset.forName(""String_Node_Str""))));
    sqlHelper.executeStatement(dsl,statementAsString,Context.UNKNOWN);
  }
  finally {
    resourceAsStream.close();
  }
}"
54534,"@Override public void deleteDids(MetaDatabase db,MetaCollection col,Collection<Integer> dids){
  Preconditions.checkState(!isClosed(),""String_Node_Str"");
  getSqlInterface().getWriteInterface().deleteCollectionDocParts(getDsl(),db.getIdentifier(),col,dids);
}","@Override public void deleteDids(MetaDatabase db,MetaCollection col,Collection<Integer> dids){
  Preconditions.checkState(!isClosed(),""String_Node_Str"");
  if (dids.isEmpty()) {
    return;
  }
  getSqlInterface().getWriteInterface().deleteCollectionDocParts(getDsl(),db.getIdentifier(),col,dids);
}"
54535,"@Locked(exclusive=true) private void loadState() throws OplogManagerPersistException {
  Status<? extends Object> result=retrier.retry(() -> {
    try (ReadOnlyMongodTransaction transaction=connection.openReadOnlyTransaction()){
      Status<FindResult> status=transaction.execute(new Request(OPLOG_DB,null,true,null),FindCommand.INSTANCE,new FindArgument.Builder().setComment(OPLOG_COL).setSlaveOk(true).build());
      if (!status.isOK()) {
        return status;
      }
      Iterator<BsonDocument> batch=status.getResult().getCursor().getFirstBatch();
      if (!batch.hasNext()) {
        lastAppliedHash=0;
        lastAppliedOpTime=OpTime.EPOCH;
      }
 else {
        BsonDocument doc=batch.next();
        BsonDocument subDoc=BsonReaderTool.getDocument(doc,KEY);
        lastAppliedHash=BsonReaderTool.getLong(subDoc,""String_Node_Str"");
        BsonDocument opTimeDoc=BsonReaderTool.getDocument(subDoc,""String_Node_Str"");
        lastAppliedOpTime=new OpTime(UnsignedInteger.valueOf(BsonReaderTool.getLong(opTimeDoc,""String_Node_Str"")),UnsignedInteger.valueOf(BsonReaderTool.getLong(opTimeDoc,""String_Node_Str"")));
      }
      return Status.ok();
    }
 catch (    MongoException ex) {
      return Status.from(ex);
    }
  }
);
  if (!result.isOK()) {
    throw new OplogManagerPersistException(result);
  }
}","@Locked(exclusive=true) private void loadState() throws OplogManagerPersistException {
  Status<? extends Object> result=retrier.retry(() -> {
    try (ReadOnlyMongodTransaction transaction=connection.openReadOnlyTransaction()){
      Status<FindResult> status=transaction.execute(new Request(OPLOG_DB,null,true,null),FindCommand.INSTANCE,new FindArgument.Builder().setComment(OPLOG_COL).setSlaveOk(true).build());
      if (!status.isOK()) {
        return status;
      }
      Iterator<BsonDocument> batch=status.getResult().getCursor().getFirstBatch();
      if (!batch.hasNext()) {
        lastAppliedHash=0;
        lastAppliedOpTime=OpTime.EPOCH;
      }
 else {
        BsonDocument doc=batch.next();
        BsonDocument subDoc=BsonReaderTool.getDocument(doc,KEY);
        lastAppliedHash=BsonReaderTool.getLong(subDoc,""String_Node_Str"");
        BsonDocument opTimeDoc=BsonReaderTool.getDocument(subDoc,""String_Node_Str"");
        lastAppliedOpTime=new OpTime(UnsignedInteger.valueOf(BsonReaderTool.getLong(opTimeDoc,""String_Node_Str"")),UnsignedInteger.valueOf(BsonReaderTool.getLong(opTimeDoc,""String_Node_Str"")));
      }
      return Status.ok();
    }
 catch (    MongoException ex) {
      return Status.from(ex);
    }
  }
);
  if (!result.isOK()) {
    throw new OplogManagerPersistException(result.getErrorCode(),result.getErrorMsg());
  }
}"
54536,"public OplogManagerPersistException(Status<?> originalStatus){
  this.originalStatus=originalStatus;
}","public OplogManagerPersistException(ErrorCode errorCode,String errorMsg){
  this.errorCode=errorCode;
  this.errorMsg=errorMsg;
}"
54537,"@Locked(exclusive=true) private void storeState(long hash,OpTime opTime) throws OplogManagerPersistException {
  Preconditions.checkState(isRunning(),""String_Node_Str"");
  Status<?> result=retrier.retry(() -> {
    try (WriteMongodTransaction transaction=connection.openWriteTransaction()){
      Status<Long> deleteResult=transaction.execute(new Request(OPLOG_DB,null,true,null),DeleteCommand.INSTANCE,new DeleteArgument.Builder(OPLOG_COL).addStatement(new DeleteStatement(DOC_QUERY,false)).build());
      if (!deleteResult.isOK()) {
        return deleteResult;
      }
      Status<InsertResult> insertResult=transaction.execute(new Request(""String_Node_Str"",null,true,null),InsertCommand.INSTANCE,new InsertArgument.Builder(""String_Node_Str"").addDocument(new BsonDocumentBuilder().appendUnsafe(KEY,new BsonDocumentBuilder().appendUnsafe(""String_Node_Str"",newLong(hash)).appendUnsafe(""String_Node_Str"",new BsonDocumentBuilder().appendUnsafe(""String_Node_Str"",newLong(opTime.getSecs().longValue())).appendUnsafe(""String_Node_Str"",newLong(opTime.getTerm().longValue())).build()).build()).build()).build());
      if (insertResult.isOK() && insertResult.getResult().getN() != 1) {
        return Status.from(ErrorCode.OPERATION_FAILED,""String_Node_Str"");
      }
      return insertResult;
    }
   }
);
  if (!result.isOK()) {
    throw new OplogManagerPersistException(result);
  }
}","@Locked(exclusive=true) private void storeState(long hash,OpTime opTime) throws OplogManagerPersistException {
  Preconditions.checkState(isRunning(),""String_Node_Str"");
  Status<?> result=retrier.retry(() -> {
    try (WriteMongodTransaction transaction=connection.openWriteTransaction()){
      Status<Long> deleteResult=transaction.execute(new Request(OPLOG_DB,null,true,null),DeleteCommand.INSTANCE,new DeleteArgument.Builder(OPLOG_COL).addStatement(new DeleteStatement(DOC_QUERY,false)).build());
      if (!deleteResult.isOK()) {
        return deleteResult;
      }
      Status<InsertResult> insertResult=transaction.execute(new Request(""String_Node_Str"",null,true,null),InsertCommand.INSTANCE,new InsertArgument.Builder(""String_Node_Str"").addDocument(new BsonDocumentBuilder().appendUnsafe(KEY,new BsonDocumentBuilder().appendUnsafe(""String_Node_Str"",newLong(hash)).appendUnsafe(""String_Node_Str"",new BsonDocumentBuilder().appendUnsafe(""String_Node_Str"",newLong(opTime.getSecs().longValue())).appendUnsafe(""String_Node_Str"",newLong(opTime.getTerm().longValue())).build()).build()).build()).build());
      if (insertResult.isOK() && insertResult.getResult().getN() != 1) {
        return Status.from(ErrorCode.OPERATION_FAILED,""String_Node_Str"");
      }
      return insertResult;
    }
   }
);
  if (!result.isOK()) {
    throw new OplogManagerPersistException(result.getErrorCode(),result.getErrorMsg());
  }
}"
54538,"private void cloneDatabases(@Nonnull MongoConnection remoteConnection) throws CloningException, MongoException {
  ListDatabasesReply databasesReply=remoteConnection.execute(ListDatabasesCommand.INSTANCE,""String_Node_Str"",true,Empty.getInstance());
  CompletionService<?> completionService=new ExecutorCompletionService<>(ForkJoinPool.commonPool());
  for (  DatabaseEntry database : databasesReply.getDatabases()) {
    String databaseName=database.getName();
    if (isNotReplicable(databaseName)) {
      continue;
    }
    MyWritePermissionSupplier writePermissionSupplier=new MyWritePermissionSupplier(databaseName);
    CloneOptions options=new CloneOptions(true,false,true,false,databaseName,Collections.<String>emptySet(),writePermissionSupplier);
    completionService.submit(() -> {
      try (MongodConnection conn=server.openConnection();WriteMongodTransaction trans=conn.openWriteTransaction()){
        cloner.cloneDatabase(databaseName,remoteConnection,trans,options);
        trans.commit();
        return null;
      }
     }
);
  }
  for (  DatabaseEntry database : databasesReply.getDatabases()) {
    if (isNotReplicable(database.getName())) {
      continue;
    }
    try {
      completionService.take().get();
    }
 catch (    InterruptedException ex) {
      Thread.currentThread().interrupt();
      throw new CloningException(""String_Node_Str"",ex);
    }
catch (    ExecutionException ex) {
      if (ex.getCause() instanceof MongoException) {
        throw (MongoException)ex.getCause();
      }
 else {
        throw new CloningException(""String_Node_Str"",ex);
      }
    }
  }
}","private void cloneDatabases(@Nonnull MongoConnection remoteConnection) throws CloningException, MongoException {
  ListDatabasesReply databasesReply=remoteConnection.execute(ListDatabasesCommand.INSTANCE,""String_Node_Str"",true,Empty.getInstance());
  CompletionService<?> completionService=new ExecutorCompletionService<>(ForkJoinPool.commonPool());
  for (  DatabaseEntry database : databasesReply.getDatabases()) {
    String databaseName=database.getName();
    if (isNotReplicable(databaseName)) {
      continue;
    }
    MyWritePermissionSupplier writePermissionSupplier=new MyWritePermissionSupplier(databaseName);
    CloneOptions options=new CloneOptions(true,false,true,false,databaseName,Collections.<String>emptySet(),writePermissionSupplier);
    completionService.submit(() -> {
      try (MongodConnection conn=server.openConnection();WriteMongodTransaction trans=conn.openWriteTransaction()){
        cloner.cloneDatabase(databaseName,remoteConnection,trans,options);
        trans.commit();
        return null;
      }
     }
);
  }
  for (  DatabaseEntry database : databasesReply.getDatabases()) {
    if (isNotReplicable(database.getName())) {
      continue;
    }
    try {
      completionService.take().get();
    }
 catch (    InterruptedException ex) {
      Thread.currentThread().interrupt();
      throw new CloningException(""String_Node_Str"",ex);
    }
catch (    ExecutionException ex) {
      Throwable cause=ex.getCause();
      if (cause instanceof MongoException) {
        throw (MongoException)cause;
      }
 else {
        throw new CloningException(""String_Node_Str"",ex);
      }
    }
  }
}"
54539,"public static void main(String[] args) throws Exception {
  Console console=JCommander.getConsole();
  Log4jUtils.setRootLevel(LogLevel.NONE);
  ResourceBundle cliBundle=PropertyResourceBundle.getBundle(""String_Node_Str"");
  final CliConfig cliConfig=new CliConfig();
  JCommander jCommander=new JCommander(cliConfig,cliBundle,args);
  jCommander.setColumnSize(Integer.MAX_VALUE);
  if (cliConfig.isHelp()) {
    jCommander.usage();
    System.exit(0);
  }
  if (cliConfig.isHelpParam()) {
    console.println(cliBundle.getString(""String_Node_Str""));
    ConfigUtils.printParamDescriptionFromConfigSchema(console,0);
    System.exit(0);
  }
  final Config config=CliConfigUtils.readConfig(cliConfig);
  if (cliConfig.isPrintConfig()) {
    ConfigUtils.printYamlConfig(config,console);
    System.exit(0);
  }
  if (cliConfig.isPrintXmlConfig()) {
    ConfigUtils.printXmlConfig(config,console);
    System.exit(0);
  }
  if (config.getGeneric().getLog4j2File() != null) {
    Log4jUtils.reconfigure(config.getGeneric().getLog4j2File());
  }
 else {
    Log4jUtils.setRootLevel(config.getGeneric().getLogLevel());
    if (config.getGeneric().getLogPackages() != null) {
      Log4jUtils.setLogPackages(config.getGeneric().getLogPackages());
    }
    if (config.getGeneric().getLogFile() != null) {
      Log4jUtils.appendToLogFile(config.getGeneric().getLogFile());
    }
  }
  ConfigUtils.parseToropassFile(config);
  if (config.getBackend().isPostgresLike()) {
    Postgres postgres=config.getBackend().asPostgres();
    if (cliConfig.isAskForPassword()) {
      console.print(""String_Node_Str"");
      postgres.setPassword(readPwd());
    }
  }
  try {
    Clock clock=Clock.systemDefaultZone();
    Service server;
    if (config.getProtocol().getMongo().getReplication().isEmpty()) {
      ToroDbServer toroDbServer=ToroDbServer.create(config,clock);
      toroDbServer.startAsync();
      toroDbServer.awaitRunning();
      server=toroDbServer;
    }
 else {
      ToroDbiServer toroDbiServer=ToroDbiServer.create(config,clock);
      toroDbiServer.startAsync();
      toroDbiServer.awaitTerminated();
      server=toroDbiServer;
    }
    Runtime.getRuntime().addShutdownHook(new Thread(() -> {
      server.stopAsync();
      server.awaitTerminated();
    }
));
  }
 catch (  CreationException ex) {
    ex.getErrorMessages().stream().forEach(m -> {
      if (m.getCause() != null)       LOGGER.error(m.getCause().getMessage());
 else       LOGGER.error(m.getMessage());
    }
);
    System.exit(1);
  }
catch (  Throwable ex) {
    LOGGER.error(""String_Node_Str"",ex);
    Throwable rootCause=Throwables.getRootCause(ex);
    String causeMessage=rootCause.getMessage();
    JCommander.getConsole().println(""String_Node_Str"" + causeMessage);
    System.exit(1);
  }
}","public static void main(String[] args) throws Exception {
  Console console=JCommander.getConsole();
  Log4jUtils.setRootLevel(LogLevel.NONE);
  ResourceBundle cliBundle=PropertyResourceBundle.getBundle(""String_Node_Str"");
  final CliConfig cliConfig=new CliConfig();
  JCommander jCommander=new JCommander(cliConfig,cliBundle,args);
  jCommander.setColumnSize(Integer.MAX_VALUE);
  if (cliConfig.isHelp()) {
    jCommander.usage();
    System.exit(0);
  }
  if (cliConfig.isHelpParam()) {
    console.println(cliBundle.getString(""String_Node_Str""));
    ConfigUtils.printParamDescriptionFromConfigSchema(console,0);
    System.exit(0);
  }
  final Config config=CliConfigUtils.readConfig(cliConfig);
  if (cliConfig.isPrintConfig()) {
    ConfigUtils.printYamlConfig(config,console);
    System.exit(0);
  }
  if (cliConfig.isPrintXmlConfig()) {
    ConfigUtils.printXmlConfig(config,console);
    System.exit(0);
  }
  if (config.getGeneric().getLog4j2File() != null) {
    Log4jUtils.reconfigure(config.getGeneric().getLog4j2File());
  }
 else {
    Log4jUtils.setRootLevel(config.getGeneric().getLogLevel());
    if (config.getGeneric().getLogPackages() != null) {
      Log4jUtils.setLogPackages(config.getGeneric().getLogPackages());
    }
    if (config.getGeneric().getLogFile() != null) {
      Log4jUtils.appendToLogFile(config.getGeneric().getLogFile());
    }
  }
  ConfigUtils.parseToropassFile(config);
  if (config.getBackend().isPostgresLike()) {
    Postgres postgres=config.getBackend().asPostgres();
    if (cliConfig.isAskForPassword()) {
      console.print(""String_Node_Str"");
      postgres.setPassword(readPwd());
    }
  }
  try {
    Clock clock=Clock.systemDefaultZone();
    Service server;
    if (config.getProtocol().getMongo().getReplication() == null || config.getProtocol().getMongo().getReplication().isEmpty()) {
      ToroDbServer toroDbServer=ToroDbServer.create(config,clock);
      toroDbServer.startAsync();
      toroDbServer.awaitRunning();
      server=toroDbServer;
    }
 else {
      ToroDbiServer toroDbiServer=ToroDbiServer.create(config,clock);
      toroDbiServer.startAsync();
      toroDbiServer.awaitTerminated();
      server=toroDbiServer;
    }
    Runtime.getRuntime().addShutdownHook(new Thread(() -> {
      server.stopAsync();
      server.awaitTerminated();
    }
));
  }
 catch (  CreationException ex) {
    ex.getErrorMessages().stream().forEach(m -> {
      if (m.getCause() != null)       LOGGER.error(m.getCause().getMessage());
 else       LOGGER.error(m.getMessage());
    }
);
    System.exit(1);
  }
catch (  Throwable ex) {
    LOGGER.error(""String_Node_Str"",ex);
    Throwable rootCause=Throwables.getRootCause(ex);
    String causeMessage=rootCause.getMessage();
    JCommander.getConsole().println(""String_Node_Str"" + causeMessage);
    System.exit(1);
  }
}"
54540,"@Override public KVDocument createFrom(InputStream is){
  return converter.convert(gson.fromJson(new InputStreamReader(is),new HashMap<String,Object>().getClass()));
}","@Override public KVDocument createFrom(InputStream is){
  return converter.convert(gson.fromJson(new InputStreamReader(is,Charsets.UTF_8),sampleClass.getClass()));
}"
54541,"@Override public KVDocument createFromJson(String json){
  return converter.convert(gson.fromJson(json,new HashMap<String,Object>().getClass()));
}","@Override public KVDocument createFromJson(String json){
  return converter.convert(gson.fromJson(json,sampleClass.getClass()));
}"
54542,"@Override public List<KVDocument> createListFrom(InputStream is){
  return converter.convert((List<Map<String,Object>>)gson.fromJson(new InputStreamReader(is),new TypeToken<List<HashMap<String,Object>>>(){
  }
.getType()));
}","@Override public List<KVDocument> createListFrom(InputStream is){
  return converter.convert((List<Map<String,Object>>)gson.fromJson(new InputStreamReader(is,Charsets.UTF_8),new TypeToken<List<HashMap<String,Object>>>(){
  }
.getType()));
}"
54543,"private boolean isSpecialObject(Map<String,Object> map){
  if (map != null && map.keySet().size() == 1) {
    String key=map.keySet().iterator().next();
    if (key.startsWith(""String_Node_Str"") && map.get(key) != null) {
      return true;
    }
  }
  return false;
}","private boolean isSpecialObject(Map<String,Object> map){
  if (map != null && map.entrySet().size() == 1) {
    Entry<String,Object> next=map.entrySet().iterator().next();
    String key=next.getKey();
    Object value=next.getValue();
    if (key.startsWith(""String_Node_Str"") && value != null) {
      return true;
    }
  }
  return false;
}"
54544,"private KVValue<?> buildSpecialObject(Map<String,Object> map){
  String key=map.keySet().iterator().next();
  Object value=map.get(key);
  if (""String_Node_Str"".equals(key) && value instanceof String) {
    return new ByteArrayKVMongoObjectId(HexUtils.hex2Bytes((String)value));
  }
  if (""String_Node_Str"".equals(key)) {
    return parseDate(key,value);
  }
  throw new RuntimeException(""String_Node_Str"" + key);
}","private KVValue<?> buildSpecialObject(Map<String,Object> map){
  Entry<String,Object> first=map.entrySet().iterator().next();
  String key=first.getKey();
  Object value=first.getValue();
  if (""String_Node_Str"".equals(key) && value instanceof String) {
    return new ByteArrayKVMongoObjectId(HexUtils.hex2Bytes((String)value));
  }
  if (""String_Node_Str"".equals(key)) {
    return parseDate(key,value);
  }
  throw new RuntimeException(""String_Node_Str"" + key);
}"
54545,"@Benchmark @Fork(value=5) @BenchmarkMode(value=Mode.Throughput) @Warmup(iterations=3) @Measurement(iterations=10) public void benchmarkTranslate(TranslateState state,Blackhole blackhole){
  MvccMetainfoRepository mvccMetainfoRepository=new MvccMetainfoRepository(InitialView);
  MutableMetaSnapshot mutableSnapshot;
  try (SnapshotStage snapshot=mvccMetainfoRepository.startSnapshotStage()){
    mutableSnapshot=snapshot.createMutableSnapshot();
  }
   MutableMetaDatabase db=mutableSnapshot.getMetaDatabaseByName(DB1);
  D2RTranslator translator=new D2RTranslatorStack(tableRefFactory,identifierFactory,ridGenerator,db,db.getMetaCollectionByName(COLL1));
  for (  KVDocument doc : state.document) {
    translator.translate(doc);
  }
  blackhole.consume(translator.getCollectionDataAccumulator());
}","@Benchmark @Fork(value=5) @BenchmarkMode(value=Mode.Throughput) @Warmup(iterations=3) @Measurement(iterations=10) public void benchmarkTranslate(TranslateState state,Blackhole blackhole){
  MvccMetainfoRepository mvccMetainfoRepository=new MvccMetainfoRepository(initialView);
  MutableMetaSnapshot mutableSnapshot;
  try (SnapshotStage snapshot=mvccMetainfoRepository.startSnapshotStage()){
    mutableSnapshot=snapshot.createMutableSnapshot();
  }
   MutableMetaDatabase db=mutableSnapshot.getMetaDatabaseByName(DB1);
  D2RTranslator translator=new D2RTranslatorStack(tableRefFactory,identifierFactory,ridGenerator,db,db.getMetaCollectionByName(COLL1));
  for (  KVDocument doc : state.document) {
    translator.translate(doc);
  }
  blackhole.consume(translator.getCollectionDataAccumulator());
}"
54546,"public static void main(String[] args) throws IOException {
  MvccMetainfoRepository mvccMetainfoRepository=new MvccMetainfoRepository(InitialView);
  TableRefFactory tableRefFactory=new TableRefFactoryImpl();
  RidGenerator ridGenerator=new InMemoryRidGenerator();
  IdentifierFactory identifierFactory=new IdentifierFactoryImpl(new MockIdentifierInterface());
  AtomicLong cont=new AtomicLong(0);
  Stopwatch toroTimer=Stopwatch.createUnstarted();
  JsonArchiveFeed feed=new JsonArchiveFeed(""String_Node_Str"");
  feed.getGroupedFeedForLines(line -> line.length() < 1024,50).forEach(docStream -> {
    toroTimer.start();
    executeMetaOperation(mvccMetainfoRepository,(mutableSnapshot) -> {
      MutableMetaDatabase db=mutableSnapshot.getMetaDatabaseByName(DB1);
      D2RTranslator translator=new D2RTranslatorStack(tableRefFactory,identifierFactory,ridGenerator,db,db.getMetaCollectionByName(COLL1));
      docStream.forEach(doc -> {
        translator.translate(doc);
      }
);
      for (      DocPartData table : translator.getCollectionDataAccumulator().orderedDocPartData()) {
        cont.addAndGet(table.rowCount());
      }
    }
);
    toroTimer.stop();
  }
);
  double tt=(double)toroTimer.elapsed(TimeUnit.MICROSECONDS);
  System.out.println(""String_Node_Str"" + feed.datasize / (1024 * 1024) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + feed.documents);
  System.out.println(""String_Node_Str"" + cont);
  System.out.println(""String_Node_Str"" + tt + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + (tt / feed.documents) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + ((feed.documents / tt) * 1000000) + ""String_Node_Str"");
}","public static void main(String[] args) throws IOException {
  MvccMetainfoRepository mvccMetainfoRepository=new MvccMetainfoRepository(initialView);
  TableRefFactory tableRefFactory=new TableRefFactoryImpl();
  RidGenerator ridGenerator=new InMemoryRidGenerator();
  IdentifierFactory identifierFactory=new IdentifierFactoryImpl(new MockIdentifierInterface());
  AtomicLong cont=new AtomicLong(0);
  Stopwatch toroTimer=Stopwatch.createUnstarted();
  JsonArchiveFeed feed=new JsonArchiveFeed(""String_Node_Str"");
  feed.getGroupedFeedForLines(line -> line.length() < 1024,50).forEach(docStream -> {
    toroTimer.start();
    executeMetaOperation(mvccMetainfoRepository,(mutableSnapshot) -> {
      MutableMetaDatabase db=mutableSnapshot.getMetaDatabaseByName(DB1);
      D2RTranslator translator=new D2RTranslatorStack(tableRefFactory,identifierFactory,ridGenerator,db,db.getMetaCollectionByName(COLL1));
      docStream.forEach(doc -> {
        translator.translate(doc);
      }
);
      for (      DocPartData table : translator.getCollectionDataAccumulator().orderedDocPartData()) {
        cont.addAndGet(table.rowCount());
      }
    }
);
    toroTimer.stop();
  }
);
  double tt=(double)toroTimer.elapsed(TimeUnit.MICROSECONDS);
  System.out.println(""String_Node_Str"" + feed.datasize / (1024 * 1024) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + feed.documents);
  System.out.println(""String_Node_Str"" + cont);
  System.out.println(""String_Node_Str"" + tt + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + (tt / feed.documents) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + ((feed.documents / tt) * 1000000) + ""String_Node_Str"");
}"
54547,"public static void main(String[] args) throws IOException {
  MvccMetainfoRepository mvccMetainfoRepository=new MvccMetainfoRepository(InitialView);
  TableRefFactory tableRefFactory=new TableRefFactoryImpl();
  RidGenerator ridGenerator=new InMemoryRidGenerator();
  IdentifierFactory identifierFactory=new IdentifierFactoryImpl(new MockIdentifierInterface());
  AtomicLong cont=new AtomicLong(0);
  Stopwatch toroTimer=Stopwatch.createUnstarted();
  JsonArchiveFeed feed=new JsonArchiveFeed(""String_Node_Str"");
  feed.getGroupedFeedForFiles((f) -> f.getName().startsWith(""String_Node_Str""),50).forEach(docStream -> {
    toroTimer.start();
    executeMetaOperation(mvccMetainfoRepository,(mutableSnapshot) -> {
      MutableMetaDatabase db=mutableSnapshot.getMetaDatabaseByName(DB1);
      D2RTranslator translator=new D2RTranslatorStack(tableRefFactory,identifierFactory,ridGenerator,db,db.getMetaCollectionByName(COLL1));
      docStream.forEach(doc -> {
        translator.translate(doc);
      }
);
      for (      DocPartData table : translator.getCollectionDataAccumulator().orderedDocPartData()) {
        cont.addAndGet(table.rowCount());
      }
    }
);
    toroTimer.stop();
  }
);
  double tt=(double)toroTimer.elapsed(TimeUnit.MICROSECONDS);
  System.out.println(""String_Node_Str"" + feed.datasize / (1024 * 1024) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + feed.documents);
  System.out.println(""String_Node_Str"" + cont);
  System.out.println(""String_Node_Str"" + tt + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + (tt / feed.documents) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + ((feed.documents / tt) * 1000000) + ""String_Node_Str"");
}","public static void main(String[] args) throws IOException {
  MvccMetainfoRepository mvccMetainfoRepository=new MvccMetainfoRepository(initialView);
  TableRefFactory tableRefFactory=new TableRefFactoryImpl();
  RidGenerator ridGenerator=new InMemoryRidGenerator();
  IdentifierFactory identifierFactory=new IdentifierFactoryImpl(new MockIdentifierInterface());
  AtomicLong cont=new AtomicLong(0);
  Stopwatch toroTimer=Stopwatch.createUnstarted();
  JsonArchiveFeed feed=new JsonArchiveFeed(""String_Node_Str"");
  feed.getGroupedFeedForFiles((f) -> f.getName().startsWith(""String_Node_Str""),50).forEach(docStream -> {
    toroTimer.start();
    executeMetaOperation(mvccMetainfoRepository,(mutableSnapshot) -> {
      MutableMetaDatabase db=mutableSnapshot.getMetaDatabaseByName(DB1);
      D2RTranslator translator=new D2RTranslatorStack(tableRefFactory,identifierFactory,ridGenerator,db,db.getMetaCollectionByName(COLL1));
      docStream.forEach(doc -> {
        translator.translate(doc);
      }
);
      for (      DocPartData table : translator.getCollectionDataAccumulator().orderedDocPartData()) {
        cont.addAndGet(table.rowCount());
      }
    }
);
    toroTimer.stop();
  }
);
  double tt=(double)toroTimer.elapsed(TimeUnit.MICROSECONDS);
  System.out.println(""String_Node_Str"" + feed.datasize / (1024 * 1024) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + feed.documents);
  System.out.println(""String_Node_Str"" + cont);
  System.out.println(""String_Node_Str"" + tt + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + (tt / feed.documents) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + ((feed.documents / tt) * 1000000) + ""String_Node_Str"");
}"
54548,"public static void main(String[] args){
  MvccMetainfoRepository mvccMetainfoRepository=new MvccMetainfoRepository(InitialView);
  AtomicLong cont=new AtomicLong(0);
  Stopwatch timer=Stopwatch.createUnstarted();
  SimpleDocumentFeed feed=new SimpleDocumentFeed(1000000);
  feed.getFeed(""String_Node_Str"").forEach(doc -> {
    timer.start();
    executeMetaOperation(mvccMetainfoRepository,(mutableSnapshot) -> {
      MutableMetaDatabase db=mutableSnapshot.getMetaDatabaseByName(DB1);
      D2RTranslator translator=new D2RTranslatorStack(new TableRefFactoryImpl(),new IdentifierFactoryImpl(new MockIdentifierInterface()),new InMemoryRidGenerator(),db,db.getMetaCollectionByName(COLL1));
      translator.translate(doc);
      for (      DocPartData table : translator.getCollectionDataAccumulator().orderedDocPartData()) {
        cont.addAndGet(table.rowCount());
      }
    }
);
    timer.stop();
  }
);
  long elapsed=timer.elapsed(TimeUnit.MICROSECONDS);
  System.out.println(""String_Node_Str"" + feed.datasize / (1024 * 1024) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + feed.documents);
  System.out.println(""String_Node_Str"" + cont);
  System.out.println(""String_Node_Str"" + elapsed + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + ((double)elapsed / feed.documents) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + (feed.documents / (double)elapsed * 1000000) + ""String_Node_Str"");
}","public static void main(String[] args){
  MvccMetainfoRepository mvccMetainfoRepository=new MvccMetainfoRepository(initialView);
  AtomicLong cont=new AtomicLong(0);
  Stopwatch timer=Stopwatch.createUnstarted();
  SimpleDocumentFeed feed=new SimpleDocumentFeed(1000000);
  feed.getFeed(""String_Node_Str"").forEach(doc -> {
    timer.start();
    executeMetaOperation(mvccMetainfoRepository,(mutableSnapshot) -> {
      MutableMetaDatabase db=mutableSnapshot.getMetaDatabaseByName(DB1);
      D2RTranslator translator=new D2RTranslatorStack(new TableRefFactoryImpl(),new IdentifierFactoryImpl(new MockIdentifierInterface()),new InMemoryRidGenerator(),db,db.getMetaCollectionByName(COLL1));
      translator.translate(doc);
      for (      DocPartData table : translator.getCollectionDataAccumulator().orderedDocPartData()) {
        cont.addAndGet(table.rowCount());
      }
    }
);
    timer.stop();
  }
);
  long elapsed=timer.elapsed(TimeUnit.MICROSECONDS);
  System.out.println(""String_Node_Str"" + feed.datasize / (1024 * 1024) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + feed.documents);
  System.out.println(""String_Node_Str"" + cont);
  System.out.println(""String_Node_Str"" + elapsed + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + ((double)elapsed / feed.documents) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + (feed.documents / (double)elapsed * 1000000) + ""String_Node_Str"");
}"
54549,"private static String getDocument(String name){
  try (InputStream is=SimpleDocumentFeed.class.getClassLoader().getResourceAsStream(name)){
    try (BufferedReader reader=new BufferedReader(new InputStreamReader(is))){
      StringBuffer sb=new StringBuffer();
      String line=null;
      while ((line=reader.readLine()) != null) {
        sb.append(line);
      }
      return sb.toString();
    }
   }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
}","private static String getDocument(String name){
  try (InputStream is=SimpleDocumentFeed.class.getClassLoader().getResourceAsStream(name)){
    try (BufferedReader reader=new BufferedReader(new InputStreamReader(is,Charsets.UTF_8))){
      StringBuffer sb=new StringBuffer();
      String line=null;
      while ((line=reader.readLine()) != null) {
        sb.append(line);
      }
      return sb.toString();
    }
   }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
}"
54550,"@Override public DataSource getConfiguredDataSource(DerbyDbBackendConfiguration configuration,String poolName){
  DataSource dataSource;
  if (configuration.embedded()) {
    EmbeddedDataSource embeddedDataSource=new EmbeddedDataSource();
    embeddedDataSource.setCreateDatabase(""String_Node_Str"");
    if (configuration.inMemory()) {
      embeddedDataSource.setDatabaseName(""String_Node_Str"" + configuration.getDbName());
    }
 else {
      embeddedDataSource.setDatabaseName(configuration.getDbName());
    }
    try {
      embeddedDataSource.getConnection();
    }
 catch (    SQLException ex) {
      throw new SystemException(ex);
    }
    embeddedDataSource.setCreateDatabase(null);
    dataSource=embeddedDataSource;
  }
 else {
    ClientDataSource clientDataSource=new ClientDataSource();
    clientDataSource.setServerName(configuration.getDbHost());
    clientDataSource.setPortNumber(configuration.getDbPort());
    clientDataSource.setUser(configuration.getUsername());
    clientDataSource.setPassword(configuration.getPassword());
    if (configuration.inMemory()) {
      clientDataSource.setDatabaseName(""String_Node_Str"" + configuration.getDbName());
    }
 else {
      clientDataSource.setDatabaseName(configuration.getDbName());
    }
    dataSource=clientDataSource;
  }
  if (LOGGER.isTraceEnabled()) {
    try {
      dataSource.setLogWriter(LOGGER_WRITER);
    }
 catch (    SQLException sqlException) {
      throw new SystemException(sqlException);
    }
  }
  Statement stat=null;
  ResultSet rs=null;
  Connection conn=null;
  try {
    conn=dataSource.getConnection();
    stat=conn.createStatement();
    rs=stat.executeQuery(""String_Node_Str"");
    rs.next();
  }
 catch (  SQLException ex) {
    throw new SystemException(ex);
  }
 finally {
    try {
      if (rs != null)       rs.close();
    }
 catch (    SQLException ex) {
    }
    try {
      if (stat != null)       stat.close();
    }
 catch (    SQLException ex) {
    }
    try {
      if (conn != null)       conn.close();
    }
 catch (    SQLException ex) {
    }
  }
  return dataSource;
}","@Override public DataSource getConfiguredDataSource(DerbyDbBackendConfiguration configuration,String poolName){
  DataSource dataSource;
  if (configuration.embedded()) {
    EmbeddedDataSource embeddedDataSource=new EmbeddedDataSource();
    embeddedDataSource.setCreateDatabase(""String_Node_Str"");
    if (configuration.inMemory()) {
      embeddedDataSource.setDatabaseName(""String_Node_Str"" + configuration.getDbName());
    }
 else {
      embeddedDataSource.setDatabaseName(configuration.getDbName());
    }
    try (Connection connection=embeddedDataSource.getConnection()){
      LOGGER.debug(""String_Node_Str"");
    }
 catch (    SQLException ex) {
      throw new SystemException(ex);
    }
    embeddedDataSource.setCreateDatabase(null);
    dataSource=embeddedDataSource;
  }
 else {
    ClientDataSource clientDataSource=new ClientDataSource();
    clientDataSource.setServerName(configuration.getDbHost());
    clientDataSource.setPortNumber(configuration.getDbPort());
    clientDataSource.setUser(configuration.getUsername());
    clientDataSource.setPassword(configuration.getPassword());
    if (configuration.inMemory()) {
      clientDataSource.setDatabaseName(""String_Node_Str"" + configuration.getDbName());
    }
 else {
      clientDataSource.setDatabaseName(configuration.getDbName());
    }
    dataSource=clientDataSource;
  }
  if (LOGGER.isTraceEnabled()) {
    try {
      dataSource.setLogWriter(LOGGER_WRITER);
    }
 catch (    SQLException sqlException) {
      throw new SystemException(sqlException);
    }
  }
  Statement stat=null;
  ResultSet rs=null;
  Connection conn=null;
  try {
    conn=dataSource.getConnection();
    stat=conn.createStatement();
    rs=stat.executeQuery(""String_Node_Str"");
    rs.next();
  }
 catch (  SQLException ex) {
    throw new SystemException(ex);
  }
 finally {
    try {
      if (rs != null)       rs.close();
    }
 catch (    SQLException ex) {
    }
    try {
      if (stat != null)       stat.close();
    }
 catch (    SQLException ex) {
    }
    try {
      if (conn != null)       conn.close();
    }
 catch (    SQLException ex) {
    }
  }
  return dataSource;
}"
54551,"private void ChainConverterFactory(NameConverterFactory... nameConverterFactories){
  this.converterFactories=nameConverterFactories;
}","private void ChainConverterFactory(NameConverter... nameConverterFactories){
  this.converters=createConverters(nameConverterFactories);
}"
54552,"private String generateUniqueIdentifier(NameChain nameChain,IdentifierChecker identifierChecker,String extraImmutableName){
  final Instant beginInstant=Instant.now();
  final int maxSize=identifierConstraints.identifierMaxSize();
  String lastCollision=null;
  ChainConverterFactory chainConverterFactory=ChainConverterFactory.straight;
  Counter counter=new Counter();
  String identifier=buildIdentifier(nameChain,chainConverterFactory.createConverters(),maxSize,counter,identifierChecker,extraImmutableName);
  if (identifier.length() <= maxSize && identifierChecker.isUnique(identifier)) {
    return identifier;
  }
  if (identifier.length() <= maxSize) {
    lastCollision=identifier;
  }
  ChainConverterFactory counterChainConverterFactory=ChainConverterFactory.counter;
  NameConverter[] randomConverters=counterChainConverterFactory.createConverters();
  while (ChronoUnit.SECONDS.between(beginInstant,Instant.now()) < MAX_GENERATION_TIME) {
    identifier=buildIdentifier(nameChain,randomConverters,maxSize,counter,identifierChecker,extraImmutableName);
    if (identifier.length() > maxSize) {
      throw new SystemException(""String_Node_Str"");
    }
    if (identifierChecker.isUnique(identifier)) {
      return identifier;
    }
    lastCollision=identifier;
    counter.increment();
  }
  if (lastCollision != null) {
    throw new SystemException(""String_Node_Str"" + lastCollision + ""String_Node_Str""+ nameChain);
  }
  throw new SystemException(""String_Node_Str"" + nameChain);
}","private String generateUniqueIdentifier(NameChain nameChain,IdentifierChecker identifierChecker,String extraImmutableName){
  final Instant beginInstant=Instant.now();
  final int maxSize=identifierConstraints.identifierMaxSize();
  String lastCollision=null;
  ChainConverterFactory straightConverterFactory=ChainConverterFactory.straight;
  Counter counter=new Counter();
  String identifier=buildIdentifier(nameChain,straightConverterFactory.getConverters(),maxSize,counter,identifierChecker,extraImmutableName);
  if (identifier.length() <= maxSize && identifierChecker.isUnique(identifier)) {
    return identifier;
  }
  if (identifier.length() <= maxSize) {
    lastCollision=identifier;
  }
  ChainConverterFactory counterChainConverterFactory=ChainConverterFactory.counter;
  NameConverter[] counterConverters=counterChainConverterFactory.getConverters();
  while (ChronoUnit.SECONDS.between(beginInstant,Instant.now()) < MAX_GENERATION_TIME) {
    identifier=buildIdentifier(nameChain,counterConverters,maxSize,counter,identifierChecker,extraImmutableName);
    if (identifier.length() > maxSize) {
      throw new SystemException(""String_Node_Str"");
    }
    if (identifierChecker.isUnique(identifier)) {
      return identifier;
    }
    lastCollision=identifier;
    counter.increment();
  }
  if (lastCollision != null) {
    throw new SystemException(""String_Node_Str"" + lastCollision + ""String_Node_Str""+ nameChain);
  }
  throw new SystemException(""String_Node_Str"" + nameChain);
}"
54553,"public NameConverter[] createConverters(){
  NameConverter[] converters=new NameConverter[3];
  converters[0]=converterFactories[0].create();
  converters[1]=converters[0];
  converters[2]=converters[0];
  if (converterFactories.length > 1) {
    if (converterFactories[0] == converterFactories[1]) {
      converters[1]=converters[0];
    }
 else {
      converters[1]=converterFactories[1].create();
    }
    converters[2]=converters[0];
  }
  if (converterFactories.length > 2) {
    if (converterFactories[0] == converterFactories[2]) {
      converters[2]=converters[0];
    }
 else     if (converterFactories[1] == converterFactories[2]) {
      converters[2]=converters[1];
    }
 else {
      converters[2]=converterFactories[2].create();
    }
  }
  return converters;
}","private NameConverter[] createConverters(NameConverter[] converterFactories){
  NameConverter[] converters=new NameConverter[3];
  converters[0]=converterFactories[0];
  converters[1]=converters[0];
  converters[2]=converters[0];
  if (converterFactories.length > 1) {
    if (converterFactories[0] == converterFactories[1]) {
      converters[1]=converters[0];
    }
 else {
      converters[1]=converterFactories[1];
    }
    converters[2]=converters[0];
  }
  if (converterFactories.length > 2) {
    if (converterFactories[0] == converterFactories[2]) {
      converters[2]=converters[0];
    }
 else     if (converterFactories[1] == converterFactories[2]) {
      converters[2]=converters[1];
    }
 else {
      converters[2]=converterFactories[2];
    }
  }
  return converters;
}"
54554,"private void addValueToDocPartRow(Map<Integer,Map<String,List<KVValue<?>>>> currentDocPartRow,TableRef tableRef,Integer pid,Integer seq,KVValue<?> value){
  if (seq == null) {
    setDocPartRowValue(currentDocPartRow,tableRef,pid,seq,ImmutableList.of(value));
  }
 else {
    addToDocPartRow(currentDocPartRow,tableRef,pid,seq,value);
  }
}","private void addValueToDocPartRow(Map<Integer,Map<String,List<KVValue<?>>>> currentDocPartRow,TableRef tableRef,Integer pid,Integer seq,KVValue<?> value){
  if (seq == null) {
    setDocPartRowValue(currentDocPartRow,tableRef,pid,null,ImmutableList.of(value));
  }
 else {
    addToDocPartRow(currentDocPartRow,tableRef,pid,seq,value);
  }
}"
54555,"@Override public R next(){
  idx++;
  return null;
}","@Override public R next(){
  if (hasNext()) {
    idx++;
    return null;
  }
  throw new NoSuchElementException();
}"
54556,"private static void escape(String nonEscaped,StringBuilder appender){
  if (!needsEscape(nonEscaped)) {
    appender.append(nonEscaped);
    return;
  }
  appender.ensureCapacity(nonEscaped.length() + 16);
  int lenght=nonEscaped.length();
  int i=0;
  while (i < lenght) {
    char c=nonEscaped.charAt(i);
switch (c) {
case ROW_DELIMETER:
case COLUMN_DELIMETER:
case '\\':
case '\r':
      appender.append('\\');
    break;
default :
}
appender.append(c);
i++;
}
}","private static void escape(String nonEscaped,StringBuilder appender){
  if (!needsEscape(nonEscaped)) {
    appender.append(nonEscaped);
    return;
  }
  appender.ensureCapacity(nonEscaped.length() + 16);
  int lenght=nonEscaped.length();
  int i=0;
  while (i < lenght) {
    char c=nonEscaped.charAt(i);
switch (c) {
case ROW_DELIMETER:
case COLUMN_DELIMETER:
case '\\':
case '\r':
      appender.append('\\');
    break;
default :
  break;
}
appender.append(c);
i++;
}
}"
54557,"public KVDocument build(){
  KVDocument updatedDocument;
  if (did != null) {
    updatedDocument=buildRoot();
  }
 else {
    updatedDocument=buildRoot();
  }
  clear();
  return updatedDocument;
}","public KVDocument build(){
  KVDocument updatedDocument;
  updatedDocument=buildRoot();
  clear();
  return updatedDocument;
}"
54558,"@Override public DidCursor getCollectionDidsWithFieldEqualsTo(DSLContext dsl,MetaDatabase metaDatabase,MetaCollection metaCol,MetaDocPart metaDocPart,MetaField metaField,KVValue<?> value) throws SQLException {
}","@Override @SuppressFBWarnings(value={""String_Node_Str"",""String_Node_Str""},justification=""String_Node_Str"") public DidCursor getCollectionDidsWithFieldEqualsTo(DSLContext dsl,MetaDatabase metaDatabase,MetaCollection metaCol,MetaDocPart metaDocPart,MetaField metaField,KVValue<?> value) throws SQLException {
}"
54559,"@Override public DocPartResultBatch getCollectionResultSets(DSLContext dsl,MetaDatabase metaDatabase,MetaCollection metaCollection,Collection<Integer> dids) throws SQLException {
  ArrayList<DocPartResult> result=new ArrayList<>();
  Connection connection=dsl.configuration().connectionProvider().acquire();
  try {
    Iterator<? extends MetaDocPart> metaDocPartIterator=metaCollection.streamContainedMetaDocParts().sorted(TableRefComparator.MetaDocPart.DESC).iterator();
    while (metaDocPartIterator.hasNext()) {
      MetaDocPart metaDocPart=metaDocPartIterator.next();
      String statament=getDocPartStatament(metaDatabase,metaDocPart,dids);
      PreparedStatement preparedStatement=connection.prepareStatement(statament);
      result.add(new ResultSetDocPartResult(metaDataReadInterface,dataTypeProvider,errorHandler,metaDocPart,preparedStatement.executeQuery(),sqlHelper));
    }
  }
  finally {
    dsl.configuration().connectionProvider().release(connection);
  }
  return new DocPartResultBatch(result);
}","@Override @SuppressFBWarnings(value={""String_Node_Str"",""String_Node_Str""},justification=""String_Node_Str"") public DocPartResultBatch getCollectionResultSets(DSLContext dsl,MetaDatabase metaDatabase,MetaCollection metaCollection,Collection<Integer> dids) throws SQLException {
  ArrayList<DocPartResult> result=new ArrayList<>();
  Connection connection=dsl.configuration().connectionProvider().acquire();
  try {
    Iterator<? extends MetaDocPart> metaDocPartIterator=metaCollection.streamContainedMetaDocParts().sorted(TableRefComparator.MetaDocPart.DESC).iterator();
    while (metaDocPartIterator.hasNext()) {
      MetaDocPart metaDocPart=metaDocPartIterator.next();
      String statament=getDocPartStatament(metaDatabase,metaDocPart,dids);
      PreparedStatement preparedStatement=connection.prepareStatement(statament);
      result.add(new ResultSetDocPartResult(metaDataReadInterface,dataTypeProvider,errorHandler,metaDocPart,preparedStatement.executeQuery(),sqlHelper));
    }
  }
  finally {
    dsl.configuration().connectionProvider().release(connection);
  }
  return new DocPartResultBatch(result);
}"
54560,"@Override public DidCursor getAllCollectionDids(DSLContext dsl,MetaDatabase metaDatabase,MetaCollection metaCollection) throws SQLException {
  MetaDocPart rootDocPart=metaCollection.getMetaDocPartByTableRef(tableRefFactory.createRoot());
  if (rootDocPart == null) {
    return EmptyDidCursor.INSTANCE;
  }
  String statement=getReadAllCollectionDidsStatement(metaDatabase.getIdentifier(),rootDocPart.getIdentifier());
  Connection connection=dsl.configuration().connectionProvider().acquire();
  try {
    PreparedStatement preparedStatement=connection.prepareStatement(statement);
    return new DefaultDidCursor(errorHandler,preparedStatement.executeQuery());
  }
  finally {
    dsl.configuration().connectionProvider().release(connection);
  }
}","@Override @SuppressFBWarnings(value={""String_Node_Str"",""String_Node_Str""},justification=""String_Node_Str"") public DidCursor getAllCollectionDids(DSLContext dsl,MetaDatabase metaDatabase,MetaCollection metaCollection) throws SQLException {
  MetaDocPart rootDocPart=metaCollection.getMetaDocPartByTableRef(tableRefFactory.createRoot());
  if (rootDocPart == null) {
    return EmptyDidCursor.INSTANCE;
  }
  String statement=getReadAllCollectionDidsStatement(metaDatabase.getIdentifier(),rootDocPart.getIdentifier());
  Connection connection=dsl.configuration().connectionProvider().acquire();
  try {
    PreparedStatement preparedStatement=connection.prepareStatement(statement);
    return new DefaultDidCursor(errorHandler,preparedStatement.executeQuery());
  }
  finally {
    dsl.configuration().connectionProvider().release(connection);
  }
}"
54561,"@Override public int getLastRowIdUsed(@Nonnull DSLContext dsl,@Nonnull MetaDatabase metaDatabase,@Nonnull MetaCollection metaCollection,@Nonnull MetaDocPart metaDocPart){
  String statement=getLastRowIdUsedStatement(metaDatabase,metaDocPart);
  Connection connection=dsl.configuration().connectionProvider().acquire();
  try (PreparedStatement preparedStatement=connection.prepareStatement(statement)){
    ResultSet rs=preparedStatement.executeQuery();
    rs.next();
    int maxId=rs.getInt(1);
    if (rs.wasNull()) {
      return -1;
    }
    return maxId;
  }
 catch (  SQLException ex) {
    throw errorHandler.handleException(Context.FETCH,ex);
  }
 finally {
    dsl.configuration().connectionProvider().release(connection);
  }
}","@Override public int getLastRowIdUsed(DSLContext dsl,MetaDatabase metaDatabase,MetaCollection metaCollection,MetaDocPart metaDocPart){
  String statement=getLastRowIdUsedStatement(metaDatabase,metaDocPart);
  Connection connection=dsl.configuration().connectionProvider().acquire();
  try (PreparedStatement preparedStatement=connection.prepareStatement(statement)){
    try (ResultSet rs=preparedStatement.executeQuery()){
      rs.next();
      int maxId=rs.getInt(1);
      if (rs.wasNull()) {
        return -1;
      }
      return maxId;
    }
   }
 catch (  SQLException ex) {
    throw errorHandler.handleException(Context.FETCH,ex);
  }
 finally {
    dsl.configuration().connectionProvider().release(connection);
  }
}"
54562,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public void setPreparedStatementValue(PreparedStatement preparedStatement,int parameterIndex,FieldType fieldType,KVValue<?> value) throws SQLException {
  DataTypeForKV dataType=dataTypeProvider.getDataType(fieldType);
  Converter converter=dataType.getConverter();
  KVValueConverter valueConverter=dataType.getKVValueConverter();
  SqlBinding sqlBinding=valueConverter.getSqlBinding();
  sqlBinding.set(preparedStatement,parameterIndex,converter.to(value));
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public void setPreparedStatementValue(PreparedStatement preparedStatement,int parameterIndex,FieldType fieldType,KVValue<?> value) throws SQLException {
  DataTypeForKV dataType=dataTypeProvider.getDataType(fieldType);
  KVValueConverter valueConverter=dataType.getKVValueConverter();
  Converter converter=dataType.getConverter();
  SqlBinding sqlBinding=valueConverter.getSqlBinding();
  sqlBinding.set(preparedStatement,parameterIndex,converter.to(value));
}"
54563,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public void setPreparedStatementNullableValue(PreparedStatement preparedStatement,int parameterIndex,FieldType fieldType,KVValue<?> value) throws SQLException {
  DataTypeForKV dataType=dataTypeProvider.getDataType(fieldType);
  Converter converter=dataType.getConverter();
  KVValueConverter valueConverter=dataType.getKVValueConverter();
  SqlBinding sqlBinding=valueConverter.getSqlBinding();
  if (value != null) {
    sqlBinding.set(preparedStatement,parameterIndex,converter.to(value));
  }
 else {
    preparedStatement.setNull(parameterIndex,dataType.getSQLType());
  }
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public void setPreparedStatementNullableValue(PreparedStatement preparedStatement,int parameterIndex,FieldType fieldType,KVValue<?> value) throws SQLException {
  DataTypeForKV dataType=dataTypeProvider.getDataType(fieldType);
  if (value != null) {
    KVValueConverter valueConverter=dataType.getKVValueConverter();
    SqlBinding sqlBinding=valueConverter.getSqlBinding();
    Converter converter=dataType.getConverter();
    sqlBinding.set(preparedStatement,parameterIndex,converter.to(value));
  }
 else {
    preparedStatement.setNull(parameterIndex,dataType.getSQLType());
  }
}"
54564,"public Result<Record> executeStatementWithResult(DSLContext dsl,String statement,Context context){
  Connection c=dsl.configuration().connectionProvider().acquire();
  try (PreparedStatement ps=c.prepareStatement(statement)){
    ResultSet resultSet=ps.executeQuery();
    return dsl.fetch(resultSet);
  }
 catch (  SQLException ex) {
    throw errorHandler.handleException(context,ex);
  }
 finally {
    dsl.configuration().connectionProvider().release(c);
  }
}","public Result<Record> executeStatementWithResult(DSLContext dsl,String statement,Context context){
  Connection c=dsl.configuration().connectionProvider().acquire();
  try (PreparedStatement ps=c.prepareStatement(statement)){
    try (ResultSet resultSet=ps.executeQuery()){
      return dsl.fetch(resultSet);
    }
   }
 catch (  SQLException ex) {
    throw errorHandler.handleException(context,ex);
  }
 finally {
    dsl.configuration().connectionProvider().release(c);
  }
}"
54565,"private static TableRef createChild(TableRefFactory tableRefFactory,TableRef tableRef,String tableRefName){
  if (isArrayDimension(tableRefName)) {
    int dimension=Integer.valueOf(tableRefName.substring(1));
    tableRef=tableRefFactory.createChild(tableRef,dimension);
  }
 else {
    tableRef=tableRefFactory.createChild(tableRef,unescapeTableRefName(tableRefName).intern());
  }
  return tableRef;
}","private static TableRef createChild(TableRefFactory tableRefFactory,TableRef tableRef,String tableRefName){
  if (isArrayDimension(tableRefName)) {
    Integer dimension=Integer.valueOf(tableRefName.substring(1));
    tableRef=tableRefFactory.createChild(tableRef,dimension);
  }
 else {
    tableRef=tableRefFactory.createChild(tableRef,unescapeTableRefName(tableRefName).intern());
  }
  return tableRef;
}"
54566,"public ResultSetNewDocPartRow() throws IllegalDocPartRowException {
  Collection<InternalField<?>> internalFields=metaDataReadInterface.getInternalFields(metaDocPart);
  Integer _did=null;
  Integer _pid=null;
  Integer _rid=null;
  Integer _seq=null;
  int columnIndex=1;
  MetaDocPartTable<Object,MetaDocPartRecord<Object>> metaDocPartTable=metaDataReadInterface.getMetaDocPartTable();
  for (  InternalField<?> internalField : internalFields) {
    try {
      if (internalField.isDid()) {
        _did=metaDocPartTable.DID.getValue(rs,columnIndex);
      }
 else       if (internalField.isRid()) {
        _rid=metaDocPartTable.RID.getValue(rs,columnIndex);
      }
 else       if (internalField.isPid()) {
        _pid=metaDocPartTable.PID.getValue(rs,columnIndex);
      }
 else       if (internalField.isSeq()) {
        _seq=metaDocPartTable.SEQ.getValue(rs,columnIndex);
      }
    }
 catch (    SQLException sqlException) {
      throw errorHandler.handleException(Context.FETCH,sqlException);
    }
    columnIndex++;
    if (_did == null) {
      throw new IllegalDocPartRowException(_did,_rid,_pid,_seq,""String_Node_Str"" + metaDocPart.getTableRef());
    }
    if (_rid == null) {
      _rid=_did;
    }
    if (_pid == null) {
      _pid=_did;
    }
  }
  this.did=_did;
  this.rid=_rid;
  this.pid=_pid;
  this.seq=_seq;
  this.firstUserColumnIndex=columnIndex;
}","public ResultSetNewDocPartRow() throws IllegalDocPartRowException {
  Collection<InternalField<?>> internalFields=metaDataReadInterface.getInternalFields(metaDocPart);
  Integer _did=null;
  Integer _pid=null;
  Integer _rid=null;
  Integer _seq=null;
  int columnIndex=1;
  MetaDocPartTable<Object,MetaDocPartRecord<Object>> metaDocPartTable=metaDataReadInterface.getMetaDocPartTable();
  for (  InternalField<?> internalField : internalFields) {
    try {
      if (internalField.isDid()) {
        _did=metaDocPartTable.DID.getValue(rs,columnIndex);
      }
 else       if (internalField.isRid()) {
        _rid=metaDocPartTable.RID.getValue(rs,columnIndex);
      }
 else       if (internalField.isPid()) {
        _pid=metaDocPartTable.PID.getValue(rs,columnIndex);
      }
 else       if (internalField.isSeq()) {
        _seq=metaDocPartTable.SEQ.getValue(rs,columnIndex);
      }
    }
 catch (    SQLException sqlException) {
      throw errorHandler.handleException(Context.FETCH,sqlException);
    }
    columnIndex++;
    if (_did == null) {
      throw new IllegalDocPartRowException(null,_rid,_pid,_seq,""String_Node_Str"" + metaDocPart.getTableRef());
    }
    if (_rid == null) {
      _rid=_did;
    }
    if (_pid == null) {
      _pid=_did;
    }
  }
  this.did=_did;
  this.rid=_rid;
  this.pid=_pid;
  this.seq=_seq;
  this.firstUserColumnIndex=columnIndex;
}"
54567,"@Override public long deleteCollectionDocParts(@Nonnull DSLContext dsl,@Nonnull String schemaName,@Nonnull MetaCollection metaCollection,@Nonnull DidCursor didCursor){
  Iterator<? extends MetaDocPart> iterator=metaCollection.streamContainedMetaDocParts().sorted(TableRefComparator.MetaDocPart.DESC).iterator();
  Connection c=dsl.configuration().connectionProvider().acquire();
  try {
    int maxBatchSize=100;
    long updated=0;
    while (didCursor.hasNext()) {
      Collection<Integer> dids=didCursor.getNextBatch(maxBatchSize);
      while (iterator.hasNext()) {
        MetaDocPart metaDocPart=iterator.next();
        String statement=getDeleteDocPartsStatement(schemaName,metaDocPart.getIdentifier(),dids);
        sqlHelper.executeUpdate(c,statement,Context.DELETE);
      }
      updated+=dids.size();
    }
    return updated;
  }
  finally {
    dsl.configuration().connectionProvider().release(c);
  }
}","@Override public long deleteCollectionDocParts(@Nonnull DSLContext dsl,@Nonnull String schemaName,@Nonnull MetaCollection metaCollection,@Nonnull DidCursor didCursor){
  Connection c=dsl.configuration().connectionProvider().acquire();
  try {
    int maxBatchSize=100;
    long updated=0;
    while (didCursor.hasNext()) {
      Collection<Integer> dids=didCursor.getNextBatch(maxBatchSize);
      Iterator<? extends MetaDocPart> iterator=metaCollection.streamContainedMetaDocParts().sorted(TableRefComparator.MetaDocPart.DESC).iterator();
      while (iterator.hasNext()) {
        MetaDocPart metaDocPart=iterator.next();
        String statement=getDeleteDocPartsStatement(schemaName,metaDocPart.getIdentifier(),dids);
        sqlHelper.executeUpdate(c,statement,Context.DELETE);
      }
      updated+=dids.size();
    }
    return updated;
  }
  finally {
    dsl.configuration().connectionProvider().release(c);
  }
}"
54568,"protected AbstractIdentifierConstraints(ImmutableSet<String> restrictedSchemaNames,ImmutableSet<String> restrictedColumnNames){
  this.fieldTypeIdentifiers=Maps.immutableEnumMap(ImmutableMap.<FieldType,Character>builder().put(FieldType.BINARY,Character.valueOf('r')).put(FieldType.BOOLEAN,Character.valueOf('b')).put(FieldType.DATE,Character.valueOf('c')).put(FieldType.DOUBLE,Character.valueOf('d')).put(FieldType.INSTANT,Character.valueOf('g')).put(FieldType.INTEGER,Character.valueOf('i')).put(FieldType.LONG,Character.valueOf('l')).put(FieldType.MONGO_OBJECT_ID,Character.valueOf('x')).put(FieldType.MONGO_TIME_STAMP,Character.valueOf('y')).put(FieldType.NULL,Character.valueOf('n')).put(FieldType.STRING,Character.valueOf('s')).put(FieldType.TIME,Character.valueOf('t')).put(FieldType.CHILD,Character.valueOf('e')).build());
  ImmutableMap.Builder<FieldType,String> scalarFieldTypeIdentifiersBuilder=ImmutableMap.<FieldType,String>builder();
  Set<Character> fieldTypeIdentifierSet=new HashSet<>();
  for (  FieldType fieldType : FieldType.values()) {
    if (!this.fieldTypeIdentifiers.containsKey(fieldType)) {
      throw new SystemException(""String_Node_Str"" + fieldType + ""String_Node_Str"");
    }
    char identifier=this.fieldTypeIdentifiers.get(fieldType);
    if ((identifier < 'a' || identifier > 'z') && (identifier < '0' || identifier > '9')) {
      throw new SystemException(""String_Node_Str"" + fieldType + ""String_Node_Str""+ identifier);
    }
    if (fieldTypeIdentifierSet.contains(identifier)) {
      throw new SystemException(""String_Node_Str"" + fieldType + ""String_Node_Str""+ identifier+ ""String_Node_Str"");
    }
    fieldTypeIdentifierSet.add(identifier);
    scalarFieldTypeIdentifiersBuilder.put(fieldType,DocPartTableFields.SCALAR.fieldName + SEPARATOR + identifier);
  }
  this.scalarFieldTypeIdentifiers=Maps.immutableEnumMap(scalarFieldTypeIdentifiersBuilder.build());
  this.restrictedSchemaNames=ImmutableSet.<String>builder().add(TorodbSchema.TORODB_SCHEMA).addAll(restrictedSchemaNames).build();
  this.restrictedColumnNames=ImmutableSet.<String>builder().add(DocPartTableFields.DID.fieldName).add(DocPartTableFields.RID.fieldName).add(DocPartTableFields.PID.fieldName).add(DocPartTableFields.SEQ.fieldName).addAll(scalarFieldTypeIdentifiers.values()).addAll(restrictedColumnNames).build();
}","protected AbstractIdentifierConstraints(ImmutableSet<String> restrictedSchemaNames,ImmutableSet<String> restrictedColumnNames){
  this.fieldTypeIdentifiers=Maps.immutableEnumMap(ImmutableMap.<FieldType,Character>builder().put(FieldType.BINARY,Character.valueOf('r')).put(FieldType.BOOLEAN,Character.valueOf('b')).put(FieldType.DATE,Character.valueOf('c')).put(FieldType.DOUBLE,Character.valueOf('d')).put(FieldType.INSTANT,Character.valueOf('g')).put(FieldType.INTEGER,Character.valueOf('i')).put(FieldType.LONG,Character.valueOf('l')).put(FieldType.MONGO_OBJECT_ID,Character.valueOf('x')).put(FieldType.MONGO_TIME_STAMP,Character.valueOf('y')).put(FieldType.NULL,Character.valueOf('n')).put(FieldType.STRING,Character.valueOf('s')).put(FieldType.TIME,Character.valueOf('t')).put(FieldType.CHILD,Character.valueOf('e')).build());
  ImmutableMap.Builder<FieldType,String> scalarFieldTypeIdentifiersBuilder=ImmutableMap.<FieldType,String>builder();
  Set<Character> fieldTypeIdentifierSet=new HashSet<>();
  for (  FieldType fieldType : FieldType.values()) {
    if (!this.fieldTypeIdentifiers.containsKey(fieldType)) {
      throw new SystemException(""String_Node_Str"" + fieldType + ""String_Node_Str"");
    }
    char identifier=this.fieldTypeIdentifiers.get(fieldType);
    if ((identifier < 'a' || identifier > 'z') && (identifier < '0' || identifier > '9')) {
      throw new SystemException(""String_Node_Str"" + fieldType + ""String_Node_Str""+ identifier);
    }
    if (fieldTypeIdentifierSet.contains(identifier)) {
      throw new SystemException(""String_Node_Str"" + fieldType + ""String_Node_Str""+ identifier+ ""String_Node_Str"");
    }
    fieldTypeIdentifierSet.add(identifier);
    scalarFieldTypeIdentifiersBuilder.put(fieldType,DocPartTableFields.SCALAR.fieldName + SEPARATOR + identifier);
  }
  this.scalarFieldTypeIdentifiers=Maps.immutableEnumMap(scalarFieldTypeIdentifiersBuilder.build());
  this.restrictedSchemaNames=ImmutableSet.<String>builder().add(TorodbSchema.IDENTIFIER).addAll(restrictedSchemaNames).build();
  this.restrictedColumnNames=ImmutableSet.<String>builder().add(DocPartTableFields.DID.fieldName).add(DocPartTableFields.RID.fieldName).add(DocPartTableFields.PID.fieldName).add(DocPartTableFields.SEQ.fieldName).addAll(scalarFieldTypeIdentifiers.values()).addAll(restrictedColumnNames).build();
}"
54569,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private void checkSchema(Schema torodbSchema,SqlInterface sqlInterface) throws InvalidDatabaseException {
  SemanticTable<?>[] metaTables=new SemanticTable[]{sqlInterface.getMetaDatabaseTable(),sqlInterface.getMetaCollectionTable(),sqlInterface.getMetaDocPartTable(),sqlInterface.getMetaFieldTable(),sqlInterface.getMetaScalarTable()};
  for (  SemanticTable metaTable : metaTables) {
    String metaTableName=metaTable.getName();
    boolean metaTableFound=false;
    for (    Table<?> table : torodbSchema.getTables()) {
      if (sqlInterface.isSameIdentifier(table.getName(),metaTableName)) {
        metaTable.checkSemanticallyEquals(table);
        metaTableFound=true;
        LOGGER.info(table + ""String_Node_Str"");
      }
    }
    if (!metaTableFound) {
      throw new InvalidDatabaseException(""String_Node_Str"" + TorodbSchema.TORODB_SCHEMA + ""String_Node_Str""+ ""String_Node_Str""+ metaTableName+ ""String_Node_Str"");
    }
  }
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private void checkSchema(Schema torodbSchema,SqlInterface sqlInterface) throws InvalidDatabaseException {
  SemanticTable<?>[] metaTables=new SemanticTable[]{sqlInterface.getMetaDatabaseTable(),sqlInterface.getMetaCollectionTable(),sqlInterface.getMetaDocPartTable(),sqlInterface.getMetaFieldTable(),sqlInterface.getMetaScalarTable()};
  for (  SemanticTable metaTable : metaTables) {
    String metaTableName=metaTable.getName();
    boolean metaTableFound=false;
    for (    Table<?> table : torodbSchema.getTables()) {
      if (sqlInterface.isSameIdentifier(table.getName(),metaTableName)) {
        metaTable.checkSemanticallyEquals(table);
        metaTableFound=true;
        LOGGER.info(table + ""String_Node_Str"");
      }
    }
    if (!metaTableFound) {
      throw new InvalidDatabaseException(""String_Node_Str"" + TorodbSchema.IDENTIFIER + ""String_Node_Str""+ ""String_Node_Str""+ metaTableName+ ""String_Node_Str"");
    }
  }
}"
54570,"@Override public void checkOrCreate(DSLContext dsl,Meta jooqMeta,SqlInterface sqlInterface,SqlHelper sqlHelper) throws SQLException, IOException, InvalidDatabaseException {
  Schema torodbSchema=null;
  for (  Schema schema : jooqMeta.getSchemas()) {
    if (sqlInterface.isSameIdentifier(TorodbSchema.TORODB_SCHEMA,schema.getName())) {
      torodbSchema=schema;
      break;
    }
  }
  if (torodbSchema == null) {
    LOGGER.info(""String_Node_Str"",TorodbSchema.TORODB_SCHEMA);
    createSchema(dsl,sqlInterface,sqlHelper);
    LOGGER.info(""String_Node_Str"",TorodbSchema.TORODB_SCHEMA);
  }
 else {
    LOGGER.info(""String_Node_Str"",TorodbSchema.TORODB_SCHEMA);
    checkSchema(torodbSchema,sqlInterface);
    LOGGER.info(""String_Node_Str"",TorodbSchema.TORODB_SCHEMA);
  }
}","@Override public void checkOrCreate(DSLContext dsl,Meta jooqMeta,SqlInterface sqlInterface,SqlHelper sqlHelper) throws SQLException, IOException, InvalidDatabaseException {
  Schema torodbSchema=null;
  for (  Schema schema : jooqMeta.getSchemas()) {
    if (sqlInterface.isSameIdentifier(TorodbSchema.IDENTIFIER,schema.getName())) {
      torodbSchema=schema;
      break;
    }
  }
  if (torodbSchema == null) {
    LOGGER.info(""String_Node_Str"",TorodbSchema.IDENTIFIER);
    createSchema(dsl,sqlInterface,sqlHelper);
    LOGGER.info(""String_Node_Str"",TorodbSchema.IDENTIFIER);
  }
 else {
    LOGGER.info(""String_Node_Str"",TorodbSchema.IDENTIFIER);
    checkSchema(torodbSchema,sqlInterface);
    LOGGER.info(""String_Node_Str"",TorodbSchema.IDENTIFIER);
  }
}"
54571,"protected void createSchema(DSLContext dsl,SqlInterface sqlInterface,SqlHelper sqlHelper) throws SQLException, IOException {
  sqlInterface.createSchema(dsl,TorodbSchema.TORODB_SCHEMA);
  sqlInterface.createMetaDatabaseTable(dsl);
  sqlInterface.createMetaCollectionTable(dsl);
  sqlInterface.createMetaDocPartTable(dsl);
  sqlInterface.createMetaFieldTable(dsl);
  sqlInterface.createMetaScalarTable(dsl);
}","protected void createSchema(DSLContext dsl,SqlInterface sqlInterface,SqlHelper sqlHelper) throws SQLException, IOException {
  sqlInterface.createSchema(dsl,TorodbSchema.IDENTIFIER);
  sqlInterface.createMetaDatabaseTable(dsl);
  sqlInterface.createMetaCollectionTable(dsl);
  sqlInterface.createMetaDocPartTable(dsl);
  sqlInterface.createMetaFieldTable(dsl);
  sqlInterface.createMetaScalarTable(dsl);
}"
54572,"/** 
 * No further instances allowed
 */
protected TorodbSchema(){
  super(TORODB_SCHEMA);
}","/** 
 * No further instances allowed
 */
protected TorodbSchema(){
  super(IDENTIFIER);
}"
54573,"/** 
 * No further instances allowed
 */
private MongoTimestampUDT(){
  super(""String_Node_Str"",TorodbSchema.TORODB);
  getDataType();
}","/** 
 * No further instances allowed
 */
private MongoTimestampUDT(){
  super(IDENTIFIER,TorodbSchema.TORODB);
  getDataType();
}"
54574,"@Override protected String getInsertDocPartDataStatement(String schemaName,MetaDocPart metaDocPart,Iterator<MetaField> metaFieldIterator,Iterator<MetaScalar> metaScalarIterator,Collection<InternalField<?>> internalFields,List<FieldType> fieldTypeList){
  final StringBuilder insertStatementBuilder=new StringBuilder(2048);
  final StringBuilder insertStatementValuesBuilder=new StringBuilder(1024);
  insertStatementBuilder.append(""String_Node_Str"").append(schemaName).append(""String_Node_Str"").append(metaDocPart.getIdentifier()).append(""String_Node_Str"");
  insertStatementValuesBuilder.append(""String_Node_Str"");
  for (  InternalField<?> internalField : internalFields) {
    insertStatementBuilder.append(""String_Node_Str"").append(internalField.getName()).append(""String_Node_Str"");
    insertStatementValuesBuilder.append(""String_Node_Str"");
  }
  while (metaScalarIterator.hasNext()) {
    MetaScalar metaScalar=metaScalarIterator.next();
    insertStatementBuilder.append(""String_Node_Str"").append(metaScalar.getIdentifier()).append(""String_Node_Str"");
    insertStatementValuesBuilder.append(""String_Node_Str"");
    fieldTypeList.add(metaScalar.getType());
  }
  while (metaFieldIterator.hasNext()) {
    MetaField metaField=metaFieldIterator.next();
    insertStatementBuilder.append(""String_Node_Str"").append(metaField.getIdentifier()).append(""String_Node_Str"");
    insertStatementValuesBuilder.append(""String_Node_Str"");
    fieldTypeList.add(metaField.getType());
  }
  insertStatementBuilder.setCharAt(insertStatementBuilder.length() - 1,')');
  insertStatementValuesBuilder.setCharAt(insertStatementValuesBuilder.length() - 1,')');
  insertStatementBuilder.append(insertStatementValuesBuilder);
  String statement=insertStatementBuilder.toString();
  return statement;
}","@Override protected String getInsertDocPartDataStatement(String schemaName,MetaDocPart metaDocPart,Iterator<MetaField> metaFieldIterator,Iterator<MetaScalar> metaScalarIterator,Collection<InternalField<?>> internalFields,List<FieldType> fieldTypeList){
  final StringBuilder insertStatementBuilder=new StringBuilder(2048);
  final StringBuilder insertStatementValuesBuilder=new StringBuilder(1024);
  insertStatementBuilder.append(""String_Node_Str"").append(schemaName).append(""String_Node_Str"").append(metaDocPart.getIdentifier()).append(""String_Node_Str"");
  insertStatementValuesBuilder.append(""String_Node_Str"");
  for (  InternalField<?> internalField : internalFields) {
    insertStatementBuilder.append(""String_Node_Str"").append(internalField.getName()).append(""String_Node_Str"");
    insertStatementValuesBuilder.append(""String_Node_Str"");
  }
  while (metaScalarIterator.hasNext()) {
    MetaScalar metaScalar=metaScalarIterator.next();
    FieldType type=metaScalar.getType();
    insertStatementBuilder.append(""String_Node_Str"").append(metaScalar.getIdentifier()).append(""String_Node_Str"");
    insertStatementValuesBuilder.append(sqlHelper.getPlaceholder(type)).append(',');
    fieldTypeList.add(type);
  }
  while (metaFieldIterator.hasNext()) {
    MetaField metaField=metaFieldIterator.next();
    FieldType type=metaField.getType();
    insertStatementBuilder.append(""String_Node_Str"").append(metaField.getIdentifier()).append(""String_Node_Str"");
    insertStatementValuesBuilder.append(sqlHelper.getPlaceholder(type)).append(',');
    fieldTypeList.add(type);
  }
  insertStatementBuilder.setCharAt(insertStatementBuilder.length() - 1,')');
  insertStatementValuesBuilder.setCharAt(insertStatementValuesBuilder.length() - 1,')');
  insertStatementBuilder.append(insertStatementValuesBuilder);
  String statement=insertStatementBuilder.toString();
  return statement;
}"
54575,"@Inject public PostgreSQLWriteInterface(PostgreSQLMetaDataReadInterface metaDataReadInterface,PostgreSQLErrorHandler errorHandler,SqlHelper sqlHelper){
  super(metaDataReadInterface,errorHandler,sqlHelper);
  this.postgreSQLMetaDataReadInterface=metaDataReadInterface;
  this.errorHandler=errorHandler;
}","@Inject public PostgreSQLWriteInterface(PostgreSQLMetaDataReadInterface metaDataReadInterface,PostgreSQLErrorHandler errorHandler,SqlHelper sqlHelper){
  super(metaDataReadInterface,errorHandler,sqlHelper);
  this.postgreSQLMetaDataReadInterface=metaDataReadInterface;
  this.errorHandler=errorHandler;
  this.sqlHelper=sqlHelper;
}"
54576,"/** 
 * Setter for <code>torodb.scalar.idenftifier</code>.
 */
public void setIdentifier(String value){
  set(5,value);
}","/** 
 * Setter for <code>torodb.scalar.idenftifier</code>.
 */
public void setIdentifier(String value){
  set(4,value);
}"
54577,"/** 
 * Getter for <code>torodb.scalar.idenftifier</code>.
 */
public String getIdentifier(){
  return (String)getValue(5);
}","/** 
 * Getter for <code>torodb.scalar.idenftifier</code>.
 */
public String getIdentifier(){
  return (String)getValue(4);
}"
54578,"/** 
 * Setter for <code>torodb.scalar.type</code>.
 */
public void setType(FieldType value){
  set(4,value);
}","/** 
 * Setter for <code>torodb.scalar.type</code>.
 */
public void setType(FieldType value){
  set(3,value);
}"
54579,"/** 
 * Getter for <code>torodb.scalar.type</code>.
 */
public FieldType getType(){
  return (FieldType)getValue(4);
}","/** 
 * Getter for <code>torodb.scalar.type</code>.
 */
public FieldType getType(){
  return (FieldType)getValue(3);
}"
54580,"@Override public ImmutableMetaDatabase getMetaDatabaseByIdentifier(String schemaDbName){
  return dbsByName.get(schemaDbName);
}","@Override public ImmutableMetaDatabase getMetaDatabaseByIdentifier(String schemaDbName){
  return dbsByIdentifier.get(schemaDbName);
}"
54581,"public ImmutableMetaSnapshot(Map<String,ImmutableMetaDatabase> dbsByName){
  this.dbsByName=Collections.unmodifiableMap(dbsByName);
  this.dbsByIdentifier=new HashMap<>(dbsByName.size());
  for (  ImmutableMetaDatabase schema : dbsByName.values()) {
    dbsByIdentifier.put(schema.getIdentifier(),schema);
  }
}","public ImmutableMetaSnapshot(@DoNotChange Map<String,ImmutableMetaDatabase> dbsById){
  this.dbsByIdentifier=Collections.unmodifiableMap(dbsById);
  this.dbsByName=new HashMap<>(dbsById.size());
  for (  ImmutableMetaDatabase schema : dbsById.values()) {
    dbsByName.put(schema.getName(),schema);
  }
}"
54582,"private static CheckCase checkCompatibility(Object nameObject,Object idObject){
}","private static CheckCase checkCompatibility(Object nameObject,Object idObject){
  if (Objects.equals(nameObject,idObject)) {
    return CheckCase.OK;
  }
  if (nameObject != null) {
    return CheckCase.DIFFERENT_NAME;
  }
  if (idObject != null) {
    return CheckCase.DIFFERENT_ID;
  }
  throw new AssertionError();
}"
54583,"protected void startupToro() throws Exception {
  if (!started) {
    started=true;
    setupConfig();
    Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler(){
      @Override public void uncaughtException(      Thread t,      Throwable e){
        addUncaughtException(e);
      }
    }
);
    new File(""String_Node_Str"").mkdirs();
    Logger root=LogbackUtils.getRootLogger();
    LogbackUtils.setLoggerLevel(root,LogLevel.WARNING);
    Appender<ILoggingEvent> uncaughtExceptionAppender=new AppenderBase<ILoggingEvent>(){
      @Override protected void append(      ILoggingEvent eventObject){
        IThrowableProxy throwableProxy=eventObject.getThrowableProxy();
        if (throwableProxy != null && throwableProxy instanceof ThrowableProxy) {
          addUncaughtException(((ThrowableProxy)throwableProxy).getThrowable());
        }
      }
    }
;
    uncaughtExceptionAppender.setContext(LogbackUtils.getLoggerContext());
    uncaughtExceptionAppender.start();
    root.addAppender(uncaughtExceptionAppender);
    if (config.getBackend().isPostgresLike()) {
      PGSimpleDataSource dataSource=new PGSimpleDataSource();
      dataSource.setUser(config.getBackend().asPostgres().getUser());
      dataSource.setPassword(config.getBackend().asPostgres().getPassword());
      dataSource.setServerName(config.getBackend().asPostgres().getHost());
      dataSource.setPortNumber(config.getBackend().asPostgres().getPort());
      dataSource.setDatabaseName(""String_Node_Str"");
      Connection connection=dataSource.getConnection();
      try {
        connection.prepareCall(""String_Node_Str"").execute();
      }
 catch (      PSQLException psqlException) {
      }
      connection.prepareCall(""String_Node_Str"").execute();
      connection.close();
    }
    Injector injector=Guice.createInjector(new ConfigModule(config),new BackendModule(config),new ConfigModule(config),new MongoConfigModule(config),new MongoLayerModule(config),new ExecutorModule(1000,1000,0.2),new DbMetaInformationCacheModule(),new D2RModule(),new ConnectionModule(),new ExecutorServiceModule());
    final Object TORO_SEMAPHOR=new Object();
    final Torod torod=injector.getInstance(Torod.class);
    final MongoServer server=injector.getInstance(MongoServer.class);
    final ReplCoordinator replCoord=injector.getInstance(ReplCoordinator.class);
    shutdowner=injector.getInstance(Shutdowner.class);
    Thread serverThread=new Thread(){
      @Override public void run(){
        try {
          torod.start();
        }
 catch (        TorodStartupException e) {
          LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME).error(e.getMessage());
          throw new RuntimeException(e.getMessage());
        }
        replCoord.startAsync();
        replCoord.awaitRunning();
        server.run();
synchronized (TORO_SEMAPHOR) {
          TORO_SEMAPHOR.notify();
        }
      }
    }
;
    serverThread.start();
    long start=System.currentTimeMillis();
synchronized (TORO_SEMAPHOR) {
      TORO_SEMAPHOR.wait(TORO_BOOT_MAX_INTERVAL_MILLIS);
    }
    if (System.currentTimeMillis() - start >= TORO_BOOT_MAX_INTERVAL_MILLIS) {
      throw new RuntimeException(""String_Node_Str"" + TORO_BOOT_MAX_INTERVAL_MILLIS + ""String_Node_Str"");
    }
    List<Throwable> exceptions=getUcaughtExceptions();
    if (!exceptions.isEmpty()) {
      throw new RuntimeException(exceptions.get(0));
    }
  }
}","protected void startupToro() throws Exception {
  if (!started) {
    started=true;
    setupConfig();
    Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler(){
      @Override public void uncaughtException(      Thread t,      Throwable e){
        addUncaughtException(e);
      }
    }
);
    new File(""String_Node_Str"").mkdirs();
    Logger root=LogbackUtils.getRootLogger();
    LogbackUtils.setLoggerLevel(root,config.getGeneric().getLogLevel());
    Appender<ILoggingEvent> uncaughtExceptionAppender=new AppenderBase<ILoggingEvent>(){
      @Override protected void append(      ILoggingEvent eventObject){
        IThrowableProxy throwableProxy=eventObject.getThrowableProxy();
        if (throwableProxy != null && throwableProxy instanceof ThrowableProxy) {
          addUncaughtException(((ThrowableProxy)throwableProxy).getThrowable());
        }
      }
    }
;
    uncaughtExceptionAppender.setContext(LogbackUtils.getLoggerContext());
    uncaughtExceptionAppender.start();
    root.addAppender(uncaughtExceptionAppender);
    if (config.getBackend().isPostgresLike()) {
      Postgres postgresBackend=config.getBackend().asPostgres();
      PGSimpleDataSource dataSource=new PGSimpleDataSource();
      dataSource.setUser(postgresBackend.getUser());
      dataSource.setPassword(postgresBackend.getPassword());
      dataSource.setServerName(postgresBackend.getHost());
      dataSource.setPortNumber(postgresBackend.getPort());
      dataSource.setDatabaseName(""String_Node_Str"");
      Connection connection=dataSource.getConnection();
      try {
        connection.prepareCall(""String_Node_Str"" + postgresBackend.getDatabase()).execute();
      }
 catch (      PSQLException psqlException) {
      }
      connection.prepareCall(""String_Node_Str"" + postgresBackend.getDatabase() + ""String_Node_Str""+ postgresBackend.getUser()).execute();
      connection.close();
    }
    Injector injector=Guice.createInjector(new ConfigModule(config),new BackendModule(config),new ConfigModule(config),new MongoConfigModule(config),new MongoLayerModule(config),new ExecutorModule(1000,1000,0.2),new DbMetaInformationCacheModule(),new D2RModule(),new ConnectionModule(),new ExecutorServiceModule());
    final Object TORO_SEMAPHOR=new Object();
    final Torod torod=injector.getInstance(Torod.class);
    final MongoServer server=injector.getInstance(MongoServer.class);
    final ReplCoordinator replCoord=injector.getInstance(ReplCoordinator.class);
    shutdowner=injector.getInstance(Shutdowner.class);
    Thread serverThread=new Thread(){
      @Override public void run(){
        try {
          torod.start();
        }
 catch (        TorodStartupException e) {
          LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME).error(e.getMessage());
          throw new RuntimeException(e.getMessage());
        }
        replCoord.startAsync();
        replCoord.awaitRunning();
        server.run();
synchronized (TORO_SEMAPHOR) {
          TORO_SEMAPHOR.notify();
        }
      }
    }
;
    serverThread.start();
    long start=System.currentTimeMillis();
synchronized (TORO_SEMAPHOR) {
      TORO_SEMAPHOR.wait(TORO_BOOT_MAX_INTERVAL_MILLIS);
    }
    if (System.currentTimeMillis() - start >= TORO_BOOT_MAX_INTERVAL_MILLIS) {
      throw new RuntimeException(""String_Node_Str"" + TORO_BOOT_MAX_INTERVAL_MILLIS + ""String_Node_Str"");
    }
    List<Throwable> exceptions=getUcaughtExceptions();
    if (!exceptions.isEmpty()) {
      throw new RuntimeException(exceptions.get(0));
    }
  }
}"
54584,"protected void runJstest() throws Exception {
  Config config=toroRunnerClassRule.getConfig();
  String toroConnectionString=config.getProtocol().getMongo().getNet().getBindIp() + ""String_Node_Str"" + config.getProtocol().getMongo().getNet().getPort()+ ""String_Node_Str""+ config.getBackend().asPostgres().getDatabase();
  URL mongoMocksUrl=Jstest.class.getResource(""String_Node_Str"");
  Process mongoProcess=Runtime.getRuntime().exec(new String[]{""String_Node_Str"",toroConnectionString,mongoMocksUrl.getPath(),testResourceUrl.getPath()});
  InputStream inputStream=mongoProcess.getInputStream();
  InputStream erroStream=mongoProcess.getErrorStream();
  ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
  int result=mongoProcess.waitFor();
  List<Throwable> uncaughtExceptions=toroRunnerClassRule.getUcaughtExceptions();
  if (result != 0) {
    int read;
    while ((read=inputStream.read()) != -1) {
      byteArrayOutputStream.write(read);
    }
    while ((read=erroStream.read()) != -1) {
      byteArrayOutputStream.write(read);
    }
  }
  if (!uncaughtExceptions.isEmpty()) {
    PrintStream printStream=new PrintStream(byteArrayOutputStream);
    for (    Throwable throwable : uncaughtExceptions) {
      throwable.printStackTrace(printStream);
    }
  }
  Assert.assertEquals(""String_Node_Str"" + testResourceUrl.getFile() + ""String_Node_Str""+ new String(byteArrayOutputStream.toByteArray(),Charsets.UTF_8),0,result);
  Assert.assertTrue(""String_Node_Str"" + testResourceUrl.getFile() + ""String_Node_Str""+ new String(byteArrayOutputStream.toByteArray(),Charsets.UTF_8),uncaughtExceptions.isEmpty());
}","protected void runJstest() throws Exception {
  Config config=toroRunnerClassRule.getConfig();
  String toroConnectionString=config.getProtocol().getMongo().getNet().getBindIp() + ""String_Node_Str"" + config.getProtocol().getMongo().getNet().getPort()+ ""String_Node_Str""+ config.getBackend().asPostgres().getDatabase();
  URL mongoMocksUrl=Jstest.class.getResource(""String_Node_Str"");
  LOGGER.info(""String_Node_Str"",testResource);
  Process mongoProcess=Runtime.getRuntime().exec(new String[]{""String_Node_Str"",toroConnectionString,mongoMocksUrl.getPath(),testResourceUrl.getPath()});
  InputStream inputStream=mongoProcess.getInputStream();
  InputStream erroStream=mongoProcess.getErrorStream();
  ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
  int result=mongoProcess.waitFor();
  List<Throwable> uncaughtExceptions=toroRunnerClassRule.getUcaughtExceptions();
  if (result != 0) {
    int read;
    while ((read=inputStream.read()) != -1) {
      byteArrayOutputStream.write(read);
    }
    while ((read=erroStream.read()) != -1) {
      byteArrayOutputStream.write(read);
    }
  }
  if (!uncaughtExceptions.isEmpty()) {
    PrintStream printStream=new PrintStream(byteArrayOutputStream);
    for (    Throwable throwable : uncaughtExceptions) {
      throwable.printStackTrace(printStream);
    }
  }
  Assert.assertEquals(""String_Node_Str"" + testResourceUrl.getFile() + ""String_Node_Str""+ new String(byteArrayOutputStream.toByteArray(),Charsets.UTF_8),0,result);
  Assert.assertTrue(""String_Node_Str"" + testResourceUrl.getFile() + ""String_Node_Str""+ new String(byteArrayOutputStream.toByteArray(),Charsets.UTF_8),uncaughtExceptions.isEmpty());
}"
54585,"@Override public void close() throws SQLException {
  connection.commit();
  connection.rollback();
  openCursors.remove(cursorId);
}","@Override public void close() throws SQLException {
  connection.commit();
  connection.close();
  openCursors.remove(cursorId);
}"
54586,"@Override public String to(NamedToroIndex userObject){
  JsonObjectBuilder objectBuilder=Json.createObjectBuilder();
  objectBuilder.add(NAME_KEY,userObject.getName());
  if (userObject.isUnique()) {
    objectBuilder.add(UNIQUE_KEY,true);
  }
  JsonArrayBuilder attsBuilder=Json.createArrayBuilder();
  JsonArrayBuilder descBuilder=Json.createArrayBuilder();
  int attPosition=0;
  boolean hasDescending=false;
  for (  Map.Entry<AttributeReference,Boolean> entry : userObject.getAttributes().entrySet()) {
    attsBuilder.add(entry.getKey().toString());
    if (!entry.getValue()) {
      descBuilder.add(attPosition);
      attPosition++;
      hasDescending=true;
    }
  }
  objectBuilder.add(ATTS_KEY,attsBuilder);
  if (hasDescending) {
    objectBuilder.add(DESCENDING,descBuilder);
  }
  StringWriter stringWriter=new StringWriter(200);
  JsonWriter jsonWriter=Json.createWriter(stringWriter);
  jsonWriter.writeObject(objectBuilder.build());
  return stringWriter.toString();
}","@Override public String to(NamedToroIndex userObject){
  JsonObjectBuilder objectBuilder=Json.createObjectBuilder();
  objectBuilder.add(NAME_KEY,userObject.getName());
  if (userObject.isUnique()) {
    objectBuilder.add(UNIQUE_KEY,true);
  }
  JsonArrayBuilder attsBuilder=Json.createArrayBuilder();
  JsonArrayBuilder descBuilder=Json.createArrayBuilder();
  int attPosition=0;
  boolean hasDescending=false;
  for (  Map.Entry<AttributeReference,Boolean> entry : userObject.getAttributes().entrySet()) {
    attsBuilder.add(entry.getKey().toString());
    if (!entry.getValue()) {
      descBuilder.add(attPosition);
      hasDescending=true;
    }
    attPosition++;
  }
  objectBuilder.add(ATTS_KEY,attsBuilder);
  if (hasDescending) {
    objectBuilder.add(DESCENDING,descBuilder);
  }
  StringWriter stringWriter=new StringWriter(200);
  JsonWriter jsonWriter=Json.createWriter(stringWriter);
  jsonWriter.writeObject(objectBuilder.build());
  return stringWriter.toString();
}"
54587,"@Override public Integer createPathViews(String collection) throws UnsupportedStructurePathViewException {
  try {
    return getDelegate().createPathViews(collection);
  }
 catch (  ImplementationDbException ex) {
    throw new ToroImplementationException(ex);
  }
}","@Override public Integer createPathViews(String collection) throws IllegalPathViewException {
  try {
    return getDelegate().createPathViews(collection);
  }
 catch (  ImplementationDbException ex) {
    throw new ToroImplementationException(ex);
  }
}"
54588,"@Override public Integer createPathViews(String collection) throws UnsupportedStructurePathViewException {
  PathViewHandler handler=new DefaultPathViewHandler(getMeta(),getDsl());
  return handler.createPathViews(collection);
}","@Override public Integer createPathViews(String collection) throws IllegalPathViewException {
  PathViewHandler.Callback callback=new DefaultPathViewHandlerCallback(getDsl());
  PathViewHandler handler=new PathViewHandler(getMeta(),callback);
  return handler.createPathViews(collection);
}"
54589,"public BasicType toBasicType(String columnName,int jdbcIntType,String jdbcStringType){
switch (jdbcIntType) {
case Types.BIGINT:
    return BasicType.LONG;
case Types.BOOLEAN:
case Types.BIT:
  return BasicType.BOOLEAN;
case Types.DATE:
return BasicType.DATE;
case Types.DOUBLE:
return BasicType.DOUBLE;
case Types.INTEGER:
return BasicType.INTEGER;
case Types.SMALLINT:
case Types.NULL:
return BasicType.NULL;
case Types.TIME:
return BasicType.TIME;
case Types.TIMESTAMP:
return BasicType.DATETIME;
case Types.VARCHAR:
return BasicType.STRING;
case Types.OTHER:
if (jdbcStringType.equals(""String_Node_Str"")) {
return BasicType.ARRAY;
}
break;
case Types.DISTINCT:
{
if (jdbcStringType.equals(""String_Node_Str"")) {
return BasicType.TWELVE_BYTES;
}
if (jdbcStringType.equals(""String_Node_Str"")) {
return BasicType.PATTERN;
}
break;
}
}
throw new ToroImplementationException(""String_Node_Str"" + jdbcStringType + ""String_Node_Str""+ jdbcIntType+ ""String_Node_Str""+ columnName+ ""String_Node_Str"");
}","public BasicType toBasicType(String columnName,int jdbcIntType,String jdbcStringType){
switch (jdbcIntType) {
case Types.BIGINT:
    return BasicType.LONG;
case Types.BOOLEAN:
case Types.BIT:
  return BasicType.BOOLEAN;
case Types.DATE:
return BasicType.DATE;
case Types.DOUBLE:
return BasicType.DOUBLE;
case Types.INTEGER:
return BasicType.INTEGER;
case Types.SMALLINT:
case Types.NULL:
return BasicType.NULL;
case Types.TIME:
return BasicType.TIME;
case Types.TIMESTAMP:
return BasicType.DATETIME;
case Types.VARCHAR:
return BasicType.STRING;
case Types.OTHER:
if (jdbcStringType.equals(""String_Node_Str"")) {
return BasicType.ARRAY;
}
break;
case Types.DISTINCT:
{
if (jdbcStringType.equals(""String_Node_Str"") || jdbcStringType.equals(TwelveBytesUDT.TWELVE_BYTES.getName())) {
return BasicType.TWELVE_BYTES;
}
if (jdbcStringType.equals(""String_Node_Str"") || jdbcStringType.equals(""String_Node_Str"")) {
return BasicType.PATTERN;
}
break;
}
}
throw new ToroImplementationException(""String_Node_Str"" + jdbcStringType + ""String_Node_Str""+ jdbcIntType+ ""String_Node_Str""+ columnName+ ""String_Node_Str"");
}"
54590,"private static void printConfig(Config config,Console console,ObjectWriter objectWriter) throws IOException, JsonGenerationException, JsonMappingException, UnsupportedEncodingException {
  ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
  PrintStream printStream=new PrintStream(byteArrayOutputStream,false,Charsets.UTF_8.name());
  objectWriter.writeValue(printStream,config);
  console.print(byteArrayOutputStream.toString(Charsets.UTF_8.name()));
}","private static void printConfig(Config config,Console console,ObjectWriter objectWriter) throws IOException, JsonGenerationException, JsonMappingException, UnsupportedEncodingException {
  ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();
  PrintStream printStream=new PrintStream(byteArrayOutputStream,false,Charsets.UTF_8.name());
  objectWriter.writeValue(printStream,config);
  console.println(byteArrayOutputStream.toString(Charsets.UTF_8.name()));
}"
54591,"public static void printParamDescriptionFromConfigSchema(Console console,int tabs) throws UnsupportedEncodingException, JsonMappingException {
  ObjectMapper objectMapper=new ObjectMapper();
  ResourceBundle resourceBundle=PropertyResourceBundle.getBundle(""String_Node_Str"");
  DescriptionFactoryWrapper visitor=new DescriptionFactoryWrapper(resourceBundle,console,tabs);
  objectMapper.acceptJsonFormatVisitor(objectMapper.constructType(Config.class),visitor);
}","public static void printParamDescriptionFromConfigSchema(Console console,int tabs) throws UnsupportedEncodingException, JsonMappingException {
  ObjectMapper objectMapper=new ObjectMapper();
  ResourceBundle resourceBundle=PropertyResourceBundle.getBundle(""String_Node_Str"");
  DescriptionFactoryWrapper visitor=new DescriptionFactoryWrapper(resourceBundle,console,tabs);
  objectMapper.acceptJsonFormatVisitor(objectMapper.constructType(Config.class),visitor);
  console.println(""String_Node_Str"");
}"
54592,"@Inject public TorodbMeta(String databaseName,DSLContext dsl,SQLWrapper sqlWrapper) throws SQLException, IOException, InvalidDatabaseException {
  this.databaseName=databaseName;
  Meta jooqMeta=dsl.meta();
  Connection conn=dsl.configuration().connectionProvider().acquire();
  DatabaseMetaData jdbcMeta=conn.getMetaData();
  collectionSchemes=new MapMaker().concurrencyLevel(1).makeMap();
  TorodbSchema.TORODB.checkOrCreate(dsl,jooqMeta,jdbcMeta);
  loadAllCollectionSchemas(dsl,jooqMeta,jdbcMeta);
  createTypes(conn,jdbcMeta);
  createProcedures(conn,jdbcMeta);
  createCast(conn,jdbcMeta);
  dsl.configuration().connectionProvider().release(conn);
  this.sqlWrapper=sqlWrapper;
}","@Inject public TorodbMeta(String databaseName,DSLContext dsl,SQLWrapper sqlWrapper) throws SQLException, IOException, InvalidDatabaseException {
  this.databaseName=databaseName;
  this.sqlWrapper=sqlWrapper;
  Meta jooqMeta=dsl.meta();
  Connection conn=dsl.configuration().connectionProvider().acquire();
  DatabaseMetaData jdbcMeta=conn.getMetaData();
  collectionSchemes=new MapMaker().concurrencyLevel(1).makeMap();
  TorodbSchema.TORODB.checkOrCreate(dsl,jooqMeta,jdbcMeta);
  loadAllCollectionSchemas(dsl,jooqMeta,jdbcMeta);
  createTypes(conn,jdbcMeta);
  createProcedures(conn,jdbcMeta);
  createCast(conn,jdbcMeta);
  dsl.configuration().connectionProvider().release(conn);
}"
54593,"@Override public void close(SessionExecutor executor){
  try {
    executor.noop().get();
synchronized (this) {
      closeImmediately(executor);
      closed=true;
    }
  }
 catch (  InterruptedException ex) {
    throw new ToroRuntimeException(ex);
  }
catch (  ExecutionException ex) {
    throw new ToroRuntimeException(ex);
  }
}","@Override public void close(SessionExecutor executor){
  try {
    executor.noop().get();
synchronized (this) {
      if (!closed) {
        closeImmediately(executor);
        closed=true;
      }
    }
  }
 catch (  InterruptedException ex) {
    throw new ToroRuntimeException(ex);
  }
catch (  ExecutionException ex) {
    throw new ToroRuntimeException(ex);
  }
}"
54594,"@Override public List<ToroDocument> read(SessionExecutor executor,int limit) throws ClosedToroCursorException {
  if (limit <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + limit + ""String_Node_Str"");
  }
  try {
    executor.noop().get();
synchronized (this) {
      if (isClosed()) {
        throw new ClosedToroCursorException();
      }
      List<? extends SplitDocument> splitDocs=executor.readCursor(getId(),limit).get();
      List<ToroDocument> docs=Lists.newArrayListWithCapacity(splitDocs.size());
      for (      SplitDocument splitDocument : splitDocs) {
        docs.add(d2r.translate(splitDocument));
      }
      position+=docs.size();
      if (isAutoclosable() && position == maxElements) {
        close(executor);
      }
      return docs;
    }
  }
 catch (  ToroTaskExecutionException ex) {
    throw new ToroRuntimeException(ex);
  }
catch (  InterruptedException ex) {
    throw new ToroRuntimeException(ex);
  }
catch (  ExecutionException ex) {
    throw new ToroRuntimeException(ex);
  }
}","@Override public List<ToroDocument> read(SessionExecutor executor,int limit) throws ClosedToroCursorException {
  if (limit <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + limit + ""String_Node_Str"");
  }
  limit=Math.min(limit,maxElements - position);
  try {
    executor.noop().get();
synchronized (this) {
      if (isClosed()) {
        throw new ClosedToroCursorException();
      }
      List<? extends SplitDocument> splitDocs=executor.readCursor(getId(),limit).get();
      List<ToroDocument> docs=Lists.newArrayListWithCapacity(splitDocs.size());
      for (      SplitDocument splitDocument : splitDocs) {
        docs.add(d2r.translate(splitDocument));
      }
      position+=docs.size();
      if (isAutoclosable() && position == maxElements) {
        close(executor);
      }
      return docs;
    }
  }
 catch (  ToroTaskExecutionException ex) {
    throw new ToroRuntimeException(ex);
  }
catch (  InterruptedException ex) {
    throw new ToroRuntimeException(ex);
  }
catch (  ExecutionException ex) {
    throw new ToroRuntimeException(ex);
  }
}"
54595,"int reserveDocId(SessionExecutor sessionExecutor,int neededIds){
  int firstFreeId=info.getAndAddLastUsedId(neededIds) + 1;
  Future<?> blocker=reserveMoreIdsIfNeeded(collection,info);
  if (blocker == null) {
    LOGGER.debug(""String_Node_Str"",neededIds,collection);
  }
 else {
    Long tick=systemExecutor.getTick();
    sessionExecutor.pauseUntil(tick);
    LOGGER.debug(""String_Node_Str"",neededIds,collection);
  }
  return firstFreeId;
}","int reserveDocId(SessionExecutor sessionExecutor,int neededIds){
  int firstFreeId=info.getAndAddLastUsedId(neededIds) + 1;
  Future<?> blocker=reserveMoreIdsIfNeeded(collection,info);
  if (blocker == null) {
    LOGGER.trace(""String_Node_Str"",neededIds,collection);
  }
 else {
    Long tick=systemExecutor.getTick();
    sessionExecutor.pauseUntil(tick);
    LOGGER.debug(""String_Node_Str"",neededIds,collection);
  }
  return firstFreeId;
}"
54596,"@Override public ToroCursor<ToroDocument> openLimitedCursor(@Nonnull SessionExecutor sessionExecutor,String collection,@Nullable QueryCriteria queryCriteria,@Nullable Projection projection,int numberToSkip,int maxResults,boolean autoclose,boolean hasTimeout){
  CursorId id=consumeId();
  Future<Void> query=sessionExecutor.query(collection,id,queryCriteria,projection,0);
  try {
    query.get();
  }
 catch (  InterruptedException ex) {
    throw new ToroRuntimeException(ex);
  }
catch (  ExecutionException ex) {
    throw new ToroRuntimeException(ex);
  }
  StandardDocumentToroCursor cursor=new StandardDocumentToroCursor(sessionExecutor,id,hasTimeout,maxResults,autoclose,d2r);
  return storage.storeCursor(cursor,sessionExecutor);
}","@Override public ToroCursor<ToroDocument> openLimitedCursor(@Nonnull SessionExecutor sessionExecutor,String collection,@Nullable QueryCriteria queryCriteria,@Nullable Projection projection,int numberToSkip,int maxResults,boolean autoclose,boolean hasTimeout){
  CursorId id=consumeId();
  Future<Void> query=sessionExecutor.query(collection,id,queryCriteria,projection,maxResults);
  try {
    query.get();
  }
 catch (  InterruptedException ex) {
    throw new ToroRuntimeException(ex);
  }
catch (  ExecutionException ex) {
    throw new ToroRuntimeException(ex);
  }
  StandardDocumentToroCursor cursor=new StandardDocumentToroCursor(sessionExecutor,id,hasTimeout,maxResults,autoclose,d2r);
  return storage.storeCursor(cursor,sessionExecutor);
}"
54597,"public static void main(String[] args) throws Exception {
  final Config config=new Config();
  JCommander jCommander=new JCommander(config,args);
  if (config.help()) {
    jCommander.usage();
    System.exit(0);
  }
  File toroPass=new File(System.getProperty(""String_Node_Str"") + ""String_Node_Str"");
  if (toroPass.exists() && toroPass.canRead() && toroPass.isFile()) {
    BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(toroPass),Charset.forName(""String_Node_Str"")));
    String line;
    while ((line=br.readLine()) != null) {
      String[] toroPassChunks=line.split(""String_Node_Str"");
      if (toroPassChunks.length != 5) {
        continue;
      }
      if ((toroPassChunks[0].equals(""String_Node_Str"") || toroPassChunks[0].equals(config.getDbHost())) && (toroPassChunks[1].equals(""String_Node_Str"") || toroPassChunks[1].equals(String.valueOf(config.getDbPort()))) && (toroPassChunks[2].equals(""String_Node_Str"") || toroPassChunks[2].equals(config.getDbName()))&& (toroPassChunks[2].equals(""String_Node_Str"") || toroPassChunks[3].equals(config.getUsername()))) {
        config.setPassword(toroPassChunks[4]);
      }
    }
    br.close();
  }
  if (!config.hasPassword() || config.askForPassword()) {
    config.setPassword(readPwd(""String_Node_Str""));
  }
  if (config.debug()) {
    Logger root=(Logger)LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);
    root.setLevel(Level.DEBUG);
  }
 else {
    if (config.verbose()) {
      Logger root=(Logger)LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);
      root.setLevel(Level.INFO);
    }
 else {
      Logger root=(Logger)LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);
      root.setLevel(Level.WARN);
    }
  }
  Injector injector=Guice.createInjector(new BackendModule(config),new PostgreSQLModule(),new ConfigModule(config),new MongoServerModule(),new DbWrapperModule(),new ExecutorModule(1000,1000,0.2),new DbMetaInformationCacheModule(),new D2RModule(),new ConnectionModule(),new InnerCursorManagerModule());
  final DbBackend dbBackend;
  try {
    dbBackend=injector.getInstance(DbBackend.class);
    final Torod torod=injector.getInstance(Torod.class);
    final MongoServer server=injector.getInstance(MongoServer.class);
    final BuildProperties buildProperties=injector.getInstance(BuildProperties.class);
    Thread shutdown=new Thread(){
      @Override public void run(){
        shutdown(dbBackend,torod,server);
      }
    }
;
    Runtime.getRuntime().addShutdownHook(shutdown);
    Thread serverThread=new Thread(){
      @Override public void run(){
        JCommander.getConsole().println(""String_Node_Str"" + buildProperties.getFullVersion() + ""String_Node_Str""+ config.getPort());
        Main.run(torod,server);
        shutdown(dbBackend,torod,server);
      }
    }
;
    serverThread.start();
  }
 catch (  ProvisionException pe) {
    String causeMessage;
    if (pe.getCause() != null) {
      causeMessage=pe.getCause().getMessage();
    }
 else {
      causeMessage=pe.getMessage();
    }
    JCommander.getConsole().println(causeMessage);
    System.exit(1);
  }
}","public static void main(String[] args) throws Exception {
  final Config config=new Config();
  JCommander jCommander=new JCommander(config,args);
  if (config.help()) {
    jCommander.usage();
    System.exit(0);
  }
  File toroPass=new File(System.getProperty(""String_Node_Str"") + ""String_Node_Str"");
  if (toroPass.exists() && toroPass.canRead() && toroPass.isFile()) {
    BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(toroPass),Charset.forName(""String_Node_Str"")));
    String line;
    while ((line=br.readLine()) != null) {
      String[] toroPassChunks=line.split(""String_Node_Str"");
      if (toroPassChunks.length != 5) {
        continue;
      }
      if ((toroPassChunks[0].equals(""String_Node_Str"") || toroPassChunks[0].equals(config.getDbHost())) && (toroPassChunks[1].equals(""String_Node_Str"") || toroPassChunks[1].equals(String.valueOf(config.getDbPort()))) && (toroPassChunks[2].equals(""String_Node_Str"") || toroPassChunks[2].equals(config.getDbName()))&& (toroPassChunks[3].equals(""String_Node_Str"") || toroPassChunks[3].equals(config.getUsername()))) {
        config.setPassword(toroPassChunks[4]);
      }
    }
    br.close();
  }
  if (!config.hasPassword() || config.askForPassword()) {
    config.setPassword(readPwd(""String_Node_Str""));
  }
  if (config.debug()) {
    Logger root=(Logger)LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);
    root.setLevel(Level.DEBUG);
  }
 else {
    if (config.verbose()) {
      Logger root=(Logger)LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);
      root.setLevel(Level.INFO);
    }
 else {
      Logger root=(Logger)LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);
      root.setLevel(Level.WARN);
    }
  }
  Injector injector=Guice.createInjector(new BackendModule(config),new PostgreSQLModule(),new ConfigModule(config),new MongoServerModule(),new DbWrapperModule(),new ExecutorModule(1000,1000,0.2),new DbMetaInformationCacheModule(),new D2RModule(),new ConnectionModule(),new InnerCursorManagerModule());
  final DbBackend dbBackend;
  try {
    dbBackend=injector.getInstance(DbBackend.class);
    final Torod torod=injector.getInstance(Torod.class);
    final MongoServer server=injector.getInstance(MongoServer.class);
    final BuildProperties buildProperties=injector.getInstance(BuildProperties.class);
    Thread shutdown=new Thread(){
      @Override public void run(){
        shutdown(dbBackend,torod,server);
      }
    }
;
    Runtime.getRuntime().addShutdownHook(shutdown);
    Thread serverThread=new Thread(){
      @Override public void run(){
        JCommander.getConsole().println(""String_Node_Str"" + buildProperties.getFullVersion() + ""String_Node_Str""+ config.getPort());
        Main.run(torod,server);
        shutdown(dbBackend,torod,server);
      }
    }
;
    serverThread.start();
  }
 catch (  ProvisionException pe) {
    String causeMessage;
    if (pe.getCause() != null) {
      causeMessage=pe.getCause().getMessage();
    }
 else {
      causeMessage=pe.getMessage();
    }
    JCommander.getConsole().println(causeMessage);
    System.exit(1);
  }
}"
54598,"@Override public PosixPatternValue toValue(String value){
  return new PosixPatternValue(value.substring(1,value.length() - 1));
}","@Override public PosixPatternValue toValue(String value){
  return new PosixPatternValue(value);
}"
54599,"private String translateValueToJsonb(Value value){
  ValueConverter converter=ValueToJsonbConverterProvider.getInstance().getConverter(value.getType());
  Object translatedObject=converter.toJson(value);
  String result;
  if (value.getType().equals(BasicType.STRING)) {
    result='\""' + translatedObject.toString() + '\""';
  }
 else {
    result=translatedObject.toString();
  }
  return result;
}","private String translateValueToJsonb(Value value){
  ValueConverter converter=ValueToJsonbConverterProvider.getInstance().getConverter(value.getType());
  Object translatedObject=converter.toJson(value);
  String result;
  if (translatedObject instanceof String) {
    result='\""' + (String)translatedObject + '\""';
  }
 else {
    result=translatedObject.toString();
  }
  return result;
}"
54600,"@Override protected void queryNamespaces(QueryMessage queryMessage,MessageReplier messageReplier) throws ImplementationDbException {
  AttributeMap attributeMap=messageReplier.getAttributeMap();
  ToroConnection connection=attributeMap.attr(ToroRequestProcessor.CONNECTION).get();
  Collection<String> allCollections=connection.getCollections();
  List<ToroDocument> candidates=Lists.newArrayList();
  ToroTransaction transaction=connection.createTransaction();
  try {
    for (    String collection : allCollections) {
      String collectionNamespace=databaseName + '.' + collection;
      candidates.add(new KVToroDocument(new ObjectValue.Builder().putValue(collection,collectionNamespace).build()));
      Collection<? extends NamedToroIndex> indexes=transaction.getIndexes(collection);
      for (      NamedToroIndex index : indexes) {
        candidates.add(new KVToroDocument(new ObjectValue.Builder().putValue(""String_Node_Str"",collectionNamespace + '.' + index.getName()).build()));
      }
    }
    candidates.add(new KVToroDocument(new ObjectValue.Builder().putValue(""String_Node_Str"",databaseName + ""String_Node_Str"").build()));
  }
  finally {
    transaction.close();
  }
  QueryCriteria queryCriteria=Util.translateQuery(queryMessage.getDocument());
  Collection<ToroDocument> filtrered=applyQueryCriteria(candidates,queryCriteria);
  BSONDocuments docs=new BSONDocuments(filtrered);
  messageReplier.replyMessageNoCursor(docs);
}","@Override protected void queryNamespaces(QueryMessage queryMessage,MessageReplier messageReplier) throws ImplementationDbException {
  AttributeMap attributeMap=messageReplier.getAttributeMap();
  ToroConnection connection=attributeMap.attr(ToroRequestProcessor.CONNECTION).get();
  Collection<String> allCollections=connection.getCollections();
  List<ToroDocument> candidates=Lists.newArrayList();
  ToroTransaction transaction=connection.createTransaction();
  try {
    for (    String collection : allCollections) {
      String collectionNamespace=databaseName + '.' + collection;
      candidates.add(new KVToroDocument(new ObjectValue.Builder().putValue(""String_Node_Str"",collectionNamespace).build()));
      Collection<? extends NamedToroIndex> indexes=transaction.getIndexes(collection);
      for (      NamedToroIndex index : indexes) {
        candidates.add(new KVToroDocument(new ObjectValue.Builder().putValue(""String_Node_Str"",collectionNamespace + '.' + index.getName()).build()));
      }
    }
    candidates.add(new KVToroDocument(new ObjectValue.Builder().putValue(""String_Node_Str"",databaseName + ""String_Node_Str"").build()));
  }
  finally {
    transaction.close();
  }
  QueryCriteria queryCriteria=Util.translateQuery(queryMessage.getDocument());
  Collection<ToroDocument> filtrered=applyQueryCriteria(candidates,queryCriteria);
  BSONDocuments docs=new BSONDocuments(filtrered);
  messageReplier.replyMessageNoCursor(docs);
}"
54601,"public Builder putValue(String key,DocValue value){
  checkNewBuild();
  if (value instanceof ObjectValue) {
    newObject(key).copy((ObjectValue)value);
  }
 else {
    if (value instanceof ArrayValue) {
      newArray(key).copy((ArrayValue)value);
    }
 else {
      values.put(key,value);
      subArrayBuilders.remove(key);
      subObjectBuilders.remove(key);
    }
  }
  return this;
}","public Builder putValue(String key,ArrayValue.Builder value){
  return putValue(key,value.build());
}"
54602,"public DropCollectionCallable(DbConnection connection,TransactionAborter abortCallback,Report report,String collection){
  super(connection,abortCallback);
  this.report=report;
  this.collection=collection;
}","public DropCollectionCallable(DbWrapper dbWrapperPool,String collection,Report report){
  super(dbWrapperPool);
  this.report=report;
  this.collection=collection;
}"
54603,"public Collection<String> getAttributes(){
  return attributes;
}","public Set<String> getAttributes(){
  return attributes;
}"
54604,"public static void execute(Configuration jooqConf,CollectionSchema colSchema){
  DSLContext dsl=DSL.using(jooqConf);
  for (  SubDocTable subDocTable : colSchema.getSubDocTables()) {
    deleteAll(dsl,subDocTable);
  }
  Table<Record> rootTable=DSL.tableByName(colSchema.getName(),""String_Node_Str"");
  deleteAll(dsl,rootTable);
}","@SuppressFBWarnings(""String_Node_Str"") public static void execute(Configuration jooqConf,CollectionSchema colSchema){
  ConnectionProvider provider=jooqConf.connectionProvider();
  Connection connection=provider.acquire();
  Statement st=null;
  try {
    st=connection.createStatement();
    st.executeUpdate(""String_Node_Str"" + colSchema.getName() + ""String_Node_Str"");
  }
 catch (  SQLException ex) {
    throw new ToroImplementationException(ex);
  }
 finally {
    AutoCloser.close(st);
  }
}"
54605,"@Override public void dropCollection(String collection){
  CollectionSchema colSchema=meta.getCollectionSchema(collection);
  Routines.dropCollection(jooqConf,colSchema);
}","@Override public void dropCollection(String collection){
  CollectionSchema colSchema=meta.getCollectionSchema(collection);
  Routines.dropCollection(jooqConf,colSchema);
  meta.dropCollectionSchema(collection);
}"
54606,"@Nullable private DocValue resolve(Iterator<AttributeReference.Key> atts,ArrayValue value){
  if (!atts.hasNext()) {
    return value;
  }
 else {
    AttributeReference.Key nextAtt=atts.next();
    if (!(nextAtt instanceof AttributeReference.ArrayKey)) {
      return null;
    }
 else {
      DocValue referencedValue=value.get(((AttributeReference.ArrayKey)nextAtt).getKeyValue());
      if (!atts.hasNext()) {
        return referencedValue;
      }
      if (referencedValue instanceof ObjectValue) {
        return resolve(atts,(ObjectValue)referencedValue);
      }
      if (referencedValue instanceof ArrayValue) {
        return resolve(atts,(ArrayValue)referencedValue);
      }
 else {
        return null;
      }
    }
  }
}","@Nullable private DocValue resolve(Iterator<AttributeReference.Key> atts,ArrayValue value){
  if (!atts.hasNext()) {
    return value;
  }
 else {
    AttributeReference.Key nextAtt=atts.next();
    if (!(nextAtt instanceof AttributeReference.ArrayKey)) {
      return null;
    }
 else {
      AttributeReference.ArrayKey castedAtt=(AttributeReference.ArrayKey)nextAtt;
      if (castedAtt.getIndex() < 0) {
        return null;
      }
      if (castedAtt.getIndex() >= value.size()) {
        return null;
      }
      DocValue referencedValue=value.get(castedAtt.getKeyValue());
      if (!atts.hasNext()) {
        return referencedValue;
      }
      if (referencedValue instanceof ObjectValue) {
        return resolve(atts,(ObjectValue)referencedValue);
      }
      if (referencedValue instanceof ArrayValue) {
        return resolve(atts,(ArrayValue)referencedValue);
      }
 else {
        return null;
      }
    }
  }
}"
54607,"@Override protected void queryIndexes(QueryMessage queryMessage,MessageReplier messageReplier) throws ImplementationDbException {
  AttributeMap attributeMap=messageReplier.getAttributeMap();
  ToroConnection connection=attributeMap.attr(ToroRequestProcessor.CONNECTION).get();
  String collection=queryMessage.getCollection();
  List<ToroDocument> candidates=Lists.newArrayList();
  ToroTransaction transaction=connection.createTransaction();
  try {
    String collectionNamespace=databaseName + '.' + collection;
    Collection<? extends NamedToroIndex> indexes=transaction.getIndexes(collection);
    for (    NamedToroIndex index : indexes) {
      ObjectValue.Builder objBuider=new ObjectValue.Builder().putValue(""String_Node_Str"",1).putValue(""String_Node_Str"",index.getName()).putValue(""String_Node_Str"",collectionNamespace).putValue(""String_Node_Str"",new ObjectValue.Builder());
      ObjectValue.Builder keyBuilder=new ObjectValue.Builder();
      for (      Map.Entry<AttributeReference,Boolean> entrySet : index.getAttributes().entrySet()) {
        keyBuilder.putValue(entrySet.getKey().toString(),entrySet.getValue() ? 1 : -1);
      }
      objBuider.putValue(""String_Node_Str"",keyBuilder);
      candidates.add(new KVToroDocument(objBuider.build()));
    }
  }
  finally {
    transaction.close();
  }
  QueryCriteria queryCriteria=Util.translateQuery(queryMessage.getDocument());
  Collection<ToroDocument> filtrered=applyQueryCriteria(candidates,queryCriteria);
  BSONDocuments docs=new BSONDocuments(filtrered);
  messageReplier.replyMessageNoCursor(docs);
}","@Override protected void queryIndexes(QueryMessage queryMessage,MessageReplier messageReplier) throws ImplementationDbException {
  AttributeMap attributeMap=messageReplier.getAttributeMap();
  ToroConnection connection=attributeMap.attr(ToroRequestProcessor.CONNECTION).get();
  Collection<String> allCollections=connection.getCollections();
  List<ToroDocument> candidates=Lists.newArrayList();
  ToroTransaction transaction=connection.createTransaction();
  try {
    for (    String collection : allCollections) {
      String collectionNamespace=databaseName + '.' + collection;
      Collection<? extends NamedToroIndex> indexes=transaction.getIndexes(collection);
      for (      NamedToroIndex index : indexes) {
        ObjectValue.Builder objBuider=new ObjectValue.Builder().putValue(""String_Node_Str"",1).putValue(""String_Node_Str"",index.getName()).putValue(""String_Node_Str"",collectionNamespace).putValue(""String_Node_Str"",new ObjectValue.Builder());
        ObjectValue.Builder keyBuilder=new ObjectValue.Builder();
        for (        Map.Entry<AttributeReference,Boolean> entrySet : index.getAttributes().entrySet()) {
          keyBuilder.putValue(entrySet.getKey().toString(),entrySet.getValue() ? 1 : -1);
        }
        objBuider.putValue(""String_Node_Str"",keyBuilder);
        candidates.add(new KVToroDocument(objBuider.build()));
      }
    }
  }
  finally {
    transaction.close();
  }
  QueryCriteria queryCriteria=Util.translateQuery(queryMessage.getDocument());
  Collection<ToroDocument> filtrered=applyQueryCriteria(candidates,queryCriteria);
  BSONDocuments docs=new BSONDocuments(filtrered);
  messageReplier.replyMessageNoCursor(docs);
}"
54608,"@Override protected void configure(){
  bind(RequestProcessor.class).to(ToroRequestProcessor.class);
  bind(BuildProperties.class).asEagerSingleton();
  bind(QueryCommandProcessor.class).to(ToroQueryCommandProcessor.class);
}","@Override protected void configure(){
  bind(RequestProcessor.class).to(ToroRequestProcessor.class);
  bind(BuildProperties.class).asEagerSingleton();
  bind(QueryCommandProcessor.class).to(ToroQueryCommandProcessor.class);
  bind(MetaQueryProcessor.class).to(ToroMetaQueryProcessor.class).in(Singleton.class);
}"
54609,"@Override public ToroTransaction createTransaction() throws ImplementationDbException {
  SessionTransaction sessionTransaction=executor.createTransaction();
  return new DefaultToroTransaction(session,sessionTransaction,d2r,executor,documentBuilderFactory,cursorManager,cache);
}","@Override public ToroTransaction createTransaction() throws ImplementationDbException {
  SessionTransaction sessionTransaction=executor.createTransaction();
  return new DefaultToroTransaction(session,sessionTransaction,d2r,executor,documentBuilderFactory,cursorManager);
}"
54610,"@Override public Collection<? extends NamedToroIndex> getIndexes(){
  return cache.getIndexes();
}","@Override public Collection<? extends NamedToroIndex> getIndexes(String collection){
  try {
    return sessionTransaction.getIndexes(collection).get();
  }
 catch (  InterruptedException ex) {
    throw new ToroRuntimeException(ex);
  }
catch (  ExecutionException ex) {
    throw new ToroRuntimeException(ex);
  }
}"
54611,"@Override public Future<NamedToroIndex> createIndex(String indexName,IndexedAttributes attributes,boolean unique,boolean blocking){
  return cache.createIndex(indexName,attributes,unique,blocking);
}","@Override public Future<NamedToroIndex> createIndex(String collection,String indexName,IndexedAttributes attributes,boolean unique,boolean blocking){
  return sessionTransaction.createIndex(collection,indexName,attributes,unique,blocking);
}"
54612,"DefaultToroTransaction(Session session,SessionTransaction sessionTransaction,D2RTranslator d2r,SessionExecutor executor,DocumentBuilderFactory documentBuilderFactory,CursorManager cursorManager,DbMetaInformationCache cache){
  this.sessionTransaction=sessionTransaction;
  this.d2r=d2r;
  this.executor=executor;
  this.documentBuilderFactory=documentBuilderFactory;
  this.cursorManager=cursorManager;
  this.cache=cache;
}","DefaultToroTransaction(Session session,SessionTransaction sessionTransaction,D2RTranslator d2r,SessionExecutor executor,DocumentBuilderFactory documentBuilderFactory,CursorManager cursorManager){
  this.sessionTransaction=sessionTransaction;
  this.d2r=d2r;
  this.executor=executor;
  this.documentBuilderFactory=documentBuilderFactory;
  this.cursorManager=cursorManager;
}"
54613,"@Override public Future<Boolean> dropIndex(String indexName){
  return cache.dropIndex(indexName);
}","@Override public Future<Boolean> dropIndex(String collection,String indexName){
  return sessionTransaction.dropIndex(collection,indexName);
}"
54614,"@Override public <R>R catchSystemException(Throwable t,Callable<R> task) throws Exception {
  Logger.getLogger(DefaultExceptionHandler.class.getName()).log(Level.SEVERE,null,t);
  return null;
}","@Override public <R>R catchSystemException(Throwable t,Callable<R> task) throws Exception {
  LOGGER.error(""String_Node_Str"",t);
  throw new ToroImplementationException(t);
}"
54615,"@Override public <R>R catchSessionException(Throwable t,Callable<R> task,Session s) throws Exception {
  Logger.getLogger(DefaultExceptionHandler.class.getName()).log(Level.SEVERE,null,t);
  return null;
}","@Override public <R>R catchSessionException(Throwable t,Callable<R> task,Session s) throws Exception {
  LOGGER.error(""String_Node_Str"",t);
  throw new UserToroException(t);
}"
54616,"@Override public Future<List<? extends SplitDocument>> readAllCursor(CursorId cursorId) throws ToroTaskExecutionException {
  return submit(new ReadAllCursorCallable(wrapper,cursorId,reportFactory.createReadAllCursorReport()));
}","@Override public Future<List<? extends SplitDocument>> readAllCursor(CursorId cursorId) throws ToroTaskExecutionException {
  return submit(new ReadAllCursorCallable(wrapper,reportFactory.createReadAllCursorReport(),cursorId));
}"
54617,"protected <R>Future<R> submit(Callable<R> callable){
  return executorService.submit(new DefaultSessionExecutor.SessionRunnable(callable));
}","protected <R>Future<R> submit(Job<R> job){
  return executorService.submit(new DefaultSessionExecutor.SessionRunnable(job));
}"
54618,"@Override public Future<List<? extends Database>> getDatabases(){
  return submit(new GetDatabasesCallable(wrapper,databaseName));
}","@Override public Future<List<? extends Database>> getDatabases(){
  return submit(new GetDatabasesCallable(wrapper,reportFactory.createGetDatabasesReport(),databaseName));
}"
54619,"@Override public Future<Integer> countRemainingDocs(CursorId cursorId){
  return submit(new CountRemainingDocs(wrapper,cursorId,reportFactory.createCountRemainingDocsReport()));
}","@Override public Future<Integer> countRemainingDocs(CursorId cursorId){
  return submit(new CountRemainingDocsCallable(wrapper,reportFactory.createCountRemainingDocsReport(),cursorId));
}"
54620,"@Override public Future<Void> query(String collection,CursorId cursorId,QueryCriteria filter,Projection projection,int maxResults){
  return submit(new QueryCallable(wrapper,collection,cursorId,filter,projection,maxResults,reportFactory.createQueryReport()));
}","@Override public Future<Void> query(String collection,CursorId cursorId,QueryCriteria filter,Projection projection,int maxResults){
  return submit(new QueryCallable(wrapper,reportFactory.createQueryReport(),collection,cursorId,filter,projection,maxResults));
}"
54621,"public SessionRunnable(Callable<R> delegate){
  this.delegate=delegate;
}","public SessionRunnable(Job<R> delegate){
  this.delegate=delegate;
}"
54622,"@Inject public DefaultSessionExecutor(ExceptionHandler exceptionHandler,DbWrapper wrapper,ExecutorServiceProvider executorServiceProvider,Monitor monitor,Session session,ReportFactory reportFactory,@DatabaseName String databaseName){
  this.executorServiceProvider=executorServiceProvider;
  this.exceptionHandler=exceptionHandler;
  this.wrapper=wrapper;
  this.executorService=executorServiceProvider.consumeSessionExecutorService(session);
  this.monitor=monitor;
  this.session=session;
  this.reportFactory=reportFactory;
  this.databaseName=databaseName;
}","@Inject public DefaultSessionExecutor(ExceptionHandler exceptionHandler,DbWrapper wrapper,ExecutorServiceProvider executorServiceProvider,Monitor monitor,Session session,ReportFactory reportFactory,@DatabaseName String databaseName){
  this.executorServiceProvider=executorServiceProvider;
  this.exceptionHandler=exceptionHandler;
  this.wrapper=new LazyDbWrapper(wrapper);
  this.executorService=executorServiceProvider.consumeSessionExecutorService(session);
  this.monitor=monitor;
  this.session=session;
  this.reportFactory=reportFactory;
  this.databaseName=databaseName;
}"
54623,"@Override public Future<List<? extends SplitDocument>> readCursor(CursorId cursorId,int limit) throws ToroTaskExecutionException {
  return submit(new ReadCursorCallable(wrapper,cursorId,limit,reportFactory.createReadCursorReport()));
}","@Override public Future<List<? extends SplitDocument>> readCursor(CursorId cursorId,int limit) throws ToroTaskExecutionException {
  return submit(new ReadCursorCallable(wrapper,reportFactory.createReadCursorReport(),cursorId,limit));
}"
54624,"@Override public SessionTransaction createTransaction() throws ImplementationDbException {
  return new DefaultSessionTransaction(this,wrapper,reportFactory);
}","@Override public SessionTransaction createTransaction() throws ImplementationDbException {
  return new DefaultSessionTransaction(this,wrapper.consumeSessionDbConnection(),reportFactory);
}"
54625,"@Override public Future<?> closeCursor(CursorId cursorId) throws ToroTaskExecutionException {
  return submit(new CloseCursorCallable(wrapper,cursorId,reportFactory.createCloseCursorReport()));
}","@Override public Future<?> closeCursor(CursorId cursorId) throws ToroTaskExecutionException {
  return submit(new CloseCursorCallable(wrapper,reportFactory.createCloseCursorReport(),cursorId));
}"
54626,"private static int executeDeleteRoots(DSLContext dsl,CollectionSchema colSchema,Collection<Integer> dids){
  Field<Integer> idField=DSL.field(""String_Node_Str"",SQLDataType.INTEGER.nullable(false));
  Table<Record> rootTable=DSL.tableByName(colSchema.getName(),""String_Node_Str"");
  return dsl.delete(rootTable).where(idField.in(dids)).execute();
}","private static int executeDeleteRoots(DSLContext dsl,CollectionSchema colSchema,Collection<Integer> dids) throws SQLException {
  ConnectionProvider connectionProvider=dsl.configuration().connectionProvider();
  Connection connection=connectionProvider.acquire();
  try {
    Table<Record> rootTable=DSL.tableByName(colSchema.getName(),""String_Node_Str"");
    return delete(connection,colSchema,rootTable,dids);
  }
  finally {
    connectionProvider.release(connection);
  }
}"
54627,"private static void executeDeleteSubDocuments(DSLContext dsl,Set<SubDocTable> tables,Collection<Integer> dids){
  for (  SubDocTable table : tables) {
    dsl.delete(table).where(table.getDidColumn().in(dids)).execute();
  }
}","private static void executeDeleteSubDocuments(DSLContext dsl,Set<SubDocTable> tables,Collection<Integer> dids){
  ConnectionProvider connectionProvider=dsl.configuration().connectionProvider();
  Connection connection=connectionProvider.acquire();
  try {
    for (    SubDocTable table : tables) {
      delete(connection,table.getSchema(),table,dids);
    }
  }
 catch (  SQLException ex) {
    throw new RuntimeException(ex);
  }
 finally {
    connectionProvider.release(connection);
  }
}"
54628,"public static int execute(Configuration configuration,CollectionSchema colSchema,Multimap<DocStructure,Integer> didsByStructure){
  TableProvider tableProvider=new TableProvider(colSchema);
  DSLContext dsl=DSL.using(configuration);
  Set<SubDocTable> tables=Sets.newHashSet();
  for (  DocStructure structure : didsByStructure.keySet()) {
    tables.clear();
    structure.accept(tableProvider,tables);
    executeDeleteSubDocuments(dsl,tables,didsByStructure.get(structure));
  }
  Set<Integer> dids=Sets.newHashSet(didsByStructure.values());
  return executeDeleteRoots(dsl,colSchema,dids);
}","public static int execute(Configuration configuration,CollectionSchema colSchema,Multimap<DocStructure,Integer> didsByStructure) throws SQLException {
  TableProvider tableProvider=new TableProvider(colSchema);
  DSLContext dsl=DSL.using(configuration);
  Set<SubDocTable> tables=Sets.newHashSet();
  for (  DocStructure structure : didsByStructure.keySet()) {
    tables.clear();
    structure.accept(tableProvider,tables);
    executeDeleteSubDocuments(dsl,tables,didsByStructure.get(structure));
  }
  Set<Integer> dids=Sets.newHashSet(didsByStructure.values());
  return executeDeleteRoots(dsl,colSchema,dids);
}"
54629,"public static DocValue translateBSON(Object value){
  if (value instanceof Double) {
    return new DoubleValue((Double)value);
  }
  if (value instanceof String) {
    return new StringValue((String)value);
  }
  if (value instanceof List) {
    List list=(List)value;
    return translateArray(list);
  }
  if (value instanceof BSONObject) {
    return translateObject((BSONObject)value);
  }
  if (value instanceof ObjectId) {
    ObjectId id=(ObjectId)value;
    byte[] bsonBytes=id.toByteArray();
    return new TwelveBytesValue(bsonBytes);
  }
  if (value instanceof Boolean) {
    Boolean bool=(Boolean)value;
    if (bool) {
      return BooleanValue.TRUE;
    }
    return BooleanValue.FALSE;
  }
  if (value instanceof Date) {
    Date date=(Date)value;
    LocalDateTime dateTime=LocalDateTime.ofInstant(Instant.ofEpochMilli(date.getTime()),ZoneOffset.UTC);
    return new DateTimeValue(dateTime);
  }
  if (value == null) {
    return NullValue.INSTANCE;
  }
  if (value instanceof Integer) {
    return new IntegerValue((Integer)value);
  }
  if (value instanceof Long) {
    return new LongValue((Long)value);
  }
  throw new IllegalArgumentException(""String_Node_Str"" + value.getClass() + ""String_Node_Str"");
}","public static DocValue translateBSON(Object value){
  if (value instanceof Double) {
    return new DoubleValue((Double)value);
  }
  if (value instanceof String) {
    return new StringValue((String)value);
  }
  if (value instanceof List) {
    List list=(List)value;
    return translateArray(list);
  }
  if (value instanceof BSONObject) {
    return translateObject((BSONObject)value);
  }
  if (value instanceof ObjectId) {
    ObjectId id=(ObjectId)value;
    byte[] bsonBytes=id.toByteArray();
    return new TwelveBytesValue(bsonBytes);
  }
  if (value instanceof Boolean) {
    Boolean bool=(Boolean)value;
    if (bool) {
      return BooleanValue.TRUE;
    }
    return BooleanValue.FALSE;
  }
  if (value instanceof Date) {
    Date date=(Date)value;
    LocalDateTime dateTime=LocalDateTime.ofInstant(Instant.ofEpochMilli(date.getTime()),ZoneId.systemDefault());
    return new DateTimeValue(dateTime);
  }
  if (value == null) {
    return NullValue.INSTANCE;
  }
  if (value instanceof Integer) {
    return new IntegerValue((Integer)value);
  }
  if (value instanceof Long) {
    return new LongValue((Long)value);
  }
  throw new IllegalArgumentException(""String_Node_Str"" + value.getClass() + ""String_Node_Str"");
}"
54630,"@Override public int getItemViewType(int position){
  if (position == 1)   return VIEW_TYPES.FIRST_VIEW;
  return position == 0 ? VIEW_TYPES.HEADER : VIEW_TYPES.NORMAL;
}","@Override public int getItemViewType(int position){
  if (position == 1)   return VIEW_TYPES.FIRST_VIEW;
  return position == 0 && mHeader != null ? VIEW_TYPES.HEADER : VIEW_TYPES.NORMAL;
}"
54631,"@Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup viewGroup,final int i){
  if (i == VIEW_TYPES.HEADER && mHeader != null)   return new ViewHolder(mHeader);
  if (i == VIEW_TYPES.FIRST_VIEW && mHeader != null && mRecyclerView != null) {
    final RecyclerView.ViewHolder holder=mRecyclerView.findViewHolderForAdapterPosition(0);
    if (holder != null) {
      translateHeader(-holder.itemView.getTop());
    }
  }
  final RecyclerView.ViewHolder holder=onCreateViewHolderImpl(viewGroup,this,i);
  if (mOnClickEvent != null) {
    holder.itemView.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        mOnClickEvent.onClick(v,holder.getAdapterPosition() - (mHeader == null ? 0 : 1));
      }
    }
);
  }
  return holder;
}","@Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup viewGroup,final int i){
  if (i == VIEW_TYPES.HEADER && mHeader != null) {
    return new ViewHolder(mHeader);
  }
  if (i == VIEW_TYPES.FIRST_VIEW && mHeader != null && mRecyclerView != null) {
    final RecyclerView.ViewHolder holder=mRecyclerView.findViewHolderForAdapterPosition(0);
    if (holder != null) {
      translateHeader(-holder.itemView.getTop());
    }
  }
  final RecyclerView.ViewHolder holder=onCreateViewHolderImpl(viewGroup,this,i);
  if (mOnClickEvent != null) {
    holder.itemView.setOnClickListener(new View.OnClickListener(){
      @Override public void onClick(      View v){
        mOnClickEvent.onClick(v,holder.getAdapterPosition() - (mHeader == null ? 0 : 1));
      }
    }
);
  }
  return holder;
}"
54632,"@Override public void onScrolled(RecyclerView recyclerView,int dx,int dy){
  super.onScrolled(recyclerView,dx,dy);
  if (mHeader != null) {
    if (mHeader != null) {
      translateHeader(mRecyclerView.getLayoutManager().getChildAt(0) == mHeader ? mRecyclerView.computeVerticalScrollOffset() : mHeader.getHeight());
    }
  }
}","@Override public void onScrolled(RecyclerView recyclerView,int dx,int dy){
  super.onScrolled(recyclerView,dx,dy);
  if (mHeader != null) {
    translateHeader(mRecyclerView.getLayoutManager().getChildAt(0) == mHeader ? mRecyclerView.computeVerticalScrollOffset() : mHeader.getHeight());
  }
}"
54633,"/** 
 * Defines if we will clip the layout or not. MUST BE CALLED BEFORE   {@link #setParallaxHeader(android.view.View,android.support.v7.widget.RecyclerView)}
 * @param shouldClickView
 */
public void setShouldClipView(boolean shouldClickView){
  mShouldClipView=shouldClickView;
}","/** 
 * Defines if we will clip the layout or not. MUST BE CALLED BEFORE   {@link #setParallaxHeader(android.view.View,android.support.v7.widget.RecyclerView)}
 */
public void setShouldClipView(boolean shouldClickView){
  mShouldClipView=shouldClickView;
}"
54634,"/** 
 * Event triggered when the parallax is being scrolled.
 * @param percentage
 * @param offset
 * @param parallax
 */
void onParallaxScroll(float percentage,float offset,View parallax);","/** 
 * Event triggered when the parallax is being scrolled.
 */
void onParallaxScroll(float percentage,float offset,View parallax);"
54635,"@Override public void onBindViewHolder(RecyclerView.ViewHolder viewHolder,final int i){
  if (i != 0 && mHeader != null) {
    onBindViewHolderImpl(viewHolder,this,i - 1);
  }
 else   if (i != 0) {
    onBindViewHolderImpl(viewHolder,this,i);
  }
}","@Override public void onBindViewHolder(RecyclerView.ViewHolder viewHolder,final int i){
  if (mHeader != null) {
    if (i == 0) {
      return;
    }
    onBindViewHolderImpl(viewHolder,this,i - 1);
  }
 else {
    onBindViewHolderImpl(viewHolder,this,i);
  }
}"
54636,"/** 
 * Set the view as header.
 * @param header The inflated header
 * @param view   The RecyclerView to set scroll listeners
 */
public void setParallaxHeader(View header,final RecyclerView view){
  mRecyclerView=view;
  mHeader=new CustomRelativeWrapper(header.getContext(),mShouldClipView);
  mHeader.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT));
  mHeader.addView(header,new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT));
  view.setOnScrollListener(new RecyclerView.OnScrollListener(){
    @Override public void onScrolled(    RecyclerView recyclerView,    int dx,    int dy){
      super.onScrolled(recyclerView,dx,dy);
      if (mHeader != null) {
        if (mHeader != null) {
          translateHeader(mRecyclerView.getLayoutManager().getChildAt(0) == mHeader ? mRecyclerView.computeVerticalScrollOffset() : mHeader.getHeight());
        }
      }
    }
  }
);
}","/** 
 * Set the view as header.
 * @param header The inflated header
 * @param view   The RecyclerView to set scroll listeners
 */
public void setParallaxHeader(View header,final RecyclerView view){
  mRecyclerView=view;
  mHeader=new CustomRelativeWrapper(header.getContext(),mShouldClipView);
  mHeader.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,ViewGroup.LayoutParams.WRAP_CONTENT));
  mHeader.addView(header,new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT));
  view.setOnScrollListener(new RecyclerView.OnScrollListener(){
    @Override public void onScrolled(    RecyclerView recyclerView,    int dx,    int dy){
      super.onScrolled(recyclerView,dx,dy);
      if (mHeader != null) {
        translateHeader(mRecyclerView.getLayoutManager().getChildAt(0) == mHeader ? mRecyclerView.computeVerticalScrollOffset() : mHeader.getHeight());
      }
    }
  }
);
}"
54637,"private void startLocationPermissionRequest(){
  ActivityCompat.requestPermissions(MainActivity.this,new String[]{Manifest.permission.ACCESS_FINE_LOCATION},REQUEST_PERMISSIONS_REQUEST_CODE);
}","private void startLocationPermissionRequest(){
  ActivityCompat.requestPermissions(MainActivity.this,new String[]{Manifest.permission.ACCESS_COARSE_LOCATION},REQUEST_PERMISSIONS_REQUEST_CODE);
}"
54638,"private void requestPermissions(){
  boolean shouldProvideRationale=ActivityCompat.shouldShowRequestPermissionRationale(this,Manifest.permission.ACCESS_FINE_LOCATION);
  if (shouldProvideRationale) {
    Log.i(TAG,""String_Node_Str"");
    showSnackbar(R.string.permission_rationale,android.R.string.ok,new View.OnClickListener(){
      @Override public void onClick(      View view){
        startLocationPermissionRequest();
      }
    }
);
  }
 else {
    Log.i(TAG,""String_Node_Str"");
    startLocationPermissionRequest();
  }
}","private void requestPermissions(){
  boolean shouldProvideRationale=ActivityCompat.shouldShowRequestPermissionRationale(this,Manifest.permission.ACCESS_COARSE_LOCATION);
  if (shouldProvideRationale) {
    Log.i(TAG,""String_Node_Str"");
    showSnackbar(R.string.permission_rationale,android.R.string.ok,new View.OnClickListener(){
      @Override public void onClick(      View view){
        startLocationPermissionRequest();
      }
    }
);
  }
 else {
    Log.i(TAG,""String_Node_Str"");
    startLocationPermissionRequest();
  }
}"
54639,"/** 
 * Removes location updates from the FusedLocationApi.
 */
private void stopLocationUpdates(){
  mFusedLocationClient.removeLocationUpdates(mLocationCallback).addOnCompleteListener(this,new OnCompleteListener<Void>(){
    @Override public void onComplete(    @NonNull Task<Void> task){
      mRequestingLocationUpdates=false;
      setButtonsEnabledState();
    }
  }
);
}","/** 
 * Removes location updates from the FusedLocationApi.
 */
private void stopLocationUpdates(){
  if (!mRequestingLocationUpdates) {
    Log.d(TAG,""String_Node_Str"");
    return;
  }
  mFusedLocationClient.removeLocationUpdates(mLocationCallback).addOnCompleteListener(this,new OnCompleteListener<Void>(){
    @Override public void onComplete(    @NonNull Task<Void> task){
      mRequestingLocationUpdates=false;
      setButtonsEnabledState();
    }
  }
);
}"
54640,"@Override public void onResume(){
  super.onResume();
  if (mRequestingLocationUpdates && checkPermissions()) {
    startLocationUpdates();
  }
 else {
    requestPermissions();
  }
  updateUI();
}","@Override public void onResume(){
  super.onResume();
  if (mRequestingLocationUpdates && checkPermissions()) {
    startLocationUpdates();
  }
 else   if (!checkPermissions()) {
    requestPermissions();
  }
  updateUI();
}"
54641,"public void processBlock(BasicBlockStatement stat,PrimitiveExprsList data,StructClass cl){
  ConstantPool pool=cl.getPool();
  StructBootstrapMethodsAttribute bootstrap=(StructBootstrapMethodsAttribute)cl.getAttribute(StructGeneralAttribute.ATTRIBUTE_BOOTSTRAP_METHODS);
  BasicBlock block=stat.getBlock();
  ExprentStack stack=data.getStack();
  List<Exprent> exprlist=data.getLstExprents();
  InstructionSequence seq=block.getSeq();
  for (int i=0; i < seq.length(); i++) {
    Instruction instr=seq.getInstr(i);
    Integer bytecode_offset=block.getOldOffset(i);
    Set<Integer> bytecode_offsets=bytecode_offset >= 0 ? Collections.singleton(bytecode_offset) : null;
switch (instr.opcode) {
case opc_aconst_null:
      pushEx(stack,exprlist,new ConstExprent(VarType.VARTYPE_NULL,null,bytecode_offsets));
    break;
case opc_bipush:
case opc_sipush:
  pushEx(stack,exprlist,new ConstExprent(instr.getOperand(0),true,bytecode_offsets));
break;
case opc_lconst_0:
case opc_lconst_1:
pushEx(stack,exprlist,new ConstExprent(VarType.VARTYPE_LONG,Long.valueOf(instr.opcode - opc_lconst_0),bytecode_offsets));
break;
case opc_fconst_0:
case opc_fconst_1:
case opc_fconst_2:
pushEx(stack,exprlist,new ConstExprent(VarType.VARTYPE_FLOAT,Float.valueOf(instr.opcode - opc_fconst_0),bytecode_offsets));
break;
case opc_dconst_0:
case opc_dconst_1:
pushEx(stack,exprlist,new ConstExprent(VarType.VARTYPE_DOUBLE,Double.valueOf(instr.opcode - opc_dconst_0),bytecode_offsets));
break;
case opc_ldc:
case opc_ldc_w:
case opc_ldc2_w:
PooledConstant cn=pool.getConstant(instr.getOperand(0));
if (cn instanceof PrimitiveConstant) {
pushEx(stack,exprlist,new ConstExprent(consts[cn.type - CONSTANT_Integer],((PrimitiveConstant)cn).value,bytecode_offsets));
}
 else if (cn instanceof LinkConstant) {
pushEx(stack,exprlist,new ConstExprent(VarType.VARTYPE_STRING,((LinkConstant)cn).elementname,bytecode_offsets));
}
break;
case opc_iload:
case opc_lload:
case opc_fload:
case opc_dload:
case opc_aload:
pushEx(stack,exprlist,new VarExprent(instr.getOperand(0),varTypes[instr.opcode - opc_iload],varProcessor,bytecode_offset));
break;
case opc_iaload:
case opc_laload:
case opc_faload:
case opc_daload:
case opc_aaload:
case opc_baload:
case opc_caload:
case opc_saload:
Exprent index=stack.pop();
Exprent arr=stack.pop();
VarType vartype=null;
switch (instr.opcode) {
case opc_laload:
vartype=VarType.VARTYPE_LONG;
break;
case opc_daload:
vartype=VarType.VARTYPE_DOUBLE;
}
pushEx(stack,exprlist,new ArrayExprent(arr,index,arrTypes[instr.opcode - opc_iaload],bytecode_offsets),vartype);
break;
case opc_istore:
case opc_lstore:
case opc_fstore:
case opc_dstore:
case opc_astore:
Exprent top=stack.pop();
int varindex=instr.getOperand(0);
AssignmentExprent assign=new AssignmentExprent(new VarExprent(varindex,varTypes[instr.opcode - opc_istore],varProcessor,nextMeaningfulOffset(block,i)),top,bytecode_offsets);
exprlist.add(assign);
break;
case opc_iastore:
case opc_lastore:
case opc_fastore:
case opc_dastore:
case opc_aastore:
case opc_bastore:
case opc_castore:
case opc_sastore:
Exprent value=stack.pop();
Exprent index_store=stack.pop();
Exprent arr_store=stack.pop();
AssignmentExprent arrassign=new AssignmentExprent(new ArrayExprent(arr_store,index_store,arrTypes[instr.opcode - opc_iastore],bytecode_offsets),value,bytecode_offsets);
exprlist.add(arrassign);
break;
case opc_iadd:
case opc_ladd:
case opc_fadd:
case opc_dadd:
case opc_isub:
case opc_lsub:
case opc_fsub:
case opc_dsub:
case opc_imul:
case opc_lmul:
case opc_fmul:
case opc_dmul:
case opc_idiv:
case opc_ldiv:
case opc_fdiv:
case opc_ddiv:
case opc_irem:
case opc_lrem:
case opc_frem:
case opc_drem:
pushEx(stack,exprlist,new FunctionExprent(func1[(instr.opcode - opc_iadd) / 4],stack,bytecode_offsets));
break;
case opc_ishl:
case opc_lshl:
case opc_ishr:
case opc_lshr:
case opc_iushr:
case opc_lushr:
case opc_iand:
case opc_land:
case opc_ior:
case opc_lor:
case opc_ixor:
case opc_lxor:
pushEx(stack,exprlist,new FunctionExprent(func2[(instr.opcode - opc_ishl) / 2],stack,bytecode_offsets));
break;
case opc_ineg:
case opc_lneg:
case opc_fneg:
case opc_dneg:
pushEx(stack,exprlist,new FunctionExprent(FunctionExprent.FUNCTION_NEG,stack,bytecode_offsets));
break;
case opc_iinc:
VarExprent vevar=new VarExprent(instr.getOperand(0),VarType.VARTYPE_INT,varProcessor);
exprlist.add(new AssignmentExprent(vevar,new FunctionExprent(instr.getOperand(1) < 0 ? FunctionExprent.FUNCTION_SUB : FunctionExprent.FUNCTION_ADD,Arrays.asList(vevar.copy(),new ConstExprent(VarType.VARTYPE_INT,Math.abs(instr.getOperand(1)),null)),bytecode_offsets),bytecode_offsets));
break;
case opc_i2l:
case opc_i2f:
case opc_i2d:
case opc_l2i:
case opc_l2f:
case opc_l2d:
case opc_f2i:
case opc_f2l:
case opc_f2d:
case opc_d2i:
case opc_d2l:
case opc_d2f:
case opc_i2b:
case opc_i2c:
case opc_i2s:
pushEx(stack,exprlist,new FunctionExprent(func3[instr.opcode - opc_i2l],stack,bytecode_offsets));
break;
case opc_lcmp:
case opc_fcmpl:
case opc_fcmpg:
case opc_dcmpl:
case opc_dcmpg:
pushEx(stack,exprlist,new FunctionExprent(func4[instr.opcode - opc_lcmp],stack,bytecode_offsets));
break;
case opc_ifeq:
case opc_ifne:
case opc_iflt:
case opc_ifge:
case opc_ifgt:
case opc_ifle:
exprlist.add(new IfExprent(negIfs[func5[instr.opcode - opc_ifeq]],stack,bytecode_offsets));
break;
case opc_if_icmpeq:
case opc_if_icmpne:
case opc_if_icmplt:
case opc_if_icmpge:
case opc_if_icmpgt:
case opc_if_icmple:
case opc_if_acmpeq:
case opc_if_acmpne:
exprlist.add(new IfExprent(negIfs[func6[instr.opcode - opc_if_icmpeq]],stack,bytecode_offsets));
break;
case opc_ifnull:
case opc_ifnonnull:
exprlist.add(new IfExprent(negIfs[func7[instr.opcode - opc_ifnull]],stack,bytecode_offsets));
break;
case opc_tableswitch:
case opc_lookupswitch:
exprlist.add(new SwitchExprent(stack.pop(),bytecode_offsets));
break;
case opc_ireturn:
case opc_lreturn:
case opc_freturn:
case opc_dreturn:
case opc_areturn:
case opc_return:
case opc_athrow:
exprlist.add(new ExitExprent(instr.opcode == opc_athrow ? ExitExprent.EXIT_THROW : ExitExprent.EXIT_RETURN,instr.opcode == opc_return ? null : stack.pop(),instr.opcode == opc_athrow ? null : methodDescriptor.ret,bytecode_offsets));
break;
case opc_monitorenter:
case opc_monitorexit:
exprlist.add(new MonitorExprent(func8[instr.opcode - opc_monitorenter],stack.pop(),bytecode_offsets));
break;
case opc_checkcast:
case opc_instanceof:
stack.push(new ConstExprent(new VarType(pool.getPrimitiveConstant(instr.getOperand(0)).getString(),true),null,null));
case opc_arraylength:
pushEx(stack,exprlist,new FunctionExprent(mapConsts.get(instr.opcode).intValue(),stack,bytecode_offsets));
break;
case opc_getstatic:
case opc_getfield:
pushEx(stack,exprlist,new FieldExprent(pool.getLinkConstant(instr.getOperand(0)),instr.opcode == opc_getstatic ? null : stack.pop(),bytecode_offsets));
break;
case opc_putstatic:
case opc_putfield:
Exprent valfield=stack.pop();
Exprent exprfield=new FieldExprent(pool.getLinkConstant(instr.getOperand(0)),instr.opcode == opc_putstatic ? null : stack.pop(),bytecode_offsets);
exprlist.add(new AssignmentExprent(exprfield,valfield,bytecode_offsets));
break;
case opc_invokevirtual:
case opc_invokespecial:
case opc_invokestatic:
case opc_invokeinterface:
case opc_invokedynamic:
if (instr.opcode != opc_invokedynamic || instr.bytecode_version >= CodeConstants.BYTECODE_JAVA_7) {
LinkConstant invoke_constant=pool.getLinkConstant(instr.getOperand(0));
List<PooledConstant> bootstrap_arguments=null;
if (instr.opcode == opc_invokedynamic && bootstrap != null) {
bootstrap_arguments=bootstrap.getMethodArguments(invoke_constant.index1);
}
InvocationExprent exprinv=new InvocationExprent(instr.opcode,invoke_constant,bootstrap_arguments,stack,bytecode_offsets);
if (exprinv.getDescriptor().ret.type == CodeConstants.TYPE_VOID) {
exprlist.add(exprinv);
}
 else {
pushEx(stack,exprlist,exprinv);
}
}
break;
case opc_new:
case opc_anewarray:
case opc_multianewarray:
int dimensions=(instr.opcode == opc_new) ? 0 : (instr.opcode == opc_anewarray) ? 1 : instr.getOperand(1);
VarType arrType=new VarType(pool.getPrimitiveConstant(instr.getOperand(0)).getString(),true);
if (instr.opcode != opc_multianewarray) {
arrType=arrType.resizeArrayDim(arrType.arrayDim + dimensions);
}
pushEx(stack,exprlist,new NewExprent(arrType,stack,dimensions,bytecode_offsets));
break;
case opc_newarray:
pushEx(stack,exprlist,new NewExprent(new VarType(arrTypeIds[instr.getOperand(0) - 4],1),stack,1,bytecode_offsets));
break;
case opc_dup:
pushEx(stack,exprlist,stack.getByOffset(-1).copy());
break;
case opc_dup_x1:
insertByOffsetEx(-2,stack,exprlist,-1);
break;
case opc_dup_x2:
if (stack.getByOffset(-2).getExprType().stackSize == 2) {
insertByOffsetEx(-2,stack,exprlist,-1);
}
 else {
insertByOffsetEx(-3,stack,exprlist,-1);
}
break;
case opc_dup2:
if (stack.getByOffset(-1).getExprType().stackSize == 2) {
pushEx(stack,exprlist,stack.getByOffset(-1).copy());
}
 else {
pushEx(stack,exprlist,stack.getByOffset(-2).copy());
pushEx(stack,exprlist,stack.getByOffset(-2).copy());
}
break;
case opc_dup2_x1:
if (stack.getByOffset(-1).getExprType().stackSize == 2) {
insertByOffsetEx(-2,stack,exprlist,-1);
}
 else {
insertByOffsetEx(-3,stack,exprlist,-2);
insertByOffsetEx(-3,stack,exprlist,-1);
}
break;
case opc_dup2_x2:
if (stack.getByOffset(-1).getExprType().stackSize == 2) {
if (stack.getByOffset(-2).getExprType().stackSize == 2) {
insertByOffsetEx(-2,stack,exprlist,-1);
}
 else {
insertByOffsetEx(-3,stack,exprlist,-1);
}
}
 else {
if (stack.getByOffset(-3).getExprType().stackSize == 2) {
insertByOffsetEx(-3,stack,exprlist,-2);
insertByOffsetEx(-3,stack,exprlist,-1);
}
 else {
insertByOffsetEx(-4,stack,exprlist,-2);
insertByOffsetEx(-4,stack,exprlist,-1);
}
}
break;
case opc_swap:
insertByOffsetEx(-2,stack,exprlist,-1);
stack.pop();
break;
case opc_pop:
case opc_pop2:
stack.pop();
}
}
}","public void processBlock(BasicBlockStatement stat,PrimitiveExprsList data,StructClass cl){
  ConstantPool pool=cl.getPool();
  StructBootstrapMethodsAttribute bootstrap=(StructBootstrapMethodsAttribute)cl.getAttribute(StructGeneralAttribute.ATTRIBUTE_BOOTSTRAP_METHODS);
  BasicBlock block=stat.getBlock();
  ExprentStack stack=data.getStack();
  List<Exprent> exprlist=data.getLstExprents();
  InstructionSequence seq=block.getSeq();
  for (int i=0; i < seq.length(); i++) {
    Instruction instr=seq.getInstr(i);
    Integer bytecode_offset=block.getOldOffset(i);
    Set<Integer> bytecode_offsets=bytecode_offset >= 0 ? Collections.singleton(bytecode_offset) : null;
switch (instr.opcode) {
case opc_aconst_null:
      pushEx(stack,exprlist,new ConstExprent(VarType.VARTYPE_NULL,null,bytecode_offsets));
    break;
case opc_bipush:
case opc_sipush:
  pushEx(stack,exprlist,new ConstExprent(instr.getOperand(0),true,bytecode_offsets));
break;
case opc_lconst_0:
case opc_lconst_1:
pushEx(stack,exprlist,new ConstExprent(VarType.VARTYPE_LONG,Long.valueOf(instr.opcode - opc_lconst_0),bytecode_offsets));
break;
case opc_fconst_0:
case opc_fconst_1:
case opc_fconst_2:
pushEx(stack,exprlist,new ConstExprent(VarType.VARTYPE_FLOAT,Float.valueOf(instr.opcode - opc_fconst_0),bytecode_offsets));
break;
case opc_dconst_0:
case opc_dconst_1:
pushEx(stack,exprlist,new ConstExprent(VarType.VARTYPE_DOUBLE,Double.valueOf(instr.opcode - opc_dconst_0),bytecode_offsets));
break;
case opc_ldc:
case opc_ldc_w:
case opc_ldc2_w:
PooledConstant cn=pool.getConstant(instr.getOperand(0));
if (cn instanceof PrimitiveConstant) {
pushEx(stack,exprlist,new ConstExprent(consts[cn.type - CONSTANT_Integer],((PrimitiveConstant)cn).value,bytecode_offsets));
}
 else if (cn instanceof LinkConstant) {
pushEx(stack,exprlist,new ConstExprent(VarType.VARTYPE_STRING,((LinkConstant)cn).elementname,bytecode_offsets));
}
break;
case opc_iload:
case opc_lload:
case opc_fload:
case opc_dload:
case opc_aload:
pushEx(stack,exprlist,new VarExprent(instr.getOperand(0),varTypes[instr.opcode - opc_iload],varProcessor,bytecode_offset));
break;
case opc_iaload:
case opc_laload:
case opc_faload:
case opc_daload:
case opc_aaload:
case opc_baload:
case opc_caload:
case opc_saload:
Exprent index=stack.pop();
Exprent arr=stack.pop();
VarType vartype=null;
switch (instr.opcode) {
case opc_laload:
vartype=VarType.VARTYPE_LONG;
break;
case opc_daload:
vartype=VarType.VARTYPE_DOUBLE;
}
pushEx(stack,exprlist,new ArrayExprent(arr,index,arrTypes[instr.opcode - opc_iaload],bytecode_offsets),vartype);
break;
case opc_istore:
case opc_lstore:
case opc_fstore:
case opc_dstore:
case opc_astore:
Exprent top=stack.pop();
int varindex=instr.getOperand(0);
AssignmentExprent assign=new AssignmentExprent(new VarExprent(varindex,varTypes[instr.opcode - opc_istore],varProcessor,nextMeaningfulOffset(block,i)),top,bytecode_offsets);
exprlist.add(assign);
break;
case opc_iastore:
case opc_lastore:
case opc_fastore:
case opc_dastore:
case opc_aastore:
case opc_bastore:
case opc_castore:
case opc_sastore:
Exprent value=stack.pop();
Exprent index_store=stack.pop();
Exprent arr_store=stack.pop();
AssignmentExprent arrassign=new AssignmentExprent(new ArrayExprent(arr_store,index_store,arrTypes[instr.opcode - opc_iastore],bytecode_offsets),value,bytecode_offsets);
exprlist.add(arrassign);
break;
case opc_iadd:
case opc_ladd:
case opc_fadd:
case opc_dadd:
case opc_isub:
case opc_lsub:
case opc_fsub:
case opc_dsub:
case opc_imul:
case opc_lmul:
case opc_fmul:
case opc_dmul:
case opc_idiv:
case opc_ldiv:
case opc_fdiv:
case opc_ddiv:
case opc_irem:
case opc_lrem:
case opc_frem:
case opc_drem:
pushEx(stack,exprlist,new FunctionExprent(func1[(instr.opcode - opc_iadd) / 4],stack,bytecode_offsets));
break;
case opc_ishl:
case opc_lshl:
case opc_ishr:
case opc_lshr:
case opc_iushr:
case opc_lushr:
case opc_iand:
case opc_land:
case opc_ior:
case opc_lor:
case opc_ixor:
case opc_lxor:
pushEx(stack,exprlist,new FunctionExprent(func2[(instr.opcode - opc_ishl) / 2],stack,bytecode_offsets));
break;
case opc_ineg:
case opc_lneg:
case opc_fneg:
case opc_dneg:
pushEx(stack,exprlist,new FunctionExprent(FunctionExprent.FUNCTION_NEG,stack,bytecode_offsets));
break;
case opc_iinc:
VarExprent vevar=new VarExprent(instr.getOperand(0),VarType.VARTYPE_INT,varProcessor);
exprlist.add(new AssignmentExprent(vevar,new FunctionExprent(instr.getOperand(1) < 0 ? FunctionExprent.FUNCTION_SUB : FunctionExprent.FUNCTION_ADD,Arrays.asList(vevar.copy(),new ConstExprent(VarType.VARTYPE_INT,Math.abs(instr.getOperand(1)),null)),bytecode_offsets),bytecode_offsets));
break;
case opc_i2l:
case opc_i2f:
case opc_i2d:
case opc_l2i:
case opc_l2f:
case opc_l2d:
case opc_f2i:
case opc_f2l:
case opc_f2d:
case opc_d2i:
case opc_d2l:
case opc_d2f:
case opc_i2b:
case opc_i2c:
case opc_i2s:
pushEx(stack,exprlist,new FunctionExprent(func3[instr.opcode - opc_i2l],stack,bytecode_offsets));
break;
case opc_lcmp:
case opc_fcmpl:
case opc_fcmpg:
case opc_dcmpl:
case opc_dcmpg:
pushEx(stack,exprlist,new FunctionExprent(func4[instr.opcode - opc_lcmp],stack,bytecode_offsets));
break;
case opc_ifeq:
case opc_ifne:
case opc_iflt:
case opc_ifge:
case opc_ifgt:
case opc_ifle:
exprlist.add(new IfExprent(negIfs[func5[instr.opcode - opc_ifeq]],stack,bytecode_offsets));
break;
case opc_if_icmpeq:
case opc_if_icmpne:
case opc_if_icmplt:
case opc_if_icmpge:
case opc_if_icmpgt:
case opc_if_icmple:
case opc_if_acmpeq:
case opc_if_acmpne:
exprlist.add(new IfExprent(negIfs[func6[instr.opcode - opc_if_icmpeq]],stack,bytecode_offsets));
break;
case opc_ifnull:
case opc_ifnonnull:
exprlist.add(new IfExprent(negIfs[func7[instr.opcode - opc_ifnull]],stack,bytecode_offsets));
break;
case opc_tableswitch:
case opc_lookupswitch:
exprlist.add(new SwitchExprent(stack.pop(),bytecode_offsets));
break;
case opc_ireturn:
case opc_lreturn:
case opc_freturn:
case opc_dreturn:
case opc_areturn:
case opc_return:
case opc_athrow:
exprlist.add(new ExitExprent(instr.opcode == opc_athrow ? ExitExprent.EXIT_THROW : ExitExprent.EXIT_RETURN,instr.opcode == opc_return ? null : stack.pop(),instr.opcode == opc_athrow ? null : methodDescriptor.ret,bytecode_offsets));
break;
case opc_monitorenter:
case opc_monitorexit:
exprlist.add(new MonitorExprent(func8[instr.opcode - opc_monitorenter],stack.pop(),bytecode_offsets));
break;
case opc_checkcast:
case opc_instanceof:
stack.push(new ConstExprent(new VarType(pool.getPrimitiveConstant(instr.getOperand(0)).getString(),true),null,null));
case opc_arraylength:
pushEx(stack,exprlist,new FunctionExprent(mapConsts.get(instr.opcode).intValue(),stack,bytecode_offsets));
break;
case opc_getstatic:
case opc_getfield:
pushEx(stack,exprlist,new FieldExprent(pool.getLinkConstant(instr.getOperand(0)),instr.opcode == opc_getstatic ? null : stack.pop(),bytecode_offsets));
break;
case opc_putstatic:
case opc_putfield:
Exprent valfield=stack.pop();
Exprent exprfield=new FieldExprent(pool.getLinkConstant(instr.getOperand(0)),instr.opcode == opc_putstatic ? null : stack.pop(),bytecode_offsets);
exprlist.add(new AssignmentExprent(exprfield,valfield,bytecode_offsets));
break;
case opc_invokevirtual:
case opc_invokespecial:
case opc_invokestatic:
case opc_invokeinterface:
case opc_invokedynamic:
if (instr.opcode != opc_invokedynamic || instr.bytecode_version >= CodeConstants.BYTECODE_JAVA_7) {
LinkConstant invoke_constant=pool.getLinkConstant(instr.getOperand(0));
List<PooledConstant> bootstrap_arguments=null;
if (instr.opcode == opc_invokedynamic && bootstrap != null) {
bootstrap_arguments=bootstrap.getMethodArguments(invoke_constant.index1);
}
InvocationExprent exprinv=new InvocationExprent(instr.opcode,invoke_constant,bootstrap_arguments,stack,bytecode_offsets);
if (exprinv.getDescriptor().ret.type == CodeConstants.TYPE_VOID) {
exprlist.add(exprinv);
}
 else {
pushEx(stack,exprlist,exprinv);
}
}
break;
case opc_new:
case opc_anewarray:
case opc_multianewarray:
int dimensions=(instr.opcode == opc_new) ? 0 : (instr.opcode == opc_anewarray) ? 1 : instr.getOperand(1);
VarType arrType=new VarType(pool.getPrimitiveConstant(instr.getOperand(0)).getString(),true);
if (instr.opcode != opc_multianewarray) {
arrType=arrType.resizeArrayDim(arrType.arrayDim + dimensions);
}
pushEx(stack,exprlist,new NewExprent(arrType,stack,dimensions,bytecode_offsets));
break;
case opc_newarray:
pushEx(stack,exprlist,new NewExprent(new VarType(arrTypeIds[instr.getOperand(0) - 4],1),stack,1,bytecode_offsets));
break;
case opc_dup:
pushEx(stack,exprlist,stack.getByOffset(-1).copy());
break;
case opc_dup_x1:
insertByOffsetEx(-2,stack,exprlist,-1);
break;
case opc_dup_x2:
if (stack.getByOffset(-2).getExprType().stackSize == 2) {
insertByOffsetEx(-2,stack,exprlist,-1);
}
 else {
insertByOffsetEx(-3,stack,exprlist,-1);
}
break;
case opc_dup2:
if (stack.getByOffset(-1).getExprType().stackSize == 2) {
pushEx(stack,exprlist,stack.getByOffset(-1).copy());
}
 else {
pushEx(stack,exprlist,stack.getByOffset(-2).copy());
pushEx(stack,exprlist,stack.getByOffset(-2).copy());
}
break;
case opc_dup2_x1:
if (stack.getByOffset(-1).getExprType().stackSize == 2) {
insertByOffsetEx(-2,stack,exprlist,-1);
}
 else {
insertByOffsetEx(-3,stack,exprlist,-2);
insertByOffsetEx(-3,stack,exprlist,-1);
}
break;
case opc_dup2_x2:
if (stack.getByOffset(-1).getExprType().stackSize == 2) {
if (stack.getByOffset(-2).getExprType().stackSize == 2) {
insertByOffsetEx(-2,stack,exprlist,-1);
}
 else {
insertByOffsetEx(-3,stack,exprlist,-1);
}
}
 else {
if (stack.getByOffset(-3).getExprType().stackSize == 2) {
insertByOffsetEx(-3,stack,exprlist,-2);
insertByOffsetEx(-3,stack,exprlist,-1);
}
 else {
insertByOffsetEx(-4,stack,exprlist,-2);
insertByOffsetEx(-4,stack,exprlist,-1);
}
}
break;
case opc_swap:
insertByOffsetEx(-2,stack,exprlist,-1);
stack.pop();
break;
case opc_pop:
stack.pop();
break;
case opc_pop2:
if (stack.getByOffset(-1).getExprType().stackSize == 1) {
stack.pop();
}
stack.pop();
break;
}
}
}"
54642,"private boolean methodToJava(ClassNode node,StructMethod mt,TextBuffer buffer,int indent,BytecodeMappingTracer tracer){
  ClassWrapper wrapper=node.getWrapper();
  StructClass cl=wrapper.getClassStruct();
  MethodWrapper methodWrapper=wrapper.getMethodWrapper(mt.getName(),mt.getDescriptor());
  boolean hideMethod=false;
  int start_index_method=buffer.length();
  MethodWrapper outerWrapper=(MethodWrapper)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_WRAPPER);
  DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER,methodWrapper);
  try {
    boolean isInterface=cl.hasModifier(CodeConstants.ACC_INTERFACE);
    boolean isAnnotation=cl.hasModifier(CodeConstants.ACC_ANNOTATION);
    boolean isEnum=cl.hasModifier(CodeConstants.ACC_ENUM) && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_ENUM);
    boolean isDeprecated=mt.hasAttribute(""String_Node_Str"");
    boolean clinit=false, init=false, dinit=false;
    MethodDescriptor md=MethodDescriptor.parseDescriptor(mt.getDescriptor());
    int flags=mt.getAccessFlags();
    if ((flags & CodeConstants.ACC_NATIVE) != 0) {
      flags&=~CodeConstants.ACC_STRICT;
    }
    if (CodeConstants.CLINIT_NAME.equals(mt.getName())) {
      flags&=CodeConstants.ACC_STATIC;
    }
    if (isDeprecated) {
      appendDeprecation(buffer,indent);
    }
    if (interceptor != null) {
      String oldName=interceptor.getOldName(cl.qualifiedName + ""String_Node_Str"" + mt.getName()+ ""String_Node_Str""+ mt.getDescriptor());
      appendRenameComment(buffer,oldName,MType.METHOD,indent);
    }
    boolean isSynthetic=(flags & CodeConstants.ACC_SYNTHETIC) != 0 || mt.hasAttribute(""String_Node_Str"");
    boolean isBridge=(flags & CodeConstants.ACC_BRIDGE) != 0;
    if (isSynthetic) {
      appendComment(buffer,""String_Node_Str"",indent);
    }
    if (isBridge) {
      appendComment(buffer,""String_Node_Str"",indent);
    }
    appendAnnotations(buffer,indent,mt,TypeAnnotation.METHOD_RETURN_TYPE);
    buffer.appendIndent(indent);
    appendModifiers(buffer,flags,METHOD_ALLOWED,isInterface,METHOD_EXCLUDED);
    if (isInterface && !mt.hasModifier(CodeConstants.ACC_STATIC) && mt.containsCode()) {
      buffer.append(""String_Node_Str"");
    }
    String name=mt.getName();
    if (CodeConstants.INIT_NAME.equals(name)) {
      if (node.type == ClassNode.CLASS_ANONYMOUS) {
        name=""String_Node_Str"";
        dinit=true;
      }
 else {
        name=node.simpleName;
        init=true;
      }
    }
 else     if (CodeConstants.CLINIT_NAME.equals(name)) {
      name=""String_Node_Str"";
      clinit=true;
    }
    GenericMethodDescriptor descriptor=null;
    if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
      StructGenericSignatureAttribute attr=(StructGenericSignatureAttribute)mt.getAttribute(""String_Node_Str"");
      if (attr != null) {
        descriptor=GenericMain.parseMethodSignature(attr.getSignature());
        if (descriptor != null) {
          long actualParams=md.params.length;
          List<VarVersionPair> sigFields=methodWrapper.signatureFields;
          if (sigFields != null) {
            actualParams=sigFields.stream().filter(Objects::isNull).count();
          }
 else           if (isEnum && init)           actualParams-=2;
          if (actualParams != descriptor.params.size()) {
            String message=""String_Node_Str"" + mt.getName() + ""String_Node_Str""+ mt.getDescriptor()+ ""String_Node_Str""+ cl.qualifiedName;
            DecompilerContext.getLogger().writeMessage(message,IFernflowerLogger.Severity.WARN);
            descriptor=null;
          }
        }
      }
    }
    boolean throwsExceptions=false;
    int paramCount=0;
    if (!clinit && !dinit) {
      boolean thisVar=!mt.hasModifier(CodeConstants.ACC_STATIC);
      if (descriptor != null && !descriptor.fparameters.isEmpty()) {
        appendTypeParameters(buffer,descriptor.fparameters,descriptor.fbounds);
        buffer.append(' ');
      }
      if (!init) {
        if (descriptor != null) {
          buffer.append(GenericMain.getGenericCastTypeName(descriptor.ret));
        }
 else {
          buffer.append(ExprProcessor.getCastTypeName(md.ret));
        }
        buffer.append(' ');
      }
      buffer.append(toValidJavaIdentifier(name));
      buffer.append('(');
      List<VarVersionPair> signFields=methodWrapper.signatureFields;
      int lastVisibleParameterIndex=-1;
      for (int i=0; i < md.params.length; i++) {
        if (signFields == null || signFields.get(i) == null) {
          lastVisibleParameterIndex=i;
        }
      }
      boolean firstParameter=true;
      int index=isEnum && init ? 3 : thisVar ? 1 : 0;
      boolean hasDescriptor=descriptor != null;
      int start=isEnum && init && !hasDescriptor ? 2 : 0;
      int params=hasDescriptor ? descriptor.params.size() : md.params.length;
      for (int i=start; i < params; i++) {
        if (hasDescriptor || (signFields == null || signFields.get(i) == null)) {
          if (!firstParameter) {
            buffer.append(""String_Node_Str"");
          }
          appendParameterAnnotations(buffer,mt,paramCount);
          if (methodWrapper.varproc.getVarFinal(new VarVersionPair(index,0)) == VarTypeProcessor.VAR_EXPLICIT_FINAL) {
            buffer.append(""String_Node_Str"");
          }
          if (descriptor != null) {
            GenericType parameterType=descriptor.params.get(i);
            boolean isVarArg=(i == lastVisibleParameterIndex && mt.hasModifier(CodeConstants.ACC_VARARGS) && parameterType.arrayDim > 0);
            if (isVarArg) {
              parameterType=parameterType.decreaseArrayDim();
            }
            String typeName=GenericMain.getGenericCastTypeName(parameterType);
            if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) && DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {
              typeName=ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);
            }
            buffer.append(typeName);
            if (isVarArg) {
              buffer.append(""String_Node_Str"");
            }
          }
 else {
            VarType parameterType=md.params[i];
            boolean isVarArg=(i == lastVisibleParameterIndex && mt.hasModifier(CodeConstants.ACC_VARARGS) && parameterType.arrayDim > 0);
            if (isVarArg) {
              parameterType=parameterType.decreaseArrayDim();
            }
            String typeName=ExprProcessor.getCastTypeName(parameterType);
            if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) && DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {
              typeName=ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);
            }
            buffer.append(typeName);
            if (isVarArg) {
              buffer.append(""String_Node_Str"");
            }
          }
          buffer.append(' ');
          String parameterName=methodWrapper.varproc.getVarName(new VarVersionPair(index,0));
          buffer.append(parameterName == null ? ""String_Node_Str"" + index : parameterName);
          firstParameter=false;
          paramCount++;
        }
        index+=md.params[i].stackSize;
      }
      buffer.append(')');
      StructExceptionsAttribute attr=(StructExceptionsAttribute)mt.getAttribute(""String_Node_Str"");
      if ((descriptor != null && !descriptor.exceptions.isEmpty()) || attr != null) {
        throwsExceptions=true;
        buffer.append(""String_Node_Str"");
        for (int i=0; i < attr.getThrowsExceptions().size(); i++) {
          if (i > 0) {
            buffer.append(""String_Node_Str"");
          }
          if (descriptor != null && !descriptor.exceptions.isEmpty()) {
            GenericType type=descriptor.exceptions.get(i);
            buffer.append(GenericMain.getGenericCastTypeName(type));
          }
 else {
            VarType type=new VarType(attr.getExcClassname(i,cl.getPool()),true);
            buffer.append(ExprProcessor.getCastTypeName(type));
          }
        }
      }
    }
    tracer.incrementCurrentSourceLine(buffer.countLines(start_index_method));
    if ((flags & (CodeConstants.ACC_ABSTRACT | CodeConstants.ACC_NATIVE)) != 0) {
      if (isAnnotation) {
        StructAnnDefaultAttribute attr=(StructAnnDefaultAttribute)mt.getAttribute(""String_Node_Str"");
        if (attr != null) {
          buffer.append(""String_Node_Str"");
          buffer.append(attr.getDefaultValue().toJava(0,BytecodeMappingTracer.DUMMY));
        }
      }
      buffer.append(';');
      buffer.appendLineSeparator();
      tracer.incrementCurrentSourceLine();
    }
 else {
      if (!clinit && !dinit) {
        buffer.append(' ');
      }
      buffer.append('{').appendLineSeparator();
      tracer.incrementCurrentSourceLine();
      RootStatement root=wrapper.getMethodWrapper(mt.getName(),mt.getDescriptor()).root;
      if (root != null && !methodWrapper.decompiledWithErrors) {
        try {
          TextBuffer code=root.toJava(indent + 1,tracer);
          hideMethod=(clinit || dinit || hideConstructor(wrapper,init,throwsExceptions,paramCount)) && code.length() == 0;
          buffer.append(code);
        }
 catch (        Throwable ex) {
          DecompilerContext.getLogger().writeMessage(""String_Node_Str"" + mt.getName() + ""String_Node_Str""+ mt.getDescriptor()+ ""String_Node_Str"",IFernflowerLogger.Severity.WARN,ex);
          methodWrapper.decompiledWithErrors=true;
        }
      }
      if (methodWrapper.decompiledWithErrors) {
        buffer.appendIndent(indent + 1);
        buffer.append(""String_Node_Str"");
        buffer.appendLineSeparator();
        tracer.incrementCurrentSourceLine();
      }
      if (root != null) {
        tracer.addMapping(root.getDummyExit().bytecode);
      }
      buffer.appendIndent(indent).append('}').appendLineSeparator();
      tracer.incrementCurrentSourceLine();
    }
  }
  finally {
    DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER,outerWrapper);
  }
  return !hideMethod;
}","private boolean methodToJava(ClassNode node,StructMethod mt,TextBuffer buffer,int indent,BytecodeMappingTracer tracer){
  ClassWrapper wrapper=node.getWrapper();
  StructClass cl=wrapper.getClassStruct();
  MethodWrapper methodWrapper=wrapper.getMethodWrapper(mt.getName(),mt.getDescriptor());
  boolean hideMethod=false;
  int start_index_method=buffer.length();
  MethodWrapper outerWrapper=(MethodWrapper)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_WRAPPER);
  DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER,methodWrapper);
  try {
    boolean isInterface=cl.hasModifier(CodeConstants.ACC_INTERFACE);
    boolean isAnnotation=cl.hasModifier(CodeConstants.ACC_ANNOTATION);
    boolean isEnum=cl.hasModifier(CodeConstants.ACC_ENUM) && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_ENUM);
    boolean isDeprecated=mt.hasAttribute(""String_Node_Str"");
    boolean clinit=false, init=false, dinit=false;
    MethodDescriptor md=MethodDescriptor.parseDescriptor(mt.getDescriptor());
    int flags=mt.getAccessFlags();
    if ((flags & CodeConstants.ACC_NATIVE) != 0) {
      flags&=~CodeConstants.ACC_STRICT;
    }
    if (CodeConstants.CLINIT_NAME.equals(mt.getName())) {
      flags&=CodeConstants.ACC_STATIC;
    }
    if (isDeprecated) {
      appendDeprecation(buffer,indent);
    }
    if (interceptor != null) {
      String oldName=interceptor.getOldName(cl.qualifiedName + ""String_Node_Str"" + mt.getName()+ ""String_Node_Str""+ mt.getDescriptor());
      appendRenameComment(buffer,oldName,MType.METHOD,indent);
    }
    boolean isSynthetic=(flags & CodeConstants.ACC_SYNTHETIC) != 0 || mt.hasAttribute(""String_Node_Str"");
    boolean isBridge=(flags & CodeConstants.ACC_BRIDGE) != 0;
    if (isSynthetic) {
      appendComment(buffer,""String_Node_Str"",indent);
    }
    if (isBridge) {
      appendComment(buffer,""String_Node_Str"",indent);
    }
    appendAnnotations(buffer,indent,mt,TypeAnnotation.METHOD_RETURN_TYPE);
    buffer.appendIndent(indent);
    appendModifiers(buffer,flags,METHOD_ALLOWED,isInterface,METHOD_EXCLUDED);
    if (isInterface && !mt.hasModifier(CodeConstants.ACC_STATIC) && mt.containsCode()) {
      buffer.append(""String_Node_Str"");
    }
    String name=mt.getName();
    if (CodeConstants.INIT_NAME.equals(name)) {
      if (node.type == ClassNode.CLASS_ANONYMOUS) {
        name=""String_Node_Str"";
        dinit=true;
      }
 else {
        name=node.simpleName;
        init=true;
      }
    }
 else     if (CodeConstants.CLINIT_NAME.equals(name)) {
      name=""String_Node_Str"";
      clinit=true;
    }
    GenericMethodDescriptor descriptor=null;
    if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
      StructGenericSignatureAttribute attr=(StructGenericSignatureAttribute)mt.getAttribute(""String_Node_Str"");
      if (attr != null) {
        descriptor=GenericMain.parseMethodSignature(attr.getSignature());
        if (descriptor != null) {
          long actualParams=md.params.length;
          List<VarVersionPair> sigFields=methodWrapper.signatureFields;
          if (sigFields != null) {
            actualParams=sigFields.stream().filter(Objects::isNull).count();
          }
 else           if (isEnum && init)           actualParams-=2;
          if (actualParams != descriptor.params.size()) {
            String message=""String_Node_Str"" + mt.getName() + ""String_Node_Str""+ mt.getDescriptor()+ ""String_Node_Str""+ cl.qualifiedName;
            DecompilerContext.getLogger().writeMessage(message,IFernflowerLogger.Severity.WARN);
            descriptor=null;
          }
        }
      }
    }
    boolean throwsExceptions=false;
    int paramCount=0;
    if (!clinit && !dinit) {
      boolean thisVar=!mt.hasModifier(CodeConstants.ACC_STATIC);
      if (descriptor != null && !descriptor.fparameters.isEmpty()) {
        appendTypeParameters(buffer,descriptor.fparameters,descriptor.fbounds);
        buffer.append(' ');
      }
      if (!init) {
        if (descriptor != null) {
          buffer.append(GenericMain.getGenericCastTypeName(descriptor.ret));
        }
 else {
          buffer.append(ExprProcessor.getCastTypeName(md.ret));
        }
        buffer.append(' ');
      }
      buffer.append(toValidJavaIdentifier(name));
      buffer.append('(');
      List<VarVersionPair> signFields=methodWrapper.signatureFields;
      int lastVisibleParameterIndex=-1;
      for (int i=0; i < md.params.length; i++) {
        if (signFields == null || signFields.get(i) == null) {
          lastVisibleParameterIndex=i;
        }
      }
      boolean firstParameter=true;
      int index=isEnum && init ? 3 : thisVar ? 1 : 0;
      boolean hasDescriptor=descriptor != null;
      int start=isEnum && init && !hasDescriptor ? 2 : 0;
      int params=hasDescriptor ? descriptor.params.size() : md.params.length;
      for (int i=start; i < params; i++) {
        if (hasDescriptor || (signFields == null || signFields.get(i) == null)) {
          if (!firstParameter) {
            buffer.append(""String_Node_Str"");
          }
          appendParameterAnnotations(buffer,mt,paramCount);
          if (methodWrapper.varproc.getVarFinal(new VarVersionPair(index,0)) == VarTypeProcessor.VAR_EXPLICIT_FINAL) {
            buffer.append(""String_Node_Str"");
          }
          if (descriptor != null) {
            GenericType parameterType=descriptor.params.get(i);
            boolean isVarArg=(i == lastVisibleParameterIndex && mt.hasModifier(CodeConstants.ACC_VARARGS) && parameterType.arrayDim > 0);
            if (isVarArg) {
              parameterType=parameterType.decreaseArrayDim();
            }
            String typeName=GenericMain.getGenericCastTypeName(parameterType);
            if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) && DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {
              typeName=ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);
            }
            buffer.append(typeName);
            if (isVarArg) {
              buffer.append(""String_Node_Str"");
            }
          }
 else {
            VarType parameterType=md.params[i];
            boolean isVarArg=(i == lastVisibleParameterIndex && mt.hasModifier(CodeConstants.ACC_VARARGS) && parameterType.arrayDim > 0);
            if (isVarArg) {
              parameterType=parameterType.decreaseArrayDim();
            }
            String typeName=ExprProcessor.getCastTypeName(parameterType);
            if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) && DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {
              typeName=ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);
            }
            buffer.append(typeName);
            if (isVarArg) {
              buffer.append(""String_Node_Str"");
            }
          }
          buffer.append(' ');
          String parameterName=methodWrapper.varproc.getVarName(new VarVersionPair(index,0));
          buffer.append(parameterName == null ? ""String_Node_Str"" + index : parameterName);
          firstParameter=false;
          paramCount++;
        }
        index+=md.params[i].stackSize;
      }
      buffer.append(')');
      StructExceptionsAttribute attr=(StructExceptionsAttribute)mt.getAttribute(""String_Node_Str"");
      if ((descriptor != null && !descriptor.exceptions.isEmpty()) || attr != null) {
        throwsExceptions=true;
        buffer.append(""String_Node_Str"");
        for (int i=0; i < attr.getThrowsExceptions().size(); i++) {
          if (i > 0) {
            buffer.append(""String_Node_Str"");
          }
          if (descriptor != null && !descriptor.exceptions.isEmpty()) {
            GenericType type=descriptor.exceptions.get(i);
            buffer.append(GenericMain.getGenericCastTypeName(type));
          }
 else {
            VarType type=new VarType(attr.getExcClassname(i,cl.getPool()),true);
            buffer.append(ExprProcessor.getCastTypeName(type));
          }
        }
      }
    }
    tracer.incrementCurrentSourceLine(buffer.countLines(start_index_method));
    if ((flags & (CodeConstants.ACC_ABSTRACT | CodeConstants.ACC_NATIVE)) != 0) {
      if (isAnnotation) {
        StructAnnDefaultAttribute attr=(StructAnnDefaultAttribute)mt.getAttribute(""String_Node_Str"");
        if (attr != null) {
          buffer.append(""String_Node_Str"");
          buffer.append(attr.getDefaultValue().toJava(0,BytecodeMappingTracer.DUMMY));
        }
      }
      buffer.append(';');
      buffer.appendLineSeparator();
      tracer.incrementCurrentSourceLine();
    }
 else {
      if (!clinit && !dinit) {
        buffer.append(' ');
      }
      buffer.append('{').appendLineSeparator();
      tracer.incrementCurrentSourceLine();
      RootStatement root=wrapper.getMethodWrapper(mt.getName(),mt.getDescriptor()).root;
      if (root != null && !methodWrapper.decompiledWithErrors) {
        try {
          BytecodeMappingTracer codeTracer=new BytecodeMappingTracer(tracer.getCurrentSourceLine());
          TextBuffer code=root.toJava(indent + 1,codeTracer);
          hideMethod=(clinit || dinit || hideConstructor(wrapper,init,throwsExceptions,paramCount)) && code.length() == 0;
          buffer.append(code);
          tracer.setCurrentSourceLine(codeTracer.getCurrentSourceLine());
          tracer.addTracer(codeTracer);
        }
 catch (        Throwable ex) {
          DecompilerContext.getLogger().writeMessage(""String_Node_Str"" + mt.getName() + ""String_Node_Str""+ mt.getDescriptor()+ ""String_Node_Str"",IFernflowerLogger.Severity.WARN,ex);
          methodWrapper.decompiledWithErrors=true;
        }
      }
      if (methodWrapper.decompiledWithErrors) {
        buffer.appendIndent(indent + 1);
        buffer.append(""String_Node_Str"");
        buffer.appendLineSeparator();
        tracer.incrementCurrentSourceLine();
      }
 else       if (root != null) {
        tracer.addMapping(root.getDummyExit().bytecode);
      }
      buffer.appendIndent(indent).append('}').appendLineSeparator();
      tracer.incrementCurrentSourceLine();
    }
  }
  finally {
    DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER,outerWrapper);
  }
  return !hideMethod;
}"
54643,"private static void processStatementLabel(Statement stat,Set<Statement> setBreak,Set<Statement> setContinue){
  if (stat.getExprents() == null) {
    for (    Statement st : stat.getStats()) {
      processStatementLabel(st,setBreak,setContinue);
    }
    boolean shieldtype=(stat.type == Statement.TYPE_DO || stat.type == Statement.TYPE_SWITCH);
    for (    StatEdge edge : stat.getLabelEdges()) {
      if (edge.explicit) {
        if (shieldtype && ((edge.getType() == StatEdge.TYPE_BREAK && setBreak.contains(edge.getSource())) || (edge.getType() == StatEdge.TYPE_CONTINUE && setContinue.contains(edge.getSource())))) {
          edge.labeled=false;
        }
      }
    }
switch (stat.type) {
case Statement.TYPE_DO:
      setContinue.clear();
case Statement.TYPE_SWITCH:
    setBreak.clear();
}
}
setBreak.add(stat);
setContinue.add(stat);
}","private static HashSet<Statement>[] processStatementLabel(Statement stat){
  HashSet<Statement> setBreak=new HashSet<Statement>();
  HashSet<Statement> setContinue=new HashSet<Statement>();
  if (stat.getExprents() == null) {
    for (    Statement st : stat.getStats()) {
      HashSet<Statement>[] arr=processStatementLabel(st);
      setBreak.addAll(arr[0]);
      setContinue.addAll(arr[1]);
    }
    boolean shieldtype=(stat.type == Statement.TYPE_DO || stat.type == Statement.TYPE_SWITCH);
    for (    StatEdge edge : stat.getLabelEdges()) {
      if (edge.explicit) {
        if (shieldtype && ((edge.getType() == StatEdge.TYPE_BREAK && setBreak.contains(edge.getSource())) || (edge.getType() == StatEdge.TYPE_CONTINUE && setContinue.contains(edge.getSource())))) {
          edge.labeled=false;
        }
      }
    }
switch (stat.type) {
case Statement.TYPE_DO:
      setContinue.clear();
case Statement.TYPE_SWITCH:
    setBreak.clear();
}
}
setBreak.add(stat);
setContinue.add(stat);
return new HashSet[]{setBreak,setContinue};
}"
54644,"private static byte[] readAndClose(InputStream stream,long length) throws IOException {
  try {
    byte[] bytes=new byte[(int)length];
    if (stream.read(bytes) != length) {
      throw new IOException(""String_Node_Str"");
    }
    return bytes;
  }
  finally {
    stream.close();
  }
}","private static byte[] readAndClose(InputStream stream,long length) throws IOException {
  try {
    byte[] bytes=new byte[(int)length];
    DataInputStream dataStream=new DataInputStream(stream);
    try {
      dataStream.readFully(bytes);
    }
 catch (    EOFException ex) {
      throw new IOException(""String_Node_Str"",ex);
    }
 finally {
      dataStream.close();
    }
    return bytes;
  }
  finally {
    stream.close();
  }
}"
54645,"private boolean methodToJava(ClassNode node,StructMethod mt,StringBuilder buffer,int indent,BytecodeMappingTracer tracer){
  ClassWrapper wrapper=node.wrapper;
  StructClass cl=wrapper.getClassStruct();
  MethodWrapper methodWrapper=wrapper.getMethodWrapper(mt.getName(),mt.getDescriptor());
  boolean hideMethod=false;
  int start_index_method=buffer.length();
  String indentString=InterpreterUtil.getIndentString(indent);
  String lineSeparator=DecompilerContext.getNewLineSeparator();
  MethodWrapper outerWrapper=(MethodWrapper)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_WRAPPER);
  DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER,methodWrapper);
  try {
    boolean isInterface=cl.hasModifier(CodeConstants.ACC_INTERFACE);
    boolean isAnnotation=cl.hasModifier(CodeConstants.ACC_ANNOTATION);
    boolean isEnum=cl.hasModifier(CodeConstants.ACC_ENUM) && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_ENUM);
    boolean isDeprecated=mt.getAttributes().containsKey(""String_Node_Str"");
    boolean clinit=false, init=false, dinit=false;
    MethodDescriptor md=MethodDescriptor.parseDescriptor(mt.getDescriptor());
    int flags=mt.getAccessFlags();
    if ((flags & CodeConstants.ACC_NATIVE) != 0) {
      flags&=~CodeConstants.ACC_STRICT;
    }
    if (""String_Node_Str"".equals(mt.getName())) {
      flags&=CodeConstants.ACC_STATIC;
    }
    if (isDeprecated) {
      appendDeprecation(buffer,indentString,lineSeparator);
    }
    if (interceptor != null) {
      String oldName=interceptor.getOldName(cl.qualifiedName + ""String_Node_Str"" + mt.getName()+ ""String_Node_Str""+ mt.getDescriptor());
      appendRenameComment(buffer,oldName,MType.METHOD,indent,lineSeparator);
    }
    boolean isSynthetic=(flags & CodeConstants.ACC_SYNTHETIC) != 0 || mt.getAttributes().containsKey(""String_Node_Str"");
    boolean isBridge=(flags & CodeConstants.ACC_BRIDGE) != 0;
    if (isSynthetic) {
      appendComment(buffer,""String_Node_Str"",indentString,lineSeparator);
    }
    if (isBridge) {
      appendComment(buffer,""String_Node_Str"",indentString,lineSeparator);
    }
    appendAnnotations(buffer,mt,indent,lineSeparator);
    buffer.append(indentString);
    appendModifiers(buffer,flags,METHOD_ALLOWED,isInterface,METHOD_EXCLUDED);
    if (isInterface && mt.containsCode()) {
      buffer.append(""String_Node_Str"");
    }
    String name=mt.getName();
    if (""String_Node_Str"".equals(name)) {
      if (node.type == ClassNode.CLASS_ANONYMOUS) {
        name=""String_Node_Str"";
        dinit=true;
      }
 else {
        name=node.simpleName;
        init=true;
      }
    }
 else     if (""String_Node_Str"".equals(name)) {
      name=""String_Node_Str"";
      clinit=true;
    }
    GenericMethodDescriptor descriptor=null;
    if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
      StructGenericSignatureAttribute attr=(StructGenericSignatureAttribute)mt.getAttributes().getWithKey(""String_Node_Str"");
      if (attr != null) {
        descriptor=GenericMain.parseMethodSignature(attr.getSignature());
        if (descriptor != null) {
          int actualParams=md.params.length;
          if (isEnum && init)           actualParams-=2;
          if (actualParams != descriptor.params.size()) {
            String message=""String_Node_Str"" + mt.getName() + ""String_Node_Str""+ mt.getDescriptor();
            DecompilerContext.getLogger().writeMessage(message,IFernflowerLogger.Severity.WARN);
            descriptor=null;
          }
        }
      }
    }
    boolean throwsExceptions=false;
    int paramCount=0;
    if (!clinit && !dinit) {
      boolean thisVar=!mt.hasModifier(CodeConstants.ACC_STATIC);
      if (descriptor != null && !descriptor.fparameters.isEmpty()) {
        appendTypeParameters(buffer,descriptor.fparameters,descriptor.fbounds);
        buffer.append(' ');
      }
      if (!init) {
        if (descriptor != null) {
          buffer.append(GenericMain.getGenericCastTypeName(descriptor.ret));
        }
 else {
          buffer.append(ExprProcessor.getCastTypeName(md.ret));
        }
        buffer.append(' ');
      }
      buffer.append(name);
      buffer.append('(');
      List<VarVersionPaar> signFields=methodWrapper.signatureFields;
      int lastVisibleParameterIndex=-1;
      for (int i=0; i < md.params.length; i++) {
        if (signFields == null || signFields.get(i) == null) {
          lastVisibleParameterIndex=i;
        }
      }
      boolean firstParameter=true;
      int index=isEnum && init ? 3 : thisVar ? 1 : 0;
      int start=isEnum && init && descriptor == null ? 2 : 0;
      int params=descriptor == null ? md.params.length : descriptor.params.size();
      for (int i=start; i < params; i++) {
        if (signFields == null || signFields.get(i) == null) {
          if (!firstParameter) {
            buffer.append(""String_Node_Str"");
          }
          appendParameterAnnotations(buffer,mt,paramCount);
          if (methodWrapper.varproc.getVarFinal(new VarVersionPaar(index,0)) == VarTypeProcessor.VAR_FINALEXPLICIT) {
            buffer.append(""String_Node_Str"");
          }
          if (descriptor != null) {
            GenericType parameterType=descriptor.params.get(i);
            boolean isVarArg=(i == lastVisibleParameterIndex && mt.hasModifier(CodeConstants.ACC_VARARGS) && parameterType.arraydim > 0);
            if (isVarArg) {
              parameterType.arraydim--;
            }
            String typeName=GenericMain.getGenericCastTypeName(parameterType);
            if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) && DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {
              typeName=ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);
            }
            buffer.append(typeName);
            if (isVarArg) {
              buffer.append(""String_Node_Str"");
            }
          }
 else {
            VarType parameterType=md.params[i].copy();
            boolean isVarArg=(i == lastVisibleParameterIndex && mt.hasModifier(CodeConstants.ACC_VARARGS) && parameterType.arraydim > 0);
            if (isVarArg) {
              parameterType.decArrayDim();
            }
            String typeName=ExprProcessor.getCastTypeName(parameterType);
            if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) && DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {
              typeName=ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);
            }
            buffer.append(typeName);
            if (isVarArg) {
              buffer.append(""String_Node_Str"");
            }
          }
          buffer.append(' ');
          String parameterName=methodWrapper.varproc.getVarName(new VarVersionPaar(index,0));
          buffer.append(parameterName == null ? ""String_Node_Str"" + index : parameterName);
          firstParameter=false;
          paramCount++;
        }
        index+=md.params[i].stack_size;
      }
      buffer.append(')');
      StructExceptionsAttribute attr=(StructExceptionsAttribute)mt.getAttributes().getWithKey(""String_Node_Str"");
      if ((descriptor != null && !descriptor.exceptions.isEmpty()) || attr != null) {
        throwsExceptions=true;
        buffer.append(""String_Node_Str"");
        for (int i=0; i < attr.getThrowsExceptions().size(); i++) {
          if (i > 0) {
            buffer.append(""String_Node_Str"");
          }
          if (descriptor != null && !descriptor.exceptions.isEmpty()) {
            GenericType type=descriptor.exceptions.get(i);
            buffer.append(GenericMain.getGenericCastTypeName(type));
          }
 else {
            VarType type=new VarType(attr.getExcClassname(i,cl.getPool()),true);
            buffer.append(ExprProcessor.getCastTypeName(type));
          }
        }
      }
    }
    if ((flags & (CodeConstants.ACC_ABSTRACT | CodeConstants.ACC_NATIVE)) != 0) {
      if (isAnnotation) {
        StructAnnDefaultAttribute attr=(StructAnnDefaultAttribute)mt.getAttributes().getWithKey(""String_Node_Str"");
        if (attr != null) {
          buffer.append(""String_Node_Str"");
          buffer.append(attr.getDefaultValue().toJava(indent + 1,new BytecodeMappingTracer()));
        }
      }
      buffer.append(';');
      buffer.append(lineSeparator);
    }
 else {
      if (!clinit && !dinit) {
        buffer.append(' ');
      }
      buffer.append('{');
      buffer.append(lineSeparator);
      RootStatement root=wrapper.getMethodWrapper(mt.getName(),mt.getDescriptor()).root;
      if (root != null && !methodWrapper.decompiledWithErrors) {
        try {
          tracer.setCurrentSourceline(buffer.substring(start_index_method).split(lineSeparator,-1).length - 1);
          String code=root.toJava(indent + 1,tracer);
          hideMethod=(clinit || dinit || hideConstructor(wrapper,init,throwsExceptions,paramCount)) && code.length() == 0;
          buffer.append(code);
        }
 catch (        Throwable ex) {
          DecompilerContext.getLogger().writeMessage(""String_Node_Str"" + mt.getName() + ""String_Node_Str""+ mt.getDescriptor()+ ""String_Node_Str"",ex);
          methodWrapper.decompiledWithErrors=true;
        }
      }
      if (methodWrapper.decompiledWithErrors) {
        buffer.append(InterpreterUtil.getIndentString(indent + 1));
        buffer.append(""String_Node_Str"");
        buffer.append(lineSeparator);
      }
      buffer.append(indentString);
      buffer.append('}');
      buffer.append(lineSeparator);
    }
  }
  finally {
    DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER,outerWrapper);
  }
  tracer.setCurrentSourceline(buffer.substring(start_index_method).split(lineSeparator,-1).length - 1);
  return !hideMethod;
}","private boolean methodToJava(ClassNode node,StructMethod mt,StringBuilder buffer,int indent,BytecodeMappingTracer tracer){
  ClassWrapper wrapper=node.wrapper;
  StructClass cl=wrapper.getClassStruct();
  MethodWrapper methodWrapper=wrapper.getMethodWrapper(mt.getName(),mt.getDescriptor());
  boolean hideMethod=false;
  int start_index_method=buffer.length();
  String indentString=InterpreterUtil.getIndentString(indent);
  String lineSeparator=DecompilerContext.getNewLineSeparator();
  MethodWrapper outerWrapper=(MethodWrapper)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_WRAPPER);
  DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER,methodWrapper);
  try {
    boolean isInterface=cl.hasModifier(CodeConstants.ACC_INTERFACE);
    boolean isAnnotation=cl.hasModifier(CodeConstants.ACC_ANNOTATION);
    boolean isEnum=cl.hasModifier(CodeConstants.ACC_ENUM) && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_ENUM);
    boolean isDeprecated=mt.getAttributes().containsKey(""String_Node_Str"");
    boolean clinit=false, init=false, dinit=false;
    MethodDescriptor md=MethodDescriptor.parseDescriptor(mt.getDescriptor());
    int flags=mt.getAccessFlags();
    if ((flags & CodeConstants.ACC_NATIVE) != 0) {
      flags&=~CodeConstants.ACC_STRICT;
    }
    if (""String_Node_Str"".equals(mt.getName())) {
      flags&=CodeConstants.ACC_STATIC;
    }
    if (isDeprecated) {
      appendDeprecation(buffer,indentString,lineSeparator);
    }
    if (interceptor != null) {
      String oldName=interceptor.getOldName(cl.qualifiedName + ""String_Node_Str"" + mt.getName()+ ""String_Node_Str""+ mt.getDescriptor());
      appendRenameComment(buffer,oldName,MType.METHOD,indent,lineSeparator);
    }
    boolean isSynthetic=(flags & CodeConstants.ACC_SYNTHETIC) != 0 || mt.getAttributes().containsKey(""String_Node_Str"");
    boolean isBridge=(flags & CodeConstants.ACC_BRIDGE) != 0;
    if (isSynthetic) {
      appendComment(buffer,""String_Node_Str"",indentString,lineSeparator);
    }
    if (isBridge) {
      appendComment(buffer,""String_Node_Str"",indentString,lineSeparator);
    }
    appendAnnotations(buffer,mt,indent,lineSeparator);
    buffer.append(indentString);
    appendModifiers(buffer,flags,METHOD_ALLOWED,isInterface,METHOD_EXCLUDED);
    if (isInterface && mt.containsCode()) {
      buffer.append(""String_Node_Str"");
    }
    String name=mt.getName();
    if (""String_Node_Str"".equals(name)) {
      if (node.type == ClassNode.CLASS_ANONYMOUS) {
        name=""String_Node_Str"";
        dinit=true;
      }
 else {
        name=node.simpleName;
        init=true;
      }
    }
 else     if (""String_Node_Str"".equals(name)) {
      name=""String_Node_Str"";
      clinit=true;
    }
    GenericMethodDescriptor descriptor=null;
    if (DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_GENERIC_SIGNATURES)) {
      StructGenericSignatureAttribute attr=(StructGenericSignatureAttribute)mt.getAttributes().getWithKey(""String_Node_Str"");
      if (attr != null) {
        descriptor=GenericMain.parseMethodSignature(attr.getSignature());
        if (descriptor != null) {
          int actualParams=md.params.length;
          if (isEnum && init)           actualParams-=2;
          if (actualParams != descriptor.params.size()) {
            String message=""String_Node_Str"" + mt.getName() + ""String_Node_Str""+ mt.getDescriptor();
            DecompilerContext.getLogger().writeMessage(message,IFernflowerLogger.Severity.WARN);
            descriptor=null;
          }
        }
      }
    }
    boolean throwsExceptions=false;
    int paramCount=0;
    if (!clinit && !dinit) {
      boolean thisVar=!mt.hasModifier(CodeConstants.ACC_STATIC);
      if (descriptor != null && !descriptor.fparameters.isEmpty()) {
        appendTypeParameters(buffer,descriptor.fparameters,descriptor.fbounds);
        buffer.append(' ');
      }
      if (!init) {
        if (descriptor != null) {
          buffer.append(GenericMain.getGenericCastTypeName(descriptor.ret));
        }
 else {
          buffer.append(ExprProcessor.getCastTypeName(md.ret));
        }
        buffer.append(' ');
      }
      buffer.append(name);
      buffer.append('(');
      List<VarVersionPaar> signFields=methodWrapper.signatureFields;
      int lastVisibleParameterIndex=-1;
      for (int i=0; i < md.params.length; i++) {
        if (signFields == null || signFields.get(i) == null) {
          lastVisibleParameterIndex=i;
        }
      }
      boolean firstParameter=true;
      int index=isEnum && init ? 3 : thisVar ? 1 : 0;
      int start=isEnum && init && descriptor == null ? 2 : 0;
      int params=descriptor == null ? md.params.length : descriptor.params.size();
      for (int i=start; i < params; i++) {
        if (signFields == null || signFields.get(i) == null) {
          if (!firstParameter) {
            buffer.append(""String_Node_Str"");
          }
          appendParameterAnnotations(buffer,mt,paramCount);
          if (methodWrapper.varproc.getVarFinal(new VarVersionPaar(index,0)) == VarTypeProcessor.VAR_FINALEXPLICIT) {
            buffer.append(""String_Node_Str"");
          }
          if (descriptor != null) {
            GenericType parameterType=descriptor.params.get(i);
            boolean isVarArg=(i == lastVisibleParameterIndex && mt.hasModifier(CodeConstants.ACC_VARARGS) && parameterType.arraydim > 0);
            if (isVarArg) {
              parameterType.arraydim--;
            }
            String typeName=GenericMain.getGenericCastTypeName(parameterType);
            if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) && DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {
              typeName=ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);
            }
            buffer.append(typeName);
            if (isVarArg) {
              buffer.append(""String_Node_Str"");
            }
          }
 else {
            VarType parameterType=md.params[i].copy();
            boolean isVarArg=(i == lastVisibleParameterIndex && mt.hasModifier(CodeConstants.ACC_VARARGS) && parameterType.arraydim > 0);
            if (isVarArg) {
              parameterType.decArrayDim();
            }
            String typeName=ExprProcessor.getCastTypeName(parameterType);
            if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(typeName) && DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {
              typeName=ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);
            }
            buffer.append(typeName);
            if (isVarArg) {
              buffer.append(""String_Node_Str"");
            }
          }
          buffer.append(' ');
          String parameterName=methodWrapper.varproc.getVarName(new VarVersionPaar(index,0));
          buffer.append(parameterName == null ? ""String_Node_Str"" + index : parameterName);
          firstParameter=false;
          paramCount++;
        }
        index+=md.params[i].stack_size;
      }
      buffer.append(')');
      StructExceptionsAttribute attr=(StructExceptionsAttribute)mt.getAttributes().getWithKey(""String_Node_Str"");
      if ((descriptor != null && !descriptor.exceptions.isEmpty()) || attr != null) {
        throwsExceptions=true;
        buffer.append(""String_Node_Str"");
        for (int i=0; i < attr.getThrowsExceptions().size(); i++) {
          if (i > 0) {
            buffer.append(""String_Node_Str"");
          }
          if (descriptor != null && !descriptor.exceptions.isEmpty()) {
            GenericType type=descriptor.exceptions.get(i);
            buffer.append(GenericMain.getGenericCastTypeName(type));
          }
 else {
            VarType type=new VarType(attr.getExcClassname(i,cl.getPool()),true);
            buffer.append(ExprProcessor.getCastTypeName(type));
          }
        }
      }
    }
    if ((flags & (CodeConstants.ACC_ABSTRACT | CodeConstants.ACC_NATIVE)) != 0) {
      if (isAnnotation) {
        StructAnnDefaultAttribute attr=(StructAnnDefaultAttribute)mt.getAttributes().getWithKey(""String_Node_Str"");
        if (attr != null) {
          buffer.append(""String_Node_Str"");
          buffer.append(attr.getDefaultValue().toJava(indent + 1,new BytecodeMappingTracer()));
        }
      }
      buffer.append(';');
      buffer.append(lineSeparator);
    }
 else {
      if (!clinit && !dinit) {
        buffer.append(' ');
      }
      buffer.append('{');
      buffer.append(lineSeparator);
      RootStatement root=wrapper.getMethodWrapper(mt.getName(),mt.getDescriptor()).root;
      if (root != null && !methodWrapper.decompiledWithErrors) {
        try {
          tracer.incrementCurrentSourceLine(buffer.substring(start_index_method).split(lineSeparator,-1).length - 1);
          String code=root.toJava(indent + 1,tracer);
          hideMethod=(clinit || dinit || hideConstructor(wrapper,init,throwsExceptions,paramCount)) && code.length() == 0;
          buffer.append(code);
        }
 catch (        Throwable ex) {
          DecompilerContext.getLogger().writeMessage(""String_Node_Str"" + mt.getName() + ""String_Node_Str""+ mt.getDescriptor()+ ""String_Node_Str"",ex);
          methodWrapper.decompiledWithErrors=true;
        }
      }
      if (methodWrapper.decompiledWithErrors) {
        buffer.append(InterpreterUtil.getIndentString(indent + 1));
        buffer.append(""String_Node_Str"");
        buffer.append(lineSeparator);
      }
      buffer.append(indentString);
      buffer.append('}');
      buffer.append(lineSeparator);
    }
  }
  finally {
    DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER,outerWrapper);
  }
  tracer.setCurrentSourceLine(buffer.substring(start_index_method).split(lineSeparator,-1).length - 1);
  return !hideMethod;
}"
54646,"public void classToJava(ClassNode node,StringBuilder buffer,int indent){
  ClassNode outerNode=(ClassNode)DecompilerContext.getProperty(DecompilerContext.CURRENT_CLASS_NODE);
  DecompilerContext.setProperty(DecompilerContext.CURRENT_CLASS_NODE,node);
  int total_offset_lines=0;
  BytecodeMappingTracer dummy_tracer=new BytecodeMappingTracer();
  try {
    invokeProcessors(node);
    ClassWrapper wrapper=node.wrapper;
    StructClass cl=wrapper.getClassStruct();
    DecompilerContext.getLogger().startWriteClass(cl.qualifiedName);
    String lineSeparator=DecompilerContext.getNewLineSeparator();
    int start_class_def=buffer.length();
    writeClassDefinition(node,buffer,indent);
    total_offset_lines=buffer.substring(start_class_def).toString().split(lineSeparator,-1).length - 1;
    boolean hasContent=false;
    boolean enumFields=false;
    for (    StructField fd : cl.getFields()) {
      boolean hide=fd.isSynthetic() && DecompilerContext.getOption(IFernflowerPreferences.REMOVE_SYNTHETIC) || wrapper.getHiddenMembers().contains(InterpreterUtil.makeUniqueKey(fd.getName(),fd.getDescriptor()));
      if (hide)       continue;
      boolean isEnum=fd.hasModifier(CodeConstants.ACC_ENUM) && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_ENUM);
      if (isEnum) {
        if (enumFields) {
          buffer.append(',');
          buffer.append(lineSeparator);
        }
        enumFields=true;
      }
 else       if (enumFields) {
        buffer.append(';');
        buffer.append(lineSeparator);
        buffer.append(lineSeparator);
        enumFields=false;
      }
      fieldToJava(wrapper,cl,fd,buffer,indent + 1,dummy_tracer);
      hasContent=true;
    }
    if (enumFields) {
      buffer.append(';');
      buffer.append(lineSeparator);
    }
    for (    StructMethod mt : cl.getMethods()) {
      boolean hide=mt.isSynthetic() && DecompilerContext.getOption(IFernflowerPreferences.REMOVE_SYNTHETIC) || mt.hasModifier(CodeConstants.ACC_BRIDGE) && DecompilerContext.getOption(IFernflowerPreferences.REMOVE_BRIDGE) || wrapper.getHiddenMembers().contains(InterpreterUtil.makeUniqueKey(mt.getName(),mt.getDescriptor()));
      if (hide)       continue;
      int position=buffer.length();
      if (hasContent) {
        buffer.append(lineSeparator);
      }
      BytecodeMappingTracer method_tracer=new BytecodeMappingTracer(total_offset_lines);
      boolean methodSkipped=!methodToJava(node,mt,buffer,indent + 1,method_tracer);
      if (!methodSkipped) {
        hasContent=true;
        DecompilerContext.getBytecodeSourceMapper().addTracer(cl.qualifiedName,InterpreterUtil.makeUniqueKey(mt.getName(),mt.getDescriptor()),method_tracer);
        total_offset_lines=method_tracer.getCurrentSourceline();
      }
 else {
        buffer.setLength(position);
      }
    }
    for (    ClassNode inner : node.nested) {
      if (inner.type == ClassNode.CLASS_MEMBER) {
        StructClass innerCl=inner.classStruct;
        boolean isSynthetic=(inner.access & CodeConstants.ACC_SYNTHETIC) != 0 || innerCl.isSynthetic();
        boolean hide=isSynthetic && DecompilerContext.getOption(IFernflowerPreferences.REMOVE_SYNTHETIC) || wrapper.getHiddenMembers().contains(innerCl.qualifiedName);
        if (hide)         continue;
        if (hasContent) {
          buffer.append(lineSeparator);
        }
        classToJava(inner,buffer,indent + 1);
        hasContent=true;
      }
    }
    InterpreterUtil.appendIndent(buffer,indent);
    buffer.append('}');
    if (node.type != ClassNode.CLASS_ANONYMOUS) {
      buffer.append(lineSeparator);
    }
  }
  finally {
    DecompilerContext.setProperty(DecompilerContext.CURRENT_CLASS_NODE,outerNode);
  }
  DecompilerContext.getLogger().endWriteClass();
}","public void classToJava(ClassNode node,StringBuilder buffer,int indent){
  ClassNode outerNode=(ClassNode)DecompilerContext.getProperty(DecompilerContext.CURRENT_CLASS_NODE);
  DecompilerContext.setProperty(DecompilerContext.CURRENT_CLASS_NODE,node);
  int total_offset_lines=0;
  BytecodeMappingTracer dummy_tracer=new BytecodeMappingTracer();
  try {
    invokeProcessors(node);
    ClassWrapper wrapper=node.wrapper;
    StructClass cl=wrapper.getClassStruct();
    DecompilerContext.getLogger().startWriteClass(cl.qualifiedName);
    String lineSeparator=DecompilerContext.getNewLineSeparator();
    int start_class_def=buffer.length();
    writeClassDefinition(node,buffer,indent);
    boolean hasContent=false;
    boolean enumFields=false;
    for (    StructField fd : cl.getFields()) {
      boolean hide=fd.isSynthetic() && DecompilerContext.getOption(IFernflowerPreferences.REMOVE_SYNTHETIC) || wrapper.getHiddenMembers().contains(InterpreterUtil.makeUniqueKey(fd.getName(),fd.getDescriptor()));
      if (hide)       continue;
      boolean isEnum=fd.hasModifier(CodeConstants.ACC_ENUM) && DecompilerContext.getOption(IFernflowerPreferences.DECOMPILE_ENUM);
      if (isEnum) {
        if (enumFields) {
          buffer.append(',');
          buffer.append(lineSeparator);
        }
        enumFields=true;
      }
 else       if (enumFields) {
        buffer.append(';');
        buffer.append(lineSeparator);
        buffer.append(lineSeparator);
        enumFields=false;
      }
      fieldToJava(wrapper,cl,fd,buffer,indent + 1,dummy_tracer);
      hasContent=true;
    }
    if (enumFields) {
      buffer.append(';');
      buffer.append(lineSeparator);
    }
    total_offset_lines=buffer.substring(start_class_def).toString().split(lineSeparator,-1).length - 1;
    for (    StructMethod mt : cl.getMethods()) {
      boolean hide=mt.isSynthetic() && DecompilerContext.getOption(IFernflowerPreferences.REMOVE_SYNTHETIC) || mt.hasModifier(CodeConstants.ACC_BRIDGE) && DecompilerContext.getOption(IFernflowerPreferences.REMOVE_BRIDGE) || wrapper.getHiddenMembers().contains(InterpreterUtil.makeUniqueKey(mt.getName(),mt.getDescriptor()));
      if (hide)       continue;
      int position=buffer.length();
      if (hasContent) {
        buffer.append(lineSeparator);
      }
      BytecodeMappingTracer method_tracer=new BytecodeMappingTracer(total_offset_lines);
      boolean methodSkipped=!methodToJava(node,mt,buffer,indent + 1,method_tracer);
      if (!methodSkipped) {
        hasContent=true;
        DecompilerContext.getBytecodeSourceMapper().addTracer(cl.qualifiedName,InterpreterUtil.makeUniqueKey(mt.getName(),mt.getDescriptor()),method_tracer);
        total_offset_lines=(method_tracer.getCurrentSourceLine() + 1);
      }
 else {
        buffer.setLength(position);
      }
    }
    for (    ClassNode inner : node.nested) {
      if (inner.type == ClassNode.CLASS_MEMBER) {
        StructClass innerCl=inner.classStruct;
        boolean isSynthetic=(inner.access & CodeConstants.ACC_SYNTHETIC) != 0 || innerCl.isSynthetic();
        boolean hide=isSynthetic && DecompilerContext.getOption(IFernflowerPreferences.REMOVE_SYNTHETIC) || wrapper.getHiddenMembers().contains(innerCl.qualifiedName);
        if (hide)         continue;
        if (hasContent) {
          buffer.append(lineSeparator);
        }
        classToJava(inner,buffer,indent + 1);
        hasContent=true;
      }
    }
    InterpreterUtil.appendIndent(buffer,indent);
    buffer.append('}');
    if (node.type != ClassNode.CLASS_ANONYMOUS) {
      buffer.append(lineSeparator);
    }
  }
  finally {
    DecompilerContext.setProperty(DecompilerContext.CURRENT_CLASS_NODE,outerNode);
  }
  DecompilerContext.getLogger().endWriteClass();
}"
54647,"public void writeClass(StructClass cl,StringBuilder buffer) throws IOException {
  ClassNode root=mapRootClasses.get(cl.qualifiedName);
  if (root.type != ClassNode.CLASS_ROOT) {
    return;
  }
  try {
    ImportCollector importCollector=new ImportCollector(root);
    DecompilerContext.setImportCollector(importCollector);
    DecompilerContext.setCounterContainer(new CounterContainer());
    DecompilerContext.setBytecodeSourceMapper(new BytecodeSourceMapper());
    new LambdaProcessor().processClass(root);
    addClassnameToImport(root,importCollector);
    initWrappers(root);
    new NestedClassProcessor().processClass(root,root);
    new NestedMemberAccess().propagateMemberAccess(root);
    StringBuilder classBuffer=new StringBuilder(AVERAGE_CLASS_SIZE);
    new ClassWriter().classToJava(root,classBuffer,0);
    String lineSeparator=DecompilerContext.getNewLineSeparator();
    int total_offset_lines=0;
    int index=cl.qualifiedName.lastIndexOf(""String_Node_Str"");
    if (index >= 0) {
      total_offset_lines++;
      String packageName=cl.qualifiedName.substring(0,index).replace('/','.');
      buffer.append(""String_Node_Str"");
      buffer.append(packageName);
      buffer.append(""String_Node_Str"");
      buffer.append(lineSeparator);
      buffer.append(lineSeparator);
    }
    int import_lines_written=importCollector.writeImports(buffer);
    if (import_lines_written > 0) {
      buffer.append(lineSeparator);
      total_offset_lines+=import_lines_written + 1;
    }
    buffer.append(classBuffer);
    if (DecompilerContext.getOption(IFernflowerPreferences.BYTECODE_SOURCE_MAPPING)) {
      BytecodeSourceMapper mapper=DecompilerContext.getBytecodeSourceMapper();
      mapper.addTotalOffset(total_offset_lines);
      buffer.append(lineSeparator);
      mapper.dumpMapping(buffer);
    }
  }
  finally {
    destroyWrappers(root);
  }
}","public void writeClass(StructClass cl,StringBuilder buffer) throws IOException {
  ClassNode root=mapRootClasses.get(cl.qualifiedName);
  if (root.type != ClassNode.CLASS_ROOT) {
    return;
  }
  try {
    ImportCollector importCollector=new ImportCollector(root);
    DecompilerContext.setImportCollector(importCollector);
    DecompilerContext.setCounterContainer(new CounterContainer());
    DecompilerContext.setBytecodeSourceMapper(new BytecodeSourceMapper());
    new LambdaProcessor().processClass(root);
    addClassnameToImport(root,importCollector);
    initWrappers(root);
    new NestedClassProcessor().processClass(root,root);
    new NestedMemberAccess().propagateMemberAccess(root);
    StringBuilder classBuffer=new StringBuilder(AVERAGE_CLASS_SIZE);
    new ClassWriter().classToJava(root,classBuffer,0);
    String lineSeparator=DecompilerContext.getNewLineSeparator();
    int total_offset_lines=0;
    int index=cl.qualifiedName.lastIndexOf(""String_Node_Str"");
    if (index >= 0) {
      total_offset_lines+=2;
      String packageName=cl.qualifiedName.substring(0,index).replace('/','.');
      buffer.append(""String_Node_Str"");
      buffer.append(packageName);
      buffer.append(""String_Node_Str"");
      buffer.append(lineSeparator);
      buffer.append(lineSeparator);
    }
    int import_lines_written=importCollector.writeImports(buffer);
    if (import_lines_written > 0) {
      buffer.append(lineSeparator);
      total_offset_lines+=import_lines_written + 1;
    }
    buffer.append(classBuffer);
    if (DecompilerContext.getOption(IFernflowerPreferences.BYTECODE_SOURCE_MAPPING)) {
      BytecodeSourceMapper mapper=DecompilerContext.getBytecodeSourceMapper();
      mapper.addTotalOffset(total_offset_lines);
      buffer.append(lineSeparator);
      mapper.dumpMapping(buffer);
    }
  }
  finally {
    destroyWrappers(root);
  }
}"
54648,"public void dumpMapping(StringBuilder buffer){
  String lineSeparator=DecompilerContext.getNewLineSeparator();
  String indentstr1=InterpreterUtil.getIndentString(1);
  String indentstr2=InterpreterUtil.getIndentString(2);
  for (  Entry<String,HashMap<String,HashMap<Integer,Integer>>> class_entry : mapping.entrySet()) {
    HashMap<String,HashMap<Integer,Integer>> class_mapping=class_entry.getValue();
    buffer.append(""String_Node_Str"" + class_entry.getKey() + ""String_Node_Str""+ lineSeparator);
    boolean is_first_method=true;
    for (    Entry<String,HashMap<Integer,Integer>> method_entry : class_mapping.entrySet()) {
      HashMap<Integer,Integer> method_mapping=method_entry.getValue();
      if (!is_first_method) {
        buffer.append(lineSeparator);
      }
      buffer.append(indentstr1 + ""String_Node_Str"" + method_entry.getKey()+ ""String_Node_Str""+ lineSeparator);
      for (      Entry<Integer,Integer> line : method_mapping.entrySet()) {
        buffer.append(indentstr2 + line.getKey() + indentstr2+ line.getValue()+ lineSeparator);
      }
      buffer.append(indentstr1 + ""String_Node_Str"" + lineSeparator);
      is_first_method=false;
    }
    buffer.append(""String_Node_Str"" + lineSeparator);
  }
}","public void dumpMapping(StringBuilder buffer){
  String lineSeparator=DecompilerContext.getNewLineSeparator();
  String indentstr1=InterpreterUtil.getIndentString(1);
  String indentstr2=InterpreterUtil.getIndentString(2);
  for (  Entry<String,HashMap<String,HashMap<Integer,Integer>>> class_entry : mapping.entrySet()) {
    HashMap<String,HashMap<Integer,Integer>> class_mapping=class_entry.getValue();
    buffer.append(""String_Node_Str"" + class_entry.getKey() + ""String_Node_Str""+ lineSeparator);
    boolean is_first_method=true;
    for (    Entry<String,HashMap<Integer,Integer>> method_entry : class_mapping.entrySet()) {
      HashMap<Integer,Integer> method_mapping=method_entry.getValue();
      if (!is_first_method) {
        buffer.append(lineSeparator);
      }
      buffer.append(indentstr1 + ""String_Node_Str"" + method_entry.getKey()+ ""String_Node_Str""+ lineSeparator);
      for (      Entry<Integer,Integer> line : method_mapping.entrySet()) {
        buffer.append(indentstr2 + line.getKey() + indentstr2+ (line.getValue() + offset_total)+ lineSeparator);
      }
      buffer.append(indentstr1 + ""String_Node_Str"" + lineSeparator);
      is_first_method=false;
    }
    buffer.append(""String_Node_Str"" + lineSeparator);
  }
}"
54649,"public static String listToJava(List<Exprent> lst,int indent,BytecodeMappingTracer tracer){
  if (lst == null || lst.isEmpty()) {
    return ""String_Node_Str"";
  }
  String indstr=InterpreterUtil.getIndentString(indent);
  String new_line_separator=DecompilerContext.getNewLineSeparator();
  StringBuilder buf=new StringBuilder();
  for (  Exprent expr : lst) {
    String content=expr.toJava(indent,tracer);
    if (content.length() > 0) {
      if (expr.type != Exprent.EXPRENT_VAR || !((VarExprent)expr).isClassdef()) {
        buf.append(indstr);
      }
      buf.append(content);
      if (expr.type == Exprent.EXPRENT_MONITOR && ((MonitorExprent)expr).getMontype() == MonitorExprent.MONITOR_ENTER) {
        buf.append(""String_Node_Str"");
      }
      if (endsWithSemikolon(expr)) {
        buf.append(""String_Node_Str"");
      }
      buf.append(new_line_separator);
      tracer.incrementSourceLine();
    }
  }
  return buf.toString();
}","public static String listToJava(List<Exprent> lst,int indent,BytecodeMappingTracer tracer){
  if (lst == null || lst.isEmpty()) {
    return ""String_Node_Str"";
  }
  String indstr=InterpreterUtil.getIndentString(indent);
  String new_line_separator=DecompilerContext.getNewLineSeparator();
  StringBuilder buf=new StringBuilder();
  for (  Exprent expr : lst) {
    String content=expr.toJava(indent,tracer);
    if (content.length() > 0) {
      if (expr.type != Exprent.EXPRENT_VAR || !((VarExprent)expr).isClassdef()) {
        buf.append(indstr);
      }
      buf.append(content);
      if (expr.type == Exprent.EXPRENT_MONITOR && ((MonitorExprent)expr).getMontype() == MonitorExprent.MONITOR_ENTER) {
        buf.append(""String_Node_Str"");
      }
      if (endsWithSemikolon(expr)) {
        buf.append(""String_Node_Str"");
      }
      buf.append(new_line_separator);
      tracer.incrementCurrentSourceLine();
    }
  }
  return buf.toString();
}"
54650,"public static String jmpWrapper(Statement stat,int indent,boolean semicolon,BytecodeMappingTracer tracer){
  StringBuilder buf=new StringBuilder(stat.toJava(indent,tracer));
  String new_line_separator=DecompilerContext.getNewLineSeparator();
  List<StatEdge> lstSuccs=stat.getSuccessorEdges(Statement.STATEDGE_DIRECT_ALL);
  if (lstSuccs.size() == 1) {
    StatEdge edge=lstSuccs.get(0);
    if (edge.getType() != StatEdge.TYPE_REGULAR && edge.explicit && edge.getDestination().type != Statement.TYPE_DUMMYEXIT) {
      buf.append(InterpreterUtil.getIndentString(indent));
switch (edge.getType()) {
case StatEdge.TYPE_BREAK:
        buf.append(""String_Node_Str"");
      break;
case StatEdge.TYPE_CONTINUE:
    buf.append(""String_Node_Str"");
}
if (edge.labeled) {
  buf.append(""String_Node_Str"").append(edge.closure.id);
}
buf.append(""String_Node_Str"").append(new_line_separator);
tracer.incrementSourceLine();
}
}
if (buf.length() == 0 && semicolon) {
buf.append(InterpreterUtil.getIndentString(indent)).append(""String_Node_Str"").append(new_line_separator);
tracer.incrementSourceLine();
}
return buf.toString();
}","public static String jmpWrapper(Statement stat,int indent,boolean semicolon,BytecodeMappingTracer tracer){
  StringBuilder buf=new StringBuilder(stat.toJava(indent,tracer));
  String new_line_separator=DecompilerContext.getNewLineSeparator();
  List<StatEdge> lstSuccs=stat.getSuccessorEdges(Statement.STATEDGE_DIRECT_ALL);
  if (lstSuccs.size() == 1) {
    StatEdge edge=lstSuccs.get(0);
    if (edge.getType() != StatEdge.TYPE_REGULAR && edge.explicit && edge.getDestination().type != Statement.TYPE_DUMMYEXIT) {
      buf.append(InterpreterUtil.getIndentString(indent));
switch (edge.getType()) {
case StatEdge.TYPE_BREAK:
        buf.append(""String_Node_Str"");
      break;
case StatEdge.TYPE_CONTINUE:
    buf.append(""String_Node_Str"");
}
if (edge.labeled) {
  buf.append(""String_Node_Str"").append(edge.closure.id);
}
buf.append(""String_Node_Str"").append(new_line_separator);
tracer.incrementCurrentSourceLine();
}
}
if (buf.length() == 0 && semicolon) {
buf.append(InterpreterUtil.getIndentString(indent)).append(""String_Node_Str"").append(new_line_separator);
tracer.incrementCurrentSourceLine();
}
return buf.toString();
}"
54651,"public String toJava(int indent,BytecodeMappingTracer tracer){
  String indstr=InterpreterUtil.getIndentString(indent);
  String indstr1=null;
  String new_line_separator=DecompilerContext.getNewLineSeparator();
  StringBuilder buf=new StringBuilder();
  buf.append(ExprProcessor.listToJava(varDefinitions,indent,tracer));
  boolean labeled=isLabeled();
  if (labeled) {
    buf.append(indstr).append(""String_Node_Str"").append(this.id).append(""String_Node_Str"").append(new_line_separator);
    tracer.incrementSourceLine();
  }
  List<StatEdge> lstSuccs=first.getSuccessorEdges(STATEDGE_DIRECT_ALL);
  if (first.type == TYPE_TRYCATCH && first.varDefinitions.isEmpty() && isFinally && !labeled && !first.isLabeled() && (lstSuccs.isEmpty() || !lstSuccs.get(0).explicit)) {
    String content=ExprProcessor.jmpWrapper(first,indent,true,tracer);
    content=content.substring(0,content.length() - new_line_separator.length());
    buf.append(content);
  }
 else {
    buf.append(indstr).append(""String_Node_Str"").append(new_line_separator);
    tracer.incrementSourceLine();
    buf.append(ExprProcessor.jmpWrapper(first,indent + 1,true,tracer));
    buf.append(indstr).append(""String_Node_Str"");
  }
  buf.append(isFinally ? ""String_Node_Str"" : ""String_Node_Str"" + vars.get(0).toJava(indent,tracer) + ""String_Node_Str"").append(""String_Node_Str"").append(new_line_separator);
  tracer.incrementSourceLine();
  if (monitor != null) {
    indstr1=InterpreterUtil.getIndentString(indent + 1);
    buf.append(indstr1).append(""String_Node_Str"").append(monitor.toJava(indent,tracer)).append(""String_Node_Str"").append(new_line_separator);
    tracer.incrementSourceLine();
  }
  buf.append(ExprProcessor.jmpWrapper(handler,indent + 1 + (monitor != null ? 1 : 0),true,tracer));
  if (monitor != null) {
    buf.append(indstr1).append(""String_Node_Str"").append(new_line_separator);
    tracer.incrementSourceLine();
  }
  buf.append(indstr).append(""String_Node_Str"").append(new_line_separator);
  tracer.incrementSourceLine();
  return buf.toString();
}","public String toJava(int indent,BytecodeMappingTracer tracer){
  String indstr=InterpreterUtil.getIndentString(indent);
  String indstr1=null;
  String new_line_separator=DecompilerContext.getNewLineSeparator();
  StringBuilder buf=new StringBuilder();
  buf.append(ExprProcessor.listToJava(varDefinitions,indent,tracer));
  boolean labeled=isLabeled();
  if (labeled) {
    buf.append(indstr).append(""String_Node_Str"").append(this.id).append(""String_Node_Str"").append(new_line_separator);
    tracer.incrementCurrentSourceLine();
  }
  List<StatEdge> lstSuccs=first.getSuccessorEdges(STATEDGE_DIRECT_ALL);
  if (first.type == TYPE_TRYCATCH && first.varDefinitions.isEmpty() && isFinally && !labeled && !first.isLabeled() && (lstSuccs.isEmpty() || !lstSuccs.get(0).explicit)) {
    String content=ExprProcessor.jmpWrapper(first,indent,true,tracer);
    content=content.substring(0,content.length() - new_line_separator.length());
    buf.append(content);
  }
 else {
    buf.append(indstr).append(""String_Node_Str"").append(new_line_separator);
    tracer.incrementCurrentSourceLine();
    buf.append(ExprProcessor.jmpWrapper(first,indent + 1,true,tracer));
    buf.append(indstr).append(""String_Node_Str"");
  }
  buf.append(isFinally ? ""String_Node_Str"" : ""String_Node_Str"" + vars.get(0).toJava(indent,tracer) + ""String_Node_Str"").append(""String_Node_Str"").append(new_line_separator);
  tracer.incrementCurrentSourceLine();
  if (monitor != null) {
    indstr1=InterpreterUtil.getIndentString(indent + 1);
    buf.append(indstr1).append(""String_Node_Str"").append(monitor.toJava(indent,tracer)).append(""String_Node_Str"").append(new_line_separator);
    tracer.incrementCurrentSourceLine();
  }
  buf.append(ExprProcessor.jmpWrapper(handler,indent + 1 + (monitor != null ? 1 : 0),true,tracer));
  if (monitor != null) {
    buf.append(indstr1).append(""String_Node_Str"").append(new_line_separator);
    tracer.incrementCurrentSourceLine();
  }
  buf.append(indstr).append(""String_Node_Str"").append(new_line_separator);
  tracer.incrementCurrentSourceLine();
  return buf.toString();
}"
54652,"public String toJava(int indent,BytecodeMappingTracer tracer){
  String indstr=InterpreterUtil.getIndentString(indent);
  StringBuilder buf=new StringBuilder();
  String new_line_separator=DecompilerContext.getNewLineSeparator();
  buf.append(ExprProcessor.listToJava(varDefinitions,indent,tracer));
  if (isLabeled()) {
    buf.append(indstr).append(""String_Node_Str"").append(this.id).append(""String_Node_Str"").append(new_line_separator);
    tracer.incrementSourceLine();
  }
  buf.append(indstr).append(""String_Node_Str"").append(new_line_separator);
  tracer.incrementSourceLine();
  buf.append(ExprProcessor.jmpWrapper(first,indent + 1,true,tracer));
  buf.append(indstr).append(""String_Node_Str"");
  for (int i=1; i < stats.size(); i++) {
    List<String> exception_types=exctstrings.get(i - 1);
    buf.append(""String_Node_Str"");
    if (exception_types.size() > 1) {
      for (int exc_index=1; exc_index < exception_types.size(); ++exc_index) {
        VarType exc_type=new VarType(CodeConstants.TYPE_OBJECT,0,exception_types.get(exc_index));
        String exc_type_name=ExprProcessor.getCastTypeName(exc_type);
        buf.append(exc_type_name).append(""String_Node_Str"");
      }
    }
    buf.append(vars.get(i - 1).toJava(indent,tracer));
    buf.append(""String_Node_Str"").append(new_line_separator);
    tracer.incrementSourceLine();
    buf.append(ExprProcessor.jmpWrapper(stats.get(i),indent + 1,true,tracer)).append(indstr).append(""String_Node_Str"");
    tracer.incrementSourceLine();
  }
  buf.append(new_line_separator);
  tracer.incrementSourceLine();
  return buf.toString();
}","public String toJava(int indent,BytecodeMappingTracer tracer){
  String indstr=InterpreterUtil.getIndentString(indent);
  StringBuilder buf=new StringBuilder();
  String new_line_separator=DecompilerContext.getNewLineSeparator();
  buf.append(ExprProcessor.listToJava(varDefinitions,indent,tracer));
  if (isLabeled()) {
    buf.append(indstr).append(""String_Node_Str"").append(this.id).append(""String_Node_Str"").append(new_line_separator);
    tracer.incrementCurrentSourceLine();
  }
  buf.append(indstr).append(""String_Node_Str"").append(new_line_separator);
  tracer.incrementCurrentSourceLine();
  buf.append(ExprProcessor.jmpWrapper(first,indent + 1,true,tracer));
  buf.append(indstr).append(""String_Node_Str"");
  for (int i=1; i < stats.size(); i++) {
    List<String> exception_types=exctstrings.get(i - 1);
    buf.append(""String_Node_Str"");
    if (exception_types.size() > 1) {
      for (int exc_index=1; exc_index < exception_types.size(); ++exc_index) {
        VarType exc_type=new VarType(CodeConstants.TYPE_OBJECT,0,exception_types.get(exc_index));
        String exc_type_name=ExprProcessor.getCastTypeName(exc_type);
        buf.append(exc_type_name).append(""String_Node_Str"");
      }
    }
    buf.append(vars.get(i - 1).toJava(indent,tracer));
    buf.append(""String_Node_Str"").append(new_line_separator);
    tracer.incrementCurrentSourceLine();
    buf.append(ExprProcessor.jmpWrapper(stats.get(i),indent + 1,true,tracer)).append(indstr).append(""String_Node_Str"");
    tracer.incrementCurrentSourceLine();
  }
  buf.append(new_line_separator);
  tracer.incrementCurrentSourceLine();
  return buf.toString();
}"
54653,"public String toJava(int indent,BytecodeMappingTracer tracer){
  String indstr=InterpreterUtil.getIndentString(indent);
  StringBuilder buf=new StringBuilder();
  String new_line_separator=DecompilerContext.getNewLineSeparator();
  buf.append(ExprProcessor.listToJava(varDefinitions,indent,tracer));
  if (isLabeled()) {
    buf.append(indstr).append(""String_Node_Str"").append(this.id).append(""String_Node_Str"").append(new_line_separator);
    tracer.incrementSourceLine();
  }
switch (looptype) {
case LOOP_DO:
    buf.append(indstr).append(""String_Node_Str"").append(new_line_separator);
  tracer.incrementSourceLine();
buf.append(ExprProcessor.jmpWrapper(first,indent + 1,true,tracer));
buf.append(indstr).append(""String_Node_Str"").append(new_line_separator);
tracer.incrementSourceLine();
break;
case LOOP_DOWHILE:
buf.append(indstr).append(""String_Node_Str"").append(new_line_separator);
tracer.incrementSourceLine();
buf.append(ExprProcessor.jmpWrapper(first,indent + 1,true,tracer));
buf.append(indstr).append(""String_Node_Str"").append(conditionExprent.get(0).toJava(indent,tracer)).append(""String_Node_Str"").append(new_line_separator);
tracer.incrementSourceLine();
break;
case LOOP_WHILE:
buf.append(indstr).append(""String_Node_Str"").append(conditionExprent.get(0).toJava(indent,tracer)).append(""String_Node_Str"").append(new_line_separator);
tracer.incrementSourceLine();
buf.append(ExprProcessor.jmpWrapper(first,indent + 1,true,tracer));
buf.append(indstr).append(""String_Node_Str"").append(new_line_separator);
tracer.incrementSourceLine();
break;
case LOOP_FOR:
buf.append(indstr).append(""String_Node_Str"").append(initExprent.get(0) == null ? ""String_Node_Str"" : initExprent.get(0).toJava(indent,tracer)).append(""String_Node_Str"").append(conditionExprent.get(0).toJava(indent,tracer)).append(""String_Node_Str"").append(incExprent.get(0).toJava(indent,tracer)).append(""String_Node_Str"").append(new_line_separator);
tracer.incrementSourceLine();
buf.append(ExprProcessor.jmpWrapper(first,indent + 1,true,tracer));
buf.append(indstr).append(""String_Node_Str"").append(new_line_separator);
tracer.incrementSourceLine();
}
return buf.toString();
}","public String toJava(int indent,BytecodeMappingTracer tracer){
  String indstr=InterpreterUtil.getIndentString(indent);
  StringBuilder buf=new StringBuilder();
  String new_line_separator=DecompilerContext.getNewLineSeparator();
  buf.append(ExprProcessor.listToJava(varDefinitions,indent,tracer));
  if (isLabeled()) {
    buf.append(indstr).append(""String_Node_Str"").append(this.id).append(""String_Node_Str"").append(new_line_separator);
    tracer.incrementCurrentSourceLine();
  }
switch (looptype) {
case LOOP_DO:
    buf.append(indstr).append(""String_Node_Str"").append(new_line_separator);
  tracer.incrementCurrentSourceLine();
buf.append(ExprProcessor.jmpWrapper(first,indent + 1,true,tracer));
buf.append(indstr).append(""String_Node_Str"").append(new_line_separator);
tracer.incrementCurrentSourceLine();
break;
case LOOP_DOWHILE:
buf.append(indstr).append(""String_Node_Str"").append(new_line_separator);
tracer.incrementCurrentSourceLine();
buf.append(ExprProcessor.jmpWrapper(first,indent + 1,true,tracer));
buf.append(indstr).append(""String_Node_Str"").append(conditionExprent.get(0).toJava(indent,tracer)).append(""String_Node_Str"").append(new_line_separator);
tracer.incrementCurrentSourceLine();
break;
case LOOP_WHILE:
buf.append(indstr).append(""String_Node_Str"").append(conditionExprent.get(0).toJava(indent,tracer)).append(""String_Node_Str"").append(new_line_separator);
tracer.incrementCurrentSourceLine();
buf.append(ExprProcessor.jmpWrapper(first,indent + 1,true,tracer));
buf.append(indstr).append(""String_Node_Str"").append(new_line_separator);
tracer.incrementCurrentSourceLine();
break;
case LOOP_FOR:
buf.append(indstr).append(""String_Node_Str"").append(initExprent.get(0) == null ? ""String_Node_Str"" : initExprent.get(0).toJava(indent,tracer)).append(""String_Node_Str"").append(conditionExprent.get(0).toJava(indent,tracer)).append(""String_Node_Str"").append(incExprent.get(0).toJava(indent,tracer)).append(""String_Node_Str"").append(new_line_separator);
tracer.incrementCurrentSourceLine();
buf.append(ExprProcessor.jmpWrapper(first,indent + 1,true,tracer));
buf.append(indstr).append(""String_Node_Str"").append(new_line_separator);
tracer.incrementCurrentSourceLine();
}
return buf.toString();
}"
54654,"public String toJava(int indent,BytecodeMappingTracer tracer){
  String indstr=InterpreterUtil.getIndentString(indent);
  StringBuilder buf=new StringBuilder();
  String new_line_separator=DecompilerContext.getNewLineSeparator();
  buf.append(ExprProcessor.listToJava(varDefinitions,indent,tracer));
  buf.append(first.toJava(indent,tracer));
  if (isLabeled()) {
    buf.append(indstr).append(""String_Node_Str"").append(this.id).append(""String_Node_Str"").append(new_line_separator);
    tracer.incrementSourceLine();
  }
  buf.append(indstr).append(headexprent.get(0).toJava(indent,tracer)).append(""String_Node_Str"").append(new_line_separator);
  tracer.incrementSourceLine();
  if (ifstat == null) {
    buf.append(InterpreterUtil.getIndentString(indent + 1));
    if (ifedge.explicit) {
      if (ifedge.getType() == StatEdge.TYPE_BREAK) {
        buf.append(""String_Node_Str"");
      }
 else {
        buf.append(""String_Node_Str"");
      }
      if (ifedge.labeled) {
        buf.append(""String_Node_Str"").append(ifedge.closure.id);
      }
    }
    buf.append(""String_Node_Str"").append(new_line_separator);
    tracer.incrementSourceLine();
  }
 else {
    buf.append(ExprProcessor.jmpWrapper(ifstat,indent + 1,true,tracer));
  }
  boolean elseif=false;
  if (elsestat != null) {
    if (elsestat.type == Statement.TYPE_IF && elsestat.varDefinitions.isEmpty() && elsestat.getFirst().getExprents().isEmpty() && !elsestat.isLabeled() && (elsestat.getSuccessorEdges(STATEDGE_DIRECT_ALL).isEmpty() || !elsestat.getSuccessorEdges(STATEDGE_DIRECT_ALL).get(0).explicit)) {
      String content=ExprProcessor.jmpWrapper(elsestat,indent,false,tracer);
      content=content.substring(indstr.length());
      buf.append(indstr).append(""String_Node_Str"");
      buf.append(content);
      elseif=true;
    }
 else {
      String content=ExprProcessor.jmpWrapper(elsestat,indent + 1,false,tracer);
      if (content.length() > 0) {
        buf.append(indstr).append(""String_Node_Str"").append(new_line_separator);
        tracer.incrementSourceLine();
        buf.append(content);
      }
    }
  }
  if (!elseif) {
    buf.append(indstr).append(""String_Node_Str"").append(new_line_separator);
    tracer.incrementSourceLine();
  }
  return buf.toString();
}","public String toJava(int indent,BytecodeMappingTracer tracer){
  String indstr=InterpreterUtil.getIndentString(indent);
  StringBuilder buf=new StringBuilder();
  String new_line_separator=DecompilerContext.getNewLineSeparator();
  buf.append(ExprProcessor.listToJava(varDefinitions,indent,tracer));
  buf.append(first.toJava(indent,tracer));
  if (isLabeled()) {
    buf.append(indstr).append(""String_Node_Str"").append(this.id).append(""String_Node_Str"").append(new_line_separator);
    tracer.incrementCurrentSourceLine();
  }
  buf.append(indstr).append(headexprent.get(0).toJava(indent,tracer)).append(""String_Node_Str"").append(new_line_separator);
  tracer.incrementCurrentSourceLine();
  if (ifstat == null) {
    buf.append(InterpreterUtil.getIndentString(indent + 1));
    if (ifedge.explicit) {
      if (ifedge.getType() == StatEdge.TYPE_BREAK) {
        buf.append(""String_Node_Str"");
      }
 else {
        buf.append(""String_Node_Str"");
      }
      if (ifedge.labeled) {
        buf.append(""String_Node_Str"").append(ifedge.closure.id);
      }
    }
    buf.append(""String_Node_Str"").append(new_line_separator);
    tracer.incrementCurrentSourceLine();
  }
 else {
    buf.append(ExprProcessor.jmpWrapper(ifstat,indent + 1,true,tracer));
  }
  boolean elseif=false;
  if (elsestat != null) {
    if (elsestat.type == Statement.TYPE_IF && elsestat.varDefinitions.isEmpty() && elsestat.getFirst().getExprents().isEmpty() && !elsestat.isLabeled() && (elsestat.getSuccessorEdges(STATEDGE_DIRECT_ALL).isEmpty() || !elsestat.getSuccessorEdges(STATEDGE_DIRECT_ALL).get(0).explicit)) {
      String content=ExprProcessor.jmpWrapper(elsestat,indent,false,tracer);
      content=content.substring(indstr.length());
      buf.append(indstr).append(""String_Node_Str"");
      buf.append(content);
      elseif=true;
    }
 else {
      BytecodeMappingTracer else_tracer=new BytecodeMappingTracer(tracer.getCurrentSourceLine());
      String content=ExprProcessor.jmpWrapper(elsestat,indent + 1,false,else_tracer);
      if (content.length() > 0) {
        buf.append(indstr).append(""String_Node_Str"").append(new_line_separator);
        else_tracer.shiftSourceLines(1);
        tracer.setCurrentSourceLine(else_tracer.getCurrentSourceLine() + 1);
        tracer.addTracer(else_tracer);
        buf.append(content);
      }
    }
  }
  if (!elseif) {
    buf.append(indstr).append(""String_Node_Str"").append(new_line_separator);
    tracer.incrementCurrentSourceLine();
  }
  return buf.toString();
}"
54655,"public String toJava(int indent,BytecodeMappingTracer tracer){
  StringBuilder buf=new StringBuilder();
  String indstr=null;
  boolean islabeled=isLabeled();
  String new_line_separator=DecompilerContext.getNewLineSeparator();
  buf.append(ExprProcessor.listToJava(varDefinitions,indent,tracer));
  if (islabeled) {
    indstr=InterpreterUtil.getIndentString(indent);
    indent++;
    buf.append(indstr).append(""String_Node_Str"").append(this.id).append(""String_Node_Str"").append(new_line_separator);
    tracer.incrementSourceLine();
  }
  boolean notempty=false;
  for (int i=0; i < stats.size(); i++) {
    Statement st=stats.get(i);
    if (i > 0 && notempty) {
      buf.append(new_line_separator);
      tracer.incrementSourceLine();
    }
    String str=ExprProcessor.jmpWrapper(st,indent,false,tracer);
    buf.append(str);
    notempty=(str.trim().length() > 0);
  }
  if (islabeled) {
    buf.append(indstr).append(""String_Node_Str"").append(new_line_separator);
    tracer.incrementSourceLine();
  }
  return buf.toString();
}","public String toJava(int indent,BytecodeMappingTracer tracer){
  StringBuilder buf=new StringBuilder();
  String indstr=null;
  boolean islabeled=isLabeled();
  String new_line_separator=DecompilerContext.getNewLineSeparator();
  buf.append(ExprProcessor.listToJava(varDefinitions,indent,tracer));
  if (islabeled) {
    indstr=InterpreterUtil.getIndentString(indent);
    indent++;
    buf.append(indstr).append(""String_Node_Str"").append(this.id).append(""String_Node_Str"").append(new_line_separator);
    tracer.incrementCurrentSourceLine();
  }
  boolean notempty=false;
  for (int i=0; i < stats.size(); i++) {
    Statement st=stats.get(i);
    if (i > 0 && notempty) {
      buf.append(new_line_separator);
      tracer.incrementCurrentSourceLine();
    }
    String str=ExprProcessor.jmpWrapper(st,indent,false,tracer);
    buf.append(str);
    notempty=(str.trim().length() > 0);
  }
  if (islabeled) {
    buf.append(indstr).append(""String_Node_Str"").append(new_line_separator);
    tracer.incrementCurrentSourceLine();
  }
  return buf.toString();
}"
54656,"public String toJava(int indent){
  if (functype <= FUNCTION_USHR) {
    return wrapOperandString(lstOperands.get(0),false,indent) + operators[functype] + wrapOperandString(lstOperands.get(1),true,indent);
  }
  if (functype >= FUNCTION_EQ) {
    return wrapOperandString(lstOperands.get(0),false,indent) + operators[functype - FUNCTION_EQ + 11] + wrapOperandString(lstOperands.get(1),true,indent);
  }
switch (functype) {
case FUNCTION_BITNOT:
    return ""String_Node_Str"" + wrapOperandString(lstOperands.get(0),true,indent);
case FUNCTION_BOOLNOT:
  return ""String_Node_Str"" + wrapOperandString(lstOperands.get(0),true,indent);
case FUNCTION_NEG:
return ""String_Node_Str"" + wrapOperandString(lstOperands.get(0),true,indent);
case FUNCTION_CAST:
return ""String_Node_Str"" + lstOperands.get(1).toJava(indent) + ""String_Node_Str""+ wrapOperandString(lstOperands.get(0),true,indent);
case FUNCTION_ARRAYLENGTH:
Exprent arr=lstOperands.get(0);
String res=wrapOperandString(arr,false,indent);
if (arr.getExprType().arraydim == 0) {
VarType objarr=VarType.VARTYPE_OBJECT.copy();
objarr.arraydim=1;
res=""String_Node_Str"" + ExprProcessor.getCastTypeName(objarr) + ""String_Node_Str""+ res+ ""String_Node_Str"";
}
return res + ""String_Node_Str"";
case FUNCTION_IIF:
return wrapOperandString(lstOperands.get(0),true,indent) + ""String_Node_Str"" + wrapOperandString(lstOperands.get(1),true,indent)+ ""String_Node_Str""+ wrapOperandString(lstOperands.get(2),true,indent);
case FUNCTION_IPP:
return wrapOperandString(lstOperands.get(0),true,indent) + ""String_Node_Str"";
case FUNCTION_PPI:
return ""String_Node_Str"" + wrapOperandString(lstOperands.get(0),true,indent);
case FUNCTION_IMM:
return wrapOperandString(lstOperands.get(0),true,indent) + ""String_Node_Str"";
case FUNCTION_MMI:
return ""String_Node_Str"" + wrapOperandString(lstOperands.get(0),true,indent);
case FUNCTION_INSTANCEOF:
return wrapOperandString(lstOperands.get(0),true,indent) + ""String_Node_Str"" + wrapOperandString(lstOperands.get(1),true,indent);
}
if (functype <= FUNCTION_I2S) {
return ""String_Node_Str"" + ExprProcessor.getTypeName(types[functype - FUNCTION_I2L]) + ""String_Node_Str""+ wrapOperandString(lstOperands.get(0),true,indent);
}
throw new RuntimeException(""String_Node_Str"");
}","public String toJava(int indent){
  if (functype <= FUNCTION_USHR) {
    return wrapOperandString(lstOperands.get(0),false,indent) + operators[functype] + wrapOperandString(lstOperands.get(1),true,indent);
  }
  if (functype >= FUNCTION_EQ) {
    return wrapOperandString(lstOperands.get(0),false,indent) + operators[functype - FUNCTION_EQ + 11] + wrapOperandString(lstOperands.get(1),true,indent);
  }
switch (functype) {
case FUNCTION_BITNOT:
    return ""String_Node_Str"" + wrapOperandString(lstOperands.get(0),true,indent);
case FUNCTION_BOOLNOT:
  return ""String_Node_Str"" + wrapOperandString(lstOperands.get(0),true,indent);
case FUNCTION_NEG:
return ""String_Node_Str"" + wrapOperandString(lstOperands.get(0),true,indent);
case FUNCTION_CAST:
return ""String_Node_Str"" + lstOperands.get(1).toJava(indent) + ""String_Node_Str""+ wrapOperandString(lstOperands.get(0),true,indent);
case FUNCTION_ARRAYLENGTH:
Exprent arr=lstOperands.get(0);
String res=wrapOperandString(arr,false,indent);
if (arr.getExprType().arraydim == 0) {
VarType objarr=VarType.VARTYPE_OBJECT.copy();
objarr.arraydim=1;
res=""String_Node_Str"" + ExprProcessor.getCastTypeName(objarr) + ""String_Node_Str""+ res+ ""String_Node_Str"";
}
return res + ""String_Node_Str"";
case FUNCTION_IIF:
return wrapOperandString(lstOperands.get(0),true,indent) + ""String_Node_Str"" + wrapOperandString(lstOperands.get(1),true,indent)+ ""String_Node_Str""+ wrapOperandString(lstOperands.get(2),true,indent);
case FUNCTION_IPP:
return wrapOperandString(lstOperands.get(0),true,indent) + ""String_Node_Str"";
case FUNCTION_PPI:
return ""String_Node_Str"" + wrapOperandString(lstOperands.get(0),true,indent);
case FUNCTION_IMM:
return wrapOperandString(lstOperands.get(0),true,indent) + ""String_Node_Str"";
case FUNCTION_MMI:
return ""String_Node_Str"" + wrapOperandString(lstOperands.get(0),true,indent);
case FUNCTION_INSTANCEOF:
return wrapOperandString(lstOperands.get(0),true,indent) + ""String_Node_Str"" + wrapOperandString(lstOperands.get(1),true,indent);
case FUNCTION_LCMP:
return ""String_Node_Str"" + wrapOperandString(lstOperands.get(0),true,indent) + ""String_Node_Str""+ wrapOperandString(lstOperands.get(1),true,indent)+ ""String_Node_Str"";
case FUNCTION_FCMPL:
return ""String_Node_Str"" + wrapOperandString(lstOperands.get(0),true,indent) + ""String_Node_Str""+ wrapOperandString(lstOperands.get(1),true,indent)+ ""String_Node_Str"";
case FUNCTION_FCMPG:
return ""String_Node_Str"" + wrapOperandString(lstOperands.get(0),true,indent) + ""String_Node_Str""+ wrapOperandString(lstOperands.get(1),true,indent)+ ""String_Node_Str"";
case FUNCTION_DCMPL:
return ""String_Node_Str"" + wrapOperandString(lstOperands.get(0),true,indent) + ""String_Node_Str""+ wrapOperandString(lstOperands.get(1),true,indent)+ ""String_Node_Str"";
case FUNCTION_DCMPG:
return ""String_Node_Str"" + wrapOperandString(lstOperands.get(0),true,indent) + ""String_Node_Str""+ wrapOperandString(lstOperands.get(1),true,indent)+ ""String_Node_Str"";
}
if (functype <= FUNCTION_I2S) {
return ""String_Node_Str"" + ExprProcessor.getTypeName(types[functype - FUNCTION_I2L]) + ""String_Node_Str""+ wrapOperandString(lstOperands.get(0),true,indent);
}
throw new RuntimeException(""String_Node_Str"");
}"
54657,"private void ssaStatements(DirectGraph dgraph,HashSet<String> updated,boolean calcLiveVars){
  for (  DirectNode node : dgraph.nodes) {
    updated.remove(node.id);
    mergeInVarMaps(node,dgraph);
    SFormsFastMapDirect varmap=new SFormsFastMapDirect(inVarVersions.get(node.id));
    SFormsFastMapDirect[] varmaparr=new SFormsFastMapDirect[]{varmap,null};
    if (node.exprents != null) {
      for (      Exprent expr : node.exprents) {
        processExprent(expr,varmaparr,node.statement,calcLiveVars);
      }
    }
    if (varmaparr[1] == null) {
      varmaparr[1]=varmaparr[0];
    }
    boolean this_updated=!mapsEqual(varmaparr[0],outVarVersions.get(node.id)) || (outNegVarVersions.containsKey(node.id) && !mapsEqual(varmaparr[1],outNegVarVersions.get(node.id)));
    if (this_updated) {
      outVarVersions.put(node.id,varmaparr[0]);
      if (dgraph.mapNegIfBranch.containsKey(node.id)) {
        outNegVarVersions.put(node.id,varmaparr[1]);
      }
      for (      DirectNode nd : node.succs) {
        updated.add(nd.id);
      }
    }
  }
}","private void ssaStatements(DirectGraph dgraph,HashSet<String> updated,boolean calcLiveVars){
  for (  DirectNode node : dgraph.nodes) {
    updated.remove(node.id);
    mergeInVarMaps(node,dgraph);
    SFormsFastMapDirect varmap=new SFormsFastMapDirect(inVarVersions.get(node.id));
    SFormsFastMapDirect[] varmaparr=new SFormsFastMapDirect[]{varmap,null};
    if (node.exprents != null) {
      for (      Exprent expr : node.exprents) {
        processExprent(expr,varmaparr,node.statement,calcLiveVars);
      }
    }
    if (varmaparr[1] == null) {
      varmaparr[1]=varmaparr[0];
    }
    boolean allow_field_propagation=node.succs.isEmpty() || (node.succs.size() == 1 && node.succs.get(0).preds.size() == 1);
    if (!allow_field_propagation && varmaparr[0] != null) {
      varmaparr[0].removeAllFields();
      varmaparr[1].removeAllFields();
    }
    boolean this_updated=!mapsEqual(varmaparr[0],outVarVersions.get(node.id)) || (outNegVarVersions.containsKey(node.id) && !mapsEqual(varmaparr[1],outNegVarVersions.get(node.id)));
    if (this_updated) {
      outVarVersions.put(node.id,varmaparr[0]);
      if (dgraph.mapNegIfBranch.containsKey(node.id)) {
        outNegVarVersions.put(node.id,varmaparr[1]);
      }
      for (      DirectNode nd : node.succs) {
        updated.add(nd.id);
      }
    }
  }
}"
54658,"public void classLambdaToJava(ClassNode node,BufferedWriter writer,int indent) throws IOException {
  ClassNode node_content=node;
  while (node_content != null && node_content.type == ClassNode.CLASS_LAMBDA) {
    node_content=node_content.parent;
  }
  if (node_content == null) {
    return;
  }
  boolean lambda_to_anonymous=DecompilerContext.getOption(IFernflowerPreferences.LAMBDA_TO_ANONYMOUS_CLASS);
  ClassNode nodeold=(ClassNode)DecompilerContext.getProperty(DecompilerContext.CURRENT_CLASSNODE);
  DecompilerContext.setProperty(DecompilerContext.CURRENT_CLASSNODE,node);
  ClassWrapper wrapper=node_content.wrapper;
  StructClass cl=wrapper.getClassStruct();
  DecompilerContext.getLogger().startWriteClass(node.simpleName);
  if (node.lambda_information.is_method_reference) {
    writer.write(ExprProcessor.getCastTypeName(new VarType(node.lambda_information.content_class_name,false)));
    writer.write(""String_Node_Str"");
    writer.write(node.lambda_information.content_method_name);
    writer.flush();
  }
 else {
    StructMethod mt=cl.getMethod(node.lambda_information.content_method_key);
    MethodWrapper meth=wrapper.getMethodWrapper(mt.getName(),mt.getDescriptor());
    MethodDescriptor md_content=MethodDescriptor.parseDescriptor(node.lambda_information.content_method_descriptor);
    MethodDescriptor md_lambda=MethodDescriptor.parseDescriptor(node.lambda_information.method_descriptor);
    if (!lambda_to_anonymous) {
      StringBuilder buff=new StringBuilder(""String_Node_Str"");
      boolean firstpar=true;
      int index=1;
      int start_index=md_content.params.length - md_lambda.params.length;
      for (int i=0; i < md_content.params.length; i++) {
        if (i >= start_index) {
          if (!firstpar) {
            buff.append(""String_Node_Str"");
          }
          String parname=meth.varproc.getVarName(new VarVersionPaar(index,0));
          buff.append(parname == null ? ""String_Node_Str"" + index : parname);
          firstpar=false;
        }
        index+=md_content.params[i].stack_size;
      }
      buff.append(""String_Node_Str"");
      writer.write(buff.toString());
    }
    StringWriter strwriter=new StringWriter();
    BufferedWriter bufstrwriter=new BufferedWriter(strwriter);
    if (lambda_to_anonymous) {
      methodLambdaToJava(node,node_content,mt,bufstrwriter,indent + 1,false);
    }
 else {
      methodLambdaToJava(node,node_content,mt,bufstrwriter,indent,true);
    }
    bufstrwriter.flush();
    writer.write(""String_Node_Str"");
    writer.write(DecompilerContext.getNewLineSeparator());
    writer.write(strwriter.toString());
    writer.write(InterpreterUtil.getIndentString(indent));
    writer.write(""String_Node_Str"");
    writer.flush();
  }
  DecompilerContext.setProperty(DecompilerContext.CURRENT_CLASSNODE,nodeold);
  DecompilerContext.getLogger().endWriteClass();
}","public void classLambdaToJava(ClassNode node,BufferedWriter writer,Exprent method_object,int indent) throws IOException {
  ClassNode node_content=node;
  while (node_content != null && node_content.type == ClassNode.CLASS_LAMBDA) {
    node_content=node_content.parent;
  }
  if (node_content == null) {
    return;
  }
  boolean lambda_to_anonymous=DecompilerContext.getOption(IFernflowerPreferences.LAMBDA_TO_ANONYMOUS_CLASS);
  ClassNode nodeold=(ClassNode)DecompilerContext.getProperty(DecompilerContext.CURRENT_CLASSNODE);
  DecompilerContext.setProperty(DecompilerContext.CURRENT_CLASSNODE,node);
  ClassWrapper wrapper=node_content.wrapper;
  StructClass cl=wrapper.getClassStruct();
  DecompilerContext.getLogger().startWriteClass(node.simpleName);
  if (node.lambda_information.is_method_reference) {
    if (!node.lambda_information.is_content_method_static && method_object != null) {
      writer.write(method_object.toJava(indent));
    }
 else {
      writer.write(ExprProcessor.getCastTypeName(new VarType(node.lambda_information.content_class_name,false)));
    }
    writer.write(""String_Node_Str"");
    writer.write(node.lambda_information.content_method_name);
    writer.flush();
  }
 else {
    StructMethod mt=cl.getMethod(node.lambda_information.content_method_key);
    MethodWrapper meth=wrapper.getMethodWrapper(mt.getName(),mt.getDescriptor());
    MethodDescriptor md_content=MethodDescriptor.parseDescriptor(node.lambda_information.content_method_descriptor);
    MethodDescriptor md_lambda=MethodDescriptor.parseDescriptor(node.lambda_information.method_descriptor);
    if (!lambda_to_anonymous) {
      StringBuilder buff=new StringBuilder(""String_Node_Str"");
      boolean firstpar=true;
      int index=node.lambda_information.is_content_method_static ? 0 : 1;
      ;
      int start_index=md_content.params.length - md_lambda.params.length;
      for (int i=0; i < md_content.params.length; i++) {
        if (i >= start_index) {
          if (!firstpar) {
            buff.append(""String_Node_Str"");
          }
          String parname=meth.varproc.getVarName(new VarVersionPaar(index,0));
          buff.append(parname == null ? ""String_Node_Str"" + index : parname);
          firstpar=false;
        }
        index+=md_content.params[i].stack_size;
      }
      buff.append(""String_Node_Str"");
      writer.write(buff.toString());
    }
    StringWriter strwriter=new StringWriter();
    BufferedWriter bufstrwriter=new BufferedWriter(strwriter);
    if (lambda_to_anonymous) {
      methodLambdaToJava(node,node_content,mt,bufstrwriter,indent + 1,false);
    }
 else {
      methodLambdaToJava(node,node_content,mt,bufstrwriter,indent,true);
    }
    bufstrwriter.flush();
    writer.write(""String_Node_Str"");
    writer.write(DecompilerContext.getNewLineSeparator());
    writer.write(strwriter.toString());
    writer.write(InterpreterUtil.getIndentString(indent));
    writer.write(""String_Node_Str"");
    writer.flush();
  }
  DecompilerContext.setProperty(DecompilerContext.CURRENT_CLASSNODE,nodeold);
  DecompilerContext.getLogger().endWriteClass();
}"
54659,"public boolean methodLambdaToJava(ClassNode node_lambda,ClassNode node_content,StructMethod mt,BufferedWriter writer,int indent,boolean code_only) throws IOException {
  ClassWrapper wrapper=node_content.wrapper;
  MethodWrapper meth=wrapper.getMethodWrapper(mt.getName(),mt.getDescriptor());
  MethodWrapper methold=(MethodWrapper)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_WRAPPER);
  DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER,meth);
  String indstr=InterpreterUtil.getIndentString(indent);
  String method_name=node_lambda.lambda_information.method_name;
  MethodDescriptor md_content=MethodDescriptor.parseDescriptor(node_lambda.lambda_information.content_method_descriptor);
  MethodDescriptor md_lambda=MethodDescriptor.parseDescriptor(node_lambda.lambda_information.method_descriptor);
  StringWriter strwriter=new StringWriter();
  BufferedWriter bufstrwriter=new BufferedWriter(strwriter);
  if (!code_only) {
    bufstrwriter.write(indstr);
    bufstrwriter.write(""String_Node_Str"");
    bufstrwriter.write(method_name);
    bufstrwriter.write(""String_Node_Str"");
    boolean firstpar=true;
    int index=1;
    int start_index=md_content.params.length - md_lambda.params.length;
    for (int i=0; i < md_content.params.length; i++) {
      if (i >= start_index) {
        if (!firstpar) {
          bufstrwriter.write(""String_Node_Str"");
        }
        VarType partype=md_content.params[i].copy();
        String strpartype=ExprProcessor.getCastTypeName(partype);
        if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(strpartype) && DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {
          strpartype=ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);
        }
        bufstrwriter.write(strpartype);
        bufstrwriter.write(""String_Node_Str"");
        String parname=meth.varproc.getVarName(new VarVersionPaar(index,0));
        bufstrwriter.write(parname == null ? ""String_Node_Str"" + index : parname);
        firstpar=false;
      }
      index+=md_content.params[i].stack_size;
    }
    bufstrwriter.write(""String_Node_Str"");
    bufstrwriter.write(""String_Node_Str"");
    bufstrwriter.write(""String_Node_Str"");
    bufstrwriter.write(DecompilerContext.getNewLineSeparator());
  }
  RootStatement root=wrapper.getMethodWrapper(mt.getName(),mt.getDescriptor()).root;
  if (root != null && !meth.decompiledWithErrors) {
    try {
      String code=root.toJava(indent + 1);
      bufstrwriter.write(code);
    }
 catch (    Throwable ex) {
      DecompilerContext.getLogger().writeMessage(""String_Node_Str"" + mt.getName() + ""String_Node_Str""+ mt.getDescriptor()+ ""String_Node_Str"",ex);
      meth.decompiledWithErrors=true;
    }
  }
  if (meth.decompiledWithErrors) {
    bufstrwriter.write(InterpreterUtil.getIndentString(indent + 1));
    bufstrwriter.write(""String_Node_Str"");
    bufstrwriter.write(DecompilerContext.getNewLineSeparator());
  }
  if (!code_only) {
    bufstrwriter.write(indstr + ""String_Node_Str"");
    bufstrwriter.write(DecompilerContext.getNewLineSeparator());
  }
  bufstrwriter.flush();
  writer.write(strwriter.toString());
  DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER,methold);
  return true;
}","public boolean methodLambdaToJava(ClassNode node_lambda,ClassNode node_content,StructMethod mt,BufferedWriter writer,int indent,boolean code_only) throws IOException {
  ClassWrapper wrapper=node_content.wrapper;
  MethodWrapper meth=wrapper.getMethodWrapper(mt.getName(),mt.getDescriptor());
  MethodWrapper methold=(MethodWrapper)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_WRAPPER);
  DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER,meth);
  String indstr=InterpreterUtil.getIndentString(indent);
  String method_name=node_lambda.lambda_information.method_name;
  MethodDescriptor md_content=MethodDescriptor.parseDescriptor(node_lambda.lambda_information.content_method_descriptor);
  MethodDescriptor md_lambda=MethodDescriptor.parseDescriptor(node_lambda.lambda_information.method_descriptor);
  StringWriter strwriter=new StringWriter();
  BufferedWriter bufstrwriter=new BufferedWriter(strwriter);
  if (!code_only) {
    bufstrwriter.write(indstr);
    bufstrwriter.write(""String_Node_Str"");
    bufstrwriter.write(method_name);
    bufstrwriter.write(""String_Node_Str"");
    boolean firstpar=true;
    int index=node_lambda.lambda_information.is_content_method_static ? 0 : 1;
    ;
    int start_index=md_content.params.length - md_lambda.params.length;
    for (int i=0; i < md_content.params.length; i++) {
      if (i >= start_index) {
        if (!firstpar) {
          bufstrwriter.write(""String_Node_Str"");
        }
        VarType partype=md_content.params[i].copy();
        String strpartype=ExprProcessor.getCastTypeName(partype);
        if (ExprProcessor.UNDEFINED_TYPE_STRING.equals(strpartype) && DecompilerContext.getOption(IFernflowerPreferences.UNDEFINED_PARAM_TYPE_OBJECT)) {
          strpartype=ExprProcessor.getCastTypeName(VarType.VARTYPE_OBJECT);
        }
        bufstrwriter.write(strpartype);
        bufstrwriter.write(""String_Node_Str"");
        String parname=meth.varproc.getVarName(new VarVersionPaar(index,0));
        bufstrwriter.write(parname == null ? ""String_Node_Str"" + index : parname);
        firstpar=false;
      }
      index+=md_content.params[i].stack_size;
    }
    bufstrwriter.write(""String_Node_Str"");
    bufstrwriter.write(""String_Node_Str"");
    bufstrwriter.write(""String_Node_Str"");
    bufstrwriter.write(DecompilerContext.getNewLineSeparator());
  }
  RootStatement root=wrapper.getMethodWrapper(mt.getName(),mt.getDescriptor()).root;
  if (root != null && !meth.decompiledWithErrors) {
    try {
      String code=root.toJava(indent + 1);
      bufstrwriter.write(code);
    }
 catch (    Throwable ex) {
      DecompilerContext.getLogger().writeMessage(""String_Node_Str"" + mt.getName() + ""String_Node_Str""+ mt.getDescriptor()+ ""String_Node_Str"",ex);
      meth.decompiledWithErrors=true;
    }
  }
  if (meth.decompiledWithErrors) {
    bufstrwriter.write(InterpreterUtil.getIndentString(indent + 1));
    bufstrwriter.write(""String_Node_Str"");
    bufstrwriter.write(DecompilerContext.getNewLineSeparator());
  }
  if (!code_only) {
    bufstrwriter.write(indstr + ""String_Node_Str"");
    bufstrwriter.write(DecompilerContext.getNewLineSeparator());
  }
  bufstrwriter.flush();
  writer.write(strwriter.toString());
  DecompilerContext.setProperty(DecompilerContext.CURRENT_METHOD_WRAPPER,methold);
  return true;
}"
54660,"public boolean hasLambda(ClassNode node) throws IOException {
  ClassesProcessor clprocessor=DecompilerContext.getClassprocessor();
  StructClass cl=node.classStruct;
  if (cl.getBytecodeVersion() < CodeConstants.BYTECODE_JAVA_8) {
    return false;
  }
  StructBootstrapMethodsAttribute bootstrap=(StructBootstrapMethodsAttribute)cl.getAttributes().getWithKey(StructGeneralAttribute.ATTRIBUTE_BOOTSTRAP_METHODS);
  if (bootstrap == null || bootstrap.getMethodsNumber() == 0) {
    return false;
  }
  Set<Integer> lambda_methods=new HashSet<Integer>();
  for (int i=0; i < bootstrap.getMethodsNumber(); ++i) {
    LinkConstant method_ref=bootstrap.getMethodReference(i);
    if (JAVAC_LAMBDA_CLASS.equals(method_ref.classname) && JAVAC_LAMBDA_METHOD.equals(method_ref.elementname) && JAVAC_LAMBDA_METHOD_DESCRIPTOR.equals(method_ref.descriptor)) {
      lambda_methods.add(i);
    }
  }
  if (lambda_methods.isEmpty()) {
    return false;
  }
  Map<String,String> mapMethodsLambda=new HashMap<String,String>();
  for (  StructMethod mt : cl.getMethods()) {
    mt.expandData();
    InstructionSequence seq=mt.getInstructionSequence();
    if (seq != null && seq.length() > 0) {
      int len=seq.length();
      for (int i=0; i < len; ++i) {
        Instruction instr=seq.getInstr(i);
        if (instr.opcode == CodeConstants.opc_invokedynamic) {
          LinkConstant invoke_dynamic=cl.getPool().getLinkConstant(instr.getOperand(0));
          if (lambda_methods.contains(invoke_dynamic.index1)) {
            List<PooledConstant> bootstrap_arguments=bootstrap.getMethodArguments(invoke_dynamic.index1);
            MethodDescriptor md=MethodDescriptor.parseDescriptor(invoke_dynamic.descriptor);
            String lambda_class_name=md.ret.value;
            String lambda_method_name=invoke_dynamic.elementname;
            String lambda_method_descriptor=((PrimitiveConstant)bootstrap_arguments.get(2)).getString();
            LinkConstant content_method_handle=(LinkConstant)bootstrap_arguments.get(1);
            ClassNode node_lambda=clprocessor.new ClassNode(content_method_handle.classname,content_method_handle.elementname,content_method_handle.descriptor,lambda_class_name,lambda_method_name,lambda_method_descriptor,cl);
            node_lambda.simpleName=cl.qualifiedName + ""String_Node_Str"" + invoke_dynamic.index1+ ""String_Node_Str""+ invoke_dynamic.index2;
            node_lambda.enclosingMethod=InterpreterUtil.makeUniqueKey(mt.getName(),mt.getDescriptor());
            node.nested.add(node_lambda);
            node_lambda.parent=node;
            clprocessor.getMapRootClasses().put(node_lambda.simpleName,node_lambda);
            mapMethodsLambda.put(node_lambda.lambda_information.content_method_key,node_lambda.simpleName);
          }
        }
      }
    }
    mt.releaseResources();
  }
  for (  ClassNode nd : node.nested) {
    if (nd.type == ClassNode.CLASS_LAMBDA) {
      String parent_class_name=mapMethodsLambda.get(nd.enclosingMethod);
      if (parent_class_name != null) {
        ClassNode parent_class=clprocessor.getMapRootClasses().get(parent_class_name);
        parent_class.nested.add(nd);
        nd.parent=parent_class;
      }
    }
  }
  return false;
}","public boolean hasLambda(ClassNode node) throws IOException {
  ClassesProcessor clprocessor=DecompilerContext.getClassprocessor();
  StructClass cl=node.classStruct;
  if (cl.getBytecodeVersion() < CodeConstants.BYTECODE_JAVA_8) {
    return false;
  }
  StructBootstrapMethodsAttribute bootstrap=(StructBootstrapMethodsAttribute)cl.getAttributes().getWithKey(StructGeneralAttribute.ATTRIBUTE_BOOTSTRAP_METHODS);
  if (bootstrap == null || bootstrap.getMethodsNumber() == 0) {
    return false;
  }
  Set<Integer> lambda_methods=new HashSet<Integer>();
  for (int i=0; i < bootstrap.getMethodsNumber(); ++i) {
    LinkConstant method_ref=bootstrap.getMethodReference(i);
    if (JAVAC_LAMBDA_CLASS.equals(method_ref.classname) && JAVAC_LAMBDA_METHOD.equals(method_ref.elementname) && JAVAC_LAMBDA_METHOD_DESCRIPTOR.equals(method_ref.descriptor)) {
      lambda_methods.add(i);
    }
  }
  if (lambda_methods.isEmpty()) {
    return false;
  }
  Map<String,String> mapMethodsLambda=new HashMap<String,String>();
  for (  StructMethod mt : cl.getMethods()) {
    mt.expandData();
    InstructionSequence seq=mt.getInstructionSequence();
    if (seq != null && seq.length() > 0) {
      int len=seq.length();
      for (int i=0; i < len; ++i) {
        Instruction instr=seq.getInstr(i);
        if (instr.opcode == CodeConstants.opc_invokedynamic) {
          LinkConstant invoke_dynamic=cl.getPool().getLinkConstant(instr.getOperand(0));
          if (lambda_methods.contains(invoke_dynamic.index1)) {
            List<PooledConstant> bootstrap_arguments=bootstrap.getMethodArguments(invoke_dynamic.index1);
            MethodDescriptor md=MethodDescriptor.parseDescriptor(invoke_dynamic.descriptor);
            String lambda_class_name=md.ret.value;
            String lambda_method_name=invoke_dynamic.elementname;
            String lambda_method_descriptor=((PrimitiveConstant)bootstrap_arguments.get(2)).getString();
            LinkConstant content_method_handle=(LinkConstant)bootstrap_arguments.get(1);
            ClassNode node_lambda=clprocessor.new ClassNode(content_method_handle.classname,content_method_handle.elementname,content_method_handle.descriptor,content_method_handle.index1,lambda_class_name,lambda_method_name,lambda_method_descriptor,cl);
            node_lambda.simpleName=cl.qualifiedName + ""String_Node_Str"" + invoke_dynamic.index1+ ""String_Node_Str""+ invoke_dynamic.index2;
            node_lambda.enclosingMethod=InterpreterUtil.makeUniqueKey(mt.getName(),mt.getDescriptor());
            node.nested.add(node_lambda);
            node_lambda.parent=node;
            clprocessor.getMapRootClasses().put(node_lambda.simpleName,node_lambda);
            mapMethodsLambda.put(node_lambda.lambda_information.content_method_key,node_lambda.simpleName);
          }
        }
      }
    }
    mt.releaseResources();
  }
  for (  ClassNode nd : node.nested) {
    if (nd.type == ClassNode.CLASS_LAMBDA) {
      String parent_class_name=mapMethodsLambda.get(nd.enclosingMethod);
      if (parent_class_name != null) {
        ClassNode parent_class=clprocessor.getMapRootClasses().get(parent_class_name);
        parent_class.nested.add(nd);
        nd.parent=parent_class;
      }
    }
  }
  return false;
}"
54661,"public static RootStatement codeToJava(StructMethod mt,VarProcessor varproc) throws IOException {
  StructClass cl=mt.getClassStruct();
  boolean isInitializer=""String_Node_Str"".equals(mt.getName());
  mt.expandData();
  InstructionSequence seq=mt.getInstructionSequence();
  ControlFlowGraph graph=new ControlFlowGraph(seq);
  DeadCodeHelper.removeDeadBlocks(graph);
  graph.inlineJsr(mt);
  DeadCodeHelper.connectDummyExitBlock(graph);
  DeadCodeHelper.removeGotos(graph);
  ExceptionDeobfuscator.removeCircularRanges(graph);
  ExceptionDeobfuscator.restorePopRanges(graph);
  if (DecompilerContext.getOption(IFernflowerPreferences.REMOVE_EMPTY_RANGES)) {
    ExceptionDeobfuscator.removeEmptyRanges(graph);
  }
  if (DecompilerContext.getOption(IFernflowerPreferences.NO_EXCEPTIONS_RETURN)) {
    DeadCodeHelper.incorporateValueReturns(graph);
  }
  ExceptionDeobfuscator.insertEmptyExceptionHandlerBlocks(graph);
  DeadCodeHelper.mergeBasicBlocks(graph);
  DecompilerContext.getCountercontainer().setCounter(CounterContainer.VAR_COUNTER,mt.getLocalVariables());
  if (ExceptionDeobfuscator.hasObfuscatedExceptions(graph)) {
    DecompilerContext.getLogger().writeMessage(""String_Node_Str"",IFernflowerLogger.WARNING);
  }
  RootStatement root=DomHelper.parseGraph(graph);
  if (!DecompilerContext.getOption(IFernflowerPreferences.FINALLY_CATCHALL)) {
    FinallyProcessor fproc=new FinallyProcessor(varproc);
    while (fproc.iterateGraph(mt,root,graph)) {
      root=DomHelper.parseGraph(graph);
    }
  }
  DomHelper.removeSynchronizedHandler(root);
  SequenceHelper.condenseSequences(root);
  ClearStructHelper.clearStatements(root);
  ExprProcessor proc=new ExprProcessor();
  proc.processStatement(root,cl.getPool());
  for (; ; ) {
    StackVarsProcessor stackproc=new StackVarsProcessor();
    stackproc.simplifyStackVars(root,mt,cl);
    varproc.setVarVersions(root);
    if (!new PPandMMHelper().findPPandMM(root)) {
      break;
    }
  }
  for (; ; ) {
    LabelHelper.cleanUpEdges(root);
    for (; ; ) {
      MergeHelper.enhanceLoops(root);
      if (LoopExtractHelper.extractLoops(root)) {
        continue;
      }
      if (!IfHelper.mergeAllIfs(root)) {
        break;
      }
    }
    if (DecompilerContext.getOption(IFernflowerPreferences.IDEA_NOT_NULL_ANNOTATION)) {
      if (IdeaNotNullHelper.removeHardcodedChecks(root,mt)) {
        SequenceHelper.condenseSequences(root);
        StackVarsProcessor stackproc=new StackVarsProcessor();
        stackproc.simplifyStackVars(root,mt,cl);
        varproc.setVarVersions(root);
      }
    }
    LabelHelper.identifyLabels(root);
    if (InlineSingleBlockHelper.inlineSingleBlocks(root)) {
      continue;
    }
    if (isInitializer || !ExitHelper.condenseExits(root)) {
      break;
    }
  }
  ExitHelper.removeRedundantReturns(root);
  SecondaryFunctionsHelper.identifySecondaryFunctions(root);
  varproc.setVarDefinitions(root);
  LabelHelper.replaceContinueWithBreak(root);
  mt.releaseResources();
  return root;
}","public static RootStatement codeToJava(StructMethod mt,VarProcessor varproc) throws IOException {
  StructClass cl=mt.getClassStruct();
  boolean isInitializer=""String_Node_Str"".equals(mt.getName());
  mt.expandData();
  InstructionSequence seq=mt.getInstructionSequence();
  ControlFlowGraph graph=new ControlFlowGraph(seq);
  DeadCodeHelper.removeDeadBlocks(graph);
  graph.inlineJsr(mt);
  DeadCodeHelper.connectDummyExitBlock(graph);
  DeadCodeHelper.removeGotos(graph);
  ExceptionDeobfuscator.removeCircularRanges(graph);
  ExceptionDeobfuscator.restorePopRanges(graph);
  if (DecompilerContext.getOption(IFernflowerPreferences.REMOVE_EMPTY_RANGES)) {
    ExceptionDeobfuscator.removeEmptyRanges(graph);
  }
  if (DecompilerContext.getOption(IFernflowerPreferences.NO_EXCEPTIONS_RETURN)) {
    DeadCodeHelper.incorporateValueReturns(graph);
  }
  ExceptionDeobfuscator.insertEmptyExceptionHandlerBlocks(graph);
  DeadCodeHelper.mergeBasicBlocks(graph);
  DecompilerContext.getCountercontainer().setCounter(CounterContainer.VAR_COUNTER,mt.getLocalVariables());
  if (ExceptionDeobfuscator.hasObfuscatedExceptions(graph)) {
    DecompilerContext.getLogger().writeMessage(""String_Node_Str"",IFernflowerLogger.WARNING);
  }
  RootStatement root=DomHelper.parseGraph(graph);
  if (!DecompilerContext.getOption(IFernflowerPreferences.FINALLY_CATCHALL)) {
    FinallyProcessor fproc=new FinallyProcessor(varproc);
    while (fproc.iterateGraph(mt,root,graph)) {
      root=DomHelper.parseGraph(graph);
    }
  }
  DomHelper.removeSynchronizedHandler(root);
  SequenceHelper.condenseSequences(root);
  ClearStructHelper.clearStatements(root);
  ExprProcessor proc=new ExprProcessor();
  proc.processStatement(root,cl);
  for (; ; ) {
    StackVarsProcessor stackproc=new StackVarsProcessor();
    stackproc.simplifyStackVars(root,mt,cl);
    varproc.setVarVersions(root);
    if (!new PPandMMHelper().findPPandMM(root)) {
      break;
    }
  }
  for (; ; ) {
    LabelHelper.cleanUpEdges(root);
    for (; ; ) {
      MergeHelper.enhanceLoops(root);
      if (LoopExtractHelper.extractLoops(root)) {
        continue;
      }
      if (!IfHelper.mergeAllIfs(root)) {
        break;
      }
    }
    if (DecompilerContext.getOption(IFernflowerPreferences.IDEA_NOT_NULL_ANNOTATION)) {
      if (IdeaNotNullHelper.removeHardcodedChecks(root,mt)) {
        SequenceHelper.condenseSequences(root);
        StackVarsProcessor stackproc=new StackVarsProcessor();
        stackproc.simplifyStackVars(root,mt,cl);
        varproc.setVarVersions(root);
      }
    }
    LabelHelper.identifyLabels(root);
    if (InlineSingleBlockHelper.inlineSingleBlocks(root)) {
      continue;
    }
    if (isInitializer || !ExitHelper.condenseExits(root)) {
      break;
    }
  }
  ExitHelper.removeRedundantReturns(root);
  SecondaryFunctionsHelper.identifySecondaryFunctions(root);
  varproc.setVarDefinitions(root);
  LabelHelper.replaceContinueWithBreak(root);
  mt.releaseResources();
  return root;
}"
54662,"public void processClass(ClassNode root,ClassNode node){
  if (node.type == ClassNode.CLASS_LAMBDA) {
    ClassNode node_content=DecompilerContext.getClassprocessor().getMapRootClasses().get(node.classStruct.qualifiedName);
    if (node_content != null && node_content.wrapper != null) {
      node_content.wrapper.getHideMembers().add(node.lambda_information.content_method_key);
    }
  }
  if (node.nested.isEmpty()) {
    return;
  }
  if (node.type != ClassNode.CLASS_LAMBDA) {
    computeLocalVarsAndDefinitions(node);
    checkNotFoundClasses(root,node);
  }
  int nameless=0, synthetics=0;
  for (  ClassNode child : node.nested) {
    if ((child.type == ClassNode.CLASS_LOCAL || child.type == ClassNode.CLASS_MEMBER) && child.simpleName == null) {
      StructClass cl=child.classStruct;
      if (((child.access | cl.access_flags) & CodeConstants.ACC_SYNTHETIC) != 0 || cl.getAttributes().containsKey(""String_Node_Str"")) {
        child.simpleName=""String_Node_Str"" + (++synthetics);
      }
 else {
        DecompilerContext.getLogger().writeMessage(""String_Node_Str"" + cl.qualifiedName + ""String_Node_Str"",IFernflowerLogger.WARNING);
        child.simpleName=""String_Node_Str"" + (++nameless);
      }
    }
  }
  for (  ClassNode child : node.nested) {
    if (child.type == ClassNode.CLASS_LAMBDA) {
      setLambdaVars(node,child);
    }
 else {
      if (child.type != ClassNode.CLASS_MEMBER || (child.access & CodeConstants.ACC_STATIC) == 0) {
        insertLocalVars(node,child);
        if (child.type == ClassNode.CLASS_LOCAL) {
          setLocalClassDefinition(node.wrapper.getMethods().getWithKey(child.enclosingMethod),child);
        }
      }
    }
  }
  for (  ClassNode child : node.nested) {
    processClass(root,child);
  }
}","public void processClass(ClassNode root,ClassNode node){
  if (node.type == ClassNode.CLASS_LAMBDA && !node.lambda_information.is_method_reference) {
    ClassNode node_content=DecompilerContext.getClassprocessor().getMapRootClasses().get(node.classStruct.qualifiedName);
    if (node_content != null && node_content.wrapper != null) {
      node_content.wrapper.getHideMembers().add(node.lambda_information.content_method_key);
    }
  }
  if (node.nested.isEmpty()) {
    return;
  }
  if (node.type != ClassNode.CLASS_LAMBDA) {
    computeLocalVarsAndDefinitions(node);
    checkNotFoundClasses(root,node);
  }
  int nameless=0, synthetics=0;
  for (  ClassNode child : node.nested) {
    if ((child.type == ClassNode.CLASS_LOCAL || child.type == ClassNode.CLASS_MEMBER) && child.simpleName == null) {
      StructClass cl=child.classStruct;
      if (((child.access | cl.access_flags) & CodeConstants.ACC_SYNTHETIC) != 0 || cl.getAttributes().containsKey(""String_Node_Str"")) {
        child.simpleName=""String_Node_Str"" + (++synthetics);
      }
 else {
        DecompilerContext.getLogger().writeMessage(""String_Node_Str"" + cl.qualifiedName + ""String_Node_Str"",IFernflowerLogger.WARNING);
        child.simpleName=""String_Node_Str"" + (++nameless);
      }
    }
  }
  for (  ClassNode child : node.nested) {
    if (child.type == ClassNode.CLASS_LAMBDA) {
      setLambdaVars(node,child);
    }
 else {
      if (child.type != ClassNode.CLASS_MEMBER || (child.access & CodeConstants.ACC_STATIC) == 0) {
        insertLocalVars(node,child);
        if (child.type == ClassNode.CLASS_LOCAL) {
          setLocalClassDefinition(node.wrapper.getMethods().getWithKey(child.enclosingMethod),child);
        }
      }
    }
  }
  for (  ClassNode child : node.nested) {
    processClass(root,child);
  }
}"
54663,"public void processBlock(BasicBlockStatement stat,PrimitiveExprsList data,ConstantPool pool){
  BasicBlock block=stat.getBlock();
  ExprentStack stack=data.getStack();
  List<Exprent> exprlist=data.getLstExprents();
  InstructionSequence seq=block.getSeq();
  for (int i=0; i < seq.length(); i++) {
    Instruction instr=seq.getInstr(i);
switch (instr.opcode) {
case opc_aconst_null:
      pushEx(stack,exprlist,new ConstExprent(VarType.VARTYPE_NULL,null));
    break;
case opc_bipush:
case opc_sipush:
  pushEx(stack,exprlist,new ConstExprent(instr.getOperand(0),true));
break;
case opc_lconst_0:
case opc_lconst_1:
pushEx(stack,exprlist,new ConstExprent(VarType.VARTYPE_LONG,new Long(instr.opcode - opc_lconst_0)));
break;
case opc_fconst_0:
case opc_fconst_1:
case opc_fconst_2:
pushEx(stack,exprlist,new ConstExprent(VarType.VARTYPE_FLOAT,new Float(instr.opcode - opc_fconst_0)));
break;
case opc_dconst_0:
case opc_dconst_1:
pushEx(stack,exprlist,new ConstExprent(VarType.VARTYPE_DOUBLE,new Double(instr.opcode - opc_dconst_0)));
break;
case opc_ldc:
case opc_ldc_w:
case opc_ldc2_w:
PrimitiveConstant cn=pool.getPrimitiveConstant(instr.getOperand(0));
pushEx(stack,exprlist,new ConstExprent(consts[cn.type - CONSTANT_Integer],cn.value));
break;
case opc_iload:
case opc_lload:
case opc_fload:
case opc_dload:
case opc_aload:
pushEx(stack,exprlist,new VarExprent(instr.getOperand(0),vartypes[instr.opcode - opc_iload],varProcessor));
break;
case opc_iaload:
case opc_laload:
case opc_faload:
case opc_daload:
case opc_aaload:
case opc_baload:
case opc_caload:
case opc_saload:
Exprent index=stack.pop();
Exprent arr=stack.pop();
VarType vartype=null;
switch (instr.opcode) {
case opc_laload:
vartype=VarType.VARTYPE_LONG;
break;
case opc_daload:
vartype=VarType.VARTYPE_DOUBLE;
}
pushEx(stack,exprlist,new ArrayExprent(arr,index,arrtypes[instr.opcode - opc_iaload]),vartype);
break;
case opc_istore:
case opc_lstore:
case opc_fstore:
case opc_dstore:
case opc_astore:
Exprent top=stack.pop();
int varindex=instr.getOperand(0);
AssignmentExprent assign=new AssignmentExprent(new VarExprent(varindex,vartypes[instr.opcode - opc_istore],varProcessor),top);
exprlist.add(assign);
break;
case opc_iastore:
case opc_lastore:
case opc_fastore:
case opc_dastore:
case opc_aastore:
case opc_bastore:
case opc_castore:
case opc_sastore:
Exprent value=stack.pop();
Exprent index_store=stack.pop();
Exprent arr_store=stack.pop();
AssignmentExprent arrassign=new AssignmentExprent(new ArrayExprent(arr_store,index_store,arrtypes[instr.opcode - opc_iastore]),value);
exprlist.add(arrassign);
break;
case opc_iadd:
case opc_ladd:
case opc_fadd:
case opc_dadd:
case opc_isub:
case opc_lsub:
case opc_fsub:
case opc_dsub:
case opc_imul:
case opc_lmul:
case opc_fmul:
case opc_dmul:
case opc_idiv:
case opc_ldiv:
case opc_fdiv:
case opc_ddiv:
case opc_irem:
case opc_lrem:
case opc_frem:
case opc_drem:
pushEx(stack,exprlist,new FunctionExprent(func1[(instr.opcode - opc_iadd) / 4],stack));
break;
case opc_ishl:
case opc_lshl:
case opc_ishr:
case opc_lshr:
case opc_iushr:
case opc_lushr:
case opc_iand:
case opc_land:
case opc_ior:
case opc_lor:
case opc_ixor:
case opc_lxor:
pushEx(stack,exprlist,new FunctionExprent(func2[(instr.opcode - opc_ishl) / 2],stack));
break;
case opc_ineg:
case opc_lneg:
case opc_fneg:
case opc_dneg:
pushEx(stack,exprlist,new FunctionExprent(FunctionExprent.FUNCTION_NEG,stack));
break;
case opc_iinc:
VarExprent vevar=new VarExprent(instr.getOperand(0),VarType.VARTYPE_INT,varProcessor);
exprlist.add(new AssignmentExprent(vevar,new FunctionExprent(instr.getOperand(1) < 0 ? FunctionExprent.FUNCTION_SUB : FunctionExprent.FUNCTION_ADD,Arrays.asList(new Exprent[]{vevar.copy(),new ConstExprent(VarType.VARTYPE_INT,new Integer(Math.abs(instr.getOperand(1))))}))));
break;
case opc_i2l:
case opc_i2f:
case opc_i2d:
case opc_l2i:
case opc_l2f:
case opc_l2d:
case opc_f2i:
case opc_f2l:
case opc_f2d:
case opc_d2i:
case opc_d2l:
case opc_d2f:
case opc_i2b:
case opc_i2c:
case opc_i2s:
pushEx(stack,exprlist,new FunctionExprent(func3[instr.opcode - opc_i2l],stack));
break;
case opc_lcmp:
case opc_fcmpl:
case opc_fcmpg:
case opc_dcmpl:
case opc_dcmpg:
pushEx(stack,exprlist,new FunctionExprent(func4[instr.opcode - opc_lcmp],stack));
break;
case opc_ifeq:
case opc_ifne:
case opc_iflt:
case opc_ifge:
case opc_ifgt:
case opc_ifle:
exprlist.add(new IfExprent(negifs[func5[instr.opcode - opc_ifeq]],stack));
break;
case opc_if_icmpeq:
case opc_if_icmpne:
case opc_if_icmplt:
case opc_if_icmpge:
case opc_if_icmpgt:
case opc_if_icmple:
case opc_if_acmpeq:
case opc_if_acmpne:
exprlist.add(new IfExprent(negifs[func6[instr.opcode - opc_if_icmpeq]],stack));
break;
case opc_ifnull:
case opc_ifnonnull:
exprlist.add(new IfExprent(negifs[func7[instr.opcode - opc_ifnull]],stack));
break;
case opc_tableswitch:
case opc_lookupswitch:
exprlist.add(new SwitchExprent(stack.pop()));
break;
case opc_ireturn:
case opc_lreturn:
case opc_freturn:
case opc_dreturn:
case opc_areturn:
case opc_return:
case opc_athrow:
exprlist.add(new ExitExprent(instr.opcode == opc_athrow ? ExitExprent.EXIT_THROW : ExitExprent.EXIT_RETURN,instr.opcode == opc_return ? null : stack.pop(),instr.opcode == opc_athrow ? null : ((MethodDescriptor)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_DESCRIPTOR)).ret));
break;
case opc_monitorenter:
case opc_monitorexit:
exprlist.add(new MonitorExprent(func8[instr.opcode - opc_monitorenter],stack.pop()));
break;
case opc_checkcast:
case opc_instanceof:
stack.push(new ConstExprent(new VarType(pool.getPrimitiveConstant(instr.getOperand(0)).getString(),true),null));
case opc_arraylength:
pushEx(stack,exprlist,new FunctionExprent(mapConsts.get(instr.opcode).intValue(),stack));
break;
case opc_getstatic:
case opc_getfield:
pushEx(stack,exprlist,new FieldExprent(pool.getLinkConstant(instr.getOperand(0)),instr.opcode == opc_getstatic ? null : stack.pop()));
break;
case opc_putstatic:
case opc_putfield:
Exprent valfield=stack.pop();
Exprent exprfield=new FieldExprent(pool.getLinkConstant(instr.getOperand(0)),instr.opcode == opc_putstatic ? null : stack.pop());
exprlist.add(new AssignmentExprent(exprfield,valfield));
break;
case opc_invokevirtual:
case opc_invokespecial:
case opc_invokestatic:
case opc_invokeinterface:
case opc_invokedynamic:
if (instr.opcode != opc_invokedynamic || instr.bytecode_version >= CodeConstants.BYTECODE_JAVA_7) {
InvocationExprent exprinv=new InvocationExprent(instr.opcode,pool.getLinkConstant(instr.getOperand(0)),stack);
if (exprinv.getDescriptor().ret.type == CodeConstants.TYPE_VOID) {
exprlist.add(exprinv);
}
 else {
pushEx(stack,exprlist,exprinv);
}
}
break;
case opc_new:
case opc_anewarray:
case opc_multianewarray:
int arrdims=(instr.opcode == opc_new) ? 0 : (instr.opcode == opc_anewarray) ? 1 : instr.getOperand(1);
VarType arrtype=new VarType(pool.getPrimitiveConstant(instr.getOperand(0)).getString(),true);
if (instr.opcode != opc_multianewarray) {
arrtype.arraydim+=arrdims;
}
pushEx(stack,exprlist,new NewExprent(arrtype,stack,arrdims));
break;
case opc_newarray:
pushEx(stack,exprlist,new NewExprent(new VarType(arr_type[instr.getOperand(0) - 4],1),stack,1));
break;
case opc_dup:
pushEx(stack,exprlist,stack.getByOffset(-1).copy());
break;
case opc_dup_x1:
insertByOffsetEx(-2,stack,exprlist,-1);
break;
case opc_dup_x2:
if (stack.getByOffset(-2).getExprType().stack_size == 2) {
insertByOffsetEx(-2,stack,exprlist,-1);
}
 else {
insertByOffsetEx(-3,stack,exprlist,-1);
}
break;
case opc_dup2:
if (stack.getByOffset(-1).getExprType().stack_size == 2) {
pushEx(stack,exprlist,stack.getByOffset(-1).copy());
}
 else {
pushEx(stack,exprlist,stack.getByOffset(-2).copy());
pushEx(stack,exprlist,stack.getByOffset(-2).copy());
}
break;
case opc_dup2_x1:
if (stack.getByOffset(-1).getExprType().stack_size == 2) {
insertByOffsetEx(-2,stack,exprlist,-1);
}
 else {
insertByOffsetEx(-3,stack,exprlist,-2);
insertByOffsetEx(-3,stack,exprlist,-1);
}
break;
case opc_dup2_x2:
if (stack.getByOffset(-1).getExprType().stack_size == 2) {
if (stack.getByOffset(-2).getExprType().stack_size == 2) {
insertByOffsetEx(-2,stack,exprlist,-1);
}
 else {
insertByOffsetEx(-3,stack,exprlist,-1);
}
}
 else {
if (stack.getByOffset(-3).getExprType().stack_size == 2) {
insertByOffsetEx(-3,stack,exprlist,-2);
insertByOffsetEx(-3,stack,exprlist,-1);
}
 else {
insertByOffsetEx(-4,stack,exprlist,-2);
insertByOffsetEx(-4,stack,exprlist,-1);
}
}
break;
case opc_swap:
insertByOffsetEx(-2,stack,exprlist,-1);
stack.pop();
break;
case opc_pop:
case opc_pop2:
stack.pop();
}
}
}","public void processBlock(BasicBlockStatement stat,PrimitiveExprsList data,StructClass cl){
  ConstantPool pool=cl.getPool();
  StructBootstrapMethodsAttribute bootstrap=(StructBootstrapMethodsAttribute)cl.getAttributes().getWithKey(StructGeneralAttribute.ATTRIBUTE_BOOTSTRAP_METHODS);
  BasicBlock block=stat.getBlock();
  ExprentStack stack=data.getStack();
  List<Exprent> exprlist=data.getLstExprents();
  InstructionSequence seq=block.getSeq();
  for (int i=0; i < seq.length(); i++) {
    Instruction instr=seq.getInstr(i);
switch (instr.opcode) {
case opc_aconst_null:
      pushEx(stack,exprlist,new ConstExprent(VarType.VARTYPE_NULL,null));
    break;
case opc_bipush:
case opc_sipush:
  pushEx(stack,exprlist,new ConstExprent(instr.getOperand(0),true));
break;
case opc_lconst_0:
case opc_lconst_1:
pushEx(stack,exprlist,new ConstExprent(VarType.VARTYPE_LONG,new Long(instr.opcode - opc_lconst_0)));
break;
case opc_fconst_0:
case opc_fconst_1:
case opc_fconst_2:
pushEx(stack,exprlist,new ConstExprent(VarType.VARTYPE_FLOAT,new Float(instr.opcode - opc_fconst_0)));
break;
case opc_dconst_0:
case opc_dconst_1:
pushEx(stack,exprlist,new ConstExprent(VarType.VARTYPE_DOUBLE,new Double(instr.opcode - opc_dconst_0)));
break;
case opc_ldc:
case opc_ldc_w:
case opc_ldc2_w:
PrimitiveConstant cn=pool.getPrimitiveConstant(instr.getOperand(0));
pushEx(stack,exprlist,new ConstExprent(consts[cn.type - CONSTANT_Integer],cn.value));
break;
case opc_iload:
case opc_lload:
case opc_fload:
case opc_dload:
case opc_aload:
pushEx(stack,exprlist,new VarExprent(instr.getOperand(0),vartypes[instr.opcode - opc_iload],varProcessor));
break;
case opc_iaload:
case opc_laload:
case opc_faload:
case opc_daload:
case opc_aaload:
case opc_baload:
case opc_caload:
case opc_saload:
Exprent index=stack.pop();
Exprent arr=stack.pop();
VarType vartype=null;
switch (instr.opcode) {
case opc_laload:
vartype=VarType.VARTYPE_LONG;
break;
case opc_daload:
vartype=VarType.VARTYPE_DOUBLE;
}
pushEx(stack,exprlist,new ArrayExprent(arr,index,arrtypes[instr.opcode - opc_iaload]),vartype);
break;
case opc_istore:
case opc_lstore:
case opc_fstore:
case opc_dstore:
case opc_astore:
Exprent top=stack.pop();
int varindex=instr.getOperand(0);
AssignmentExprent assign=new AssignmentExprent(new VarExprent(varindex,vartypes[instr.opcode - opc_istore],varProcessor),top);
exprlist.add(assign);
break;
case opc_iastore:
case opc_lastore:
case opc_fastore:
case opc_dastore:
case opc_aastore:
case opc_bastore:
case opc_castore:
case opc_sastore:
Exprent value=stack.pop();
Exprent index_store=stack.pop();
Exprent arr_store=stack.pop();
AssignmentExprent arrassign=new AssignmentExprent(new ArrayExprent(arr_store,index_store,arrtypes[instr.opcode - opc_iastore]),value);
exprlist.add(arrassign);
break;
case opc_iadd:
case opc_ladd:
case opc_fadd:
case opc_dadd:
case opc_isub:
case opc_lsub:
case opc_fsub:
case opc_dsub:
case opc_imul:
case opc_lmul:
case opc_fmul:
case opc_dmul:
case opc_idiv:
case opc_ldiv:
case opc_fdiv:
case opc_ddiv:
case opc_irem:
case opc_lrem:
case opc_frem:
case opc_drem:
pushEx(stack,exprlist,new FunctionExprent(func1[(instr.opcode - opc_iadd) / 4],stack));
break;
case opc_ishl:
case opc_lshl:
case opc_ishr:
case opc_lshr:
case opc_iushr:
case opc_lushr:
case opc_iand:
case opc_land:
case opc_ior:
case opc_lor:
case opc_ixor:
case opc_lxor:
pushEx(stack,exprlist,new FunctionExprent(func2[(instr.opcode - opc_ishl) / 2],stack));
break;
case opc_ineg:
case opc_lneg:
case opc_fneg:
case opc_dneg:
pushEx(stack,exprlist,new FunctionExprent(FunctionExprent.FUNCTION_NEG,stack));
break;
case opc_iinc:
VarExprent vevar=new VarExprent(instr.getOperand(0),VarType.VARTYPE_INT,varProcessor);
exprlist.add(new AssignmentExprent(vevar,new FunctionExprent(instr.getOperand(1) < 0 ? FunctionExprent.FUNCTION_SUB : FunctionExprent.FUNCTION_ADD,Arrays.asList(new Exprent[]{vevar.copy(),new ConstExprent(VarType.VARTYPE_INT,new Integer(Math.abs(instr.getOperand(1))))}))));
break;
case opc_i2l:
case opc_i2f:
case opc_i2d:
case opc_l2i:
case opc_l2f:
case opc_l2d:
case opc_f2i:
case opc_f2l:
case opc_f2d:
case opc_d2i:
case opc_d2l:
case opc_d2f:
case opc_i2b:
case opc_i2c:
case opc_i2s:
pushEx(stack,exprlist,new FunctionExprent(func3[instr.opcode - opc_i2l],stack));
break;
case opc_lcmp:
case opc_fcmpl:
case opc_fcmpg:
case opc_dcmpl:
case opc_dcmpg:
pushEx(stack,exprlist,new FunctionExprent(func4[instr.opcode - opc_lcmp],stack));
break;
case opc_ifeq:
case opc_ifne:
case opc_iflt:
case opc_ifge:
case opc_ifgt:
case opc_ifle:
exprlist.add(new IfExprent(negifs[func5[instr.opcode - opc_ifeq]],stack));
break;
case opc_if_icmpeq:
case opc_if_icmpne:
case opc_if_icmplt:
case opc_if_icmpge:
case opc_if_icmpgt:
case opc_if_icmple:
case opc_if_acmpeq:
case opc_if_acmpne:
exprlist.add(new IfExprent(negifs[func6[instr.opcode - opc_if_icmpeq]],stack));
break;
case opc_ifnull:
case opc_ifnonnull:
exprlist.add(new IfExprent(negifs[func7[instr.opcode - opc_ifnull]],stack));
break;
case opc_tableswitch:
case opc_lookupswitch:
exprlist.add(new SwitchExprent(stack.pop()));
break;
case opc_ireturn:
case opc_lreturn:
case opc_freturn:
case opc_dreturn:
case opc_areturn:
case opc_return:
case opc_athrow:
exprlist.add(new ExitExprent(instr.opcode == opc_athrow ? ExitExprent.EXIT_THROW : ExitExprent.EXIT_RETURN,instr.opcode == opc_return ? null : stack.pop(),instr.opcode == opc_athrow ? null : ((MethodDescriptor)DecompilerContext.getProperty(DecompilerContext.CURRENT_METHOD_DESCRIPTOR)).ret));
break;
case opc_monitorenter:
case opc_monitorexit:
exprlist.add(new MonitorExprent(func8[instr.opcode - opc_monitorenter],stack.pop()));
break;
case opc_checkcast:
case opc_instanceof:
stack.push(new ConstExprent(new VarType(pool.getPrimitiveConstant(instr.getOperand(0)).getString(),true),null));
case opc_arraylength:
pushEx(stack,exprlist,new FunctionExprent(mapConsts.get(instr.opcode).intValue(),stack));
break;
case opc_getstatic:
case opc_getfield:
pushEx(stack,exprlist,new FieldExprent(pool.getLinkConstant(instr.getOperand(0)),instr.opcode == opc_getstatic ? null : stack.pop()));
break;
case opc_putstatic:
case opc_putfield:
Exprent valfield=stack.pop();
Exprent exprfield=new FieldExprent(pool.getLinkConstant(instr.getOperand(0)),instr.opcode == opc_putstatic ? null : stack.pop());
exprlist.add(new AssignmentExprent(exprfield,valfield));
break;
case opc_invokevirtual:
case opc_invokespecial:
case opc_invokestatic:
case opc_invokeinterface:
case opc_invokedynamic:
if (instr.opcode != opc_invokedynamic || instr.bytecode_version >= CodeConstants.BYTECODE_JAVA_7) {
LinkConstant invoke_constant=pool.getLinkConstant(instr.getOperand(0));
int dynamic_invokation_type=-1;
if (instr.opcode == opc_invokedynamic && bootstrap != null) {
List<PooledConstant> bootstrap_arguments=bootstrap.getMethodArguments(invoke_constant.index1);
LinkConstant content_method_handle=(LinkConstant)bootstrap_arguments.get(1);
dynamic_invokation_type=content_method_handle.index1;
}
InvocationExprent exprinv=new InvocationExprent(instr.opcode,invoke_constant,stack,dynamic_invokation_type);
if (exprinv.getDescriptor().ret.type == CodeConstants.TYPE_VOID) {
exprlist.add(exprinv);
}
 else {
pushEx(stack,exprlist,exprinv);
}
}
break;
case opc_new:
case opc_anewarray:
case opc_multianewarray:
int arrdims=(instr.opcode == opc_new) ? 0 : (instr.opcode == opc_anewarray) ? 1 : instr.getOperand(1);
VarType arrtype=new VarType(pool.getPrimitiveConstant(instr.getOperand(0)).getString(),true);
if (instr.opcode != opc_multianewarray) {
arrtype.arraydim+=arrdims;
}
pushEx(stack,exprlist,new NewExprent(arrtype,stack,arrdims));
break;
case opc_newarray:
pushEx(stack,exprlist,new NewExprent(new VarType(arr_type[instr.getOperand(0) - 4],1),stack,1));
break;
case opc_dup:
pushEx(stack,exprlist,stack.getByOffset(-1).copy());
break;
case opc_dup_x1:
insertByOffsetEx(-2,stack,exprlist,-1);
break;
case opc_dup_x2:
if (stack.getByOffset(-2).getExprType().stack_size == 2) {
insertByOffsetEx(-2,stack,exprlist,-1);
}
 else {
insertByOffsetEx(-3,stack,exprlist,-1);
}
break;
case opc_dup2:
if (stack.getByOffset(-1).getExprType().stack_size == 2) {
pushEx(stack,exprlist,stack.getByOffset(-1).copy());
}
 else {
pushEx(stack,exprlist,stack.getByOffset(-2).copy());
pushEx(stack,exprlist,stack.getByOffset(-2).copy());
}
break;
case opc_dup2_x1:
if (stack.getByOffset(-1).getExprType().stack_size == 2) {
insertByOffsetEx(-2,stack,exprlist,-1);
}
 else {
insertByOffsetEx(-3,stack,exprlist,-2);
insertByOffsetEx(-3,stack,exprlist,-1);
}
break;
case opc_dup2_x2:
if (stack.getByOffset(-1).getExprType().stack_size == 2) {
if (stack.getByOffset(-2).getExprType().stack_size == 2) {
insertByOffsetEx(-2,stack,exprlist,-1);
}
 else {
insertByOffsetEx(-3,stack,exprlist,-1);
}
}
 else {
if (stack.getByOffset(-3).getExprType().stack_size == 2) {
insertByOffsetEx(-3,stack,exprlist,-2);
insertByOffsetEx(-3,stack,exprlist,-1);
}
 else {
insertByOffsetEx(-4,stack,exprlist,-2);
insertByOffsetEx(-4,stack,exprlist,-1);
}
}
break;
case opc_swap:
insertByOffsetEx(-2,stack,exprlist,-1);
stack.pop();
break;
case opc_pop:
case opc_pop2:
stack.pop();
}
}
}"
54664,"public void processStatement(RootStatement root,ConstantPool pool){
  FlattenStatementsHelper flatthelper=new FlattenStatementsHelper();
  DirectGraph dgraph=flatthelper.buildDirectGraph(root);
  Set<String> setFinallyShortRangeEntryPoints=new HashSet<String>();
  for (  List<FinallyPathWrapper> lst : dgraph.mapShortRangeFinallyPaths.values()) {
    for (    FinallyPathWrapper finwrap : lst) {
      setFinallyShortRangeEntryPoints.add(finwrap.entry);
    }
  }
  Set<String> setFinallyLongRangeEntryPaths=new HashSet<String>();
  for (  List<FinallyPathWrapper> lst : dgraph.mapLongRangeFinallyPaths.values()) {
    for (    FinallyPathWrapper finwrap : lst) {
      setFinallyLongRangeEntryPaths.add(finwrap.source + ""String_Node_Str"" + finwrap.entry);
    }
  }
  Map<String,VarExprent> mapCatch=new HashMap<String,VarExprent>();
  collectCatchVars(root,flatthelper,mapCatch);
  Map<DirectNode,Map<String,PrimitiveExprsList>> mapData=new HashMap<DirectNode,Map<String,PrimitiveExprsList>>();
  LinkedList<DirectNode> stack=new LinkedList<DirectNode>();
  LinkedList<LinkedList<String>> stackEntryPoint=new LinkedList<LinkedList<String>>();
  stack.add(dgraph.first);
  stackEntryPoint.add(new LinkedList<String>());
  Map<String,PrimitiveExprsList> map=new HashMap<String,PrimitiveExprsList>();
  map.put(null,new PrimitiveExprsList());
  mapData.put(dgraph.first,map);
  while (!stack.isEmpty()) {
    DirectNode node=stack.removeFirst();
    LinkedList<String> entrypoints=stackEntryPoint.removeFirst();
    PrimitiveExprsList data;
    if (mapCatch.containsKey(node.id)) {
      data=getExpressionData(mapCatch.get(node.id));
    }
 else {
      data=mapData.get(node).get(buildEntryPointKey(entrypoints));
    }
    BasicBlockStatement block=node.block;
    if (block != null) {
      processBlock(block,data,pool);
      block.setExprents(data.getLstExprents());
    }
    String currentEntrypoint=entrypoints.isEmpty() ? null : entrypoints.getLast();
    for (    DirectNode nd : node.succs) {
      boolean isSuccessor=true;
      if (currentEntrypoint != null && dgraph.mapLongRangeFinallyPaths.containsKey(node.id)) {
        isSuccessor=false;
        for (        FinallyPathWrapper finwraplong : dgraph.mapLongRangeFinallyPaths.get(node.id)) {
          if (finwraplong.source.equals(currentEntrypoint) && finwraplong.destination.equals(nd.id)) {
            isSuccessor=true;
            break;
          }
        }
      }
      if (isSuccessor) {
        Map<String,PrimitiveExprsList> mapSucc=mapData.get(nd);
        if (mapSucc == null) {
          mapData.put(nd,mapSucc=new HashMap<String,PrimitiveExprsList>());
        }
        LinkedList<String> ndentrypoints=new LinkedList<String>(entrypoints);
        if (setFinallyLongRangeEntryPaths.contains(node.id + ""String_Node_Str"" + nd.id)) {
          ndentrypoints.addLast(node.id);
        }
 else         if (!setFinallyShortRangeEntryPoints.contains(nd.id) && dgraph.mapLongRangeFinallyPaths.containsKey(node.id)) {
          ndentrypoints.removeLast();
        }
        int succ_entry_index=ndentrypoints.indexOf(nd.id);
        if (succ_entry_index >= 0) {
          for (int elements_to_remove=ndentrypoints.size() - succ_entry_index; elements_to_remove > 0; elements_to_remove--) {
            ndentrypoints.removeLast();
          }
        }
        String ndentrykey=buildEntryPointKey(ndentrypoints);
        if (!mapSucc.containsKey(ndentrykey)) {
          mapSucc.put(ndentrykey,copyVarExprents(data.copyStack()));
          stack.add(nd);
          stackEntryPoint.add(ndentrypoints);
        }
      }
    }
  }
  initStatementExprents(root);
}","public void processStatement(RootStatement root,StructClass cl){
  FlattenStatementsHelper flatthelper=new FlattenStatementsHelper();
  DirectGraph dgraph=flatthelper.buildDirectGraph(root);
  Set<String> setFinallyShortRangeEntryPoints=new HashSet<String>();
  for (  List<FinallyPathWrapper> lst : dgraph.mapShortRangeFinallyPaths.values()) {
    for (    FinallyPathWrapper finwrap : lst) {
      setFinallyShortRangeEntryPoints.add(finwrap.entry);
    }
  }
  Set<String> setFinallyLongRangeEntryPaths=new HashSet<String>();
  for (  List<FinallyPathWrapper> lst : dgraph.mapLongRangeFinallyPaths.values()) {
    for (    FinallyPathWrapper finwrap : lst) {
      setFinallyLongRangeEntryPaths.add(finwrap.source + ""String_Node_Str"" + finwrap.entry);
    }
  }
  Map<String,VarExprent> mapCatch=new HashMap<String,VarExprent>();
  collectCatchVars(root,flatthelper,mapCatch);
  Map<DirectNode,Map<String,PrimitiveExprsList>> mapData=new HashMap<DirectNode,Map<String,PrimitiveExprsList>>();
  LinkedList<DirectNode> stack=new LinkedList<DirectNode>();
  LinkedList<LinkedList<String>> stackEntryPoint=new LinkedList<LinkedList<String>>();
  stack.add(dgraph.first);
  stackEntryPoint.add(new LinkedList<String>());
  Map<String,PrimitiveExprsList> map=new HashMap<String,PrimitiveExprsList>();
  map.put(null,new PrimitiveExprsList());
  mapData.put(dgraph.first,map);
  while (!stack.isEmpty()) {
    DirectNode node=stack.removeFirst();
    LinkedList<String> entrypoints=stackEntryPoint.removeFirst();
    PrimitiveExprsList data;
    if (mapCatch.containsKey(node.id)) {
      data=getExpressionData(mapCatch.get(node.id));
    }
 else {
      data=mapData.get(node).get(buildEntryPointKey(entrypoints));
    }
    BasicBlockStatement block=node.block;
    if (block != null) {
      processBlock(block,data,cl);
      block.setExprents(data.getLstExprents());
    }
    String currentEntrypoint=entrypoints.isEmpty() ? null : entrypoints.getLast();
    for (    DirectNode nd : node.succs) {
      boolean isSuccessor=true;
      if (currentEntrypoint != null && dgraph.mapLongRangeFinallyPaths.containsKey(node.id)) {
        isSuccessor=false;
        for (        FinallyPathWrapper finwraplong : dgraph.mapLongRangeFinallyPaths.get(node.id)) {
          if (finwraplong.source.equals(currentEntrypoint) && finwraplong.destination.equals(nd.id)) {
            isSuccessor=true;
            break;
          }
        }
      }
      if (isSuccessor) {
        Map<String,PrimitiveExprsList> mapSucc=mapData.get(nd);
        if (mapSucc == null) {
          mapData.put(nd,mapSucc=new HashMap<String,PrimitiveExprsList>());
        }
        LinkedList<String> ndentrypoints=new LinkedList<String>(entrypoints);
        if (setFinallyLongRangeEntryPaths.contains(node.id + ""String_Node_Str"" + nd.id)) {
          ndentrypoints.addLast(node.id);
        }
 else         if (!setFinallyShortRangeEntryPoints.contains(nd.id) && dgraph.mapLongRangeFinallyPaths.containsKey(node.id)) {
          ndentrypoints.removeLast();
        }
        int succ_entry_index=ndentrypoints.indexOf(nd.id);
        if (succ_entry_index >= 0) {
          for (int elements_to_remove=ndentrypoints.size() - succ_entry_index; elements_to_remove > 0; elements_to_remove--) {
            ndentrypoints.removeLast();
          }
        }
        String ndentrykey=buildEntryPointKey(ndentrypoints);
        if (!mapSucc.containsKey(ndentrykey)) {
          mapSucc.put(ndentrykey,copyVarExprents(data.copyStack()));
          stack.add(nd);
          stackEntryPoint.add(ndentrypoints);
        }
      }
    }
  }
  initStatementExprents(root);
}"
54665,"private Object[] getFinallyInformation(StructMethod mt,RootStatement root,CatchAllStatement fstat){
  HashMap<BasicBlock,Boolean> mapLast=new HashMap<BasicBlock,Boolean>();
  BasicBlockStatement firstBlockStatement=fstat.getHandler().getBasichead();
  BasicBlock firstBasicBlock=firstBlockStatement.getBlock();
  Instruction instrFirst=firstBasicBlock.getInstruction(0);
  int firstcode=0;
switch (instrFirst.opcode) {
case CodeConstants.opc_pop:
    firstcode=1;
  break;
case CodeConstants.opc_astore:
firstcode=2;
}
ExprProcessor proc=new ExprProcessor();
proc.processStatement(root,mt.getClassStruct().getPool());
SSAConstructorSparseEx ssa=new SSAConstructorSparseEx();
ssa.splitVariables(root,mt);
List<Exprent> lstExprents=firstBlockStatement.getExprents();
VarVersionPaar varpaar=new VarVersionPaar((VarExprent)((AssignmentExprent)lstExprents.get(firstcode == 2 ? 1 : 0)).getLeft());
FlattenStatementsHelper flatthelper=new FlattenStatementsHelper();
DirectGraph dgraph=flatthelper.buildDirectGraph(root);
LinkedList<DirectNode> stack=new LinkedList<DirectNode>();
stack.add(dgraph.first);
HashSet<DirectNode> setVisited=new HashSet<DirectNode>();
while (!stack.isEmpty()) {
DirectNode node=stack.removeFirst();
if (setVisited.contains(node)) {
continue;
}
setVisited.add(node);
BasicBlockStatement blockStatement=null;
if (node.block != null) {
blockStatement=node.block;
}
 else if (node.preds.size() == 1) {
blockStatement=node.preds.get(0).block;
}
boolean isTrueExit=true;
if (firstcode != 1) {
isTrueExit=false;
for (int i=0; i < node.exprents.size(); i++) {
  Exprent exprent=node.exprents.get(i);
  if (firstcode == 0) {
    List<Exprent> lst=exprent.getAllExprents();
    lst.add(exprent);
    boolean found=false;
    for (    Exprent expr : lst) {
      if (expr.type == Exprent.EXPRENT_VAR && new VarVersionPaar((VarExprent)expr).equals(varpaar)) {
        found=true;
        break;
      }
    }
    if (found) {
      found=false;
      if (exprent.type == Exprent.EXPRENT_EXIT) {
        ExitExprent exexpr=(ExitExprent)exprent;
        if (exexpr.getExittype() == ExitExprent.EXIT_THROW && exexpr.getValue().type == Exprent.EXPRENT_VAR) {
          found=true;
        }
      }
      if (!found) {
        return null;
      }
 else {
        isTrueExit=true;
      }
    }
  }
 else   if (firstcode == 2) {
    if (exprent.type == Exprent.EXPRENT_ASSIGNMENT) {
      AssignmentExprent assexpr=(AssignmentExprent)exprent;
      if (assexpr.getRight().type == Exprent.EXPRENT_VAR && new VarVersionPaar((VarExprent)assexpr.getRight()).equals(varpaar)) {
        Exprent next=null;
        if (i == node.exprents.size() - 1) {
          if (node.succs.size() == 1) {
            DirectNode nd=node.succs.get(0);
            if (!nd.exprents.isEmpty()) {
              next=nd.exprents.get(0);
            }
          }
        }
 else {
          next=node.exprents.get(i + 1);
        }
        boolean found=false;
        if (next != null && next.type == Exprent.EXPRENT_EXIT) {
          ExitExprent exexpr=(ExitExprent)next;
          if (exexpr.getExittype() == ExitExprent.EXIT_THROW && exexpr.getValue().type == Exprent.EXPRENT_VAR && assexpr.getLeft().equals(exexpr.getValue())) {
            found=true;
          }
        }
        if (!found) {
          return null;
        }
 else {
          isTrueExit=true;
        }
      }
    }
  }
}
}
if (blockStatement != null && blockStatement.getBlock() != null) {
Statement handler=fstat.getHandler();
for (StatEdge edge : blockStatement.getSuccessorEdges(Statement.STATEDGE_DIRECT_ALL)) {
  if (edge.getType() != StatEdge.TYPE_REGULAR && handler.containsStatement(blockStatement) && !handler.containsStatement(edge.getDestination())) {
    Boolean existingFlag=mapLast.get(blockStatement.getBlock());
    if (existingFlag == null || !existingFlag) {
      mapLast.put(blockStatement.getBlock(),isTrueExit);
      break;
    }
  }
}
}
stack.addAll(node.succs);
}
if (fstat.getHandler().type == Statement.TYPE_BASICBLOCK) {
boolean isEmpty=false;
boolean isFirstLast=mapLast.containsKey(firstBasicBlock);
InstructionSequence seq=firstBasicBlock.getSeq();
switch (firstcode) {
case 0:
isEmpty=isFirstLast && seq.length() == 1;
break;
case 1:
isEmpty=seq.length() == 1;
break;
case 2:
isEmpty=isFirstLast ? seq.length() == 3 : seq.length() == 1;
}
if (isEmpty) {
firstcode=3;
}
}
return new Object[]{firstcode,mapLast};
}","private Object[] getFinallyInformation(StructMethod mt,RootStatement root,CatchAllStatement fstat){
  HashMap<BasicBlock,Boolean> mapLast=new HashMap<BasicBlock,Boolean>();
  BasicBlockStatement firstBlockStatement=fstat.getHandler().getBasichead();
  BasicBlock firstBasicBlock=firstBlockStatement.getBlock();
  Instruction instrFirst=firstBasicBlock.getInstruction(0);
  int firstcode=0;
switch (instrFirst.opcode) {
case CodeConstants.opc_pop:
    firstcode=1;
  break;
case CodeConstants.opc_astore:
firstcode=2;
}
ExprProcessor proc=new ExprProcessor();
proc.processStatement(root,mt.getClassStruct());
SSAConstructorSparseEx ssa=new SSAConstructorSparseEx();
ssa.splitVariables(root,mt);
List<Exprent> lstExprents=firstBlockStatement.getExprents();
VarVersionPaar varpaar=new VarVersionPaar((VarExprent)((AssignmentExprent)lstExprents.get(firstcode == 2 ? 1 : 0)).getLeft());
FlattenStatementsHelper flatthelper=new FlattenStatementsHelper();
DirectGraph dgraph=flatthelper.buildDirectGraph(root);
LinkedList<DirectNode> stack=new LinkedList<DirectNode>();
stack.add(dgraph.first);
HashSet<DirectNode> setVisited=new HashSet<DirectNode>();
while (!stack.isEmpty()) {
DirectNode node=stack.removeFirst();
if (setVisited.contains(node)) {
continue;
}
setVisited.add(node);
BasicBlockStatement blockStatement=null;
if (node.block != null) {
blockStatement=node.block;
}
 else if (node.preds.size() == 1) {
blockStatement=node.preds.get(0).block;
}
boolean isTrueExit=true;
if (firstcode != 1) {
isTrueExit=false;
for (int i=0; i < node.exprents.size(); i++) {
  Exprent exprent=node.exprents.get(i);
  if (firstcode == 0) {
    List<Exprent> lst=exprent.getAllExprents();
    lst.add(exprent);
    boolean found=false;
    for (    Exprent expr : lst) {
      if (expr.type == Exprent.EXPRENT_VAR && new VarVersionPaar((VarExprent)expr).equals(varpaar)) {
        found=true;
        break;
      }
    }
    if (found) {
      found=false;
      if (exprent.type == Exprent.EXPRENT_EXIT) {
        ExitExprent exexpr=(ExitExprent)exprent;
        if (exexpr.getExittype() == ExitExprent.EXIT_THROW && exexpr.getValue().type == Exprent.EXPRENT_VAR) {
          found=true;
        }
      }
      if (!found) {
        return null;
      }
 else {
        isTrueExit=true;
      }
    }
  }
 else   if (firstcode == 2) {
    if (exprent.type == Exprent.EXPRENT_ASSIGNMENT) {
      AssignmentExprent assexpr=(AssignmentExprent)exprent;
      if (assexpr.getRight().type == Exprent.EXPRENT_VAR && new VarVersionPaar((VarExprent)assexpr.getRight()).equals(varpaar)) {
        Exprent next=null;
        if (i == node.exprents.size() - 1) {
          if (node.succs.size() == 1) {
            DirectNode nd=node.succs.get(0);
            if (!nd.exprents.isEmpty()) {
              next=nd.exprents.get(0);
            }
          }
        }
 else {
          next=node.exprents.get(i + 1);
        }
        boolean found=false;
        if (next != null && next.type == Exprent.EXPRENT_EXIT) {
          ExitExprent exexpr=(ExitExprent)next;
          if (exexpr.getExittype() == ExitExprent.EXIT_THROW && exexpr.getValue().type == Exprent.EXPRENT_VAR && assexpr.getLeft().equals(exexpr.getValue())) {
            found=true;
          }
        }
        if (!found) {
          return null;
        }
 else {
          isTrueExit=true;
        }
      }
    }
  }
}
}
if (blockStatement != null && blockStatement.getBlock() != null) {
Statement handler=fstat.getHandler();
for (StatEdge edge : blockStatement.getSuccessorEdges(Statement.STATEDGE_DIRECT_ALL)) {
  if (edge.getType() != StatEdge.TYPE_REGULAR && handler.containsStatement(blockStatement) && !handler.containsStatement(edge.getDestination())) {
    Boolean existingFlag=mapLast.get(blockStatement.getBlock());
    if (existingFlag == null || !existingFlag) {
      mapLast.put(blockStatement.getBlock(),isTrueExit);
      break;
    }
  }
}
}
stack.addAll(node.succs);
}
if (fstat.getHandler().type == Statement.TYPE_BASICBLOCK) {
boolean isEmpty=false;
boolean isFirstLast=mapLast.containsKey(firstBasicBlock);
InstructionSequence seq=firstBasicBlock.getSeq();
switch (firstcode) {
case 0:
isEmpty=isFirstLast && seq.length() == 1;
break;
case 1:
isEmpty=seq.length() == 1;
break;
case 2:
isEmpty=isFirstLast ? seq.length() == 3 : seq.length() == 1;
}
if (isEmpty) {
firstcode=3;
}
}
return new Object[]{firstcode,mapLast};
}"
54666,"/** 
 * {@inheritDoc} 
 */
@Override protected void _transform(Dataframe newData){
  TrainingParameters trainingParameters=knowledgeBase.getTrainingParameters();
  boolean scaleResponse=trainingParameters.getScaleResponse() && newData.getYDataType() == TypeInference.DataType.NUMERICAL;
  double threshold=trainingParameters.getThreshold();
  Map<Object,TypeInference.DataType> columnTypes=newData.getXDataTypes();
  streamExecutor.forEach(StreamMethods.stream(newData.entries(),isParallelized()),e -> {
    Record r=e.getValue();
    AssociativeArray xData=r.getX().copy();
    Object yData=r.getY();
    boolean modified=false;
    for (    Map.Entry<Object,Object> entry : xData.entrySet()) {
      Object column=entry.getKey();
      Double value=xData.getDouble(column);
      if (value == null || columnTypes.get(column) != TypeInference.DataType.NUMERICAL) {
        continue;
      }
      xData.put(column,scale(value,threshold));
      modified=true;
    }
    if (scaleResponse && yData != null) {
      Double value=TypeInference.toDouble(yData);
      yData=scale(value,threshold);
      modified=true;
    }
    if (modified) {
      Integer rId=e.getKey();
      Record newR=new Record(xData,yData,r.getYPredicted(),r.getYPredictedProbabilities());
      newData._unsafe_set(rId,newR);
    }
  }
);
  newData.recalculateMeta();
}","/** 
 * {@inheritDoc} 
 */
@Override protected void _transform(Dataframe newData){
  TrainingParameters trainingParameters=knowledgeBase.getTrainingParameters();
  boolean scaleResponse=trainingParameters.getScaleResponse() && newData.getYDataType() == TypeInference.DataType.NUMERICAL;
  double threshold=trainingParameters.getThreshold();
  Map<Object,TypeInference.DataType> columnTypes=newData.getXDataTypes();
  streamExecutor.forEach(StreamMethods.stream(newData.entries(),isParallelized()),e -> {
    Record r=e.getValue();
    AssociativeArray xData=r.getX().copy();
    Object yData=r.getY();
    boolean modified=false;
    for (    Map.Entry<Object,Object> entry : xData.entrySet()) {
      Object column=entry.getKey();
      Object value=entry.getValue();
      if (value == null || columnTypes.get(column) != TypeInference.DataType.NUMERICAL) {
        continue;
      }
      xData.put(column,scale(TypeInference.toDouble(value),threshold));
      modified=true;
    }
    if (scaleResponse && yData != null) {
      Double value=TypeInference.toDouble(yData);
      yData=scale(value,threshold);
      modified=true;
    }
    if (modified) {
      Integer rId=e.getKey();
      Record newR=new Record(xData,yData,r.getYPredicted(),r.getYPredictedProbabilities());
      newData._unsafe_set(rId,newR);
    }
  }
);
  newData.recalculateMeta();
}"
54667,"/** 
 * {@inheritDoc} 
 */
@Override protected void _transform(Dataframe newData){
  ModelParameters modelParameters=knowledgeBase.getModelParameters();
  Map<Object,Double> maxAbsoluteColumnValues=modelParameters.getMaxAbsoluteColumnValues();
  boolean scaleResponse=knowledgeBase.getTrainingParameters().getScaleResponse() && maxAbsoluteColumnValues.containsKey(Dataframe.COLUMN_NAME_Y);
  streamExecutor.forEach(StreamMethods.stream(newData.entries(),isParallelized()),e -> {
    Record r=e.getValue();
    AssociativeArray xData=r.getX().copy();
    Object yData=r.getY();
    boolean modified=false;
    for (    Map.Entry<Object,Double> entry : maxAbsoluteColumnValues.entrySet()) {
      Object column=entry.getKey();
      Double value=xData.getDouble(column);
      if (value == null) {
        continue;
      }
      Double maxAbsolute=entry.getValue();
      xData.put(column,scale(value,maxAbsolute));
      modified=true;
    }
    if (scaleResponse && yData != null) {
      Double value=TypeInference.toDouble(yData);
      Double maxAbsolute=maxAbsoluteColumnValues.get(Dataframe.COLUMN_NAME_Y);
      yData=scale(value,maxAbsolute);
      modified=true;
    }
    if (modified) {
      Integer rId=e.getKey();
      Record newR=new Record(xData,yData,r.getYPredicted(),r.getYPredictedProbabilities());
      newData._unsafe_set(rId,newR);
    }
  }
);
}","/** 
 * {@inheritDoc} 
 */
@Override protected void _transform(Dataframe newData){
  ModelParameters modelParameters=knowledgeBase.getModelParameters();
  Map<Object,Double> maxAbsoluteColumnValues=modelParameters.getMaxAbsoluteColumnValues();
  boolean scaleResponse=knowledgeBase.getTrainingParameters().getScaleResponse() && maxAbsoluteColumnValues.containsKey(Dataframe.COLUMN_NAME_Y);
  streamExecutor.forEach(StreamMethods.stream(newData.entries(),isParallelized()),e -> {
    Record r=e.getValue();
    AssociativeArray xData=r.getX().copy();
    Object yData=r.getY();
    boolean modified=false;
    for (    Map.Entry<Object,Object> entry : xData.entrySet()) {
      Object value=entry.getValue();
      if (value == null) {
        continue;
      }
      Object column=entry.getKey();
      Double maxAbsolute=maxAbsoluteColumnValues.get(column);
      if (maxAbsolute == null) {
        continue;
      }
      xData.put(column,scale(TypeInference.toDouble(value),maxAbsolute));
      modified=true;
    }
    if (scaleResponse && yData != null) {
      Double value=TypeInference.toDouble(yData);
      Double maxAbsolute=maxAbsoluteColumnValues.get(Dataframe.COLUMN_NAME_Y);
      yData=scale(value,maxAbsolute);
      modified=true;
    }
    if (modified) {
      Integer rId=e.getKey();
      Record newR=new Record(xData,yData,r.getYPredicted(),r.getYPredictedProbabilities());
      newData._unsafe_set(rId,newR);
    }
  }
);
}"
54668,"/** 
 * {@inheritDoc} 
 */
@Override protected void _transform(Dataframe newData){
  ModelParameters modelParameters=knowledgeBase.getModelParameters();
  Map<Object,Double> minColumnValues=modelParameters.getMinColumnValues();
  Map<Object,Double> maxColumnValues=modelParameters.getMaxColumnValues();
  boolean scaleResponse=knowledgeBase.getTrainingParameters().getScaleResponse() && minColumnValues.containsKey(Dataframe.COLUMN_NAME_Y);
  streamExecutor.forEach(StreamMethods.stream(newData.entries(),isParallelized()),e -> {
    Record r=e.getValue();
    AssociativeArray xData=r.getX().copy();
    Object yData=r.getY();
    boolean modified=false;
    for (    Map.Entry<Object,Double> entry : minColumnValues.entrySet()) {
      Object column=entry.getKey();
      Double value=xData.getDouble(column);
      if (value == null) {
        continue;
      }
      Double min=entry.getValue();
      Double max=maxColumnValues.get(column);
      xData.put(column,scale(value,min,max));
      modified=true;
    }
    if (scaleResponse && yData != null) {
      Double value=TypeInference.toDouble(yData);
      Double min=minColumnValues.get(Dataframe.COLUMN_NAME_Y);
      Double max=maxColumnValues.get(Dataframe.COLUMN_NAME_Y);
      yData=scale(value,min,max);
      modified=true;
    }
    if (modified) {
      Integer rId=e.getKey();
      Record newR=new Record(xData,yData,r.getYPredicted(),r.getYPredictedProbabilities());
      newData._unsafe_set(rId,newR);
    }
  }
);
}","/** 
 * {@inheritDoc} 
 */
@Override protected void _transform(Dataframe newData){
  ModelParameters modelParameters=knowledgeBase.getModelParameters();
  Map<Object,Double> minColumnValues=modelParameters.getMinColumnValues();
  Map<Object,Double> maxColumnValues=modelParameters.getMaxColumnValues();
  boolean scaleResponse=knowledgeBase.getTrainingParameters().getScaleResponse() && minColumnValues.containsKey(Dataframe.COLUMN_NAME_Y);
  streamExecutor.forEach(StreamMethods.stream(newData.entries(),isParallelized()),e -> {
    Record r=e.getValue();
    AssociativeArray xData=r.getX().copy();
    Object yData=r.getY();
    boolean modified=false;
    for (    Map.Entry<Object,Object> entry : xData.entrySet()) {
      Object value=entry.getValue();
      if (value == null) {
        continue;
      }
      Object column=entry.getKey();
      Double min=minColumnValues.get(column);
      if (min == null) {
        continue;
      }
      Double max=maxColumnValues.get(column);
      xData.put(column,scale(TypeInference.toDouble(value),min,max));
      modified=true;
    }
    if (scaleResponse && yData != null) {
      Double value=TypeInference.toDouble(yData);
      Double min=minColumnValues.get(Dataframe.COLUMN_NAME_Y);
      Double max=maxColumnValues.get(Dataframe.COLUMN_NAME_Y);
      yData=scale(value,min,max);
      modified=true;
    }
    if (modified) {
      Integer rId=e.getKey();
      Record newR=new Record(xData,yData,r.getYPredicted(),r.getYPredictedProbabilities());
      newData._unsafe_set(rId,newR);
    }
  }
);
}"
54669,"/** 
 * {@inheritDoc} 
 */
@Override protected void _transform(Dataframe newData){
  ModelParameters modelParameters=knowledgeBase.getModelParameters();
  Map<Object,Double> meanColumnValues=modelParameters.getMeanColumnValues();
  Map<Object,Double> stdColumnValues=modelParameters.getStdColumnValues();
  boolean scaleResponse=knowledgeBase.getTrainingParameters().getScaleResponse() && meanColumnValues.containsKey(Dataframe.COLUMN_NAME_Y);
  streamExecutor.forEach(StreamMethods.stream(newData.entries(),isParallelized()),e -> {
    Record r=e.getValue();
    AssociativeArray xData=r.getX().copy();
    Object yData=r.getY();
    boolean modified=false;
    for (    Map.Entry<Object,Double> entry : meanColumnValues.entrySet()) {
      Object column=entry.getKey();
      Double value=xData.getDouble(column);
      if (value == null) {
        continue;
      }
      Double mean=entry.getValue();
      Double std=stdColumnValues.get(column);
      xData.put(column,scale(value,mean,std));
      modified=true;
    }
    if (scaleResponse && yData != null) {
      Double value=TypeInference.toDouble(yData);
      Double mean=meanColumnValues.get(Dataframe.COLUMN_NAME_Y);
      Double std=stdColumnValues.get(Dataframe.COLUMN_NAME_Y);
      yData=scale(value,mean,std);
      modified=true;
    }
    if (modified) {
      Integer rId=e.getKey();
      Record newR=new Record(xData,yData,r.getYPredicted(),r.getYPredictedProbabilities());
      newData._unsafe_set(rId,newR);
    }
  }
);
}","/** 
 * {@inheritDoc} 
 */
@Override protected void _transform(Dataframe newData){
  ModelParameters modelParameters=knowledgeBase.getModelParameters();
  Map<Object,Double> meanColumnValues=modelParameters.getMeanColumnValues();
  Map<Object,Double> stdColumnValues=modelParameters.getStdColumnValues();
  boolean scaleResponse=knowledgeBase.getTrainingParameters().getScaleResponse() && meanColumnValues.containsKey(Dataframe.COLUMN_NAME_Y);
  streamExecutor.forEach(StreamMethods.stream(newData.entries(),isParallelized()),e -> {
    Record r=e.getValue();
    AssociativeArray xData=r.getX().copy();
    Object yData=r.getY();
    boolean modified=false;
    for (    Map.Entry<Object,Object> entry : xData.entrySet()) {
      Object value=entry.getValue();
      if (value == null) {
        continue;
      }
      Object column=entry.getKey();
      Double mean=meanColumnValues.get(column);
      if (mean == null) {
        continue;
      }
      Double std=stdColumnValues.get(column);
      xData.put(column,scale(TypeInference.toDouble(value),mean,std));
      modified=true;
    }
    if (scaleResponse && yData != null) {
      Double value=TypeInference.toDouble(yData);
      Double mean=meanColumnValues.get(Dataframe.COLUMN_NAME_Y);
      Double std=stdColumnValues.get(Dataframe.COLUMN_NAME_Y);
      yData=scale(value,mean,std);
      modified=true;
    }
    if (modified) {
      Integer rId=e.getKey();
      Record newR=new Record(xData,yData,r.getYPredicted(),r.getYPredictedProbabilities());
      newData._unsafe_set(rId,newR);
    }
  }
);
}"
54670,"/** 
 * {@inheritDoc} 
 */
@Override protected void add(Record r){
  RealVector rv=MatrixDataframe.parseRecord(r,featureIds);
  if (size == 0) {
    xi_sum=rv;
    xi_square_sum=rv.outerProduct(rv);
  }
 else {
    xi_sum=xi_sum.add(rv);
    xi_square_sum=xi_square_sum.add(rv.outerProduct(rv));
  }
  size++;
  updateClusterParameters();
}","/** 
 * {@inheritDoc} 
 */
@Override protected void add(Record r){
  RealVector rv=MatrixDataframe.parseRecord(r,featureIds);
  if (size == 0) {
    xi_sum=rv;
    int n=rv.getDimension();
    xi_square_sum=new BlockRealMatrix(n,n).add(rv.outerProduct(rv));
  }
 else {
    xi_sum=xi_sum.add(rv);
    xi_square_sum=xi_square_sum.add(rv.outerProduct(rv));
  }
  size++;
  updateClusterParameters();
}"
54671,"/** 
 * This method is called before serializing the objects. It extracts all the not-serializable BigMap references of the provided object and stores them in a Map. Then it replaces all the references of the provided object with nulls to avoid their serialization. The main idea is that we temporarily remove from the object any reference that will cause problems during the serialization phase.
 * @param serializableObject
 * @param < T >
 * @return
 */
protected <T extends Serializable>Map<String,Object> preSerializer(T serializableObject){
  Map<String,Object> objReferences=new HashMap<>();
  for (  Field field : ReflectionMethods.getAllFields(new LinkedList<>(),serializableObject.getClass())) {
    if (field.isAnnotationPresent(BigMap.class) && !Serializable.class.isAssignableFrom(field.getDeclaringClass())) {
      field.setAccessible(true);
      try {
        objReferences.put(field.getName(),field.get(serializableObject));
        field.set(serializableObject,null);
      }
 catch (      IllegalArgumentException|IllegalAccessException ex) {
        throw new RuntimeException(ex);
      }
    }
  }
  return objReferences;
}","/** 
 * This method is called before serializing the objects. It extracts all the not-serializable BigMap references of the provided object and stores them in a Map. Then it replaces all the references of the provided object with nulls to avoid their serialization. The main idea is that we temporarily remove from the object any reference that will cause problems during the serialization phase.
 * @param serializableObject
 * @param < T >
 * @return
 */
protected <T extends Serializable>Map<String,Object> preSerializer(T serializableObject){
  Map<String,Object> objReferences=new HashMap<>();
  for (  Field field : ReflectionMethods.getAllFields(new LinkedList<>(),serializableObject.getClass())) {
    if (field.isAnnotationPresent(BigMap.class)) {
      field.setAccessible(true);
      try {
        Object value=field.get(serializableObject);
        if (!Serializable.class.isAssignableFrom(value.getClass())) {
          objReferences.put(field.getName(),value);
          field.set(serializableObject,null);
        }
      }
 catch (      IllegalArgumentException|IllegalAccessException ex) {
        throw new RuntimeException(ex);
      }
    }
  }
  return objReferences;
}"
54672,"/** 
 * {@inheritDoc} 
 */
@Override public <K,V>Map<K,V> getBigMap(String name,DatabaseConnector.MapType type,DatabaseConnector.StorageHint storageHint,boolean isConcurrent,boolean isTemporary){
  assertConnectionOpen();
  if (storageHint == DatabaseConnector.StorageHint.IN_MEMORY && dbConf.isHybridized()) {
    if (DatabaseConnector.MapType.HASHMAP.equals(type)) {
      return isConcurrent ? new ConcurrentHashMap<>() : new HashMap<>();
    }
 else     if (DatabaseConnector.MapType.TREEMAP.equals(type)) {
      return isConcurrent ? new ConcurrentSkipListMap<>() : new TreeMap<>();
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
 else {
    DBType dbType=getDatabaseTypeFromName(name);
    if (dbType == null) {
      if (isTemporary == false) {
        dbType=DBType.PRIMARY_DB;
      }
 else {
        if (storageHint == DatabaseConnector.StorageHint.IN_MEMORY || storageHint == DatabaseConnector.StorageHint.IN_CACHE) {
          dbType=DBType.TEMP_DB_CACHED;
        }
 else         if (storageHint == DatabaseConnector.StorageHint.IN_DISK) {
          dbType=DBType.TEMP_DB_UNCACHED;
        }
 else {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
      }
    }
    DB db=openDB(dbType);
    if (DatabaseConnector.MapType.HASHMAP.equals(type)) {
      return db.createHashMap(name).counterEnable().makeOrGet();
    }
 else     if (DatabaseConnector.MapType.TREEMAP.equals(type)) {
      return db.createTreeMap(name).valuesOutsideNodesEnable().counterEnable().makeOrGet();
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
}","/** 
 * {@inheritDoc} 
 */
@Override public <K,V>Map<K,V> getBigMap(String name,DatabaseConnector.MapType type,DatabaseConnector.StorageHint storageHint,boolean isConcurrent,boolean isTemporary){
  assertConnectionOpen();
  if (storageHint == DatabaseConnector.StorageHint.IN_MEMORY && dbConf.isHybridized()) {
    if (DatabaseConnector.MapType.HASHMAP.equals(type)) {
      return isConcurrent ? new ConcurrentHashMap<>() : new HashMap<>();
    }
 else     if (DatabaseConnector.MapType.TREEMAP.equals(type)) {
      return isConcurrent ? new ConcurrentSkipListMap<>() : new TreeMap<>();
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
 else {
    DBType dbType=getDatabaseTypeFromName(name);
    if (dbType == null) {
      if (isTemporary == false) {
        dbType=DBType.PRIMARY_DB;
      }
 else {
        if (storageHint == DatabaseConnector.StorageHint.IN_MEMORY || storageHint == DatabaseConnector.StorageHint.IN_CACHE) {
          dbType=DBType.TEMP_DB_CACHED;
        }
 else         if (storageHint == DatabaseConnector.StorageHint.IN_DISK) {
          dbType=DBType.TEMP_DB_UNCACHED;
        }
 else {
          throw new IllegalArgumentException(""String_Node_Str"");
        }
      }
    }
    DB db=openDB(dbType);
    Map<K,V> map;
    if (DatabaseConnector.MapType.HASHMAP.equals(type)) {
      map=db.createHashMap(name).counterEnable().makeOrGet();
    }
 else     if (DatabaseConnector.MapType.TREEMAP.equals(type)) {
      map=db.createTreeMap(name).valuesOutsideNodesEnable().counterEnable().makeOrGet();
      if (isConcurrent) {
        map=Collections.synchronizedMap(map);
      }
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    return map;
  }
}"
54673,"/** 
 * Opens the DB (if not already open) and returns the DB object.
 * @param dbType
 * @return 
 */
private DB openDB(DBType dbType){
  DB db=dbRegistry.get(dbType);
  if (!isOpenDB(db)) {
    DBMaker m;
    boolean permitCaching=true;
    if (dbType == DBType.PRIMARY_DB) {
      m=DBMaker.newFileDB(getDefaultPath().toFile());
    }
 else     if (dbType == DBType.TEMP_DB_CACHED || dbType == DBType.TEMP_DB_UNCACHED) {
      m=DBMaker.newTempFileDB().deleteFilesAfterClose();
      if (dbType == DBType.TEMP_DB_UNCACHED) {
        permitCaching=false;
      }
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (dbConf.isCompressed()) {
      m=m.compressionEnable();
    }
    if (permitCaching && dbConf.getCacheSize() > 0) {
      m=m.cacheLRUEnable().cacheSize(dbConf.getCacheSize());
    }
 else {
      m=m.cacheDisable();
    }
    m=m.transactionDisable();
    m=m.asyncWriteEnable();
    m=m.closeOnJvmShutdown();
    db=m.make();
    dbRegistry.put(dbType,db);
  }
  return db;
}","/** 
 * Opens the DB (if not already open) and returns the DB object.
 * @param dbType
 * @return 
 */
private DB openDB(DBType dbType){
  DB db=dbRegistry.get(dbType);
  if (!isOpenDB(db)) {
    DBMaker m;
    boolean permitCaching=true;
    if (dbType == DBType.PRIMARY_DB) {
      m=DBMaker.newFileDB(getDefaultPath().toFile());
    }
 else     if (dbType == DBType.TEMP_DB_CACHED || dbType == DBType.TEMP_DB_UNCACHED) {
      m=DBMaker.newTempFileDB().deleteFilesAfterClose();
      if (dbType == DBType.TEMP_DB_UNCACHED) {
        permitCaching=false;
      }
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (dbConf.isCompressed()) {
      m=m.compressionEnable();
    }
    if (permitCaching && dbConf.getCacheSize() > 0) {
      m=m.cacheLRUEnable().cacheSize(dbConf.getCacheSize());
    }
 else {
      m=m.cacheDisable();
    }
    m=m.transactionDisable();
    if (SynchronizedBlocks.WITHOUT_SYNCHRONIZED.isActivated()) {
    }
 else {
      m=m.asyncWriteEnable();
    }
    m=m.closeOnJvmShutdown();
    db=m.make();
    dbRegistry.put(dbType,db);
  }
  return db;
}"
54674,"/** 
 * {@inheritDoc} 
 */
@Override protected void _fit(Dataframe trainingData){
  ModelParameters modelParameters=kb().getModelParameters();
  int n=modelParameters.getN();
  int d=modelParameters.getD();
  kb().getTrainingParameters().setMultiProbabilityWeighted(false);
  Map<List<Object>,Double> likelihoods=modelParameters.getLogLikelihoods();
  Map<Object,Double> logPriors=modelParameters.getLogPriors();
  Set<Object> classesSet=modelParameters.getClasses();
  Map<Object,Double> sumOfLog1minusProb=modelParameters.getSumOfLog1minusProb();
  DatabaseConnector dbc=kb().getDbc();
  Map<Object,Integer> totalFeatureOccurrencesForEachClass=dbc.getBigMap(""String_Node_Str"",MapType.HASHMAP,StorageHint.IN_MEMORY,false,true);
  for (  Record r : trainingData) {
    Object theClass=r.getY();
    if (classesSet.add(theClass)) {
      logPriors.put(theClass,1.0);
      totalFeatureOccurrencesForEachClass.put(theClass,0);
      sumOfLog1minusProb.put(theClass,0.0);
    }
 else {
      logPriors.put(theClass,logPriors.get(theClass) + 1.0);
    }
  }
  streamExecutor.forEach(StreamMethods.stream(trainingData.getXDataTypes().keySet().stream(),isParallelized()),feature -> {
    for (    Object theClass : classesSet) {
      List<Object> featureClassTuple=Arrays.<Object>asList(feature,theClass);
      likelihoods.put(featureClassTuple,0.0);
    }
  }
);
  for (  Record r : trainingData) {
    Object theClass=r.getY();
    double sumOfOccurrences=streamExecutor.sum(StreamMethods.stream(r.getX().entrySet().stream(),isParallelized()).mapToDouble(entry -> {
      Object feature=entry.getKey();
      Double occurrences=TypeInference.toDouble(entry.getValue());
      if (occurrences != null && occurrences > 0.0) {
        List<Object> featureClassTuple=Arrays.<Object>asList(feature,theClass);
        likelihoods.put(featureClassTuple,likelihoods.get(featureClassTuple) + 1.0);
        return 1.0;
      }
      return 0.0;
    }
));
    totalFeatureOccurrencesForEachClass.put(theClass,totalFeatureOccurrencesForEachClass.get(theClass) + (int)sumOfOccurrences);
  }
  for (  Map.Entry<Object,Double> entry : logPriors.entrySet()) {
    Object theClass=entry.getKey();
    Double count=entry.getValue();
    logPriors.put(theClass,Math.log(count / n));
  }
  streamExecutor.forEach(StreamMethods.stream(likelihoods.entrySet().stream(),isParallelized()),entry -> {
    List<Object> featureClassTuple=entry.getKey();
    Object theClass=featureClassTuple.get(1);
    Double occurrences=entry.getValue();
    if (occurrences == null) {
      occurrences=0.0;
    }
    Double smoothedProbability=(occurrences + 1.0) / (totalFeatureOccurrencesForEachClass.get(theClass) + d);
    likelihoods.put(featureClassTuple,smoothedProbability);
    double log1minusP=Math.log(1.0 - smoothedProbability);
synchronized (sumOfLog1minusProb) {
      sumOfLog1minusProb.put(theClass,sumOfLog1minusProb.get(theClass) + log1minusP);
    }
  }
);
  dbc.dropBigMap(""String_Node_Str"",totalFeatureOccurrencesForEachClass);
}","/** 
 * {@inheritDoc} 
 */
@Override protected void _fit(Dataframe trainingData){
  ModelParameters modelParameters=kb().getModelParameters();
  int n=modelParameters.getN();
  int d=modelParameters.getD();
  kb().getTrainingParameters().setMultiProbabilityWeighted(false);
  Map<List<Object>,Double> likelihoods=modelParameters.getLogLikelihoods();
  Map<Object,Double> logPriors=modelParameters.getLogPriors();
  Set<Object> classesSet=modelParameters.getClasses();
  Map<Object,Double> sumOfLog1minusProb=modelParameters.getSumOfLog1minusProb();
  DatabaseConnector dbc=kb().getDbc();
  Map<Object,Integer> totalFeatureOccurrencesForEachClass=dbc.getBigMap(""String_Node_Str"",MapType.HASHMAP,StorageHint.IN_MEMORY,false,true);
  for (  Record r : trainingData) {
    Object theClass=r.getY();
    if (classesSet.add(theClass)) {
      logPriors.put(theClass,1.0);
      totalFeatureOccurrencesForEachClass.put(theClass,0);
      sumOfLog1minusProb.put(theClass,0.0);
    }
 else {
      logPriors.put(theClass,logPriors.get(theClass) + 1.0);
    }
  }
  streamExecutor.forEach(StreamMethods.stream(trainingData.getXDataTypes().keySet().stream(),isParallelized()),feature -> {
    for (    Object theClass : classesSet) {
      List<Object> featureClassTuple=Arrays.<Object>asList(feature,theClass);
      likelihoods.put(featureClassTuple,0.0);
    }
  }
);
  for (  Record r : trainingData) {
    Object theClass=r.getY();
    double sumOfOccurrences=streamExecutor.sum(StreamMethods.stream(r.getX().entrySet().stream(),isParallelized()).mapToDouble(entry -> {
      Object feature=entry.getKey();
      Double occurrences=TypeInference.toDouble(entry.getValue());
      if (occurrences != null && occurrences > 0.0) {
        List<Object> featureClassTuple=Arrays.<Object>asList(feature,theClass);
        likelihoods.put(featureClassTuple,likelihoods.get(featureClassTuple) + 1.0);
        return 1.0;
      }
      return 0.0;
    }
));
    totalFeatureOccurrencesForEachClass.put(theClass,totalFeatureOccurrencesForEachClass.get(theClass) + (int)sumOfOccurrences);
  }
  for (  Map.Entry<Object,Double> entry : logPriors.entrySet()) {
    Object theClass=entry.getKey();
    Double count=entry.getValue();
    logPriors.put(theClass,Math.log(count / n));
  }
  for (  Object theClass : classesSet) {
    double sumLog1minusP=streamExecutor.sum(StreamMethods.stream(trainingData.getXDataTypes().keySet().stream(),isParallelized()).mapToDouble(feature -> {
      List<Object> featureClassTuple=Arrays.<Object>asList(feature,theClass);
      Double occurrences=likelihoods.get(featureClassTuple);
      if (occurrences == null) {
        occurrences=0.0;
      }
      Double smoothedProbability=(occurrences + 1.0) / (totalFeatureOccurrencesForEachClass.get(theClass) + d);
      likelihoods.put(featureClassTuple,smoothedProbability);
      double log1minusP=Math.log(1.0 - smoothedProbability);
      return log1minusP;
    }
));
    sumOfLog1minusProb.put(theClass,sumOfLog1minusProb.get(theClass) + sumLog1minusP);
  }
  dbc.dropBigMap(""String_Node_Str"",totalFeatureOccurrencesForEachClass);
}"
54675,"private void batchGradientDescent(Dataframe trainingData,Map<Object,Object> previousThitaMapping,Map<Object,Double> newWeights,Map<Object,Double> newThitas,double learningRate){
  ModelParameters modelParameters=kb().getModelParameters();
  double multiplier=-learningRate / modelParameters.getN();
  Map<Object,Double> weights=modelParameters.getWeights();
  Map<Object,Double> thitas=modelParameters.getThitas();
  streamExecutor.forEach(StreamMethods.stream(trainingData.stream(),isParallelized()),r -> {
    Object rClass=r.getY();
    Object rPreviousClass=previousThitaMapping.get(rClass);
    double xTw=xTw(r.getX(),weights);
    double gOfCurrent=g(xTw - thitas.get(rClass));
    double gOfPrevious=0.0;
    if (rPreviousClass != null) {
      gOfPrevious=g(thitas.get(rPreviousClass) - xTw);
    }
    double dtG_multiplier=(gOfCurrent - gOfPrevious) * multiplier;
synchronized (newWeights) {
      for (      Map.Entry<Object,Object> entry : r.getX().entrySet()) {
        Object column=entry.getKey();
        Double xij=TypeInference.toDouble(entry.getValue());
        newWeights.put(column,newWeights.get(column) + xij * dtG_multiplier);
      }
    }
synchronized (newThitas) {
      newThitas.put(rClass,newThitas.get(rClass) + multiplier * (-gOfCurrent));
      if (rPreviousClass != null) {
        newThitas.put(rPreviousClass,newThitas.get(rPreviousClass) + multiplier * gOfPrevious);
      }
    }
  }
);
}","private void batchGradientDescent(Dataframe trainingData,Map<Object,Object> previousThitaMapping,Map<Object,Double> newWeights,Map<Object,Double> newThitas,double learningRate){
  ModelParameters modelParameters=kb().getModelParameters();
  double multiplier=-learningRate / modelParameters.getN();
  Map<Object,Double> weights=modelParameters.getWeights();
  Map<Object,Double> thitas=modelParameters.getThitas();
  streamExecutor.forEach(StreamMethods.stream(trainingData.stream(),isParallelized()),r -> {
    Object rClass=r.getY();
    Object rPreviousClass=previousThitaMapping.get(rClass);
    double xTw=xTw(r.getX(),weights);
    double gOfCurrent=g(xTw - thitas.get(rClass));
    double gOfPrevious=0.0;
    if (rPreviousClass != null) {
      gOfPrevious=g(thitas.get(rPreviousClass) - xTw);
    }
    double dtG_multiplier=(gOfCurrent - gOfPrevious) * multiplier;
    for (    Map.Entry<Object,Object> entry : r.getX().entrySet()) {
      Object column=entry.getKey();
      Double xij=TypeInference.toDouble(entry.getValue());
      double xij_dtG_multiplier=xij * dtG_multiplier;
synchronized (newWeights) {
        newWeights.put(column,newWeights.get(column) + xij_dtG_multiplier);
      }
    }
synchronized (newThitas) {
      newThitas.put(rClass,newThitas.get(rClass) + multiplier * (-gOfCurrent));
      if (rPreviousClass != null) {
        newThitas.put(rPreviousClass,newThitas.get(rPreviousClass) + multiplier * gOfPrevious);
      }
    }
  }
);
}"
54676,"private void batchGradientDescent(Dataframe trainingData,Map<List<Object>,Double> newThitas,double learningRate){
  ModelParameters modelParameters=kb().getModelParameters();
  double multiplier=learningRate / modelParameters.getN();
  Map<List<Object>,Double> thitas=modelParameters.getThitas();
  Set<Object> classesSet=modelParameters.getClasses();
  streamExecutor.forEach(StreamMethods.stream(trainingData.stream(),isParallelized()),r -> {
    AssociativeArray classProbabilities=hypothesisFunction(r.getX(),thitas);
    for (    Object theClass : classesSet) {
      double error;
      double score=classProbabilities.getDouble(theClass);
      if (r.getY().equals(theClass)) {
        error=1 - score;
      }
 else {
        error=-score;
      }
      double errorMultiplier=multiplier * error;
synchronized (newThitas) {
        List<Object> featureClassTuple=Arrays.<Object>asList(Dataframe.COLUMN_NAME_CONSTANT,theClass);
        newThitas.put(featureClassTuple,newThitas.get(featureClassTuple) + errorMultiplier);
        for (        Map.Entry<Object,Object> entry : r.getX().entrySet()) {
          Double value=TypeInference.toDouble(entry.getValue());
          Object feature=entry.getKey();
          featureClassTuple=Arrays.<Object>asList(feature,theClass);
          Double thitaWeight=newThitas.get(featureClassTuple);
          if (thitaWeight != null) {
            newThitas.put(featureClassTuple,thitaWeight + errorMultiplier * value);
          }
        }
      }
    }
  }
);
}","private void batchGradientDescent(Dataframe trainingData,Map<List<Object>,Double> newThitas,double learningRate){
  ModelParameters modelParameters=kb().getModelParameters();
  double multiplier=learningRate / modelParameters.getN();
  Map<List<Object>,Double> thitas=modelParameters.getThitas();
  Set<Object> classesSet=modelParameters.getClasses();
  streamExecutor.forEach(StreamMethods.stream(trainingData.stream(),isParallelized()),r -> {
    AssociativeArray classProbabilities=hypothesisFunction(r.getX(),thitas);
    for (    Object theClass : classesSet) {
      double error;
      double score=classProbabilities.getDouble(theClass);
      if (r.getY().equals(theClass)) {
        error=1 - score;
      }
 else {
        error=-score;
      }
      double errorMultiplier=multiplier * error;
      List<Object> featureClassTuple=Arrays.<Object>asList(Dataframe.COLUMN_NAME_CONSTANT,theClass);
synchronized (newThitas) {
        newThitas.put(featureClassTuple,newThitas.get(featureClassTuple) + errorMultiplier);
      }
      for (      Map.Entry<Object,Object> entry : r.getX().entrySet()) {
        Double value=TypeInference.toDouble(entry.getValue());
        Object feature=entry.getKey();
        featureClassTuple=Arrays.<Object>asList(feature,theClass);
synchronized (newThitas) {
          newThitas.put(featureClassTuple,newThitas.get(featureClassTuple) + errorMultiplier * value);
        }
      }
    }
  }
);
}"
54677,"private double hypothesisFunction(AssociativeArray x,Map<Object,Double> thitas){
  double sum=thitas.get(Dataframe.COLUMN_NAME_CONSTANT);
  for (  Map.Entry<Object,Object> entry : x.entrySet()) {
    Object feature=entry.getKey();
    Double thitaWeight=thitas.get(feature);
    if (thitaWeight != null) {
      Double xj=TypeInference.toDouble(entry.getValue());
      sum+=thitaWeight * xj;
    }
  }
  return sum;
}","private double hypothesisFunction(AssociativeArray x,Map<Object,Double> thitas){
  double sum=thitas.get(Dataframe.COLUMN_NAME_CONSTANT);
  for (  Map.Entry<Object,Object> entry : x.entrySet()) {
    Object feature=entry.getKey();
    Double xj=TypeInference.toDouble(entry.getValue());
    sum+=thitas.get(feature) * xj;
  }
  return sum;
}"
54678,"private void batchGradientDescent(Dataframe trainingData,Map<Object,Double> newThitas,double learningRate){
  ModelParameters modelParameters=kb().getModelParameters();
  double multiplier=learningRate / modelParameters.getN();
  Map<Object,Double> thitas=modelParameters.getThitas();
  streamExecutor.forEach(StreamMethods.stream(trainingData.stream(),isParallelized()),r -> {
    double error=TypeInference.toDouble(r.getY()) - hypothesisFunction(r.getX(),thitas);
    double errorMultiplier=multiplier * error;
synchronized (newThitas) {
      newThitas.put(Dataframe.COLUMN_NAME_CONSTANT,newThitas.get(Dataframe.COLUMN_NAME_CONSTANT) + errorMultiplier);
      for (      Map.Entry<Object,Object> entry : r.getX().entrySet()) {
        Object feature=entry.getKey();
        Double thitaWeight=newThitas.get(feature);
        if (thitaWeight != null) {
          Double value=TypeInference.toDouble(entry.getValue());
          newThitas.put(feature,thitaWeight + errorMultiplier * value);
        }
      }
    }
  }
);
}","private void batchGradientDescent(Dataframe trainingData,Map<Object,Double> newThitas,double learningRate){
  ModelParameters modelParameters=kb().getModelParameters();
  double multiplier=learningRate / modelParameters.getN();
  Map<Object,Double> thitas=modelParameters.getThitas();
  streamExecutor.forEach(StreamMethods.stream(trainingData.stream(),isParallelized()),r -> {
    double error=TypeInference.toDouble(r.getY()) - hypothesisFunction(r.getX(),thitas);
    double errorMultiplier=multiplier * error;
synchronized (newThitas) {
      newThitas.put(Dataframe.COLUMN_NAME_CONSTANT,newThitas.get(Dataframe.COLUMN_NAME_CONSTANT) + errorMultiplier);
    }
    for (    Map.Entry<Object,Object> entry : r.getX().entrySet()) {
      Object feature=entry.getKey();
      Double value=TypeInference.toDouble(entry.getValue());
      double errorMultiplier_value=errorMultiplier * value;
synchronized (newThitas) {
        newThitas.put(feature,newThitas.get(feature) + errorMultiplier_value);
      }
    }
  }
);
}"
54679,"private double calculateError(Dataframe trainingData,Map<Object,Double> thitas){
  double error=streamExecutor.sum(StreamMethods.stream(trainingData.entries(),isParallelized()).mapToDouble(e -> {
    Integer rId=e.getKey();
    Record r=e.getValue();
    double yPredicted=hypothesisFunction(r.getX(),thitas);
    trainingData._unsafe_set(rId,new Record(r.getX(),r.getY(),yPredicted,r.getYPredictedProbabilities()));
    return Math.pow(TypeInference.toDouble(r.getY()) - yPredicted,2);
  }
));
  return error;
}","private double calculateError(Dataframe trainingData,Map<Object,Double> thitas){
  double error=streamExecutor.sum(StreamMethods.stream(trainingData.values(),isParallelized()).mapToDouble(r -> {
    double yPredicted=hypothesisFunction(r.getX(),thitas);
    return Math.pow(TypeInference.toDouble(r.getY()) - yPredicted,2);
  }
));
  return error;
}"
54680,"private void IIS(Dataframe trainingData,Map<List<Object>,Double> EpFj_observed,double Cmax){
  ModelParameters modelParameters=kb().getModelParameters();
  int totalIterations=kb().getTrainingParameters().getTotalIterations();
  Set<Object> classesSet=modelParameters.getClasses();
  Map<List<Object>,Double> lambdas=modelParameters.getLambdas();
  int n=modelParameters.getN();
  DatabaseConnector dbc=kb().getDbc();
  for (int iteration=0; iteration < totalIterations; ++iteration) {
    logger.debug(""String_Node_Str"",iteration);
    Map<List<Object>,Double> tmp_EpFj_model=dbc.getBigMap(""String_Node_Str"",MapType.HASHMAP,StorageHint.IN_MEMORY,true,true);
    for (    Record r : trainingData) {
      final AssociativeArray xData=r.getX();
      AssociativeArray classScores=new AssociativeArray(StreamMethods.stream(classesSet.stream(),isParallelized()).collect(Collectors.toMap(Function.identity(),theClass -> calculateClassScore(xData,theClass))));
      Descriptives.normalizeExp(classScores);
      StreamMethods.stream(classScores.entrySet().stream(),isParallelized()).forEach(entry -> {
        Object theClass=entry.getKey();
        Double score=TypeInference.toDouble(entry.getValue());
        double probabilityFraction=score / n;
        for (        Map.Entry<Object,Object> entry2 : r.getX().entrySet()) {
          Double occurrences=TypeInference.toDouble(entry2.getValue());
          if (occurrences == null || occurrences == 0.0) {
            continue;
          }
          Object feature=entry2.getKey();
          List<Object> featureClassTuple=Arrays.<Object>asList(feature,theClass);
          tmp_EpFj_model.put(featureClassTuple,tmp_EpFj_model.getOrDefault(featureClassTuple,0.0) + probabilityFraction);
        }
      }
);
    }
    AtomicBoolean infiniteValuesDetected=new AtomicBoolean(false);
    StreamMethods.stream(tmp_EpFj_model.entrySet().stream(),isParallelized()).forEach(featureClassCounts -> {
      List<Object> tp=featureClassCounts.getKey();
      Double EpFj_observed_value=EpFj_observed.get(tp);
      Double EpFj_model_value=featureClassCounts.getValue();
      if (Math.abs(EpFj_observed_value - EpFj_model_value) <= 1e-8) {
      }
 else       if (EpFj_observed_value == 0.0) {
        lambdas.put(tp,Double.NEGATIVE_INFINITY);
        infiniteValuesDetected.set(true);
      }
 else       if (EpFj_model_value == 0.0) {
        lambdas.put(tp,Double.POSITIVE_INFINITY);
        infiniteValuesDetected.set(true);
      }
 else {
        double deltaJ=Math.log(EpFj_observed_value / EpFj_model_value) / Cmax;
        double newValue=lambdas.get(tp) + deltaJ;
        lambdas.put(tp,newValue);
      }
    }
);
    if (infiniteValuesDetected.get()) {
      Double minimumNonInfiniteLambdaWeight=StreamMethods.stream(lambdas.values().stream(),isParallelized()).filter(v -> Double.isFinite(v)).min(Double::compare).get();
      Double maximumNonInfiniteLambdaWeight=StreamMethods.stream(lambdas.values().stream(),isParallelized()).filter(v -> Double.isFinite(v)).max(Double::compare).get();
      StreamMethods.stream(lambdas.entrySet().stream(),isParallelized()).filter(e -> Double.isInfinite(e.getValue())).forEach(e -> {
        List<Object> featureClass=e.getKey();
        Double value=e.getValue();
        if (value < 0.0) {
          lambdas.put(featureClass,minimumNonInfiniteLambdaWeight);
        }
 else {
          lambdas.put(featureClass,maximumNonInfiniteLambdaWeight);
        }
      }
);
    }
    dbc.dropBigMap(""String_Node_Str"",tmp_EpFj_model);
  }
}","private void IIS(Dataframe trainingData,Map<List<Object>,Double> EpFj_observed,double Cmax){
  ModelParameters modelParameters=kb().getModelParameters();
  int totalIterations=kb().getTrainingParameters().getTotalIterations();
  Set<Object> classesSet=modelParameters.getClasses();
  Map<List<Object>,Double> lambdas=modelParameters.getLambdas();
  int n=modelParameters.getN();
  DatabaseConnector dbc=kb().getDbc();
  for (int iteration=0; iteration < totalIterations; ++iteration) {
    logger.debug(""String_Node_Str"",iteration);
    Map<List<Object>,Double> tmp_EpFj_model=dbc.getBigMap(""String_Node_Str"",MapType.HASHMAP,StorageHint.IN_MEMORY,true,true);
    for (    Record r : trainingData) {
      final AssociativeArray xData=r.getX();
      AssociativeArray classScores=new AssociativeArray(StreamMethods.stream(classesSet.stream(),isParallelized()).collect(Collectors.toMap(Function.identity(),theClass -> calculateClassScore(xData,theClass))));
      Descriptives.normalizeExp(classScores);
      StreamMethods.stream(classScores.entrySet().stream(),isParallelized()).forEach(entry -> {
        Object theClass=entry.getKey();
        Double score=TypeInference.toDouble(entry.getValue());
        double probabilityFraction=score / n;
        for (        Map.Entry<Object,Object> entry2 : r.getX().entrySet()) {
          Double occurrences=TypeInference.toDouble(entry2.getValue());
          if (occurrences == null || occurrences == 0.0) {
            continue;
          }
          Object feature=entry2.getKey();
          List<Object> featureClassTuple=Arrays.<Object>asList(feature,theClass);
          tmp_EpFj_model.put(featureClassTuple,tmp_EpFj_model.getOrDefault(featureClassTuple,0.0) + probabilityFraction);
        }
      }
);
    }
    AtomicBoolean infiniteValuesDetected=new AtomicBoolean(false);
    StreamMethods.stream(tmp_EpFj_model.entrySet().stream(),isParallelized()).forEach(featureClassCounts -> {
      List<Object> tp=featureClassCounts.getKey();
      Double EpFj_observed_value=EpFj_observed.get(tp);
      Double EpFj_model_value=featureClassCounts.getValue();
      if (Math.abs(EpFj_observed_value - EpFj_model_value) <= 1e-8) {
      }
 else       if (EpFj_observed_value == 0.0) {
        lambdas.put(tp,Double.NEGATIVE_INFINITY);
        infiniteValuesDetected.set(true);
      }
 else       if (EpFj_model_value == 0.0) {
        lambdas.put(tp,Double.POSITIVE_INFINITY);
        infiniteValuesDetected.set(true);
      }
 else {
        double deltaJ=Math.log(EpFj_observed_value / EpFj_model_value) / Cmax;
        double newValue=lambdas.get(tp) + deltaJ;
        lambdas.put(tp,newValue);
      }
    }
);
    if (infiniteValuesDetected.get()) {
      Double minimumNonInfiniteLambdaWeight=StreamMethods.stream(lambdas.values().stream(),isParallelized()).filter(v -> Double.isFinite(v)).min(Double::compare).get();
      Double maximumNonInfiniteLambdaWeight=StreamMethods.stream(lambdas.values().stream(),isParallelized()).filter(v -> Double.isFinite(v)).max(Double::compare).get();
      StreamMethods.stream(lambdas.entrySet().stream(),isParallelized()).forEach(e -> {
        List<Object> featureClass=e.getKey();
        Double value=e.getValue();
        if (Double.isInfinite(value)) {
          if (value < 0.0) {
            lambdas.put(featureClass,minimumNonInfiniteLambdaWeight);
          }
 else {
            lambdas.put(featureClass,maximumNonInfiniteLambdaWeight);
          }
        }
      }
);
    }
    dbc.dropBigMap(""String_Node_Str"",tmp_EpFj_model);
  }
}"
54681,"/** 
 * {@inheritDoc} 
 */
@Override protected void updateClusterParameters(){
  int kappa_n=kappa0 + size;
  int nu=nu0 + size;
  RealVector mu=xi_sum.mapDivide(size);
  RealVector mu_mu0=mu.subtract(mu0);
  RealMatrix C=xi_square_sum.subtract((mu.outerProduct(mu)).scalarMultiply(size));
  RealMatrix psi=psi0.add(C.add((mu_mu0.outerProduct(mu_mu0)).scalarMultiply(kappa0 * size / (double)kappa_n)));
  mean=(mu0.mapMultiply(kappa0)).add(mu.mapMultiply(size)).mapDivide(kappa_n);
  covariance=psi.scalarMultiply((kappa_n + 1.0) / (kappa_n * (nu - dimensions + 1.0)));
  meanError=calculateMeanError(psi,kappa_n,nu);
  meanDf=nu - dimensions + 1;
  cache_covariance_determinant=null;
  cache_covariance_inverse=null;
}","/** 
 * {@inheritDoc} 
 */
@Override protected void updateClusterParameters(){
  int kappa_n=kappa0 + size;
  int nu=nu0 + size;
  RealVector mu=xi_sum.mapDivide(size);
  RealVector mu_mu0=mu.subtract(mu0);
  RealMatrix C=xi_square_sum.subtract((mu.outerProduct(mu)).scalarMultiply(size));
  RealMatrix psi=psi0.add(C.add((mu_mu0.outerProduct(mu_mu0)).scalarMultiply(kappa0 * size / (double)kappa_n)));
  mean=(mu0.mapMultiply(kappa0)).add(mu.mapMultiply(size)).mapDivide(kappa_n);
synchronized (this) {
    covariance=psi.scalarMultiply((kappa_n + 1.0) / (kappa_n * (nu - dimensions + 1.0)));
    cache_covariance_determinant=null;
    cache_covariance_inverse=null;
  }
  meanError=calculateMeanError(psi,kappa_n,nu);
  meanDf=nu - dimensions + 1;
}"
54682,"/** 
 * Implementation of Collapsed Gibbs Sampling algorithm.
 * @param dataset The list of points that we want to cluster
 * @param maxIterations The maximum number of iterations
 */
private int collapsedGibbsSampling(Dataframe dataset){
  AbstractModelParameters modelParameters=kb().getModelParameters();
  Map<Integer,CL> tempClusterMap=kb().getDbc().getBigMap(""String_Node_Str"",MapType.HASHMAP,StorageHint.IN_CACHE,false,true);
  tempClusterMap.putAll(modelParameters.getClusterMap());
  AbstractTrainingParameters trainingParameters=kb().getTrainingParameters();
  double alpha=trainingParameters.getAlpha();
  Integer newClusterId=tempClusterMap.size();
  if (trainingParameters.getInitializationMethod() == AbstractTrainingParameters.Initialization.ONE_CLUSTER_PER_RECORD) {
    for (    Map.Entry<Integer,Record> e : dataset.entries()) {
      Integer rId=e.getKey();
      Record r=e.getValue();
      CL cluster=createNewCluster(newClusterId);
      cluster.add(r);
      tempClusterMap.put(newClusterId,cluster);
      r=new Record(r.getX(),r.getY(),newClusterId,r.getYPredictedProbabilities());
      dataset._unsafe_set(rId,r);
      ++newClusterId;
    }
  }
 else {
    int numberOfNewClusters=(int)(Math.max(alpha,1) * Math.log(dataset.size()));
    if (numberOfNewClusters <= 0) {
      numberOfNewClusters=1;
    }
    for (int i=0; i < numberOfNewClusters; ++i) {
      CL cluster=createNewCluster(newClusterId);
      tempClusterMap.put(newClusterId,cluster);
      ++newClusterId;
    }
    int clusterMapSize=newClusterId;
    for (    Map.Entry<Integer,Record> e : dataset.entries()) {
      Integer rId=e.getKey();
      Record r=e.getValue();
      Integer assignedClusterId=PHPMethods.mt_rand(0,clusterMapSize - 1);
      r=new Record(r.getX(),r.getY(),assignedClusterId,r.getYPredictedProbabilities());
      dataset._unsafe_set(rId,r);
      CL c=getFromClusterMap(assignedClusterId,tempClusterMap);
      c.add(r);
      tempClusterMap.put(assignedClusterId,c);
    }
  }
  int n=tempClusterMap.size();
  int maxIterations=trainingParameters.getMaxIterations();
  boolean noChangeMade=false;
  int iteration=0;
  while (iteration < maxIterations && noChangeMade == false) {
    logger.debug(""String_Node_Str"",iteration);
    noChangeMade=true;
    for (    Map.Entry<Integer,Record> e : dataset.entries()) {
      Integer rId=e.getKey();
      Record r=e.getValue();
      Integer pointClusterId=(Integer)r.getYPredicted();
      CL ci=getFromClusterMap(pointClusterId,tempClusterMap);
      ci.remove(r);
      if (ci.size() == 0) {
        tempClusterMap.remove(pointClusterId);
      }
 else {
        tempClusterMap.put(pointClusterId,ci);
      }
      AssociativeArray condProbCiGivenXiAndOtherCi=clusterProbabilities(r,n,tempClusterMap);
      CL cNew=createNewCluster(newClusterId);
      double priorLogPredictive=cNew.posteriorLogPdf(r);
      double probNewCluster=alpha / (alpha + n - 1.0);
      condProbCiGivenXiAndOtherCi.put(newClusterId,priorLogPredictive + Math.log(probNewCluster));
      Descriptives.normalizeExp(condProbCiGivenXiAndOtherCi);
      Integer sampledClusterId=(Integer)SimpleRandomSampling.weightedSampling(condProbCiGivenXiAndOtherCi,1,true).iterator().next();
      if (Objects.equals(sampledClusterId,newClusterId)) {
        r=new Record(r.getX(),r.getY(),newClusterId,r.getYPredictedProbabilities());
        dataset._unsafe_set(rId,r);
        cNew.add(r);
        tempClusterMap.put(newClusterId,cNew);
        noChangeMade=false;
        ++newClusterId;
      }
 else {
        if (!Objects.equals(pointClusterId,sampledClusterId)) {
          r=new Record(r.getX(),r.getY(),sampledClusterId,r.getYPredictedProbabilities());
          dataset._unsafe_set(rId,r);
          noChangeMade=false;
        }
        CL c=getFromClusterMap(sampledClusterId,tempClusterMap);
        c.add(r);
        tempClusterMap.put(sampledClusterId,c);
      }
    }
    ++iteration;
  }
  Map<Integer,CL> clusterMap=modelParameters.getClusterMap();
  newClusterId=clusterMap.size();
  for (  CL cluster : tempClusterMap.values()) {
    clusterMap.put(newClusterId,(CL)cluster.copy2new(newClusterId));
    newClusterId++;
  }
  kb().getDbc().dropBigMap(""String_Node_Str"",tempClusterMap);
  return iteration;
}","/** 
 * Implementation of Collapsed Gibbs Sampling algorithm.
 * @param dataset The list of points that we want to cluster
 * @param maxIterations The maximum number of iterations
 */
private int collapsedGibbsSampling(Dataframe dataset){
  AbstractModelParameters modelParameters=kb().getModelParameters();
  Map<Integer,CL> tempClusterMap=kb().getDbc().getBigMap(""String_Node_Str"",MapType.HASHMAP,StorageHint.IN_CACHE,false,true);
  tempClusterMap.putAll(modelParameters.getClusterMap());
  AbstractTrainingParameters trainingParameters=kb().getTrainingParameters();
  double alpha=trainingParameters.getAlpha();
  Integer newClusterId=tempClusterMap.size();
  if (trainingParameters.getInitializationMethod() == AbstractTrainingParameters.Initialization.ONE_CLUSTER_PER_RECORD) {
    for (    Map.Entry<Integer,Record> e : dataset.entries()) {
      Integer rId=e.getKey();
      Record r=e.getValue();
      CL cluster=createNewCluster(newClusterId);
      cluster.add(r);
      tempClusterMap.put(newClusterId,cluster);
      r=new Record(r.getX(),r.getY(),newClusterId,r.getYPredictedProbabilities());
      dataset._unsafe_set(rId,r);
      ++newClusterId;
    }
  }
 else {
    int numberOfNewClusters=(int)(Math.max(alpha,1) * Math.log(dataset.size()));
    if (numberOfNewClusters <= 0) {
      numberOfNewClusters=1;
    }
    for (int i=0; i < numberOfNewClusters; ++i) {
      CL cluster=createNewCluster(newClusterId);
      tempClusterMap.put(newClusterId,cluster);
      ++newClusterId;
    }
    int clusterMapSize=newClusterId;
    for (    Map.Entry<Integer,Record> e : dataset.entries()) {
      Integer rId=e.getKey();
      Record r=e.getValue();
      Integer assignedClusterId=PHPMethods.mt_rand(0,clusterMapSize - 1);
      r=new Record(r.getX(),r.getY(),assignedClusterId,r.getYPredictedProbabilities());
      dataset._unsafe_set(rId,r);
      CL c=getFromClusterMap(assignedClusterId,tempClusterMap);
      c.add(r);
      tempClusterMap.put(assignedClusterId,c);
    }
  }
  int n=tempClusterMap.size();
  int maxIterations=trainingParameters.getMaxIterations();
  boolean noChangeMade=false;
  int iteration=0;
  while (iteration < maxIterations && noChangeMade == false) {
    logger.debug(""String_Node_Str"",iteration);
    noChangeMade=true;
    for (    Map.Entry<Integer,Record> e : dataset.entries()) {
      Integer rId=e.getKey();
      Record r=e.getValue();
      Integer pointClusterId=(Integer)r.getYPredicted();
      CL ci=getFromClusterMap(pointClusterId,tempClusterMap);
      ci.remove(r);
      if (ci.size() == 0) {
        tempClusterMap.remove(pointClusterId);
      }
 else {
        tempClusterMap.put(pointClusterId,ci);
      }
      AssociativeArray condProbCiGivenXiAndOtherCi=clusterProbabilities(r,n,tempClusterMap);
      CL cNew=createNewCluster(newClusterId);
      double priorLogPredictive=cNew.posteriorLogPdf(r);
      double probNewCluster=alpha / (alpha + n - 1.0);
      condProbCiGivenXiAndOtherCi.put(newClusterId,priorLogPredictive + Math.log(probNewCluster));
      Descriptives.normalizeExp(condProbCiGivenXiAndOtherCi);
      Integer sampledClusterId=(Integer)SimpleRandomSampling.weightedSampling(condProbCiGivenXiAndOtherCi,1,true).iterator().next();
      if (Objects.equals(sampledClusterId,newClusterId)) {
        r=new Record(r.getX(),r.getY(),newClusterId,r.getYPredictedProbabilities());
        dataset._unsafe_set(rId,r);
        cNew.add(r);
        tempClusterMap.put(newClusterId,cNew);
        noChangeMade=false;
        ++newClusterId;
      }
 else {
        if (!Objects.equals(pointClusterId,sampledClusterId)) {
          r=new Record(r.getX(),r.getY(),sampledClusterId,r.getYPredictedProbabilities());
          dataset._unsafe_set(rId,r);
          noChangeMade=false;
        }
        CL c=getFromClusterMap(sampledClusterId,tempClusterMap);
        c.add(r);
        tempClusterMap.put(sampledClusterId,c);
      }
    }
    ++iteration;
  }
  Map<Integer,CL> clusterMap=modelParameters.getClusterMap();
  int cid=clusterMap.size();
  for (  CL cluster : tempClusterMap.values()) {
    clusterMap.put(cid,(CL)cluster.copy2new(cid));
    cid++;
  }
  kb().getDbc().dropBigMap(""String_Node_Str"",tempClusterMap);
  return iteration;
}"
54683,"/** 
 * Returns the number of clusters.
 * @return 
 */
public Integer getC(){
  return clusterMap.size();
}","/** 
 * Returns the number of clusters.
 * @return 
 */
public Integer getC(){
  if (clusterMap == null) {
    return 0;
  }
  return clusterMap.size();
}"
54684,"/** 
 * {@inheritDoc} 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseModelParameters#BaseModelParameters(com.datumbox.common.persistentstorage.interfaces.DatabaseConnector) 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}"
54685,"/** 
 * {@inheritDoc} 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseModelParameters#BaseModelParameters(com.datumbox.common.persistentstorage.interfaces.DatabaseConnector) 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}"
54686,"/** 
 * {@inheritDoc} 
 */
protected InMemoryConnector(String database,InMemoryConfiguration dbConf){
  super();
  this.dbConf=dbConf;
  this.database=database;
}","/** 
 * @see com.datumbox.common.persistentstorage.AutoCloseConnector#AutoCloseConnector()   
 */
protected InMemoryConnector(String database,InMemoryConfiguration dbConf){
  super();
  this.dbConf=dbConf;
  this.database=database;
}"
54687,"/** 
 * {@inheritDoc} 
 */
protected MapDBConnector(String database,MapDBConfiguration dbConf){
  super();
  this.dbConf=dbConf;
  this.database=database;
}","/** 
 * @see com.datumbox.common.persistentstorage.AutoCloseConnector#AutoCloseConnector()   
 */
protected MapDBConnector(String database,MapDBConfiguration dbConf){
  super();
  this.dbConf=dbConf;
  this.database=database;
}"
54688,"/** 
 * {@inheritDoc} 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseModelParameters#BaseModelParameters(com.datumbox.common.persistentstorage.interfaces.DatabaseConnector) 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}"
54689,"/** 
 * {@inheritDoc} 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseModelParameters#BaseModelParameters(com.datumbox.common.persistentstorage.interfaces.DatabaseConnector) 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}"
54690,"/** 
 * {@inheritDoc} 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseModelParameters#BaseModelParameters(com.datumbox.common.persistentstorage.interfaces.DatabaseConnector) 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}"
54691,"/** 
 * {@inheritDoc} 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseModelParameters#BaseModelParameters(com.datumbox.common.persistentstorage.interfaces.DatabaseConnector) 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}"
54692,"/** 
 * {@inheritDoc} 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseModelParameters#BaseModelParameters(com.datumbox.common.persistentstorage.interfaces.DatabaseConnector) 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}"
54693,"/** 
 * {@inheritDoc} 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseModelParameters#BaseModelParameters(com.datumbox.common.persistentstorage.interfaces.DatabaseConnector) 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}"
54694,"/** 
 * {@inheritDoc} 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseModelParameters#BaseModelParameters(com.datumbox.common.persistentstorage.interfaces.DatabaseConnector) 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}"
54695,"/** 
 * {@inheritDoc} 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseModelParameters#BaseModelParameters(com.datumbox.common.persistentstorage.interfaces.DatabaseConnector) 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}"
54696,"/** 
 * {@inheritDoc} 
 */
protected Cluster(Integer clusterId){
  super(clusterId);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.mlmodels.BaseMLclusterer.Cluster
 */
protected Cluster(Integer clusterId){
  super(clusterId);
}"
54697,"/** 
 * {@inheritDoc} 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseModelParameters#BaseModelParameters(com.datumbox.common.persistentstorage.interfaces.DatabaseConnector) 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}"
54698,"/** 
 * {@inheritDoc} 
 */
protected Cluster(int clusterId){
  super(clusterId);
  centroid=new Record(new AssociativeArray(),null);
  xi_sum=new AssociativeArray();
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.mlmodels.BaseMLclusterer.Cluster 
 */
protected Cluster(int clusterId){
  super(clusterId);
  centroid=new Record(new AssociativeArray(),null);
  xi_sum=new AssociativeArray();
}"
54699,"/** 
 * {@inheritDoc} 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseModelParameters#BaseModelParameters(com.datumbox.common.persistentstorage.interfaces.DatabaseConnector) 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}"
54700,"/** 
 * {@inheritDoc} 
 */
protected Cluster(int clusterId){
  super(clusterId);
  centroid=new Record(new AssociativeArray(),null);
  xi_sum=new AssociativeArray();
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.mlmodels.BaseMLclusterer.Cluster 
 */
protected Cluster(int clusterId){
  super(clusterId);
  centroid=new Record(new AssociativeArray(),null);
  xi_sum=new AssociativeArray();
}"
54701,"/** 
 * {@inheritDoc} 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseModelParameters#BaseModelParameters(com.datumbox.common.persistentstorage.interfaces.DatabaseConnector) 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}"
54702,"/** 
 * {@inheritDoc} 
 */
protected Cluster(Integer clusterId){
  super(clusterId);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.mlmodels.BaseMLclusterer.Cluster 
 */
protected Cluster(Integer clusterId){
  super(clusterId);
}"
54703,"/** 
 * {@inheritDoc} 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseModelParameters#BaseModelParameters(com.datumbox.common.persistentstorage.interfaces.DatabaseConnector) 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}"
54704,"/** 
 * {@inheritDoc} 
 */
protected BaseBoostingBagging(String dbName,DatabaseConfiguration dbConf,Class<MP> mpClass,Class<TP> tpClass,Class<VM> vmClass){
  super(dbName,dbConf,mpClass,tpClass,vmClass,new ClassifierValidation<>());
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseTrainable#BaseTrainable(java.lang.String,com.datumbox.common.persistentstorage.interfaces.DatabaseConfiguration,java.lang.Class,java.lang.Class)  
 */
protected BaseBoostingBagging(String dbName,DatabaseConfiguration dbConf,Class<MP> mpClass,Class<TP> tpClass,Class<VM> vmClass){
  super(dbName,dbConf,mpClass,tpClass,vmClass,new ClassifierValidation<>());
}"
54705,"/** 
 * {@inheritDoc} 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseModelParameters#BaseModelParameters(com.datumbox.common.persistentstorage.interfaces.DatabaseConnector) 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}"
54706,"/** 
 * {@inheritDoc} 
 */
protected Cluster(Integer clusterId){
  super(clusterId);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.mlmodels.BaseMLclusterer.Cluster 
 */
protected Cluster(Integer clusterId){
  super(clusterId);
}"
54707,"/** 
 * {@inheritDoc} 
 */
protected BaseDPMM(String dbName,DatabaseConfiguration dbConf,Class<MP> mpClass,Class<TP> tpClass,Class<VM> vmClass){
  super(dbName,dbConf,mpClass,tpClass,vmClass,new ClustererValidation<>());
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseTrainable#BaseTrainable(java.lang.String,com.datumbox.common.persistentstorage.interfaces.DatabaseConfiguration,java.lang.Class,java.lang.Class)  
 */
protected BaseDPMM(String dbName,DatabaseConfiguration dbConf,Class<MP> mpClass,Class<TP> tpClass,Class<VM> vmClass){
  super(dbName,dbConf,mpClass,tpClass,vmClass,new ClustererValidation<>());
}"
54708,"/** 
 * {@inheritDoc} 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseModelParameters#BaseModelParameters(com.datumbox.common.persistentstorage.interfaces.DatabaseConnector) 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}"
54709,"/** 
 * {@inheritDoc} 
 */
protected BaseLinearRegression(String dbName,DatabaseConfiguration dbConf,Class<MP> mpClass,Class<TP> tpClass,Class<VM> vmClass){
  super(dbName,dbConf,mpClass,tpClass,vmClass,new LinearRegressionValidation<>());
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseTrainable#BaseTrainable(java.lang.String,com.datumbox.common.persistentstorage.interfaces.DatabaseConfiguration,java.lang.Class,java.lang.Class)  
 */
protected BaseLinearRegression(String dbName,DatabaseConfiguration dbConf,Class<MP> mpClass,Class<TP> tpClass,Class<VM> vmClass){
  super(dbName,dbConf,mpClass,tpClass,vmClass,new LinearRegressionValidation<>());
}"
54710,"/** 
 * {@inheritDoc} 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseModelParameters#BaseModelParameters(com.datumbox.common.persistentstorage.interfaces.DatabaseConnector) 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}"
54711,"/** 
 * {@inheritDoc} 
 */
protected BaseNaiveBayes(String dbName,DatabaseConfiguration dbConf,Class<MP> mpClass,Class<TP> tpClass,Class<VM> vmClass){
  super(dbName,dbConf,mpClass,tpClass,vmClass,new ClassifierValidation<>());
  isBinarized=false;
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseTrainable#BaseTrainable(java.lang.String,com.datumbox.common.persistentstorage.interfaces.DatabaseConfiguration,java.lang.Class,java.lang.Class)  
 */
protected BaseNaiveBayes(String dbName,DatabaseConfiguration dbConf,Class<MP> mpClass,Class<TP> tpClass,Class<VM> vmClass){
  super(dbName,dbConf,mpClass,tpClass,vmClass,new ClassifierValidation<>());
  isBinarized=false;
}"
54712,"/** 
 * {@inheritDoc} 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseModelParameters#BaseModelParameters(com.datumbox.common.persistentstorage.interfaces.DatabaseConnector) 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}"
54713,"/** 
 * {@inheritDoc} 
 */
protected BaseDummyMinMaxTransformer(String dbName,DatabaseConfiguration dbConf){
  super(dbName,dbConf,BaseDummyMinMaxTransformer.ModelParameters.class,BaseDummyMinMaxTransformer.TrainingParameters.class);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseTrainable#BaseTrainable(java.lang.String,com.datumbox.common.persistentstorage.interfaces.DatabaseConfiguration,java.lang.Class,java.lang.Class)  
 */
protected BaseDummyMinMaxTransformer(String dbName,DatabaseConfiguration dbConf){
  super(dbName,dbConf,BaseDummyMinMaxTransformer.ModelParameters.class,BaseDummyMinMaxTransformer.TrainingParameters.class);
}"
54714,"/** 
 * {@inheritDoc} 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseModelParameters#BaseModelParameters(com.datumbox.common.persistentstorage.interfaces.DatabaseConnector) 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}"
54715,"/** 
 * {@inheritDoc} 
 */
protected DataTransformer(String dbName,DatabaseConfiguration dbConf,Class<MP> mpClass,Class<TP> tpClass){
  super(dbName,dbConf,mpClass,tpClass);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseTrainable#BaseTrainable(java.lang.String,com.datumbox.common.persistentstorage.interfaces.DatabaseConfiguration,java.lang.Class,java.lang.Class)  
 */
protected DataTransformer(String dbName,DatabaseConfiguration dbConf,Class<MP> mpClass,Class<TP> tpClass){
  super(dbName,dbConf,mpClass,tpClass);
}"
54716,"/** 
 * {@inheritDoc} 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseModelParameters#BaseModelParameters(com.datumbox.common.persistentstorage.interfaces.DatabaseConnector) 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}"
54717,"/** 
 * {@inheritDoc} 
 */
protected CategoricalFeatureSelection(String dbName,DatabaseConfiguration dbConf,Class<MP> mpClass,Class<TP> tpClass){
  super(dbName,dbConf,mpClass,tpClass);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseTrainable#BaseTrainable(java.lang.String,com.datumbox.common.persistentstorage.interfaces.DatabaseConfiguration,java.lang.Class,java.lang.Class)  
 */
protected CategoricalFeatureSelection(String dbName,DatabaseConfiguration dbConf,Class<MP> mpClass,Class<TP> tpClass){
  super(dbName,dbConf,mpClass,tpClass);
}"
54718,"/** 
 * {@inheritDoc} 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseModelParameters#BaseModelParameters(com.datumbox.common.persistentstorage.interfaces.DatabaseConnector) 
 */
protected ModelParameters(DatabaseConnector dbc){
  super(dbc);
}"
54719,"/** 
 * {@inheritDoc} 
 */
protected ContinuousFeatureSelection(String dbName,DatabaseConfiguration dbConf,Class<MP> mpClass,Class<TP> tpClass){
  super(dbName,dbConf,mpClass,tpClass);
}","/** 
 * @see com.datumbox.framework.machinelearning.common.bases.baseobjects.BaseTrainable#BaseTrainable(java.lang.String,com.datumbox.common.persistentstorage.interfaces.DatabaseConfiguration,java.lang.Class,java.lang.Class)  
 */
protected ContinuousFeatureSelection(String dbName,DatabaseConfiguration dbConf,Class<MP> mpClass,Class<TP> tpClass){
  super(dbName,dbConf,mpClass,tpClass);
}"
54720,"/** 
 * Transforms the categorical variables into dummy (boolean) variables.
 * @param data
 * @param referenceLevels 
 */
protected static void transformDummy(Dataset data,Map<Object,Object> referenceLevels){
  Map<Object,TypeInference.DataType> columnTypes=data.getXDataTypes();
  for (  Integer rId : data) {
    Record r=data.get(rId);
    AssociativeArray xData=r.getX().copy();
    boolean modified=false;
    for (    Object column : r.getX().keySet()) {
      if (covert2dummy(columnTypes.get(column)) == false) {
        continue;
      }
      Object value=xData.get(column);
      xData.remove(column);
      modified=true;
      Object referenceLevel=referenceLevels.get(column);
      if (referenceLevel != null && !referenceLevel.equals(value)) {
        List<Object> newColumn=Arrays.<Object>asList(column,value);
        xData.put(newColumn,true);
      }
    }
    if (modified) {
      r=new Record(xData,r.getY(),r.getYPredicted(),r.getYPredictedProbabilities());
      data.set(rId,r);
    }
  }
  data.recalculateMeta();
}","/** 
 * Transforms the categorical variables into dummy (boolean) variables.
 * @param data
 * @param referenceLevels 
 */
protected static void transformDummy(Dataset data,Map<Object,Object> referenceLevels){
  Map<Object,TypeInference.DataType> columnTypes=data.getXDataTypes();
  for (  Integer rId : data) {
    Record r=data.get(rId);
    AssociativeArray xData=r.getX().copy();
    boolean modified=false;
    for (    Object column : r.getX().keySet()) {
      if (covert2dummy(columnTypes.get(column)) == false) {
        continue;
      }
      Object value=xData.get(column);
      xData.remove(column);
      modified=true;
      Object referenceLevel=referenceLevels.get(column);
      if (referenceLevel != null && !referenceLevel.equals(value)) {
        List<Object> newColumn=Arrays.<Object>asList(column,value);
        xData.put(newColumn,true);
      }
    }
    if (modified) {
      r=new Record(xData,r.getY(),r.getYPredicted(),r.getYPredictedProbabilities());
      data._set(rId,r);
    }
  }
  data.recalculateMeta();
}"
54721,"@Override protected void _denormalize(Dataset data){
  Map<Object,Double> minColumnValues=knowledgeBase.getModelParameters().getMinColumnValues();
  Map<Object,Double> maxColumnValues=knowledgeBase.getModelParameters().getMaxColumnValues();
  BaseDummyMinMaxTransformer.normalizeX(data,minColumnValues,maxColumnValues);
}","@Override protected void _denormalize(Dataset data){
  Map<Object,Double> minColumnValues=knowledgeBase.getModelParameters().getMinColumnValues();
  Map<Object,Double> maxColumnValues=knowledgeBase.getModelParameters().getMaxColumnValues();
  BaseDummyMinMaxTransformer.denormalizeX(data,minColumnValues,maxColumnValues);
}"
54722,"@Override protected void _denormalize(Dataset data){
  Map<Object,Double> minColumnValues=knowledgeBase.getModelParameters().getMinColumnValues();
  Map<Object,Double> maxColumnValues=knowledgeBase.getModelParameters().getMaxColumnValues();
  BaseDummyMinMaxTransformer.normalizeX(data,minColumnValues,maxColumnValues);
}","@Override protected void _denormalize(Dataset data){
  Map<Object,Double> minColumnValues=knowledgeBase.getModelParameters().getMinColumnValues();
  Map<Object,Double> maxColumnValues=knowledgeBase.getModelParameters().getMaxColumnValues();
  BaseDummyMinMaxTransformer.denormalizeX(data,minColumnValues,maxColumnValues);
}"
54723,"@Override public void dropDatabase(){
  if (!existsDatabase()) {
    return;
  }
  try {
    Files.delete(filepath);
  }
 catch (  IOException ex) {
    throw new RuntimeException(ex);
  }
}","@Override public void dropDatabase(){
  if (!existsDatabase()) {
    return;
  }
  try {
    Files.deleteIfExists(filepath);
  }
 catch (  IOException ex) {
    throw new RuntimeException(ex);
  }
}"
54724,"@Override public void dropDatabase(){
  if (!existsDatabase()) {
    return;
  }
  try {
    db.close();
    Files.delete(filepath);
    Files.delete(Paths.get(filepath.toString() + ""String_Node_Str""));
    Files.delete(Paths.get(filepath.toString() + ""String_Node_Str""));
  }
 catch (  IOException ex) {
    throw new RuntimeException(ex);
  }
}","@Override public void dropDatabase(){
  if (!existsDatabase()) {
    return;
  }
  try {
    if (isDBopen()) {
      db.close();
    }
    Files.deleteIfExists(filepath);
    Files.deleteIfExists(Paths.get(filepath.toString() + ""String_Node_Str""));
  }
 catch (  IOException ex) {
    throw new RuntimeException(ex);
  }
}"
54725,"@Override @SuppressWarnings(""String_Node_Str"") public <KB extends KnowledgeBase>KB load(Class<KB> klass){
  ConcurrentNavigableMap<Integer,KB> map=db.getTreeMap(""String_Node_Str"");
  KB knowledgeBaseObject=map.get(0);
  return knowledgeBaseObject;
}","@Override @SuppressWarnings(""String_Node_Str"") public <KB extends KnowledgeBase>KB load(Class<KB> klass){
  openDB();
  Atomic.Var<KB> knowledgeBaseVar=db.getAtomicVar(""String_Node_Str"");
  return knowledgeBaseVar.get();
}"
54726,"@Override public <T extends Map>void dropBigMap(String name,T map){
  map.clear();
  db.delete(name);
}","@Override public <T extends Map>void dropBigMap(String name,T map){
  map.clear();
  if (isDBopen()) {
    db.delete(name);
  }
}"
54727,"@Override public <KB extends KnowledgeBase>void save(KB knowledgeBaseObject){
  db.commit();
  db.compact();
  ConcurrentNavigableMap<Integer,KB> map=db.getTreeMap(""String_Node_Str"");
  map.put(0,knowledgeBaseObject);
  db.commit();
}","@Override public <KB extends KnowledgeBase>void save(KB knowledgeBaseObject){
  openDB();
  Atomic.Var<KB> knowledgeBaseVar=db.getAtomicVar(""String_Node_Str"");
  knowledgeBaseVar.set(knowledgeBaseObject);
  db.commit();
  db.compact();
}"
54728,"@Override public boolean existsDatabase(){
  return Files.exists(filepath) && db.exists(""String_Node_Str"");
}","@Override public boolean existsDatabase(){
  if (Files.exists(filepath) || db == null) {
    return true;
  }
  if (db.isClosed()) {
    return true;
  }
  if (db.getCatalog().size() > 0) {
    return true;
  }
  return false;
}"
54729,"@Override public <K,V>Map<K,V> getBigMap(String name){
  return db.getHashMap(name);
}","@Override public <K,V>Map<K,V> getBigMap(String name){
  openDB();
  return db.createHashMap(name).counterEnable().makeOrGet();
}"
54730,"public MapDBConnector(String database,MapDBConfiguration dbConf){
  this.dbConf=dbConf;
  String rootDbFolder=this.dbConf.getDbRootFolder();
  if (rootDbFolder.isEmpty()) {
    filepath=FileSystems.getDefault().getPath(database);
  }
 else {
    filepath=Paths.get(rootDbFolder + File.separator + database);
  }
  db=DBMaker.newFileDB(filepath.toFile()).compressionEnable().cacheSize(this.dbConf.getCacheSize()).closeOnJvmShutdown().make();
}","public MapDBConnector(String database,MapDBConfiguration dbConf){
  this.dbConf=dbConf;
  String rootDbFolder=this.dbConf.getDbRootFolder();
  if (rootDbFolder.isEmpty()) {
    filepath=FileSystems.getDefault().getPath(database);
  }
 else {
    filepath=Paths.get(rootDbFolder + File.separator + database);
  }
  openDB();
}"
54731,"private static Route attrs(final Route route,final Route[] routes,final int i){
  Map<String,Object> attrs=new HashMap<>(16);
  for (int t=i; t < routes.length; t++) {
    attrs.putAll(routes[t].attributes());
  }
  return new Route.Forwarding(route){
    @Override public Map<String,Object> attributes(){
      return attrs;
    }
  }
;
}","private static Route attrs(final Route route,final Route[] routes,final int i){
  Map<String,Object> attrs=new HashMap<>(16);
  for (int t=i; t < routes.length; t++) {
    routes[t].attributes().forEach((name,value) -> attrs.putIfAbsent(name,value));
  }
  return new Route.Forwarding(route){
    @Override public <T>T attr(    String name){
      return (T)attrs.get(name);
    }
    @Override public Map<String,Object> attributes(){
      return attrs;
    }
  }
;
}"
54732,"@SuppressWarnings(""String_Node_Str"") private static Map<String,Object> executor(final String name,final boolean daemon,final int priority,final int n,final Object value){
  Map<String,Object> options=new HashMap<>();
  options.put(""String_Node_Str"",name);
  options.put(""String_Node_Str"",daemon);
  options.put(""String_Node_Str"",priority);
  if (value instanceof Map) {
    Map<String,Object> config=(Map<String,Object>)value;
    Object rawType=config.get(""String_Node_Str"");
    if (rawType == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    String type=rawType.toString();
    options.put(""String_Node_Str"",type);
    options.put(type,config.containsKey(""String_Node_Str"") ? Integer.parseInt(config.get(""String_Node_Str"").toString()) : n);
    options.put(""String_Node_Str"",config.containsKey(""String_Node_Str"") ? Boolean.parseBoolean(config.get(""String_Node_Str"").toString()) : daemon);
    options.put(""String_Node_Str"",config.containsKey(""String_Node_Str"") ? Boolean.parseBoolean(config.get(""String_Node_Str"").toString()) : false);
    options.put(""String_Node_Str"",config.containsKey(""String_Node_Str"") ? Integer.parseInt(config.get(""String_Node_Str"").toString()) : priority);
  }
 else {
    Iterable<String> spec=Splitter.on(""String_Node_Str"").trimResults().omitEmptyStrings().split(value.toString());
    for (    String option : spec) {
      String[] opt=option.split(""String_Node_Str"");
      String optname=opt[0].trim();
      Object optvalue;
      if (optname.equals(""String_Node_Str"")) {
        optvalue=opt.length > 1 ? Boolean.parseBoolean(opt[1].trim()) : daemon;
      }
 else       if (optname.equals(""String_Node_Str"")) {
        optvalue=opt.length > 1 ? Boolean.parseBoolean(opt[1].trim()) : false;
      }
 else       if (optname.equals(""String_Node_Str"")) {
        optvalue=opt.length > 1 ? Integer.parseInt(opt[1].trim()) : priority;
      }
 else {
        optvalue=opt.length > 1 ? Integer.parseInt(opt[1].trim()) : n;
        options.put(""String_Node_Str"",optname);
      }
      options.put(optname,optvalue);
    }
  }
  return options;
}","@SuppressWarnings(""String_Node_Str"") private static Map<String,Object> executor(final String name,final boolean daemon,final int priority,final int n,final Object value){
  Map<String,Object> options=new HashMap<>();
  options.put(""String_Node_Str"",name);
  options.put(""String_Node_Str"",daemon);
  options.put(""String_Node_Str"",priority);
  if (value instanceof Map) {
    Map<String,Object> config=(Map<String,Object>)value;
    Object rawType=config.get(""String_Node_Str"");
    if (rawType == null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    String type=rawType.toString();
    options.put(""String_Node_Str"",type);
    options.put(type,config.containsKey(""String_Node_Str"") ? Integer.parseInt(config.get(""String_Node_Str"").toString()) : n);
    options.put(""String_Node_Str"",config.containsKey(""String_Node_Str"") ? Boolean.parseBoolean(config.get(""String_Node_Str"").toString()) : daemon);
    options.put(""String_Node_Str"",config.containsKey(""String_Node_Str"") && Boolean.parseBoolean(config.get(""String_Node_Str"").toString()));
    options.put(""String_Node_Str"",config.containsKey(""String_Node_Str"") ? Integer.parseInt(config.get(""String_Node_Str"").toString()) : priority);
  }
 else {
    Iterable<String> spec=Splitter.on(""String_Node_Str"").trimResults().omitEmptyStrings().split(value.toString());
    for (    String option : spec) {
      String[] opt=option.split(""String_Node_Str"");
      String optname=opt[0].trim();
      Object optvalue;
switch (optname) {
case ""String_Node_Str"":
        optvalue=opt.length > 1 ? Boolean.parseBoolean(opt[1].trim()) : daemon;
      break;
case ""String_Node_Str"":
    optvalue=opt.length > 1 && Boolean.parseBoolean(opt[1].trim());
  break;
case ""String_Node_Str"":
optvalue=opt.length > 1 ? Integer.parseInt(opt[1].trim()) : priority;
break;
default :
optvalue=opt.length > 1 ? Integer.parseInt(opt[1].trim()) : n;
options.put(""String_Node_Str"",optname);
break;
}
options.put(optname,optvalue);
}
}
return options;
}"
54733,"private static List<Map<String,Object>> executors(final ConfigValue candidate,final boolean daemon,final int priority,final int n){
  if (candidate.valueType() == ConfigValueType.STRING) {
    Map<String,Object> options=executor(""String_Node_Str"",daemon,priority,n,candidate.unwrapped());
    return ImmutableList.of(options);
  }
  ConfigObject conf=(ConfigObject)candidate;
  List<Map<String,Object>> result=new ArrayList<>();
  for (  Entry<String,ConfigValue> executor : conf.entrySet()) {
    String name=executor.getKey();
    Object value=executor.getValue().unwrapped();
    Map<String,Object> options=new HashMap<>();
    options.putAll(executor(name,daemon,priority,n,value));
    result.add(options);
  }
  return result;
}","private static List<Map<String,Object>> executors(final ConfigValue candidate,final boolean daemon,final int priority,final int n){
  if (candidate.valueType() == ConfigValueType.STRING) {
    Map<String,Object> options=executor(""String_Node_Str"",daemon,priority,n,candidate.unwrapped());
    return ImmutableList.of(options);
  }
  ConfigObject conf=(ConfigObject)candidate;
  List<Map<String,Object>> result=new ArrayList<>();
  for (  Entry<String,ConfigValue> executor : conf.entrySet()) {
    String name=executor.getKey();
    Object value=executor.getValue().unwrapped();
    Map<String,Object> options=new HashMap<>(executor(name,daemon,priority,n,value));
    result.add(options);
  }
  return result;
}"
54734,"protected void configure(final Env env,final Config conf,final Binder binder,final BiConsumer<String,Executor> callback){
  List<Map<String,Object>> executors=conf.hasPath(namespace) ? executors(conf.getValue(namespace),daemon,priority,Runtime.getRuntime().availableProcessors()) : Collections.emptyList();
  List<Entry<String,ExecutorService>> services=new ArrayList<>(executors.size());
  for (  Map<String,Object> options : executors) {
    String name=(String)options.remove(""String_Node_Str"");
    log.debug(""String_Node_Str"",name,options);
    Boolean daemon=(Boolean)options.remove(""String_Node_Str"");
    Integer priority=(Integer)options.remove(""String_Node_Str"");
    String type=String.valueOf(options.remove(""String_Node_Str""));
    Integer n=(Integer)options.remove(type);
    Throwing.Function4<String,Integer,Supplier<ThreadFactory>,Map<String,Object>,ExecutorService> factory=f.get(type);
    if (factory == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + type + ""String_Node_Str""+ f.keySet());
    }
    ExecutorService executor=factory.apply(type,n,() -> factory(name,daemon,priority),options);
    bind(binder,name,executor);
    callback.accept(name,executor);
    services.add(Maps.immutableEntry(name,executor));
  }
  services.stream().filter(it -> it.getKey().equals(""String_Node_Str"")).findFirst().ifPresent(e -> {
    bind(binder,null,e.getValue());
  }
);
  env.onStop(() -> {
    services.forEach(exec -> Try.run(() -> exec.getValue().shutdown()).onFailure(cause -> {
      log.error(""String_Node_Str"",exec.getKey(),cause);
    }
));
    services.clear();
  }
);
}","protected void configure(final Env env,final Config conf,final Binder binder,final BiConsumer<String,Executor> callback){
  List<Map<String,Object>> executors=conf.hasPath(namespace) ? executors(conf.getValue(namespace),daemon,priority,Runtime.getRuntime().availableProcessors()) : Collections.emptyList();
  List<Entry<String,ExecutorService>> services=new ArrayList<>(executors.size());
  for (  Map<String,Object> options : executors) {
    String name=(String)options.remove(""String_Node_Str"");
    log.debug(""String_Node_Str"",name,options);
    Boolean daemon=(Boolean)options.remove(""String_Node_Str"");
    Integer priority=(Integer)options.remove(""String_Node_Str"");
    String type=String.valueOf(options.remove(""String_Node_Str""));
    Integer n=(Integer)options.remove(type);
    Throwing.Function4<String,Integer,Supplier<ThreadFactory>,Map<String,Object>,ExecutorService> factory=f.get(type);
    if (factory == null) {
      throw new IllegalArgumentException(""String_Node_Str"" + type + ""String_Node_Str""+ f.keySet());
    }
    ExecutorService executor=factory.apply(type,n,() -> factory(name,daemon,priority),options);
    bind(binder,name,executor);
    callback.accept(name,executor);
    services.add(Maps.immutableEntry(name,executor));
  }
  services.stream().filter(it -> it.getKey().equals(""String_Node_Str"")).findFirst().ifPresent(e -> bind(binder,null,e.getValue()));
  env.onStop(() -> {
    services.forEach(exec -> Try.run(() -> exec.getValue().shutdown()).onFailure(cause -> log.error(""String_Node_Str"",exec.getKey(),cause)));
    services.clear();
  }
);
}"
54735,"@Override public List<String> params(final String name){
  Builder<String> builder=ImmutableList.builder();
  Deque<String> query=exchange.getQueryParameters().get(name);
  if (query != null) {
    query.stream().forEach(builder::add);
  }
  Optional.ofNullable(parseForm().get(name)).ifPresent(values -> {
    values.stream().forEach(value -> {
      if (!value.isFile()) {
        builder.add(value.getValue());
      }
    }
);
  }
);
  return builder.build();
}","@Override public List<String> params(final String name){
  Builder<String> builder=ImmutableList.builder();
  Deque<String> query=exchange.getQueryParameters().get(name);
  if (query != null) {
    query.forEach(builder::add);
  }
  Optional.ofNullable(parseForm().get(name)).ifPresent(values -> values.forEach(value -> {
    if (!value.isFile()) {
      builder.add(value.getValue());
    }
  }
));
  return builder.build();
}"
54736,"@Override public List<String> paramNames(){
  ImmutableList.Builder<String> builder=ImmutableList.<String>builder();
  builder.addAll(exchange.getQueryParameters().keySet());
  FormData formdata=parseForm();
  formdata.forEach(v -> {
    if (!formdata.getFirst(v).isFile()) {
      builder.add(v);
    }
  }
);
  return builder.build();
}","@Override public List<String> paramNames(){
  ImmutableList.Builder<String> builder=ImmutableList.builder();
  builder.addAll(exchange.getQueryParameters().keySet());
  FormData formdata=parseForm();
  formdata.forEach(v -> {
    if (!formdata.getFirst(v).isFile()) {
      builder.add(v);
    }
  }
);
  return builder.build();
}"
54737,"@Override public void end(){
  NativeWebSocket ws=exchange.getAttachment(UndertowRequest.SOCKET);
  if (ws != null) {
    try {
      Handlers.websocket((wsExchange,channel) -> {
        ((UndertowWebSocket)ws).connect(channel);
      }
).handleRequest(exchange);
    }
 catch (    Exception ex) {
      LoggerFactory.getLogger(NativeResponse.class).error(""String_Node_Str"",ex);
    }
 finally {
      exchange.removeAttachment(UndertowRequest.SOCKET);
    }
  }
  if (endExchange) {
    exchange.endExchange();
  }
}","@Override public void end(){
  NativeWebSocket ws=exchange.getAttachment(UndertowRequest.SOCKET);
  if (ws != null) {
    try {
      Handlers.websocket((wsExchange,channel) -> ((UndertowWebSocket)ws).connect(channel)).handleRequest(exchange);
    }
 catch (    Exception ex) {
      LoggerFactory.getLogger(NativeResponse.class).error(""String_Node_Str"",ex);
    }
 finally {
      exchange.removeAttachment(UndertowRequest.SOCKET);
    }
  }
  if (endExchange) {
    exchange.endExchange();
  }
}"
54738,"@SuppressWarnings(""String_Node_Str"") static Builder configure(final Config config,final Builder builder){
  Config $undertow=config.getConfig(""String_Node_Str"");
  set($undertow,""String_Node_Str"",name -> {
    int value=$undertow.getBytes(name).intValue();
    log.debug(""String_Node_Str"",value);
    builder.setBufferSize(value);
  }
);
  set($undertow,""String_Node_Str"",name -> {
    boolean value=$undertow.getBoolean(name);
    log.debug(""String_Node_Str"",value);
    builder.setDirectBuffers(value);
  }
);
  set($undertow,""String_Node_Str"",name -> {
    int value=$undertow.getInt(name);
    log.debug(""String_Node_Str"",value);
    builder.setIoThreads(value);
  }
);
  set($undertow,""String_Node_Str"",name -> {
    int value=$undertow.getInt(name);
    log.debug(""String_Node_Str"",value);
    builder.setWorkerThreads(value);
  }
);
  $undertow.getConfig(""String_Node_Str"").root().entrySet().forEach(setOption($undertow,""String_Node_Str"",(option,value) -> builder.setServerOption(option,value)));
  $undertow.getConfig(""String_Node_Str"").root().entrySet().forEach(setOption($undertow,""String_Node_Str"",(option,value) -> builder.setWorkerOption(option,value)));
  $undertow.getConfig(""String_Node_Str"").root().entrySet().forEach(setOption($undertow,""String_Node_Str"",(option,value) -> builder.setSocketOption(option,value)));
  return builder;
}","@SuppressWarnings(""String_Node_Str"") static Builder configure(final Config config,final Builder builder){
  Config $undertow=config.getConfig(""String_Node_Str"");
  set($undertow,""String_Node_Str"",name -> {
    int value=$undertow.getBytes(name).intValue();
    log.debug(""String_Node_Str"",value);
    builder.setBufferSize(value);
  }
);
  set($undertow,""String_Node_Str"",name -> {
    boolean value=$undertow.getBoolean(name);
    log.debug(""String_Node_Str"",value);
    builder.setDirectBuffers(value);
  }
);
  set($undertow,""String_Node_Str"",name -> {
    int value=$undertow.getInt(name);
    log.debug(""String_Node_Str"",value);
    builder.setIoThreads(value);
  }
);
  set($undertow,""String_Node_Str"",name -> {
    int value=$undertow.getInt(name);
    log.debug(""String_Node_Str"",value);
    builder.setWorkerThreads(value);
  }
);
  $undertow.getConfig(""String_Node_Str"").root().entrySet().forEach(setOption($undertow,""String_Node_Str"",builder::setServerOption));
  $undertow.getConfig(""String_Node_Str"").root().entrySet().forEach(setOption($undertow,""String_Node_Str"",builder::setWorkerOption));
  $undertow.getConfig(""String_Node_Str"").root().entrySet().forEach(setOption($undertow,""String_Node_Str"",builder::setSocketOption));
  return builder;
}"
54739,"@SuppressWarnings(""String_Node_Str"") private static Optional<ObservableAdapter> toAdapter(final Function<Observable,Observable> fn){
  return Optional.of(new ObservableAdapter(){
    @SuppressWarnings(""String_Node_Str"") @Override public <T>Observable<T> adapt(    final Observable<T> observable){
      return fn.apply(observable);
    }
  }
);
}","@SuppressWarnings(""String_Node_Str"") private static Optional<ObservableAdapter> toAdapter(final Function<Observable,Observable> fn){
  return Optional.of(fn::apply);
}"
54740,"@Override public void configure(final Env env,final Config config,final Binder binder){
  HibernateValidatorConfiguration configuration=byProvider(HibernateValidator.class).configure();
  if (config.hasPath(""String_Node_Str"")) {
    config.getConfig(""String_Node_Str"").root().forEach((k,v) -> {
      configuration.addProperty(""String_Node_Str"" + k,v.unwrapped().toString());
    }
);
  }
  if (configurer != null) {
    configurer.accept(configuration,config);
  }
  binder.bind(HibernateValidatorConfiguration.class).toInstance(configuration);
  binder.bind(Validator.class).toProvider(HbvFactory.class).asEagerSingleton();
  env.lifeCycle(HbvFactory.class);
  Multibinder.newSetBinder(binder,Parser.class).addBinding().toInstance(new HbvParser(predicate));
}","@Override public void configure(final Env env,final Config config,final Binder binder){
  HibernateValidatorConfiguration configuration=byProvider(HibernateValidator.class).configure();
  if (config.hasPath(""String_Node_Str"")) {
    config.getConfig(""String_Node_Str"").root().forEach((k,v) -> configuration.addProperty(""String_Node_Str"" + k,v.unwrapped().toString()));
  }
  if (configurer != null) {
    configurer.accept(configuration,config);
  }
  binder.bind(HibernateValidatorConfiguration.class).toInstance(configuration);
  binder.bind(Validator.class).toProvider(HbvFactory.class).asEagerSingleton();
  env.lifeCycle(HbvFactory.class);
  Multibinder.newSetBinder(binder,Parser.class).addBinding().toInstance(new HbvParser(predicate));
}"
54741,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override public void configure(final Env env,final Config conf,final Binder binder){
  ConnectionString cstr=Try.apply(() -> ConnectionString.parse(db)).orElseGet(() -> ConnectionString.parse(conf.getString(db)));
  ServiceKey serviceKey=env.serviceKey();
  Throwing.Function3<Class,String,Object,Void> bind=(type,name,value) -> {
    serviceKey.generate(type,name,k -> {
      binder.bind(k).toInstance(value);
    }
);
    return null;
  }
;
  Cluster.Builder builder=this.builder.get().addContactPoints(cstr.contactPoints()).withPort(cstr.port());
  if (ccbuilder != null) {
    ccbuilder.accept(builder,conf);
  }
  log.debug(""String_Node_Str"",cstr);
  Cluster cluster=builder.build();
  if (cc != null) {
    cc.accept(cluster,conf);
  }
  Configuration configuration=cluster.getConfiguration();
  CodecRegistry codecRegistry=configuration.getCodecRegistry();
  codecRegistry.register(InstantCodec.instance,LocalDateCodec.instance,LocalTimeCodec.instance);
  hierarchy(cluster.getClass(),type -> bind.apply(type,cstr.keyspace(),cluster));
  Session session=cluster.connect(cstr.keyspace());
  hierarchy(session.getClass(),type -> bind.apply(type,cstr.keyspace(),session));
  MappingManager manager=new MappingManager(session);
  bind.apply(MappingManager.class,cstr.keyspace(),manager);
  bind.apply(Datastore.class,cstr.keyspace(),new Datastore(manager));
  accesors.forEach(c -> {
    Object accessor=manager.createAccessor(c);
    binder.bind(c).toInstance(accessor);
  }
);
  env.router().map(new CassandraMapper());
  env.onStop(() -> {
    log.debug(""String_Node_Str"",cstr);
    Try.run(session::close).onFailure(x -> log.error(""String_Node_Str"",x));
    cluster.close();
    log.info(""String_Node_Str"",cstr);
  }
);
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override public void configure(final Env env,final Config conf,final Binder binder){
  ConnectionString cstr=Try.apply(() -> ConnectionString.parse(db)).orElseGet(() -> ConnectionString.parse(conf.getString(db)));
  ServiceKey serviceKey=env.serviceKey();
  Throwing.Function3<Class,String,Object,Void> bind=(type,name,value) -> {
    serviceKey.generate(type,name,k -> binder.bind(k).toInstance(value));
    return null;
  }
;
  Cluster.Builder builder=this.builder.get().addContactPoints(cstr.contactPoints()).withPort(cstr.port());
  if (ccbuilder != null) {
    ccbuilder.accept(builder,conf);
  }
  log.debug(""String_Node_Str"",cstr);
  Cluster cluster=builder.build();
  if (cc != null) {
    cc.accept(cluster,conf);
  }
  Configuration configuration=cluster.getConfiguration();
  CodecRegistry codecRegistry=configuration.getCodecRegistry();
  codecRegistry.register(InstantCodec.instance,LocalDateCodec.instance,LocalTimeCodec.instance);
  hierarchy(cluster.getClass(),type -> bind.apply(type,cstr.keyspace(),cluster));
  Session session=cluster.connect(cstr.keyspace());
  hierarchy(session.getClass(),type -> bind.apply(type,cstr.keyspace(),session));
  MappingManager manager=new MappingManager(session);
  bind.apply(MappingManager.class,cstr.keyspace(),manager);
  bind.apply(Datastore.class,cstr.keyspace(),new Datastore(manager));
  accesors.forEach(c -> {
    Object accessor=manager.createAccessor(c);
    binder.bind(c).toInstance(accessor);
  }
);
  env.router().map(new CassandraMapper());
  env.onStop(() -> {
    log.debug(""String_Node_Str"",cstr);
    Try.run(session::close).onFailure(x -> log.error(""String_Node_Str"",x));
    cluster.close();
    log.info(""String_Node_Str"",cstr);
  }
);
}"
54742,"@SuppressWarnings(""String_Node_Str"") private String toSpec(final Object spec){
  if (spec instanceof Map) {
    Map<String,Object> m=(Map<String,Object>)spec;
    return m.entrySet().stream().map(e -> e.getKey() + ""String_Node_Str"" + e.getValue()).collect(Collectors.joining(""String_Node_Str"")).toString();
  }
  return spec.toString();
}","@SuppressWarnings(""String_Node_Str"") private String toSpec(final Object spec){
  if (spec instanceof Map) {
    Map<String,Object> m=(Map<String,Object>)spec;
    return m.entrySet().stream().map(e -> e.getKey() + ""String_Node_Str"" + e.getValue()).collect(Collectors.joining(""String_Node_Str""));
  }
  return spec.toString();
}"
54743,"/** 
 * Creates a new   {@link CaffeineCache} with {@link String} and {@link Object} types as key/value.
 * @return A new {@link CaffeineCache}.
 */
public static final CaffeineCache<String,Object> newCache(){
  return new CaffeineCache<String,Object>(){
  }
;
}","/** 
 * Creates a new   {@link CaffeineCache} with {@link String} and {@link Object} types as key/value.
 * @return A new {@link CaffeineCache}.
 */
public static CaffeineCache<String,Object> newCache(){
  return new CaffeineCache<String,Object>(){
  }
;
}"
54744,"private void cacheExtensionFactory(final Config conf){
  if (conf.hasPath(""String_Node_Str"")) {
    cache.addCacheExtensionFactory(newFactory(path + ""String_Node_Str"",conf,CacheExtensionFactoryConfiguration::new));
  }
 else {
    each(conf,(name,decoconf) -> {
      cache.addCacheExtensionFactory(newFactory(path + ""String_Node_Str"" + name,decoconf,CacheExtensionFactoryConfiguration::new));
    }
);
  }
}","private void cacheExtensionFactory(final Config conf){
  if (conf.hasPath(""String_Node_Str"")) {
    cache.addCacheExtensionFactory(newFactory(path + ""String_Node_Str"",conf,CacheExtensionFactoryConfiguration::new));
  }
 else {
    each(conf,(name,decoconf) -> cache.addCacheExtensionFactory(newFactory(path + ""String_Node_Str"" + name,decoconf,CacheExtensionFactoryConfiguration::new)));
  }
}"
54745,"private void cacheLoaderFactory(final Config conf){
  if (conf.hasPath(""String_Node_Str"")) {
    cache.addCacheLoaderFactory(newFactory(path + ""String_Node_Str"",conf,CacheLoaderFactoryConfiguration::new));
  }
 else {
    each(conf,(name,c) -> {
      cache.addCacheLoaderFactory(newFactory(path + ""String_Node_Str"" + name,c,CacheLoaderFactoryConfiguration::new));
    }
);
  }
}","private void cacheLoaderFactory(final Config conf){
  if (conf.hasPath(""String_Node_Str"")) {
    cache.addCacheLoaderFactory(newFactory(path + ""String_Node_Str"",conf,CacheLoaderFactoryConfiguration::new));
  }
 else {
    each(conf,(name,c) -> cache.addCacheLoaderFactory(newFactory(path + ""String_Node_Str"" + name,c,CacheLoaderFactoryConfiguration::new)));
  }
}"
54746,"private void cacheDecoratorFactory(final Config conf){
  if (conf.hasPath(""String_Node_Str"")) {
    cache.addCacheDecoratorFactory(newFactory(path + ""String_Node_Str"",conf,CacheDecoratorFactoryConfiguration::new));
  }
 else {
    each(conf,(name,decoconf) -> {
      cache.addCacheDecoratorFactory(newFactory(path + ""String_Node_Str"" + name,decoconf,CacheDecoratorFactoryConfiguration::new));
    }
);
  }
}","private void cacheDecoratorFactory(final Config conf){
  if (conf.hasPath(""String_Node_Str"")) {
    cache.addCacheDecoratorFactory(newFactory(path + ""String_Node_Str"",conf,CacheDecoratorFactoryConfiguration::new));
  }
 else {
    each(conf,(name,decoconf) -> cache.addCacheDecoratorFactory(newFactory(path + ""String_Node_Str"" + name,decoconf,CacheDecoratorFactoryConfiguration::new)));
  }
}"
54747,"private void cacheManagerPeerProviderFactory(final Config conf){
  if (conf.hasPath(""String_Node_Str"")) {
    eh.addCacheManagerPeerProviderFactory(newFactory(""String_Node_Str"",conf,FactoryConfiguration::new));
  }
 else {
    each(conf,(name,c) -> {
      eh.addCacheManagerPeerProviderFactory(newFactory(""String_Node_Str"" + name,c,FactoryConfiguration::new));
    }
);
  }
}","private void cacheManagerPeerProviderFactory(final Config conf){
  if (conf.hasPath(""String_Node_Str"")) {
    eh.addCacheManagerPeerProviderFactory(newFactory(""String_Node_Str"",conf,FactoryConfiguration::new));
  }
 else {
    each(conf,(name,c) -> eh.addCacheManagerPeerProviderFactory(newFactory(""String_Node_Str"" + name,c,FactoryConfiguration::new)));
  }
}"
54748,"private boolean existsIdx(final String name){
  MongoCursor<Document> iterator=sessions.listIndexes().iterator();
  while (iterator.hasNext()) {
    Document doc=iterator.next();
    if (doc.getString(""String_Node_Str"").equals(name)) {
      return true;
    }
  }
  return false;
}","private boolean existsIdx(final String name){
  for (  final Document doc : sessions.listIndexes()) {
    if (doc.getString(""String_Node_Str"").equals(name)) {
      return true;
    }
  }
  return false;
}"
54749,"private static Function<Object,Object> idGen(final Bucket bucket){
  return entity -> {
    return IdGenerator.getOrGenId(entity,() -> bucket.counter(entity.getClass().getName(),1,1).content());
  }
;
}","private static Function<Object,Object> idGen(final Bucket bucket){
  return entity -> IdGenerator.getOrGenId(entity,() -> bucket.counter(entity.getClass().getName(),1,1).content());
}"
54750,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override public void configure(final Env env,final Config conf,final Binder binder){
  String cstr=db.startsWith(ConnectionString.DEFAULT_SCHEME) ? db : conf.getString(db);
  String defbucket=defbucket(cstr);
  System.setProperty(N1Q.COUCHBASE_DEFBUCKET,defbucket);
  String dbname=cstr.equals(db) ? defbucket : db;
  if (conf.hasPath(""String_Node_Str"")) {
    conf.getConfig(""String_Node_Str"").entrySet().forEach(e -> {
      System.setProperty(""String_Node_Str"" + e.getKey(),e.getValue().unwrapped().toString());
    }
);
  }
  log.debug(""String_Node_Str"",cstr);
  ServiceKey serviceKey=env.serviceKey();
  Throwing.Function3<Class,String,Object,Void> bind=(type,name,value) -> {
    serviceKey.generate(type,name,k -> {
      binder.bind(k).toInstance(value);
    }
);
    return null;
  }
;
  CouchbaseEnvironment cenv=this.env.apply(conf);
  String cstrworkaround=cstr.replace(""String_Node_Str"" + defbucket,""String_Node_Str"");
  CouchbaseCluster cluster=CouchbaseCluster.fromConnectionString(cenv,cstrworkaround);
  serviceKey.generate(CouchbaseCluster.class,dbname,k -> binder.bind(k).toInstance(cluster));
  if (conf.hasPath(""String_Node_Str"")) {
    ClusterManager clusterManager=cluster.clusterManager(conf.getString(""String_Node_Str""),conf.getString(""String_Node_Str""));
    bind.apply(ClusterManager.class,dbname,clusterManager);
  }
  Set<String> buckets=Sets.newHashSet(defbucket);
  buckets.addAll(this.buckets);
  Function<String,String> password=name -> {
    return Arrays.asList(""String_Node_Str"" + name + ""String_Node_Str"",""String_Node_Str"").stream().filter(conf::hasPath).map(conf::getString).findFirst().orElse(null);
  }
;
  buckets.forEach(name -> {
    Bucket bucket=cluster.openBucket(name,password.apply(name));
    log.debug(""String_Node_Str"",name);
    bind.apply(Bucket.class,name,bucket);
    AsyncBucket async=bucket.async();
    bind.apply(AsyncBucket.class,name,async);
    Repository repo=bucket.repository();
    AsyncRepository asyncrepo=repo.async();
    SetConverterHack.forceConverter(asyncrepo,CONVERTER);
    bind.apply(Repository.class,name,repo);
    bind.apply(AsyncRepository.class,name,asyncrepo);
    AsyncDatastoreImpl asyncds=new AsyncDatastoreImpl(async,asyncrepo,idGen(bucket),CONVERTER);
    bind.apply(AsyncDatastore.class,name,asyncds);
    bind.apply(Datastore.class,name,new DatastoreImpl(asyncds));
    buckets.add(name);
  }
);
  this.sessionBucket.ifPresent(buckets::add);
  String session=this.sessionBucket.orElse(defbucket);
  bind.apply(Bucket.class,""String_Node_Str"",cluster.openBucket(session,password.apply(session)));
  env.onStop(r -> {
    buckets.forEach(n -> {
      Try.apply(() -> r.require(n,Bucket.class).close()).onFailure(x -> log.debug(""String_Node_Str"",n,x)).orElse(false);
    }
);
    Try.run(cluster::disconnect).onFailure(x -> log.debug(""String_Node_Str"",x));
    Try.run(cenv::shutdown).onFailure(x -> log.debug(""String_Node_Str"",x));
  }
);
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override public void configure(final Env env,final Config conf,final Binder binder){
  String cstr=db.startsWith(ConnectionString.DEFAULT_SCHEME) ? db : conf.getString(db);
  String defbucket=defbucket(cstr);
  System.setProperty(N1Q.COUCHBASE_DEFBUCKET,defbucket);
  String dbname=cstr.equals(db) ? defbucket : db;
  if (conf.hasPath(""String_Node_Str"")) {
    conf.getConfig(""String_Node_Str"").entrySet().forEach(e -> System.setProperty(""String_Node_Str"" + e.getKey(),e.getValue().unwrapped().toString()));
  }
  log.debug(""String_Node_Str"",cstr);
  ServiceKey serviceKey=env.serviceKey();
  Throwing.Function3<Class,String,Object,Void> bind=(type,name,value) -> {
    serviceKey.generate(type,name,k -> binder.bind(k).toInstance(value));
    return null;
  }
;
  CouchbaseEnvironment cenv=this.env.apply(conf);
  String cstrworkaround=cstr.replace(""String_Node_Str"" + defbucket,""String_Node_Str"");
  CouchbaseCluster cluster=CouchbaseCluster.fromConnectionString(cenv,cstrworkaround);
  serviceKey.generate(CouchbaseCluster.class,dbname,k -> binder.bind(k).toInstance(cluster));
  if (conf.hasPath(""String_Node_Str"")) {
    ClusterManager clusterManager=cluster.clusterManager(conf.getString(""String_Node_Str""),conf.getString(""String_Node_Str""));
    bind.apply(ClusterManager.class,dbname,clusterManager);
  }
  Set<String> buckets=Sets.newHashSet(defbucket);
  buckets.addAll(this.buckets);
  Function<String,String> password=name -> Stream.of(""String_Node_Str"" + name + ""String_Node_Str"",""String_Node_Str"").filter(conf::hasPath).map(conf::getString).findFirst().orElse(null);
  buckets.forEach(name -> {
    Bucket bucket=cluster.openBucket(name,password.apply(name));
    log.debug(""String_Node_Str"",name);
    bind.apply(Bucket.class,name,bucket);
    AsyncBucket async=bucket.async();
    bind.apply(AsyncBucket.class,name,async);
    Repository repo=bucket.repository();
    AsyncRepository asyncrepo=repo.async();
    SetConverterHack.forceConverter(asyncrepo,CONVERTER);
    bind.apply(Repository.class,name,repo);
    bind.apply(AsyncRepository.class,name,asyncrepo);
    AsyncDatastoreImpl asyncds=new AsyncDatastoreImpl(async,asyncrepo,idGen(bucket),CONVERTER);
    bind.apply(AsyncDatastore.class,name,asyncds);
    bind.apply(Datastore.class,name,new DatastoreImpl(asyncds));
    buckets.add(name);
  }
);
  this.sessionBucket.ifPresent(buckets::add);
  String session=this.sessionBucket.orElse(defbucket);
  bind.apply(Bucket.class,""String_Node_Str"",cluster.openBucket(session,password.apply(session)));
  env.onStop(r -> {
    buckets.forEach(n -> Try.apply(() -> r.require(n,Bucket.class).close()).onFailure(x -> log.debug(""String_Node_Str"",n,x)).orElse(false));
    Try.run(cluster::disconnect).onFailure(x -> log.debug(""String_Node_Str"",x));
    Try.run(cenv::shutdown).onFailure(x -> log.debug(""String_Node_Str"",x));
  }
);
}"
54751,"/** 
 * Retrieve and lock a entity by its unique ID. If the entity is found, a entity is returned. Otherwise a  {@link DocumentDoesNotExistException}. This method works similar to   {@link #get(Class,Object)}, but in addition it (write) locks the entity for the given lock time interval. Note that this lock time is hard capped to 30 seconds, even if provided with a higher value and is not configurable. The entity will unlock afterwards automatically. Detecting an already locked entity is done by checking for  {@link TemporaryLockFailureException}. Note that this exception can also be raised in other conditions, always when the error is transient and retrying may help.
 * @param entityClass Entity class.
 * @param id id the unique ID of the entity.
 * @param lockTime the time to write lock the entity (max. 30 seconds).
 * @param < T > Entity type.
 * @return an {@link Observable} eventually containing the found {@link JsonDocument}.
 */
default <T>T getAndLock(final Class<T> entityClass,final Object id,final int lockTime) throws DocumentDoesNotExistException {
  return async().<T>getAndLock(entityClass,id,lockTime).switchIfEmpty(notFound(entityClass,id)).toBlocking().single();
}","/** 
 * Retrieve and lock a entity by its unique ID. If the entity is found, a entity is returned. Otherwise a  {@link DocumentDoesNotExistException}. This method works similar to   {@link #get(Class,Object)}, but in addition it (write) locks the entity for the given lock time interval. Note that this lock time is hard capped to 30 seconds, even if provided with a higher value and is not configurable. The entity will unlock afterwards automatically. Detecting an already locked entity is done by checking for  {@link TemporaryLockFailureException}. Note that this exception can also be raised in other conditions, always when the error is transient and retrying may help.
 * @param entityClass Entity class.
 * @param id id the unique ID of the entity.
 * @param lockTime the time to write lock the entity (max. 30 seconds).
 * @param < T > Entity type.
 * @return an {@link Observable} eventually containing the found {@link JsonDocument}.
 */
default <T>T getAndLock(final Class<T> entityClass,final Object id,final int lockTime) throws DocumentDoesNotExistException {
  return async().getAndLock(entityClass,id,lockTime).switchIfEmpty(notFound(entityClass,id)).toBlocking().single();
}"
54752,"/** 
 * Retrieve and touch an entity by its unique ID. If the entity is found, an entity is returned. Otherwise a  {@link DocumentDoesNotExistException}. This method works similar to   {@link #get(Class,Object)}, but in addition it touches the entity, which will reset its configured expiration time to the value provided.
 * @param entityClass Entity class.
 * @param id id the unique ID of the entity.
 * @param expiry the new expiration time for the entity (in seconds).
 * @param < T > Entity type.
 * @return an {@link Observable} eventually containing the found {@link JsonDocument}.
 */
default <T>T getAndTouch(final Class<T> entityClass,final Object id,final int expiry) throws DocumentDoesNotExistException {
  return async().<T>getAndTouch(entityClass,id,expiry).switchIfEmpty(notFound(entityClass,id)).toBlocking().single();
}","/** 
 * Retrieve and touch an entity by its unique ID. If the entity is found, an entity is returned. Otherwise a  {@link DocumentDoesNotExistException}. This method works similar to   {@link #get(Class,Object)}, but in addition it touches the entity, which will reset its configured expiration time to the value provided.
 * @param entityClass Entity class.
 * @param id id the unique ID of the entity.
 * @param expiry the new expiration time for the entity (in seconds).
 * @param < T > Entity type.
 * @return an {@link Observable} eventually containing the found {@link JsonDocument}.
 */
default <T>T getAndTouch(final Class<T> entityClass,final Object id,final int expiry) throws DocumentDoesNotExistException {
  return async().getAndTouch(entityClass,id,expiry).switchIfEmpty(notFound(entityClass,id)).toBlocking().single();
}"
54753,"/** 
 * Get an entity/document by ID. The unique ID is constructed via  {@link N1Q#qualifyId(Class,Object)}. If the entity is found, a entity is returned. Otherwise a  {@link DocumentDoesNotExistException}.
 * @param entityClass Entity class.
 * @param id Entity id.
 * @param mode Replica mode.
 * @param < T > Entity type.
 * @return An entity matching the id or an empty observable.
 */
default <T>T getFromReplica(final Class<T> entityClass,final Object id,final ReplicaMode mode) throws DocumentDoesNotExistException {
  return async().<T>getFromReplica(entityClass,id,mode).switchIfEmpty(notFound(entityClass,id)).toBlocking().single();
}","/** 
 * Get an entity/document by ID. The unique ID is constructed via  {@link N1Q#qualifyId(Class,Object)}. If the entity is found, a entity is returned. Otherwise a  {@link DocumentDoesNotExistException}.
 * @param entityClass Entity class.
 * @param id Entity id.
 * @param mode Replica mode.
 * @param < T > Entity type.
 * @return An entity matching the id or an empty observable.
 */
default <T>T getFromReplica(final Class<T> entityClass,final Object id,final ReplicaMode mode) throws DocumentDoesNotExistException {
  return async().getFromReplica(entityClass,id,mode).switchIfEmpty(notFound(entityClass,id)).toBlocking().single();
}"
54754,"/** 
 * Get an entity/document by ID. The unique ID is constructed via  {@link N1Q#qualifyId(Class,Object)}. If the entity is found, a entity is returned. Otherwise a  {@link DocumentDoesNotExistException}.
 * @param entityClass Entity class.
 * @param id Entity id.
 * @param < T > Entity type.
 * @return An entity matching the id or an empty observable.
 */
default <T>T get(final Class<T> entityClass,final Object id) throws DocumentDoesNotExistException {
  return async().<T>get(entityClass,id).switchIfEmpty(notFound(entityClass,id)).toBlocking().single();
}","/** 
 * Get an entity/document by ID. The unique ID is constructed via  {@link N1Q#qualifyId(Class,Object)}. If the entity is found, a entity is returned. Otherwise a  {@link DocumentDoesNotExistException}.
 * @param entityClass Entity class.
 * @param id Entity id.
 * @param < T > Entity type.
 * @return An entity matching the id or an empty observable.
 */
default <T>T get(final Class<T> entityClass,final Object id) throws DocumentDoesNotExistException {
  return async().get(entityClass,id).switchIfEmpty(notFound(entityClass,id)).toBlocking().single();
}"
54755,"/** 
 * Produces an observable that throws a   {@link DocumentDoesNotExistException}.
 * @param entityClass Entity class.
 * @param id Entity id.
 * @param < T > Entity type.
 * @return An observable that throws a {@link DocumentDoesNotExistException}.
 */
@SuppressWarnings(""String_Node_Str"") static <T>Observable<T> notFound(final Class entityClass,final Object id){
  return Observable.create(s -> {
    s.onError(new DocumentDoesNotExistException(N1Q.qualifyId(entityClass,id)));
  }
);
}","/** 
 * Produces an observable that throws a   {@link DocumentDoesNotExistException}.
 * @param entityClass Entity class.
 * @param id Entity id.
 * @param < T > Entity type.
 * @return An observable that throws a {@link DocumentDoesNotExistException}.
 */
@SuppressWarnings(""String_Node_Str"") static <T>Observable<T> notFound(final Class entityClass,final Object id){
  return Observable.create(s -> s.onError(new DocumentDoesNotExistException(N1Q.qualifyId(entityClass,id))));
}"
54756,"@Override public Field load(final Class key) throws Exception {
  if (key == Object.class) {
    throw new IllegalArgumentException(""String_Node_Str"" + key.getName() + ""String_Node_Str""+ Id.class.getName());
  }
  Field[] fields=key.getDeclaredFields();
  for (  Field field : fields) {
    if (field.getName().equals(""String_Node_Str"")) {
      field.setAccessible(true);
      return field;
    }
 else     if (field.getAnnotation(Id.class) != null) {
      field.setAccessible(true);
      return field;
    }
  }
  return load(key.getSuperclass());
}","@Override public Field load(final Class key){
  if (key == Object.class) {
    throw new IllegalArgumentException(""String_Node_Str"" + key.getName() + ""String_Node_Str""+ Id.class.getName());
  }
  Field[] fields=key.getDeclaredFields();
  for (  Field field : fields) {
    if (field.getName().equals(""String_Node_Str"")) {
      field.setAccessible(true);
      return field;
    }
 else     if (field.getAnnotation(Id.class) != null) {
      field.setAccessible(true);
      return field;
    }
  }
  return load(key.getSuperclass());
}"
54757,"private static Field field(final Object bean){
  Field id=Try.apply(() -> CACHE.getUnchecked(bean.getClass())).unwrap(UncheckedExecutionException.class).get();
  return id;
}","private static Field field(final Object bean){
  return Try.apply(() -> CACHE.getUnchecked(bean.getClass())).unwrap(UncheckedExecutionException.class).get();
}"
54758,"static Handler tryPage(final Handler handler,final Logger log){
  return (req,rsp,ex) -> Try.run(() -> handler.handle(req,rsp,ex)).onFailure(cause -> {
    log.debug(""String_Node_Str"",cause);
  }
);
}","static Handler tryPage(final Handler handler,final Logger log){
  return (req,rsp,ex) -> Try.run(() -> handler.handle(req,rsp,ex)).onFailure(cause -> log.debug(""String_Node_Str"",cause));
}"
54759,"private static Handler prettyPage(final ClassLoader loader,final SourceLocator locator,final int maxStackSize,final Logger log){
  String css=readString(loader,""String_Node_Str"");
  String clipboard=readString(loader,""String_Node_Str"");
  String js=readString(loader,""String_Node_Str"");
  String zepto=readString(loader,""String_Node_Str"");
  ClasspathLoader cpathloader=new ClasspathLoader();
  cpathloader.setPrefix(""String_Node_Str"");
  cpathloader.setSuffix(""String_Node_Str"");
  PebbleEngine engine=new PebbleEngine.Builder().loader(cpathloader).templateCache(CacheBuilder.newBuilder().maximumSize(10).build()).build();
  Throwing.Function<String,PebbleTemplate> template=Throwing.<String,PebbleTemplate>throwingFunction(name -> engine.getTemplate(name)).memoized();
  return (req,rsp,err) -> {
    if (req.accepts(MediaType.html).isPresent()) {
      Throwable cause=Optional.ofNullable(err.getCause()).orElse(err);
      List<Throwable> causal=Throwables.getCausalChain(cause);
      Throwable head=causal.get(causal.size() - 1);
      String message=message(head);
      Map<String,Object> envdata=new LinkedHashMap<>();
      envdata.put(""String_Node_Str"",dump(() -> ImmutableMap.of(""String_Node_Str"",rsp.status().get())));
      envdata.put(""String_Node_Str"",dump(() -> {
        Route route=req.route();
        ImmutableMap.Builder<String,Object> map=ImmutableMap.builder();
        return map.put(""String_Node_Str"",route.method()).put(""String_Node_Str"",route.path()).put(""String_Node_Str"",route.vars()).put(""String_Node_Str"",route.pattern()).put(""String_Node_Str"",route.name()).put(""String_Node_Str"",route.attributes()).build();
      }
));
      envdata.put(""String_Node_Str"",dump(() -> req.params().toMap()));
      envdata.put(""String_Node_Str"",dump(req::attributes));
      envdata.put(""String_Node_Str"",dump(req::headers));
      req.ifSession().ifPresent(s -> envdata.put(""String_Node_Str"",dump(s::attributes)));
      List<Map<String,Object>> frames=causal.stream().filter(it -> it != head).map(it -> frame(loader,locator,it,it.getStackTrace()[0])).collect(Collectors.toList());
      frames.addAll(frames(loader,locator,head));
      frames=frames.subList(0,Math.min(maxStackSize,frames.size()));
      Map<String,Object> context=ImmutableMap.<String,Object>builder().put(""String_Node_Str"",css).put(""String_Node_Str"",zepto).put(""String_Node_Str"",clipboard).put(""String_Node_Str"",js).put(""String_Node_Str"",causal).put(""String_Node_Str"",head.getClass().getName() + ""String_Node_Str"" + message).put(""String_Node_Str"",message).put(""String_Node_Str"",Throwables.getStackTraceAsString(cause)).put(""String_Node_Str"",frames).put(""String_Node_Str"",envdata).build();
      Writer writer=new StringWriter();
      template.apply(""String_Node_Str"").evaluate(writer,context);
      log.error(""String_Node_Str"",req.method(),req.path(),req.route().print(6),err);
      rsp.type(MediaType.html).send(writer.toString());
    }
  }
;
}","private static Handler prettyPage(final ClassLoader loader,final SourceLocator locator,final int maxStackSize,final Logger log){
  String css=readString(loader,""String_Node_Str"");
  String clipboard=readString(loader,""String_Node_Str"");
  String js=readString(loader,""String_Node_Str"");
  String zepto=readString(loader,""String_Node_Str"");
  ClasspathLoader cpathloader=new ClasspathLoader();
  cpathloader.setPrefix(""String_Node_Str"");
  cpathloader.setSuffix(""String_Node_Str"");
  PebbleEngine engine=new PebbleEngine.Builder().loader(cpathloader).templateCache(CacheBuilder.newBuilder().maximumSize(10).build()).build();
  Throwing.Function<String,PebbleTemplate> template=Throwing.throwingFunction(engine::getTemplate).memoized();
  return (req,rsp,err) -> {
    if (req.accepts(MediaType.html).isPresent()) {
      Throwable cause=Optional.ofNullable(err.getCause()).orElse(err);
      List<Throwable> causal=Throwables.getCausalChain(cause);
      Throwable head=causal.get(causal.size() - 1);
      String message=message(head);
      Map<String,Object> envdata=new LinkedHashMap<>();
      envdata.put(""String_Node_Str"",dump(() -> ImmutableMap.of(""String_Node_Str"",rsp.status().get())));
      envdata.put(""String_Node_Str"",dump(() -> {
        Route route=req.route();
        ImmutableMap.Builder<String,Object> map=ImmutableMap.builder();
        return map.put(""String_Node_Str"",route.method()).put(""String_Node_Str"",route.path()).put(""String_Node_Str"",route.vars()).put(""String_Node_Str"",route.pattern()).put(""String_Node_Str"",route.name()).put(""String_Node_Str"",route.attributes()).build();
      }
));
      envdata.put(""String_Node_Str"",dump(() -> req.params().toMap()));
      envdata.put(""String_Node_Str"",dump(req::attributes));
      envdata.put(""String_Node_Str"",dump(req::headers));
      req.ifSession().ifPresent(s -> envdata.put(""String_Node_Str"",dump(s::attributes)));
      List<Map<String,Object>> frames=causal.stream().filter(it -> it != head).map(it -> frame(loader,locator,it,it.getStackTrace()[0])).collect(Collectors.toList());
      frames.addAll(frames(loader,locator,head));
      frames=frames.subList(0,Math.min(maxStackSize,frames.size()));
      Map<String,Object> context=ImmutableMap.<String,Object>builder().put(""String_Node_Str"",css).put(""String_Node_Str"",zepto).put(""String_Node_Str"",clipboard).put(""String_Node_Str"",js).put(""String_Node_Str"",causal).put(""String_Node_Str"",head.getClass().getName() + ""String_Node_Str"" + message).put(""String_Node_Str"",message).put(""String_Node_Str"",Throwables.getStackTraceAsString(cause)).put(""String_Node_Str"",frames).put(""String_Node_Str"",envdata).build();
      Writer writer=new StringWriter();
      template.apply(""String_Node_Str"").evaluate(writer,context);
      log.error(""String_Node_Str"",req.method(),req.path(),req.route().print(6),err);
      rsp.type(MediaType.html).send(writer.toString());
    }
  }
;
}"
54760,"@SuppressWarnings(""String_Node_Str"") static Optional<Class> findClass(final ClassLoader loader,final String name){
  return Arrays.asList(loader,Thread.currentThread().getContextClassLoader()).stream().map(Throwing.<ClassLoader,Class>throwingFunction(cl -> cl.loadClass(name)).orElse((Class)null)).filter(Objects::nonNull).findFirst();
}","@SuppressWarnings(""String_Node_Str"") static Optional<Class> findClass(final ClassLoader loader,final String name){
  return Stream.of(loader,Thread.currentThread().getContextClassLoader()).map(Throwing.<ClassLoader,Class>throwingFunction(cl -> cl.loadClass(name)).orElse((Class)null)).filter(Objects::nonNull).findFirst();
}"
54761,"@SuppressWarnings(""String_Node_Str"") static Map<String,Object> frame(final ClassLoader loader,final SourceLocator locator,final Throwable cause,final StackTraceElement e){
  int line=Math.max(e.getLineNumber(),1);
  String className=e.getClassName();
  SourceLocator.Source source=locator.source(className);
  int[] range=source.range(line,SAMPLE_SIZE);
  int lineStart=range[0];
  int lineNth=line - lineStart;
  Path filePath=source.getPath();
  Optional<Class> clazz=findClass(loader,className);
  String filename=Optional.ofNullable(e.getFileName()).orElse(""String_Node_Str"");
  return ImmutableMap.<String,Object>builder().put(""String_Node_Str"",new File(filename).getName()).put(""String_Node_Str"",Optional.ofNullable(e.getMethodName()).orElse(""String_Node_Str"")).put(""String_Node_Str"",line).put(""String_Node_Str"",lineStart + 1).put(""String_Node_Str"",lineNth).put(""String_Node_Str"",Optional.ofNullable(clazz.map(Whoops::locationOf).orElse(new File(filename).getParent())).orElse(filename)).put(""String_Node_Str"",source.source(range[0],range[1])).put(""String_Node_Str"",openWith.apply(filePath,line)).put(""String_Node_Str"",clazz.map(c -> c.getSimpleName()).orElse(new File(filename).getName())).put(""String_Node_Str"",Arrays.asList(ImmutableMap.of(""String_Node_Str"",cause.getClass().getName(),""String_Node_Str"",message(cause)))).build();
}","@SuppressWarnings(""String_Node_Str"") static Map<String,Object> frame(final ClassLoader loader,final SourceLocator locator,final Throwable cause,final StackTraceElement e){
  int line=Math.max(e.getLineNumber(),1);
  String className=e.getClassName();
  SourceLocator.Source source=locator.source(className);
  int[] range=source.range(line,SAMPLE_SIZE);
  int lineStart=range[0];
  int lineNth=line - lineStart;
  Path filePath=source.getPath();
  Optional<Class> clazz=findClass(loader,className);
  String filename=Optional.ofNullable(e.getFileName()).orElse(""String_Node_Str"");
  return ImmutableMap.<String,Object>builder().put(""String_Node_Str"",new File(filename).getName()).put(""String_Node_Str"",Optional.ofNullable(e.getMethodName()).orElse(""String_Node_Str"")).put(""String_Node_Str"",line).put(""String_Node_Str"",lineStart + 1).put(""String_Node_Str"",lineNth).put(""String_Node_Str"",Optional.ofNullable(clazz.map(Whoops::locationOf).orElse(new File(filename).getParent())).orElse(filename)).put(""String_Node_Str"",source.source(range[0],range[1])).put(""String_Node_Str"",openWith.apply(filePath,line)).put(""String_Node_Str"",clazz.map(Class::getSimpleName).orElse(new File(filename).getName())).put(""String_Node_Str"",Arrays.asList(ImmutableMap.of(""String_Node_Str"",cause.getClass().getName(),""String_Node_Str"",message(cause)))).build();
}"
54762,"@Inject public FileMonitor(final Injector injector,final Env env,final WatchService watcher,final Set<FileEventOptions> optionList) throws IOException {
  this.injector=injector;
  this.watcher=watcher;
  this.optionList=optionList;
  ExecutorService monitor=Executors.newSingleThreadExecutor(task -> {
    Thread thread=new Thread(task,""String_Node_Str"");
    thread.setDaemon(true);
    return thread;
  }
);
  env.onStop(monitor::shutdown);
  monitor.execute(this);
}","@Inject public FileMonitor(final Injector injector,final Env env,final WatchService watcher,final Set<FileEventOptions> optionList){
  this.injector=injector;
  this.watcher=watcher;
  this.optionList=optionList;
  ExecutorService monitor=Executors.newSingleThreadExecutor(task -> {
    Thread thread=new Thread(task,""String_Node_Str"");
    thread.setDaemon(true);
    return thread;
  }
);
  env.onStop(monitor::shutdown);
  monitor.execute(this);
}"
54763,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private void paths(final ClassLoader loader,final Config conf,final String name,final Consumer<FileEventOptions> callback) throws Throwable {
  list(conf,name,value -> {
    Config coptions=ConfigFactory.parseMap((Map)value);
    Class handler=loader.loadClass(coptions.getString(""String_Node_Str""));
    Path path=Paths.get(coptions.getString(""String_Node_Str""));
    FileEventOptions options=new FileEventOptions(path,handler);
    list(coptions,""String_Node_Str"",it -> options.kind(new WatchEventKind(it.toString())));
    list(coptions,""String_Node_Str"",it -> options.modifier(new WatchEventModifier(it.toString())));
    list(coptions,""String_Node_Str"",it -> options.includes(it.toString()));
    list(coptions,""String_Node_Str"",it -> options.recursive(Boolean.valueOf(it.toString())));
    callback.accept(options);
  }
);
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private void paths(final ClassLoader loader,final Config conf,final String name,final Consumer<FileEventOptions> callback){
  list(conf,name,value -> {
    Config coptions=ConfigFactory.parseMap((Map)value);
    Class handler=loader.loadClass(coptions.getString(""String_Node_Str""));
    Path path=Paths.get(coptions.getString(""String_Node_Str""));
    FileEventOptions options=new FileEventOptions(path,handler);
    list(coptions,""String_Node_Str"",it -> options.kind(new WatchEventKind(it.toString())));
    list(coptions,""String_Node_Str"",it -> options.modifier(new WatchEventModifier(it.toString())));
    list(coptions,""String_Node_Str"",it -> options.includes(it.toString()));
    list(coptions,""String_Node_Str"",it -> options.recursive(Boolean.valueOf(it.toString())));
    callback.accept(options);
  }
);
}"
54764,"@Override public void configure(final Env env,final Config conf,final Binder binder) throws Throwable {
  this.watcher=FileSystems.getDefault().newWatchService();
  binder.bind(WatchService.class).toInstance(watcher);
  List<FileEventOptions> paths=new ArrayList<>();
  paths(env.getClass().getClassLoader(),conf,""String_Node_Str"",options -> {
    paths.add(register(binder,options));
  }
);
  for (  Throwing.Function2<Config,Binder,FileEventOptions> binding : bindings) {
    paths.add(binding.apply(conf,binder));
  }
  binder.bind(FileMonitor.class).asEagerSingleton();
  paths.forEach(it -> log.info(""String_Node_Str"",it));
}","@Override public void configure(final Env env,final Config conf,final Binder binder) throws Throwable {
  this.watcher=FileSystems.getDefault().newWatchService();
  binder.bind(WatchService.class).toInstance(watcher);
  List<FileEventOptions> paths=new ArrayList<>();
  paths(env.getClass().getClassLoader(),conf,""String_Node_Str"",options -> paths.add(register(binder,options)));
  for (  Throwing.Function2<Config,Binder,FileEventOptions> binding : bindings) {
    paths.add(binding.apply(conf,binder));
  }
  binder.bind(FileMonitor.class).asEagerSingleton();
  paths.forEach(it -> log.info(""String_Node_Str"",it));
}"
54765,"@SuppressWarnings(""String_Node_Str"") private void list(final Config conf,final String name,final Throwing.Consumer<Object> callback) throws Throwable {
  if (conf.hasPath(name)) {
    Object value=conf.getAnyRef(name);
    List values=value instanceof List ? (List)value : ImmutableList.of(value);
    for (    Object it : values) {
      callback.accept(it);
    }
  }
}","@SuppressWarnings(""String_Node_Str"") private void list(final Config conf,final String name,final Throwing.Consumer<Object> callback){
  if (conf.hasPath(name)) {
    Object value=conf.getAnyRef(name);
    List values=value instanceof List ? (List)value : ImmutableList.of(value);
    for (    Object it : values) {
      callback.accept(it);
    }
  }
}"
54766,"@Override public boolean matches(final Path path){
  return matchers.stream().filter(it -> it.matches(path)).findFirst().isPresent();
}","@Override public boolean matches(final Path path){
  return matchers.stream().anyMatch(it -> it.matches(path));
}"
54767,"public <T extends Email>T newEmail(final T email){
  try {
    ifset(""String_Node_Str"",p -> {
      email.setAuthentication(mail.getString(p),mail.getString(""String_Node_Str""));
    }
);
    ifset(""String_Node_Str"",p -> email.setBcc(address(strList(p))));
    ifset(""String_Node_Str"",p -> email.setBounceAddress(mail.getString(p)));
    ifset(""String_Node_Str"",p -> email.setCc(address(strList(p))));
    email.setCharset(mail.getString(""String_Node_Str""));
    ifset(""String_Node_Str"",p -> email.setDebug(mail.getBoolean(p)));
    ifset(""String_Node_Str"",p -> email.setFrom(mail.getString(p)));
    ifset(""String_Node_Str"",p -> email.setHostName(mail.getString(p)));
    ifset(""String_Node_Str"",p -> {
      if (email instanceof HtmlEmail) {
        ((HtmlEmail)email).setHtmlMsg(mail.getString(p));
      }
 else {
        email.setMsg(mail.getString(p));
      }
    }
);
    ifset(""String_Node_Str"",p -> email.setReplyTo(address(mail.getStringList(p))));
    ifset(""String_Node_Str"",p -> email.setSendPartial(mail.getBoolean(p)));
    ifset(""String_Node_Str"",p -> email.setSmtpPort(mail.getInt(p)));
    ifset(""String_Node_Str"",p -> email.setSocketConnectionTimeout((int)mail.getDuration(p,TimeUnit.MILLISECONDS)));
    ifset(""String_Node_Str"",p -> email.setSocketTimeout((int)mail.getDuration(p,TimeUnit.MILLISECONDS)));
    ifset(""String_Node_Str"",p -> email.setSSLCheckServerIdentity(mail.getBoolean(p)));
    ifset(""String_Node_Str"",p -> email.setSSLOnConnect(mail.getBoolean(p)));
    ifset(""String_Node_Str"",p -> email.setSslSmtpPort(mail.getString(p)));
    ifset(""String_Node_Str"",p -> email.setStartTLSEnabled(mail.getBoolean(p)));
    ifset(""String_Node_Str"",p -> email.setStartTLSRequired(mail.getBoolean(p)));
    ifset(""String_Node_Str"",p -> email.setSubject(mail.getString(p)));
    ifset(""String_Node_Str"",p -> email.setTo(address(strList(p))));
    return email;
  }
 catch (  Exception ex) {
    throw new IllegalArgumentException(ex);
  }
}","public <T extends Email>T newEmail(final T email){
  try {
    ifset(""String_Node_Str"",p -> email.setAuthentication(mail.getString(p),mail.getString(""String_Node_Str"")));
    ifset(""String_Node_Str"",p -> email.setBcc(address(strList(p))));
    ifset(""String_Node_Str"",p -> email.setBounceAddress(mail.getString(p)));
    ifset(""String_Node_Str"",p -> email.setCc(address(strList(p))));
    email.setCharset(mail.getString(""String_Node_Str""));
    ifset(""String_Node_Str"",p -> email.setDebug(mail.getBoolean(p)));
    ifset(""String_Node_Str"",p -> email.setFrom(mail.getString(p)));
    ifset(""String_Node_Str"",p -> email.setHostName(mail.getString(p)));
    ifset(""String_Node_Str"",p -> {
      if (email instanceof HtmlEmail) {
        ((HtmlEmail)email).setHtmlMsg(mail.getString(p));
      }
 else {
        email.setMsg(mail.getString(p));
      }
    }
);
    ifset(""String_Node_Str"",p -> email.setReplyTo(address(mail.getStringList(p))));
    ifset(""String_Node_Str"",p -> email.setSendPartial(mail.getBoolean(p)));
    ifset(""String_Node_Str"",p -> email.setSmtpPort(mail.getInt(p)));
    ifset(""String_Node_Str"",p -> email.setSocketConnectionTimeout((int)mail.getDuration(p,TimeUnit.MILLISECONDS)));
    ifset(""String_Node_Str"",p -> email.setSocketTimeout((int)mail.getDuration(p,TimeUnit.MILLISECONDS)));
    ifset(""String_Node_Str"",p -> email.setSSLCheckServerIdentity(mail.getBoolean(p)));
    ifset(""String_Node_Str"",p -> email.setSSLOnConnect(mail.getBoolean(p)));
    ifset(""String_Node_Str"",p -> email.setSslSmtpPort(mail.getString(p)));
    ifset(""String_Node_Str"",p -> email.setStartTLSEnabled(mail.getBoolean(p)));
    ifset(""String_Node_Str"",p -> email.setStartTLSRequired(mail.getBoolean(p)));
    ifset(""String_Node_Str"",p -> email.setSubject(mail.getString(p)));
    ifset(""String_Node_Str"",p -> email.setTo(address(strList(p))));
    return email;
  }
 catch (  Exception ex) {
    throw new IllegalArgumentException(ex);
  }
}"
54768,"@Override public void configure(final Env env,final Config config,final Binder binder){
  Config mail=config.getConfig(name).withFallback(config.getConfig(""String_Node_Str""));
  ServiceKey serviceKey=env.serviceKey();
  serviceKey.generate(SimpleEmail.class,name,k -> {
    binder.bind(k).toProvider(new SimpleEmailProvider(mail));
  }
);
  serviceKey.generate(HtmlEmail.class,name,k -> {
    binder.bind(k).toProvider(new HtmlEmailProvider(mail));
  }
);
  serviceKey.generate(MultiPartEmail.class,name,k -> {
    binder.bind(k).toProvider(new MultiPartEmailProvider(mail));
  }
);
  serviceKey.generate(ImageHtmlEmail.class,name,k -> {
    binder.bind(k).toProvider(new ImageHtmlEmailProvider(mail));
  }
);
}","@Override public void configure(final Env env,final Config config,final Binder binder){
  Config mail=config.getConfig(name).withFallback(config.getConfig(""String_Node_Str""));
  ServiceKey serviceKey=env.serviceKey();
  serviceKey.generate(SimpleEmail.class,name,k -> binder.bind(k).toProvider(new SimpleEmailProvider(mail)));
  serviceKey.generate(HtmlEmail.class,name,k -> binder.bind(k).toProvider(new HtmlEmailProvider(mail)));
  serviceKey.generate(MultiPartEmail.class,name,k -> binder.bind(k).toProvider(new MultiPartEmailProvider(mail)));
  serviceKey.generate(ImageHtmlEmail.class,name,k -> binder.bind(k).toProvider(new ImageHtmlEmailProvider(mail)));
}"
54769,"private static <T>T newObject(final Class<T> klass){
  return throwingSupplier(() -> klass.newInstance()).get();
}","private static <T>T newObject(final Class<T> klass){
  return throwingSupplier(klass::newInstance).get();
}"
54770,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override public void configure(final Env env,final Config conf,final Binder binder){
  List<String> packages=Optional.ofNullable(this.packages).orElseGet(() -> ImmutableList.of(conf.getString(""String_Node_Str"")));
  Set<String> spec=Sets.newLinkedHashSet(packages);
  serviceTypes.forEach(it -> spec.add(it.getPackage().getName()));
  FastClasspathScanner scanner=new FastClasspathScanner(spec.toArray(new String[spec.size()]));
  Router routes=env.router();
  ClassLoader loader=getClass().getClassLoader();
  Throwing.Function<String,Class> loadClass=name -> loader.loadClass(name);
  Set<Object> bindings=new HashSet<>();
  Predicate<Object> once=bindings::add;
  Consumer<Class> bind=klass -> {
    binder.bind(klass).asEagerSingleton();
    env.lifeCycle(klass);
  }
;
  ScanResult result=scanner.scan(conf.getInt(""String_Node_Str"") + 1);
  Predicate<String> inPackage=name -> packages.stream().filter(name::startsWith).findFirst().isPresent();
  result.getNamesOfClassesWithAnnotation(Path.class).stream().filter(once).map(loadClass).filter(C).forEach(routes::use);
  String mainClass=conf.getString(""String_Node_Str"");
  result.getNamesOfSubclassesOf(Jooby.class).stream().filter(once).filter(name -> !name.equals(mainClass)).map(loadClass).filter(C).forEach(klass -> routes.use(((Jooby)newObject(klass))));
  serviceTypes.stream().filter(A).forEach(a -> {
    result.getNamesOfClassesWithAnnotation(a).stream().filter(once).map(loadClass).filter(C).forEach(bind);
  }
);
  serviceTypes.stream().filter(I).filter(type -> type != Jooby.Module.class && type != Module.class && type != Service.class).forEach(i -> {
    result.getNamesOfClassesImplementing(i).stream().filter(inPackage).filter(once).map(loadClass).filter(C).forEach(bind);
  }
);
  serviceTypes.stream().filter(S).forEach(k -> {
    result.getNamesOfSubclassesOf(k).stream().filter(inPackage).filter(once).map(loadClass).filter(C).forEach(bind);
  }
);
  if (serviceTypes.contains(Module.class)) {
    result.getNamesOfClassesImplementing(Module.class).stream().filter(inPackage).filter(once).map(loadClass).filter(C).forEach(klass -> ((Module)newObject(klass)).configure(binder));
  }
  if (serviceTypes.contains(Service.class)) {
    Set<Class<Service>> guavaServices=new HashSet<>();
    result.getNamesOfClassesImplementing(Service.class).stream().filter(inPackage).filter(once).map(loadClass).filter(C).forEach(guavaServices::add);
    if (guavaServices.size() > 0) {
      guavaServices(env,binder,guavaServices);
    }
  }
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override public void configure(final Env env,final Config conf,final Binder binder){
  List<String> packages=Optional.ofNullable(this.packages).orElseGet(() -> ImmutableList.of(conf.getString(""String_Node_Str"")));
  Set<String> spec=Sets.newLinkedHashSet(packages);
  serviceTypes.forEach(it -> spec.add(it.getPackage().getName()));
  FastClasspathScanner scanner=new FastClasspathScanner(spec.toArray(new String[spec.size()]));
  Router routes=env.router();
  ClassLoader loader=getClass().getClassLoader();
  Throwing.Function<String,Class> loadClass=loader::loadClass;
  Set<Object> bindings=new HashSet<>();
  Predicate<Object> once=bindings::add;
  Consumer<Class> bind=klass -> {
    binder.bind(klass).asEagerSingleton();
    env.lifeCycle(klass);
  }
;
  ScanResult result=scanner.scan(conf.getInt(""String_Node_Str"") + 1);
  Predicate<String> inPackage=name -> packages.stream().anyMatch(name::startsWith);
  result.getNamesOfClassesWithAnnotation(Path.class).stream().filter(once).map(loadClass).filter(C).forEach(routes::use);
  String mainClass=conf.getString(""String_Node_Str"");
  result.getNamesOfSubclassesOf(Jooby.class).stream().filter(once).filter(name -> !name.equals(mainClass)).map(loadClass).filter(C).forEach(klass -> routes.use(((Jooby)newObject(klass))));
  serviceTypes.stream().filter(A).forEach(a -> result.getNamesOfClassesWithAnnotation(a).stream().filter(once).map(loadClass).filter(C).forEach(bind));
  serviceTypes.stream().filter(I).filter(type -> type != Jooby.Module.class && type != Module.class && type != Service.class).forEach(i -> result.getNamesOfClassesImplementing(i).stream().filter(inPackage).filter(once).map(loadClass).filter(C).forEach(bind));
  serviceTypes.stream().filter(S).forEach(k -> result.getNamesOfSubclassesOf(k).stream().filter(inPackage).filter(once).map(loadClass).filter(C).forEach(bind));
  if (serviceTypes.contains(Module.class)) {
    result.getNamesOfClassesImplementing(Module.class).stream().filter(inPackage).filter(once).map(loadClass).filter(C).forEach(klass -> ((Module)newObject(klass)).configure(binder));
  }
  if (serviceTypes.contains(Service.class)) {
    Set<Class<Service>> guavaServices=new HashSet<>();
    result.getNamesOfClassesImplementing(Service.class).stream().filter(inPackage).filter(once).map(loadClass).filter(C).forEach(guavaServices::add);
    if (guavaServices.size() > 0) {
      guavaServices(env,binder,guavaServices);
    }
  }
}"
54771,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private static void guavaServices(final Env env,final Binder binder,final Set<Class<Service>> serviceTypes){
  Consumer<Class> guavaService=klass -> {
    binder.bind(klass).asEagerSingleton();
    serviceTypes.add(klass);
  }
;
  serviceTypes.forEach(guavaService);
  AtomicReference<ServiceManager> sm=new AtomicReference<>();
  Provider<ServiceManager> smProvider=() -> sm.get();
  binder.bind(ServiceManager.class).toProvider(smProvider);
  env.onStart(r -> {
    List<Service> services=serviceTypes.stream().map(r::require).collect(Collectors.toList());
    sm.set(new ServiceManager(services));
    sm.get().startAsync().awaitHealthy();
  }
);
  env.onStop(() -> {
    sm.get().stopAsync().awaitStopped();
  }
);
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) private static void guavaServices(final Env env,final Binder binder,final Set<Class<Service>> serviceTypes){
  Consumer<Class> guavaService=klass -> {
    binder.bind(klass).asEagerSingleton();
    serviceTypes.add(klass);
  }
;
  serviceTypes.forEach(guavaService);
  AtomicReference<ServiceManager> sm=new AtomicReference<>();
  Provider<ServiceManager> smProvider=sm::get;
  binder.bind(ServiceManager.class).toProvider(smProvider);
  env.onStart(r -> {
    List<Service> services=serviceTypes.stream().map(r::require).collect(Collectors.toList());
    sm.set(new ServiceManager(services));
    sm.get().startAsync().awaitHealthy();
  }
);
  env.onStop(() -> sm.get().stopAsync().awaitStopped());
}"
54772,"@SuppressWarnings(""String_Node_Str"") private String toSpec(final Object spec){
  if (spec instanceof Map) {
    Map<String,Object> m=(Map<String,Object>)spec;
    return m.entrySet().stream().map(e -> e.getKey() + ""String_Node_Str"" + e.getValue()).collect(Collectors.joining(""String_Node_Str"")).toString();
  }
  return spec.toString();
}","@SuppressWarnings(""String_Node_Str"") private String toSpec(final Object spec){
  if (spec instanceof Map) {
    Map<String,Object> m=(Map<String,Object>)spec;
    return m.entrySet().stream().map(e -> e.getKey() + ""String_Node_Str"" + e.getValue()).collect(Collectors.joining(""String_Node_Str""));
  }
  return spec.toString();
}"
54773,"private static JobKey jobKey(final Method method){
  Class<?> klass=method.getDeclaringClass();
  String classname=klass.getSimpleName();
  klass=klass.getDeclaringClass();
  while (klass != null) {
    classname=klass.getSimpleName() + ""String_Node_Str"" + classname;
    klass=klass.getDeclaringClass();
  }
  return JobKey.jobKey(classname + ""String_Node_Str"" + method.getName(),method.getDeclaringClass().getPackage().getName());
}","private static JobKey jobKey(final Method method){
  Class<?> klass=method.getDeclaringClass();
  StringBuilder classname=new StringBuilder(klass.getSimpleName());
  klass=klass.getDeclaringClass();
  while (klass != null) {
    classname.insert(0,klass.getSimpleName() + ""String_Node_Str"");
    klass=klass.getDeclaringClass();
  }
  return JobKey.jobKey(classname + ""String_Node_Str"" + method.getName(),method.getDeclaringClass().getPackage().getName());
}"
54774,"@Override public Object handle(final Request req) throws Throwable {
  Set<Route.Definition> routes=req.require(Route.KEY);
  WebPageProvider provider=req.require(name,WebPageProvider.class);
  List<WebPage> pages=routes.stream().filter(filter).flatMap(r -> provider.apply(r).stream()).map(page -> {
    String name=page.getName();
    if (name.startsWith(""String_Node_Str"")) {
      name=name.substring(1);
    }
    page.setName(name);
    return page;
  }
).collect(Collectors.toList());
  return Results.ok(gen.apply(pages)).type(MediaType.xml);
}","@Override public Object handle(final Request req) throws Throwable {
  Set<Route.Definition> routes=req.require(Route.KEY);
  WebPageProvider provider=req.require(name,WebPageProvider.class);
  List<WebPage> pages=routes.stream().filter(filter).flatMap(r -> provider.apply(r).stream()).peek(page -> {
    String name=page.getName();
    if (name.startsWith(""String_Node_Str"")) {
      name=name.substring(1);
    }
    page.setName(name);
  }
).collect(Collectors.toList());
  return Results.ok(gen.apply(pages)).type(MediaType.xml);
}"
54775,"@TaskAction public void process() throws Throwable {
  try {
    String env=getEnv();
    this.assetFile=new File(getOutput(),""String_Node_Str"" + env + ""String_Node_Str"");
    new JoobyContainer(getProject()).run(getMainClassName(),(app,conf) -> {
      compile(getLogger(),app.getClass().getClassLoader(),env,getMaxAge(),getOutput(),assetFile,getAssemblyOutput(),conf);
    }
,env);
  }
 catch (  CompilationDone ex) {
  }
}","@TaskAction public void process() throws Throwable {
  try {
    String env=getEnv();
    this.assetFile=new File(getOutput(),""String_Node_Str"" + env + ""String_Node_Str"");
    new JoobyContainer(getProject()).run(getMainClassName(),(app,conf) -> compile(getLogger(),app.getClass().getClassLoader(),env,getMaxAge(),getOutput(),assetFile,getAssemblyOutput(),conf),env);
  }
 catch (  CompilationDone ex) {
  }
}"
54776,"private static void compile(final Logger logger,final ClassLoader loader,final String env,final String maxAge,final File output,final File distFile,final File assemblyOutput,Config conf){
  Try.run(() -> {
    output.mkdirs();
    logger.debug(""String_Node_Str"" + loader);
    Config assetConf=ConfigFactory.parseResources(loader,""String_Node_Str"").withFallback(conf);
    logger.debug(""String_Node_Str"" + assetConf.getConfig(""String_Node_Str""));
    AssetCompiler compiler=new AssetCompiler(loader,assetConf);
    AtomicReference<ProgressBar> pb=new AtomicReference<>();
    compiler.setProgressBar((progress,total) -> {
      if (pb.get() == null) {
        pb.set(new ProgressBar(""String_Node_Str"",total).start().stepTo(progress));
      }
 else {
        pb.get().step();
      }
    }
);
    long start=System.currentTimeMillis();
    Map<String,List<File>> fileset=compiler.build(env,output);
    pb.get().stop();
    StringBuilder dist=new StringBuilder();
    dist.append(""String_Node_Str"").append(fileset.entrySet().stream().map(e -> {
      String files=e.getValue().stream().map(file -> output.toPath().relativize(file.toPath())).map(path -> ""String_Node_Str"" + path.toString().replace(""String_Node_Str"",""String_Node_Str"")).collect(Collectors.joining(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
      return ""String_Node_Str"" + e.getKey() + ""String_Node_Str""+ files;
    }
).collect(Collectors.joining(""String_Node_Str""))).append(""String_Node_Str"");
    dist.append(""String_Node_Str"").append(maxAge).append(""String_Node_Str"");
    dist.append(""String_Node_Str"");
    dist.append(""String_Node_Str"");
    dist.append(""String_Node_Str"").append(env).append(""String_Node_Str"");
    try (FileWriter writer=new FileWriter(distFile)){
      writer.write(dist.toString());
    }
     long end=System.currentTimeMillis();
    CharSequence summary=compiler.summary(fileset,output.toPath(),env,end - start,""String_Node_Str"" + assemblyOutput,""String_Node_Str"" + distFile);
    logger.info(summary.toString());
    List<File> files=fileset.values().stream().flatMap(it -> it.stream()).collect(Collectors.toList());
    for (    File from : files) {
      File to=assemblyOutput.toPath().resolve(output.toPath().relativize(from.toPath())).toFile();
      to.getParentFile().mkdirs();
      logger.debug(""String_Node_Str"" + to);
      Files.copy(from,to);
    }
  }
).unwrap(InvocationTargetException.class).throwException();
}","private static void compile(final Logger logger,final ClassLoader loader,final String env,final String maxAge,final File output,final File distFile,final File assemblyOutput,Config conf){
  Try.run(() -> {
    output.mkdirs();
    logger.debug(""String_Node_Str"" + loader);
    Config assetConf=ConfigFactory.parseResources(loader,""String_Node_Str"").withFallback(conf);
    logger.debug(""String_Node_Str"" + assetConf.getConfig(""String_Node_Str""));
    AssetCompiler compiler=new AssetCompiler(loader,assetConf);
    AtomicReference<ProgressBar> pb=new AtomicReference<>();
    compiler.setProgressBar((progress,total) -> {
      if (pb.get() == null) {
        pb.set(new ProgressBar(""String_Node_Str"",total).start().stepTo(progress));
      }
 else {
        pb.get().step();
      }
    }
);
    long start=System.currentTimeMillis();
    Map<String,List<File>> fileset=compiler.build(env,output);
    pb.get().stop();
    StringBuilder dist=new StringBuilder();
    dist.append(""String_Node_Str"").append(fileset.entrySet().stream().map(e -> {
      String files=e.getValue().stream().map(file -> output.toPath().relativize(file.toPath())).map(path -> ""String_Node_Str"" + path.toString().replace(""String_Node_Str"",""String_Node_Str"")).collect(Collectors.joining(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
      return ""String_Node_Str"" + e.getKey() + ""String_Node_Str""+ files;
    }
).collect(Collectors.joining(""String_Node_Str""))).append(""String_Node_Str"");
    dist.append(""String_Node_Str"").append(maxAge).append(""String_Node_Str"");
    dist.append(""String_Node_Str"");
    dist.append(""String_Node_Str"");
    dist.append(""String_Node_Str"").append(env).append(""String_Node_Str"");
    try (FileWriter writer=new FileWriter(distFile)){
      writer.write(dist.toString());
    }
     long end=System.currentTimeMillis();
    CharSequence summary=compiler.summary(fileset,output.toPath(),env,end - start,""String_Node_Str"" + assemblyOutput,""String_Node_Str"" + distFile);
    logger.info(summary.toString());
    List<File> files=fileset.values().stream().flatMap(Collection::stream).collect(Collectors.toList());
    for (    File from : files) {
      File to=assemblyOutput.toPath().resolve(output.toPath().relativize(from.toPath())).toFile();
      to.getParentFile().mkdirs();
      logger.debug(""String_Node_Str"" + to);
      Files.copy(from,to);
    }
  }
).unwrap(InvocationTargetException.class).throwException();
}"
54777,"private SourceSet sourceSet(final Project project){
  SourceSet sourceSet=getJavaConvention(project).getSourceSets().getByName(SourceSet.MAIN_SOURCE_SET_NAME);
  return sourceSet;
}","private SourceSet sourceSet(final Project project){
  return getJavaConvention(project).getSourceSets().getByName(SourceSet.MAIN_SOURCE_SET_NAME);
}"
54778,"public Set<File> sources(){
  SourceSet sourceSet=sourceSet(project);
  Set<File> src=new LinkedHashSet<>();
  sourceSet.getResources().getSrcDirs().forEach(src::add);
  sourceSet.getJava().getSrcDirs().forEach(f -> src.add(f.getParentFile()));
  return src;
}","public Set<File> sources(){
  SourceSet sourceSet=sourceSet(project);
  Set<File> src=new LinkedHashSet<>(sourceSet.getResources().getSrcDirs());
  sourceSet.getJava().getSrcDirs().forEach(f -> src.add(f.getParentFile()));
  return src;
}"
54779,"public Set<File> classpath(){
  SourceSet sourceSet=sourceSet(project);
  Set<File> cp=new LinkedHashSet<>();
  sourceSet.getResources().getSrcDirs().forEach(cp::add);
  sourceSet.getRuntimeClasspath().getFiles().forEach(cp::add);
  Configuration provided=project.getConfigurations().findByName(""String_Node_Str"");
  if (provided != null) {
    provided.getFiles().forEach(cp::add);
  }
  return cp;
}","public Set<File> classpath(){
  SourceSet sourceSet=sourceSet(project);
  Set<File> cp=new LinkedHashSet<>(sourceSet.getResources().getSrcDirs());
  cp.addAll(sourceSet.getRuntimeClasspath().getFiles());
  Configuration provided=project.getConfigurations().findByName(""String_Node_Str"");
  if (provided != null) {
    cp.addAll(provided.getFiles());
  }
  return cp;
}"
54780,"public URLClassLoader newClassLoader() throws MalformedURLException {
  return toClassLoader(classpath().stream().map(throwingFunction(f -> f.toURI().toURL())).collect(Collectors.toList()),getClass().getClassLoader());
}","public URLClassLoader newClassLoader(){
  return toClassLoader(classpath().stream().map(throwingFunction(f -> f.toURI().toURL())).collect(Collectors.toList()),getClass().getClassLoader());
}"
54781,"private Properties toProperties(final Config config){
  Properties properties=new Properties();
  config.withoutPath(""String_Node_Str"").entrySet().forEach(prop -> {
    properties.setProperty(""String_Node_Str"" + prop.getKey(),prop.getValue().unwrapped().toString());
  }
);
  return properties;
}","private Properties toProperties(final Config config){
  Properties properties=new Properties();
  config.withoutPath(""String_Node_Str"").entrySet().forEach(prop -> properties.setProperty(""String_Node_Str"" + prop.getKey(),prop.getValue().unwrapped().toString()));
  return properties;
}"
54782,"@Override public void onCompleted(){
  if (done.compareAndSet(false,true)) {
    deferred.resolve((Object)null);
  }
  deferred=null;
}","@Override public void onCompleted(){
  if (done.compareAndSet(false,true)) {
    deferred.resolve(null);
  }
  deferred=null;
}"
54783,"/** 
 * Append persistent classes (classess annotated with Entity).
 * @param classes Persistent classes.
 * @return This module.
 */
@SuppressWarnings(""String_Node_Str"") public Hbm classes(final Class... classes){
  sources.add((m,c) -> Arrays.asList(classes).stream().forEach(m::addAnnotatedClass));
  return this;
}","/** 
 * Append persistent classes (classess annotated with Entity).
 * @param classes Persistent classes.
 * @return This module.
 */
@SuppressWarnings(""String_Node_Str"") public Hbm classes(final Class... classes){
  sources.add((m,c) -> Arrays.stream(classes).forEach(m::addAnnotatedClass));
  return this;
}"
54784,"/** 
 * Register an hibernate event listener. Listener will be created and injected by Guice.
 * @param type Event type.
 * @param listenerType Listener type.
 * @return This module.
 */
@SuppressWarnings(""String_Node_Str"") public <T>Hbm onEvent(final EventType<T> type,final Class<? extends T> listenerType){
  bindings.add(b -> {
    b.bind(listenerType).asEagerSingleton();
  }
);
  listeners.add((s,r) -> {
    ServiceRegistryImplementor serviceRegistry=s.getServiceRegistry();
    EventListenerRegistry service=serviceRegistry.getService(EventListenerRegistry.class);
    T listener=r.require(listenerType);
    service.appendListeners(type,listener);
  }
);
  return this;
}","/** 
 * Register an hibernate event listener. Listener will be created and injected by Guice.
 * @param type Event type.
 * @param listenerType Listener type.
 * @return This module.
 */
@SuppressWarnings(""String_Node_Str"") public <T>Hbm onEvent(final EventType<T> type,final Class<? extends T> listenerType){
  bindings.add(b -> b.bind(listenerType).asEagerSingleton());
  listeners.add((s,r) -> {
    ServiceRegistryImplementor serviceRegistry=s.getServiceRegistry();
    EventListenerRegistry service=serviceRegistry.getService(EventListenerRegistry.class);
    T listener=r.require(listenerType);
    service.appendListeners(type,listener);
  }
);
  return this;
}"
54785,"public UnitOfWork rollback(){
  active(session,trx -> {
    log.debug(""String_Node_Str"",oid(session),oid(trx));
    trx.rollback();
  }
,trx -> {
    log.warn(""String_Node_Str"",oid(session),oid(trx));
  }
);
  return this;
}","public UnitOfWork rollback(){
  active(session,trx -> {
    log.debug(""String_Node_Str"",oid(session),oid(trx));
    trx.rollback();
  }
,trx -> log.warn(""String_Node_Str"",oid(session),oid(trx)));
  return this;
}"
54786,"public UnitOfWork commit(){
  if (rollbackOnly) {
    return this;
  }
  if (!readOnly) {
    log.debug(""String_Node_Str"",oid(session));
    session.flush();
  }
 else {
    log.debug(""String_Node_Str"",oid(session));
  }
  active(session,trx -> {
    log.debug(""String_Node_Str"",oid(session),oid(trx));
    trx.commit();
  }
,trx -> {
    log.warn(""String_Node_Str"",oid(session),oid(trx));
  }
);
  return this;
}","public UnitOfWork commit(){
  if (rollbackOnly) {
    return this;
  }
  if (!readOnly) {
    log.debug(""String_Node_Str"",oid(session));
    session.flush();
  }
 else {
    log.debug(""String_Node_Str"",oid(session));
  }
  active(session,trx -> {
    log.debug(""String_Node_Str"",oid(session),oid(trx));
    trx.commit();
  }
,trx -> log.warn(""String_Node_Str"",oid(session),oid(trx)));
  return this;
}"
54787,"public UnitOfWork begin(){
  if (rollbackOnly) {
    return this;
  }
  active(session,trx -> {
    log.debug(""String_Node_Str"",oid(session),oid(trx));
  }
,trx -> {
    log.debug(""String_Node_Str"",oid(session),oid(trx));
    trx.begin();
  }
);
  return this;
}","public UnitOfWork begin(){
  if (rollbackOnly) {
    return this;
  }
  active(session,trx -> log.debug(""String_Node_Str"",oid(session),oid(trx)),trx -> {
    log.debug(""String_Node_Str"",oid(session),oid(trx));
    trx.begin();
  }
);
  return this;
}"
54788,"private void onSyncPackageJson(Config conf,Path workDirectory,Throwing.Consumer<String> action) throws IOException {
  Path tmp=Paths.get(conf.getString(""String_Node_Str""),""String_Node_Str"");
  Files.createDirectories(tmp);
  Throwing.Consumer<String> syncPackageJson=existingSha1 -> {
    Path packageJson=workDirectory.resolve(""String_Node_Str"");
    String sha1=Hashing.sha1().hashBytes(Files.readAllBytes(packageJson)).toString();
    if (!existingSha1.equals(sha1)) {
      action.accept(""String_Node_Str"");
      Files.write(tmp.resolve(""String_Node_Str"" + sha1),Arrays.asList(""String_Node_Str""));
    }
  }
;
  if (!Files.exists(workDirectory.resolve(""String_Node_Str""))) {
    syncPackageJson.accept(""String_Node_Str"");
  }
 else {
    String existingSha1=Files.find(tmp,1,(path,attr) -> path.getFileName().toString().startsWith(""String_Node_Str"")).findFirst().map(path -> path.getFileName().toString().replace(""String_Node_Str"",""String_Node_Str"")).orElse(""String_Node_Str"");
    syncPackageJson.accept(existingSha1);
  }
}","private void onSyncPackageJson(Config conf,Path workDirectory,Throwing.Consumer<String> action) throws IOException {
  Path tmp=Paths.get(conf.getString(""String_Node_Str""),""String_Node_Str"");
  Files.createDirectories(tmp);
  String sha1=Hashing.sha1().hashBytes(Files.readAllBytes(workDirectory.resolve(""String_Node_Str""))).toString();
  Path lastSha1=tmp.resolve(sha1 + ""String_Node_Str"");
  if (!Files.exists(lastSha1) || !Files.exists(workDirectory.resolve(""String_Node_Str""))) {
    action.accept(""String_Node_Str"");
    Files.write(tmp.resolve(lastSha1),Arrays.asList(""String_Node_Str""));
  }
}"
54789,"@Override public void execute() throws MojoExecutionException, MojoFailureException {
  try {
    Path srcdir=new File(mavenProject.getBuild().getSourceDirectory()).toPath();
    Path bindir=new File(mavenProject.getBuild().getOutputDirectory()).toPath();
    new JoobyRunner(mavenProject).run(mainClass,(app,conf) -> {
      process(app,srcdir,bindir);
    }
);
  }
 catch (  Throwable ex) {
    throw new MojoFailureException(""String_Node_Str"" + mainClass,ex);
  }
}","@Override public void execute() throws MojoExecutionException, MojoFailureException {
  if (mainClass == null) {
    throw new MojoExecutionException(""String_Node_Str"");
  }
  try {
    Path srcdir=new File(mavenProject.getBuild().getSourceDirectory()).toPath();
    Path bindir=new File(mavenProject.getBuild().getOutputDirectory()).toPath();
    new JoobyRunner(mavenProject).run(mainClass,(app,conf) -> {
      process(app,srcdir,bindir);
    }
);
  }
 catch (  Throwable ex) {
    throw new MojoFailureException(""String_Node_Str"" + mainClass,ex);
  }
}"
54790,"private void handleErr(final RequestImpl req,final ResponseImpl rsp,final Throwable ex){
  try {
    log.debug(""String_Node_Str"",req.method(),req.path(),ex);
    Status status=sc.apply(ex);
    if (status == Status.REQUESTED_RANGE_NOT_SATISFIABLE) {
      String range=rsp.header(""String_Node_Str"").toOptional().map(it -> ""String_Node_Str"" + it).orElse(""String_Node_Str"");
      rsp.reset();
      rsp.header(""String_Node_Str"",range);
    }
 else {
      rsp.reset();
    }
    rsp.header(""String_Node_Str"",NO_CACHE);
    rsp.status(status);
    Err err=ex instanceof Err ? (Err)ex : new Err(status,ex);
    Iterator<Handler> it=this.err.iterator();
    while (!rsp.committed() && it.hasNext()) {
      Err.Handler next=it.next();
      log.debug(""String_Node_Str"",next);
      next.handle(req,rsp,err);
    }
  }
 catch (  Throwable errex) {
    log.error(""String_Node_Str"",req.method(),req.path(),Throwables.getStackTraceAsString(errex),ex);
  }
}","private void handleErr(final RequestImpl req,final ResponseImpl rsp,final Throwable ex){
  try {
    log.debug(""String_Node_Str"",req.method(),req.path(),ex);
    Status status=sc.apply(ex);
    if (status == Status.REQUESTED_RANGE_NOT_SATISFIABLE) {
      String range=rsp.header(""String_Node_Str"").toOptional().map(it -> ""String_Node_Str"" + it).orElse(""String_Node_Str"");
      rsp.reset();
      rsp.header(""String_Node_Str"",range);
    }
 else {
      rsp.reset();
    }
    rsp.header(""String_Node_Str"",NO_CACHE);
    rsp.status(status);
    Err err=ex instanceof Err ? (Err)ex : new Err(status,ex);
    Iterator<Handler> it=this.err.iterator();
    while (!rsp.committed() && it.hasNext()) {
      Err.Handler next=it.next();
      log.debug(""String_Node_Str"",next);
      next.handle(req,rsp,err);
    }
  }
 catch (  Throwable errex) {
    log.error(""String_Node_Str"",req.method(),req.path(),req.route().print(6),Throwables.getStackTraceAsString(errex),ex);
  }
}"
54791,"@Inject public ServerExecutorProvider(final Server server){
  executor=requireNonNull(server,""String_Node_Str"").executor().orElse(MoreExecutors.directExecutor());
}","@Inject public ServerExecutorProvider(final ServerHolder serverHolder){
  requireNonNull(serverHolder,""String_Node_Str"");
  executor=(serverHolder.server != null) ? serverHolder.server.executor().orElse(MoreExecutors.directExecutor()) : MoreExecutors.directExecutor();
}"
54792,"private String sha1(final File dir) throws IOException {
  try (Stream<Path> stream=Files.walk(dir.toPath())){
    Hasher sha1=Hashing.sha1().newHasher();
    stream.filter(p -> !Files.isDirectory(p)).forEach(p -> Try.run(() -> sha1.putBytes(Files.readAllBytes(p))));
    return BaseEncoding.base16().encode(sha1.hash().asBytes()).toLowerCase();
  }
 }","private String sha1(final File dir,final File sprite,final File css) throws IOException {
  try (Stream<Path> stream=Files.walk(dir.toPath())){
    Hasher sha1=Hashing.sha1().newHasher();
    stream.filter(p -> !Files.isDirectory(p)).forEach(p -> Try.run(() -> sha1.putBytes(Files.readAllBytes(p))));
    if (sprite.exists()) {
      sha1.putBytes(Files.readAllBytes(sprite.toPath()));
    }
    if (css.exists()) {
      sha1.putBytes(Files.readAllBytes(css.toPath()));
    }
    return BaseEncoding.base16().encode(sha1.hash().asBytes()).toLowerCase();
  }
 }"
54793,"public String spritePath(){
  String spritePath=get(""String_Node_Str"");
  if (spritePath == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (spritePath.endsWith(""String_Node_Str"")) {
    return spritePath;
  }
 else {
    return spritePath + ""String_Node_Str"" + prefix(""String_Node_Str"")+ prefix(""String_Node_Str"")+ ""String_Node_Str"";
  }
}","public String spritePath(){
  return nameFor(""String_Node_Str"",""String_Node_Str"");
}"
54794,"public String cssPath(){
  String cssPath=get(""String_Node_Str"");
  if (cssPath == null) {
    return spritePath().replace(""String_Node_Str"",""String_Node_Str"");
  }
  return cssPath;
}","public String cssPath(){
  try {
    return nameFor(""String_Node_Str"",""String_Node_Str"");
  }
 catch (  IllegalArgumentException x) {
    return spritePath().replace(""String_Node_Str"",""String_Node_Str"");
  }
}"
54795,"@Override public void run(final Config conf) throws Exception {
  File spriteElementPath=resolve(get(""String_Node_Str"").toString());
  if (!spriteElementPath.exists()) {
    throw new FileNotFoundException(spriteElementPath.toString());
  }
  String sha1=new File(spritePath()).getName().replace(""String_Node_Str"",""String_Node_Str"" + sha1(spriteElementPath) + ""String_Node_Str"");
  File uptodate=Paths.get(System.getProperty(""String_Node_Str""),""String_Node_Str"",sha1).toFile();
  if (uptodate.exists()) {
    log.debug(""String_Node_Str"",uptodate);
    return;
  }
  Nodejs.run(node -> {
    node.overwrite(conf.hasPath(""String_Node_Str"") ? conf.getBoolean(""String_Node_Str"") : false).exec(""String_Node_Str"",v8 -> {
      Map<String,Object> options=options();
      options.put(""String_Node_Str"",resolve(spritePath()).toString());
      options.put(""String_Node_Str"",resolve(cssPath()).toString());
      options.put(""String_Node_Str"",spriteElementPath.toString());
      log.debug(""String_Node_Str"",options.entrySet().stream().map(e -> e.getKey() + ""String_Node_Str"" + e.getValue()).collect(Collectors.joining(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
      v8.add(""String_Node_Str"",toV8Object(v8,options));
      v8.add(""String_Node_Str"",new V8Function(v8,(receiver,params) -> {
        String svgPath=params.get(0).toString();
        String pngPath=params.get(1).toString();
        Float w=new Float(params.getDouble(2));
        Float h=new Float(params.getDouble(3));
        V8Function callback=(V8Function)params.get(4);
        Try.run(() -> {
          try (FileReader in=new FileReader(svgPath);OutputStream out=new FileOutputStream(pngPath)){
            PNGTranscoder transcoder=new PNGTranscoder();
            transcoder.addTranscodingHint(PNGTranscoder.KEY_WIDTH,w);
            transcoder.addTranscodingHint(PNGTranscoder.KEY_HEIGHT,h);
            transcoder.transcode(new TranscoderInput(in),new TranscoderOutput(out));
          }
         }
).onSuccess(v -> callback.call(null,null)).onFailure(x -> {
          log.debug(""String_Node_Str"",x);
          callback.call(null,toV8Array(v8,Arrays.asList(x.getMessage())));
        }
);
        return V8.UNDEFINED;
      }
));
    }
);
  }
);
  log.debug(""String_Node_Str"",uptodate);
  uptodate.getParentFile().mkdirs();
  Files.createFile(uptodate.toPath());
  uptodate.deleteOnExit();
}","@Override public void run(final Config conf) throws Exception {
  File spriteElementPath=resolve(get(""String_Node_Str"").toString());
  if (!spriteElementPath.exists()) {
    throw new FileNotFoundException(spriteElementPath.toString());
  }
  File workdir=new File(Try.of(() -> conf.getString(""String_Node_Str"")).getOrElse(System.getProperty(""String_Node_Str"")));
  File spritePath=resolve(spritePath());
  File cssPath=resolve(cssPath());
  String sha1=new File(spritePath()).getName().replace(""String_Node_Str"",""String_Node_Str"" + sha1(spriteElementPath,spritePath,cssPath) + ""String_Node_Str"");
  File uptodate=workdir.toPath().resolve(""String_Node_Str"").resolve(sha1).toFile();
  if (uptodate.exists()) {
    log.info(""String_Node_Str"",uptodate);
    return;
  }
  Nodejs.run(workdir,node -> {
    node.overwrite(conf.hasPath(""String_Node_Str"") ? conf.getBoolean(""String_Node_Str"") : false).exec(""String_Node_Str"",v8 -> {
      Map<String,Object> options=options();
      options.put(""String_Node_Str"",spritePath.toString());
      options.put(""String_Node_Str"",cssPath.toString());
      options.put(""String_Node_Str"",spriteElementPath.toString());
      log.debug(""String_Node_Str"",options.entrySet().stream().map(e -> e.getKey() + ""String_Node_Str"" + e.getValue()).collect(Collectors.joining(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"")));
      v8.add(""String_Node_Str"",toV8Object(v8,options));
      v8.add(""String_Node_Str"",new V8Function(v8,(receiver,params) -> {
        String svgPath=params.get(0).toString();
        String pngPath=params.get(1).toString();
        Float w=new Float(params.getDouble(2));
        Float h=new Float(params.getDouble(3));
        V8Function callback=(V8Function)params.get(4);
        Try.run(() -> {
          try (FileReader in=new FileReader(svgPath);OutputStream out=new FileOutputStream(pngPath)){
            PNGTranscoder transcoder=new PNGTranscoder();
            transcoder.addTranscodingHint(PNGTranscoder.KEY_WIDTH,w);
            transcoder.addTranscodingHint(PNGTranscoder.KEY_HEIGHT,h);
            transcoder.transcode(new TranscoderInput(in),new TranscoderOutput(out));
          }
         }
).onSuccess(v -> callback.call(null,null)).onFailure(x -> {
          log.debug(""String_Node_Str"",x);
          callback.call(null,toV8Array(v8,Arrays.asList(x.getMessage())));
        }
);
        return V8.UNDEFINED;
      }
));
    }
);
  }
);
  log.debug(""String_Node_Str"",uptodate);
  uptodate.getParentFile().mkdirs();
  try (Stream<Path> sha1files=Files.walk(uptodate.getParentFile().toPath()).filter(it -> it.toString().endsWith(""String_Node_Str""))){
    sha1files.forEach(it -> Try.run(() -> Files.delete(it)));
  }
   Files.createFile(uptodate.toPath());
  uptodate.deleteOnExit();
}"
54796,"private void start(final String[] args,final Consumer<List<Route.Definition>> routes) throws Throwable {
  long start=System.currentTimeMillis();
  started.set(true);
  this.injector=bootstrap(args(args),routes);
  Runtime.getRuntime().addShutdownHook(new Thread(() -> stop()));
  Config conf=injector.getInstance(Config.class);
  Logger log=logger(this);
  if (log.isDebugEnabled()) {
    String desc=configTree(conf.origin().description());
    log.debug(""String_Node_Str"",desc);
  }
  for (  CheckedConsumer<Registry> onStart : this.onStart) {
    onStart.accept(this);
  }
  Set<Route.Definition> routeDefs=injector.getInstance(Route.KEY);
  Set<WebSocket.Definition> sockets=injector.getInstance(WebSocket.KEY);
  if (mapper != null) {
    routeDefs.forEach(it -> it.map(mapper));
  }
  Server server=injector.getInstance(Server.class);
  String serverName=server.getClass().getSimpleName().replace(""String_Node_Str"",""String_Node_Str"").toLowerCase();
  server.start();
  long end=System.currentTimeMillis();
  log.info(""String_Node_Str"",conf.getString(""String_Node_Str""),serverName,end - start,new AppPrinter(routeDefs,sockets,conf));
  boolean join=conf.hasPath(""String_Node_Str"") ? conf.getBoolean(""String_Node_Str"") : true;
  if (join) {
    server.join();
  }
}","private void start(final String[] args,final Consumer<List<Route.Definition>> routes) throws Throwable {
  long start=System.currentTimeMillis();
  started.set(true);
  this.injector=bootstrap(args(args),routes);
  Runtime.getRuntime().addShutdownHook(new Thread(() -> stop()));
  Config conf=injector.getInstance(Config.class);
  Logger log=logger(this);
  for (  CheckedConsumer<Registry> onStart : this.onStart) {
    onStart.accept(this);
  }
  Set<Route.Definition> routeDefs=injector.getInstance(Route.KEY);
  Set<WebSocket.Definition> sockets=injector.getInstance(WebSocket.KEY);
  if (mapper != null) {
    routeDefs.forEach(it -> it.map(mapper));
  }
  AppPrinter printer=new AppPrinter(routeDefs,sockets,conf);
  printer.printConf(log,conf);
  Server server=injector.getInstance(Server.class);
  String serverName=server.getClass().getSimpleName().replace(""String_Node_Str"",""String_Node_Str"").toLowerCase();
  server.start();
  long end=System.currentTimeMillis();
  log.info(""String_Node_Str"",conf.getString(""String_Node_Str""),serverName,end - start,printer);
  boolean join=conf.hasPath(""String_Node_Str"") ? conf.getBoolean(""String_Node_Str"") : true;
  if (join) {
    server.join();
  }
}"
54797,"@Test public void stopOnServerFailure() throws Exception {
  new MockUnit(Binder.class).expect(unit -> {
    Server server=unit.mock(Server.class);
    server.start();
    server.join();
    server.stop();
    expectLastCall().andThrow(new Exception());
    ScopedBindingBuilder serverScope=unit.mock(ScopedBindingBuilder.class);
    serverScope.in(Singleton.class);
    expectLastCall().times(0,1);
    AnnotatedBindingBuilder<Server> serverBinding=unit.mock(AnnotatedBindingBuilder.class);
    expect(serverBinding.to(isA(Class.class))).andReturn(serverScope).times(0,1);
    Binder binder=unit.get(Binder.class);
    expect(binder.bind(Server.class)).andReturn(serverBinding).times(0,1);
    unit.constructor(AppPrinter.class).args(Set.class,Set.class,Config.class).build(isA(Set.class),isA(Set.class),isA(Config.class));
    Config config=unit.mock(Config.class);
    expect(config.getString(""String_Node_Str"")).andReturn(""String_Node_Str"");
    expect(config.hasPath(""String_Node_Str"")).andReturn(true);
    expect(config.getBoolean(""String_Node_Str"")).andReturn(true);
    Injector injector=unit.mock(Injector.class);
    expect(injector.getInstance(Server.class)).andReturn(server).times(1,2);
    expect(injector.getInstance(Config.class)).andReturn(config);
    expect(injector.getInstance(Route.KEY)).andReturn(Collections.emptySet());
    expect(injector.getInstance(WebSocket.KEY)).andReturn(Collections.emptySet());
    unit.mockStatic(Guice.class);
    expect(Guice.createInjector(eq(Stage.DEVELOPMENT),unit.capture(Module.class))).andReturn(injector);
    unit.mockStatic(OptionalBinder.class);
    TypeConverters tc=unit.mockConstructor(TypeConverters.class);
    tc.configure(binder);
  }
).expect(shutdown).expect(config).expect(env).expect(classInfo).expect(ssl).expect(charset).expect(locale).expect(zoneId).expect(timeZone).expect(dateTimeFormatter).expect(numberFormat).expect(decimalFormat).expect(renderers).expect(session).expect(routes).expect(routeHandler).expect(params).expect(requestScope).expect(webSockets).expect(tmpdir).expect(err).expect(executor(""String_Node_Str"")).run(unit -> {
    Jooby jooby=new Jooby();
    jooby.start();
  }
,boot);
}","@Test public void stopOnServerFailure() throws Exception {
  new MockUnit(Binder.class).expect(unit -> {
    Server server=unit.mock(Server.class);
    server.start();
    server.join();
    server.stop();
    expectLastCall().andThrow(new Exception());
    ScopedBindingBuilder serverScope=unit.mock(ScopedBindingBuilder.class);
    serverScope.in(Singleton.class);
    expectLastCall().times(0,1);
    AnnotatedBindingBuilder<Server> serverBinding=unit.mock(AnnotatedBindingBuilder.class);
    expect(serverBinding.to(isA(Class.class))).andReturn(serverScope).times(0,1);
    Binder binder=unit.get(Binder.class);
    expect(binder.bind(Server.class)).andReturn(serverBinding).times(0,1);
    Config config=unit.mock(Config.class);
    expect(config.getString(""String_Node_Str"")).andReturn(""String_Node_Str"");
    expect(config.hasPath(""String_Node_Str"")).andReturn(true);
    expect(config.getBoolean(""String_Node_Str"")).andReturn(true);
    AppPrinter printer=unit.constructor(AppPrinter.class).args(Set.class,Set.class,Config.class).build(isA(Set.class),isA(Set.class),isA(Config.class));
    printer.printConf(isA(Logger.class),eq(config));
    Injector injector=unit.mock(Injector.class);
    expect(injector.getInstance(Server.class)).andReturn(server).times(1,2);
    expect(injector.getInstance(Config.class)).andReturn(config);
    expect(injector.getInstance(Route.KEY)).andReturn(Collections.emptySet());
    expect(injector.getInstance(WebSocket.KEY)).andReturn(Collections.emptySet());
    unit.mockStatic(Guice.class);
    expect(Guice.createInjector(eq(Stage.DEVELOPMENT),unit.capture(Module.class))).andReturn(injector);
    unit.mockStatic(OptionalBinder.class);
    TypeConverters tc=unit.mockConstructor(TypeConverters.class);
    tc.configure(binder);
  }
).expect(shutdown).expect(config).expect(env).expect(classInfo).expect(ssl).expect(charset).expect(locale).expect(zoneId).expect(timeZone).expect(dateTimeFormatter).expect(numberFormat).expect(decimalFormat).expect(renderers).expect(session).expect(routes).expect(routeHandler).expect(params).expect(requestScope).expect(webSockets).expect(tmpdir).expect(err).expect(executor(""String_Node_Str"")).run(unit -> {
    Jooby jooby=new Jooby();
    jooby.start();
  }
,boot);
}"
54798,"@Test public void applicationSecret() throws Exception {
  new MockUnit(Binder.class).expect(unit -> {
    Server server=unit.mock(Server.class);
    server.start();
    server.join();
    server.stop();
    ScopedBindingBuilder serverScope=unit.mock(ScopedBindingBuilder.class);
    serverScope.in(Singleton.class);
    expectLastCall().times(0,1);
    AnnotatedBindingBuilder<Server> serverBinding=unit.mock(AnnotatedBindingBuilder.class);
    expect(serverBinding.to(isA(Class.class))).andReturn(serverScope).times(0,1);
    Binder binder=unit.get(Binder.class);
    expect(binder.bind(Server.class)).andReturn(serverBinding).times(0,1);
    unit.constructor(AppPrinter.class).args(Set.class,Set.class,Config.class).build(isA(Set.class),isA(Set.class),isA(Config.class));
    Config config=unit.mock(Config.class);
    expect(config.getString(""String_Node_Str"")).andReturn(""String_Node_Str"");
    expect(config.hasPath(""String_Node_Str"")).andReturn(true);
    expect(config.getBoolean(""String_Node_Str"")).andReturn(true);
    Injector injector=unit.mock(Injector.class);
    expect(injector.getInstance(Server.class)).andReturn(server).times(1,2);
    expect(injector.getInstance(Config.class)).andReturn(config);
    expect(injector.getInstance(Route.KEY)).andReturn(Collections.emptySet());
    expect(injector.getInstance(WebSocket.KEY)).andReturn(Collections.emptySet());
    unit.mockStatic(Guice.class);
    expect(Guice.createInjector(eq(Stage.PRODUCTION),unit.capture(Module.class))).andReturn(injector);
    unit.mockStatic(OptionalBinder.class);
    TypeConverters tc=unit.mockConstructor(TypeConverters.class);
    tc.configure(binder);
  }
).expect(shutdown).expect(config).expect(ssl).expect(env).expect(classInfo).expect(charset).expect(locale).expect(zoneId).expect(timeZone).expect(dateTimeFormatter).expect(numberFormat).expect(decimalFormat).expect(renderers).expect(session).expect(routes).expect(routeHandler).expect(params).expect(requestScope).expect(webSockets).expect(tmpdir).expect(err).expect(executor(""String_Node_Str"")).run(unit -> {
    Jooby jooby=new Jooby();
    jooby.use(ConfigFactory.empty().withValue(""String_Node_Str"",ConfigValueFactory.fromAnyRef(""String_Node_Str"")).withValue(""String_Node_Str"",ConfigValueFactory.fromAnyRef(""String_Node_Str"")));
    jooby.start();
  }
,boot);
}","@Test public void applicationSecret() throws Exception {
  new MockUnit(Binder.class).expect(unit -> {
    Server server=unit.mock(Server.class);
    server.start();
    server.join();
    server.stop();
    ScopedBindingBuilder serverScope=unit.mock(ScopedBindingBuilder.class);
    serverScope.in(Singleton.class);
    expectLastCall().times(0,1);
    AnnotatedBindingBuilder<Server> serverBinding=unit.mock(AnnotatedBindingBuilder.class);
    expect(serverBinding.to(isA(Class.class))).andReturn(serverScope).times(0,1);
    Binder binder=unit.get(Binder.class);
    expect(binder.bind(Server.class)).andReturn(serverBinding).times(0,1);
    Config config=unit.mock(Config.class);
    expect(config.getString(""String_Node_Str"")).andReturn(""String_Node_Str"");
    expect(config.hasPath(""String_Node_Str"")).andReturn(true);
    expect(config.getBoolean(""String_Node_Str"")).andReturn(true);
    AppPrinter printer=unit.constructor(AppPrinter.class).args(Set.class,Set.class,Config.class).build(isA(Set.class),isA(Set.class),isA(Config.class));
    printer.printConf(isA(Logger.class),eq(config));
    Injector injector=unit.mock(Injector.class);
    expect(injector.getInstance(Server.class)).andReturn(server).times(1,2);
    expect(injector.getInstance(Config.class)).andReturn(config);
    expect(injector.getInstance(Route.KEY)).andReturn(Collections.emptySet());
    expect(injector.getInstance(WebSocket.KEY)).andReturn(Collections.emptySet());
    unit.mockStatic(Guice.class);
    expect(Guice.createInjector(eq(Stage.PRODUCTION),unit.capture(Module.class))).andReturn(injector);
    unit.mockStatic(OptionalBinder.class);
    TypeConverters tc=unit.mockConstructor(TypeConverters.class);
    tc.configure(binder);
  }
).expect(shutdown).expect(config).expect(ssl).expect(env).expect(classInfo).expect(charset).expect(locale).expect(zoneId).expect(timeZone).expect(dateTimeFormatter).expect(numberFormat).expect(decimalFormat).expect(renderers).expect(session).expect(routes).expect(routeHandler).expect(params).expect(requestScope).expect(webSockets).expect(tmpdir).expect(err).expect(executor(""String_Node_Str"")).run(unit -> {
    Jooby jooby=new Jooby();
    jooby.use(ConfigFactory.empty().withValue(""String_Node_Str"",ConfigValueFactory.fromAnyRef(""String_Node_Str"")).withValue(""String_Node_Str"",ConfigValueFactory.fromAnyRef(""String_Node_Str"")));
    jooby.start();
  }
,boot);
}"
54799,"private Path deploy(final String library) throws Exception {
  URL url=loader.getResource(library);
  if (url == null) {
    throw new FileNotFoundException(library);
  }
  URI uri=url.toURI();
  log.debug(""String_Node_Str"",uri);
  Path outdir=this.basedir.toPath().resolve(""String_Node_Str"").resolve(library.replace(""String_Node_Str"",""String_Node_Str""));
  Optional<Path> basedir=Try.of(() -> Paths.get(uri)).toJavaOptional();
  try (Library lib=loadLibrary(uri)){
    try (Stream<Path> stream=lib.stream()){
      stream.filter(it -> !Files.isDirectory(it)).forEach(it -> {
        String relative=basedir.map(d -> d.relativize(it).toString()).orElse(it.toString().substring(1));
        Path output=outdir.resolve(relative);
        File fout=output.toFile();
        boolean copy=!fout.exists() || coptions.contains(StandardCopyOption.REPLACE_EXISTING);
        if (copy) {
          log.info(""String_Node_Str"",it,fout);
          fout.getParentFile().mkdirs();
          StandardCopyOption[] coptions=this.coptions.toArray(new StandardCopyOption[this.coptions.size()]);
          Try.run(() -> Files.copy(it,output,coptions)).onFailure(x -> log.error(""String_Node_Str"",it,x));
        }
      }
);
    }
   }
   return outdir;
}","private Path deploy(final String library) throws Exception {
  URL url=loader.getResource(library);
  if (url == null) {
    throw new FileNotFoundException(library);
  }
  URI uri=url.toURI();
  log.debug(""String_Node_Str"",uri);
  Path outdir=this.basedir.toPath().resolve(""String_Node_Str"").resolve(library.replace(""String_Node_Str"",""String_Node_Str""));
  Optional<Path> basedir=Try.of(() -> Paths.get(uri)).toJavaOptional();
  try (Library lib=loadLibrary(uri)){
    try (Stream<Path> stream=lib.stream()){
      stream.filter(it -> !Files.isDirectory(it)).forEach(it -> {
        String relative=basedir.map(d -> d.relativize(it).toString()).orElse(it.toString().substring(1));
        Path output=outdir.resolve(relative);
        File fout=output.toFile();
        boolean copy=!fout.exists() || coptions.contains(StandardCopyOption.REPLACE_EXISTING);
        if (copy) {
          log.debug(""String_Node_Str"",it,fout);
          fout.getParentFile().mkdirs();
          StandardCopyOption[] coptions=this.coptions.toArray(new StandardCopyOption[this.coptions.size()]);
          Try.run(() -> Files.copy(it,output,coptions)).onFailure(x -> log.error(""String_Node_Str"",it,x));
        }
      }
);
    }
   }
   return outdir;
}"
54800,"@SuppressWarnings(""String_Node_Str"") @Override public void execute() throws MojoExecutionException, MojoFailureException {
  boolean js=new File(""String_Node_Str"").exists();
  if (js) {
    mainClass=""String_Node_Str"";
  }
  Set<File> appcp=new LinkedHashSet<File>();
  appcp.addAll(resources(mavenProject.getResources()));
  appcp.add(new File(buildOutputDirectory));
  Set<Artifact> artifacts=new LinkedHashSet<Artifact>(mavenProject.getArtifacts());
  artifacts.forEach(artifact -> {
    if (!""String_Node_Str"".equals(artifact.getType())) {
      appcp.add(new File(artifact.getFile().getAbsolutePath()));
    }
  }
);
  Set<File> classpath=new LinkedHashSet<>();
  File hotreload=extra(pluginArtifacts,""String_Node_Str"").get();
  File jbossModules=extra(pluginArtifacts,""String_Node_Str"").get();
  classpath.add(hotreload);
  classpath.add(jbossModules);
  List<Command> cmds=new ArrayList<>();
  if (commands != null && commands.size() > 0) {
    cmds.addAll(this.commands);
  }
  String includes=null;
  if (this.includes != null && this.includes.size() > 0) {
    includes=this.includes.stream().collect(Collectors.joining(""String_Node_Str""));
  }
  String excludes=null;
  if (this.excludes != null && this.excludes.size() > 0) {
    excludes=this.excludes.stream().collect(Collectors.joining(""String_Node_Str""));
  }
  String mId=mavenProject.getGroupId() + ""String_Node_Str"" + mavenProject.getArtifactId();
  setLogback();
  System.setProperty(""String_Node_Str"",mavenProject.getVersion());
  Command runapp=fork ? new RunForkedApp(mavenProject.getBasedir(),debug,vmArgs,classpath,mId,mainClass,appcp,includes,excludes) : new RunApp(mId,mainClass,appcp,includes,excludes);
  cmds.add(runapp);
  for (  Command cmd : cmds) {
    cmd.setWorkdir(mavenProject.getBasedir());
    getLog().debug(""String_Node_Str"" + cmd.debug());
  }
  Watcher watcher=setupCompiler(mavenProject,compiler,goal -> {
    maven.execute(DefaultMavenExecutionRequest.copy(session.getRequest()).setGoals(Arrays.asList(goal)));
  }
);
  ShutdownHook shutdownHook=new ShutdownHook(getLog(),cmds);
  shutdownHook.watcher=watcher;
  Runtime.getRuntime().addShutdownHook(shutdownHook);
  if (watcher != null) {
    watcher.start();
  }
  for (  Command cmd : cmds) {
    try {
      getLog().debug(""String_Node_Str"" + cmd.debug());
      cmd.execute();
    }
 catch (    Exception ex) {
      throw new MojoFailureException(""String_Node_Str"" + cmd + ""String_Node_Str"",ex);
    }
  }
}","@SuppressWarnings(""String_Node_Str"") @Override public void execute() throws MojoExecutionException, MojoFailureException {
  Set<File> appcp=new LinkedHashSet<File>();
  appcp.addAll(resources(mavenProject.getResources()));
  appcp.add(new File(buildOutputDirectory));
  Set<Artifact> artifacts=new LinkedHashSet<Artifact>(mavenProject.getArtifacts());
  artifacts.forEach(artifact -> {
    if (!""String_Node_Str"".equals(artifact.getType())) {
      appcp.add(new File(artifact.getFile().getAbsolutePath()));
    }
  }
);
  Set<File> classpath=new LinkedHashSet<>();
  File hotreload=extra(pluginArtifacts,""String_Node_Str"").get();
  File jbossModules=extra(pluginArtifacts,""String_Node_Str"").get();
  classpath.add(hotreload);
  classpath.add(jbossModules);
  List<Command> cmds=new ArrayList<>();
  if (commands != null && commands.size() > 0) {
    cmds.addAll(this.commands);
  }
  String includes=null;
  if (this.includes != null && this.includes.size() > 0) {
    includes=this.includes.stream().collect(Collectors.joining(""String_Node_Str""));
  }
  String excludes=null;
  if (this.excludes != null && this.excludes.size() > 0) {
    excludes=this.excludes.stream().collect(Collectors.joining(""String_Node_Str""));
  }
  String mId=mavenProject.getGroupId() + ""String_Node_Str"" + mavenProject.getArtifactId();
  setLogback();
  System.setProperty(""String_Node_Str"",mavenProject.getVersion());
  Command runapp=fork ? new RunForkedApp(mavenProject.getBasedir(),debug,vmArgs,classpath,mId,mainClass,appcp,includes,excludes) : new RunApp(mId,mainClass,appcp,includes,excludes);
  cmds.add(runapp);
  for (  Command cmd : cmds) {
    cmd.setWorkdir(mavenProject.getBasedir());
    getLog().debug(""String_Node_Str"" + cmd.debug());
  }
  Watcher watcher=setupCompiler(mavenProject,compiler,goal -> {
    maven.execute(DefaultMavenExecutionRequest.copy(session.getRequest()).setGoals(Arrays.asList(goal)));
  }
);
  ShutdownHook shutdownHook=new ShutdownHook(getLog(),cmds);
  shutdownHook.watcher=watcher;
  Runtime.getRuntime().addShutdownHook(shutdownHook);
  if (watcher != null) {
    watcher.start();
  }
  for (  Command cmd : cmds) {
    try {
      getLog().debug(""String_Node_Str"" + cmd.debug());
      cmd.execute();
    }
 catch (    Exception ex) {
      throw new MojoFailureException(""String_Node_Str"" + cmd + ""String_Node_Str"",ex);
    }
  }
}"
54801,"/** 
 * Build a flat jboss module, with some minor exceptions (like j2v8).
 * @param name module name.
 * @param mainClass
 * @param cp
 * @return
 * @throws Exception
 */
public static AppModuleLoader build(final String name,final String mainClass,final File... cp) throws Exception {
  Map<ModuleIdentifier,ModuleSpec> modules=newModule(name,mainClass,0,""String_Node_Str"",cp);
  return new AppModuleLoader(modules);
}","/** 
 * Build a flat jboss module, with some minor exceptions (like j2v8).
 * @param name module name.
 * @param cp
 * @return
 * @throws Exception
 */
public static AppModuleLoader build(final String name,final File... cp) throws Exception {
  Map<ModuleIdentifier,ModuleSpec> modules=newModule(name,0,""String_Node_Str"",cp);
  return new AppModuleLoader(modules);
}"
54802,"private static Map<ModuleIdentifier,ModuleSpec> newModule(final String name,final String mainClass,final int level,final String prefix,final File... cp) throws Exception {
  Map<ModuleIdentifier,ModuleSpec> modules=new HashMap<>();
  String mId=name.replace(""String_Node_Str"",""String_Node_Str"");
  ModuleSpec.Builder builder=ModuleSpec.build(ModuleIdentifier.fromString(mId));
  int l=(prefix.length() + mId.length() + level);
  Main.debug(""String_Node_Str"" + l + ""String_Node_Str"",prefix + mId);
  for (  File file : cp) {
    String fname=""String_Node_Str"" + file.getAbsolutePath();
    if (file.getName().startsWith(""String_Node_Str"") && !name.equals(file.getName())) {
      ModuleSpec dependency=newModule(file.getName(),null,level + 2,""String_Node_Str"",file).values().iterator().next();
      builder.addDependency(DependencySpec.createModuleDependencySpec(dependency.getModuleIdentifier()));
      modules.put(dependency.getModuleIdentifier(),dependency);
    }
 else {
      Main.debug(""String_Node_Str"" + (fname.length() + level + 2) + ""String_Node_Str"",fname);
      if (file.getName().endsWith(""String_Node_Str"")) {
        builder.addResourceRoot(ResourceLoaderSpec.createResourceLoaderSpec(ResourceLoaders.createJarResourceLoader(file.getName(),new JarFile(file))));
      }
 else {
        builder.addResourceRoot(ResourceLoaderSpec.createResourceLoaderSpec(ResourceLoaders.createFileResourceLoader(file.getName(),file)));
      }
    }
  }
  Set<String> sysPaths=sysPaths();
  Main.trace(""String_Node_Str"");
  sysPaths.forEach(p -> Main.trace(""String_Node_Str"",p));
  builder.addDependency(DependencySpec.createSystemDependencySpec(sysPaths));
  builder.addDependency(DependencySpec.createLocalDependencySpec());
  if (mainClass != null) {
    builder.setMainClass(mainClass);
  }
  ModuleSpec module=builder.create();
  modules.put(module.getModuleIdentifier(),builder.create());
  return modules;
}","private static Map<ModuleIdentifier,ModuleSpec> newModule(final String name,final int level,final String prefix,final File... cp) throws Exception {
  Map<ModuleIdentifier,ModuleSpec> modules=new HashMap<>();
  String mId=name.replace(""String_Node_Str"",""String_Node_Str"");
  ModuleSpec.Builder builder=ModuleSpec.build(ModuleIdentifier.fromString(mId));
  int l=(prefix.length() + mId.length() + level);
  Main.debug(""String_Node_Str"" + l + ""String_Node_Str"",prefix + mId);
  for (  File file : cp) {
    String fname=""String_Node_Str"" + file.getAbsolutePath();
    if (file.getName().startsWith(""String_Node_Str"") && !name.equals(file.getName())) {
      ModuleSpec dependency=newModule(file.getName(),level + 2,""String_Node_Str"",file).values().iterator().next();
      builder.addDependency(DependencySpec.createModuleDependencySpec(dependency.getModuleIdentifier()));
      modules.put(dependency.getModuleIdentifier(),dependency);
    }
 else {
      Main.debug(""String_Node_Str"" + (fname.length() + level + 2) + ""String_Node_Str"",fname);
      if (file.getName().endsWith(""String_Node_Str"")) {
        builder.addResourceRoot(ResourceLoaderSpec.createResourceLoaderSpec(ResourceLoaders.createJarResourceLoader(file.getName(),new JarFile(file))));
      }
 else {
        builder.addResourceRoot(ResourceLoaderSpec.createResourceLoaderSpec(ResourceLoaders.createFileResourceLoader(file.getName(),file)));
      }
    }
  }
  Set<String> sysPaths=sysPaths();
  Main.trace(""String_Node_Str"");
  sysPaths.forEach(p -> Main.trace(""String_Node_Str"",p));
  builder.addDependency(DependencySpec.createSystemDependencySpec(sysPaths));
  builder.addDependency(DependencySpec.createLocalDependencySpec());
  ModuleSpec module=builder.create();
  modules.put(module.getModuleIdentifier(),builder.create());
  return modules;
}"
54803,"@SuppressWarnings(""String_Node_Str"") private void startApp(){
  if (app != null) {
    stopApp(app);
  }
  debug(""String_Node_Str"",mainClass);
  executor.execute(() -> {
    ClassLoader ctxLoader=Thread.currentThread().getContextClassLoader();
    try {
      module=loader.loadModule(mId);
      ModuleClassLoader mcloader=module.getClassLoader();
      Thread.currentThread().setContextClassLoader(mcloader);
      Class<?> joobyClass=mcloader.loadClass(""String_Node_Str"");
      if (mainClass.equals(joobyClass.getName())) {
        Object js=mcloader.loadClass(""String_Node_Str"").newInstance();
        Method runjs=js.getClass().getDeclaredMethod(""String_Node_Str"",File.class);
        this.app=((Supplier)runjs.invoke(js,new File(""String_Node_Str""))).get();
      }
 else {
        this.app=joobyClass.getDeclaredConstructors()[0].newInstance();
      }
      debug(""String_Node_Str"",mainClass);
      Method joobyRun=joobyClass.getMethod(""String_Node_Str"");
      joobyRun.invoke(this.app);
    }
 catch (    Throwable ex) {
      Throwable cause=ex;
      if (ex instanceof InvocationTargetException) {
        cause=((InvocationTargetException)ex).getTargetException();
      }
      error(""String_Node_Str"",mainClass,cause);
    }
 finally {
      Thread.currentThread().setContextClassLoader(ctxLoader);
    }
  }
);
}","@SuppressWarnings(""String_Node_Str"") private void startApp(){
  if (app != null) {
    stopApp(app);
  }
  debug(""String_Node_Str"",mainClass);
  executor.execute(() -> {
    ClassLoader ctxLoader=Thread.currentThread().getContextClassLoader();
    try {
      module=loader.loadModule(mId);
      ModuleClassLoader mcloader=module.getClassLoader();
      Thread.currentThread().setContextClassLoader(mcloader);
      if (mainClass.endsWith(""String_Node_Str"")) {
        Object js=mcloader.loadClass(""String_Node_Str"").newInstance();
        Method runjs=js.getClass().getDeclaredMethod(""String_Node_Str"",File.class);
        this.app=((Supplier)runjs.invoke(js,new File(mainClass))).get();
      }
 else {
        this.app=mcloader.loadClass(mainClass).getDeclaredConstructors()[0].newInstance();
      }
      debug(""String_Node_Str"",mainClass);
      Method joobyRun=app.getClass().getMethod(""String_Node_Str"");
      joobyRun.invoke(this.app);
    }
 catch (    Throwable ex) {
      Throwable cause=ex;
      if (ex instanceof InvocationTargetException) {
        cause=((InvocationTargetException)ex).getTargetException();
      }
      error(""String_Node_Str"",mainClass,cause);
    }
 finally {
      Thread.currentThread().setContextClassLoader(ctxLoader);
    }
  }
);
}"
54804,"private static void logLevel(){
  DEBUG=""String_Node_Str"".equalsIgnoreCase(System.getProperty(""String_Node_Str"",""String_Node_Str""));
  TRACE=""String_Node_Str"".equalsIgnoreCase(System.getProperty(""String_Node_Str"",""String_Node_Str""));
  if (TRACE) {
    DEBUG=true;
    Module.setModuleLogger(new ModuleLogger(){
      @Override public void trace(      final Throwable t,      final String format,      final Object arg1,      final Object arg2,      final Object arg3){
        Main.trace(format,arg1,arg2,arg3,t);
      }
      @Override public void trace(      final Throwable t,      final String format,      final Object arg1,      final Object arg2){
        Main.trace(format,arg1,arg2,t);
      }
      @Override public void trace(      final String format,      final Object arg1,      final Object arg2,      final Object arg3){
        Main.trace(format,arg1,arg2,arg3);
      }
      @Override public void trace(      final Throwable t,      final String format,      final Object... args){
        Object[] values=new Object[args.length + 1];
        System.arraycopy(args,0,values,0,args.length);
        values[values.length - 1]=t;
        Main.trace(format,values);
      }
      @Override public void trace(      final Throwable t,      final String format,      final Object arg1){
        Main.trace(format,arg1,t);
      }
      @Override public void trace(      final String format,      final Object arg1,      final Object arg2){
        Main.trace(format,arg1,arg2);
      }
      @Override public void trace(      final Throwable t,      final String message){
        Main.trace(message,t);
      }
      @Override public void trace(      final String format,      final Object... args){
        Main.trace(format,args);
      }
      @Override public void trace(      final String format,      final Object arg1){
        Main.trace(format,arg1);
      }
      @Override public void trace(      final String message){
        Main.trace(message);
      }
      @Override public void providerUnloadable(      final String name,      final ClassLoader loader){
      }
      @Override public void moduleDefined(      final ModuleIdentifier identifier,      final ModuleLoader moduleLoader){
      }
      @Override public void greeting(){
      }
      @Override public void classDefined(      final String name,      final Module module){
      }
      @Override public void classDefineFailed(      final Throwable throwable,      final String className,      final Module module){
      }
    }
);
  }
}","private static void logLevel(){
  DEBUG=""String_Node_Str"".equalsIgnoreCase(System.getProperty(""String_Node_Str"",""String_Node_Str""));
  TRACE=""String_Node_Str"".equalsIgnoreCase(System.getProperty(""String_Node_Str"",""String_Node_Str""));
  if (TRACE) {
    DEBUG=true;
    Module.setModuleLogger(new ModuleLogger(){
      @Override public void trace(      final Throwable t,      final String format,      final Object arg1,      final Object arg2,      final Object arg3){
        Main.trace(format,arg1,arg2,arg3,t);
      }
      @Override public void trace(      final Throwable t,      final String format,      final Object arg1,      final Object arg2){
        Main.trace(format,arg1,arg2,t);
      }
      @Override public void trace(      final String format,      final Object arg1,      final Object arg2,      final Object arg3){
        Main.trace(format,arg1,arg2,arg3);
      }
      @Override public void trace(      final Throwable t,      final String format,      final Object... args){
        Object[] values=new Object[args.length + 1];
        System.arraycopy(args,0,values,0,args.length);
        values[values.length - 1]=t;
        Main.trace(format,values);
      }
      @Override public void trace(      final Throwable t,      final String format,      final Object arg1){
        Main.trace(format,arg1,t);
      }
      @Override public void trace(      final String format,      final Object arg1,      final Object arg2){
        Main.trace(format,arg1,arg2);
      }
      @Override public void trace(      final Throwable t,      final String message){
        Main.trace(message,t);
      }
      @Override public void trace(      final String format,      final Object... args){
        Main.trace(format,args);
      }
      @Override public void trace(      final String format,      final Object arg1){
        Main.trace(format,arg1);
      }
      @Override public void trace(      final String message){
        Main.trace(message);
      }
      @Override public void providerUnloadable(      final String name,      final ClassLoader loader){
      }
      @Override public void moduleDefined(      final ModuleIdentifier identifier,      final ModuleLoader moduleLoader){
      }
      @Override public void greeting(){
      }
      @Override public void classDefined(      final String name,      final Module module){
      }
      @Override public void classDefineFailed(      final Throwable throwable,      final String className,      final Module module){
      }
    }
);
  }
  String logback=Optional.ofNullable(System.getProperty(""String_Node_Str"")).orElseGet(() -> Arrays.asList(Paths.get(""String_Node_Str"",""String_Node_Str""),Paths.get(""String_Node_Str"",""String_Node_Str"")).stream().filter(p -> p.toFile().exists()).map(Path::toString).findFirst().orElse(Paths.get(""String_Node_Str"",""String_Node_Str"").toString()));
  debug(""String_Node_Str"",logback);
  System.setProperty(""String_Node_Str"",logback);
}"
54805,"public Main(final String mId,final String mainClass,final File... cp) throws Exception {
  this.mainClass=mainClass;
  loader=AppModuleLoader.build(mId,mainClass,cp);
  this.mId=ModuleIdentifier.create(mId);
  this.executor=Executors.newSingleThreadExecutor(task -> new Thread(task,""String_Node_Str""));
  this.scanner=new Watcher(this::onChange,new Path[]{basedir.toPath()});
  includes(""String_Node_Str"");
  excludes(""String_Node_Str"");
}","public Main(final String mId,final String mainClass,final File... cp) throws Exception {
  this.mainClass=mainClass;
  loader=AppModuleLoader.build(mId,cp);
  this.mId=ModuleIdentifier.create(mId);
  this.executor=Executors.newSingleThreadExecutor(task -> new Thread(task,""String_Node_Str""));
  this.scanner=new Watcher(this::onChange,new Path[]{basedir.toPath()});
  includes(""String_Node_Str"");
  excludes(""String_Node_Str"");
}"
54806,"/** 
 * Overwrite the default bean parser with <code>null</code> supports. The default bean parser doesn't allow <code>null</code>, so if a parameter is optional you must declare it as  {@link Optional} otherwise parsing fails with a <code>404</code> status code.For example: <pre> {@code}public class Book  public String title; public Date releaseDate; public String toString() { return title + "":"" + releaseDate; } } { parser(Parser.bean(true)); post(""/"", req -> { return req.params(Book.class).toString(); }); } }</pre> With <code>/?title=Title&releaseDate=</code> prints <code>Title:null</code>. Now, same call with <code>allowNulls=false</code> results in <code>Bad Request: 400</code> because <code>releaseDate</code> if required and isn't present in the HTTP request.
 * @param allowNulls Enabled null supports while parsing HTTP params as Java Beans.
 * @return A new parser.
 */
static Parser bean(final boolean allowNulls){
  return new BeanParser(allowNulls);
}","/** 
 * Overwrite the default bean parser with <code>null</code> supports. The default bean parser doesn't allow <code>null</code>, so if a parameter is optional you must declare it as  {@link Optional} otherwise parsing fails with a <code>404</code> status code.For example: <pre> {@code}public class Book  public String title; public Date releaseDate; public String toString() { return title + "":"" + releaseDate; } } { parser(Parser.bean(true)); post(""/"", req -> { return req.params(Book.class).toString(); }); } }</pre> <p> With <code>/?title=Title&amp;releaseDate=</code> prints <code>Title:null</code>. </p> <p> Now, same call with <code>allowNulls=false</code> results in <code>Bad Request: 400</code> because <code>releaseDate</code> if required and isn't present in the HTTP request. </p>
 * @param allowNulls Enabled null supports while parsing HTTP params as Java Beans.
 * @return A new parser.
 */
static Parser bean(final boolean allowNulls){
  return new BeanParser(allowNulls);
}"
54807,"/** 
 * Map a reactor object like   {@link Flux} or {@link Mono} into a {@link Deferred} object.<pre> {@code ... import org.jooby.reactor.Reactor; ...}{ with(() -> { get(""/lux"", req -> Flux...); get(""/mono"", req -> Mono...); }).map(Reactor.reactor( flux -> flux.publishOn(Computations.concurrent()), mono -> mono.publishOn(Computations.concurrent())); } }</pre>
 * @param flux A flux adapter.
 * @param mono A mono adapter.
 * @return A new mapper.
 */
public static Route.Mapper<Object> reactor(){
  return reactor(Function.identity(),Function.identity());
}","/** 
 * Map a reactor object like   {@link Flux} or {@link Mono} into a {@link Deferred} object.<pre> {@code ... import org.jooby.reactor.Reactor; ...}{ with(() -> { get(""/lux"", req -> Flux...); get(""/mono"", req -> Mono...); }).map(Reactor.reactor( flux -> flux.publishOn(Computations.concurrent()), mono -> mono.publishOn(Computations.concurrent())); } }</pre>
 * @return A new mapper.
 */
public static Route.Mapper<Object> reactor(){
  return reactor(Function.identity(),Function.identity());
}"
54808,"/** 
 * Append a metric to the   {@link MetricRegistry}. The metric will be resolved by Guice. This call is identical to   {@link MetricRegistry#register(String,Metric)}.
 * @param name Name of the metric.
 * @param metric A metric object.
 * @return This metrics module.
 */
public <M extends Metric>Metrics metric(final String name,final Class<M> metric){
  bindings.add((binder,conf) -> {
    MapBinder.newMapBinder(binder,String.class,Metric.class).addBinding(name).to(metric);
  }
);
  return this;
}","/** 
 * Append a metric to the   {@link MetricRegistry}. The metric will be resolved by Guice. This call is identical to   {@link MetricRegistry#register(String,Metric)}.
 * @param name Name of the metric.
 * @param metric A metric object.
 * @param < M > Metric type.
 * @return This metrics module.
 */
public <M extends Metric>Metrics metric(final String name,final Class<M> metric){
  bindings.add((binder,conf) -> {
    MapBinder.newMapBinder(binder,String.class,Metric.class).addBinding(name).to(metric);
  }
);
  return this;
}"
54809,"/** 
 * Append a simple ping handler that results in a <code>200</code> responses with a <code>pong</code> body.
 * @return This metrics module.
 * @see PingHandler.
 */
public Metrics ping(){
  bindings.add((binder,conf) -> {
    Multibinder.newSetBinder(binder,Route.Definition.class).addBinding().toInstance(new Route.Definition(""String_Node_Str"",this.pattern + ""String_Node_Str"",new PingHandler()));
  }
);
  return this;
}","/** 
 * Append a simple ping handler that results in a <code>200</code> responses with a <code>pong</code> body. See   {@link PingHandler}
 * @return This metrics module.
 */
public Metrics ping(){
  bindings.add((binder,conf) -> {
    Multibinder.newSetBinder(binder,Route.Definition.class).addBinding().toInstance(new Route.Definition(""String_Node_Str"",this.pattern + ""String_Node_Str"",new PingHandler()));
  }
);
  return this;
}"
54810,"/** 
 * Append a health check to the   {@link HealthCheckRegistry}. The metric will be resolved by Guice. This call is identical to   {@link HealthCheckRegistry#register(String,HealthCheck)}.
 * @param name Name of the check.
 * @param metric A check object.
 * @return This metrics module.
 */
public <H extends HealthCheck>Metrics healthCheck(final String name,final Class<H> check){
  bindings.add((binder,conf) -> {
    MapBinder.newMapBinder(binder,String.class,HealthCheck.class).addBinding(name).to(check);
  }
);
  return this;
}","/** 
 * Append a health check to the   {@link HealthCheckRegistry}. The metric will be resolved by Guice. This call is identical to   {@link HealthCheckRegistry#register(String,HealthCheck)}.
 * @param name Name of the check.
 * @param check A check object.
 * @param < H > {@link HealthCheck} type.
 * @return This metrics module.
 */
public <H extends HealthCheck>Metrics healthCheck(final String name,final Class<H> check){
  bindings.add((binder,conf) -> {
    MapBinder.newMapBinder(binder,String.class,HealthCheck.class).addBinding(name).to(check);
  }
);
  return this;
}"
54811,"/** 
 * Append a handler that prints thread states (a.k.a thread dump).
 * @return This metrics module.
 * @see ThreadDumpHandler.
 */
public Metrics threadDump(){
  bindings.add((binder,conf) -> {
    Multibinder<Definition> routes=Multibinder.newSetBinder(binder,Route.Definition.class);
    routes.addBinding().toInstance(new Route.Definition(""String_Node_Str"",this.pattern + ""String_Node_Str"",new ThreadDumpHandler()));
  }
);
  return this;
}","/** 
 * Append a handler that prints thread states (a.k.a thread dump). See   {@link ThreadDumpHandler}.
 * @return This metrics module.
 */
public Metrics threadDump(){
  bindings.add((binder,conf) -> {
    Multibinder<Definition> routes=Multibinder.newSetBinder(binder,Route.Definition.class);
    routes.addBinding().toInstance(new Route.Definition(""String_Node_Str"",this.pattern + ""String_Node_Str"",new ThreadDumpHandler()));
  }
);
  return this;
}"
54812,"/** 
 * </p> Setup up an   {@link EntityInterceptor} on {@link PrePersist} events that generates anincremental ID. </p> Usage: <pre> { use(new Monphia().idGen(IdGen.GLOBAL); } </pre> <p> ID must be of type:  {@link Long} and annotated with {@link GeneratedValue}: </p> <pre> &#64;Entity public class MyEntity { &#64;Id &#64;GeneratedValue Long id; } </pre>
 * @param gen an {@link IdGen} strategy
 * @return This module.
 */
public Monphia with(final IdGen gen){
  this.gen=requireNonNull(gen,""String_Node_Str"");
  return this;
}","/** 
 * <p> Setup up an   {@link EntityInterceptor} on {@link PrePersist} events that generates anincremental ID. </p> Usage: <pre> { use(new Monphia().idGen(IdGen.GLOBAL); } </pre> <p> ID must be of type:  {@link Long} and annotated with {@link GeneratedValue}: </p> <pre> &#64;Entity public class MyEntity { &#64;Id &#64;GeneratedValue Long id; } </pre>
 * @param gen an {@link IdGen} strategy
 * @return This module.
 */
public Monphia with(final IdGen gen){
  this.gen=requireNonNull(gen,""String_Node_Str"");
  return this;
}"
54813,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test public void guiceJobFactory() throws Exception {
  Config conf=ConfigFactory.empty().withValue(""String_Node_Str"",ConfigValueFactory.fromAnyRef(""String_Node_Str""));
  Properties props=new Properties();
  props.setProperty(""String_Node_Str"",""String_Node_Str"");
  Job job=ctx -> {
  }
;
  new MockUnit(Injector.class,Scheduler.class,Map.class,TriggerFiredBundle.class).expect(unit -> {
    Scheduler scheduler=unit.get(Scheduler.class);
    scheduler.setJobFactory(unit.capture(JobFactory.class));
  }
).expect(unit -> {
    Map triggers=unit.get(Map.class);
    expect(triggers.entrySet()).andReturn(Collections.emptySet());
  }
).expect(unit -> {
    Class jobClass=Job.class;
    JobDetail jobDetail=unit.mock(JobDetail.class);
    expect(jobDetail.getJobClass()).andReturn(jobClass);
    TriggerFiredBundle bundle=unit.get(TriggerFiredBundle.class);
    expect(bundle.getJobDetail()).andReturn(jobDetail);
    Injector injector=unit.get(Injector.class);
    expect(injector.getInstance(jobClass)).andReturn(job);
  }
).expect(unit -> {
    Scheduler scheduler=unit.get(Scheduler.class);
    StdSchedulerFactory factory=unit.mockConstructor(StdSchedulerFactory.class,new Class[]{Properties.class},props);
    expect(factory.getScheduler()).andReturn(scheduler);
  }
).run(unit -> {
    new QuartzProvider(unit.get(Injector.class),conf,unit.get(Map.class));
  }
,unit -> {
    JobFactory factory=unit.captured(JobFactory.class).iterator().next();
    Job newJob=factory.newJob(unit.get(TriggerFiredBundle.class),unit.get(Scheduler.class));
    assertEquals(job,newJob);
  }
);
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test public void guiceJobFactory() throws Exception {
  Config conf=ConfigFactory.empty().withValue(""String_Node_Str"",ConfigValueFactory.fromAnyRef(""String_Node_Str""));
  Properties props=new Properties();
  props.setProperty(""String_Node_Str"",""String_Node_Str"");
  Job job=ctx -> {
  }
;
  new MockUnit(Injector.class,Scheduler.class,Map.class,TriggerFiredBundle.class).expect(unit -> {
    Scheduler scheduler=unit.get(Scheduler.class);
    scheduler.setJobFactory(unit.capture(JobFactory.class));
  }
).expect(unit -> {
    Map triggers=unit.get(Map.class);
    expect(triggers.entrySet()).andReturn(Collections.emptySet());
  }
).expect(unit -> {
    Class jobClass=Job.class;
    JobDetail jobDetail=unit.mock(JobDetail.class);
    expect(jobDetail.getJobClass()).andReturn(jobClass);
    TriggerFiredBundle bundle=unit.get(TriggerFiredBundle.class);
    expect(bundle.getJobDetail()).andReturn(jobDetail);
    Injector injector=unit.get(Injector.class);
    expect(injector.getInstance(Job.class)).andReturn(job);
  }
).expect(unit -> {
    Scheduler scheduler=unit.get(Scheduler.class);
    StdSchedulerFactory factory=unit.mockConstructor(StdSchedulerFactory.class,new Class[]{Properties.class},props);
    expect(factory.getScheduler()).andReturn(scheduler);
  }
).run(unit -> {
    new QuartzProvider(unit.get(Injector.class),conf,unit.get(Map.class));
  }
,unit -> {
    JobFactory factory=unit.captured(JobFactory.class).iterator().next();
    Job newJob=factory.newJob(unit.get(TriggerFiredBundle.class),unit.get(Scheduler.class));
    assertEquals(job,newJob);
  }
);
}"
54814,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test(expected=IOException.class) public void handleException() throws Exception {
  Class handlerClass=MvcHandlerTest.class;
  Object handler=new MvcHandlerTest();
  Method method=handlerClass.getDeclaredMethod(""String_Node_Str"");
  new MockUnit(RequestParamProvider.class,Request.class,Response.class).expect(unit -> {
    Request req=unit.get(Request.class);
    expect(req.require(handlerClass)).andReturn(handler);
  }
).expect(unit -> {
    List<RequestParam> params=Collections.emptyList();
    RequestParamProvider paramProvider=unit.get(RequestParamProvider.class);
    expect(paramProvider.parameters(method)).andReturn(params);
  }
).run(unit -> {
    new MvcHandler(method,unit.get(RequestParamProvider.class)).handle(unit.get(Request.class),unit.get(Response.class));
  }
);
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test(expected=IOException.class) public void handleException() throws Exception {
  Class handlerClass=MvcHandlerTest.class;
  MvcHandlerTest handler=new MvcHandlerTest();
  Method method=handlerClass.getDeclaredMethod(""String_Node_Str"");
  new MockUnit(RequestParamProvider.class,Request.class,Response.class).expect(unit -> {
    Request req=unit.get(Request.class);
    expect(req.require(MvcHandlerTest.class)).andReturn(handler);
  }
).expect(unit -> {
    List<RequestParam> params=Collections.emptyList();
    RequestParamProvider paramProvider=unit.get(RequestParamProvider.class);
    expect(paramProvider.parameters(method)).andReturn(params);
  }
).run(unit -> {
    new MvcHandler(method,unit.get(RequestParamProvider.class)).handle(unit.get(Request.class),unit.get(Response.class));
  }
);
}"
54815,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test(expected=RuntimeException.class) public void throwableException() throws Exception {
  Class handlerClass=MvcHandlerTest.class;
  Object handler=new MvcHandlerTest();
  Method method=handlerClass.getDeclaredMethod(""String_Node_Str"");
  new MockUnit(RequestParamProvider.class,Request.class,Response.class).expect(unit -> {
    Request req=unit.get(Request.class);
    expect(req.require(handlerClass)).andReturn(handler);
  }
).expect(unit -> {
    List<RequestParam> params=Collections.emptyList();
    RequestParamProvider paramProvider=unit.get(RequestParamProvider.class);
    expect(paramProvider.parameters(method)).andReturn(params);
  }
).run(unit -> {
    new MvcHandler(method,unit.get(RequestParamProvider.class)).handle(unit.get(Request.class),unit.get(Response.class));
  }
);
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test(expected=RuntimeException.class) public void throwableException() throws Exception {
  Class handlerClass=MvcHandlerTest.class;
  MvcHandlerTest handler=new MvcHandlerTest();
  Method method=handlerClass.getDeclaredMethod(""String_Node_Str"");
  new MockUnit(RequestParamProvider.class,Request.class,Response.class).expect(unit -> {
    Request req=unit.get(Request.class);
    expect(req.require(MvcHandlerTest.class)).andReturn(handler);
  }
).expect(unit -> {
    List<RequestParam> params=Collections.emptyList();
    RequestParamProvider paramProvider=unit.get(RequestParamProvider.class);
    expect(paramProvider.parameters(method)).andReturn(params);
  }
).run(unit -> {
    new MvcHandler(method,unit.get(RequestParamProvider.class)).handle(unit.get(Request.class),unit.get(Response.class));
  }
);
}"
54816,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test public void handle() throws Exception {
  Class handlerClass=MvcHandlerTest.class;
  Object handler=new MvcHandlerTest();
  Method method=handlerClass.getDeclaredMethod(""String_Node_Str"");
  new MockUnit(RequestParamProvider.class,Request.class,Response.class).expect(unit -> {
    Request req=unit.get(Request.class);
    expect(req.require(handlerClass)).andReturn(handler);
  }
).expect(unit -> {
    Response rsp=unit.get(Response.class);
    expect(rsp.status(Status.OK)).andReturn(rsp);
    rsp.send(""String_Node_Str"");
  }
).expect(unit -> {
    List<RequestParam> params=Collections.emptyList();
    RequestParamProvider paramProvider=unit.get(RequestParamProvider.class);
    expect(paramProvider.parameters(method)).andReturn(params);
  }
).run(unit -> {
    new MvcHandler(method,unit.get(RequestParamProvider.class)).handle(unit.get(Request.class),unit.get(Response.class));
  }
);
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test public void handle() throws Exception {
  Class handlerClass=MvcHandlerTest.class;
  MvcHandlerTest handler=new MvcHandlerTest();
  Method method=handlerClass.getDeclaredMethod(""String_Node_Str"");
  new MockUnit(RequestParamProvider.class,Request.class,Response.class).expect(unit -> {
    Request req=unit.get(Request.class);
    expect(req.require(MvcHandlerTest.class)).andReturn(handler);
  }
).expect(unit -> {
    Response rsp=unit.get(Response.class);
    expect(rsp.status(Status.OK)).andReturn(rsp);
    rsp.send(""String_Node_Str"");
  }
).expect(unit -> {
    List<RequestParam> params=Collections.emptyList();
    RequestParamProvider paramProvider=unit.get(RequestParamProvider.class);
    expect(paramProvider.parameters(method)).andReturn(params);
  }
).run(unit -> {
    new MvcHandler(method,unit.get(RequestParamProvider.class)).handle(unit.get(Request.class),unit.get(Response.class));
  }
);
}"
54817,"@Test public void globTrace() throws Exception {
  request().trace(""String_Node_Str"").expect(200).header(""String_Node_Str"",len -> {
    assertTrue(Integer.parseInt(len) >= 163);
  }
).startsWith(""String_Node_Str"");
}","@Test public void globTrace() throws Exception {
  request().trace(""String_Node_Str"").expect(200).startsWith(""String_Node_Str"");
}"
54818,"public Request patch(final String path){
  this.req=new Request(this,executor(),org.apache.http.client.fluent.Request.Patch(host + path));
  return req;
}","public Request patch(final String path){
  this.req=new Request(this,executor(),pathHack(host + path));
  return req;
}"
54819,"/** 
 * Attempt to write a message into the HTTP response body. <p> For text format (json, yaml, xml, etc.) a converter usually call to  {@link Context#text(Context.Text)} in order to set charset and close resources.</p> <p> For binary format a converter usually call to {@link Context#bytes(Context.Bytes)} in order to close resources.</p>
 * @param body A body message.
 * @param ctx A write context.
 * @throws Exception If write operation fail.
 */
void format(Object body,BodyFormatter.Context ctx) throws Exception ;","/** 
 * Attempt to write a message into the HTTP response body. <p> For text format (json, yaml, xml, etc.) a converter usually call to  {@link BodyFormatter.Context#text(BodyFormatter.Context.Text)} in orderto set charset and close resources. </p> <p> For binary format a converter usually call to {@link BodyFormatter.Context#bytes(BodyFormatter.Context.Bytes)} in orderto close resources. </p>
 * @param body A body message.
 * @param ctx A write context.
 * @throws Exception If write operation fail.
 */
void format(Object body,BodyFormatter.Context ctx) throws Exception ;"
54820,"/** 
 * Access to request locals. See   {@link Request#attributes()} and {@link Locals}.
 * @return Current request locals.
 */
Map<String,Object> locals();","/** 
 * Access to request locals. See   {@link Request#attributes()}.
 * @return Current request locals.
 */
Map<String,Object> locals();"
54821,"/** 
 * Attempt to read a message from HTTP request body. <p> For text format (json, yaml, xml, etc.) a converter usually call to  {@link Context#text(Context.Text)} in order to apply correct charset and closeresources. </p> <p> For binary format a converter usually call to  {@link Context#bytes(Context.Bytes)} inorder to close resources. </p>
 * @param type A type of message.
 * @param ctx A read context.
 * @param < T > Target type.
 * @return A body message.
 * @throws Exception If read operation fail.
 */
<T>T parse(TypeLiteral<T> type,BodyParser.Context ctx) throws Exception ;","/** 
 * Attempt to read a message from HTTP request body. <p> For text format (json, yaml, xml, etc.) a converter usually call to  {@link BodyParser.Context#text(BodyParser.Context.Text)} in order to apply correct charsetand close resources. </p> <p> For binary format a converter usually call to {@link BodyParser.Context#bytes(BodyParser.Context.Bytes)} in order to close resources.</p>
 * @param type A type of message.
 * @param ctx A read context.
 * @param < T > Target type.
 * @return A body message.
 * @throws Exception If read operation fail.
 */
<T>T parse(TypeLiteral<T> type,BodyParser.Context ctx) throws Exception ;"
54822,"/** 
 * Remove a request local attribute.
 * @param name Attribute's name.
 * @return A local attribute.
 */
<T>Optional<T> unset(String name);","/** 
 * Remove a request local attribute.
 * @param name Attribute's name.
 * @param < T > Target type.
 * @return A local attribute.
 */
<T>Optional<T> unset(String name);"
54823,"/** 
 * Get a request local attribute.
 * @param name Attribute's name.
 * @return A local attribute.
 */
<T>Optional<T> get(String name);","/** 
 * Get a request local attribute.
 * @param name Attribute's name.
 * @param < T > Target type.
 * @return A local attribute.
 */
<T>Optional<T> get(String name);"
54824,"/** 
 * Get a object from this session. If the object isn't found this method returns an empty optional.
 * @param name A local var's name.
 * @param < T > Target type.
 * @return A value or empty optional.
 */
Mutant get(final String name);","/** 
 * Get a object from this session. If the object isn't found this method returns an empty optional.
 * @param name A local var's name.
 * @return A value or empty optional.
 */
Mutant get(final String name);"
54825,"@Test public void arrayResponse() throws IOException {
  this.snippet.expectResponseFields(""String_Node_Str"").withContents(tableWithHeader(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").row(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  MockHttpServletResponse response=new MockHttpServletResponse();
  response.getWriter().append(""String_Node_Str"");
  documentResponseFields(""String_Node_Str"",fieldWithPath(""String_Node_Str"").description(""String_Node_Str"")).handle(result(response));
}","@Test public void arrayResponse() throws IOException {
  this.snippet.expectResponseFields(""String_Node_Str"").withContents(tableWithHeader(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").row(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  MockHttpServletResponse response=new MockHttpServletResponse();
  response.getWriter().append(""String_Node_Str"");
  documentResponseFields(""String_Node_Str"",null,fieldWithPath(""String_Node_Str"").description(""String_Node_Str"")).handle(result(response));
}"
54826,"/** 
 * Returns a new instance of   {@link GoogleJsonResponseException}. <p> If there is a JSON error response, it is parsed using   {@link GoogleJsonError}, which can be inspected using   {@link #getDetails()}. Otherwise, the full response content is read and included in the exception message. </p>
 * @param jsonFactory JSON factory
 * @param response HTTP response
 * @return new instance of {@link GoogleJsonResponseException}
 */
public static GoogleJsonResponseException from(JsonFactory jsonFactory,HttpResponse response){
  HttpResponseException.Builder builder=new HttpResponseException.Builder(response.getStatusCode(),response.getStatusMessage(),response.getHeaders());
  Preconditions.checkNotNull(jsonFactory);
  GoogleJsonError details=null;
  String detailString=null;
  try {
    if (!response.isSuccessStatusCode() && HttpMediaType.equalsIgnoreParameters(Json.MEDIA_TYPE,response.getContentType()) && response.getContent() != null) {
      JsonParser parser=null;
      try {
        parser=jsonFactory.createJsonParser(response.getContent());
        JsonToken currentToken=parser.getCurrentToken();
        if (currentToken == null) {
          currentToken=parser.nextToken();
        }
        if (currentToken != null) {
          parser.skipToKey(""String_Node_Str"");
          if (parser.getCurrentToken() != JsonToken.END_OBJECT) {
            details=parser.parseAndClose(GoogleJsonError.class);
            detailString=details.toPrettyString();
          }
        }
      }
 catch (      IOException exception) {
        exception.printStackTrace();
      }
 finally {
        if (parser == null) {
          response.ignore();
        }
 else         if (details == null) {
          parser.close();
        }
      }
    }
 else {
      detailString=response.parseAsString();
    }
  }
 catch (  IOException exception) {
    exception.printStackTrace();
  }
  StringBuilder message=HttpResponseException.computeMessageBuffer(response);
  if (!com.google.api.client.util.Strings.isNullOrEmpty(detailString)) {
    message.append(StringUtils.LINE_SEPARATOR).append(detailString);
    builder.setContent(detailString);
  }
  builder.setMessage(message.toString());
  return new GoogleJsonResponseException(builder,details);
}","/** 
 * Returns a new instance of   {@link GoogleJsonResponseException}. <p> If there is a JSON error response, it is parsed using   {@link GoogleJsonError}, which can be inspected using   {@link #getDetails()}. Otherwise, the full response content is read and included in the exception message. </p>
 * @param jsonFactory JSON factory
 * @param response HTTP response
 * @return new instance of {@link GoogleJsonResponseException}
 */
public static GoogleJsonResponseException from(JsonFactory jsonFactory,HttpResponse response){
  HttpResponseException.Builder builder=new HttpResponseException.Builder(response.getStatusCode(),response.getStatusMessage(),response.getHeaders());
  Preconditions.checkNotNull(jsonFactory);
  GoogleJsonError details=null;
  String detailString=null;
  try {
    if (!response.isSuccessStatusCode() && HttpMediaType.equalsIgnoreParameters(Json.MEDIA_TYPE,response.getContentType()) && response.getContent() != null) {
      JsonParser parser=null;
      try {
        parser=jsonFactory.createJsonParser(response.getContent());
        JsonToken currentToken=parser.getCurrentToken();
        if (currentToken == null) {
          currentToken=parser.nextToken();
        }
        if (currentToken != null) {
          parser.skipToKey(""String_Node_Str"");
          if (parser.getCurrentToken() == JsonToken.VALUE_STRING) {
            detailString=parser.getText();
          }
 else           if (parser.getCurrentToken() == JsonToken.START_OBJECT) {
            details=parser.parseAndClose(GoogleJsonError.class);
            detailString=details.toPrettyString();
          }
        }
      }
 catch (      IOException exception) {
        exception.printStackTrace();
      }
 finally {
        if (parser == null) {
          response.ignore();
        }
 else         if (details == null) {
          parser.close();
        }
      }
    }
 else {
      detailString=response.parseAsString();
    }
  }
 catch (  IOException exception) {
    exception.printStackTrace();
  }
  StringBuilder message=HttpResponseException.computeMessageBuffer(response);
  if (!com.google.api.client.util.Strings.isNullOrEmpty(detailString)) {
    message.append(StringUtils.LINE_SEPARATOR).append(detailString);
    builder.setContent(detailString);
  }
  builder.setMessage(message.toString());
  return new GoogleJsonResponseException(builder,details);
}"
54827,"@Override protected TokenResponse executeRefreshToken() throws IOException {
  Socket socket=new Socket(""String_Node_Str"",this.getAuthPort());
  socket.setSoTimeout(READ_TIMEOUT_MS);
  TokenResponse token=new TokenResponse();
  try {
    PrintWriter out=new PrintWriter(socket.getOutputStream(),true);
    out.println(GET_AUTH_TOKEN_REQUEST);
    BufferedReader input=new BufferedReader(new InputStreamReader(socket.getInputStream()));
    String ignoredSizeLine=input.readLine();
    Collection<Object> messageArray=jsonFactory.createJsonParser(input).parseArray(LinkedList.class,Object.class);
    String accessToken=((List<Object>)messageArray).get(ACCESS_TOKEN_INDEX).toString();
    token.setAccessToken(accessToken);
  }
  finally {
    socket.close();
  }
  return token;
}","@Override protected TokenResponse executeRefreshToken() throws IOException {
  Socket socket=new Socket(""String_Node_Str"",this.getAuthPort());
  socket.setSoTimeout(READ_TIMEOUT_MS);
  TokenResponse token=new TokenResponse();
  try {
    PrintWriter out=new PrintWriter(socket.getOutputStream(),true);
    out.println(GET_AUTH_TOKEN_REQUEST);
    BufferedReader input=new BufferedReader(new InputStreamReader(socket.getInputStream()));
    input.readLine();
    Collection<Object> messageArray=jsonFactory.createJsonParser(input).parseArray(LinkedList.class,Object.class);
    String accessToken=((List<Object>)messageArray).get(ACCESS_TOKEN_INDEX).toString();
    token.setAccessToken(accessToken);
  }
  finally {
    socket.close();
  }
  return token;
}"
54828,"/** 
 * {@link Beta} <br/>The call back method that will be invoked on a server error or an I/O exception during resumable upload inside  {@link #upload}. <p> This method changes the current request to query the current status of the upload to find how many bytes were successfully uploaded before the server error occurred. </p>
 */
@Beta void serverErrorCallback() throws IOException {
  Preconditions.checkNotNull(currentRequest,""String_Node_Str"");
  currentRequest.setContent(new EmptyContent());
  currentRequest.getHeaders().setContentRange(""String_Node_Str"" + (isMediaLengthKnown() ? getMediaContentLength() : ""String_Node_Str""));
}","/** 
 * {@link Beta} <br/>The call back method that will be invoked on a server error or an I/O exception during resumable upload inside  {@link #upload}. <p> This method changes the current request to query the current status of the upload to find how many bytes were successfully uploaded before the server error occurred. </p>
 */
@Beta void serverErrorCallback() throws IOException {
  Preconditions.checkNotNull(currentRequest,""String_Node_Str"");
  currentRequest.setContent(new EmptyContent());
  currentRequest.getHeaders().setContentRange(""String_Node_Str"" + mediaContentLengthStr);
}"
54829,"/** 
 * Sets the HTTP media content chunk and the required headers that should be used in the upload request.
 */
private void setContentAndHeadersOnCurrentRequest() throws IOException {
  int blockSize;
  if (isMediaLengthKnown()) {
    blockSize=(int)Math.min(chunkSize,getMediaContentLength() - totalBytesServerReceived);
  }
 else {
    blockSize=chunkSize;
  }
  AbstractInputStreamContent contentChunk;
  int actualBlockSize=blockSize;
  if (isMediaLengthKnown()) {
    contentInputStream.mark(blockSize);
    InputStream limitInputStream=ByteStreams.limit(contentInputStream,blockSize);
    contentChunk=new InputStreamContent(mediaContent.getType(),limitInputStream).setRetrySupported(true).setLength(blockSize).setCloseInputStream(false);
    mediaContentLengthStr=String.valueOf(getMediaContentLength());
  }
 else {
    int actualBytesRead;
    int bytesAllowedToRead;
    int copyBytes=0;
    if (currentRequestContentBuffer == null) {
      bytesAllowedToRead=cachedByte == null ? blockSize + 1 : blockSize;
      currentRequestContentBuffer=new byte[blockSize + 1];
      if (cachedByte != null) {
        currentRequestContentBuffer[0]=cachedByte;
      }
    }
 else {
      copyBytes=(int)(totalBytesClientSent - totalBytesServerReceived);
      System.arraycopy(currentRequestContentBuffer,currentChunkLength - copyBytes,currentRequestContentBuffer,0,copyBytes);
      if (cachedByte != null) {
        currentRequestContentBuffer[copyBytes]=cachedByte;
      }
      bytesAllowedToRead=blockSize - copyBytes;
    }
    actualBytesRead=ByteStreams.read(contentInputStream,currentRequestContentBuffer,blockSize + 1 - bytesAllowedToRead,bytesAllowedToRead);
    if (actualBytesRead < bytesAllowedToRead) {
      actualBlockSize=copyBytes + Math.max(0,actualBytesRead);
      if (cachedByte != null) {
        actualBlockSize++;
        cachedByte=null;
      }
      if (mediaContentLengthStr.equals(""String_Node_Str"")) {
        mediaContentLengthStr=String.valueOf(totalBytesServerReceived + actualBlockSize);
      }
    }
 else {
      cachedByte=currentRequestContentBuffer[blockSize];
    }
    contentChunk=new ByteArrayContent(mediaContent.getType(),currentRequestContentBuffer,0,actualBlockSize);
    totalBytesClientSent=totalBytesServerReceived + actualBlockSize;
  }
  currentChunkLength=actualBlockSize;
  currentRequest.setContent(contentChunk);
  if (actualBlockSize == 0) {
    currentRequest.getHeaders().setContentRange(""String_Node_Str"");
  }
 else {
    currentRequest.getHeaders().setContentRange(""String_Node_Str"" + totalBytesServerReceived + ""String_Node_Str""+ (totalBytesServerReceived + actualBlockSize - 1)+ ""String_Node_Str""+ mediaContentLengthStr);
  }
}","/** 
 * Sets the HTTP media content chunk and the required headers that should be used in the upload request.
 */
private void setContentAndHeadersOnCurrentRequest() throws IOException {
  int blockSize;
  if (isMediaLengthKnown()) {
    blockSize=(int)Math.min(chunkSize,getMediaContentLength() - totalBytesServerReceived);
  }
 else {
    blockSize=chunkSize;
  }
  AbstractInputStreamContent contentChunk;
  int actualBlockSize=blockSize;
  if (isMediaLengthKnown()) {
    contentInputStream.mark(blockSize);
    InputStream limitInputStream=ByteStreams.limit(contentInputStream,blockSize);
    contentChunk=new InputStreamContent(mediaContent.getType(),limitInputStream).setRetrySupported(true).setLength(blockSize).setCloseInputStream(false);
    mediaContentLengthStr=String.valueOf(getMediaContentLength());
  }
 else {
    int actualBytesRead;
    int bytesAllowedToRead;
    int copyBytes=0;
    if (currentRequestContentBuffer == null) {
      bytesAllowedToRead=cachedByte == null ? blockSize + 1 : blockSize;
      currentRequestContentBuffer=new byte[blockSize + 1];
      if (cachedByte != null) {
        currentRequestContentBuffer[0]=cachedByte;
      }
    }
 else {
      copyBytes=(int)(totalBytesClientSent - totalBytesServerReceived);
      System.arraycopy(currentRequestContentBuffer,currentChunkLength - copyBytes,currentRequestContentBuffer,0,copyBytes);
      if (cachedByte != null) {
        currentRequestContentBuffer[copyBytes]=cachedByte;
      }
      bytesAllowedToRead=blockSize - copyBytes;
    }
    actualBytesRead=ByteStreams.read(contentInputStream,currentRequestContentBuffer,blockSize + 1 - bytesAllowedToRead,bytesAllowedToRead);
    if (actualBytesRead < bytesAllowedToRead) {
      actualBlockSize=copyBytes + Math.max(0,actualBytesRead);
      if (cachedByte != null) {
        actualBlockSize++;
        cachedByte=null;
      }
      if (mediaContentLengthStr.equals(""String_Node_Str"")) {
        mediaContentLengthStr=String.valueOf(totalBytesServerReceived + actualBlockSize);
      }
    }
 else {
      cachedByte=currentRequestContentBuffer[blockSize];
    }
    contentChunk=new ByteArrayContent(mediaContent.getType(),currentRequestContentBuffer,0,actualBlockSize);
    totalBytesClientSent=totalBytesServerReceived + actualBlockSize;
  }
  currentChunkLength=actualBlockSize;
  currentRequest.setContent(contentChunk);
  if (actualBlockSize == 0) {
    currentRequest.getHeaders().setContentRange(""String_Node_Str"" + mediaContentLengthStr);
  }
 else {
    currentRequest.getHeaders().setContentRange(""String_Node_Str"" + totalBytesServerReceived + ""String_Node_Str""+ (totalBytesServerReceived + actualBlockSize - 1)+ ""String_Node_Str""+ mediaContentLengthStr);
  }
}"
54830,"public void subtestUpload_ResumableWithError(ErrorType error,int contentLength,boolean contentLengthKnown,int maxByteIndexUploadedOnError,int chunks) throws Exception {
  MediaTransport fakeTransport=new MediaTransport(contentLength,true);
  if (error == ErrorType.IO_EXCEPTION) {
    fakeTransport.testIOException=true;
  }
 else   if (error == ErrorType.SERVER_UNAVAILABLE) {
    fakeTransport.testServerError=true;
  }
  fakeTransport.contentLengthNotSpecified=!contentLengthKnown;
  fakeTransport.maxByteIndexUploadedOnError=maxByteIndexUploadedOnError;
  byte[] testedData=new byte[contentLength];
  new Random().nextBytes(testedData);
  InputStream is=new ByteArrayInputStream(testedData);
  InputStreamContent mediaContent=new InputStreamContent(TEST_CONTENT_TYPE,is);
  if (contentLengthKnown) {
    mediaContent.setLength(contentLength);
  }
  MediaHttpUploader uploader=new MediaHttpUploader(mediaContent,fakeTransport,new ZeroBackOffRequestInitializer());
  uploader.setDisableGZipContent(true);
  HttpResponse response=uploader.upload(new GenericUrl(TEST_RESUMABLE_REQUEST_URL));
  assertEquals(200,response.getStatusCode());
  int calls=2 + chunks;
  assertEquals(calls,fakeTransport.lowLevelExecCalls);
  assertTrue(Arrays.equals(testedData,fakeTransport.bytesReceived));
}","public void subtestUpload_ResumableWithError(ErrorType error,int contentLength,boolean contentLengthKnown,int maxByteIndexUploadedOnError,int chunks,boolean force308OnRangeQueryResponse) throws Exception {
  MediaTransport fakeTransport=new MediaTransport(contentLength,true);
  if (error == ErrorType.IO_EXCEPTION) {
    fakeTransport.testIOException=true;
  }
 else   if (error == ErrorType.SERVER_UNAVAILABLE) {
    fakeTransport.testServerError=true;
  }
  fakeTransport.contentLengthNotSpecified=!contentLengthKnown;
  fakeTransport.maxByteIndexUploadedOnError=maxByteIndexUploadedOnError;
  fakeTransport.force308OnRangeQueryResponse=force308OnRangeQueryResponse;
  byte[] testedData=new byte[contentLength];
  new Random().nextBytes(testedData);
  InputStream is=new ByteArrayInputStream(testedData);
  InputStreamContent mediaContent=new InputStreamContent(TEST_CONTENT_TYPE,is);
  if (contentLengthKnown) {
    mediaContent.setLength(contentLength);
  }
  MediaHttpUploader uploader=new MediaHttpUploader(mediaContent,fakeTransport,new ZeroBackOffRequestInitializer());
  uploader.setDisableGZipContent(true);
  HttpResponse response=uploader.upload(new GenericUrl(TEST_RESUMABLE_REQUEST_URL));
  assertEquals(200,response.getStatusCode());
  int calls=2 + chunks;
  assertEquals(calls,fakeTransport.lowLevelExecCalls);
  assertTrue(Arrays.equals(testedData,fakeTransport.bytesReceived));
}"
54831,"@Override public LowLevelHttpResponse execute() throws IOException {
  lowLevelExecCalls++;
  MockLowLevelHttpResponse response=new MockLowLevelHttpResponse();
  String contentRangeHeader=getFirstHeaderValue(""String_Node_Str"");
  if (testServerError || testIOException) {
switch (lowLevelExecCalls) {
case 3:
      int bytesToRead=maxByteIndexUploadedOnError + 1 - bytesUploaded;
    copyBytesToBytesReceivedArray(bytesToRead);
  bytesUploaded+=bytesToRead;
if (testIOException) {
  throw new IOException();
}
response.setStatusCode(500);
return response;
case 4:
if (contentLengthNotSpecified) {
assertEquals(""String_Node_Str"",contentRangeHeader);
}
 else {
assertEquals(""String_Node_Str"" + contentLength,contentRangeHeader);
}
response.setStatusCode(contentLength == maxByteIndexUploadedOnError + 1 ? 200 : 308);
bytesUploaded=maxByteIndexUploadedOnError + 1;
response.addHeader(""String_Node_Str"",""String_Node_Str"" + maxByteIndexUploadedOnError);
return response;
default :
break;
}
}
 else if (testClientError) {
response.setStatusCode(411);
return response;
}
String bytesRange;
if (bytesUploaded + MediaHttpUploader.DEFAULT_CHUNK_SIZE > contentLength) {
bytesRange=bytesUploaded + ""String_Node_Str"" + (contentLength - 1);
}
 else {
bytesRange=bytesUploaded + ""String_Node_Str"" + (bytesUploaded + MediaHttpUploader.DEFAULT_CHUNK_SIZE - 1);
}
String expectedContentRange;
if (contentLength == 0) {
expectedContentRange=""String_Node_Str"";
}
 else if (contentLengthNotSpecified && ((bytesUploaded + MediaHttpUploader.DEFAULT_CHUNK_SIZE) < contentLength)) {
expectedContentRange=""String_Node_Str"" + bytesRange + ""String_Node_Str"";
}
 else {
expectedContentRange=""String_Node_Str"" + bytesRange + ""String_Node_Str""+ contentLength;
}
assertEquals(expectedContentRange,contentRangeHeader);
copyBytesToBytesReceivedArray(-1);
bytesUploaded+=MediaHttpUploader.DEFAULT_CHUNK_SIZE;
if (bytesUploaded >= contentLength) {
response.setStatusCode(200);
}
 else {
response.setStatusCode(308);
response.addHeader(""String_Node_Str"",""String_Node_Str"" + bytesRange);
}
return response;
}","@Override public LowLevelHttpResponse execute() throws IOException {
  lowLevelExecCalls++;
  MockLowLevelHttpResponse response=new MockLowLevelHttpResponse();
  String contentRangeHeader=getFirstHeaderValue(""String_Node_Str"");
  if (testServerError || testIOException) {
switch (lowLevelExecCalls) {
case 3:
      int bytesToRead=maxByteIndexUploadedOnError + 1 - bytesUploaded;
    copyBytesToBytesReceivedArray(bytesToRead);
  bytesUploaded+=bytesToRead;
if (testIOException) {
  throw new IOException();
}
response.setStatusCode(500);
return response;
case 4:
if (!contentLengthNotSpecified || (2 * MediaHttpUploader.DEFAULT_CHUNK_SIZE >= contentLength)) {
assertEquals(""String_Node_Str"" + contentLength,contentRangeHeader);
}
 else {
assertEquals(""String_Node_Str"",contentRangeHeader);
}
int statusCode=200;
if (contentLength != (maxByteIndexUploadedOnError + 1) || force308OnRangeQueryResponse) {
statusCode=308;
}
response.setStatusCode(statusCode);
response.addHeader(""String_Node_Str"",""String_Node_Str"" + maxByteIndexUploadedOnError);
return response;
case 5:
if (force308OnRangeQueryResponse && (contentLength == (maxByteIndexUploadedOnError + 1))) {
assertEquals(""String_Node_Str"" + contentLength,contentRangeHeader);
response.setStatusCode(200);
response.addHeader(""String_Node_Str"",""String_Node_Str"" + contentLength);
return response;
}
default :
break;
}
}
 else if (testClientError) {
response.setStatusCode(411);
return response;
}
String bytesRange;
if (bytesUploaded + MediaHttpUploader.DEFAULT_CHUNK_SIZE > contentLength) {
bytesRange=bytesUploaded + ""String_Node_Str"" + (contentLength - 1);
}
 else {
bytesRange=bytesUploaded + ""String_Node_Str"" + (bytesUploaded + MediaHttpUploader.DEFAULT_CHUNK_SIZE - 1);
}
String expectedContentRange;
if (contentLength == 0) {
expectedContentRange=""String_Node_Str"";
}
 else if (contentLengthNotSpecified && ((bytesUploaded + MediaHttpUploader.DEFAULT_CHUNK_SIZE) < contentLength)) {
expectedContentRange=""String_Node_Str"" + bytesRange + ""String_Node_Str"";
}
 else {
expectedContentRange=""String_Node_Str"" + bytesRange + ""String_Node_Str""+ contentLength;
}
assertEquals(expectedContentRange,contentRangeHeader);
copyBytesToBytesReceivedArray(-1);
bytesUploaded+=MediaHttpUploader.DEFAULT_CHUNK_SIZE;
if (bytesUploaded >= contentLength) {
response.setStatusCode(200);
}
 else {
response.setStatusCode(308);
response.addHeader(""String_Node_Str"",""String_Node_Str"" + bytesRange);
}
return response;
}"
54832,"private final GoogleCredential tryGetAppEngineCredential(HttpTransport transport,JsonFactory jsonFactory){
  if (checkedAppEngine) {
    return null;
  }
  checkedAppEngine=true;
  try {
    Class<?> credentialClass=forName(APP_ENGINE_CREDENTIAL_CLASS);
    Constructor<?> constructor=credentialClass.getConstructor(HttpTransport.class,JsonFactory.class);
    return (GoogleCredential)constructor.newInstance(transport,jsonFactory);
  }
 catch (  ClassNotFoundException expected) {
  }
catch (  NoSuchMethodException expected) {
  }
catch (  InstantiationException expected) {
  }
catch (  IllegalAccessException expected) {
  }
catch (  InvocationTargetException expected) {
  }
  return null;
}","private final GoogleCredential tryGetAppEngineCredential(HttpTransport transport,JsonFactory jsonFactory) throws IOException {
  if (checkedAppEngine) {
    return null;
  }
  boolean onAppEngine=runningOnAppEngine();
  checkedAppEngine=true;
  if (!onAppEngine) {
    return null;
  }
  Exception innerException=null;
  try {
    Class<?> credentialClass=forName(APP_ENGINE_CREDENTIAL_CLASS);
    Constructor<?> constructor=credentialClass.getConstructor(HttpTransport.class,JsonFactory.class);
    return (GoogleCredential)constructor.newInstance(transport,jsonFactory);
  }
 catch (  ClassNotFoundException e) {
    innerException=e;
  }
catch (  NoSuchMethodException e) {
    innerException=e;
  }
catch (  InstantiationException e) {
    innerException=e;
  }
catch (  IllegalAccessException e) {
    innerException=e;
  }
catch (  InvocationTargetException e) {
    innerException=e;
  }
  throw OAuth2Utils.exceptionWithCause(new IOException(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",APP_ENGINE_CREDENTIAL_CLASS)),innerException);
}"
54833,"public void testDefaultCredentialCaches() throws IOException {
  HttpTransport transport=new MockHttpTransport();
  TestDefaultCredentialProvider testProvider=new TestDefaultCredentialProvider();
  testProvider.addType(DefaultCredentialProvider.APP_ENGINE_CREDENTIAL_CLASS,MockAppEngineCredential.class);
  Credential firstCall=testProvider.getDefaultCredential(transport,JSON_FACTORY);
  assertNotNull(firstCall);
  Credential secondCall=testProvider.getDefaultCredential(transport,JSON_FACTORY);
  assertSame(firstCall,secondCall);
}","public void testDefaultCredentialCaches() throws IOException {
  HttpTransport transport=new MockHttpTransport();
  TestDefaultCredentialProvider testProvider=new TestDefaultCredentialProvider();
  testProvider.addType(DefaultCredentialProvider.APP_ENGINE_CREDENTIAL_CLASS,MockAppEngineCredential.class);
  testProvider.addType(GAE_SIGNAL_CLASS,MockAppEngineSystemProperty.class);
  Credential firstCall=testProvider.getDefaultCredential(transport,JSON_FACTORY);
  assertNotNull(firstCall);
  Credential secondCall=testProvider.getDefaultCredential(transport,JSON_FACTORY);
  assertSame(firstCall,secondCall);
}"
54834,"@Override protected TokenResponse executeRefreshToken() throws IOException {
  Socket socket=new Socket(""String_Node_Str"",this.getAuthPort());
  socket.setSoTimeout(READ_TIMEOUT_MS);
  TokenResponse token=new TokenResponse();
  try {
    PrintWriter out=new PrintWriter(socket.getOutputStream(),true);
    out.println(GET_AUTH_TOKEN_REQUEST);
    BufferedReader input=new BufferedReader(new InputStreamReader(socket.getInputStream()));
    String ignoredSizeLine=input.readLine();
    Collection<String> messageArray=jsonFactory.createJsonParser(input).parseArray(LinkedList.class,String.class);
    String accessToken=((List<String>)messageArray).get(ACCESS_TOKEN_INDEX);
    token.setAccessToken(accessToken);
  }
  finally {
    socket.close();
  }
  return token;
}","@Override protected TokenResponse executeRefreshToken() throws IOException {
  Socket socket=new Socket(""String_Node_Str"",this.getAuthPort());
  socket.setSoTimeout(READ_TIMEOUT_MS);
  TokenResponse token=new TokenResponse();
  try {
    PrintWriter out=new PrintWriter(socket.getOutputStream(),true);
    out.println(GET_AUTH_TOKEN_REQUEST);
    BufferedReader input=new BufferedReader(new InputStreamReader(socket.getInputStream()));
    String ignoredSizeLine=input.readLine();
    Collection<Object> messageArray=jsonFactory.createJsonParser(input).parseArray(LinkedList.class,Object.class);
    String accessToken=((List<Object>)messageArray).get(ACCESS_TOKEN_INDEX).toString();
    token.setAccessToken(accessToken);
  }
  finally {
    socket.close();
  }
  return token;
}"
54835,"/** 
 * Override in test code to isolate from environment
 */
Class<?> forName(String className) throws ClassNotFoundException {
  return Class.forName(className);
}","/** 
 * Override in test code to isolate from environment.
 */
Class<?> forName(String className) throws ClassNotFoundException {
  return Class.forName(className);
}"
54836,"private final GoogleCredential getDefaultCredentialUnsynchronized(HttpTransport transport,JsonFactory jsonFactory) throws IOException {
  GoogleCredential credential=null;
  String credentialsPath=getEnv(CREDENTIAL_ENV_VAR);
  if (credentialsPath != null && credentialsPath.length() > 0) {
    InputStream credentialsStream=null;
    try {
      File credentialsFile=new File(credentialsPath);
      if (!credentialsFile.exists() || credentialsFile.isDirectory()) {
        throw new IOException(""String_Node_Str"");
      }
      credentialsStream=new FileInputStream(credentialsFile);
      credential=GoogleCredential.fromStream(credentialsStream,transport,jsonFactory);
    }
 catch (    IOException e) {
      throw OAuth2Utils.exceptionWithCause(new IOException(String.format(""String_Node_Str"",CREDENTIAL_ENV_VAR,credentialsPath,e.getMessage())),e);
    }
catch (    AccessControlException expected) {
    }
 finally {
      if (credentialsStream != null) {
        credentialsStream.close();
      }
    }
  }
  File wellKnownFileLocation=getWellKnownCredentialsFile();
  try {
    if (fileExists(wellKnownFileLocation)) {
      InputStream credentialsStream=null;
      try {
        credentialsStream=new FileInputStream(wellKnownFileLocation);
        credential=GoogleCredential.fromStream(credentialsStream,transport,jsonFactory);
      }
 catch (      IOException e) {
        throw new IOException(String.format(""String_Node_Str"",wellKnownFileLocation,e.getMessage()));
      }
 finally {
        if (credentialsStream != null) {
          credentialsStream.close();
        }
      }
    }
  }
 catch (  AccessControlException expected) {
  }
  if (credential == null) {
    credential=tryGetAppEngineCredential(transport,jsonFactory);
  }
  if (credential == null) {
    credential=tryGetComputeCredential(transport,jsonFactory);
  }
  return credential;
}","private final GoogleCredential getDefaultCredentialUnsynchronized(HttpTransport transport,JsonFactory jsonFactory) throws IOException {
  GoogleCredential credential=null;
  String credentialsPath=getEnv(CREDENTIAL_ENV_VAR);
  if (credentialsPath != null && credentialsPath.length() > 0) {
    InputStream credentialsStream=null;
    try {
      File credentialsFile=new File(credentialsPath);
      if (!credentialsFile.exists() || credentialsFile.isDirectory()) {
        throw new IOException(""String_Node_Str"");
      }
      credentialsStream=new FileInputStream(credentialsFile);
      credential=GoogleCredential.fromStream(credentialsStream,transport,jsonFactory);
    }
 catch (    IOException e) {
      throw OAuth2Utils.exceptionWithCause(new IOException(String.format(""String_Node_Str"",CREDENTIAL_ENV_VAR,credentialsPath,e.getMessage())),e);
    }
catch (    AccessControlException expected) {
    }
 finally {
      if (credentialsStream != null) {
        credentialsStream.close();
      }
    }
  }
  if (credential == null) {
    File wellKnownFileLocation=getWellKnownCredentialsFile();
    try {
      if (fileExists(wellKnownFileLocation)) {
        InputStream credentialsStream=null;
        try {
          credentialsStream=new FileInputStream(wellKnownFileLocation);
          credential=GoogleCredential.fromStream(credentialsStream,transport,jsonFactory);
        }
 catch (        IOException e) {
          throw new IOException(String.format(""String_Node_Str"",wellKnownFileLocation,e.getMessage()));
        }
 finally {
          if (credentialsStream != null) {
            credentialsStream.close();
          }
        }
      }
    }
 catch (    AccessControlException expected) {
    }
  }
  if (credential == null) {
    credential=tryGetAppEngineCredential(transport,jsonFactory);
  }
  if (credential == null) {
    credential=tryGetComputeCredential(transport,jsonFactory);
  }
  return credential;
}"
54837,"/** 
 * Sets the HTTP media content chunk and the required headers that should be used in the upload request.
 */
private void setContentAndHeadersOnCurrentRequest() throws IOException {
  int blockSize;
  if (isMediaLengthKnown()) {
    blockSize=(int)Math.min(chunkSize,getMediaContentLength() - totalBytesServerReceived);
  }
 else {
    blockSize=chunkSize;
  }
  AbstractInputStreamContent contentChunk;
  int actualBlockSize=blockSize;
  String mediaContentLengthStr;
  if (isMediaLengthKnown()) {
    contentInputStream.mark(blockSize);
    InputStream limitInputStream=ByteStreams.limit(contentInputStream,blockSize);
    contentChunk=new InputStreamContent(mediaContent.getType(),limitInputStream).setRetrySupported(true).setLength(blockSize).setCloseInputStream(false);
    mediaContentLengthStr=String.valueOf(getMediaContentLength());
  }
 else {
    int actualBytesRead;
    int bytesAllowedToRead;
    int copyBytes=0;
    if (currentRequestContentBuffer == null) {
      totalBytesClientSent+=currentChunkLength;
      bytesAllowedToRead=cachedByte == null ? blockSize + 1 : blockSize;
      currentRequestContentBuffer=new byte[blockSize + 1];
      if (cachedByte != null) {
        currentRequestContentBuffer[0]=cachedByte;
      }
    }
 else {
      copyBytes=(currentChunkLength - (int)(totalBytesServerReceived - totalBytesClientSent));
      totalBytesClientSent=totalBytesServerReceived;
      System.arraycopy(currentRequestContentBuffer,currentChunkLength - copyBytes,currentRequestContentBuffer,0,copyBytes);
      if (cachedByte != null) {
        currentRequestContentBuffer[copyBytes]=cachedByte;
        cachedByte=null;
      }
      bytesAllowedToRead=blockSize - copyBytes;
    }
    actualBytesRead=ByteStreams.read(contentInputStream,currentRequestContentBuffer,blockSize + 1 - bytesAllowedToRead,bytesAllowedToRead);
    if (actualBytesRead < bytesAllowedToRead || bytesAllowedToRead == 0) {
      actualBlockSize=copyBytes + Math.max(0,actualBytesRead);
      if (cachedByte != null) {
        actualBlockSize++;
        cachedByte=null;
      }
      mediaContentLengthStr=String.valueOf(totalBytesServerReceived + actualBlockSize);
    }
 else {
      cachedByte=currentRequestContentBuffer[blockSize];
      mediaContentLengthStr=""String_Node_Str"";
    }
    contentChunk=new ByteArrayContent(mediaContent.getType(),currentRequestContentBuffer,0,actualBlockSize);
  }
  currentChunkLength=actualBlockSize;
  currentRequest.setContent(contentChunk);
  if (actualBlockSize == 0) {
    currentRequest.getHeaders().setContentRange(""String_Node_Str"");
  }
 else {
    currentRequest.getHeaders().setContentRange(""String_Node_Str"" + totalBytesServerReceived + ""String_Node_Str""+ (totalBytesServerReceived + actualBlockSize - 1)+ ""String_Node_Str""+ mediaContentLengthStr);
  }
}","/** 
 * Sets the HTTP media content chunk and the required headers that should be used in the upload request.
 */
private void setContentAndHeadersOnCurrentRequest() throws IOException {
  int blockSize;
  if (isMediaLengthKnown()) {
    blockSize=(int)Math.min(chunkSize,getMediaContentLength() - totalBytesServerReceived);
  }
 else {
    blockSize=chunkSize;
  }
  AbstractInputStreamContent contentChunk;
  int actualBlockSize=blockSize;
  if (isMediaLengthKnown()) {
    contentInputStream.mark(blockSize);
    InputStream limitInputStream=ByteStreams.limit(contentInputStream,blockSize);
    contentChunk=new InputStreamContent(mediaContent.getType(),limitInputStream).setRetrySupported(true).setLength(blockSize).setCloseInputStream(false);
    mediaContentLengthStr=String.valueOf(getMediaContentLength());
  }
 else {
    int actualBytesRead;
    int bytesAllowedToRead;
    int copyBytes=0;
    if (currentRequestContentBuffer == null) {
      bytesAllowedToRead=cachedByte == null ? blockSize + 1 : blockSize;
      currentRequestContentBuffer=new byte[blockSize + 1];
      if (cachedByte != null) {
        currentRequestContentBuffer[0]=cachedByte;
      }
    }
 else {
      copyBytes=(int)(totalBytesClientSent - totalBytesServerReceived);
      System.arraycopy(currentRequestContentBuffer,currentChunkLength - copyBytes,currentRequestContentBuffer,0,copyBytes);
      if (cachedByte != null) {
        currentRequestContentBuffer[copyBytes]=cachedByte;
      }
      bytesAllowedToRead=blockSize - copyBytes;
    }
    actualBytesRead=ByteStreams.read(contentInputStream,currentRequestContentBuffer,blockSize + 1 - bytesAllowedToRead,bytesAllowedToRead);
    if (actualBytesRead < bytesAllowedToRead) {
      actualBlockSize=copyBytes + Math.max(0,actualBytesRead);
      if (cachedByte != null) {
        actualBlockSize++;
        cachedByte=null;
      }
      if (mediaContentLengthStr.equals(""String_Node_Str"")) {
        mediaContentLengthStr=String.valueOf(totalBytesServerReceived + actualBlockSize);
      }
    }
 else {
      cachedByte=currentRequestContentBuffer[blockSize];
    }
    contentChunk=new ByteArrayContent(mediaContent.getType(),currentRequestContentBuffer,0,actualBlockSize);
    totalBytesClientSent=totalBytesServerReceived + actualBlockSize;
  }
  currentChunkLength=actualBlockSize;
  currentRequest.setContent(contentChunk);
  if (actualBlockSize == 0) {
    currentRequest.getHeaders().setContentRange(""String_Node_Str"");
  }
 else {
    currentRequest.getHeaders().setContentRange(""String_Node_Str"" + totalBytesServerReceived + ""String_Node_Str""+ (totalBytesServerReceived + actualBlockSize - 1)+ ""String_Node_Str""+ mediaContentLengthStr);
  }
}"
54838,"public void subtestUpload_ResumableWithError(ErrorType error,int contentLength,boolean contentLengthKnown,int maxByteIndexUploadedOnIOException) throws Exception {
  MediaTransport fakeTransport=new MediaTransport(contentLength,true);
  if (error == ErrorType.IO_EXCEPTION) {
    fakeTransport.testIOException=true;
  }
 else   if (error == ErrorType.SERVER_UNAVAILABLE) {
    fakeTransport.testServerError=true;
  }
  fakeTransport.contentLengthNotSpecified=!contentLengthKnown;
  fakeTransport.maxByteIndexUploadedOnIOException=maxByteIndexUploadedOnIOException;
  byte[] testedData=new byte[contentLength];
  new Random().nextBytes(testedData);
  InputStream is=new ByteArrayInputStream(testedData);
  InputStreamContent mediaContent=new InputStreamContent(TEST_CONTENT_TYPE,is);
  if (contentLengthKnown) {
    mediaContent.setLength(contentLength);
  }
  MediaHttpUploader uploader=new MediaHttpUploader(mediaContent,fakeTransport,new HttpRequestInitializer(){
    public void initialize(    HttpRequest request){
      request.setIOExceptionHandler(new HttpBackOffIOExceptionHandler(BackOff.ZERO_BACKOFF));
      request.setUnsuccessfulResponseHandler(new HttpBackOffUnsuccessfulResponseHandler(BackOff.ZERO_BACKOFF));
    }
  }
);
  uploader.setDisableGZipContent(true);
  HttpResponse response=uploader.upload(new GenericUrl(TEST_RESUMABLE_REQUEST_URL));
  assertEquals(200,response.getStatusCode());
  int calls=contentLength / uploader.getChunkSize();
  assertEquals(maxByteIndexUploadedOnIOException + 1 == contentLength ? calls + 2 : calls + 3,fakeTransport.lowLevelExecCalls);
  assertTrue(Arrays.equals(testedData,fakeTransport.bytesReceived));
}","public void subtestUpload_ResumableWithError(ErrorType error,int contentLength,boolean contentLengthKnown,int maxByteIndexUploadedOnError,int chunks) throws Exception {
  MediaTransport fakeTransport=new MediaTransport(contentLength,true);
  if (error == ErrorType.IO_EXCEPTION) {
    fakeTransport.testIOException=true;
  }
 else   if (error == ErrorType.SERVER_UNAVAILABLE) {
    fakeTransport.testServerError=true;
  }
  fakeTransport.contentLengthNotSpecified=!contentLengthKnown;
  fakeTransport.maxByteIndexUploadedOnError=maxByteIndexUploadedOnError;
  byte[] testedData=new byte[contentLength];
  new Random().nextBytes(testedData);
  InputStream is=new ByteArrayInputStream(testedData);
  InputStreamContent mediaContent=new InputStreamContent(TEST_CONTENT_TYPE,is);
  if (contentLengthKnown) {
    mediaContent.setLength(contentLength);
  }
  MediaHttpUploader uploader=new MediaHttpUploader(mediaContent,fakeTransport,new HttpRequestInitializer(){
    public void initialize(    HttpRequest request){
      request.setIOExceptionHandler(new HttpBackOffIOExceptionHandler(BackOff.ZERO_BACKOFF));
      request.setUnsuccessfulResponseHandler(new HttpBackOffUnsuccessfulResponseHandler(BackOff.ZERO_BACKOFF));
    }
  }
);
  uploader.setDisableGZipContent(true);
  HttpResponse response=uploader.upload(new GenericUrl(TEST_RESUMABLE_REQUEST_URL));
  assertEquals(200,response.getStatusCode());
  int calls=2 + chunks;
  assertEquals(calls,fakeTransport.lowLevelExecCalls);
  assertTrue(Arrays.equals(testedData,fakeTransport.bytesReceived));
}"
54839,"@Override public LowLevelHttpResponse execute() throws IOException {
  lowLevelExecCalls++;
  MockLowLevelHttpResponse response=new MockLowLevelHttpResponse();
  String contentRangeHeader=getFirstHeaderValue(""String_Node_Str"");
  if (testServerError || testIOException) {
switch (lowLevelExecCalls) {
case 3:
      int bytesToRead=maxByteIndexUploadedOnIOException + 1 - bytesUploaded;
    copyBytesToBytesReceivedArray(bytesToRead);
  bytesUploaded+=bytesToRead;
if (testIOException) {
  throw new IOException();
}
response.setStatusCode(500);
return response;
case 4:
if (contentLengthNotSpecified) {
assertEquals(""String_Node_Str"",contentRangeHeader);
}
 else {
assertEquals(""String_Node_Str"" + contentLength,contentRangeHeader);
}
response.setStatusCode(contentLength == maxByteIndexUploadedOnIOException + 1 ? 200 : 308);
bytesUploaded=maxByteIndexUploadedOnIOException + 1;
response.addHeader(""String_Node_Str"",""String_Node_Str"" + maxByteIndexUploadedOnIOException);
return response;
default :
break;
}
}
 else if (testClientError) {
response.setStatusCode(411);
return response;
}
String bytesRange;
if (bytesUploaded + MediaHttpUploader.DEFAULT_CHUNK_SIZE > contentLength) {
bytesRange=bytesUploaded + ""String_Node_Str"" + (contentLength - 1);
}
 else {
bytesRange=bytesUploaded + ""String_Node_Str"" + (bytesUploaded + MediaHttpUploader.DEFAULT_CHUNK_SIZE - 1);
}
String expectedContentRange;
if (contentLength == 0) {
expectedContentRange=""String_Node_Str"";
}
 else if (contentLengthNotSpecified && ((bytesUploaded + MediaHttpUploader.DEFAULT_CHUNK_SIZE) < contentLength)) {
expectedContentRange=""String_Node_Str"" + bytesRange + ""String_Node_Str"";
}
 else {
expectedContentRange=""String_Node_Str"" + bytesRange + ""String_Node_Str""+ contentLength;
}
assertEquals(expectedContentRange,contentRangeHeader);
copyBytesToBytesReceivedArray(-1);
bytesUploaded+=MediaHttpUploader.DEFAULT_CHUNK_SIZE;
if (bytesUploaded >= contentLength) {
response.setStatusCode(200);
}
 else {
response.setStatusCode(308);
response.addHeader(""String_Node_Str"",""String_Node_Str"" + bytesRange);
}
return response;
}","@Override public LowLevelHttpResponse execute() throws IOException {
  lowLevelExecCalls++;
  MockLowLevelHttpResponse response=new MockLowLevelHttpResponse();
  String contentRangeHeader=getFirstHeaderValue(""String_Node_Str"");
  if (testServerError || testIOException) {
switch (lowLevelExecCalls) {
case 3:
      int bytesToRead=maxByteIndexUploadedOnError + 1 - bytesUploaded;
    copyBytesToBytesReceivedArray(bytesToRead);
  bytesUploaded+=bytesToRead;
if (testIOException) {
  throw new IOException();
}
response.setStatusCode(500);
return response;
case 4:
if (contentLengthNotSpecified) {
assertEquals(""String_Node_Str"",contentRangeHeader);
}
 else {
assertEquals(""String_Node_Str"" + contentLength,contentRangeHeader);
}
response.setStatusCode(contentLength == maxByteIndexUploadedOnError + 1 ? 200 : 308);
bytesUploaded=maxByteIndexUploadedOnError + 1;
response.addHeader(""String_Node_Str"",""String_Node_Str"" + maxByteIndexUploadedOnError);
return response;
default :
break;
}
}
 else if (testClientError) {
response.setStatusCode(411);
return response;
}
String bytesRange;
if (bytesUploaded + MediaHttpUploader.DEFAULT_CHUNK_SIZE > contentLength) {
bytesRange=bytesUploaded + ""String_Node_Str"" + (contentLength - 1);
}
 else {
bytesRange=bytesUploaded + ""String_Node_Str"" + (bytesUploaded + MediaHttpUploader.DEFAULT_CHUNK_SIZE - 1);
}
String expectedContentRange;
if (contentLength == 0) {
expectedContentRange=""String_Node_Str"";
}
 else if (contentLengthNotSpecified && ((bytesUploaded + MediaHttpUploader.DEFAULT_CHUNK_SIZE) < contentLength)) {
expectedContentRange=""String_Node_Str"" + bytesRange + ""String_Node_Str"";
}
 else {
expectedContentRange=""String_Node_Str"" + bytesRange + ""String_Node_Str""+ contentLength;
}
assertEquals(expectedContentRange,contentRangeHeader);
copyBytesToBytesReceivedArray(-1);
bytesUploaded+=MediaHttpUploader.DEFAULT_CHUNK_SIZE;
if (bytesUploaded >= contentLength) {
response.setStatusCode(200);
}
 else {
response.setStatusCode(308);
response.addHeader(""String_Node_Str"",""String_Node_Str"" + bytesRange);
}
return response;
}"
54840,"/** 
 * Executes a direct media upload or resumable media upload conforming to the specifications listed <a href='http://code.google.com/apis/gdata/docs/resumable_upload.html'>here.</a> <p> This method is not reentrant. A new instance of   {@link MediaHttpUploader} must be instantiatedbefore upload called be called again. </p> <p> If an error is encountered during the request execution the caller is responsible for parsing the response correctly. For example for JSON errors: </p> <pre> if (!response.isSuccessStatusCode()) { throw GoogleJsonResponseException.from(jsonFactory, response); } </pre> <p> Callers should call  {@link HttpResponse#disconnect} when the returned HTTP response object isno longer needed. However,  {@link HttpResponse#disconnect} does not have to be called if theresponse stream is properly closed. Example usage: </p> <pre> HttpResponse response = batch.upload(initiationRequestUrl); try { // process the HTTP response object } finally { response.disconnect(); } </pre>
 * @param initiationRequestUrl The request URL where the initiation request will be sent
 * @return HTTP response
 */
public HttpResponse upload(GenericUrl initiationRequestUrl) throws IOException {
  Preconditions.checkArgument(uploadState == UploadState.NOT_STARTED);
  if (directUploadEnabled) {
    updateStateAndNotifyListener(UploadState.MEDIA_IN_PROGRESS);
    HttpContent content=mediaContent;
    if (metadata != null) {
      content=new MultipartContent().setContentParts(Arrays.asList(metadata,mediaContent));
      initiationRequestUrl.put(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      initiationRequestUrl.put(""String_Node_Str"",""String_Node_Str"");
    }
    HttpRequest request=requestFactory.buildRequest(initiationRequestMethod,initiationRequestUrl,content);
    request.getHeaders().putAll(initiationHeaders);
    HttpResponse response=executeCurrentRequestWithBackOffAndGZip(request);
    boolean responseProcessed=false;
    try {
      if (getMediaContentLength() >= 0) {
        bytesUploaded=getMediaContentLength();
      }
      updateStateAndNotifyListener(UploadState.MEDIA_COMPLETE);
      responseProcessed=true;
    }
  finally {
      if (!responseProcessed) {
        response.disconnect();
      }
    }
    return response;
  }
  HttpResponse initialResponse=executeUploadInitiation(initiationRequestUrl);
  if (!initialResponse.isSuccessStatusCode()) {
    return initialResponse;
  }
  GenericUrl uploadUrl;
  try {
    uploadUrl=new GenericUrl(initialResponse.getHeaders().getLocation());
  }
  finally {
    initialResponse.disconnect();
  }
  contentInputStream=mediaContent.getInputStream();
  if (!contentInputStream.markSupported() && getMediaContentLength() >= 0) {
    contentInputStream=new BufferedInputStream(contentInputStream);
  }
  HttpResponse response;
  while (true) {
    currentRequest=requestFactory.buildPutRequest(uploadUrl,null);
    setContentAndHeadersOnCurrentRequest(bytesUploaded);
    if (backOffPolicyEnabled) {
      currentRequest.setBackOffPolicy(new MediaUploadExponentialBackOffPolicy(this));
    }
 else {
      new MediaUploadErrorHandler(this,currentRequest);
    }
    if (getMediaContentLength() >= 0) {
    }
 else     if (!disableGZipContent) {
      currentRequest.setEncoding(new GZipEncoding());
    }
    response=executeCurrentRequest(currentRequest);
    boolean returningResponse=false;
    try {
      if (response.isSuccessStatusCode()) {
        bytesUploaded=getMediaContentLength();
        if (mediaContent.getCloseInputStream()) {
          contentInputStream.close();
        }
        updateStateAndNotifyListener(UploadState.MEDIA_COMPLETE);
        returningResponse=true;
        return response;
      }
      if (response.getStatusCode() != 308) {
        returningResponse=true;
        return response;
      }
      String updatedUploadUrl=response.getHeaders().getLocation();
      if (updatedUploadUrl != null) {
        uploadUrl=new GenericUrl(updatedUploadUrl);
      }
      bytesUploaded=getNextByteIndex(response.getHeaders().getRange());
      currentRequestContentBuffer=null;
      updateStateAndNotifyListener(UploadState.MEDIA_IN_PROGRESS);
    }
  finally {
      if (!returningResponse) {
        response.disconnect();
      }
    }
  }
}","/** 
 * Executes a direct media upload or resumable media upload conforming to the specifications listed <a href='http://code.google.com/apis/gdata/docs/resumable_upload.html'>here.</a> <p> This method is not reentrant. A new instance of   {@link MediaHttpUploader} must be instantiatedbefore upload called be called again. </p> <p> If an error is encountered during the request execution the caller is responsible for parsing the response correctly. For example for JSON errors: </p> <pre> if (!response.isSuccessStatusCode()) { throw GoogleJsonResponseException.from(jsonFactory, response); } </pre> <p> Callers should call  {@link HttpResponse#disconnect} when the returned HTTP response object isno longer needed. However,  {@link HttpResponse#disconnect} does not have to be called if theresponse stream is properly closed. Example usage: </p> <pre> HttpResponse response = batch.upload(initiationRequestUrl); try { // process the HTTP response object } finally { response.disconnect(); } </pre>
 * @param initiationRequestUrl The request URL where the initiation request will be sent
 * @return HTTP response
 */
public HttpResponse upload(GenericUrl initiationRequestUrl) throws IOException {
  Preconditions.checkArgument(uploadState == UploadState.NOT_STARTED);
  if (directUploadEnabled) {
    updateStateAndNotifyListener(UploadState.MEDIA_IN_PROGRESS);
    HttpContent content=mediaContent;
    if (metadata != null) {
      content=new MultipartContent().setContentParts(Arrays.asList(metadata,mediaContent));
      initiationRequestUrl.put(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      initiationRequestUrl.put(""String_Node_Str"",""String_Node_Str"");
    }
    HttpRequest request=requestFactory.buildRequest(initiationRequestMethod,initiationRequestUrl,content);
    request.getHeaders().putAll(initiationHeaders);
    HttpResponse response=executeCurrentRequestWithBackOffAndGZip(request);
    boolean responseProcessed=false;
    try {
      if (getMediaContentLength() >= 0) {
        bytesUploaded=getMediaContentLength();
      }
      updateStateAndNotifyListener(UploadState.MEDIA_COMPLETE);
      responseProcessed=true;
    }
  finally {
      if (!responseProcessed) {
        response.disconnect();
      }
    }
    return response;
  }
  HttpResponse initialResponse=executeUploadInitiation(initiationRequestUrl);
  if (!initialResponse.isSuccessStatusCode()) {
    return initialResponse;
  }
  GenericUrl uploadUrl;
  try {
    uploadUrl=new GenericUrl(initialResponse.getHeaders().getLocation());
  }
  finally {
    initialResponse.disconnect();
  }
  contentInputStream=mediaContent.getInputStream();
  if (!contentInputStream.markSupported() && getMediaContentLength() >= 0) {
    contentInputStream=new BufferedInputStream(contentInputStream);
  }
  HttpResponse response;
  while (true) {
    currentRequest=requestFactory.buildPutRequest(uploadUrl,null);
    setContentAndHeadersOnCurrentRequest(bytesUploaded);
    if (backOffPolicyEnabled) {
      currentRequest.setBackOffPolicy(new MediaUploadExponentialBackOffPolicy(this));
    }
 else {
    }
    if (getMediaContentLength() >= 0) {
    }
 else     if (!disableGZipContent) {
      currentRequest.setEncoding(new GZipEncoding());
    }
    response=executeCurrentRequest(currentRequest);
    boolean returningResponse=false;
    try {
      if (response.isSuccessStatusCode()) {
        bytesUploaded=getMediaContentLength();
        if (mediaContent.getCloseInputStream()) {
          contentInputStream.close();
        }
        updateStateAndNotifyListener(UploadState.MEDIA_COMPLETE);
        returningResponse=true;
        return response;
      }
      if (response.getStatusCode() != 308) {
        returningResponse=true;
        return response;
      }
      String updatedUploadUrl=response.getHeaders().getLocation();
      if (updatedUploadUrl != null) {
        uploadUrl=new GenericUrl(updatedUploadUrl);
      }
      bytesUploaded=getNextByteIndex(response.getHeaders().getRange());
      currentRequestContentBuffer=null;
      updateStateAndNotifyListener(UploadState.MEDIA_IN_PROGRESS);
    }
  finally {
      if (!returningResponse) {
        response.disconnect();
      }
    }
  }
}"
54841,"/** 
 * The call back method that will be invoked on a server error or an I/O exception during resumable upload inside   {@link #upload}. <p> This method will query the current status of the upload to find how many bytes were successfully uploaded before the server error occurred. It will then adjust the HTTP Request object to contain the correct range header and media content chunk. </p>
 */
public void serverErrorCallback() throws IOException {
  Preconditions.checkNotNull(currentRequest,""String_Node_Str"");
  HttpRequest request=requestFactory.buildPutRequest(currentRequest.getUrl(),new EmptyContent());
  request.getHeaders().setContentRange(""String_Node_Str"" + (getMediaContentLength() >= 0 ? getMediaContentLength() : ""String_Node_Str""));
  HttpResponse response=executeCurrentRequestWithBackOffAndGZip(request);
  try {
    long bytesWritten=getNextByteIndex(response.getHeaders().getRange());
    String updatedUploadUrl=response.getHeaders().getLocation();
    if (updatedUploadUrl != null) {
      currentRequest.setUrl(new GenericUrl(updatedUploadUrl));
    }
    if (getMediaContentLength() >= 0) {
      contentInputStream.reset();
      long skipValue=bytesUploaded - bytesWritten;
      long actualSkipValue=contentInputStream.skip(skipValue);
      Preconditions.checkState(skipValue == actualSkipValue);
    }
    setContentAndHeadersOnCurrentRequest(bytesWritten);
  }
  finally {
    response.disconnect();
  }
}","/** 
 * {@link Beta} <br/>The call back method that will be invoked on a server error or an I/O exception during resumable upload inside  {@link #upload}. <p> This method will query the current status of the upload to find how many bytes were successfully uploaded before the server error occurred. It will then adjust the HTTP Request object to contain the correct range header and media content chunk. </p>
 */
@Beta public void serverErrorCallback() throws IOException {
  Preconditions.checkNotNull(currentRequest,""String_Node_Str"");
  HttpRequest request=requestFactory.buildPutRequest(currentRequest.getUrl(),new EmptyContent());
  request.getHeaders().setContentRange(""String_Node_Str"" + (getMediaContentLength() >= 0 ? getMediaContentLength() : ""String_Node_Str""));
  HttpResponse response=executeCurrentRequestWithBackOffAndGZip(request);
  try {
    long bytesWritten=getNextByteIndex(response.getHeaders().getRange());
    String updatedUploadUrl=response.getHeaders().getLocation();
    if (updatedUploadUrl != null) {
      currentRequest.setUrl(new GenericUrl(updatedUploadUrl));
    }
    if (getMediaContentLength() >= 0) {
      contentInputStream.reset();
      long skipValue=bytesUploaded - bytesWritten;
      long actualSkipValue=contentInputStream.skip(skipValue);
      Preconditions.checkState(skipValue == actualSkipValue);
    }
    setContentAndHeadersOnCurrentRequest(bytesWritten);
  }
  finally {
    response.disconnect();
  }
}"
54842,"public void testUploadServerErrorWithBackOffEnabled_WithNoContentSizeProvided() throws Exception {
  int contentLength=MediaHttpUploader.DEFAULT_CHUNK_SIZE * 2;
  MediaTransport fakeTransport=new MediaTransport(contentLength);
  fakeTransport.testServerError=true;
  fakeTransport.contentLengthNotSpecified=true;
  InputStream is=new ByteArrayInputStream(new byte[contentLength]);
  InputStreamContent mediaContent=new InputStreamContent(TEST_CONTENT_TYPE,is);
  MediaHttpUploader uploader=new MediaHttpUploader(mediaContent,fakeTransport,null);
  uploader.setBackOffPolicyEnabled(true);
  uploader.upload(new GenericUrl(TEST_RESUMABLE_REQUEST_URL));
  assertEquals(5,fakeTransport.lowLevelExecCalls);
}","@SuppressWarnings(""String_Node_Str"") public void testUploadServerErrorWithBackOffEnabled_WithNoContentSizeProvided() throws Exception {
  int contentLength=MediaHttpUploader.DEFAULT_CHUNK_SIZE * 2;
  MediaTransport fakeTransport=new MediaTransport(contentLength);
  fakeTransport.testServerError=true;
  fakeTransport.contentLengthNotSpecified=true;
  InputStream is=new ByteArrayInputStream(new byte[contentLength]);
  InputStreamContent mediaContent=new InputStreamContent(TEST_CONTENT_TYPE,is);
  MediaHttpUploader uploader=new MediaHttpUploader(mediaContent,fakeTransport,null);
  uploader.setBackOffPolicyEnabled(true);
  uploader.upload(new GenericUrl(TEST_RESUMABLE_REQUEST_URL));
  assertEquals(5,fakeTransport.lowLevelExecCalls);
}"
54843,"public void testUploadServerErrorWithBackOffEnabled() throws Exception {
  int contentLength=MediaHttpUploader.DEFAULT_CHUNK_SIZE * 2;
  MediaTransport fakeTransport=new MediaTransport(contentLength);
  fakeTransport.testServerError=true;
  InputStream is=new ByteArrayInputStream(new byte[contentLength]);
  InputStreamContent mediaContent=new InputStreamContent(TEST_CONTENT_TYPE,is);
  mediaContent.setLength(contentLength);
  MediaHttpUploader uploader=new MediaHttpUploader(mediaContent,fakeTransport,null);
  uploader.setBackOffPolicyEnabled(true);
  uploader.upload(new GenericUrl(TEST_RESUMABLE_REQUEST_URL));
  assertEquals(5,fakeTransport.lowLevelExecCalls);
}","@SuppressWarnings(""String_Node_Str"") public void testUploadServerErrorWithBackOffEnabled() throws Exception {
  int contentLength=MediaHttpUploader.DEFAULT_CHUNK_SIZE * 2;
  MediaTransport fakeTransport=new MediaTransport(contentLength);
  fakeTransport.testServerError=true;
  InputStream is=new ByteArrayInputStream(new byte[contentLength]);
  InputStreamContent mediaContent=new InputStreamContent(TEST_CONTENT_TYPE,is);
  mediaContent.setLength(contentLength);
  MediaHttpUploader uploader=new MediaHttpUploader(mediaContent,fakeTransport,null);
  uploader.setBackOffPolicyEnabled(true);
  uploader.upload(new GenericUrl(TEST_RESUMABLE_REQUEST_URL));
  assertEquals(5,fakeTransport.lowLevelExecCalls);
}"
54844,"public void testDirectUploadServerErrorWithBackOffEnabled() throws Exception {
  int contentLength=MediaHttpUploader.DEFAULT_CHUNK_SIZE * 2;
  MediaTransport fakeTransport=new MediaTransport(contentLength);
  fakeTransport.testServerError=true;
  fakeTransport.directUploadEnabled=true;
  ByteArrayContent mediaContent=new ByteArrayContent(TEST_CONTENT_TYPE,new byte[contentLength]);
  MediaHttpUploader uploader=new MediaHttpUploader(mediaContent,fakeTransport,null);
  uploader.setDirectUploadEnabled(true);
  uploader.setBackOffPolicyEnabled(true);
  uploader.upload(new GenericUrl(TEST_DIRECT_REQUEST_URL));
  assertEquals(2,fakeTransport.lowLevelExecCalls);
}","@SuppressWarnings(""String_Node_Str"") public void testDirectUploadServerErrorWithBackOffEnabled() throws Exception {
  int contentLength=MediaHttpUploader.DEFAULT_CHUNK_SIZE * 2;
  MediaTransport fakeTransport=new MediaTransport(contentLength);
  fakeTransport.testServerError=true;
  fakeTransport.directUploadEnabled=true;
  ByteArrayContent mediaContent=new ByteArrayContent(TEST_CONTENT_TYPE,new byte[contentLength]);
  MediaHttpUploader uploader=new MediaHttpUploader(mediaContent,fakeTransport,null);
  uploader.setDirectUploadEnabled(true);
  uploader.setBackOffPolicyEnabled(true);
  uploader.upload(new GenericUrl(TEST_DIRECT_REQUEST_URL));
  assertEquals(2,fakeTransport.lowLevelExecCalls);
}"
54845,"/** 
 * Executes a direct media upload or resumable media upload conforming to the specifications listed <a href='http://code.google.com/apis/gdata/docs/resumable_upload.html'>here.</a> <p> This method is not reentrant. A new instance of   {@link MediaHttpUploader} must be instantiatedbefore upload called be called again. </p> <p> If an error is encountered during the request execution the caller is responsible for parsing the response correctly. For example for JSON errors: <pre> if (!response.isSuccessStatusCode()) { throw GoogleJsonResponseException.from(jsonFactory, response); } </pre> </p> <p> Callers should call  {@link HttpResponse#disconnect} when the returned HTTP response object isno longer needed. However,  {@link HttpResponse#disconnect} does not have to be called if theresponse stream is properly closed. Example usage: </p> <pre> HttpResponse response = batch.upload(initiationRequestUrl); try { // process the HTTP response object } finally { response.disconnect(); } </pre>
 * @param initiationRequestUrl The request URL where the initiation request will be sent
 * @return HTTP response
 */
public HttpResponse upload(GenericUrl initiationRequestUrl) throws IOException {
  Preconditions.checkArgument(uploadState == UploadState.NOT_STARTED);
  if (directUploadEnabled) {
    updateStateAndNotifyListener(UploadState.MEDIA_IN_PROGRESS);
    HttpContent content=mediaContent;
    if (metadata != null) {
      content=new MultipartContent().setContentParts(Arrays.asList(metadata,mediaContent));
      initiationRequestUrl.put(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      initiationRequestUrl.put(""String_Node_Str"",""String_Node_Str"");
    }
    HttpRequest request=requestFactory.buildRequest(initiationRequestMethod,initiationRequestUrl,content);
    request.getHeaders().putAll(initiationHeaders);
    HttpResponse response=executeCurrentRequestWithBackOffAndGZip(request);
    boolean responseProcessed=false;
    try {
      if (getMediaContentLength() >= 0) {
        bytesUploaded=getMediaContentLength();
      }
      updateStateAndNotifyListener(UploadState.MEDIA_COMPLETE);
      responseProcessed=true;
    }
  finally {
      if (!responseProcessed) {
        response.disconnect();
      }
    }
    return response;
  }
  HttpResponse initialResponse=executeUploadInitiation(initiationRequestUrl);
  if (!initialResponse.isSuccessStatusCode()) {
    return initialResponse;
  }
  GenericUrl uploadUrl;
  try {
    uploadUrl=new GenericUrl(initialResponse.getHeaders().getLocation());
  }
  finally {
    initialResponse.disconnect();
  }
  contentInputStream=mediaContent.getInputStream();
  if (!contentInputStream.markSupported() && getMediaContentLength() >= 0) {
    contentInputStream=new BufferedInputStream(contentInputStream);
  }
  HttpResponse response;
  while (true) {
    currentRequest=requestFactory.buildPutRequest(uploadUrl,null);
    setContentAndHeadersOnCurrentRequest(bytesUploaded);
    if (backOffPolicyEnabled) {
      currentRequest.setBackOffPolicy(new MediaUploadExponentialBackOffPolicy(this));
    }
    if (getMediaContentLength() >= 0) {
    }
 else     if (!disableGZipContent) {
      currentRequest.setEncoding(new GZipEncoding());
    }
    response=executeCurrentRequest(currentRequest);
    boolean returningResponse=false;
    try {
      if (response.isSuccessStatusCode()) {
        bytesUploaded=getMediaContentLength();
        contentInputStream.close();
        updateStateAndNotifyListener(UploadState.MEDIA_COMPLETE);
        returningResponse=true;
        return response;
      }
      if (response.getStatusCode() != 308) {
        returningResponse=true;
        return response;
      }
      String updatedUploadUrl=response.getHeaders().getLocation();
      if (updatedUploadUrl != null) {
        uploadUrl=new GenericUrl(updatedUploadUrl);
      }
      bytesUploaded=getNextByteIndex(response.getHeaders().getRange());
      currentRequestContentBuffer=null;
      updateStateAndNotifyListener(UploadState.MEDIA_IN_PROGRESS);
    }
  finally {
      if (!returningResponse) {
        response.disconnect();
      }
    }
  }
}","/** 
 * Executes a direct media upload or resumable media upload conforming to the specifications listed <a href='http://code.google.com/apis/gdata/docs/resumable_upload.html'>here.</a> <p> This method is not reentrant. A new instance of   {@link MediaHttpUploader} must be instantiatedbefore upload called be called again. </p> <p> If an error is encountered during the request execution the caller is responsible for parsing the response correctly. For example for JSON errors: <pre> if (!response.isSuccessStatusCode()) { throw GoogleJsonResponseException.from(jsonFactory, response); } </pre> </p> <p> Callers should call  {@link HttpResponse#disconnect} when the returned HTTP response object isno longer needed. However,  {@link HttpResponse#disconnect} does not have to be called if theresponse stream is properly closed. Example usage: </p> <pre> HttpResponse response = batch.upload(initiationRequestUrl); try { // process the HTTP response object } finally { response.disconnect(); } </pre>
 * @param initiationRequestUrl The request URL where the initiation request will be sent
 * @return HTTP response
 */
public HttpResponse upload(GenericUrl initiationRequestUrl) throws IOException {
  Preconditions.checkArgument(uploadState == UploadState.NOT_STARTED);
  if (directUploadEnabled) {
    updateStateAndNotifyListener(UploadState.MEDIA_IN_PROGRESS);
    HttpContent content=mediaContent;
    if (metadata != null) {
      content=new MultipartContent().setContentParts(Arrays.asList(metadata,mediaContent));
      initiationRequestUrl.put(""String_Node_Str"",""String_Node_Str"");
    }
 else {
      initiationRequestUrl.put(""String_Node_Str"",""String_Node_Str"");
    }
    HttpRequest request=requestFactory.buildRequest(initiationRequestMethod,initiationRequestUrl,content);
    request.getHeaders().putAll(initiationHeaders);
    HttpResponse response=executeCurrentRequestWithBackOffAndGZip(request);
    boolean responseProcessed=false;
    try {
      if (getMediaContentLength() >= 0) {
        bytesUploaded=getMediaContentLength();
      }
      updateStateAndNotifyListener(UploadState.MEDIA_COMPLETE);
      responseProcessed=true;
    }
  finally {
      if (!responseProcessed) {
        response.disconnect();
      }
    }
    return response;
  }
  HttpResponse initialResponse=executeUploadInitiation(initiationRequestUrl);
  if (!initialResponse.isSuccessStatusCode()) {
    return initialResponse;
  }
  GenericUrl uploadUrl;
  try {
    uploadUrl=new GenericUrl(initialResponse.getHeaders().getLocation());
  }
  finally {
    initialResponse.disconnect();
  }
  contentInputStream=mediaContent.getInputStream();
  if (!contentInputStream.markSupported() && getMediaContentLength() >= 0) {
    contentInputStream=new BufferedInputStream(contentInputStream);
  }
  HttpResponse response;
  while (true) {
    currentRequest=requestFactory.buildPutRequest(uploadUrl,null);
    setContentAndHeadersOnCurrentRequest(bytesUploaded);
    if (backOffPolicyEnabled) {
      currentRequest.setBackOffPolicy(new MediaUploadExponentialBackOffPolicy(this));
    }
    if (getMediaContentLength() >= 0) {
    }
 else     if (!disableGZipContent) {
      currentRequest.setEncoding(new GZipEncoding());
    }
    response=executeCurrentRequest(currentRequest);
    boolean returningResponse=false;
    try {
      if (response.isSuccessStatusCode()) {
        bytesUploaded=getMediaContentLength();
        if (mediaContent.getCloseInputStream()) {
          contentInputStream.close();
        }
        updateStateAndNotifyListener(UploadState.MEDIA_COMPLETE);
        returningResponse=true;
        return response;
      }
      if (response.getStatusCode() != 308) {
        returningResponse=true;
        return response;
      }
      String updatedUploadUrl=response.getHeaders().getLocation();
      if (updatedUploadUrl != null) {
        uploadUrl=new GenericUrl(updatedUploadUrl);
      }
      bytesUploaded=getNextByteIndex(response.getHeaders().getRange());
      currentRequestContentBuffer=null;
      updateStateAndNotifyListener(UploadState.MEDIA_IN_PROGRESS);
    }
  finally {
      if (!returningResponse) {
        response.disconnect();
      }
    }
  }
}"
54846,"/** 
 * Sets the HTTP media content chunk and the required headers that should be used in the upload request.
 * @param bytesWritten The number of bytes that have been successfully uploaded on the server
 */
private void setContentAndHeadersOnCurrentRequest(long bytesWritten) throws IOException {
  int blockSize;
  if (getMediaContentLength() >= 0) {
    blockSize=(int)Math.min(chunkSize,getMediaContentLength() - bytesWritten);
  }
 else {
    blockSize=chunkSize;
  }
  AbstractInputStreamContent contentChunk;
  int actualBlockSize=blockSize;
  String mediaContentLengthStr;
  if (getMediaContentLength() >= 0) {
    contentInputStream.mark(blockSize);
    InputStream limitInputStream=ByteStreams.limit(contentInputStream,blockSize);
    contentChunk=new InputStreamContent(mediaContent.getType(),limitInputStream).setRetrySupported(true).setLength(blockSize).setCloseInputStream(false);
    mediaContentLengthStr=String.valueOf(getMediaContentLength());
  }
 else {
    int actualBytesRead;
    int bytesAllowedToRead;
    int contentBufferStartIndex=0;
    if (currentRequestContentBuffer == null) {
      bytesAllowedToRead=cachedByte == null ? blockSize + 1 : blockSize;
      InputStream limitInputStream=ByteStreams.limit(contentInputStream,bytesAllowedToRead);
      currentRequestContentBuffer=new byte[blockSize + 1];
      if (cachedByte != null) {
        currentRequestContentBuffer[0]=cachedByte;
      }
      actualBytesRead=limitInputStream.read(currentRequestContentBuffer,blockSize + 1 - bytesAllowedToRead,bytesAllowedToRead);
    }
 else {
      bytesAllowedToRead=(int)(chunkSize - (bytesWritten - bytesUploaded) + 1);
      contentBufferStartIndex=(int)(bytesWritten - bytesUploaded);
      actualBytesRead=bytesAllowedToRead;
    }
    if (actualBytesRead < bytesAllowedToRead) {
      actualBlockSize=Math.max(0,actualBytesRead);
      if (cachedByte != null) {
        actualBlockSize++;
      }
      mediaContentLengthStr=String.valueOf(bytesWritten + actualBlockSize);
    }
 else {
      cachedByte=currentRequestContentBuffer[blockSize];
      mediaContentLengthStr=""String_Node_Str"";
    }
    contentChunk=new ByteArrayContent(mediaContent.getType(),currentRequestContentBuffer,contentBufferStartIndex,actualBlockSize);
  }
  currentRequest.setContent(contentChunk);
  if (actualBlockSize == 0) {
    currentRequest.getHeaders().setContentRange(""String_Node_Str"");
  }
 else {
    currentRequest.getHeaders().setContentRange(""String_Node_Str"" + bytesWritten + ""String_Node_Str""+ (bytesWritten + actualBlockSize - 1)+ ""String_Node_Str""+ mediaContentLengthStr);
  }
}","/** 
 * Sets the HTTP media content chunk and the required headers that should be used in the upload request.
 * @param bytesWritten The number of bytes that have been successfully uploaded on the server
 */
private void setContentAndHeadersOnCurrentRequest(long bytesWritten) throws IOException {
  int blockSize;
  if (getMediaContentLength() >= 0) {
    blockSize=(int)Math.min(chunkSize,getMediaContentLength() - bytesWritten);
  }
 else {
    blockSize=chunkSize;
  }
  AbstractInputStreamContent contentChunk;
  int actualBlockSize=blockSize;
  String mediaContentLengthStr;
  if (getMediaContentLength() >= 0) {
    contentInputStream.mark(blockSize);
    InputStream limitInputStream=ByteStreams.limit(contentInputStream,blockSize);
    contentChunk=new InputStreamContent(mediaContent.getType(),limitInputStream).setRetrySupported(true).setLength(blockSize).setCloseInputStream(false);
    mediaContentLengthStr=String.valueOf(getMediaContentLength());
  }
 else {
    int actualBytesRead;
    int bytesAllowedToRead;
    int contentBufferStartIndex=0;
    if (currentRequestContentBuffer == null) {
      bytesAllowedToRead=cachedByte == null ? blockSize + 1 : blockSize;
      currentRequestContentBuffer=new byte[blockSize + 1];
      if (cachedByte != null) {
        currentRequestContentBuffer[0]=cachedByte;
      }
      actualBytesRead=ByteStreams.read(contentInputStream,currentRequestContentBuffer,blockSize + 1 - bytesAllowedToRead,bytesAllowedToRead);
    }
 else {
      bytesAllowedToRead=(int)(chunkSize - (bytesWritten - bytesUploaded) + 1);
      contentBufferStartIndex=(int)(bytesWritten - bytesUploaded);
      actualBytesRead=bytesAllowedToRead;
    }
    if (actualBytesRead < bytesAllowedToRead) {
      actualBlockSize=Math.max(0,actualBytesRead);
      if (cachedByte != null) {
        actualBlockSize++;
      }
      mediaContentLengthStr=String.valueOf(bytesWritten + actualBlockSize);
    }
 else {
      cachedByte=currentRequestContentBuffer[blockSize];
      mediaContentLengthStr=""String_Node_Str"";
    }
    contentChunk=new ByteArrayContent(mediaContent.getType(),currentRequestContentBuffer,contentBufferStartIndex,actualBlockSize);
  }
  currentRequest.setContent(contentChunk);
  if (actualBlockSize == 0) {
    currentRequest.getHeaders().setContentRange(""String_Node_Str"");
  }
 else {
    currentRequest.getHeaders().setContentRange(""String_Node_Str"" + bytesWritten + ""String_Node_Str""+ (bytesWritten + actualBlockSize - 1)+ ""String_Node_Str""+ mediaContentLengthStr);
  }
}"
54847,"/** 
 * @param request HTTP GET request
 * @param notificationDeliveryMethod notification delivery method
 */
public SubscribeRequest(HttpRequest request,String notificationDeliveryMethod){
  this.request=Preconditions.checkNotNull(request);
  Preconditions.checkArgument(HttpMethods.GET.equals(request.getRequestMethod()));
  request.setRequestMethod(HttpMethods.POST);
  setNotificationDeliveryMethod(notificationDeliveryMethod);
  setSubscriptionId(UUID.randomUUID().toString());
}","/** 
 * @param request HTTP GET request
 * @param notificationDeliveryMethod notification delivery method
 */
public SubscribeRequest(HttpRequest request,String notificationDeliveryMethod){
  this.request=Preconditions.checkNotNull(request);
  Preconditions.checkArgument(HttpMethods.GET.equals(request.getRequestMethod()));
  request.setRequestMethod(HttpMethods.POST);
  request.setContent(new EmptyContent());
  setNotificationDeliveryMethod(notificationDeliveryMethod);
  setSubscriptionId(UUID.randomUUID().toString());
}"
54848,"@Override public void initialize(AbstractGoogleClientRequest<?> request){
  isCalled=true;
}","public void initialize(AbstractGoogleClientRequest<?> request){
  isCalled=true;
}"
54849,"/** 
 * Intercept the request by using the access token obtained from the   {@link AppIdentityService}. <p> Upgrade warning: this method now throws an   {@link Exception}. In prior version 1.11 it threw an  {@link java.io.IOException}. In prior version   {@link AppIdentityServiceFailureException} waswrapped with an  {@link Exception}, but now it is no longer wrapped. </p>
 */
@Override public void intercept(HttpRequest request) throws Exception {
  String accessToken=AppIdentityServiceFactory.getAppIdentityService().getAccessToken(scopes).getAccessToken();
  BearerToken.authorizationHeaderAccessMethod().intercept(request,accessToken);
}","/** 
 * Intercept the request by using the access token obtained from the   {@link AppIdentityService}. <p> Upgrade warning: this method now throws an   {@link Exception}. In prior version 1.11 it threw an  {@link java.io.IOException}. In prior version   {@link AppIdentityServiceFailureException} waswrapped with an  {@link Exception}, but now it is no longer wrapped. </p>
 */
@Override public void intercept(HttpRequest request) throws Exception {
  String accessToken=appIdentityService.getAccessToken(scopes).getAccessToken();
  BearerToken.authorizationHeaderAccessMethod().intercept(request,accessToken);
}"
54850,"/** 
 * Executes a direct media download or a resumable media download. <p> This method does not close the given output stream. </p> <p> This method is not reentrant. A new instance of   {@link MediaHttpDownloader} must beinstantiated before download called be called again. </p>
 * @param requestUrl The request URL where the download requests will be sent
 * @param requestHeaders request headers or {@code null} to ignore
 * @param outputStream destination output stream
 * @since 1.12
 */
public void download(GenericUrl requestUrl,HttpHeaders requestHeaders,OutputStream outputStream) throws IOException {
  Preconditions.checkArgument(downloadState == DownloadState.NOT_STARTED);
  requestUrl.put(""String_Node_Str"",""String_Node_Str"");
  if (directDownloadEnabled) {
    updateStateAndNotifyListener(DownloadState.MEDIA_IN_PROGRESS);
    HttpRequest request=requestFactory.buildGetRequest(requestUrl);
    if (requestHeaders != null) {
      request.getHeaders().putAll(requestHeaders);
    }
    HttpResponse response=request.execute();
    try {
      mediaContentLength=response.getHeaders().getContentLength();
      bytesDownloaded=mediaContentLength;
      updateStateAndNotifyListener(DownloadState.MEDIA_COMPLETE);
      AbstractInputStreamContent.copy(response.getContent(),outputStream);
    }
  finally {
      response.disconnect();
    }
    return;
  }
  while (true) {
    HttpRequest request=requestFactory.buildGetRequest(requestUrl);
    if (requestHeaders != null) {
      request.getHeaders().putAll(requestHeaders);
    }
    request.getHeaders().setRange(""String_Node_Str"" + bytesDownloaded + ""String_Node_Str""+ (bytesDownloaded + chunkSize - 1));
    if (backOffPolicyEnabled) {
      request.setBackOffPolicy(new ExponentialBackOffPolicy());
    }
    HttpResponse response=request.execute();
    AbstractInputStreamContent.copy(response.getContent(),outputStream);
    String contentRange=response.getHeaders().getContentRange();
    long nextByteIndex=getNextByteIndex(contentRange);
    setMediaContentLength(contentRange);
    if (mediaContentLength <= nextByteIndex) {
      bytesDownloaded=mediaContentLength;
      updateStateAndNotifyListener(DownloadState.MEDIA_COMPLETE);
      return;
    }
    bytesDownloaded=nextByteIndex;
    updateStateAndNotifyListener(DownloadState.MEDIA_IN_PROGRESS);
  }
}","/** 
 * Executes a direct media download or a resumable media download. <p> This method does not close the given output stream. </p> <p> This method is not reentrant. A new instance of   {@link MediaHttpDownloader} must beinstantiated before download called be called again. </p>
 * @param requestUrl The request URL where the download requests will be sent
 * @param requestHeaders request headers or {@code null} to ignore
 * @param outputStream destination output stream
 * @since 1.12
 */
public void download(GenericUrl requestUrl,HttpHeaders requestHeaders,OutputStream outputStream) throws IOException {
  Preconditions.checkArgument(downloadState == DownloadState.NOT_STARTED);
  requestUrl.put(""String_Node_Str"",""String_Node_Str"");
  if (directDownloadEnabled) {
    updateStateAndNotifyListener(DownloadState.MEDIA_IN_PROGRESS);
    HttpRequest request=requestFactory.buildGetRequest(requestUrl);
    if (requestHeaders != null) {
      request.getHeaders().putAll(requestHeaders);
    }
    if (bytesDownloaded != 0) {
      request.getHeaders().setRange(""String_Node_Str"" + bytesDownloaded + ""String_Node_Str"");
    }
    HttpResponse response=request.execute();
    try {
      mediaContentLength=response.getHeaders().getContentLength();
      bytesDownloaded=mediaContentLength;
      updateStateAndNotifyListener(DownloadState.MEDIA_COMPLETE);
      AbstractInputStreamContent.copy(response.getContent(),outputStream);
    }
  finally {
      response.disconnect();
    }
    return;
  }
  while (true) {
    HttpRequest request=requestFactory.buildGetRequest(requestUrl);
    if (requestHeaders != null) {
      request.getHeaders().putAll(requestHeaders);
    }
    request.getHeaders().setRange(""String_Node_Str"" + bytesDownloaded + ""String_Node_Str""+ (bytesDownloaded + chunkSize - 1));
    if (backOffPolicyEnabled) {
      request.setBackOffPolicy(new ExponentialBackOffPolicy());
    }
    HttpResponse response=request.execute();
    AbstractInputStreamContent.copy(response.getContent(),outputStream);
    String contentRange=response.getHeaders().getContentRange();
    long nextByteIndex=getNextByteIndex(contentRange);
    setMediaContentLength(contentRange);
    if (mediaContentLength <= nextByteIndex) {
      bytesDownloaded=mediaContentLength;
      updateStateAndNotifyListener(DownloadState.MEDIA_COMPLETE);
      return;
    }
    bytesDownloaded=nextByteIndex;
    updateStateAndNotifyListener(DownloadState.MEDIA_IN_PROGRESS);
  }
}"
54851,"@Override public LowLevelHttpRequest buildRequest(String name,String url){
  assertEquals(TEST_REQUEST_URL,url);
  return new MockLowLevelHttpRequest(){
    @Override public LowLevelHttpResponse execute(){
      lowLevelExecCalls++;
      MockLowLevelHttpResponse response=new MockLowLevelHttpResponse();
      if (directDownloadEnabled) {
        response.setStatusCode(200);
        response.addHeader(""String_Node_Str"",String.valueOf(contentLength));
        response.setContent(testChunkStream);
        return response;
      }
      assertEquals(""String_Node_Str"" + bytesDownloaded + ""String_Node_Str""+ (bytesDownloaded + TEST_CHUNK_SIZE - 1),getHeaders().get(""String_Node_Str"").get(0));
      if (testServerError && lowLevelExecCalls == 2) {
        response.setStatusCode(500);
        return response;
      }
 else       if (testClientError) {
        response.setStatusCode(404);
        return response;
      }
      response.setStatusCode(206);
      response.addHeader(""String_Node_Str"",""String_Node_Str"" + bytesDownloaded + ""String_Node_Str""+ (bytesDownloaded + TEST_CHUNK_SIZE - 1)+ ""String_Node_Str""+ contentLength);
      response.setContent(testChunkStream);
      bytesDownloaded+=TEST_CHUNK_SIZE;
      return response;
    }
  }
;
}","@Override public LowLevelHttpRequest buildRequest(String name,String url){
  assertEquals(TEST_REQUEST_URL,url);
  return new MockLowLevelHttpRequest(){
    @Override public LowLevelHttpResponse execute(){
      lowLevelExecCalls++;
      MockLowLevelHttpResponse response=new MockLowLevelHttpResponse();
      if (directDownloadEnabled) {
        response.setStatusCode(200);
        response.addHeader(""String_Node_Str"",String.valueOf(contentLength));
        response.setContent(new ByteArrayInputStream(new byte[contentLength - bytesDownloaded]));
        return response;
      }
      assertEquals(""String_Node_Str"" + bytesDownloaded + ""String_Node_Str""+ (bytesDownloaded + TEST_CHUNK_SIZE - 1),getHeaders().get(""String_Node_Str"").get(0));
      if (testServerError && lowLevelExecCalls == 2) {
        response.setStatusCode(500);
        return response;
      }
 else       if (testClientError) {
        response.setStatusCode(404);
        return response;
      }
      response.setStatusCode(206);
      int upper=Math.min(bytesDownloaded + TEST_CHUNK_SIZE,contentLength) - 1;
      response.addHeader(""String_Node_Str"",""String_Node_Str"" + bytesDownloaded + ""String_Node_Str""+ upper+ ""String_Node_Str""+ contentLength);
      int bytesDownloadedCur=upper - bytesDownloaded + 1;
      response.setContent(new ByteArrayInputStream(new byte[bytesDownloadedCur]));
      bytesDownloaded+=bytesDownloadedCur;
      return response;
    }
  }
;
}"
54852,"public void testDownloadOneCallHalfChunkSize() throws Exception {
  int contentLength=MediaHttpDownloader.MAXIMUM_CHUNK_SIZE / 2;
  ByteArrayOutputStream outputStream=new ByteArrayOutputStream();
  MediaTransport fakeTransport=new MediaTransport(contentLength);
  MediaHttpDownloader downloader=new MediaHttpDownloader(fakeTransport,null);
  downloader.download(new GenericUrl(TEST_REQUEST_URL),outputStream);
  assertEquals(TEST_CHUNK_SIZE,outputStream.size());
  assertEquals(1,fakeTransport.lowLevelExecCalls);
}","public void testDownloadOneCallHalfChunkSize() throws Exception {
  int contentLength=MediaHttpDownloader.MAXIMUM_CHUNK_SIZE / 2;
  ByteArrayOutputStream outputStream=new ByteArrayOutputStream();
  MediaTransport fakeTransport=new MediaTransport(contentLength);
  MediaHttpDownloader downloader=new MediaHttpDownloader(fakeTransport,null);
  downloader.download(new GenericUrl(TEST_REQUEST_URL),outputStream);
  assertEquals(contentLength,outputStream.size());
  assertEquals(1,fakeTransport.lowLevelExecCalls);
}"
54853,"@Override public LowLevelHttpResponse execute(){
  lowLevelExecCalls++;
  MockLowLevelHttpResponse response=new MockLowLevelHttpResponse();
  if (directDownloadEnabled) {
    response.setStatusCode(200);
    response.addHeader(""String_Node_Str"",String.valueOf(contentLength));
    response.setContent(testChunkStream);
    return response;
  }
  assertEquals(""String_Node_Str"" + bytesDownloaded + ""String_Node_Str""+ (bytesDownloaded + TEST_CHUNK_SIZE - 1),getHeaders().get(""String_Node_Str"").get(0));
  if (testServerError && lowLevelExecCalls == 2) {
    response.setStatusCode(500);
    return response;
  }
 else   if (testClientError) {
    response.setStatusCode(404);
    return response;
  }
  response.setStatusCode(206);
  response.addHeader(""String_Node_Str"",""String_Node_Str"" + bytesDownloaded + ""String_Node_Str""+ (bytesDownloaded + TEST_CHUNK_SIZE - 1)+ ""String_Node_Str""+ contentLength);
  response.setContent(testChunkStream);
  bytesDownloaded+=TEST_CHUNK_SIZE;
  return response;
}","@Override public LowLevelHttpResponse execute(){
  lowLevelExecCalls++;
  MockLowLevelHttpResponse response=new MockLowLevelHttpResponse();
  if (directDownloadEnabled) {
    response.setStatusCode(200);
    response.addHeader(""String_Node_Str"",String.valueOf(contentLength));
    response.setContent(new ByteArrayInputStream(new byte[contentLength - bytesDownloaded]));
    return response;
  }
  assertEquals(""String_Node_Str"" + bytesDownloaded + ""String_Node_Str""+ (bytesDownloaded + TEST_CHUNK_SIZE - 1),getHeaders().get(""String_Node_Str"").get(0));
  if (testServerError && lowLevelExecCalls == 2) {
    response.setStatusCode(500);
    return response;
  }
 else   if (testClientError) {
    response.setStatusCode(404);
    return response;
  }
  response.setStatusCode(206);
  int upper=Math.min(bytesDownloaded + TEST_CHUNK_SIZE,contentLength) - 1;
  response.addHeader(""String_Node_Str"",""String_Node_Str"" + bytesDownloaded + ""String_Node_Str""+ upper+ ""String_Node_Str""+ contentLength);
  int bytesDownloadedCur=upper - bytesDownloaded + 1;
  response.setContent(new ByteArrayInputStream(new byte[bytesDownloadedCur]));
  bytesDownloaded+=bytesDownloadedCur;
  return response;
}"
54854,"public void testDownloadMultipleCallsMaxChunkSize() throws Exception {
  int contentLength=MediaHttpDownloader.MAXIMUM_CHUNK_SIZE * 3;
  ByteArrayOutputStream outputStream=new ByteArrayOutputStream();
  MediaTransport fakeTransport=new MediaTransport(contentLength);
  MediaHttpDownloader downloader=new MediaHttpDownloader(fakeTransport,null);
  downloader.download(new GenericUrl(TEST_REQUEST_URL),outputStream);
  assertEquals(TEST_CHUNK_SIZE,outputStream.size());
  assertEquals(3,fakeTransport.lowLevelExecCalls);
}","public void testDownloadMultipleCallsMaxChunkSize() throws Exception {
  int contentLength=MediaHttpDownloader.MAXIMUM_CHUNK_SIZE * 3;
  ByteArrayOutputStream outputStream=new ByteArrayOutputStream();
  MediaTransport fakeTransport=new MediaTransport(contentLength);
  MediaHttpDownloader downloader=new MediaHttpDownloader(fakeTransport,null);
  downloader.download(new GenericUrl(TEST_REQUEST_URL),outputStream);
  assertEquals(contentLength,outputStream.size());
  assertEquals(3,fakeTransport.lowLevelExecCalls);
}"
54855,"public void testSetBytesDownloaded() throws Exception {
  int contentLength=MediaHttpDownloader.MAXIMUM_CHUNK_SIZE;
  MediaTransport fakeTransport=new MediaTransport(contentLength);
  fakeTransport.bytesDownloaded=contentLength - 10000;
  MediaHttpDownloader downloader=new MediaHttpDownloader(fakeTransport,null);
  downloader.setBytesDownloaded(contentLength - 10000);
  ByteArrayOutputStream outputStream=new ByteArrayOutputStream();
  downloader.download(new GenericUrl(TEST_REQUEST_URL),outputStream);
  assertEquals(1,fakeTransport.lowLevelExecCalls);
}","public void testSetBytesDownloaded() throws Exception {
  int contentLength=MediaHttpDownloader.MAXIMUM_CHUNK_SIZE;
  MediaTransport fakeTransport=new MediaTransport(contentLength);
  fakeTransport.bytesDownloaded=contentLength - 10000;
  MediaHttpDownloader downloader=new MediaHttpDownloader(fakeTransport,null);
  downloader.setBytesDownloaded(contentLength - 10000);
  ByteArrayOutputStream outputStream=new ByteArrayOutputStream();
  downloader.download(new GenericUrl(TEST_REQUEST_URL),outputStream);
  assertEquals(10000,outputStream.size());
  assertEquals(1,fakeTransport.lowLevelExecCalls);
}"
54856,"@Override protected void doPost(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  String subscriptionId=req.getHeader(SubscriptionHeaders.SUBSCRIPTION_ID);
  if (subscriptionId == null) {
    resp.sendError(HttpServletResponse.SC_BAD_REQUEST,""String_Node_Str"");
    return;
  }
  String topicId=req.getHeader(SubscriptionHeaders.TOPIC_ID);
  String topicUri=req.getHeader(SubscriptionHeaders.TOPIC_URI);
  String eventType=req.getHeader(SubscriptionHeaders.EVENT_TYPE);
  String clientToken=req.getHeader(SubscriptionHeaders.CLIENT_TOKEN);
  if (topicId == null || topicUri == null || eventType == null) {
    resp.sendError(HttpServletResponse.SC_BAD_REQUEST,""String_Node_Str"");
    return;
  }
  InputStream contentStream=req.getInputStream();
  try {
    UnparsedNotification notification=new UnparsedNotification(subscriptionId,topicId,topicUri,clientToken,eventType,req.getContentType(),contentStream);
    if (!getSubscriptionManager().deliverNotification(notification)) {
      sendUnsubscribeResponse(resp,notification);
    }
  }
 catch (  Exception ex) {
    throw new IOException(ex);
  }
 finally {
    contentStream.close();
  }
}","@Override protected void doPost(HttpServletRequest req,HttpServletResponse resp) throws ServletException, IOException {
  String subscriptionId=req.getHeader(SubscriptionHeaders.SUBSCRIPTION_ID);
  if (subscriptionId == null) {
    resp.sendError(HttpServletResponse.SC_BAD_REQUEST,""String_Node_Str"");
    return;
  }
  String topicId=req.getHeader(SubscriptionHeaders.TOPIC_ID);
  String topicUri=req.getHeader(SubscriptionHeaders.TOPIC_URI);
  String eventType=req.getHeader(SubscriptionHeaders.EVENT_TYPE);
  String clientToken=req.getHeader(SubscriptionHeaders.CLIENT_TOKEN);
  if (topicId == null || topicUri == null || eventType == null) {
    resp.sendError(HttpServletResponse.SC_BAD_REQUEST,""String_Node_Str"");
    return;
  }
  InputStream contentStream=req.getInputStream();
  try {
    UnparsedNotification notification=new UnparsedNotification(subscriptionId,topicId,topicUri,clientToken,eventType,req.getContentType(),contentStream);
    if (!getSubscriptionManager().deliverNotification(notification)) {
      sendUnsubscribeResponse(resp,notification);
    }
  }
 catch (  Exception ex) {
    IOException io=new IOException();
    io.initCause(ex);
    throw io;
  }
 finally {
    contentStream.close();
  }
}"
54857,"public void testLoad() throws IOException {
  GoogleClientSecrets clientSecrets=GoogleClientSecrets.load(new GsonFactory(),new ByteArrayInputStream(CLIENT_SECRETS.getBytes(Charsets.UTF_8)));
  Details installed=clientSecrets.getInstalled();
  assertNotNull(installed);
  assertEquals(CLIENT_ID,installed.getClientId());
  assertEquals(CLIENT_SECRET,installed.getClientSecret());
}","public void testLoad() throws IOException {
  GoogleClientSecrets clientSecrets=GoogleClientSecrets.load(new GsonFactory(),new ByteArrayInputStream(StringUtils.getBytesUtf8(CLIENT_SECRETS)));
  Details installed=clientSecrets.getInstalled();
  assertNotNull(installed);
  assertEquals(CLIENT_ID,installed.getClientId());
  assertEquals(CLIENT_SECRET,installed.getClientSecret());
}"
54858,"/** 
 * Downloads the public keys from the public certificates endpoint at  {@code ""https://www.googleapis.com/oauth2/v1/certs""}. <p> This method is automatically called if the public keys have not yet been initialized or if the expiration time is very close, so normally this doesn't need to be called. Only call this method explicitly to force the public keys to be updated. </p>
 */
public GoogleIdTokenVerifier loadPublicCerts() throws GeneralSecurityException, IOException {
  lock.lock();
  try {
    publicKeys=new ArrayList<PublicKey>();
    CertificateFactory factory=CertificateFactory.getInstance(""String_Node_Str"");
    HttpResponse certsResponse=transport.createRequestFactory().buildGetRequest(new GenericUrl(""String_Node_Str"")).execute();
    for (    String arg : certsResponse.getHeaders().getCacheControl().split(""String_Node_Str"")) {
      Matcher m=MAX_AGE_PATTERN.matcher(arg);
      if (m.matches()) {
        expirationTimeMilliseconds=clock.currentTimeMillis() + Long.valueOf(m.group(1)) * 1000;
        break;
      }
    }
    JsonParser parser=jsonFactory.createJsonParser(certsResponse.getContent());
    try {
      while (parser.nextToken() != JsonToken.END_OBJECT) {
        parser.nextToken();
        String certValue=parser.getText();
        X509Certificate x509Cert=(X509Certificate)factory.generateCertificate(new ByteArrayInputStream(StringUtils.getBytesUtf8(certValue)));
        publicKeys.add(x509Cert.getPublicKey());
      }
      publicKeys=Collections.unmodifiableList(publicKeys);
    }
  finally {
      parser.close();
    }
    return this;
  }
  finally {
    lock.unlock();
  }
}","/** 
 * Downloads the public keys from the public certificates endpoint at  {@code ""https://www.googleapis.com/oauth2/v1/certs""}. <p> This method is automatically called if the public keys have not yet been initialized or if the expiration time is very close, so normally this doesn't need to be called. Only call this method explicitly to force the public keys to be updated. </p>
 */
public GoogleIdTokenVerifier loadPublicCerts() throws GeneralSecurityException, IOException {
  lock.lock();
  try {
    publicKeys=new ArrayList<PublicKey>();
    CertificateFactory factory=CertificateFactory.getInstance(""String_Node_Str"");
    HttpResponse certsResponse=transport.createRequestFactory().buildGetRequest(new GenericUrl(""String_Node_Str"")).execute();
    for (    String arg : certsResponse.getHeaders().getCacheControl().split(""String_Node_Str"")) {
      Matcher m=MAX_AGE_PATTERN.matcher(arg);
      if (m.matches()) {
        expirationTimeMilliseconds=clock.currentTimeMillis() + Long.valueOf(m.group(1)) * 1000;
        break;
      }
    }
    JsonParser parser=jsonFactory.createJsonParser(certsResponse.getContent());
    JsonToken currentToken=parser.getCurrentToken();
    if (currentToken == null) {
      currentToken=parser.nextToken();
    }
    Preconditions.checkArgument(currentToken == JsonToken.START_OBJECT);
    try {
      while (parser.nextToken() != JsonToken.END_OBJECT) {
        parser.nextToken();
        String certValue=parser.getText();
        X509Certificate x509Cert=(X509Certificate)factory.generateCertificate(new ByteArrayInputStream(StringUtils.getBytesUtf8(certValue)));
        publicKeys.add(x509Cert.getPublicKey());
      }
      publicKeys=Collections.unmodifiableList(publicKeys);
    }
  finally {
      parser.close();
    }
    return this;
  }
  finally {
    lock.unlock();
  }
}"
54859,"/** 
 * Create an instance of   {@link AppAssertionFlow} that is specialized for communicating with Google APIs.
 * @param robotName Identifier that will eventually become the primary key for the credentialobject created by this flow. This is usually the application's identifier.
 * @param scope OAuth scope for which we are requesting access.
 * @param transport Instance that we will use for network communication.
 * @param jsonFactory Instance that we will use to deserialize responses from the auth server.
 */
public GoogleAppAssertionFlow(String robotName,String scope,HttpTransport transport,JsonFactory jsonFactory){
  super(robotName,GoogleAccessTokenRequest.AUTHORIZATION_SERVER_URL,scope,GoogleAccessTokenRequest.AUTHORIZATION_SERVER_URL,transport,jsonFactory);
}","/** 
 * Create an instance of   {@link AppAssertionFlow} that is specialized for communicating withGoogle APIs.
 * @param robotName Identifier that will eventually become the primary key for the credentialobject created by this flow. This is usually the application's identifier.
 * @param scope OAuth scope for which we are requesting access.
 * @param transport Instance that we will use for network communication.
 * @param jsonFactory Instance that we will use to deserialize responses from the auth server.
 */
public GoogleAppAssertionFlow(String robotName,String scope,HttpTransport transport,JsonFactory jsonFactory){
  super(robotName,GoogleAccessTokenRequest.AUTHORIZATION_SERVER_URL,scope,GoogleAccessTokenRequest.AUTHORIZATION_SERVER_URL,transport,jsonFactory);
}"
54860,"HttpResponse(HttpRequest request,LowLevelHttpResponse response){
  this.request=request;
  transport=request.transport;
  headers=request.headers;
  this.response=response;
  contentLength=response.getContentLength();
  contentType=response.getContentType();
  contentEncoding=response.getContentEncoding();
  int code=response.getStatusCode();
  statusCode=code;
  isSuccessStatusCode=isSuccessStatusCode(code);
  String message=response.getReasonPhrase();
  statusMessage=message;
  Logger logger=HttpTransport.LOGGER;
  boolean loggable=logger.isLoggable(Level.CONFIG);
  StringBuilder logbuf=null;
  if (loggable) {
    logbuf=new StringBuilder();
    logbuf.append(""String_Node_Str"").append(Strings.LINE_SEPARATOR);
    String statusLine=response.getStatusLine();
    if (statusLine != null) {
      logbuf.append(statusLine);
    }
 else {
      logbuf.append(code);
      if (message != null) {
        logbuf.append(' ').append(message);
      }
    }
    logbuf.append(Strings.LINE_SEPARATOR);
  }
  int size=response.getHeaderCount();
  Class<? extends HttpHeaders> headersClass=headers.getClass();
  List<Type> context=Arrays.<Type>asList(headersClass);
  ClassInfo classInfo=ClassInfo.of(headersClass);
  HashMap<String,String> fieldNameMap=HttpHeaders.getFieldNameMap(headersClass);
  ArrayValueMap arrayValueMap=new ArrayValueMap(headers);
  for (int i=0; i < size; i++) {
    String headerName=response.getHeaderName(i);
    String headerValue=response.getHeaderValue(i);
    if (loggable) {
      logbuf.append(headerName + ""String_Node_Str"" + headerValue).append(Strings.LINE_SEPARATOR);
    }
    String fieldName=fieldNameMap.get(headerName);
    if (fieldName == null) {
      fieldName=headerName;
    }
    FieldInfo fieldInfo=classInfo.getFieldInfo(fieldName);
    if (fieldInfo != null) {
      Type type=Data.resolveWildcardTypeOrTypeVariable(context,fieldInfo.getGenericType());
      if (Types.isArray(type)) {
        Class<?> rawArrayComponentType=Types.getRawArrayComponentType(context,Types.getArrayComponentType(type));
        arrayValueMap.put(fieldInfo.getField(),rawArrayComponentType,parseValue(rawArrayComponentType,context,headerValue));
      }
 else       if (Types.isAssignableToOrFrom(Types.getRawArrayComponentType(context,type),Iterable.class)) {
        @SuppressWarnings(""String_Node_Str"") Collection<Object> collection=(Collection<Object>)fieldInfo.getValue(headers);
        if (collection == null) {
          collection=Data.newCollectionInstance(type);
          fieldInfo.setValue(headers,collection);
        }
        Type subFieldType=type == Object.class ? null : Types.getIterableParameter(type);
        collection.add(parseValue(subFieldType,context,headerValue));
      }
 else {
        fieldInfo.setValue(headers,parseValue(type,context,headerValue));
      }
    }
 else {
      @SuppressWarnings(""String_Node_Str"") ArrayList<String> listValue=(ArrayList<String>)headers.get(fieldName);
      if (listValue == null) {
        listValue=new ArrayList<String>();
        headers.set(fieldName,listValue);
      }
      listValue.add(headerValue);
    }
  }
  arrayValueMap.setValues();
  if (loggable) {
    logger.config(logbuf.toString());
  }
}","HttpResponse(HttpRequest request,LowLevelHttpResponse response){
  this.request=request;
  transport=request.transport;
  headers=request.responseHeaders;
  this.response=response;
  contentLength=response.getContentLength();
  contentType=response.getContentType();
  contentEncoding=response.getContentEncoding();
  int code=response.getStatusCode();
  statusCode=code;
  isSuccessStatusCode=isSuccessStatusCode(code);
  String message=response.getReasonPhrase();
  statusMessage=message;
  Logger logger=HttpTransport.LOGGER;
  boolean loggable=logger.isLoggable(Level.CONFIG);
  StringBuilder logbuf=null;
  if (loggable) {
    logbuf=new StringBuilder();
    logbuf.append(""String_Node_Str"").append(Strings.LINE_SEPARATOR);
    String statusLine=response.getStatusLine();
    if (statusLine != null) {
      logbuf.append(statusLine);
    }
 else {
      logbuf.append(code);
      if (message != null) {
        logbuf.append(' ').append(message);
      }
    }
    logbuf.append(Strings.LINE_SEPARATOR);
  }
  int size=response.getHeaderCount();
  Class<? extends HttpHeaders> headersClass=headers.getClass();
  List<Type> context=Arrays.<Type>asList(headersClass);
  ClassInfo classInfo=ClassInfo.of(headersClass);
  HashMap<String,String> fieldNameMap=HttpHeaders.getFieldNameMap(headersClass);
  ArrayValueMap arrayValueMap=new ArrayValueMap(headers);
  for (int i=0; i < size; i++) {
    String headerName=response.getHeaderName(i);
    String headerValue=response.getHeaderValue(i);
    if (loggable) {
      logbuf.append(headerName + ""String_Node_Str"" + headerValue).append(Strings.LINE_SEPARATOR);
    }
    String fieldName=fieldNameMap.get(headerName);
    if (fieldName == null) {
      fieldName=headerName;
    }
    FieldInfo fieldInfo=classInfo.getFieldInfo(fieldName);
    if (fieldInfo != null) {
      Type type=Data.resolveWildcardTypeOrTypeVariable(context,fieldInfo.getGenericType());
      if (Types.isArray(type)) {
        Class<?> rawArrayComponentType=Types.getRawArrayComponentType(context,Types.getArrayComponentType(type));
        arrayValueMap.put(fieldInfo.getField(),rawArrayComponentType,parseValue(rawArrayComponentType,context,headerValue));
      }
 else       if (Types.isAssignableToOrFrom(Types.getRawArrayComponentType(context,type),Iterable.class)) {
        @SuppressWarnings(""String_Node_Str"") Collection<Object> collection=(Collection<Object>)fieldInfo.getValue(headers);
        if (collection == null) {
          collection=Data.newCollectionInstance(type);
          fieldInfo.setValue(headers,collection);
        }
        Type subFieldType=type == Object.class ? null : Types.getIterableParameter(type);
        collection.add(parseValue(subFieldType,context,headerValue));
      }
 else {
        fieldInfo.setValue(headers,parseValue(type,context,headerValue));
      }
    }
 else {
      @SuppressWarnings(""String_Node_Str"") ArrayList<String> listValue=(ArrayList<String>)headers.get(fieldName);
      if (listValue == null) {
        listValue=new ArrayList<String>();
        headers.set(fieldName,listValue);
      }
      listValue.add(headerValue);
    }
  }
  arrayValueMap.setValues();
  if (loggable) {
    logger.config(logbuf.toString());
  }
}"
54861,"/** 
 * Returns a deep clone of the given key/value data, such that the result is a completely independent copy. <p> This should not be used directly in the implementation of   {@code Object.clone()}. Instead use  {@link #deepCopy(Object,Object)} for that purpose.</p> <p> Final fields cannot be changed and therefore their value won't be copied. </p>
 * @param data key/value data object or map to clone or {@code null} for a {@code null} returnvalue
 * @return deep clone or {@code null} for {@code null} input
 */
@SuppressWarnings(""String_Node_Str"") public static <T>T clone(T data){
  if (data == null || Data.isPrimitive(data.getClass())) {
    return data;
  }
  if (data instanceof GenericData) {
    return (T)((GenericData)data).clone();
  }
  T copy;
  Class<?> dataClass=data.getClass();
  if (dataClass.isArray()) {
    copy=(T)Array.newInstance(dataClass.getComponentType(),Array.getLength(data));
  }
 else   if (data instanceof ArrayMap<?,?>) {
    copy=(T)ArrayMap.create();
  }
 else {
    copy=(T)Types.newInstance(dataClass);
  }
  deepCopy(data,copy);
  return copy;
}","/** 
 * Returns a deep clone of the given key/value data, such that the result is a completely independent copy. <p> This should not be used directly in the implementation of   {@code Object.clone()}. Instead use  {@link #deepCopy(Object,Object)} for that purpose.</p> <p> Final fields cannot be changed and therefore their value won't be copied. </p>
 * @param data key/value data object or map to clone or {@code null} for a {@code null} returnvalue
 * @return deep clone or {@code null} for {@code null} input
 */
@SuppressWarnings(""String_Node_Str"") public static <T>T clone(T data){
  if (data == null || Data.isPrimitive(data.getClass())) {
    return data;
  }
  if (data instanceof GenericData) {
    return (T)((GenericData)data).clone();
  }
  T copy;
  Class<?> dataClass=data.getClass();
  if (dataClass.isArray()) {
    copy=(T)Array.newInstance(dataClass.getComponentType(),Array.getLength(data));
  }
 else   if (data instanceof ArrayMap<?,?>) {
    copy=(T)((ArrayMap<?,?>)data).clone();
  }
 else {
    copy=(T)Types.newInstance(dataClass);
  }
  deepCopy(data,copy);
  return copy;
}"
54862,"HttpResponse(HttpRequest request,LowLevelHttpResponse response){
  this.request=request;
  transport=request.transport;
  headers=request.headers;
  this.response=response;
  contentLength=response.getContentLength();
  contentType=response.getContentType();
  contentEncoding=response.getContentEncoding();
  int code=response.getStatusCode();
  statusCode=code;
  isSuccessStatusCode=isSuccessStatusCode(code);
  String message=response.getReasonPhrase();
  statusMessage=message;
  Logger logger=HttpTransport.LOGGER;
  boolean loggable=logger.isLoggable(Level.CONFIG);
  StringBuilder logbuf=null;
  if (loggable) {
    logbuf=new StringBuilder();
    logbuf.append(""String_Node_Str"").append(Strings.LINE_SEPARATOR);
    String statusLine=response.getStatusLine();
    if (statusLine != null) {
      logbuf.append(statusLine);
    }
 else {
      logbuf.append(code);
      if (message != null) {
        logbuf.append(' ').append(message);
      }
    }
    logbuf.append(Strings.LINE_SEPARATOR);
  }
  int size=response.getHeaderCount();
  Class<? extends HttpHeaders> headersClass=headers.getClass();
  List<Type> context=Arrays.<Type>asList(headersClass);
  ClassInfo classInfo=ClassInfo.of(headersClass);
  HashMap<String,String> fieldNameMap=HttpHeaders.getFieldNameMap(headersClass);
  ArrayValueMap arrayValueMap=new ArrayValueMap(headers);
  for (int i=0; i < size; i++) {
    String headerName=response.getHeaderName(i);
    String headerValue=response.getHeaderValue(i);
    if (loggable) {
      logbuf.append(headerName + ""String_Node_Str"" + headerValue).append(Strings.LINE_SEPARATOR);
    }
    String fieldName=fieldNameMap.get(headerName);
    if (fieldName == null) {
      fieldName=headerName;
    }
    FieldInfo fieldInfo=classInfo.getFieldInfo(fieldName);
    if (fieldInfo != null) {
      Type type=Data.resolveWildcardTypeOrTypeVariable(context,fieldInfo.getGenericType());
      if (Types.isArray(type)) {
        Class<?> rawArrayComponentType=Types.getRawArrayComponentType(context,Types.getArrayComponentType(type));
        arrayValueMap.put(fieldInfo.getField(),rawArrayComponentType,parseValue(rawArrayComponentType,context,headerValue));
      }
 else       if (Types.isAssignableToOrFrom(Types.getRawArrayComponentType(context,type),Iterable.class)) {
        @SuppressWarnings(""String_Node_Str"") Collection<Object> collection=(Collection<Object>)fieldInfo.getValue(headers);
        if (collection == null) {
          collection=Data.newCollectionInstance(type);
          fieldInfo.setValue(headers,collection);
        }
        Type subFieldType=type == Object.class ? null : Types.getIterableParameter(type);
        collection.add(parseValue(subFieldType,context,headerValue));
      }
 else {
        fieldInfo.setValue(headers,parseValue(type,context,headerValue));
      }
    }
 else {
      @SuppressWarnings(""String_Node_Str"") ArrayList<String> listValue=(ArrayList<String>)headers.get(fieldName);
      if (listValue == null) {
        listValue=new ArrayList<String>();
        headers.set(fieldName,listValue);
      }
      listValue.add(headerValue);
    }
  }
  arrayValueMap.setValues();
  if (loggable) {
    logger.config(logbuf.toString());
  }
}","HttpResponse(HttpRequest request,LowLevelHttpResponse response){
  this.request=request;
  transport=request.transport;
  headers=request.responseHeaders;
  this.response=response;
  contentLength=response.getContentLength();
  contentType=response.getContentType();
  contentEncoding=response.getContentEncoding();
  int code=response.getStatusCode();
  statusCode=code;
  isSuccessStatusCode=isSuccessStatusCode(code);
  String message=response.getReasonPhrase();
  statusMessage=message;
  Logger logger=HttpTransport.LOGGER;
  boolean loggable=logger.isLoggable(Level.CONFIG);
  StringBuilder logbuf=null;
  if (loggable) {
    logbuf=new StringBuilder();
    logbuf.append(""String_Node_Str"").append(Strings.LINE_SEPARATOR);
    String statusLine=response.getStatusLine();
    if (statusLine != null) {
      logbuf.append(statusLine);
    }
 else {
      logbuf.append(code);
      if (message != null) {
        logbuf.append(' ').append(message);
      }
    }
    logbuf.append(Strings.LINE_SEPARATOR);
  }
  int size=response.getHeaderCount();
  Class<? extends HttpHeaders> headersClass=headers.getClass();
  List<Type> context=Arrays.<Type>asList(headersClass);
  ClassInfo classInfo=ClassInfo.of(headersClass);
  HashMap<String,String> fieldNameMap=HttpHeaders.getFieldNameMap(headersClass);
  ArrayValueMap arrayValueMap=new ArrayValueMap(headers);
  for (int i=0; i < size; i++) {
    String headerName=response.getHeaderName(i);
    String headerValue=response.getHeaderValue(i);
    if (loggable) {
      logbuf.append(headerName + ""String_Node_Str"" + headerValue).append(Strings.LINE_SEPARATOR);
    }
    String fieldName=fieldNameMap.get(headerName);
    if (fieldName == null) {
      fieldName=headerName;
    }
    FieldInfo fieldInfo=classInfo.getFieldInfo(fieldName);
    if (fieldInfo != null) {
      Type type=Data.resolveWildcardTypeOrTypeVariable(context,fieldInfo.getGenericType());
      if (Types.isArray(type)) {
        Class<?> rawArrayComponentType=Types.getRawArrayComponentType(context,Types.getArrayComponentType(type));
        arrayValueMap.put(fieldInfo.getField(),rawArrayComponentType,parseValue(rawArrayComponentType,context,headerValue));
      }
 else       if (Types.isAssignableToOrFrom(Types.getRawArrayComponentType(context,type),Iterable.class)) {
        @SuppressWarnings(""String_Node_Str"") Collection<Object> collection=(Collection<Object>)fieldInfo.getValue(headers);
        if (collection == null) {
          collection=Data.newCollectionInstance(type);
          fieldInfo.setValue(headers,collection);
        }
        Type subFieldType=type == Object.class ? null : Types.getIterableParameter(type);
        collection.add(parseValue(subFieldType,context,headerValue));
      }
 else {
        fieldInfo.setValue(headers,parseValue(type,context,headerValue));
      }
    }
 else {
      @SuppressWarnings(""String_Node_Str"") ArrayList<String> listValue=(ArrayList<String>)headers.get(fieldName);
      if (listValue == null) {
        listValue=new ArrayList<String>();
        headers.set(fieldName,listValue);
      }
      listValue.add(headerValue);
    }
  }
  arrayValueMap.setValues();
  if (loggable) {
    logger.config(logbuf.toString());
  }
}"
54863,"public void intercept(HttpRequest request){
  if (overrideThisMethod(request)) {
    HttpMethod method=request.method;
    request.method=HttpMethod.POST;
    request.headers.set(""String_Node_Str"",method.name());
    if (request.content == null) {
      InputStreamContent content=new InputStreamContent();
      content.setByteArrayInput(new byte[0]);
      request.content=content;
    }
  }
  if (!HttpTransport.useLowLevelHttpTransport().supportsHead()) {
    overriddenMethods.add(""String_Node_Str"");
  }
}","public void intercept(HttpRequest request){
  if (overrideThisMethod(request)) {
    HttpMethod method=request.method;
    request.method=HttpMethod.POST;
    request.headers.set(""String_Node_Str"",method.name());
    if (request.content == null) {
      InputStreamContent content=new InputStreamContent();
      content.setByteArrayInput(new byte[0]);
      request.content=content;
    }
  }
}"
54864,"public void intercept(HttpRequest request) throws IOException {
  HttpHeaders headers=request.headers;
  StringBuilder messageBuf=new StringBuilder();
  messageBuf.append(request.method).append('\n');
  String contentMD5=headers.contentMD5;
  if (contentMD5 != null) {
    messageBuf.append(contentMD5);
  }
  messageBuf.append('\n');
  HttpContent content=request.content;
  if (content != null) {
    String contentType=content.getType();
    messageBuf.append(contentType);
  }
  messageBuf.append('\n');
  Object date=headers.date;
  if (date != null) {
    messageBuf.append(headers.date);
  }
  messageBuf.append('\n');
  TreeMap<String,String> extensions=new TreeMap<String,String>();
  for (  Map.Entry<String,Object> headerEntry : headers.entrySet()) {
    String name=headerEntry.getKey().toLowerCase();
    Object value=headerEntry.getValue();
    if (value != null && name.startsWith(""String_Node_Str"")) {
      if (value instanceof Collection<?>) {
        @SuppressWarnings(""String_Node_Str"") Collection<Object> collectionValue=(Collection<Object>)value;
        StringBuilder buf=new StringBuilder();
        boolean first=true;
        for (        Object repeatedValue : collectionValue) {
          if (first) {
            first=false;
          }
 else {
            buf.append(',');
          }
          buf.append(WHITESPACE_PATTERN.matcher(repeatedValue.toString()).replaceAll(""String_Node_Str""));
        }
        extensions.put(name,buf.toString());
      }
 else {
        extensions.put(name,WHITESPACE_PATTERN.matcher(value.toString()).replaceAll(""String_Node_Str""));
      }
    }
  }
  for (  Map.Entry<String,String> extensionEntry : extensions.entrySet()) {
    messageBuf.append(extensionEntry.getKey()).append(':').append(extensionEntry.getValue()).append('\n');
  }
  GenericUrl url=request.url;
  String host=url.host;
  if (!host.endsWith(HOST)) {
    throw new IllegalArgumentException(""String_Node_Str"" + HOST);
  }
  int bucketNameLength=host.length() - HOST.length() - 1;
  if (bucketNameLength > 0) {
    String bucket=host.substring(0,bucketNameLength);
    if (!bucket.equals(""String_Node_Str"")) {
      messageBuf.append('/').append(bucket);
    }
  }
  if (url.get(""String_Node_Str"") != null) {
    messageBuf.append(""String_Node_Str"");
  }
 else   if (url.get(""String_Node_Str"") != null) {
    messageBuf.append(""String_Node_Str"");
  }
 else   if (url.get(""String_Node_Str"") != null) {
    messageBuf.append(""String_Node_Str"");
  }
 else   if (url.get(""String_Node_Str"") != null) {
    messageBuf.append(""String_Node_Str"");
  }
 else   if (url.get(""String_Node_Str"") != null) {
    messageBuf.append(""String_Node_Str"");
  }
  messageBuf.append(url.getRawPath());
  try {
    request.headers.authorization=""String_Node_Str"" + accessKey + ""String_Node_Str""+ HmacSha.sign(secret,messageBuf.toString());
  }
 catch (  GeneralSecurityException e) {
    IOException io=new IOException();
    io.initCause(e);
    throw io;
  }
}","public void intercept(HttpRequest request) throws IOException {
  HttpHeaders headers=request.headers;
  StringBuilder messageBuf=new StringBuilder();
  messageBuf.append(request.method).append('\n');
  String contentMD5=headers.contentMD5;
  if (contentMD5 != null) {
    messageBuf.append(contentMD5);
  }
  messageBuf.append('\n');
  HttpContent content=request.content;
  if (content != null) {
    String contentType=content.getType();
    messageBuf.append(contentType);
  }
  messageBuf.append('\n');
  Object date=headers.date;
  if (date != null) {
    messageBuf.append(headers.date);
  }
  messageBuf.append('\n');
  TreeMap<String,String> extensions=new TreeMap<String,String>();
  for (  Map.Entry<String,Object> headerEntry : headers.entrySet()) {
    String name=headerEntry.getKey().toLowerCase();
    Object value=headerEntry.getValue();
    if (value != null && name.startsWith(""String_Node_Str"")) {
      if (value instanceof Collection<?>) {
        @SuppressWarnings(""String_Node_Str"") Collection<Object> collectionValue=(Collection<Object>)value;
        StringBuilder buf=new StringBuilder();
        boolean first=true;
        for (        Object repeatedValue : collectionValue) {
          if (first) {
            first=false;
          }
 else {
            buf.append(',');
          }
          buf.append(WHITESPACE_PATTERN.matcher(repeatedValue.toString()).replaceAll(""String_Node_Str""));
        }
        extensions.put(name,buf.toString());
      }
 else {
        extensions.put(name,WHITESPACE_PATTERN.matcher(value.toString()).replaceAll(""String_Node_Str""));
      }
    }
  }
  for (  Map.Entry<String,String> extensionEntry : extensions.entrySet()) {
    messageBuf.append(extensionEntry.getKey()).append(':').append(extensionEntry.getValue()).append('\n');
  }
  GenericUrl url=request.url;
  String host=url.host;
  if (!host.endsWith(HOST)) {
    throw new IllegalArgumentException(""String_Node_Str"" + HOST);
  }
  int bucketNameLength=host.length() - HOST.length() - 1;
  if (bucketNameLength > 0) {
    String bucket=host.substring(0,bucketNameLength);
    if (!bucket.equals(""String_Node_Str"")) {
      messageBuf.append('/').append(bucket);
    }
  }
  if (url.pathParts != null) {
    messageBuf.append(url.getRawPath());
  }
  if (url.get(""String_Node_Str"") != null) {
    messageBuf.append(""String_Node_Str"");
  }
 else   if (url.get(""String_Node_Str"") != null) {
    messageBuf.append(""String_Node_Str"");
  }
 else   if (url.get(""String_Node_Str"") != null) {
    messageBuf.append(""String_Node_Str"");
  }
 else   if (url.get(""String_Node_Str"") != null) {
    messageBuf.append(""String_Node_Str"");
  }
 else   if (url.get(""String_Node_Str"") != null) {
    messageBuf.append(""String_Node_Str"");
  }
  try {
    request.headers.authorization=""String_Node_Str"" + accessKey + ""String_Node_Str""+ HmacSha.sign(secret,messageBuf.toString());
  }
 catch (  GeneralSecurityException e) {
    IOException io=new IOException();
    io.initCause(e);
    throw io;
  }
}"
54865,"public void test() throws IOException {
  HttpTransport transport=GoogleTransport.create();
  GoogleStorageAuthentication.authorize(transport,""String_Node_Str"",""String_Node_Str"");
  HttpExecuteIntercepter intercepter=transport.intercepters.get(1);
  HttpRequest request=transport.buildPutRequest();
  request.setUrl(""String_Node_Str"");
  GoogleHeaders headers=(GoogleHeaders)request.headers;
  headers.date=""String_Node_Str"";
  MockHttpContent content=new MockHttpContent();
  content.length=4539;
  content.type=""String_Node_Str"";
  request.content=content;
  headers.googAcl=""String_Node_Str"";
  headers.set(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str""));
  intercepter.intercept(request);
  assertEquals(""String_Node_Str"",request.headers.authorization);
}","public void test() throws Exception {
  subtest(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  subtest(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  subtest(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  subtest(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  subtest(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}"
54866,"public void intercept(HttpRequest request) throws IOException {
  HttpHeaders headers=request.headers;
  StringBuilder messageBuf=new StringBuilder();
  messageBuf.append(request.method).append('\n');
  String contentMD5=headers.contentMD5;
  if (contentMD5 != null) {
    messageBuf.append(contentMD5);
  }
  messageBuf.append('\n');
  HttpContent content=request.content;
  if (content != null) {
    String contentType=content.getType();
    messageBuf.append(contentType);
  }
  messageBuf.append('\n');
  Object date=headers.date;
  if (date != null) {
    messageBuf.append(headers.date);
  }
  messageBuf.append('\n');
  TreeMap<String,String> extensions=new TreeMap<String,String>();
  for (  Map.Entry<String,Object> headerEntry : headers.entrySet()) {
    String name=headerEntry.getKey().toLowerCase();
    Object value=headerEntry.getValue();
    if (value != null && name.startsWith(""String_Node_Str"")) {
      if (value instanceof Collection<?>) {
        @SuppressWarnings(""String_Node_Str"") Collection<Object> collectionValue=(Collection<Object>)value;
        StringBuilder buf=new StringBuilder();
        boolean first=true;
        for (        Object repeatedValue : collectionValue) {
          if (first) {
            first=false;
          }
 else {
            buf.append(',');
          }
          buf.append(WHITESPACE_PATTERN.matcher(repeatedValue.toString()).replaceAll(""String_Node_Str""));
        }
        extensions.put(name,buf.toString());
      }
 else {
        extensions.put(name,WHITESPACE_PATTERN.matcher(value.toString()).replaceAll(""String_Node_Str""));
      }
    }
  }
  for (  Map.Entry<String,String> extensionEntry : extensions.entrySet()) {
    messageBuf.append(extensionEntry.getKey()).append(':').append(extensionEntry.getValue()).append('\n');
  }
  GenericUrl url=request.url;
  String host=url.host;
  if (!host.endsWith(HOST)) {
    throw new IllegalArgumentException(""String_Node_Str"" + HOST);
  }
  int bucketNameLength=host.length() - HOST.length() - 1;
  if (bucketNameLength > 0) {
    String bucket=host.substring(0,bucketNameLength);
    if (!bucket.equals(""String_Node_Str"")) {
      messageBuf.append('/').append(bucket);
    }
  }
  if (url.get(""String_Node_Str"") != null) {
    messageBuf.append(""String_Node_Str"");
  }
 else   if (url.get(""String_Node_Str"") != null) {
    messageBuf.append(""String_Node_Str"");
  }
 else   if (url.get(""String_Node_Str"") != null) {
    messageBuf.append(""String_Node_Str"");
  }
 else   if (url.get(""String_Node_Str"") != null) {
    messageBuf.append(""String_Node_Str"");
  }
 else   if (url.get(""String_Node_Str"") != null) {
    messageBuf.append(""String_Node_Str"");
  }
  messageBuf.append(url.getRawPath());
  try {
    request.headers.authorization=""String_Node_Str"" + accessKey + ""String_Node_Str""+ HmacSha.sign(secret,messageBuf.toString());
  }
 catch (  GeneralSecurityException e) {
    IOException io=new IOException();
    io.initCause(e);
    throw io;
  }
}","public void intercept(HttpRequest request) throws IOException {
  HttpHeaders headers=request.headers;
  StringBuilder messageBuf=new StringBuilder();
  messageBuf.append(request.method).append('\n');
  String contentMD5=headers.contentMD5;
  if (contentMD5 != null) {
    messageBuf.append(contentMD5);
  }
  messageBuf.append('\n');
  HttpContent content=request.content;
  if (content != null) {
    String contentType=content.getType();
    messageBuf.append(contentType);
  }
  messageBuf.append('\n');
  Object date=headers.date;
  if (date != null) {
    messageBuf.append(headers.date);
  }
  messageBuf.append('\n');
  TreeMap<String,String> extensions=new TreeMap<String,String>();
  for (  Map.Entry<String,Object> headerEntry : headers.entrySet()) {
    String name=headerEntry.getKey().toLowerCase();
    Object value=headerEntry.getValue();
    if (value != null && name.startsWith(""String_Node_Str"")) {
      if (value instanceof Collection<?>) {
        @SuppressWarnings(""String_Node_Str"") Collection<Object> collectionValue=(Collection<Object>)value;
        StringBuilder buf=new StringBuilder();
        boolean first=true;
        for (        Object repeatedValue : collectionValue) {
          if (first) {
            first=false;
          }
 else {
            buf.append(',');
          }
          buf.append(WHITESPACE_PATTERN.matcher(repeatedValue.toString()).replaceAll(""String_Node_Str""));
        }
        extensions.put(name,buf.toString());
      }
 else {
        extensions.put(name,WHITESPACE_PATTERN.matcher(value.toString()).replaceAll(""String_Node_Str""));
      }
    }
  }
  for (  Map.Entry<String,String> extensionEntry : extensions.entrySet()) {
    messageBuf.append(extensionEntry.getKey()).append(':').append(extensionEntry.getValue()).append('\n');
  }
  GenericUrl url=request.url;
  String host=url.host;
  if (!host.endsWith(HOST)) {
    throw new IllegalArgumentException(""String_Node_Str"" + HOST);
  }
  int bucketNameLength=host.length() - HOST.length() - 1;
  if (bucketNameLength > 0) {
    String bucket=host.substring(0,bucketNameLength);
    if (!bucket.equals(""String_Node_Str"")) {
      messageBuf.append('/').append(bucket);
    }
  }
  if (url.pathParts != null) {
    messageBuf.append(url.getRawPath());
  }
  if (url.get(""String_Node_Str"") != null) {
    messageBuf.append(""String_Node_Str"");
  }
 else   if (url.get(""String_Node_Str"") != null) {
    messageBuf.append(""String_Node_Str"");
  }
 else   if (url.get(""String_Node_Str"") != null) {
    messageBuf.append(""String_Node_Str"");
  }
 else   if (url.get(""String_Node_Str"") != null) {
    messageBuf.append(""String_Node_Str"");
  }
 else   if (url.get(""String_Node_Str"") != null) {
    messageBuf.append(""String_Node_Str"");
  }
  try {
    request.headers.authorization=""String_Node_Str"" + accessKey + ""String_Node_Str""+ HmacSha.sign(secret,messageBuf.toString());
  }
 catch (  GeneralSecurityException e) {
    IOException io=new IOException();
    io.initCause(e);
    throw io;
  }
}"
54867,"public void test() throws IOException {
  HttpTransport transport=GoogleTransport.create();
  GoogleStorageAuthentication.authorize(transport,""String_Node_Str"",""String_Node_Str"");
  HttpExecuteIntercepter intercepter=transport.intercepters.get(1);
  HttpRequest request=transport.buildPutRequest();
  request.setUrl(""String_Node_Str"");
  GoogleHeaders headers=(GoogleHeaders)request.headers;
  headers.date=""String_Node_Str"";
  MockHttpContent content=new MockHttpContent();
  content.length=4539;
  content.type=""String_Node_Str"";
  request.content=content;
  headers.googAcl=""String_Node_Str"";
  headers.set(""String_Node_Str"",Arrays.asList(""String_Node_Str"",""String_Node_Str""));
  intercepter.intercept(request);
  assertEquals(""String_Node_Str"",request.headers.authorization);
}","public void test() throws Exception {
  subtest(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  subtest(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  subtest(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  subtest(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  subtest(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
}"
54868,"NetHttpRequest(NetHttpTransport transport,String requestMethod,String url) throws IOException {
  this.transport=transport;
  HttpURLConnection connection=this.connection=(HttpURLConnection)new URL(url).openConnection();
  connection.setRequestMethod(requestMethod);
  connection.setUseCaches(false);
}","NetHttpRequest(NetHttpTransport transport,String requestMethod,String url) throws IOException {
  this.transport=transport;
  HttpURLConnection connection=this.connection=(HttpURLConnection)new URL(url).openConnection();
  connection.setRequestMethod(requestMethod);
  connection.setUseCaches(false);
  connection.setInstanceFollowRedirects(false);
}"
54869,"private static void addPackageModels(int rootPathLength,File dir,SortedSet<PackageModel> pkgs) throws IOException {
  PackageModel pkg=null;
  for (  File file : dir.listFiles()) {
    if (""String_Node_Str"".equals(file.getName())) {
      continue;
    }
    if (file.isDirectory()) {
      addPackageModels(rootPathLength,file,pkgs);
    }
 else {
      if (file.getName().endsWith(""String_Node_Str"")) {
        if (pkg == null) {
          pkg=new PackageModel(file.getParentFile().getCanonicalPath().substring(1 + rootPathLength).replace('/','-'));
          pkgs.add(pkg);
        }
        String content=readFile(file);
        Matcher matcher=IMPORT_PATTERN.matcher(content);
        while (matcher.find()) {
          String className=matcher.group(1);
          String packageName=getPackageName(className);
          if (className.startsWith(""String_Node_Str"")) {
            DependencyModel dep=new DependencyModel();
            dep.groupId=""String_Node_Str"";
            dep.artifactId=packageName.substring(4).replace('.','-');
            dep.version=VERSION_SNAPSHOT;
            pkg.dependencies.add(dep);
          }
 else           if (className.startsWith(""String_Node_Str"") || className.startsWith(""String_Node_Str"")) {
            DependencyModel dep=new DependencyModel();
            dep.groupId=""String_Node_Str"";
            dep.artifactId=""String_Node_Str"";
            dep.scope=""String_Node_Str"";
            pkg.dependencies.add(dep);
          }
 else           if (className.startsWith(""String_Node_Str"")) {
            DependencyModel dep=new DependencyModel();
            dep.groupId=""String_Node_Str"";
            dep.artifactId=""String_Node_Str"";
            pkg.dependencies.add(dep);
          }
 else           if (className.startsWith(""String_Node_Str"") || className.startsWith(""String_Node_Str"")) {
          }
 else {
            throw new IllegalArgumentException(""String_Node_Str"" + packageName);
          }
        }
      }
    }
  }
}","private static void addPackageModels(int rootPathLength,File dir,SortedSet<PackageModel> pkgs) throws IOException {
  PackageModel pkg=null;
  for (  File file : dir.listFiles()) {
    if (file.isDirectory()) {
      addPackageModels(rootPathLength,file,pkgs);
    }
 else {
      if (file.getName().endsWith(""String_Node_Str"")) {
        if (pkg == null) {
          pkg=new PackageModel(file.getParentFile().getCanonicalPath().substring(1 + rootPathLength).replace('/','-'));
          pkgs.add(pkg);
        }
        String content=readFile(file);
        Matcher matcher=IMPORT_PATTERN.matcher(content);
        while (matcher.find()) {
          String className=matcher.group(1);
          String packageName=getPackageName(className);
          if (className.startsWith(""String_Node_Str"")) {
            DependencyModel dep=new DependencyModel();
            dep.groupId=""String_Node_Str"";
            dep.artifactId=packageName.substring(4).replace('.','-');
            dep.version=VERSION_SNAPSHOT;
            if (!pkg.artifactId.equals(dep.artifactId)) {
              pkg.dependencies.add(dep);
            }
          }
 else           if (className.startsWith(""String_Node_Str"") || className.startsWith(""String_Node_Str"")) {
            DependencyModel dep=new DependencyModel();
            dep.groupId=""String_Node_Str"";
            dep.artifactId=""String_Node_Str"";
            dep.scope=""String_Node_Str"";
            pkg.dependencies.add(dep);
          }
 else           if (className.startsWith(""String_Node_Str"")) {
            DependencyModel dep=new DependencyModel();
            dep.groupId=""String_Node_Str"";
            dep.artifactId=""String_Node_Str"";
            pkg.dependencies.add(dep);
          }
 else           if (className.startsWith(""String_Node_Str"") || className.startsWith(""String_Node_Str"")) {
          }
 else {
            throw new IllegalArgumentException(""String_Node_Str"" + packageName);
          }
        }
      }
    }
  }
}"
54870,"NetHttpTransport(){
}","NetHttpTransport(){
  HttpURLConnection.setFollowRedirects(false);
}"
54871,"public DateTime(boolean dateOnly,long value,Integer tzShift){
  this.dateOnly=false;
  this.value=value;
  this.tzShift=tzShift;
}","public DateTime(boolean dateOnly,long value,Integer tzShift){
  this.dateOnly=dateOnly;
  this.value=value;
  this.tzShift=tzShift;
}"
54872,"public void testParseDateTime(){
  expectExceptionForParseRfc3339(""String_Node_Str"");
  expectExceptionForParseRfc3339(""String_Node_Str"");
  DateTime.parseRfc3339(""String_Node_Str"");
  DateTime.parseRfc3339(""String_Node_Str"");
}","public void testParseDateTime(){
  expectExceptionForParseRfc3339(""String_Node_Str"");
  expectExceptionForParseRfc3339(""String_Node_Str"");
  DateTime value=DateTime.parseRfc3339(""String_Node_Str"");
  assertTrue(value.dateOnly);
  value=DateTime.parseRfc3339(""String_Node_Str"");
  assertFalse(value.dateOnly);
}"
54873,"ApacheHttpTransport(){
  HttpParams params=new BasicHttpParams();
  HttpConnectionParams.setStaleCheckingEnabled(params,false);
  HttpConnectionParams.setConnectionTimeout(params,20 * 1000);
  HttpConnectionParams.setSoTimeout(params,20 * 1000);
  HttpConnectionParams.setSocketBufferSize(params,8192);
  this.httpClient=new DefaultHttpClient(params);
}","ApacheHttpTransport(){
  HttpParams params=new BasicHttpParams();
  HttpConnectionParams.setStaleCheckingEnabled(params,false);
  HttpConnectionParams.setConnectionTimeout(params,20 * 1000);
  HttpConnectionParams.setSoTimeout(params,20 * 1000);
  HttpConnectionParams.setSocketBufferSize(params,8192);
  params.setBooleanParameter(ClientPNames.HANDLE_REDIRECTS,false);
  this.httpClient=new DefaultHttpClient(params);
}"
54874,"@Override public LowLevelHttpResponse execute() throws IOException {
  HttpURLConnection connection=this.connection;
  HttpContent content=this.content;
  if (content != null) {
    connection.setDoOutput(true);
    addHeader(""String_Node_Str"",content.getType());
    String contentEncoding=content.getEncoding();
    if (contentEncoding != null) {
      addHeader(""String_Node_Str"",contentEncoding);
    }
    long contentLength=content.getLength();
    if (contentLength >= 0) {
      addHeader(""String_Node_Str"",Long.toString(contentLength));
    }
    content.writeTo(connection.getOutputStream());
  }
  String httpStrictPostRedirect=System.getProperty(""String_Node_Str"");
  try {
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    connection.connect();
    return new NetHttpResponse(connection);
  }
  finally {
    if (httpStrictPostRedirect == null) {
      System.clearProperty(""String_Node_Str"");
    }
 else {
      System.setProperty(""String_Node_Str"",httpStrictPostRedirect);
    }
  }
}","@Override public LowLevelHttpResponse execute() throws IOException {
  HttpURLConnection connection=this.connection;
  HttpContent content=this.content;
  if (content != null) {
    connection.setDoOutput(true);
    addHeader(""String_Node_Str"",content.getType());
    String contentEncoding=content.getEncoding();
    if (contentEncoding != null) {
      addHeader(""String_Node_Str"",contentEncoding);
    }
    long contentLength=content.getLength();
    if (contentLength >= 0) {
      addHeader(""String_Node_Str"",Long.toString(contentLength));
    }
    content.writeTo(connection.getOutputStream());
  }
  connection.connect();
  return new NetHttpResponse(connection);
}"
54875,"/** 
 * Returns whether the customize parser has requested to stop or reached end of document. Otherwise, identical to   {@link #parseElement(XmlPullParser,Object,XmlNamespaceDictionary,CustomizeParser)} .
 */
private static boolean parseElementInternal(XmlPullParser parser,Object destination,XmlNamespaceDictionary namespaceDictionary,CustomizeParser customizeParser) throws IOException, XmlPullParserException {
  Class<?> destinationClass=destination == null ? null : destination.getClass();
  GenericXml genericXml=destination instanceof GenericXml ? (GenericXml)destination : null;
  boolean isMap=genericXml == null && destination instanceof Map<?,?>;
  @SuppressWarnings(""String_Node_Str"") Map<String,Object> destinationMap=isMap ? (Map<String,Object>)destination : null;
  ClassInfo classInfo=isMap || destination == null ? null : ClassInfo.of(destinationClass);
  int eventType=parser.getEventType();
  if (parser.getEventType() == XmlPullParser.START_DOCUMENT) {
    eventType=parser.next();
  }
  if (eventType != XmlPullParser.START_TAG) {
    throw new IllegalArgumentException(""String_Node_Str"" + eventType + ""String_Node_Str"");
  }
  String prefix=parser.getPrefix();
  String alias=prefix == null ? ""String_Node_Str"" : prefix;
  namespaceDictionary.addNamespace(alias,parser.getNamespace());
  if (genericXml != null) {
    genericXml.namespaceDictionary=namespaceDictionary;
    String name=parser.getName();
    genericXml.name=prefix == null ? name : prefix + ""String_Node_Str"" + name;
  }
  if (destination != null) {
    int attributeCount=parser.getAttributeCount();
    for (int i=0; i < attributeCount; i++) {
      String attributeName=parser.getAttributeName(i);
      String attributePrefix=parser.getAttributePrefix(i);
      String attributeNamespace=parser.getAttributeNamespace(i);
      if (attributePrefix != null) {
        namespaceDictionary.addNamespace(attributePrefix,attributeNamespace);
      }
      String fieldName=getFieldName(true,attributePrefix,attributeNamespace,attributeName);
      Field field=isMap ? null : classInfo.getField(fieldName);
      parseValue(parser.getAttributeValue(i),field,destination,genericXml,destinationMap,fieldName);
    }
  }
  Field field;
  while (true) {
    int event=parser.next();
switch (event) {
case XmlPullParser.END_DOCUMENT:
      return true;
case XmlPullParser.END_TAG:
    return customizeParser != null && customizeParser.stopAfterEndTag(parser.getNamespace(),parser.getName());
case XmlPullParser.TEXT:
  if (destination != null) {
    String textFieldName=""String_Node_Str"";
    field=isMap ? null : classInfo.getField(textFieldName);
    parseValue(parser.getText(),field,destination,genericXml,destinationMap,textFieldName);
  }
break;
case XmlPullParser.START_TAG:
if (customizeParser != null && customizeParser.stopBeforeStartTag(parser.getNamespace(),parser.getName())) {
return true;
}
if (destination == null) {
int level=1;
while (level != 0) {
switch (parser.next()) {
case XmlPullParser.END_DOCUMENT:
  return true;
case XmlPullParser.START_TAG:
level++;
break;
case XmlPullParser.END_TAG:
level--;
break;
}
}
continue;
}
String fieldName=getFieldName(false,parser.getPrefix(),parser.getNamespace(),parser.getName());
field=isMap ? null : classInfo.getField(fieldName);
Class<?> fieldClass=field == null ? null : field.getType();
boolean isStopped=false;
if (field == null && !isMap && genericXml == null || field != null && FieldInfo.isPrimitive(fieldClass)) {
int level=1;
while (level != 0) {
switch (parser.next()) {
case XmlPullParser.END_DOCUMENT:
return true;
case XmlPullParser.START_TAG:
level++;
break;
case XmlPullParser.END_TAG:
level--;
break;
case XmlPullParser.TEXT:
if (level == 1) {
parseValue(parser.getText(),field,destination,genericXml,destinationMap,fieldName);
}
break;
}
}
}
 else if (field == null || Map.class.isAssignableFrom(fieldClass)) {
Map<String,Object> mapValue=ClassInfo.newMapInstance(fieldClass);
isStopped=parseElementInternal(parser,mapValue,namespaceDictionary,customizeParser);
if (isMap) {
@SuppressWarnings(""String_Node_Str"") List<Object> list=(List<Object>)destinationMap.get(fieldName);
if (list == null) {
list=new ArrayList<Object>(1);
destinationMap.put(fieldName,list);
}
list.add(mapValue);
}
 else if (field != null) {
FieldInfo.setFieldValue(field,destination,mapValue);
}
 else {
GenericXml atom=(GenericXml)destination;
@SuppressWarnings(""String_Node_Str"") List<Object> list=(List<Object>)atom.get(fieldName);
if (list == null) {
list=new ArrayList<Object>(1);
atom.set(fieldName,list);
}
list.add(mapValue);
}
}
 else if (Collection.class.isAssignableFrom(fieldClass)) {
@SuppressWarnings(""String_Node_Str"") Collection<Object> collectionValue=(Collection<Object>)FieldInfo.getFieldValue(field,destination);
if (collectionValue == null) {
collectionValue=ClassInfo.newCollectionInstance(fieldClass);
FieldInfo.setFieldValue(field,destination,collectionValue);
}
Object elementValue=null;
Class<?> subFieldClass=ClassInfo.getCollectionParameter(field);
if (subFieldClass == null || FieldInfo.isPrimitive(subFieldClass)) {
int level=1;
while (level != 0) {
switch (parser.next()) {
case XmlPullParser.END_DOCUMENT:
return true;
case XmlPullParser.START_TAG:
level++;
break;
case XmlPullParser.END_TAG:
level--;
break;
case XmlPullParser.TEXT:
if (level == 1 && subFieldClass != null) {
elementValue=parseValue(parser.getText(),subFieldClass);
}
break;
}
}
}
 else {
elementValue=ClassInfo.newInstance(subFieldClass);
isStopped=parseElementInternal(parser,elementValue,namespaceDictionary,customizeParser);
}
collectionValue.add(elementValue);
}
 else {
Object value=ClassInfo.newInstance(fieldClass);
isStopped=parseElementInternal(parser,value,namespaceDictionary,customizeParser);
FieldInfo.setFieldValue(field,destination,value);
}
if (isStopped) {
return true;
}
break;
}
}
}","/** 
 * Returns whether the customize parser has requested to stop or reached end of document. Otherwise, identical to   {@link #parseElement(XmlPullParser,Object,XmlNamespaceDictionary,CustomizeParser)} .
 */
private static boolean parseElementInternal(XmlPullParser parser,Object destination,XmlNamespaceDictionary namespaceDictionary,CustomizeParser customizeParser) throws IOException, XmlPullParserException {
  Class<?> destinationClass=destination == null ? null : destination.getClass();
  GenericXml genericXml=destination instanceof GenericXml ? (GenericXml)destination : null;
  boolean isMap=genericXml == null && destination instanceof Map<?,?>;
  @SuppressWarnings(""String_Node_Str"") Map<String,Object> destinationMap=isMap ? (Map<String,Object>)destination : null;
  ClassInfo classInfo=isMap || destination == null ? null : ClassInfo.of(destinationClass);
  int eventType=parser.getEventType();
  if (parser.getEventType() == XmlPullParser.START_DOCUMENT) {
    eventType=parser.next();
  }
  if (eventType != XmlPullParser.START_TAG) {
    throw new IllegalArgumentException(""String_Node_Str"" + eventType + ""String_Node_Str"");
  }
  String prefix=parser.getPrefix();
  String alias=prefix == null ? ""String_Node_Str"" : prefix;
  namespaceDictionary.addNamespace(alias,parser.getNamespace());
  if (genericXml != null) {
    genericXml.namespaceDictionary=namespaceDictionary;
    String name=parser.getName();
    genericXml.name=prefix == null ? name : prefix + ""String_Node_Str"" + name;
  }
  if (destination != null) {
    int attributeCount=parser.getAttributeCount();
    for (int i=0; i < attributeCount; i++) {
      String attributeName=parser.getAttributeName(i);
      String attributePrefix=parser.getAttributePrefix(i);
      String attributeNamespace=parser.getAttributeNamespace(i);
      if (attributePrefix != null) {
        namespaceDictionary.addNamespace(attributePrefix,attributeNamespace);
      }
      String fieldName=getFieldName(true,attributePrefix,attributeNamespace,attributeName);
      Field field=isMap ? null : classInfo.getField(fieldName);
      parseValue(parser.getAttributeValue(i),field,destination,genericXml,destinationMap,fieldName);
    }
  }
  Field field;
  while (true) {
    int event=parser.next();
switch (event) {
case XmlPullParser.END_DOCUMENT:
      return true;
case XmlPullParser.END_TAG:
    return customizeParser != null && customizeParser.stopAfterEndTag(parser.getNamespace(),parser.getName());
case XmlPullParser.TEXT:
  if (destination != null) {
    String textFieldName=""String_Node_Str"";
    field=isMap ? null : classInfo.getField(textFieldName);
    parseValue(parser.getText(),field,destination,genericXml,destinationMap,textFieldName);
  }
break;
case XmlPullParser.START_TAG:
if (customizeParser != null && customizeParser.stopBeforeStartTag(parser.getNamespace(),parser.getName())) {
return true;
}
if (destination == null) {
int level=1;
while (level != 0) {
switch (parser.next()) {
case XmlPullParser.END_DOCUMENT:
  return true;
case XmlPullParser.START_TAG:
level++;
break;
case XmlPullParser.END_TAG:
level--;
break;
}
}
continue;
}
String fieldName=getFieldName(false,parser.getPrefix(),parser.getNamespace(),parser.getName());
field=isMap ? null : classInfo.getField(fieldName);
Class<?> fieldClass=field == null ? null : field.getType();
boolean isStopped=false;
if (field == null && !isMap && genericXml == null || field != null && FieldInfo.isPrimitive(fieldClass)) {
int level=1;
while (level != 0) {
switch (parser.next()) {
case XmlPullParser.END_DOCUMENT:
return true;
case XmlPullParser.START_TAG:
level++;
break;
case XmlPullParser.END_TAG:
level--;
break;
case XmlPullParser.TEXT:
if (level == 1) {
parseValue(parser.getText(),field,destination,genericXml,destinationMap,fieldName);
}
break;
}
}
}
 else if (field == null || Map.class.isAssignableFrom(fieldClass)) {
Map<String,Object> mapValue=ClassInfo.newMapInstance(fieldClass);
isStopped=parseElementInternal(parser,mapValue,namespaceDictionary,customizeParser);
if (isMap) {
@SuppressWarnings(""String_Node_Str"") Collection<Object> list=(Collection<Object>)destinationMap.get(fieldName);
if (list == null) {
list=new ArrayList<Object>(1);
destinationMap.put(fieldName,list);
}
list.add(mapValue);
}
 else if (field != null) {
FieldInfo.setFieldValue(field,destination,mapValue);
}
 else {
GenericXml atom=(GenericXml)destination;
@SuppressWarnings(""String_Node_Str"") Collection<Object> list=(Collection<Object>)atom.get(fieldName);
if (list == null) {
list=new ArrayList<Object>(1);
atom.set(fieldName,list);
}
list.add(mapValue);
}
}
 else if (Collection.class.isAssignableFrom(fieldClass)) {
@SuppressWarnings(""String_Node_Str"") Collection<Object> collectionValue=(Collection<Object>)FieldInfo.getFieldValue(field,destination);
if (collectionValue == null) {
collectionValue=ClassInfo.newCollectionInstance(fieldClass);
FieldInfo.setFieldValue(field,destination,collectionValue);
}
Object elementValue=null;
Class<?> subFieldClass=ClassInfo.getCollectionParameter(field);
if (subFieldClass == null || FieldInfo.isPrimitive(subFieldClass)) {
int level=1;
while (level != 0) {
switch (parser.next()) {
case XmlPullParser.END_DOCUMENT:
return true;
case XmlPullParser.START_TAG:
level++;
break;
case XmlPullParser.END_TAG:
level--;
break;
case XmlPullParser.TEXT:
if (level == 1 && subFieldClass != null) {
elementValue=parseValue(parser.getText(),subFieldClass);
}
break;
}
}
}
 else {
elementValue=ClassInfo.newInstance(subFieldClass);
isStopped=parseElementInternal(parser,elementValue,namespaceDictionary,customizeParser);
}
collectionValue.add(elementValue);
}
 else {
Object value=ClassInfo.newInstance(fieldClass);
isStopped=parseElementInternal(parser,value,namespaceDictionary,customizeParser);
FieldInfo.setFieldValue(field,destination,value);
}
if (isStopped) {
return true;
}
break;
}
}
}"
54876,"void serialize(XmlSerializer serializer,String elementNamespaceUri,String elementLocalName) throws IOException {
  boolean errorOnUnknown=this.errorOnUnknown;
  if (elementLocalName == null) {
    if (errorOnUnknown) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    elementLocalName=""String_Node_Str"";
  }
  serializer.startTag(elementNamespaceUri,elementLocalName);
  List<String> attributeNames=this.attributeNames;
  List<Object> attributeValues=this.attributeValues;
  int num=attributeNames.size();
  for (int i=0; i < num; i++) {
    String attributeName=attributeNames.get(i);
    int colon=attributeName.indexOf(':');
    String attributeLocalName=attributeName.substring(colon + 1);
    String attributeNamespaceUri=colon == -1 ? null : getNamespaceUriForAlias(attributeName.substring(0,colon));
    serializer.attribute(attributeNamespaceUri,attributeLocalName,toSerializedValue(attributeValues.get(i)));
  }
  Object textValue=this.textValue;
  if (textValue != null) {
    serializer.text(toSerializedValue(textValue));
  }
  List<String> subElementNames=this.subElementNames;
  List<Object> subElementValues=this.subElementValues;
  num=subElementNames.size();
  for (int i=0; i < num; i++) {
    Object subElementValue=subElementValues.get(i);
    String subElementName=subElementNames.get(i);
    if (subElementValue instanceof List<?>) {
      for (      Object subElement : (List<?>)subElementValue) {
        new ElementSerializer(subElement,errorOnUnknown).serialize(serializer,subElementName);
      }
    }
 else {
      new ElementSerializer(subElementValue,errorOnUnknown).serialize(serializer,subElementName);
    }
  }
  serializer.endTag(elementNamespaceUri,elementLocalName);
}","void serialize(XmlSerializer serializer,String elementNamespaceUri,String elementLocalName) throws IOException {
  boolean errorOnUnknown=this.errorOnUnknown;
  if (elementLocalName == null) {
    if (errorOnUnknown) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    elementLocalName=""String_Node_Str"";
  }
  serializer.startTag(elementNamespaceUri,elementLocalName);
  List<String> attributeNames=this.attributeNames;
  List<Object> attributeValues=this.attributeValues;
  int num=attributeNames.size();
  for (int i=0; i < num; i++) {
    String attributeName=attributeNames.get(i);
    int colon=attributeName.indexOf(':');
    String attributeLocalName=attributeName.substring(colon + 1);
    String attributeNamespaceUri=colon == -1 ? null : getNamespaceUriForAlias(attributeName.substring(0,colon));
    serializer.attribute(attributeNamespaceUri,attributeLocalName,toSerializedValue(attributeValues.get(i)));
  }
  Object textValue=this.textValue;
  if (textValue != null) {
    serializer.text(toSerializedValue(textValue));
  }
  List<String> subElementNames=this.subElementNames;
  List<Object> subElementValues=this.subElementValues;
  num=subElementNames.size();
  for (int i=0; i < num; i++) {
    Object subElementValue=subElementValues.get(i);
    String subElementName=subElementNames.get(i);
    if (subElementValue instanceof Collection<?>) {
      for (      Object subElement : (Collection<?>)subElementValue) {
        new ElementSerializer(subElement,errorOnUnknown).serialize(serializer,subElementName);
      }
    }
 else {
      new ElementSerializer(subElementValue,errorOnUnknown).serialize(serializer,subElementName);
    }
  }
  serializer.endTag(elementNamespaceUri,elementLocalName);
}"
54877,"private void computeAliases(Object element,SortedSet<String> aliases){
  for (  Map.Entry<String,Object> entry : DataUtil.mapOf(element).entrySet()) {
    Object value=entry.getValue();
    if (value != null) {
      String name=entry.getKey();
      if (!""String_Node_Str"".equals(name)) {
        int colon=name.indexOf(':');
        boolean isAttribute=name.charAt(0) == '@';
        if (colon != -1 || !isAttribute) {
          String alias=colon == -1 ? ""String_Node_Str"" : name.substring(name.charAt(0) == '@' ? 1 : 0,colon);
          aliases.add(alias);
        }
        if (!isAttribute && !FieldInfo.isPrimitive(value)) {
          computeAliases(value,aliases);
        }
      }
    }
  }
}","private void computeAliases(Object element,SortedSet<String> aliases){
  for (  Map.Entry<String,Object> entry : DataUtil.mapOf(element).entrySet()) {
    Object value=entry.getValue();
    if (value != null) {
      String name=entry.getKey();
      if (!""String_Node_Str"".equals(name)) {
        int colon=name.indexOf(':');
        boolean isAttribute=name.charAt(0) == '@';
        if (colon != -1 || !isAttribute) {
          String alias=colon == -1 ? ""String_Node_Str"" : name.substring(name.charAt(0) == '@' ? 1 : 0,colon);
          aliases.add(alias);
        }
        if (!isAttribute && !FieldInfo.isPrimitive(value)) {
          if (value instanceof Collection<?>) {
            for (            Object subValue : (Collection<?>)value) {
              computeAliases(subValue,aliases);
            }
          }
 else {
            computeAliases(value,aliases);
          }
        }
      }
    }
  }
}"
54878,"public static TestSuite suite(){
  TestSuite result=new TestSuite();
  result.addTest(com.google.api.client.auth.oauth.AllTests.suite());
  result.addTest(com.google.api.client.googleapis.auth.storage.AllTests.suite());
  result.addTest(com.google.api.client.http.AllTests.suite());
  result.addTest(com.google.api.client.util.AllTests.suite());
  return result;
}","public static TestSuite suite(){
  TestSuite result=new TestSuite();
  result.addTest(com.google.api.client.auth.oauth.AllTests.suite());
  result.addTest(com.google.api.client.googleapis.auth.storage.AllTests.suite());
  result.addTest(com.google.api.client.http.AllTests.suite());
  result.addTest(com.google.api.client.util.AllTests.suite());
  result.addTest(com.google.api.client.xml.AllTests.suite());
  return result;
}"
54879,"@Before public void setup(){
  MockitoAnnotations.initMocks(this);
  fragment=new LightCycleSupportFragment();
  fragment.addLifeCycleComponent(lightCycle);
  activityController=attach(fragment);
}","@Before public void setup(){
  MockitoAnnotations.initMocks(this);
  fragment=new LightCycleSupportFragment();
  fragment.attachLightCycle(lightCycle);
  activityController=attach(fragment);
}"
54880,"@Before public void setUp() throws Exception {
  MockitoAnnotations.initMocks(this);
  dispatcher=new SupportFragmentLightCycleDispatcher().addLifeCycleComponent(lifeCycleComponent1).addLifeCycleComponent(lifeCycleComponent2);
}","@Before public void setUp() throws Exception {
  MockitoAnnotations.initMocks(this);
  dispatcher=new SupportFragmentLightCycleDispatcher();
  dispatcher.attachLightCycle(lifeCycleComponent1);
  dispatcher.attachLightCycle(lifeCycleComponent2);
}"
54881,"@Override public boolean onTouch(View v,MotionEvent event){
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
    isClick=true;
  touchPosition(i);
return true;
case MotionEvent.ACTION_CANCEL:
touchPosition(-1);
return true;
case MotionEvent.ACTION_MOVE:
isClick=false;
return false;
case MotionEvent.ACTION_UP:
touchPosition(-1);
if (isClick && mNavigationDrawerCallbacks != null) {
mNavigationDrawerCallbacks.onNavigationDrawerItemSelected(i);
}
return true;
}
return false;
}","@Override public boolean onTouch(View v,MotionEvent event){
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
    touchPosition(i);
  return false;
case MotionEvent.ACTION_CANCEL:
touchPosition(-1);
return false;
case MotionEvent.ACTION_MOVE:
return false;
case MotionEvent.ACTION_UP:
touchPosition(-1);
return false;
}
return true;
}"
54882,"@Override public void onBindViewHolder(NavigationDrawerAdapter.ViewHolder viewHolder,final int i){
  viewHolder.textView.setText(mData.get(i).getText());
  viewHolder.textView.setCompoundDrawablesWithIntrinsicBounds(mData.get(i).getDrawable(),null,null,null);
  viewHolder.itemView.setOnTouchListener(new View.OnTouchListener(){
    @Override public boolean onTouch(    View v,    MotionEvent event){
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
        isClick=true;
      touchPosition(i);
    return true;
case MotionEvent.ACTION_CANCEL:
  touchPosition(-1);
return true;
case MotionEvent.ACTION_MOVE:
isClick=false;
return false;
case MotionEvent.ACTION_UP:
touchPosition(-1);
if (isClick && mNavigationDrawerCallbacks != null) {
mNavigationDrawerCallbacks.onNavigationDrawerItemSelected(i);
}
return true;
}
return false;
}
}
);
if (mSelectedPosition == i && mTouchedPosition == i) {
viewHolder.itemView.setBackgroundColor(Color.LTGRAY);
}
 else if (mSelectedPosition == i || mTouchedPosition == i) {
viewHolder.itemView.setBackgroundColor(viewHolder.itemView.getContext().getResources().getColor(R.color.selected_gray));
}
 else {
viewHolder.itemView.setBackgroundColor(Color.TRANSPARENT);
}
}","@Override public void onBindViewHolder(NavigationDrawerAdapter.ViewHolder viewHolder,final int i){
  viewHolder.textView.setText(mData.get(i).getText());
  viewHolder.textView.setCompoundDrawablesWithIntrinsicBounds(mData.get(i).getDrawable(),null,null,null);
  viewHolder.itemView.setOnTouchListener(new View.OnTouchListener(){
    @Override public boolean onTouch(    View v,    MotionEvent event){
switch (event.getAction()) {
case MotionEvent.ACTION_DOWN:
        touchPosition(i);
      return false;
case MotionEvent.ACTION_CANCEL:
    touchPosition(-1);
  return false;
case MotionEvent.ACTION_MOVE:
return false;
case MotionEvent.ACTION_UP:
touchPosition(-1);
return false;
}
return true;
}
}
);
viewHolder.itemView.setOnClickListener(new View.OnClickListener(){
@Override public void onClick(View v){
if (mNavigationDrawerCallbacks != null) mNavigationDrawerCallbacks.onNavigationDrawerItemSelected(i);
}
}
);
if (mSelectedPosition == i || mTouchedPosition == i) {
viewHolder.itemView.setBackgroundColor(viewHolder.itemView.getContext().getResources().getColor(R.color.selected_gray));
}
 else {
viewHolder.itemView.setBackgroundColor(Color.TRANSPARENT);
}
}"
54883,"public SettingsHandler(String passwordToken){
  this.passwordToken=passwordToken;
}","public SettingsHandler(String settingNamePasswordToken){
  this.settingNamePasswordToken=settingNamePasswordToken;
}"
54884,"protected void writeSettings(Map<String,String> settings,BufferedWriter writer) throws IOException {
  Set<String> names=new TreeSet<>(settings.keySet());
  for (  String name : names) {
    String value=settings.get(name);
    if (maskingPassword && value.contains(passwordToken)) {
      value=""String_Node_Str"";
    }
    writer.write(name + ""String_Node_Str"" + value);
    writer.newLine();
  }
}","protected void writeSettings(Map<String,String> settings,BufferedWriter writer) throws IOException {
  Set<String> names=new TreeSet<>(settings.keySet());
  for (  String name : names) {
    if (maskingPassword && name.contains(settingNamePasswordToken)) {
      writer.write(name + ""String_Node_Str"");
    }
 else {
      writer.write(name + ""String_Node_Str"" + settings.get(name));
    }
    writer.newLine();
  }
}"
54885,"@Override public URL getResourceUrl(String resourcePath){
  String resourceName=getResourceBasePath() + ""String_Node_Str"" + resourcePath;
  return this.getClass().getClassLoader().getResource(resourceName);
}","@Override public URL getResourceUrl(String resourcePath){
  if (!isValidResourcePath(resourceBasePath,resourcePath)) {
    log.warn(""String_Node_Str"",resourcePath,resourceBasePath);
    return null;
  }
  String resourceName=getResourceBasePath() + ""String_Node_Str"" + resourcePath;
  return this.getClass().getClassLoader().getResource(resourceName);
}"
54886,"@Override public URL getResourceUrl(String resourcePath){
  String resourceName=getResourceBasePath() + ""String_Node_Str"" + resourcePath;
  String artifactPath=resourcePath.substring(0,resourcePath.indexOf('/') + 1);
  if (pathAliases.containsKey(artifactPath)) {
    String artifactVersion=pathAliases.get(artifactPath);
    if (!resourcePath.startsWith(artifactVersion)) {
      String aliasedPath=artifactVersion + resourcePath.substring(artifactPath.length());
      log.trace(""String_Node_Str"",resourcePath,aliasedPath);
      resourceName=getResourceBasePath() + ""String_Node_Str"" + aliasedPath;
    }
  }
  URL url=this.getClass().getClassLoader().getResource(resourceName);
  if (url == null) {
    log.warn(""String_Node_Str"",resourceName);
  }
  return url;
}","@Override public URL getResourceUrl(String resourcePath){
  if (!isValidResourcePath(resourceBasePath,resourcePath)) {
    log.warn(""String_Node_Str"",resourcePath,resourceBasePath);
    return null;
  }
  String resourceName=getResourceBasePath() + ""String_Node_Str"" + resourcePath;
  String artifactPath=resourcePath.substring(0,resourcePath.indexOf('/') + 1);
  if (pathAliases.containsKey(artifactPath)) {
    String artifactVersion=pathAliases.get(artifactPath);
    if (!resourcePath.startsWith(artifactVersion)) {
      String aliasedPath=artifactVersion + resourcePath.substring(artifactPath.length());
      log.trace(""String_Node_Str"",resourcePath,aliasedPath);
      resourceName=getResourceBasePath() + ""String_Node_Str"" + aliasedPath;
    }
  }
  URL url=this.getClass().getClassLoader().getResource(resourceName);
  if (url == null) {
    log.warn(""String_Node_Str"",resourceName);
  }
  return url;
}"
54887,"private void commit(CharSequence content){
  checkCommitted();
  finalizeResponse();
  if (getContentType() == null) {
    contentType(HttpConstants.ContentType.TEXT_HTML);
  }
  try {
    if (content != null) {
      contentLength(content.toString().getBytes().length);
      httpServletResponse.getWriter().append(content);
    }
    log.trace(""String_Node_Str"");
    if (chunked) {
      httpServletResponse.flushBuffer();
    }
  }
 catch (  IOException e) {
    throw new PippoRuntimeException(e);
  }
}","private void commit(CharSequence content){
  checkCommitted();
  finalizeResponse();
  if (getContentType() == null) {
    contentType(HttpConstants.ContentType.TEXT_HTML);
  }
  try {
    if (content != null) {
      contentLength(content.toString().getBytes().length);
      httpServletResponse.getWriter().append(content);
    }
    log.trace(""String_Node_Str"");
    if (chunked) {
      httpServletResponse.flushBuffer();
    }
    finishGZip();
  }
 catch (  IOException e) {
    throw new PippoRuntimeException(e);
  }
}"
54888,"public GZipRequestResponseFactory(Application application){
  super(application);
  application.getRoutePostDispatchListeners().add(this);
}","public GZipRequestResponseFactory(Application application){
  super(application);
}"
54889,"void finish(){
  try {
    if (writer != null) {
      writer.close();
    }
 else {
      if (stream != null) {
        stream.close();
      }
    }
  }
 catch (  IOException e) {
  }
}","public void finish(){
  IoUtils.close(writer);
  IoUtils.close(stream);
}"
54890,"@Override public WebServer setPippoFilter(PippoFilter pippoFilter){
  this.application=pippoFilter.getApplication();
}","@Override public WebServer setPippoFilter(PippoFilter pippoFilter){
  this.application=pippoFilter.getApplication();
  return this;
}"
54891,"@Override public WebServer setPippoFilter(PippoFilter pippoFilter){
  super.setPippoFilter(pippoFilter);
  application=pippoFilter.getApplication();
}","@Override public WebServer setPippoFilter(PippoFilter pippoFilter){
  super.setPippoFilter(pippoFilter);
  application=pippoFilter.getApplication();
  return this;
}"
54892,"private void enableSSLConnector(Tomcat tomcat){
  log.info(""String_Node_Str"");
  Connector connector=tomcat.getConnector();
  connector.setPort(getSettings().getPort());
  connector.setSecure(true);
  connector.setScheme(""String_Node_Str"");
  connector.setAttribute(""String_Node_Str"",getSettings().getKeyAlias());
  connector.setAttribute(""String_Node_Str"",getSettings().getKeystorePassword());
  connector.setAttribute(""String_Node_Str"",getSettings().getKeyType());
  connector.setAttribute(""String_Node_Str"",getSettings().getKeystoreFile());
  connector.setAttribute(""String_Node_Str"",getSettings().getTruststoreFile());
  connector.setAttribute(""String_Node_Str"",getSettings().getTruststorePassword());
  connector.setAttribute(""String_Node_Str"",getSettings().getClientAuth());
  connector.setAttribute(""String_Node_Str"",""String_Node_Str"");
  connector.setAttribute(""String_Node_Str"",""String_Node_Str"");
  connector.setAttribute(""String_Node_Str"",getSettings().getMaxConnections());
  connector.setAttribute(""String_Node_Str"",""String_Node_Str"");
  connector.setAttribute(""String_Node_Str"",true);
}","private void enableSSLConnector(Tomcat tomcat){
  log.info(""String_Node_Str"");
  Connector connector=tomcat.getConnector();
  connector.setPort(getSettings().getPort());
  connector.setSecure(true);
  connector.setScheme(""String_Node_Str"");
  connector.setAttribute(""String_Node_Str"",getSettings().getKeyAlias());
  connector.setAttribute(""String_Node_Str"",getSettings().getKeystorePassword());
  connector.setAttribute(""String_Node_Str"",getSettings().getKeyType());
  connector.setAttribute(""String_Node_Str"",getSettings().getKeystoreFile());
  connector.setAttribute(""String_Node_Str"",getSettings().getClientAuth());
  if (getSettings().getClientAuth()) {
    connector.setAttribute(""String_Node_Str"",getSettings().getTruststoreFile());
    connector.setAttribute(""String_Node_Str"",getSettings().getTruststorePassword());
  }
  connector.setAttribute(""String_Node_Str"",""String_Node_Str"");
  connector.setAttribute(""String_Node_Str"",""String_Node_Str"");
  connector.setAttribute(""String_Node_Str"",getSettings().getMaxConnections());
  connector.setAttribute(""String_Node_Str"",""String_Node_Str"");
  connector.setAttribute(""String_Node_Str"",true);
}"
54893,"/** 
 * Transforms an url pattern like ""/{name}/id/*"" into a regex like ""/([^/]*)/id/*."" <p/> Also handles regular expressions if defined inside routes: For instance ""/users/{username: [a-zA-Z][a-zA-Z_0-9]}"" becomes ""/users/([a-zA-Z][a-zA-Z_0-9])""
 * @return The converted regex with default matching regex - or the regexspecified by the user.
 */
private String getRegex(String urlPattern){
  StringBuffer buffer=new StringBuffer();
  Matcher matcher=PATTERN_FOR_VARIABLE_PARTS_OF_ROUTE.matcher(urlPattern);
  while (matcher.find()) {
    String variablePartOfRouteName=matcher.group(1);
    String namedVariablePartOfRoute=matcher.group(3);
    String namedVariablePartOfORouteReplacedWithRegex;
    if (namedVariablePartOfRoute != null) {
      String variableRegex=replacePosixClasses(namedVariablePartOfRoute);
      namedVariablePartOfORouteReplacedWithRegex=String.format(""String_Node_Str"",variablePartOfRouteName,Matcher.quoteReplacement(variableRegex));
    }
 else {
      namedVariablePartOfORouteReplacedWithRegex=String.format(VARIABLE_ROUTES_DEFAULT_REGEX,variablePartOfRouteName);
    }
    matcher.appendReplacement(buffer,namedVariablePartOfORouteReplacedWithRegex);
  }
  matcher.appendTail(buffer);
  return buffer.toString();
}","/** 
 * Transforms an url pattern like ""/{name}/id/*"" into a regex like ""/([^/]*)/id/*."" <p/> Also handles regular expressions if defined inside routes: For instance ""/users/{username: [a-zA-Z][a-zA-Z_0-9]}"" becomes ""/users/([a-zA-Z][a-zA-Z_0-9])""
 * @return The converted regex with default matching regex - or the regexspecified by the user.
 */
private String getRegex(String urlPattern){
  StringBuffer buffer=new StringBuffer();
  Matcher matcher=PATTERN_FOR_VARIABLE_PARTS_OF_ROUTE.matcher(urlPattern);
  int pathParameterIndex=0;
  while (matcher.find()) {
    String namedVariablePartOfRoute=matcher.group(3);
    String namedVariablePartOfORouteReplacedWithRegex;
    if (namedVariablePartOfRoute != null) {
      String variableRegex=replacePosixClasses(namedVariablePartOfRoute);
      namedVariablePartOfORouteReplacedWithRegex=String.format(""String_Node_Str"",getPathParameterRegexGroupName(pathParameterIndex),Matcher.quoteReplacement(variableRegex));
    }
 else {
      namedVariablePartOfORouteReplacedWithRegex=String.format(VARIABLE_ROUTES_DEFAULT_REGEX,getPathParameterRegexGroupName(pathParameterIndex));
    }
    matcher.appendReplacement(buffer,namedVariablePartOfORouteReplacedWithRegex);
    pathParameterIndex++;
  }
  matcher.appendTail(buffer);
  return buffer.toString();
}"
54894,"private Map<String,String> getParameters(PatternBinding binding,String requestUri){
  if (binding.getParameterNames().isEmpty()) {
    return Collections.EMPTY_MAP;
  }
  Map<String,String> parameters=new HashMap<>();
  List<String> parameterNames=binding.getParameterNames();
  Matcher matcher=binding.getPattern().matcher(requestUri);
  matcher.matches();
  int groupCount=matcher.groupCount();
  if (groupCount > 0) {
    for (    String name : parameterNames) {
      parameters.put(name,matcher.group(name));
    }
  }
  return parameters;
}","private Map<String,String> getParameters(PatternBinding binding,String requestUri){
  if (binding.getParameterNames().isEmpty()) {
    return Collections.EMPTY_MAP;
  }
  Map<String,String> parameters=new HashMap<>();
  List<String> parameterNames=binding.getParameterNames();
  Matcher matcher=binding.getPattern().matcher(requestUri);
  matcher.matches();
  int groupCount=matcher.groupCount();
  if (groupCount > 0) {
    for (int i=0; i < parameterNames.size(); i++) {
      parameters.put(parameterNames.get(i),matcher.group(getPathParameterRegexGroupName(i)));
    }
  }
  return parameters;
}"
54895,"public String getAbsoluteUriPattern(){
  if (absoluteUriPattern == null) {
    RouteGroup group=this.group;
    String path=this.uriPattern;
    while (group != null) {
      path=StringUtils.addStart(StringUtils.addStart(path,""String_Node_Str""),group.getUriPattern());
      group=group.getParent();
    }
    absoluteUriPattern=StringUtils.removeEnd(path,""String_Node_Str"");
  }
  return absoluteUriPattern;
}","public String getAbsoluteUriPattern(){
  if (absoluteUriPattern == null) {
    RouteGroup group=this.group;
    String path=this.uriPattern;
    while (group != null) {
      path=StringUtils.addStart(StringUtils.addStart(path,""String_Node_Str""),group.getUriPattern());
      group=group.getParent();
    }
    absoluteUriPattern=""String_Node_Str"".equals(path) ? path : StringUtils.removeEnd(path,""String_Node_Str"");
  }
  return absoluteUriPattern;
}"
54896,"@Override public void handleResource(String resourcePath,RouteContext routeContext){
  URL url=getResourceUrl(resourcePath);
  if (url == null) {
    routeContext.getResponse().notFound().commit();
  }
 else {
    streamResource(url,routeContext);
  }
  routeContext.next();
}","@Override public void handleResource(String resourcePath,RouteContext routeContext){
  URL url=getResourceUrl(resourcePath);
  if (url == null) {
    routeContext.getResponse().notFound().commit();
  }
 else {
    streamResource(url,routeContext);
  }
}"
54897,"private PatternBinding getBinding(String nameOrUriPattern){
  Collection<List<PatternBinding>> values=bindingsCache.values();
  for (  List<PatternBinding> bindings : values) {
    for (    PatternBinding binding : bindings) {
      if (nameOrUriPattern.equals(binding.getRoute().getNameOrUriPattern())) {
        return binding;
      }
    }
  }
  return null;
}","private PatternBinding getBinding(String nameOrUriPattern){
  Collection<List<PatternBinding>> values=bindingsCache.values();
  Route route;
  for (  List<PatternBinding> bindings : values) {
    for (    PatternBinding binding : bindings) {
      route=binding.getRoute();
      if (nameOrUriPattern.equals(route.getName()) || nameOrUriPattern.equals(route.getUriPattern())) {
        return binding;
      }
    }
  }
  return null;
}"
54898,"private void removeBinding(Route route){
  PatternBinding binding=getBinding(route.getNameOrUriPattern());
  bindingsCache.get(route.getRequestMethod()).remove(binding);
}","private void removeBinding(Route route){
  String nameOrUriPattern=StringUtils.isNullOrEmpty(route.getName()) ? route.getUriPattern() : route.getName();
  PatternBinding binding=getBinding(nameOrUriPattern);
  bindingsCache.get(route.getRequestMethod()).remove(binding);
}"
54899,"@Override public Reader getReader(String templateName) throws LoaderException {
  StringBuilder path=new StringBuilder(""String_Node_Str"");
  if (getPrefix() != null) {
    path.append(getPrefix());
    if (!getPrefix().endsWith(String.valueOf(File.separatorChar))) {
      path.append(File.separatorChar);
    }
  }
  String resource=path.toString() + templateName + (getSuffix() == null ? ""String_Node_Str"" : getSuffix());
  String location=resource;
  if (resource.charAt(0) == '/') {
    location=resource.substring(1);
  }
  URL url=ClasspathUtils.locateOnClasspath(location);
  if (url == null) {
    throw new LoaderException(null,""String_Node_Str"" + location + ""String_Node_Str"");
  }
  Reader reader=null;
  try {
    InputStream is=url.openStream();
    InputStreamReader isr=new InputStreamReader(is,getCharset());
    reader=new BufferedReader(isr);
  }
 catch (  IOException e) {
    throw new PippoRuntimeException(e);
  }
  return reader;
}","@Override public Reader getReader(String templateName) throws LoaderException {
  StringBuilder path=new StringBuilder(""String_Node_Str"");
  if (getPrefix() != null) {
    path.append(getPrefix());
    if (!getPrefix().endsWith(String.valueOf('/'))) {
      path.append('/');
    }
  }
  String resource=path.toString() + templateName + (getSuffix() == null ? ""String_Node_Str"" : getSuffix());
  String location=resource;
  if (resource.charAt(0) == '/') {
    location=resource.substring(1);
  }
  URL url=ClasspathUtils.locateOnClasspath(location);
  if (url == null) {
    throw new LoaderException(null,""String_Node_Str"" + location + ""String_Node_Str"");
  }
  Reader reader=null;
  try {
    InputStream is=url.openStream();
    InputStreamReader isr=new InputStreamReader(is,getCharset());
    reader=new BufferedReader(isr);
  }
 catch (  IOException e) {
    throw new PippoRuntimeException(e);
  }
  return reader;
}"
54900,"@Override public void init(FilterConfig filterConfig) throws ServletException {
  log.info(PippoUtils.getPippoLogo());
  String mode=filterConfig.getInitParameter(MODE_PARAM);
  if (!StringUtils.isNullOrEmpty(mode)) {
    System.setProperty(PippoConstants.SYSTEM_PROPERTY_PIPPO_MODE,mode);
  }
  if (application == null) {
    createApplication(filterConfig);
    log.debug(""String_Node_Str"",application);
  }
  try {
    String contextPath=StringUtils.addStart(filterConfig.getServletContext().getContextPath(),""String_Node_Str"");
    application.getRouter().setContextPath(contextPath);
    if (filterPath == null) {
      initFilterPath(filterConfig);
    }
    String applicationPath=contextPath + ""String_Node_Str"" + filterPath;
    application.getRouter().setApplicationPath(applicationPath);
    if (!contextPath.equals(applicationPath)) {
      log.debug(""String_Node_Str"",contextPath);
    }
    log.debug(""String_Node_Str"",applicationPath);
    log.debug(""String_Node_Str"");
    routeDispatcher=new RouteDispatcher(application);
    routeDispatcher.init();
    String runtimeMode=application.getRuntimeMode().toString().toUpperCase();
    log.info(""String_Node_Str"",runtimeMode);
  }
 catch (  Exception e) {
    destroy();
    throw new ServletException(e);
  }
}","@Override public void init(FilterConfig filterConfig) throws ServletException {
  log.info(PippoUtils.getPippoLogo());
  String mode=filterConfig.getInitParameter(MODE_PARAM);
  if (!StringUtils.isNullOrEmpty(mode)) {
    System.setProperty(PippoConstants.SYSTEM_PROPERTY_PIPPO_MODE,mode);
  }
  if (application == null) {
    createApplication(filterConfig);
    log.debug(""String_Node_Str"",application);
  }
  try {
    String contextPath=StringUtils.addStart(filterConfig.getServletContext().getContextPath(),""String_Node_Str"");
    application.getRouter().setContextPath(contextPath);
    if (filterPath == null) {
      initFilterPath(filterConfig);
    }
    String applicationPath=getApplicationPath(contextPath,filterPath);
    application.getRouter().setApplicationPath(applicationPath);
    if (!contextPath.equals(applicationPath)) {
      log.debug(""String_Node_Str"",contextPath);
    }
    log.debug(""String_Node_Str"",applicationPath);
    log.debug(""String_Node_Str"");
    routeDispatcher=new RouteDispatcher(application);
    routeDispatcher.init();
    String runtimeMode=application.getRuntimeMode().toString().toUpperCase();
    log.info(""String_Node_Str"",runtimeMode);
  }
 catch (  Exception e) {
    destroy();
    throw new ServletException(e);
  }
}"
54901,"@Override public String toString(){
  String toString=(getApplicationName() + ""String_Node_Str"" + getApplicationVersion()).trim();
  if (toString.isEmpty()) {
    super.toString();
  }
  return toString;
}","@Override public String toString(){
  String toString=(getApplicationName() + ""String_Node_Str"" + getApplicationVersion()).trim();
  return toString.isEmpty() ? super.toString() : toString;
}"
54902,"/** 
 * This method commits the response.
 */
public void commit(){
  checkCommitted();
  for (  Cookie cookie : getCookies()) {
    httpServletResponse.addCookie(cookie);
  }
  if (getStatus() == 0) {
    ok();
  }
  if (getContentType() == null) {
    contentType(HttpConstants.ContentType.TEXT_HTML);
  }
  try {
    log.trace(""String_Node_Str"");
    httpServletResponse.flushBuffer();
  }
 catch (  IOException e) {
    throw new PippoRuntimeException(e);
  }
}","private void commit(CharSequence content){
  checkCommitted();
  for (  Cookie cookie : getCookies()) {
    httpServletResponse.addCookie(cookie);
  }
  if (getStatus() == 0) {
    ok();
  }
  if (getContentType() == null) {
    contentType(HttpConstants.ContentType.TEXT_HTML);
  }
  try {
    if (content != null) {
      httpServletResponse.getWriter().append(content);
    }
    log.trace(""String_Node_Str"");
    httpServletResponse.flushBuffer();
  }
 catch (  IOException e) {
    throw new PippoRuntimeException(e);
  }
}"
54903,"protected void streamResource(URL resourceUrl,Request request,Response response){
  try {
    URLConnection urlConnection=resourceUrl.openConnection();
    long lastModified=urlConnection.getLastModified();
    httpCacheToolkit.addEtag(request,response,lastModified);
    if (response.getStatus() == HttpConstants.StatusCode.NOT_MODIFIED) {
      log.debug(""String_Node_Str"",resourceUrl);
      response.commit();
    }
 else {
      String filename=resourceUrl.getFile();
      String mimeType=mimeTypes.getContentType(request,response,filename);
      if (!StringUtils.isNullOrEmpty(mimeType)) {
        log.debug(""String_Node_Str"",resourceUrl);
        response.contentType(mimeType);
        response.resource(urlConnection.getInputStream());
      }
 else {
        log.debug(""String_Node_Str"",resourceUrl);
        response.file(filename,urlConnection.getInputStream());
      }
    }
  }
 catch (  Exception e) {
    throw new PippoRuntimeException(""String_Node_Str"" + resourceUrl,e);
  }
}","protected void streamResource(URL resourceUrl,Request request,Response response){
  try {
    URLConnection urlConnection=resourceUrl.openConnection();
    long lastModified=urlConnection.getLastModified();
    httpCacheToolkit.addEtag(request,response,lastModified);
    if (response.getStatus() == HttpConstants.StatusCode.NOT_MODIFIED) {
      log.debug(""String_Node_Str"",resourceUrl);
      response.commit();
    }
 else {
      String filename=resourceUrl.getFile();
      String mimeType=mimeTypes.getContentType(request,response,filename);
      if (!StringUtils.isNullOrEmpty(mimeType)) {
        log.debug(""String_Node_Str"",resourceUrl);
        response.contentType(mimeType);
        response.resource(urlConnection.getInputStream());
      }
 else {
        log.debug(""String_Node_Str"",resourceUrl);
        response.file(filename,urlConnection.getInputStream());
      }
    }
  }
 catch (  Exception e) {
    throw new PippoRuntimeException(""String_Node_Str"",e,resourceUrl);
  }
}"
54904,"/** 
 * Copies the input stream to the response output stream. <p>This method commits the response.</p>
 * @param input
 */
public void resource(InputStream input){
  checkCommitted();
  for (  Cookie cookie : getCookies()) {
    httpServletResponse.addCookie(cookie);
  }
  if (getContentType() == null) {
    contentType(HttpConstants.ContentType.APPLICATION_OCTET_STREAM);
  }
  try {
    long length=IoUtils.copy(input,httpServletResponse.getOutputStream());
    if (isHeaderEmpty(HttpConstants.Header.CONTENT_LENGTH)) {
      contentLength(length);
    }
    httpServletResponse.flushBuffer();
  }
 catch (  Exception e) {
    throw new PippoRuntimeException(e);
  }
 finally {
    IoUtils.close(input);
  }
}","/** 
 * Copies the input stream to the response output stream. <p>This method commits the response.</p>
 * @param input
 */
public void resource(InputStream input){
  checkCommitted();
  for (  Cookie cookie : getCookies()) {
    httpServletResponse.addCookie(cookie);
  }
  if (getContentType() == null) {
    contentType(HttpConstants.ContentType.APPLICATION_OCTET_STREAM);
  }
  try {
    IoUtils.copy(input,httpServletResponse.getOutputStream());
    httpServletResponse.flushBuffer();
  }
 catch (  Exception e) {
    throw new PippoRuntimeException(e);
  }
 finally {
    IoUtils.close(input);
  }
}"
54905,"/** 
 * Copies the input stream to the response output stream as a download. <p>This method commits the response.</p>
 * @param filename
 * @param input
 */
public void file(String filename,InputStream input){
  checkCommitted();
  for (  Cookie cookie : getCookies()) {
    httpServletResponse.addCookie(cookie);
  }
  if (getContentType() == null) {
    contentType(HttpConstants.ContentType.APPLICATION_OCTET_STREAM);
  }
  if (isHeaderEmpty(HttpConstants.Header.CONTENT_DISPOSITION)) {
    if (filename != null && !filename.isEmpty()) {
      header(HttpConstants.Header.CONTENT_DISPOSITION,""String_Node_Str"" + filename + ""String_Node_Str"");
    }
 else {
      header(HttpConstants.Header.CONTENT_DISPOSITION,""String_Node_Str"");
    }
  }
  try {
    long length=IoUtils.copy(input,httpServletResponse.getOutputStream());
    if (isHeaderEmpty(HttpConstants.Header.CONTENT_LENGTH)) {
      contentLength(length);
    }
    httpServletResponse.flushBuffer();
  }
 catch (  Exception e) {
    throw new PippoRuntimeException(e);
  }
 finally {
    IoUtils.close(input);
  }
}","/** 
 * Copies the input stream to the response output stream as a download. <p>This method commits the response.</p>
 * @param filename
 * @param input
 */
public void file(String filename,InputStream input){
  checkCommitted();
  for (  Cookie cookie : getCookies()) {
    httpServletResponse.addCookie(cookie);
  }
  if (getContentType() == null) {
    contentType(HttpConstants.ContentType.APPLICATION_OCTET_STREAM);
  }
  if (isHeaderEmpty(HttpConstants.Header.CONTENT_DISPOSITION)) {
    if (filename != null && !filename.isEmpty()) {
      header(HttpConstants.Header.CONTENT_DISPOSITION,""String_Node_Str"" + filename + ""String_Node_Str"");
    }
 else {
      header(HttpConstants.Header.CONTENT_DISPOSITION,""String_Node_Str"");
    }
  }
  try {
    IoUtils.copy(input,httpServletResponse.getOutputStream());
    httpServletResponse.flushBuffer();
  }
 catch (  Exception e) {
    throw new PippoRuntimeException(e);
  }
 finally {
    IoUtils.close(input);
  }
}"
54906,"private Map<String,String> getParameters(PatternBinding binding,String requestUri){
  Map<String,String> parameters=new HashMap<>();
  List<String> parameterNames=binding.getParameterNames();
  Matcher matcher=binding.getPattern().matcher(requestUri);
  matcher.matches();
  int groupCount=matcher.groupCount();
  if (groupCount > 0) {
    for (int i=1; i <= groupCount; i++) {
      parameters.put(parameterNames.get(i - 1),matcher.group(i));
    }
  }
  return parameters;
}","private Map<String,String> getParameters(PatternBinding binding,String requestUri){
  if (binding.getParameterNames().isEmpty()) {
    return Collections.EMPTY_MAP;
  }
  Map<String,String> parameters=new HashMap<>();
  List<String> parameterNames=binding.getParameterNames();
  Matcher matcher=binding.getPattern().matcher(requestUri);
  matcher.matches();
  int groupCount=matcher.groupCount();
  if (groupCount > 0) {
    for (int i=1; i <= groupCount; i++) {
      parameters.put(parameterNames.get(i - 1),matcher.group(i));
    }
  }
  return parameters;
}"
54907,"/** 
 * This method commits the response.
 */
public void commit(){
  checkCommitted();
  for (  Cookie cookie : getCookies()) {
    httpServletResponse.addCookie(cookie);
  }
  if (getStatus() == 0) {
    ok();
  }
  if (getContentType() == null) {
    header(HttpConstants.Header.CONTENT_TYPE,HttpConstants.ContentType.TEXT_HTML);
  }
  try {
    httpServletResponse.flushBuffer();
  }
 catch (  IOException e) {
    throw new PippoRuntimeException(e);
  }
}","/** 
 * This method commits the response.
 */
public void commit(){
  checkCommitted();
  for (  Cookie cookie : getCookies()) {
    httpServletResponse.addCookie(cookie);
  }
  if (getStatus() == 0) {
    ok();
  }
  if (getContentType() == null) {
    contentType(HttpConstants.ContentType.TEXT_HTML);
  }
  try {
    httpServletResponse.flushBuffer();
  }
 catch (  IOException e) {
    throw new PippoRuntimeException(e);
  }
}"
54908,"private boolean isHeaderEmpty(String name){
  String value=getHttpServletResponse().getHeader(name);
  return (value == null) || value.isEmpty();
}","private boolean isHeaderEmpty(String name){
  return StringUtils.isNullOrEmpty(getHttpServletResponse().getHeader(name));
}"
54909,"/** 
 * Copies the input stream to the response output stream. <p>This method commits the response.</p>
 * @param input
 */
public void resource(InputStream input){
  checkCommitted();
  if (isHeaderEmpty(HttpConstants.Header.CONTENT_TYPE)) {
    header(HttpConstants.Header.CONTENT_TYPE,HttpConstants.ContentType.APPLICATION_OCTET_STREAM);
  }
  try {
    long length=IoUtils.copy(input,httpServletResponse.getOutputStream());
    if (isHeaderEmpty(HttpConstants.Header.CONTENT_LENGTH)) {
      contentLength(length);
    }
    commit();
  }
 catch (  Exception e) {
    throw new PippoRuntimeException(e);
  }
 finally {
    IoUtils.close(input);
  }
}","/** 
 * Copies the input stream to the response output stream. <p>This method commits the response.</p>
 * @param input
 */
public void resource(InputStream input){
  checkCommitted();
  if (getContentType() == null) {
    contentType(HttpConstants.ContentType.APPLICATION_OCTET_STREAM);
  }
  try {
    long length=IoUtils.copy(input,httpServletResponse.getOutputStream());
    if (isHeaderEmpty(HttpConstants.Header.CONTENT_LENGTH)) {
      contentLength(length);
    }
    commit();
  }
 catch (  Exception e) {
    throw new PippoRuntimeException(e);
  }
 finally {
    IoUtils.close(input);
  }
}"
54910,"/** 
 * Copies the input stream to the response output stream as a download. <p>This method commits the response.</p>
 * @param filename
 * @param input
 */
public void file(String filename,InputStream input){
  checkCommitted();
  header(HttpConstants.Header.CONTENT_TYPE,HttpConstants.ContentType.APPLICATION_OCTET_STREAM);
  if (isHeaderEmpty(HttpConstants.Header.CONTENT_DISPOSITION)) {
    if (filename != null && !filename.isEmpty()) {
      header(HttpConstants.Header.CONTENT_DISPOSITION,""String_Node_Str"" + filename + ""String_Node_Str"");
    }
 else {
      header(HttpConstants.Header.CONTENT_DISPOSITION,""String_Node_Str"");
    }
  }
  try {
    long length=IoUtils.copy(input,httpServletResponse.getOutputStream());
    if (isHeaderEmpty(HttpConstants.Header.CONTENT_LENGTH)) {
      contentLength(length);
    }
    commit();
  }
 catch (  Exception e) {
    throw new PippoRuntimeException(e);
  }
 finally {
    IoUtils.close(input);
  }
}","/** 
 * Copies the input stream to the response output stream as a download. <p>This method commits the response.</p>
 * @param filename
 * @param input
 */
public void file(String filename,InputStream input){
  checkCommitted();
  if (getContentType() == null) {
    contentType(HttpConstants.ContentType.APPLICATION_OCTET_STREAM);
  }
  if (isHeaderEmpty(HttpConstants.Header.CONTENT_DISPOSITION)) {
    if (filename != null && !filename.isEmpty()) {
      header(HttpConstants.Header.CONTENT_DISPOSITION,""String_Node_Str"" + filename + ""String_Node_Str"");
    }
 else {
      header(HttpConstants.Header.CONTENT_DISPOSITION,""String_Node_Str"");
    }
  }
  try {
    long length=IoUtils.copy(input,httpServletResponse.getOutputStream());
    if (isHeaderEmpty(HttpConstants.Header.CONTENT_LENGTH)) {
      contentLength(length);
    }
    commit();
  }
 catch (  Exception e) {
    throw new PippoRuntimeException(e);
  }
 finally {
    IoUtils.close(input);
  }
}"
54911,"/** 
 * A permanent (3XX status code) redirect. <p>This method commits the response.</p>
 * @param location
 * @param statusCode
 */
public void redirect(String location,int statusCode){
  checkCommitted();
  httpServletResponse.setStatus(statusCode);
  httpServletResponse.setHeader(HttpConstants.Header.LOCATION,location);
  httpServletResponse.setHeader(HttpConstants.Header.CONNECTION,""String_Node_Str"");
  try {
    httpServletResponse.sendError(statusCode);
  }
 catch (  IOException e) {
    throw new PippoRuntimeException(e);
  }
}","/** 
 * A permanent (3XX status code) redirect. <p>This method commits the response.</p>
 * @param location
 * @param statusCode
 */
public void redirect(String location,int statusCode){
  checkCommitted();
  status(statusCode);
  header(HttpConstants.Header.LOCATION,location);
  header(HttpConstants.Header.CONNECTION,""String_Node_Str"");
  try {
    httpServletResponse.sendError(statusCode);
  }
 catch (  IOException e) {
    throw new PippoRuntimeException(e);
  }
}"
54912,"/** 
 * Sets the content length of the response.
 * @param length
 * @return the response
 */
public Response contentLength(long length){
  checkCommitted();
  httpServletResponse.setHeader(HttpConstants.Header.CONTENT_LENGTH,Long.toString(length));
  return this;
}","/** 
 * Sets the content length of the response.
 * @param length
 * @return the response
 */
public Response contentLength(long length){
  checkCommitted();
  httpServletResponse.setContentLength((int)length);
  return this;
}"
54913,"public static void main(String[] args){
  Pippo pippo=new Pippo(new CrudApplication());
  pippo.getServer().getSettings().staticFilesLocation(""String_Node_Str"");
  pippo.start();
}","public static void main(String[] args){
  Pippo pippo=new Pippo(new CrudApplication());
  pippo.getApplication().GET(new WebjarsResourceHandler());
  pippo.getApplication().GET(new PublicResourceHandler());
  pippo.start();
}"
54914,"public Application(PippoSettings settings){
  this.pippoSettings=new PippoSettings();
}","public Application(PippoSettings settings){
  this.pippoSettings=settings;
}"
54915,"public void send(CharSequence content){
  checkCommitted();
  if (getStatus() == 0) {
    status(HttpConstants.StatusCode.OK);
  }
  if (getContentType() == null) {
    header(HttpConstants.Header.CONTENT_TYPE,HttpConstants.ContentType.TEXT_HTML);
  }
  if (getCharacterEncoding() == null) {
    characterEncoding(""String_Node_Str"");
  }
  write(content);
  try {
    httpServletResponse.flushBuffer();
  }
 catch (  IOException e) {
    new PippoRuntimeException(e);
  }
}","public void send(CharSequence content){
  checkCommitted();
  if (getStatus() == 0) {
    status(HttpConstants.StatusCode.OK);
  }
  if (getContentType() == null) {
    header(HttpConstants.Header.CONTENT_TYPE,HttpConstants.ContentType.TEXT_HTML);
  }
  if (getCharacterEncoding() == null) {
    characterEncoding(StandardCharsets.UTF_8.toString());
  }
  write(content);
  try {
    httpServletResponse.flushBuffer();
  }
 catch (  IOException e) {
    new PippoRuntimeException(e);
  }
}"
54916,"@Override public void init(){
  super.init();
  contactService=new InMemoryContactService();
  GET(""String_Node_Str"",new RouteHandler(){
    @Override public void handle(    Request request,    Response response,    RouteHandlerChain chain){
      System.out.println(""String_Node_Str"" + request.getUri());
      chain.next();
    }
  }
);
  GET(""String_Node_Str"",new RouteHandler(){
    @Override public void handle(    Request request,    Response response,    RouteHandlerChain chain){
      if (request.getSession().getAttribute(""String_Node_Str"") == null) {
        request.getSession().setAttribute(""String_Node_Str"",request.getUri());
        request.getSession().setAttribute(""String_Node_Str"",""String_Node_Str"");
        response.redirect(""String_Node_Str"");
      }
 else {
        chain.next();
      }
    }
  }
);
  GET(""String_Node_Str"",new RouteHandler(){
    @Override public void handle(    Request request,    Response response,    RouteHandlerChain chain){
      response.redirect(""String_Node_Str"");
    }
  }
);
  GET(""String_Node_Str"",new RouteHandler(){
    @Override public void handle(    Request request,    Response response,    RouteHandlerChain chain){
      Map<String,Object> model=new HashMap<String,Object>();
      model.put(""String_Node_Str"",contactService.getContacts());
      response.render(""String_Node_Str"",model);
    }
  }
);
  GET(""String_Node_Str"",new RouteHandler(){
    @Override public void handle(    Request request,    Response response,    RouteHandlerChain chain){
      int id=request.getParameter(""String_Node_Str"").toInt(0);
      String action=request.getParameter(""String_Node_Str"").toString(""String_Node_Str"");
      if (""String_Node_Str"".equals(action)) {
        contactService.delete(id);
        response.redirect(""String_Node_Str"");
        return;
      }
      Contact contact=(id > 0) ? contactService.getContact(id) : new Contact();
      Map<String,Object> model=new HashMap<String,Object>();
      model.put(""String_Node_Str"",contact);
      StringBuilder editAction=new StringBuilder();
      editAction.append(""String_Node_Str"");
      if (id > 0) {
        editAction.append(""String_Node_Str"");
        editAction.append(id);
      }
      model.put(""String_Node_Str"",editAction);
      model.put(""String_Node_Str"",""String_Node_Str"");
      response.render(""String_Node_Str"",model);
    }
  }
);
  POST(""String_Node_Str"",new RouteHandler(){
    @Override public void handle(    Request request,    Response response,    RouteHandlerChain chain){
      String action=request.getParameter(""String_Node_Str"").toString();
      if (""String_Node_Str"".equals(action)) {
        Contact contact=new Contact();
        contact.setId(request.getParameter(""String_Node_Str"").toInt(-1));
        contact.setName(request.getParameter(""String_Node_Str"").toString());
        contact.setPhone(request.getParameter(""String_Node_Str"").toString());
        contact.setAddress(request.getParameter(""String_Node_Str"").toString());
        contactService.save(contact);
        response.redirect(""String_Node_Str"");
      }
    }
  }
);
  GET(""String_Node_Str"",new RouteHandler(){
    @Override public void handle(    Request request,    Response response,    RouteHandlerChain chain){
      Map<String,Object> model=new HashMap<String,Object>();
      String error=(String)request.getSession().getAttribute(""String_Node_Str"");
      request.getSession().removeAttribute(""String_Node_Str"");
      if (error != null) {
        model.put(""String_Node_Str"",error);
      }
      response.render(""String_Node_Str"",model);
    }
  }
);
  POST(""String_Node_Str"",new RouteHandler(){
    @Override public void handle(    Request request,    Response response,    RouteHandlerChain chain){
      String username=request.getParameter(""String_Node_Str"").toString();
      String password=request.getParameter(""String_Node_Str"").toString();
      if (authenticate(username,password)) {
        request.getSession().setAttribute(""String_Node_Str"",username);
        String originalDestination=(String)request.getSession().getAttribute(""String_Node_Str"");
        response.redirect(originalDestination != null ? originalDestination : ""String_Node_Str"");
      }
 else {
        request.getSession().setAttribute(""String_Node_Str"",""String_Node_Str"");
        response.redirect(""String_Node_Str"");
      }
    }
    private boolean authenticate(    String username,    String password){
      return !username.isEmpty() && !password.isEmpty();
    }
  }
);
}","@Override public void init(){
  super.init();
  contactService=new InMemoryContactService();
  GET(""String_Node_Str"",new RouteHandler(){
    @Override public void handle(    Request request,    Response response,    RouteHandlerChain chain){
      System.out.println(""String_Node_Str"" + request.getUri());
      chain.next();
    }
  }
);
  GET(""String_Node_Str"",new RouteHandler(){
    @Override public void handle(    Request request,    Response response,    RouteHandlerChain chain){
      if (request.getSession().getAttribute(""String_Node_Str"") == null) {
        request.getSession().setAttribute(""String_Node_Str"",request.getUri());
        response.redirect(""String_Node_Str"");
      }
 else {
        chain.next();
      }
    }
  }
);
  GET(""String_Node_Str"",new RouteHandler(){
    @Override public void handle(    Request request,    Response response,    RouteHandlerChain chain){
      response.redirect(""String_Node_Str"");
    }
  }
);
  GET(""String_Node_Str"",new RouteHandler(){
    @Override public void handle(    Request request,    Response response,    RouteHandlerChain chain){
      Map<String,Object> model=new HashMap<String,Object>();
      model.put(""String_Node_Str"",contactService.getContacts());
      response.render(""String_Node_Str"",model);
    }
  }
);
  GET(""String_Node_Str"",new RouteHandler(){
    @Override public void handle(    Request request,    Response response,    RouteHandlerChain chain){
      int id=request.getParameter(""String_Node_Str"").toInt(0);
      String action=request.getParameter(""String_Node_Str"").toString(""String_Node_Str"");
      if (""String_Node_Str"".equals(action)) {
        contactService.delete(id);
        response.redirect(""String_Node_Str"");
        return;
      }
      Contact contact=(id > 0) ? contactService.getContact(id) : new Contact();
      Map<String,Object> model=new HashMap<String,Object>();
      model.put(""String_Node_Str"",contact);
      StringBuilder editAction=new StringBuilder();
      editAction.append(""String_Node_Str"");
      if (id > 0) {
        editAction.append(""String_Node_Str"");
        editAction.append(id);
      }
      model.put(""String_Node_Str"",editAction);
      model.put(""String_Node_Str"",""String_Node_Str"");
      response.render(""String_Node_Str"",model);
    }
  }
);
  POST(""String_Node_Str"",new RouteHandler(){
    @Override public void handle(    Request request,    Response response,    RouteHandlerChain chain){
      String action=request.getParameter(""String_Node_Str"").toString();
      if (""String_Node_Str"".equals(action)) {
        Contact contact=new Contact();
        contact.setId(request.getParameter(""String_Node_Str"").toInt(-1));
        contact.setName(request.getParameter(""String_Node_Str"").toString());
        contact.setPhone(request.getParameter(""String_Node_Str"").toString());
        contact.setAddress(request.getParameter(""String_Node_Str"").toString());
        contactService.save(contact);
        response.redirect(""String_Node_Str"");
      }
    }
  }
);
  GET(""String_Node_Str"",new RouteHandler(){
    @Override public void handle(    Request request,    Response response,    RouteHandlerChain chain){
      Map<String,Object> model=new HashMap<String,Object>();
      String error=(String)request.getSession().getAttribute(""String_Node_Str"");
      request.getSession().removeAttribute(""String_Node_Str"");
      if (error != null) {
        model.put(""String_Node_Str"",error);
      }
      response.render(""String_Node_Str"",model);
    }
  }
);
  POST(""String_Node_Str"",new RouteHandler(){
    @Override public void handle(    Request request,    Response response,    RouteHandlerChain chain){
      String username=request.getParameter(""String_Node_Str"").toString();
      String password=request.getParameter(""String_Node_Str"").toString();
      if (authenticate(username,password)) {
        request.getSession().setAttribute(""String_Node_Str"",username);
        String originalDestination=(String)request.getSession().getAttribute(""String_Node_Str"");
        response.redirect(originalDestination != null ? originalDestination : ""String_Node_Str"");
      }
 else {
        request.getSession().setAttribute(""String_Node_Str"",""String_Node_Str"");
        response.redirect(""String_Node_Str"");
      }
    }
    private boolean authenticate(    String username,    String password){
      return !username.isEmpty() && !password.isEmpty();
    }
  }
);
}"
54917,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_details);
  ViewPager pager=(ViewPager)findViewById(R.id.pager);
  pager.setAdapter(new DetailsFragmentPagerAdapter(getFragmentManager()));
  int currentPosition=getIntent().getIntExtra(EXTRA_CURRENT_ALBUM_POSITION,0);
  pager.setCurrentItem(currentPosition);
  postponeEnterTransition();
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_details);
  ViewPager pager=(ViewPager)findViewById(R.id.pager);
  pager.setAdapter(new DetailsFragmentPagerAdapter(getFragmentManager()));
  mStartingPosition=getIntent().getIntExtra(EXTRA_STARTING_ALBUM_POSITION,0);
  pager.setCurrentItem(mStartingPosition);
  postponeEnterTransition();
}"
54918,"@Override public Fragment getItem(int position){
  return DetailsFragment.newInstance(position);
}","@Override public Fragment getItem(int position){
  return DetailsFragment.newInstance(position,mStartingPosition);
}"
54919,"public static DetailsFragment newInstance(int position){
  Bundle args=new Bundle();
  args.putInt(ARG_SELECTED_IMAGE_POSITION,position);
  DetailsFragment fragment=new DetailsFragment();
  fragment.setArguments(args);
  return fragment;
}","public static DetailsFragment newInstance(int position,int startingPosition){
  Bundle args=new Bundle();
  args.putInt(ARG_ALBUM_IMAGE_POSITION,position);
  args.putInt(ARG_STARTING_ALBUM_IMAGE_POSITION,startingPosition);
  DetailsFragment fragment=new DetailsFragment();
  fragment.setArguments(args);
  return fragment;
}"
54920,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View rootView=inflater.inflate(R.layout.fragment_details,container,false);
  final ImageView albumImage=(ImageView)rootView.findViewById(R.id.details_album_image);
  ImageView backgroundImage=(ImageView)rootView.findViewById(R.id.details_background_image);
  View textContainer=rootView.findViewById(R.id.details_text_container);
  TextView albumTitleText=(TextView)textContainer.findViewById(R.id.details_album_title);
  int selectedPosition=getArguments().getInt(ARG_SELECTED_IMAGE_POSITION);
  String albumImageUrl=ALBUM_IMAGE_URLS[selectedPosition];
  String backgroundImageUrl=BACKGROUND_IMAGE_URLS[selectedPosition];
  String albumName=ALBUM_NAMES[selectedPosition];
  Picasso.with(getActivity()).load(albumImageUrl).fit().centerCrop().into(albumImage);
  Picasso.with(getActivity()).load(backgroundImageUrl).fit().centerCrop().into(backgroundImage);
  albumTitleText.setText(albumName);
  albumImage.setTransitionName(albumName);
  albumImage.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener(){
    @Override public boolean onPreDraw(){
      albumImage.getViewTreeObserver().removeOnPreDrawListener(this);
      getActivity().startPostponedEnterTransition();
      return true;
    }
  }
);
  return rootView;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View rootView=inflater.inflate(R.layout.fragment_details,container,false);
  final ImageView albumImage=(ImageView)rootView.findViewById(R.id.details_album_image);
  ImageView backgroundImage=(ImageView)rootView.findViewById(R.id.details_background_image);
  View textContainer=rootView.findViewById(R.id.details_text_container);
  TextView albumTitleText=(TextView)textContainer.findViewById(R.id.details_album_title);
  int albumPosition=getArguments().getInt(ARG_ALBUM_IMAGE_POSITION);
  String albumImageUrl=ALBUM_IMAGE_URLS[albumPosition];
  String backgroundImageUrl=BACKGROUND_IMAGE_URLS[albumPosition];
  String albumName=ALBUM_NAMES[albumPosition];
  albumImage.setTransitionName(albumName);
  Picasso.with(getActivity()).load(albumImageUrl).fit().centerCrop().into(albumImage);
  Picasso.with(getActivity()).load(backgroundImageUrl).fit().centerCrop().into(backgroundImage);
  albumTitleText.setText(albumName);
  int startingPosition=getArguments().getInt(ARG_STARTING_ALBUM_IMAGE_POSITION);
  if (savedInstanceState == null && albumPosition == startingPosition) {
    albumImage.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener(){
      @Override public boolean onPreDraw(){
        albumImage.getViewTreeObserver().removeOnPreDrawListener(this);
        getActivity().startPostponedEnterTransition();
        return true;
      }
    }
);
  }
  return rootView;
}"
54921,"@Override public void onClick(View v){
  Intent intent=new Intent(MainActivity.this,DetailsActivity.class);
  intent.putExtra(EXTRA_CURRENT_ALBUM_POSITION,mAlbumPosition);
  startActivity(intent,ActivityOptions.makeSceneTransitionAnimation(MainActivity.this,mAlbumImage,mAlbumImage.getTransitionName()).toBundle());
}","@Override public void onClick(View v){
  Intent intent=new Intent(MainActivity.this,DetailsActivity.class);
  intent.putExtra(EXTRA_STARTING_ALBUM_POSITION,mAlbumPosition);
  startActivity(intent,ActivityOptions.makeSceneTransitionAnimation(MainActivity.this,mAlbumImage,mAlbumImage.getTransitionName()).toBundle());
}"
54922,"@Override public void onClick(View v){
  Intent intent=new Intent(MainActivity.this,DetailsActivity.class);
  intent.putExtra(EXTRA_STARTING_ALBUM_POSITION,mAlbumPosition);
  startActivity(intent,ActivityOptions.makeSceneTransitionAnimation(MainActivity.this,mAlbumImage,mAlbumImage.getTransitionName()).toBundle());
}","@Override public void onClick(View v){
  Intent intent=new Intent(MainActivity.this,DetailsActivity.class);
  intent.putExtra(EXTRA_STARTING_ALBUM_POSITION,mAlbumPosition);
  if (!mIsDetailsActivityStarted) {
    mIsDetailsActivityStarted=true;
    startActivity(intent,ActivityOptions.makeSceneTransitionAnimation(MainActivity.this,mAlbumImage,mAlbumImage.getTransitionName()).toBundle());
  }
}"
54923,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_details);
  ViewPager pager=(ViewPager)findViewById(R.id.pager);
  pager.setAdapter(new DetailsFragmentPagerAdapter(getFragmentManager()));
  int currentPosition=getIntent().getIntExtra(EXTRA_CURRENT_ALBUM_POSITION,0);
  pager.setCurrentItem(currentPosition);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_details);
  ViewPager pager=(ViewPager)findViewById(R.id.pager);
  pager.setAdapter(new DetailsFragmentPagerAdapter(getFragmentManager()));
  int currentPosition=getIntent().getIntExtra(EXTRA_CURRENT_ALBUM_POSITION,0);
  pager.setCurrentItem(currentPosition);
  postponeEnterTransition();
}"
54924,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View rootView=inflater.inflate(R.layout.fragment_details,container,false);
  ImageView albumImage=(ImageView)rootView.findViewById(R.id.details_album_image);
  ImageView backgroundImage=(ImageView)rootView.findViewById(R.id.details_background_image);
  View textContainer=rootView.findViewById(R.id.details_text_container);
  TextView albumTitleText=(TextView)textContainer.findViewById(R.id.details_album_title);
  int selectedPosition=getArguments().getInt(ARG_SELECTED_IMAGE_POSITION);
  String albumImageUrl=ALBUM_IMAGE_URLS[selectedPosition];
  String backgroundImageUrl=BACKGROUND_IMAGE_URLS[selectedPosition];
  String albumName=ALBUM_NAMES[selectedPosition];
  Picasso.with(getActivity()).load(albumImageUrl).fit().into(albumImage);
  Picasso.with(getActivity()).load(backgroundImageUrl).fit().centerCrop().into(backgroundImage);
  albumTitleText.setText(albumName);
  albumImage.setTransitionName(albumName);
  return rootView;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  View rootView=inflater.inflate(R.layout.fragment_details,container,false);
  final ImageView albumImage=(ImageView)rootView.findViewById(R.id.details_album_image);
  ImageView backgroundImage=(ImageView)rootView.findViewById(R.id.details_background_image);
  View textContainer=rootView.findViewById(R.id.details_text_container);
  TextView albumTitleText=(TextView)textContainer.findViewById(R.id.details_album_title);
  int selectedPosition=getArguments().getInt(ARG_SELECTED_IMAGE_POSITION);
  String albumImageUrl=ALBUM_IMAGE_URLS[selectedPosition];
  String backgroundImageUrl=BACKGROUND_IMAGE_URLS[selectedPosition];
  String albumName=ALBUM_NAMES[selectedPosition];
  Picasso.with(getActivity()).load(albumImageUrl).fit().into(albumImage);
  Picasso.with(getActivity()).load(backgroundImageUrl).fit().centerCrop().into(backgroundImage);
  albumTitleText.setText(albumName);
  albumImage.setTransitionName(albumName);
  albumImage.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener(){
    @Override public boolean onPreDraw(){
      albumImage.getViewTreeObserver().removeOnPreDrawListener(this);
      getActivity().startPostponedEnterTransition();
      return true;
    }
  }
);
  return rootView;
}"
54925,"@Override public void onSharedElementStart(List<String> sharedElementNames,List<View> sharedElements,List<View> sharedElementSnapshots){
  LOG(""String_Node_Str"",mIsReturning);
  if (!mIsReturning) {
    getWindow().setEnterTransition(makeEnterTransition(sharedElements.get(0)));
  }
}","@Override public void onSharedElementStart(List<String> sharedElementNames,List<View> sharedElements,List<View> sharedElementSnapshots){
  LOG(""String_Node_Str"",mIsReturning);
  if (!mIsReturning) {
    getWindow().setEnterTransition(makeEnterTransition(getSharedElement(sharedElements)));
  }
}"
54926,"@Override public void onSharedElementEnd(List<String> sharedElementNames,List<View> sharedElements,List<View> sharedElementSnapshots){
  LOG(""String_Node_Str"",mIsReentering);
}","@Override public void onSharedElementEnd(List<String> sharedElementNames,List<View> sharedElements,List<View> sharedElementSnapshots){
  LOG(""String_Node_Str"",mIsReentering);
  logSharedElementsInfo(sharedElementNames,sharedElements);
}"
54927,"@Override public boolean onPreDraw(){
  mRecyclerView.getViewTreeObserver().removeOnPreDrawListener(this);
  startPostponedEnterTransition();
  return true;
}","@Override public boolean onPreDraw(){
  mRecyclerView.getViewTreeObserver().removeOnPreDrawListener(this);
  mRecyclerView.requestLayout();
  startPostponedEnterTransition();
  return true;
}"
54928,"@Override public void onActivityReenter(int requestCode,Intent data){
  LOG(""String_Node_Str"",true);
  super.onActivityReenter(requestCode,data);
  mIsReentering=true;
  mTmpState=new Bundle(data.getExtras());
  int oldPosition=mTmpState.getInt(EXTRA_OLD_ITEM_POSITION);
  int currentPosition=mTmpState.getInt(EXTRA_CURRENT_ITEM_POSITION);
  if (oldPosition != currentPosition) {
    mRecyclerView.scrollToPosition(currentPosition);
  }
  postponeEnterTransition();
  mRecyclerView.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener(){
    @Override public boolean onPreDraw(){
      mRecyclerView.getViewTreeObserver().removeOnPreDrawListener(this);
      startPostponedEnterTransition();
      return true;
    }
  }
);
}","@Override public void onActivityReenter(int requestCode,Intent data){
  LOG(""String_Node_Str"",true);
  super.onActivityReenter(requestCode,data);
  mIsReentering=true;
  mTmpState=new Bundle(data.getExtras());
  int oldPosition=mTmpState.getInt(EXTRA_OLD_ITEM_POSITION);
  int currentPosition=mTmpState.getInt(EXTRA_CURRENT_ITEM_POSITION);
  if (oldPosition != currentPosition) {
    mRecyclerView.scrollToPosition(currentPosition);
  }
  postponeEnterTransition();
  mRecyclerView.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener(){
    @Override public boolean onPreDraw(){
      mRecyclerView.getViewTreeObserver().removeOnPreDrawListener(this);
      mRecyclerView.requestLayout();
      startPostponedEnterTransition();
      return true;
    }
  }
);
}"
54929,"@Override public void onSharedElementStart(List<String> sharedElementNames,List<View> sharedElements,List<View> sharedElementSnapshots){
  LOG(""String_Node_Str"",mIsReentering);
}","@Override public void onSharedElementStart(List<String> sharedElementNames,List<View> sharedElements,List<View> sharedElementSnapshots){
  LOG(""String_Node_Str"",mIsReentering);
  logSharedElementsInfo(sharedElementNames,sharedElements);
}"
54930,"@Override public void onMapSharedElements(List<String> names,Map<String,View> sharedElements){
  LOG(""String_Node_Str"",mIsReentering);
  if (mIsReentering) {
    int oldPosition=mTmpState.getInt(EXTRA_OLD_ITEM_POSITION);
    int currentPosition=mTmpState.getInt(EXTRA_CURRENT_ITEM_POSITION);
    if (currentPosition != oldPosition) {
      String newTransitionName=RADIOHEAD_ALBUM_NAMES[currentPosition];
      View newSharedView=mRecyclerView.findViewWithTag(newTransitionName);
      if (newSharedView != null) {
        names.clear();
        names.add(newTransitionName);
        sharedElements.clear();
        sharedElements.put(newTransitionName,newSharedView);
      }
    }
    mTmpState=null;
  }
  View decor=getWindow().getDecorView();
  View navigationBar=decor.findViewById(android.R.id.navigationBarBackground);
  View statusBar=decor.findViewById(android.R.id.statusBarBackground);
  int actionBarId=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  View actionBar=decor.findViewById(actionBarId);
  if (!mIsReentering) {
    if (navigationBar != null) {
      navigationBar.setTransitionName(""String_Node_Str"");
      names.add(navigationBar.getTransitionName());
      sharedElements.put(navigationBar.getTransitionName(),navigationBar);
    }
    if (statusBar != null) {
      statusBar.setTransitionName(""String_Node_Str"");
      names.add(statusBar.getTransitionName());
      sharedElements.put(statusBar.getTransitionName(),statusBar);
    }
    if (actionBar != null) {
      actionBar.setTransitionName(""String_Node_Str"");
      names.add(actionBar.getTransitionName());
      sharedElements.put(actionBar.getTransitionName(),actionBar);
    }
  }
 else {
    names.remove(""String_Node_Str"");
    sharedElements.remove(""String_Node_Str"");
    names.remove(""String_Node_Str"");
    sharedElements.remove(""String_Node_Str"");
    names.remove(""String_Node_Str"");
    sharedElements.remove(""String_Node_Str"");
  }
  LOG(""String_Node_Str"" + names.toString(),mIsReentering);
  LOG(""String_Node_Str"" + Utils.setToString(sharedElements.keySet()),mIsReentering);
}","@Override public void onMapSharedElements(List<String> names,Map<String,View> sharedElements){
  LOG(""String_Node_Str"",mIsReentering);
  if (mIsReentering) {
    int oldPosition=mTmpState.getInt(EXTRA_OLD_ITEM_POSITION);
    int currentPosition=mTmpState.getInt(EXTRA_CURRENT_ITEM_POSITION);
    if (currentPosition != oldPosition) {
      String newTransitionName=RADIOHEAD_ALBUM_NAMES[currentPosition];
      View newSharedView=mRecyclerView.findViewWithTag(newTransitionName);
      if (newSharedView != null) {
        names.clear();
        names.add(newTransitionName);
        sharedElements.clear();
        sharedElements.put(newTransitionName,newSharedView);
      }
    }
    mTmpState=null;
  }
  View decor=getWindow().getDecorView();
  View navigationBar=decor.findViewById(android.R.id.navigationBarBackground);
  View statusBar=decor.findViewById(android.R.id.statusBarBackground);
  int actionBarId=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  View actionBar=decor.findViewById(actionBarId);
  if (!mIsReentering) {
    if (navigationBar != null) {
      names.add(navigationBar.getTransitionName());
      sharedElements.put(navigationBar.getTransitionName(),navigationBar);
    }
    if (statusBar != null) {
      names.add(statusBar.getTransitionName());
      sharedElements.put(statusBar.getTransitionName(),statusBar);
    }
    if (actionBar != null) {
      actionBar.setTransitionName(""String_Node_Str"");
      names.add(actionBar.getTransitionName());
      sharedElements.put(actionBar.getTransitionName(),actionBar);
    }
  }
 else {
    names.remove(Window.NAVIGATION_BAR_BACKGROUND_TRANSITION_NAME);
    sharedElements.remove(Window.NAVIGATION_BAR_BACKGROUND_TRANSITION_NAME);
    names.remove(Window.STATUS_BAR_BACKGROUND_TRANSITION_NAME);
    sharedElements.remove(Window.STATUS_BAR_BACKGROUND_TRANSITION_NAME);
    names.remove(""String_Node_Str"");
    sharedElements.remove(""String_Node_Str"");
  }
  LOG(""String_Node_Str"" + names.toString(),mIsReentering);
  LOG(""String_Node_Str"" + Utils.setToString(sharedElements.keySet()),mIsReentering);
}"
54931,"@Override public void finishAfterTransition(){
  LOG(""String_Node_Str"",true);
  mIsReturning=true;
  getWindow().setReturnTransition(makeReturnTransition());
  Intent data=new Intent();
  data.putExtra(EXTRA_OLD_ITEM_POSITION,getIntent().getIntExtra(EXTRA_CURRENT_ITEM_POSITION,0));
  data.putExtra(EXTRA_CURRENT_ITEM_POSITION,mCurrentPosition);
  setResult(RESULT_OK,data);
  super.finishAfterTransition();
}","@Override public void finishAfterTransition(){
  LOG(""String_Node_Str"",true);
  mIsReturning=true;
  getWindow().setReturnTransition(makeReturnTransition());
  Intent data=new Intent();
  data.putExtra(EXTRA_OLD_ITEM_POSITION,getIntent().getExtras().getInt(EXTRA_CURRENT_ITEM_POSITION));
  data.putExtra(EXTRA_CURRENT_ITEM_POSITION,mCurrentPosition);
  setResult(RESULT_OK,data);
  super.finishAfterTransition();
}"
54932,"@Override public void onActivityReenter(int requestCode,Intent data){
  LOG(""String_Node_Str"",true);
  super.onActivityReenter(requestCode,data);
  mIsReentering=true;
  mTmpState=new Bundle(data.getExtras());
  mRecyclerView.scrollToPosition(mTmpState.getInt(EXTRA_CURRENT_ITEM_POSITION));
  postponeEnterTransition();
  mRecyclerView.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener(){
    @Override public boolean onPreDraw(){
      mRecyclerView.getViewTreeObserver().removeOnPreDrawListener(this);
      startPostponedEnterTransition();
      return true;
    }
  }
);
}","@Override public void onActivityReenter(int requestCode,Intent data){
  LOG(""String_Node_Str"",true);
  super.onActivityReenter(requestCode,data);
  mIsReentering=true;
  mTmpState=new Bundle(data.getExtras());
  int oldPosition=mTmpState.getInt(EXTRA_OLD_ITEM_POSITION);
  int currentPosition=mTmpState.getInt(EXTRA_CURRENT_ITEM_POSITION);
  if (oldPosition != currentPosition) {
    mRecyclerView.scrollToPosition(currentPosition);
  }
  postponeEnterTransition();
  mRecyclerView.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener(){
    @Override public boolean onPreDraw(){
      mRecyclerView.getViewTreeObserver().removeOnPreDrawListener(this);
      startPostponedEnterTransition();
      return true;
    }
  }
);
}"
54933,"@Override public void onMapSharedElements(List<String> names,Map<String,View> sharedElements){
  LOG(""String_Node_Str"",mIsReentering);
  if (mTmpState != null) {
    final int oldPosition=mTmpState.getInt(EXTRA_OLD_ITEM_POSITION);
    final int currentPosition=mTmpState.getInt(EXTRA_CURRENT_ITEM_POSITION);
    if (currentPosition != oldPosition) {
      final String newTransitionName=CAPTIONS[currentPosition];
      final View newSharedView=mRecyclerView.findViewWithTag(newTransitionName);
      if (newSharedView != null) {
        names.clear();
        names.add(newTransitionName);
        sharedElements.clear();
        sharedElements.put(newTransitionName,newSharedView);
      }
    }
  }
  View decor=getWindow().getDecorView();
  View navigationBar=decor.findViewById(android.R.id.navigationBarBackground);
  View statusBar=decor.findViewById(android.R.id.statusBarBackground);
  View actionBar=decor.findViewById(getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  if (!mIsReentering) {
    if (navigationBar != null) {
      names.add(""String_Node_Str"");
      sharedElements.put(""String_Node_Str"",navigationBar);
    }
    if (statusBar != null) {
      names.add(""String_Node_Str"");
      sharedElements.put(""String_Node_Str"",statusBar);
    }
    if (actionBar != null) {
      names.add(""String_Node_Str"");
      sharedElements.put(""String_Node_Str"",actionBar);
    }
  }
 else {
    names.remove(""String_Node_Str"");
    sharedElements.remove(""String_Node_Str"");
    names.remove(""String_Node_Str"");
    sharedElements.remove(""String_Node_Str"");
    names.remove(""String_Node_Str"");
    sharedElements.remove(""String_Node_Str"");
  }
  LOG(""String_Node_Str"" + names.toString(),mIsReentering);
  LOG(""String_Node_Str"" + makeString(sharedElements.keySet()),mIsReentering);
}","@Override public void onMapSharedElements(List<String> names,Map<String,View> sharedElements){
  LOG(""String_Node_Str"",mIsReentering);
  if (mTmpState != null) {
    final int oldPosition=mTmpState.getInt(EXTRA_OLD_ITEM_POSITION);
    final int currentPosition=mTmpState.getInt(EXTRA_CURRENT_ITEM_POSITION);
    if (currentPosition != oldPosition) {
      final String newTransitionName=CAPTIONS[currentPosition];
      final View newSharedView=mRecyclerView.findViewWithTag(newTransitionName);
      if (newSharedView != null) {
        names.clear();
        names.add(newTransitionName);
        sharedElements.clear();
        sharedElements.put(newTransitionName,newSharedView);
      }
    }
  }
  View decor=getWindow().getDecorView();
  View navigationBar=decor.findViewById(android.R.id.navigationBarBackground);
  View statusBar=decor.findViewById(android.R.id.statusBarBackground);
  View actionBar=decor.findViewById(getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  if (!mIsReentering) {
    names.add(""String_Node_Str"");
    sharedElements.put(""String_Node_Str"",navigationBar);
    names.add(""String_Node_Str"");
    sharedElements.put(""String_Node_Str"",statusBar);
    names.add(""String_Node_Str"");
    sharedElements.put(""String_Node_Str"",actionBar);
  }
 else {
    names.remove(""String_Node_Str"");
    sharedElements.remove(""String_Node_Str"");
    names.remove(""String_Node_Str"");
    sharedElements.remove(""String_Node_Str"");
    names.remove(""String_Node_Str"");
    sharedElements.remove(""String_Node_Str"");
  }
  LOG(""String_Node_Str"" + names.toString(),mIsReentering);
  LOG(""String_Node_Str"" + makeString(sharedElements.keySet()),mIsReentering);
}"
54934,"@Override public void onMapSharedElements(List<String> names,Map<String,View> sharedElements){
  LOG(""String_Node_Str"",mIsReturning);
  if (mIsReturning && mCurrentPosition != mOriginalPosition) {
    names.clear();
    sharedElements.clear();
    final View sharedView=mAdapter.getCurrentDetailsFragment().getSharedView();
    if (sharedView == null) {
    }
 else {
      names.add(sharedView.getTransitionName());
      sharedElements.put(sharedView.getTransitionName(),sharedView);
    }
  }
}","@Override public void onMapSharedElements(List<String> names,Map<String,View> sharedElements){
  LOG(""String_Node_Str"",mIsReturning);
  if (mIsReturning && mCurrentPosition != mOriginalPosition) {
    final View sharedView=mAdapter.getCurrentDetailsFragment().getSharedView();
    if (sharedView == null) {
    }
 else {
      names.add(sharedView.getTransitionName());
      sharedElements.put(sharedView.getTransitionName(),sharedView);
    }
  }
  LOG(""String_Node_Str"" + names.toString(),mIsReturning);
  LOG(""String_Node_Str"" + makeString(sharedElements.keySet()),mIsReturning);
}"
54935,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  final View root=inflater.inflate(R.layout.fragment_details,container,false);
  View revealContainer=root.findViewById(R.id.reveal_container);
  ImageView headerImage=(ImageView)revealContainer.findViewById(R.id.header_image);
  ImageView backgroundImage=(ImageView)revealContainer.findViewById(R.id.background_image);
  View infoText=root.findViewById(R.id.text_container);
  TextView titleText=(TextView)infoText.findViewById(R.id.title);
  TextView descText=(TextView)infoText.findViewById(R.id.description);
  int selectedPosition=getArguments().getInt(ARG_SELECTED_IMAGE_POSITION);
  headerImage.setTransitionName(MainActivity.CAPTIONS[selectedPosition]);
  headerImage.setImageResource(MainActivity.IMAGES[selectedPosition]);
  titleText.setText(MainActivity.CAPTIONS[selectedPosition]);
  root.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener(){
    @Override public boolean onPreDraw(){
      root.getViewTreeObserver().removeOnPreDrawListener(this);
      getActivity().startPostponedEnterTransition();
      return true;
    }
  }
);
  int imageResource=BACKGROUND_IMAGES[selectedPosition];
  Bitmap bitmap=BITMAP_CACHE.get(imageResource);
  if (BITMAP_CACHE.get(imageResource) == null) {
    backgroundImage.setImageResource(BACKGROUND_IMAGES[selectedPosition]);
    bitmap=(((BitmapDrawable)backgroundImage.getDrawable()).getBitmap());
    BITMAP_CACHE.put(imageResource,bitmap);
  }
 else {
    backgroundImage.setImageBitmap(bitmap);
  }
  Palette palette=Palette.generate(bitmap,24);
  titleText.setTextColor(palette.getDarkVibrantColor(Color.BLACK));
  descText.setTextColor(palette.getVibrantColor(Color.BLACK));
  infoText.setBackgroundColor(palette.getLightMutedColor(Color.WHITE));
  return root;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  final View root=inflater.inflate(R.layout.fragment_details,container,false);
  View revealContainer=root.findViewById(R.id.reveal_container);
  ImageView headerImage=(ImageView)revealContainer.findViewById(R.id.header_image);
  ImageView backgroundImage=(ImageView)revealContainer.findViewById(R.id.background_image);
  View infoText=root.findViewById(R.id.text_container);
  TextView titleText=(TextView)infoText.findViewById(R.id.title);
  TextView descText=(TextView)infoText.findViewById(R.id.description);
  int selectedPosition=getArguments().getInt(ARG_SELECTED_IMAGE_POSITION);
  headerImage.setTransitionName(MainActivity.CAPTIONS[selectedPosition]);
  headerImage.setImageResource(MainActivity.IMAGES[selectedPosition]);
  titleText.setText(MainActivity.CAPTIONS[selectedPosition]);
  root.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener(){
    @Override public boolean onPreDraw(){
      root.getViewTreeObserver().removeOnPreDrawListener(this);
      getActivity().startPostponedEnterTransition();
      return true;
    }
  }
);
  int imageResource=BACKGROUND_IMAGES[selectedPosition];
  Bitmap bitmap=BITMAP_CACHE.get(imageResource);
  if (BITMAP_CACHE.get(imageResource) == null) {
    backgroundImage.setImageResource(BACKGROUND_IMAGES[selectedPosition]);
    bitmap=(((BitmapDrawable)backgroundImage.getDrawable()).getBitmap());
    BITMAP_CACHE.put(imageResource,bitmap);
  }
 else {
    backgroundImage.setImageBitmap(bitmap);
  }
  return root;
}"
54936,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  Resources res=getResources();
  mRecyclerView=(RecyclerView)findViewById(R.id.recycler_view);
  mRecyclerView.setLayoutManager(new StaggeredGridLayoutManager(res.getInteger(R.integer.num_columns),StaggeredGridLayoutManager.VERTICAL));
  mRecyclerView.setAdapter(new CardAdapter());
  setExitSharedElementCallback(mCallback);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  Resources res=getResources();
  mRecyclerView=(RecyclerView)findViewById(R.id.recycler_view);
  mRecyclerView.setLayoutManager(new GridLayoutManager(this,res.getInteger(R.integer.num_columns)));
  mRecyclerView.setAdapter(new CardAdapter());
  setExitSharedElementCallback(mCallback);
}"
54937,"@Override public void onMapSharedElements(List<String> names,Map<String,View> sharedElements){
  LOG(""String_Node_Str"",mIsReentering);
  if (mTmpState != null) {
    final int oldPosition=mTmpState.getInt(EXTRA_OLD_ITEM_POSITION);
    final int currentPosition=mTmpState.getInt(EXTRA_CURRENT_ITEM_POSITION);
    if (currentPosition != oldPosition) {
      final String newTransitionName=CAPTIONS[currentPosition];
      final View newSharedView=mRecyclerView.findViewWithTag(newTransitionName);
      if (newSharedView != null) {
        names.clear();
        names.add(newTransitionName);
        sharedElements.clear();
        sharedElements.put(newTransitionName,newSharedView);
      }
    }
  }
}","@Override public void onMapSharedElements(List<String> names,Map<String,View> sharedElements){
  LOG(""String_Node_Str"",mIsReentering);
  if (mTmpState != null) {
    final int oldPosition=mTmpState.getInt(EXTRA_OLD_ITEM_POSITION);
    final int currentPosition=mTmpState.getInt(EXTRA_CURRENT_ITEM_POSITION);
    if (currentPosition != oldPosition) {
      final String newTransitionName=CAPTIONS[currentPosition];
      final View newSharedView=mRecyclerView.findViewWithTag(newTransitionName);
      if (newSharedView != null) {
        names.clear();
        names.add(newTransitionName);
        sharedElements.clear();
        sharedElements.put(newTransitionName,newSharedView);
      }
    }
  }
  View decor=getWindow().getDecorView();
  View navigationBar=decor.findViewById(android.R.id.navigationBarBackground);
  View statusBar=decor.findViewById(android.R.id.statusBarBackground);
  View actionBar=decor.findViewById(getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  if (!mIsReentering) {
    if (navigationBar != null) {
      names.add(""String_Node_Str"");
      sharedElements.put(""String_Node_Str"",navigationBar);
    }
    if (statusBar != null) {
      names.add(""String_Node_Str"");
      sharedElements.put(""String_Node_Str"",statusBar);
    }
    if (actionBar != null) {
      names.add(""String_Node_Str"");
      sharedElements.put(""String_Node_Str"",actionBar);
    }
  }
 else {
    names.remove(""String_Node_Str"");
    sharedElements.remove(""String_Node_Str"");
    names.remove(""String_Node_Str"");
    sharedElements.remove(""String_Node_Str"");
    names.remove(""String_Node_Str"");
    sharedElements.remove(""String_Node_Str"");
  }
  LOG(""String_Node_Str"" + names.toString(),mIsReentering);
  LOG(""String_Node_Str"" + makeString(sharedElements.keySet()),mIsReentering);
}"
54938,"@Override public void onClick(View v){
  if (RecommendCardView.class.isInstance(v)) {
    RecommendCardView rcv=(RecommendCardView)v;
    DisplayItem item=rcv.getContentData();
    if (null != item) {
      String target=item.target;
      if (null != target) {
        if (target.equals(""String_Node_Str"")) {
        }
 else         if (target.equals(""String_Node_Str"")) {
        }
 else         if (target.equals(""String_Node_Str"")) {
        }
 else         if (target.equals(""String_Node_Str"")) {
        }
 else {
        }
        Intent intent=new Intent(Intent.ACTION_VIEW);
        intent.setData(Uri.parse(""String_Node_Str"" + item.ns + ""String_Node_Str""+ item.type+ ""String_Node_Str""+ item.id));
        intent.putExtra(""String_Node_Str"",item);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        v.getContext().startActivity(intent);
      }
    }
  }
}","@Override public void onClick(View v){
  if (RecommendCardView.class.isInstance(v)) {
    RecommendCardView rcv=(RecommendCardView)v;
    DisplayItem item=rcv.getContentData();
    if (null != item) {
      DisplayItem.Target target=item.target;
      if (null != target) {
        if (target.type.equals(""String_Node_Str"")) {
        }
 else         if (target.type.equals(""String_Node_Str"")) {
        }
 else         if (target.type.equals(""String_Node_Str"")) {
        }
 else         if (target.type.equals(""String_Node_Str"")) {
        }
 else {
        }
        Intent intent=new Intent(Intent.ACTION_VIEW);
        intent.setData(Uri.parse(""String_Node_Str"" + item.ns + ""String_Node_Str""+ item.type+ ""String_Node_Str""+ item.id));
        intent.putExtra(""String_Node_Str"",item);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        v.getContext().startActivity(intent);
      }
    }
  }
}"
54939,"protected void createTabsLoader(){
  mLoader=new AppTabsGsonLoader(this);
}","protected void createTabsLoader(){
  mLoader=new AppTabsGsonLoader(this,null);
}"
54940,"@Override public void onClick(View v){
  if (RecommendCardView.class.isInstance(v)) {
    RecommendCardView rcv=(RecommendCardView)v;
    DisplayItem item=rcv.getContentData();
    if (null != item) {
      String target=item.target;
      if (null != target) {
        if (target.equals(""String_Node_Str"")) {
        }
 else         if (target.equals(""String_Node_Str"")) {
        }
 else         if (target.equals(""String_Node_Str"")) {
        }
 else         if (target.equals(""String_Node_Str"")) {
        }
 else {
        }
        Intent intent=new Intent(Intent.ACTION_VIEW);
        intent.setData(Uri.parse(""String_Node_Str"" + item.ns + ""String_Node_Str""+ item.type+ ""String_Node_Str""+ item.id));
        intent.putExtra(""String_Node_Str"",item);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        v.getContext().startActivity(intent);
      }
    }
  }
}","@Override public void onClick(View v){
  if (RecommendCardView.class.isInstance(v)) {
    RecommendCardView rcv=(RecommendCardView)v;
    DisplayItem item=rcv.getContentData();
    if (null != item) {
      DisplayItem.Target target=item.target;
      if (null != target) {
        if (target.type.equals(""String_Node_Str"")) {
        }
 else         if (target.type.equals(""String_Node_Str"")) {
        }
 else         if (target.type.equals(""String_Node_Str"")) {
        }
 else         if (target.type.equals(""String_Node_Str"")) {
        }
 else {
        }
        Intent intent=new Intent(Intent.ACTION_VIEW);
        intent.setData(Uri.parse(""String_Node_Str"" + item.ns + ""String_Node_Str""+ item.type+ ""String_Node_Str""+ item.id));
        intent.putExtra(""String_Node_Str"",item);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        v.getContext().startActivity(intent);
      }
    }
  }
}"
54941,"protected void createTabsLoader(){
  mLoader=new GameTabsGsonLoader(this);
}","protected void createTabsLoader(){
  mLoader=new GameTabsGsonLoader(this,null);
}"
54942,"public AppTabsGsonLoader(Context context){
  super(context);
}","public AppTabsGsonLoader(Context context,DisplayItem item){
  super(context,item);
}"
54943,"public GameTabsGsonLoader(Context context){
  super(context);
}","public GameTabsGsonLoader(Context context,DisplayItem item){
  super(context,item);
}"
54944,"@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  if (parent == lv_categories) {
    categoriesCursor.moveToPosition(position);
    String categoryName=categoriesCursor.getString(categoriesCursor.getColumnIndex(BookmarkCategories.COLUMN_NAME_CATEGORY_NAME));
    bt_category.setText(""String_Node_Str"" + categoryName);
    String selection=Bookmarks.COLUMN_NAME_CATEGORY_ID + ""String_Node_Str"";
    String[] selectionArgs={""String_Node_Str"" + id};
    if (bookmarksCursor != null)     bookmarksCursor.close();
    bookmarksCursor=activity.getContentResolver().query(Bookmarks.CONTENT_URI,null,selection,selectionArgs,null);
    bookmarksAdapter.changeCursor(bookmarksCursor);
    fl_list.bringChildToFront(ll_bookmarks_list);
    lv_categories.setVisibility(View.GONE);
    ll_bookmarks_list.setVisibility(View.VISIBLE);
  }
 else   if (parent == lv_bookmarks) {
    bookmarksCursor.moveToPosition(position);
    long newChannelFrequency=bookmarksCursor.getLong(bookmarksCursor.getColumnIndex(Bookmarks.COLUMN_NAME_FREQUENCY));
    int newChannelWidth=bookmarksCursor.getInt(bookmarksCursor.getColumnIndex(Bookmarks.COLUMN_NAME_CHANNEL_WIDTH));
    int newMode=bookmarksCursor.getInt(bookmarksCursor.getColumnIndex(Bookmarks.COLUMN_NAME_MODE));
    int newSquelch=bookmarksCursor.getInt(bookmarksCursor.getColumnIndex(Bookmarks.COLUMN_NAME_SQUELCH));
    boolean ret=rfControlInterface.updateDemodulationMode(newMode);
    long currentFrequency=rfControlInterface.requestCurrentSourceFrequency();
    int currentSampleRate=rfControlInterface.requestCurrentSampleRate();
    if (ret && ((newChannelFrequency - newChannelWidth / 2) < (currentFrequency - currentSampleRate / 2) || (newChannelFrequency + newChannelWidth / 2) > (currentFrequency + currentSampleRate / 2))) {
      Log.d(LOGTAG,""String_Node_Str"" + currentFrequency + ""String_Node_Str""+ newChannelFrequency+ ""String_Node_Str"");
      ret=rfControlInterface.updateSourceFrequency(newChannelFrequency - currentSampleRate / 8);
    }
    if (ret)     ret=rfControlInterface.updateChannelWidth(newChannelWidth);
    if (ret)     ret=rfControlInterface.updateChannelFrequency(newChannelFrequency);
    if (ret)     rfControlInterface.updateSquelch(newSquelch);
    if (ret) {
      dialog.dismiss();
    }
 else {
      Log.i(LOGTAG,""String_Node_Str"");
      Toast.makeText(activity,""String_Node_Str"",Toast.LENGTH_LONG).show();
    }
  }
 else {
    Log.e(LOGTAG,""String_Node_Str"" + parent);
  }
}","@Override public void onItemClick(AdapterView<?> parent,View view,int position,long id){
  if (parent == lv_categories) {
    categoriesCursor.moveToPosition(position);
    String categoryName=categoriesCursor.getString(categoriesCursor.getColumnIndex(BookmarkCategories.COLUMN_NAME_CATEGORY_NAME));
    bt_category.setText(""String_Node_Str"" + categoryName);
    String selection=Bookmarks.COLUMN_NAME_CATEGORY_ID + ""String_Node_Str"";
    String[] selectionArgs={""String_Node_Str"" + id};
    if (bookmarksCursor != null)     bookmarksCursor.close();
    bookmarksCursor=activity.getContentResolver().query(Bookmarks.CONTENT_URI,null,selection,selectionArgs,null);
    bookmarksAdapter.changeCursor(bookmarksCursor);
    fl_list.bringChildToFront(ll_bookmarks_list);
    lv_categories.setVisibility(View.GONE);
    ll_bookmarks_list.setVisibility(View.VISIBLE);
  }
 else   if (parent == lv_bookmarks) {
    bookmarksCursor.moveToPosition(position);
    long newChannelFrequency=bookmarksCursor.getLong(bookmarksCursor.getColumnIndex(Bookmarks.COLUMN_NAME_FREQUENCY));
    int newChannelWidth=bookmarksCursor.getInt(bookmarksCursor.getColumnIndex(Bookmarks.COLUMN_NAME_CHANNEL_WIDTH));
    int newMode=bookmarksCursor.getInt(bookmarksCursor.getColumnIndex(Bookmarks.COLUMN_NAME_MODE));
    int newSquelch=bookmarksCursor.getInt(bookmarksCursor.getColumnIndex(Bookmarks.COLUMN_NAME_SQUELCH));
    int savedDemodulationMode=rfControlInterface.requestCurrentDemodulationMode();
    boolean ret=rfControlInterface.updateDemodulationMode(newMode);
    long currentFrequency=rfControlInterface.requestCurrentSourceFrequency();
    int currentSampleRate=rfControlInterface.requestCurrentSampleRate();
    if (ret && ((newChannelFrequency - newChannelWidth / 2) < (currentFrequency - currentSampleRate / 2) || (newChannelFrequency + newChannelWidth / 2) > (currentFrequency + currentSampleRate / 2))) {
      Log.d(LOGTAG,""String_Node_Str"" + currentFrequency + ""String_Node_Str""+ newChannelFrequency+ ""String_Node_Str"");
      ret=rfControlInterface.updateSourceFrequency(newChannelFrequency - currentSampleRate / 8);
    }
    if (ret)     ret=rfControlInterface.updateChannelWidth(newChannelWidth);
    if (ret)     ret=rfControlInterface.updateChannelFrequency(newChannelFrequency);
    if (ret)     rfControlInterface.updateSquelch(newSquelch);
    if (ret) {
      dialog.dismiss();
    }
 else {
      Log.i(LOGTAG,""String_Node_Str"");
      Toast.makeText(activity,""String_Node_Str"",Toast.LENGTH_LONG).show();
      rfControlInterface.updateDemodulationMode(savedDemodulationMode);
    }
  }
 else {
    Log.e(LOGTAG,""String_Node_Str"" + parent);
  }
}"
54945,"public EditBookmarkDialog(final Activity activity,final long bookmarkID){
  final LinearLayout ll_root=(LinearLayout)activity.getLayoutInflater().inflate(R.layout.edit_bookmark,null);
  final EditText et_name=(EditText)ll_root.findViewById(R.id.et_editBookmark_name);
  final Spinner sp_category=(Spinner)ll_root.findViewById(R.id.sp_editBookmark_category);
  final EditText et_frequency=(EditText)ll_root.findViewById(R.id.et_editBookmark_frequency);
  final EditText et_channelWidth=(EditText)ll_root.findViewById(R.id.et_editBookmark_channelWidth);
  final Spinner sp_mode=(Spinner)ll_root.findViewById(R.id.sp_editBookmark_mode);
  final EditText et_squelch=(EditText)ll_root.findViewById(R.id.et_editBookmark_squelch);
  final EditText et_comment=(EditText)ll_root.findViewById(R.id.et_editBookmark_comment);
  final ArrayAdapter<CharSequence> modeAdapter=ArrayAdapter.createFromResource(activity,R.array.demodulation_modes,android.R.layout.simple_spinner_item);
  modeAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
  sp_mode.setAdapter(modeAdapter);
  final SimpleCursorAdapter categoryAdapter=new SimpleCursorAdapter(activity,android.R.layout.simple_spinner_dropdown_item,categoriesCursor,new String[]{BookmarkCategories.COLUMN_NAME_CATEGORY_NAME},new int[]{android.R.id.text1},0);
  sp_category.setAdapter(categoryAdapter);
  if (bookmarkID >= 0) {
    Cursor cursor=activity.getContentResolver().query(ContentUris.withAppendedId(Bookmarks.CONTENT_URI,bookmarkID),null,null,new String[]{},null);
    cursor.moveToNext();
    et_name.setText(cursor.getString(cursor.getColumnIndex(Bookmarks.COLUMN_NAME_NAME)));
    et_frequency.setText(""String_Node_Str"" + cursor.getLong(cursor.getColumnIndex(Bookmarks.COLUMN_NAME_FREQUENCY)));
    et_channelWidth.setText(""String_Node_Str"" + cursor.getInt(cursor.getColumnIndex(Bookmarks.COLUMN_NAME_CHANNEL_WIDTH)));
    sp_mode.setSelection(cursor.getInt(cursor.getColumnIndex(Bookmarks.COLUMN_NAME_MODE)));
    et_squelch.setText(""String_Node_Str"" + cursor.getFloat(cursor.getColumnIndex(Bookmarks.COLUMN_NAME_SQUELCH)));
    et_comment.setText(cursor.getString(cursor.getColumnIndex(Bookmarks.COLUMN_NAME_COMMENT)));
    int categoryPosition=getPositionOfId(categoriesCursor,cursor.getLong(cursor.getColumnIndex(Bookmarks.COLUMN_NAME_CATEGORY_ID)),BookmarkCategories._ID);
    if (categoryPosition >= 0)     sp_category.setSelection(categoryPosition);
    cursor.close();
  }
 else {
    double frequency=rfControlInterface.requestCurrentChannelFrequency();
    int channelWidth=rfControlInterface.requestCurrentChannelWidth();
    int mode=rfControlInterface.requestCurrentDemodulationMode();
    float squelch=rfControlInterface.requestCurrentSquelch();
    if (frequency < 0)     frequency=100000000;
    if (channelWidth < 0)     channelWidth=0;
    if (squelch < 0)     squelch=-50;
    et_name.setText(""String_Node_Str"");
    et_frequency.setText(""String_Node_Str"" + frequency);
    et_channelWidth.setText(""String_Node_Str"" + channelWidth);
    sp_mode.setSelection(mode);
    et_squelch.setText(""String_Node_Str"" + squelch);
    et_comment.setText(""String_Node_Str"");
  }
  dialog=new AlertDialog.Builder(activity).setTitle(bookmarkID < 0 ? ""String_Node_Str"" : ""String_Node_Str"").setView(ll_root).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
    }
  }
).setPositiveButton(bookmarkID < 0 ? ""String_Node_Str"" : ""String_Node_Str"",new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      String name=et_name.getText().toString();
      long categoryId=sp_category.getSelectedItemId();
      if (et_frequency.getText().length() == 0) {
        Toast.makeText(activity,""String_Node_Str"",Toast.LENGTH_LONG).show();
        return;
      }
      double frequency=Double.valueOf(et_frequency.getText().toString());
      if (frequency < rfControlInterface.requestMaxSourceFrequency() / 1000000)       frequency=frequency * 1000000;
      if (et_channelWidth.getText().length() == 0) {
        Toast.makeText(activity,""String_Node_Str"",Toast.LENGTH_LONG).show();
        return;
      }
      int channelWidth=Integer.valueOf(et_channelWidth.getText().toString());
      int mode=sp_mode.getSelectedItemPosition();
      float squelch=Float.valueOf(et_squelch.getText().toString());
      String comment=et_comment.getText().toString();
      ContentValues values=new ContentValues();
      values.put(Bookmarks.COLUMN_NAME_NAME,name);
      values.put(Bookmarks.COLUMN_NAME_COMMENT,comment);
      values.put(Bookmarks.COLUMN_NAME_CATEGORY_ID,categoryId);
      values.put(Bookmarks.COLUMN_NAME_FREQUENCY,frequency);
      values.put(Bookmarks.COLUMN_NAME_CHANNEL_WIDTH,channelWidth);
      values.put(Bookmarks.COLUMN_NAME_MODE,mode);
      values.put(Bookmarks.COLUMN_NAME_SQUELCH,squelch);
      if (bookmarkID >= 0)       activity.getContentResolver().update(ContentUris.withAppendedId(Bookmarks.CONTENT_URI,bookmarkID),values,null,null);
 else       activity.getContentResolver().insert(Bookmarks.CONTENT_URI,values);
      if (bookmarksCursor != null)       bookmarksCursor.requery();
    }
  }
).create();
  dialog.show();
}","public EditBookmarkDialog(final Activity activity,final long bookmarkID){
  final LinearLayout ll_root=(LinearLayout)activity.getLayoutInflater().inflate(R.layout.edit_bookmark,null);
  final EditText et_name=(EditText)ll_root.findViewById(R.id.et_editBookmark_name);
  final Spinner sp_category=(Spinner)ll_root.findViewById(R.id.sp_editBookmark_category);
  final EditText et_frequency=(EditText)ll_root.findViewById(R.id.et_editBookmark_frequency);
  final EditText et_channelWidth=(EditText)ll_root.findViewById(R.id.et_editBookmark_channelWidth);
  final Spinner sp_mode=(Spinner)ll_root.findViewById(R.id.sp_editBookmark_mode);
  final EditText et_squelch=(EditText)ll_root.findViewById(R.id.et_editBookmark_squelch);
  final EditText et_comment=(EditText)ll_root.findViewById(R.id.et_editBookmark_comment);
  final ArrayAdapter<CharSequence> modeAdapter=ArrayAdapter.createFromResource(activity,R.array.demodulation_modes,android.R.layout.simple_spinner_item);
  modeAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
  sp_mode.setAdapter(modeAdapter);
  final SimpleCursorAdapter categoryAdapter=new SimpleCursorAdapter(activity,android.R.layout.simple_spinner_dropdown_item,categoriesCursor,new String[]{BookmarkCategories.COLUMN_NAME_CATEGORY_NAME},new int[]{android.R.id.text1},0);
  sp_category.setAdapter(categoryAdapter);
  if (bookmarkID >= 0) {
    Cursor cursor=activity.getContentResolver().query(ContentUris.withAppendedId(Bookmarks.CONTENT_URI,bookmarkID),null,null,new String[]{},null);
    cursor.moveToNext();
    et_name.setText(cursor.getString(cursor.getColumnIndex(Bookmarks.COLUMN_NAME_NAME)));
    et_frequency.setText(""String_Node_Str"" + cursor.getLong(cursor.getColumnIndex(Bookmarks.COLUMN_NAME_FREQUENCY)));
    et_channelWidth.setText(""String_Node_Str"" + cursor.getInt(cursor.getColumnIndex(Bookmarks.COLUMN_NAME_CHANNEL_WIDTH)));
    sp_mode.setSelection(cursor.getInt(cursor.getColumnIndex(Bookmarks.COLUMN_NAME_MODE)));
    et_squelch.setText(""String_Node_Str"" + cursor.getFloat(cursor.getColumnIndex(Bookmarks.COLUMN_NAME_SQUELCH)));
    et_comment.setText(cursor.getString(cursor.getColumnIndex(Bookmarks.COLUMN_NAME_COMMENT)));
    int categoryPosition=getPositionOfId(categoriesCursor,cursor.getLong(cursor.getColumnIndex(Bookmarks.COLUMN_NAME_CATEGORY_ID)),BookmarkCategories._ID);
    if (categoryPosition >= 0)     sp_category.setSelection(categoryPosition);
    cursor.close();
  }
 else {
    long frequency=rfControlInterface.requestCurrentChannelFrequency();
    int channelWidth=rfControlInterface.requestCurrentChannelWidth();
    int mode=rfControlInterface.requestCurrentDemodulationMode();
    float squelch=rfControlInterface.requestCurrentSquelch();
    if (frequency < 0)     frequency=100000000;
    if (channelWidth < 0)     channelWidth=0;
    if (squelch < -100 || squelch > 10)     squelch=-30;
    et_name.setText(""String_Node_Str"");
    et_frequency.setText(""String_Node_Str"" + frequency);
    et_channelWidth.setText(""String_Node_Str"" + channelWidth);
    sp_mode.setSelection(mode);
    et_squelch.setText(""String_Node_Str"" + squelch);
    et_comment.setText(""String_Node_Str"");
  }
  new AlertDialog.Builder(activity).setTitle(bookmarkID < 0 ? ""String_Node_Str"" : ""String_Node_Str"").setView(ll_root).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
    }
  }
).setPositiveButton(bookmarkID < 0 ? ""String_Node_Str"" : ""String_Node_Str"",new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      String name=et_name.getText().toString();
      long categoryId=sp_category.getSelectedItemId();
      if (et_frequency.getText().length() == 0) {
        Toast.makeText(activity,""String_Node_Str"",Toast.LENGTH_LONG).show();
        return;
      }
      double frequency=Double.valueOf(et_frequency.getText().toString());
      if (frequency < rfControlInterface.requestMaxSourceFrequency() / 1000000)       frequency=frequency * 1000000;
      if (et_channelWidth.getText().length() == 0) {
        Toast.makeText(activity,""String_Node_Str"",Toast.LENGTH_LONG).show();
        return;
      }
      int channelWidth=Integer.valueOf(et_channelWidth.getText().toString());
      int mode=sp_mode.getSelectedItemPosition();
      float squelch=Float.valueOf(et_squelch.getText().toString());
      String comment=et_comment.getText().toString();
      ContentValues values=new ContentValues();
      values.put(Bookmarks.COLUMN_NAME_NAME,name);
      values.put(Bookmarks.COLUMN_NAME_COMMENT,comment);
      values.put(Bookmarks.COLUMN_NAME_CATEGORY_ID,categoryId);
      values.put(Bookmarks.COLUMN_NAME_FREQUENCY,frequency);
      values.put(Bookmarks.COLUMN_NAME_CHANNEL_WIDTH,channelWidth);
      values.put(Bookmarks.COLUMN_NAME_MODE,mode);
      values.put(Bookmarks.COLUMN_NAME_SQUELCH,squelch);
      if (bookmarkID >= 0)       activity.getContentResolver().update(ContentUris.withAppendedId(Bookmarks.CONTENT_URI,bookmarkID),values,null,null);
 else       activity.getContentResolver().insert(Bookmarks.CONTENT_URI,values);
      if (bookmarksCursor != null)       bookmarksCursor.requery();
    }
  }
).create().show();
}"
54946,"public EditBookmarkCategoryDialog(final Activity activity,final long categoryID){
  final LinearLayout ll_root=(LinearLayout)activity.getLayoutInflater().inflate(R.layout.edit_bookmark_category,null);
  final EditText et_name=(EditText)ll_root.findViewById(R.id.et_editBookmarkCategory_name);
  final EditText et_description=(EditText)ll_root.findViewById(R.id.et_editBookmarkCategory_description);
  if (categoryID >= 0) {
    Cursor cursor=activity.getContentResolver().query(ContentUris.withAppendedId(BookmarkCategories.CONTENT_URI,categoryID),null,null,new String[]{},null);
    cursor.moveToNext();
    et_name.setText(cursor.getString(cursor.getColumnIndex(BookmarkCategories.COLUMN_NAME_CATEGORY_NAME)));
    et_description.setText(cursor.getString(cursor.getColumnIndex(BookmarkCategories.COLUMN_NAME_DESCRIPTION)));
    cursor.close();
  }
 else {
    et_name.setText(""String_Node_Str"");
    et_description.setText(""String_Node_Str"");
  }
  dialog=new AlertDialog.Builder(activity).setTitle(categoryID < 0 ? ""String_Node_Str"" : ""String_Node_Str"").setView(ll_root).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
    }
  }
).setPositiveButton(categoryID < 0 ? ""String_Node_Str"" : ""String_Node_Str"",new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      String name=et_name.getText().toString();
      String comment=et_description.getText().toString();
      ContentValues values=new ContentValues();
      values.put(BookmarkCategories.COLUMN_NAME_CATEGORY_NAME,name);
      values.put(BookmarkCategories.COLUMN_NAME_DESCRIPTION,comment);
      if (categoryID >= 0)       activity.getContentResolver().update(ContentUris.withAppendedId(BookmarkCategories.CONTENT_URI,categoryID),values,null,null);
 else       activity.getContentResolver().insert(BookmarkCategories.CONTENT_URI,values);
      reloadCategories();
    }
  }
).create();
  dialog.show();
}","public EditBookmarkCategoryDialog(final Activity activity,final long categoryID){
  final LinearLayout ll_root=(LinearLayout)activity.getLayoutInflater().inflate(R.layout.edit_bookmark_category,null);
  final EditText et_name=(EditText)ll_root.findViewById(R.id.et_editBookmarkCategory_name);
  final EditText et_description=(EditText)ll_root.findViewById(R.id.et_editBookmarkCategory_description);
  if (categoryID >= 0) {
    Cursor cursor=activity.getContentResolver().query(ContentUris.withAppendedId(BookmarkCategories.CONTENT_URI,categoryID),null,null,new String[]{},null);
    cursor.moveToNext();
    et_name.setText(cursor.getString(cursor.getColumnIndex(BookmarkCategories.COLUMN_NAME_CATEGORY_NAME)));
    et_description.setText(cursor.getString(cursor.getColumnIndex(BookmarkCategories.COLUMN_NAME_DESCRIPTION)));
    cursor.close();
  }
 else {
    et_name.setText(""String_Node_Str"");
    et_description.setText(""String_Node_Str"");
  }
  new AlertDialog.Builder(activity).setTitle(categoryID < 0 ? ""String_Node_Str"" : ""String_Node_Str"").setView(ll_root).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
    }
  }
).setPositiveButton(categoryID < 0 ? ""String_Node_Str"" : ""String_Node_Str"",new DialogInterface.OnClickListener(){
    @Override public void onClick(    DialogInterface dialog,    int which){
      String name=et_name.getText().toString();
      String comment=et_description.getText().toString();
      ContentValues values=new ContentValues();
      values.put(BookmarkCategories.COLUMN_NAME_CATEGORY_NAME,name);
      values.put(BookmarkCategories.COLUMN_NAME_DESCRIPTION,comment);
      if (categoryID >= 0)       activity.getContentResolver().update(ContentUris.withAppendedId(BookmarkCategories.CONTENT_URI,categoryID),values,null,null);
 else       activity.getContentResolver().insert(BookmarkCategories.CONTENT_URI,values);
      reloadCategories();
    }
  }
).create().show();
}"
54947,"@Override public void onRequestPermissionsResult(int requestCode,String permissions[],int[] grantResults){
switch (requestCode) {
case PERMISSION_REQUEST_FILE_SOURCE_READ_FILES:
{
      if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
        if (source != null && source instanceof FileIQSource) {
          if (!source.open(this,this))           Log.e(LOGTAG,""String_Node_Str"");
        }
 else {
          Log.e(LOGTAG,""String_Node_Str"");
        }
      }
    }
case PERMISSION_REQUEST_RECORDING_WRITE_FILES:
{
    if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
      showRecordingDialog();
    }
  }
}
}","@Override public void onRequestPermissionsResult(int requestCode,String permissions[],int[] grantResults){
switch (requestCode) {
case PERMISSION_REQUEST_FILE_SOURCE_READ_FILES:
{
      if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
        if (source != null && source instanceof FileIQSource) {
          if (!source.open(this,this))           Log.e(LOGTAG,""String_Node_Str"");
        }
 else {
          Log.e(LOGTAG,""String_Node_Str"");
        }
      }
      break;
    }
case PERMISSION_REQUEST_RECORDING_WRITE_FILES:
{
    if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
      showRecordingDialog();
    }
    break;
  }
}
}"
54948,"/** 
 * @param enabled true: will prevent the analyzerSurface from re-tune the frequency or change the sample rate.
 */
public void setRecordingEnabled(boolean enabled){
  this.recordingEnabled=enabled;
  virtualFrequency=source.getFrequency();
  virtualSampleRate=source.getSampleRate();
}","/** 
 * @param enabled true: will prevent the analyzerSurface from re-tune the frequency or change the sample rate.
 */
public void setRecordingEnabled(boolean enabled){
  this.recordingEnabled=enabled;
  if (enabled) {
    virtualFrequency=source.getFrequency();
    virtualSampleRate=source.getSampleRate();
  }
}"
54949,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  this.savedInstanceState=savedInstanceState;
  PreferenceManager.setDefaultValues(this,R.xml.preferences,false);
  preferences=PreferenceManager.getDefaultSharedPreferences(this);
  String extStorage=Environment.getExternalStorageDirectory().getAbsolutePath();
  String defaultFile=getString(R.string.pref_filesource_file_default);
  if (preferences.getString(getString(R.string.pref_filesource_file),""String_Node_Str"").equals(defaultFile))   preferences.edit().putString(getString(R.string.pref_filesource_file),extStorage + ""String_Node_Str"" + defaultFile).apply();
  defaultFile=getString(R.string.pref_logfile_default);
  if (preferences.getString(getString(R.string.pref_logfile),""String_Node_Str"").equals(defaultFile))   preferences.edit().putString(getString(R.string.pref_logfile),extStorage + ""String_Node_Str"" + defaultFile).apply();
  if (preferences.getBoolean(getString(R.string.pref_logging),false)) {
    try {
      File logfile=new File(preferences.getString(getString(R.string.pref_logfile),""String_Node_Str""));
      logfile.getParentFile().mkdir();
      logcat=Runtime.getRuntime().exec(""String_Node_Str"" + logfile);
      Log.i(""String_Node_Str"",""String_Node_Str"" + logcat.toString() + ""String_Node_Str""+ logfile);
    }
 catch (    Exception e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
    }
  }
  fl_analyzerFrame=(FrameLayout)findViewById(R.id.fl_analyzerFrame);
  analyzerSurface=new AnalyzerSurface(this,this);
  analyzerSurface.setVerticalScrollEnabled(preferences.getBoolean(getString(R.string.pref_scrollDB),true));
  analyzerSurface.setVerticalZoomEnabled(preferences.getBoolean(getString(R.string.pref_zoomDB),true));
  analyzerSurface.setDecoupledAxis(preferences.getBoolean(getString(R.string.pref_decoupledAxis),false));
  analyzerSurface.setDisplayRelativeFrequencies(preferences.getBoolean(getString(R.string.pref_relativeFrequencies),false));
  analyzerSurface.setWaterfallColorMapType(Integer.valueOf(preferences.getString(getString(R.string.pref_colorMapType),""String_Node_Str"")));
  analyzerSurface.setFftDrawingType(Integer.valueOf(preferences.getString(getString(R.string.pref_fftDrawingType),""String_Node_Str"")));
  analyzerSurface.setFftRatio(Float.valueOf(preferences.getString(getString(R.string.pref_spectrumWaterfallRatio),""String_Node_Str"")));
  analyzerSurface.setFontSize(Integer.valueOf(preferences.getString(getString(R.string.pref_fontSize),""String_Node_Str"")));
  analyzerSurface.setShowDebugInformation(preferences.getBoolean(getString(R.string.pref_showDebugInformation),false));
  fl_analyzerFrame.addView(analyzerSurface);
  if (savedInstanceState != null) {
    running=savedInstanceState.getBoolean(getString(R.string.save_state_running));
    demodulationMode=savedInstanceState.getInt(getString(R.string.save_state_demodulatorMode));
    if (running && Integer.valueOf(preferences.getString(getString(R.string.pref_sourceType),""String_Node_Str"")) == RTLSDR_SOURCE && !preferences.getBoolean(getString(R.string.pref_rtlsdr_externalServer),false)) {
      running=false;
      Toast.makeText(MainActivity.this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
      Thread timer=new Thread(){
        @Override public void run(){
          try {
            Thread.sleep(1500);
            startAnalyzer();
          }
 catch (          InterruptedException e) {
            Log.e(LOGTAG,""String_Node_Str"");
          }
        }
      }
;
      timer.start();
    }
  }
 else {
    running=preferences.getBoolean((getString(R.string.pref_autostart)),false);
  }
  setVolumeControlStream(AudioManager.STREAM_MUSIC);
  getActionBar().setDisplayShowTitleEnabled(false);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  this.savedInstanceState=savedInstanceState;
  PreferenceManager.setDefaultValues(this,R.xml.preferences,false);
  preferences=PreferenceManager.getDefaultSharedPreferences(this);
  String extStorage=Environment.getExternalStorageDirectory().getAbsolutePath();
  String defaultFile=getString(R.string.pref_filesource_file_default);
  if (preferences.getString(getString(R.string.pref_filesource_file),""String_Node_Str"").equals(defaultFile))   preferences.edit().putString(getString(R.string.pref_filesource_file),extStorage + ""String_Node_Str"" + defaultFile).apply();
  defaultFile=getString(R.string.pref_logfile_default);
  if (preferences.getString(getString(R.string.pref_logfile),""String_Node_Str"").equals(defaultFile))   preferences.edit().putString(getString(R.string.pref_logfile),extStorage + ""String_Node_Str"" + defaultFile).apply();
  if (preferences.getBoolean(getString(R.string.pref_logging),false)) {
    try {
      File logfile=new File(preferences.getString(getString(R.string.pref_logfile),""String_Node_Str""));
      logfile.getParentFile().mkdir();
      logcat=Runtime.getRuntime().exec(""String_Node_Str"" + logfile);
      Log.i(""String_Node_Str"",""String_Node_Str"" + logcat.toString() + ""String_Node_Str""+ logfile);
    }
 catch (    Exception e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
    }
  }
  fl_analyzerFrame=(FrameLayout)findViewById(R.id.fl_analyzerFrame);
  analyzerSurface=new AnalyzerSurface(this,this);
  analyzerSurface.setVerticalScrollEnabled(preferences.getBoolean(getString(R.string.pref_scrollDB),true));
  analyzerSurface.setVerticalZoomEnabled(preferences.getBoolean(getString(R.string.pref_zoomDB),true));
  analyzerSurface.setDecoupledAxis(preferences.getBoolean(getString(R.string.pref_decoupledAxis),false));
  analyzerSurface.setDisplayRelativeFrequencies(preferences.getBoolean(getString(R.string.pref_relativeFrequencies),false));
  analyzerSurface.setWaterfallColorMapType(Integer.valueOf(preferences.getString(getString(R.string.pref_colorMapType),""String_Node_Str"")));
  analyzerSurface.setFftDrawingType(Integer.valueOf(preferences.getString(getString(R.string.pref_fftDrawingType),""String_Node_Str"")));
  analyzerSurface.setFftRatio(Float.valueOf(preferences.getString(getString(R.string.pref_spectrumWaterfallRatio),""String_Node_Str"")));
  analyzerSurface.setFontSize(Integer.valueOf(preferences.getString(getString(R.string.pref_fontSize),""String_Node_Str"")));
  analyzerSurface.setShowDebugInformation(preferences.getBoolean(getString(R.string.pref_showDebugInformation),false));
  fl_analyzerFrame.addView(analyzerSurface);
  if (savedInstanceState != null) {
    running=savedInstanceState.getBoolean(getString(R.string.save_state_running));
    demodulationMode=savedInstanceState.getInt(getString(R.string.save_state_demodulatorMode));
    if (running && Integer.valueOf(preferences.getString(getString(R.string.pref_sourceType),""String_Node_Str"")) == RTLSDR_SOURCE && !preferences.getBoolean(getString(R.string.pref_rtlsdr_externalServer),false)) {
      running=false;
      Toast.makeText(MainActivity.this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
      Thread timer=new Thread(){
        @Override public void run(){
          try {
            Thread.sleep(1500);
            startAnalyzer();
          }
 catch (          InterruptedException e) {
            Log.e(LOGTAG,""String_Node_Str"");
          }
        }
      }
;
      timer.start();
    }
  }
 else {
    running=preferences.getBoolean((getString(R.string.pref_autostart)),false);
  }
  setVolumeControlStream(AudioManager.STREAM_MUSIC);
}"
54950,"/** 
 * Will check if any preference conflicts with the current state of the app and fix it
 */
public void checkForChangedPreferences(){
  int sourceType=Integer.valueOf(preferences.getString(getString(R.string.pref_sourceType),""String_Node_Str""));
  if (source != null) {
switch (sourceType) {
case FILE_SOURCE:
      if (!(source instanceof FileIQSource)) {
        source.close();
        createSource();
      }
 else {
        long freq=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_frequency),""String_Node_Str""));
        int sampRate=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_sampleRate),""String_Node_Str""));
        String fileName=preferences.getString(getString(R.string.pref_filesource_file),""String_Node_Str"");
        int fileFormat=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_format),""String_Node_Str""));
        boolean repeat=preferences.getBoolean(getString(R.string.pref_filesource_repeat),false);
        if (freq != source.getFrequency() || sampRate != source.getSampleRate() || !fileName.equals(((FileIQSource)source).getFilename()) || repeat != ((FileIQSource)source).isRepeat() || fileFormat != ((FileIQSource)source).getFileFormat()) {
          source.close();
          createSource();
        }
      }
    break;
case HACKRF_SOURCE:
  if (!(source instanceof HackrfSource)) {
    source.close();
    createSource();
  }
 else {
    boolean amp=preferences.getBoolean(getString(R.string.pref_hackrf_amplifier),false);
    boolean antennaPower=preferences.getBoolean(getString(R.string.pref_hackrf_antennaPower),false);
    int frequencyShift=Integer.valueOf(preferences.getString(getString(R.string.pref_hackrf_frequencyShift),""String_Node_Str""));
    if (((HackrfSource)source).isAmplifierOn() != amp)     ((HackrfSource)source).setAmplifier(amp);
    if (((HackrfSource)source).isAntennaPowerOn() != antennaPower)     ((HackrfSource)source).setAntennaPower(antennaPower);
    if (((HackrfSource)source).getFrequencyShift() != frequencyShift)     ((HackrfSource)source).setFrequencyShift(frequencyShift);
  }
break;
case RTLSDR_SOURCE:
if (!(source instanceof RtlsdrSource)) {
source.close();
createSource();
}
 else {
String ip=preferences.getString(getString(R.string.pref_rtlsdr_ip),""String_Node_Str"");
int port=Integer.valueOf(preferences.getString(getString(R.string.pref_rtlsdr_port),""String_Node_Str""));
boolean externalServer=preferences.getBoolean(getString(R.string.pref_rtlsdr_externalServer),false);
if (externalServer) {
  if (!ip.equals(((RtlsdrSource)source).getIpAddress()) || port != ((RtlsdrSource)source).getPort()) {
    source.close();
    createSource();
    return;
  }
}
 else {
  if (!((RtlsdrSource)source).getIpAddress().equals(""String_Node_Str"") || 1234 != ((RtlsdrSource)source).getPort()) {
    source.close();
    createSource();
    return;
  }
}
int frequencyCorrection=Integer.valueOf(preferences.getString(getString(R.string.pref_rtlsdr_frequencyCorrection),""String_Node_Str""));
int frequencyShift=Integer.valueOf(preferences.getString(getString(R.string.pref_rtlsdr_frequencyShift),""String_Node_Str""));
if (frequencyCorrection != ((RtlsdrSource)source).getFrequencyCorrection()) ((RtlsdrSource)source).setFrequencyCorrection(frequencyCorrection);
if (((RtlsdrSource)source).getFrequencyShift() != frequencyShift) ((RtlsdrSource)source).setFrequencyShift(frequencyShift);
}
break;
default :
}
}
if (analyzerSurface != null) {
analyzerSurface.setVerticalScrollEnabled(preferences.getBoolean(getString(R.string.pref_scrollDB),true));
analyzerSurface.setVerticalZoomEnabled(preferences.getBoolean(getString(R.string.pref_zoomDB),true));
analyzerSurface.setDecoupledAxis(preferences.getBoolean(getString(R.string.pref_decoupledAxis),false));
analyzerSurface.setDisplayRelativeFrequencies(preferences.getBoolean(getString(R.string.pref_relativeFrequencies),false));
analyzerSurface.setWaterfallColorMapType(Integer.valueOf(preferences.getString(getString(R.string.pref_colorMapType),""String_Node_Str"")));
analyzerSurface.setFftDrawingType(Integer.valueOf(preferences.getString(getString(R.string.pref_fftDrawingType),""String_Node_Str"")));
analyzerSurface.setAverageLength(Integer.valueOf(preferences.getString(getString(R.string.pref_averaging),""String_Node_Str"")));
analyzerSurface.setPeakHoldEnabled(preferences.getBoolean(getString(R.string.pref_peakHold),false));
analyzerSurface.setFftRatio(Float.valueOf(preferences.getString(getString(R.string.pref_spectrumWaterfallRatio),""String_Node_Str"")));
analyzerSurface.setFontSize(Integer.valueOf(preferences.getString(getString(R.string.pref_fontSize),""String_Node_Str"")));
analyzerSurface.setShowDebugInformation(preferences.getBoolean(getString(R.string.pref_showDebugInformation),false));
}
String screenOrientation=preferences.getString(getString(R.string.pref_screenOrientation),""String_Node_Str"");
if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);
}","/** 
 * Will check if any preference conflicts with the current state of the app and fix it
 */
public void checkForChangedPreferences(){
  int sourceType=Integer.valueOf(preferences.getString(getString(R.string.pref_sourceType),""String_Node_Str""));
  if (source != null) {
switch (sourceType) {
case FILE_SOURCE:
      if (!(source instanceof FileIQSource)) {
        source.close();
        createSource();
      }
 else {
        long freq=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_frequency),""String_Node_Str""));
        int sampRate=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_sampleRate),""String_Node_Str""));
        String fileName=preferences.getString(getString(R.string.pref_filesource_file),""String_Node_Str"");
        int fileFormat=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_format),""String_Node_Str""));
        boolean repeat=preferences.getBoolean(getString(R.string.pref_filesource_repeat),false);
        if (freq != source.getFrequency() || sampRate != source.getSampleRate() || !fileName.equals(((FileIQSource)source).getFilename()) || repeat != ((FileIQSource)source).isRepeat() || fileFormat != ((FileIQSource)source).getFileFormat()) {
          source.close();
          createSource();
        }
      }
    break;
case HACKRF_SOURCE:
  if (!(source instanceof HackrfSource)) {
    source.close();
    createSource();
  }
 else {
    boolean amp=preferences.getBoolean(getString(R.string.pref_hackrf_amplifier),false);
    boolean antennaPower=preferences.getBoolean(getString(R.string.pref_hackrf_antennaPower),false);
    int frequencyShift=Integer.valueOf(preferences.getString(getString(R.string.pref_hackrf_frequencyShift),""String_Node_Str""));
    if (((HackrfSource)source).isAmplifierOn() != amp)     ((HackrfSource)source).setAmplifier(amp);
    if (((HackrfSource)source).isAntennaPowerOn() != antennaPower)     ((HackrfSource)source).setAntennaPower(antennaPower);
    if (((HackrfSource)source).getFrequencyShift() != frequencyShift)     ((HackrfSource)source).setFrequencyShift(frequencyShift);
  }
break;
case RTLSDR_SOURCE:
if (!(source instanceof RtlsdrSource)) {
source.close();
createSource();
}
 else {
String ip=preferences.getString(getString(R.string.pref_rtlsdr_ip),""String_Node_Str"");
int port=Integer.valueOf(preferences.getString(getString(R.string.pref_rtlsdr_port),""String_Node_Str""));
boolean externalServer=preferences.getBoolean(getString(R.string.pref_rtlsdr_externalServer),false);
if (externalServer) {
  if (!ip.equals(((RtlsdrSource)source).getIpAddress()) || port != ((RtlsdrSource)source).getPort()) {
    source.close();
    createSource();
    return;
  }
}
 else {
  if (!((RtlsdrSource)source).getIpAddress().equals(""String_Node_Str"") || 1234 != ((RtlsdrSource)source).getPort()) {
    source.close();
    createSource();
    return;
  }
}
int frequencyCorrection=Integer.valueOf(preferences.getString(getString(R.string.pref_rtlsdr_frequencyCorrection),""String_Node_Str""));
int frequencyShift=Integer.valueOf(preferences.getString(getString(R.string.pref_rtlsdr_frequencyShift),""String_Node_Str""));
if (frequencyCorrection != ((RtlsdrSource)source).getFrequencyCorrection()) ((RtlsdrSource)source).setFrequencyCorrection(frequencyCorrection);
if (((RtlsdrSource)source).getFrequencyShift() != frequencyShift) ((RtlsdrSource)source).setFrequencyShift(frequencyShift);
}
break;
default :
}
}
if (analyzerSurface != null) {
analyzerSurface.setVerticalScrollEnabled(preferences.getBoolean(getString(R.string.pref_scrollDB),true));
analyzerSurface.setVerticalZoomEnabled(preferences.getBoolean(getString(R.string.pref_zoomDB),true));
analyzerSurface.setDecoupledAxis(preferences.getBoolean(getString(R.string.pref_decoupledAxis),false));
analyzerSurface.setDisplayRelativeFrequencies(preferences.getBoolean(getString(R.string.pref_relativeFrequencies),false));
analyzerSurface.setWaterfallColorMapType(Integer.valueOf(preferences.getString(getString(R.string.pref_colorMapType),""String_Node_Str"")));
analyzerSurface.setFftDrawingType(Integer.valueOf(preferences.getString(getString(R.string.pref_fftDrawingType),""String_Node_Str"")));
analyzerSurface.setAverageLength(Integer.valueOf(preferences.getString(getString(R.string.pref_averaging),""String_Node_Str"")));
analyzerSurface.setPeakHoldEnabled(preferences.getBoolean(getString(R.string.pref_peakHold),false));
analyzerSurface.setFftRatio(Float.valueOf(preferences.getString(getString(R.string.pref_spectrumWaterfallRatio),""String_Node_Str"")));
analyzerSurface.setFontSize(Integer.valueOf(preferences.getString(getString(R.string.pref_fontSize),""String_Node_Str"")));
analyzerSurface.setShowDebugInformation(preferences.getBoolean(getString(R.string.pref_showDebugInformation),false));
}
String screenOrientation=preferences.getString(getString(R.string.pref_screenOrientation),""String_Node_Str"");
if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);
}"
54951,"/** 
 * Will set the screen orientation of the hosting activity
 * @param orientation		auto, landscape, portrait, reverse_landscape or reverse_portrait
 */
public void setScreenOrientation(String orientation){
  if (orientation.equals(""String_Node_Str""))   getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR);
 else   if (orientation.equals(""String_Node_Str""))   getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
 else   if (orientation.equals(""String_Node_Str""))   getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
 else   if (orientation.equals(""String_Node_Str""))   getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);
 else   if (orientation.equals(""String_Node_Str""))   getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);
}","/** 
 * Will set the screen orientation of the hosting activity
 * @param orientation		auto, landscape, portrait, reverse_landscape or reverse_portrait
 */
public void setScreenOrientation(String orientation){
  if (orientation.equals(""String_Node_Str""))   getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
 else   if (orientation.equals(""String_Node_Str""))   getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
 else   if (orientation.equals(""String_Node_Str""))   getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
 else   if (orientation.equals(""String_Node_Str""))   getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);
 else   if (orientation.equals(""String_Node_Str""))   getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);
}"
54952,"/** 
 * Will pop up a dialog to let the user adjust gain settings
 */
private void adjustGain(){
  if (source == null)   return;
  int sourceType=Integer.valueOf(preferences.getString(getString(R.string.pref_sourceType),""String_Node_Str""));
switch (sourceType) {
case FILE_SOURCE:
    Toast.makeText(this,getString(R.string.filesource_doesnt_support_gain),Toast.LENGTH_LONG).show();
  break;
case HACKRF_SOURCE:
final LinearLayout view_hackrf=(LinearLayout)this.getLayoutInflater().inflate(R.layout.hackrf_gain,null);
final SeekBar sb_hackrf_vga=(SeekBar)view_hackrf.findViewById(R.id.sb_hackrf_vga_gain);
final SeekBar sb_hackrf_lna=(SeekBar)view_hackrf.findViewById(R.id.sb_hackrf_lna_gain);
final TextView tv_hackrf_vga=(TextView)view_hackrf.findViewById(R.id.tv_hackrf_vga_gain);
final TextView tv_hackrf_lna=(TextView)view_hackrf.findViewById(R.id.tv_hackrf_lna_gain);
sb_hackrf_vga.setMax(HackrfSource.MAX_VGA_RX_GAIN / HackrfSource.VGA_RX_GAIN_STEP_SIZE);
sb_hackrf_lna.setMax(HackrfSource.MAX_LNA_GAIN / HackrfSource.LNA_GAIN_STEP_SIZE);
sb_hackrf_vga.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
tv_hackrf_vga.setText(""String_Node_Str"" + progress * HackrfSource.VGA_RX_GAIN_STEP_SIZE);
((HackrfSource)source).setVgaRxGain(progress * HackrfSource.VGA_RX_GAIN_STEP_SIZE);
}
@Override public void onStartTrackingTouch(SeekBar seekBar){
}
@Override public void onStopTrackingTouch(SeekBar seekBar){
}
}
);
sb_hackrf_lna.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
tv_hackrf_lna.setText(""String_Node_Str"" + progress * HackrfSource.LNA_GAIN_STEP_SIZE);
((HackrfSource)source).setLnaGain(progress * HackrfSource.LNA_GAIN_STEP_SIZE);
}
@Override public void onStartTrackingTouch(SeekBar seekBar){
}
@Override public void onStopTrackingTouch(SeekBar seekBar){
}
}
);
sb_hackrf_vga.setProgress(((HackrfSource)source).getVgaRxGain() / HackrfSource.VGA_RX_GAIN_STEP_SIZE);
sb_hackrf_lna.setProgress(((HackrfSource)source).getLnaGain() / HackrfSource.LNA_GAIN_STEP_SIZE);
AlertDialog hackrfDialog=new AlertDialog.Builder(this).setTitle(""String_Node_Str"").setView(view_hackrf).setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int whichButton){
SharedPreferences.Editor edit=preferences.edit();
edit.putInt(getString(R.string.pref_hackrf_vgaRxGain),sb_hackrf_vga.getProgress() * HackrfSource.VGA_RX_GAIN_STEP_SIZE);
edit.putInt(getString(R.string.pref_hackrf_lnaGain),sb_hackrf_lna.getProgress() * HackrfSource.LNA_GAIN_STEP_SIZE);
edit.apply();
}
}
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int whichButton){
}
}
).create();
hackrfDialog.setOnDismissListener(new DialogInterface.OnDismissListener(){
@Override public void onDismiss(DialogInterface dialog){
int vgaRxGain=preferences.getInt(getString(R.string.pref_hackrf_vgaRxGain),HackrfSource.MAX_VGA_RX_GAIN / 2);
int lnaGain=preferences.getInt(getString(R.string.pref_hackrf_lnaGain),HackrfSource.MAX_LNA_GAIN / 2);
if (((HackrfSource)source).getVgaRxGain() != vgaRxGain) ((HackrfSource)source).setVgaRxGain(vgaRxGain);
if (((HackrfSource)source).getLnaGain() != lnaGain) ((HackrfSource)source).setLnaGain(lnaGain);
}
}
);
hackrfDialog.show();
hackrfDialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);
break;
case RTLSDR_SOURCE:
final int[] possibleGainValues=((RtlsdrSource)source).getPossibleGainValues();
final int[] possibleIFGainValues=((RtlsdrSource)source).getPossibleIFGainValues();
if (possibleGainValues.length <= 1 && possibleIFGainValues.length <= 1) {
Toast.makeText(MainActivity.this,source.getName() + ""String_Node_Str"",Toast.LENGTH_LONG).show();
}
final LinearLayout view_rtlsdr=(LinearLayout)this.getLayoutInflater().inflate(R.layout.rtlsdr_gain,null);
final LinearLayout ll_rtlsdr_gain=(LinearLayout)view_rtlsdr.findViewById(R.id.ll_rtlsdr_gain);
final LinearLayout ll_rtlsdr_ifgain=(LinearLayout)view_rtlsdr.findViewById(R.id.ll_rtlsdr_ifgain);
final Switch sw_rtlsdr_manual_gain=(Switch)view_rtlsdr.findViewById(R.id.sw_rtlsdr_manual_gain);
final CheckBox cb_rtlsdr_agc=(CheckBox)view_rtlsdr.findViewById(R.id.cb_rtlsdr_agc);
final SeekBar sb_rtlsdr_gain=(SeekBar)view_rtlsdr.findViewById(R.id.sb_rtlsdr_gain);
final SeekBar sb_rtlsdr_ifGain=(SeekBar)view_rtlsdr.findViewById(R.id.sb_rtlsdr_ifgain);
final TextView tv_rtlsdr_gain=(TextView)view_rtlsdr.findViewById(R.id.tv_rtlsdr_gain);
final TextView tv_rtlsdr_ifGain=(TextView)view_rtlsdr.findViewById(R.id.tv_rtlsdr_ifgain);
sw_rtlsdr_manual_gain.setOnCheckedChangeListener(new Switch.OnCheckedChangeListener(){
@Override public void onCheckedChanged(CompoundButton buttonView,boolean isChecked){
sb_rtlsdr_gain.setEnabled(isChecked);
tv_rtlsdr_gain.setEnabled(isChecked);
sb_rtlsdr_ifGain.setEnabled(isChecked);
tv_rtlsdr_ifGain.setEnabled(isChecked);
((RtlsdrSource)source).setManualGain(isChecked);
if (isChecked) {
((RtlsdrSource)source).setGain(possibleGainValues[sb_rtlsdr_gain.getProgress()]);
((RtlsdrSource)source).setIFGain(possibleIFGainValues[sb_rtlsdr_ifGain.getProgress()]);
}
}
}
);
cb_rtlsdr_agc.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
@Override public void onCheckedChanged(CompoundButton buttonView,boolean isChecked){
((RtlsdrSource)source).setAutomaticGainControl(isChecked);
}
}
);
sb_rtlsdr_gain.setMax(possibleGainValues.length - 1);
sb_rtlsdr_ifGain.setMax(possibleIFGainValues.length - 1);
sb_rtlsdr_gain.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
tv_rtlsdr_gain.setText(""String_Node_Str"" + possibleGainValues[progress]);
((RtlsdrSource)source).setGain(possibleGainValues[progress]);
}
@Override public void onStartTrackingTouch(SeekBar seekBar){
}
@Override public void onStopTrackingTouch(SeekBar seekBar){
}
}
);
sb_rtlsdr_ifGain.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
tv_rtlsdr_ifGain.setText(""String_Node_Str"" + possibleIFGainValues[progress]);
((RtlsdrSource)source).setIFGain(possibleIFGainValues[progress]);
}
@Override public void onStartTrackingTouch(SeekBar seekBar){
}
@Override public void onStopTrackingTouch(SeekBar seekBar){
}
}
);
int gainIndex=0;
int ifGainIndex=0;
for (int i=0; i < possibleGainValues.length; i++) {
if (((RtlsdrSource)source).getGain() == possibleGainValues[i]) {
gainIndex=i;
break;
}
}
for (int i=0; i < possibleIFGainValues.length; i++) {
if (((RtlsdrSource)source).getIFGain() == possibleIFGainValues[i]) {
ifGainIndex=i;
break;
}
}
sb_rtlsdr_gain.setProgress(gainIndex);
sb_rtlsdr_ifGain.setProgress(ifGainIndex);
tv_rtlsdr_gain.setText(""String_Node_Str"" + possibleGainValues[gainIndex]);
tv_rtlsdr_ifGain.setText(""String_Node_Str"" + possibleIFGainValues[ifGainIndex]);
sw_rtlsdr_manual_gain.setChecked(((RtlsdrSource)source).isManualGain());
cb_rtlsdr_agc.setChecked(((RtlsdrSource)source).isAutomaticGainControl());
if (possibleGainValues.length <= 1) ll_rtlsdr_gain.setVisibility(View.GONE);
if (possibleIFGainValues.length <= 1) ll_rtlsdr_ifgain.setVisibility(View.GONE);
if (!sw_rtlsdr_manual_gain.isChecked()) {
sb_rtlsdr_gain.setEnabled(false);
tv_rtlsdr_gain.setEnabled(false);
sb_rtlsdr_ifGain.setEnabled(false);
tv_rtlsdr_ifGain.setEnabled(false);
}
AlertDialog rtlsdrDialog=new AlertDialog.Builder(this).setTitle(""String_Node_Str"").setView(view_rtlsdr).setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int whichButton){
SharedPreferences.Editor edit=preferences.edit();
edit.putBoolean(getString(R.string.pref_rtlsdr_manual_gain),sw_rtlsdr_manual_gain.isChecked());
edit.putBoolean(getString(R.string.pref_rtlsdr_agc),cb_rtlsdr_agc.isChecked());
edit.putInt(getString(R.string.pref_rtlsdr_gain),possibleGainValues[sb_rtlsdr_gain.getProgress()]);
edit.putInt(getString(R.string.pref_rtlsdr_ifGain),possibleIFGainValues[sb_rtlsdr_ifGain.getProgress()]);
edit.apply();
}
}
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int whichButton){
}
}
).create();
rtlsdrDialog.setOnDismissListener(new DialogInterface.OnDismissListener(){
@Override public void onDismiss(DialogInterface dialog){
boolean manualGain=preferences.getBoolean(getString(R.string.pref_rtlsdr_manual_gain),false);
boolean agc=preferences.getBoolean(getString(R.string.pref_rtlsdr_agc),false);
int gain=preferences.getInt(getString(R.string.pref_rtlsdr_gain),0);
int ifGain=preferences.getInt(getString(R.string.pref_rtlsdr_ifGain),0);
((RtlsdrSource)source).setGain(gain);
((RtlsdrSource)source).setIFGain(ifGain);
((RtlsdrSource)source).setManualGain(manualGain);
((RtlsdrSource)source).setAutomaticGainControl(agc);
if (manualGain) {
((RtlsdrSource)source).setGain(gain);
((RtlsdrSource)source).setIFGain(ifGain);
}
}
}
);
rtlsdrDialog.show();
rtlsdrDialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);
break;
default :
Log.e(LOGTAG,""String_Node_Str"" + sourceType);
break;
}
}","/** 
 * Will pop up a dialog to let the user adjust gain settings
 */
private void adjustGain(){
  if (source == null)   return;
  int sourceType=Integer.valueOf(preferences.getString(getString(R.string.pref_sourceType),""String_Node_Str""));
switch (sourceType) {
case FILE_SOURCE:
    Toast.makeText(this,getString(R.string.filesource_doesnt_support_gain),Toast.LENGTH_LONG).show();
  break;
case HACKRF_SOURCE:
final LinearLayout view_hackrf=(LinearLayout)this.getLayoutInflater().inflate(R.layout.hackrf_gain,null);
final SeekBar sb_hackrf_vga=(SeekBar)view_hackrf.findViewById(R.id.sb_hackrf_vga_gain);
final SeekBar sb_hackrf_lna=(SeekBar)view_hackrf.findViewById(R.id.sb_hackrf_lna_gain);
final TextView tv_hackrf_vga=(TextView)view_hackrf.findViewById(R.id.tv_hackrf_vga_gain);
final TextView tv_hackrf_lna=(TextView)view_hackrf.findViewById(R.id.tv_hackrf_lna_gain);
sb_hackrf_vga.setMax(HackrfSource.MAX_VGA_RX_GAIN / HackrfSource.VGA_RX_GAIN_STEP_SIZE);
sb_hackrf_lna.setMax(HackrfSource.MAX_LNA_GAIN / HackrfSource.LNA_GAIN_STEP_SIZE);
sb_hackrf_vga.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
tv_hackrf_vga.setText(""String_Node_Str"" + progress * HackrfSource.VGA_RX_GAIN_STEP_SIZE);
((HackrfSource)source).setVgaRxGain(progress * HackrfSource.VGA_RX_GAIN_STEP_SIZE);
}
@Override public void onStartTrackingTouch(SeekBar seekBar){
}
@Override public void onStopTrackingTouch(SeekBar seekBar){
}
}
);
sb_hackrf_lna.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
tv_hackrf_lna.setText(""String_Node_Str"" + progress * HackrfSource.LNA_GAIN_STEP_SIZE);
((HackrfSource)source).setLnaGain(progress * HackrfSource.LNA_GAIN_STEP_SIZE);
}
@Override public void onStartTrackingTouch(SeekBar seekBar){
}
@Override public void onStopTrackingTouch(SeekBar seekBar){
}
}
);
sb_hackrf_vga.setProgress(((HackrfSource)source).getVgaRxGain() / HackrfSource.VGA_RX_GAIN_STEP_SIZE);
sb_hackrf_lna.setProgress(((HackrfSource)source).getLnaGain() / HackrfSource.LNA_GAIN_STEP_SIZE);
AlertDialog hackrfDialog=new AlertDialog.Builder(this).setTitle(""String_Node_Str"").setView(view_hackrf).setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int whichButton){
SharedPreferences.Editor edit=preferences.edit();
edit.putInt(getString(R.string.pref_hackrf_vgaRxGain),sb_hackrf_vga.getProgress() * HackrfSource.VGA_RX_GAIN_STEP_SIZE);
edit.putInt(getString(R.string.pref_hackrf_lnaGain),sb_hackrf_lna.getProgress() * HackrfSource.LNA_GAIN_STEP_SIZE);
edit.apply();
}
}
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int whichButton){
}
}
).create();
hackrfDialog.setOnDismissListener(new DialogInterface.OnDismissListener(){
@Override public void onDismiss(DialogInterface dialog){
int vgaRxGain=preferences.getInt(getString(R.string.pref_hackrf_vgaRxGain),HackrfSource.MAX_VGA_RX_GAIN / 2);
int lnaGain=preferences.getInt(getString(R.string.pref_hackrf_lnaGain),HackrfSource.MAX_LNA_GAIN / 2);
if (((HackrfSource)source).getVgaRxGain() != vgaRxGain) ((HackrfSource)source).setVgaRxGain(vgaRxGain);
if (((HackrfSource)source).getLnaGain() != lnaGain) ((HackrfSource)source).setLnaGain(lnaGain);
}
}
);
hackrfDialog.show();
hackrfDialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);
break;
case RTLSDR_SOURCE:
final int[] possibleGainValues=((RtlsdrSource)source).getPossibleGainValues();
final int[] possibleIFGainValues=((RtlsdrSource)source).getPossibleIFGainValues();
if (possibleGainValues.length <= 1 && possibleIFGainValues.length <= 1) {
Toast.makeText(MainActivity.this,source.getName() + ""String_Node_Str"",Toast.LENGTH_LONG).show();
}
final LinearLayout view_rtlsdr=(LinearLayout)this.getLayoutInflater().inflate(R.layout.rtlsdr_gain,null);
final LinearLayout ll_rtlsdr_gain=(LinearLayout)view_rtlsdr.findViewById(R.id.ll_rtlsdr_gain);
final LinearLayout ll_rtlsdr_ifgain=(LinearLayout)view_rtlsdr.findViewById(R.id.ll_rtlsdr_ifgain);
final Switch sw_rtlsdr_manual_gain=(Switch)view_rtlsdr.findViewById(R.id.sw_rtlsdr_manual_gain);
final CheckBox cb_rtlsdr_agc=(CheckBox)view_rtlsdr.findViewById(R.id.cb_rtlsdr_agc);
final SeekBar sb_rtlsdr_gain=(SeekBar)view_rtlsdr.findViewById(R.id.sb_rtlsdr_gain);
final SeekBar sb_rtlsdr_ifGain=(SeekBar)view_rtlsdr.findViewById(R.id.sb_rtlsdr_ifgain);
final TextView tv_rtlsdr_gain=(TextView)view_rtlsdr.findViewById(R.id.tv_rtlsdr_gain);
final TextView tv_rtlsdr_ifGain=(TextView)view_rtlsdr.findViewById(R.id.tv_rtlsdr_ifgain);
int gainIndex=0;
int ifGainIndex=0;
for (int i=0; i < possibleGainValues.length; i++) {
if (((RtlsdrSource)source).getGain() == possibleGainValues[i]) {
gainIndex=i;
break;
}
}
for (int i=0; i < possibleIFGainValues.length; i++) {
if (((RtlsdrSource)source).getIFGain() == possibleIFGainValues[i]) {
ifGainIndex=i;
break;
}
}
sb_rtlsdr_gain.setMax(possibleGainValues.length - 1);
sb_rtlsdr_ifGain.setMax(possibleIFGainValues.length - 1);
sb_rtlsdr_gain.setProgress(gainIndex);
sb_rtlsdr_ifGain.setProgress(ifGainIndex);
tv_rtlsdr_gain.setText(""String_Node_Str"" + possibleGainValues[gainIndex]);
tv_rtlsdr_ifGain.setText(""String_Node_Str"" + possibleIFGainValues[ifGainIndex]);
sw_rtlsdr_manual_gain.setChecked(((RtlsdrSource)source).isManualGain());
cb_rtlsdr_agc.setChecked(((RtlsdrSource)source).isAutomaticGainControl());
sw_rtlsdr_manual_gain.setOnCheckedChangeListener(new Switch.OnCheckedChangeListener(){
@Override public void onCheckedChanged(CompoundButton buttonView,boolean isChecked){
sb_rtlsdr_gain.setEnabled(isChecked);
tv_rtlsdr_gain.setEnabled(isChecked);
sb_rtlsdr_ifGain.setEnabled(isChecked);
tv_rtlsdr_ifGain.setEnabled(isChecked);
((RtlsdrSource)source).setManualGain(isChecked);
if (isChecked) {
((RtlsdrSource)source).setGain(possibleGainValues[sb_rtlsdr_gain.getProgress()]);
((RtlsdrSource)source).setIFGain(possibleIFGainValues[sb_rtlsdr_ifGain.getProgress()]);
}
}
}
);
cb_rtlsdr_agc.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
@Override public void onCheckedChanged(CompoundButton buttonView,boolean isChecked){
((RtlsdrSource)source).setAutomaticGainControl(isChecked);
}
}
);
sb_rtlsdr_gain.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
tv_rtlsdr_gain.setText(""String_Node_Str"" + possibleGainValues[progress]);
((RtlsdrSource)source).setGain(possibleGainValues[progress]);
}
@Override public void onStartTrackingTouch(SeekBar seekBar){
}
@Override public void onStopTrackingTouch(SeekBar seekBar){
}
}
);
sb_rtlsdr_ifGain.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener(){
@Override public void onProgressChanged(SeekBar seekBar,int progress,boolean fromUser){
tv_rtlsdr_ifGain.setText(""String_Node_Str"" + possibleIFGainValues[progress]);
((RtlsdrSource)source).setIFGain(possibleIFGainValues[progress]);
}
@Override public void onStartTrackingTouch(SeekBar seekBar){
}
@Override public void onStopTrackingTouch(SeekBar seekBar){
}
}
);
if (possibleGainValues.length <= 1) ll_rtlsdr_gain.setVisibility(View.GONE);
if (possibleIFGainValues.length <= 1) ll_rtlsdr_ifgain.setVisibility(View.GONE);
if (!sw_rtlsdr_manual_gain.isChecked()) {
sb_rtlsdr_gain.setEnabled(false);
tv_rtlsdr_gain.setEnabled(false);
sb_rtlsdr_ifGain.setEnabled(false);
tv_rtlsdr_ifGain.setEnabled(false);
}
AlertDialog rtlsdrDialog=new AlertDialog.Builder(this).setTitle(""String_Node_Str"").setView(view_rtlsdr).setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int whichButton){
SharedPreferences.Editor edit=preferences.edit();
edit.putBoolean(getString(R.string.pref_rtlsdr_manual_gain),sw_rtlsdr_manual_gain.isChecked());
edit.putBoolean(getString(R.string.pref_rtlsdr_agc),cb_rtlsdr_agc.isChecked());
edit.putInt(getString(R.string.pref_rtlsdr_gain),possibleGainValues[sb_rtlsdr_gain.getProgress()]);
edit.putInt(getString(R.string.pref_rtlsdr_ifGain),possibleIFGainValues[sb_rtlsdr_ifGain.getProgress()]);
edit.apply();
}
}
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
public void onClick(DialogInterface dialog,int whichButton){
}
}
).create();
rtlsdrDialog.setOnDismissListener(new DialogInterface.OnDismissListener(){
@Override public void onDismiss(DialogInterface dialog){
boolean manualGain=preferences.getBoolean(getString(R.string.pref_rtlsdr_manual_gain),false);
boolean agc=preferences.getBoolean(getString(R.string.pref_rtlsdr_agc),false);
int gain=preferences.getInt(getString(R.string.pref_rtlsdr_gain),0);
int ifGain=preferences.getInt(getString(R.string.pref_rtlsdr_ifGain),0);
((RtlsdrSource)source).setGain(gain);
((RtlsdrSource)source).setIFGain(ifGain);
((RtlsdrSource)source).setManualGain(manualGain);
((RtlsdrSource)source).setAutomaticGainControl(agc);
if (manualGain) {
((RtlsdrSource)source).setGain(gain);
((RtlsdrSource)source).setIFGain(ifGain);
}
}
}
);
rtlsdrDialog.show();
rtlsdrDialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);
break;
default :
Log.e(LOGTAG,""String_Node_Str"" + sourceType);
break;
}
}"
54953,"/** 
 * @param enabled true: will prevent the analyzerSurface from re-tune the frequency or change the sample rate.
 */
public void setRecordingEnabled(boolean enabled){
  this.recordingEnabled=enabled;
  virtualFrequency=source.getFrequency();
  virtualSampleRate=source.getSampleRate();
}","/** 
 * @param enabled true: will prevent the analyzerSurface from re-tune the frequency or change the sample rate.
 */
public void setRecordingEnabled(boolean enabled){
  this.recordingEnabled=enabled;
  if (enabled) {
    virtualFrequency=source.getFrequency();
    virtualSampleRate=source.getSampleRate();
  }
}"
54954,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  this.savedInstanceState=savedInstanceState;
  PreferenceManager.setDefaultValues(this,R.xml.preferences,false);
  preferences=PreferenceManager.getDefaultSharedPreferences(this);
  String extStorage=Environment.getExternalStorageDirectory().getAbsolutePath();
  String defaultFile=getString(R.string.pref_filesource_file_default);
  if (preferences.getString(getString(R.string.pref_filesource_file),""String_Node_Str"").equals(defaultFile))   preferences.edit().putString(getString(R.string.pref_filesource_file),extStorage + ""String_Node_Str"" + defaultFile).apply();
  defaultFile=getString(R.string.pref_logfile_default);
  if (preferences.getString(getString(R.string.pref_logfile),""String_Node_Str"").equals(defaultFile))   preferences.edit().putString(getString(R.string.pref_logfile),extStorage + ""String_Node_Str"" + defaultFile).apply();
  if (preferences.getBoolean(getString(R.string.pref_logging),false)) {
    try {
      File logfile=new File(preferences.getString(getString(R.string.pref_logfile),""String_Node_Str""));
      logfile.getParentFile().mkdir();
      logcat=Runtime.getRuntime().exec(""String_Node_Str"" + logfile);
      Log.i(""String_Node_Str"",""String_Node_Str"" + logcat.toString() + ""String_Node_Str""+ logfile);
    }
 catch (    Exception e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
    }
  }
  fl_analyzerFrame=(FrameLayout)findViewById(R.id.fl_analyzerFrame);
  analyzerSurface=new AnalyzerSurface(this,this);
  analyzerSurface.setVerticalScrollEnabled(preferences.getBoolean(getString(R.string.pref_scrollDB),true));
  analyzerSurface.setVerticalZoomEnabled(preferences.getBoolean(getString(R.string.pref_zoomDB),true));
  analyzerSurface.setDecoupledAxis(preferences.getBoolean(getString(R.string.pref_decoupledAxis),false));
  analyzerSurface.setDisplayRelativeFrequencies(preferences.getBoolean(getString(R.string.pref_relativeFrequencies),false));
  analyzerSurface.setWaterfallColorMapType(Integer.valueOf(preferences.getString(getString(R.string.pref_colorMapType),""String_Node_Str"")));
  analyzerSurface.setFftDrawingType(Integer.valueOf(preferences.getString(getString(R.string.pref_fftDrawingType),""String_Node_Str"")));
  analyzerSurface.setFftRatio(Float.valueOf(preferences.getString(getString(R.string.pref_spectrumWaterfallRatio),""String_Node_Str"")));
  analyzerSurface.setFontSize(Integer.valueOf(preferences.getString(getString(R.string.pref_fontSize),""String_Node_Str"")));
  analyzerSurface.setShowDebugInformation(preferences.getBoolean(getString(R.string.pref_showDebugInformation),false));
  fl_analyzerFrame.addView(analyzerSurface);
  if (savedInstanceState != null) {
    running=savedInstanceState.getBoolean(getString(R.string.save_state_running));
    demodulationMode=savedInstanceState.getInt(getString(R.string.save_state_demodulatorMode));
    if (running && Integer.valueOf(preferences.getString(getString(R.string.pref_sourceType),""String_Node_Str"")) == RTLSDR_SOURCE && !preferences.getBoolean(getString(R.string.pref_rtlsdr_externalServer),false)) {
      running=false;
      Toast.makeText(MainActivity.this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
      Thread timer=new Thread(){
        @Override public void run(){
          try {
            Thread.sleep(1500);
            startAnalyzer();
          }
 catch (          InterruptedException e) {
            Log.e(LOGTAG,""String_Node_Str"");
          }
        }
      }
;
      timer.start();
    }
  }
 else {
    running=preferences.getBoolean((getString(R.string.pref_autostart)),false);
  }
  setVolumeControlStream(AudioManager.STREAM_MUSIC);
  getActionBar().setDisplayShowTitleEnabled(false);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  this.savedInstanceState=savedInstanceState;
  PreferenceManager.setDefaultValues(this,R.xml.preferences,false);
  preferences=PreferenceManager.getDefaultSharedPreferences(this);
  String extStorage=Environment.getExternalStorageDirectory().getAbsolutePath();
  String defaultFile=getString(R.string.pref_filesource_file_default);
  if (preferences.getString(getString(R.string.pref_filesource_file),""String_Node_Str"").equals(defaultFile))   preferences.edit().putString(getString(R.string.pref_filesource_file),extStorage + ""String_Node_Str"" + defaultFile).apply();
  defaultFile=getString(R.string.pref_logfile_default);
  if (preferences.getString(getString(R.string.pref_logfile),""String_Node_Str"").equals(defaultFile))   preferences.edit().putString(getString(R.string.pref_logfile),extStorage + ""String_Node_Str"" + defaultFile).apply();
  if (preferences.getBoolean(getString(R.string.pref_logging),false)) {
    try {
      File logfile=new File(preferences.getString(getString(R.string.pref_logfile),""String_Node_Str""));
      logfile.getParentFile().mkdir();
      logcat=Runtime.getRuntime().exec(""String_Node_Str"" + logfile);
      Log.i(""String_Node_Str"",""String_Node_Str"" + logcat.toString() + ""String_Node_Str""+ logfile);
    }
 catch (    Exception e) {
      Log.e(""String_Node_Str"",""String_Node_Str"");
    }
  }
  fl_analyzerFrame=(FrameLayout)findViewById(R.id.fl_analyzerFrame);
  analyzerSurface=new AnalyzerSurface(this,this);
  analyzerSurface.setVerticalScrollEnabled(preferences.getBoolean(getString(R.string.pref_scrollDB),true));
  analyzerSurface.setVerticalZoomEnabled(preferences.getBoolean(getString(R.string.pref_zoomDB),true));
  analyzerSurface.setDecoupledAxis(preferences.getBoolean(getString(R.string.pref_decoupledAxis),false));
  analyzerSurface.setDisplayRelativeFrequencies(preferences.getBoolean(getString(R.string.pref_relativeFrequencies),false));
  analyzerSurface.setWaterfallColorMapType(Integer.valueOf(preferences.getString(getString(R.string.pref_colorMapType),""String_Node_Str"")));
  analyzerSurface.setFftDrawingType(Integer.valueOf(preferences.getString(getString(R.string.pref_fftDrawingType),""String_Node_Str"")));
  analyzerSurface.setFftRatio(Float.valueOf(preferences.getString(getString(R.string.pref_spectrumWaterfallRatio),""String_Node_Str"")));
  analyzerSurface.setFontSize(Integer.valueOf(preferences.getString(getString(R.string.pref_fontSize),""String_Node_Str"")));
  analyzerSurface.setShowDebugInformation(preferences.getBoolean(getString(R.string.pref_showDebugInformation),false));
  fl_analyzerFrame.addView(analyzerSurface);
  if (savedInstanceState != null) {
    running=savedInstanceState.getBoolean(getString(R.string.save_state_running));
    demodulationMode=savedInstanceState.getInt(getString(R.string.save_state_demodulatorMode));
    if (running && Integer.valueOf(preferences.getString(getString(R.string.pref_sourceType),""String_Node_Str"")) == RTLSDR_SOURCE && !preferences.getBoolean(getString(R.string.pref_rtlsdr_externalServer),false)) {
      running=false;
      Toast.makeText(MainActivity.this,""String_Node_Str"",Toast.LENGTH_SHORT).show();
      Thread timer=new Thread(){
        @Override public void run(){
          try {
            Thread.sleep(1500);
            startAnalyzer();
          }
 catch (          InterruptedException e) {
            Log.e(LOGTAG,""String_Node_Str"");
          }
        }
      }
;
      timer.start();
    }
  }
 else {
    running=preferences.getBoolean((getString(R.string.pref_autostart)),false);
  }
  setVolumeControlStream(AudioManager.STREAM_MUSIC);
}"
54955,"/** 
 * Will check if any preference conflicts with the current state of the app and fix it
 */
public void checkForChangedPreferences(){
  int sourceType=Integer.valueOf(preferences.getString(getString(R.string.pref_sourceType),""String_Node_Str""));
  if (source != null) {
switch (sourceType) {
case FILE_SOURCE:
      if (!(source instanceof FileIQSource)) {
        source.close();
        createSource();
      }
 else {
        long freq=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_frequency),""String_Node_Str""));
        int sampRate=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_sampleRate),""String_Node_Str""));
        String fileName=preferences.getString(getString(R.string.pref_filesource_file),""String_Node_Str"");
        int fileFormat=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_format),""String_Node_Str""));
        boolean repeat=preferences.getBoolean(getString(R.string.pref_filesource_repeat),false);
        if (freq != source.getFrequency() || sampRate != source.getSampleRate() || !fileName.equals(((FileIQSource)source).getFilename()) || repeat != ((FileIQSource)source).isRepeat() || fileFormat != ((FileIQSource)source).getFileFormat()) {
          source.close();
          createSource();
        }
      }
    break;
case HACKRF_SOURCE:
  if (!(source instanceof HackrfSource)) {
    source.close();
    createSource();
  }
 else {
    boolean amp=preferences.getBoolean(getString(R.string.pref_hackrf_amplifier),false);
    boolean antennaPower=preferences.getBoolean(getString(R.string.pref_hackrf_antennaPower),false);
    int frequencyShift=Integer.valueOf(preferences.getString(getString(R.string.pref_hackrf_frequencyShift),""String_Node_Str""));
    if (((HackrfSource)source).isAmplifierOn() != amp)     ((HackrfSource)source).setAmplifier(amp);
    if (((HackrfSource)source).isAntennaPowerOn() != antennaPower)     ((HackrfSource)source).setAntennaPower(antennaPower);
    if (((HackrfSource)source).getFrequencyShift() != frequencyShift)     ((HackrfSource)source).setFrequencyShift(frequencyShift);
  }
break;
case RTLSDR_SOURCE:
if (!(source instanceof RtlsdrSource)) {
source.close();
createSource();
}
 else {
String ip=preferences.getString(getString(R.string.pref_rtlsdr_ip),""String_Node_Str"");
int port=Integer.valueOf(preferences.getString(getString(R.string.pref_rtlsdr_port),""String_Node_Str""));
boolean externalServer=preferences.getBoolean(getString(R.string.pref_rtlsdr_externalServer),false);
if (externalServer) {
  if (!ip.equals(((RtlsdrSource)source).getIpAddress()) || port != ((RtlsdrSource)source).getPort()) {
    source.close();
    createSource();
    return;
  }
}
 else {
  if (!((RtlsdrSource)source).getIpAddress().equals(""String_Node_Str"") || 1234 != ((RtlsdrSource)source).getPort()) {
    source.close();
    createSource();
    return;
  }
}
int frequencyCorrection=Integer.valueOf(preferences.getString(getString(R.string.pref_rtlsdr_frequencyCorrection),""String_Node_Str""));
int frequencyShift=Integer.valueOf(preferences.getString(getString(R.string.pref_rtlsdr_frequencyShift),""String_Node_Str""));
if (frequencyCorrection != ((RtlsdrSource)source).getFrequencyCorrection()) ((RtlsdrSource)source).setFrequencyCorrection(frequencyCorrection);
if (((RtlsdrSource)source).getFrequencyShift() != frequencyShift) ((RtlsdrSource)source).setFrequencyShift(frequencyShift);
}
break;
default :
}
}
if (analyzerSurface != null) {
analyzerSurface.setVerticalScrollEnabled(preferences.getBoolean(getString(R.string.pref_scrollDB),true));
analyzerSurface.setVerticalZoomEnabled(preferences.getBoolean(getString(R.string.pref_zoomDB),true));
analyzerSurface.setDecoupledAxis(preferences.getBoolean(getString(R.string.pref_decoupledAxis),false));
analyzerSurface.setDisplayRelativeFrequencies(preferences.getBoolean(getString(R.string.pref_relativeFrequencies),false));
analyzerSurface.setWaterfallColorMapType(Integer.valueOf(preferences.getString(getString(R.string.pref_colorMapType),""String_Node_Str"")));
analyzerSurface.setFftDrawingType(Integer.valueOf(preferences.getString(getString(R.string.pref_fftDrawingType),""String_Node_Str"")));
analyzerSurface.setAverageLength(Integer.valueOf(preferences.getString(getString(R.string.pref_averaging),""String_Node_Str"")));
analyzerSurface.setPeakHoldEnabled(preferences.getBoolean(getString(R.string.pref_peakHold),false));
analyzerSurface.setFftRatio(Float.valueOf(preferences.getString(getString(R.string.pref_spectrumWaterfallRatio),""String_Node_Str"")));
analyzerSurface.setFontSize(Integer.valueOf(preferences.getString(getString(R.string.pref_fontSize),""String_Node_Str"")));
analyzerSurface.setShowDebugInformation(preferences.getBoolean(getString(R.string.pref_showDebugInformation),false));
}
String screenOrientation=preferences.getString(getString(R.string.pref_screenOrientation),""String_Node_Str"");
if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);
}","/** 
 * Will check if any preference conflicts with the current state of the app and fix it
 */
public void checkForChangedPreferences(){
  int sourceType=Integer.valueOf(preferences.getString(getString(R.string.pref_sourceType),""String_Node_Str""));
  if (source != null) {
switch (sourceType) {
case FILE_SOURCE:
      if (!(source instanceof FileIQSource)) {
        source.close();
        createSource();
      }
 else {
        long freq=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_frequency),""String_Node_Str""));
        int sampRate=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_sampleRate),""String_Node_Str""));
        String fileName=preferences.getString(getString(R.string.pref_filesource_file),""String_Node_Str"");
        int fileFormat=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_format),""String_Node_Str""));
        boolean repeat=preferences.getBoolean(getString(R.string.pref_filesource_repeat),false);
        if (freq != source.getFrequency() || sampRate != source.getSampleRate() || !fileName.equals(((FileIQSource)source).getFilename()) || repeat != ((FileIQSource)source).isRepeat() || fileFormat != ((FileIQSource)source).getFileFormat()) {
          source.close();
          createSource();
        }
      }
    break;
case HACKRF_SOURCE:
  if (!(source instanceof HackrfSource)) {
    source.close();
    createSource();
  }
 else {
    boolean amp=preferences.getBoolean(getString(R.string.pref_hackrf_amplifier),false);
    boolean antennaPower=preferences.getBoolean(getString(R.string.pref_hackrf_antennaPower),false);
    int frequencyShift=Integer.valueOf(preferences.getString(getString(R.string.pref_hackrf_frequencyShift),""String_Node_Str""));
    if (((HackrfSource)source).isAmplifierOn() != amp)     ((HackrfSource)source).setAmplifier(amp);
    if (((HackrfSource)source).isAntennaPowerOn() != antennaPower)     ((HackrfSource)source).setAntennaPower(antennaPower);
    if (((HackrfSource)source).getFrequencyShift() != frequencyShift)     ((HackrfSource)source).setFrequencyShift(frequencyShift);
  }
break;
case RTLSDR_SOURCE:
if (!(source instanceof RtlsdrSource)) {
source.close();
createSource();
}
 else {
String ip=preferences.getString(getString(R.string.pref_rtlsdr_ip),""String_Node_Str"");
int port=Integer.valueOf(preferences.getString(getString(R.string.pref_rtlsdr_port),""String_Node_Str""));
boolean externalServer=preferences.getBoolean(getString(R.string.pref_rtlsdr_externalServer),false);
if (externalServer) {
  if (!ip.equals(((RtlsdrSource)source).getIpAddress()) || port != ((RtlsdrSource)source).getPort()) {
    source.close();
    createSource();
    return;
  }
}
 else {
  if (!((RtlsdrSource)source).getIpAddress().equals(""String_Node_Str"") || 1234 != ((RtlsdrSource)source).getPort()) {
    source.close();
    createSource();
    return;
  }
}
int frequencyCorrection=Integer.valueOf(preferences.getString(getString(R.string.pref_rtlsdr_frequencyCorrection),""String_Node_Str""));
int frequencyShift=Integer.valueOf(preferences.getString(getString(R.string.pref_rtlsdr_frequencyShift),""String_Node_Str""));
if (frequencyCorrection != ((RtlsdrSource)source).getFrequencyCorrection()) ((RtlsdrSource)source).setFrequencyCorrection(frequencyCorrection);
if (((RtlsdrSource)source).getFrequencyShift() != frequencyShift) ((RtlsdrSource)source).setFrequencyShift(frequencyShift);
}
break;
default :
}
}
if (analyzerSurface != null) {
analyzerSurface.setVerticalScrollEnabled(preferences.getBoolean(getString(R.string.pref_scrollDB),true));
analyzerSurface.setVerticalZoomEnabled(preferences.getBoolean(getString(R.string.pref_zoomDB),true));
analyzerSurface.setDecoupledAxis(preferences.getBoolean(getString(R.string.pref_decoupledAxis),false));
analyzerSurface.setDisplayRelativeFrequencies(preferences.getBoolean(getString(R.string.pref_relativeFrequencies),false));
analyzerSurface.setWaterfallColorMapType(Integer.valueOf(preferences.getString(getString(R.string.pref_colorMapType),""String_Node_Str"")));
analyzerSurface.setFftDrawingType(Integer.valueOf(preferences.getString(getString(R.string.pref_fftDrawingType),""String_Node_Str"")));
analyzerSurface.setAverageLength(Integer.valueOf(preferences.getString(getString(R.string.pref_averaging),""String_Node_Str"")));
analyzerSurface.setPeakHoldEnabled(preferences.getBoolean(getString(R.string.pref_peakHold),false));
analyzerSurface.setFftRatio(Float.valueOf(preferences.getString(getString(R.string.pref_spectrumWaterfallRatio),""String_Node_Str"")));
analyzerSurface.setFontSize(Integer.valueOf(preferences.getString(getString(R.string.pref_fontSize),""String_Node_Str"")));
analyzerSurface.setShowDebugInformation(preferences.getBoolean(getString(R.string.pref_showDebugInformation),false));
}
String screenOrientation=preferences.getString(getString(R.string.pref_screenOrientation),""String_Node_Str"");
if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);
}"
54956,"/** 
 * Will set the screen orientation of the hosting activity
 * @param orientation		auto, landscape, portrait, reverse_landscape or reverse_portrait
 */
public void setScreenOrientation(String orientation){
  if (orientation.equals(""String_Node_Str""))   getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR);
 else   if (orientation.equals(""String_Node_Str""))   getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
 else   if (orientation.equals(""String_Node_Str""))   getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
 else   if (orientation.equals(""String_Node_Str""))   getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);
 else   if (orientation.equals(""String_Node_Str""))   getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);
}","/** 
 * Will set the screen orientation of the hosting activity
 * @param orientation		auto, landscape, portrait, reverse_landscape or reverse_portrait
 */
public void setScreenOrientation(String orientation){
  if (orientation.equals(""String_Node_Str""))   getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED);
 else   if (orientation.equals(""String_Node_Str""))   getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
 else   if (orientation.equals(""String_Node_Str""))   getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
 else   if (orientation.equals(""String_Node_Str""))   getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);
 else   if (orientation.equals(""String_Node_Str""))   getActivity().setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);
}"
54957,"@Override public void onUpdateSquelchSatisfied(boolean squelchSatisfied){
  scheduler.setSquelchSatisfied(squelchSatisfied);
}","@Override public void onUpdateSquelchSatisfied(boolean squelchSatisfied){
  if (scheduler != null)   scheduler.setSquelchSatisfied(squelchSatisfied);
}"
54958,"/** 
 * Called by the analyzer surface after the user changed the channel width
 * @param newChannelWidth    new channel width (single sided) in Hz
 * @return true if channel width is valid; false if out of range
 */
@Override public boolean onUpdateChannelWidth(int newChannelWidth){
  return demodulator.setChannelWidth(newChannelWidth);
}","/** 
 * Called by the analyzer surface after the user changed the channel width
 * @param newChannelWidth    new channel width (single sided) in Hz
 * @return true if channel width is valid; false if out of range
 */
@Override public boolean onUpdateChannelWidth(int newChannelWidth){
  if (demodulator != null)   return demodulator.setChannelWidth(newChannelWidth);
 else   return false;
}"
54959,"@Override public void onUpdateChannelFrequency(long newChannelFrequency){
  scheduler.setChannelFrequency(newChannelFrequency);
}","@Override public void onUpdateChannelFrequency(long newChannelFrequency){
  if (scheduler != null)   scheduler.setChannelFrequency(newChannelFrequency);
}"
54960,"@Override public void run(){
  SamplePacket inputSamples=null;
  SamplePacket audioBuffer=null;
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
  audioSink.start();
  decimator.start();
  while (!stopRequested) {
    inputSamples=decimator.getDecimatedPacket(1000);
    if (inputSamples == null) {
      continue;
    }
    applyUserFilter(inputSamples,quadratureSamples);
    decimator.returnDecimatedPacket(inputSamples);
    audioBuffer=audioSink.getPacketBuffer(1000);
switch (demodulationMode) {
case DEMODULATION_OFF:
      break;
case DEMODULATION_AM:
    demodulateAM(quadratureSamples,audioBuffer);
  break;
case DEMODULATION_NFM:
demodulateFM(quadratureSamples,audioBuffer,5000);
break;
case DEMODULATION_WFM:
demodulateFM(quadratureSamples,audioBuffer,75000);
break;
case DEMODULATION_LSB:
demodulateSSB(quadratureSamples,audioBuffer,false);
break;
case DEMODULATION_USB:
demodulateSSB(quadratureSamples,audioBuffer,true);
break;
default :
Log.e(LOGTAG,""String_Node_Str"" + demodulationMode);
}
audioSink.enqueuePacket(audioBuffer);
}
audioSink.stopSink();
decimator.stopDecimator();
this.stopRequested=true;
Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
}","@Override public void run(){
  SamplePacket inputSamples=null;
  SamplePacket audioBuffer=null;
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
  audioSink.start();
  decimator.start();
  while (!stopRequested) {
    inputSamples=decimator.getDecimatedPacket(1000);
    if (inputSamples == null) {
      continue;
    }
    applyUserFilter(inputSamples,quadratureSamples);
    decimator.returnDecimatedPacket(inputSamples);
    audioBuffer=audioSink.getPacketBuffer(1000);
    if (audioBuffer == null) {
      Log.d(LOGTAG,""String_Node_Str"");
      continue;
    }
switch (demodulationMode) {
case DEMODULATION_OFF:
      break;
case DEMODULATION_AM:
    demodulateAM(quadratureSamples,audioBuffer);
  break;
case DEMODULATION_NFM:
demodulateFM(quadratureSamples,audioBuffer,5000);
break;
case DEMODULATION_WFM:
demodulateFM(quadratureSamples,audioBuffer,75000);
break;
case DEMODULATION_LSB:
demodulateSSB(quadratureSamples,audioBuffer,false);
break;
case DEMODULATION_USB:
demodulateSSB(quadratureSamples,audioBuffer,true);
break;
default :
Log.e(LOGTAG,""String_Node_Str"" + demodulationMode);
}
audioSink.enqueuePacket(audioBuffer);
}
audioSink.stopSink();
decimator.stopDecimator();
this.stopRequested=true;
Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
}"
54961,"/** 
 * Set the font size
 * @param fontSize FONT_SIZE_SMALL, *_MEDIUM or *_LARGE
 */
public void setFontSize(int fontSize){
  int normalTextSize;
  int smallTextSize;
switch (fontSize) {
case FONT_SIZE_SMALL:
    normalTextSize=(int)(getGridSize() * 0.3);
  smallTextSize=(int)(getGridSize() * 0.2);
break;
case FONT_SIZE_MEDIUM:
normalTextSize=(int)(getGridSize() * 0.476);
smallTextSize=(int)(getGridSize() * 0.25);
break;
case FONT_SIZE_LARGE:
normalTextSize=(int)(getGridSize() * 0.7);
smallTextSize=(int)(getGridSize() * 0.35);
break;
default :
Log.e(LOGTAG,""String_Node_Str"" + fontSize);
return;
}
this.fontSize=fontSize;
this.textPaint.setTextSize(normalTextSize);
this.textSmallPaint.setTextSize(smallTextSize);
Log.i(LOGTAG,""String_Node_Str"" + getResources().getDisplayMetrics().xdpi + ""String_Node_Str""+ fontSize+ ""String_Node_Str""+ normalTextSize+ ""String_Node_Str""+ smallTextSize);
}","/** 
 * Set the font size
 * @param fontSize FONT_SIZE_SMALL, *_MEDIUM or *_LARGE
 */
public void setFontSize(int fontSize){
  int normalTextSize;
  int smallTextSize;
switch (fontSize) {
case FONT_SIZE_SMALL:
    normalTextSize=(int)(getGridSize() * 0.3);
  smallTextSize=(int)(getGridSize() * 0.2);
break;
case FONT_SIZE_MEDIUM:
normalTextSize=(int)(getGridSize() * 0.476);
smallTextSize=(int)(getGridSize() * 0.25);
break;
case FONT_SIZE_LARGE:
normalTextSize=(int)(getGridSize() * 0.7);
smallTextSize=(int)(getGridSize() * 0.35);
break;
default :
Log.e(LOGTAG,""String_Node_Str"" + fontSize);
return;
}
this.fontSize=fontSize;
this.textPaint.setTextSize(normalTextSize);
this.textSmallPaint.setTextSize(smallTextSize);
Log.i(LOGTAG,""String_Node_Str"" + getResources().getDisplayMetrics().xdpi + ""String_Node_Str""+ getResources().getDisplayMetrics().widthPixels+ ""String_Node_Str""+ fontSize+ ""String_Node_Str""+ normalTextSize+ ""String_Node_Str""+ smallTextSize);
}"
54962,"/** 
 * This method will draw the performance information into the canvas
 * @param c				canvas of the surface view
 * @param frameRate 	current frame rate (FPS)
 * @param load			current load (percentage [0..1])
 * @param averageSignalStrength		average magnitude of the signal in the selected channel
 */
private void drawPerformanceInfo(Canvas c,int frameRate,double load,float averageSignalStrength){
  Rect bounds=new Rect();
  String text;
  float yPos=height * 0.01f;
  float rightBorder=width * 0.99f;
  if (demodulationEnabled) {
    text=String.format(""String_Node_Str"",channelFrequency / 1000000f);
    textSmallPaint.getTextBounds(text,0,text.length(),bounds);
    c.drawText(text,rightBorder - bounds.width(),yPos + bounds.height(),textSmallPaint);
    yPos+=bounds.height() * 1.1f;
  }
  if (demodulationEnabled) {
    text=String.format(""String_Node_Str"",averageSignalStrength);
    textSmallPaint.getTextBounds(text,0,text.length(),bounds);
    float indicatorWidth=width / 10;
    float indicatorPosX=rightBorder - indicatorWidth;
    float indicatorPosY=yPos + bounds.height();
    float squelchTickPos=(squelch - minDB) / (maxDB - minDB) * indicatorWidth;
    float signalWidth=(averageSignalStrength - minDB) / (maxDB - minDB) * indicatorWidth;
    if (signalWidth < 0)     signalWidth=0;
    if (signalWidth > indicatorWidth)     signalWidth=indicatorWidth;
    c.drawRect(indicatorPosX,yPos + bounds.height() * 0.1f,indicatorPosX + signalWidth,indicatorPosY,squelchPaint);
    c.drawLine(indicatorPosX,indicatorPosY,indicatorPosX,yPos,textPaint);
    c.drawLine(rightBorder,indicatorPosY,rightBorder,yPos,textPaint);
    c.drawLine(indicatorPosX,indicatorPosY,rightBorder,indicatorPosY,textPaint);
    c.drawLine(indicatorPosX + squelchTickPos,indicatorPosY + 2,indicatorPosX + squelchTickPos,yPos + bounds.height() * 0.5f,textPaint);
    c.drawText(text,indicatorPosX - bounds.width() * 1.1f,indicatorPosY,textSmallPaint);
    yPos+=bounds.height() * 1.1f;
  }
  if (recordingEnabled) {
    text=String.format(""String_Node_Str"",source.getFrequency() / 1000000f,source.getSampleRate() / 1000000f);
    textSmallPaint.getTextBounds(text,0,text.length(),bounds);
    c.drawText(text,rightBorder - bounds.width(),yPos + bounds.height(),textSmallPaint);
    defaultPaint.setColor(Color.RED);
    c.drawCircle(rightBorder - bounds.width() - (bounds.height() / 2) * 1.3f,yPos + bounds.height() / 2,bounds.height() / 2,defaultPaint);
    yPos+=bounds.height() * 1.1f;
  }
  if (showDebugInformation) {
    text=frameRate + ""String_Node_Str"";
    textSmallPaint.getTextBounds(text,0,text.length(),bounds);
    c.drawText(text,rightBorder - bounds.width(),yPos + bounds.height(),textSmallPaint);
    yPos+=bounds.height() * 1.1f;
    text=String.format(""String_Node_Str"",load * 100);
    textSmallPaint.getTextBounds(text,0,text.length(),bounds);
    c.drawText(text,rightBorder - bounds.width(),yPos + bounds.height(),textSmallPaint);
    yPos+=bounds.height() * 1.1f;
  }
}","/** 
 * This method will draw the performance information into the canvas
 * @param c				canvas of the surface view
 * @param frameRate 	current frame rate (FPS)
 * @param load			current load (percentage [0..1])
 * @param averageSignalStrength		average magnitude of the signal in the selected channel
 */
private void drawPerformanceInfo(Canvas c,int frameRate,double load,float averageSignalStrength){
  Rect bounds=new Rect();
  String text;
  float yPos=height * 0.01f;
  float rightBorder=width * 0.99f;
  if (source != null) {
    text=source.getName();
    textSmallPaint.getTextBounds(text,0,text.length(),bounds);
    c.drawText(text,rightBorder - bounds.width(),yPos + bounds.height(),textSmallPaint);
    yPos+=bounds.height() * 1.1f;
    if (source instanceof HackrfSource) {
      text=String.format(""String_Node_Str"",((HackrfSource)source).getFrequencyShift() / 1000000f);
      textSmallPaint.getTextBounds(text,0,text.length(),bounds);
      c.drawText(text,rightBorder - bounds.width(),yPos + bounds.height(),textSmallPaint);
      yPos+=bounds.height() * 1.1f;
    }
    if (source instanceof RtlsdrSource) {
      text=String.format(""String_Node_Str"",((RtlsdrSource)source).getFrequencyShift() / 1000000f);
      textSmallPaint.getTextBounds(text,0,text.length(),bounds);
      c.drawText(text,rightBorder - bounds.width(),yPos + bounds.height(),textSmallPaint);
      yPos+=bounds.height() * 1.1f;
      text=""String_Node_Str"" + ((RtlsdrSource)source).getFrequencyCorrection();
      textSmallPaint.getTextBounds(text,0,text.length(),bounds);
      c.drawText(text,rightBorder - bounds.width(),yPos + bounds.height(),textSmallPaint);
      yPos+=bounds.height() * 1.1f;
    }
  }
  if (demodulationEnabled) {
    text=String.format(""String_Node_Str"",channelFrequency / 1000000f);
    textSmallPaint.getTextBounds(text,0,text.length(),bounds);
    c.drawText(text,rightBorder - bounds.width(),yPos + bounds.height(),textSmallPaint);
    yPos+=bounds.height() * 1.1f;
  }
  if (demodulationEnabled) {
    text=String.format(""String_Node_Str"",averageSignalStrength);
    textSmallPaint.getTextBounds(text,0,text.length(),bounds);
    float indicatorWidth=width / 10;
    float indicatorPosX=rightBorder - indicatorWidth;
    float indicatorPosY=yPos + bounds.height();
    float squelchTickPos=(squelch - minDB) / (maxDB - minDB) * indicatorWidth;
    float signalWidth=(averageSignalStrength - minDB) / (maxDB - minDB) * indicatorWidth;
    if (signalWidth < 0)     signalWidth=0;
    if (signalWidth > indicatorWidth)     signalWidth=indicatorWidth;
    c.drawRect(indicatorPosX,yPos + bounds.height() * 0.1f,indicatorPosX + signalWidth,indicatorPosY,squelchPaint);
    c.drawLine(indicatorPosX,indicatorPosY,indicatorPosX,yPos,textPaint);
    c.drawLine(rightBorder,indicatorPosY,rightBorder,yPos,textPaint);
    c.drawLine(indicatorPosX,indicatorPosY,rightBorder,indicatorPosY,textPaint);
    c.drawLine(indicatorPosX + squelchTickPos,indicatorPosY + 2,indicatorPosX + squelchTickPos,yPos + bounds.height() * 0.5f,textPaint);
    c.drawText(text,indicatorPosX - bounds.width() * 1.1f,indicatorPosY,textSmallPaint);
    yPos+=bounds.height() * 1.1f;
  }
  if (recordingEnabled) {
    text=String.format(""String_Node_Str"",source.getFrequency() / 1000000f,source.getSampleRate() / 1000000f);
    textSmallPaint.getTextBounds(text,0,text.length(),bounds);
    c.drawText(text,rightBorder - bounds.width(),yPos + bounds.height(),textSmallPaint);
    defaultPaint.setColor(Color.RED);
    c.drawCircle(rightBorder - bounds.width() - (bounds.height() / 2) * 1.3f,yPos + bounds.height() / 2,bounds.height() / 2,defaultPaint);
    yPos+=bounds.height() * 1.1f;
  }
  if (showDebugInformation) {
    text=frameRate + ""String_Node_Str"";
    textSmallPaint.getTextBounds(text,0,text.length(),bounds);
    c.drawText(text,rightBorder - bounds.width(),yPos + bounds.height(),textSmallPaint);
    yPos+=bounds.height() * 1.1f;
    text=String.format(""String_Node_Str"",load * 100);
    textSmallPaint.getTextBounds(text,0,text.length(),bounds);
    c.drawText(text,rightBorder - bounds.width(),yPos + bounds.height(),textSmallPaint);
    yPos+=bounds.height() * 1.1f;
  }
}"
54963,"@Override public String getName(){
  if (hackrf != null) {
    try {
      return Hackrf.convertBoardIdToString(hackrf.getBoardID());
    }
 catch (    HackrfUsbException e) {
    }
  }
  return ""String_Node_Str"";
}","@Override public String getName(){
  if (name == null && hackrf != null) {
    try {
      name=Hackrf.convertBoardIdToString(hackrf.getBoardID());
    }
 catch (    HackrfUsbException e) {
    }
  }
  if (name != null)   return name;
 else   return ""String_Node_Str"";
}"
54964,"@Override public void setFrequency(long frequency){
  frequency+=upconverterFrequencyShift;
  if (hackrf != null) {
    try {
      hackrf.setFrequency(frequency);
    }
 catch (    HackrfUsbException e) {
      Log.e(LOGTAG,""String_Node_Str"" + e.getMessage());
      reportError(""String_Node_Str"");
      return;
    }
  }
  this.flushQueue();
  this.frequency=frequency;
  this.iqConverter.setFrequency(frequency);
}","@Override public void setFrequency(long frequency){
  long actualFrequency=frequency - frequencyShift;
  if (hackrf != null) {
    try {
      hackrf.setFrequency(actualFrequency);
    }
 catch (    HackrfUsbException e) {
      Log.e(LOGTAG,""String_Node_Str"" + e.getMessage());
      reportError(""String_Node_Str"");
      return;
    }
  }
  this.flushQueue();
  this.frequency=actualFrequency;
  this.iqConverter.setFrequency(frequency);
}"
54965,"@Override public long getMinFrequency(){
  return MIN_FREQUENCY - upconverterFrequencyShift;
}","@Override public long getMinFrequency(){
  return MIN_FREQUENCY + frequencyShift;
}"
54966,"@Override public long getFrequency(){
  return frequency - upconverterFrequencyShift;
}","@Override public long getFrequency(){
  return frequency + frequencyShift;
}"
54967,"@Override public long getMaxFrequency(){
  return MAX_FREQUENCY - upconverterFrequencyShift;
}","@Override public long getMaxFrequency(){
  return MAX_FREQUENCY + frequencyShift;
}"
54968,"@Override public void onUpdateSquelchSatisfied(boolean squelchSatisfied){
  scheduler.setSquelchSatisfied(squelchSatisfied);
}","@Override public void onUpdateSquelchSatisfied(boolean squelchSatisfied){
  if (scheduler != null)   scheduler.setSquelchSatisfied(squelchSatisfied);
}"
54969,"/** 
 * Called by the analyzer surface after the user changed the channel width
 * @param newChannelWidth    new channel width (single sided) in Hz
 * @return true if channel width is valid; false if out of range
 */
@Override public boolean onUpdateChannelWidth(int newChannelWidth){
  return demodulator.setChannelWidth(newChannelWidth);
}","/** 
 * Called by the analyzer surface after the user changed the channel width
 * @param newChannelWidth    new channel width (single sided) in Hz
 * @return true if channel width is valid; false if out of range
 */
@Override public boolean onUpdateChannelWidth(int newChannelWidth){
  if (demodulator != null)   return demodulator.setChannelWidth(newChannelWidth);
 else   return false;
}"
54970,"/** 
 * Will check if any preference conflicts with the current state of the app and fix it
 */
public void checkForChangedPreferences(){
  int sourceType=Integer.valueOf(preferences.getString(getString(R.string.pref_sourceType),""String_Node_Str""));
  if (source != null) {
switch (sourceType) {
case FILE_SOURCE:
      if (!(source instanceof FileIQSource)) {
        source.close();
        createSource();
      }
 else {
        long freq=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_frequency),""String_Node_Str""));
        int sampRate=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_sampleRate),""String_Node_Str""));
        String fileName=preferences.getString(getString(R.string.pref_filesource_file),""String_Node_Str"");
        int fileFormat=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_format),""String_Node_Str""));
        boolean repeat=preferences.getBoolean(getString(R.string.pref_filesource_repeat),false);
        if (freq != source.getFrequency() || sampRate != source.getSampleRate() || !fileName.equals(((FileIQSource)source).getFilename()) || repeat != ((FileIQSource)source).isRepeat() || fileFormat != ((FileIQSource)source).getFileFormat()) {
          source.close();
          createSource();
        }
      }
    break;
case HACKRF_SOURCE:
  if (!(source instanceof HackrfSource)) {
    source.close();
    createSource();
  }
 else {
    boolean amp=preferences.getBoolean(getString(R.string.pref_hackrf_amplifier),false);
    boolean antennaPower=preferences.getBoolean(getString(R.string.pref_hackrf_antennaPower),false);
    int upconverterFrequencyShift=Integer.valueOf(preferences.getString(getString(R.string.pref_hackrf_upconverterFrequencyShift),""String_Node_Str""));
    if (((HackrfSource)source).isAmplifierOn() != amp)     ((HackrfSource)source).setAmplifier(amp);
    if (((HackrfSource)source).isAntennaPowerOn() != antennaPower)     ((HackrfSource)source).setAntennaPower(antennaPower);
    if (((HackrfSource)source).getUpconverterFrequencyShift() != upconverterFrequencyShift)     ((HackrfSource)source).setUpconverterFrequencyShift(upconverterFrequencyShift);
  }
break;
case RTLSDR_SOURCE:
if (!(source instanceof RtlsdrSource)) {
source.close();
createSource();
}
 else {
String ip=preferences.getString(getString(R.string.pref_rtlsdr_ip),""String_Node_Str"");
int port=Integer.valueOf(preferences.getString(getString(R.string.pref_rtlsdr_port),""String_Node_Str""));
boolean externalServer=preferences.getBoolean(getString(R.string.pref_rtlsdr_externalServer),false);
if (externalServer) {
  if (!ip.equals(((RtlsdrSource)source).getIpAddress()) || port != ((RtlsdrSource)source).getPort()) {
    source.close();
    createSource();
    return;
  }
}
 else {
  if (!((RtlsdrSource)source).getIpAddress().equals(""String_Node_Str"") || 1234 != ((RtlsdrSource)source).getPort()) {
    source.close();
    createSource();
    return;
  }
}
int frequencyCorrection=Integer.valueOf(preferences.getString(getString(R.string.pref_rtlsdr_frequencyCorrection),""String_Node_Str""));
int upconverterFrequencyShift=Integer.valueOf(preferences.getString(getString(R.string.pref_rtlsdr_upconverterFrequencyShift),""String_Node_Str""));
if (frequencyCorrection != ((RtlsdrSource)source).getFrequencyCorrection()) ((RtlsdrSource)source).setFrequencyCorrection(frequencyCorrection);
if (((RtlsdrSource)source).getUpconverterFrequencyShift() != upconverterFrequencyShift) ((RtlsdrSource)source).setUpconverterFrequencyShift(upconverterFrequencyShift);
}
break;
default :
}
}
if (analyzerSurface != null) {
analyzerSurface.setVerticalScrollEnabled(preferences.getBoolean(getString(R.string.pref_scrollDB),true));
analyzerSurface.setVerticalZoomEnabled(preferences.getBoolean(getString(R.string.pref_zoomDB),true));
analyzerSurface.setDecoupledAxis(preferences.getBoolean(getString(R.string.pref_decoupledAxis),false));
analyzerSurface.setWaterfallColorMapType(Integer.valueOf(preferences.getString(getString(R.string.pref_colorMapType),""String_Node_Str"")));
analyzerSurface.setFftDrawingType(Integer.valueOf(preferences.getString(getString(R.string.pref_fftDrawingType),""String_Node_Str"")));
analyzerSurface.setAverageLength(Integer.valueOf(preferences.getString(getString(R.string.pref_averaging),""String_Node_Str"")));
analyzerSurface.setPeakHoldEnabled(preferences.getBoolean(getString(R.string.pref_peakHold),false));
analyzerSurface.setFftRatio(Float.valueOf(preferences.getString(getString(R.string.pref_spectrumWaterfallRatio),""String_Node_Str"")));
analyzerSurface.setFontSize(Integer.valueOf(preferences.getString(getString(R.string.pref_fontSize),""String_Node_Str"")));
analyzerSurface.setShowDebugInformation(preferences.getBoolean(getString(R.string.pref_showDebugInformation),false));
}
String screenOrientation=preferences.getString(getString(R.string.pref_screenOrientation),""String_Node_Str"");
if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);
}","/** 
 * Will check if any preference conflicts with the current state of the app and fix it
 */
public void checkForChangedPreferences(){
  int sourceType=Integer.valueOf(preferences.getString(getString(R.string.pref_sourceType),""String_Node_Str""));
  if (source != null) {
switch (sourceType) {
case FILE_SOURCE:
      if (!(source instanceof FileIQSource)) {
        source.close();
        createSource();
      }
 else {
        long freq=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_frequency),""String_Node_Str""));
        int sampRate=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_sampleRate),""String_Node_Str""));
        String fileName=preferences.getString(getString(R.string.pref_filesource_file),""String_Node_Str"");
        int fileFormat=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_format),""String_Node_Str""));
        boolean repeat=preferences.getBoolean(getString(R.string.pref_filesource_repeat),false);
        if (freq != source.getFrequency() || sampRate != source.getSampleRate() || !fileName.equals(((FileIQSource)source).getFilename()) || repeat != ((FileIQSource)source).isRepeat() || fileFormat != ((FileIQSource)source).getFileFormat()) {
          source.close();
          createSource();
        }
      }
    break;
case HACKRF_SOURCE:
  if (!(source instanceof HackrfSource)) {
    source.close();
    createSource();
  }
 else {
    boolean amp=preferences.getBoolean(getString(R.string.pref_hackrf_amplifier),false);
    boolean antennaPower=preferences.getBoolean(getString(R.string.pref_hackrf_antennaPower),false);
    int frequencyShift=Integer.valueOf(preferences.getString(getString(R.string.pref_hackrf_frequencyShift),""String_Node_Str""));
    if (((HackrfSource)source).isAmplifierOn() != amp)     ((HackrfSource)source).setAmplifier(amp);
    if (((HackrfSource)source).isAntennaPowerOn() != antennaPower)     ((HackrfSource)source).setAntennaPower(antennaPower);
    if (((HackrfSource)source).getFrequencyShift() != frequencyShift)     ((HackrfSource)source).setFrequencyShift(frequencyShift);
  }
break;
case RTLSDR_SOURCE:
if (!(source instanceof RtlsdrSource)) {
source.close();
createSource();
}
 else {
String ip=preferences.getString(getString(R.string.pref_rtlsdr_ip),""String_Node_Str"");
int port=Integer.valueOf(preferences.getString(getString(R.string.pref_rtlsdr_port),""String_Node_Str""));
boolean externalServer=preferences.getBoolean(getString(R.string.pref_rtlsdr_externalServer),false);
if (externalServer) {
  if (!ip.equals(((RtlsdrSource)source).getIpAddress()) || port != ((RtlsdrSource)source).getPort()) {
    source.close();
    createSource();
    return;
  }
}
 else {
  if (!((RtlsdrSource)source).getIpAddress().equals(""String_Node_Str"") || 1234 != ((RtlsdrSource)source).getPort()) {
    source.close();
    createSource();
    return;
  }
}
int frequencyCorrection=Integer.valueOf(preferences.getString(getString(R.string.pref_rtlsdr_frequencyCorrection),""String_Node_Str""));
int frequencyShift=Integer.valueOf(preferences.getString(getString(R.string.pref_rtlsdr_frequencyShift),""String_Node_Str""));
if (frequencyCorrection != ((RtlsdrSource)source).getFrequencyCorrection()) ((RtlsdrSource)source).setFrequencyCorrection(frequencyCorrection);
if (((RtlsdrSource)source).getFrequencyShift() != frequencyShift) ((RtlsdrSource)source).setFrequencyShift(frequencyShift);
}
break;
default :
}
}
if (analyzerSurface != null) {
analyzerSurface.setVerticalScrollEnabled(preferences.getBoolean(getString(R.string.pref_scrollDB),true));
analyzerSurface.setVerticalZoomEnabled(preferences.getBoolean(getString(R.string.pref_zoomDB),true));
analyzerSurface.setDecoupledAxis(preferences.getBoolean(getString(R.string.pref_decoupledAxis),false));
analyzerSurface.setWaterfallColorMapType(Integer.valueOf(preferences.getString(getString(R.string.pref_colorMapType),""String_Node_Str"")));
analyzerSurface.setFftDrawingType(Integer.valueOf(preferences.getString(getString(R.string.pref_fftDrawingType),""String_Node_Str"")));
analyzerSurface.setAverageLength(Integer.valueOf(preferences.getString(getString(R.string.pref_averaging),""String_Node_Str"")));
analyzerSurface.setPeakHoldEnabled(preferences.getBoolean(getString(R.string.pref_peakHold),false));
analyzerSurface.setFftRatio(Float.valueOf(preferences.getString(getString(R.string.pref_spectrumWaterfallRatio),""String_Node_Str"")));
analyzerSurface.setFontSize(Integer.valueOf(preferences.getString(getString(R.string.pref_fontSize),""String_Node_Str"")));
analyzerSurface.setShowDebugInformation(preferences.getBoolean(getString(R.string.pref_showDebugInformation),false));
}
String screenOrientation=preferences.getString(getString(R.string.pref_screenOrientation),""String_Node_Str"");
if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE);
 else if (screenOrientation.equals(""String_Node_Str"")) setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT);
}"
54971,"@Override public void onUpdateChannelFrequency(long newChannelFrequency){
  scheduler.setChannelFrequency(newChannelFrequency);
}","@Override public void onUpdateChannelFrequency(long newChannelFrequency){
  if (scheduler != null)   scheduler.setChannelFrequency(newChannelFrequency);
}"
54972,"/** 
 * Will create a IQ Source instance according to the user settings.
 * @return true on success; false on error
 */
public boolean createSource(){
  long frequency;
  int sampleRate;
  int sourceType=Integer.valueOf(preferences.getString(getString(R.string.pref_sourceType),""String_Node_Str""));
switch (sourceType) {
case FILE_SOURCE:
    try {
      frequency=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_frequency),""String_Node_Str""));
      sampleRate=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_sampleRate),""String_Node_Str""));
    }
 catch (    NumberFormatException e) {
      this.runOnUiThread(new Runnable(){
        @Override public void run(){
          Toast.makeText(MainActivity.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
        }
      }
);
      return false;
    }
  String filename=preferences.getString(getString(R.string.pref_filesource_file),""String_Node_Str"");
int fileFormat=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_format),""String_Node_Str""));
boolean repeat=preferences.getBoolean(getString(R.string.pref_filesource_repeat),false);
source=new FileIQSource(filename,sampleRate,frequency,16384,repeat,fileFormat);
break;
case HACKRF_SOURCE:
source=new HackrfSource();
source.setFrequency(preferences.getLong(getString(R.string.pref_frequency),97000000));
source.setSampleRate(preferences.getInt(getString(R.string.pref_sampleRate),HackrfSource.MAX_SAMPLERATE));
((HackrfSource)source).setVgaRxGain(preferences.getInt(getString(R.string.pref_hackrf_vgaRxGain),HackrfSource.MAX_VGA_RX_GAIN / 2));
((HackrfSource)source).setLnaGain(preferences.getInt(getString(R.string.pref_hackrf_lnaGain),HackrfSource.MAX_LNA_GAIN / 2));
((HackrfSource)source).setAmplifier(preferences.getBoolean(getString(R.string.pref_hackrf_amplifier),false));
((HackrfSource)source).setAntennaPower(preferences.getBoolean(getString(R.string.pref_hackrf_antennaPower),false));
((HackrfSource)source).setUpconverterFrequencyShift(Integer.valueOf(preferences.getString(getString(R.string.pref_hackrf_upconverterFrequencyShift),""String_Node_Str"")));
break;
case RTLSDR_SOURCE:
if (preferences.getBoolean(getString(R.string.pref_rtlsdr_externalServer),false)) source=new RtlsdrSource(preferences.getString(getString(R.string.pref_rtlsdr_ip),""String_Node_Str""),Integer.valueOf(preferences.getString(getString(R.string.pref_rtlsdr_port),""String_Node_Str"")));
 else {
source=new RtlsdrSource(""String_Node_Str"",1234);
}
frequency=preferences.getLong(getString(R.string.pref_frequency),97000000);
sampleRate=preferences.getInt(getString(R.string.pref_sampleRate),source.getMaxSampleRate());
if (sampleRate > 2000000) sampleRate=2000000;
source.setFrequency(frequency);
source.setSampleRate(sampleRate);
((RtlsdrSource)source).setFrequencyCorrection(Integer.valueOf(preferences.getString(getString(R.string.pref_rtlsdr_frequencyCorrection),""String_Node_Str"")));
((RtlsdrSource)source).setUpconverterFrequencyShift(Integer.valueOf(preferences.getString(getString(R.string.pref_rtlsdr_upconverterFrequencyShift),""String_Node_Str"")));
((RtlsdrSource)source).setManualGain(preferences.getBoolean(getString(R.string.pref_rtlsdr_manual_gain),false));
((RtlsdrSource)source).setAutomaticGainControl(preferences.getBoolean(getString(R.string.pref_rtlsdr_agc),false));
if (((RtlsdrSource)source).isManualGain()) {
((RtlsdrSource)source).setGain(preferences.getInt(getString(R.string.pref_rtlsdr_gain),0));
((RtlsdrSource)source).setIFGain(preferences.getInt(getString(R.string.pref_rtlsdr_ifGain),0));
}
break;
default :
Log.e(LOGTAG,""String_Node_Str"" + sourceType);
return false;
}
analyzerSurface.setSource(source);
return true;
}","/** 
 * Will create a IQ Source instance according to the user settings.
 * @return true on success; false on error
 */
public boolean createSource(){
  long frequency;
  int sampleRate;
  int sourceType=Integer.valueOf(preferences.getString(getString(R.string.pref_sourceType),""String_Node_Str""));
switch (sourceType) {
case FILE_SOURCE:
    try {
      frequency=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_frequency),""String_Node_Str""));
      sampleRate=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_sampleRate),""String_Node_Str""));
    }
 catch (    NumberFormatException e) {
      this.runOnUiThread(new Runnable(){
        @Override public void run(){
          Toast.makeText(MainActivity.this,""String_Node_Str"",Toast.LENGTH_LONG).show();
        }
      }
);
      return false;
    }
  String filename=preferences.getString(getString(R.string.pref_filesource_file),""String_Node_Str"");
int fileFormat=Integer.valueOf(preferences.getString(getString(R.string.pref_filesource_format),""String_Node_Str""));
boolean repeat=preferences.getBoolean(getString(R.string.pref_filesource_repeat),false);
source=new FileIQSource(filename,sampleRate,frequency,16384,repeat,fileFormat);
break;
case HACKRF_SOURCE:
source=new HackrfSource();
source.setFrequency(preferences.getLong(getString(R.string.pref_frequency),97000000));
source.setSampleRate(preferences.getInt(getString(R.string.pref_sampleRate),HackrfSource.MAX_SAMPLERATE));
((HackrfSource)source).setVgaRxGain(preferences.getInt(getString(R.string.pref_hackrf_vgaRxGain),HackrfSource.MAX_VGA_RX_GAIN / 2));
((HackrfSource)source).setLnaGain(preferences.getInt(getString(R.string.pref_hackrf_lnaGain),HackrfSource.MAX_LNA_GAIN / 2));
((HackrfSource)source).setAmplifier(preferences.getBoolean(getString(R.string.pref_hackrf_amplifier),false));
((HackrfSource)source).setAntennaPower(preferences.getBoolean(getString(R.string.pref_hackrf_antennaPower),false));
((HackrfSource)source).setFrequencyShift(Integer.valueOf(preferences.getString(getString(R.string.pref_hackrf_frequencyShift),""String_Node_Str"")));
break;
case RTLSDR_SOURCE:
if (preferences.getBoolean(getString(R.string.pref_rtlsdr_externalServer),false)) source=new RtlsdrSource(preferences.getString(getString(R.string.pref_rtlsdr_ip),""String_Node_Str""),Integer.valueOf(preferences.getString(getString(R.string.pref_rtlsdr_port),""String_Node_Str"")));
 else {
source=new RtlsdrSource(""String_Node_Str"",1234);
}
frequency=preferences.getLong(getString(R.string.pref_frequency),97000000);
sampleRate=preferences.getInt(getString(R.string.pref_sampleRate),source.getMaxSampleRate());
if (sampleRate > 2000000) sampleRate=2000000;
source.setFrequency(frequency);
source.setSampleRate(sampleRate);
((RtlsdrSource)source).setFrequencyCorrection(Integer.valueOf(preferences.getString(getString(R.string.pref_rtlsdr_frequencyCorrection),""String_Node_Str"")));
((RtlsdrSource)source).setFrequencyShift(Integer.valueOf(preferences.getString(getString(R.string.pref_rtlsdr_frequencyShift),""String_Node_Str"")));
((RtlsdrSource)source).setManualGain(preferences.getBoolean(getString(R.string.pref_rtlsdr_manual_gain),false));
((RtlsdrSource)source).setAutomaticGainControl(preferences.getBoolean(getString(R.string.pref_rtlsdr_agc),false));
if (((RtlsdrSource)source).isManualGain()) {
((RtlsdrSource)source).setGain(preferences.getInt(getString(R.string.pref_rtlsdr_gain),0));
((RtlsdrSource)source).setIFGain(preferences.getInt(getString(R.string.pref_rtlsdr_ifGain),0));
}
break;
default :
Log.e(LOGTAG,""String_Node_Str"" + sourceType);
return false;
}
analyzerSurface.setSource(source);
return true;
}"
54973,"@Override public void setFrequency(long frequency){
  frequency+=upconverterFrequencyShift;
  if (isOpen()) {
    if (frequency < getMinFrequency() || frequency > getMaxFrequency()) {
      Log.e(LOGTAG,""String_Node_Str"" + frequency + ""String_Node_Str""+ upconverterFrequencyShift+ ""String_Node_Str"");
      return;
    }
    commandThread.executeFrequencyChangeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_FREQUENCY,(int)frequency));
  }
  this.flushQueue();
  this.frequency=frequency;
  this.iqConverter.setFrequency(frequency);
}","@Override public void setFrequency(long frequency){
  long actualSourceFrequency=frequency - frequencyShift;
  if (isOpen()) {
    if (actualSourceFrequency < getMinFrequency() || actualSourceFrequency > getMaxFrequency()) {
      Log.e(LOGTAG,""String_Node_Str"" + frequency + ""String_Node_Str""+ frequencyShift+ ""String_Node_Str"");
      return;
    }
    commandThread.executeFrequencyChangeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_FREQUENCY,(int)actualSourceFrequency));
  }
  this.flushQueue();
  this.frequency=actualSourceFrequency;
  this.iqConverter.setFrequency(frequency);
}"
54974,"@Override public long getMinFrequency(){
  return MIN_FREQUENCY[tuner] - upconverterFrequencyShift;
}","@Override public long getMinFrequency(){
  return MIN_FREQUENCY[tuner] + frequencyShift;
}"
54975,"@Override public long getMaxFrequency(){
  return MAX_FREQUENCY[tuner] - upconverterFrequencyShift;
}","@Override public long getMaxFrequency(){
  return MAX_FREQUENCY[tuner] + frequencyShift;
}"
54976,"/** 
 * Called from run(); will setup the connection to the rtl_tcp instance
 */
private boolean connect(int timeoutMillis){
  if (socket != null) {
    Log.e(LOGTAG,""String_Node_Str"");
    return false;
  }
  try {
    long timeoutTime=System.currentTimeMillis() + timeoutMillis;
    while (!stopRequested && socket == null && System.currentTimeMillis() < timeoutTime) {
      try {
        socket=new Socket(ipAddress,port);
      }
 catch (      IOException e) {
      }
      sleep(100);
    }
    if (socket == null) {
      if (stopRequested)       Log.i(LOGTAG,""String_Node_Str"");
 else       Log.e(LOGTAG,""String_Node_Str"");
      return false;
    }
    socket.setTcpNoDelay(true);
    socket.setSoTimeout(1000);
    inputStream=socket.getInputStream();
    outputStream=socket.getOutputStream();
    byte[] buffer=new byte[4];
    if (inputStream.read(buffer,0,buffer.length) != buffer.length) {
      Log.e(LOGTAG,""String_Node_Str"");
      return false;
    }
    magic=new String(buffer,""String_Node_Str"");
    if (inputStream.read(buffer,0,buffer.length) != buffer.length) {
      Log.e(LOGTAG,""String_Node_Str"");
      return false;
    }
    tuner=buffer[3];
    if (tuner <= 0 || tuner >= TUNER_STRING.length) {
      Log.e(LOGTAG,""String_Node_Str"");
      return false;
    }
    if (inputStream.read(buffer,0,buffer.length) != buffer.length) {
      Log.e(LOGTAG,""String_Node_Str"");
      return false;
    }
    Log.i(LOGTAG,""String_Node_Str"" + TUNER_STRING[tuner] + ""String_Node_Str""+ magic+ ""String_Node_Str""+ buffer[3]+ ""String_Node_Str""+ ipAddress+ ""String_Node_Str""+ port);
    name=""String_Node_Str"" + TUNER_STRING[tuner] + ""String_Node_Str""+ ipAddress+ ""String_Node_Str""+ port;
    if (frequency > MAX_FREQUENCY[tuner]) {
      frequency=MAX_FREQUENCY[tuner];
      iqConverter.setFrequency(frequency);
    }
    if (frequency < MIN_FREQUENCY[tuner]) {
      frequency=MIN_FREQUENCY[tuner];
      iqConverter.setFrequency(frequency);
    }
    if (sampleRate > getMaxSampleRate())     sampleRate=getMaxSampleRate();
    if (sampleRate < getMinSampleRate())     sampleRate=getMinSampleRate();
    for (    int gainStep : getPossibleGainValues()) {
      if (gainStep >= gain) {
        gain=gainStep;
        break;
      }
    }
    executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_FREQUENCY,(int)frequency));
    executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_SAMPLERATE,sampleRate));
    executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_GAIN_MODE,(int)(manualGain ? 0x01 : 0x00)));
    if (manualGain)     executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_GAIN,gain));
    if (manualGain && tuner == RTLSDR_TUNER_E4000)     executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_IFGAIN,(short)0,(short)ifGain));
    executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_FREQ_CORR,frequencyCorrection));
    executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_AGC_MODE,(int)(automaticGainControl ? 0x01 : 0x00)));
    return true;
  }
 catch (  UnknownHostException e) {
    Log.e(LOGTAG,""String_Node_Str"" + ipAddress);
    reportError(""String_Node_Str"" + ipAddress);
  }
catch (  IOException e) {
    Log.e(LOGTAG,""String_Node_Str"" + ipAddress + ""String_Node_Str""+ port+ ""String_Node_Str""+ e.getMessage());
  }
catch (  InterruptedException e) {
    Log.e(LOGTAG,""String_Node_Str"");
  }
  return false;
}","/** 
 * Called from run(); will setup the connection to the rtl_tcp instance
 */
private boolean connect(int timeoutMillis){
  if (socket != null) {
    Log.e(LOGTAG,""String_Node_Str"");
    return false;
  }
  try {
    long timeoutTime=System.currentTimeMillis() + timeoutMillis;
    while (!stopRequested && socket == null && System.currentTimeMillis() < timeoutTime) {
      try {
        socket=new Socket(ipAddress,port);
      }
 catch (      IOException e) {
      }
      sleep(100);
    }
    if (socket == null) {
      if (stopRequested)       Log.i(LOGTAG,""String_Node_Str"");
 else       Log.e(LOGTAG,""String_Node_Str"");
      return false;
    }
    socket.setTcpNoDelay(true);
    socket.setSoTimeout(1000);
    inputStream=socket.getInputStream();
    outputStream=socket.getOutputStream();
    byte[] buffer=new byte[4];
    if (inputStream.read(buffer,0,buffer.length) != buffer.length) {
      Log.e(LOGTAG,""String_Node_Str"");
      return false;
    }
    magic=new String(buffer,""String_Node_Str"");
    if (inputStream.read(buffer,0,buffer.length) != buffer.length) {
      Log.e(LOGTAG,""String_Node_Str"");
      return false;
    }
    tuner=buffer[3];
    if (tuner <= 0 || tuner >= TUNER_STRING.length) {
      Log.e(LOGTAG,""String_Node_Str"");
      return false;
    }
    if (inputStream.read(buffer,0,buffer.length) != buffer.length) {
      Log.e(LOGTAG,""String_Node_Str"");
      return false;
    }
    Log.i(LOGTAG,""String_Node_Str"" + TUNER_STRING[tuner] + ""String_Node_Str""+ magic+ ""String_Node_Str""+ buffer[3]+ ""String_Node_Str""+ ipAddress+ ""String_Node_Str""+ port);
    name=""String_Node_Str"" + TUNER_STRING[tuner] + ""String_Node_Str""+ ipAddress+ ""String_Node_Str""+ port;
    if (frequency > MAX_FREQUENCY[tuner]) {
      frequency=MAX_FREQUENCY[tuner];
    }
    if (frequency < MIN_FREQUENCY[tuner]) {
      frequency=MIN_FREQUENCY[tuner];
    }
    iqConverter.setFrequency(frequency + frequencyShift);
    if (sampleRate > getMaxSampleRate())     sampleRate=getMaxSampleRate();
    if (sampleRate < getMinSampleRate())     sampleRate=getMinSampleRate();
    for (    int gainStep : getPossibleGainValues()) {
      if (gainStep >= gain) {
        gain=gainStep;
        break;
      }
    }
    executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_FREQUENCY,(int)frequency));
    executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_SAMPLERATE,sampleRate));
    executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_GAIN_MODE,(int)(manualGain ? 0x01 : 0x00)));
    if (manualGain)     executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_GAIN,gain));
    if (manualGain && tuner == RTLSDR_TUNER_E4000)     executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_IFGAIN,(short)0,(short)ifGain));
    executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_FREQ_CORR,frequencyCorrection));
    executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_AGC_MODE,(int)(automaticGainControl ? 0x01 : 0x00)));
    return true;
  }
 catch (  UnknownHostException e) {
    Log.e(LOGTAG,""String_Node_Str"" + ipAddress);
    reportError(""String_Node_Str"" + ipAddress);
  }
catch (  IOException e) {
    Log.e(LOGTAG,""String_Node_Str"" + ipAddress + ""String_Node_Str""+ port+ ""String_Node_Str""+ e.getMessage());
  }
catch (  InterruptedException e) {
    Log.e(LOGTAG,""String_Node_Str"");
  }
  return false;
}"
54977,"@Override public long getFrequency(){
  return frequency - upconverterFrequencyShift;
}","@Override public long getFrequency(){
  return frequency + frequencyShift;
}"
54978,"/** 
 * Will go through each preference element and initialize/update the summary according to its value.
 * @note this will also correct invalid user inputs on EdittextPreferences!
 */
public void updateSummaries(){
  ListPreference listPref=(ListPreference)findPreference(getString(R.string.pref_sourceType));
  listPref.setSummary(getString(R.string.pref_sourceType_summ,listPref.getEntry()));
  EditTextPreference editTextPref=(EditTextPreference)findPreference(getString(R.string.pref_filesource_frequency));
  if (editTextPref.getText().length() == 0)   editTextPref.setText(getString(R.string.pref_filesource_frequency_default));
  editTextPref.setSummary(getString(R.string.pref_filesource_frequency_summ,editTextPref.getText()));
  editTextPref=(EditTextPreference)findPreference(getString(R.string.pref_filesource_sampleRate));
  if (editTextPref.getText().length() == 0)   editTextPref.setText(getString(R.string.pref_filesource_sampleRate_default));
  editTextPref.setSummary(getString(R.string.pref_filesource_sampleRate_summ,editTextPref.getText()));
  editTextPref=(EditTextPreference)findPreference(getString(R.string.pref_filesource_file));
  editTextPref.setSummary(getString(R.string.pref_filesource_file_summ,editTextPref.getText()));
  listPref=(ListPreference)findPreference(getString(R.string.pref_filesource_format));
  listPref.setSummary(getString(R.string.pref_filesource_format_summ,listPref.getEntry()));
  editTextPref=(EditTextPreference)findPreference(getString(R.string.pref_hackrf_upconverterFrequencyShift));
  if (editTextPref.getText().length() == 0)   editTextPref.setText(""String_Node_Str"");
  editTextPref.setSummary(getString(R.string.pref_hackrf_upconverterFrequencyShift_summ,editTextPref.getText()));
  editTextPref=(EditTextPreference)findPreference(getString(R.string.pref_rtlsdr_ip));
  editTextPref.setSummary(getString(R.string.pref_rtlsdr_ip_summ,editTextPref.getText()));
  editTextPref=(EditTextPreference)findPreference(getString(R.string.pref_rtlsdr_port));
  editTextPref.setSummary(getString(R.string.pref_rtlsdr_port_summ,editTextPref.getText()));
  editTextPref=(EditTextPreference)findPreference(getString(R.string.pref_rtlsdr_frequencyCorrection));
  if (editTextPref.getText().length() == 0)   editTextPref.setText(getString(R.string.pref_rtlsdr_frequencyCorrection_default));
  editTextPref.setSummary(getString(R.string.pref_rtlsdr_frequencyCorrection_summ,editTextPref.getText()));
  editTextPref=(EditTextPreference)findPreference(getString(R.string.pref_rtlsdr_upconverterFrequencyShift));
  if (editTextPref.getText().length() == 0)   editTextPref.setText(""String_Node_Str"");
  editTextPref.setSummary(getString(R.string.pref_rtlsdr_upconverterFrequencyShift_summ,editTextPref.getText()));
  listPref=(ListPreference)findPreference(getString(R.string.pref_fftSize));
  listPref.setSummary(getString(R.string.pref_fftSize_summ,listPref.getEntry()));
  listPref=(ListPreference)findPreference(getString(R.string.pref_colorMapType));
  listPref.setSummary(getString(R.string.pref_colorMapType_summ,listPref.getEntry()));
  listPref=(ListPreference)findPreference(getString(R.string.pref_fftDrawingType));
  listPref.setSummary(getString(R.string.pref_fftDrawingType_summ,listPref.getEntry()));
  listPref=(ListPreference)findPreference(getString(R.string.pref_averaging));
  listPref.setSummary(getString(R.string.pref_averaging_summ,listPref.getEntry()));
  listPref=(ListPreference)findPreference(getString(R.string.pref_screenOrientation));
  listPref.setSummary(getString(R.string.pref_screenOrientation_summ,listPref.getEntry()));
  listPref=(ListPreference)findPreference(getString(R.string.pref_spectrumWaterfallRatio));
  listPref.setSummary(getString(R.string.pref_spectrumWaterfallRatio_summ,listPref.getEntry()));
  listPref=(ListPreference)findPreference(getString(R.string.pref_fontSize));
  listPref.setSummary(getString(R.string.pref_fontSize_summ,listPref.getEntry()));
  SwitchPreference switchPref=(SwitchPreference)findPreference(getString(R.string.pref_dynamicFrameRate));
  listPref=(ListPreference)findPreference(getString(R.string.pref_frameRate));
  if (switchPref.isChecked())   listPref.setSummary(getString(R.string.pref_frameRate_summ,""String_Node_Str""));
 else   listPref.setSummary(getString(R.string.pref_frameRate_summ,listPref.getEntry()));
  editTextPref=(EditTextPreference)findPreference(getString(R.string.pref_logfile));
  editTextPref.setSummary(getString(R.string.pref_logfile_summ,editTextPref.getText()));
}","/** 
 * Will go through each preference element and initialize/update the summary according to its value.
 * @note this will also correct invalid user inputs on EdittextPreferences!
 */
public void updateSummaries(){
  ListPreference listPref=(ListPreference)findPreference(getString(R.string.pref_sourceType));
  listPref.setSummary(getString(R.string.pref_sourceType_summ,listPref.getEntry()));
  EditTextPreference editTextPref=(EditTextPreference)findPreference(getString(R.string.pref_filesource_frequency));
  if (editTextPref.getText().length() == 0)   editTextPref.setText(getString(R.string.pref_filesource_frequency_default));
  editTextPref.setSummary(getString(R.string.pref_filesource_frequency_summ,editTextPref.getText()));
  editTextPref=(EditTextPreference)findPreference(getString(R.string.pref_filesource_sampleRate));
  if (editTextPref.getText().length() == 0)   editTextPref.setText(getString(R.string.pref_filesource_sampleRate_default));
  editTextPref.setSummary(getString(R.string.pref_filesource_sampleRate_summ,editTextPref.getText()));
  editTextPref=(EditTextPreference)findPreference(getString(R.string.pref_filesource_file));
  editTextPref.setSummary(getString(R.string.pref_filesource_file_summ,editTextPref.getText()));
  listPref=(ListPreference)findPreference(getString(R.string.pref_filesource_format));
  listPref.setSummary(getString(R.string.pref_filesource_format_summ,listPref.getEntry()));
  editTextPref=(EditTextPreference)findPreference(getString(R.string.pref_hackrf_frequencyShift));
  if (editTextPref.getText().length() == 0)   editTextPref.setText(""String_Node_Str"");
  editTextPref.setSummary(getString(R.string.pref_hackrf_frequencyShift_summ,editTextPref.getText()));
  editTextPref=(EditTextPreference)findPreference(getString(R.string.pref_rtlsdr_ip));
  editTextPref.setSummary(getString(R.string.pref_rtlsdr_ip_summ,editTextPref.getText()));
  editTextPref=(EditTextPreference)findPreference(getString(R.string.pref_rtlsdr_port));
  editTextPref.setSummary(getString(R.string.pref_rtlsdr_port_summ,editTextPref.getText()));
  editTextPref=(EditTextPreference)findPreference(getString(R.string.pref_rtlsdr_frequencyCorrection));
  if (editTextPref.getText().length() == 0)   editTextPref.setText(getString(R.string.pref_rtlsdr_frequencyCorrection_default));
  editTextPref.setSummary(getString(R.string.pref_rtlsdr_frequencyCorrection_summ,editTextPref.getText()));
  editTextPref=(EditTextPreference)findPreference(getString(R.string.pref_rtlsdr_frequencyShift));
  if (editTextPref.getText().length() == 0)   editTextPref.setText(""String_Node_Str"");
  editTextPref.setSummary(getString(R.string.pref_rtlsdr_frequencyShift_summ,editTextPref.getText()));
  listPref=(ListPreference)findPreference(getString(R.string.pref_fftSize));
  listPref.setSummary(getString(R.string.pref_fftSize_summ,listPref.getEntry()));
  listPref=(ListPreference)findPreference(getString(R.string.pref_colorMapType));
  listPref.setSummary(getString(R.string.pref_colorMapType_summ,listPref.getEntry()));
  listPref=(ListPreference)findPreference(getString(R.string.pref_fftDrawingType));
  listPref.setSummary(getString(R.string.pref_fftDrawingType_summ,listPref.getEntry()));
  listPref=(ListPreference)findPreference(getString(R.string.pref_averaging));
  listPref.setSummary(getString(R.string.pref_averaging_summ,listPref.getEntry()));
  listPref=(ListPreference)findPreference(getString(R.string.pref_screenOrientation));
  listPref.setSummary(getString(R.string.pref_screenOrientation_summ,listPref.getEntry()));
  listPref=(ListPreference)findPreference(getString(R.string.pref_spectrumWaterfallRatio));
  listPref.setSummary(getString(R.string.pref_spectrumWaterfallRatio_summ,listPref.getEntry()));
  listPref=(ListPreference)findPreference(getString(R.string.pref_fontSize));
  listPref.setSummary(getString(R.string.pref_fontSize_summ,listPref.getEntry()));
  SwitchPreference switchPref=(SwitchPreference)findPreference(getString(R.string.pref_dynamicFrameRate));
  listPref=(ListPreference)findPreference(getString(R.string.pref_frameRate));
  if (switchPref.isChecked())   listPref.setSummary(getString(R.string.pref_frameRate_summ,""String_Node_Str""));
 else   listPref.setSummary(getString(R.string.pref_frameRate_summ,listPref.getEntry()));
  editTextPref=(EditTextPreference)findPreference(getString(R.string.pref_logfile));
  editTextPref.setSummary(getString(R.string.pref_logfile_summ,editTextPref.getText()));
}"
54979,"@Override public void setFrequency(long frequency){
  long actualSourceFrequency=frequency - frequencyShift;
  if (isOpen()) {
    if (actualSourceFrequency < getMinFrequency() || actualSourceFrequency > getMaxFrequency()) {
      Log.e(LOGTAG,""String_Node_Str"" + frequency + ""String_Node_Str""+ frequencyShift+ ""String_Node_Str"");
      return;
    }
    commandThread.executeFrequencyChangeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_FREQUENCY,(int)actualSourceFrequency));
  }
  this.flushQueue();
  this.frequency=actualSourceFrequency;
  this.iqConverter.setFrequency(frequency);
}","@Override public void setFrequency(long frequency){
  long actualSourceFrequency=frequency - frequencyShift;
  if (isOpen()) {
    if (frequency < getMinFrequency() || frequency > getMaxFrequency()) {
      Log.e(LOGTAG,""String_Node_Str"" + frequency + ""String_Node_Str""+ frequencyShift+ ""String_Node_Str"");
      return;
    }
    commandThread.executeFrequencyChangeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_FREQUENCY,(int)actualSourceFrequency));
  }
  this.flushQueue();
  this.frequency=actualSourceFrequency;
  this.iqConverter.setFrequency(frequency);
}"
54980,"@Override public void run(){
  SamplePacket inputSamples=null;
  SamplePacket audioBuffer=null;
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
  audioSink.start();
  decimator.start();
  while (!stopRequested) {
    inputSamples=decimator.getDecimatedPacket(1000);
    if (inputSamples == null) {
      continue;
    }
    applyUserFilter(inputSamples,quadratureSamples);
    decimator.returnDecimatedPacket(inputSamples);
    audioBuffer=audioSink.getPacketBuffer(1000);
switch (demodulationMode) {
case DEMODULATION_OFF:
      break;
case DEMODULATION_AM:
    demodulateAM(quadratureSamples,audioBuffer);
  break;
case DEMODULATION_NFM:
demodulateFM(quadratureSamples,audioBuffer,5000);
break;
case DEMODULATION_WFM:
demodulateFM(quadratureSamples,audioBuffer,75000);
break;
case DEMODULATION_LSB:
demodulateSSB(quadratureSamples,audioBuffer,false);
break;
case DEMODULATION_USB:
demodulateSSB(quadratureSamples,audioBuffer,true);
break;
default :
Log.e(LOGTAG,""String_Node_Str"" + demodulationMode);
}
audioSink.enqueuePacket(audioBuffer);
}
audioSink.stopSink();
decimator.stopDecimator();
this.stopRequested=true;
Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
}","@Override public void run(){
  SamplePacket inputSamples=null;
  SamplePacket audioBuffer=null;
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
  audioSink.start();
  decimator.start();
  while (!stopRequested) {
    inputSamples=decimator.getDecimatedPacket(1000);
    if (inputSamples == null) {
      continue;
    }
    applyUserFilter(inputSamples,quadratureSamples);
    decimator.returnDecimatedPacket(inputSamples);
    audioBuffer=audioSink.getPacketBuffer(1000);
    if (audioBuffer == null) {
      Log.d(LOGTAG,""String_Node_Str"");
      continue;
    }
switch (demodulationMode) {
case DEMODULATION_OFF:
      break;
case DEMODULATION_AM:
    demodulateAM(quadratureSamples,audioBuffer);
  break;
case DEMODULATION_NFM:
demodulateFM(quadratureSamples,audioBuffer,5000);
break;
case DEMODULATION_WFM:
demodulateFM(quadratureSamples,audioBuffer,75000);
break;
case DEMODULATION_LSB:
demodulateSSB(quadratureSamples,audioBuffer,false);
break;
case DEMODULATION_USB:
demodulateSSB(quadratureSamples,audioBuffer,true);
break;
default :
Log.e(LOGTAG,""String_Node_Str"" + demodulationMode);
}
audioSink.enqueuePacket(audioBuffer);
}
audioSink.stopSink();
decimator.stopDecimator();
this.stopRequested=true;
Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
}"
54981,"@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  super.onActivityResult(requestCode,resultCode,data);
switch (requestCode) {
case RTL2832U_RESULT_CODE:
    if (resultCode == RESULT_OK)     Log.i(LOGTAG,""String_Node_Str"");
 else {
      String[] errInfo={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
      int errorId=data.getIntExtra(""String_Node_Str"",-1);
      int exceptionCode=data.getIntExtra(""String_Node_Str"",0);
      String detailedDescription=data.getStringExtra(""String_Node_Str"");
      String errorMsg=""String_Node_Str"";
      if (errorId >= 0 && errorId < errInfo.length)       errorMsg=errInfo[errorId];
      Log.e(LOGTAG,""String_Node_Str"" + errorMsg + ""String_Node_Str""+ errorId+ ""String_Node_Str"");
      if (source != null && source instanceof RtlsdrSource) {
        Toast.makeText(MainActivity.this,""String_Node_Str"" + source.getName() + ""String_Node_Str""+ errorMsg+ ""String_Node_Str""+ errorId+ ""String_Node_Str""+ (detailedDescription != null ? ""String_Node_Str"" + detailedDescription + ""String_Node_Str""+ exceptionCode+ ""String_Node_Str"" : ""String_Node_Str""),Toast.LENGTH_LONG).show();
        source.close();
      }
    }
}
}","@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  super.onActivityResult(requestCode,resultCode,data);
switch (requestCode) {
case RTL2832U_RESULT_CODE:
    if (resultCode == RESULT_OK)     Log.i(LOGTAG,""String_Node_Str"");
 else {
      String[] errInfo={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
      int errorId=data.getIntExtra(""String_Node_Str"",-1);
      int exceptionCode=data.getIntExtra(""String_Node_Str"",0);
      String detailedDescription=data.getStringExtra(""String_Node_Str"");
      String errorMsg=""String_Node_Str"";
      if (errorId >= 0 && errorId < errInfo.length)       errorMsg=errInfo[errorId];
      Log.e(LOGTAG,""String_Node_Str"" + errorMsg + ""String_Node_Str""+ errorId+ ""String_Node_Str"");
      try {
        if (source != null && source instanceof RtlsdrSource) {
          Toast.makeText(MainActivity.this,""String_Node_Str"" + source.getName() + ""String_Node_Str""+ errorMsg+ ""String_Node_Str""+ errorId+ ""String_Node_Str""+ (detailedDescription != null ? ""String_Node_Str"" + detailedDescription + ""String_Node_Str""+ exceptionCode+ ""String_Node_Str"" : ""String_Node_Str""),Toast.LENGTH_LONG).show();
          source.close();
        }
      }
 catch (      NullPointerException e) {
        Log.e(LOGTAG,""String_Node_Str"");
      }
    }
}
}"
54982,"@Override public void onIQSourceError(final IQSourceInterface source,final String message){
  this.runOnUiThread(new Runnable(){
    @Override public void run(){
      Toast.makeText(MainActivity.this,""String_Node_Str"" + source.getName() + ""String_Node_Str""+ message,Toast.LENGTH_LONG).show();
    }
  }
);
  stopAnalyzer();
  if (this.source != null && this.source.isOpen())   this.source.close();
  this.source=null;
}","@Override public void onIQSourceError(final IQSourceInterface source,final String message){
  this.runOnUiThread(new Runnable(){
    @Override public void run(){
      Toast.makeText(MainActivity.this,""String_Node_Str"" + source.getName() + ""String_Node_Str""+ message,Toast.LENGTH_LONG).show();
    }
  }
);
  stopAnalyzer();
  try {
    if (this.source != null && this.source.isOpen())     this.source.close();
  }
 catch (  NullPointerException e) {
    Log.e(LOGTAG,""String_Node_Str"");
  }
  this.source=null;
  analyzerSurface.setSource(null);
}"
54983,"@Override public void setSampleRate(int sampleRate){
  if (isOpen()) {
    if (sampleRate < getMinSampleRate() || sampleRate > getMaxSampleRate()) {
      Log.e(LOGTAG,""String_Node_Str"" + sampleRate);
      return;
    }
    if (!commandThread.executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_SAMPLERATE,sampleRate))) {
      Log.e(LOGTAG,""String_Node_Str"");
    }
  }
  this.sampleRate=sampleRate;
}","@Override public void setSampleRate(int sampleRate){
  if (isOpen()) {
    if (sampleRate < getMinSampleRate() || sampleRate > getMaxSampleRate()) {
      Log.e(LOGTAG,""String_Node_Str"" + sampleRate);
      return;
    }
    if (!commandThread.executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_SAMPLERATE,sampleRate))) {
      Log.e(LOGTAG,""String_Node_Str"");
    }
  }
  this.flushQueue();
  this.sampleRate=sampleRate;
}"
54984,"public void run(){
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
  byte[] nextCommand=null;
  if (connect(10000)) {
    callback.onIQSourceReady(RtlsdrSource.this);
  }
 else {
    Log.e(LOGTAG,""String_Node_Str"");
    reportError(""String_Node_Str"");
    stopRequested=true;
  }
  while (!stopRequested && outputStream != null) {
    try {
      nextCommand=commandQueue.poll(1000,TimeUnit.MILLISECONDS);
      if (nextCommand == null)       continue;
      outputStream.write(nextCommand);
      Log.d(LOGTAG,""String_Node_Str"" + COMMAND_NAME[nextCommand[0]]);
    }
 catch (    IOException e) {
      Log.e(LOGTAG,""String_Node_Str"" + COMMAND_NAME[nextCommand[0]] + ""String_Node_Str""+ e.getMessage());
      reportError(""String_Node_Str"" + COMMAND_NAME[nextCommand[0]]);
      break;
    }
catch (    InterruptedException e) {
      Log.e(LOGTAG,""String_Node_Str"" + COMMAND_NAME[nextCommand[0]] + ""String_Node_Str"");
      reportError(""String_Node_Str"" + COMMAND_NAME[nextCommand[0]]);
      break;
    }
  }
  if (socket != null) {
    try {
      socket.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  socket=null;
  inputStream=null;
  outputStream=null;
  RtlsdrSource.this.commandThread=null;
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
}","public void run(){
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
  threadName=this.getName();
  byte[] nextCommand=null;
  if (connect(10000)) {
    callback.onIQSourceReady(RtlsdrSource.this);
  }
 else {
    Log.e(LOGTAG,""String_Node_Str"");
    reportError(""String_Node_Str"");
    stopRequested=true;
  }
  while (!stopRequested && outputStream != null) {
    try {
      nextCommand=commandQueue.poll(1000,TimeUnit.MILLISECONDS);
      if (nextCommand == null)       continue;
      outputStream.write(nextCommand);
      Log.d(LOGTAG,""String_Node_Str"" + COMMAND_NAME[nextCommand[0]]);
    }
 catch (    IOException e) {
      Log.e(LOGTAG,""String_Node_Str"" + COMMAND_NAME[nextCommand[0]] + ""String_Node_Str""+ e.getMessage());
      reportError(""String_Node_Str"" + COMMAND_NAME[nextCommand[0]]);
      break;
    }
catch (    InterruptedException e) {
      Log.e(LOGTAG,""String_Node_Str"" + COMMAND_NAME[nextCommand[0]] + ""String_Node_Str"");
      reportError(""String_Node_Str"" + COMMAND_NAME[nextCommand[0]]);
      break;
    }
  }
  if (socket != null) {
    try {
      socket.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  socket=null;
  inputStream=null;
  outputStream=null;
  RtlsdrSource.this.commandThread=null;
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
}"
54985,"@Override public void setFrequency(long frequency){
  if (isOpen()) {
    if (frequency < getMinFrequency() || frequency > getMaxFrequency()) {
      Log.e(LOGTAG,""String_Node_Str"" + frequency);
      return;
    }
    if (!commandThread.executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_FREQUENCY,(int)frequency))) {
      Log.e(LOGTAG,""String_Node_Str"");
    }
  }
  this.frequency=frequency;
}","@Override public void setFrequency(long frequency){
  if (isOpen()) {
    if (frequency < getMinFrequency() || frequency > getMaxFrequency()) {
      Log.e(LOGTAG,""String_Node_Str"" + frequency);
      return;
    }
    if (!commandThread.executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_FREQUENCY,(int)frequency))) {
      Log.e(LOGTAG,""String_Node_Str"");
    }
  }
  this.flushQueue();
  this.frequency=frequency;
}"
54986,"@Override public void stopSampling(){
  if (receiverThread != null) {
    receiverThread.stopReceiving();
    try {
      receiverThread.join();
    }
 catch (    InterruptedException e) {
      Log.e(LOGTAG,""String_Node_Str"" + e.getMessage());
    }
    receiverThread=null;
  }
}","@Override public void stopSampling(){
  if (receiverThread != null) {
    receiverThread.stopReceiving();
    if (Thread.currentThread().getName().equals(receiverThread.threadName)) {
      try {
        receiverThread.join();
      }
 catch (      InterruptedException e) {
        Log.e(LOGTAG,""String_Node_Str"" + e.getMessage());
      }
    }
    receiverThread=null;
  }
}"
54987,"@Override public boolean close(){
  if (receiverThread != null)   stopSampling();
  if (commandThread != null) {
    commandThread.stopCommandThread();
    try {
      commandThread.join();
    }
 catch (    InterruptedException e) {
    }
    commandThread=null;
  }
  this.tuner=0;
  this.magic=null;
  this.name=""String_Node_Str"";
  callback=null;
  return true;
}","@Override public boolean close(){
  if (receiverThread != null)   stopSampling();
  if (commandThread != null) {
    commandThread.stopCommandThread();
    if (Thread.currentThread().getName().equals(commandThread.threadName)) {
      try {
        commandThread.join();
      }
 catch (      InterruptedException e) {
      }
    }
    commandThread=null;
  }
  this.tuner=0;
  this.magic=null;
  this.name=""String_Node_Str"";
  return true;
}"
54988,"/** 
 * Called from run(); will setup the connection to the rtl_tcp instance
 */
private boolean connect(int timeoutMillis){
  if (socket != null) {
    Log.e(LOGTAG,""String_Node_Str"");
    return false;
  }
  try {
    long timeoutTime=System.currentTimeMillis() + timeoutMillis;
    while (socket == null && System.currentTimeMillis() < timeoutTime) {
      try {
        socket=new Socket(ipAddress,port);
      }
 catch (      IOException e) {
      }
      sleep(100);
    }
    if (socket == null) {
      Log.e(LOGTAG,""String_Node_Str"");
      return false;
    }
    socket.setTcpNoDelay(true);
    inputStream=socket.getInputStream();
    outputStream=socket.getOutputStream();
    byte[] buffer=new byte[4];
    if (inputStream.read(buffer,0,buffer.length) != buffer.length) {
      Log.e(LOGTAG,""String_Node_Str"");
      return false;
    }
    magic=new String(buffer,""String_Node_Str"");
    if (inputStream.read(buffer,0,buffer.length) != buffer.length) {
      Log.e(LOGTAG,""String_Node_Str"");
      return false;
    }
    tuner=buffer[3];
    if (tuner <= 0 || tuner >= TUNER_STRING.length) {
      Log.e(LOGTAG,""String_Node_Str"");
      return false;
    }
    if (inputStream.read(buffer,0,buffer.length) != buffer.length) {
      Log.e(LOGTAG,""String_Node_Str"");
      return false;
    }
    Log.i(LOGTAG,""String_Node_Str"" + TUNER_STRING[tuner] + ""String_Node_Str""+ magic+ ""String_Node_Str""+ buffer[3]+ ""String_Node_Str""+ ipAddress+ ""String_Node_Str""+ port);
    name=""String_Node_Str"" + TUNER_STRING[tuner] + ""String_Node_Str""+ ipAddress+ ""String_Node_Str""+ port;
    if (frequency > getMaxFrequency())     frequency=getMaxFrequency();
    if (frequency < getMinFrequency())     frequency=getMinFrequency();
    if (sampleRate > getMaxSampleRate())     sampleRate=getMaxSampleRate();
    if (sampleRate < getMinSampleRate())     sampleRate=getMinSampleRate();
    for (    int gainStep : getPossibleGainValues()) {
      if (gainStep >= gain) {
        gain=gainStep;
        break;
      }
    }
    executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_FREQUENCY,(int)frequency));
    executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_SAMPLERATE,sampleRate));
    executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_GAIN_MODE,(int)(manualGain ? 0x01 : 0x00)));
    executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_GAIN,gain));
    if (tuner == RTLSDR_TUNER_E4000)     executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_IFGAIN,(short)0,(short)ifGain));
    executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_FREQ_CORR,frequencyCorrection));
    executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_AGC_MODE,(int)(automaticGainControl ? 0x01 : 0x00)));
    return true;
  }
 catch (  UnknownHostException e) {
    Log.e(LOGTAG,""String_Node_Str"" + ipAddress);
    reportError(""String_Node_Str"" + ipAddress);
  }
catch (  IOException e) {
    Log.e(LOGTAG,""String_Node_Str"" + ipAddress + ""String_Node_Str""+ port+ ""String_Node_Str""+ e.getMessage());
  }
catch (  InterruptedException e) {
    Log.e(LOGTAG,""String_Node_Str"");
  }
  return false;
}","/** 
 * Called from run(); will setup the connection to the rtl_tcp instance
 */
private boolean connect(int timeoutMillis){
  if (socket != null) {
    Log.e(LOGTAG,""String_Node_Str"");
    return false;
  }
  try {
    long timeoutTime=System.currentTimeMillis() + timeoutMillis;
    while (socket == null && System.currentTimeMillis() < timeoutTime) {
      try {
        socket=new Socket(ipAddress,port);
      }
 catch (      IOException e) {
      }
      sleep(100);
    }
    if (socket == null) {
      Log.e(LOGTAG,""String_Node_Str"");
      return false;
    }
    socket.setTcpNoDelay(true);
    socket.setSoTimeout(1000);
    inputStream=socket.getInputStream();
    outputStream=socket.getOutputStream();
    byte[] buffer=new byte[4];
    if (inputStream.read(buffer,0,buffer.length) != buffer.length) {
      Log.e(LOGTAG,""String_Node_Str"");
      return false;
    }
    magic=new String(buffer,""String_Node_Str"");
    if (inputStream.read(buffer,0,buffer.length) != buffer.length) {
      Log.e(LOGTAG,""String_Node_Str"");
      return false;
    }
    tuner=buffer[3];
    if (tuner <= 0 || tuner >= TUNER_STRING.length) {
      Log.e(LOGTAG,""String_Node_Str"");
      return false;
    }
    if (inputStream.read(buffer,0,buffer.length) != buffer.length) {
      Log.e(LOGTAG,""String_Node_Str"");
      return false;
    }
    Log.i(LOGTAG,""String_Node_Str"" + TUNER_STRING[tuner] + ""String_Node_Str""+ magic+ ""String_Node_Str""+ buffer[3]+ ""String_Node_Str""+ ipAddress+ ""String_Node_Str""+ port);
    name=""String_Node_Str"" + TUNER_STRING[tuner] + ""String_Node_Str""+ ipAddress+ ""String_Node_Str""+ port;
    if (frequency > getMaxFrequency())     frequency=getMaxFrequency();
    if (frequency < getMinFrequency())     frequency=getMinFrequency();
    if (sampleRate > getMaxSampleRate())     sampleRate=getMaxSampleRate();
    if (sampleRate < getMinSampleRate())     sampleRate=getMinSampleRate();
    for (    int gainStep : getPossibleGainValues()) {
      if (gainStep >= gain) {
        gain=gainStep;
        break;
      }
    }
    executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_FREQUENCY,(int)frequency));
    executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_SAMPLERATE,sampleRate));
    executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_GAIN_MODE,(int)(manualGain ? 0x01 : 0x00)));
    executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_GAIN,gain));
    if (tuner == RTLSDR_TUNER_E4000)     executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_IFGAIN,(short)0,(short)ifGain));
    executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_FREQ_CORR,frequencyCorrection));
    executeCommand(commandToByteArray(RTL_TCP_COMMAND_SET_AGC_MODE,(int)(automaticGainControl ? 0x01 : 0x00)));
    return true;
  }
 catch (  UnknownHostException e) {
    Log.e(LOGTAG,""String_Node_Str"" + ipAddress);
    reportError(""String_Node_Str"" + ipAddress);
  }
catch (  IOException e) {
    Log.e(LOGTAG,""String_Node_Str"" + ipAddress + ""String_Node_Str""+ port+ ""String_Node_Str""+ e.getMessage());
  }
catch (  InterruptedException e) {
    Log.e(LOGTAG,""String_Node_Str"");
  }
  return false;
}"
54989,"@Override public boolean onScroll(MotionEvent e1,MotionEvent e2,float distanceX,float distanceY){
  if (source != null) {
    virtualFrequency=Math.min(Math.max(virtualFrequency + (long)(((virtualSampleRate / (float)width) * distanceX)),source.getMinFrequency() - source.getSampleRate() / 2),source.getMaxFrequency() + source.getSampleRate() / 2);
    if (virtualFrequency <= 0)     virtualFrequency=1;
    if (verticalScrollEnabled) {
      float yDiff=(maxDB - minDB) * (distanceY / (float)getFftHeight());
      if (maxDB - yDiff > MAX_DB)       yDiff=MAX_DB - maxDB;
      if (minDB - yDiff < MIN_DB)       yDiff=MIN_DB - minDB;
      this.setDBScale(minDB - yDiff,maxDB - yDiff);
    }
    if (source.getFrequency() + source.getSampleRate() / 2 < virtualFrequency + virtualSampleRate / 3 || source.getFrequency() - source.getSampleRate() / 2 > virtualFrequency - virtualSampleRate / 3) {
      if (virtualFrequency >= source.getMinFrequency() && virtualFrequency <= source.getMaxFrequency())       source.setFrequency(virtualFrequency);
    }
  }
  return true;
}","@Override public boolean onScroll(MotionEvent e1,MotionEvent e2,float distanceX,float distanceY){
  if (source != null) {
    virtualFrequency=Math.min(Math.max(virtualFrequency + (long)(((virtualSampleRate / (float)width) * distanceX)),source.getMinFrequency() - source.getSampleRate() / 2),source.getMaxFrequency() + source.getSampleRate() / 2);
    if (virtualFrequency <= 0)     virtualFrequency=1;
    if (verticalScrollEnabled) {
      float yDiff=(maxDB - minDB) * (distanceY / (float)getFftHeight());
      if (maxDB - yDiff > MAX_DB)       yDiff=MAX_DB - maxDB;
      if (minDB - yDiff < MIN_DB)       yDiff=MIN_DB - minDB;
      this.setDBScale(minDB - yDiff,maxDB - yDiff);
    }
    if (source.getFrequency() + source.getSampleRate() / 2 < virtualFrequency + virtualSampleRate / 2 || source.getFrequency() - source.getSampleRate() / 2 > virtualFrequency - virtualSampleRate / 2) {
      if (virtualFrequency >= source.getMinFrequency() && virtualFrequency <= source.getMaxFrequency())       source.setFrequency(virtualFrequency);
    }
  }
  return true;
}"
54990,"@Override public void run(){
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
  long startTime;
  long sleepTime;
  long frequency;
  int sampleRate;
  while (!stopRequested) {
    startTime=System.currentTimeMillis();
    SamplePacket samples;
    try {
      samples=inputQueue.poll(1000 / frameRate,TimeUnit.MILLISECONDS);
      if (samples == null) {
        Log.d(LOGTAG,""String_Node_Str"");
        continue;
      }
    }
 catch (    InterruptedException e) {
      Log.e(LOGTAG,""String_Node_Str"");
      this.stopLoop();
      break;
    }
    frequency=samples.getFrequency();
    sampleRate=samples.getSampleRate();
    this.doProcessing(samples);
    returnQueue.offer(samples);
    view.draw(mag,frequency,sampleRate,frameRate,load);
    sleepTime=(1000 / frameRate) - (System.currentTimeMillis() - startTime);
    try {
      if (sleepTime > 0) {
        load=(System.currentTimeMillis() - startTime) / (1000.0 / frameRate);
        if (dynamicFrameRate && load < LOW_THRESHOLD && frameRate < MAX_FRAMERATE)         frameRate++;
        if (dynamicFrameRate && load > HIGH_THRESHOLD && frameRate > 1)         frameRate--;
        sleep(sleepTime);
      }
 else {
        if (dynamicFrameRate && frameRate > 1)         frameRate--;
        Log.w(LOGTAG,""String_Node_Str"");
        load=1;
      }
    }
 catch (    Exception e) {
      Log.e(LOGTAG,""String_Node_Str"");
    }
  }
  this.stopRequested=true;
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
}","@Override public void run(){
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
  long startTime;
  long sleepTime;
  long frequency;
  int sampleRate;
  while (!stopRequested) {
    startTime=System.currentTimeMillis();
    SamplePacket samples;
    try {
      samples=inputQueue.poll(1000 / frameRate,TimeUnit.MILLISECONDS);
      if (samples == null) {
        Log.d(LOGTAG,""String_Node_Str"");
        continue;
      }
    }
 catch (    InterruptedException e) {
      Log.e(LOGTAG,""String_Node_Str"");
      this.stopLoop();
      break;
    }
    frequency=samples.getFrequency();
    sampleRate=samples.getSampleRate();
    this.doProcessing(samples);
    returnQueue.offer(samples);
    view.draw(mag,frequency,sampleRate,frameRate,load);
    sleepTime=(1000 / frameRate) - (System.currentTimeMillis() - startTime);
    try {
      if (sleepTime > 0) {
        load=(System.currentTimeMillis() - startTime) / (1000.0 / frameRate);
        if (dynamicFrameRate && load < LOW_THRESHOLD && frameRate < MAX_FRAMERATE)         frameRate++;
        if (dynamicFrameRate && load > HIGH_THRESHOLD && frameRate > 1)         frameRate--;
        sleep(sleepTime);
      }
 else {
        if (dynamicFrameRate && frameRate > 1)         frameRate--;
        load=1;
      }
    }
 catch (    Exception e) {
      Log.e(LOGTAG,""String_Node_Str"");
    }
  }
  this.stopRequested=true;
  Log.i(LOGTAG,""String_Node_Str"" + this.getName() + ""String_Node_Str"");
}"
54991,"/** 
 * This method will draw the frequency grid into the canvas
 * @param c				canvas of the surface view
 */
private void drawFrequencyGrid(Canvas c){
  String frequencyStr;
  double MHZ=1000000F;
  double tickFreqMHz;
  float lastTextEndPos=-99999;
  float textPos;
  Rect bounds=new Rect();
  textPaint.getTextBounds(""String_Node_Str"",0,2,bounds);
  float minFreeSpaceBetweenText=bounds.width();
  int tickSize=10;
  float helperVar=virtualSampleRate / 20f;
  while (helperVar > 100) {
    helperVar=helperVar / 10f;
    tickSize=tickSize * 10;
  }
  float pixelPerMinorTick=width / (virtualSampleRate / (float)tickSize);
  long startFrequency=(long)(virtualFrequency - (virtualSampleRate / 2.0));
  long tickFreq=(long)(Math.ceil((double)startFrequency / (float)tickSize) * tickSize);
  float tickPos=pixelPerMinorTick / (float)tickSize * (tickFreq - startFrequency);
  for (int i=0; i < virtualSampleRate / (float)tickSize; i++) {
    float tickHeight;
    if (tickFreq % (tickSize * 10) == 0) {
      tickHeight=(float)(getGridSize() / 2.0);
      tickFreqMHz=tickFreq / MHZ;
      if (tickFreqMHz == (int)tickFreqMHz)       frequencyStr=String.format(""String_Node_Str"",(int)tickFreqMHz);
 else       frequencyStr=String.format(""String_Node_Str"",tickFreqMHz);
      textPaint.getTextBounds(frequencyStr,0,frequencyStr.length(),bounds);
      textPos=tickPos - bounds.width() / 2;
      if (lastTextEndPos + minFreeSpaceBetweenText < textPos) {
        c.drawText(frequencyStr,textPos,getFftHeight() - tickHeight,textPaint);
        lastTextEndPos=textPos + bounds.width();
      }
    }
 else     if (tickFreq % (tickSize * 5) == 0) {
      tickHeight=(float)(getGridSize() / 3.0);
      tickFreqMHz=tickFreq / MHZ;
      if (tickFreqMHz == (int)tickFreqMHz)       frequencyStr=String.format(""String_Node_Str"",(int)tickFreqMHz);
 else       frequencyStr=String.format(""String_Node_Str"",tickFreqMHz);
      textPaint.getTextBounds(frequencyStr,0,frequencyStr.length(),bounds);
      textPos=tickPos - bounds.width() / 2;
      if (lastTextEndPos + minFreeSpaceBetweenText < textPos) {
        if (bounds.width() < pixelPerMinorTick * 4) {
          c.drawText(frequencyStr,textPos,getFftHeight() - tickHeight,textPaint);
          lastTextEndPos=textPos + bounds.width();
        }
      }
    }
 else {
      tickHeight=(float)(getGridSize() / 4.0);
    }
    c.drawLine(tickPos,getFftHeight(),tickPos,getFftHeight() - tickHeight,textPaint);
    tickFreq+=tickSize;
    tickPos+=pixelPerMinorTick;
  }
}","/** 
 * This method will draw the frequency grid into the canvas
 * @param c				canvas of the surface view
 */
private void drawFrequencyGrid(Canvas c){
  String textStr;
  double MHZ=1000000F;
  double tickFreqMHz;
  float lastTextEndPos=-99999;
  float textPos;
  Rect bounds=new Rect();
  textPaint.getTextBounds(""String_Node_Str"",0,2,bounds);
  float minFreeSpaceBetweenText=bounds.width();
  int tickSize=10;
  float helperVar=virtualSampleRate / 20f;
  while (helperVar > 100) {
    helperVar=helperVar / 10f;
    tickSize=tickSize * 10;
  }
  float pixelPerMinorTick=width / (virtualSampleRate / (float)tickSize);
  long startFrequency=(long)(virtualFrequency - (virtualSampleRate / 2.0));
  long tickFreq=(long)(Math.ceil((double)startFrequency / (float)tickSize) * tickSize);
  float tickPos=pixelPerMinorTick / (float)tickSize * (tickFreq - startFrequency);
  for (int i=0; i < virtualSampleRate / (float)tickSize; i++) {
    float tickHeight;
    if (tickFreq % (tickSize * 10) == 0) {
      tickHeight=(float)(getGridSize() / 2.0);
      tickFreqMHz=tickFreq / MHZ;
      if (tickFreqMHz == (int)tickFreqMHz)       textStr=String.format(""String_Node_Str"",(int)tickFreqMHz);
 else       textStr=String.format(""String_Node_Str"",tickFreqMHz);
      textPaint.getTextBounds(textStr,0,textStr.length(),bounds);
      textPos=tickPos - bounds.width() / 2;
      if (lastTextEndPos + minFreeSpaceBetweenText < textPos) {
        c.drawText(textStr,textPos,getFftHeight() - tickHeight,textPaint);
        lastTextEndPos=textPos + bounds.width();
      }
    }
 else     if (tickFreq % (tickSize * 5) == 0) {
      tickHeight=(float)(getGridSize() / 3.0);
      tickFreqMHz=tickFreq / MHZ;
      if (tickFreqMHz == (int)tickFreqMHz)       textStr=String.format(""String_Node_Str"",(int)tickFreqMHz);
 else       textStr=String.format(""String_Node_Str"",tickFreqMHz);
      textPaint.getTextBounds(textStr,0,textStr.length(),bounds);
      textPos=tickPos - bounds.width() / 2;
      if (lastTextEndPos + minFreeSpaceBetweenText < textPos) {
        if (bounds.width() < pixelPerMinorTick * 4) {
          c.drawText(textStr,textPos,getFftHeight() - tickHeight,textPaint);
          lastTextEndPos=textPos + bounds.width();
        }
      }
    }
 else {
      tickHeight=(float)(getGridSize() / 4.0);
    }
    c.drawLine(tickPos,getFftHeight(),tickPos,getFftHeight() - tickHeight,textPaint);
    tickFreq+=tickSize;
    tickPos+=pixelPerMinorTick;
  }
  if (demodulationEnabled) {
    float pxPerHz=width / (float)virtualSampleRate;
    float channelPosition=width / 2 + pxPerHz * (channelFrequency - virtualFrequency);
    float leftBorder=channelPosition - pxPerHz * channelWidth;
    float rightBorder=channelPosition + pxPerHz * channelWidth;
    float dbWidth=getFftHeight() / (maxDB - minDB);
    float squelchPosition=getFftHeight() - (squelch - minDB) * dbWidth;
    demodSelectorPaint.setAlpha(0x7f);
    c.drawRect(leftBorder,0,rightBorder,squelchPosition,demodSelectorPaint);
    demodSelectorPaint.setAlpha(0xff);
    c.drawLine(channelPosition,getFftHeight(),channelPosition,0,demodSelectorPaint);
    c.drawLine(leftBorder,getFftHeight(),leftBorder,0,demodSelectorPaint);
    c.drawLine(rightBorder,getFftHeight(),rightBorder,0,demodSelectorPaint);
    c.drawLine(leftBorder,squelchPosition,rightBorder,squelchPosition,squelchPaint);
    textStr=String.format(""String_Node_Str"",squelch);
    textPaint.getTextBounds(textStr,0,textStr.length(),bounds);
    c.drawText(textStr,channelPosition - bounds.width() / 2f,squelchPosition - bounds.height() * 0.1f,textPaint);
    textStr=String.format(""String_Node_Str"",channelWidth * 2 / 1000);
    textPaint.getTextBounds(textStr,0,textStr.length(),bounds);
    c.drawText(textStr,channelPosition - bounds.width() / 2f,squelchPosition + bounds.height() * 1.1f,textPaint);
  }
}"
54992,"@Override public boolean onDown(MotionEvent e){
  float hzPerPx=virtualSampleRate / (float)width;
  float dbPerPx=(maxDB - minDB) / (float)getFftHeight();
  float frequencyVariation=(float)Math.min(channelWidth / 2.0,virtualSampleRate / 10);
  long touchedFrequency=virtualFrequency - virtualSampleRate / 2 + (long)(e.getX() * hzPerPx);
  float touchedDB=maxDB - e.getY() * dbPerPx;
  if (demodulationEnabled && touchedFrequency < channelFrequency + channelWidth && touchedFrequency > channelFrequency - channelWidth && touchedDB < squelch + (maxDB - minDB) / 10 && touchedDB > squelch - (maxDB - minDB) / 10)   this.scrollType=SCROLLTYPE_SQUELCH;
 else   if (demodulationEnabled && e.getY() <= getFftHeight() && touchedFrequency < channelFrequency + frequencyVariation && touchedFrequency > channelFrequency - frequencyVariation)   this.scrollType=SCROLLTYPE_CHANNEL_FREQUENCY;
 else   if (demodulationEnabled && e.getY() <= getFftHeight() && touchedFrequency < channelFrequency - channelWidth + frequencyVariation && touchedFrequency > channelFrequency - channelWidth - frequencyVariation)   this.scrollType=SCROLLTYPE_CHANNEL_WIDTH_LEFT;
 else   if (demodulationEnabled && e.getY() <= getFftHeight() && touchedFrequency < channelFrequency + channelWidth + frequencyVariation && touchedFrequency > channelFrequency + channelWidth - frequencyVariation)   this.scrollType=SCROLLTYPE_CHANNEL_WIDTH_RIGHT;
 else   this.scrollType=SCROLLTYPE_NORMAL;
  return true;
}","@Override public boolean onDown(MotionEvent e){
  float hzPerPx=virtualSampleRate / (float)width;
  float dbPerPx=(maxDB - minDB) / (float)getFftHeight();
  float channelFrequencyVariation=(float)Math.max(channelWidth * 0.8f,width / 15f * hzPerPx);
  float channelWidthVariation=width / 15 * hzPerPx;
  long touchedFrequency=virtualFrequency - virtualSampleRate / 2 + (long)(e.getX() * hzPerPx);
  float touchedDB=maxDB - e.getY() * dbPerPx;
  if (demodulationEnabled && touchedFrequency < channelFrequency + channelWidth && touchedFrequency > channelFrequency - channelWidth && touchedDB < squelch + (maxDB - minDB) / 7 && touchedDB > squelch - (maxDB - minDB) / 7)   this.scrollType=SCROLLTYPE_SQUELCH;
 else   if (demodulationEnabled && e.getY() <= getFftHeight() && touchedFrequency < channelFrequency + channelFrequencyVariation && touchedFrequency > channelFrequency - channelFrequencyVariation)   this.scrollType=SCROLLTYPE_CHANNEL_FREQUENCY;
 else   if (demodulationEnabled && e.getY() <= getFftHeight() && touchedFrequency < channelFrequency - channelWidth + channelWidthVariation && touchedFrequency > channelFrequency - channelWidth - channelWidthVariation)   this.scrollType=SCROLLTYPE_CHANNEL_WIDTH_LEFT;
 else   if (demodulationEnabled && e.getY() <= getFftHeight() && touchedFrequency < channelFrequency + channelWidth + channelWidthVariation && touchedFrequency > channelFrequency + channelWidth - channelWidthVariation)   this.scrollType=SCROLLTYPE_CHANNEL_WIDTH_RIGHT;
 else   this.scrollType=SCROLLTYPE_NORMAL;
  return true;
}"
54993,"/** 
 * Constructor. Will initialize the Paint instances and register the callback functions of the SurfaceHolder
 * @param context
 */
public AnalyzerSurface(Context context,CallbackInterface callbackHandler){
  super(context);
  this.callbackHandler=callbackHandler;
  this.defaultPaint=new Paint();
  this.blackPaint=new Paint();
  this.blackPaint.setColor(Color.BLACK);
  this.fftPaint=new Paint();
  this.fftPaint.setColor(Color.BLUE);
  this.fftPaint.setStyle(Paint.Style.FILL);
  this.peakHoldPaint=new Paint();
  this.peakHoldPaint.setColor(Color.YELLOW);
  this.textPaint=new Paint();
  this.textPaint.setColor(Color.WHITE);
  this.waterfallLinePaint=new Paint();
  this.demodSelectorPaint=new Paint();
  this.demodSelectorPaint.setColor(Color.WHITE);
  this.getHolder().addCallback(this);
  this.createWaterfallColorMap();
  this.scaleGestureDetector=new ScaleGestureDetector(context,this);
  this.gestureDetector=new GestureDetector(context,this);
}","/** 
 * Constructor. Will initialize the Paint instances and register the callback functions of the SurfaceHolder
 * @param context
 */
public AnalyzerSurface(Context context,CallbackInterface callbackHandler){
  super(context);
  this.callbackHandler=callbackHandler;
  this.defaultPaint=new Paint();
  this.blackPaint=new Paint();
  this.blackPaint.setColor(Color.BLACK);
  this.fftPaint=new Paint();
  this.fftPaint.setColor(Color.BLUE);
  this.fftPaint.setStyle(Paint.Style.FILL);
  this.peakHoldPaint=new Paint();
  this.peakHoldPaint.setColor(Color.YELLOW);
  this.textPaint=new Paint();
  this.textPaint.setColor(Color.WHITE);
  this.waterfallLinePaint=new Paint();
  this.demodSelectorPaint=new Paint();
  this.demodSelectorPaint.setColor(Color.WHITE);
  this.squelchPaint=new Paint();
  this.squelchPaint.setColor(Color.RED);
  this.getHolder().addCallback(this);
  this.createWaterfallColorMap();
  this.scaleGestureDetector=new ScaleGestureDetector(context,this);
  this.gestureDetector=new GestureDetector(context,this);
}"
54994,"public void setDemodulationEnabled(boolean demodulationEnabled){
synchronized (this.getHolder()) {
    if (demodulationEnabled) {
      this.virtualSampleRate=(int)(source.getSampleRate() * 0.9);
      source.setFrequency(virtualFrequency);
      if (channelFrequency < virtualFrequency - virtualSampleRate / 2 || channelFrequency > virtualFrequency + virtualSampleRate / 2) {
        this.channelFrequency=virtualFrequency;
        callbackHandler.onUpdateChannelFrequency(channelFrequency);
      }
      this.channelWidth=callbackHandler.onCurrentChannelWidthRequested();
      if (squelch < minDB || squelch > maxDB) {
        this.squelch=minDB + (maxDB - minDB) / 4;
        callbackHandler.onUpdateSquelch(squelch);
      }
    }
    this.demodulationEnabled=demodulationEnabled;
  }
}","public void setDemodulationEnabled(boolean demodulationEnabled){
synchronized (this.getHolder()) {
    if (demodulationEnabled) {
      if (virtualSampleRate > source.getSampleRate() * 0.9)       this.virtualSampleRate=(int)(source.getSampleRate() * 0.9);
      if (virtualFrequency - virtualSampleRate / 2 < source.getFrequency() - source.getSampleRate() / 2 || virtualFrequency + virtualSampleRate / 2 > source.getFrequency() + source.getSampleRate() / 2)       source.setFrequency(virtualFrequency);
      if (channelFrequency < virtualFrequency - virtualSampleRate / 2 || channelFrequency > virtualFrequency + virtualSampleRate / 2) {
        this.channelFrequency=virtualFrequency;
        callbackHandler.onUpdateChannelFrequency(channelFrequency);
      }
      if (!callbackHandler.onUpdateChannelWidth(channelWidth))       this.channelWidth=callbackHandler.onCurrentChannelWidthRequested();
      if (squelch < minDB || squelch > maxDB) {
        this.squelch=minDB + (maxDB - minDB) / 4;
      }
      callbackHandler.onUpdateSquelchSatisfied(squelchSatisfied);
    }
    this.demodulationEnabled=demodulationEnabled;
  }
}"
54995,"/** 
 * Returns height (in pixel) of each line in the waterfall plot
 * @return number of pixels (in vertical direction) of one line in the waterfall plot
 */
private int getPixelPerWaterfallLine(){
  return 3;
}","/** 
 * Returns height (in pixel) of each line in the waterfall plot
 * @return number of pixels (in vertical direction) of one line in the waterfall plot
 */
private int getPixelPerWaterfallLine(){
  return 1;
}"
54996,"/** 
 * This method will draw the fft onto the canvas. It will also update the bitmap in waterfallLines[waterfallLinesTopIndex] with the data from mag. Important: start and end may be out of bounds of the mag array. This will cause black padding.
 * @param c			canvas of the surface view
 * @param mag		array of magnitude values that represent the fft
 * @param start		first index to draw from mag (may be negative)
 * @param end		last index to draw from mag (may be > mag.length)
 */
private void drawFFT(Canvas c,double[] mag,int start,int end){
  float previousY=getFftHeight();
  float currentY;
  float samplesPerPx=(float)(end - start) / (float)width;
  float dbDiff=maxDB - minDB;
  float dbWidth=getFftHeight() / dbDiff;
  float scale=this.waterfallColorMap.length / dbDiff;
  float avg;
  float peakAvg;
  int counter;
  Canvas newline=new Canvas(waterfallLines[waterfallLinesTopIndex]);
  newline.drawColor(Color.BLACK);
  c.drawRect(0,0,width,getFftHeight(),blackPaint);
  int firstPixel=start >= 0 ? 0 : (int)((start * -1) / samplesPerPx);
  int lastPixel=end >= mag.length ? (int)((mag.length - start) / samplesPerPx) : (int)((end - start) / samplesPerPx);
  for (int i=firstPixel + 1; i < lastPixel; i++) {
    avg=0;
    peakAvg=0;
    counter=0;
    for (int j=(int)(i * samplesPerPx); j < (i + 1) * samplesPerPx; j++) {
      avg+=mag[j + start];
      if (peaks != null)       peakAvg+=peaks[j + start];
      counter++;
    }
    avg=avg / counter;
    if (peaks != null)     peakAvg=peakAvg / counter;
    if (avg > minDB) {
      currentY=getFftHeight() - (avg - minDB) * dbWidth;
      if (currentY < 0)       currentY=0;
switch (fftDrawingType) {
case FFT_DRAWING_TYPE_BAR:
        c.drawLine(i,getFftHeight(),i,currentY,fftPaint);
      break;
case FFT_DRAWING_TYPE_LINE:
    c.drawLine(i - 1,previousY,i,currentY,fftPaint);
  previousY=currentY;
if (i + 1 == lastPixel) c.drawLine(i,previousY,i + 1,getFftHeight(),fftPaint);
break;
default :
Log.e(LOGTAG,""String_Node_Str"" + fftDrawingType);
}
}
if (peaks != null) {
if (peakAvg > minDB) {
peakAvg=getFftHeight() - (peakAvg - minDB) * dbWidth;
if (peakAvg > 0) c.drawPoint(i,peakAvg,peakHoldPaint);
}
}
if (avg <= minDB) waterfallLinePaint.setColor(waterfallColorMap[0]);
 else if (avg >= maxDB) waterfallLinePaint.setColor(waterfallColorMap[waterfallColorMap.length - 1]);
 else waterfallLinePaint.setColor(waterfallColorMap[(int)((avg - minDB) * scale)]);
newline.drawLine(i,0,i,getPixelPerWaterfallLine(),waterfallLinePaint);
}
if (demodulationEnabled) {
float pxPerHz=width / (float)virtualSampleRate;
float channelPosition=width / 2 + pxPerHz * (channelFrequency - virtualFrequency);
float leftBorder=channelPosition - pxPerHz * channelWidth;
float rightBorder=channelPosition + pxPerHz * channelWidth;
float squelchPosition=getFftHeight() - (squelch - minDB) * dbWidth;
demodSelectorPaint.setAlpha(0x7f);
c.drawRect(leftBorder,0,rightBorder,squelchPosition,demodSelectorPaint);
demodSelectorPaint.setAlpha(0xff);
c.drawLine(channelPosition,getFftHeight(),channelPosition,0,demodSelectorPaint);
c.drawLine(leftBorder,getFftHeight(),leftBorder,0,demodSelectorPaint);
c.drawLine(rightBorder,getFftHeight(),rightBorder,0,demodSelectorPaint);
c.drawLine(leftBorder,squelchPosition,rightBorder,squelchPosition,demodSelectorPaint);
}
}","/** 
 * This method will draw the fft onto the canvas. It will also update the bitmap in waterfallLines[waterfallLinesTopIndex] with the data from mag. Important: start and end may be out of bounds of the mag array. This will cause black padding.
 * @param c			canvas of the surface view
 * @param mag		array of magnitude values that represent the fft
 * @param start		first index to draw from mag (may be negative)
 * @param end		last index to draw from mag (may be > mag.length)
 */
private void drawFFT(Canvas c,double[] mag,int start,int end){
  float previousY=getFftHeight();
  float currentY;
  float samplesPerPx=(float)(end - start) / (float)width;
  float dbDiff=maxDB - minDB;
  float dbWidth=getFftHeight() / dbDiff;
  float scale=this.waterfallColorMap.length / dbDiff;
  float avg;
  float peakAvg;
  int counter;
  Canvas newline=new Canvas(waterfallLines[waterfallLinesTopIndex]);
  newline.drawColor(Color.BLACK);
  c.drawRect(0,0,width,getFftHeight(),blackPaint);
  int firstPixel=start >= 0 ? 0 : (int)((start * -1) / samplesPerPx);
  int lastPixel=end >= mag.length ? (int)((mag.length - start) / samplesPerPx) : (int)((end - start) / samplesPerPx);
  for (int i=firstPixel + 1; i < lastPixel; i++) {
    avg=0;
    peakAvg=0;
    counter=0;
    for (int j=(int)(i * samplesPerPx); j < (i + 1) * samplesPerPx; j++) {
      avg+=mag[j + start];
      if (peaks != null)       peakAvg+=peaks[j + start];
      counter++;
    }
    avg=avg / counter;
    if (peaks != null)     peakAvg=peakAvg / counter;
    if (avg > minDB) {
      currentY=getFftHeight() - (avg - minDB) * dbWidth;
      if (currentY < 0)       currentY=0;
switch (fftDrawingType) {
case FFT_DRAWING_TYPE_BAR:
        c.drawLine(i,getFftHeight(),i,currentY,fftPaint);
      break;
case FFT_DRAWING_TYPE_LINE:
    c.drawLine(i - 1,previousY,i,currentY,fftPaint);
  previousY=currentY;
if (i + 1 == lastPixel) c.drawLine(i,previousY,i + 1,getFftHeight(),fftPaint);
break;
default :
Log.e(LOGTAG,""String_Node_Str"" + fftDrawingType);
}
}
if (peaks != null) {
if (peakAvg > minDB) {
peakAvg=getFftHeight() - (peakAvg - minDB) * dbWidth;
if (peakAvg > 0) c.drawPoint(i,peakAvg,peakHoldPaint);
}
}
if (avg <= minDB) waterfallLinePaint.setColor(waterfallColorMap[0]);
 else if (avg >= maxDB) waterfallLinePaint.setColor(waterfallColorMap[waterfallColorMap.length - 1]);
 else waterfallLinePaint.setColor(waterfallColorMap[(int)((avg - minDB) * scale)]);
newline.drawLine(i,0,i,getPixelPerWaterfallLine(),waterfallLinePaint);
}
}"
54997,"@Override public boolean onScroll(MotionEvent e1,MotionEvent e2,float distanceX,float distanceY){
  if (source != null) {
    float hzPerPx=virtualSampleRate / (float)width;
switch (this.scrollType) {
case SCROLLTYPE_NORMAL:
      virtualFrequency=Math.min(Math.max(virtualFrequency + (long)(hzPerPx * distanceX),source.getMinFrequency() - source.getSampleRate() / 2),source.getMaxFrequency() + source.getSampleRate() / 2);
    if (virtualFrequency <= 0)     virtualFrequency=1;
  if (demodulationEnabled && channelFrequency < virtualFrequency - virtualSampleRate / 2) {
    channelFrequency=virtualFrequency - virtualSampleRate / 2;
    callbackHandler.onUpdateChannelFrequency(channelFrequency);
  }
if (demodulationEnabled && channelFrequency > virtualFrequency + virtualSampleRate / 2) {
  channelFrequency=virtualFrequency + virtualSampleRate / 2;
  callbackHandler.onUpdateChannelFrequency(channelFrequency);
}
break;
case SCROLLTYPE_CHANNEL_FREQUENCY:
channelFrequency-=distanceX * hzPerPx;
callbackHandler.onUpdateChannelFrequency(channelFrequency);
break;
case SCROLLTYPE_CHANNEL_WIDTH_LEFT:
case SCROLLTYPE_CHANNEL_WIDTH_RIGHT:
int tmpChannelWidth=scrollType == SCROLLTYPE_CHANNEL_WIDTH_LEFT ? (int)(channelWidth + distanceX * hzPerPx) : (int)(channelWidth - distanceX * hzPerPx);
if (callbackHandler.onUpdateChannelWidth(tmpChannelWidth)) channelWidth=tmpChannelWidth;
break;
case SCROLLTYPE_SQUELCH:
float dbPerPx=(maxDB - minDB) / (float)getFftHeight();
squelch=squelch + distanceY * dbPerPx;
callbackHandler.onUpdateSquelch(squelch);
break;
default :
Log.e(LOGTAG,""String_Node_Str"" + scrollType);
}
if (verticalScrollEnabled && scrollType != SCROLLTYPE_SQUELCH) {
float yDiff=(maxDB - minDB) * (distanceY / (float)getFftHeight());
if (maxDB - yDiff > MAX_DB) yDiff=MAX_DB - maxDB;
if (minDB - yDiff < MIN_DB) yDiff=MIN_DB - minDB;
this.setDBScale(minDB - yDiff,maxDB - yDiff);
}
if (source.getFrequency() + source.getSampleRate() / 2 < virtualFrequency + virtualSampleRate / 2 || source.getFrequency() - source.getSampleRate() / 2 > virtualFrequency - virtualSampleRate / 2) {
if (virtualFrequency >= source.getMinFrequency() && virtualFrequency <= source.getMaxFrequency()) source.setFrequency(virtualFrequency);
}
}
return true;
}","@Override public boolean onScroll(MotionEvent e1,MotionEvent e2,float distanceX,float distanceY){
  if (source != null) {
    float hzPerPx=virtualSampleRate / (float)width;
switch (this.scrollType) {
case SCROLLTYPE_NORMAL:
      virtualFrequency=Math.min(Math.max(virtualFrequency + (long)(hzPerPx * distanceX),source.getMinFrequency() - source.getSampleRate() / 2),source.getMaxFrequency() + source.getSampleRate() / 2);
    if (virtualFrequency <= 0)     virtualFrequency=1;
  if (demodulationEnabled && channelFrequency < virtualFrequency - virtualSampleRate / 2) {
    channelFrequency=virtualFrequency - virtualSampleRate / 2;
    callbackHandler.onUpdateChannelFrequency(channelFrequency);
  }
if (demodulationEnabled && channelFrequency > virtualFrequency + virtualSampleRate / 2) {
  channelFrequency=virtualFrequency + virtualSampleRate / 2;
  callbackHandler.onUpdateChannelFrequency(channelFrequency);
}
break;
case SCROLLTYPE_CHANNEL_FREQUENCY:
channelFrequency-=distanceX * hzPerPx;
callbackHandler.onUpdateChannelFrequency(channelFrequency);
break;
case SCROLLTYPE_CHANNEL_WIDTH_LEFT:
case SCROLLTYPE_CHANNEL_WIDTH_RIGHT:
int tmpChannelWidth=scrollType == SCROLLTYPE_CHANNEL_WIDTH_LEFT ? (int)(channelWidth + distanceX * hzPerPx) : (int)(channelWidth - distanceX * hzPerPx);
if (callbackHandler.onUpdateChannelWidth(tmpChannelWidth)) channelWidth=tmpChannelWidth;
break;
case SCROLLTYPE_SQUELCH:
float dbPerPx=(maxDB - minDB) / (float)getFftHeight();
squelch=squelch + distanceY * dbPerPx;
if (squelch < minDB) squelch=minDB;
break;
default :
Log.e(LOGTAG,""String_Node_Str"" + scrollType);
}
if (verticalScrollEnabled && scrollType != SCROLLTYPE_SQUELCH) {
float yDiff=(maxDB - minDB) * (distanceY / (float)getFftHeight());
if (maxDB - yDiff > MAX_DB) yDiff=MAX_DB - maxDB;
if (minDB - yDiff < MIN_DB) yDiff=MIN_DB - minDB;
this.setDBScale(minDB - yDiff,maxDB - yDiff);
if (squelch < minDB) squelch=minDB;
if (squelch > maxDB) squelch=maxDB;
}
if (source.getFrequency() + source.getSampleRate() / 2 < virtualFrequency + virtualSampleRate / 2 || source.getFrequency() - source.getSampleRate() / 2 > virtualFrequency - virtualSampleRate / 2) {
if (virtualFrequency >= source.getMinFrequency() && virtualFrequency <= source.getMaxFrequency()) source.setFrequency(virtualFrequency);
}
}
return true;
}"
54998,"/** 
 * This method will draw the performance information into the canvas
 * @param c				canvas of the surface view
 * @param frameRate 	current frame rate (FPS)
 * @param load			current load (percentage [0..1])
 */
private void drawPerformanceInfo(Canvas c,int frameRate,double load){
  Rect bounds=new Rect();
  String text;
  text=frameRate + ""String_Node_Str"";
  textPaint.getTextBounds(text,0,text.length(),bounds);
  c.drawText(text,width - bounds.width(),bounds.height(),textPaint);
  text=String.format(""String_Node_Str"",load * 100);
  textPaint.getTextBounds(text,0,text.length(),bounds);
  c.drawText(text,width - bounds.width(),bounds.height() * 2,textPaint);
}","/** 
 * This method will draw the performance information into the canvas
 * @param c				canvas of the surface view
 * @param frameRate 	current frame rate (FPS)
 * @param load			current load (percentage [0..1])
 * @param averageSignalStrength		average magnitude of the signal in the selected channel
 */
private void drawPerformanceInfo(Canvas c,int frameRate,double load,float averageSignalStrength){
  Rect bounds=new Rect();
  String text;
  float yPos=height * 0.01f;
  float rightBorder=width * 0.99f;
  if (demodulationEnabled) {
    text=String.format(""String_Node_Str"",averageSignalStrength);
    textPaint.getTextBounds(text,0,text.length(),bounds);
    float indicatorWidth=width / 10;
    float indicatorPosX=rightBorder - indicatorWidth;
    float indicatorPosY=yPos + bounds.height();
    float squelchTickPos=(squelch - minDB) / (maxDB - minDB) * indicatorWidth;
    float signalWidth=(averageSignalStrength - minDB) / (maxDB - minDB) * indicatorWidth;
    if (signalWidth < 0)     signalWidth=0;
    if (signalWidth > indicatorWidth)     signalWidth=indicatorWidth;
    c.drawRect(indicatorPosX,yPos + bounds.height() * 0.1f,indicatorPosX + signalWidth,indicatorPosY,squelchPaint);
    c.drawLine(indicatorPosX,indicatorPosY,indicatorPosX,yPos,textPaint);
    c.drawLine(rightBorder,indicatorPosY,rightBorder,yPos,textPaint);
    c.drawLine(indicatorPosX,indicatorPosY,rightBorder,indicatorPosY,textPaint);
    c.drawLine(indicatorPosX + squelchTickPos,indicatorPosY + 2,indicatorPosX + squelchTickPos,yPos + bounds.height() * 0.5f,textPaint);
    c.drawText(text,indicatorPosX - bounds.width() * 1.1f,indicatorPosY,textPaint);
    yPos+=bounds.height() * 1.1f;
  }
  text=frameRate + ""String_Node_Str"";
  textPaint.getTextBounds(text,0,text.length(),bounds);
  c.drawText(text,rightBorder - bounds.width(),yPos + bounds.height(),textPaint);
  yPos+=bounds.height() * 1.1f;
  text=String.format(""String_Node_Str"",load * 100);
  textPaint.getTextBounds(text,0,text.length(),bounds);
  c.drawText(text,rightBorder - bounds.width(),yPos + bounds.height(),textPaint);
  yPos+=bounds.height() * 1.1f;
}"
54999,"@Override public boolean onScale(ScaleGestureDetector detector){
  if (source != null) {
    float xScale=detector.getCurrentSpanX() / detector.getPreviousSpanX();
    long frequencyFocus=virtualFrequency + (int)((detector.getFocusX() / width - 0.5) * virtualSampleRate);
    int maxSampleRate=demodulationEnabled ? (int)(source.getSampleRate() * 0.9) : source.getMaxSampleRate();
    virtualSampleRate=(int)Math.min(Math.max(virtualSampleRate / xScale,MIN_VIRTUAL_SAMPLERATE),maxSampleRate);
    virtualFrequency=Math.min(Math.max(frequencyFocus + (long)((virtualFrequency - frequencyFocus) / xScale),source.getMinFrequency() - source.getSampleRate() / 2),source.getMaxFrequency() + source.getSampleRate() / 2);
    if (verticalZoomEnabled) {
      float yScale=detector.getCurrentSpanY() / detector.getPreviousSpanY();
      float dBFocus=maxDB - (maxDB - minDB) * (detector.getFocusY() / getFftHeight());
      float newMinDB=Math.min(Math.max(dBFocus - (dBFocus - minDB) / yScale,MIN_DB),MAX_DB - 10);
      float newMaxDB=Math.min(Math.max(dBFocus - (dBFocus - maxDB) / yScale,newMinDB + 10),MAX_DB);
      this.setDBScale(newMinDB,newMaxDB);
    }
    if (source.getSampleRate() < virtualSampleRate && virtualSampleRate < source.getMaxSampleRate())     source.setSampleRate(source.getNextHigherOptimalSampleRate(virtualSampleRate));
    int nextLower=source.getNextLowerOptimalSampleRate(source.getSampleRate());
    if ((virtualSampleRate < nextLower) && (source.getSampleRate() > nextLower)) {
      source.setSampleRate(nextLower);
    }
  }
  return true;
}","@Override public boolean onScale(ScaleGestureDetector detector){
  if (source != null) {
    float xScale=detector.getCurrentSpanX() / detector.getPreviousSpanX();
    long frequencyFocus=virtualFrequency + (int)((detector.getFocusX() / width - 0.5) * virtualSampleRate);
    int maxSampleRate=demodulationEnabled ? (int)(source.getSampleRate() * 0.9) : source.getMaxSampleRate();
    virtualSampleRate=(int)Math.min(Math.max(virtualSampleRate / xScale,MIN_VIRTUAL_SAMPLERATE),maxSampleRate);
    virtualFrequency=Math.min(Math.max(frequencyFocus + (long)((virtualFrequency - frequencyFocus) / xScale),source.getMinFrequency() - source.getSampleRate() / 2),source.getMaxFrequency() + source.getSampleRate() / 2);
    if (verticalZoomEnabled) {
      float yScale=detector.getCurrentSpanY() / detector.getPreviousSpanY();
      float dBFocus=maxDB - (maxDB - minDB) * (detector.getFocusY() / getFftHeight());
      float newMinDB=Math.min(Math.max(dBFocus - (dBFocus - minDB) / yScale,MIN_DB),MAX_DB - 10);
      float newMaxDB=Math.min(Math.max(dBFocus - (dBFocus - maxDB) / yScale,newMinDB + 10),MAX_DB);
      this.setDBScale(newMinDB,newMaxDB);
      if (squelch < minDB)       squelch=minDB;
      if (squelch > maxDB)       squelch=maxDB;
    }
    if (source.getSampleRate() < virtualSampleRate && virtualSampleRate < source.getMaxSampleRate())     source.setSampleRate(source.getNextHigherOptimalSampleRate(virtualSampleRate));
    int nextLower=source.getNextLowerOptimalSampleRate(source.getSampleRate());
    if ((virtualSampleRate < nextLower) && (source.getSampleRate() > nextLower)) {
      source.setSampleRate(nextLower);
    }
  }
  return true;
}"
55000,"/** 
 * Will (re-)draw the given data set on the surface. Note that it actually only draws a sub set of the fft data depending on the current settings of virtual frequency and sample rate.
 * @param mag			array of magnitude values that represent the fft
 * @param frequency		center frequency
 * @param sampleRate	sample rate
 * @param frameRate 	current frame rate (FPS)
 * @param load			current load (percentage [0..1])
 */
public void draw(double[] mag,long frequency,int sampleRate,int frameRate,double load){
  if (virtualFrequency < 0)   virtualFrequency=frequency;
  if (virtualSampleRate < 0)   virtualSampleRate=sampleRate;
  float samplesPerHz=(float)mag.length / (float)sampleRate;
  long frequencyDiff=virtualFrequency - frequency;
  int sampleRateDiff=virtualSampleRate - sampleRate;
  int start=(int)((frequencyDiff - sampleRateDiff / 2.0) * samplesPerHz);
  int end=mag.length + (int)((frequencyDiff + sampleRateDiff / 2.0) * samplesPerHz);
  if (averageLength > 0) {
    if (historySamples == null || historySamples.length != averageLength || historySamples[0].length != mag.length) {
      historySamples=new double[averageLength][mag.length];
      for (int i=0; i < averageLength; i++) {
        for (int j=0; j < mag.length; j++) {
          historySamples[i][j]=mag[j];
        }
      }
      oldesthistoryIndex=0;
    }
    if (frequency != lastFrequency || sampleRate != lastSampleRate) {
      for (int i=0; i < averageLength; i++) {
        for (int j=0; j < mag.length; j++) {
          historySamples[i][j]=mag[j];
        }
      }
    }
    double tmp;
    for (int i=0; i < mag.length; i++) {
      tmp=mag[i];
      for (int j=0; j < historySamples.length; j++)       tmp+=historySamples[j][i];
      historySamples[oldesthistoryIndex][i]=mag[i];
      mag[i]=tmp / (historySamples.length + 1);
    }
    oldesthistoryIndex=(oldesthistoryIndex + 1) % historySamples.length;
  }
  if (doAutoscaleInNextDraw) {
    doAutoscaleInNextDraw=false;
    float min=MAX_DB;
    float max=MIN_DB;
    for (int i=Math.max(0,start); i < Math.min(mag.length,end); i++) {
      if (i == (mag.length / 2) - 5)       i+=10;
      min=Math.min((float)mag[i],min);
      max=Math.max((float)mag[i],max);
    }
    if (min < max) {
      minDB=Math.max(min,MIN_DB);
      maxDB=Math.min(max,MAX_DB);
    }
  }
  if (peakHoldEnabled) {
    if (peaks == null || peaks.length != mag.length) {
      peaks=new double[mag.length];
      for (int i=0; i < peaks.length; i++)       peaks[i]=-999999F;
    }
    if (frequency != lastFrequency || sampleRate != lastSampleRate) {
      for (int i=0; i < peaks.length; i++)       peaks[i]=-999999F;
    }
    for (int i=0; i < mag.length; i++)     peaks[i]=Math.max(peaks[i],mag[i]);
  }
 else {
    peaks=null;
  }
  Canvas c=null;
  try {
    c=this.getHolder().lockCanvas();
synchronized (this.getHolder()) {
      if (c != null) {
        drawFFT(c,mag,start,end);
        drawWaterfall(c);
        drawFrequencyGrid(c);
        drawPowerGrid(c);
        drawPerformanceInfo(c,frameRate,load);
      }
 else       Log.d(LOGTAG,""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.e(LOGTAG,""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (c != null) {
      this.getHolder().unlockCanvasAndPost(c);
    }
  }
  this.lastFrequency=frequency;
  this.lastSampleRate=sampleRate;
}","/** 
 * Will (re-)draw the given data set on the surface. Note that it actually only draws a sub set of the fft data depending on the current settings of virtual frequency and sample rate.
 * @param mag			array of magnitude values that represent the fft
 * @param frequency		center frequency
 * @param sampleRate	sample rate
 * @param frameRate 	current frame rate (FPS)
 * @param load			current load (percentage [0..1])
 */
public void draw(double[] mag,long frequency,int sampleRate,int frameRate,double load){
  if (virtualFrequency < 0)   virtualFrequency=frequency;
  if (virtualSampleRate < 0)   virtualSampleRate=sampleRate;
  float samplesPerHz=(float)mag.length / (float)sampleRate;
  long frequencyDiff=virtualFrequency - frequency;
  int sampleRateDiff=virtualSampleRate - sampleRate;
  int start=(int)((frequencyDiff - sampleRateDiff / 2.0) * samplesPerHz);
  int end=mag.length + (int)((frequencyDiff + sampleRateDiff / 2.0) * samplesPerHz);
  if (averageLength > 0) {
    if (historySamples == null || historySamples.length != averageLength || historySamples[0].length != mag.length) {
      historySamples=new double[averageLength][mag.length];
      for (int i=0; i < averageLength; i++) {
        for (int j=0; j < mag.length; j++) {
          historySamples[i][j]=mag[j];
        }
      }
      oldesthistoryIndex=0;
    }
    if (frequency != lastFrequency || sampleRate != lastSampleRate) {
      for (int i=0; i < averageLength; i++) {
        for (int j=0; j < mag.length; j++) {
          historySamples[i][j]=mag[j];
        }
      }
    }
    double tmp;
    for (int i=0; i < mag.length; i++) {
      tmp=mag[i];
      for (int j=0; j < historySamples.length; j++)       tmp+=historySamples[j][i];
      historySamples[oldesthistoryIndex][i]=mag[i];
      mag[i]=tmp / (historySamples.length + 1);
    }
    oldesthistoryIndex=(oldesthistoryIndex + 1) % historySamples.length;
  }
  if (doAutoscaleInNextDraw) {
    doAutoscaleInNextDraw=false;
    float min=MAX_DB;
    float max=MIN_DB;
    for (int i=Math.max(0,start); i < Math.min(mag.length,end); i++) {
      if (i == (mag.length / 2) - 5)       i+=10;
      min=Math.min((float)mag[i],min);
      max=Math.max((float)mag[i],max);
    }
    if (min < max) {
      minDB=Math.max(min,MIN_DB);
      maxDB=Math.min(max,MAX_DB);
    }
  }
  if (peakHoldEnabled) {
    if (peaks == null || peaks.length != mag.length) {
      peaks=new double[mag.length];
      for (int i=0; i < peaks.length; i++)       peaks[i]=-999999F;
    }
    if (frequency != lastFrequency || sampleRate != lastSampleRate) {
      for (int i=0; i < peaks.length; i++)       peaks[i]=-999999F;
    }
    for (int i=0; i < mag.length; i++)     peaks[i]=Math.max(peaks[i],mag[i]);
  }
 else {
    peaks=null;
  }
  float averageSignalStrengh=-9999;
  if (demodulationEnabled) {
    float sum=0;
    int chanStart=(int)((channelFrequency - (frequency - sampleRate / 2) - channelWidth / 2) * samplesPerHz);
    int chanEnd=(int)(chanStart + channelWidth * samplesPerHz);
    if (chanStart > 0 && chanEnd <= mag.length) {
      for (int i=chanStart; i < chanEnd; i++)       sum+=mag[i];
      averageSignalStrengh=sum / (chanEnd - chanStart);
      if (averageSignalStrengh >= squelch && squelchSatisfied == false) {
        squelchSatisfied=true;
        this.squelchPaint.setColor(Color.GREEN);
        callbackHandler.onUpdateSquelchSatisfied(squelchSatisfied);
      }
 else       if (averageSignalStrengh < squelch && squelchSatisfied == true) {
        squelchSatisfied=false;
        this.squelchPaint.setColor(Color.RED);
        callbackHandler.onUpdateSquelchSatisfied(squelchSatisfied);
      }
    }
  }
  Canvas c=null;
  try {
    c=this.getHolder().lockCanvas();
synchronized (this.getHolder()) {
      if (c != null) {
        drawFFT(c,mag,start,end);
        drawWaterfall(c);
        drawFrequencyGrid(c);
        drawPowerGrid(c);
        drawPerformanceInfo(c,frameRate,load,averageSignalStrengh);
      }
 else       Log.d(LOGTAG,""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    Log.e(LOGTAG,""String_Node_Str"");
    e.printStackTrace();
  }
 finally {
    if (c != null) {
      this.getHolder().unlockCanvasAndPost(c);
    }
  }
  this.lastFrequency=frequency;
  this.lastSampleRate=sampleRate;
}"
