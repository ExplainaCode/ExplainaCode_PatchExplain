record_number,buggy_code,fixed_code
50001,"@Override public void mousePressed(MouseEvent arg0){
}","public void mousePressed(MouseEvent arg0){
}"
50002,"@Override public void mouseReleased(MouseEvent arg0){
}","public void mouseReleased(MouseEvent arg0){
}"
50003,"@Override public void mouseEntered(MouseEvent arg0){
}","public void mouseEntered(MouseEvent arg0){
}"
50004,"/** 
 * Create a pop up window with customization options. Let the user choose between adding a piece to the square or customizing options of the piece.
 */
private void options(){
  final JFrame popup=new JFrame(""String_Node_Str"");
  popup.setSize(300,160);
  popup.setLocationRelativeTo(null);
  popup.setLayout(new FlowLayout());
  popup.setResizable(false);
  final JButton squareButton=new JButton(""String_Node_Str"");
  squareButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      squareOptions();
      popup.dispose();
    }
  }
);
  popup.add(squareButton);
  final JButton makePiece=new JButton(""String_Node_Str"");
  makePiece.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (square.isHabitable()) {
        askForPiece();
      }
 else {
        JOptionPane.showMessageDialog(popup,""String_Node_Str"");
      }
      popup.dispose();
    }
  }
);
  popup.add(makePiece);
  final JButton removePiece=new JButton(""String_Node_Str"");
  removePiece.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent arg0){
      square.setPiece(null);
      square.refresh();
      popup.dispose();
    }
  }
);
  if (square.isOccupied())   removePiece.setEnabled(true);
 else   removePiece.setEnabled(false);
  popup.add(removePiece);
  popup.setVisible(true);
}","/** 
 * Create a pop up window with customization options. Let the user choose between adding a piece to the square or customizing options of the piece.
 */
private void options(){
  final JFrame popup=new JFrame(""String_Node_Str"");
  popup.setSize(300,90);
  popup.setLocationRelativeTo(null);
  popup.setLayout(new FlowLayout());
  popup.setResizable(false);
  final JButton squareButton=new JButton(""String_Node_Str"");
  squareButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      squareOptions();
      popup.dispose();
    }
  }
);
  popup.add(squareButton);
  popup.setVisible(true);
}"
50005,"/** 
 * @param r Reference to which button the user clicked for the end game. ""Save"" ""New Game"" or ""Quit""
 */
public static void endOfGame(Result r){
  if (isPlayback)   return;
  Object[] options=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  String toDisplay;
  System.out.println(r.isDraw());
  if (r.isDraw())   toDisplay=""String_Node_Str"" + ""String_Node_Str"";
 else   toDisplay=""String_Node_Str"" + r.text() + ""String_Node_Str""+ ""String_Node_Str"";
  toDisplay+=""String_Node_Str"";
  int answer=JOptionPane.showOptionDialog(null,toDisplay,r.text(),JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.PLAIN_MESSAGE,null,options,options[0]);
switch (answer) {
case 0:
    String fileName=JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
  g.saveGame(""String_Node_Str"",fileName,g.isClassicChess());
Driver.getInstance().revertPanel();
break;
case 2:
System.exit(0);
break;
default :
Driver.getInstance().revertPanel();
}
}","/** 
 * @param r Reference to which button the user clicked for the end game. ""Save"" ""New Game"" or ""Quit""
 */
public static void endOfGame(Result r){
  if (isPlayback)   return;
  Object[] options=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  String toDisplay;
  if (r.isDraw())   toDisplay=""String_Node_Str"" + ""String_Node_Str"";
 else   toDisplay=""String_Node_Str"" + r.text() + ""String_Node_Str""+ ""String_Node_Str"";
  toDisplay+=""String_Node_Str"";
  int answer=JOptionPane.showOptionDialog(null,toDisplay,r.text(),JOptionPane.YES_NO_CANCEL_OPTION,JOptionPane.PLAIN_MESSAGE,null,options,options[0]);
switch (answer) {
case 0:
    String fileName=JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
  g.saveGame(""String_Node_Str"",fileName,g.isClassicChess());
Driver.getInstance().revertPanel();
break;
case 2:
System.exit(0);
break;
default :
Driver.getInstance().revertPanel();
}
}"
50006,"/** 
 * Play a move in the Game
 * @param move The Move to play
 * @throws Exception If the Move was illegal
 */
public void playMove(Move move) throws Exception {
  Move m=move;
  m.execute();
  if (getHistory().contains(m))   return;
  getHistory().add(m);
  if (!isBlackMove()) {
    getBlackRules().endOfGame(blackObjectivePiece);
  }
 else {
    getWhiteRules().endOfGame(whiteObjectivePiece);
  }
}","/** 
 * Play a move in the Game
 * @param move The Move to play
 * @throws Exception If the Move was illegal
 */
public void playMove(Move move) throws Exception {
  Move m=move;
  m.execute();
  if (getHistory().contains(m))   return;
  getHistory().add(m);
  if (isBlackMove()) {
    getBlackRules().endOfGame(blackObjectivePiece);
  }
 else {
    getWhiteRules().endOfGame(whiteObjectivePiece);
  }
}"
50007,"/** 
 * Constructor. Call initComponents to initialize the GUI.
 * @param g The reference to the game being played.
 * @param isPlayback whether PlayGame is in play back mode
 */
public PlayGame(Game g,boolean isPlayback){
  PlayGame.g=g;
  PlayGame.isPlayback=isPlayback;
  if (isPlayback) {
    PlayGame.whiteTimer=new NoTimer();
    PlayGame.blackTimer=new NoTimer();
    history=new Move[g.getHistory().size()];
    g.getHistory().toArray(history);
    index=history.length - 1;
    while (index >= 0) {
      history[index].undo();
      index--;
    }
  }
 else {
    mustMove=false;
    PlayGame.whiteTimer=g.getWhiteTimer();
    PlayGame.blackTimer=g.getBlackTimer();
    whiteTimer.restart();
    blackTimer.restart();
    turn(g.isBlackMove());
    history=null;
    index=-3;
  }
  initComponents(isPlayback);
  boardRefresh(g.getBoards());
}","/** 
 * Constructor. Call initComponents to initialize the GUI.
 * @param g The reference to the game being played.
 * @param isPlayback whether PlayGame is in play back mode
 */
public PlayGame(Game g,boolean isPlayback){
  PlayGame.g=g;
  PlayGame.isPlayback=isPlayback;
  initComponents(isPlayback);
  if (isPlayback) {
    PlayGame.whiteTimer=new NoTimer();
    PlayGame.blackTimer=new NoTimer();
    history=new Move[g.getHistory().size()];
    g.getHistory().toArray(history);
    index=history.length - 1;
    while (index >= 0) {
      history[index].undo();
      index--;
    }
  }
 else {
    mustMove=false;
    PlayGame.whiteTimer=g.getWhiteTimer();
    PlayGame.blackTimer=g.getBlackTimer();
    whiteTimer.restart();
    blackTimer.restart();
    turn(g.isBlackMove());
    history=null;
    index=-3;
  }
  boardRefresh(g.getBoards());
}"
50008,"/** 
 * Constructor. Call initComponents to initialize the GUI.
 * @param g The reference to the game being played.
 * @param isPlayback whether PlayGame is in play back mode
 */
public PlayGame(Game g,boolean isPlayback){
  PlayGame.g=g;
  PlayGame.isPlayback=isPlayback;
  initComponents(isPlayback);
  if (isPlayback) {
    PlayGame.whiteTimer=new NoTimer();
    PlayGame.blackTimer=new NoTimer();
    history=new Move[g.getHistory().size()];
    g.getHistory().toArray(history);
    index=history.length - 1;
    while (index >= 0) {
      history[index].undo();
      index--;
    }
  }
 else {
    mustMove=false;
    PlayGame.whiteTimer=g.getWhiteTimer();
    PlayGame.blackTimer=g.getBlackTimer();
    whiteTimer.restart();
    blackTimer.restart();
    turn(g.isBlackMove());
    history=null;
    index=-3;
  }
  boardRefresh(g.getBoards());
}","/** 
 * Constructor. Call initComponents to initialize the GUI.
 * @param g The reference to the game being played.
 * @param isPlayback whether PlayGame is in play back mode
 */
public PlayGame(Game g,boolean isPlayback){
  PlayGame.g=g;
  PlayGame.isPlayback=isPlayback;
  if (isPlayback) {
    PlayGame.whiteTimer=new NoTimer();
    PlayGame.blackTimer=new NoTimer();
    history=new Move[g.getHistory().size()];
    g.getHistory().toArray(history);
    initComponents(isPlayback);
    index=history.length - 1;
    while (index >= 0) {
      history[index].undo();
      index--;
    }
  }
 else {
    mustMove=false;
    PlayGame.whiteTimer=g.getWhiteTimer();
    PlayGame.blackTimer=g.getBlackTimer();
    whiteTimer.restart();
    blackTimer.restart();
    turn(g.isBlackMove());
    history=null;
    index=-3;
    initComponents(isPlayback);
  }
  boardRefresh(g.getBoards());
}"
50009,"/** 
 * Generate the ArrayList of legal destinations for this Piece
 * @param board The Board on which to look for legal destinations
 * @return The number of legal destinations for this Piece
 */
public int genLegalDests(Board board){
  getLegalDests().clear();
  getGuardSquares().clear();
  setPinnedBy(null);
  boolean done=false;
  Square dest;
  boolean wraparound=board.isWraparound();
  if (movements.containsKey('E')) {
    int northMax=movements.get('E') + curSquare.getCol();
    if (northMax > board.getMaxCol() || movements.get('E') == -1)     if (!wraparound) {
      northMax=board.getMaxCol();
    }
    for (int c=curSquare.getCol() + 1; ((movements.get('E') == -1 && wraparound) ? true : c <= northMax) && !done; c++) {
      int j=c;
      if (wraparound)       if (j > board.getMaxCol()) {
        j=j % board.getMaxCol();
      }
      if (j == 0) {
        break;
      }
      dest=board.getSquare(curSquare.getRow(),j);
      done=!addLegalDest(dest);
      done=(done || (dest.isOccupied() && !(board.isBlackTurn() != isBlack() && dest.getPiece().equals(board.getGame().getOtherObjectivePiece(isBlack())))));
    }
  }
  done=false;
  if (movements.containsKey('W')) {
    int southMax=curSquare.getCol() - movements.get('W');
    if (southMax < 1 || movements.get('W') == -1)     if (!wraparound) {
      southMax=1;
    }
    for (int c=curSquare.getCol() - 1; ((movements.get('W') == -1 && wraparound) ? true : c >= southMax) && !done; c--) {
      int j=c;
      if (wraparound)       if (j < 1) {
        j=board.getMaxCol() + j;
      }
      dest=board.getSquare(curSquare.getRow(),j);
      done=!addLegalDest(dest);
      done=(done || leaper ? false : (dest.isOccupied() && !(board.isBlackTurn() != isBlack() && dest.getPiece().equals(board.getGame().getOtherObjectivePiece(isBlack())))));
    }
  }
  done=false;
  if (movements.containsKey('N')) {
    int eastMax=movements.get('N') + curSquare.getRow();
    if (eastMax >= board.getMaxRow() || movements.get('N') == -1) {
      eastMax=board.getMaxRow();
    }
    for (int r=curSquare.getRow() + 1; (r <= eastMax) && !done; r++) {
      int j=r;
      dest=board.getSquare(j,curSquare.getCol());
      done=!addLegalDest(dest);
      done=(done || leaper ? false : (dest.isOccupied() && !(board.isBlackTurn() != isBlack() && dest.getPiece().equals(board.getGame().getOtherObjectivePiece(isBlack())))));
    }
  }
  done=false;
  if (movements.containsKey('S')) {
    int westMax=curSquare.getRow() - movements.get('S');
    if (westMax < 1 || movements.get('S') == -1) {
      westMax=1;
    }
    for (int r=curSquare.getRow() - 1; (r >= westMax) && !done; r--) {
      int j=r;
      dest=board.getSquare(j,curSquare.getCol());
      done=!addLegalDest(dest);
      done=(done || leaper ? false : (dest.isOccupied() && !(board.isBlackTurn() != isBlack() && dest.getPiece().equals(board.getGame().getOtherObjectivePiece(isBlack())))));
    }
  }
  done=false;
  if (movements.containsKey('R')) {
    int neMax=((curSquare.getRow() >= curSquare.getCol()) ? curSquare.getRow() : curSquare.getCol()) + movements.get('R');
    if (neMax >= board.getMaxCol() || movements.get('R') == -1) {
      neMax=board.getMaxCol();
    }
    if (neMax >= board.getMaxRow() || movements.get('R') == -1) {
      neMax=board.getMaxRow();
    }
    for (int r=curSquare.getRow() + 1, c=curSquare.getCol() + 1; r <= neMax && c <= neMax && !done; r++, c++) {
      dest=board.getSquare(r,c);
      done=!addLegalDest(dest);
      done=(done || leaper ? false : (dest.isOccupied() && !(board.isBlackTurn() != isBlack() && dest.getPiece().equals(board.getGame().getOtherObjectivePiece(isBlack())))));
    }
  }
  done=false;
  if (movements.containsKey('r')) {
    int eastMax=curSquare.getCol() + movements.get('r');
    if (eastMax >= board.getMaxCol() || movements.get('r') == -1) {
      eastMax=board.getMaxCol();
    }
    int southMin=curSquare.getRow() - movements.get('r');
    if (southMin <= 1 || movements.get('R') == -1) {
      southMin=1;
    }
    for (int r=curSquare.getRow() - 1, c=curSquare.getCol() + 1; r >= southMin && c <= eastMax && !done; r--, c++) {
      dest=board.getSquare(r,c);
      done=!addLegalDest(dest);
      done=(done || leaper ? false : (dest.isOccupied() && !(board.isBlackTurn() != isBlack() && dest.getPiece().equals(board.getGame().getOtherObjectivePiece(isBlack())))));
    }
  }
  done=false;
  if (movements.containsKey('L')) {
    int westMin=curSquare.getCol() - movements.get('L');
    if (westMin <= 1 || movements.get('L') == -1) {
      westMin=1;
    }
    int NorthMax=curSquare.getRow() + movements.get('L');
    if (NorthMax >= board.getMaxRow() || movements.get('L') == -1) {
      NorthMax=board.getMaxRow();
    }
    for (int r=curSquare.getRow() + 1, c=curSquare.getCol() - 1; r <= NorthMax && c >= westMin && !done; r++, c--) {
      dest=board.getSquare(r,c);
      done=!addLegalDest(dest);
      done=(done || leaper ? false : (dest.isOccupied() && !(board.isBlackTurn() != isBlack() && dest.getPiece().equals(board.getGame().getOtherObjectivePiece(isBlack())))));
    }
  }
  done=false;
  if (movements.containsKey('l')) {
    int westMin=curSquare.getCol() - movements.get('l');
    if (westMin <= 1 || movements.get('l') == -1) {
      westMin=1;
    }
    int southMin=curSquare.getRow() - movements.get('l');
    if (southMin <= 1 || movements.get('l') == -1) {
      southMin=1;
    }
    for (int r=curSquare.getRow() - 1, c=curSquare.getCol() - 1; r >= southMin && c >= westMin && !done; r--, c--) {
      dest=board.getSquare(r,c);
      done=!addLegalDest(dest);
      done=(done || leaper ? false : (dest.isOccupied() && !(board.isBlackTurn() != isBlack() && dest.getPiece().equals(board.getGame().getOtherObjectivePiece(isBlack())))));
    }
  }
  int f, r;
  int Rank=3;
  int File=2;
  f=(curSquare.getRow() + File);
  r=(curSquare.getCol() + Rank);
  if (wraparound) {
    if (r > board.getMaxCol() + 1) {
      r=r % board.getMaxCol();
    }
  }
  if (board.isRowValid(f) && board.isColValid(r)) {
    addLegalDest(board.getSquare(f,r));
  }
  f=(curSquare.getRow() + Rank);
  r=(curSquare.getCol() + File);
  if (wraparound) {
    if (r > board.getMaxCol() + 1) {
      r=r % board.getMaxCol();
    }
  }
  if (board.isRowValid(f) && board.isColValid(r)) {
    addLegalDest(board.getSquare(f,r));
  }
  f=(curSquare.getRow() + File);
  r=(curSquare.getCol() - Rank);
  if (wraparound) {
    if (r < 1) {
      r=board.getMaxCol() + r;
    }
  }
  if (board.isRowValid(f) && board.isColValid(r)) {
    addLegalDest(board.getSquare(f,r));
  }
  f=(curSquare.getRow() + Rank);
  r=(curSquare.getCol() - File);
  if (wraparound) {
    if (r < 1) {
      r=board.getMaxCol() + r;
    }
  }
  if (board.isRowValid(f) && board.isColValid(r)) {
    addLegalDest(board.getSquare(f,r));
  }
  f=(curSquare.getRow() - File);
  r=(curSquare.getCol() - Rank);
  if (wraparound) {
    if (r < 1) {
      r=board.getMaxCol() + r;
    }
  }
  if (board.isRowValid(f) && board.isColValid(r)) {
    addLegalDest(board.getSquare(f,r));
  }
  f=(curSquare.getRow() - Rank);
  r=(curSquare.getCol() - File);
  if (wraparound) {
    if (r < 1) {
      r=board.getMaxCol() + r;
    }
  }
  if (board.isRowValid(f) && board.isColValid(r)) {
    addLegalDest(board.getSquare(f,r));
  }
  f=(curSquare.getRow() - File);
  r=(curSquare.getCol() + Rank);
  if (wraparound) {
    if (r > board.getMaxCol() + 1) {
      r=r % board.getMaxCol();
    }
  }
  if (board.isRowValid(f) && board.isColValid(r)) {
    addLegalDest(board.getSquare(f,r));
  }
  f=(curSquare.getRow() - Rank);
  r=(curSquare.getCol() + File);
  if (wraparound) {
    if (r > board.getMaxCol() + 1) {
      r=r % board.getMaxCol();
    }
  }
  if (board.isRowValid(f) && board.isColValid(r)) {
    addLegalDest(board.getSquare(f,r));
  }
  return getLegalDests().size();
}","/** 
 * Generate the ArrayList of legal destinations for this Piece
 * @param board The Board on which to look for legal destinations
 * @return The number of legal destinations for this Piece
 */
public int genLegalDests(Board board){
  getLegalDests().clear();
  getGuardSquares().clear();
  setPinnedBy(null);
  boolean done=false;
  Square dest;
  boolean wraparound=board.isWraparound();
  if (movements.containsKey('E')) {
    int northMax=movements.get('E') + curSquare.getCol();
    if (northMax > board.getMaxCol() || movements.get('E') == -1)     if (!wraparound) {
      northMax=board.getMaxCol();
    }
    for (int c=curSquare.getCol() + 1; ((movements.get('E') == -1 && wraparound) ? true : c <= northMax) && !done; c++) {
      int j=c;
      if (wraparound)       if (j > board.getMaxCol()) {
        j=j % board.getMaxCol();
      }
      if (j == 0) {
        break;
      }
      dest=board.getSquare(curSquare.getRow(),j);
      done=!addLegalDest(dest);
      done=(done || (dest.isOccupied() && !(board.isBlackTurn() != isBlack() && dest.getPiece().equals(board.getGame().getOtherObjectivePiece(isBlack())))));
    }
  }
  done=false;
  if (movements.containsKey('W')) {
    int southMax=curSquare.getCol() - movements.get('W');
    if (southMax < 1 || movements.get('W') == -1)     if (!wraparound) {
      southMax=1;
    }
    for (int c=curSquare.getCol() - 1; ((movements.get('W') == -1 && wraparound) ? true : c >= southMax) && !done; c--) {
      int j=c;
      if (wraparound)       if (j < 1) {
        j=board.getMaxCol() + j;
      }
      dest=board.getSquare(curSquare.getRow(),j);
      done=!addLegalDest(dest);
      done=(done || leaper ? false : (dest.isOccupied() && !(board.isBlackTurn() != isBlack() && dest.getPiece().equals(board.getGame().getOtherObjectivePiece(isBlack())))));
    }
  }
  done=false;
  if (movements.containsKey('N')) {
    int eastMax=movements.get('N') + curSquare.getRow();
    if (eastMax >= board.getMaxRow() || movements.get('N') == -1) {
      eastMax=board.getMaxRow();
    }
    for (int r=curSquare.getRow() + 1; (r <= eastMax) && !done; r++) {
      int j=r;
      dest=board.getSquare(j,curSquare.getCol());
      done=!addLegalDest(dest);
      done=(done || leaper ? false : (dest.isOccupied() && !(board.isBlackTurn() != isBlack() && dest.getPiece().equals(board.getGame().getOtherObjectivePiece(isBlack())))));
    }
  }
  done=false;
  if (movements.containsKey('S')) {
    int westMax=curSquare.getRow() - movements.get('S');
    if (westMax < 1 || movements.get('S') == -1) {
      westMax=1;
    }
    for (int r=curSquare.getRow() - 1; (r >= westMax) && !done; r--) {
      int j=r;
      dest=board.getSquare(j,curSquare.getCol());
      done=!addLegalDest(dest);
      done=(done || leaper ? false : (dest.isOccupied() && !(board.isBlackTurn() != isBlack() && dest.getPiece().equals(board.getGame().getOtherObjectivePiece(isBlack())))));
    }
  }
  done=false;
  if (movements.containsKey('R')) {
    int neMax=((curSquare.getRow() >= curSquare.getCol()) ? curSquare.getRow() : curSquare.getCol()) + movements.get('R');
    if (neMax >= board.getMaxCol() || movements.get('R') == -1) {
      neMax=board.getMaxCol();
    }
    if (neMax >= board.getMaxRow() || movements.get('R') == -1) {
      neMax=board.getMaxRow();
    }
    for (int r=curSquare.getRow() + 1, c=curSquare.getCol() + 1; r <= neMax && c <= neMax && !done; r++, c++) {
      dest=board.getSquare(r,c);
      done=!addLegalDest(dest);
      done=(done || leaper ? false : (dest.isOccupied() && !(board.isBlackTurn() != isBlack() && dest.getPiece().equals(board.getGame().getOtherObjectivePiece(isBlack())))));
    }
  }
  done=false;
  if (movements.containsKey('r')) {
    int eastMax=curSquare.getCol() + movements.get('r');
    if (eastMax >= board.getMaxCol() || movements.get('r') == -1) {
      eastMax=board.getMaxCol();
    }
    int southMin=curSquare.getRow() - movements.get('r');
    if (southMin <= 1 || movements.get('R') == -1) {
      southMin=1;
    }
    for (int r=curSquare.getRow() - 1, c=curSquare.getCol() + 1; r >= southMin && c <= eastMax && !done; r--, c++) {
      dest=board.getSquare(r,c);
      done=!addLegalDest(dest);
      done=(done || leaper ? false : (dest.isOccupied() && !(board.isBlackTurn() != isBlack() && dest.getPiece().equals(board.getGame().getOtherObjectivePiece(isBlack())))));
    }
  }
  done=false;
  if (movements.containsKey('L')) {
    int westMin=curSquare.getCol() - movements.get('L');
    if (westMin <= 1 || movements.get('L') == -1) {
      westMin=1;
    }
    int NorthMax=curSquare.getRow() + movements.get('L');
    if (NorthMax >= board.getMaxRow() || movements.get('L') == -1) {
      NorthMax=board.getMaxRow();
    }
    for (int r=curSquare.getRow() + 1, c=curSquare.getCol() - 1; r <= NorthMax && c >= westMin && !done; r++, c--) {
      dest=board.getSquare(r,c);
      done=!addLegalDest(dest);
      done=(done || leaper ? false : (dest.isOccupied() && !(board.isBlackTurn() != isBlack() && dest.getPiece().equals(board.getGame().getOtherObjectivePiece(isBlack())))));
    }
  }
  done=false;
  if (movements.containsKey('l')) {
    int westMin=curSquare.getCol() - movements.get('l');
    if (westMin <= 1 || movements.get('l') == -1) {
      westMin=1;
    }
    int southMin=curSquare.getRow() - movements.get('l');
    if (southMin <= 1 || movements.get('l') == -1) {
      southMin=1;
    }
    for (int r=curSquare.getRow() - 1, c=curSquare.getCol() - 1; r >= southMin && c >= westMin && !done; r--, c--) {
      dest=board.getSquare(r,c);
      done=!addLegalDest(dest);
      done=(done || leaper ? false : (dest.isOccupied() && !(board.isBlackTurn() != isBlack() && dest.getPiece().equals(board.getGame().getOtherObjectivePiece(isBlack())))));
    }
  }
  if (movements.containsKey('x')) {
    int f, r;
    int Rank=movements.get('x');
    int File=movements.get('y');
    f=(curSquare.getRow() + File);
    r=(curSquare.getCol() + Rank);
    if (wraparound) {
      if (r > board.getMaxCol() + 1) {
        r=r % board.getMaxCol();
      }
    }
    if (board.isRowValid(f) && board.isColValid(r)) {
      addLegalDest(board.getSquare(f,r));
    }
    f=(curSquare.getRow() + Rank);
    r=(curSquare.getCol() + File);
    if (wraparound) {
      if (r > board.getMaxCol() + 1) {
        r=r % board.getMaxCol();
      }
    }
    if (board.isRowValid(f) && board.isColValid(r)) {
      addLegalDest(board.getSquare(f,r));
    }
    f=(curSquare.getRow() + File);
    r=(curSquare.getCol() - Rank);
    if (wraparound) {
      if (r < 1) {
        r=board.getMaxCol() + r;
      }
    }
    if (board.isRowValid(f) && board.isColValid(r)) {
      addLegalDest(board.getSquare(f,r));
    }
    f=(curSquare.getRow() + Rank);
    r=(curSquare.getCol() - File);
    if (wraparound) {
      if (r < 1) {
        r=board.getMaxCol() + r;
      }
    }
    if (board.isRowValid(f) && board.isColValid(r)) {
      addLegalDest(board.getSquare(f,r));
    }
    f=(curSquare.getRow() - File);
    r=(curSquare.getCol() - Rank);
    if (wraparound) {
      if (r < 1) {
        r=board.getMaxCol() + r;
      }
    }
    if (board.isRowValid(f) && board.isColValid(r)) {
      addLegalDest(board.getSquare(f,r));
    }
    f=(curSquare.getRow() - Rank);
    r=(curSquare.getCol() - File);
    if (wraparound) {
      if (r < 1) {
        r=board.getMaxCol() + r;
      }
    }
    if (board.isRowValid(f) && board.isColValid(r)) {
      addLegalDest(board.getSquare(f,r));
    }
    f=(curSquare.getRow() - File);
    r=(curSquare.getCol() + Rank);
    if (wraparound) {
      if (r > board.getMaxCol() + 1) {
        r=r % board.getMaxCol();
      }
    }
    if (board.isRowValid(f) && board.isColValid(r)) {
      addLegalDest(board.getSquare(f,r));
    }
    f=(curSquare.getRow() - Rank);
    r=(curSquare.getCol() + File);
    if (wraparound) {
      if (r > board.getMaxCol() + 1) {
        r=r % board.getMaxCol();
      }
    }
    if (board.isRowValid(f) && board.isColValid(r)) {
      addLegalDest(board.getSquare(f,r));
    }
  }
  return getLegalDests().size();
}"
50010,"/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the  window. Also add any necessary ActionListeners.
 */
public void initComponents(){
  humanPlay=new JButton(""String_Node_Str"");
  humanPlay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      final JFrame popup=new JFrame(""String_Node_Str"");
      popup.setLayout(new FlowLayout());
      popup.setSize(370,150);
      popup.setResizable(false);
      popup.setLocationRelativeTo(null);
      final JComboBox dropdown=new JComboBox(Builder.getArray());
      popup.add(new JLabel(""String_Node_Str""));
      popup.add(dropdown);
      final JButton done=new JButton(""String_Node_Str"");
      String[] timerNames={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
      final JComboBox timers=new JComboBox(timerNames);
      final JLabel totalTimeText=new JLabel(""String_Node_Str"");
      totalTimeText.setVisible(false);
      final TextField totalTime=new TextField(""String_Node_Str"",3);
      totalTime.setVisible(false);
      final JLabel increaseText=new JLabel(""String_Node_Str"");
      increaseText.setVisible(false);
      final TextField increase=new TextField(""String_Node_Str"",3);
      increase.setVisible(false);
      timers.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          String timerName=(String)timers.getSelectedItem();
          if (timerName.equals(""String_Node_Str"") == false) {
            totalTimeText.setVisible(true);
            totalTime.setVisible(true);
            increaseText.setVisible(true);
            increase.setVisible(true);
          }
 else {
            totalTimeText.setVisible(false);
            totalTime.setVisible(false);
            increaseText.setVisible(false);
            increase.setVisible(false);
          }
        }
      }
);
      popup.add(new JLabel(""String_Node_Str""));
      popup.add(timers);
      popup.add(totalTimeText);
      popup.add(totalTime);
      popup.add(increaseText);
      popup.add(increase);
      done.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          String timerName=(String)timers.getSelectedItem();
          long startTime=Integer.parseInt(totalTime.getText()) * 1000;
          long increment=Integer.parseInt(increase.getText()) * 1000;
          ChessTimer blackTimer=null;
          ChessTimer whiteTimer=null;
          if (timerName.equals(""String_Node_Str"")) {
            blackTimer=new NoTimer();
            whiteTimer=new NoTimer();
          }
 else           if (timerName.equals(""String_Node_Str"")) {
            blackTimer=new BronsteinDelay(increment,startTime,true);
            whiteTimer=new BronsteinDelay(increment,startTime,false);
          }
 else           if (timerName.equals(""String_Node_Str"")) {
            blackTimer=new Fischer(increment,startTime,false,true);
            whiteTimer=new Fischer(increment,startTime,false,false);
          }
 else           if (timerName.equals(""String_Node_Str"")) {
            blackTimer=new Fischer(increment,startTime,true,true);
            whiteTimer=new Fischer(increment,startTime,true,false);
          }
 else           if (timerName.equals(""String_Node_Str"")) {
            blackTimer=new HourGlass(startTime / 2,true);
            whiteTimer=new HourGlass(startTime / 2,false);
          }
 else           if (timerName.equals(""String_Node_Str"")) {
            blackTimer=new SimpleDelay(increment,startTime,true);
            whiteTimer=new SimpleDelay(increment,startTime,false);
          }
 else {
            blackTimer=new Word(startTime);
            whiteTimer=new Word(startTime);
          }
          Game toPlay=Builder.newGame((String)dropdown.getSelectedItem());
          toPlay.setTimers(whiteTimer,blackTimer);
          PlayGame game=new PlayGame(toPlay,false);
          Driver.getInstance().setPanel(game);
          popup.dispose();
        }
      }
);
      popup.add(done);
      final JButton back=new JButton(""String_Node_Str"");
      back.addActionListener(new ActionListener(){
        @Override public void actionPerformed(        ActionEvent arg0){
          popup.dispose();
        }
      }
);
      popup.add(back);
      popup.setVisible(true);
    }
  }
);
  networkPlay=new JButton(""String_Node_Str"");
  AIPlay=new JButton(""String_Node_Str"");
  backButton=new JButton(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      Driver.getInstance().helpMenu.setText(""String_Node_Str"");
      Driver.getInstance().gameInfo.setVisible(false);
      Driver.getInstance().gamePlayHelp.setVisible(false);
      Driver.getInstance().revertPanel();
    }
  }
);
  GroupLayout layout=new GroupLayout(this);
  this.setLayout(layout);
  layout.setHorizontalGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(20,20,20).addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addComponent(AIPlay,GroupLayout.PREFERRED_SIZE,234,GroupLayout.PREFERRED_SIZE).addComponent(networkPlay,GroupLayout.PREFERRED_SIZE,234,GroupLayout.PREFERRED_SIZE).addComponent(humanPlay,GroupLayout.PREFERRED_SIZE,234,GroupLayout.PREFERRED_SIZE))).addGroup(layout.createSequentialGroup().addGap(112,112,112).addComponent(backButton))).addContainerGap(20,Short.MAX_VALUE)));
  layout.setVerticalGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addComponent(humanPlay).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addComponent(networkPlay).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addComponent(AIPlay).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addComponent(backButton).addGap(4,4,4)));
}","/** 
 * Initialize components of the GUI Create all the GUI components, set their specific properties and add them to the  window. Also add any necessary ActionListeners.
 */
public void initComponents(){
  humanPlay=new JButton(""String_Node_Str"");
  humanPlay.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent arg0){
      if (!clicked) {
        clicked=true;
        final JFrame popup=new JFrame(""String_Node_Str"");
        popup.setLayout(new FlowLayout());
        popup.setSize(370,150);
        popup.setResizable(false);
        popup.setLocationRelativeTo(null);
        final JComboBox dropdown=new JComboBox(Builder.getArray());
        popup.add(new JLabel(""String_Node_Str""));
        popup.add(dropdown);
        final JButton done=new JButton(""String_Node_Str"");
        String[] timerNames={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
        final JComboBox timers=new JComboBox(timerNames);
        final JLabel totalTimeText=new JLabel(""String_Node_Str"");
        totalTimeText.setVisible(false);
        final TextField totalTime=new TextField(""String_Node_Str"",3);
        totalTime.setVisible(false);
        final JLabel increaseText=new JLabel(""String_Node_Str"");
        increaseText.setVisible(false);
        final TextField increase=new TextField(""String_Node_Str"",3);
        increase.setVisible(false);
        timers.addActionListener(new ActionListener(){
          @Override public void actionPerformed(          ActionEvent arg0){
            String timerName=(String)timers.getSelectedItem();
            if (timerName.equals(""String_Node_Str"") == false) {
              totalTimeText.setVisible(true);
              totalTime.setVisible(true);
              increaseText.setVisible(true);
              increase.setVisible(true);
            }
 else {
              totalTimeText.setVisible(false);
              totalTime.setVisible(false);
              increaseText.setVisible(false);
              increase.setVisible(false);
            }
          }
        }
);
        popup.add(new JLabel(""String_Node_Str""));
        popup.add(timers);
        popup.add(totalTimeText);
        popup.add(totalTime);
        popup.add(increaseText);
        popup.add(increase);
        popup.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        popup.addWindowListener(new WindowListener(){
          public void windowActivated(          WindowEvent arg0){
          }
          public void windowClosed(          WindowEvent arg0){
          }
          public void windowClosing(          WindowEvent arg0){
            clicked=false;
            popup.setVisible(false);
            popup.dispose();
          }
          public void windowDeactivated(          WindowEvent arg0){
          }
          public void windowDeiconified(          WindowEvent arg0){
          }
          public void windowIconified(          WindowEvent arg0){
          }
          public void windowOpened(          WindowEvent arg0){
          }
        }
);
        done.addActionListener(new ActionListener(){
          @Override public void actionPerformed(          ActionEvent arg0){
            clicked=false;
            String timerName=(String)timers.getSelectedItem();
            long startTime=Integer.parseInt(totalTime.getText()) * 1000;
            long increment=Integer.parseInt(increase.getText()) * 1000;
            ChessTimer blackTimer=null;
            ChessTimer whiteTimer=null;
            if (timerName.equals(""String_Node_Str"")) {
              blackTimer=new NoTimer();
              whiteTimer=new NoTimer();
            }
 else             if (timerName.equals(""String_Node_Str"")) {
              blackTimer=new BronsteinDelay(increment,startTime,true);
              whiteTimer=new BronsteinDelay(increment,startTime,false);
            }
 else             if (timerName.equals(""String_Node_Str"")) {
              blackTimer=new Fischer(increment,startTime,false,true);
              whiteTimer=new Fischer(increment,startTime,false,false);
            }
 else             if (timerName.equals(""String_Node_Str"")) {
              blackTimer=new Fischer(increment,startTime,true,true);
              whiteTimer=new Fischer(increment,startTime,true,false);
            }
 else             if (timerName.equals(""String_Node_Str"")) {
              blackTimer=new HourGlass(startTime / 2,true);
              whiteTimer=new HourGlass(startTime / 2,false);
            }
 else             if (timerName.equals(""String_Node_Str"")) {
              blackTimer=new SimpleDelay(increment,startTime,true);
              whiteTimer=new SimpleDelay(increment,startTime,false);
            }
 else {
              blackTimer=new Word(startTime);
              whiteTimer=new Word(startTime);
            }
            Game toPlay=Builder.newGame((String)dropdown.getSelectedItem());
            toPlay.setTimers(whiteTimer,blackTimer);
            PlayGame game=new PlayGame(toPlay,false);
            Driver.getInstance().setPanel(game);
            popup.dispose();
          }
        }
);
        popup.add(done);
        final JButton back=new JButton(""String_Node_Str"");
        back.addActionListener(new ActionListener(){
          @Override public void actionPerformed(          ActionEvent arg0){
            clicked=false;
            popup.dispose();
          }
        }
);
        popup.add(back);
        popup.setVisible(true);
      }
    }
  }
);
  networkPlay=new JButton(""String_Node_Str"");
  AIPlay=new JButton(""String_Node_Str"");
  backButton=new JButton(""String_Node_Str"");
  backButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      Driver.getInstance().helpMenu.setText(""String_Node_Str"");
      Driver.getInstance().gameInfo.setVisible(false);
      Driver.getInstance().gamePlayHelp.setVisible(false);
      Driver.getInstance().revertPanel();
    }
  }
);
  GroupLayout layout=new GroupLayout(this);
  this.setLayout(layout);
  layout.setHorizontalGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(layout.createSequentialGroup().addGap(20,20,20).addGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addComponent(AIPlay,GroupLayout.PREFERRED_SIZE,234,GroupLayout.PREFERRED_SIZE).addComponent(networkPlay,GroupLayout.PREFERRED_SIZE,234,GroupLayout.PREFERRED_SIZE).addComponent(humanPlay,GroupLayout.PREFERRED_SIZE,234,GroupLayout.PREFERRED_SIZE))).addGroup(layout.createSequentialGroup().addGap(112,112,112).addComponent(backButton))).addContainerGap(20,Short.MAX_VALUE)));
  layout.setVerticalGroup(layout.createParallelGroup(GroupLayout.Alignment.LEADING).addGroup(GroupLayout.Alignment.TRAILING,layout.createSequentialGroup().addComponent(humanPlay).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addComponent(networkPlay).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addComponent(AIPlay).addPreferredGap(LayoutStyle.ComponentPlacement.RELATED).addComponent(backButton).addGap(4,4,4)));
}"
50011,"/** 
 * @return The Menu bar for the GUI
 */
public JMenu createMenu(){
  JMenu menu=new JMenu(""String_Node_Str"");
  if (!isPlayback) {
    JMenuItem drawItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_D);
    JMenuItem saveItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_S);
    drawItem.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        if (g.getLastMove() == null)         return;
        g.getLastMove().setResult(new Result(Result.DRAW));
        endOfGame(new Result(Result.DRAW));
      }
    }
);
    saveItem.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        String fileName=JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
        if (fileName == null)         return;
        g.saveGame(""String_Node_Str"",fileName,false);
        Driver.getInstance().revertPanel();
      }
    }
);
    menu.add(drawItem);
    menu.add(saveItem);
  }
  return menu;
}","/** 
 * @return The Menu bar for the GUI
 */
public JMenu createMenu(){
  JMenu menu=new JMenu(""String_Node_Str"");
  if (!isPlayback) {
    JMenuItem drawItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_D);
    JMenuItem saveItem=new JMenuItem(""String_Node_Str"",KeyEvent.VK_S);
    drawItem.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        if (g.getLastMove() == null)         return;
        g.getLastMove().setResult(new Result(Result.DRAW));
        endOfGame(new Result(Result.DRAW));
      }
    }
);
    saveItem.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        whiteTimer.stop();
        blackTimer.stop();
        String fileName=JOptionPane.showInputDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE);
        if (fileName == null)         return;
        g.saveGame(""String_Node_Str"",fileName,false);
        Driver.getInstance().revertPanel();
      }
    }
);
    menu.add(drawItem);
    menu.add(saveItem);
  }
  return menu;
}"
50012,"public void addName(String name){
  if (name.equals(""String_Node_Str""))   propPrefix=name + ""String_Node_Str"" + propPrefix;
}","public void addName(String name){
  if (!name.equals(""String_Node_Str""))   propPrefix=name + ""String_Node_Str"" + propPrefix;
}"
50013,"/** 
 * Example: java -DTwitterTokenizer.unicode=proj/tokenize/unicode.csv -DTwitterTokenizer.full=true edu.jhu.jerboa.processing.TwitterTokenizer proj/tokenize/example_tweets.txt
 */
public static void main(String[] args) throws Exception {
  BufferedReader reader;
  if (args.length == 0)   reader=new BufferedReader(new InputStreamReader(System.in,""String_Node_Str""));
 else   reader=FileManager.getReader(args[0]);
  String line;
  String[][] tokens;
  boolean full=JerboaProperties.getBoolean(""String_Node_Str"",false);
  while ((line=reader.readLine()) != null) {
    tokens=tokenize(line);
    if (tokens[0].length > 0) {
      if (full)       System.out.println(line);
      System.out.print(tokens[0][0]);
      for (int i=1; i < tokens[0].length; i++)       System.out.print(""String_Node_Str"" + tokens[0][i]);
      System.out.println();
      if (full) {
        System.out.print(tokens[1][0]);
        for (int i=1; i < tokens[1].length; i++)         System.out.print(""String_Node_Str"" + tokens[1][i]);
        System.out.println();
      }
      if (full) {
        System.out.print(tokens[2][0]);
        for (int i=1; i < tokens[2].length; i++)         System.out.print(""String_Node_Str"" + tokens[2][i]);
        System.out.println();
      }
    }
 else {
      if (full) {
        System.out.println(""String_Node_Str"");
        System.out.println(""String_Node_Str"");
        System.out.println(""String_Node_Str"");
        System.out.println(""String_Node_Str"");
      }
 else {
        System.out.println(""String_Node_Str"");
      }
    }
  }
  reader.close();
}","/** 
 * Example: java -DTwitterTokenizer.unicode=proj/tokenize/unicode.csv -DTwitterTokenizer.full=true edu.jhu.jerboa.processing.TwitterTokenizer proj/tokenize/example_tweets.txt
 */
public static void main(String[] args) throws Exception {
  BufferedReader reader;
  if (args.length == 0)   reader=new BufferedReader(new InputStreamReader(System.in,""String_Node_Str""));
 else   reader=FileManager.getReader(args[0]);
  PrintStream out=new PrintStream(System.out,true,""String_Node_Str"");
  String line;
  String[][] tokens;
  boolean full=JerboaProperties.getBoolean(""String_Node_Str"",false);
  while ((line=reader.readLine()) != null) {
    tokens=tokenize(line);
    if (tokens[0].length > 0) {
      if (full)       out.println(line);
      out.print(tokens[0][0]);
      for (int i=1; i < tokens[0].length; i++)       out.print(""String_Node_Str"" + tokens[0][i]);
      out.println();
      if (full) {
        out.print(tokens[1][0]);
        for (int i=1; i < tokens[1].length; i++)         out.print(""String_Node_Str"" + tokens[1][i]);
        out.println();
      }
      if (full) {
        out.print(tokens[2][0]);
        for (int i=1; i < tokens[2].length; i++)         out.print(""String_Node_Str"" + tokens[2][i]);
        out.println();
      }
    }
 else {
      if (full) {
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
        out.println(""String_Node_Str"");
      }
 else {
        out.println(""String_Node_Str"");
      }
    }
  }
  reader.close();
}"
50014,"public Hashtable<String,Object> next() throws Exception {
  if (messageIter == null)   return null;
  Message m=messageIter.next();
  Hashtable<String,Object> h=new Hashtable();
  h.put(""String_Node_Str"",m);
  h.put(""String_Node_Str"",participants);
  h.put(""String_Node_Str"",participantMap);
  h.put(""String_Node_Str"",m.getSender().getCommunicationId());
  String label=processor.getLabel(participantMap.get(m.getSender()));
  if (form == ClassifierForm.BINARY)   h.put(""String_Node_Str"",classPolarity.get(label.toLowerCase()) ? this.classLabels[0] : this.classLabels[1]);
 else   if (form == ClassifierForm.REGRESSION)   h.put(""String_Node_Str"",Double.parseDouble(label));
 else   h.put(""String_Node_Str"",label);
  return h;
}","public Hashtable<String,Object> next() throws Exception {
  if (messageIter == null)   return null;
  Message m=messageIter.next();
  Hashtable<String,Object> h=new Hashtable();
  h.put(""String_Node_Str"",m);
  h.put(""String_Node_Str"",participants);
  h.put(""String_Node_Str"",participantMap);
  h.put(""String_Node_Str"",m.getSender().getCommunicationId());
  String label=processor.getLabel(participantMap.get(m.getSender()));
  if (form == ClassifierForm.BINARY)   h.put(""String_Node_Str"",classPolarity.get(label.toLowerCase()) ? 1.0 : -1.0);
 else   if (form == ClassifierForm.REGRESSION)   h.put(""String_Node_Str"",Double.parseDouble(label));
 else   h.put(""String_Node_Str"",label);
  return h;
}"
50015,"public MessageSenderParser() throws Exception {
  form=ClassifierForm.valueOf(JerboaProperties.getString(propPrefix + ""String_Node_Str"",""String_Node_Str""));
  if (form == ClassifierForm.BINARY) {
    this.classLabels=JerboaProperties.getStrings(propPrefix + ""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""});
    if (classLabels.length != 2)     throw new Exception(""String_Node_Str"" + classLabels.length + ""String_Node_Str"");
    classPolarity=new Hashtable();
    classPolarity.put(classLabels[0].toLowerCase(),true);
    classPolarity.put(classLabels[1].toLowerCase(),false);
  }
  this.processor=new VertexProcessor();
}","public MessageSenderParser() throws Exception {
  form=ClassifierForm.valueOf(JerboaProperties.getString(propPrefix + ""String_Node_Str"",""String_Node_Str""));
  if (form == ClassifierForm.BINARY) {
    String[] classLabels=JerboaProperties.getStrings(propPrefix + ""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""});
    if (classLabels.length != 2)     throw new Exception(""String_Node_Str"" + classLabels.length + ""String_Node_Str"");
    classPolarity=new Hashtable();
    classPolarity.put(classLabels[0].toLowerCase(),true);
    classPolarity.put(classLabels[1].toLowerCase(),false);
  }
  this.processor=new VertexProcessor();
}"
50016,"public BloomParamOpt() throws Exception {
  this.propPrefix=""String_Node_Str"";
  this.weights=getWeights();
  this.numElements=JerboaProperties.getInt(propPrefix + ""String_Node_Str"",this.weights.size());
  this.numBits=parseNumBits(JerboaProperties.getString(propPrefix + ""String_Node_Str""));
  this.kmax=JerboaProperties.getDouble(propPrefix + ""String_Node_Str"",2);
  this.outputFilename=JerboaProperties.getString(propPrefix + ""String_Node_Str"");
  this.coreValsCached=JerboaProperties.getBoolean(propPrefix + ""String_Node_Str"");
  this.featuresCache=JerboaProperties.getString(propPrefix + ""String_Node_Str"");
  this.trainInstCache=JerboaProperties.getString(propPrefix + ""String_Node_Str"");
  this.usersCache=JerboaProperties.getString(propPrefix + ""String_Node_Str"");
  this.labelsCache=JerboaProperties.getString(propPrefix + ""String_Node_Str"");
}","public BloomParamOpt() throws Exception {
  this.propPrefix=""String_Node_Str"";
  this.weights=getWeights();
  this.numElements=JerboaProperties.getInt(propPrefix + ""String_Node_Str"",this.weights.size());
  this.numBits=parseNumBits(JerboaProperties.getString(propPrefix + ""String_Node_Str""));
  this.kmax=JerboaProperties.getDouble(propPrefix + ""String_Node_Str"",2);
  this.outputFilename=JerboaProperties.getString(propPrefix + ""String_Node_Str"");
  this.coreValsCached=JerboaProperties.getBoolean(propPrefix + ""String_Node_Str"");
  this.featuresCache=JerboaProperties.getString(propPrefix + ""String_Node_Str"");
  this.trainInstCache=JerboaProperties.getString(propPrefix + ""String_Node_Str"");
  this.usersCache=JerboaProperties.getString(propPrefix + ""String_Node_Str"");
  this.labelsCache=JerboaProperties.getString(propPrefix + ""String_Node_Str"");
  populateCoreValues();
}"
50017,"public void optimize(){
  logger.config(""String_Node_Str"" + this.numElements + ""String_Node_Str""+ this.numBits+ ""String_Node_Str""+ this.kmax);
  populateCoreValues();
}","public void optimize(){
  logger.config(""String_Node_Str"" + this.numElements + ""String_Node_Str""+ this.numBits+ ""String_Node_Str""+ this.kmax);
}"
50018,"public void populateCoreValues(){
  if (this.coreValsCached) {
    try {
      readAll();
    }
 catch (    IOException err) {
      System.out.println(""String_Node_Str"");
      System.err.println(err);
      System.exit(0);
    }
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
 else {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
}","public void populateCoreValues(){
  if (this.coreValsCached) {
    logger.info(""String_Node_Str"");
    try {
      readAll();
    }
 catch (    IOException err) {
      logger.info(""String_Node_Str"" + ""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.err.println(err);
      System.exit(0);
    }
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
 else {
    System.out.println(""String_Node_Str"");
    System.exit(0);
  }
}"
50019,"public void disconnect(){
  log.info(""String_Node_Str"");
  log.debug(""String_Node_Str"" + session.getExitStatus());
  session.close();
  stopParsing();
  log.debug(""String_Node_Str"");
  connection.close();
  closed=true;
  log.info(""String_Node_Str"");
  for (  TransportListener handler : listeners)   handler.transportClosed();
}","public void disconnect(){
  log.info(""String_Node_Str"");
  log.debug(""String_Node_Str"" + session.getExitStatus());
  session.close();
  log.debug(""String_Node_Str"");
  closed=true;
  connection.close();
  log.info(""String_Node_Str"");
  for (  TransportListener handler : listeners)   handler.transportClosed();
}"
50020,"private void startParsing(){
  parserThread=new Thread(""String_Node_Str""){
    @Override public void run(){
      log.debug(""String_Node_Str"");
      while (!closed) {
        try {
          String buffer=""String_Node_Str"";
          BufferedReader reader=new BufferedReader(new InputStreamReader(session.getStdout()));
          do {
            buffer+=reader.readLine();
          }
 while (!buffer.endsWith(delimiter));
          parser.parse(new InputSource(new StringReader(buffer)));
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
catch (        SAXException e) {
          if (e.getMessage().contentEquals(""String_Node_Str"")) {
          }
 else {
            log.error(e.getMessage());
            e.printStackTrace();
            disconnect();
          }
          log.info(""String_Node_Str"");
        }
        log.debug(""String_Node_Str"");
      }
      log.debug(""String_Node_Str"");
    }
  }
;
  parserThread.start();
}","private void startParsing(){
  parserThread=new Thread(""String_Node_Str""){
    @Override public void run(){
      log.debug(""String_Node_Str"");
      BufferedReader reader=null;
      while (!closed) {
        try {
          String buffer=""String_Node_Str"";
          reader=new BufferedReader(new InputStreamReader(session.getStdout()));
          do {
            buffer+=reader.readLine();
          }
 while (!buffer.endsWith(delimiter) && !closed);
          parser.parse(new InputSource(new StringReader(buffer)));
        }
 catch (        IOException e) {
          log.error(e.getMessage());
        }
catch (        SAXException e) {
          if (e.getMessage().contentEquals(""String_Node_Str"")) {
          }
 else {
            log.error(e.getMessage());
            disconnect();
          }
          log.info(""String_Node_Str"");
        }
 finally {
          if (reader != null) {
            try {
              reader.close();
            }
 catch (            IOException e) {
              log.error(e.getMessage());
            }
          }
        }
        log.debug(""String_Node_Str"");
      }
      log.debug(""String_Node_Str"");
    }
  }
;
  parserThread.start();
}"
50021,"public SSHTransport(){
  listeners=new Vector<TransportListener>();
  xmlHandler=new TransportContentParser();
  try {
    parser=XMLReaderFactory.createXMLReader();
    parser.setContentHandler(xmlHandler);
    parser.setErrorHandler(xmlHandler);
  }
 catch (  SAXException e) {
    e.printStackTrace();
  }
}","public SSHTransport(){
  listeners=new Vector<TransportListener>();
  xmlHandler=new TransportContentParser();
  try {
    parser=XMLReaderFactory.createXMLReader();
    parser.setContentHandler(xmlHandler);
    parser.setErrorHandler(xmlHandler);
  }
 catch (  SAXException e) {
    log.error(e.getMessage());
  }
}"
50022,"@Override public void run(){
  log.debug(""String_Node_Str"");
  while (!closed) {
    try {
      String buffer=""String_Node_Str"";
      BufferedReader reader=new BufferedReader(new InputStreamReader(session.getStdout()));
      do {
        buffer+=reader.readLine();
      }
 while (!buffer.endsWith(delimiter));
      parser.parse(new InputSource(new StringReader(buffer)));
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
catch (    SAXException e) {
      if (e.getMessage().contentEquals(""String_Node_Str"")) {
      }
 else {
        log.error(e.getMessage());
        e.printStackTrace();
        disconnect();
      }
      log.info(""String_Node_Str"");
    }
    log.debug(""String_Node_Str"");
  }
  log.debug(""String_Node_Str"");
}","@Override public void run(){
  log.debug(""String_Node_Str"");
  BufferedReader reader=null;
  while (!closed) {
    try {
      String buffer=""String_Node_Str"";
      reader=new BufferedReader(new InputStreamReader(session.getStdout()));
      do {
        buffer+=reader.readLine();
      }
 while (!buffer.endsWith(delimiter) && !closed);
      parser.parse(new InputSource(new StringReader(buffer)));
    }
 catch (    IOException e) {
      log.error(e.getMessage());
    }
catch (    SAXException e) {
      if (e.getMessage().contentEquals(""String_Node_Str"")) {
      }
 else {
        log.error(e.getMessage());
        disconnect();
      }
      log.info(""String_Node_Str"");
    }
 finally {
      if (reader != null) {
        try {
          reader.close();
        }
 catch (        IOException e) {
          log.error(e.getMessage());
        }
      }
    }
    log.debug(""String_Node_Str"");
  }
  log.debug(""String_Node_Str"");
}"
50023,"@Override public void endElement(String uri,String localName,String qName) throws SAXException {
  super.endElement(uri,localName,qName);
  if (insideDataTag && !localName.equalsIgnoreCase(""String_Node_Str"")) {
    dataTagContent.append(""String_Node_Str"" + localName + ""String_Node_Str"");
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    messageQueue.put(hello);
    hello=null;
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    hello.setCapabilities(capabilities);
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideCapabilityTag=false;
    capabilities.add(Capability.getCapabilityByNamespace(capabilityTagContent.toString()));
    capabilityTagContent=new StringBuffer();
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideSessionIdTag=false;
    hello.setSessionId(sessionIdTagContent.toString());
    sessionIdTagContent=new StringBuffer();
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    messageQueue.put(reply);
    reply=null;
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideDataTag=false;
    reply.setContain(dataTagContent.toString());
    reply.setContainName(""String_Node_Str"");
    dataTagContent=new StringBuffer();
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    reply.addError(error);
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorTypeTag=false;
    error.setType(ErrorType.valueOf(errorTypeTagContent.toString().toUpperCase()));
    errorTypeTagContent=new StringBuffer();
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorTagTag=false;
    error.setTag(ErrorTag.valueOf(errorTagTagContent.toString()));
    errorTagTagContent=new StringBuffer();
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorSeverityTag=false;
    error.setSeverity(ErrorSeverity.valueOf(errorSeverityTagContent.toString().toUpperCase()));
    errorSeverityTagContent=new StringBuffer();
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorAppTagTag=false;
    error.setAppTag(errorAppTagTagContent.toString());
    errorAppTagTagContent=new StringBuffer();
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorPathTag=false;
    error.setPath(errorPathTagContent.toString());
    errorPathTagContent=new StringBuffer();
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorMessageTag=false;
    error.setMessage(errorMessageTagContent.toString());
    errorMessageTagContent=new StringBuffer();
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorInfoTag=false;
    error.setInfo(errorInfoTagContent.toString());
    errorInfoTagContent=new StringBuffer();
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideInterfaceInfoTag=false;
    reply.setContain(interfaceInfoTagContent.toString());
    reply.setContainName(""String_Node_Str"");
    interfaceInfoTagContent=new StringBuffer();
  }
}","@Override public void endElement(String uri,String localName,String qName) throws SAXException {
  super.endElement(uri,localName,qName);
  if (insideDataTag && !localName.equalsIgnoreCase(""String_Node_Str"")) {
    dataTagContent.append(""String_Node_Str"" + localName + ""String_Node_Str"");
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    messageQueue.put(hello);
    hello=null;
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    hello.setCapabilities(capabilities);
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideCapabilityTag=false;
    capabilities.add(Capability.getCapabilityByNamespace(capabilityTagContent.toString()));
    capabilityTagContent=new StringBuffer();
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideSessionIdTag=false;
    hello.setSessionId(sessionIdTagContent.toString());
    sessionIdTagContent=new StringBuffer();
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    messageQueue.put(reply);
    reply=null;
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideDataTag=false;
    reply.setContain(dataTagContent.toString());
    reply.setContainName(""String_Node_Str"");
    dataTagContent=new StringBuffer();
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    reply.addError(error);
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorTypeTag=false;
    error.setType(ErrorType.getErrorTypeByValue(errorTypeTagContent.toString()));
    errorTypeTagContent=new StringBuffer();
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorTagTag=false;
    error.setTag(ErrorTag.getErrorTagByValue((errorTagTagContent.toString())));
    errorTagTagContent=new StringBuffer();
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorSeverityTag=false;
    error.setSeverity(ErrorSeverity.getErrorSeverityByValue(errorSeverityTagContent.toString()));
    errorSeverityTagContent=new StringBuffer();
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorAppTagTag=false;
    error.setAppTag(errorAppTagTagContent.toString());
    errorAppTagTagContent=new StringBuffer();
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorPathTag=false;
    error.setPath(errorPathTagContent.toString());
    errorPathTagContent=new StringBuffer();
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorMessageTag=false;
    error.setMessage(errorMessageTagContent.toString());
    errorMessageTagContent=new StringBuffer();
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorInfoTag=false;
    error.setInfo(errorInfoTagContent.toString());
    errorInfoTagContent=new StringBuffer();
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideInterfaceInfoTag=false;
    reply.setContain(interfaceInfoTagContent.toString());
    reply.setContainName(""String_Node_Str"");
    interfaceInfoTagContent=new StringBuffer();
  }
}"
50024,"public SessionContext() throws ConfigurationException {
  this.addConfiguration(new PropertiesConfiguration(""String_Node_Str""));
}","public SessionContext() throws ConfigurationException {
  this.addConfiguration(createDefaultConfiguration());
  try {
    String path=new java.io.File(""String_Node_Str"").getCanonicalPath();
    log.info(""String_Node_Str"" + path);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}"
50025,"public String generateReply(RPCElement request){
  String pathFile=""String_Node_Str"";
  String strResponse=""String_Node_Str"";
  String messageId=""String_Node_Str"";
  log.debug(""String_Node_Str"");
  log.debug(request.toXML());
  if (request instanceof Hello) {
    log.debug(""String_Node_Str"");
    pathFile=helloFile;
  }
 else   if (request instanceof Query) {
    if (responseError) {
      log.debug(""String_Node_Str"");
      pathFile=errorFile;
    }
 else {
      Operation oper=((Query)request).getOperation();
      messageId=((Query)request).getMessageId();
      if (oper.equals(Operation.GET) || oper.equals(Operation.GET_CONFIG)) {
        log.debug(""String_Node_Str"");
        pathFile=infoFile;
      }
 else {
        log.debug(""String_Node_Str"");
        pathFile=okFile;
      }
    }
  }
  log.info(""String_Node_Str"" + pathFile);
  strResponse=FileHelper.readStringFromFile(pathFile);
  if (!messageId.equals(""String_Node_Str""))   strResponse=changeMessageIdNETCONF(strResponse,messageId);
  return strResponse;
}","public String generateReply(RPCElement request){
  String pathFile=""String_Node_Str"";
  String strResponse=""String_Node_Str"";
  String messageId=""String_Node_Str"";
  log.debug(""String_Node_Str"");
  log.debug(request.toXML());
  if (request instanceof Hello) {
    log.debug(""String_Node_Str"");
    pathFile=helloFile;
  }
 else   if (request instanceof Query) {
    if (responseError) {
      log.debug(""String_Node_Str"");
      pathFile=errorFile;
    }
 else {
      Operation oper=((Query)request).getOperation();
      messageId=((Query)request).getMessageId();
      if (oper.equals(Operation.GET) || oper.equals(Operation.GET_CONFIG)) {
        log.debug(""String_Node_Str"");
        pathFile=infoFile;
      }
 else {
        log.debug(""String_Node_Str"");
        pathFile=okFile;
      }
    }
  }
  log.info(""String_Node_Str"" + pathFile);
  try {
    strResponse=FileHelper.getInstance().readStringFromFile(pathFile);
  }
 catch (  Exception e) {
    log.error(e.getMessage());
  }
  if (!messageId.equals(""String_Node_Str""))   strResponse=changeMessageIdNETCONF(strResponse,messageId);
  return strResponse;
}"
50026,"public ArrayList<Capability> getActiveCapabilities(){
  return (ArrayList<Capability>)this.getList(CAPABILITIES_ACTIVE);
}","public ArrayList<Capability> getActiveCapabilities(){
  if (this.getProperty(CAPABILITIES_ACTIVE) instanceof Capability) {
    return getCapability(CAPABILITIES_ACTIVE);
  }
  return (ArrayList<Capability>)this.getList(CAPABILITIES_ACTIVE);
}"
50027,"public ArrayList<Capability> getServerCapabilities(){
  return (ArrayList<Capability>)this.getList(CAPABILITIES_SERVER);
}","public ArrayList<Capability> getServerCapabilities(){
  if (this.getProperty(CAPABILITIES_SERVER) instanceof Capability) {
    return getCapability(CAPABILITIES_SERVER);
  }
  return (ArrayList<Capability>)this.getList(CAPABILITIES_SERVER);
}"
50028,"public ArrayList<Capability> getClientCapabilities(){
  return (ArrayList<Capability>)this.getList(CAPABILITIES_CLIENT);
}","public ArrayList<Capability> getClientCapabilities(){
  if (this.getProperty(CAPABILITIES_CLIENT) instanceof Capability) {
    return getCapability(CAPABILITIES_CLIENT);
  }
  return (ArrayList<Capability>)this.getList(CAPABILITIES_CLIENT);
}"
50029,"public String toXML(){
  String xml=""String_Node_Str"";
  xml+=""String_Node_Str"" + messageId + ""String_Node_Str"";
  if (operation.equals(Operation.EDIT_CONFIG)) {
    xml+=""String_Node_Str"" + operation.getName() + ""String_Node_Str""+ editOperation+ ""String_Node_Str"";
  }
 else {
    xml+=""String_Node_Str"" + operation.getName() + ""String_Node_Str"";
  }
  if (target != null)   xml+=""String_Node_Str"" + target + ""String_Node_Str"";
  if (source != null)   xml+=""String_Node_Str"" + source + ""String_Node_Str"";
  if (filter != null) {
    xml+=""String_Node_Str"";
    if (filterType != null)     xml+=""String_Node_Str"" + filterType;
    xml+=""String_Node_Str"" + filter + ""String_Node_Str"";
  }
  if (sessionId != null)   xml+=""String_Node_Str"" + sessionId + ""String_Node_Str"";
  if (defaultOperation != null)   xml+=""String_Node_Str"" + defaultOperation + ""String_Node_Str"";
  if (editOperation != null)   xml+=""String_Node_Str"" + defaultOperation + ""String_Node_Str"";
  if (testOption != null)   xml+=""String_Node_Str"" + defaultOperation + ""String_Node_Str"";
  if (errorOption != null)   xml+=""String_Node_Str"" + errorOption + ""String_Node_Str"";
  if (config != null)   xml+=""String_Node_Str"" + config + ""String_Node_Str"";
  xml+=""String_Node_Str"" + operation.getName() + ""String_Node_Str"";
  xml+=""String_Node_Str"";
  return xml;
}","public String toXML(){
  String xml=""String_Node_Str"";
  xml+=""String_Node_Str"" + messageId + ""String_Node_Str"";
  xml+=""String_Node_Str"" + operation.getName() + ""String_Node_Str"";
  if (target != null)   xml+=""String_Node_Str"" + target + ""String_Node_Str"";
  if (source != null)   xml+=""String_Node_Str"" + source + ""String_Node_Str"";
  if (filter != null) {
    xml+=""String_Node_Str"";
    if (filterType != null)     xml+=""String_Node_Str"" + filterType;
    xml+=""String_Node_Str"" + filter + ""String_Node_Str"";
  }
  if (sessionId != null)   xml+=""String_Node_Str"" + sessionId + ""String_Node_Str"";
  if (defaultOperation != null)   xml+=""String_Node_Str"" + defaultOperation + ""String_Node_Str"";
  if (editOperation != null)   xml+=""String_Node_Str"" + defaultOperation + ""String_Node_Str"";
  if (testOption != null)   xml+=""String_Node_Str"" + defaultOperation + ""String_Node_Str"";
  if (errorOption != null)   xml+=""String_Node_Str"" + errorOption + ""String_Node_Str"";
  if (config != null)   xml+=""String_Node_Str"" + config + ""String_Node_Str"";
  xml+=""String_Node_Str"" + operation.getName() + ""String_Node_Str"";
  xml+=""String_Node_Str"";
  return xml;
}"
50030,"public String getDataFromFile(String fileConfig) throws TransportException {
  String str=""String_Node_Str"";
  log.info(""String_Node_Str"" + fileConfig);
  try {
    str=FileHelper.readStringFromFile(fileConfig);
  }
 catch (  Exception e) {
    e.printStackTrace();
    log.error(""String_Node_Str"" + e.getLocalizedMessage());
    throw new TransportException(e.getMessage());
  }
  log.info(""String_Node_Str"");
  return str;
}","public String getDataFromFile(String fileConfig) throws TransportException {
  String str=""String_Node_Str"";
  log.info(""String_Node_Str"" + fileConfig);
  try {
    str=FileHelper.getInstance().readStringFromFile(fileConfig);
  }
 catch (  Exception e) {
    e.printStackTrace();
    log.error(""String_Node_Str"" + e.getLocalizedMessage());
    throw new TransportException(e.getMessage());
  }
  log.info(""String_Node_Str"");
  return str;
}"
50031,"/** 
 * Simple parser. It was used for proves with xml files
 * @param stream
 * @return
 */
public static String readStringFromFile(String pathFile){
  String answer=null;
  InputStream inputFile=ClassLoader.getSystemResourceAsStream(pathFile);
  try {
    InputStreamReader streamReader=new InputStreamReader(inputFile);
    StringBuffer fileData=new StringBuffer(1000);
    BufferedReader reader=new BufferedReader(streamReader);
    char[] buf=new char[1024];
    int numRead=0;
    while ((numRead=reader.read(buf)) != -1) {
      String readData=String.valueOf(buf,0,numRead);
      fileData.append(readData);
      buf=new char[1024];
    }
    reader.close();
    answer=fileData.toString();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return answer;
}","/** 
 * Simple parser. It was used for proves with xml files
 * @param stream
 * @return
 */
public String readStringFromFile(String pathFile) throws Exception {
  String answer=null;
  InputStream inputFile=getClass().getResourceAsStream(pathFile);
  InputStreamReader streamReader=new InputStreamReader(inputFile);
  StringBuffer fileData=new StringBuffer(1000);
  BufferedReader reader=new BufferedReader(streamReader);
  char[] buf=new char[1024];
  int numRead=0;
  while ((numRead=reader.read(buf)) != -1) {
    String readData=String.valueOf(buf,0,numRead);
    fileData.append(readData);
    buf=new char[1024];
  }
  reader.close();
  answer=fileData.toString();
  return answer;
}"
50032,"public void sendAsyncQuery(RPCElement elem) throws TransportException {
  Reply reply=new Reply();
  Vector<Error> errors=new Vector<Error>();
  if (elem instanceof Hello) {
    ArrayList<Capability> capabilities=((Hello)elem).getCapabilities();
    capabilities.retainAll(this.supportedCapabilities);
    context.setActiveCapabilities(capabilities);
  }
  if (elem instanceof Query) {
    Query query=(Query)elem;
    Operation op=query.getOperation();
    if (op.equals(Operation.COPY_CONFIG)) {
    }
 else     if (op.equals(Operation.DELETE_CONFIG)) {
      reply.setOk(true);
    }
 else     if (op.equals(Operation.EDIT_CONFIG)) {
      reply.setOk(true);
    }
 else     if (op.equals(Operation.GET)) {
      if (query.getFilter() != null && query.getFilterType() != null) {
        if (context.getActiveCapabilities().contains(Capability.XPATH)) {
          if (!(query.getFilterType().equals(""String_Node_Str"") || query.getFilterType().equals(""String_Node_Str"")))           errors.add(new Error(){
{
              setTag(ErrorTag.BAD_ATTRIBUTE);
              setType(ErrorType.PROTOCOL);
              setSeverity(ErrorSeverity.ERROR);
              setInfo(""String_Node_Str"");
            }
          }
);
 else           if (query.getFilterType().equals(""String_Node_Str""))           errors.add(new Error(){
{
              setTag(ErrorTag.BAD_ATTRIBUTE);
              setType(ErrorType.PROTOCOL);
              setSeverity(ErrorSeverity.ERROR);
              setInfo(""String_Node_Str"");
            }
          }
);
        }
      }
      reply.setMessageId(query.getMessageId());
      reply.setContain(getDataFromFile(fileIPConfiguration));
    }
 else     if (op.equals(Operation.GET_CONFIG)) {
      if (query.getSource() == null)       errors.add(new Error(){
{
          setTag(ErrorTag.MISSING_ELEMENT);
          setType(ErrorType.PROTOCOL);
          setSeverity(ErrorSeverity.ERROR);
          setInfo(""String_Node_Str"");
        }
      }
);
      if (query.getSource() == null && query.getSource().equals(""String_Node_Str"")) {
        errors.add(new Error(){
{
            setTag(ErrorTag.BAD_ELEMENT);
            setType(ErrorType.PROTOCOL);
            setSeverity(ErrorSeverity.ERROR);
            setInfo(""String_Node_Str"");
          }
        }
);
      }
      if (query.getFilter() != null && query.getFilterType() != null) {
        if (context.getActiveCapabilities().contains(Capability.XPATH)) {
          if (!(query.getFilterType().equals(""String_Node_Str"") || query.getFilterType().equals(""String_Node_Str"")))           errors.add(new Error(){
{
              setTag(ErrorTag.BAD_ATTRIBUTE);
              setType(ErrorType.PROTOCOL);
              setSeverity(ErrorSeverity.ERROR);
              setInfo(""String_Node_Str"");
            }
          }
);
 else           if (query.getFilterType().equals(""String_Node_Str""))           errors.add(new Error(){
{
              setTag(ErrorTag.BAD_ATTRIBUTE);
              setType(ErrorType.PROTOCOL);
              setSeverity(ErrorSeverity.ERROR);
              setInfo(""String_Node_Str"");
            }
          }
);
        }
      }
      reply.setMessageId(query.getMessageId());
      if (!insideLogicalRouter) {
        reply.setContain(getDataFromFile(fileIPConfiguration));
      }
 else {
        reply.setContain(getDataFromFile(fileIPLogicalRouterConfig));
      }
    }
 else     if (op.equals(Operation.KILL_SESSION)) {
      disconnect();
      return;
    }
 else     if (op.equals(Operation.CLOSE_SESSION)) {
      reply.setMessageId(query.getMessageId());
      reply.setOk(true);
      disconnect();
    }
 else     if (op.equals(Operation.LOCK)) {
      error(""String_Node_Str"");
    }
 else     if (op.equals(Operation.UNLOCK)) {
      error(""String_Node_Str"");
    }
 else     if (op.equals(Operation.SET_LOGICAL_ROUTER)) {
      reply.setMessageId(query.getMessageId());
      reply.setContain(""String_Node_Str"" + query.getIdLogicalRouter() + ""String_Node_Str"");
      insideLogicalRouter=true;
    }
  }
  if (subsystem.equals(""String_Node_Str""))   addErrors(errors);
  if (errors.size() > 0)   reply.setErrors(errors);
  queue.put(reply);
}","public void sendAsyncQuery(RPCElement elem) throws TransportException {
  Reply reply=new Reply();
  Vector<Error> errors=new Vector<Error>();
  if (elem instanceof Hello) {
    ArrayList<Capability> capabilities=((Hello)elem).getCapabilities();
    capabilities.retainAll(this.supportedCapabilities);
    context.setActiveCapabilities(capabilities);
  }
  if (elem instanceof Query) {
    Query query=(Query)elem;
    Operation op=query.getOperation();
    if (op.equals(Operation.COPY_CONFIG)) {
    }
 else     if (op.equals(Operation.DELETE_CONFIG)) {
      reply.setOk(true);
    }
 else     if (op.equals(Operation.EDIT_CONFIG)) {
      reply.setOk(true);
    }
 else     if (op.equals(Operation.GET)) {
      if (query.getFilter() != null && query.getFilterType() != null) {
        if (context.getActiveCapabilities().contains(Capability.XPATH)) {
          if (!(query.getFilterType().equals(""String_Node_Str"") || query.getFilterType().equals(""String_Node_Str"")))           errors.add(new Error(){
{
              setTag(ErrorTag.BAD_ATTRIBUTE);
              setType(ErrorType.PROTOCOL);
              setSeverity(ErrorSeverity.ERROR);
              setInfo(""String_Node_Str"");
            }
          }
);
 else           if (query.getFilterType().equals(""String_Node_Str""))           errors.add(new Error(){
{
              setTag(ErrorTag.BAD_ATTRIBUTE);
              setType(ErrorType.PROTOCOL);
              setSeverity(ErrorSeverity.ERROR);
              setInfo(""String_Node_Str"");
            }
          }
);
        }
      }
      reply.setMessageId(query.getMessageId());
      reply.setContain(getDataFromFile(fileIPConfiguration));
    }
 else     if (op.equals(Operation.GET_CONFIG)) {
      if (query.getSource() == null)       errors.add(new Error(){
{
          setTag(ErrorTag.MISSING_ELEMENT);
          setType(ErrorType.PROTOCOL);
          setSeverity(ErrorSeverity.ERROR);
          setInfo(""String_Node_Str"");
        }
      }
);
      if (query.getSource() == null && query.getSource().equals(""String_Node_Str"")) {
        errors.add(new Error(){
{
            setTag(ErrorTag.BAD_ELEMENT);
            setType(ErrorType.PROTOCOL);
            setSeverity(ErrorSeverity.ERROR);
            setInfo(""String_Node_Str"");
          }
        }
);
      }
      if (query.getFilter() != null && query.getFilterType() != null) {
        if (context.getActiveCapabilities().contains(Capability.XPATH)) {
          if (!(query.getFilterType().equals(""String_Node_Str"") || query.getFilterType().equals(""String_Node_Str"")))           errors.add(new Error(){
{
              setTag(ErrorTag.BAD_ATTRIBUTE);
              setType(ErrorType.PROTOCOL);
              setSeverity(ErrorSeverity.ERROR);
              setInfo(""String_Node_Str"");
            }
          }
);
 else           if (query.getFilterType().equals(""String_Node_Str""))           errors.add(new Error(){
{
              setTag(ErrorTag.BAD_ATTRIBUTE);
              setType(ErrorType.PROTOCOL);
              setSeverity(ErrorSeverity.ERROR);
              setInfo(""String_Node_Str"");
            }
          }
);
        }
      }
      reply.setMessageId(query.getMessageId());
      if (!insideLogicalRouter) {
        reply.setContain(getDataFromFile(fileIPConfiguration));
      }
 else {
        reply.setContain(getDataFromFile(fileIPLogicalRouterConfig));
      }
    }
 else     if (op.equals(Operation.KILL_SESSION)) {
      insideLogicalRouter=false;
      disconnect();
      return;
    }
 else     if (op.equals(Operation.CLOSE_SESSION)) {
      reply.setMessageId(query.getMessageId());
      reply.setOk(true);
      insideLogicalRouter=false;
      disconnect();
    }
 else     if (op.equals(Operation.LOCK)) {
      error(""String_Node_Str"");
    }
 else     if (op.equals(Operation.UNLOCK)) {
      error(""String_Node_Str"");
    }
 else     if (op.equals(Operation.SET_LOGICAL_ROUTER)) {
      reply.setMessageId(query.getMessageId());
      reply.setContain(""String_Node_Str"" + query.getIdLogicalRouter() + ""String_Node_Str"");
      insideLogicalRouter=true;
    }
  }
  if (subsystem.equals(""String_Node_Str""))   addErrors(errors);
  if (errors.size() > 0)   reply.setErrors(errors);
  queue.put(reply);
}"
50033,"public void sendAsyncQuery(RPCElement elem) throws TransportException {
  Reply reply=new Reply();
  Vector<Error> errors=new Vector<Error>();
  if (elem instanceof Hello) {
    ArrayList<Capability> capabilities=((Hello)elem).getCapabilities();
    capabilities.retainAll(this.supportedCapabilities);
    context.setActiveCapabilities(capabilities);
  }
  if (elem instanceof Query) {
    Query query=(Query)elem;
    Operation op=query.getOperation();
    if (op.equals(Operation.COPY_CONFIG)) {
    }
 else     if (op.equals(Operation.DELETE_CONFIG)) {
      reply.setOk(true);
    }
 else     if (op.equals(Operation.EDIT_CONFIG)) {
      reply.setOk(true);
    }
 else     if (op.equals(Operation.GET)) {
      if (query.getFilter() != null && query.getFilterType() != null) {
        if (context.getActiveCapabilities().contains(Capability.XPATH)) {
          if (!(query.getFilterType().equals(""String_Node_Str"") || query.getFilterType().equals(""String_Node_Str"")))           errors.add(new Error(){
{
              setTag(ErrorTag.BAD_ATTRIBUTE);
              setType(ErrorType.PROTOCOL);
              setSeverity(ErrorSeverity.ERROR);
              setInfo(""String_Node_Str"");
            }
          }
);
 else           if (query.getFilterType().equals(""String_Node_Str""))           errors.add(new Error(){
{
              setTag(ErrorTag.BAD_ATTRIBUTE);
              setType(ErrorType.PROTOCOL);
              setSeverity(ErrorSeverity.ERROR);
              setInfo(""String_Node_Str"");
            }
          }
);
        }
      }
      reply.setMessageId(query.getMessageId());
      reply.setContain(getDataFromFile(fileIPConfiguration));
    }
 else     if (op.equals(Operation.GET_CONFIG)) {
      if (query.getSource() == null)       errors.add(new Error(){
{
          setTag(ErrorTag.MISSING_ELEMENT);
          setType(ErrorType.PROTOCOL);
          setSeverity(ErrorSeverity.ERROR);
          setInfo(""String_Node_Str"");
        }
      }
);
      if (query.getSource() == null && query.getSource().equals(""String_Node_Str"")) {
        errors.add(new Error(){
{
            setTag(ErrorTag.BAD_ELEMENT);
            setType(ErrorType.PROTOCOL);
            setSeverity(ErrorSeverity.ERROR);
            setInfo(""String_Node_Str"");
          }
        }
);
      }
      if (query.getFilter() != null && query.getFilterType() != null) {
        if (context.getActiveCapabilities().contains(Capability.XPATH)) {
          if (!(query.getFilterType().equals(""String_Node_Str"") || query.getFilterType().equals(""String_Node_Str"")))           errors.add(new Error(){
{
              setTag(ErrorTag.BAD_ATTRIBUTE);
              setType(ErrorType.PROTOCOL);
              setSeverity(ErrorSeverity.ERROR);
              setInfo(""String_Node_Str"");
            }
          }
);
 else           if (query.getFilterType().equals(""String_Node_Str""))           errors.add(new Error(){
{
              setTag(ErrorTag.BAD_ATTRIBUTE);
              setType(ErrorType.PROTOCOL);
              setSeverity(ErrorSeverity.ERROR);
              setInfo(""String_Node_Str"");
            }
          }
);
        }
      }
      reply.setMessageId(query.getMessageId());
      if (!insideLogicalRouter) {
        reply.setContain(getDataFromFile(fileIPConfiguration));
      }
 else {
        reply.setContain(getDataFromFile(fileIPLogicalRouterConfig));
      }
    }
 else     if (op.equals(Operation.KILL_SESSION)) {
      insideLogicalRouter=false;
      disconnect();
      return;
    }
 else     if (op.equals(Operation.CLOSE_SESSION)) {
      reply.setMessageId(query.getMessageId());
      reply.setOk(true);
      insideLogicalRouter=false;
      disconnect();
    }
 else     if (op.equals(Operation.LOCK)) {
      error(""String_Node_Str"");
    }
 else     if (op.equals(Operation.UNLOCK)) {
      error(""String_Node_Str"");
    }
 else     if (op.equals(Operation.SET_LOGICAL_ROUTER)) {
      reply.setMessageId(query.getMessageId());
      reply.setContain(""String_Node_Str"" + query.getIdLogicalRouter() + ""String_Node_Str"");
      insideLogicalRouter=true;
    }
  }
  if (subsystem.equals(""String_Node_Str""))   addErrors(errors);
  if (errors.size() > 0)   reply.setErrors(errors);
  queue.put(reply);
}","public void sendAsyncQuery(RPCElement elem) throws TransportException {
  Reply reply=new Reply();
  Vector<Error> errors=new Vector<Error>();
  if (elem instanceof Hello) {
    ArrayList<Capability> capabilities=((Hello)elem).getCapabilities();
    capabilities.retainAll(this.supportedCapabilities);
    context.setActiveCapabilities(capabilities);
  }
  if (elem instanceof Query) {
    Query query=(Query)elem;
    Operation op=query.getOperation();
    if (op.equals(Operation.COPY_CONFIG)) {
    }
 else     if (op.equals(Operation.DELETE_CONFIG)) {
      reply.setOk(true);
      reply.setMessageId(query.getMessageId());
    }
 else     if (op.equals(Operation.EDIT_CONFIG)) {
      reply.setOk(true);
      reply.setMessageId(query.getMessageId());
    }
 else     if (op.equals(Operation.GET)) {
      if (query.getFilter() != null && query.getFilterType() != null) {
        if (context.getActiveCapabilities().contains(Capability.XPATH)) {
          if (!(query.getFilterType().equals(""String_Node_Str"") || query.getFilterType().equals(""String_Node_Str"")))           errors.add(new Error(){
{
              setTag(ErrorTag.BAD_ATTRIBUTE);
              setType(ErrorType.PROTOCOL);
              setSeverity(ErrorSeverity.ERROR);
              setInfo(""String_Node_Str"");
            }
          }
);
 else           if (query.getFilterType().equals(""String_Node_Str""))           errors.add(new Error(){
{
              setTag(ErrorTag.BAD_ATTRIBUTE);
              setType(ErrorType.PROTOCOL);
              setSeverity(ErrorSeverity.ERROR);
              setInfo(""String_Node_Str"");
            }
          }
);
        }
      }
      reply.setMessageId(query.getMessageId());
      reply.setContain(getDataFromFile(fileIPConfiguration));
    }
 else     if (op.equals(Operation.GET_CONFIG)) {
      if (query.getSource() == null)       errors.add(new Error(){
{
          setTag(ErrorTag.MISSING_ELEMENT);
          setType(ErrorType.PROTOCOL);
          setSeverity(ErrorSeverity.ERROR);
          setInfo(""String_Node_Str"");
        }
      }
);
      if (query.getSource() == null && query.getSource().equals(""String_Node_Str"")) {
        errors.add(new Error(){
{
            setTag(ErrorTag.BAD_ELEMENT);
            setType(ErrorType.PROTOCOL);
            setSeverity(ErrorSeverity.ERROR);
            setInfo(""String_Node_Str"");
          }
        }
);
      }
      if (query.getFilter() != null && query.getFilterType() != null) {
        if (context.getActiveCapabilities().contains(Capability.XPATH)) {
          if (!(query.getFilterType().equals(""String_Node_Str"") || query.getFilterType().equals(""String_Node_Str"")))           errors.add(new Error(){
{
              setTag(ErrorTag.BAD_ATTRIBUTE);
              setType(ErrorType.PROTOCOL);
              setSeverity(ErrorSeverity.ERROR);
              setInfo(""String_Node_Str"");
            }
          }
);
 else           if (query.getFilterType().equals(""String_Node_Str""))           errors.add(new Error(){
{
              setTag(ErrorTag.BAD_ATTRIBUTE);
              setType(ErrorType.PROTOCOL);
              setSeverity(ErrorSeverity.ERROR);
              setInfo(""String_Node_Str"");
            }
          }
);
        }
      }
      reply.setMessageId(query.getMessageId());
      if (!insideLogicalRouter) {
        reply.setContain(getDataFromFile(fileIPConfiguration));
      }
 else {
        reply.setContain(getDataFromFile(fileIPLogicalRouterConfig));
      }
    }
 else     if (op.equals(Operation.KILL_SESSION)) {
      insideLogicalRouter=false;
      disconnect();
      return;
    }
 else     if (op.equals(Operation.CLOSE_SESSION)) {
      reply.setMessageId(query.getMessageId());
      reply.setOk(true);
      insideLogicalRouter=false;
      disconnect();
    }
 else     if (op.equals(Operation.LOCK)) {
      error(""String_Node_Str"");
    }
 else     if (op.equals(Operation.UNLOCK)) {
      error(""String_Node_Str"");
    }
 else     if (op.equals(Operation.SET_LOGICAL_ROUTER)) {
      reply.setMessageId(query.getMessageId());
      reply.setContain(""String_Node_Str"" + query.getIdLogicalRouter() + ""String_Node_Str"");
      insideLogicalRouter=true;
    }
  }
  if (subsystem.equals(""String_Node_Str""))   addErrors(errors);
  if (errors.size() > 0)   reply.setErrors(errors);
  queue.put(reply);
}"
50034,"public boolean equals(Operation compareOperation){
  return (this.name == compareOperation.name && this.capability == compareOperation.capability);
}","public boolean equals(Operation compareOperation){
  return (this.name.equals(compareOperation.name) && this.capability.equals(compareOperation.capability));
}"
50035,"public void sendAsyncQuery(RPCElement elem) throws TransportException {
  Reply reply=new Reply();
  Vector<Error> errors=new Vector<Error>();
  if (elem instanceof Hello) {
    ArrayList<Capability> capabilities=((Hello)elem).getCapabilities();
    capabilities.retainAll(this.supportedCapabilities);
    context.setActiveCapabilities(capabilities);
  }
  if (elem instanceof Query) {
    Query query=(Query)elem;
    Operation op=query.getOperation();
    if (op == Operation.COPY_CONFIG) {
    }
    if (op == Operation.DELETE_CONFIG) {
      reply.setOk(true);
    }
    if (op == Operation.EDIT_CONFIG) {
    }
    if (op.equals(Operation.GET)) {
      if (query.getFilter() != null && query.getFilterType() != null) {
        if (context.getActiveCapabilities().contains(Capability.XPATH)) {
          if (!(query.getFilterType().equals(""String_Node_Str"") || query.getFilterType().equals(""String_Node_Str"")))           errors.add(new Error(){
{
              setTag(ErrorTag.BAD_ATTRIBUTE);
              setType(ErrorType.PROTOCOL);
              setSeverity(ErrorSeverity.ERROR);
              setInfo(""String_Node_Str"");
            }
          }
);
 else           if (query.getFilterType().equals(""String_Node_Str""))           errors.add(new Error(){
{
              setTag(ErrorTag.BAD_ATTRIBUTE);
              setType(ErrorType.PROTOCOL);
              setSeverity(ErrorSeverity.ERROR);
              setInfo(""String_Node_Str"");
            }
          }
);
        }
      }
      reply.setMessageId(query.getMessageId());
      reply.setData(""String_Node_Str"");
    }
    if (op == Operation.GET_CONFIG) {
      if (query.getSource() == null)       errors.add(new Error(){
{
          setTag(ErrorTag.MISSING_ELEMENT);
          setType(ErrorType.PROTOCOL);
          setSeverity(ErrorSeverity.ERROR);
          setInfo(""String_Node_Str"");
        }
      }
);
      if (query.getSource() == null && query.getSource().equals(""String_Node_Str"")) {
        errors.add(new Error(){
{
            setTag(ErrorTag.BAD_ELEMENT);
            setType(ErrorType.PROTOCOL);
            setSeverity(ErrorSeverity.ERROR);
            setInfo(""String_Node_Str"");
          }
        }
);
      }
      if (query.getFilter() != null && query.getFilterType() != null) {
        if (context.getActiveCapabilities().contains(Capability.XPATH)) {
          if (!(query.getFilterType().equals(""String_Node_Str"") || query.getFilterType().equals(""String_Node_Str"")))           errors.add(new Error(){
{
              setTag(ErrorTag.BAD_ATTRIBUTE);
              setType(ErrorType.PROTOCOL);
              setSeverity(ErrorSeverity.ERROR);
              setInfo(""String_Node_Str"");
            }
          }
);
 else           if (query.getFilterType().equals(""String_Node_Str""))           errors.add(new Error(){
{
              setTag(ErrorTag.BAD_ATTRIBUTE);
              setType(ErrorType.PROTOCOL);
              setSeverity(ErrorSeverity.ERROR);
              setInfo(""String_Node_Str"");
            }
          }
);
        }
      }
      reply.setMessageId(query.getMessageId());
      reply.setData(""String_Node_Str"");
    }
    if (op == Operation.KILL_SESSION) {
      disconnect();
      return;
    }
    if (op == Operation.CLOSE_SESSION) {
      reply.setMessageId(query.getMessageId());
      reply.setOk(true);
      disconnect();
    }
    if (op == Operation.LOCK) {
      error(""String_Node_Str"");
    }
    if (op == Operation.UNLOCK) {
      error(""String_Node_Str"");
    }
  }
  if (subsystem.equals(""String_Node_Str""))   addErrors(errors);
  if (errors.size() > 0)   reply.setErrors(errors);
  queue.put(reply);
}","public void sendAsyncQuery(RPCElement elem) throws TransportException {
  Reply reply=new Reply();
  Vector<Error> errors=new Vector<Error>();
  if (elem instanceof Hello) {
    ArrayList<Capability> capabilities=((Hello)elem).getCapabilities();
    capabilities.retainAll(this.supportedCapabilities);
    context.setActiveCapabilities(capabilities);
  }
  if (elem instanceof Query) {
    Query query=(Query)elem;
    Operation op=query.getOperation();
    if (op.equals(Operation.COPY_CONFIG)) {
    }
    if (op.equals(Operation.DELETE_CONFIG)) {
      reply.setOk(true);
    }
    if (op.equals(Operation.EDIT_CONFIG)) {
    }
    if (op.equals(Operation.GET)) {
      if (query.getFilter() != null && query.getFilterType() != null) {
        if (context.getActiveCapabilities().contains(Capability.XPATH)) {
          if (!(query.getFilterType().equals(""String_Node_Str"") || query.getFilterType().equals(""String_Node_Str"")))           errors.add(new Error(){
{
              setTag(ErrorTag.BAD_ATTRIBUTE);
              setType(ErrorType.PROTOCOL);
              setSeverity(ErrorSeverity.ERROR);
              setInfo(""String_Node_Str"");
            }
          }
);
 else           if (query.getFilterType().equals(""String_Node_Str""))           errors.add(new Error(){
{
              setTag(ErrorTag.BAD_ATTRIBUTE);
              setType(ErrorType.PROTOCOL);
              setSeverity(ErrorSeverity.ERROR);
              setInfo(""String_Node_Str"");
            }
          }
);
        }
      }
      reply.setMessageId(query.getMessageId());
      reply.setData(""String_Node_Str"");
    }
    if (op.equals(Operation.GET_CONFIG)) {
      if (query.getSource() == null)       errors.add(new Error(){
{
          setTag(ErrorTag.MISSING_ELEMENT);
          setType(ErrorType.PROTOCOL);
          setSeverity(ErrorSeverity.ERROR);
          setInfo(""String_Node_Str"");
        }
      }
);
      if (query.getSource() == null && query.getSource().equals(""String_Node_Str"")) {
        errors.add(new Error(){
{
            setTag(ErrorTag.BAD_ELEMENT);
            setType(ErrorType.PROTOCOL);
            setSeverity(ErrorSeverity.ERROR);
            setInfo(""String_Node_Str"");
          }
        }
);
      }
      if (query.getFilter() != null && query.getFilterType() != null) {
        if (context.getActiveCapabilities().contains(Capability.XPATH)) {
          if (!(query.getFilterType().equals(""String_Node_Str"") || query.getFilterType().equals(""String_Node_Str"")))           errors.add(new Error(){
{
              setTag(ErrorTag.BAD_ATTRIBUTE);
              setType(ErrorType.PROTOCOL);
              setSeverity(ErrorSeverity.ERROR);
              setInfo(""String_Node_Str"");
            }
          }
);
 else           if (query.getFilterType().equals(""String_Node_Str""))           errors.add(new Error(){
{
              setTag(ErrorTag.BAD_ATTRIBUTE);
              setType(ErrorType.PROTOCOL);
              setSeverity(ErrorSeverity.ERROR);
              setInfo(""String_Node_Str"");
            }
          }
);
        }
      }
      reply.setMessageId(query.getMessageId());
      reply.setData(""String_Node_Str"");
    }
    if (op.equals(Operation.KILL_SESSION)) {
      disconnect();
      return;
    }
    if (op.equals(Operation.CLOSE_SESSION)) {
      reply.setMessageId(query.getMessageId());
      reply.setOk(true);
      disconnect();
    }
    if (op.equals(Operation.LOCK)) {
      error(""String_Node_Str"");
    }
    if (op.equals(Operation.UNLOCK)) {
      error(""String_Node_Str"");
    }
  }
  if (subsystem.equals(""String_Node_Str""))   addErrors(errors);
  if (errors.size() > 0)   reply.setErrors(errors);
  queue.put(reply);
}"
50036,"public void disconnect() throws TransportException {
  if (timerKeepAlive != null)   timerKeepAlive.close();
  transport.disconnect();
}","public void disconnect() throws TransportException {
  transport.disconnect();
}"
50037,"/** 
 * Send a Netconf Query and return immediately. You will have to get the reply (if any) via a NetconfReplyHandler or polling receiveReply() for it. Don't set message-id, it will be ignored and overridden by the session.
 * @param querys
 * @throws TransportException
 */
public void sendAsyncQuery(Query query) throws TransportException {
  query.setMessageId(generateMessageId());
  timerKeepAlive.reset();
  transport.sendAsyncQuery(query);
}","/** 
 * Send a Netconf Query and return immediately. You will have to get the reply (if any) via a NetconfReplyHandler or polling receiveReply() for it. Don't set message-id, it will be ignored and overridden by the session.
 * @param querys
 * @throws TransportException
 */
public void sendAsyncQuery(Query query) throws TransportException {
  query.setMessageId(generateMessageId());
  transport.sendAsyncQuery(query);
}"
50038,"public void loadConfiguration(Configuration source){
  sessionContext.addConfiguration(source);
}","public void loadConfiguration(Configuration source){
  sessionContext.newConfiguration(source);
}"
50039,"public void connect() throws TransportException, NetconfProtocolException {
  RPCElement reply;
  Hello clientHello;
  Hello serverHello;
  ArrayList<Capability> activeCapabilities;
  ArrayList<Capability> clientCapabilities;
  ArrayList<Capability> serverCapabilities;
  messageQueue=new MessageQueue();
  messageQueue.addListener(this);
  try {
    transport=TransportFactory.getTransport(sessionContext.getURI().getScheme());
  }
 catch (  TransportNotImplementedException e) {
    TransportException te=new TransportException(e.getMessage());
    te.initCause(e);
    throw te;
  }
  transport.setMessageQueue(messageQueue);
  transport.addListener(this);
  sessionContext.setLastMessageId(0);
  transport.connect(sessionContext);
  log.info(""String_Node_Str"");
  clientHello=new Hello();
  clientCapabilities=Capability.getSupportedCapabilities();
  clientHello.setCapabilities(clientCapabilities);
  log.info(""String_Node_Str"");
  transport.sendAsyncQuery(clientHello);
  reply=messageQueue.blockingConsumeById(""String_Node_Str"");
  if (!(reply instanceof Hello))   throw new NetconfProtocolException(""String_Node_Str"");
 else   serverHello=(Hello)reply;
  log.info(""String_Node_Str"");
  this.sessionId=serverHello.getSessionId();
  serverCapabilities=serverHello.getCapabilities();
  activeCapabilities=(ArrayList<Capability>)clientCapabilities.clone();
  activeCapabilities.retainAll(serverCapabilities);
  log.debug(""String_Node_Str"" + activeCapabilities);
  sessionContext.setActiveCapabilities(activeCapabilities);
  sessionContext.setClientCapabilities(clientCapabilities);
  sessionContext.setServerCapabilities(serverCapabilities);
  log.info(""String_Node_Str"" + this.sessionId + ""String_Node_Str"");
  for (  Capability capability : activeCapabilities)   log.info(""String_Node_Str"" + capability);
  timerKeepAlive=new TimerKeepAlive(this);
  timerKeepAlive.start(PERIOD);
}","public void connect() throws TransportException, NetconfProtocolException {
  RPCElement reply;
  Hello clientHello;
  Hello serverHello;
  ArrayList<Capability> activeCapabilities;
  ArrayList<Capability> clientCapabilities;
  ArrayList<Capability> serverCapabilities;
  messageQueue=new MessageQueue();
  messageQueue.addListener(this);
  try {
    transport=TransportFactory.getTransport(sessionContext.getURI().getScheme());
  }
 catch (  TransportNotImplementedException e) {
    TransportException te=new TransportException(e.getMessage());
    te.initCause(e);
    throw te;
  }
  transport.setMessageQueue(messageQueue);
  transport.addListener(this);
  sessionContext.setLastMessageId(0);
  transport.connect(sessionContext);
  log.info(""String_Node_Str"");
  clientHello=new Hello();
  clientCapabilities=Capability.getSupportedCapabilities();
  clientHello.setCapabilities(clientCapabilities);
  log.info(""String_Node_Str"");
  transport.sendAsyncQuery(clientHello);
  reply=messageQueue.blockingConsumeById(""String_Node_Str"");
  if (!(reply instanceof Hello))   throw new NetconfProtocolException(""String_Node_Str"");
 else   serverHello=(Hello)reply;
  log.info(""String_Node_Str"");
  this.sessionId=serverHello.getSessionId();
  serverCapabilities=serverHello.getCapabilities();
  activeCapabilities=(ArrayList<Capability>)clientCapabilities.clone();
  activeCapabilities.retainAll(serverCapabilities);
  log.debug(""String_Node_Str"" + activeCapabilities);
  sessionContext.setActiveCapabilities(activeCapabilities);
  sessionContext.setClientCapabilities(clientCapabilities);
  sessionContext.setServerCapabilities(serverCapabilities);
  log.info(""String_Node_Str"" + this.sessionId + ""String_Node_Str"");
  for (  Capability capability : activeCapabilities)   log.info(""String_Node_Str"" + capability);
}"
50040,"public void start(int period){
  this.period=period;
  log.info(""String_Node_Str"");
  schedulerHandler=timer.scheduleAtFixedRate(this,0,period,TimeUnit.MINUTES);
}","public void start(int period){
  this.period=period;
  log.info(""String_Node_Str"");
  schedulerHandler=timer.scheduleAtFixedRate(this,period,period,TimeUnit.MINUTES);
}"
50041,"public void reset(){
  close();
  schedulerHandler=timer.scheduleAtFixedRate(this,0,period,TimeUnit.MINUTES);
}","public void reset(){
  close();
  schedulerHandler=timer.scheduleAtFixedRate(this,period,period,TimeUnit.MINUTES);
}"
50042,"public void run(){
  try {
    log.info(""String_Node_Str"");
    Reply reply=netconfSession.sendSyncQuery(query);
    if (reply.containsErrors()) {
      log.error(""String_Node_Str"" + '\n' + reply.toXML()+ '\n');
      isOK=false;
    }
 else {
      log.info(""String_Node_Str"");
      isOK=true;
    }
  }
 catch (  TransportException e) {
    log.error(e.getMessage());
    isOK=true;
  }
}","public void run(){
  try {
    log.info(""String_Node_Str"");
    Reply reply=netconfSession.sendSyncQuery(query);
    if (reply.containsErrors()) {
      log.error(""String_Node_Str"" + '\n' + reply.toXML()+ '\n');
      netconfSession.disconnect();
    }
 else {
      log.info(""String_Node_Str"");
    }
  }
 catch (  TransportException e) {
    log.error(e.getMessage());
  }
}"
50043,"public void receiveRPCElement(RPCElement element){
synchronized (monitor) {
    monitor.notifyAll();
  }
}","public void receiveRPCElement(RPCElement element){
  isReceived=true;
}"
50044,"@Test(timeout=10000) public void testSendAsyncQuery(){
  final Object monitor=new Object();
  Query query=QueryFactory.newKeepAlive();
  session.registerMessageQueueListener(new TestMessageQueueListener(monitor));
  try {
    session.sendAsyncQuery(query);
synchronized (monitor) {
      monitor.wait();
    }
  }
 catch (  TransportException e) {
    fail(e.getMessage());
  }
catch (  InterruptedException e) {
    e.printStackTrace();
  }
}","@Test(timeout=2000) public void testSendAsyncQuery(){
  Query query=QueryFactory.newKeepAlive();
  TestMessageQueueListener testMsgQueueList=new TestMessageQueueListener();
  session.registerMessageQueueListener(testMsgQueueList);
  try {
    session.sendAsyncQuery(query);
    while (!testMsgQueueList.isReceived()) {
      Thread.sleep(1000);
    }
  }
 catch (  TransportException e) {
    fail(e.getMessage());
  }
catch (  InterruptedException e) {
    fail(e.getMessage());
  }
}"
50045,"public TestMessageQueueListener(Object monitor){
  this.monitor=monitor;
}","public TestMessageQueueListener(){
  this.isReceived=false;
}"
50046,"private void startParsing(){
  parserThread=new Thread(""String_Node_Str""){
    @Override public void run(){
      log.debug(""String_Node_Str"");
      while (!closed) {
        try {
          log.debug(""String_Node_Str"");
          if (sessionContext.isLogRespXML()) {
            log.debug(""String_Node_Str"" + sessionContext.getLogFileXML());
            parser.parse(new InputSource(new TeeInputStream(session.getStdout(),new FileOutputStream(sessionContext.getLogFileXML()),true)));
          }
 else {
            parser.parse(new InputSource(session.getStdout()));
          }
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
catch (        SAXException e) {
          if (e.getMessage().contentEquals(""String_Node_Str"")) {
          }
 else {
            log.error(e.getMessage());
            e.printStackTrace();
            disconnect();
          }
          log.info(""String_Node_Str"");
        }
        log.debug(""String_Node_Str"");
      }
      log.debug(""String_Node_Str"");
    }
  }
;
  parserThread.start();
}","private void startParsing(){
  parserThread=new Thread(""String_Node_Str""){
    @Override public void run(){
      log.debug(""String_Node_Str"");
      while (!closed) {
        try {
          log.debug(""String_Node_Str"");
          String buffer=""String_Node_Str"";
          BufferedReader reader=new BufferedReader(new InputStreamReader(session.getStdout()));
          do {
            buffer+=reader.readLine();
          }
 while (!buffer.endsWith(delimiter));
          parser.parse(new InputSource(new StringReader(buffer)));
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
catch (        SAXException e) {
          if (e.getMessage().contentEquals(""String_Node_Str"")) {
          }
 else {
            log.error(e.getMessage());
            e.printStackTrace();
            disconnect();
          }
          log.info(""String_Node_Str"");
        }
        log.debug(""String_Node_Str"");
      }
      log.debug(""String_Node_Str"");
    }
  }
;
  parserThread.start();
}"
50047,"@Override public void run(){
  log.debug(""String_Node_Str"");
  while (!closed) {
    try {
      log.debug(""String_Node_Str"");
      if (sessionContext.isLogRespXML()) {
        log.debug(""String_Node_Str"" + sessionContext.getLogFileXML());
        parser.parse(new InputSource(new TeeInputStream(session.getStdout(),new FileOutputStream(sessionContext.getLogFileXML()),true)));
      }
 else {
        parser.parse(new InputSource(session.getStdout()));
      }
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
catch (    SAXException e) {
      if (e.getMessage().contentEquals(""String_Node_Str"")) {
      }
 else {
        log.error(e.getMessage());
        e.printStackTrace();
        disconnect();
      }
      log.info(""String_Node_Str"");
    }
    log.debug(""String_Node_Str"");
  }
  log.debug(""String_Node_Str"");
}","@Override public void run(){
  log.debug(""String_Node_Str"");
  while (!closed) {
    try {
      log.debug(""String_Node_Str"");
      String buffer=""String_Node_Str"";
      BufferedReader reader=new BufferedReader(new InputStreamReader(session.getStdout()));
      do {
        buffer+=reader.readLine();
      }
 while (!buffer.endsWith(delimiter));
      parser.parse(new InputSource(new StringReader(buffer)));
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
catch (    SAXException e) {
      if (e.getMessage().contentEquals(""String_Node_Str"")) {
      }
 else {
        log.error(e.getMessage());
        e.printStackTrace();
        disconnect();
      }
      log.info(""String_Node_Str"");
    }
    log.debug(""String_Node_Str"");
  }
  log.debug(""String_Node_Str"");
}"
50048,"@Override public void startElement(String uri,String localName,String qName,Attributes attributes) throws SAXException {
  super.startElement(uri,localName,qName,attributes);
  log.debug(""String_Node_Str"" + uri + ""String_Node_Str""+ localName+ ""String_Node_Str"");
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    hello=new Hello();
    capabilities=new ArrayList<Capability>();
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideCapabilityTag=true;
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideSessionIdTag=true;
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    reply=new Reply();
    messageId=attributes.getValue(""String_Node_Str"");
    if (messageId == null)     throw new SAXException(new NetconfProtocolException(""String_Node_Str""));
    reply.setMessageId(messageId);
    reply.setOk(false);
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideDataTag=true;
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    reply.setOk(true);
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    error=new Error();
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorTypeTag=true;
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorTagTag=true;
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorSeverityTag=true;
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorAppTagTag=true;
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorPathTag=true;
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorMessageTag=true;
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorInfoTag=true;
  }
}","@Override public void startElement(String uri,String localName,String qName,Attributes attributes) throws SAXException {
  super.startElement(uri,localName,qName,attributes);
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    hello=new Hello();
    capabilities=new ArrayList<Capability>();
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideCapabilityTag=true;
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideSessionIdTag=true;
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    reply=new Reply();
    messageId=attributes.getValue(""String_Node_Str"");
    if (messageId == null)     throw new SAXException(new NetconfProtocolException(""String_Node_Str""));
    reply.setMessageId(messageId);
    reply.setOk(false);
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideDataTag=true;
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    reply.setOk(true);
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    error=new Error();
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorTypeTag=true;
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorTagTag=true;
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorSeverityTag=true;
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorAppTagTag=true;
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorPathTag=true;
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorMessageTag=true;
  }
  if (localName.equalsIgnoreCase(""String_Node_Str"")) {
    insideErrorInfoTag=true;
  }
}"
50049,"/** 
 * Send a Netconf Query and return immediately. You will have to get the reply (if any) via a NetconfReplyHandler or polling receiveReply() for it. Don't set message-id, it will be ignored and overridden by the session.
 * @param querys
 * @throws TransportException
 */
public void sendAsyncQuery(Query query) throws TransportException {
  query.setMessageId(generateMessageId());
  transport.sendAsyncQuery(query);
}","/** 
 * Send a Netconf Query and return immediately. You will have to get the reply (if any) via a NetconfReplyHandler or polling receiveReply() for it. Don't set message-id, it will be ignored and overridden by the session.
 * @param querys
 * @throws TransportException
 */
public void sendAsyncQuery(Query query) throws TransportException {
  query.setMessageId(generateMessageId());
  timerKeepAlive.reset();
  transport.sendAsyncQuery(query);
}"
50050,"public void connect() throws TransportException, NetconfProtocolException {
  TimerKeepAlive timerKeepAlive;
  RPCElement reply;
  Hello clientHello;
  Hello serverHello;
  ArrayList<Capability> activeCapabilities;
  ArrayList<Capability> clientCapabilities;
  ArrayList<Capability> serverCapabilities;
  messageQueue=new MessageQueue();
  messageQueue.addListener(this);
  try {
    transport=TransportFactory.getTransport(sessionContext.getURI().getScheme());
  }
 catch (  TransportNotImplementedException e) {
    TransportException te=new TransportException(e.getMessage());
    te.initCause(e);
    throw te;
  }
  transport.setMessageQueue(messageQueue);
  transport.addListener(this);
  sessionContext.setLastMessageId(0);
  transport.connect(sessionContext);
  log.info(""String_Node_Str"");
  clientHello=new Hello();
  clientCapabilities=Capability.getSupportedCapabilities();
  clientHello.setCapabilities(clientCapabilities);
  log.info(""String_Node_Str"");
  transport.sendAsyncQuery(clientHello);
  reply=messageQueue.blockingConsumeById(""String_Node_Str"");
  if (!(reply instanceof Hello))   throw new NetconfProtocolException(""String_Node_Str"");
 else   serverHello=(Hello)reply;
  log.info(""String_Node_Str"");
  this.sessionId=serverHello.getSessionId();
  serverCapabilities=serverHello.getCapabilities();
  activeCapabilities=(ArrayList<Capability>)clientCapabilities.clone();
  activeCapabilities.retainAll(serverCapabilities);
  log.debug(""String_Node_Str"" + activeCapabilities);
  sessionContext.setActiveCapabilities(activeCapabilities);
  sessionContext.setClientCapabilities(clientCapabilities);
  sessionContext.setServerCapabilities(serverCapabilities);
  log.info(""String_Node_Str"" + this.sessionId + ""String_Node_Str"");
  for (  Capability capability : activeCapabilities)   log.info(""String_Node_Str"" + capability);
  timerKeepAlive=new TimerKeepAlive(this);
  timerKeepAlive.start(PERIOD);
}","public void connect() throws TransportException, NetconfProtocolException {
  RPCElement reply;
  Hello clientHello;
  Hello serverHello;
  ArrayList<Capability> activeCapabilities;
  ArrayList<Capability> clientCapabilities;
  ArrayList<Capability> serverCapabilities;
  messageQueue=new MessageQueue();
  messageQueue.addListener(this);
  try {
    transport=TransportFactory.getTransport(sessionContext.getURI().getScheme());
  }
 catch (  TransportNotImplementedException e) {
    TransportException te=new TransportException(e.getMessage());
    te.initCause(e);
    throw te;
  }
  transport.setMessageQueue(messageQueue);
  transport.addListener(this);
  sessionContext.setLastMessageId(0);
  transport.connect(sessionContext);
  log.info(""String_Node_Str"");
  clientHello=new Hello();
  clientCapabilities=Capability.getSupportedCapabilities();
  clientHello.setCapabilities(clientCapabilities);
  log.info(""String_Node_Str"");
  transport.sendAsyncQuery(clientHello);
  reply=messageQueue.blockingConsumeById(""String_Node_Str"");
  if (!(reply instanceof Hello))   throw new NetconfProtocolException(""String_Node_Str"");
 else   serverHello=(Hello)reply;
  log.info(""String_Node_Str"");
  this.sessionId=serverHello.getSessionId();
  serverCapabilities=serverHello.getCapabilities();
  activeCapabilities=(ArrayList<Capability>)clientCapabilities.clone();
  activeCapabilities.retainAll(serverCapabilities);
  log.debug(""String_Node_Str"" + activeCapabilities);
  sessionContext.setActiveCapabilities(activeCapabilities);
  sessionContext.setClientCapabilities(clientCapabilities);
  sessionContext.setServerCapabilities(serverCapabilities);
  log.info(""String_Node_Str"" + this.sessionId + ""String_Node_Str"");
  for (  Capability capability : activeCapabilities)   log.info(""String_Node_Str"" + capability);
  timerKeepAlive=new TimerKeepAlive(this);
  timerKeepAlive.start(PERIOD);
}"
50051,"@Test public void testLoadConfiguration(){
  try {
    session.loadConfiguration(new PropertiesConfiguration(""String_Node_Str""));
  }
 catch (  ConfigurationException e) {
    fail(e.getMessage());
  }
}","@Test public void testLoadConfiguration(){
  try {
    session.loadConfiguration(new PropertiesConfiguration(""String_Node_Str""));
  }
 catch (  ConfigurationException e) {
    e.printStackTrace();
  }
}"
50052,"public String toXML(){
  String xml=""String_Node_Str"";
  xml+=""String_Node_Str"" + messageId + ""String_Node_Str"";
  if (operation.equals(Operation.EDIT_CONFIG)) {
    xml+=""String_Node_Str"" + operation.getName() + ""String_Node_Str""+ editOperation+ ""String_Node_Str"";
  }
 else {
    xml+=""String_Node_Str"" + operation.getName() + ""String_Node_Str"";
  }
  if (target != null)   xml+=""String_Node_Str"" + target + ""String_Node_Str"";
  if (source != null)   xml+=""String_Node_Str"" + source + ""String_Node_Str"";
  if (filter != null) {
    xml+=""String_Node_Str"";
    if (filterType != null)     xml+=""String_Node_Str"" + filterType;
    xml+=""String_Node_Str"" + filter + ""String_Node_Str"";
  }
  if (sessionId != null)   xml+=""String_Node_Str"" + sessionId + ""String_Node_Str"";
  if (defaultOperation != null)   xml+=""String_Node_Str"" + defaultOperation + ""String_Node_Str"";
  if (editOperation != null)   xml+=""String_Node_Str"" + defaultOperation + ""String_Node_Str"";
  if (testOption != null)   xml+=""String_Node_Str"" + defaultOperation + ""String_Node_Str"";
  if (errorOption != null)   xml+=""String_Node_Str"" + errorOption + ""String_Node_Str"";
  if (config != null)   xml+=""String_Node_Str"" + config + ""String_Node_Str"";
  xml+=""String_Node_Str"" + operation.getName() + ""String_Node_Str"";
  xml+=""String_Node_Str"";
  return xml;
}","public String toXML(){
  String xml=""String_Node_Str"";
  xml+=""String_Node_Str"" + messageId + ""String_Node_Str"";
  if (operation.equals(Operation.EDIT_CONFIG)) {
    xml+=""String_Node_Str"" + operation.getName() + ""String_Node_Str""+ editOperation+ ""String_Node_Str"";
  }
 else {
    xml+=""String_Node_Str"" + operation.getName() + ""String_Node_Str"";
  }
  if (target != null)   xml+=""String_Node_Str"" + target + ""String_Node_Str"";
  if (source != null)   xml+=""String_Node_Str"" + source + ""String_Node_Str"";
  if (filter != null) {
    xml+=""String_Node_Str"";
    if (attrFilter != null)     xml+=""String_Node_Str"" + attrFilter;
    xml+=""String_Node_Str"" + filter + ""String_Node_Str"";
  }
  if (sessionId != null)   xml+=""String_Node_Str"" + sessionId + ""String_Node_Str"";
  if (defaultOperation != null)   xml+=""String_Node_Str"" + defaultOperation + ""String_Node_Str"";
  if (editOperation != null)   xml+=""String_Node_Str"" + defaultOperation + ""String_Node_Str"";
  if (testOption != null)   xml+=""String_Node_Str"" + defaultOperation + ""String_Node_Str"";
  if (errorOption != null)   xml+=""String_Node_Str"" + errorOption + ""String_Node_Str"";
  if (config != null)   xml+=""String_Node_Str"" + config + ""String_Node_Str"";
  xml+=""String_Node_Str"" + operation.getName() + ""String_Node_Str"";
  xml+=""String_Node_Str"";
  return xml;
}"
50053,"private void startParsing(){
  parserThread=new Thread(""String_Node_Str""){
    @Override public void run(){
      log.debug(""String_Node_Str"");
      while (!closed) {
        try {
          log.debug(""String_Node_Str"");
          if (sessionContext.isLogRespXML())           parser.parse(new InputSource(new TeeInputStream(inStream,new FileOutputStream(sessionContext.getLogFileXML()))));
 else           parser.parse(new InputSource(inStream));
        }
 catch (        InterruptedIOException ie) {
          log.warn(""String_Node_Str"");
        }
catch (        IOException e) {
          e.printStackTrace();
        }
catch (        SAXException e) {
          if (e.getMessage().contentEquals(""String_Node_Str"")) {
            log.debug(""String_Node_Str"");
          }
 else {
            log.error(e.getMessage());
            e.printStackTrace();
            disconnect();
          }
          log.info(""String_Node_Str"");
        }
        log.debug(""String_Node_Str"");
      }
      log.debug(""String_Node_Str"");
    }
  }
;
  parserThread.start();
}","private void startParsing(){
  parserThread=new Thread(""String_Node_Str""){
    @Override public void run(){
      log.debug(""String_Node_Str"");
      while (!closed) {
        try {
          log.debug(""String_Node_Str"");
          if (sessionContext.isLogRespXML())           parser.parse(new InputSource(new TeeInputStream(inStream,new FileOutputStream(sessionContext.getLogFileXML()))));
 else {
            parser.parse(new InputSource(inStream));
          }
        }
 catch (        InterruptedIOException ie) {
          log.warn(""String_Node_Str"");
        }
catch (        IOException e) {
          e.printStackTrace();
        }
catch (        SAXException e) {
          if (e.getMessage().contentEquals(""String_Node_Str"")) {
            log.debug(""String_Node_Str"");
          }
 else {
            log.error(e.getMessage());
            e.printStackTrace();
            disconnect();
          }
          log.info(""String_Node_Str"");
        }
        log.debug(""String_Node_Str"");
      }
      log.debug(""String_Node_Str"");
    }
  }
;
  parserThread.start();
}"
50054,"@Override public void run(){
  log.debug(""String_Node_Str"");
  while (!closed) {
    try {
      log.debug(""String_Node_Str"");
      if (sessionContext.isLogRespXML())       parser.parse(new InputSource(new TeeInputStream(inStream,new FileOutputStream(sessionContext.getLogFileXML()))));
 else       parser.parse(new InputSource(inStream));
    }
 catch (    InterruptedIOException ie) {
      log.warn(""String_Node_Str"");
    }
catch (    IOException e) {
      e.printStackTrace();
    }
catch (    SAXException e) {
      if (e.getMessage().contentEquals(""String_Node_Str"")) {
        log.debug(""String_Node_Str"");
      }
 else {
        log.error(e.getMessage());
        e.printStackTrace();
        disconnect();
      }
      log.info(""String_Node_Str"");
    }
    log.debug(""String_Node_Str"");
  }
  log.debug(""String_Node_Str"");
}","@Override public void run(){
  log.debug(""String_Node_Str"");
  while (!closed) {
    try {
      log.debug(""String_Node_Str"");
      if (sessionContext.isLogRespXML())       parser.parse(new InputSource(new TeeInputStream(inStream,new FileOutputStream(sessionContext.getLogFileXML()))));
 else {
        parser.parse(new InputSource(inStream));
      }
    }
 catch (    InterruptedIOException ie) {
      log.warn(""String_Node_Str"");
    }
catch (    IOException e) {
      e.printStackTrace();
    }
catch (    SAXException e) {
      if (e.getMessage().contentEquals(""String_Node_Str"")) {
        log.debug(""String_Node_Str"");
      }
 else {
        log.error(e.getMessage());
        e.printStackTrace();
        disconnect();
      }
      log.info(""String_Node_Str"");
    }
    log.debug(""String_Node_Str"");
  }
  log.debug(""String_Node_Str"");
}"
50055,"public void sendAsyncQuery(RPCElement query){
  try {
    outStream.write(simHelper.generateReply(query).getBytes());
  }
 catch (  IOException e) {
    log.error(e.getMessage());
  }
  log.info(""String_Node_Str"");
}","public void sendAsyncQuery(RPCElement query){
  try {
    outStream.write(simHelper.generateReply(query).getBytes());
    outStream.flush();
  }
 catch (  IOException e) {
    log.error(e.getMessage());
  }
  log.info(""String_Node_Str"");
}"
50056,"/** 
 * This method handles the case where a project looks like a Grails project but doesn't have grails nature. 
 */
private void handleNoGrailsNature(final IProject project,GrailsVersion grailsVersion){
  debug(""String_Node_Str"" + project);
  final IGrailsInstall install=GrailsCoreActivator.getDefault().getInstallManager().getDefaultGrailsInstall();
  Assert.isTrue(install.getVersion().equals(grailsVersion));
  boolean convert=askConvertToGrailsProject(project,grailsVersion);
  if (convert) {
    debug(""String_Node_Str"");
    WorkspaceJob job=new WorkspaceJob(""String_Node_Str"" + project.getName() + ""String_Node_Str""){
      @Override public IStatus runInWorkspace(      IProgressMonitor monitor) throws CoreException {
        monitor.beginTask(""String_Node_Str"",2);
        try {
          performLegacyConversion(project,new SubProgressMonitor(monitor,1));
          GrailsCommandUtils.eclipsifyProject(install,project);
          monitor.worked(1);
          return Status.OK_STATUS;
        }
  finally {
          monitor.done();
        }
      }
    }
;
    job.setRule(ResourcesPlugin.getWorkspace().getRuleFactory().buildRule());
    job.setPriority(Job.INTERACTIVE);
    job.schedule();
  }
}","/** 
 * This method handles the case where a project looks like a Grails project but doesn't have grails nature. 
 */
private void handleNoGrailsNature(final IProject project,GrailsVersion grailsVersion){
  debug(""String_Node_Str"" + project);
  final IGrailsInstall install=GrailsCoreActivator.getDefault().getInstallManager().getGrailsInstall(project);
  Assert.isTrue(install.getVersion().equals(grailsVersion));
  boolean convert=askConvertToGrailsProject(project,grailsVersion);
  if (convert) {
    debug(""String_Node_Str"");
    WorkspaceJob job=new WorkspaceJob(""String_Node_Str"" + project.getName() + ""String_Node_Str""){
      @Override public IStatus runInWorkspace(      IProgressMonitor monitor) throws CoreException {
        monitor.beginTask(""String_Node_Str"",2);
        try {
          performLegacyConversion(project,new SubProgressMonitor(monitor,1));
          GrailsCommandUtils.eclipsifyProject(install,project);
          monitor.worked(1);
          return Status.OK_STATUS;
        }
  finally {
          monitor.done();
        }
      }
    }
;
    job.setRule(ResourcesPlugin.getWorkspace().getRuleFactory().buildRule());
    job.setPriority(Job.INTERACTIVE);
    job.schedule();
  }
}"
50057,"public boolean perform(IProgressMonitor mon) throws CoreException {
  int totalWork=2;
  File copyLoc=getCopyLocation();
  if (copyLoc != null) {
    totalWork++;
  }
  mon.beginTask(""String_Node_Str"",totalWork);
  try {
    if (copyLoc != null) {
      FileUtils.copyDirectory(location.getValue(),copyLoc);
      mon.worked(1);
    }
    IWorkspace ws=ResourcesPlugin.getWorkspace();
    File projectDir=copyLoc != null ? copyLoc : location.getValue();
    String projectName=projectDir.getName();
    IProjectDescription projectDescription=ws.newProjectDescription(projectName);
    if (!isDefaultProjectLocation(projectName,projectDir)) {
      projectDescription.setLocation(new Path(projectDir.getAbsolutePath()));
    }
    IProject project=ResourcesPlugin.getWorkspace().getRoot().getProject(projectName);
    project.create(projectDescription,new SubProgressMonitor(mon,1));
    IGrailsInstall install=grailsInstall.getValue();
    if (install != null) {
      File projectAbsoluteFile=location.getValue();
      if (projectAbsoluteFile != null) {
        IPath projectAbsolutePath=new Path(projectAbsoluteFile.toString());
        GrailsCommandUtils.eclipsifyProject(grailsInstall.getValue(),false,projectAbsolutePath);
        return true;
      }
    }
    mon.worked(1);
    return false;
  }
 catch (  IOException e) {
    throw new CoreException(new Status(IStatus.ERROR,GrailsCoreActivator.PLUGIN_ID,""String_Node_Str"",e));
  }
 finally {
    mon.done();
  }
}","public boolean perform(IProgressMonitor mon) throws CoreException {
  int totalWork=2;
  File copyLoc=getCopyLocation();
  if (copyLoc != null) {
    totalWork++;
  }
  mon.beginTask(""String_Node_Str"",totalWork);
  try {
    if (copyLoc != null) {
      FileUtils.copyDirectory(location.getValue(),copyLoc);
      mon.worked(1);
    }
    IWorkspace ws=ResourcesPlugin.getWorkspace();
    File projectDir=copyLoc != null ? copyLoc : location.getValue();
    String projectName=projectDir.getName();
    IProjectDescription projectDescription=ws.newProjectDescription(projectName);
    if (!isDefaultProjectLocation(projectName,projectDir)) {
      projectDescription.setLocation(new Path(projectDir.getAbsolutePath()));
    }
    IProject project=ResourcesPlugin.getWorkspace().getRoot().getProject(projectName);
    project.create(projectDescription,new SubProgressMonitor(mon,1));
    IGrailsInstall install=grailsInstall.getValue();
    if (install != null) {
      File projectAbsoluteFile=location.getValue();
      if (projectAbsoluteFile != null) {
        IPath projectAbsolutePath=new Path(projectAbsoluteFile.toString());
        GrailsCommandUtils.eclipsifyProject(grailsInstall.getValue(),projectAbsolutePath);
        return true;
      }
    }
    mon.worked(1);
    return false;
  }
 catch (  IOException e) {
    throw new CoreException(new Status(IStatus.ERROR,GrailsCoreActivator.PLUGIN_ID,""String_Node_Str"",e));
  }
 finally {
    mon.done();
  }
}"
50058,"public void testCreateAndEclipsifyLinkedProject() throws Exception {
  String projName=""String_Node_Str"";
  GrailsCommand createApp=GrailsCommandFactory.createApp(projName);
  final File projectLoc=new File(StsTestUtil.createTempDirectory(),projName);
  createApp.setPath(projectLoc.getParent());
  createApp.synchExec();
  GrailsCommandUtils.eclipsifyProject(null,true,new Path(projectLoc.getAbsolutePath()));
  project=ResourcesPlugin.getWorkspace().getRoot().getProject(projName);
  checkProjectBasics();
}","public void testCreateAndEclipsifyLinkedProject() throws Exception {
  String projName=""String_Node_Str"";
  GrailsCommand createApp=GrailsCommandFactory.createApp(projName);
  final File projectLoc=new File(StsTestUtil.createTempDirectory(),projName);
  createApp.setPath(projectLoc.getParent());
  createApp.synchExec();
  GrailsCommandUtils.eclipsifyProject(null,new Path(projectLoc.getAbsolutePath()));
  project=ResourcesPlugin.getWorkspace().getRoot().getProject(projName);
  checkProjectBasics();
}"
50059,"public static boolean isVersionSynched(IProject project){
  GrailsClasspathContainer container=GrailsClasspathUtils.getClasspathContainer(JavaCore.create(project));
  GrailsVersion oldVersion=container.getGrailsVersion();
  GrailsVersion newVersion=GrailsVersion.getGrailsVersion(project);
  return oldVersion.equals(newVersion);
}","public static boolean isVersionSynched(IProject project){
  GrailsClasspathContainer container=GrailsClasspathUtils.getClasspathContainer(JavaCore.create(project));
  if (container != null) {
    GrailsVersion oldVersion=container.getGrailsVersion();
    if (oldVersion != null) {
      GrailsVersion newVersion=GrailsVersion.getGrailsVersion(project);
      return oldVersion.equals(newVersion);
    }
    return false;
  }
  return true;
}"
50060,"/** 
 * Change given project's application.properties file so it is specified to  use this GrailsVersion
 */
public void setOn(IProject project) throws Exception {
  Properties props=GrailsBuildSettingsHelper.getApplicationProperties(project);
  props.put(""String_Node_Str"",this.getVersionString());
  GrailsBuildSettingsHelper.saveApplicationProperties(project,props);
}","/** 
 * Change given project's application.properties file so it is specified to  use this GrailsVersion
 */
public void setOn(IProject project,boolean create) throws Exception {
  Properties props;
  if (create) {
    props=new Properties();
  }
 else {
    props=GrailsBuildSettingsHelper.getApplicationProperties(project);
  }
  props.put(""String_Node_Str"",this.getVersionString());
  GrailsBuildSettingsHelper.saveApplicationProperties(project,props);
}"
50061,"private void setGrailsVersion(IProject project,GrailsVersion version) throws Exception {
  version.setOn(project);
}","private void setGrailsVersion(IProject project,GrailsVersion version) throws Exception {
  version.setOn(project,false);
}"
50062,"/** 
 * Ensures that the project passed in has a classpath compatible with a grails project. Sets up project natures and compliance levels Sets up the grails dsld file
 * @param project
 * @throws Exception
 */
public static void mockGrailsProject(IProject project,GrailsVersion grailsVersion) throws Exception {
  IClasspathEntry[] classpath=JavaCore.create(project).getRawClasspath();
  boolean wasAutobuilding=isAutoBuilding();
  try {
    setAutoBuilding(false);
    @SuppressWarnings(""String_Node_Str"") Hashtable options=JavaCore.getDefaultOptions();
    options.put(JavaCore.COMPILER_COMPLIANCE,""String_Node_Str"");
    options.put(JavaCore.COMPILER_SOURCE,""String_Node_Str"");
    JavaCore.setOptions(options);
    addGrailsNature(project);
    grailsVersion.setOn(project);
    Set<String> dependencies=findDependencies();
    for (    String file : dependencies) {
      if (new File(file).isFile()) {
        if (!(file.contains(""String_Node_Str"") || file.contains(""String_Node_Str""))) {
          addExternalLibrary(project,file);
        }
      }
 else {
        System.out.println(""String_Node_Str"" + file);
      }
    }
    GroovyRuntime.addGroovyClasspathContainer(JavaCore.create(project));
    File grailsDSLD=GrailsTestsActivator.getGrailsDSLD();
    addExternalLibrary(project,grailsDSLD.getCanonicalPath());
    new RefreshDSLDJob(project).run(null);
  }
  finally {
    setAutoBuilding(wasAutobuilding);
  }
}","/** 
 * Ensures that the project passed in has a classpath compatible with a grails project. Sets up project natures and compliance levels Sets up the grails dsld file
 * @param project
 * @throws Exception
 */
public static void mockGrailsProject(IProject project,GrailsVersion grailsVersion) throws Exception {
  IClasspathEntry[] classpath=JavaCore.create(project).getRawClasspath();
  boolean wasAutobuilding=isAutoBuilding();
  try {
    setAutoBuilding(false);
    @SuppressWarnings(""String_Node_Str"") Hashtable options=JavaCore.getDefaultOptions();
    options.put(JavaCore.COMPILER_COMPLIANCE,""String_Node_Str"");
    options.put(JavaCore.COMPILER_SOURCE,""String_Node_Str"");
    JavaCore.setOptions(options);
    addGrailsNature(project);
    grailsVersion.setOn(project,true);
    Set<String> dependencies=findDependencies();
    for (    String file : dependencies) {
      if (new File(file).isFile()) {
        if (!(file.contains(""String_Node_Str"") || file.contains(""String_Node_Str""))) {
          addExternalLibrary(project,file);
        }
      }
 else {
        System.out.println(""String_Node_Str"" + file);
      }
    }
    GroovyRuntime.addGroovyClasspathContainer(JavaCore.create(project));
    File grailsDSLD=GrailsTestsActivator.getGrailsDSLD();
    addExternalLibrary(project,grailsDSLD.getCanonicalPath());
    new RefreshDSLDJob(project).run(null);
  }
  finally {
    setAutoBuilding(wasAutobuilding);
  }
}"
50063,"/** 
 * The cache is flushed when the classpath changes or there is a refresh dependencies Cache is selectively flushed when a service class changes
 */
public void projectChanged(GrailsElementKind[] changeKinds,IResourceDelta change){
synchronized (GrailsCore.get().getLockForProject(project)) {
    boolean foundRelevantChange=false;
    for (    GrailsElementKind changeKind : changeKinds) {
      if (changeKind == GrailsElementKind.PROJECT || changeKind == GrailsElementKind.CLASSPATH) {
        foundRelevantChange=true;
        break;
      }
    }
    if (foundRelevantChange) {
      classNodeCache.clear();
      setProject(project);
    }
  }
}","/** 
 * The cache is flushed when the classpath changes or there is a refresh dependencies Cache is selectively flushed when a service class changes
 */
public void projectChanged(GrailsElementKind[] changeKinds,IResourceDelta change){
synchronized (GrailsCore.get().getLockForProject(project)) {
    boolean foundRelevantChange=changeKinds.length > 0;
    if (foundRelevantChange) {
      classNodeCache.clear();
      setProject(project);
    }
  }
}"
50064,"private static String windowsEscape(String argument){
  if (System.getProperty(""String_Node_Str"").toLowerCase().indexOf(""String_Node_Str"") >= 0) {
    return winQuote(argument);
  }
  return argument;
}","private static String windowsEscape(String argument){
  return argument;
}"
50065,"public void testGrails20SourceAttachements() throws Exception {
  if (GrailsVersion.MOST_RECENT.compareTo(GrailsVersion.V_2_2_3) > 0) {
    try {
      doTestType(GrailsVersion.MOST_RECENT,""String_Node_Str"",""String_Node_Str"");
      fail(""String_Node_Str"");
    }
 catch (    AssertionFailedError e) {
      assertTrue(e.getMessage().contains(""String_Node_Str""));
    }
    DownloadSourcesActionDelegate.doit(project,new NullProgressMonitor());
    doTestType(GrailsVersion.MOST_RECENT,""String_Node_Str"",""String_Node_Str"");
  }
}","public void testGrails20SourceAttachements() throws Exception {
  if (GrailsVersion.MOST_RECENT.compareTo(GrailsVersion.V_2_2_4) > 0) {
    try {
      doTestType(GrailsVersion.MOST_RECENT,""String_Node_Str"",""String_Node_Str"");
      fail(""String_Node_Str"");
    }
 catch (    AssertionFailedError e) {
      assertTrue(e.getMessage().contains(""String_Node_Str""));
    }
    DownloadSourcesActionDelegate.doit(project,new NullProgressMonitor());
    doTestType(GrailsVersion.MOST_RECENT,""String_Node_Str"",""String_Node_Str"");
  }
}"
50066,"@Override public PerWorkingCopyInfo getPerWorkingCopyInfo(){
  if (elementInfo == null) {
    try {
      elementInfo=(CompilationUnitElementInfo)createElementInfo();
      openWhenClosed(elementInfo,new NullProgressMonitor());
    }
 catch (    JavaModelException e) {
      elementInfo=null;
      GrailsCoreActivator.log(e.getJavaModelStatus());
    }
  }
  return info;
}","@Override public PerWorkingCopyInfo getPerWorkingCopyInfo(){
  if (elementInfo == null) {
    try {
      elementInfo=(CompilationUnitElementInfo)createElementInfo();
      openWhenClosed(elementInfo,true,new NullProgressMonitor());
    }
 catch (    JavaModelException e) {
      elementInfo=null;
      GrailsCoreActivator.log(e.getJavaModelStatus());
    }
  }
  return info;
}"
50067,"private static String windowsEscape(String argument){
  if (System.getProperty(""String_Node_Str"").toLowerCase().indexOf(""String_Node_Str"") >= 0) {
    Bundle jdtLaunching=Platform.getBundle(""String_Node_Str"");
    if (jdtLaunching != null) {
      Version version=jdtLaunching.getVersion();
      VersionRange newEnough=new VersionRange(""String_Node_Str"");
      if (!newEnough.includes(version)) {
        return winQuote(argument);
      }
    }
  }
  return argument;
}","private static String windowsEscape(String argument){
  Bundle jdtLaunching=Platform.getBundle(""String_Node_Str"");
  if (jdtLaunching != null) {
    Version version=jdtLaunching.getVersion();
    Version newEnough=new Version(""String_Node_Str"");
    if (newEnough.compareTo(version) <= 0) {
    }
 else {
      return winQuote(argument);
    }
  }
  return argument;
}"
50068,"private static String windowsEscape(String argument){
  return argument;
}","private static String windowsEscape(String argument){
  if (System.getProperty(""String_Node_Str"").toLowerCase().indexOf(""String_Node_Str"") >= 0) {
    Bundle jdtLaunching=Platform.getBundle(""String_Node_Str"");
    if (jdtLaunching != null) {
      Version version=jdtLaunching.getVersion();
      VersionRange newEnough=new VersionRange(""String_Node_Str"");
      if (!newEnough.includes(version)) {
        return winQuote(argument);
      }
    }
  }
  return argument;
}"
50069,"public void testPerformRenameMethodRefactoring() throws Exception {
  if (GrailsVersion.getDefault().compareTo(GrailsVersion.V_2_0_0) >= 0) {
    importZippedProject(""String_Node_Str"");
    checkImportedProject();
    createResource(project,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    String oldActionName=""String_Node_Str"";
    String newActionName=""String_Node_Str"";
    IType controller=getType(""String_Node_Str"");
    IMethod target=getMethod(controller,""String_Node_Str"");
    assertTrue(""String_Node_Str"",target.exists());
    RenameMethodProcessor processor=new RenameVirtualMethodProcessor(target);
    processor.setNewElementName(newActionName);
    RenameRefactoring refactoring=new RenameRefactoring(processor);
    RefactoringStatus status=performRefactoring(refactoring,true,false);
    assertOK(status);
    assertFileDeleted(""String_Node_Str"" + oldActionName + ""String_Node_Str"");
    assertFile(""String_Node_Str"" + newActionName + ""String_Node_Str"");
    assertFile(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    String songControllerPath=""String_Node_Str"";
    String songController=getContents(ResourcesPlugin.getWorkspace().getRoot().getFile(new Path(songControllerPath)));
    songController=songController.replace('""' + oldActionName + '""','""' + newActionName + '""');
    songController=songController.replace(""String_Node_Str"" + oldActionName,""String_Node_Str"" + newActionName);
    assertFile(songControllerPath,songController);
  }
}","public void testPerformRenameMethodRefactoring() throws Exception {
  if (GrailsVersion.getDefault().compareTo(GrailsVersion.V_2_0_0) >= 0) {
    importZippedProject(""String_Node_Str"");
    checkImportedProject();
    createResource(project,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    StsTestUtil.assertNoErrors(project);
    String oldActionName=""String_Node_Str"";
    String newActionName=""String_Node_Str"";
    IType controller=getType(""String_Node_Str"");
    IMethod target=getMethod(controller,""String_Node_Str"");
    assertTrue(""String_Node_Str"",target.exists());
    RenameMethodProcessor processor=new RenameVirtualMethodProcessor(target);
    processor.setNewElementName(newActionName);
    RenameRefactoring refactoring=new RenameRefactoring(processor);
    RefactoringStatus status=performRefactoring(refactoring,true,false);
    assertOK(status);
    assertFileDeleted(""String_Node_Str"" + oldActionName + ""String_Node_Str"");
    assertFile(""String_Node_Str"" + newActionName + ""String_Node_Str"");
    assertFile(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
    String songControllerPath=""String_Node_Str"";
    String songController=getContents(ResourcesPlugin.getWorkspace().getRoot().getFile(new Path(songControllerPath)));
    songController=songController.replace('""' + oldActionName + '""','""' + newActionName + '""');
    songController=songController.replace(""String_Node_Str"" + oldActionName,""String_Node_Str"" + newActionName);
    assertFile(songControllerPath,songController);
  }
}"
50070,"/** 
 * It is possible to have controller without associated views. This shouldn't break the refactoring.
 */
public void testPerformRenameActionWithoutViewRefactoring() throws Exception {
  importZippedProject(""String_Node_Str"");
  checkImportedProject();
  createResource(project,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  String oldActionName=""String_Node_Str"";
  String newActionName=""String_Node_Str"";
  IType controller=getType(""String_Node_Str"");
  IMethod target=controller.getMethod(oldActionName,new String[]{});
  RenameMethodProcessor processor=new RenameVirtualMethodProcessor(target);
  processor.setNewElementName(newActionName);
  RenameRefactoring refactoring=new RenameRefactoring(processor);
  RefactoringStatus status=performRefactoring(refactoring,true,false);
  assertOK(status);
  assertFile(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  String songControllerPath=""String_Node_Str"";
  String songController=getContents(ResourcesPlugin.getWorkspace().getRoot().getFile(new Path(songControllerPath)));
  assertFile(songControllerPath,songController);
}","/** 
 * It is possible to have controller without associated views. This shouldn't break the refactoring.
 */
public void testPerformRenameActionWithoutViewRefactoring() throws Exception {
  importZippedProject(""String_Node_Str"");
  checkImportedProject();
  createResource(project,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  StsTestUtil.assertNoErrors(project);
  String oldActionName=""String_Node_Str"";
  String newActionName=""String_Node_Str"";
  IType controller=getType(""String_Node_Str"");
  IMethod target=controller.getMethod(oldActionName,new String[]{});
  RenameMethodProcessor processor=new RenameVirtualMethodProcessor(target);
  processor.setNewElementName(newActionName);
  RenameRefactoring refactoring=new RenameRefactoring(processor);
  RefactoringStatus status=performRefactoring(refactoring,true,false);
  assertOK(status);
  assertFile(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  String songControllerPath=""String_Node_Str"";
  String songController=getContents(ResourcesPlugin.getWorkspace().getRoot().getFile(new Path(songControllerPath)));
  assertFile(songControllerPath,songController);
}"
50071,"/** 
 * This test uses actions represented as fields (1.3.x style). To see if these actions also get visited and renamed properly.
 */
public void testPerformFieldActionRefactoring() throws Exception {
  importZippedProject(""String_Node_Str"");
  checkImportedProject();
  createResource(project,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  String oldActionName=""String_Node_Str"";
  String newActionName=""String_Node_Str"";
  createResource(project,""String_Node_Str"" + oldActionName + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  IType controller=getType(""String_Node_Str"");
  IField target=controller.getField(oldActionName);
  RenameFieldProcessor processor=new RenameFieldProcessor(target);
  processor.setNewElementName(newActionName);
  RenameRefactoring refactoring=new RenameRefactoring(processor);
  RefactoringStatus status=performRefactoring(refactoring,true,false);
  assertOK(status);
  assertFileDeleted(""String_Node_Str"" + oldActionName + ""String_Node_Str"");
  assertFile(""String_Node_Str"" + newActionName + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  assertFile(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  String songControllerPath=""String_Node_Str"";
  String songController=getContents(ResourcesPlugin.getWorkspace().getRoot().getFile(new Path(songControllerPath)));
  assertFile(songControllerPath,songController);
}","/** 
 * This test uses actions represented as fields (1.3.x style). To see if these actions also get visited and renamed properly.
 */
public void testPerformFieldActionRefactoring() throws Exception {
  importZippedProject(""String_Node_Str"");
  checkImportedProject();
  createResource(project,""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  String oldActionName=""String_Node_Str"";
  String newActionName=""String_Node_Str"";
  createResource(project,""String_Node_Str"" + oldActionName + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  StsTestUtil.assertNoErrors(project);
  IType controller=getType(""String_Node_Str"");
  IField target=controller.getField(oldActionName);
  RenameFieldProcessor processor=new RenameFieldProcessor(target);
  processor.setNewElementName(newActionName);
  RenameRefactoring refactoring=new RenameRefactoring(processor);
  RefactoringStatus status=performRefactoring(refactoring,true,false);
  assertOK(status);
  assertFileDeleted(""String_Node_Str"" + oldActionName + ""String_Node_Str"");
  assertFile(""String_Node_Str"" + newActionName + ""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  assertFile(""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  String songControllerPath=""String_Node_Str"";
  String songController=getContents(ResourcesPlugin.getWorkspace().getRoot().getFile(new Path(songControllerPath)));
  assertFile(songControllerPath,songController);
}"
50072,"public GrailsCommandExecution(GrailsClient process,GrailsCommand cmd){
  this.process=process;
  this.cmd=cmd;
  this.bytesOut=new LimitedByteArrayOutputStream(GrailsCoreActivator.getDefault().getGrailsCommandOutputLimit());
  this.bytesErr=new LimitedByteArrayOutputStream(GrailsCoreActivator.getDefault().getGrailsCommandOutputLimit());
  this.console=buildConsole(cmd,bytesOut,bytesErr);
  this.console.setExection(this);
}","public GrailsCommandExecution(GrailsClient process,GrailsCommand cmd){
  this.process=process;
  this.cmd=cmd;
  this.bytesOut=new LimitedByteArrayOutputStream(GrailsCoreActivator.getDefault().getGrailsCommandOutputLimit());
  this.bytesErr=new LimitedByteArrayOutputStream(GrailsCoreActivator.getDefault().getGrailsCommandOutputLimit());
  this.console=buildConsole(cmd,bytesOut,bytesErr);
}"
50073,"/** 
 * Get the springloaded jar, search for it the first time. Cached after that 
 */
public File get(){
  if (getVersion().compareTo(GrailsVersion.V_2_0_0) >= 0) {
    if (foundJar == null) {
      find(new File(getHome(),searchIn));
    }
  }
  return foundJar;
}","/** 
 * Get the springloaded jar, search for it the first time. Cached after that 
 */
public File get(){
  if (getVersion().compareTo(GrailsVersion.V_2_0_0) >= 0) {
    if (foundJar == null) {
      for (      String searchLoc : searchIn) {
        if (foundJar != null) {
          break;
        }
        find(new File(getHome(),searchLoc));
      }
    }
  }
  return foundJar;
}"
50074,"public static void configureGrailsVersions(boolean useGrails200){
  if (useGrails200) {
    GrailsVersion.PREVIOUS_PREVIOUS=GrailsVersion.V_1_3_7;
    GrailsVersion.PREVIOUS=GrailsVersion.V_2_0_4;
    GrailsVersion.MOST_RECENT=GrailsVersion.V_2_1_1_SNAP;
  }
 else {
    GrailsVersion.PREVIOUS_PREVIOUS=GrailsVersion.V_1_3_6;
    GrailsVersion.PREVIOUS=GrailsVersion.V_1_3_7;
    GrailsVersion.MOST_RECENT=GrailsVersion.V_1_3_8;
  }
  System.out.println(""String_Node_Str"" + GrailsVersion.MOST_RECENT);
}","public static void configureGrailsVersions(boolean useGrails200){
  if (useGrails200) {
    GrailsVersion.PREVIOUS_PREVIOUS=GrailsVersion.V_1_3_7;
    GrailsVersion.PREVIOUS=GrailsVersion.V_2_0_4;
    GrailsVersion.MOST_RECENT=GrailsVersion.V_2_1_0;
  }
 else {
    GrailsVersion.PREVIOUS_PREVIOUS=GrailsVersion.V_1_3_6;
    GrailsVersion.PREVIOUS=GrailsVersion.V_1_3_7;
    GrailsVersion.MOST_RECENT=GrailsVersion.V_1_3_8;
  }
  System.out.println(""String_Node_Str"" + GrailsVersion.MOST_RECENT);
}"
50075,"private boolean isMavenProject(IJavaProject javaProject) throws CoreException {
  return javaProject.getProject().hasNature(M2E_NATURE);
}","private boolean isMavenProject(IJavaProject javaProject) throws CoreException {
  try {
    return javaProject.getProject().hasNature(M2E_NATURE);
  }
 catch (  CoreException e) {
    GrailsCoreActivator.log(e);
    return false;
  }
}"
50076,"public void run(IProgressMonitor monitor) throws CoreException {
  if (!isMavenProject(javaProject)) {
    return;
  }
  javaProject.getProject().refreshLocal(IResource.DEPTH_INFINITE,monitor);
  GrailsClasspathContainer container=GrailsClasspathUtils.getClasspathContainer(javaProject);
  if (container != null) {
    container.invalidate();
  }
  GrailsCore.get().connect(javaProject.getProject(),PerProjectDependencyDataCache.class).refreshData();
  GrailsCore.get().connect(javaProject.getProject(),PerProjectPluginCache.class).refreshDependencyCache();
  SourceFolderJob updateSourceFolders=new SourceFolderJob(javaProject);
  updateSourceFolders.refreshSourceFolders(new NullProgressMonitor());
  javaProject.setRawClasspath(javaProject.getRawClasspath(),monitor);
}","public void run(IProgressMonitor monitor) throws CoreException {
  if (isMavenProject(javaProject)) {
    return;
  }
  javaProject.getProject().refreshLocal(IResource.DEPTH_INFINITE,monitor);
  GrailsClasspathContainer container=GrailsClasspathUtils.getClasspathContainer(javaProject);
  if (container != null) {
    container.invalidate();
  }
  GrailsCore.get().connect(javaProject.getProject(),PerProjectDependencyDataCache.class).refreshData();
  GrailsCore.get().connect(javaProject.getProject(),PerProjectPluginCache.class).refreshDependencyCache();
  SourceFolderJob updateSourceFolders=new SourceFolderJob(javaProject);
  updateSourceFolders.refreshSourceFolders(new NullProgressMonitor());
  javaProject.setRawClasspath(javaProject.getRawClasspath(),monitor);
}"
50077,"public static String[] getURLDependencies() throws Exception {
  List<String> allJars=new ArrayList<String>();
  allJars.add(getLocationForBundle(""String_Node_Str""));
  allJars.add(getLocationForBundle(""String_Node_Str""));
  allJars.add(FileLocator.getBundleFile(elBundle).getAbsolutePath());
  GrailsTest.waitForGrailsIntall();
  GrailsTest.ensureDefaultGrailsVersion(GrailsVersion.MOST_RECENT);
  IGrailsInstall install=GrailsCoreActivator.getDefault().getInstallManager().getInstallFor(GrailsVersion.MOST_RECENT);
  if (install == null) {
    throw new AssertionFailedError(""String_Node_Str"" + GrailsVersion.MOST_RECENT);
  }
  allJars.addAll(findJars(install.getHome() + ""String_Node_Str"",true));
  allJars.addAll(findJars(install.getHome() + ""String_Node_Str"",true));
  return allJars.toArray(new String[0]);
}","public static String[] getURLDependencies() throws Exception {
  List<String> allJars=new ArrayList<String>();
  allJars.add(getLocationForBundle(""String_Node_Str""));
  allJars.add(getLocationForBundle(""String_Node_Str""));
  GrailsTest.waitForGrailsIntall();
  GrailsTest.ensureDefaultGrailsVersion(GrailsVersion.MOST_RECENT);
  IGrailsInstall install=GrailsCoreActivator.getDefault().getInstallManager().getInstallFor(GrailsVersion.MOST_RECENT);
  if (install == null) {
    throw new AssertionFailedError(""String_Node_Str"" + GrailsVersion.MOST_RECENT);
  }
  allJars.addAll(findJars(install.getHome() + ""String_Node_Str"",true));
  allJars.addAll(findJars(install.getHome() + ""String_Node_Str"",true));
  return allJars.toArray(new String[0]);
}"
50078,"@Override public AccountHolder getAccountHolder(String uuidOrName){
  OfflinePlayer player;
  try {
    UUID playerId=UUID.fromString(uuidOrName);
    player=Bukkit.getOfflinePlayer(playerId);
  }
 catch (  IllegalArgumentException ignored) {
    for (    OfflinePlayer p : Bukkit.getOfflinePlayers()) {
      if (p.getName().equals(uuidOrName))       return new PlayerAccountHolder(p);
    }
    return null;
  }
  if (player.isOnline() || player.hasPlayedBefore())   return new PlayerAccountHolder(player);
 else   return null;
}","@Override public AccountHolder getAccountHolder(String uuidOrName){
  if (uuidOrName == null)   return null;
  OfflinePlayer player;
  try {
    UUID playerId=UUID.fromString(uuidOrName);
    player=Bukkit.getOfflinePlayer(playerId);
  }
 catch (  IllegalArgumentException ignored) {
    for (    OfflinePlayer p : Bukkit.getOfflinePlayers()) {
      if (uuidOrName.equals(p.getName()))       return new PlayerAccountHolder(p);
    }
    return null;
  }
  if (player.isOnline() || player.hasPlayedBefore())   return new PlayerAccountHolder(player);
 else   return null;
}"
50079,"@Override public AccountHolder getAccountHolder(String uuidOrName){
  OfflinePlayer player;
  try {
    UUID playerId=UUID.fromString(uuidOrName);
    player=Bukkit.getOfflinePlayer(playerId);
  }
 catch (  IllegalArgumentException ignored) {
    player=Bukkit.getOfflinePlayer(uuidOrName);
  }
  if (player.isOnline() || player.hasPlayedBefore())   return new PlayerAccountHolder(player);
 else   return null;
}","@Override public AccountHolder getAccountHolder(String uuidOrName){
  OfflinePlayer player;
  try {
    UUID playerId=UUID.fromString(uuidOrName);
    player=Bukkit.getOfflinePlayer(playerId);
  }
 catch (  IllegalArgumentException ignored) {
    for (    OfflinePlayer p : Bukkit.getOfflinePlayers()) {
      if (p.getName().equals(uuidOrName))       return new PlayerAccountHolder(p);
    }
    return null;
  }
  if (player.isOnline() || player.hasPlayedBefore())   return new PlayerAccountHolder(player);
 else   return null;
}"
50080,"@Override public Set<AccountChest> getChests(GringottsAccount account){
  SqlQuery getChests=db.createSqlQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  getChests.setParameter(""String_Node_Str"",account.owner.getId());
  getChests.setParameter(""String_Node_Str"",account.owner.getType());
  Set<AccountChest> chests=new HashSet<>();
  for (  SqlRow result : getChests.findSet()) {
    String worldName=result.getString(""String_Node_Str"");
    int x=result.getInteger(""String_Node_Str"");
    int y=result.getInteger(""String_Node_Str"");
    int z=result.getInteger(""String_Node_Str"");
    World world=Bukkit.getWorld(worldName);
    Location loc=new Location(world,x,y,z);
    Block signBlock=loc.getBlock();
    if (Util.isSignBlock(signBlock)) {
      Sign sign=(Sign)loc.getBlock().getState();
      chests.add(new AccountChest(sign,account));
    }
 else {
      deleteAccountChest(worldName,x,y,z);
    }
  }
  return chests;
}","@Override public Set<AccountChest> getChests(GringottsAccount account){
  SqlQuery getChests=db.createSqlQuery(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  getChests.setParameter(""String_Node_Str"",account.owner.getId());
  getChests.setParameter(""String_Node_Str"",account.owner.getType());
  Set<AccountChest> chests=new HashSet<>();
  for (  SqlRow result : getChests.findSet()) {
    String worldName=result.getString(""String_Node_Str"");
    int x=result.getInteger(""String_Node_Str"");
    int y=result.getInteger(""String_Node_Str"");
    int z=result.getInteger(""String_Node_Str"");
    World world=Bukkit.getWorld(worldName);
    if (world == null)     continue;
    Location loc=new Location(world,x,y,z);
    Block signBlock=loc.getBlock();
    if (Util.isSignBlock(signBlock)) {
      Sign sign=(Sign)loc.getBlock().getState();
      chests.add(new AccountChest(sign,account));
    }
 else {
      deleteAccountChest(worldName,x,y,z);
    }
  }
  return chests;
}"
50081,"/** 
 * Get a FactionAccountHolder based on the name of the account. Valid ids for this method are either raw faction ids, or faction ids or tags prefixed with ""faction-""  Only names beginning with ""faction-"" will be considered, and the rest of the string  can be either a faction id or a faction tag.
 * @param name Name of the account.
 * @return a FactionAccountHolder based on the name of the account, if a valid faction could be found. null otherwise.
 */
@Override public FactionAccountHolder getAccountHolder(String id){
  String factionId=id;
  if (id.startsWith(""String_Node_Str""))   factionId=id.substring(8);
  FactionAccountHolder owner=getAccountHolderById(factionId);
  if (owner != null)   return owner;
  String factionTag=factionId.substring(8);
  Faction faction=Factions.i.getByTag(factionTag);
  if (faction != null)   return new FactionAccountHolder(faction);
  return null;
}","/** 
 * Get a FactionAccountHolder based on the name of the account. Valid ids for this method are either raw faction ids, or faction ids or tags prefixed with ""faction-""  Only names beginning with ""faction-"" will be considered, and the rest of the string  can be either a faction id or a faction tag.
 * @param name Name of the account.
 * @return a FactionAccountHolder based on the name of the account, if a valid faction could be found. null otherwise.
 */
@Override public FactionAccountHolder getAccountHolder(String id){
  String factionId=id;
  if (id.startsWith(""String_Node_Str""))   factionId=id.substring(8);
  FactionAccountHolder owner=getAccountHolderById(factionId);
  if (owner != null)   return owner;
  Faction faction=Factions.i.getByTag(id);
  if (faction != null)   return new FactionAccountHolder(faction);
  return null;
}"
50082,"/** 
 * Check whether a block is a sign or wall sign type.
 * @param block
 * @return true if the block is a sign or wall sign
 */
public static boolean isSignBlock(Block block){
  Material type=block.getType();
  return Material.SIGN == type || Material.WALL_SIGN == type;
}","/** 
 * Check whether a block is a sign or wall sign type.
 * @param block
 * @return true if the block is a sign or wall sign
 */
public static boolean isSignBlock(Block block){
  return block.getState() instanceof Sign;
}"
50083,"/** 
 * Catches and handles breaking of the sign block of an account chest.
 * @param event
 */
@EventHandler public void vaultBroken(BlockBreakEvent event){
  Block block=event.getBlock();
  if (!Util.isSignBlock(block))   return;
  Sign sign=(Sign)block.getState();
  if (!(""String_Node_Str"".equalsIgnoreCase(sign.getLine(0)) || ""String_Node_Str"".equalsIgnoreCase(sign.getLine(0))))   return;
  Location loc=block.getLocation();
  for (  AccountChest chest : dao.getChests()) {
    if (loc.equals(chest.sign.getBlock().getLocation())) {
      chest.destroy();
      Account account=chest.getAccount();
      account.owner.sendMessage(""String_Node_Str"" + account.balance());
    }
  }
}","/** 
 * Catches and handles breaking of the sign block of an account chest.
 * @param event
 */
@EventHandler public void vaultBroken(BlockBreakEvent event){
  Block block=event.getBlock();
  if (!Util.isSignBlock(block))   return;
  Sign sign=(Sign)block.getState();
  if (!(""String_Node_Str"".equalsIgnoreCase(sign.getLine(0)) || ""String_Node_Str"".equalsIgnoreCase(sign.getLine(0))))   return;
  Location loc=block.getLocation();
  for (  AccountChest chest : dao.getChests()) {
    if (loc.equals(chest.sign.getBlock().getLocation())) {
      dao.destroyAccountChest(chest);
      Account account=chest.getAccount();
      account.owner.sendMessage(""String_Node_Str"" + account.balance());
    }
  }
}"
50084,"/** 
 * Attempts to add given amount to this chest.  If the amount is larger than available space, the space is filled and the actually added amount returned.
 * @return amount actually added
 */
public long add(long value){
  int stacksize=config.currency.getMaxStackSize();
  Inventory inv=chest.getInventory();
  long remaining=value;
  while (remaining > 0) {
    ItemStack stack=new ItemStack(config.currency);
    stack.setAmount(remaining > stacksize ? stacksize : (int)remaining);
    int returned=0;
    for (    ItemStack leftover : inv.addItem(stack).values())     returned+=leftover.getAmount();
    remaining-=stacksize - returned;
    if (returned > 0)     break;
  }
  return value - remaining;
}","/** 
 * Attempts to add given amount to this chest.  If the amount is larger than available space, the space is filled and the actually added amount returned.
 * @return amount actually added
 */
public long add(long value){
  int stacksize=config.currency.getMaxStackSize();
  Inventory inv=chest.getInventory();
  long remaining=value;
  while (remaining > 0) {
    ItemStack stack=new ItemStack(config.currency);
    int remainderStackSize=remaining > stacksize ? stacksize : (int)remaining;
    stack.setAmount(remainderStackSize);
    int returned=0;
    for (    ItemStack leftover : inv.addItem(stack).values())     returned+=leftover.getAmount();
    remaining-=remainderStackSize - returned;
    if (returned > 0)     break;
  }
  return value - remaining;
}"
50085,"/** 
 * Attempts to remove given amount from this chest. If the amount is larger than available items, everything is removed and the number of removed items returned.
 * @param value
 * @return amount actually removed from this chest
 */
public long remove(long value){
  int stacksize=config.currency.getMaxStackSize();
  Inventory inv=chest.getInventory();
  long remaining=value;
  while (remaining > 0) {
    ItemStack stack=new ItemStack(config.currency);
    stack.setAmount(remaining > stacksize ? stacksize : (int)remaining);
    int returned=0;
    for (    ItemStack leftover : inv.removeItem(stack).values())     returned+=leftover.getAmount();
    remaining-=stacksize - returned;
    if (returned > 0)     break;
  }
  return value - remaining;
}","/** 
 * Attempts to remove given amount from this chest. If the amount is larger than available items, everything is removed and the number of removed items returned.
 * @param value
 * @return amount actually removed from this chest
 */
public long remove(long value){
  int stacksize=config.currency.getMaxStackSize();
  Inventory inv=chest.getInventory();
  long remaining=value;
  while (remaining > 0) {
    ItemStack stack=new ItemStack(config.currency);
    int remainderStackSize=remaining > stacksize ? stacksize : (int)remaining;
    stack.setAmount(remainderStackSize);
    int returned=0;
    for (    ItemStack leftover : inv.removeItem(stack).values())     returned+=leftover.getAmount();
    remaining-=remainderStackSize - returned;
    if (returned > 0)     break;
  }
  return value - remaining;
}"
50086,"private void evalExprNew(ICPPASTNewExpression expr,List<MExpression> ret) throws DOMException {
  if (expr.isArrayAllocation() && !TypeManager.isOneOf(expr.getExpressionType(),TypeEnum.OBJECT_POINTER)) {
    MNewArrayExpression ptr=new MNewArrayExpression();
    for (    IASTExpression arraySize : expr.getNewTypeIdArrayExpressions())     ptr.sizes.add(eval1Expr(arraySize));
    ptr.type=ctx.typeMngr.cppToJavaType(expr.getExpressionType(),TypeType.IMPLEMENTATION);
    ret.add(ptr);
  }
 else   if (expr.isArrayAllocation() && TypeManager.isOneOf(expr.getExpressionType(),TypeEnum.OBJECT_POINTER)) {
    MNewArrayExpressionObject ptr=new MNewArrayExpressionObject();
    for (    IASTExpression arraySize : expr.getNewTypeIdArrayExpressions())     ptr.sizes.add(eval1Expr(arraySize));
    ptr.type=ctx.typeMngr.cppToJavaType(expr.getExpressionType(),TypeType.IMPLEMENTATION);
    ret.add(ptr);
  }
 else   if (TypeManager.isOneOf(expr.getExpressionType(),TypeEnum.OBJECT_POINTER)) {
    MNewExpressionObject ptr=new MNewExpressionObject();
    ptr.type=ctx.typeMngr.cppToJavaType(expr.getExpressionType(),TypeType.RAW);
    MValueOfExpressionPtr ptrExpr=new MValueOfExpressionPtr();
    ptrExpr.type=""String_Node_Str"";
    ptrExpr.operand=ptr;
    ret.add(ptrExpr);
  }
 else   if (TypeManager.isOneOf(expr.getExpressionType(),TypeEnum.BASIC_POINTER) && TypeManager.getPointerIndirectionCount(expr.getExpressionType()) == 1) {
    ret.add(ctx.initMngr.eval1Init(expr.getInitializer(),TypeManager.getPointerBaseType(expr.getExpressionType()),null));
  }
 else   if (TypeManager.isOneOf(expr.getExpressionType(),TypeEnum.BASIC_POINTER)) {
  }
}","private void evalExprNew(ICPPASTNewExpression expr,List<MExpression> ret) throws DOMException {
  if (expr.isArrayAllocation() && !TypeManager.isOneOf(expr.getExpressionType(),TypeEnum.OBJECT_POINTER)) {
    MNewArrayExpression ptr=new MNewArrayExpression();
    for (    IASTExpression arraySize : expr.getNewTypeIdArrayExpressions())     ptr.sizes.add(eval1Expr(arraySize));
    ptr.type=ctx.typeMngr.cppToJavaType(expr.getExpressionType(),TypeType.IMPLEMENTATION);
    ret.add(ptr);
  }
 else   if (expr.isArrayAllocation() && TypeManager.isOneOf(expr.getExpressionType(),TypeEnum.OBJECT_POINTER)) {
    MNewArrayExpressionObject ptr=new MNewArrayExpressionObject();
    for (    IASTExpression arraySize : expr.getNewTypeIdArrayExpressions())     ptr.sizes.add(eval1Expr(arraySize));
    ptr.type=ctx.typeMngr.cppToJavaType(expr.getExpressionType(),TypeType.IMPLEMENTATION);
    ret.add(ptr);
  }
 else   if (TypeManager.isOneOf(expr.getExpressionType(),TypeEnum.OBJECT_POINTER)) {
    MNewExpressionObject ptr=new MNewExpressionObject();
    ptr.type=ctx.typeMngr.cppToJavaType(expr.getExpressionType(),TypeType.RAW);
    MValueOfExpressionPtr ptrExpr=new MValueOfExpressionPtr();
    ptrExpr.type=""String_Node_Str"";
    ptrExpr.operand=ptr;
    ret.add(ptrExpr);
  }
 else   if (TypeManager.isOneOf(expr.getExpressionType(),TypeEnum.BASIC_POINTER) && TypeManager.getPointerIndirectionCount(expr.getExpressionType()) == 1) {
    ret.add(ctx.initMngr.eval1Init(expr.getInitializer(),TypeManager.getPointerBaseType(expr.getExpressionType()),null,InitType.WRAPPED));
  }
 else   if (TypeManager.isOneOf(expr.getExpressionType(),TypeEnum.BASIC_POINTER)) {
  }
}"
50087,"/** 
 * Gets the default expressions for function arguments (null where default is not provided).
 */
private List<MExpression> getDefaultValues(IASTFunctionDeclarator func) throws DOMException {
  IASTStandardFunctionDeclarator declarator=(IASTStandardFunctionDeclarator)func;
  IASTParameterDeclaration[] params=declarator.getParameters();
  List<MExpression> exprs=new ArrayList<MExpression>();
  for (  IASTParameterDeclaration param : params) {
    IASTDeclarator paramDeclarator=param.getDeclarator();
    IBinding binding=paramDeclarator.getName().resolveBinding();
    IType tp=ctx.converter.evalBindingReturnType(binding);
    if (paramDeclarator.getInitializer() != null) {
      exprs.add(ctx.initMngr.eval1Init(paramDeclarator.getInitializer(),tp,paramDeclarator.getName()));
    }
 else {
      exprs.add(null);
    }
  }
  return exprs;
}","/** 
 * Gets the default expressions for function arguments (null where default is not provided).
 */
private List<MExpression> getDefaultValues(IASTFunctionDeclarator func) throws DOMException {
  IASTStandardFunctionDeclarator declarator=(IASTStandardFunctionDeclarator)func;
  IASTParameterDeclaration[] params=declarator.getParameters();
  List<MExpression> exprs=new ArrayList<MExpression>();
  for (  IASTParameterDeclaration param : params) {
    IASTDeclarator paramDeclarator=param.getDeclarator();
    IBinding binding=paramDeclarator.getName().resolveBinding();
    IType tp=ctx.converter.evalBindingReturnType(binding);
    if (paramDeclarator.getInitializer() != null) {
      exprs.add(ctx.initMngr.eval1Init(paramDeclarator.getInitializer(),tp,paramDeclarator.getName(),InitType.WRAPPED));
    }
 else {
      exprs.add(null);
    }
  }
  return exprs;
}"
50088,"/** 
 * Evaluates a function definition and converts it to Java.
 */
void evalFunction(IASTDeclaration declaration) throws DOMException {
  IASTFunctionDefinition func=(IASTFunctionDefinition)declaration;
  IBinding funcBinding=func.getDeclarator().getName().resolveBinding();
  CppFunction method=(CppFunction)ctx.typeMngr.getDeclFromType(ctx.converter.evalBindingReturnType(funcBinding));
  if (method == null) {
    method=new CppFunction();
    ctx.typeMngr.registerDecl(method,ctx.converter.evalBindingReturnType(funcBinding),func.getDeclarator().getName(),NameType.CAMEL_CASE,func.getDeclarator().getContainingFilename(),func.getDeclarator().getFileLocation().getStartingLineNumber());
  }
  method.isStatic=((IFunction)funcBinding).isStatic();
  method.retType=evalReturnType(funcBinding);
  if (funcBinding instanceof ICPPConstructor) {
    method.isCtor=true;
    method.retType=null;
  }
 else   if (funcBinding instanceof ICPPMethod) {
    if (((ICPPMethod)funcBinding).isDestructor()) {
      method.isDtor=true;
      method.retType=null;
    }
  }
  method.args.addAll(evalParameters(funcBinding));
  ctx.stackMngr.reset();
  if (funcBinding instanceof IFunction) {
    IFunction funcb=(IFunction)funcBinding;
    IFunctionType funcType=funcb.getType();
    ctx.currentReturnType=funcType.getReturnType();
  }
  method.body=(MCompoundStmt)ctx.stmtEvaluator.eval1Stmt(func.getBody());
  ctx.currentReturnType=null;
  if (ctx.stackMngr.getMaxLocalVariableId() != null) {
    MStringExpression expr=new MStringExpression();
    expr.contents=""String_Node_Str"" + ctx.stackMngr.getMaxLocalVariableId() + ""String_Node_Str"";
    method.body.statements.add(0,ModelCreation.createExprStmt(expr));
  }
  CompositeInfo info=ctx.converter.currentInfoStack.peekFirst();
  if (func instanceof ICPPASTFunctionDefinition && info != null) {
    List<FieldInfo> fields=ctx.converter.collectFieldsForClass(info.declSpecifier);
    MExpression superInit=null;
    ICPPASTFunctionDefinition funcCpp=(ICPPASTFunctionDefinition)func;
    ICPPASTConstructorChainInitializer[] chains=funcCpp.getMemberInitializers();
    if (chains != null && chains.length != 0) {
      for (      ICPPASTConstructorChainInitializer chain : chains) {
        if ((chain.getMemberInitializerId().resolveBinding() instanceof IVariable && ((IVariable)chain.getMemberInitializerId().resolveBinding()).getType() instanceof ICompositeType)) {
          MLiteralExpression lit=ModelCreation.createLiteral(ctx.typeMngr.cppToJavaType(((IVariable)chain.getMemberInitializerId().resolveBinding()).getType(),TypeType.IMPLEMENTATION));
          MClassInstanceCreation create=new MClassInstanceCreation();
          create.name=lit;
          create.args.add(ctx.initMngr.eval1Init(chain.getInitializer(),ctx.converter.evalBindingReturnType(chain.getMemberInitializerId().resolveBinding()),chain.getMemberInitializerId()));
          for (          FieldInfo fieldInfo : fields) {
            if (chain.getMemberInitializerId().resolveBinding().getName().equals(fieldInfo.field.getName()))             fieldInfo.init=create;
          }
        }
 else         if (chain.getInitializer() != null) {
          for (          FieldInfo fieldInfo : fields) {
            if (chain.getMemberInitializerId().resolveBinding().getName().equals(fieldInfo.field.getName()) && ctx.bitfieldMngr.isBitfield(fieldInfo.declarator.getName())) {
              IType tp=ctx.converter.evalBindingReturnType(chain.getMemberInitializerId().resolveBinding());
              fieldInfo.init=ctx.initMngr.eval1Init(chain.getInitializer(),tp,fieldInfo.declarator.getName());
            }
 else             if (chain.getMemberInitializerId().resolveBinding().getName().equals(fieldInfo.field.getName())) {
              IType tp=ctx.converter.evalBindingReturnType(chain.getMemberInitializerId().resolveBinding());
              fieldInfo.init=ctx.initMngr.eval1Init(chain.getInitializer(),tp,fieldInfo.declarator.getName());
            }
          }
          if (info.hasSuper && chain.getMemberInitializerId().resolveBinding().getName().equals(info.superClass)) {
            superInit=ctx.initMngr.eval1Init(chain.getInitializer(),ctx.converter.evalBindingReturnType(chain.getMemberInitializerId().resolveBinding()),chain.getMemberInitializerId());
          }
        }
 else {
        }
      }
    }
    if (method.isCtor) {
      MyLogger.log(""String_Node_Str"");
      ctx.specialGenerator.generateCtorStatements(fields,method.body);
      if (info.hasSuper) {
        MFunctionCallExpression expr=ModelCreation.createFuncCall(""String_Node_Str"");
        if (superInit != null)         expr.args.add(superInit);
        method.body.statements.add(0,ModelCreation.createExprStmt(expr));
      }
    }
 else     if (method.isDtor) {
      ctx.specialGenerator.generateDtorStatements(fields,method.body,info.hasSuper);
    }
  }
  makeDefaultCalls(func.getDeclarator(),funcBinding);
}","/** 
 * Evaluates a function definition and converts it to Java.
 */
void evalFunction(IASTDeclaration declaration) throws DOMException {
  IASTFunctionDefinition func=(IASTFunctionDefinition)declaration;
  IBinding funcBinding=func.getDeclarator().getName().resolveBinding();
  CppFunction method=(CppFunction)ctx.typeMngr.getDeclFromType(ctx.converter.evalBindingReturnType(funcBinding));
  if (method == null) {
    method=new CppFunction();
    ctx.typeMngr.registerDecl(method,ctx.converter.evalBindingReturnType(funcBinding),func.getDeclarator().getName(),NameType.CAMEL_CASE,func.getDeclarator().getContainingFilename(),func.getDeclarator().getFileLocation().getStartingLineNumber());
  }
  method.isStatic=((IFunction)funcBinding).isStatic();
  method.retType=evalReturnType(funcBinding);
  if (funcBinding instanceof ICPPConstructor) {
    method.isCtor=true;
    method.retType=null;
  }
 else   if (funcBinding instanceof ICPPMethod) {
    if (((ICPPMethod)funcBinding).isDestructor()) {
      method.isDtor=true;
      method.retType=null;
    }
  }
  method.args.addAll(evalParameters(funcBinding));
  ctx.stackMngr.reset();
  if (funcBinding instanceof IFunction) {
    IFunction funcb=(IFunction)funcBinding;
    IFunctionType funcType=funcb.getType();
    ctx.currentReturnType=funcType.getReturnType();
  }
  method.body=(MCompoundStmt)ctx.stmtEvaluator.eval1Stmt(func.getBody());
  ctx.currentReturnType=null;
  if (ctx.stackMngr.getMaxLocalVariableId() != null) {
    MStringExpression expr=new MStringExpression();
    expr.contents=""String_Node_Str"" + ctx.stackMngr.getMaxLocalVariableId() + ""String_Node_Str"";
    method.body.statements.add(0,ModelCreation.createExprStmt(expr));
  }
  CompositeInfo info=ctx.converter.currentInfoStack.peekFirst();
  if (func instanceof ICPPASTFunctionDefinition && info != null) {
    List<FieldInfo> fields=ctx.converter.collectFieldsForClass(info.declSpecifier);
    MExpression superInit=null;
    ICPPASTFunctionDefinition funcCpp=(ICPPASTFunctionDefinition)func;
    ICPPASTConstructorChainInitializer[] chains=funcCpp.getMemberInitializers();
    if (chains != null && chains.length != 0) {
      for (      ICPPASTConstructorChainInitializer chain : chains) {
        if ((chain.getMemberInitializerId().resolveBinding() instanceof IVariable && ((IVariable)chain.getMemberInitializerId().resolveBinding()).getType() instanceof ICompositeType)) {
          MLiteralExpression lit=ModelCreation.createLiteral(ctx.typeMngr.cppToJavaType(((IVariable)chain.getMemberInitializerId().resolveBinding()).getType(),TypeType.IMPLEMENTATION));
          MClassInstanceCreation create=new MClassInstanceCreation();
          create.name=lit;
          create.args.add(ctx.initMngr.eval1Init(chain.getInitializer(),ctx.converter.evalBindingReturnType(chain.getMemberInitializerId().resolveBinding()),chain.getMemberInitializerId(),InitType.WRAPPED));
          for (          FieldInfo fieldInfo : fields) {
            if (chain.getMemberInitializerId().resolveBinding().getName().equals(fieldInfo.field.getName()))             fieldInfo.init=create;
          }
        }
 else         if (chain.getInitializer() != null) {
          for (          FieldInfo fieldInfo : fields) {
            if (chain.getMemberInitializerId().resolveBinding().getName().equals(fieldInfo.field.getName()) && ctx.bitfieldMngr.isBitfield(fieldInfo.declarator.getName())) {
              IType tp=ctx.converter.evalBindingReturnType(chain.getMemberInitializerId().resolveBinding());
              fieldInfo.init=ctx.initMngr.eval1Init(chain.getInitializer(),tp,fieldInfo.declarator.getName(),InitType.WRAPPED);
            }
 else             if (chain.getMemberInitializerId().resolveBinding().getName().equals(fieldInfo.field.getName())) {
              IType tp=ctx.converter.evalBindingReturnType(chain.getMemberInitializerId().resolveBinding());
              fieldInfo.init=ctx.initMngr.eval1Init(chain.getInitializer(),tp,fieldInfo.declarator.getName(),InitType.WRAPPED);
            }
          }
          if (info.hasSuper && chain.getMemberInitializerId().resolveBinding().getName().equals(info.superClass)) {
            superInit=ctx.initMngr.eval1Init(chain.getInitializer(),ctx.converter.evalBindingReturnType(chain.getMemberInitializerId().resolveBinding()),chain.getMemberInitializerId(),InitType.WRAPPED);
          }
        }
 else {
        }
      }
    }
    if (method.isCtor) {
      MyLogger.log(""String_Node_Str"");
      ctx.specialGenerator.generateCtorStatements(fields,method.body);
      if (info.hasSuper) {
        MFunctionCallExpression expr=ModelCreation.createFuncCall(""String_Node_Str"");
        if (superInit != null)         expr.args.add(superInit);
        method.body.statements.add(0,ModelCreation.createExprStmt(expr));
      }
    }
 else     if (method.isDtor) {
      ctx.specialGenerator.generateDtorStatements(fields,method.body,info.hasSuper);
    }
  }
  makeDefaultCalls(func.getDeclarator(),funcBinding);
}"
50089,"MExpression eval1Init(IASTInitializer initializer,IType typeRequired,IASTName name) throws DOMException {
  if (initializer == null) {
    if (TypeManager.isBasicType(typeRequired) && (name == null || !ctx.bitfieldMngr.isBitfield(name))) {
      return ctx.exprEvaluator.makeSimpleCreationExpression(typeRequired);
    }
 else     if (TypeManager.isOneOf(typeRequired,TypeEnum.BASIC_ARRAY,TypeEnum.BASIC_POINTER,TypeEnum.OBJECT_POINTER)) {
      return ctx.exprEvaluator.makeSimpleCreationExpression(typeRequired);
    }
 else     if (TypeManager.isOneOf(typeRequired,TypeEnum.OBJECT)) {
      MNewExpressionObject expr=new MNewExpressionObject();
      expr.type=ctx.typeMngr.cppToJavaType(typeRequired,TypeType.IMPLEMENTATION);
      if (!(name.resolveBinding() instanceof IField)) {
        return ctx.stackMngr.createAddItemCall(expr);
      }
 else {
        return expr;
      }
    }
 else     if (TypeManager.isOneOf(typeRequired,TypeEnum.OBJECT_ARRAY)) {
      return null;
    }
 else {
      return null;
    }
  }
 else   if (initializer instanceof IASTEqualsInitializer) {
    if (ctx.bitfieldMngr.isBitfield(name)) {
      return ctx.exprEvaluator.eval1Expr((IASTExpression)((IASTEqualsInitializer)initializer).getInitializerClause());
    }
 else     if (TypeManager.isOneOf(typeRequired,TypeEnum.BASIC_POINTER,TypeEnum.OBJECT_POINTER)) {
      MExpression expr=ctx.exprEvaluator.eval1Expr((IASTExpression)((IASTEqualsInitializer)initializer).getInitializerClause());
      ctx.exprEvaluator.modifyLiteralToPtr(expr);
      return expr;
    }
 else     if (TypeManager.isOneOf(typeRequired,TypeEnum.OBJECT)) {
      MExpression expr=ctx.exprEvaluator.eval1Expr((IASTExpression)((IASTEqualsInitializer)initializer).getInitializerClause());
      return ctx.stackMngr.createAddItemCall(expr);
    }
 else {
      return ctx.exprEvaluator.wrapIfNeeded((IASTExpression)((IASTEqualsInitializer)initializer).getInitializerClause(),typeRequired);
    }
  }
 else   if (initializer instanceof ICPPASTConstructorInitializer) {
    ICPPASTConstructorInitializer inti=(ICPPASTConstructorInitializer)initializer;
    MMultiExpression multi=new MMultiExpression();
    for (    IASTInitializerClause cls : inti.getArguments()) {
      IASTExpression expr=(IASTExpression)cls;
      MExpression create;
      if (name != null && ctx.bitfieldMngr.isBitfield(name)) {
        create=ctx.exprEvaluator.eval1Expr(expr);
      }
 else       if (TypeManager.isOneOf(typeRequired,TypeEnum.BASIC_POINTER,TypeEnum.OBJECT_POINTER)) {
        create=ctx.exprEvaluator.eval1Expr(expr);
        ctx.exprEvaluator.modifyLiteralToPtr(create);
      }
 else {
        create=ctx.exprEvaluator.wrapIfNeeded(expr,typeRequired);
      }
      multi.exprs.add(create);
    }
    return multi;
  }
  return null;
}","MExpression eval1Init(IASTInitializer initializer,IType typeRequired,IASTName name,InitType initType) throws DOMException {
  if (initializer == null) {
    if (TypeManager.isBasicType(typeRequired) && (name == null || !ctx.bitfieldMngr.isBitfield(name))) {
      return ctx.exprEvaluator.makeSimpleCreationExpression(typeRequired);
    }
 else     if (TypeManager.isOneOf(typeRequired,TypeEnum.BASIC_ARRAY,TypeEnum.BASIC_POINTER,TypeEnum.OBJECT_POINTER)) {
      return ctx.exprEvaluator.makeSimpleCreationExpression(typeRequired);
    }
 else     if (TypeManager.isOneOf(typeRequired,TypeEnum.OBJECT)) {
      MNewExpressionObject expr=new MNewExpressionObject();
      expr.type=ctx.typeMngr.cppToJavaType(typeRequired,TypeType.IMPLEMENTATION);
      if (!(name.resolveBinding() instanceof IField)) {
        return ctx.stackMngr.createAddItemCall(expr);
      }
 else {
        return expr;
      }
    }
 else     if (TypeManager.isOneOf(typeRequired,TypeEnum.OBJECT_ARRAY)) {
      return null;
    }
 else {
      return null;
    }
  }
 else   if (initializer instanceof IASTEqualsInitializer) {
    if (ctx.bitfieldMngr.isBitfield(name)) {
      return ctx.exprEvaluator.eval1Expr((IASTExpression)((IASTEqualsInitializer)initializer).getInitializerClause());
    }
 else     if (TypeManager.isOneOf(typeRequired,TypeEnum.BASIC_POINTER,TypeEnum.OBJECT_POINTER)) {
      MExpression expr=ctx.exprEvaluator.eval1Expr((IASTExpression)((IASTEqualsInitializer)initializer).getInitializerClause());
      ctx.exprEvaluator.modifyLiteralToPtr(expr);
      return expr;
    }
 else     if (TypeManager.isOneOf(typeRequired,TypeEnum.OBJECT)) {
      MExpression expr=ctx.exprEvaluator.eval1Expr((IASTExpression)((IASTEqualsInitializer)initializer).getInitializerClause());
      return ctx.stackMngr.createAddItemCall(expr);
    }
 else {
      if (initType == InitType.WRAPPED)       return ctx.exprEvaluator.wrapIfNeeded((IASTExpression)((IASTEqualsInitializer)initializer).getInitializerClause(),typeRequired);
 else       return ctx.exprEvaluator.eval1Expr((IASTExpression)((IASTEqualsInitializer)initializer).getInitializerClause());
    }
  }
 else   if (initializer instanceof ICPPASTConstructorInitializer) {
    ICPPASTConstructorInitializer inti=(ICPPASTConstructorInitializer)initializer;
    MMultiExpression multi=new MMultiExpression();
    for (    IASTInitializerClause cls : inti.getArguments()) {
      IASTExpression expr=(IASTExpression)cls;
      MExpression create;
      if (name != null && ctx.bitfieldMngr.isBitfield(name)) {
        create=ctx.exprEvaluator.eval1Expr(expr);
      }
 else       if (TypeManager.isOneOf(typeRequired,TypeEnum.BASIC_POINTER,TypeEnum.OBJECT_POINTER)) {
        create=ctx.exprEvaluator.eval1Expr(expr);
        ctx.exprEvaluator.modifyLiteralToPtr(create);
      }
 else {
        create=ctx.exprEvaluator.wrapIfNeeded(expr,typeRequired);
      }
      multi.exprs.add(create);
    }
    return multi;
  }
  return null;
}"
50090,"/** 
 * Given a declaration like: int a = 5; Returns an infix expression: a.set(5); Optionally the return expression is made into a boolean expression. Used to split up the declaration into two parts for if, while, switch and for condition declarations. Example: while (int a = 10) {} becomes: MInteger a = new MInteger(); while ((a.set(10)) != 0) {}
 */
MExpression makeInfixFromDecl(String varName,MExpression initExpr,IType tp,boolean makeBoolean) throws DOMException {
  MInfixExpression infix=null;
  if (TypeManager.isBasicType(tp)) {
    infix=new MInfixAssignmentWithNumberOnLeft();
    infix.left=ModelCreation.createNumberId(varName);
  }
 else {
    infix=new MInfixExpressionPlain();
    infix.left=ModelCreation.createLiteral(varName);
  }
  infix.right=initExpr;
  if (makeBoolean)   infix.right=ExpressionHelpers.makeExpressionBoolean(infix.right,tp);
 else   infix.right=ExpressionHelpers.bracket(infix.right);
  infix.operator=""String_Node_Str"";
  return infix;
}","/** 
 * Given a declaration like: int a = 5; Returns an infix expression: a.set(5); Optionally the return expression is made into a boolean expression. Used to split up the declaration into two parts for if, while, switch and for condition declarations. Example: while (int a = 10) {} becomes: MInteger a = new MInteger(); while ((a.set(10)) != 0) {}
 */
MExpression makeInfixFromDecl(String varName,MExpression initExpr,IType tp,boolean makeBoolean) throws DOMException {
  MInfixExpression infix=null;
  if (TypeManager.isBasicType(tp)) {
    infix=new MInfixAssignmentWithNumberOnLeft();
    infix.left=ModelCreation.createNumberId(varName);
  }
 else {
    infix=new MInfixExpressionPlain();
    infix.left=ModelCreation.createLiteral(varName);
  }
  infix.right=initExpr;
  if (TypeManager.isOneOf(tp,TypeEnum.BOOLEAN))   infix.right=ExpressionHelpers.makeExpressionBoolean(infix.right,tp);
 else   infix.right=ExpressionHelpers.bracket(infix.right);
  infix.operator=""String_Node_Str"";
  return (makeBoolean && !TypeManager.isOneOf(tp,TypeEnum.BOOLEAN)) ? ExpressionHelpers.makeExpressionBoolean(infix,tp) : ExpressionHelpers.bracket(infix);
}"
50091,"/** 
 * Attempts to evaluate the given declaration (function, class, namespace, template, etc).
 */
void evalDeclaration(IASTDeclaration declaration) throws DOMException {
  if (declaration instanceof IASTFunctionDefinition && ((IASTFunctionDefinition)declaration).getDeclarator().getName().resolveBinding() instanceof IFunction) {
    MyLogger.log(""String_Node_Str"");
    ctx.funcMngr.evalFunction(declaration);
  }
 else   if (declaration instanceof IASTFunctionDefinition) {
    IBinding bind=((IASTFunctionDefinition)declaration).getDeclarator().getName().resolveBinding();
    if (bind instanceof IProblemBinding)     MyLogger.logImportant(""String_Node_Str"" + ((IProblemBinding)bind).getFileName() + ((IProblemBinding)bind).getLineNumber());
 else     MyLogger.logImportant(""String_Node_Str"" + bind.getClass().getCanonicalName());
  }
 else   if (declaration instanceof IASTSimpleDeclaration) {
    IASTSimpleDeclaration simple=(IASTSimpleDeclaration)declaration;
    evalDeclSpecifier(simple.getDeclSpecifier());
    List<MExpression> exprs=evaluateDeclarationReturnInitializers(simple);
    int i=0;
    for (    IASTDeclarator declarator : simple.getDeclarators()) {
      IBinding binding=declarator.getName().resolveBinding();
      if (declarator instanceof IASTFieldDeclarator && ((IASTFieldDeclarator)declarator).getBitFieldSize() != null) {
        MyLogger.log(""String_Node_Str"");
        ctx.bitfieldMngr.evalDeclBitfield((IField)binding,declarator);
      }
 else       if (binding instanceof IField) {
        MyLogger.log(""String_Node_Str"");
        generateField(binding,declarator,exprs.get(i));
      }
 else       if (binding instanceof IFunction && declarator instanceof IASTFunctionDeclarator) {
        CppFunction func=(CppFunction)ctx.typeMngr.getDeclFromType(evalBindingReturnType(binding));
        if (func == null) {
          func=new CppFunction();
          ctx.typeMngr.registerDecl(func,evalBindingReturnType(binding),declarator.getName(),NameType.CAMEL_CASE,declarator.getContainingFilename(),declarator.getFileLocation().getStartingLineNumber());
        }
        ctx.funcMngr.makeDefaultCalls((IASTFunctionDeclarator)declarator,binding);
      }
 else       if (binding instanceof IVariable) {
        generateVariable(binding,declarator,exprs.get(i));
      }
 else {
        MyLogger.logImportant(""String_Node_Str"" + declarator.getClass().getCanonicalName() + ""String_Node_Str""+ binding.getClass().getName());
      }
      i++;
    }
  }
 else   if (declaration instanceof ICPPASTNamespaceDefinition) {
    ICPPASTNamespaceDefinition namespace=(ICPPASTNamespaceDefinition)declaration;
    MyLogger.log(""String_Node_Str"");
    for (    IASTDeclaration childDeclaration : namespace.getDeclarations())     evalDeclaration(childDeclaration);
  }
 else   if (declaration instanceof IASTASMDeclaration) {
    MyLogger.logImportant(""String_Node_Str"" + declaration.getRawSignature());
    MyLogger.exitOnError();
  }
 else   if (declaration instanceof IASTProblemDeclaration) {
    IASTProblemDeclaration p=(IASTProblemDeclaration)declaration;
    MyLogger.logImportant(""String_Node_Str"" + ""String_Node_Str"" + p.getRawSignature());
  }
 else   if (declaration instanceof ICPPASTVisibilityLabel) {
    MyLogger.log(""String_Node_Str"");
  }
 else   if (declaration instanceof ICPPASTUsingDirective) {
    MyLogger.log(""String_Node_Str"");
  }
 else   if (declaration instanceof ICPPASTNamespaceAlias) {
    MyLogger.log(""String_Node_Str"");
  }
 else   if (declaration instanceof ICPPASTUsingDeclaration) {
    MyLogger.log(""String_Node_Str"");
  }
 else   if (declaration instanceof ICPPASTLinkageSpecification) {
    ICPPASTLinkageSpecification linkageSpecification=(ICPPASTLinkageSpecification)declaration;
    MyLogger.log(""String_Node_Str"");
    for (    IASTDeclaration childDeclaration : linkageSpecification.getDeclarations())     evalDeclaration(childDeclaration);
  }
 else   if (declaration instanceof ICPPASTTemplateDeclaration) {
    ICPPASTTemplateDeclaration templateDeclaration=(ICPPASTTemplateDeclaration)declaration;
    evalDeclaration(templateDeclaration.getDeclaration());
  }
 else   if (declaration instanceof ICPPASTExplicitTemplateInstantiation) {
    ICPPASTExplicitTemplateInstantiation explicitTemplateInstantiation=(ICPPASTExplicitTemplateInstantiation)declaration;
    MyLogger.log(""String_Node_Str"");
    evalDeclaration(explicitTemplateInstantiation.getDeclaration());
  }
 else   if (declaration instanceof ICPPASTTemplateSpecialization) {
    ICPPASTTemplateSpecialization templateSpecialization=(ICPPASTTemplateSpecialization)declaration;
    MyLogger.log(""String_Node_Str"");
    evalDeclaration(templateSpecialization.getDeclaration());
  }
 else {
    MyLogger.log(""String_Node_Str"" + declaration.getClass().getCanonicalName());
    MyLogger.exitOnError();
  }
}","/** 
 * Attempts to evaluate the given declaration (function, class, namespace, template, etc).
 */
void evalDeclaration(IASTDeclaration declaration) throws DOMException {
  if (declaration instanceof IASTFunctionDefinition && ((IASTFunctionDefinition)declaration).getDeclarator().getName().resolveBinding() instanceof IFunction) {
    MyLogger.log(""String_Node_Str"");
    ctx.funcMngr.evalFunction(declaration);
  }
 else   if (declaration instanceof IASTFunctionDefinition) {
    IBinding bind=((IASTFunctionDefinition)declaration).getDeclarator().getName().resolveBinding();
    if (bind instanceof IProblemBinding)     MyLogger.logImportant(""String_Node_Str"" + ((IProblemBinding)bind).getFileName() + ((IProblemBinding)bind).getLineNumber());
 else     MyLogger.logImportant(""String_Node_Str"" + bind.getClass().getCanonicalName());
  }
 else   if (declaration instanceof IASTSimpleDeclaration) {
    IASTSimpleDeclaration simple=(IASTSimpleDeclaration)declaration;
    evalDeclSpecifier(simple.getDeclSpecifier());
    List<MExpression> exprs=evaluateDeclarationReturnInitializers(simple,InitType.WRAPPED);
    int i=0;
    for (    IASTDeclarator declarator : simple.getDeclarators()) {
      IBinding binding=declarator.getName().resolveBinding();
      if (declarator instanceof IASTFieldDeclarator && ((IASTFieldDeclarator)declarator).getBitFieldSize() != null) {
        MyLogger.log(""String_Node_Str"");
        ctx.bitfieldMngr.evalDeclBitfield((IField)binding,declarator);
      }
 else       if (binding instanceof IField) {
        MyLogger.log(""String_Node_Str"");
        generateField(binding,declarator,exprs.get(i));
      }
 else       if (binding instanceof IFunction && declarator instanceof IASTFunctionDeclarator) {
        CppFunction func=(CppFunction)ctx.typeMngr.getDeclFromType(evalBindingReturnType(binding));
        if (func == null) {
          func=new CppFunction();
          ctx.typeMngr.registerDecl(func,evalBindingReturnType(binding),declarator.getName(),NameType.CAMEL_CASE,declarator.getContainingFilename(),declarator.getFileLocation().getStartingLineNumber());
        }
        ctx.funcMngr.makeDefaultCalls((IASTFunctionDeclarator)declarator,binding);
      }
 else       if (binding instanceof IVariable) {
        generateVariable(binding,declarator,exprs.get(i));
      }
 else {
        MyLogger.logImportant(""String_Node_Str"" + declarator.getClass().getCanonicalName() + ""String_Node_Str""+ binding.getClass().getName());
      }
      i++;
    }
  }
 else   if (declaration instanceof ICPPASTNamespaceDefinition) {
    ICPPASTNamespaceDefinition namespace=(ICPPASTNamespaceDefinition)declaration;
    MyLogger.log(""String_Node_Str"");
    for (    IASTDeclaration childDeclaration : namespace.getDeclarations())     evalDeclaration(childDeclaration);
  }
 else   if (declaration instanceof IASTASMDeclaration) {
    MyLogger.logImportant(""String_Node_Str"" + declaration.getRawSignature());
    MyLogger.exitOnError();
  }
 else   if (declaration instanceof IASTProblemDeclaration) {
    IASTProblemDeclaration p=(IASTProblemDeclaration)declaration;
    MyLogger.logImportant(""String_Node_Str"" + ""String_Node_Str"" + p.getRawSignature());
  }
 else   if (declaration instanceof ICPPASTVisibilityLabel) {
    MyLogger.log(""String_Node_Str"");
  }
 else   if (declaration instanceof ICPPASTUsingDirective) {
    MyLogger.log(""String_Node_Str"");
  }
 else   if (declaration instanceof ICPPASTNamespaceAlias) {
    MyLogger.log(""String_Node_Str"");
  }
 else   if (declaration instanceof ICPPASTUsingDeclaration) {
    MyLogger.log(""String_Node_Str"");
  }
 else   if (declaration instanceof ICPPASTLinkageSpecification) {
    ICPPASTLinkageSpecification linkageSpecification=(ICPPASTLinkageSpecification)declaration;
    MyLogger.log(""String_Node_Str"");
    for (    IASTDeclaration childDeclaration : linkageSpecification.getDeclarations())     evalDeclaration(childDeclaration);
  }
 else   if (declaration instanceof ICPPASTTemplateDeclaration) {
    ICPPASTTemplateDeclaration templateDeclaration=(ICPPASTTemplateDeclaration)declaration;
    evalDeclaration(templateDeclaration.getDeclaration());
  }
 else   if (declaration instanceof ICPPASTExplicitTemplateInstantiation) {
    ICPPASTExplicitTemplateInstantiation explicitTemplateInstantiation=(ICPPASTExplicitTemplateInstantiation)declaration;
    MyLogger.log(""String_Node_Str"");
    evalDeclaration(explicitTemplateInstantiation.getDeclaration());
  }
 else   if (declaration instanceof ICPPASTTemplateSpecialization) {
    ICPPASTTemplateSpecialization templateSpecialization=(ICPPASTTemplateSpecialization)declaration;
    MyLogger.log(""String_Node_Str"");
    evalDeclaration(templateSpecialization.getDeclaration());
  }
 else {
    MyLogger.log(""String_Node_Str"" + declaration.getClass().getCanonicalName());
    MyLogger.exitOnError();
  }
}"
50092,"/** 
 * Given a declaration creates one Java declaration.
 */
MSimpleDecl eval1Decl(IASTDeclaration decla) throws DOMException {
  MyLogger.log(""String_Node_Str"");
  IASTSimpleDeclaration simpleDeclaration=(IASTSimpleDeclaration)decla;
  assert(simpleDeclaration.getDeclarators().length == 1);
  List<MExpression> inits=evaluateDeclarationReturnInitializers(simpleDeclaration);
  List<String> names=evaluateDeclarationReturnNames(simpleDeclaration);
  List<String> types=evaluateDeclarationReturnTypes(simpleDeclaration);
  MSimpleDecl dec=new MSimpleDecl();
  dec.name=names.get(0);
  dec.initExpr=inits.get(0);
  dec.type=types.get(0);
  return dec;
}","/** 
 * Given a declaration creates one Java declaration.
 */
MSimpleDecl eval1Decl(IASTDeclaration decla,InitType initType) throws DOMException {
  MyLogger.log(""String_Node_Str"");
  IASTSimpleDeclaration simpleDeclaration=(IASTSimpleDeclaration)decla;
  assert(simpleDeclaration.getDeclarators().length == 1);
  List<MExpression> inits=evaluateDeclarationReturnInitializers(simpleDeclaration,initType);
  List<String> names=evaluateDeclarationReturnNames(simpleDeclaration);
  List<String> types=evaluateDeclarationReturnTypes(simpleDeclaration);
  MSimpleDecl dec=new MSimpleDecl();
  dec.name=names.get(0);
  dec.initExpr=inits.get(0);
  dec.type=types.get(0);
  return dec;
}"
50093,"/** 
 * Returns one initializer for each declarator. This can be the provided C++ initializer or it can be a generated initializer for objects. Example: int i, j = 5, * p; returns: [MInteger.valueOf(0), MInteger.valueOf(5), MInteger.valueOf(0)]
 */
List<MExpression> evaluateDeclarationReturnInitializers(IASTSimpleDeclaration simple) throws DOMException {
  List<MExpression> exprs=new ArrayList<MExpression>();
  List<IType> types=evaluateDeclarationReturnCppTypes(simple);
  int i=0;
  for (  IASTDeclarator decl : simple.getDeclarators()) {
    exprs.add(ctx.initMngr.eval1Init(decl.getInitializer(),types.get(i),decl.getName()));
    i++;
  }
  return exprs;
}","/** 
 * Returns one initializer for each declarator. This can be the provided C++ initializer or it can be a generated initializer for objects. Example: int i, j = 5, * p; returns: [MInteger.valueOf(0), MInteger.valueOf(5), MInteger.valueOf(0)]
 */
List<MExpression> evaluateDeclarationReturnInitializers(IASTSimpleDeclaration simple,InitType initType) throws DOMException {
  List<MExpression> exprs=new ArrayList<MExpression>();
  List<IType> types=evaluateDeclarationReturnCppTypes(simple);
  int i=0;
  for (  IASTDeclarator decl : simple.getDeclarators()) {
    exprs.add(ctx.initMngr.eval1Init(decl.getInitializer(),types.get(i),decl.getName(),initType));
    i++;
  }
  return exprs;
}"
50094,"/** 
 * This method creates a list of fields present in the class. This is used to generate ctor, dtor, assign and copy statements. Note: Includes static fields.
 */
List<FieldInfo> collectFieldsForClass(IASTDeclSpecifier declSpec) throws DOMException {
  if (!(declSpec instanceof IASTCompositeTypeSpecifier))   return Collections.emptyList();
  IASTCompositeTypeSpecifier composite=(IASTCompositeTypeSpecifier)declSpec;
  List<FieldInfo> fields=new ArrayList<FieldInfo>();
  for (  IASTDeclaration decl : composite.getMembers()) {
    if (decl instanceof IASTSimpleDeclaration) {
      IASTSimpleDeclaration simple=(IASTSimpleDeclaration)decl;
      List<MExpression> exprs=evaluateDeclarationReturnInitializers(simple);
      int i=0;
      for (      IASTDeclarator declarator : simple.getDeclarators()) {
        IBinding binding=declarator.getName().resolveBinding();
        if (binding instanceof IField) {
          FieldInfo field=new FieldInfo(declarator,exprs.get(i),(IField)binding);
          if (declarator instanceof IASTFieldDeclarator && ((IASTFieldDeclarator)declarator).getBitFieldSize() != null) {
            ctx.bitfieldMngr.addBitfield(declarator.getName());
            field.isBitfield=true;
          }
          if (((IField)binding).isStatic())           field.isStatic=true;
          fields.add(field);
        }
        i++;
      }
    }
  }
  return fields;
}","/** 
 * This method creates a list of fields present in the class. This is used to generate ctor, dtor, assign and copy statements. Note: Includes static fields.
 */
List<FieldInfo> collectFieldsForClass(IASTDeclSpecifier declSpec) throws DOMException {
  if (!(declSpec instanceof IASTCompositeTypeSpecifier))   return Collections.emptyList();
  IASTCompositeTypeSpecifier composite=(IASTCompositeTypeSpecifier)declSpec;
  List<FieldInfo> fields=new ArrayList<FieldInfo>();
  for (  IASTDeclaration decl : composite.getMembers()) {
    if (decl instanceof IASTSimpleDeclaration) {
      IASTSimpleDeclaration simple=(IASTSimpleDeclaration)decl;
      List<MExpression> exprs=evaluateDeclarationReturnInitializers(simple,InitType.WRAPPED);
      int i=0;
      for (      IASTDeclarator declarator : simple.getDeclarators()) {
        IBinding binding=declarator.getName().resolveBinding();
        if (binding instanceof IField) {
          FieldInfo field=new FieldInfo(declarator,exprs.get(i),(IField)binding);
          if (declarator instanceof IASTFieldDeclarator && ((IASTFieldDeclarator)declarator).getBitFieldSize() != null) {
            ctx.bitfieldMngr.addBitfield(declarator.getName());
            field.isBitfield=true;
          }
          if (((IField)binding).isStatic())           field.isStatic=true;
          fields.add(field);
        }
        i++;
      }
    }
  }
  return fields;
}"
50095,"/** 
 * Attempts to convert the given C++ statement to one or more Java statements.
 */
List<MStmt> evalStmt(IASTStatement statement) throws DOMException {
  List<MStmt> stmts=new ArrayList<MStmt>();
  if (statement instanceof IASTBreakStatement) {
    MyLogger.log(""String_Node_Str"");
    Integer temp=ctx.stackMngr.findLastSwitchOrLoopId();
    MBreakStmt brk=new MBreakStmt();
    stmts.add(brk);
    if (temp != null)     brk.cleanup=ctx.stackMngr.createCleanupCall(temp);
  }
 else   if (statement instanceof IASTCaseStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTCaseStatement caseStatement=(IASTCaseStatement)statement;
    MCaseStmt cs=new MCaseStmt();
    stmts.add(cs);
    cs.expr=ctx.exprEvaluator.eval1Expr(caseStatement.getExpression());
  }
 else   if (statement instanceof IASTContinueStatement) {
    MyLogger.log(""String_Node_Str"");
    Integer temp=ctx.stackMngr.findLastLoopId();
    MContinueStmt con=new MContinueStmt();
    stmts.add(con);
    if (temp != null)     con.cleanup=ctx.stackMngr.createCleanupCall(temp);
  }
 else   if (statement instanceof IASTDefaultStatement) {
    MyLogger.log(""String_Node_Str"");
    MDefaultStmt def=new MDefaultStmt();
    stmts.add(def);
  }
 else   if (statement instanceof IASTGotoStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTGotoStatement gotoStatement=(IASTGotoStatement)statement;
    MGotoStmt go=new MGotoStmt();
    stmts.add(go);
    go.lbl=gotoStatement.getName().toString();
  }
 else   if (statement instanceof IASTNullStatement) {
    MyLogger.log(""String_Node_Str"");
    MEmptyStmt empty=new MEmptyStmt();
    stmts.add(empty);
  }
 else   if (statement instanceof IASTProblemStatement) {
    IASTProblemStatement probStatement=(IASTProblemStatement)statement;
    MyLogger.log(""String_Node_Str"" + probStatement.getProblem().getMessageWithLocation());
    MProblemStmt prob=new MProblemStmt();
    stmts.add(prob);
    prob.problem=probStatement.getProblem().getMessageWithLocation();
  }
 else   if (statement instanceof IASTCompoundStatement) {
    IASTCompoundStatement compoundStatement=(IASTCompoundStatement)statement;
    MyLogger.log(""String_Node_Str"");
    ctx.stackMngr.startNewCompoundStmt(false,false);
    MCompoundStmt compound=new MCompoundStmt();
    stmts.add(compound);
    for (    IASTStatement s : compoundStatement.getStatements())     compound.statements.addAll(evalStmt(s));
    Integer idToCleanTo=ctx.stackMngr.endCompoundStmt();
    if (idToCleanTo != null && !compound.statements.isEmpty() && !isTerminatingStatement(compound.statements.get(compound.statements.size() - 1))) {
      compound.cleanup=ctx.stackMngr.createCleanupCall(idToCleanTo);
    }
  }
 else   if (statement instanceof IASTDeclarationStatement) {
    IASTDeclarationStatement declarationStatement=(IASTDeclarationStatement)statement;
    MyLogger.log(""String_Node_Str"");
    List<String> types=ctx.converter.evaluateDeclarationReturnTypes(declarationStatement.getDeclaration());
    List<String> names=ctx.converter.evaluateDeclarationReturnNames(declarationStatement.getDeclaration());
    List<MExpression> exprs=ctx.converter.evaluateDeclarationReturnInitializers((IASTSimpleDeclaration)declarationStatement.getDeclaration());
    for (int i=0; i < types.size(); i++) {
      MSimpleDecl simple=new MSimpleDecl();
      simple.type=types.get(i);
      simple.name=names.get(i);
      simple.initExpr=exprs.get(i);
      MDeclarationStmt stmt=new MDeclarationStmt();
      stmt.simple=simple;
      stmts.add(stmt);
    }
  }
 else   if (statement instanceof IASTDoStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTDoStatement doStatement=(IASTDoStatement)statement;
    MDoStmt dos=new MDoStmt();
    stmts.add(dos);
    dos.body=surround(evalStmt(doStatement.getBody()));
    dos.expr=ctx.exprEvaluator.eval1Expr(doStatement.getCondition());
    dos.expr=ExpressionHelpers.makeExpressionBoolean(dos.expr,doStatement.getCondition());
  }
 else   if (statement instanceof IASTExpressionStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTExpressionStatement expressionStatement=(IASTExpressionStatement)statement;
    MExprStmt exprStmt=new MExprStmt();
    stmts.add(exprStmt);
    exprStmt.expr=ctx.exprEvaluator.eval1Expr(expressionStatement.getExpression());
  }
 else   if (statement instanceof IASTForStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTForStatement forStatement=(IASTForStatement)statement;
    MForStmt fs=new MForStmt();
    stmts.add(fs);
    if (forStatement.getInitializerStatement() != null)     fs.initializer=eval1Stmt(forStatement.getInitializerStatement());
    if (forStatement.getConditionExpression() != null) {
      fs.condition=ctx.exprEvaluator.eval1Expr(forStatement.getConditionExpression());
      fs.condition=ExpressionHelpers.makeExpressionBoolean(fs.condition,forStatement.getConditionExpression());
    }
    if (forStatement.getIterationExpression() != null)     fs.updater=ctx.exprEvaluator.eval1Expr(forStatement.getIterationExpression());
    fs.body=surround(evalStmt(forStatement.getBody()));
    if (forStatement instanceof ICPPASTForStatement && ((ICPPASTForStatement)forStatement).getConditionDeclaration() != null) {
      IType tp=ctx.converter.eval1DeclReturnCppType(((ICPPASTForStatement)forStatement).getConditionDeclaration());
      fs.decl=ctx.converter.eval1Decl(((ICPPASTForStatement)forStatement).getConditionDeclaration());
      fs.condition=ctx.converter.makeInfixFromDecl(fs.decl.name,fs.decl.initExpr,tp,true);
      fs.decl.initExpr=ctx.exprEvaluator.makeSimpleCreationExpression(tp);
    }
  }
 else   if (statement instanceof IASTIfStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTIfStatement ifStatement=(IASTIfStatement)statement;
    MIfStmt ifs=new MIfStmt();
    stmts.add(ifs);
    if (ifStatement.getConditionExpression() != null) {
      ifs.condition=ctx.exprEvaluator.eval1Expr(ifStatement.getConditionExpression());
      ifs.condition=ExpressionHelpers.makeExpressionBoolean(ifs.condition,ifStatement.getConditionExpression());
    }
    ifs.body=surround(evalStmt(ifStatement.getThenClause()));
    if (ifStatement.getElseClause() != null)     ifs.elseBody=eval1Stmt(ifStatement.getElseClause());
    if (ifStatement instanceof ICPPASTIfStatement && ((ICPPASTIfStatement)ifStatement).getConditionDeclaration() != null) {
      IType tp=ctx.converter.eval1DeclReturnCppType(((ICPPASTIfStatement)ifStatement).getConditionDeclaration());
      ifs.decl=ctx.converter.eval1Decl(((ICPPASTIfStatement)ifStatement).getConditionDeclaration());
      ifs.condition=ctx.converter.makeInfixFromDecl(ifs.decl.name,ifs.decl.initExpr,tp,true);
      ifs.decl.initExpr=ctx.exprEvaluator.makeSimpleCreationExpression(tp);
    }
  }
 else   if (statement instanceof IASTLabelStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTLabelStatement labelStatement=(IASTLabelStatement)statement;
    MLabelStmt lbl=new MLabelStmt();
    stmts.add(lbl);
    lbl.lbl=labelStatement.getName().toString();
    lbl.body=eval1Stmt(labelStatement.getNestedStatement());
  }
 else   if (statement instanceof IASTReturnStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTReturnStatement returnStatement=(IASTReturnStatement)statement;
    MReturnStmt retu=new MReturnStmt();
    stmts.add(retu);
    retu.expr=ctx.exprEvaluator.wrapIfNeeded(returnStatement.getReturnValue(),ctx.currentReturnType);
    if (ctx.stackMngr.getLocalVariableId() != 0 && TypeManager.isOneOf(ctx.currentReturnType,TypeEnum.VOID)) {
      retu.cleanup=ctx.stackMngr.createCleanupCall(0);
    }
 else     if (ctx.stackMngr.getLocalVariableId() != 0) {
      retu.expr=ctx.stackMngr.wrapCleanupCall(retu.expr);
    }
  }
 else   if (statement instanceof IASTSwitchStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTSwitchStatement switchStatement=(IASTSwitchStatement)statement;
    MSwitchStmt swi=new MSwitchStmt();
    stmts.add(swi);
    swi.body=surround(evalStmt(switchStatement.getBody()));
    if (switchStatement.getControllerExpression() != null) {
      swi.expr=ctx.exprEvaluator.eval1Expr(switchStatement.getControllerExpression());
    }
    if (switchStatement instanceof ICPPASTSwitchStatement && ((ICPPASTSwitchStatement)switchStatement).getControllerDeclaration() != null) {
      IType tp=ctx.converter.eval1DeclReturnCppType(((ICPPASTSwitchStatement)switchStatement).getControllerDeclaration());
      swi.decl=ctx.converter.eval1Decl(((ICPPASTSwitchStatement)switchStatement).getControllerDeclaration());
      swi.expr=ctx.converter.makeInfixFromDecl(swi.decl.name,swi.decl.initExpr,tp,false);
      swi.decl.initExpr=ctx.exprEvaluator.makeSimpleCreationExpression(tp);
    }
  }
 else   if (statement instanceof IASTWhileStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTWhileStatement whileStatement=(IASTWhileStatement)statement;
    MWhileStmt whi=new MWhileStmt();
    stmts.add(whi);
    whi.body=surround(evalStmt(whileStatement.getBody()));
    if (whileStatement.getCondition() != null) {
      whi.expr=ctx.exprEvaluator.eval1Expr(whileStatement.getCondition());
      whi.expr=ExpressionHelpers.makeExpressionBoolean(whi.expr,whileStatement.getCondition());
    }
    if (whileStatement instanceof ICPPASTWhileStatement && ((ICPPASTWhileStatement)whileStatement).getConditionDeclaration() != null) {
      IType tp=ctx.converter.eval1DeclReturnCppType(((ICPPASTWhileStatement)whileStatement).getConditionDeclaration());
      whi.decl=ctx.converter.eval1Decl(((ICPPASTWhileStatement)whileStatement).getConditionDeclaration());
      whi.expr=ctx.converter.makeInfixFromDecl(whi.decl.name,whi.decl.initExpr,tp,true);
      whi.decl.initExpr=ctx.exprEvaluator.makeSimpleCreationExpression(tp);
    }
  }
 else   if (statement instanceof ICPPASTTryBlockStatement) {
  }
 else   if (statement != null) {
    MyLogger.logImportant(statement.getClass().getCanonicalName());
  }
  if (stmts.isEmpty())   stmts.add(new MEmptyStmt());
  return stmts;
}","/** 
 * Attempts to convert the given C++ statement to one or more Java statements.
 */
List<MStmt> evalStmt(IASTStatement statement) throws DOMException {
  List<MStmt> stmts=new ArrayList<MStmt>();
  if (statement instanceof IASTBreakStatement) {
    MyLogger.log(""String_Node_Str"");
    Integer temp=ctx.stackMngr.findLastSwitchOrLoopId();
    MBreakStmt brk=new MBreakStmt();
    stmts.add(brk);
    if (temp != null)     brk.cleanup=ctx.stackMngr.createCleanupCall(temp);
  }
 else   if (statement instanceof IASTCaseStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTCaseStatement caseStatement=(IASTCaseStatement)statement;
    MCaseStmt cs=new MCaseStmt();
    stmts.add(cs);
    cs.expr=ctx.exprEvaluator.eval1Expr(caseStatement.getExpression());
  }
 else   if (statement instanceof IASTContinueStatement) {
    MyLogger.log(""String_Node_Str"");
    Integer temp=ctx.stackMngr.findLastLoopId();
    MContinueStmt con=new MContinueStmt();
    stmts.add(con);
    if (temp != null)     con.cleanup=ctx.stackMngr.createCleanupCall(temp);
  }
 else   if (statement instanceof IASTDefaultStatement) {
    MyLogger.log(""String_Node_Str"");
    MDefaultStmt def=new MDefaultStmt();
    stmts.add(def);
  }
 else   if (statement instanceof IASTGotoStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTGotoStatement gotoStatement=(IASTGotoStatement)statement;
    MGotoStmt go=new MGotoStmt();
    stmts.add(go);
    go.lbl=gotoStatement.getName().toString();
  }
 else   if (statement instanceof IASTNullStatement) {
    MyLogger.log(""String_Node_Str"");
    MEmptyStmt empty=new MEmptyStmt();
    stmts.add(empty);
  }
 else   if (statement instanceof IASTProblemStatement) {
    IASTProblemStatement probStatement=(IASTProblemStatement)statement;
    MyLogger.log(""String_Node_Str"" + probStatement.getProblem().getMessageWithLocation());
    MProblemStmt prob=new MProblemStmt();
    stmts.add(prob);
    prob.problem=probStatement.getProblem().getMessageWithLocation();
  }
 else   if (statement instanceof IASTCompoundStatement) {
    IASTCompoundStatement compoundStatement=(IASTCompoundStatement)statement;
    MyLogger.log(""String_Node_Str"");
    ctx.stackMngr.startNewCompoundStmt(false,false);
    MCompoundStmt compound=new MCompoundStmt();
    stmts.add(compound);
    for (    IASTStatement s : compoundStatement.getStatements())     compound.statements.addAll(evalStmt(s));
    Integer idToCleanTo=ctx.stackMngr.endCompoundStmt();
    if (idToCleanTo != null && !compound.statements.isEmpty() && !isTerminatingStatement(compound.statements.get(compound.statements.size() - 1))) {
      compound.cleanup=ctx.stackMngr.createCleanupCall(idToCleanTo);
    }
  }
 else   if (statement instanceof IASTDeclarationStatement) {
    IASTDeclarationStatement declarationStatement=(IASTDeclarationStatement)statement;
    MyLogger.log(""String_Node_Str"");
    List<String> types=ctx.converter.evaluateDeclarationReturnTypes(declarationStatement.getDeclaration());
    List<String> names=ctx.converter.evaluateDeclarationReturnNames(declarationStatement.getDeclaration());
    List<MExpression> exprs=ctx.converter.evaluateDeclarationReturnInitializers((IASTSimpleDeclaration)declarationStatement.getDeclaration(),InitType.WRAPPED);
    for (int i=0; i < types.size(); i++) {
      MSimpleDecl simple=new MSimpleDecl();
      simple.type=types.get(i);
      simple.name=names.get(i);
      simple.initExpr=exprs.get(i);
      MDeclarationStmt stmt=new MDeclarationStmt();
      stmt.simple=simple;
      stmts.add(stmt);
    }
  }
 else   if (statement instanceof IASTDoStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTDoStatement doStatement=(IASTDoStatement)statement;
    MDoStmt dos=new MDoStmt();
    stmts.add(dos);
    dos.body=surround(evalStmt(doStatement.getBody()));
    dos.expr=ctx.exprEvaluator.eval1Expr(doStatement.getCondition());
    dos.expr=ExpressionHelpers.makeExpressionBoolean(dos.expr,doStatement.getCondition());
  }
 else   if (statement instanceof IASTExpressionStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTExpressionStatement expressionStatement=(IASTExpressionStatement)statement;
    MExprStmt exprStmt=new MExprStmt();
    stmts.add(exprStmt);
    exprStmt.expr=ctx.exprEvaluator.eval1Expr(expressionStatement.getExpression());
  }
 else   if (statement instanceof IASTForStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTForStatement forStatement=(IASTForStatement)statement;
    MForStmt fs=new MForStmt();
    stmts.add(fs);
    if (forStatement.getInitializerStatement() != null)     fs.initializer=eval1Stmt(forStatement.getInitializerStatement());
    if (forStatement.getConditionExpression() != null) {
      fs.condition=ctx.exprEvaluator.eval1Expr(forStatement.getConditionExpression());
      fs.condition=ExpressionHelpers.makeExpressionBoolean(fs.condition,forStatement.getConditionExpression());
    }
    if (forStatement.getIterationExpression() != null)     fs.updater=ctx.exprEvaluator.eval1Expr(forStatement.getIterationExpression());
    fs.body=surround(evalStmt(forStatement.getBody()));
    if (forStatement instanceof ICPPASTForStatement && ((ICPPASTForStatement)forStatement).getConditionDeclaration() != null) {
      IType tp=ctx.converter.eval1DeclReturnCppType(((ICPPASTForStatement)forStatement).getConditionDeclaration());
      fs.decl=ctx.converter.eval1Decl(((ICPPASTForStatement)forStatement).getConditionDeclaration(),InitType.RAW);
      fs.condition=ctx.converter.makeInfixFromDecl(fs.decl.name,fs.decl.initExpr,tp,true);
      fs.decl.initExpr=ctx.exprEvaluator.makeSimpleCreationExpression(tp);
    }
  }
 else   if (statement instanceof IASTIfStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTIfStatement ifStatement=(IASTIfStatement)statement;
    MIfStmt ifs=new MIfStmt();
    stmts.add(ifs);
    if (ifStatement.getConditionExpression() != null) {
      ifs.condition=ctx.exprEvaluator.eval1Expr(ifStatement.getConditionExpression());
      ifs.condition=ExpressionHelpers.makeExpressionBoolean(ifs.condition,ifStatement.getConditionExpression());
    }
    ifs.body=surround(evalStmt(ifStatement.getThenClause()));
    if (ifStatement.getElseClause() != null)     ifs.elseBody=eval1Stmt(ifStatement.getElseClause());
    if (ifStatement instanceof ICPPASTIfStatement && ((ICPPASTIfStatement)ifStatement).getConditionDeclaration() != null) {
      IType tp=ctx.converter.eval1DeclReturnCppType(((ICPPASTIfStatement)ifStatement).getConditionDeclaration());
      ifs.decl=ctx.converter.eval1Decl(((ICPPASTIfStatement)ifStatement).getConditionDeclaration(),InitType.RAW);
      ifs.condition=ctx.converter.makeInfixFromDecl(ifs.decl.name,ifs.decl.initExpr,tp,true);
      ifs.decl.initExpr=ctx.exprEvaluator.makeSimpleCreationExpression(tp);
    }
  }
 else   if (statement instanceof IASTLabelStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTLabelStatement labelStatement=(IASTLabelStatement)statement;
    MLabelStmt lbl=new MLabelStmt();
    stmts.add(lbl);
    lbl.lbl=labelStatement.getName().toString();
    lbl.body=eval1Stmt(labelStatement.getNestedStatement());
  }
 else   if (statement instanceof IASTReturnStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTReturnStatement returnStatement=(IASTReturnStatement)statement;
    MReturnStmt retu=new MReturnStmt();
    stmts.add(retu);
    retu.expr=ctx.exprEvaluator.wrapIfNeeded(returnStatement.getReturnValue(),ctx.currentReturnType);
    if (ctx.stackMngr.getLocalVariableId() != 0 && TypeManager.isOneOf(ctx.currentReturnType,TypeEnum.VOID)) {
      retu.cleanup=ctx.stackMngr.createCleanupCall(0);
    }
 else     if (ctx.stackMngr.getLocalVariableId() != 0) {
      retu.expr=ctx.stackMngr.wrapCleanupCall(retu.expr);
    }
  }
 else   if (statement instanceof IASTSwitchStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTSwitchStatement switchStatement=(IASTSwitchStatement)statement;
    MSwitchStmt swi=new MSwitchStmt();
    stmts.add(swi);
    swi.body=surround(evalStmt(switchStatement.getBody()));
    if (switchStatement.getControllerExpression() != null) {
      swi.expr=ctx.exprEvaluator.eval1Expr(switchStatement.getControllerExpression());
    }
    if (switchStatement instanceof ICPPASTSwitchStatement && ((ICPPASTSwitchStatement)switchStatement).getControllerDeclaration() != null) {
      IType tp=ctx.converter.eval1DeclReturnCppType(((ICPPASTSwitchStatement)switchStatement).getControllerDeclaration());
      swi.decl=ctx.converter.eval1Decl(((ICPPASTSwitchStatement)switchStatement).getControllerDeclaration(),InitType.RAW);
      swi.expr=ctx.converter.makeInfixFromDecl(swi.decl.name,swi.decl.initExpr,tp,false);
      swi.decl.initExpr=ctx.exprEvaluator.makeSimpleCreationExpression(tp);
    }
  }
 else   if (statement instanceof IASTWhileStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTWhileStatement whileStatement=(IASTWhileStatement)statement;
    MWhileStmt whi=new MWhileStmt();
    stmts.add(whi);
    whi.body=surround(evalStmt(whileStatement.getBody()));
    if (whileStatement.getCondition() != null) {
      whi.expr=ctx.exprEvaluator.eval1Expr(whileStatement.getCondition());
      whi.expr=ExpressionHelpers.makeExpressionBoolean(whi.expr,whileStatement.getCondition());
    }
    if (whileStatement instanceof ICPPASTWhileStatement && ((ICPPASTWhileStatement)whileStatement).getConditionDeclaration() != null) {
      IType tp=ctx.converter.eval1DeclReturnCppType(((ICPPASTWhileStatement)whileStatement).getConditionDeclaration());
      whi.decl=ctx.converter.eval1Decl(((ICPPASTWhileStatement)whileStatement).getConditionDeclaration(),InitType.RAW);
      whi.expr=ctx.converter.makeInfixFromDecl(whi.decl.name,whi.decl.initExpr,tp,true);
      whi.decl.initExpr=ctx.exprEvaluator.makeSimpleCreationExpression(tp);
    }
  }
 else   if (statement instanceof ICPPASTTryBlockStatement) {
  }
 else   if (statement != null) {
    MyLogger.logImportant(statement.getClass().getCanonicalName());
  }
  if (stmts.isEmpty())   stmts.add(new MEmptyStmt());
  return stmts;
}"
50096,"static TypeEnum expressionGetType(IASTExpression expr) throws DOMException {
  return TypeHelpers.getTypeEnum(expr.getExpressionType());
}","static TypeEnum expressionGetType(IASTExpression expr) throws DOMException {
  if (expr == null) {
    MyLogger.logImportant(""String_Node_Str"");
    MyLogger.exitOnError();
  }
 else   if (expr.getExpressionType() == null) {
    MyLogger.logImportant(""String_Node_Str"" + expr.getRawSignature());
    MyLogger.exitOnError();
  }
  return TypeHelpers.getTypeEnum(expr.getExpressionType());
}"
50097,"static void log(String msg){
  System.out.println(msg);
}","static void log(String msg){
}"
50098,"static void exitOnError(){
  System.exit(-1);
}","static void exitOnError(){
  try {
    throw new RuntimeException();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    System.exit(-1);
  }
}"
50099,"/** 
 * Attempts to convert the given C++ statement to one or more Java statements.
 */
List<MStmt> evalStmt(IASTStatement statement) throws DOMException {
  List<MStmt> stmts=new ArrayList<MStmt>();
  if (statement instanceof IASTBreakStatement) {
    MyLogger.log(""String_Node_Str"");
    Integer temp=ctx.stackMngr.findLastSwitchOrLoopId();
    MBreakStmt brk=new MBreakStmt();
    stmts.add(brk);
    if (temp != null)     brk.cleanup=ctx.stackMngr.createCleanupCall(temp);
  }
 else   if (statement instanceof IASTCaseStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTCaseStatement caseStatement=(IASTCaseStatement)statement;
    MCaseStmt cs=new MCaseStmt();
    stmts.add(cs);
    cs.expr=ctx.exprEvaluator.eval1Expr(caseStatement.getExpression());
  }
 else   if (statement instanceof IASTContinueStatement) {
    MyLogger.log(""String_Node_Str"");
    Integer temp=ctx.stackMngr.findLastLoopId();
    MContinueStmt con=new MContinueStmt();
    stmts.add(con);
    if (temp != null)     con.cleanup=ctx.stackMngr.createCleanupCall(temp);
  }
 else   if (statement instanceof IASTDefaultStatement) {
    MyLogger.log(""String_Node_Str"");
    MDefaultStmt def=new MDefaultStmt();
    stmts.add(def);
  }
 else   if (statement instanceof IASTGotoStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTGotoStatement gotoStatement=(IASTGotoStatement)statement;
    MGotoStmt go=new MGotoStmt();
    stmts.add(go);
    go.lbl=gotoStatement.getName().toString();
  }
 else   if (statement instanceof IASTNullStatement) {
    MyLogger.log(""String_Node_Str"");
    MEmptyStmt empty=new MEmptyStmt();
    stmts.add(empty);
  }
 else   if (statement instanceof IASTProblemStatement) {
    IASTProblemStatement probStatement=(IASTProblemStatement)statement;
    MyLogger.log(""String_Node_Str"" + probStatement.getProblem().getMessageWithLocation());
    MProblemStmt prob=new MProblemStmt();
    stmts.add(prob);
    prob.problem=probStatement.getProblem().getMessageWithLocation();
  }
 else   if (statement instanceof IASTCompoundStatement) {
    IASTCompoundStatement compoundStatement=(IASTCompoundStatement)statement;
    MyLogger.log(""String_Node_Str"");
    ctx.stackMngr.startNewCompoundStmt(false,false);
    MCompoundStmt compound=new MCompoundStmt();
    stmts.add(compound);
    for (    IASTStatement s : compoundStatement.getStatements())     compound.statements.add(eval1Stmt(s));
    Integer idToCleanTo=ctx.stackMngr.endCompoundStmt();
    if (idToCleanTo != null && !compound.statements.isEmpty() && !isTerminatingStatement(compound.statements.get(compound.statements.size() - 1))) {
      compound.cleanup=ctx.stackMngr.createCleanupCall(idToCleanTo);
    }
  }
 else   if (statement instanceof IASTDeclarationStatement) {
    IASTDeclarationStatement declarationStatement=(IASTDeclarationStatement)statement;
    MyLogger.log(""String_Node_Str"");
    List<String> types=ctx.converter.evaluateDeclarationReturnTypes(declarationStatement.getDeclaration());
    List<String> names=ctx.converter.evaluateDeclarationReturnNames(declarationStatement.getDeclaration());
    List<MExpression> exprs=ctx.converter.evaluateDeclarationReturnInitializers((IASTSimpleDeclaration)declarationStatement.getDeclaration());
    for (int i=0; i < types.size(); i++) {
      MSimpleDecl simple=new MSimpleDecl();
      simple.type=types.get(i);
      simple.name=names.get(i);
      simple.initExpr=exprs.get(i);
      MDeclarationStmt stmt=new MDeclarationStmt();
      stmt.simple=simple;
      stmts.add(stmt);
    }
  }
 else   if (statement instanceof IASTDoStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTDoStatement doStatement=(IASTDoStatement)statement;
    MDoStmt dos=new MDoStmt();
    stmts.add(dos);
    dos.body=surround(evalStmt(doStatement.getBody()));
    dos.expr=ctx.exprEvaluator.eval1Expr(doStatement.getCondition());
    dos.expr=ExpressionHelpers.makeExpressionBoolean(dos.expr,doStatement.getCondition());
  }
 else   if (statement instanceof IASTExpressionStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTExpressionStatement expressionStatement=(IASTExpressionStatement)statement;
    MExprStmt exprStmt=new MExprStmt();
    stmts.add(exprStmt);
    exprStmt.expr=ctx.exprEvaluator.eval1Expr(expressionStatement.getExpression());
  }
 else   if (statement instanceof IASTForStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTForStatement forStatement=(IASTForStatement)statement;
    MForStmt fs=new MForStmt();
    stmts.add(fs);
    if (forStatement.getInitializerStatement() != null)     fs.initializer=eval1Stmt(forStatement.getInitializerStatement());
    if (forStatement.getConditionExpression() != null) {
      fs.condition=ctx.exprEvaluator.eval1Expr(forStatement.getConditionExpression());
      fs.condition=ExpressionHelpers.makeExpressionBoolean(fs.condition,forStatement.getConditionExpression());
    }
    if (forStatement.getIterationExpression() != null)     fs.updater=ctx.exprEvaluator.eval1Expr(forStatement.getIterationExpression());
    fs.body=surround(evalStmt(forStatement.getBody()));
    if (forStatement instanceof ICPPASTForStatement && ((ICPPASTForStatement)forStatement).getConditionDeclaration() != null) {
      IType tp=ctx.converter.eval1DeclReturnCppType(((ICPPASTForStatement)forStatement).getConditionDeclaration());
      fs.decl=ctx.converter.eval1Decl(((ICPPASTForStatement)forStatement).getConditionDeclaration());
      fs.condition=ctx.converter.makeInfixFromDecl(fs.decl.name,fs.decl.initExpr,tp,true);
      fs.decl.initExpr=ExpressionHelpers.makeSimpleCreationExpression(tp);
    }
  }
 else   if (statement instanceof IASTIfStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTIfStatement ifStatement=(IASTIfStatement)statement;
    MIfStmt ifs=new MIfStmt();
    stmts.add(ifs);
    ifs.condition=ctx.exprEvaluator.eval1Expr(ifStatement.getConditionExpression());
    ifs.condition=ExpressionHelpers.makeExpressionBoolean(ifs.condition,ifStatement.getConditionExpression());
    ifs.body=surround(evalStmt(ifStatement.getThenClause()));
    if (ifStatement.getElseClause() != null)     ifs.elseBody=eval1Stmt(ifStatement.getElseClause());
    if (ifStatement instanceof ICPPASTIfStatement && ((ICPPASTIfStatement)ifStatement).getConditionDeclaration() != null) {
      IType tp=ctx.converter.eval1DeclReturnCppType(((ICPPASTIfStatement)ifStatement).getConditionDeclaration());
      ifs.decl=ctx.converter.eval1Decl(((ICPPASTIfStatement)ifStatement).getConditionDeclaration());
      ifs.condition=ctx.converter.makeInfixFromDecl(ifs.decl.name,ifs.decl.initExpr,tp,true);
      ifs.decl.initExpr=ExpressionHelpers.makeSimpleCreationExpression(tp);
    }
  }
 else   if (statement instanceof IASTLabelStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTLabelStatement labelStatement=(IASTLabelStatement)statement;
    MLabelStmt lbl=new MLabelStmt();
    stmts.add(lbl);
    lbl.lbl=labelStatement.getName().toString();
    lbl.body=eval1Stmt(labelStatement.getNestedStatement());
  }
 else   if (statement instanceof IASTReturnStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTReturnStatement returnStatement=(IASTReturnStatement)statement;
    MReturnStmt retu=new MReturnStmt();
    stmts.add(retu);
    if (ExpressionHelpers.isNumberExpression(returnStatement.getReturnValue())) {
      MValueOfExpressionNumber valOfExpr=new MValueOfExpressionNumber();
      valOfExpr.type=""String_Node_Str"";
      valOfExpr.operand=ctx.exprEvaluator.eval1Expr(returnStatement.getReturnValue());
      retu.expr=valOfExpr;
    }
 else {
      retu.expr=ctx.exprEvaluator.eval1Expr(returnStatement.getReturnValue());
      retu.expr=ctx.converter.callCopyIfNeeded(retu.expr,returnStatement.getReturnValue());
    }
    if (ctx.stackMngr.getLocalVariableId() != 0)     retu.cleanup=ctx.stackMngr.createCleanupCall(0);
  }
 else   if (statement instanceof IASTSwitchStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTSwitchStatement switchStatement=(IASTSwitchStatement)statement;
    MSwitchStmt swi=new MSwitchStmt();
    stmts.add(swi);
    swi.body=surround(evalStmt(switchStatement.getBody()));
    swi.expr=ctx.exprEvaluator.eval1Expr(switchStatement.getControllerExpression());
    if (switchStatement instanceof ICPPASTSwitchStatement && ((ICPPASTSwitchStatement)switchStatement).getControllerDeclaration() != null) {
      IType tp=ctx.converter.eval1DeclReturnCppType(((ICPPASTSwitchStatement)switchStatement).getControllerDeclaration());
      swi.decl=ctx.converter.eval1Decl(((ICPPASTSwitchStatement)switchStatement).getControllerDeclaration());
      swi.expr=ctx.converter.makeInfixFromDecl(swi.decl.name,swi.decl.initExpr,tp,false);
      swi.decl.initExpr=ExpressionHelpers.makeSimpleCreationExpression(tp);
    }
  }
 else   if (statement instanceof IASTWhileStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTWhileStatement whileStatement=(IASTWhileStatement)statement;
    MWhileStmt whi=new MWhileStmt();
    stmts.add(whi);
    whi.body=surround(evalStmt(whileStatement.getBody()));
    whi.expr=ctx.exprEvaluator.eval1Expr(whileStatement.getCondition());
    whi.expr=ExpressionHelpers.makeExpressionBoolean(whi.expr,whileStatement.getCondition());
    if (whileStatement instanceof ICPPASTWhileStatement && ((ICPPASTWhileStatement)whileStatement).getConditionDeclaration() != null) {
      IType tp=ctx.converter.eval1DeclReturnCppType(((ICPPASTWhileStatement)whileStatement).getConditionDeclaration());
      whi.decl=ctx.converter.eval1Decl(((ICPPASTWhileStatement)whileStatement).getConditionDeclaration());
      whi.expr=ctx.converter.makeInfixFromDecl(whi.decl.name,whi.decl.initExpr,tp,true);
      whi.decl.initExpr=ExpressionHelpers.makeSimpleCreationExpression(tp);
    }
  }
 else   if (statement instanceof ICPPASTTryBlockStatement) {
  }
 else   if (statement != null) {
    MyLogger.logImportant(statement.getClass().getCanonicalName());
  }
  if (stmts.isEmpty())   stmts.add(new MEmptyStmt());
  return stmts;
}","/** 
 * Attempts to convert the given C++ statement to one or more Java statements.
 */
List<MStmt> evalStmt(IASTStatement statement) throws DOMException {
  List<MStmt> stmts=new ArrayList<MStmt>();
  if (statement instanceof IASTBreakStatement) {
    MyLogger.log(""String_Node_Str"");
    Integer temp=ctx.stackMngr.findLastSwitchOrLoopId();
    MBreakStmt brk=new MBreakStmt();
    stmts.add(brk);
    if (temp != null)     brk.cleanup=ctx.stackMngr.createCleanupCall(temp);
  }
 else   if (statement instanceof IASTCaseStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTCaseStatement caseStatement=(IASTCaseStatement)statement;
    MCaseStmt cs=new MCaseStmt();
    stmts.add(cs);
    cs.expr=ctx.exprEvaluator.eval1Expr(caseStatement.getExpression());
  }
 else   if (statement instanceof IASTContinueStatement) {
    MyLogger.log(""String_Node_Str"");
    Integer temp=ctx.stackMngr.findLastLoopId();
    MContinueStmt con=new MContinueStmt();
    stmts.add(con);
    if (temp != null)     con.cleanup=ctx.stackMngr.createCleanupCall(temp);
  }
 else   if (statement instanceof IASTDefaultStatement) {
    MyLogger.log(""String_Node_Str"");
    MDefaultStmt def=new MDefaultStmt();
    stmts.add(def);
  }
 else   if (statement instanceof IASTGotoStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTGotoStatement gotoStatement=(IASTGotoStatement)statement;
    MGotoStmt go=new MGotoStmt();
    stmts.add(go);
    go.lbl=gotoStatement.getName().toString();
  }
 else   if (statement instanceof IASTNullStatement) {
    MyLogger.log(""String_Node_Str"");
    MEmptyStmt empty=new MEmptyStmt();
    stmts.add(empty);
  }
 else   if (statement instanceof IASTProblemStatement) {
    IASTProblemStatement probStatement=(IASTProblemStatement)statement;
    MyLogger.log(""String_Node_Str"" + probStatement.getProblem().getMessageWithLocation());
    MProblemStmt prob=new MProblemStmt();
    stmts.add(prob);
    prob.problem=probStatement.getProblem().getMessageWithLocation();
  }
 else   if (statement instanceof IASTCompoundStatement) {
    IASTCompoundStatement compoundStatement=(IASTCompoundStatement)statement;
    MyLogger.log(""String_Node_Str"");
    ctx.stackMngr.startNewCompoundStmt(false,false);
    MCompoundStmt compound=new MCompoundStmt();
    stmts.add(compound);
    for (    IASTStatement s : compoundStatement.getStatements())     compound.statements.add(eval1Stmt(s));
    Integer idToCleanTo=ctx.stackMngr.endCompoundStmt();
    if (idToCleanTo != null && !compound.statements.isEmpty() && !isTerminatingStatement(compound.statements.get(compound.statements.size() - 1))) {
      compound.cleanup=ctx.stackMngr.createCleanupCall(idToCleanTo);
    }
  }
 else   if (statement instanceof IASTDeclarationStatement) {
    IASTDeclarationStatement declarationStatement=(IASTDeclarationStatement)statement;
    MyLogger.log(""String_Node_Str"");
    List<String> types=ctx.converter.evaluateDeclarationReturnTypes(declarationStatement.getDeclaration());
    List<String> names=ctx.converter.evaluateDeclarationReturnNames(declarationStatement.getDeclaration());
    List<MExpression> exprs=ctx.converter.evaluateDeclarationReturnInitializers((IASTSimpleDeclaration)declarationStatement.getDeclaration());
    for (int i=0; i < types.size(); i++) {
      MSimpleDecl simple=new MSimpleDecl();
      simple.type=types.get(i);
      simple.name=names.get(i);
      simple.initExpr=exprs.get(i);
      MDeclarationStmt stmt=new MDeclarationStmt();
      stmt.simple=simple;
      stmts.add(stmt);
    }
  }
 else   if (statement instanceof IASTDoStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTDoStatement doStatement=(IASTDoStatement)statement;
    MDoStmt dos=new MDoStmt();
    stmts.add(dos);
    dos.body=surround(evalStmt(doStatement.getBody()));
    dos.expr=ctx.exprEvaluator.eval1Expr(doStatement.getCondition());
    dos.expr=ExpressionHelpers.makeExpressionBoolean(dos.expr,doStatement.getCondition());
  }
 else   if (statement instanceof IASTExpressionStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTExpressionStatement expressionStatement=(IASTExpressionStatement)statement;
    MExprStmt exprStmt=new MExprStmt();
    stmts.add(exprStmt);
    exprStmt.expr=ctx.exprEvaluator.eval1Expr(expressionStatement.getExpression());
  }
 else   if (statement instanceof IASTForStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTForStatement forStatement=(IASTForStatement)statement;
    MForStmt fs=new MForStmt();
    stmts.add(fs);
    if (forStatement.getInitializerStatement() != null)     fs.initializer=eval1Stmt(forStatement.getInitializerStatement());
    if (forStatement.getConditionExpression() != null) {
      fs.condition=ctx.exprEvaluator.eval1Expr(forStatement.getConditionExpression());
      fs.condition=ExpressionHelpers.makeExpressionBoolean(fs.condition,forStatement.getConditionExpression());
    }
    if (forStatement.getIterationExpression() != null)     fs.updater=ctx.exprEvaluator.eval1Expr(forStatement.getIterationExpression());
    fs.body=surround(evalStmt(forStatement.getBody()));
    if (forStatement instanceof ICPPASTForStatement && ((ICPPASTForStatement)forStatement).getConditionDeclaration() != null) {
      IType tp=ctx.converter.eval1DeclReturnCppType(((ICPPASTForStatement)forStatement).getConditionDeclaration());
      fs.decl=ctx.converter.eval1Decl(((ICPPASTForStatement)forStatement).getConditionDeclaration());
      fs.condition=ctx.converter.makeInfixFromDecl(fs.decl.name,fs.decl.initExpr,tp,true);
      fs.decl.initExpr=ExpressionHelpers.makeSimpleCreationExpression(tp);
    }
  }
 else   if (statement instanceof IASTIfStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTIfStatement ifStatement=(IASTIfStatement)statement;
    MIfStmt ifs=new MIfStmt();
    stmts.add(ifs);
    if (ifStatement.getConditionExpression() != null) {
      ifs.condition=ctx.exprEvaluator.eval1Expr(ifStatement.getConditionExpression());
      ifs.condition=ExpressionHelpers.makeExpressionBoolean(ifs.condition,ifStatement.getConditionExpression());
    }
    ifs.body=surround(evalStmt(ifStatement.getThenClause()));
    if (ifStatement.getElseClause() != null)     ifs.elseBody=eval1Stmt(ifStatement.getElseClause());
    if (ifStatement instanceof ICPPASTIfStatement && ((ICPPASTIfStatement)ifStatement).getConditionDeclaration() != null) {
      IType tp=ctx.converter.eval1DeclReturnCppType(((ICPPASTIfStatement)ifStatement).getConditionDeclaration());
      ifs.decl=ctx.converter.eval1Decl(((ICPPASTIfStatement)ifStatement).getConditionDeclaration());
      ifs.condition=ctx.converter.makeInfixFromDecl(ifs.decl.name,ifs.decl.initExpr,tp,true);
      ifs.decl.initExpr=ExpressionHelpers.makeSimpleCreationExpression(tp);
    }
  }
 else   if (statement instanceof IASTLabelStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTLabelStatement labelStatement=(IASTLabelStatement)statement;
    MLabelStmt lbl=new MLabelStmt();
    stmts.add(lbl);
    lbl.lbl=labelStatement.getName().toString();
    lbl.body=eval1Stmt(labelStatement.getNestedStatement());
  }
 else   if (statement instanceof IASTReturnStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTReturnStatement returnStatement=(IASTReturnStatement)statement;
    MReturnStmt retu=new MReturnStmt();
    stmts.add(retu);
    if (ExpressionHelpers.isNumberExpression(returnStatement.getReturnValue())) {
      MValueOfExpressionNumber valOfExpr=new MValueOfExpressionNumber();
      valOfExpr.type=""String_Node_Str"";
      valOfExpr.operand=ctx.exprEvaluator.eval1Expr(returnStatement.getReturnValue());
      retu.expr=valOfExpr;
    }
 else {
      retu.expr=ctx.exprEvaluator.eval1Expr(returnStatement.getReturnValue());
      retu.expr=ctx.converter.callCopyIfNeeded(retu.expr,returnStatement.getReturnValue());
    }
    if (ctx.stackMngr.getLocalVariableId() != 0)     retu.cleanup=ctx.stackMngr.createCleanupCall(0);
  }
 else   if (statement instanceof IASTSwitchStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTSwitchStatement switchStatement=(IASTSwitchStatement)statement;
    MSwitchStmt swi=new MSwitchStmt();
    stmts.add(swi);
    swi.body=surround(evalStmt(switchStatement.getBody()));
    if (switchStatement.getControllerExpression() != null) {
      swi.expr=ctx.exprEvaluator.eval1Expr(switchStatement.getControllerExpression());
    }
    if (switchStatement instanceof ICPPASTSwitchStatement && ((ICPPASTSwitchStatement)switchStatement).getControllerDeclaration() != null) {
      IType tp=ctx.converter.eval1DeclReturnCppType(((ICPPASTSwitchStatement)switchStatement).getControllerDeclaration());
      swi.decl=ctx.converter.eval1Decl(((ICPPASTSwitchStatement)switchStatement).getControllerDeclaration());
      swi.expr=ctx.converter.makeInfixFromDecl(swi.decl.name,swi.decl.initExpr,tp,false);
      swi.decl.initExpr=ExpressionHelpers.makeSimpleCreationExpression(tp);
    }
  }
 else   if (statement instanceof IASTWhileStatement) {
    MyLogger.log(""String_Node_Str"");
    IASTWhileStatement whileStatement=(IASTWhileStatement)statement;
    MWhileStmt whi=new MWhileStmt();
    stmts.add(whi);
    whi.body=surround(evalStmt(whileStatement.getBody()));
    if (whileStatement.getCondition() != null) {
      whi.expr=ctx.exprEvaluator.eval1Expr(whileStatement.getCondition());
      whi.expr=ExpressionHelpers.makeExpressionBoolean(whi.expr,whileStatement.getCondition());
    }
    if (whileStatement instanceof ICPPASTWhileStatement && ((ICPPASTWhileStatement)whileStatement).getConditionDeclaration() != null) {
      IType tp=ctx.converter.eval1DeclReturnCppType(((ICPPASTWhileStatement)whileStatement).getConditionDeclaration());
      whi.decl=ctx.converter.eval1Decl(((ICPPASTWhileStatement)whileStatement).getConditionDeclaration());
      whi.expr=ctx.converter.makeInfixFromDecl(whi.decl.name,whi.decl.initExpr,tp,true);
      whi.decl.initExpr=ExpressionHelpers.makeSimpleCreationExpression(tp);
    }
  }
 else   if (statement instanceof ICPPASTTryBlockStatement) {
  }
 else   if (statement != null) {
    MyLogger.logImportant(statement.getClass().getCanonicalName());
  }
  if (stmts.isEmpty())   stmts.add(new MEmptyStmt());
  return stmts;
}"
50100,"void func5(){
  Object[] __stack=new Object[2];
  int i=0;
  if (true)   i+=5;
  while (false)   i-=10;
  for (i=0; i < 20; i++)   i--;
switch (i) {
case 1:
    return;
case 2:
  i++;
}
if (true) for (; ; ) while (true) ;
for (int k=0; (k < 10) != 0; k++) k*=10;
foo ptr1=new foo();
foo ptr2=new foo(100);
foo ptr3=CreateHelper.allocateArray(foo.class,100);
(ptr1).destruct();
(ptr2).destruct();
DestructHelper.destructArray(ptr3);
int[] basic=new int[100];
short[][] basic2=new short[5][10];
if (false) return;
foo[] foos_array=StackHelper.addItem(CreateHelper.allocateArray(foo.class,45 + 2),0,__stack);
foo[][] foos_array2=StackHelper.addItem(CreateHelper.allocateArray(foo.class,50,20),1,__stack);
PtrInteger p=new int[2];
int r;
StackHelper.cleanup(null,__stack,0);
}","void func5(){
  Object[] __stack=new Object[2];
  int i=0;
  if (true)   i+=5;
  while (false)   i-=10;
  for (i=0; i < 20; i++)   i--;
switch (i) {
case 1:
    return;
case 2:
  i++;
}
if (true) for (; ; ) while (true) ;
for (int k=0; k < 10; k++) k*=10;
foo ptr1=new foo();
foo ptr2=new foo(100);
foo ptr3=CreateHelper.allocateArray(foo.class,100);
(ptr1).destruct();
(ptr2).destruct();
DestructHelper.destructArray(ptr3);
int[] basic=new int[100];
short[][] basic2=new short[5][10];
if (false) return;
foo[] foos_array=StackHelper.addItem(CreateHelper.allocateArray(foo.class,45 + 2),0,__stack);
foo[][] foos_array2=StackHelper.addItem(CreateHelper.allocateArray(foo.class,50,20),1,__stack);
PtrInteger p=new int[2];
int r;
StackHelper.cleanup(null,__stack,0);
}"
50101,"void func6(foo a){
  Object[] __stack=new Object[3];
  func6(new foo(1));
{
    foo foo_bar=StackHelper.addItem(new foo(),0,__stack);
    StackHelper.cleanup(null,__stack,0);
  }
  if (true) {
    foo foo_bar=StackHelper.addItem(new foo(),0,__stack);
    StackHelper.cleanup(null,__stack,0);
  }
  while (true) {
    foo foo_bar=StackHelper.addItem(new foo(),0,__stack);
    StackHelper.cleanup(null,__stack,0);
  }
switch (1) {
case 1:
{
      foo foo_bar=StackHelper.addItem(new foo(),0,__stack);
      StackHelper.cleanup(null,__stack,0);
    }
}
do {
  foo foo_bar=StackHelper.addItem(new foo(),0,__stack);
  StackHelper.cleanup(null,__stack,0);
}
 while (false);
if (true) {
  foo foo_bar=StackHelper.addItem(new foo(),0,__stack);
  while (true) {
    foo foo_baz=StackHelper.addItem(new foo(),1,__stack);
    for (; ; ) {
      foo foo_bug=StackHelper.addItem(new foo(),2,__stack);
      StackHelper.cleanup(null,__stack,2);
    }
    StackHelper.cleanup(null,__stack,1);
  }
  StackHelper.cleanup(null,__stack,0);
}
}","void func6(foo a){
  Object[] __stack=new Object[4];
  func6(StackHelper.addItem(new foo(1),0,__stack));
{
    foo foo_bar=StackHelper.addItem(new foo(),1,__stack);
    StackHelper.cleanup(null,__stack,1);
  }
  if (true) {
    foo foo_bar=StackHelper.addItem(new foo(),1,__stack);
    StackHelper.cleanup(null,__stack,1);
  }
  while (true) {
    foo foo_bar=StackHelper.addItem(new foo(),1,__stack);
    StackHelper.cleanup(null,__stack,1);
  }
switch (1) {
case 1:
{
      foo foo_bar=StackHelper.addItem(new foo(),1,__stack);
      StackHelper.cleanup(null,__stack,1);
    }
}
do {
  foo foo_bar=StackHelper.addItem(new foo(),1,__stack);
  StackHelper.cleanup(null,__stack,1);
}
 while (false);
if (true) {
  foo foo_bar=StackHelper.addItem(new foo(),1,__stack);
  while (true) {
    foo foo_baz=StackHelper.addItem(new foo(),2,__stack);
    for (; ; ) {
      foo foo_bug=StackHelper.addItem(new foo(),3,__stack);
      StackHelper.cleanup(null,__stack,3);
    }
    StackHelper.cleanup(null,__stack,2);
  }
  StackHelper.cleanup(null,__stack,1);
}
StackHelper.cleanup(null,__stack,0);
}"
50102,"void func7(){
  Object[] __stack=new Object[5];
  for (int i=0; i < 10; i++) {
    foo bar=StackHelper.addItem(new foo(),0,__stack);
    if (false) {
      StackHelper.cleanup(null,__stack,0);
      break;
    }
    if (true) {
{
        StackHelper.cleanup(null,__stack,0);
        continue;
      }
      StackHelper.cleanup(null,__stack,1);
    }
    StackHelper.cleanup(null,__stack,0);
  }
  for (int i=0; i < 20; i++) {
    if (true)     break;
 else     continue;
  }
  foo baz=StackHelper.addItem(new foo(),0,__stack);
  foo bug=StackHelper.addItem(new foo(),1,__stack);
  foo dog=StackHelper.addItem(new foo(),2,__stack);
  for (int i=0; i < 5; i++) {
    foo house=StackHelper.addItem(new foo(),3,__stack);
    if (false) {
      foo car=StackHelper.addItem(new foo(),4,__stack);
{
        StackHelper.cleanup(null,__stack,3);
        break;
      }
      StackHelper.cleanup(null,__stack,4);
    }
 else {
      StackHelper.cleanup(null,__stack,3);
      continue;
    }
    StackHelper.cleanup(null,__stack,3);
  }
  while (true) {
    foo honda=StackHelper.addItem(new foo(),3,__stack);
    do {
      foo ferrari=StackHelper.addItem(new foo(),4,__stack);
      if (true) {
        StackHelper.cleanup(null,__stack,4);
        break;
      }
 else {
        StackHelper.cleanup(null,__stack,4);
        continue;
      }
      StackHelper.cleanup(null,__stack,4);
    }
 while (false);
    StackHelper.cleanup(null,__stack,3);
  }
  StackHelper.cleanup(null,__stack,0);
}","void func7(){
  Object[] __stack=new Object[6];
  for (int i=0; i < 10; i++) {
    foo bar=StackHelper.addItem(new foo(),0,__stack);
    if (false)     break;
    if (true) {
      continue;
    }
    StackHelper.cleanup(null,__stack,0);
  }
  for (int i=0; i < 20; i++) {
    if (true)     break;
 else     continue;
  }
  foo baz=StackHelper.addItem(new foo(),0,__stack);
  foo bug=StackHelper.addItem(new foo(),1,__stack);
  foo dog=StackHelper.addItem(new foo(),2,__stack);
  for (int i=0; i < 5; i++) {
    foo house=StackHelper.addItem(new foo(),3,__stack);
    if (false) {
      foo car=StackHelper.addItem(new foo(),4,__stack);
{
        StackHelper.cleanup(null,__stack,3);
        break;
      }
      StackHelper.cleanup(null,__stack,4);
    }
 else {
      StackHelper.cleanup(null,__stack,3);
      continue;
    }
    StackHelper.cleanup(null,__stack,3);
  }
  while (true) {
    foo honda=StackHelper.addItem(new foo(),3,__stack);
    do {
      foo ferrari=StackHelper.addItem(new foo(),4,__stack);
      if (true) {
        StackHelper.cleanup(null,__stack,4);
        break;
      }
 else {
        StackHelper.cleanup(null,__stack,4);
        continue;
      }
      StackHelper.cleanup(null,__stack,4);
    }
 while (false);
    StackHelper.cleanup(null,__stack,3);
  }
  StackHelper.addItem(new foo(1),3,__stack);
  func6(StackHelper.addItem(new foo(),4,__stack));
  StackHelper.addItem(func8(),5,__stack);
  StackHelper.cleanup(null,__stack,0);
}"
50103,"private Expression eval1Expr(IASTExpression expr) throws DOMException {
  List<Expression> exprs=evalExpr(expr);
  assert(exprs.size() == 1);
  return exprs.get(0);
}","private Expression eval1Expr(IASTExpression expr,TypeEnum wanted) throws DOMException {
  List<Expression> exprs=evalExpr(expr,wanted);
  assert(exprs.size() == 1);
  return exprs.get(0);
}"
50104,"/** 
 * Attempts to convert the given C++ statement to one or more Java statements.
 */
private List<Statement> evalStmt(IASTStatement statement) throws DOMException {
  List<Statement> ret=new ArrayList<Statement>();
  if (statement instanceof IASTBreakStatement) {
    print(""String_Node_Str"");
    int temp=findLastLoopId();
    if (m_localVariableId != -1) {
      Block blk=ast.newBlock();
      blk.statements().add(ast.newExpressionStatement(createCleanupCall(temp + 1)));
      blk.statements().add(ast.newBreakStatement());
      ret.add(blk);
    }
 else     ret.add(ast.newBreakStatement());
  }
 else   if (statement instanceof IASTCaseStatement) {
    IASTCaseStatement caseStatement=(IASTCaseStatement)statement;
    print(""String_Node_Str"");
    SwitchCase cs=ast.newSwitchCase();
    cs.setExpression(eval1Expr(caseStatement.getExpression()));
    ret.add(cs);
  }
 else   if (statement instanceof IASTContinueStatement) {
    print(""String_Node_Str"");
    int temp=findLastLoopId();
    if (m_localVariableId != -1) {
      Block blk=ast.newBlock();
      blk.statements().add(ast.newExpressionStatement(createCleanupCall(temp + 1)));
      blk.statements().add(ast.newContinueStatement());
      ret.add(blk);
    }
 else     ret.add(ast.newContinueStatement());
  }
 else   if (statement instanceof IASTDefaultStatement) {
    print(""String_Node_Str"");
    SwitchCase cs=ast.newSwitchCase();
    cs.setExpression(null);
    ret.add(cs);
  }
 else   if (statement instanceof IASTGotoStatement) {
    IASTGotoStatement gotoStatement=(IASTGotoStatement)statement;
    print(""String_Node_Str"");
    getSimpleName(gotoStatement.getName());
  }
 else   if (statement instanceof IASTNullStatement) {
    print(""String_Node_Str"");
    ret.add(ast.newEmptyStatement());
  }
 else   if (statement instanceof IASTProblemStatement) {
    IASTProblemStatement probStatement=(IASTProblemStatement)statement;
    print(""String_Node_Str"" + probStatement.getProblem().getMessageWithLocation());
  }
 else   if (statement instanceof IASTCompoundStatement) {
    IASTCompoundStatement compoundStatement=(IASTCompoundStatement)statement;
    print(""String_Node_Str"");
    m_localVariableStack.push(new StackVar(m_localVariableId,m_isLoop));
    m_isLoop=false;
    Block block=ast.newBlock();
    for (    IASTStatement childStatement : compoundStatement.getStatements())     block.statements().addAll(evalStmt(childStatement));
    block.statements().addAll(stmtQueue);
    stmtQueue.clear();
    int temp=m_localVariableStack.pop().id;
    if (!block.statements().isEmpty() && !(block.statements().get(block.statements().size() - 1) instanceof ReturnStatement) && m_localVariableId != -1) {
      block.statements().add(ast.newExpressionStatement(createCleanupCall(temp + 1)));
    }
    m_localVariableId=temp;
    ret.add(block);
  }
 else   if (statement instanceof IASTDeclarationStatement) {
    IASTDeclarationStatement declarationStatement=(IASTDeclarationStatement)statement;
    print(""String_Node_Str"");
    List<VariableDeclarationFragment> frags=getDeclarationFragments(declarationStatement.getDeclaration());
    List<Type> types=evaluateDeclarationReturnTypes(declarationStatement.getDeclaration());
    for (int i=0; i < types.size(); i++) {
      VariableDeclarationStatement decl=ast.newVariableDeclarationStatement(frags.get(i));
      decl.setType(types.get(i));
      ret.add(decl);
    }
    ret.addAll(stmtQueue);
    stmtQueue.clear();
  }
 else   if (statement instanceof IASTDoStatement) {
    IASTDoStatement doStatement=(IASTDoStatement)statement;
    print(""String_Node_Str"");
    DoStatement dos=ast.newDoStatement();
    m_isLoop=true;
    dos.setBody(eval1Stmt(doStatement.getBody()));
    m_isLoop=false;
    dos.setExpression(evalExpr(doStatement.getCondition(),TypeEnum.BOOLEAN).get(0));
    ret.add(dos);
  }
 else   if (statement instanceof IASTExpressionStatement) {
    IASTExpressionStatement expressionStatement=(IASTExpressionStatement)statement;
    print(""String_Node_Str"");
    ret.add(ast.newExpressionStatement(eval1Expr(expressionStatement.getExpression())));
  }
 else   if (statement instanceof IASTForStatement) {
    IASTForStatement forStatement=(IASTForStatement)statement;
    print(""String_Node_Str"");
    if (forStatement instanceof ICPPASTForStatement)     ;
    ForStatement fs=ast.newForStatement();
    List<Expression> inits=evaluateForInitializer(forStatement.getInitializerStatement());
    Expression expr=evalExpr(forStatement.getConditionExpression(),TypeEnum.BOOLEAN).get(0);
    List<Expression> updaters=evalExpr(forStatement.getIterationExpression());
    if (inits != null)     fs.initializers().addAll(inits);
    if (expr != null)     fs.setExpression(expr);
    if (updaters.get(0) != null)     fs.updaters().addAll(updaters);
    m_isLoop=true;
    fs.setBody(eval1Stmt(forStatement.getBody()));
    m_isLoop=false;
    ret.add(fs);
  }
 else   if (statement instanceof IASTIfStatement) {
    IASTIfStatement ifStatement=(IASTIfStatement)statement;
    print(""String_Node_Str"");
    IfStatement ifs=ast.newIfStatement();
    if (ifStatement instanceof ICPPASTIfStatement && ((ICPPASTIfStatement)ifStatement).getConditionDeclaration() != null) {
      ICPPASTIfStatement cppIf=(ICPPASTIfStatement)ifStatement;
      List<VariableDeclarationFragment> frags=getDeclarationFragments(cppIf.getConditionDeclaration());
      frags.get(0).setInitializer(null);
      VariableDeclarationStatement decl=ast.newVariableDeclarationStatement(frags.get(0));
      Type jType=evaluateDeclarationReturnTypes(cppIf.getConditionDeclaration()).get(0);
      decl.setType(jType);
      ret.add(decl);
      List<Expression> exprs=evaluateDeclarationReturnInitializers(cppIf.getConditionDeclaration());
      Assignment assign=jast.newAssign().left(ast.newSimpleName(frags.get(0).getName().getIdentifier())).right(exprs.get(0)).op(Assignment.Operator.ASSIGN).toAST();
      IASTExpression expr=evalDeclarationReturnFirstInitializerExpression(cppIf.getConditionDeclaration());
      Expression finalExpr=makeExpressionBoolean(assign,expr);
      ifs.setExpression(finalExpr);
    }
 else {
      ifs.setExpression(evalExpr(ifStatement.getConditionExpression(),TypeEnum.BOOLEAN).get(0));
    }
    ifs.setThenStatement(eval1Stmt(ifStatement.getThenClause()));
    List<Statement> elseStmts=evalStmt(ifStatement.getElseClause());
    ifs.setElseStatement(!elseStmts.isEmpty() ? elseStmts.get(0) : null);
    ret.add(ifs);
  }
 else   if (statement instanceof IASTLabelStatement) {
    IASTLabelStatement labelStatement=(IASTLabelStatement)statement;
    print(""String_Node_Str"");
    evalStmt(labelStatement.getNestedStatement());
  }
 else   if (statement instanceof IASTReturnStatement) {
    IASTReturnStatement returnStatement=(IASTReturnStatement)statement;
    print(""String_Node_Str"");
    JASTHelper.Method method=jast.newMethod().on(""String_Node_Str"").call(""String_Node_Str"");
    ReturnStatement ret2=ast.newReturnStatement();
    if (returnStatement.getReturnValue() != null) {
      if (returnStatement.getReturnValue() != null && ((returnStatement.getReturnValue().getExpressionType() instanceof ICompositeType || (returnStatement.getReturnValue().getExpressionType() instanceof IQualifierType && ((IQualifierType)returnStatement.getReturnValue().getExpressionType()).getType() instanceof ICompositeType)) && !(eval1Expr(returnStatement.getReturnValue()) instanceof ClassInstanceCreation))) {
        ClassInstanceCreation create=jast.newClassCreate().type(cppToJavaType(returnStatement.getReturnValue().getExpressionType())).with(eval1Expr(returnStatement.getReturnValue())).toAST();
        if (m_localVariableId != -1)         method.with(create);
 else         ret2.setExpression(create);
      }
 else {
        if (m_localVariableId != -1)         method.with(eval1Expr(returnStatement.getReturnValue()));
 else         ret2.setExpression(eval1Expr(returnStatement.getReturnValue()));
      }
      if (m_localVariableId != -1) {
        method.with(""String_Node_Str"").with(0);
        ret2.setExpression(method.toAST());
      }
      ret.add(ret2);
    }
 else {
      if (m_localVariableId != -1) {
        Block blk=ast.newBlock();
        method.with(ast.newNullLiteral()).with(""String_Node_Str"").with(0);
        blk.statements().add(ast.newExpressionStatement(method.toAST()));
        blk.statements().add(ret2);
        ret.add(blk);
      }
 else       ret.add(ret2);
    }
  }
 else   if (statement instanceof IASTSwitchStatement) {
    IASTSwitchStatement switchStatement=(IASTSwitchStatement)statement;
    print(""String_Node_Str"");
    SwitchStatement swt=ast.newSwitchStatement();
    if (switchStatement instanceof ICPPASTSwitchStatement && ((ICPPASTSwitchStatement)switchStatement).getControllerDeclaration() != null) {
      ICPPASTSwitchStatement cppSwitch=(ICPPASTSwitchStatement)switchStatement;
      List<VariableDeclarationFragment> frags=getDeclarationFragments(cppSwitch.getControllerDeclaration());
      frags.get(0).setInitializer(null);
      VariableDeclarationStatement decl=ast.newVariableDeclarationStatement(frags.get(0));
      Type jType=evaluateDeclarationReturnTypes(cppSwitch.getControllerDeclaration()).get(0);
      decl.setType(jType);
      ret.add(decl);
      List<Expression> exprs=evaluateDeclarationReturnInitializers(cppSwitch.getControllerDeclaration());
      Assignment assign=jast.newAssign().left(ast.newSimpleName(frags.get(0).getName().getIdentifier())).right(exprs.get(0)).op(Assignment.Operator.ASSIGN).toAST();
      swt.setExpression(assign);
    }
 else {
      swt.setExpression(evalExpr(switchStatement.getControllerExpression()).get(0));
    }
    if (switchStatement.getBody() instanceof IASTCompoundStatement) {
      IASTCompoundStatement compound=(IASTCompoundStatement)switchStatement.getBody();
      for (      IASTStatement stmt : compound.getStatements()) {
        swt.statements().addAll(evalStmt(stmt));
      }
    }
 else {
      swt.statements().addAll(evalStmt(switchStatement.getBody()));
    }
    ret.add(swt);
  }
 else   if (statement instanceof IASTWhileStatement) {
    IASTWhileStatement whileStatement=(IASTWhileStatement)statement;
    print(""String_Node_Str"");
    WhileStatement whs=ast.newWhileStatement();
    if (whileStatement instanceof ICPPASTWhileStatement && ((ICPPASTWhileStatement)whileStatement).getConditionDeclaration() != null) {
      ICPPASTWhileStatement cppWhile=(ICPPASTWhileStatement)whileStatement;
      List<VariableDeclarationFragment> frags=getDeclarationFragments(cppWhile.getConditionDeclaration());
      frags.get(0).setInitializer(null);
      VariableDeclarationStatement decl=ast.newVariableDeclarationStatement(frags.get(0));
      Type jType=evaluateDeclarationReturnTypes(cppWhile.getConditionDeclaration()).get(0);
      decl.setType(jType);
      ret.add(decl);
      List<Expression> exprs=evaluateDeclarationReturnInitializers(cppWhile.getConditionDeclaration());
      Assignment assign=jast.newAssign().left(ast.newSimpleName(frags.get(0).getName().getIdentifier())).right(exprs.get(0)).op(Assignment.Operator.ASSIGN).toAST();
      IASTExpression expr=evalDeclarationReturnFirstInitializerExpression(cppWhile.getConditionDeclaration());
      Expression finalExpr=makeExpressionBoolean(assign,expr);
      whs.setExpression(finalExpr);
    }
 else {
      whs.setExpression(evalExpr(whileStatement.getCondition(),TypeEnum.BOOLEAN).get(0));
    }
    whs.setBody(evalStmt(whileStatement.getBody()).get(0));
    ret.add(whs);
  }
 else   if (statement instanceof ICPPASTTryBlockStatement) {
    ICPPASTTryBlockStatement tryBlockStatement=(ICPPASTTryBlockStatement)statement;
    print(""String_Node_Str"");
    TryStatement trys=ast.newTryStatement();
    trys.setBody((Block)evalStmt(tryBlockStatement.getTryBody()));
    for (    ICPPASTCatchHandler catchHandler : tryBlockStatement.getCatchHandlers())     trys.catchClauses().add(evaluateCatchClause(catchHandler));
    ret.add(trys);
  }
 else   if (statement != null) {
    printerr(statement.getClass().getCanonicalName());
  }
  return ret;
}","/** 
 * Attempts to convert the given C++ statement to one or more Java statements.
 */
private List<Statement> evalStmt(IASTStatement statement) throws DOMException {
  List<Statement> ret=new ArrayList<Statement>();
  if (statement instanceof IASTBreakStatement) {
    print(""String_Node_Str"");
    int temp=findLastLoopId();
    if (temp != -1) {
      Block blk=ast.newBlock();
      blk.statements().add(ast.newExpressionStatement(createCleanupCall(temp + 1)));
      blk.statements().add(ast.newBreakStatement());
      ret.add(blk);
    }
 else     ret.add(ast.newBreakStatement());
  }
 else   if (statement instanceof IASTCaseStatement) {
    IASTCaseStatement caseStatement=(IASTCaseStatement)statement;
    print(""String_Node_Str"");
    SwitchCase cs=ast.newSwitchCase();
    cs.setExpression(eval1Expr(caseStatement.getExpression()));
    ret.add(cs);
  }
 else   if (statement instanceof IASTContinueStatement) {
    print(""String_Node_Str"");
    int temp=findLastLoopId();
    if (temp != -1) {
      Block blk=ast.newBlock();
      blk.statements().add(ast.newExpressionStatement(createCleanupCall(temp + 1)));
      blk.statements().add(ast.newContinueStatement());
      ret.add(blk);
    }
 else     ret.add(ast.newContinueStatement());
  }
 else   if (statement instanceof IASTDefaultStatement) {
    print(""String_Node_Str"");
    SwitchCase cs=ast.newSwitchCase();
    cs.setExpression(null);
    ret.add(cs);
  }
 else   if (statement instanceof IASTGotoStatement) {
    IASTGotoStatement gotoStatement=(IASTGotoStatement)statement;
    print(""String_Node_Str"");
    getSimpleName(gotoStatement.getName());
  }
 else   if (statement instanceof IASTNullStatement) {
    print(""String_Node_Str"");
    ret.add(ast.newEmptyStatement());
  }
 else   if (statement instanceof IASTProblemStatement) {
    IASTProblemStatement probStatement=(IASTProblemStatement)statement;
    print(""String_Node_Str"" + probStatement.getProblem().getMessageWithLocation());
  }
 else   if (statement instanceof IASTCompoundStatement) {
    IASTCompoundStatement compoundStatement=(IASTCompoundStatement)statement;
    print(""String_Node_Str"");
    int temp=m_localVariableId;
    m_localVariableStack.push(new StackVar(m_localVariableId,m_isLoop));
    m_isLoop=false;
    Block block=ast.newBlock();
    for (    IASTStatement childStatement : compoundStatement.getStatements())     block.statements().addAll(evalStmt(childStatement));
    block.statements().addAll(stmtQueue);
    stmtQueue.clear();
    if (m_localVariableId != -1 && !block.statements().isEmpty() && !(block.statements().get(block.statements().size() - 1) instanceof ReturnStatement) && !(block.statements().get(block.statements().size() - 1) instanceof BreakStatement) && !(block.statements().get(block.statements().size() - 1) instanceof ContinueStatement)) {
      block.statements().add(ast.newExpressionStatement(createCleanupCall(temp + 1)));
    }
    m_localVariableId=temp;
    ret.add(block);
  }
 else   if (statement instanceof IASTDeclarationStatement) {
    IASTDeclarationStatement declarationStatement=(IASTDeclarationStatement)statement;
    print(""String_Node_Str"");
    List<VariableDeclarationFragment> frags=getDeclarationFragments(declarationStatement.getDeclaration());
    List<Type> types=evaluateDeclarationReturnTypes(declarationStatement.getDeclaration());
    for (int i=0; i < types.size(); i++) {
      VariableDeclarationStatement decl=ast.newVariableDeclarationStatement(frags.get(i));
      decl.setType(types.get(i));
      ret.add(decl);
    }
    ret.addAll(stmtQueue);
    stmtQueue.clear();
  }
 else   if (statement instanceof IASTDoStatement) {
    IASTDoStatement doStatement=(IASTDoStatement)statement;
    print(""String_Node_Str"");
    DoStatement dos=ast.newDoStatement();
    m_isLoop=true;
    dos.setBody(eval1Stmt(doStatement.getBody()));
    dos.setExpression(eval1Expr(doStatement.getCondition(),TypeEnum.BOOLEAN));
    ret.add(dos);
  }
 else   if (statement instanceof IASTExpressionStatement) {
    IASTExpressionStatement expressionStatement=(IASTExpressionStatement)statement;
    print(""String_Node_Str"");
    ret.add(ast.newExpressionStatement(eval1Expr(expressionStatement.getExpression())));
  }
 else   if (statement instanceof IASTForStatement) {
    IASTForStatement forStatement=(IASTForStatement)statement;
    print(""String_Node_Str"");
    if (forStatement instanceof ICPPASTForStatement)     ;
    ForStatement fs=ast.newForStatement();
    List<Expression> inits=evaluateForInitializer(forStatement.getInitializerStatement());
    Expression expr=eval1Expr(forStatement.getConditionExpression(),TypeEnum.BOOLEAN);
    List<Expression> updaters=evalExpr(forStatement.getIterationExpression());
    if (inits != null)     fs.initializers().addAll(inits);
    if (expr != null)     fs.setExpression(expr);
    if (updaters.get(0) != null)     fs.updaters().addAll(updaters);
    m_isLoop=true;
    fs.setBody(eval1Stmt(forStatement.getBody()));
    ret.add(fs);
  }
 else   if (statement instanceof IASTIfStatement) {
    IASTIfStatement ifStatement=(IASTIfStatement)statement;
    print(""String_Node_Str"");
    IfStatement ifs=ast.newIfStatement();
    if (ifStatement instanceof ICPPASTIfStatement && ((ICPPASTIfStatement)ifStatement).getConditionDeclaration() != null) {
      ifs.setExpression(generateDeclarationForWhileIf(((ICPPASTIfStatement)ifStatement).getConditionDeclaration(),ret));
    }
 else {
      ifs.setExpression(eval1Expr(ifStatement.getConditionExpression(),TypeEnum.BOOLEAN));
    }
    ifs.setThenStatement(eval1Stmt(ifStatement.getThenClause()));
    List<Statement> elseStmts=evalStmt(ifStatement.getElseClause());
    ifs.setElseStatement(!elseStmts.isEmpty() ? elseStmts.get(0) : null);
    ret.add(ifs);
  }
 else   if (statement instanceof IASTLabelStatement) {
    IASTLabelStatement labelStatement=(IASTLabelStatement)statement;
    print(""String_Node_Str"");
    evalStmt(labelStatement.getNestedStatement());
  }
 else   if (statement instanceof IASTReturnStatement) {
    IASTReturnStatement returnStatement=(IASTReturnStatement)statement;
    print(""String_Node_Str"");
    JASTHelper.Method method=jast.newMethod().on(""String_Node_Str"").call(""String_Node_Str"");
    ReturnStatement ret2=ast.newReturnStatement();
    if (returnStatement.getReturnValue() != null) {
      if (((returnStatement.getReturnValue().getExpressionType() instanceof ICompositeType || (returnStatement.getReturnValue().getExpressionType() instanceof IQualifierType && ((IQualifierType)returnStatement.getReturnValue().getExpressionType()).getType() instanceof ICompositeType)) && !(eval1Expr(returnStatement.getReturnValue()) instanceof ClassInstanceCreation))) {
        ClassInstanceCreation create=jast.newClassCreate().type(cppToJavaType(returnStatement.getReturnValue().getExpressionType())).with(eval1Expr(returnStatement.getReturnValue())).toAST();
        if (m_localVariableId != -1)         method.with(create);
 else         ret2.setExpression(create);
      }
 else {
        if (m_localVariableId != -1)         method.with(eval1Expr(returnStatement.getReturnValue()));
 else         ret2.setExpression(eval1Expr(returnStatement.getReturnValue()));
      }
      if (m_localVariableId != -1) {
        method.with(""String_Node_Str"").with(0);
        ret2.setExpression(method.toAST());
      }
      ret.add(ret2);
    }
 else {
      if (m_localVariableId != -1) {
        Block blk=ast.newBlock();
        method.with(ast.newNullLiteral()).with(""String_Node_Str"").with(0);
        blk.statements().add(ast.newExpressionStatement(method.toAST()));
        blk.statements().add(ret2);
        ret.add(blk);
      }
 else       ret.add(ret2);
    }
  }
 else   if (statement instanceof IASTSwitchStatement) {
    IASTSwitchStatement switchStatement=(IASTSwitchStatement)statement;
    print(""String_Node_Str"");
    SwitchStatement swt=ast.newSwitchStatement();
    if (switchStatement instanceof ICPPASTSwitchStatement && ((ICPPASTSwitchStatement)switchStatement).getControllerDeclaration() != null) {
      ICPPASTSwitchStatement cppSwitch=(ICPPASTSwitchStatement)switchStatement;
      List<VariableDeclarationFragment> frags=getDeclarationFragments(cppSwitch.getControllerDeclaration());
      frags.get(0).setInitializer(null);
      VariableDeclarationStatement decl=ast.newVariableDeclarationStatement(frags.get(0));
      Type jType=evaluateDeclarationReturnTypes(cppSwitch.getControllerDeclaration()).get(0);
      decl.setType(jType);
      ret.add(decl);
      List<Expression> exprs=evaluateDeclarationReturnInitializers(cppSwitch.getControllerDeclaration());
      Assignment assign=jast.newAssign().left(ast.newSimpleName(frags.get(0).getName().getIdentifier())).right(exprs.get(0)).op(Assignment.Operator.ASSIGN).toAST();
      swt.setExpression(assign);
    }
 else {
      swt.setExpression(evalExpr(switchStatement.getControllerExpression()).get(0));
    }
    if (switchStatement.getBody() instanceof IASTCompoundStatement) {
      IASTCompoundStatement compound=(IASTCompoundStatement)switchStatement.getBody();
      for (      IASTStatement stmt : compound.getStatements())       swt.statements().addAll(evalStmt(stmt));
    }
 else {
      swt.statements().addAll(evalStmt(switchStatement.getBody()));
    }
    ret.add(swt);
  }
 else   if (statement instanceof IASTWhileStatement) {
    IASTWhileStatement whileStatement=(IASTWhileStatement)statement;
    print(""String_Node_Str"");
    WhileStatement whs=ast.newWhileStatement();
    if (whileStatement instanceof ICPPASTWhileStatement && ((ICPPASTWhileStatement)whileStatement).getConditionDeclaration() != null) {
      whs.setExpression(generateDeclarationForWhileIf(((ICPPASTWhileStatement)whileStatement).getConditionDeclaration(),ret));
    }
 else {
      whs.setExpression(eval1Expr(whileStatement.getCondition(),TypeEnum.BOOLEAN));
    }
    whs.setBody(eval1Stmt(whileStatement.getBody()));
    ret.add(whs);
  }
 else   if (statement instanceof ICPPASTTryBlockStatement) {
    ICPPASTTryBlockStatement tryBlockStatement=(ICPPASTTryBlockStatement)statement;
    print(""String_Node_Str"");
    TryStatement trys=ast.newTryStatement();
    trys.setBody((Block)evalStmt(tryBlockStatement.getTryBody()));
    for (    ICPPASTCatchHandler catchHandler : tryBlockStatement.getCatchHandlers())     trys.catchClauses().add(evaluateCatchClause(catchHandler));
    ret.add(trys);
  }
 else   if (statement != null) {
    printerr(statement.getClass().getCanonicalName());
  }
  return ret;
}"
50105,"MethodInvocation createCleanupCall(int until){
  MethodInvocation meth=jast.newMethod().on(""String_Node_Str"").call(""String_Node_Str"").with(ast.newNullLiteral()).with(""String_Node_Str"").with(until).toAST();
  return meth;
}","private MethodInvocation createCleanupCall(int until){
  MethodInvocation meth=jast.newMethod().on(""String_Node_Str"").call(""String_Node_Str"").with(ast.newNullLiteral()).with(""String_Node_Str"").with(until).toAST();
  return meth;
}"
50106,"/** 
 * Given a C++ expression, attempts to convert it into one or more Java expressions.
 */
private List<Expression> evalExpr(IASTExpression expression,TypeEnum wanted) throws DOMException {
  List<Expression> ret=new ArrayList<Expression>();
  boolean fNeedBooleans=(wanted == TypeEnum.BOOLEAN);
  if (expression instanceof IASTLiteralExpression) {
    IASTLiteralExpression literal=(IASTLiteralExpression)expression;
switch (literal.getKind()) {
case IASTLiteralExpression.lk_char_constant:
      CharacterLiteral cl=ast.newCharacterLiteral();
    cl.setEscapedValue(new String(literal.getValue()));
  ret.add(cl);
break;
case IASTLiteralExpression.lk_false:
BooleanLiteral bl=ast.newBooleanLiteral(false);
ret.add(bl);
break;
case IASTLiteralExpression.lk_true:
BooleanLiteral bl2=ast.newBooleanLiteral(true);
ret.add(bl2);
break;
case IASTLiteralExpression.lk_float_constant:
NumberLiteral fl=ast.newNumberLiteral();
fl.setToken(new String(literal.getValue()));
ret.add(fl);
break;
case IASTLiteralExpression.lk_string_literal:
StringLiteral sl=ast.newStringLiteral();
sl.setLiteralValue(new String(literal.getValue()));
ret.add(sl);
break;
case IASTLiteralExpression.lk_integer_constant:
NumberLiteral il=ast.newNumberLiteral();
il.setToken(new String(literal.getValue()));
ret.add(il);
break;
case IASTLiteralExpression.lk_this:
ThisExpression te=ast.newThisExpression();
ret.add(te);
break;
}
}
 else if (expression instanceof IASTArraySubscriptExpression) {
IASTArraySubscriptExpression arraySubscriptExpression=(IASTArraySubscriptExpression)expression;
print(""String_Node_Str"");
ArrayAccess array=ast.newArrayAccess();
array.setArray(eval1Expr(arraySubscriptExpression.getArrayExpression()));
array.setIndex(eval1Expr(arraySubscriptExpression.getSubscriptExpression()));
ret.add(array);
}
 else if (expression instanceof IASTBinaryExpression) {
IASTBinaryExpression binaryExpression=(IASTBinaryExpression)expression;
print(""String_Node_Str"" + binaryExpression.getRawSignature());
boolean fSubsNeedBooleans=needBooleanExpressions(binaryExpression.getOperator());
if (expression instanceof IASTImplicitNameOwner && ((IASTImplicitNameOwner)expression).getImplicitNames().length != 0 && ((IASTImplicitNameOwner)expression).getImplicitNames()[0].isOperator()) {
String name=((IASTImplicitNameOwner)expression).getImplicitNames()[0].resolveBinding().getName();
String replace=""String_Node_Str"";
if (name.equals(""String_Node_Str"") && ((IASTImplicitNameOwner)expression).getImplicitNames()[0].resolveBinding() instanceof ICPPMethod) {
ICPPMethod bind=(ICPPMethod)((IASTImplicitNameOwner)expression).getImplicitNames()[0].resolveBinding();
Assignment ass=ast.newAssignment();
if (!(eval1Expr(binaryExpression.getOperand2()) instanceof ClassInstanceCreation)) {
ClassInstanceCreation create=jast.newClassCreate().type(cppToJavaType(bind.getParameters()[0].getType())).with(eval1Expr(binaryExpression.getOperand2())).toAST();
ass.setRightHandSide(create);
}
 else {
ass.setRightHandSide(eval1Expr(binaryExpression.getOperand2()));
}
ass.setLeftHandSide(eval1Expr(binaryExpression.getOperand1()));
ret.add(ass);
}
 else {
replace=normalizeName(name);
MethodInvocation method=jast.newMethod().on(eval1Expr(binaryExpression.getOperand1())).call(replace).with(eval1Expr(binaryExpression.getOperand2())).toAST();
ret.add(method);
}
}
 else if (isAssignmentExpression(binaryExpression.getOperator())) {
Assignment assign=jast.newAssign().left(eval1Expr(binaryExpression.getOperand1())).right(eval1Expr(binaryExpression.getOperand2())).op(evaluateBinaryAssignmentOperator(binaryExpression.getOperator())).toAST();
ret.add(assign);
}
 else {
InfixExpression infix=jast.newInfix().left(evalExpr(binaryExpression.getOperand1(),fSubsNeedBooleans ? TypeEnum.BOOLEAN : TypeEnum.ANY).get(0)).right(evalExpr(binaryExpression.getOperand2(),fSubsNeedBooleans ? TypeEnum.BOOLEAN : TypeEnum.ANY).get(0)).op(evaluateBinaryOperator(binaryExpression.getOperator())).toAST();
ret.add(infix);
}
}
 else if (expression instanceof IASTCastExpression) {
IASTCastExpression castExpression=(IASTCastExpression)expression;
print(""String_Node_Str"");
CastExpression cast=ast.newCastExpression();
cast.setExpression(eval1Expr(castExpression.getOperand()));
cast.setType(evalTypeId(castExpression.getTypeId()));
ret.add(cast);
}
 else if (expression instanceof IASTConditionalExpression) {
IASTConditionalExpression conditionalExpression=(IASTConditionalExpression)expression;
print(""String_Node_Str"");
ConditionalExpression conditional=ast.newConditionalExpression();
conditional.setExpression(eval1Expr(conditionalExpression.getLogicalConditionExpression()));
conditional.setThenExpression(eval1Expr(conditionalExpression.getPositiveResultExpression()));
conditional.setElseExpression(eval1Expr(conditionalExpression.getNegativeResultExpression()));
ret.add(conditional);
}
 else if (expression instanceof IASTFieldReference) {
IASTFieldReference fieldReference=(IASTFieldReference)expression;
print(""String_Node_Str"");
IBinding binding=fieldReference.getFieldName().resolveBinding();
boolean isBitField=false;
print(binding.getName());
FieldAccess field=jast.newField().on(eval1Expr(fieldReference.getFieldOwner())).field(getSimpleName(fieldReference.getFieldName())).toAST();
if (binding instanceof IEnumerator) {
FieldAccess access=jast.newField().on(field).field(""String_Node_Str"").toAST();
ret.add(access);
}
 else {
ret.add(field);
}
}
 else if (expression instanceof IASTFunctionCallExpression) {
IASTFunctionCallExpression functionCallExpression=(IASTFunctionCallExpression)expression;
print(""String_Node_Str"");
Expression funcCallExpr;
if (functionCallExpression.getFunctionNameExpression() instanceof IASTIdExpression && ((IASTIdExpression)functionCallExpression.getFunctionNameExpression()).getName().resolveBinding() instanceof ICPPClassType) {
ICPPClassType con=(ICPPClassType)((IASTIdExpression)functionCallExpression.getFunctionNameExpression()).getName().resolveBinding();
ClassInstanceCreation create=ast.newClassInstanceCreation();
create.setType(jast.newType(con.getName()));
MethodInvocation method=jast.newMethod().on(""String_Node_Str"").call(""String_Node_Str"").with(create).with(m_localVariableId + 1).with(""String_Node_Str"").toAST();
m_localVariableId++;
if (m_localVariableId > m_localVariableMaxId) m_localVariableMaxId=m_localVariableId;
if (functionCallExpression.getParameterExpression() instanceof IASTExpressionList) {
IASTExpressionList list=(IASTExpressionList)functionCallExpression.getParameterExpression();
for (IASTExpression arg : list.getExpressions()) {
create.arguments().addAll(evalExpr(arg));
}
}
 else if (functionCallExpression.getParameterExpression() instanceof IASTExpression) {
create.arguments().addAll(evalExpr((IASTExpression)functionCallExpression.getParameterExpression()));
}
funcCallExpr=(method);
ret.add(funcCallExpr);
}
 else {
JASTHelper.Method method=jast.newMethod();
if (functionCallExpression.getFunctionNameExpression() instanceof IASTFieldReference) {
IASTFieldReference fr=(IASTFieldReference)functionCallExpression.getFunctionNameExpression();
method.on(eval1Expr(fr.getFieldOwner())).call(getSimpleName(fr.getFieldName()));
}
 else if (functionCallExpression.getFunctionNameExpression() instanceof IASTIdExpression) {
IASTIdExpression id=(IASTIdExpression)functionCallExpression.getFunctionNameExpression();
if (getSimpleName(id.getName()).equals(""String_Node_Str"") || getSimpleName(id.getName()).equals(""String_Node_Str"")) {
method.on(""String_Node_Str"");
}
method.call(getSimpleName(id.getName()));
}
if (functionCallExpression.getParameterExpression() instanceof IASTExpressionList) {
IASTExpressionList list=(IASTExpressionList)functionCallExpression.getParameterExpression();
for (IASTExpression arg : list.getExpressions()) {
method.withArguments(evalExpr(arg));
}
}
 else if (functionCallExpression.getParameterExpression() instanceof IASTExpression) {
method.withArguments(evalExpr(functionCallExpression.getParameterExpression()));
}
funcCallExpr=(method.toAST());
if (getTypeEnum(expression.getExpressionType()) == TypeEnum.OTHER || getTypeEnum(expression.getExpressionType()) == TypeEnum.ARRAY) {
MethodInvocation method2=jast.newMethod().on(""String_Node_Str"").call(""String_Node_Str"").with(funcCallExpr).with(m_localVariableId + 1).with(""String_Node_Str"").toAST();
m_localVariableId++;
if (m_localVariableId > m_localVariableMaxId) m_localVariableMaxId=m_localVariableId;
ret.add(method2);
}
 else ret.add(funcCallExpr);
}
}
 else if (expression instanceof IASTIdExpression) {
IASTIdExpression idExpression=(IASTIdExpression)expression;
print(""String_Node_Str"");
if (isBitfield(idExpression.getName())) {
print(""String_Node_Str"");
MethodInvocation methodGet=jast.newMethod().call(""String_Node_Str"" + getSimpleName(idExpression.getName())).toAST();
ret.add(methodGet);
}
 else {
IBinding bind=idExpression.getName().resolveBinding();
if (bind instanceof IEnumerator) {
IEnumerator enumerator=(IEnumerator)bind;
String enumeration=getSimpleType(((IEnumeration)enumerator.getType()).getName());
QualifiedName qual;
if (enumeration.equals(""String_Node_Str"")) {
String first=((IEnumeration)enumerator.getOwner()).getEnumerators()[0].getName();
String enumName=m_anonEnumMap.get(first);
if (enumName == null) exitOnError();
qual=ast.newQualifiedName(ast.newSimpleName(enumName),ast.newSimpleName(getSimpleName(idExpression.getName())));
}
 else {
qual=ast.newQualifiedName(ast.newSimpleName(enumeration),ast.newSimpleName(getSimpleName(idExpression.getName())));
}
FieldAccess fa=jast.newField().on(qual).field(""String_Node_Str"").toAST();
ret.add(fa);
}
 else if (isEventualPtrOrRef(idExpression.getExpressionType())) {
FieldAccess fa=jast.newField().on(getSimpleName(idExpression.getName())).field(""String_Node_Str"").toAST();
ret.add(fa);
}
 else {
SimpleName nm=ast.newSimpleName(getSimpleName(idExpression.getName()));
ret.add(nm);
}
}
}
 else if (expression instanceof IASTTypeIdExpression) {
IASTTypeIdExpression typeIdExpression=(IASTTypeIdExpression)expression;
print(""String_Node_Str"");
printerr(typeIdExpression.getRawSignature());
FieldAccess fa=ast.newFieldAccess();
fa.setName(ast.newSimpleName(""String_Node_Str""));
ret.add(fa);
evalTypeId(typeIdExpression.getTypeId());
}
 else if (expression instanceof IASTUnaryExpression) {
IASTUnaryExpression unaryExpression=(IASTUnaryExpression)expression;
print(""String_Node_Str"");
if (isPostfixExpression(unaryExpression.getOperator())) {
PostfixExpression post=ast.newPostfixExpression();
post.setOperator(evalUnaryPostfixOperator(unaryExpression.getOperator()));
post.setOperand(eval1Expr(unaryExpression.getOperand()));
ret.add(post);
}
 else if (isPrefixExpression(unaryExpression.getOperator())) {
PrefixExpression pre=ast.newPrefixExpression();
pre.setOperator(evalUnaryPrefixOperator(unaryExpression.getOperator()));
pre.setOperand(eval1Expr(unaryExpression.getOperand()));
ret.add(pre);
}
 else if (unaryExpression.getOperator() == IASTUnaryExpression.op_bracketedPrimary) {
ParenthesizedExpression paren=jast.newParen(eval1Expr(unaryExpression.getOperand()));
ret.add(paren);
}
 else if (unaryExpression.getOperator() == IASTUnaryExpression.op_star) {
ret.addAll(evalExpr(unaryExpression.getOperand()));
}
 else if (unaryExpression.getOperator() == IASTUnaryExpression.op_amper) {
ret.addAll(evalExpr(unaryExpression.getOperand()));
}
 else {
print(""String_Node_Str"");
print(""String_Node_Str"" + unaryExpression.getOperator());
ret.add(ast.newStringLiteral());
}
}
 else if (expression instanceof ICASTTypeIdInitializerExpression) {
ICASTTypeIdInitializerExpression typeIdInitializerExpression=(ICASTTypeIdInitializerExpression)expression;
print(""String_Node_Str"");
evalTypeId(typeIdInitializerExpression.getTypeId());
evaluate(typeIdInitializerExpression.getInitializer());
}
 else if (expression instanceof ICPPASTDeleteExpression) {
ICPPASTDeleteExpression deleteExpression=(ICPPASTDeleteExpression)expression;
print(""String_Node_Str"");
if (!deleteExpression.isVectored()) {
ret.add(jast.newMethod().on(eval1Expr(deleteExpression.getOperand()),true).call(""String_Node_Str"").toAST());
}
 else {
ret.add(jast.newMethod().on(""String_Node_Str"").call(""String_Node_Str"").with(eval1Expr(deleteExpression.getOperand())).toAST());
}
}
 else if (expression instanceof ICPPASTNewExpression) {
ICPPASTNewExpression newExpression=(ICPPASTNewExpression)expression;
print(""String_Node_Str"");
if (!newExpression.isArrayAllocation()) {
boolean isBasic=false;
if (getTypeEnum(newExpression.getExpressionType()) == TypeEnum.POINTER) {
TypeEnum teBase=getTypeEnum(getPointerBaseType(newExpression.getExpressionType()));
if (teBase == TypeEnum.CHAR || teBase == TypeEnum.NUMBER || teBase == TypeEnum.BOOLEAN) {
ret.add(ast.newNumberLiteral(""String_Node_Str""));
isBasic=true;
}
}
if (!isBasic) {
ClassInstanceCreation create=ast.newClassInstanceCreation();
create.setType(evalTypeId(newExpression.getTypeId()));
if (newExpression.getNewInitializer() instanceof IASTExpressionList) {
for (IASTExpression arg : ((IASTExpressionList)newExpression.getNewInitializer()).getExpressions()) create.arguments().addAll(evalExpr(arg));
}
 else if (newExpression.getNewInitializer() instanceof IASTExpression) {
create.arguments().addAll(evalExpr((IASTExpression)newExpression.getNewInitializer()));
}
ret.add(create);
}
}
 else {
List<Expression> sizeExprs=new ArrayList<Expression>();
for (IASTExpression arraySize : newExpression.getNewTypeIdArrayExpressions()) sizeExprs.add(eval1Expr(arraySize));
Expression ex=generateArrayCreationExpression(newExpression.getExpressionType(),sizeExprs);
ret.add(ex);
}
}
 else if (expression instanceof ICPPASTSimpleTypeConstructorExpression) {
ICPPASTSimpleTypeConstructorExpression simpleTypeConstructorExpression=(ICPPASTSimpleTypeConstructorExpression)expression;
printerr(""String_Node_Str"");
evalExpr(simpleTypeConstructorExpression.getInitialValue());
}
 else if (expression instanceof IGNUASTCompoundStatementExpression) {
IGNUASTCompoundStatementExpression compoundStatementExpression=(IGNUASTCompoundStatementExpression)expression;
print(""String_Node_Str"");
evalStmt(compoundStatementExpression.getCompoundStatement());
}
 else if (expression instanceof IASTExpressionList) {
IASTExpressionList list=(IASTExpressionList)expression;
for (IASTExpression childExpression : list.getExpressions()) ret.addAll(evalExpr(childExpression));
}
 else if (expression == null) {
ret.add(null);
}
if (ret.isEmpty()) printerr(expression.getClass().getCanonicalName());
if (fNeedBooleans) ret.set(0,makeExpressionBoolean(ret.get(0),expression));
if (expression != null) print(expression.getClass().getCanonicalName());
if (ret.isEmpty()) ret.add(ast.newNumberLiteral(""String_Node_Str""));
return ret;
}","/** 
 * Given a C++ expression, attempts to convert it into one or more Java expressions.
 */
private List<Expression> evalExpr(IASTExpression expression,TypeEnum wanted) throws DOMException {
  List<Expression> ret=new ArrayList<Expression>();
  boolean fNeedBooleans=(wanted == TypeEnum.BOOLEAN);
  if (expression instanceof IASTLiteralExpression) {
    IASTLiteralExpression literal=(IASTLiteralExpression)expression;
switch (literal.getKind()) {
case IASTLiteralExpression.lk_char_constant:
      CharacterLiteral cl=ast.newCharacterLiteral();
    cl.setEscapedValue(new String(literal.getValue()));
  ret.add(cl);
break;
case IASTLiteralExpression.lk_false:
BooleanLiteral bl=ast.newBooleanLiteral(false);
ret.add(bl);
break;
case IASTLiteralExpression.lk_true:
BooleanLiteral bl2=ast.newBooleanLiteral(true);
ret.add(bl2);
break;
case IASTLiteralExpression.lk_float_constant:
NumberLiteral fl=ast.newNumberLiteral();
fl.setToken(new String(literal.getValue()));
ret.add(fl);
break;
case IASTLiteralExpression.lk_string_literal:
StringLiteral sl=ast.newStringLiteral();
sl.setLiteralValue(new String(literal.getValue()));
ret.add(sl);
break;
case IASTLiteralExpression.lk_integer_constant:
NumberLiteral il=ast.newNumberLiteral();
il.setToken(new String(literal.getValue()));
ret.add(il);
break;
case IASTLiteralExpression.lk_this:
ThisExpression te=ast.newThisExpression();
ret.add(te);
break;
}
}
 else if (expression instanceof IASTArraySubscriptExpression) {
IASTArraySubscriptExpression arraySubscriptExpression=(IASTArraySubscriptExpression)expression;
print(""String_Node_Str"");
ArrayAccess array=ast.newArrayAccess();
array.setArray(eval1Expr(arraySubscriptExpression.getArrayExpression()));
array.setIndex(eval1Expr(arraySubscriptExpression.getSubscriptExpression()));
ret.add(array);
}
 else if (expression instanceof IASTBinaryExpression) {
IASTBinaryExpression binaryExpression=(IASTBinaryExpression)expression;
print(""String_Node_Str"" + binaryExpression.getRawSignature());
boolean fSubsNeedBooleans=needBooleanExpressions(binaryExpression.getOperator());
if (expression instanceof IASTImplicitNameOwner && ((IASTImplicitNameOwner)expression).getImplicitNames().length != 0 && ((IASTImplicitNameOwner)expression).getImplicitNames()[0].isOperator()) {
String name=((IASTImplicitNameOwner)expression).getImplicitNames()[0].resolveBinding().getName();
String replace=""String_Node_Str"";
if (name.equals(""String_Node_Str"") && ((IASTImplicitNameOwner)expression).getImplicitNames()[0].resolveBinding() instanceof ICPPMethod) {
ICPPMethod bind=(ICPPMethod)((IASTImplicitNameOwner)expression).getImplicitNames()[0].resolveBinding();
Assignment ass=ast.newAssignment();
if (!(eval1Expr(binaryExpression.getOperand2()) instanceof ClassInstanceCreation)) {
ClassInstanceCreation create=jast.newClassCreate().type(cppToJavaType(bind.getParameters()[0].getType())).with(eval1Expr(binaryExpression.getOperand2())).toAST();
ass.setRightHandSide(create);
}
 else {
ass.setRightHandSide(eval1Expr(binaryExpression.getOperand2()));
}
ass.setLeftHandSide(eval1Expr(binaryExpression.getOperand1()));
ret.add(ass);
}
 else {
replace=normalizeName(name);
MethodInvocation method=jast.newMethod().on(eval1Expr(binaryExpression.getOperand1())).call(replace).with(eval1Expr(binaryExpression.getOperand2())).toAST();
ret.add(method);
}
}
 else if (isAssignmentExpression(binaryExpression.getOperator())) {
Assignment assign=jast.newAssign().left(eval1Expr(binaryExpression.getOperand1())).right(eval1Expr(binaryExpression.getOperand2())).op(evaluateBinaryAssignmentOperator(binaryExpression.getOperator())).toAST();
ret.add(assign);
}
 else {
InfixExpression infix=jast.newInfix().left(eval1Expr(binaryExpression.getOperand1(),fSubsNeedBooleans ? TypeEnum.BOOLEAN : TypeEnum.ANY)).right(eval1Expr(binaryExpression.getOperand2(),fSubsNeedBooleans ? TypeEnum.BOOLEAN : TypeEnum.ANY)).op(evaluateBinaryOperator(binaryExpression.getOperator())).toAST();
ret.add(infix);
}
}
 else if (expression instanceof IASTCastExpression) {
IASTCastExpression castExpression=(IASTCastExpression)expression;
print(""String_Node_Str"");
CastExpression cast=ast.newCastExpression();
cast.setExpression(eval1Expr(castExpression.getOperand()));
cast.setType(evalTypeId(castExpression.getTypeId()));
ret.add(cast);
}
 else if (expression instanceof IASTConditionalExpression) {
IASTConditionalExpression conditionalExpression=(IASTConditionalExpression)expression;
print(""String_Node_Str"");
ConditionalExpression conditional=ast.newConditionalExpression();
conditional.setExpression(eval1Expr(conditionalExpression.getLogicalConditionExpression()));
conditional.setThenExpression(eval1Expr(conditionalExpression.getPositiveResultExpression()));
conditional.setElseExpression(eval1Expr(conditionalExpression.getNegativeResultExpression()));
ret.add(conditional);
}
 else if (expression instanceof IASTFieldReference) {
IASTFieldReference fieldReference=(IASTFieldReference)expression;
print(""String_Node_Str"");
IBinding binding=fieldReference.getFieldName().resolveBinding();
boolean isBitField=false;
print(binding.getName());
FieldAccess field=jast.newField().on(eval1Expr(fieldReference.getFieldOwner())).field(getSimpleName(fieldReference.getFieldName())).toAST();
if (binding instanceof IEnumerator) {
FieldAccess access=jast.newField().on(field).field(""String_Node_Str"").toAST();
ret.add(access);
}
 else {
ret.add(field);
}
}
 else if (expression instanceof IASTFunctionCallExpression) {
IASTFunctionCallExpression functionCallExpression=(IASTFunctionCallExpression)expression;
print(""String_Node_Str"");
Expression funcCallExpr;
if (functionCallExpression.getFunctionNameExpression() instanceof IASTIdExpression && ((IASTIdExpression)functionCallExpression.getFunctionNameExpression()).getName().resolveBinding() instanceof ICPPClassType) {
ICPPClassType con=(ICPPClassType)((IASTIdExpression)functionCallExpression.getFunctionNameExpression()).getName().resolveBinding();
ClassInstanceCreation create=ast.newClassInstanceCreation();
create.setType(jast.newType(con.getName()));
MethodInvocation method=jast.newMethod().on(""String_Node_Str"").call(""String_Node_Str"").with(create).with(m_localVariableId + 1).with(""String_Node_Str"").toAST();
m_localVariableId++;
if (m_localVariableId > m_localVariableMaxId) m_localVariableMaxId=m_localVariableId;
if (functionCallExpression.getParameterExpression() instanceof IASTExpressionList) {
IASTExpressionList list=(IASTExpressionList)functionCallExpression.getParameterExpression();
for (IASTExpression arg : list.getExpressions()) {
create.arguments().addAll(evalExpr(arg));
}
}
 else if (functionCallExpression.getParameterExpression() instanceof IASTExpression) {
create.arguments().addAll(evalExpr((IASTExpression)functionCallExpression.getParameterExpression()));
}
funcCallExpr=(method);
ret.add(funcCallExpr);
}
 else {
JASTHelper.Method method=jast.newMethod();
if (functionCallExpression.getFunctionNameExpression() instanceof IASTFieldReference) {
IASTFieldReference fr=(IASTFieldReference)functionCallExpression.getFunctionNameExpression();
method.on(eval1Expr(fr.getFieldOwner())).call(getSimpleName(fr.getFieldName()));
}
 else if (functionCallExpression.getFunctionNameExpression() instanceof IASTIdExpression) {
IASTIdExpression id=(IASTIdExpression)functionCallExpression.getFunctionNameExpression();
if (getSimpleName(id.getName()).equals(""String_Node_Str"") || getSimpleName(id.getName()).equals(""String_Node_Str"")) {
method.on(""String_Node_Str"");
}
method.call(getSimpleName(id.getName()));
}
if (functionCallExpression.getParameterExpression() instanceof IASTExpressionList) {
IASTExpressionList list=(IASTExpressionList)functionCallExpression.getParameterExpression();
for (IASTExpression arg : list.getExpressions()) {
method.withArguments(evalExpr(arg));
}
}
 else if (functionCallExpression.getParameterExpression() instanceof IASTExpression) {
method.withArguments(evalExpr(functionCallExpression.getParameterExpression()));
}
funcCallExpr=(method.toAST());
if (getTypeEnum(expression.getExpressionType()) == TypeEnum.OTHER || getTypeEnum(expression.getExpressionType()) == TypeEnum.ARRAY) {
MethodInvocation method2=jast.newMethod().on(""String_Node_Str"").call(""String_Node_Str"").with(funcCallExpr).with(m_localVariableId + 1).with(""String_Node_Str"").toAST();
m_localVariableId++;
if (m_localVariableId > m_localVariableMaxId) m_localVariableMaxId=m_localVariableId;
ret.add(method2);
}
 else ret.add(funcCallExpr);
}
}
 else if (expression instanceof IASTIdExpression) {
IASTIdExpression idExpression=(IASTIdExpression)expression;
print(""String_Node_Str"");
if (isBitfield(idExpression.getName())) {
print(""String_Node_Str"");
MethodInvocation methodGet=jast.newMethod().call(""String_Node_Str"" + getSimpleName(idExpression.getName())).toAST();
ret.add(methodGet);
}
 else {
IBinding bind=idExpression.getName().resolveBinding();
if (bind instanceof IEnumerator) {
IEnumerator enumerator=(IEnumerator)bind;
String enumeration=getSimpleType(((IEnumeration)enumerator.getType()).getName());
QualifiedName qual;
if (enumeration.equals(""String_Node_Str"")) {
String first=((IEnumeration)enumerator.getOwner()).getEnumerators()[0].getName();
String enumName=m_anonEnumMap.get(first);
if (enumName == null) exitOnError();
qual=ast.newQualifiedName(ast.newSimpleName(enumName),ast.newSimpleName(getSimpleName(idExpression.getName())));
}
 else {
qual=ast.newQualifiedName(ast.newSimpleName(enumeration),ast.newSimpleName(getSimpleName(idExpression.getName())));
}
FieldAccess fa=jast.newField().on(qual).field(""String_Node_Str"").toAST();
ret.add(fa);
}
 else if (isEventualPtrOrRef(idExpression.getExpressionType())) {
FieldAccess fa=jast.newField().on(getSimpleName(idExpression.getName())).field(""String_Node_Str"").toAST();
ret.add(fa);
}
 else {
SimpleName nm=ast.newSimpleName(getSimpleName(idExpression.getName()));
ret.add(nm);
}
}
}
 else if (expression instanceof IASTTypeIdExpression) {
IASTTypeIdExpression typeIdExpression=(IASTTypeIdExpression)expression;
print(""String_Node_Str"");
printerr(typeIdExpression.getRawSignature());
FieldAccess fa=ast.newFieldAccess();
fa.setName(ast.newSimpleName(""String_Node_Str""));
ret.add(fa);
evalTypeId(typeIdExpression.getTypeId());
}
 else if (expression instanceof IASTUnaryExpression) {
IASTUnaryExpression unaryExpression=(IASTUnaryExpression)expression;
print(""String_Node_Str"");
if (isPostfixExpression(unaryExpression.getOperator())) {
PostfixExpression post=ast.newPostfixExpression();
post.setOperator(evalUnaryPostfixOperator(unaryExpression.getOperator()));
post.setOperand(eval1Expr(unaryExpression.getOperand()));
ret.add(post);
}
 else if (isPrefixExpression(unaryExpression.getOperator())) {
PrefixExpression pre=ast.newPrefixExpression();
pre.setOperator(evalUnaryPrefixOperator(unaryExpression.getOperator()));
pre.setOperand(eval1Expr(unaryExpression.getOperand()));
ret.add(pre);
}
 else if (unaryExpression.getOperator() == IASTUnaryExpression.op_bracketedPrimary) {
ParenthesizedExpression paren=jast.newParen(eval1Expr(unaryExpression.getOperand()));
ret.add(paren);
}
 else if (unaryExpression.getOperator() == IASTUnaryExpression.op_star) {
ret.addAll(evalExpr(unaryExpression.getOperand()));
}
 else if (unaryExpression.getOperator() == IASTUnaryExpression.op_amper) {
ret.addAll(evalExpr(unaryExpression.getOperand()));
}
 else {
print(""String_Node_Str"");
print(""String_Node_Str"" + unaryExpression.getOperator());
ret.add(ast.newStringLiteral());
}
}
 else if (expression instanceof ICASTTypeIdInitializerExpression) {
ICASTTypeIdInitializerExpression typeIdInitializerExpression=(ICASTTypeIdInitializerExpression)expression;
print(""String_Node_Str"");
evalTypeId(typeIdInitializerExpression.getTypeId());
evaluate(typeIdInitializerExpression.getInitializer());
}
 else if (expression instanceof ICPPASTDeleteExpression) {
ICPPASTDeleteExpression deleteExpression=(ICPPASTDeleteExpression)expression;
print(""String_Node_Str"");
if (!deleteExpression.isVectored()) {
ret.add(jast.newMethod().on(eval1Expr(deleteExpression.getOperand()),true).call(""String_Node_Str"").toAST());
}
 else {
ret.add(jast.newMethod().on(""String_Node_Str"").call(""String_Node_Str"").with(eval1Expr(deleteExpression.getOperand())).toAST());
}
}
 else if (expression instanceof ICPPASTNewExpression) {
ICPPASTNewExpression newExpression=(ICPPASTNewExpression)expression;
print(""String_Node_Str"");
if (!newExpression.isArrayAllocation()) {
boolean isBasic=false;
if (getTypeEnum(newExpression.getExpressionType()) == TypeEnum.POINTER) {
TypeEnum teBase=getTypeEnum(getPointerBaseType(newExpression.getExpressionType()));
if (teBase == TypeEnum.CHAR || teBase == TypeEnum.NUMBER || teBase == TypeEnum.BOOLEAN) {
ret.add(ast.newNumberLiteral(""String_Node_Str""));
isBasic=true;
}
}
if (!isBasic) {
ClassInstanceCreation create=ast.newClassInstanceCreation();
create.setType(evalTypeId(newExpression.getTypeId()));
if (newExpression.getNewInitializer() instanceof IASTExpressionList) {
for (IASTExpression arg : ((IASTExpressionList)newExpression.getNewInitializer()).getExpressions()) create.arguments().addAll(evalExpr(arg));
}
 else if (newExpression.getNewInitializer() instanceof IASTExpression) {
create.arguments().addAll(evalExpr((IASTExpression)newExpression.getNewInitializer()));
}
ret.add(create);
}
}
 else {
List<Expression> sizeExprs=new ArrayList<Expression>();
for (IASTExpression arraySize : newExpression.getNewTypeIdArrayExpressions()) sizeExprs.add(eval1Expr(arraySize));
Expression ex=generateArrayCreationExpression(newExpression.getExpressionType(),sizeExprs);
ret.add(ex);
}
}
 else if (expression instanceof ICPPASTSimpleTypeConstructorExpression) {
ICPPASTSimpleTypeConstructorExpression simpleTypeConstructorExpression=(ICPPASTSimpleTypeConstructorExpression)expression;
printerr(""String_Node_Str"");
evalExpr(simpleTypeConstructorExpression.getInitialValue());
}
 else if (expression instanceof IGNUASTCompoundStatementExpression) {
IGNUASTCompoundStatementExpression compoundStatementExpression=(IGNUASTCompoundStatementExpression)expression;
print(""String_Node_Str"");
evalStmt(compoundStatementExpression.getCompoundStatement());
}
 else if (expression instanceof IASTExpressionList) {
IASTExpressionList list=(IASTExpressionList)expression;
for (IASTExpression childExpression : list.getExpressions()) ret.addAll(evalExpr(childExpression));
}
 else if (expression == null) {
ret.add(null);
}
if (ret.isEmpty()) printerr(expression.getClass().getCanonicalName());
if (fNeedBooleans) ret.set(0,makeExpressionBoolean(ret.get(0),expression));
if (expression != null) print(expression.getClass().getCanonicalName());
if (ret.isEmpty()) ret.add(ast.newNumberLiteral(""String_Node_Str""));
return ret;
}"
50107,"/** 
 * Attempts to evaluate the given declaration specifier
 */
private TypeDeclaration evalDeclSpecifier(IASTDeclSpecifier declSpecifier) throws DOMException {
  if (declSpecifier instanceof IASTCompositeTypeSpecifier) {
    IASTCompositeTypeSpecifier compositeTypeSpecifier=(IASTCompositeTypeSpecifier)declSpecifier;
    print(""String_Node_Str"");
    TypeDeclaration tyd=ast.newTypeDeclaration();
    CompositeInfo info=compositeMap.get(getQualifiedPart(compositeTypeSpecifier.getName()));
    if (info != null) {
      tyd.modifiers().add(ast.newModifier(ModifierKeyword.STATIC_KEYWORD));
      info.tyd.bodyDeclarations().add(tyd);
    }
 else {
      unit.types().add(tyd);
    }
    info=new CompositeInfo(tyd);
    if (compositeTypeSpecifier.getKey() == IASTCompositeTypeSpecifier.k_union) {
      Javadoc jd=ast.newJavadoc();
      TagElement tg=ast.newTagElement();
      tg.setTagName(""String_Node_Str"");
      jd.tags().add(tg);
      tyd.setJavadoc(jd);
    }
    String finalName;
    if (getSimpleName(compositeTypeSpecifier.getName()).equals(""String_Node_Str"")) {
      finalName=""String_Node_Str"" + m_anonClassCount;
      compositeMap.put(getCompleteName(compositeTypeSpecifier.getName()),info);
      m_anonClassCount++;
    }
 else {
      finalName=getSimpleName(compositeTypeSpecifier.getName());
      compositeMap.put(getCompleteName(compositeTypeSpecifier.getName()),info);
    }
    info.declSpecifier=declSpecifier;
    findSpecialMethods(declSpecifier,info);
    tyd.setName(ast.newSimpleName(finalName));
    tyd.typeParameters().addAll(templateParamsQueue);
    templateParamsQueue.clear();
    ParameterizedType type=ast.newParameterizedType(jast.newType(""String_Node_Str""));
    type.typeArguments().add(jast.newType(finalName));
    tyd.superInterfaceTypes().add(type);
    if (compositeTypeSpecifier instanceof ICPPASTCompositeTypeSpecifier) {
      ICPPASTCompositeTypeSpecifier cppCompositeTypeSpecifier=(ICPPASTCompositeTypeSpecifier)compositeTypeSpecifier;
      if (cppCompositeTypeSpecifier.getBaseSpecifiers() != null && cppCompositeTypeSpecifier.getBaseSpecifiers().length != 0) {
        tyd.setSuperclassType(jast.newType(getSimpleName(cppCompositeTypeSpecifier.getBaseSpecifiers()[0].getName())));
        info.hasSuper=true;
      }
    }
    for (    IASTDeclaration decl : compositeTypeSpecifier.getMembers()) {
      evalDeclaration(decl);
    }
    if (!info.hasCtor) {
      MethodDeclaration meth=jast.newMethodDecl().returnType(null).name(finalName).setCtor(true).toAST();
      Block blk=ast.newBlock();
      meth.setBody(blk);
      List<FieldInfo> fields=collectFieldsForClass(declSpecifier);
      generateCtorStatements(fields,meth);
      tyd.bodyDeclarations().add(meth);
    }
    if (!info.hasDtor) {
      MethodDeclaration meth=jast.newMethodDecl().returnType(ast.newPrimitiveType(PrimitiveType.VOID)).name(""String_Node_Str"").toAST();
      meth.modifiers().add(ast.newModifier(ModifierKeyword.PUBLIC_KEYWORD));
      Block blk=ast.newBlock();
      meth.setBody(blk);
      List<FieldInfo> fields=collectFieldsForClass(declSpecifier);
      generateDtorStatements(fields,meth,info.hasSuper);
      tyd.bodyDeclarations().add(meth);
    }
    if (!info.hasAssign) {
      MethodDeclaration meth=jast.newMethodDecl().returnType(jast.newType(finalName)).name(""String_Node_Str"").toAST();
      meth.modifiers().add(ast.newModifier(ModifierKeyword.PUBLIC_KEYWORD));
      SingleVariableDeclaration var=ast.newSingleVariableDeclaration();
      var.setType(jast.newType(finalName));
      var.setName(ast.newSimpleName(""String_Node_Str""));
      meth.parameters().add(var);
      Block blk=ast.newBlock();
      meth.setBody(blk);
      List<FieldInfo> fields=collectFieldsForClass(declSpecifier);
      Block ifBlock=ast.newBlock();
      if (info.hasSuper) {
        SuperMethodInvocation sup=ast.newSuperMethodInvocation();
        sup.setName(ast.newSimpleName(""String_Node_Str""));
        sup.arguments().add(ast.newSimpleName(""String_Node_Str""));
        ifBlock.statements().add(ast.newExpressionStatement(sup));
      }
      for (      FieldInfo fieldInfo : fields) {
        print(fieldInfo.field.getName());
        if (fieldInfo.isStatic)         ;
 else         if (fieldInfo.init != null && getTypeEnum(fieldInfo.field.getType()) != TypeEnum.ARRAY) {
          QualifiedName qual=ast.newQualifiedName(ast.newSimpleName(""String_Node_Str""),ast.newSimpleName(fieldInfo.field.getName()));
          MethodInvocation meth2=jast.newMethod().on(ast.newSimpleName(fieldInfo.field.getName())).call(""String_Node_Str"").with(qual).toAST();
          ifBlock.statements().add(ast.newExpressionStatement(meth2));
        }
 else         if (getTypeEnum(fieldInfo.field.getType()) == TypeEnum.ARRAY && getTypeEnum(getArrayBaseType(fieldInfo.field.getType())) == TypeEnum.OTHER) {
          QualifiedName qual=ast.newQualifiedName(ast.newSimpleName(""String_Node_Str""),ast.newSimpleName(fieldInfo.field.getName()));
          MethodInvocation meth3=jast.newMethod().on(""String_Node_Str"").call(""String_Node_Str"").with(ast.newSimpleName(fieldInfo.field.getName())).with(qual).toAST();
          ifBlock.statements().add(ast.newExpressionStatement(meth3));
        }
 else         if (getTypeEnum(fieldInfo.field.getType()) == TypeEnum.ARRAY) {
          QualifiedName qual=ast.newQualifiedName(ast.newSimpleName(""String_Node_Str""),ast.newSimpleName(fieldInfo.field.getName()));
          String methodName=""String_Node_Str"";
          if (getArraySizeExpressions(fieldInfo.field.getType()).size() > 1)           methodName=""String_Node_Str"";
          MethodInvocation meth3=jast.newMethod().on(""String_Node_Str"").call(methodName).with(ast.newSimpleName(fieldInfo.field.getName())).with(qual).toAST();
          ifBlock.statements().add(ast.newExpressionStatement(meth3));
        }
 else {
          QualifiedName qual=ast.newQualifiedName(ast.newSimpleName(""String_Node_Str""),ast.newSimpleName(fieldInfo.field.getName()));
          Assignment assign=jast.newAssign().left(ast.newSimpleName(fieldInfo.field.getName())).right(qual).op(Assignment.Operator.ASSIGN).toAST();
          ifBlock.statements().add(ast.newExpressionStatement(assign));
        }
      }
      if (!ifBlock.statements().isEmpty()) {
        IfStatement ifStmt=ast.newIfStatement();
        InfixExpression condition=ast.newInfixExpression();
        condition.setLeftOperand(ast.newSimpleName(""String_Node_Str""));
        condition.setRightOperand(ast.newThisExpression());
        condition.setOperator(InfixExpression.Operator.NOT_EQUALS);
        ifStmt.setExpression(condition);
        ifStmt.setThenStatement(ifBlock);
        blk.statements().add(ifStmt);
      }
      blk.statements().add(jast.newReturn(ast.newThisExpression()));
      tyd.bodyDeclarations().add(meth);
    }
    if (!info.hasCopy) {
      MethodDeclaration meth=jast.newMethodDecl().returnType(null).name(finalName).setCtor(true).toAST();
      SingleVariableDeclaration var=ast.newSingleVariableDeclaration();
      var.setType(jast.newType(finalName));
      var.setName(ast.newSimpleName(""String_Node_Str""));
      meth.parameters().add(var);
      Block blk=ast.newBlock();
      meth.setBody(blk);
      List<FieldInfo> fields=collectFieldsForClass(declSpecifier);
      if (info.hasSuper) {
        SuperConstructorInvocation sup=ast.newSuperConstructorInvocation();
        sup.arguments().add(ast.newSimpleName(""String_Node_Str""));
        blk.statements().add(sup);
      }
      for (      FieldInfo fieldInfo : fields) {
        print(fieldInfo.field.getName());
        if (fieldInfo.isStatic)         ;
 else         if (fieldInfo.init != null && getTypeEnum(fieldInfo.field.getType()) != TypeEnum.ARRAY) {
          QualifiedName qual=ast.newQualifiedName(ast.newSimpleName(""String_Node_Str""),ast.newSimpleName(fieldInfo.field.getName()));
          MethodInvocation meth2=jast.newMethod().on(qual).call(""String_Node_Str"").toAST();
          Assignment assign=jast.newAssign().left(ast.newSimpleName(fieldInfo.field.getName())).right(meth2).op(Assignment.Operator.ASSIGN).toAST();
          blk.statements().add(ast.newExpressionStatement(assign));
        }
 else         if (getTypeEnum(fieldInfo.field.getType()) == TypeEnum.ARRAY && getTypeEnum(getArrayBaseType(fieldInfo.field.getType())) == TypeEnum.OTHER) {
          QualifiedName qual=ast.newQualifiedName(ast.newSimpleName(""String_Node_Str""),ast.newSimpleName(fieldInfo.field.getName()));
          MethodInvocation meth3=jast.newMethod().on(""String_Node_Str"").call(""String_Node_Str"").with(qual).toAST();
          CastExpression cast=ast.newCastExpression();
          cast.setType(cppToJavaType(fieldInfo.field.getType()));
          cast.setExpression(meth3);
          Assignment assign=jast.newAssign().left(ast.newSimpleName(fieldInfo.field.getName())).right(cast).op(Assignment.Operator.ASSIGN).toAST();
          blk.statements().add(ast.newExpressionStatement(assign));
        }
 else         if (getTypeEnum(fieldInfo.field.getType()) == TypeEnum.ARRAY) {
          QualifiedName qual=ast.newQualifiedName(ast.newSimpleName(""String_Node_Str""),ast.newSimpleName(fieldInfo.field.getName()));
          String methodName=""String_Node_Str"";
          if (getArraySizeExpressions(fieldInfo.field.getType()).size() > 1)           methodName=""String_Node_Str"";
          MethodInvocation meth3=jast.newMethod().on(""String_Node_Str"").call(methodName).with(ast.newSimpleName(fieldInfo.field.getName())).with(qual).toAST();
          CastExpression cast=ast.newCastExpression();
          cast.setType(cppToJavaType(fieldInfo.field.getType()));
          cast.setExpression(meth3);
          Assignment assign=jast.newAssign().left(ast.newSimpleName(fieldInfo.field.getName())).right(cast).op(Assignment.Operator.ASSIGN).toAST();
          blk.statements().add(ast.newExpressionStatement(assign));
        }
 else {
          QualifiedName qual=ast.newQualifiedName(ast.newSimpleName(""String_Node_Str""),ast.newSimpleName(fieldInfo.field.getName()));
          Assignment assign=jast.newAssign().left(ast.newSimpleName(fieldInfo.field.getName())).right(qual).op(Assignment.Operator.ASSIGN).toAST();
          blk.statements().add(ast.newExpressionStatement(assign));
        }
      }
      tyd.bodyDeclarations().add(meth);
    }
    MethodDeclaration meth=jast.newMethodDecl().returnType(jast.newType(finalName)).name(""String_Node_Str"").toAST();
    meth.modifiers().add(ast.newModifier(ModifierKeyword.PUBLIC_KEYWORD));
    ClassInstanceCreation create=ast.newClassInstanceCreation();
    create.setType(jast.newType(finalName));
    create.arguments().add(ast.newThisExpression());
    ReturnStatement stmt=jast.newReturn(create);
    Block blk=ast.newBlock();
    blk.statements().add(stmt);
    meth.setBody(blk);
    tyd.bodyDeclarations().add(meth);
  }
 else   if (declSpecifier instanceof IASTElaboratedTypeSpecifier) {
    IASTElaboratedTypeSpecifier elaboratedTypeSpecifier=(IASTElaboratedTypeSpecifier)declSpecifier;
    print(""String_Node_Str"" + elaboratedTypeSpecifier.getRawSignature());
    getSimpleName(elaboratedTypeSpecifier.getName());
    if (declSpecifier instanceof ICPPASTElaboratedTypeSpecifier) {
      print(""String_Node_Str"");
    }
  }
 else   if (declSpecifier instanceof IASTEnumerationSpecifier) {
    IASTEnumerationSpecifier enumerationSpecifier=(IASTEnumerationSpecifier)declSpecifier;
    generateEnumeration(enumerationSpecifier);
  }
 else   if (declSpecifier instanceof IASTNamedTypeSpecifier) {
    IASTNamedTypeSpecifier namedTypeSpecifier=(IASTNamedTypeSpecifier)declSpecifier;
    print(""String_Node_Str"");
    getSimpleName(namedTypeSpecifier.getName());
    if (declSpecifier instanceof ICPPASTNamedTypeSpecifier) {
      print(""String_Node_Str"");
    }
  }
 else   if (declSpecifier instanceof IASTSimpleDeclSpecifier) {
    IASTSimpleDeclSpecifier simple=(IASTSimpleDeclSpecifier)declSpecifier;
    print(""String_Node_Str"");
    if (declSpecifier instanceof ICPPASTSimpleDeclSpecifier) {
      print(""String_Node_Str"");
    }
    evaluateSimpleType(simple.getType(),simple.isShort(),simple.isLong(),simple.isUnsigned());
  }
 else   if (declSpecifier instanceof ICASTDeclSpecifier) {
    print(""String_Node_Str"");
  }
  return null;
}","/** 
 * Attempts to evaluate the given declaration specifier
 */
private TypeDeclaration evalDeclSpecifier(IASTDeclSpecifier declSpecifier) throws DOMException {
  if (declSpecifier instanceof IASTCompositeTypeSpecifier) {
    IASTCompositeTypeSpecifier compositeTypeSpecifier=(IASTCompositeTypeSpecifier)declSpecifier;
    print(""String_Node_Str"");
    TypeDeclaration tyd=ast.newTypeDeclaration();
    CompositeInfo info=compositeMap.get(getQualifiedPart(compositeTypeSpecifier.getName()));
    if (info != null) {
      tyd.modifiers().add(ast.newModifier(ModifierKeyword.STATIC_KEYWORD));
      info.tyd.bodyDeclarations().add(tyd);
    }
 else {
      unit.types().add(tyd);
    }
    info=new CompositeInfo(tyd);
    if (compositeTypeSpecifier.getKey() == IASTCompositeTypeSpecifier.k_union) {
      Javadoc jd=ast.newJavadoc();
      TagElement tg=ast.newTagElement();
      tg.setTagName(""String_Node_Str"");
      jd.tags().add(tg);
      tyd.setJavadoc(jd);
    }
    String finalName;
    if (getSimpleName(compositeTypeSpecifier.getName()).equals(""String_Node_Str"")) {
      finalName=""String_Node_Str"" + m_anonClassCount;
      compositeMap.put(getCompleteName(compositeTypeSpecifier.getName()),info);
      m_anonClassCount++;
    }
 else {
      finalName=getSimpleName(compositeTypeSpecifier.getName());
      compositeMap.put(getCompleteName(compositeTypeSpecifier.getName()),info);
    }
    info.declSpecifier=declSpecifier;
    findSpecialMethods(declSpecifier,info);
    tyd.setName(ast.newSimpleName(finalName));
    tyd.typeParameters().addAll(templateParamsQueue);
    templateParamsQueue.clear();
    ParameterizedType type=ast.newParameterizedType(jast.newType(""String_Node_Str""));
    type.typeArguments().add(jast.newType(finalName));
    tyd.superInterfaceTypes().add(type);
    if (compositeTypeSpecifier instanceof ICPPASTCompositeTypeSpecifier) {
      ICPPASTCompositeTypeSpecifier cppCompositeTypeSpecifier=(ICPPASTCompositeTypeSpecifier)compositeTypeSpecifier;
      if (cppCompositeTypeSpecifier.getBaseSpecifiers() != null && cppCompositeTypeSpecifier.getBaseSpecifiers().length != 0) {
        tyd.setSuperclassType(jast.newType(getSimpleName(cppCompositeTypeSpecifier.getBaseSpecifiers()[0].getName())));
        info.hasSuper=true;
      }
    }
    for (    IASTDeclaration decl : compositeTypeSpecifier.getMembers()) {
      evalDeclaration(decl);
    }
    if (!info.hasCtor) {
      MethodDeclaration meth=jast.newMethodDecl().returnType(null).name(finalName).setCtor(true).toAST();
      Block blk=ast.newBlock();
      meth.setBody(blk);
      List<FieldInfo> fields=collectFieldsForClass(declSpecifier);
      generateCtorStatements(fields,meth);
      tyd.bodyDeclarations().add(meth);
    }
    if (!info.hasDtor) {
      MethodDeclaration meth=jast.newMethodDecl().returnType(ast.newPrimitiveType(PrimitiveType.VOID)).name(""String_Node_Str"").toAST();
      meth.modifiers().add(ast.newModifier(ModifierKeyword.PUBLIC_KEYWORD));
      Block blk=ast.newBlock();
      meth.setBody(blk);
      List<FieldInfo> fields=collectFieldsForClass(declSpecifier);
      generateDtorStatements(fields,meth,info.hasSuper);
      tyd.bodyDeclarations().add(meth);
    }
    if (!info.hasAssign) {
      MethodDeclaration meth=jast.newMethodDecl().returnType(jast.newType(finalName)).name(""String_Node_Str"").toAST();
      meth.modifiers().add(ast.newModifier(ModifierKeyword.PUBLIC_KEYWORD));
      SingleVariableDeclaration var=ast.newSingleVariableDeclaration();
      var.setType(jast.newType(finalName));
      var.setName(ast.newSimpleName(""String_Node_Str""));
      meth.parameters().add(var);
      Block blk=ast.newBlock();
      meth.setBody(blk);
      List<FieldInfo> fields=collectFieldsForClass(declSpecifier);
      Block ifBlock=ast.newBlock();
      if (info.hasSuper) {
        SuperMethodInvocation sup=ast.newSuperMethodInvocation();
        sup.setName(ast.newSimpleName(""String_Node_Str""));
        sup.arguments().add(ast.newSimpleName(""String_Node_Str""));
        ifBlock.statements().add(ast.newExpressionStatement(sup));
      }
      for (      FieldInfo fieldInfo : fields) {
        print(fieldInfo.field.getName());
        if (fieldInfo.isStatic)         ;
 else         if (fieldInfo.init != null && getTypeEnum(fieldInfo.field.getType()) != TypeEnum.ARRAY) {
          QualifiedName qual=ast.newQualifiedName(ast.newSimpleName(""String_Node_Str""),ast.newSimpleName(fieldInfo.field.getName()));
          MethodInvocation meth2=jast.newMethod().on(ast.newSimpleName(fieldInfo.field.getName())).call(""String_Node_Str"").with(qual).toAST();
          ifBlock.statements().add(ast.newExpressionStatement(meth2));
        }
 else         if (getTypeEnum(fieldInfo.field.getType()) == TypeEnum.ARRAY && getTypeEnum(getArrayBaseType(fieldInfo.field.getType())) == TypeEnum.OTHER) {
          QualifiedName qual=ast.newQualifiedName(ast.newSimpleName(""String_Node_Str""),ast.newSimpleName(fieldInfo.field.getName()));
          MethodInvocation meth3=jast.newMethod().on(""String_Node_Str"").call(""String_Node_Str"").with(ast.newSimpleName(fieldInfo.field.getName())).with(qual).toAST();
          ifBlock.statements().add(ast.newExpressionStatement(meth3));
        }
 else         if (getTypeEnum(fieldInfo.field.getType()) == TypeEnum.ARRAY) {
          QualifiedName qual=ast.newQualifiedName(ast.newSimpleName(""String_Node_Str""),ast.newSimpleName(fieldInfo.field.getName()));
          String methodName=""String_Node_Str"";
          if (getArraySizeExpressions(fieldInfo.field.getType()).size() > 1)           methodName=""String_Node_Str"";
          MethodInvocation meth3=jast.newMethod().on(""String_Node_Str"").call(methodName).with(ast.newSimpleName(fieldInfo.field.getName())).with(qual).toAST();
          ifBlock.statements().add(ast.newExpressionStatement(meth3));
        }
 else {
          QualifiedName qual=ast.newQualifiedName(ast.newSimpleName(""String_Node_Str""),ast.newSimpleName(fieldInfo.field.getName()));
          Assignment assign=jast.newAssign().left(ast.newSimpleName(fieldInfo.field.getName())).right(qual).op(Assignment.Operator.ASSIGN).toAST();
          ifBlock.statements().add(ast.newExpressionStatement(assign));
        }
      }
      if (!ifBlock.statements().isEmpty()) {
        IfStatement ifStmt=ast.newIfStatement();
        InfixExpression condition=ast.newInfixExpression();
        condition.setLeftOperand(ast.newSimpleName(""String_Node_Str""));
        condition.setRightOperand(ast.newThisExpression());
        condition.setOperator(InfixExpression.Operator.NOT_EQUALS);
        ifStmt.setExpression(condition);
        ifStmt.setThenStatement(ifBlock);
        blk.statements().add(ifStmt);
      }
      blk.statements().add(jast.newReturn(ast.newThisExpression()));
      tyd.bodyDeclarations().add(meth);
    }
    if (!info.hasCopy) {
      MethodDeclaration meth=jast.newMethodDecl().returnType(null).name(finalName).setCtor(true).toAST();
      SingleVariableDeclaration var=ast.newSingleVariableDeclaration();
      var.setType(jast.newType(finalName));
      var.setName(ast.newSimpleName(""String_Node_Str""));
      meth.parameters().add(var);
      Block blk=ast.newBlock();
      meth.setBody(blk);
      List<FieldInfo> fields=collectFieldsForClass(declSpecifier);
      if (info.hasSuper) {
        SuperConstructorInvocation sup=ast.newSuperConstructorInvocation();
        sup.arguments().add(ast.newSimpleName(""String_Node_Str""));
        blk.statements().add(sup);
      }
      for (      FieldInfo fieldInfo : fields) {
        print(fieldInfo.field.getName());
        if (fieldInfo.isStatic)         ;
 else         if (fieldInfo.init != null && getTypeEnum(fieldInfo.field.getType()) != TypeEnum.ARRAY) {
          QualifiedName qual=ast.newQualifiedName(ast.newSimpleName(""String_Node_Str""),ast.newSimpleName(fieldInfo.field.getName()));
          MethodInvocation meth2=jast.newMethod().on(qual).call(""String_Node_Str"").toAST();
          Assignment assign=jast.newAssign().left(ast.newSimpleName(fieldInfo.field.getName())).right(meth2).op(Assignment.Operator.ASSIGN).toAST();
          blk.statements().add(ast.newExpressionStatement(assign));
        }
 else         if (getTypeEnum(fieldInfo.field.getType()) == TypeEnum.ARRAY && getTypeEnum(getArrayBaseType(fieldInfo.field.getType())) == TypeEnum.OTHER) {
          QualifiedName qual=ast.newQualifiedName(ast.newSimpleName(""String_Node_Str""),ast.newSimpleName(fieldInfo.field.getName()));
          MethodInvocation meth3=jast.newMethod().on(""String_Node_Str"").call(""String_Node_Str"").with(qual).toAST();
          CastExpression cast=ast.newCastExpression();
          cast.setType(cppToJavaType(fieldInfo.field.getType()));
          cast.setExpression(meth3);
          Assignment assign=jast.newAssign().left(ast.newSimpleName(fieldInfo.field.getName())).right(cast).op(Assignment.Operator.ASSIGN).toAST();
          blk.statements().add(ast.newExpressionStatement(assign));
        }
 else         if (getTypeEnum(fieldInfo.field.getType()) == TypeEnum.ARRAY) {
          QualifiedName qual=ast.newQualifiedName(ast.newSimpleName(""String_Node_Str""),ast.newSimpleName(fieldInfo.field.getName()));
          String methodName=""String_Node_Str"";
          if (getArraySizeExpressions(fieldInfo.field.getType()).size() > 1)           methodName=""String_Node_Str"";
          MethodInvocation meth3=jast.newMethod().on(""String_Node_Str"").call(methodName).with(qual).toAST();
          CastExpression cast=ast.newCastExpression();
          cast.setType(cppToJavaType(fieldInfo.field.getType()));
          cast.setExpression(meth3);
          Assignment assign=jast.newAssign().left(ast.newSimpleName(fieldInfo.field.getName())).right(cast).op(Assignment.Operator.ASSIGN).toAST();
          blk.statements().add(ast.newExpressionStatement(assign));
        }
 else {
          QualifiedName qual=ast.newQualifiedName(ast.newSimpleName(""String_Node_Str""),ast.newSimpleName(fieldInfo.field.getName()));
          Assignment assign=jast.newAssign().left(ast.newSimpleName(fieldInfo.field.getName())).right(qual).op(Assignment.Operator.ASSIGN).toAST();
          blk.statements().add(ast.newExpressionStatement(assign));
        }
      }
      tyd.bodyDeclarations().add(meth);
    }
    MethodDeclaration meth=jast.newMethodDecl().returnType(jast.newType(finalName)).name(""String_Node_Str"").toAST();
    meth.modifiers().add(ast.newModifier(ModifierKeyword.PUBLIC_KEYWORD));
    ClassInstanceCreation create=ast.newClassInstanceCreation();
    create.setType(jast.newType(finalName));
    create.arguments().add(ast.newThisExpression());
    ReturnStatement stmt=jast.newReturn(create);
    Block blk=ast.newBlock();
    blk.statements().add(stmt);
    meth.setBody(blk);
    tyd.bodyDeclarations().add(meth);
  }
 else   if (declSpecifier instanceof IASTElaboratedTypeSpecifier) {
    IASTElaboratedTypeSpecifier elaboratedTypeSpecifier=(IASTElaboratedTypeSpecifier)declSpecifier;
    print(""String_Node_Str"" + elaboratedTypeSpecifier.getRawSignature());
    getSimpleName(elaboratedTypeSpecifier.getName());
    if (declSpecifier instanceof ICPPASTElaboratedTypeSpecifier) {
      print(""String_Node_Str"");
    }
  }
 else   if (declSpecifier instanceof IASTEnumerationSpecifier) {
    IASTEnumerationSpecifier enumerationSpecifier=(IASTEnumerationSpecifier)declSpecifier;
    generateEnumeration(enumerationSpecifier);
  }
 else   if (declSpecifier instanceof IASTNamedTypeSpecifier) {
    IASTNamedTypeSpecifier namedTypeSpecifier=(IASTNamedTypeSpecifier)declSpecifier;
    print(""String_Node_Str"");
    getSimpleName(namedTypeSpecifier.getName());
    if (declSpecifier instanceof ICPPASTNamedTypeSpecifier) {
      print(""String_Node_Str"");
    }
  }
 else   if (declSpecifier instanceof IASTSimpleDeclSpecifier) {
    IASTSimpleDeclSpecifier simple=(IASTSimpleDeclSpecifier)declSpecifier;
    print(""String_Node_Str"");
    if (declSpecifier instanceof ICPPASTSimpleDeclSpecifier) {
      print(""String_Node_Str"");
    }
    evaluateSimpleType(simple.getType(),simple.isShort(),simple.isLong(),simple.isUnsigned());
  }
 else   if (declSpecifier instanceof ICASTDeclSpecifier) {
    print(""String_Node_Str"");
  }
  return null;
}"
50108,"/** 
 * Attempts to evaluate the given declaration specifier
 */
private TypeDeclaration evalDeclSpecifier(IASTDeclSpecifier declSpecifier) throws DOMException {
  if (declSpecifier instanceof IASTCompositeTypeSpecifier) {
    IASTCompositeTypeSpecifier compositeTypeSpecifier=(IASTCompositeTypeSpecifier)declSpecifier;
    print(""String_Node_Str"");
    TypeDeclaration tyd=ast.newTypeDeclaration();
    CompositeInfo info=compositeMap.get(getQualifiedPart(compositeTypeSpecifier.getName()));
    if (info != null) {
      tyd.modifiers().add(ast.newModifier(ModifierKeyword.STATIC_KEYWORD));
      info.tyd.bodyDeclarations().add(tyd);
    }
 else {
      unit.types().add(tyd);
    }
    info=new CompositeInfo(tyd);
    if (compositeTypeSpecifier.getKey() == IASTCompositeTypeSpecifier.k_union) {
      Javadoc jd=ast.newJavadoc();
      TagElement tg=ast.newTagElement();
      tg.setTagName(""String_Node_Str"");
      jd.tags().add(tg);
      tyd.setJavadoc(jd);
    }
    String finalName;
    if (getSimpleName(compositeTypeSpecifier.getName()).equals(""String_Node_Str"")) {
      finalName=""String_Node_Str"" + m_anonClassCount;
      compositeMap.put(getCompleteName(compositeTypeSpecifier.getName()),info);
      m_anonClassCount++;
    }
 else {
      finalName=getSimpleName(compositeTypeSpecifier.getName());
      compositeMap.put(getCompleteName(compositeTypeSpecifier.getName()),info);
    }
    info.declSpecifier=declSpecifier;
    findSpecialMethods(declSpecifier,info);
    tyd.setName(ast.newSimpleName(finalName));
    tyd.typeParameters().addAll(templateParamsQueue);
    templateParamsQueue.clear();
    ParameterizedType type=ast.newParameterizedType(jast.newType(""String_Node_Str""));
    type.typeArguments().add(jast.newType(finalName));
    tyd.superInterfaceTypes().add(type);
    if (compositeTypeSpecifier instanceof ICPPASTCompositeTypeSpecifier) {
      ICPPASTCompositeTypeSpecifier cppCompositeTypeSpecifier=(ICPPASTCompositeTypeSpecifier)compositeTypeSpecifier;
      if (cppCompositeTypeSpecifier.getBaseSpecifiers() != null && cppCompositeTypeSpecifier.getBaseSpecifiers().length != 0) {
        tyd.setSuperclassType(jast.newType(getSimpleName(cppCompositeTypeSpecifier.getBaseSpecifiers()[0].getName())));
      }
    }
    for (    IASTDeclaration decl : compositeTypeSpecifier.getMembers()) {
      evalDeclaration(decl);
    }
    if (!info.hasCtor) {
      MethodDeclaration meth=jast.newMethodDecl().returnType(null).name(finalName).setCtor(true).toAST();
      Block blk=ast.newBlock();
      meth.setBody(blk);
      List<FieldInfo> fields=collectFieldsForClass(declSpecifier);
      generateCtorStatements(fields,meth);
      tyd.bodyDeclarations().add(meth);
    }
    if (!info.hasDtor) {
      MethodDeclaration meth=jast.newMethodDecl().returnType(ast.newPrimitiveType(PrimitiveType.VOID)).name(""String_Node_Str"").toAST();
      meth.modifiers().add(ast.newModifier(ModifierKeyword.PUBLIC_KEYWORD));
      Block blk=ast.newBlock();
      meth.setBody(blk);
      List<FieldInfo> fields=collectFieldsForClass(declSpecifier);
      generateDtorStatements(fields,meth);
      tyd.bodyDeclarations().add(meth);
    }
    if (!info.hasAssign) {
      MethodDeclaration meth=jast.newMethodDecl().returnType(jast.newType(finalName)).name(""String_Node_Str"").toAST();
      meth.modifiers().add(ast.newModifier(ModifierKeyword.PUBLIC_KEYWORD));
      SingleVariableDeclaration var=ast.newSingleVariableDeclaration();
      var.setType(jast.newType(finalName));
      var.setName(ast.newSimpleName(""String_Node_Str""));
      meth.parameters().add(var);
      Block blk=ast.newBlock();
      meth.setBody(blk);
      List<FieldInfo> fields=collectFieldsForClass(declSpecifier);
      if (!fields.isEmpty()) {
        IfStatement ifStmt=ast.newIfStatement();
        InfixExpression condition=ast.newInfixExpression();
        condition.setLeftOperand(ast.newSimpleName(""String_Node_Str""));
        condition.setRightOperand(ast.newThisExpression());
        condition.setOperator(InfixExpression.Operator.NOT_EQUALS);
        ifStmt.setExpression(condition);
        Block ifBlock=ast.newBlock();
        ifStmt.setThenStatement(ifBlock);
        blk.statements().add(ifStmt);
        for (        FieldInfo fieldInfo : fields) {
          print(fieldInfo.field.getName());
          if (fieldInfo.init != null && getTypeEnum(fieldInfo.field.getType()) != TypeEnum.ARRAY) {
            QualifiedName qual=ast.newQualifiedName(ast.newSimpleName(""String_Node_Str""),ast.newSimpleName(fieldInfo.field.getName()));
            MethodInvocation meth2=jast.newMethod().on(ast.newSimpleName(fieldInfo.field.getName())).call(""String_Node_Str"").with(qual).toAST();
            ifBlock.statements().add(ast.newExpressionStatement(meth2));
          }
 else           if (getTypeEnum(fieldInfo.field.getType()) == TypeEnum.ARRAY && getTypeEnum(getArrayBaseType(fieldInfo.field.getType())) == TypeEnum.OTHER) {
            QualifiedName qual=ast.newQualifiedName(ast.newSimpleName(""String_Node_Str""),ast.newSimpleName(fieldInfo.field.getName()));
            MethodInvocation meth3=jast.newMethod().on(""String_Node_Str"").call(""String_Node_Str"").with(qual).toAST();
            CastExpression cast=ast.newCastExpression();
            cast.setExpression(meth3);
            cast.setType(cppToJavaType(fieldInfo.field.getType()));
            Assignment assign=jast.newAssign().left(ast.newSimpleName(fieldInfo.field.getName())).right(cast).op(Assignment.Operator.ASSIGN).toAST();
            ifBlock.statements().add(ast.newExpressionStatement(assign));
          }
 else           if (getTypeEnum(fieldInfo.field.getType()) == TypeEnum.ARRAY) {
            QualifiedName qual=ast.newQualifiedName(ast.newSimpleName(""String_Node_Str""),ast.newSimpleName(fieldInfo.field.getName()));
            MethodInvocation meth3=jast.newMethod().on(qual).call(""String_Node_Str"").toAST();
            CastExpression cast=ast.newCastExpression();
            cast.setExpression(meth3);
            cast.setType(cppToJavaType(fieldInfo.field.getType()));
            Assignment assign=jast.newAssign().left(ast.newSimpleName(fieldInfo.field.getName())).right(cast).op(Assignment.Operator.ASSIGN).toAST();
            ifBlock.statements().add(ast.newExpressionStatement(assign));
          }
 else {
            QualifiedName qual=ast.newQualifiedName(ast.newSimpleName(""String_Node_Str""),ast.newSimpleName(fieldInfo.field.getName()));
            Assignment assign=jast.newAssign().left(ast.newSimpleName(fieldInfo.field.getName())).right(qual).op(Assignment.Operator.ASSIGN).toAST();
            ifBlock.statements().add(ast.newExpressionStatement(assign));
          }
        }
      }
      blk.statements().add(jast.newReturn(ast.newThisExpression()));
      tyd.bodyDeclarations().add(meth);
    }
    MethodDeclaration meth=jast.newMethodDecl().returnType(jast.newType(finalName)).name(""String_Node_Str"").toAST();
    meth.modifiers().add(ast.newModifier(ModifierKeyword.PUBLIC_KEYWORD));
    ClassInstanceCreation create=ast.newClassInstanceCreation();
    create.setType(jast.newType(finalName));
    create.arguments().add(ast.newThisExpression());
    ReturnStatement stmt=jast.newReturn(create);
    Block blk=ast.newBlock();
    blk.statements().add(stmt);
    meth.setBody(blk);
    tyd.bodyDeclarations().add(meth);
  }
 else   if (declSpecifier instanceof IASTElaboratedTypeSpecifier) {
    IASTElaboratedTypeSpecifier elaboratedTypeSpecifier=(IASTElaboratedTypeSpecifier)declSpecifier;
    print(""String_Node_Str"" + elaboratedTypeSpecifier.getRawSignature());
    getSimpleName(elaboratedTypeSpecifier.getName());
    if (declSpecifier instanceof ICPPASTElaboratedTypeSpecifier) {
      print(""String_Node_Str"");
    }
  }
 else   if (declSpecifier instanceof IASTEnumerationSpecifier) {
    IASTEnumerationSpecifier enumerationSpecifier=(IASTEnumerationSpecifier)declSpecifier;
    generateEnumeration(enumerationSpecifier);
  }
 else   if (declSpecifier instanceof IASTNamedTypeSpecifier) {
    IASTNamedTypeSpecifier namedTypeSpecifier=(IASTNamedTypeSpecifier)declSpecifier;
    print(""String_Node_Str"");
    getSimpleName(namedTypeSpecifier.getName());
    if (declSpecifier instanceof ICPPASTNamedTypeSpecifier) {
      print(""String_Node_Str"");
    }
  }
 else   if (declSpecifier instanceof IASTSimpleDeclSpecifier) {
    IASTSimpleDeclSpecifier simple=(IASTSimpleDeclSpecifier)declSpecifier;
    print(""String_Node_Str"");
    if (declSpecifier instanceof ICPPASTSimpleDeclSpecifier) {
      print(""String_Node_Str"");
    }
    evaluateSimpleType(simple.getType(),simple.isShort(),simple.isLong(),simple.isUnsigned());
  }
 else   if (declSpecifier instanceof ICASTDeclSpecifier) {
    print(""String_Node_Str"");
  }
  return null;
}","/** 
 * Attempts to evaluate the given declaration specifier
 */
private TypeDeclaration evalDeclSpecifier(IASTDeclSpecifier declSpecifier) throws DOMException {
  if (declSpecifier instanceof IASTCompositeTypeSpecifier) {
    IASTCompositeTypeSpecifier compositeTypeSpecifier=(IASTCompositeTypeSpecifier)declSpecifier;
    print(""String_Node_Str"");
    TypeDeclaration tyd=ast.newTypeDeclaration();
    CompositeInfo info=compositeMap.get(getQualifiedPart(compositeTypeSpecifier.getName()));
    if (info != null) {
      tyd.modifiers().add(ast.newModifier(ModifierKeyword.STATIC_KEYWORD));
      info.tyd.bodyDeclarations().add(tyd);
    }
 else {
      unit.types().add(tyd);
    }
    info=new CompositeInfo(tyd);
    if (compositeTypeSpecifier.getKey() == IASTCompositeTypeSpecifier.k_union) {
      Javadoc jd=ast.newJavadoc();
      TagElement tg=ast.newTagElement();
      tg.setTagName(""String_Node_Str"");
      jd.tags().add(tg);
      tyd.setJavadoc(jd);
    }
    String finalName;
    if (getSimpleName(compositeTypeSpecifier.getName()).equals(""String_Node_Str"")) {
      finalName=""String_Node_Str"" + m_anonClassCount;
      compositeMap.put(getCompleteName(compositeTypeSpecifier.getName()),info);
      m_anonClassCount++;
    }
 else {
      finalName=getSimpleName(compositeTypeSpecifier.getName());
      compositeMap.put(getCompleteName(compositeTypeSpecifier.getName()),info);
    }
    info.declSpecifier=declSpecifier;
    findSpecialMethods(declSpecifier,info);
    tyd.setName(ast.newSimpleName(finalName));
    tyd.typeParameters().addAll(templateParamsQueue);
    templateParamsQueue.clear();
    ParameterizedType type=ast.newParameterizedType(jast.newType(""String_Node_Str""));
    type.typeArguments().add(jast.newType(finalName));
    tyd.superInterfaceTypes().add(type);
    if (compositeTypeSpecifier instanceof ICPPASTCompositeTypeSpecifier) {
      ICPPASTCompositeTypeSpecifier cppCompositeTypeSpecifier=(ICPPASTCompositeTypeSpecifier)compositeTypeSpecifier;
      if (cppCompositeTypeSpecifier.getBaseSpecifiers() != null && cppCompositeTypeSpecifier.getBaseSpecifiers().length != 0) {
        tyd.setSuperclassType(jast.newType(getSimpleName(cppCompositeTypeSpecifier.getBaseSpecifiers()[0].getName())));
      }
    }
    for (    IASTDeclaration decl : compositeTypeSpecifier.getMembers()) {
      evalDeclaration(decl);
    }
    if (!info.hasCtor) {
      MethodDeclaration meth=jast.newMethodDecl().returnType(null).name(finalName).setCtor(true).toAST();
      Block blk=ast.newBlock();
      meth.setBody(blk);
      List<FieldInfo> fields=collectFieldsForClass(declSpecifier);
      generateCtorStatements(fields,meth);
      tyd.bodyDeclarations().add(meth);
    }
    if (!info.hasDtor) {
      MethodDeclaration meth=jast.newMethodDecl().returnType(ast.newPrimitiveType(PrimitiveType.VOID)).name(""String_Node_Str"").toAST();
      meth.modifiers().add(ast.newModifier(ModifierKeyword.PUBLIC_KEYWORD));
      Block blk=ast.newBlock();
      meth.setBody(blk);
      List<FieldInfo> fields=collectFieldsForClass(declSpecifier);
      generateDtorStatements(fields,meth);
      tyd.bodyDeclarations().add(meth);
    }
    if (!info.hasAssign) {
      MethodDeclaration meth=jast.newMethodDecl().returnType(jast.newType(finalName)).name(""String_Node_Str"").toAST();
      meth.modifiers().add(ast.newModifier(ModifierKeyword.PUBLIC_KEYWORD));
      SingleVariableDeclaration var=ast.newSingleVariableDeclaration();
      var.setType(jast.newType(finalName));
      var.setName(ast.newSimpleName(""String_Node_Str""));
      meth.parameters().add(var);
      Block blk=ast.newBlock();
      meth.setBody(blk);
      List<FieldInfo> fields=collectFieldsForClass(declSpecifier);
      if (!fields.isEmpty()) {
        IfStatement ifStmt=ast.newIfStatement();
        InfixExpression condition=ast.newInfixExpression();
        condition.setLeftOperand(ast.newSimpleName(""String_Node_Str""));
        condition.setRightOperand(ast.newThisExpression());
        condition.setOperator(InfixExpression.Operator.NOT_EQUALS);
        ifStmt.setExpression(condition);
        Block ifBlock=ast.newBlock();
        ifStmt.setThenStatement(ifBlock);
        blk.statements().add(ifStmt);
        for (        FieldInfo fieldInfo : fields) {
          print(fieldInfo.field.getName());
          if (fieldInfo.init != null && getTypeEnum(fieldInfo.field.getType()) != TypeEnum.ARRAY) {
            QualifiedName qual=ast.newQualifiedName(ast.newSimpleName(""String_Node_Str""),ast.newSimpleName(fieldInfo.field.getName()));
            MethodInvocation meth2=jast.newMethod().on(ast.newSimpleName(fieldInfo.field.getName())).call(""String_Node_Str"").with(qual).toAST();
            ifBlock.statements().add(ast.newExpressionStatement(meth2));
          }
 else           if (getTypeEnum(fieldInfo.field.getType()) == TypeEnum.ARRAY && getTypeEnum(getArrayBaseType(fieldInfo.field.getType())) == TypeEnum.OTHER) {
            QualifiedName qual=ast.newQualifiedName(ast.newSimpleName(""String_Node_Str""),ast.newSimpleName(fieldInfo.field.getName()));
            MethodInvocation meth3=jast.newMethod().on(""String_Node_Str"").call(""String_Node_Str"").with(ast.newSimpleName(fieldInfo.field.getName())).with(qual).toAST();
            ifBlock.statements().add(ast.newExpressionStatement(meth3));
          }
 else           if (getTypeEnum(fieldInfo.field.getType()) == TypeEnum.ARRAY) {
            QualifiedName qual=ast.newQualifiedName(ast.newSimpleName(""String_Node_Str""),ast.newSimpleName(fieldInfo.field.getName()));
            String methodName=""String_Node_Str"";
            if (getArraySizeExpressions(fieldInfo.field.getType()).size() > 1)             methodName=""String_Node_Str"";
            MethodInvocation meth3=jast.newMethod().on(""String_Node_Str"").call(methodName).with(ast.newSimpleName(fieldInfo.field.getName())).with(qual).toAST();
            ifBlock.statements().add(ast.newExpressionStatement(meth3));
          }
 else {
            QualifiedName qual=ast.newQualifiedName(ast.newSimpleName(""String_Node_Str""),ast.newSimpleName(fieldInfo.field.getName()));
            Assignment assign=jast.newAssign().left(ast.newSimpleName(fieldInfo.field.getName())).right(qual).op(Assignment.Operator.ASSIGN).toAST();
            ifBlock.statements().add(ast.newExpressionStatement(assign));
          }
        }
      }
      blk.statements().add(jast.newReturn(ast.newThisExpression()));
      tyd.bodyDeclarations().add(meth);
    }
    MethodDeclaration meth=jast.newMethodDecl().returnType(jast.newType(finalName)).name(""String_Node_Str"").toAST();
    meth.modifiers().add(ast.newModifier(ModifierKeyword.PUBLIC_KEYWORD));
    ClassInstanceCreation create=ast.newClassInstanceCreation();
    create.setType(jast.newType(finalName));
    create.arguments().add(ast.newThisExpression());
    ReturnStatement stmt=jast.newReturn(create);
    Block blk=ast.newBlock();
    blk.statements().add(stmt);
    meth.setBody(blk);
    tyd.bodyDeclarations().add(meth);
  }
 else   if (declSpecifier instanceof IASTElaboratedTypeSpecifier) {
    IASTElaboratedTypeSpecifier elaboratedTypeSpecifier=(IASTElaboratedTypeSpecifier)declSpecifier;
    print(""String_Node_Str"" + elaboratedTypeSpecifier.getRawSignature());
    getSimpleName(elaboratedTypeSpecifier.getName());
    if (declSpecifier instanceof ICPPASTElaboratedTypeSpecifier) {
      print(""String_Node_Str"");
    }
  }
 else   if (declSpecifier instanceof IASTEnumerationSpecifier) {
    IASTEnumerationSpecifier enumerationSpecifier=(IASTEnumerationSpecifier)declSpecifier;
    generateEnumeration(enumerationSpecifier);
  }
 else   if (declSpecifier instanceof IASTNamedTypeSpecifier) {
    IASTNamedTypeSpecifier namedTypeSpecifier=(IASTNamedTypeSpecifier)declSpecifier;
    print(""String_Node_Str"");
    getSimpleName(namedTypeSpecifier.getName());
    if (declSpecifier instanceof ICPPASTNamedTypeSpecifier) {
      print(""String_Node_Str"");
    }
  }
 else   if (declSpecifier instanceof IASTSimpleDeclSpecifier) {
    IASTSimpleDeclSpecifier simple=(IASTSimpleDeclSpecifier)declSpecifier;
    print(""String_Node_Str"");
    if (declSpecifier instanceof ICPPASTSimpleDeclSpecifier) {
      print(""String_Node_Str"");
    }
    evaluateSimpleType(simple.getType(),simple.isShort(),simple.isLong(),simple.isUnsigned());
  }
 else   if (declSpecifier instanceof ICASTDeclSpecifier) {
    print(""String_Node_Str"");
  }
  return null;
}"
50109,"/** 
 * Builds default argument function calls.
 */
private void makeDefaultCalls(IASTFunctionDeclarator func,IBinding funcBinding,TypeDeclaration decl) throws DOMException {
  List<Expression> defaultValues=getDefaultValues(func);
  for (int k=defaultValues.size() - 1; k >= 0; k--) {
    if (defaultValues.get(k) == null)     break;
    MethodDeclaration methodDef=ast.newMethodDeclaration();
    methodDef.setName(ast.newSimpleName(getSimpleName(func.getName())));
    methodDef.setReturnType2(evalReturnType(funcBinding));
    methodDef.modifiers().add(ast.newModifier(ModifierKeyword.PUBLIC_KEYWORD));
    List<SingleVariableDeclaration> list=evalParameters(funcBinding);
    for (int k2=0; k2 < k; k2++)     methodDef.parameters().add(list.get(k2));
    Block funcBlockDef=ast.newBlock();
    MethodInvocation methodInvoc=ast.newMethodInvocation();
    methodInvoc.setName(ast.newSimpleName(getSimpleName(func.getName())));
    List<SimpleName> names=getArgumentNames(funcBinding);
    for (int k3=0; k3 < k; k3++)     methodInvoc.arguments().add(names.get(k3));
    List<Expression> vals=getDefaultValues(func);
    for (int k4=k; k4 < defaultValues.size(); k4++)     methodInvoc.arguments().add(vals.get(k4));
    ReturnStatement ret2=ast.newReturnStatement();
    ret2.setExpression(methodInvoc);
    funcBlockDef.statements().add(ret2);
    methodDef.setBody(funcBlockDef);
    if (decl != null)     decl.bodyDeclarations().add(methodDef);
 else {
      decl=currentDeclarations.get(getQualifiedPart(func.getName()));
      decl.bodyDeclarations().add(methodDef);
    }
  }
}","/** 
 * Builds default argument function calls. For example: int func_with_defaults(int one, int two = 5); would generate: public int func_with_defaults(int one) { return func_with_defaults(one, 5); }
 */
private void makeDefaultCalls(IASTFunctionDeclarator func,IBinding funcBinding,TypeDeclaration decl) throws DOMException {
  List<Expression> defaultValues=getDefaultValues(func);
  for (int k=defaultValues.size() - 1; k >= 0; k--) {
    if (defaultValues.get(k) == null)     break;
    MethodDeclaration methodDef=ast.newMethodDeclaration();
    methodDef.setName(ast.newSimpleName(getSimpleName(func.getName())));
    methodDef.setReturnType2(evalReturnType(funcBinding));
    methodDef.modifiers().add(ast.newModifier(ModifierKeyword.PUBLIC_KEYWORD));
    List<SingleVariableDeclaration> list=evalParameters(funcBinding);
    for (int k2=0; k2 < k; k2++)     methodDef.parameters().add(list.get(k2));
    Block funcBlockDef=ast.newBlock();
    MethodInvocation methodInvoc=ast.newMethodInvocation();
    methodInvoc.setName(ast.newSimpleName(getSimpleName(func.getName())));
    List<SimpleName> names=getArgumentNames(funcBinding);
    for (int k3=0; k3 < k; k3++)     methodInvoc.arguments().add(names.get(k3));
    List<Expression> vals=getDefaultValues(func);
    for (int k4=k; k4 < defaultValues.size(); k4++)     methodInvoc.arguments().add(vals.get(k4));
    if (evalReturnType(funcBinding).toString().equals(""String_Node_Str"")) {
      funcBlockDef.statements().add(ast.newExpressionStatement(methodInvoc));
    }
 else {
      ReturnStatement ret2=ast.newReturnStatement();
      ret2.setExpression(methodInvoc);
      funcBlockDef.statements().add(ret2);
    }
    methodDef.setBody(funcBlockDef);
    if (decl != null)     decl.bodyDeclarations().add(methodDef);
 else {
      decl=currentDeclarations.get(getQualifiedPart(func.getName()));
      decl.bodyDeclarations().add(methodDef);
    }
  }
}"
50110,"public int loadTreeAnalysis(String[] args) throws Exception {
  if (args.length < 4) {
    System.out.println(""String_Node_Str"");
    return 1;
  }
  String filename=args[1];
  String taxaloaded=args[3];
  boolean tloaded=true;
  boolean isSubset=false;
  if (taxaloaded.toLowerCase().equals(""String_Node_Str"")) {
    tloaded=false;
  }
  if (args.length == 5) {
    isSubset=true;
  }
  String graphname=args[2];
  int treeCounter=0;
  String ts=""String_Node_Str"";
  List<Tree> jt=new ArrayList<Tree>();
  MessageLogger messageLogger=new MessageLogger(""String_Node_Str"");
  Map<TreeNode,String> subsetTipInfo=null;
  Map<Tree,String> sourceForTrees=null;
  try {
    BufferedReader br=new BufferedReader(new FileReader(filename));
    boolean sourceAvail=false;
    String first=br.readLine();
    if (first.split(""String_Node_Str"").length > 1 && first.split(""String_Node_Str"")[0].length() > 0) {
      sourceAvail=true;
      sourceForTrees=new HashMap<Tree,String>();
    }
    br.close();
    br=new BufferedReader(new FileReader(filename));
    System.out.println(""String_Node_Str"" + sourceAvail + ""String_Node_Str"");
    while ((ts=br.readLine()) != null) {
      if (ts.length() > 1) {
        String source=null;
        if (sourceAvail) {
          String[] spls=ts.split(""String_Node_Str"");
          source=spls[0];
          ts=spls[1];
        }
        Tree tt=jade.tree.TreeReader.readTree(ts);
        if (tt.internalNodeCount() < 2) {
          System.out.println(""String_Node_Str"" + tt);
          continue;
        }
        if (((String)tt.getRoot().getLabel()).contains(""String_Node_Str"")) {
          if (subsetTipInfo == null)           subsetTipInfo=new HashMap<TreeNode,String>();
          String[] spls=((String)tt.getRoot().getLabel()).split(""String_Node_Str"");
          String subset=spls[1];
          ((jade.tree.JadeNode)tt.getRoot()).setName(""String_Node_Str"");
          subsetTipInfo.put(tt.getRoot(),subset);
        }
        for (        TreeNode jn : tt.externalNodes()) {
          if (((String)jn.getLabel()).contains(""String_Node_Str"")) {
            String[] spls=((String)jn.getLabel()).split(""String_Node_Str"");
            String id=spls[1];
            ((jade.tree.JadeNode)jn).setName(id);
          }
        }
        for (        TreeNode jn : tt.externalNodes()) {
          if (((String)jn.getLabel()).contains(""String_Node_Str"")) {
            if (subsetTipInfo == null) {
              subsetTipInfo=new HashMap<TreeNode,String>();
            }
            String[] spls=((String)jn.getLabel()).split(""String_Node_Str"");
            String name=spls[0];
            String subset=spls[1];
            ((jade.tree.JadeNode)jn).setName(name);
            subsetTipInfo.put(jn,subset);
          }
        }
        if (sourceAvail) {
          sourceForTrees.put(tt,source);
        }
        jt.add(tt);
        treeCounter++;
      }
    }
    br.close();
  }
 catch (  FileNotFoundException e) {
    System.err.println(""String_Node_Str"" + args[1] + ""String_Node_Str"");
    return -1;
  }
catch (  IOException ioe) {
  }
  if (treeCounter == 0) {
    System.err.println(""String_Node_Str"" + args[1] + ""String_Node_Str"");
    return -1;
  }
  System.out.println(treeCounter + ""String_Node_Str"");
  GraphDatabaseAgent gdb=new GraphDatabaseAgent(graphname);
  System.out.println(""String_Node_Str"");
  BipartOracle bo=new BipartOracle(jt,gdb,tloaded,sourceForTrees,subsetTipInfo,isSubset,filename);
  gdb.shutdownDb();
  return 0;
}","public int loadTreeAnalysis(String[] args) throws Exception {
  if (args.length < 4) {
    System.out.println(""String_Node_Str"");
    return 1;
  }
  String filename=args[1];
  String taxaloaded=args[3];
  boolean tloaded=true;
  boolean isSubset=false;
  if (taxaloaded.toLowerCase().equals(""String_Node_Str"")) {
    tloaded=false;
  }
  if (args.length == 5) {
    isSubset=true;
  }
  String graphname=args[2];
  int treeCounter=0;
  String ts=""String_Node_Str"";
  List<Tree> jt=new ArrayList<Tree>();
  MessageLogger messageLogger=new MessageLogger(""String_Node_Str"");
  Map<TreeNode,String> subsetTipInfo=null;
  Map<Tree,String> sourceForTrees=null;
  try {
    BufferedReader br=new BufferedReader(new FileReader(filename));
    boolean sourceAvail=false;
    String first=br.readLine();
    if (first.split(""String_Node_Str"").length > 1 && first.split(""String_Node_Str"")[0].length() > 0) {
      sourceAvail=true;
      sourceForTrees=new HashMap<Tree,String>();
    }
    br.close();
    br=new BufferedReader(new FileReader(filename));
    System.out.println(""String_Node_Str"" + sourceAvail + ""String_Node_Str"");
    while ((ts=br.readLine()) != null) {
      if (ts.length() > 1) {
        String source=null;
        if (sourceAvail) {
          String[] spls=ts.split(""String_Node_Str"");
          source=spls[0].replace(""String_Node_Str"",""String_Node_Str"");
          ts=spls[1];
        }
        Tree tt=jade.tree.TreeReader.readTree(ts);
        if (tt.internalNodeCount() < 2) {
          System.out.println(""String_Node_Str"" + tt);
          continue;
        }
        if (((String)tt.getRoot().getLabel()).contains(""String_Node_Str"")) {
          if (subsetTipInfo == null)           subsetTipInfo=new HashMap<TreeNode,String>();
          String[] spls=((String)tt.getRoot().getLabel()).split(""String_Node_Str"");
          String subset=spls[1];
          ((jade.tree.JadeNode)tt.getRoot()).setName(""String_Node_Str"");
          subsetTipInfo.put(tt.getRoot(),subset);
        }
        for (        TreeNode jn : tt.externalNodes()) {
          if (((String)jn.getLabel()).contains(""String_Node_Str"")) {
            String[] spls=((String)jn.getLabel()).split(""String_Node_Str"");
            String id=spls[1];
            ((jade.tree.JadeNode)jn).setName(id);
          }
        }
        for (        TreeNode jn : tt.externalNodes()) {
          if (((String)jn.getLabel()).contains(""String_Node_Str"")) {
            if (subsetTipInfo == null) {
              subsetTipInfo=new HashMap<TreeNode,String>();
            }
            String[] spls=((String)jn.getLabel()).split(""String_Node_Str"");
            String name=spls[0];
            String subset=spls[1];
            ((jade.tree.JadeNode)jn).setName(name);
            subsetTipInfo.put(jn,subset);
          }
        }
        if (sourceAvail) {
          sourceForTrees.put(tt,source);
        }
        jt.add(tt);
        treeCounter++;
      }
    }
    br.close();
  }
 catch (  FileNotFoundException e) {
    System.err.println(""String_Node_Str"" + args[1] + ""String_Node_Str"");
    return -1;
  }
catch (  IOException ioe) {
  }
  if (treeCounter == 0) {
    System.err.println(""String_Node_Str"" + args[1] + ""String_Node_Str"");
    return -1;
  }
  System.out.println(treeCounter + ""String_Node_Str"");
  GraphDatabaseAgent gdb=new GraphDatabaseAgent(graphname);
  System.out.println(""String_Node_Str"");
  BipartOracle bo=new BipartOracle(jt,gdb,tloaded,sourceForTrees,subsetTipInfo,isSubset,filename);
  gdb.shutdownDb();
  return 0;
}"
50111,"public static MappingRepresentation getSourceMetadataRepresentation(JadeNode inNode){
  HashMap<String,Node> sourceNameToMetadataNodeMap=(HashMap<String,Node>)inNode.getObject(""String_Node_Str"");
  HashMap<String,Object> sourceMetadataMap=new HashMap<String,Object>();
  for (  String sourceName : sourceNameToMetadataNodeMap.keySet()) {
    HashMap<String,Object> studyMetadata=new HashMap<String,Object>();
    Node metadataNode=sourceNameToMetadataNodeMap.get(sourceName);
    if (sourceName == null || sourceName.length() == 0) {
      sourceName=""String_Node_Str"";
    }
    if (metadataNode == null) {
      HashMap<String,Object> indStudy=GeneralUtils.reformatSourceID(sourceName);
      studyMetadata.putAll(indStudy);
      sourceMetadataMap.put(sourceName,studyMetadata);
    }
 else {
      for (      SourceProperty p : SourceProperty.values()) {
        if (metadataNode.hasProperty(p.propertyName)) {
          if (!p.propertyName.equals(""String_Node_Str"")) {
            if (p.propertyName.equals(""String_Node_Str"")) {
              String sStudy=String.valueOf(metadataNode.getProperty(p.propertyName));
              if (sStudy.compareTo(""String_Node_Str"") == 0) {
                GraphDatabaseAgent gda=new GraphDatabaseAgent(metadataNode.getGraphDatabase());
                String taxVersion=String.valueOf(gda.getGraphProperty(""String_Node_Str""));
                gda.shutdownDb();
                studyMetadata.put(""String_Node_Str"",taxVersion);
              }
 else {
                HashMap<String,Object> indStudy=GeneralUtils.reformatSourceID(sStudy);
                studyMetadata.putAll(indStudy);
              }
            }
 else {
              studyMetadata.put(p.propertyName,p.type.cast(metadataNode.getProperty(p.propertyName)));
            }
          }
        }
      }
      sourceMetadataMap.put(sourceName,studyMetadata);
    }
  }
  return GeneralizedMappingRepresentation.getMapRepresentation(sourceMetadataMap);
}","public static MappingRepresentation getSourceMetadataRepresentation(JadeNode inNode){
  HashMap<String,Node> sourceNameToMetadataNodeMap=(HashMap<String,Node>)inNode.getObject(""String_Node_Str"");
  HashMap<String,Object> sourceMetadataMap=new HashMap<String,Object>();
  for (  String sourceName : sourceNameToMetadataNodeMap.keySet()) {
    HashMap<String,Object> studyMetadata=new HashMap<String,Object>();
    Node metadataNode=sourceNameToMetadataNodeMap.get(sourceName);
    if (sourceName == null || sourceName.length() == 0) {
      sourceName=""String_Node_Str"";
    }
    if (metadataNode == null) {
      sourceMetadataMap.put(sourceName,null);
    }
 else {
      for (      SourceProperty p : SourceProperty.values()) {
        if (metadataNode.hasProperty(p.propertyName)) {
          if (!p.propertyName.equals(""String_Node_Str"")) {
            if (p.propertyName.equals(""String_Node_Str"")) {
              String sStudy=String.valueOf(metadataNode.getProperty(p.propertyName));
              if (sStudy.compareTo(""String_Node_Str"") == 0) {
                GraphDatabaseAgent gda=new GraphDatabaseAgent(metadataNode.getGraphDatabase());
                String taxVersion=String.valueOf(gda.getGraphProperty(""String_Node_Str""));
                gda.shutdownDb();
                studyMetadata.put(""String_Node_Str"",taxVersion);
              }
 else {
                HashMap<String,Object> indStudy=GeneralUtils.reformatSourceID(sStudy);
                studyMetadata.putAll(indStudy);
              }
            }
 else {
              studyMetadata.put(p.propertyName,p.type.cast(metadataNode.getProperty(p.propertyName)));
            }
          }
        }
      }
      sourceMetadataMap.put(sourceName,studyMetadata);
    }
  }
  return GeneralizedMappingRepresentation.getMapRepresentation(sourceMetadataMap);
}"
50112,"/** 
 * Used to add missing external nodes to the draft tree stored in the graph.
 * @param startNode
 * @param taxRootNode
 */
private void addMissingChildrenToDraftTreewhile(Node startNode,Node taxRootNode){
  String[] supportingSources=new String[1];
  supportingSources[0]=""String_Node_Str"";
  TLongArrayList taxaleft=new TLongArrayList((long[])startNode.getProperty(""String_Node_Str""));
  while (taxaleft.removeAll(knownIdsInTree) == true) {
    continue;
  }
  System.out.println(""String_Node_Str"" + taxaleft.size());
  while (taxaleft.size() > 0) {
    System.out.print(""String_Node_Str"" + taxaleft.size());
    long tid=taxaleft.removeAt(0);
    Node taxNode=graphDb.getNodeById(tid);
    System.out.println(""String_Node_Str"" + ((String)taxNode.getProperty(""String_Node_Str"")));
    TLongArrayList ttmrca=new TLongArrayList((long[])taxNode.getProperty(""String_Node_Str""));
    if (taxNode.hasRelationship(Direction.OUTGOING,RelType.SYNTHCHILDOF)) {
      continue;
    }
    Node ptaxNode=taxNode.getSingleRelationship(RelType.TAXCHILDOF,Direction.OUTGOING).getEndNode();
    ArrayList<Node> nodesInTree=new ArrayList<Node>();
    for (    long cid : (long[])ptaxNode.getProperty(""String_Node_Str"")) {
      Node childNode=graphDb.getNodeById(cid);
      if (knownIdsInTree.contains(cid)) {
        nodesInTree.add(childNode);
      }
    }
    if (nodesInTree.size() > 1) {
      Node mrca=null;
      mrca=getLICAForDraftTreeNodes(nodesInTree);
      Node taxmrca=null;
      taxmrca=getTaxonomyMRCA(nodesInTree);
      boolean going=true;
      ImmutableCompactLongSet ints=new ImmutableCompactLongSet((long[])taxmrca.getProperty(""String_Node_Str""));
      while (going == true) {
        if (mrca.hasProperty(""String_Node_Str"")) {
          ImmutableCompactLongSet outs=new ImmutableCompactLongSet((long[])mrca.getProperty(""String_Node_Str""));
          if (outs.containsAny(ints)) {
            mrca=mrca.getSingleRelationship(RelType.SYNTHCHILDOF,Direction.OUTGOING).getEndNode();
          }
 else {
            break;
          }
        }
 else {
          ImmutableCompactLongSet ins=new ImmutableCompactLongSet((long[])mrca.getProperty(""String_Node_Str""));
          if (ins.containsAll(ints) == true)           break;
 else           mrca=mrca.getSingleRelationship(RelType.SYNTHCHILDOF,Direction.OUTGOING).getEndNode();
        }
      }
      Relationship newRel=taxNode.createRelationshipTo(mrca,RelType.SYNTHCHILDOF);
      synthRelIndex.add(newRel,""String_Node_Str"",DRAFTTREENAME);
      newRel.setProperty(""String_Node_Str"",DRAFTTREENAME);
      newRel.setProperty(""String_Node_Str"",supportingSources);
      knownIdsInTree.add(taxNode.getId());
    }
 else {
      Relationship newRel=taxNode.createRelationshipTo(ptaxNode,RelType.SYNTHCHILDOF);
      synthRelIndex.add(newRel,""String_Node_Str"",DRAFTTREENAME);
      newRel.setProperty(""String_Node_Str"",DRAFTTREENAME);
      newRel.setProperty(""String_Node_Str"",supportingSources);
      taxaleft.add(ptaxNode.getId());
    }
  }
}","/** 
 * Used to add missing external nodes to the draft tree stored in the graph.
 * @param startNode
 * @param taxRootNode
 */
private void addMissingChildrenToDraftTreewhile(Node startNode,Node taxRootNode){
  String[] supportingSources=new String[1];
  supportingSources[0]=""String_Node_Str"";
  TLongArrayList taxaleft=new TLongArrayList((long[])startNode.getProperty(""String_Node_Str""));
  while (taxaleft.removeAll(knownIdsInTree) == true) {
    continue;
  }
  System.out.println(""String_Node_Str"" + taxaleft.size());
  while (taxaleft.size() > 0) {
    System.out.print(""String_Node_Str"" + taxaleft.size());
    long tid=taxaleft.removeAt(0);
    Node taxNode=graphDb.getNodeById(tid);
    System.out.println(""String_Node_Str"" + ((String)taxNode.getProperty(""String_Node_Str"")));
    TLongArrayList ttmrca=new TLongArrayList((long[])taxNode.getProperty(""String_Node_Str""));
    if (taxNode.hasRelationship(Direction.OUTGOING,RelType.SYNTHCHILDOF)) {
      continue;
    }
    Node ptaxNode=taxNode.getSingleRelationship(RelType.TAXCHILDOF,Direction.OUTGOING).getEndNode();
    ArrayList<Node> nodesInTree=new ArrayList<Node>();
    for (    long cid : (long[])ptaxNode.getProperty(""String_Node_Str"")) {
      Node childNode=graphDb.getNodeById(cid);
      if (knownIdsInTree.contains(cid)) {
        nodesInTree.add(childNode);
      }
    }
    if (nodesInTree.size() > 0) {
      Node mrca=null;
      mrca=getLICAForDraftTreeNodes(nodesInTree);
      Node taxmrca=null;
      taxmrca=getTaxonomyMRCA(nodesInTree);
      boolean going=true;
      ImmutableCompactLongSet ints=new ImmutableCompactLongSet((long[])taxmrca.getProperty(""String_Node_Str""));
      while (going == true) {
        if (mrca.hasProperty(""String_Node_Str"")) {
          ImmutableCompactLongSet outs=new ImmutableCompactLongSet((long[])mrca.getProperty(""String_Node_Str""));
          if (outs.containsAny(ints)) {
            mrca=mrca.getSingleRelationship(RelType.SYNTHCHILDOF,Direction.OUTGOING).getEndNode();
          }
 else {
            break;
          }
        }
 else {
          ImmutableCompactLongSet ins=new ImmutableCompactLongSet((long[])mrca.getProperty(""String_Node_Str""));
          if (ins.containsAll(ints) == true)           break;
 else           mrca=mrca.getSingleRelationship(RelType.SYNTHCHILDOF,Direction.OUTGOING).getEndNode();
        }
      }
      Relationship newRel=taxNode.createRelationshipTo(mrca,RelType.SYNTHCHILDOF);
      synthRelIndex.add(newRel,""String_Node_Str"",DRAFTTREENAME);
      newRel.setProperty(""String_Node_Str"",DRAFTTREENAME);
      newRel.setProperty(""String_Node_Str"",supportingSources);
      knownIdsInTree.add(taxNode.getId());
    }
 else {
      Relationship newRel=taxNode.createRelationshipTo(ptaxNode,RelType.SYNTHCHILDOF);
      synthRelIndex.add(newRel,""String_Node_Str"",DRAFTTREENAME);
      newRel.setProperty(""String_Node_Str"",DRAFTTREENAME);
      newRel.setProperty(""String_Node_Str"",supportingSources);
      taxaleft.add(ptaxNode.getId());
    }
  }
}"
50113,"/** 
 * Used to add missing external nodes to the draft tree stored in the graph.
 * @param startNode
 * @param taxRootNode
 */
private void addMissingChildrenToDraftTreewhile(Node startNode,Node taxRootNode){
  String[] supportingSources=new String[1];
  supportingSources[0]=""String_Node_Str"";
  TLongArrayList taxaleft=new TLongArrayList((long[])startNode.getProperty(""String_Node_Str""));
  while (taxaleft.removeAll(knownIdsInTree) == true) {
    continue;
  }
  System.out.println(""String_Node_Str"" + taxaleft.size());
  while (taxaleft.size() > 0) {
    System.out.print(""String_Node_Str"" + taxaleft.size());
    long tid=taxaleft.removeAt(0);
    Node taxNode=graphDb.getNodeById(tid);
    System.out.println(""String_Node_Str"" + ((String)taxNode.getProperty(""String_Node_Str"")));
    TLongArrayList ttmrca=new TLongArrayList((long[])taxNode.getProperty(""String_Node_Str""));
    if (taxNode.hasRelationship(Direction.OUTGOING,RelType.SYNTHCHILDOF)) {
      continue;
    }
    Node ptaxNode=taxNode.getSingleRelationship(RelType.TAXCHILDOF,Direction.OUTGOING).getEndNode();
    ArrayList<Node> nodesInTree=new ArrayList<Node>();
    for (    long cid : (long[])ptaxNode.getProperty(""String_Node_Str"")) {
      Node childNode=graphDb.getNodeById(cid);
      if (knownIdsInTree.contains(cid)) {
        nodesInTree.add(childNode);
      }
    }
    if (nodesInTree.size() > 1) {
      Node mrca=null;
      mrca=getLICAForDraftTreeNodes(nodesInTree);
      Relationship newRel=taxNode.createRelationshipTo(mrca,RelType.SYNTHCHILDOF);
      synthRelIndex.add(newRel,""String_Node_Str"",DRAFTTREENAME);
      newRel.setProperty(""String_Node_Str"",DRAFTTREENAME);
      newRel.setProperty(""String_Node_Str"",supportingSources);
      knownIdsInTree.add(taxNode.getId());
    }
 else {
      Relationship newRel=taxNode.createRelationshipTo(ptaxNode,RelType.SYNTHCHILDOF);
      synthRelIndex.add(newRel,""String_Node_Str"",DRAFTTREENAME);
      newRel.setProperty(""String_Node_Str"",DRAFTTREENAME);
      newRel.setProperty(""String_Node_Str"",supportingSources);
      taxaleft.add(ptaxNode.getId());
    }
  }
}","/** 
 * Used to add missing external nodes to the draft tree stored in the graph.
 * @param startNode
 * @param taxRootNode
 */
private void addMissingChildrenToDraftTreewhile(Node startNode,Node taxRootNode){
  String[] supportingSources=new String[1];
  supportingSources[0]=""String_Node_Str"";
  TLongArrayList taxaleft=new TLongArrayList((long[])startNode.getProperty(""String_Node_Str""));
  while (taxaleft.removeAll(knownIdsInTree) == true) {
    continue;
  }
  System.out.println(""String_Node_Str"" + taxaleft.size());
  while (taxaleft.size() > 0) {
    System.out.print(""String_Node_Str"" + taxaleft.size());
    long tid=taxaleft.removeAt(0);
    Node taxNode=graphDb.getNodeById(tid);
    System.out.println(""String_Node_Str"" + ((String)taxNode.getProperty(""String_Node_Str"")));
    TLongArrayList ttmrca=new TLongArrayList((long[])taxNode.getProperty(""String_Node_Str""));
    if (taxNode.hasRelationship(Direction.OUTGOING,RelType.SYNTHCHILDOF)) {
      continue;
    }
    Node ptaxNode=taxNode.getSingleRelationship(RelType.TAXCHILDOF,Direction.OUTGOING).getEndNode();
    ArrayList<Node> nodesInTree=new ArrayList<Node>();
    for (    long cid : (long[])ptaxNode.getProperty(""String_Node_Str"")) {
      Node childNode=graphDb.getNodeById(cid);
      if (knownIdsInTree.contains(cid)) {
        nodesInTree.add(childNode);
      }
    }
    if (nodesInTree.size() > 1) {
      Node nextAncestorTaxInTree=ptaxNode;
      while (!nextAncestorTaxInTree.hasRelationship(RelType.SYNTHCHILDOF)) {
        nextAncestorTaxInTree=nextAncestorTaxInTree.getSingleRelationship(RelType.TAXCHILDOF,Direction.OUTGOING).getEndNode();
      }
      Relationship newRel=taxNode.createRelationshipTo(nextAncestorTaxInTree,RelType.SYNTHCHILDOF);
      synthRelIndex.add(newRel,""String_Node_Str"",DRAFTTREENAME);
      newRel.setProperty(""String_Node_Str"",DRAFTTREENAME);
      newRel.setProperty(""String_Node_Str"",supportingSources);
      knownIdsInTree.add(taxNode.getId());
    }
 else {
      Relationship newRel=taxNode.createRelationshipTo(ptaxNode,RelType.SYNTHCHILDOF);
      synthRelIndex.add(newRel,""String_Node_Str"",DRAFTTREENAME);
      newRel.setProperty(""String_Node_Str"",DRAFTTREENAME);
      newRel.setProperty(""String_Node_Str"",supportingSources);
      taxaleft.add(ptaxNode.getId());
    }
  }
}"
50114,"/** 
 * Whether or not this synthesis subtree contains any edges/nodes representing the same tree edges that are represented by nodes/edges in <tt>that</tt>.
 * @param that
 * @param workingRank
 * @return
 */
public boolean containsAnyStreeElementsOf(SynthesisSubtreeInfoUsingEdgeIds that,int workingRank){
  boolean containsAny=false;
  for (  int rank : ranksForIncludedEdges()) {
    if (rank < workingRank || !that.edgeIdsByRank.containsKey(rank)) {
      continue;
    }
    for (    long edgeId : that.edgeIdsForRank(rank)) {
      if (this.edgeIdsForRank(rank).contains(edgeId)) {
        containsAny=true;
        break;
      }
    }
  }
  if (!containsAny) {
    outer:     for (    int rank : ranksForIncludedTips()) {
      if (rank < workingRank || !that.tipIdSetsByRank.containsKey(rank)) {
        continue;
      }
      for (      LongSet thoseTips : that.tipIdSetsForRank(rank)) {
        for (        LongSet theseTips : this.tipIdSetsForRank(rank)) {
          if (theseTips.containsAny(thoseTips)) {
            containsAny=true;
            break outer;
          }
        }
      }
    }
  }
  return containsAny;
}","/** 
 * Whether or not this synthesis subtree contains any edges/nodes representing the same tree edges that are represented by nodes/edges in <tt>that</tt>.
 * @param that
 * @param workingRank
 * @return
 */
public boolean containsAnyStreeElementsOf(SynthesisSubtreeInfoUsingEdgeIds that,int workingRank){
  boolean containsAny=false;
  for (  int rank : ranksForIncludedEdges()) {
    if (rank < workingRank || !that.edgeIdsByRank.containsKey(rank)) {
      continue;
    }
    for (    Object edgeId : that.edgeIdsForRank(rank)) {
      if (this.edgeIdsForRank(rank).contains(edgeId)) {
        print(""String_Node_Str"",""String_Node_Str"",rank,""String_Node_Str"",edgeId);
        containsAny=true;
        break;
      }
    }
  }
  if (!containsAny) {
    outer:     for (    int rank : ranksForIncludedTips()) {
      if (rank < workingRank || !that.tipIdSetsByRank.containsKey(rank)) {
        continue;
      }
      for (      LongSet thoseTips : that.tipIdSetsForRank(rank)) {
        for (        LongSet theseTips : this.tipIdSetsForRank(rank)) {
          if (theseTips.containsAny(thoseTips)) {
            containsAny=true;
            break outer;
          }
        }
      }
    }
  }
  return containsAny;
}"
50115,"private void processIncomingRel(Relationship r){
  children.add(r.getStartNode());
  int rank=rank(r);
  observedRanks.add(rank);
  if (!edgeSetsByRankAndEdgeId.containsKey(rank)) {
    edgeSetsByRankAndEdgeId.put(rank,new HashMap<Long,EdgeSet>());
  }
  long edgeId=edgeId(r);
  if (!edgeSetsByRankAndEdgeId.get(rank).containsKey(edgeId)) {
    edgeSetsByRankAndEdgeId.get(rank).put(edgeId,new EdgeSet(r.getEndNode(),rank,edgeId));
  }
  if (VERBOSE) {
    print(""String_Node_Str"",r,""String_Node_Str"",rank,""String_Node_Str"",edgeId);
  }
  edgeSetsByRankAndEdgeId.get(rank).get(edgeId(r)).add(r);
}","private void processIncomingRel(Relationship r){
  children.add(r.getStartNode());
  int rank=rank(r);
  observedRanks.add(rank);
  if (!edgeSetsByRankAndEdgeId.containsKey(rank)) {
    edgeSetsByRankAndEdgeId.put(rank,new HashMap<Object,EdgeSet>());
  }
  Object edgeId=edgeId(r);
  if (!edgeSetsByRankAndEdgeId.get(rank).containsKey(edgeId)) {
    edgeSetsByRankAndEdgeId.get(rank).put(edgeId,new EdgeSet(r.getEndNode(),rank,edgeId));
  }
  if (VERBOSE) {
    print(""String_Node_Str"",r,""String_Node_Str"",rank,""String_Node_Str"",edgeId);
  }
  edgeSetsByRankAndEdgeId.get(rank).get(edgeId(r)).add(r);
}"
50116,"public SourceRankTopoOrderSynthesisExpanderUsingEdgeIdsAndTipIds(){
  VERBOSE=false;
  System.out.println(""String_Node_Str"");
}","public SourceRankTopoOrderSynthesisExpanderUsingEdgeIdsAndTipIds(){
  VERBOSE=true;
  System.out.println(""String_Node_Str"");
}"
50117,"/** 
 * Get the unique edge id for this relationship within its source tree. For taxonomy rels, we just use the database id of the rel (which are unique) since each taxonomy rel is only represented once in the db.
 */
private static long edgeId(Relationship r){
  return isTaxonomyRel(r) ? r.getId() : (int)r.getProperty(RelProperty.SOURCE_EDGE_ID.propertyName);
}","/** 
 * Get the unique edge id for this relationship within its source tree. For taxonomy rels, we just use the database id of the rel (which are unique) since each taxonomy rel is only represented once in the db.
 */
private static Object edgeId(Relationship r){
  return isTaxonomyRel(r) ? r.getId() : r.getProperty(RelProperty.SOURCE_EDGE_ID.propertyName);
}"
50118,"public EdgeSet(Node parent,int rank,long edgeId){
  this.rank=rank;
  this.edgeId=edgeId;
  this.parent=parent;
  info=new SynthesisSubtreeInfoUsingEdgeIds(parent);
  rels=new HashSet<Relationship>();
}","public EdgeSet(Node parent,int rank,Object edgeId){
  if (edgeId == null) {
    throw new IllegalArgumentException();
  }
  this.rank=rank;
  this.edgeId=edgeId;
  this.parent=parent;
  info=new SynthesisSubtreeInfoUsingEdgeIds(parent);
  rels=new HashSet<Relationship>();
}"
50119,"/** 
 * Whether or not this synthesis subtree contains any nodes or represents any tree edges that are also contained/represented by <tt>that</tt>. (If so, then the subtrees cannot both be included in synthesis).
 * @param that
 * @param workingRank
 * @return
 */
public boolean overlapsWith(SynthesisSubtreeInfoUsingEdgeIds that,int workingRank){
  print(""String_Node_Str"",this);
  print(""String_Node_Str"",that,""String_Node_Str"");
  return this.includedNodeIds.containsAny(that.includedNodeIds) ? true : containsAnyStreeElementsOf(that,workingRank);
}","/** 
 * Whether or not this synthesis subtree contains any nodes or represents any tree edges that are also contained/represented by <tt>that</tt>. (If so, then the subtrees cannot both be included in synthesis).
 * @param that
 * @param workingRank
 * @return
 */
public boolean overlapsWith(SynthesisSubtreeInfoUsingEdgeIds that,int workingRank){
  return this.includedNodeIds.containsAny(that.includedNodeIds) ? true : containsAnyStreeElementsOf(that,workingRank);
}"
50120,"/** 
 * Called once for each node, visited in topological order. This method contains the high level logic to make decisions about which child nodes to include as descendants in the synthesis subtree of the node <tt>n</tt>.
 */
@Override List<Relationship> selectRelsForNode(Node n){
  if (VERBOSE) {
    String name=""String_Node_Str"";
    Object ottId=n.getProperty(NodeProperty.TAX_UID.propertyName,null);
    if (ottId != null) {
      name=(String)n.getProperty(NodeProperty.NAME.propertyName) + ""String_Node_Str"" + ottId;
    }
    print(""String_Node_Str"",n,""String_Node_Str"",name,""String_Node_Str"");
  }
  initialize(n);
  boolean hasChildren=false;
  for (  Relationship r : availableRelsForSynth(n,RelType.STREECHILDOF)) {
    hasChildren=true;
    processIncomingRel(r);
  }
  if (VERBOSE && hasChildren) {
    print();
  }
  Set<Relationship> taxonomySingletonRels=new HashSet<Relationship>();
  Set<Node> taxonomySingletonNodes=new HashSet<Node>();
  for (  Relationship r : availableRelsForSynth(n,RelType.TAXCHILDOF)) {
    Node childNode=r.getStartNode();
    if (childNode.hasRelationship(Direction.INCOMING,RelType.TAXCHILDOF,RelType.STREECHILDOF)) {
      processIncomingRel(r);
    }
 else {
      taxonomySingletonRels.add(r);
      taxonomySingletonNodes.add(childNode);
    }
  }
  for (  Node child : children) {
    immediateSubtrees.put(child,new SynthesisSubtreeInfoUsingEdgeIds(n,child));
  }
  for (  Node child : taxonomySingletonNodes) {
    immediateSubtrees.put(child,new SynthesisSubtreeInfoUsingEdgeIds(n,child));
  }
  List<Integer> sortedRanks=new ArrayList<Integer>(observedRanks);
  Collections.sort(sortedRanks);
  Collections.reverse(sortedRanks);
  if (VERBOSE) {
    print(""String_Node_Str"",sortedRanks);
  }
  bestSet=new CandidateRelSet(n);
  for (  int currentRank : sortedRanks) {
    if (VERBOSE) {
      print(""String_Node_Str"" + currentRank);
    }
    Set<EdgeSet> overlappingSets=new HashSet<EdgeSet>();
    Set<EdgeSet> nonOverlappingSets=new HashSet<EdgeSet>();
    for (    EdgeSet edgeSet : edgeSetsByRankAndEdgeId.get(currentRank).values()) {
      if (bestSet.info().overlapsWith(edgeSet.info(),currentRank)) {
        overlappingSets.add(edgeSet);
      }
 else {
        nonOverlappingSets.add(edgeSet);
      }
    }
    while (overlappingSets.size() > 0) {
      if (VERBOSE) {
        print(""String_Node_Str"");
        for (        EdgeSet x : overlappingSets) {
          print(x,x.info());
        }
      }
      PrunableCPSupersetIterator<Relationship> combinations=new CartesianProduct<Relationship>((Set<Set<Relationship>>)(Set<?>)overlappingSets).withMissingElements().prunableIterator();
      while (combinations.hasNext()) {
        Set<Relationship> c=combinations.next();
        if (c.size() < 1) {
          continue;
        }
        CandidateRelSet proposed=new CandidateRelSet(c);
        if (!internallyDisjoint(proposed)) {
          combinations.prune();
          continue;
        }
        if (VERBOSE) {
          print(""String_Node_Str"",bestSet,""String_Node_Str"",bestSet.info(),""String_Node_Str"",proposed,""String_Node_Str"",proposed.info());
        }
        CandidateRelSet candidate=(CandidateRelSet)updateSet(n,proposed,bestSet,currentRank);
        if (candidate == null) {
          combinations.prune();
          continue;
        }
        if (VERBOSE) {
          print(""String_Node_Str"",candidate,""String_Node_Str"",bestSet);
        }
        if (candidate.info().improvesUpon(bestSet.info(),currentRank)) {
          bestSet=candidate;
        }
      }
      overlappingSets=new HashSet<EdgeSet>();
      Iterator<EdgeSet> nonOverlappingIter=nonOverlappingSets.iterator();
      while (nonOverlappingIter.hasNext()) {
        EdgeSet edgeSet=nonOverlappingIter.next();
        if (bestSet.info().overlapsWith(edgeSet.info(),currentRank)) {
          overlappingSets.add(edgeSet);
          nonOverlappingIter.remove();
        }
      }
      if (!nonOverlappingSets.isEmpty()) {
        if (VERBOSE) {
          print(""String_Node_Str"");
        }
        bestSet=augmentFromNonOverlappingSets(bestSet,nonOverlappingSets,currentRank);
      }
      if (VERBOSE) {
        print(""String_Node_Str"",bestSet,""String_Node_Str"",bestSet.info());
      }
    }
    if (!nonOverlappingSets.isEmpty()) {
      if (VERBOSE) {
        print(""String_Node_Str"");
      }
      bestSet=augmentFromNonOverlappingSets(bestSet,nonOverlappingSets,currentRank);
    }
  }
  for (  Relationship t : taxonomySingletonRels) {
    if (!bestSet.info().overlapsWith(completedSubtree(t),0)) {
      bestSet.add(t);
    }
  }
  bestSet.info().complete();
  print(""String_Node_Str"" + n,""String_Node_Str"",bestSet + ""String_Node_Str"" + bestSet.info());
  updateCompletedSubtreeInfo(n,bestSet.info());
  if (n.getId() == root.getId()) {
    completeRootInfo=bestSet.info();
  }
  return new ArrayList<Relationship>(bestSet);
}","/** 
 * Called once for each node, visited in topological order. This method contains the high level logic to make decisions about which child nodes to include as descendants in the synthesis subtree of the node <tt>n</tt>.
 */
@Override List<Relationship> selectRelsForNode(Node n){
  if (VERBOSE) {
    String name=""String_Node_Str"";
    Object ottId=n.getProperty(NodeProperty.TAX_UID.propertyName,null);
    if (ottId != null) {
      name=(String)n.getProperty(NodeProperty.NAME.propertyName) + ""String_Node_Str"" + ottId;
    }
    print(""String_Node_Str"",n,""String_Node_Str"",name,""String_Node_Str"");
  }
  initialize(n);
  boolean hasChildren=false;
  for (  Relationship r : availableRelsForSynth(n,RelType.STREECHILDOF)) {
    hasChildren=true;
    processIncomingRel(r);
  }
  if (VERBOSE && hasChildren) {
    print();
  }
  Set<Relationship> taxonomySingletonRels=new HashSet<Relationship>();
  Set<Node> taxonomySingletonNodes=new HashSet<Node>();
  for (  Relationship r : availableRelsForSynth(n,RelType.TAXCHILDOF)) {
    Node childNode=r.getStartNode();
    if (childNode.hasRelationship(Direction.INCOMING,RelType.TAXCHILDOF,RelType.STREECHILDOF)) {
      processIncomingRel(r);
    }
 else {
      taxonomySingletonRels.add(r);
      taxonomySingletonNodes.add(childNode);
    }
  }
  for (  Node child : children) {
    immediateSubtrees.put(child,new SynthesisSubtreeInfoUsingEdgeIds(n,child));
  }
  for (  Node child : taxonomySingletonNodes) {
    immediateSubtrees.put(child,new SynthesisSubtreeInfoUsingEdgeIds(n,child));
  }
  List<Integer> sortedRanks=new ArrayList<Integer>(observedRanks);
  Collections.sort(sortedRanks);
  Collections.reverse(sortedRanks);
  if (VERBOSE) {
    print(""String_Node_Str"",sortedRanks);
  }
  bestSet=new CandidateRelSet(n);
  for (  int currentRank : sortedRanks) {
    if (VERBOSE) {
      print(""String_Node_Str"" + currentRank);
    }
    Set<EdgeSet> overlappingSets=new HashSet<EdgeSet>();
    Set<EdgeSet> nonOverlappingSets=new HashSet<EdgeSet>();
    for (    EdgeSet edgeSet : edgeSetsByRankAndEdgeId.get(currentRank).values()) {
      if (bestSet.info().overlapsWith(edgeSet.info(),currentRank)) {
        overlappingSets.add(edgeSet);
      }
 else {
        nonOverlappingSets.add(edgeSet);
      }
    }
    while (overlappingSets.size() > 0) {
      if (VERBOSE) {
        print(""String_Node_Str"");
        for (        EdgeSet x : overlappingSets) {
          print(x,x.info());
        }
      }
      PrunableCPSupersetIterator<Relationship> combinations=new CartesianProduct<Relationship>((Set<Set<Relationship>>)(Set<?>)overlappingSets).withMissingElements().prunableIterator();
      while (combinations.hasNext()) {
        Set<Relationship> c=combinations.next();
        if (c.size() < 1) {
          continue;
        }
        CandidateRelSet proposed=new CandidateRelSet(c);
        if (!internallyDisjoint(proposed)) {
          combinations.prune();
          continue;
        }
        if (VERBOSE) {
          print(""String_Node_Str"",bestSet,""String_Node_Str"",bestSet.info(),""String_Node_Str"",proposed,""String_Node_Str"",proposed.info());
        }
        CandidateRelSet candidate=(CandidateRelSet)updateSet(n,proposed,bestSet,currentRank);
        if (candidate == null) {
          combinations.prune();
          continue;
        }
        if (VERBOSE) {
          print(""String_Node_Str"",candidate,""String_Node_Str"",bestSet);
        }
        if (candidate.info().improvesUpon(bestSet.info(),currentRank)) {
          bestSet=candidate;
        }
      }
      overlappingSets=new HashSet<EdgeSet>();
      Iterator<EdgeSet> nonOverlappingIter=nonOverlappingSets.iterator();
      while (nonOverlappingIter.hasNext()) {
        EdgeSet edgeSet=nonOverlappingIter.next();
        if (bestSet.info().overlapsWith(edgeSet.info(),currentRank)) {
          overlappingSets.add(edgeSet);
          nonOverlappingIter.remove();
        }
      }
      if (!nonOverlappingSets.isEmpty()) {
        if (VERBOSE) {
          print(""String_Node_Str"");
        }
        bestSet=augmentFromNonOverlappingSets(bestSet,nonOverlappingSets,currentRank);
      }
      if (VERBOSE) {
        print(""String_Node_Str"",bestSet,""String_Node_Str"",bestSet.info());
      }
    }
    if (!nonOverlappingSets.isEmpty()) {
      if (VERBOSE) {
        print(""String_Node_Str"");
      }
      bestSet=augmentFromNonOverlappingSets(bestSet,nonOverlappingSets,currentRank);
    }
  }
  bestSet.info().complete();
  print(""String_Node_Str"" + n,""String_Node_Str"",bestSet + ""String_Node_Str"" + bestSet.info());
  updateCompletedSubtreeInfo(n,bestSet.info());
  if (n.getId() == root.getId()) {
    completeRootInfo=bestSet.info();
  }
  return new ArrayList<Relationship>(bestSet);
}"
50121,"public Set<Long> edgeIdsForRank(int rank){
  return edgeIdsByRank.get(rank);
}","public Set<Object> edgeIdsForRank(int rank){
  return edgeIdsByRank.get(rank);
}"
50122,"/** 
 * trivial convenience function for code simplification.
 * @param v
 * @param m
 */
private void updateSetMap(int v,Map<Integer,Set<Long>> m){
  if (!m.containsKey(v)) {
    m.put(v,new HashSet<Long>());
  }
}","/** 
 * trivial convenience function for code simplification.
 * @param v
 * @param m
 */
private void updateSetMap(int v,Map<Integer,Set<Object>> m){
  if (!m.containsKey(v)) {
    m.put(v,new HashSet<Object>());
  }
}"
50123,"/** 
 * Whether or not this synthesis subtree contains edges/nodes representing <strong>all</strong> the same tree edges that are represented by nodes/edges in <tt>that</tt>.
 * @param that
 * @param workingRank
 * @return
 */
public boolean containsAllStreeElementsOf(SynthesisSubtreeInfoUsingEdgeIds that,int workingRank){
  boolean containsAll=true;
  for (  int rank : that.ranksForIncludedEdges()) {
    if (rank < workingRank) {
      continue;
    }
    if (!this.ranksForIncludedEdges().contains(rank)) {
      containsAll=false;
      print(""String_Node_Str"" + rank + ""String_Node_Str"");
      break;
    }
    for (    long edgeId : that.edgeIdsForRank(rank)) {
      if (!this.edgeIdsForRank(rank).contains(edgeId)) {
        containsAll=false;
        print(""String_Node_Str"" + edgeId + ""String_Node_Str""+ rank);
        break;
      }
    }
  }
  if (containsAll) {
    for (    int rank : that.ranksForIncludedTips()) {
      if (rank < workingRank) {
        continue;
      }
      for (      LongSet thoseTips : that.tipIdSetsForRank(rank)) {
        if (!this.includedNodeIds.containsAny(thoseTips)) {
          containsAll=false;
          print(""String_Node_Str"" + thoseTips + ""String_Node_Str""+ rank);
          break;
        }
      }
    }
  }
  return containsAll;
}","/** 
 * Whether or not this synthesis subtree contains edges/nodes representing <strong>all</strong> the same tree edges that are represented by nodes/edges in <tt>that</tt>.
 * @param that
 * @param workingRank
 * @return
 */
public boolean containsAllStreeElementsOf(SynthesisSubtreeInfoUsingEdgeIds that,int workingRank){
  boolean containsAll=true;
  for (  int rank : that.ranksForIncludedEdges()) {
    if (rank < workingRank) {
      continue;
    }
    if (!this.ranksForIncludedEdges().contains(rank)) {
      containsAll=false;
      print(""String_Node_Str"" + rank + ""String_Node_Str"");
      break;
    }
    for (    Object edgeId : that.edgeIdsForRank(rank)) {
      if (!this.edgeIdsForRank(rank).contains(edgeId)) {
        containsAll=false;
        print(""String_Node_Str"" + edgeId + ""String_Node_Str""+ rank);
        break;
      }
    }
  }
  if (containsAll) {
    for (    int rank : that.ranksForIncludedTips()) {
      if (rank < workingRank) {
        continue;
      }
      for (      LongSet thoseTips : that.tipIdSetsForRank(rank)) {
        if (!this.includedNodeIds.containsAny(thoseTips)) {
          containsAll=false;
          print(""String_Node_Str"" + thoseTips + ""String_Node_Str""+ rank);
          break;
        }
      }
    }
  }
  return containsAll;
}"
50124,"private void initialize(Node n){
  immediateSubtrees=new HashMap<Node,SynthesisSubtreeInfoUsingEdgeIds>();
  edgeSetsByRankAndEdgeId=new HashMap<Integer,Map<Long,EdgeSet>>();
  children=new HashSet<Node>();
  observedRanks=new HashSet<Integer>();
}","private void initialize(Node n){
  immediateSubtrees=new HashMap<Node,SynthesisSubtreeInfoUsingEdgeIds>();
  edgeSetsByRankAndEdgeId=new HashMap<Integer,Map<Object,EdgeSet>>();
  children=new HashSet<Node>();
  observedRanks=new HashSet<Integer>();
}"
50125,"public SourceRankTopoOrderSynthesisExpanderUsingEdgeIdsAndTipIds(){
  VERBOSE=true;
  System.out.println(""String_Node_Str"");
}","public SourceRankTopoOrderSynthesisExpanderUsingEdgeIdsAndTipIds(){
  VERBOSE=false;
  System.out.println(""String_Node_Str"");
}"
50126,"private void mapNonRootNodes(List<Tree> trees){
  for (int k=0; k < trees.size(); k++) {
    Tree tree=trees.get(k);
    System.out.print(""String_Node_Str"" + k + ""String_Node_Str"");
    long z=new Date().getTime();
    Transaction tx=gdb.beginTx();
    Map<TreeNode,Integer> edgeIdForTreeNode=new HashMap<TreeNode,Integer>();
    int i=0;
    for (    TreeNode treeNode : tree.internalNodes(NodeOrder.PREORDER)) {
      if (!treeNode.isTheRoot()) {
        int edgeId=++i;
        edgeIdForTreeNode.put(treeNode,edgeId);
        Set<Node> graphNodes=mapGraphNodes(treeNode,tree,edgeId,false);
        if (graphNodes.size() == 0) {
          System.out.println(""String_Node_Str"" + treeNode.getNewick(false) + ""String_Node_Str""+ graphNodes);
          throw new AssertionError();
        }
        graphNodesForTreeNode.put(treeNode,(HashSet<Node>)graphNodes);
      }
    }
    for (    TreeNode treeTip : tree.externalNodes()) {
      int edgeId=++i;
      edgeIdForTreeNode.put(treeTip,edgeId);
      mapGraphNodes(treeTip,tree,edgeIdForTreeNode.get(treeTip),true);
      Node tip=gdb.getNodeById(nodeIdForLabel.get(treeTip.getLabel()));
      LongBipartition lb=getExpandedTaxonomyBipart(getGraphBipartForTreeNode(treeTip,tree));
      for (      Node parent : graphNodesForTreeNode.get(treeTip.getParent())) {
        if (tip.equals(parent))         continue;
        updateMRCAChildOf(tip,parent);
        updateSTREEChildOf(tip,parent,sourceForTreeNode.get(treeTip),rankForTreeNode.get(treeTip),edgeId,lb,true);
        if (mapdeepest == true) {
          Node startTip=tip;
          boolean going=true;
          while (going == true) {
            startTip=startTip.getSingleRelationship(RelType.TAXCHILDOF,Direction.OUTGOING).getEndNode();
            if (taxonomyGraphNodesMap.containsKey(startTip)) {
              LongBipartition pbip=null;
              LongBipartition cbip=taxonomyGraphNodesMap.get(startTip);
              if (bipartForGraphNodeExploded.containsKey(parent)) {
                pbip=bipartForGraphNodeExploded.get(parent);
              }
 else {
                pbip=taxonomyGraphNodesMap.get(parent);
              }
              if (pbip.ingroup().containsAny(cbip.ingroup()) && cbip.ingroup().containsAny(pbip.outgroup()) == false && cbip.ingroup().containsAll(pbip.ingroup()) == false) {
                updateMRCAChildOf(tip,startTip);
                updateSTREEChildOf(tip,startTip,sourceForTreeNode.get(treeTip),rankForTreeNode.get(treeTip),edgeId,lb,true);
                if (startTip.equals(parent))                 continue;
                updateMRCAChildOf(startTip,parent);
                updateSTREEChildOf(startTip,parent,sourceForTreeNode.get(treeTip),rankForTreeNode.get(treeTip),edgeId,lb,true);
              }
 else {
                going=false;
                break;
              }
            }
 else {
              break;
            }
          }
        }
      }
    }
    if (subsetTipInfo != null) {
      for (      TreeNode treeTip : tree.externalNodes()) {
        int edgeId=edgeIdForTreeNode.get(treeTip);
        if (subsetTipInfo.containsKey(treeTip)) {
          Index<Node> ottIdIndexss=gdb.getNodeIndex(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
          IndexHits<Node> hitroots=ottIdIndexss.get(""String_Node_Str"",sourceForTreeNode.get(treeTip) + subsetTipInfo.get(treeTip));
          for (          Node tip : hitroots) {
            for (            Node parent : graphNodesForTreeNode.get(treeTip.getParent())) {
              if (tip.equals(parent))               continue;
              updateMRCAChildOf(tip,parent);
              updateSTREEChildOf(tip,parent,sourceForTreeNode.get(treeTip),rankForTreeNode.get(treeTip),edgeId,null,false);
            }
          }
        }
      }
    }
    tx.success();
    tx.finish();
    System.out.println(""String_Node_Str"" + (new Date().getTime() - z) / (float)1000 + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
}","private void mapNonRootNodes(List<Tree> trees){
  for (int k=0; k < trees.size(); k++) {
    Tree tree=trees.get(k);
    System.out.print(""String_Node_Str"" + k + ""String_Node_Str"");
    long z=new Date().getTime();
    Transaction tx=gdb.beginTx();
    Map<TreeNode,Integer> edgeIdForTreeNode=new HashMap<TreeNode,Integer>();
    int i=0;
    for (    TreeNode treeNode : tree.internalNodes(NodeOrder.PREORDER)) {
      if (!treeNode.isTheRoot()) {
        int edgeId=++i;
        edgeIdForTreeNode.put(treeNode,edgeId);
        Set<Node> graphNodes=mapGraphNodes(treeNode,tree,edgeId,false);
        if (graphNodes.size() == 0) {
          System.out.println(""String_Node_Str"" + treeNode.getNewick(false) + ""String_Node_Str""+ graphNodes);
          throw new AssertionError();
        }
        graphNodesForTreeNode.put(treeNode,(HashSet<Node>)graphNodes);
      }
    }
    for (    TreeNode treeTip : tree.externalNodes()) {
      int edgeId=++i;
      edgeIdForTreeNode.put(treeTip,edgeId);
      mapGraphNodes(treeTip,tree,edgeIdForTreeNode.get(treeTip),true);
      Node tip=gdb.getNodeById(nodeIdForLabel.get(treeTip.getLabel()));
      LongBipartition lb=getExpandedTaxonomyBipart(getGraphBipartForTreeNode(treeTip,tree));
      for (      Node parent : graphNodesForTreeNode.get(treeTip.getParent())) {
        if (tip.equals(parent))         continue;
        updateMRCAChildOf(tip,parent);
        updateSTREEChildOf(tip,parent,sourceForTreeNode.get(treeTip),rankForTreeNode.get(treeTip),edgeId,lb,true);
        if (mapdeepest == true) {
          LongBipartition nodeBipartExp=bipartForTreeNodeExploded.get(treeTip.getParent());
          MutableCompactLongSet alsoExclude=new MutableCompactLongSet();
          for (          TreeNode othertips : treeTip.getParent().getChildren()) {
            if (othertips.equals(treeTip))             continue;
            if (othertips.isExternal()) {
              alsoExclude.add(nodeIdForLabel.get(treeTip.getLabel()));
            }
 else {
              alsoExclude.addAll(bipartForTreeNodeExploded.get(othertips).ingroup());
            }
          }
          Node startTip=tip;
          boolean going=true;
          while (going == true) {
            startTip=startTip.getSingleRelationship(RelType.TAXCHILDOF,Direction.OUTGOING).getEndNode();
            if (taxonomyGraphNodesMap.containsKey(startTip)) {
              LongBipartition pbip=null;
              LongBipartition cbip=taxonomyGraphNodesMap.get(startTip);
              if (bipartForGraphNodeExploded.containsKey(parent)) {
                pbip=bipartForGraphNodeExploded.get(parent);
              }
 else {
                pbip=taxonomyGraphNodesMap.get(parent);
              }
              if (cbip.ingroup().containsAny(nodeBipartExp.outgroup())) {
                break;
              }
              if (cbip.ingroup().containsAny(alsoExclude)) {
                break;
              }
              if (pbip.ingroup().containsAny(cbip.ingroup()) && cbip.ingroup().containsAny(pbip.outgroup()) == false && cbip.ingroup().containsAll(pbip.ingroup()) == false) {
                updateMRCAChildOf(tip,startTip);
                updateSTREEChildOf(tip,startTip,sourceForTreeNode.get(treeTip),rankForTreeNode.get(treeTip),edgeId,lb,true);
                if (startTip.equals(parent))                 continue;
                updateMRCAChildOf(startTip,parent);
                updateSTREEChildOf(startTip,parent,sourceForTreeNode.get(treeTip),rankForTreeNode.get(treeTip),edgeId,lb,true);
              }
 else {
                going=false;
                break;
              }
            }
 else {
              break;
            }
          }
        }
      }
    }
    if (subsetTipInfo != null) {
      for (      TreeNode treeTip : tree.externalNodes()) {
        int edgeId=edgeIdForTreeNode.get(treeTip);
        if (subsetTipInfo.containsKey(treeTip)) {
          Index<Node> ottIdIndexss=gdb.getNodeIndex(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
          IndexHits<Node> hitroots=ottIdIndexss.get(""String_Node_Str"",sourceForTreeNode.get(treeTip) + subsetTipInfo.get(treeTip));
          for (          Node tip : hitroots) {
            for (            Node parent : graphNodesForTreeNode.get(treeTip.getParent())) {
              if (tip.equals(parent))               continue;
              updateMRCAChildOf(tip,parent);
              updateSTREEChildOf(tip,parent,sourceForTreeNode.get(treeTip),rankForTreeNode.get(treeTip),edgeId,null,false);
            }
          }
        }
      }
    }
    tx.success();
    tx.finish();
    System.out.println(""String_Node_Str"" + (new Date().getTime() - z) / (float)1000 + ""String_Node_Str"");
  }
  System.out.println(""String_Node_Str"");
}"
50127,"/** 
 * instantiation runs the entire analysis
 * @param trees
 * @param gdb
 * @param mapInternalNodesToTax
 * @throws Exception
 */
public BipartOracle(List<Tree> trees,GraphDatabaseAgent gdb,boolean useTaxonomy,Map<Tree,String> sources,Map<TreeNode,String> subsetInfo,boolean subset,String subsetFileName) throws Exception {
  this.subset=subset;
  if (subset) {
    mapdeepest=false;
    Transaction tx=gdb.beginTx();
    Index<Node> ottIdIndex=gdb.getNodeIndex(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    if (subsetFileName.contains(""String_Node_Str"")) {
      ottidFromSubset=subsetFileName.split(""String_Node_Str"")[1];
    }
 else {
      ottidFromSubset=subsetFileName;
    }
    ottidFromSubset=ottidFromSubset.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"");
    taxnodeFromSubset=ottIdIndex.get(NodeProperty.TAX_UID.propertyName,ottidFromSubset).getSingle();
    Index<Node> ottIdIndexss=gdb.getNodeIndex(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    ottIdIndexss.add(taxnodeFromSubset,""String_Node_Str"",ottidFromSubset);
    tx.success();
    tx.finish();
  }
  this.gdb=gdb;
  this.USING_TAXONOMY=useTaxonomy;
  this.subsetTipInfo=subsetInfo;
  this.sourceForTrees=sources;
  long w=new Date().getTime();
  validateTrees(trees);
  createTreeIdRankMap(trees);
  if (USING_TAXONOMY) {
    explodedTipsHash=TipExploder.explodeTipsReturnHash(trees,gdb);
    reduceExplodedTipsHash();
  }
  gatherTreeData(trees);
  if (USING_TAXONOMY) {
    mapTreeNodesToTaxa(trees);
  }
  if (USING_TAXONOMY) {
    populateTaxonomyGraphNodesMap(trees);
  }
  gatherBipartitions(trees);
  identifyNestedChildBiparts(trees);
  findAllPaths();
  createNodesUsingPaths();
  mapTreeRootNodes(trees);
  generateMRCAChildOfs();
  mapNonRootNodes(trees);
  removeUnusedNodesAndRels();
  System.out.println(""String_Node_Str"" + (new Date().getTime() - w) / 1000 + ""String_Node_Str"");
}","/** 
 * instantiation runs the entire analysis
 * @param trees
 * @param gdb
 * @param mapInternalNodesToTax
 * @throws Exception
 */
public BipartOracle(List<Tree> trees,GraphDatabaseAgent gdb,boolean useTaxonomy,Map<Tree,String> sources,Map<TreeNode,String> subsetInfo,boolean subset,String subsetFileName) throws Exception {
  this.subset=subset;
  if (subset) {
    Transaction tx=gdb.beginTx();
    Index<Node> ottIdIndex=gdb.getNodeIndex(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    if (subsetFileName.contains(""String_Node_Str"")) {
      ottidFromSubset=subsetFileName.split(""String_Node_Str"")[1];
    }
 else {
      ottidFromSubset=subsetFileName;
    }
    ottidFromSubset=ottidFromSubset.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"");
    taxnodeFromSubset=ottIdIndex.get(NodeProperty.TAX_UID.propertyName,ottidFromSubset).getSingle();
    Index<Node> ottIdIndexss=gdb.getNodeIndex(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    ottIdIndexss.add(taxnodeFromSubset,""String_Node_Str"",ottidFromSubset);
    tx.success();
    tx.finish();
  }
  this.gdb=gdb;
  this.USING_TAXONOMY=useTaxonomy;
  this.subsetTipInfo=subsetInfo;
  this.sourceForTrees=sources;
  long w=new Date().getTime();
  validateTrees(trees);
  createTreeIdRankMap(trees);
  if (USING_TAXONOMY) {
    explodedTipsHash=TipExploder.explodeTipsReturnHash(trees,gdb);
    reduceExplodedTipsHash();
  }
  gatherTreeData(trees);
  if (USING_TAXONOMY) {
    mapTreeNodesToTaxa(trees);
  }
  if (USING_TAXONOMY) {
    populateTaxonomyGraphNodesMap(trees);
  }
  gatherBipartitions(trees);
  identifyNestedChildBiparts(trees);
  findAllPaths();
  createNodesUsingPaths();
  mapTreeRootNodes(trees);
  generateMRCAChildOfs();
  mapNonRootNodes(trees);
  removeUnusedNodesAndRels();
  System.out.println(""String_Node_Str"" + (new Date().getTime() - w) / 1000 + ""String_Node_Str"");
}"
50128,"private boolean isSubproblemRoot(Node n){
  boolean passes=n.equals(root);
  if (!passes) {
    Object ottId=n.getProperty(NodeProperty.TAX_UID.propertyName,null);
    passes=ottId == null ? false : subproblemIndex.get(""String_Node_Str"",ottId).hasNext();
  }
  return passes;
}","private boolean isSubproblemRoot(Node n){
  boolean passes=n.equals(root);
  if (!passes) {
    return subproblemIds.contains(Long.valueOf(((String)n.getProperty(NodeProperty.TAX_UID.propertyName,null))));
  }
  return passes;
}"
50129,"public SubproblemSynthesisExpander(SourceRankTopoOrderSynthesisExpanderUsingEdgeIdsAndTipIds subExpander,Node root) throws InstantiationException, IllegalAccessException, IOException {
  this.subExpander=subExpander;
  this.root=root;
  this.G=new GraphDatabaseAgent(root.getGraphDatabase());
  subproblemIndex=new GraphDatabaseAgent(root.getGraphDatabase()).getNodeIndex(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  TopologicalOrder subproblemRoots=new TopologicalOrder(root,RelType.TAXCHILDOF).validateWith(new Predicate<Node>(){
    @Override public boolean test(    Node n){
      return isSubproblemRoot(n);
    }
    @Override public String toString(){
      return ""String_Node_Str"";
    }
  }
);
  Map<Long,SynthesisSubtreeInfo> preservedSubtrees=new TreeMap<Long,SynthesisSubtreeInfo>();
  for (  Node s : subproblemRoots) {
    if (VERBOSE) {
      print(""String_Node_Str"",s.getProperty(NodeProperty.NAME.propertyName) + ""String_Node_Str"" + s.getProperty(NodeProperty.TAX_UID.propertyName,""String_Node_Str""));
    }
    Transaction tx=G.beginTx();
    try {
      subExpander.synthesizeFrom(s);
      tx.success();
    }
  finally {
      tx.finish();
    }
    childRels.putAll(subExpander.childRels);
    preservedSubtrees.put(s.getId(),subExpander.completedRootInfo());
    subExpander.reset(preservedSubtrees);
  }
}","public SubproblemSynthesisExpander(SourceRankTopoOrderSynthesisExpanderUsingEdgeIdsAndTipIds subExpander,Node root) throws InstantiationException, IllegalAccessException, IOException {
  this.subExpander=subExpander;
  this.root=root;
  this.G=new GraphDatabaseAgent(root.getGraphDatabase());
  Index<Node> subproblemIndex=new GraphDatabaseAgent(root.getGraphDatabase()).getNodeIndex(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  subproblemIds=new TreeSet<Long>();
  for (  Node n : subproblemIndex.query(new MatchAllDocsQuery())) {
    subproblemIds.add(Long.valueOf((String)n.getProperty(NodeProperty.TAX_UID.propertyName)));
  }
  if (VERBOSE) {
    print(""String_Node_Str"",subproblemIds.size(),""String_Node_Str"",subproblemIds);
  }
  TopologicalOrder orderedSubproblems=new TopologicalOrder(root,RelType.TAXCHILDOF).validateWith(new Predicate<Node>(){
    @Override public boolean test(    Node n){
      return isSubproblemRoot(n);
    }
    @Override public String toString(){
      return ""String_Node_Str"";
    }
  }
);
  Map<Long,SynthesisSubtreeInfo> preservedSubtrees=new TreeMap<Long,SynthesisSubtreeInfo>();
  print(""String_Node_Str"");
  for (  Node s : orderedSubproblems) {
    if (VERBOSE) {
      print(""String_Node_Str"",s.getProperty(NodeProperty.NAME.propertyName) + ""String_Node_Str"" + s.getProperty(NodeProperty.TAX_UID.propertyName,""String_Node_Str""));
    }
    Transaction tx=G.beginTx();
    try {
      subExpander.synthesizeFrom(s);
      tx.success();
    }
  finally {
      tx.finish();
    }
    childRels.putAll(subExpander.childRels);
    preservedSubtrees.put(s.getId(),subExpander.completedRootInfo());
    subExpander.reset(preservedSubtrees);
  }
}"
50130,"@Override public Node next(){
  Node p=toVisit.pop();
  for (  Relationship r : p.getRelationships(Direction.INCOMING,relTypes)) {
    Node c=r.getStartNode();
    if (!observed.contains(c) && validate(c)) {
      queue(c);
    }
  }
  return p;
}","@Override public Node next(){
  Node n=next;
  loadNext();
  return n;
}"
50131,"@Override public Iterator<Node> iterator(){
  sort();
  return nodes.iterator();
}","@Override public Iterator<Node> iterator(){
  sort();
  print(""String_Node_Str"",nodes.size(),""String_Node_Str"");
  return nodes.iterator();
}"
50132,"@Override public boolean hasNext(){
  return !toVisit.isEmpty();
}","@Override public boolean hasNext(){
  return next != null;
}"
50133,"private void sort(){
}","private void sort(){
  for (  Node n : getNodes()) {
    if (n.hasRelationship(relTypes)) {
      unmarked.add(n);
    }
  }
  while (!unmarked.isEmpty()) {
    visit(unmarked.iterator().next());
  }
}"
50134,"private void visit(Node n){
  if (temporaryMarked.contains(n)) {
    throw new IllegalArgumentException(""String_Node_Str"" + n);
  }
  if (unmarked.contains(n)) {
    temporaryMarked.add(n);
    for (    Relationship m : n.getRelationships(Direction.INCOMING,relTypes)) {
      visit(m.getStartNode());
    }
    unmarked.remove(n);
    temporaryMarked.remove(n);
    nodes.add(n);
    System.out.println(nodes.size() + ""String_Node_Str"");
  }
}","private void visit(Node n){
  if (temporaryMarked.contains(n)) {
    throw new IllegalArgumentException(""String_Node_Str"" + n);
  }
  if (unmarked.contains(n)) {
    temporaryMarked.add(n);
    for (    Relationship m : n.getRelationships(Direction.INCOMING,relTypes)) {
      visit(m.getStartNode());
    }
    unmarked.remove(n);
    temporaryMarked.remove(n);
    if (validate(n)) {
      nodes.add(n);
    }
  }
}"
50135,"@Override public Node next(){
  Node p=toVisit.pollFirst();
  visited.add(p.getId());
  for (  Relationship r : p.getRelationships(Direction.INCOMING,relTypes)) {
    Node c=r.getStartNode();
    if (!visited.contains(c.getId()) && validate(c)) {
      if (c.hasRelationship(Direction.INCOMING,relTypes)) {
        toVisit.addLast(c);
      }
    }
  }
  return p;
}","@Override public Node next(){
  Node p=toVisit.pollFirst();
  visited.add(p.getId());
  for (  Relationship r : p.getRelationships(Direction.INCOMING,relTypes)) {
    Node c=r.getStartNode();
    if (!visited.contains(c.getId()) && validate(c)) {
      toVisit.addLast(c);
    }
  }
  return p;
}"
50136,"public TopologicalOrder(GraphDatabaseAgent G,RelationshipType... relTypes){
  this.G=G;
  this.relTypes=relTypes;
}","public TopologicalOrder(GraphDatabaseAgent G,RelationshipType... relTypes){
  this.root=null;
  this.G=G;
  this.usingAllNodes=true;
  this.relTypes=relTypes;
}"
50137,"private void sort(){
  if (G == null && root == null) {
    throw new NullPointerException();
  }
  Iterable<Node> nodes=G == null ? validDescendants(root) : G.getAllNodes();
  for (  Node n : nodes) {
    if (n.hasRelationship(relTypes)) {
      unmarked.add(n);
    }
  }
  while (!unmarked.isEmpty()) {
    visit(unmarked.iterator().next());
  }
}","private void sort(){
}"
50138,"private void visit(Node n){
  if (temporaryMarked.contains(n)) {
    throw new IllegalArgumentException(""String_Node_Str"" + n);
  }
  if (unmarked.contains(n)) {
    temporaryMarked.add(n);
    for (    Relationship m : n.getRelationships(Direction.INCOMING,relTypes)) {
      visit(m.getStartNode());
    }
    unmarked.remove(n);
    temporaryMarked.remove(n);
    nodes.add(n);
    System.out.println(nodes.size() + ""String_Node_Str"");
  }
}","private void visit(Node n){
  long nid=n.getId();
  if (temporaryMarked.contains(nid)) {
    throw new IllegalArgumentException(""String_Node_Str"" + n);
  }
  if (unmarked.contains(nid)) {
    temporaryMarked.add(nid);
    for (    Relationship m : n.getRelationships(Direction.INCOMING,relTypes)) {
      visit(m.getStartNode());
    }
    unmarked.remove(nid);
    temporaryMarked.remove(nid);
    nodes.add(n);
    System.out.println(nodes.size() + ""String_Node_Str"");
  }
}"
50139,"/** 
 * instantiation runs the entire analysis
 * @param trees
 * @param gdb
 * @param mapInternalNodesToTax
 * @throws Exception
 */
public BipartOracle(List<Tree> trees,GraphDatabaseAgent gdb,boolean useTaxonomy,Map<Tree,String> sources,Map<TreeNode,String> subsetInfo,boolean subset,String subsetFileName) throws Exception {
  this.subset=subset;
  this.gdb=gdb;
  this.USING_TAXONOMY=useTaxonomy;
  this.subsetTipInfo=subsetInfo;
  this.sourceForTrees=sources;
  long w=new Date().getTime();
  validateTrees(trees);
  createTreeIdRankMap(trees);
  if (USING_TAXONOMY) {
    explodedTipsHash=TipExploder.explodeTipsReturnHash(trees,gdb);
    reduceExplodedTipsHash();
  }
  gatherTreeData(trees);
  if (USING_TAXONOMY) {
    mapTreeNodesToTaxa(trees);
  }
  if (USING_TAXONOMY) {
    populateTaxonomyGraphNodesMap(trees);
  }
  gatherBipartitions(trees);
  identifyNestedChildBiparts(trees);
  findAllPaths();
  createNodesUsingPaths();
  mapTreeRootNodes(trees);
  generateMRCAChildOfs();
  mapNonRootNodes(trees);
  removeUnusedNodesAndRels();
  if (subset) {
    Transaction tx=gdb.beginTx();
    Index<Node> ottIdIndex=gdb.getNodeIndex(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    String ottidFromSubset=null;
    if (subsetFileName.contains(""String_Node_Str""))     ottidFromSubset=subsetFileName.split(""String_Node_Str"")[1];
    ottidFromSubset=ottidFromSubset.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"");
    Node gn=ottIdIndex.get(NodeProperty.TAX_UID.propertyName,ottidFromSubset).getSingle();
    Index<Node> ottIdIndexss=gdb.getNodeIndex(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    ottIdIndexss.add(gn,""String_Node_Str"",ottidFromSubset);
    tx.success();
    tx.finish();
  }
  System.out.println(""String_Node_Str"" + (new Date().getTime() - w) / 1000 + ""String_Node_Str"");
}","/** 
 * instantiation runs the entire analysis
 * @param trees
 * @param gdb
 * @param mapInternalNodesToTax
 * @throws Exception
 */
public BipartOracle(List<Tree> trees,GraphDatabaseAgent gdb,boolean useTaxonomy,Map<Tree,String> sources,Map<TreeNode,String> subsetInfo,boolean subset,String subsetFileName) throws Exception {
  this.subset=subset;
  this.gdb=gdb;
  this.USING_TAXONOMY=useTaxonomy;
  this.subsetTipInfo=subsetInfo;
  this.sourceForTrees=sources;
  long w=new Date().getTime();
  validateTrees(trees);
  createTreeIdRankMap(trees);
  if (USING_TAXONOMY) {
    explodedTipsHash=TipExploder.explodeTipsReturnHash(trees,gdb);
    reduceExplodedTipsHash();
  }
  gatherTreeData(trees);
  if (USING_TAXONOMY) {
    mapTreeNodesToTaxa(trees);
  }
  if (USING_TAXONOMY) {
    populateTaxonomyGraphNodesMap(trees);
  }
  gatherBipartitions(trees);
  identifyNestedChildBiparts(trees);
  findAllPaths();
  createNodesUsingPaths();
  mapTreeRootNodes(trees);
  generateMRCAChildOfs();
  mapNonRootNodes(trees);
  removeUnusedNodesAndRels();
  if (subset) {
    Transaction tx=gdb.beginTx();
    Index<Node> ottIdIndex=gdb.getNodeIndex(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    String ottidFromSubset=null;
    if (subsetFileName.contains(""String_Node_Str"")) {
      ottidFromSubset=subsetFileName.split(""String_Node_Str"")[1];
    }
 else {
      ottidFromSubset=subsetFileName;
    }
    ottidFromSubset=ottidFromSubset.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"");
    Node gn=ottIdIndex.get(NodeProperty.TAX_UID.propertyName,ottidFromSubset).getSingle();
    Index<Node> ottIdIndexss=gdb.getNodeIndex(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    ottIdIndexss.add(gn,""String_Node_Str"",ottidFromSubset);
    tx.success();
    tx.finish();
  }
  System.out.println(""String_Node_Str"" + (new Date().getTime() - w) / 1000 + ""String_Node_Str"");
}"
50140,"/** 
 * return a graph containing a tree with N tips and nBackEdges backward edges.
 * @throws IOException 
 */
public static GraphDatabaseAgent randomTreeWithBackEdges(int nTips,int maxChildren,int nBackEdges,String dbname) throws IOException {
  if (nTips < 3) {
    throw new IllegalArgumentException();
  }
  GraphDatabaseAgent G=emptyGraph(dbname);
  createRandomNTree(G,nTips,maxChildren);
  List<Node> all=new ArrayList<Node>();
  for (  Node n : new TopologicalOrder(G,new HashSet<Relationship>(),RelType.STREECHILDOF)) {
    if (n.getId() != 0)     all.add(n);
  }
  int N=all.size() - 1;
  System.out.println(N);
  System.out.println(N - nTips);
  Transaction tx=G.beginTx();
  Random r=new Random();
  for (int i=0; i < nBackEdges; i++) {
    long p=r.nextInt(N - nTips) + 2;
    long q=all.size();
    while (p <= q) {
      q=r.nextInt(N - nTips - 1) + 1;
      System.out.println(p + ""String_Node_Str"" + q);
    }
    G.getNodeById(p).createRelationshipTo(G.getNodeById(q),RelType.STREECHILDOF);
  }
  tx.success();
  tx.finish();
  return G;
}","/** 
 * return a graph containing a tree with N tips and nBackEdges backward edges.
 * @throws IOException 
 */
public static GraphDatabaseAgent randomTreeWithBackEdges(int nTips,int maxChildren,int nBackEdges,String dbname) throws IOException {
  if (nTips < 3) {
    throw new IllegalArgumentException();
  }
  GraphDatabaseAgent G=emptyGraph(dbname);
  createRandomNTree(G,nTips,maxChildren);
  List<Node> all=new ArrayList<Node>();
  for (  Node n : new TopologicalOrder(G,new HashSet<Relationship>(),RelType.STREECHILDOF)) {
    if (n.getId() != 0)     all.add(n);
  }
  int N=all.size() - 1;
  System.out.println(N);
  System.out.println(N - nTips);
  Transaction tx=G.beginTx();
  Random r=new Random();
  for (int i=0; i < nBackEdges; i++) {
    Node p=G.getNodeById((long)r.nextInt(N - nTips) + nTips);
    LinkedList<Node> toVisit=new LinkedList<Node>();
    toVisit.add(p);
    List<Node> descendants=new ArrayList<Node>();
    while (toVisit.size() > 0) {
      addChildren(toVisit.pop(),descendants);
    }
    p.createRelationshipTo(descendants.get(r.nextInt(descendants.size())),RelType.STREECHILDOF);
  }
  tx.success();
  tx.finish();
  return G;
}"
50141,"public static void main(String[] args) throws IOException {
  String dbname=""String_Node_Str"";
  simpleTest(GraphGenerator.simpleCycle(10,dbname),1);
  simpleTest(GraphGenerator.chordedCycle(10,4,dbname),1);
  simpleTest(GraphGenerator.chainOfSimpleCycles(5,5,dbname),5);
  simpleTest(GraphGenerator.cycleOfSimpleCycles(5,5,dbname),1);
  simpleTest(GraphGenerator.randomTree(20,2,dbname),20 + 20 - 1);
  maximumCountTest(GraphGenerator.randomTreeWithBackEdges(10,2,1,dbname),18);
}","public static void main(String[] args) throws IOException {
  String dbname=""String_Node_Str"";
  simpleTest(GraphGenerator.simpleCycle(10,dbname),1);
  simpleTest(GraphGenerator.chordedCycle(10,4,dbname),1);
  simpleTest(GraphGenerator.chainOfSimpleCycles(5,5,dbname),5);
  simpleTest(GraphGenerator.cycleOfSimpleCycles(5,5,dbname),1);
  simpleTest(GraphGenerator.randomTree(20,2,dbname),20 + 20 - 1);
  int maxTips=10;
  int nReps=1000;
  Random r=new Random();
  for (int i=0; i < nReps; i++) {
    int nTips=r.nextInt(maxTips - 3) + 3;
    int maxSCCs=(2 * maxTips) - 2;
    int nBackEdges=1;
    maximumCountTest(GraphGenerator.randomTreeWithBackEdges(nTips,2,nBackEdges,dbname),maxSCCs);
  }
}"
50142,"private void visit(Node n){
  if (temporaryMarked.contains(n)) {
    throw new IllegalArgumentException(""String_Node_Str"" + n);
  }
  if (unmarked.contains(n)) {
    temporaryMarked.add(n);
    for (    Relationship m : n.getRelationships(Direction.INCOMING,relTypes)) {
      if (excludedRels.contains(m)) {
        visit(m.getStartNode());
      }
    }
    unmarked.remove(n);
    temporaryMarked.remove(n);
    nodes.add(n);
  }
}","private void visit(Node n){
  if (temporaryMarked.contains(n)) {
    throw new IllegalArgumentException(""String_Node_Str"" + n);
  }
  if (unmarked.contains(n)) {
    temporaryMarked.add(n);
    for (    Relationship m : n.getRelationships(Direction.INCOMING,relTypes)) {
      if (!excludedRels.contains(m)) {
        visit(m.getStartNode());
      }
    }
    unmarked.remove(n);
    temporaryMarked.remove(n);
    nodes.add(n);
  }
}"
50143,"public Iterable<Long> findBestNonOverlappingGraph(Long[] relIds){
  boolean trivialTestCase=false;
  if (trivialTestCase) {
    return Arrays.asList(relIds);
  }
  WeightedUndirectedGraph G=new WeightedUndirectedGraph();
  for (  long relId : relIds) {
    G.addNode(relId,getWeight(relId));
  }
  for (int i=0; i < relIds.length; i++) {
    long a=getStartNodeId(relIds[i]);
    for (int j=i + 1; j < relIds.length; j++) {
      long b=getStartNodeId(relIds[j]);
      if (nodeMrca.get(a).containsAny(nodeMrca.get(b))) {
        G.getNode(a).attachTo(b);
      }
    }
  }
  return null;
}","public Iterable<Long> findBestNonOverlappingGraph(Long[] relIds){
  boolean trivialTestCase=false;
  if (trivialTestCase) {
    return Arrays.asList(relIds);
  }
  WeightedUndirectedGraph G=new WeightedUndirectedGraph();
  for (  long relId : relIds) {
    G.addNode(relId,getWeight(relId));
  }
  for (int i=0; i < relIds.length; i++) {
    long a=getStartNodeId(relIds[i]);
    for (int j=i + 1; j < relIds.length; j++) {
      long b=getStartNodeId(relIds[j]);
      if (nodeMrcaTipsAndInternal.get(a).containsAny(nodeMrcaTipsAndInternal.get(b))) {
        G.getNode(a).attachTo(b);
      }
    }
  }
  return null;
}"
50144,"/** 
 * simple weight based only on the size of the mrca set of the node 
 */
private int getWeight(long id){
  TLongBitArraySet m=nodeMrca.get(id);
  if (m == null) {
    return 1;
  }
 else {
    return m.size();
  }
}","/** 
 * simple weight based only on the size of the mrca set of the node 
 */
private int getWeight(long id){
  TLongBitArraySet m=nodeMrcaTipsAndInternal.get(id);
  if (m == null) {
    return 1;
  }
 else {
    return m.size();
  }
}"
50145,"/** 
 * This is the simplest node scoring criterion we could come up with: just the number of descendants. Joseph has done some work coming up with a better one that included the structure of the tree.
 * @param node
 * @return
 */
private double getScoreNodeCount(Relationship rel){
  return nodeMrca.get(rel.getStartNode().getId()).cardinality();
}","/** 
 * This is the simplest node scoring criterion we could come up with: just the number of descendants. Joseph has done some work coming up with a better one that included the structure of the tree.
 * @param node
 * @return
 */
private double getScoreNodeCount(Relationship rel){
  return nodeMrcaTipsAndInternal.get(rel.getStartNode().getId()).cardinality();
}"
50146,"private List<Long> findBestNonOverlapping(Collection<Relationship> rels){
  if (rels.size() < 1) {
    if (VERBOSE) {
      System.out.println(""String_Node_Str"");
    }
    return new ArrayList<Long>();
  }
  TLongBitArraySet[] mrcaSetsForRels=new TLongBitArraySet[rels.size()];
  double[] weights=new double[rels.size()];
  Long[] relIds=new Long[rels.size()];
  int taxSum=0;
  HashSet<Long> uniqueTips=new HashSet<Long>();
  Iterator<Relationship> relsIter=rels.iterator();
  for (int i=0; relsIter.hasNext(); i++) {
    Relationship rel=relsIter.next();
    TLongBitArraySet currDesc=mrcaTipsAndInternal(rel.getId());
    if (currDesc == null) {
      throw new IllegalStateException(""String_Node_Str"" + rel);
    }
    relIds[i]=rel.getId();
    mrcaSetsForRels[i]=currDesc;
    weights[i]=getScoreNodeCount(rel);
    long[] currTips=mrcaTips(rel);
    taxSum+=currTips.length;
    for (int j=0; j < currTips.length; j++) {
      uniqueTips.add(currTips[j]);
    }
    if (VERBOSE) {
      System.out.println(rel.getId() + ""String_Node_Str"" + rel.getStartNode().getId()+ ""String_Node_Str""+ nodeMrca.get(rel.getStartNode().getId())+ ""String_Node_Str""+ weights[i]);
    }
  }
  System.out.println(""String_Node_Str"" + taxSum + ""String_Node_Str""+ uniqueTips.size()+ ""String_Node_Str""+ relIds.length);
  if (taxSum == uniqueTips.size()) {
    System.out.println(""String_Node_Str"");
    return new ArrayList<Long>(Arrays.asList(relIds));
  }
 else   if (relIds.length <= BruteWeightedIS.MAX_TRACTABLE_N) {
    return new BruteWeightedIS(relIds,weights,mrcaSetsForRels).best();
  }
 else {
    return new GreedyApproximateWeightedIS(relIds,weights,mrcaSetsForRels).best();
  }
}","private List<Long> findBestNonOverlapping(Collection<Relationship> rels){
  if (rels.size() < 1) {
    if (VERBOSE) {
      System.out.println(""String_Node_Str"");
    }
    return new ArrayList<Long>();
  }
  TLongBitArraySet[] mrcaSetsForRels=new TLongBitArraySet[rels.size()];
  double[] weights=new double[rels.size()];
  Long[] relIds=new Long[rels.size()];
  int taxSum=0;
  HashSet<Long> uniqueTips=new HashSet<Long>();
  Iterator<Relationship> relsIter=rels.iterator();
  for (int i=0; relsIter.hasNext(); i++) {
    Relationship rel=relsIter.next();
    TLongBitArraySet currDesc=mrcaTipsAndInternal(rel.getStartNode());
    if (currDesc == null) {
      throw new IllegalStateException(""String_Node_Str"" + rel);
    }
    relIds[i]=rel.getId();
    mrcaSetsForRels[i]=currDesc;
    weights[i]=getScoreNodeCount(rel);
    TLongBitArraySet currTips=mrcaTips(rel.getStartNode());
    taxSum+=currTips.size();
    for (    long t : currTips) {
      uniqueTips.add(t);
    }
    if (VERBOSE) {
      System.out.println(rel.getId() + ""String_Node_Str"" + rel.getStartNode().getId()+ ""String_Node_Str""+ nodeMrcaTipsAndInternal.get(rel.getStartNode().getId())+ ""String_Node_Str""+ weights[i]);
    }
  }
  System.out.println(""String_Node_Str"" + taxSum + ""String_Node_Str""+ uniqueTips.size()+ ""String_Node_Str""+ relIds.length);
  if (taxSum == uniqueTips.size()) {
    System.out.println(""String_Node_Str"");
    return new ArrayList<Long>(Arrays.asList(relIds));
  }
 else   if (relIds.length <= BruteWeightedIS.MAX_TRACTABLE_N) {
    return new BruteWeightedIS(relIds,weights,mrcaSetsForRels).best();
  }
 else {
    return new GreedyApproximateWeightedIS(relIds,weights,mrcaSetsForRels).best();
  }
}"
50147,"/** 
 * For each candidate rel r, we must check whether or not setToUpdate contains *any* rels which are completely contained by r. If this is true, and if r does not conflict with any other rels in setToUpdate, then we return a new set that contains r, all of the rels from setToUpdate that are not contained by r and do not overlap with r, and none of the rels from setToUpdate that are completely contained by r.
 */
private Set<Relationship> updateSet(Relationship candidate,Set<Relationship> setToUpdate){
  Set<Relationship> updated=new HashSet<Relationship>();
  Set<Relationship> containedByCandidate=new HashSet<Relationship>();
  boolean addCandidate=true;
  for (  Relationship s : setToUpdate) {
    if (ancestorOf(s,candidate)) {
      containedByCandidate.add(s);
      if (VERBOSE) {
        print(""String_Node_Str"",candidate,""String_Node_Str"",s);
      }
    }
 else     if (overlapsWith(candidate,s)) {
      addCandidate=false;
      if (VERBOSE) {
        print(""String_Node_Str"",candidate,""String_Node_Str"",s);
      }
      break;
    }
 else {
      updated.add(s);
    }
  }
  if (addCandidate) {
    if (VERBOSE) {
      print(""String_Node_Str"",candidate,""String_Node_Str"");
    }
    updated.add(candidate);
  }
 else {
    if (VERBOSE) {
      print(""String_Node_Str"");
    }
    updated=setToUpdate;
  }
  if (VERBOSE) {
    print();
  }
  return updated;
}","/** 
 * For each candidate rel r, we must check whether or not setToUpdate contains *any* rels which are completely contained by r. If this is true, and if r does not conflict with any other rels in setToUpdate, then we return a new set that contains r, all of the rels from setToUpdate that are not contained by r and do not overlap with r, and none of the rels from setToUpdate that are completely contained by r.
 */
private Set<Relationship> updateSet(Relationship candidate,Set<Relationship> setToUpdate){
  if (VERBOSE) {
    print(""String_Node_Str"",candidate,""String_Node_Str"",mrcaTips(candidate.getStartNode()));
  }
  Set<Relationship> updated=new HashSet<Relationship>();
  Set<Relationship> containedByCandidate=new HashSet<Relationship>();
  boolean addCandidate=true;
  for (  Relationship s : setToUpdate) {
    if (VERBOSE) {
      print(""String_Node_Str"",s,""String_Node_Str"",mrcaTips(s.getStartNode()));
    }
    if (containsAllTips(s,candidate)) {
      containedByCandidate.add(s);
      if (VERBOSE) {
        print(""String_Node_Str"",candidate,""String_Node_Str"",s);
      }
    }
 else     if (overlapsWith(candidate,s)) {
      addCandidate=false;
      if (VERBOSE) {
        print(""String_Node_Str"",candidate,""String_Node_Str"",s);
      }
      break;
    }
 else {
      updated.add(s);
    }
  }
  if (addCandidate) {
    if (VERBOSE) {
      print(""String_Node_Str"",candidate,""String_Node_Str"");
    }
    updated.add(candidate);
  }
 else {
    if (VERBOSE) {
      print(""String_Node_Str"");
    }
    updated=setToUpdate;
  }
  if (VERBOSE) {
    print();
  }
  return updated;
}"
50148,"private int nodeCount(Set<Relationship> rels){
  int n=0;
  for (  Relationship r : rels) {
    n+=mrcaTipsAndInternal(r.getId()).size();
  }
  return n;
}","private int nodeCount(Set<Relationship> rels){
  int n=0;
  for (  Relationship r : rels) {
    n+=mrcaTipsAndInternal(r.getStartNode()).size();
  }
  return n;
}"
50149,"/** 
 * Returns true if and only if r contains no descendant tips that are shared by any of the rels in others.<br><br>
 */
private boolean overlapsWith(Relationship r,Relationship s){
  return mrcaTipsAndInternal(s.getId()).containsAny(mrcaTipsAndInternal(r.getId()));
}","/** 
 * Returns true if and only if r contains no descendant tips that are shared by any of the rels in others.<br><br>
 */
private boolean overlapsWith(Relationship r,Relationship s){
  return mrcaTipsAndInternal(s.getStartNode()).containsAny(mrcaTipsAndInternal(r.getStartNode()));
}"
50150,"/** 
 * Record the specified rels as the selected set for the given node.
 * @param n
 * @param bestRelIds
 */
private void recordRels(Node n,Iterable<Relationship> bestRels){
  TLongBitArraySet descendants=new TLongBitArraySet();
  HashSet<Relationship> incomingRels=new HashSet<Relationship>();
  for (  Relationship r : bestRels) {
    long childId=r.getStartNode().getId();
    incomingRels.add(r);
    descendants.add(childId);
    descendants.addAll(nodeMrca.get(childId));
    if (VERBOSE) {
      print(""String_Node_Str"" + childId + ""String_Node_Str""+ nodeMrca.get(childId)+ ""String_Node_Str""+ n.getId()+ ""String_Node_Str"");
    }
  }
  long nodeId=n.getId();
  descendants.add(nodeId);
  nodeMrca.put(nodeId,descendants);
  childRels.put(nodeId,incomingRels);
  if (VERBOSE) {
    print(""String_Node_Str"");
    print(""String_Node_Str"" + n.getId() + ""String_Node_Str""+ nodeMrca.get(n.getId()));
    print(""String_Node_Str"" + n.getId() + ""String_Node_Str""+ childRels.get(n.getId()));
  }
  ;
}","/** 
 * Record the specified rels as the selected set for the given node.
 * @param n
 * @param bestRelIds
 */
private void recordRels(Node n,Iterable<Relationship> bestRels){
  TLongBitArraySet descendants=new TLongBitArraySet();
  TLongBitArraySet descendantTips=new TLongBitArraySet();
  HashSet<Relationship> incomingRels=new HashSet<Relationship>();
  for (  Relationship r : bestRels) {
    long childId=r.getStartNode().getId();
    incomingRels.add(r);
    descendants.add(childId);
    descendants.addAll(nodeMrcaTipsAndInternal.get(childId));
    descendantTips.addAll(nodeMrcaTips.get(childId));
    if (VERBOSE) {
      print(""String_Node_Str"" + childId + ""String_Node_Str""+ nodeMrcaTipsAndInternal.get(childId)+ ""String_Node_Str""+ n.getId()+ ""String_Node_Str"");
    }
  }
  if (!n.hasRelationship(Direction.INCOMING,RelType.STREECHILDOF,RelType.TAXCHILDOF)) {
    descendantTips.add(n.getId());
  }
  long nodeId=n.getId();
  descendants.add(nodeId);
  nodeMrcaTipsAndInternal.put(nodeId,descendants);
  nodeMrcaTips.put(nodeId,descendantTips);
  childRels.put(nodeId,incomingRels);
  if (VERBOSE) {
    print(""String_Node_Str"");
    print(""String_Node_Str"" + n.getId() + ""String_Node_Str""+ nodeMrcaTipsAndInternal.get(n.getId()));
    print(""String_Node_Str"" + n.getId() + ""String_Node_Str""+ childRels.get(n.getId()));
  }
  ;
}"
50151,"/** 
 * Get *all* the graph nodes--tips as well as internal--that are descended from the start node of the  passed relId in the synthetic topology. <strong>Clarification:</strong> The argument should be a  neo4j relationship id.
 * @param rel
 * @return
 */
TLongBitArraySet mrcaTipsAndInternal(Long relId){
  return nodeMrca.get(G.getRelationshipById(relId).getStartNode().getId());
}","/** 
 * Get *all* the graph nodes--tips as well as internal--that are descended from the start node of the  passed relId in the synthetic topology. <strong>Clarification:</strong> The argument should be a  neo4j relationship id.
 * @param rel
 * @return
 */
TLongBitArraySet mrcaTipsAndInternal(Node n){
  return nodeMrcaTipsAndInternal.get(n.getId());
}"
50152,"/** 
 * Return a list containing all the *graph tip nodes* (which will be terminal taxa if taxonomy is being used) that are descended from the child node of this relationship. This should be used for assessing taxonomic overlap among nodes.<br><br> WARNING: this may not provide the expected results when taxonomy nodes are ancestors/descendants of a given node: we don't update mrca properties to contain taxonomy so it is possible for a node x to have descendant tips that are not in x.mrca!
 * @param rel
 * @return
 */
long[] mrcaTips(Relationship rel){
  return (long[])rel.getStartNode().getProperty(NodeProperty.MRCA.propertyName);
}","/** 
 * Get *all* the graph nodes--tips as well as internal--that are descended from the start node of the  passed relId in the synthetic topology. <strong>Clarification:</strong> The argument should be a  neo4j relationship id.
 * @param rel
 * @return
 */
TLongBitArraySet mrcaTips(Node n){
  return nodeMrcaTips.get(n.getId());
}"
50153,"/** 
 * The synthesis method for creating the draft tree. Uses the refactored synthesis classes. This will store the synthesized topology as SYNTHCHILDOF relationships in the graph.
 * @param startNode this is the beginning node for analysis
 * @param preferredSourceIds this includes the list of preferred sources
 * @param test this will just run through the motions but won't store the synthesis 
 * @throws Exception 
 */
public boolean synthesizeAndStoreDraftTreeBranches(Node startNode,Iterable<String> preferredSourceIds,boolean test) throws Exception {
  ArrayList<Object> sourceIdPriorityList=new ArrayList<Object>();
  for (  String sourceId : preferredSourceIds) {
    sourceIdPriorityList.add(sourceId);
  }
  String synthName=""String_Node_Str"";
  String[] sourceIdPriorityListString=new String[sourceIdPriorityList.size()];
  int iii=0;
  ArrayList<Object> justSourcePriorityList=new ArrayList<Object>();
  for (  String sourceId : preferredSourceIds) {
    if (sourceId.startsWith(""String_Node_Str"")) {
      justSourcePriorityList.add(""String_Node_Str"" + sourceId.split(""String_Node_Str"")[1]);
    }
 else     if (sourceId.startsWith(""String_Node_Str"")) {
      justSourcePriorityList.add(""String_Node_Str"" + sourceId.split(""String_Node_Str"")[1]);
    }
 else {
      justSourcePriorityList.add(sourceId.split(""String_Node_Str"")[0]);
    }
    if (synthName == ""String_Node_Str"") {
      synthName=sourceId;
    }
 else {
      synthName+=""String_Node_Str"" + sourceId;
    }
    sourceIdPriorityListString[iii]=sourceId;
    iii++;
  }
  System.out.println(""String_Node_Str"" + synthName + ""String_Node_Str"");
  boolean done=false;
  String tempSynthTreeName=DRAFTTREENAME;
  int jj=0;
  while (!done) {
    String terp=tempSynthTreeName;
    if (jj > 0) {
      terp+=""String_Node_Str"" + jj;
    }
    IndexHits<Node> hits=synthMetaIndex.query(""String_Node_Str"",terp);
    if (hits.size() > 0) {
      System.out.println(""String_Node_Str"" + terp + ""String_Node_Str"");
    }
 else {
      tempSynthTreeName=terp;
      System.out.println(""String_Node_Str"" + terp + ""String_Node_Str"");
      done=true;
    }
    jj++;
  }
  SynthesisExpander draftSynthesisMethod=new SynthesisExpander();
  RelationshipFilter rf=new RelationshipFilter();
  HashSet<String> filteredsources=new HashSet<String>();
  IndexHits<Node> hits=sourceMetaIndex.query(""String_Node_Str"",""String_Node_Str"");
  boolean studyids=false;
  while (hits.hasNext()) {
    Node n=hits.next();
    if (n.hasProperty(""String_Node_Str"")) {
      if (justSourcePriorityList.contains(n.getProperty(""String_Node_Str"")) == false) {
        filteredsources.add((String)n.getProperty(""String_Node_Str""));
        studyids=true;
      }
    }
 else {
      if (sourceIdPriorityList.contains(n.getProperty(""String_Node_Str"")) == false) {
        filteredsources.add((String)n.getProperty(""String_Node_Str""));
      }
    }
  }
  System.out.println(""String_Node_Str"" + filteredsources);
  if (filteredsources.size() > 0) {
    if (studyids == true) {
      rf.addCriterion(new FilterCriterion(Directive.INCLUDE,new SourcePropertySetTest(filteredsources,SetComparison.CONTAINS_ANY,SourceProperty.STUDY_ID,sourceMetaIndex)));
    }
 else {
      rf.addCriterion(new FilterCriterion(Directive.INCLUDE,new SourcePropertySetTest(filteredsources,SetComparison.CONTAINS_ANY,SourceProperty.SOURCE,sourceMetaIndex)));
    }
    draftSynthesisMethod.setFilter(rf);
  }
  RelationshipRanker rs=new RelationshipRanker();
  if (studyids == true) {
    rs.addCriterion(new SourcePropertyPrioritizedRankingCriterion(SourceProperty.STUDY_ID,sourceIdPriorityList,sourceMetaIndex));
  }
 else {
    rs.addCriterion(new SourcePropertyPrioritizedRankingCriterion(SourceProperty.SOURCE,sourceIdPriorityList,sourceMetaIndex));
  }
  draftSynthesisMethod.setRanker(rs);
  RelationshipConflictResolver rcr=new RelationshipConflictResolver(new RankResolutionMethod());
  draftSynthesisMethod.setConflictResolver(rcr);
  draftSynthesisMethod=new RootwardSynthesisExpander(startNode);
  System.out.println(""String_Node_Str"" + draftSynthesisMethod.getDescription());
  Transaction tx=graphDb.beginTx();
  String synthTreeName=tempSynthTreeName;
  try {
    Node metadatanode=graphDb.createNode();
    metadatanode.createRelationshipTo(startNode,RelType.SYNTHMETADATAFOR);
    metadatanode.setProperty(""String_Node_Str"",synthTreeName);
    Date date=new Date();
    metadatanode.setProperty(""String_Node_Str"",date.toString());
    metadatanode.setProperty(""String_Node_Str"",sourceIdPriorityListString);
    if (getTaxonomyVersion() != null) {
      metadatanode.setProperty(""String_Node_Str"",getTaxonomyVersion());
    }
 else {
      metadatanode.setProperty(""String_Node_Str"",""String_Node_Str"");
    }
    metadatanode.setProperty(""String_Node_Str"",startNode.getId());
    synthMetaIndex.add(metadatanode,""String_Node_Str"",synthTreeName);
    this.graphDb.setGraphProperty(""String_Node_Str"",startNode.getId());
    tx.success();
  }
 catch (  Exception ex) {
    tx.failure();
    throw ex;
  }
 finally {
    tx.finish();
  }
  knownIdsInTree=new HashSet<Long>();
  tx=graphDb.beginTx();
  try {
    for (    Relationship rel : Traversal.description().breadthFirst().expand(draftSynthesisMethod).traverse(startNode).relationships()) {
      System.out.println(""String_Node_Str"" + rel.getId());
      Node parentNode=rel.getEndNode();
      Node curNode=rel.getStartNode();
      if (parentNode != null && test == false) {
        Relationship newRel=curNode.createRelationshipTo(parentNode,RelType.SYNTHCHILDOF);
        newRel.setProperty(""String_Node_Str"",synthTreeName);
        synthRelIndex.add(newRel,""String_Node_Str"",synthTreeName);
        HashSet<String> sources=new HashSet<String>();
        for (        Relationship rel2 : curNode.getRelationships(RelType.STREECHILDOF)) {
          if (rel2.hasProperty(""String_Node_Str"")) {
            sources.add(String.valueOf(rel2.getProperty(""String_Node_Str"")));
          }
        }
        String[] sourcesArray=new String[sources.size()];
        Iterator<String> sourcesIter=sources.iterator();
        for (int i=0; i < sources.size(); i++) {
          sourcesArray[i]=sourcesIter.next();
        }
        newRel.setProperty(""String_Node_Str"",sourcesArray);
      }
      knownIdsInTree.add(curNode.getId());
    }
    System.out.println(""String_Node_Str"" + draftSynthesisMethod.getDeadNodes().size());
    TLongArrayList deadnodes=new TLongArrayList(draftSynthesisMethod.getDeadNodes());
    System.out.println(""String_Node_Str"");
    TLongHashSet vd=new TLongHashSet();
    int actual=0;
    for (int i=0; i < deadnodes.size(); i++) {
      long cnd=deadnodes.get(i);
      if (vd.contains(cnd)) {
        continue;
      }
 else {
        vd.add(cnd);
      }
      Node cn=graphDb.getNodeById(cnd);
      if (cn.hasRelationship(RelType.STREECHILDOF,Direction.INCOMING) == false) {
        vd.add(cnd);
      }
 else {
        System.out.println(""String_Node_Str"" + cnd);
        actual++;
        boolean going=true;
        Node curnode=cn;
        while (going) {
          if (curnode.hasRelationship(RelType.SYNTHCHILDOF,Direction.INCOMING) == false) {
            vd.add(curnode.getId());
            Relationship tr=curnode.getSingleRelationship(RelType.SYNTHCHILDOF,Direction.OUTGOING);
            curnode=tr.getEndNode();
            System.out.println(""String_Node_Str"" + tr);
            synthRelIndex.remove(tr,""String_Node_Str"",synthTreeName);
            tr.delete();
          }
 else {
            break;
          }
        }
      }
    }
    System.out.println(""String_Node_Str"" + actual);
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + draftSynthesisMethod.getReport());
    tx.success();
  }
 catch (  Exception ex) {
    tx.failure();
    throw ex;
  }
 finally {
    tx.finish();
  }
  System.out.println(""String_Node_Str"");
  return true;
}","/** 
 * The synthesis method for creating the draft tree. Uses the refactored synthesis classes. This will store the synthesized topology as SYNTHCHILDOF relationships in the graph.
 * @param startNode this is the beginning node for analysis
 * @param preferredSourceIds this includes the list of preferred sources
 * @param test this will just run through the motions but won't store the synthesis 
 * @throws Exception 
 */
public boolean synthesizeAndStoreDraftTreeBranches(Node startNode,Iterable<String> preferredSourceIds,boolean test) throws Exception {
  ArrayList<Object> sourceIdPriorityList=new ArrayList<Object>();
  for (  String sourceId : preferredSourceIds) {
    sourceIdPriorityList.add(sourceId);
  }
  String synthName=""String_Node_Str"";
  String[] sourceIdPriorityListString=new String[sourceIdPriorityList.size()];
  int iii=0;
  ArrayList<Object> justSourcePriorityList=new ArrayList<Object>();
  for (  String sourceId : preferredSourceIds) {
    if (sourceId.startsWith(""String_Node_Str"")) {
      justSourcePriorityList.add(""String_Node_Str"" + sourceId.split(""String_Node_Str"")[1]);
    }
 else     if (sourceId.startsWith(""String_Node_Str"")) {
      justSourcePriorityList.add(""String_Node_Str"" + sourceId.split(""String_Node_Str"")[1]);
    }
 else {
      justSourcePriorityList.add(sourceId.split(""String_Node_Str"")[0]);
    }
    if (synthName == ""String_Node_Str"") {
      synthName=sourceId;
    }
 else {
      synthName+=""String_Node_Str"" + sourceId;
    }
    sourceIdPriorityListString[iii]=sourceId;
    iii++;
  }
  System.out.println(""String_Node_Str"" + synthName + ""String_Node_Str"");
  boolean done=false;
  String tempSynthTreeName=DRAFTTREENAME;
  int jj=0;
  while (!done) {
    String terp=tempSynthTreeName;
    if (jj > 0) {
      terp+=""String_Node_Str"" + jj;
    }
    IndexHits<Node> hits=synthMetaIndex.query(""String_Node_Str"",terp);
    if (hits.size() > 0) {
      System.out.println(""String_Node_Str"" + terp + ""String_Node_Str"");
    }
 else {
      tempSynthTreeName=terp;
      System.out.println(""String_Node_Str"" + terp + ""String_Node_Str"");
      done=true;
    }
    jj++;
  }
  SynthesisExpander draftSynthesisMethod=new SynthesisExpander();
  RelationshipFilter rf=new RelationshipFilter();
  HashSet<String> filteredsources=new HashSet<String>();
  IndexHits<Node> hits=sourceMetaIndex.query(""String_Node_Str"",""String_Node_Str"");
  boolean studyids=false;
  while (hits.hasNext()) {
    Node n=hits.next();
    if (n.hasProperty(""String_Node_Str"")) {
      if (justSourcePriorityList.contains(n.getProperty(""String_Node_Str"")) == false) {
        filteredsources.add((String)n.getProperty(""String_Node_Str""));
        studyids=true;
      }
    }
 else {
      if (sourceIdPriorityList.contains(n.getProperty(""String_Node_Str"")) == false) {
        filteredsources.add((String)n.getProperty(""String_Node_Str""));
      }
    }
  }
  System.out.println(""String_Node_Str"" + filteredsources);
  if (filteredsources.size() > 0) {
    if (studyids == true) {
      rf.addCriterion(new FilterCriterion(Directive.INCLUDE,new SourcePropertySetTest(filteredsources,SetComparison.CONTAINS_ANY,SourceProperty.STUDY_ID,sourceMetaIndex)));
    }
 else {
      rf.addCriterion(new FilterCriterion(Directive.INCLUDE,new SourcePropertySetTest(filteredsources,SetComparison.CONTAINS_ANY,SourceProperty.SOURCE,sourceMetaIndex)));
    }
    draftSynthesisMethod.setFilter(rf);
  }
  RelationshipRanker rs=new RelationshipRanker();
  if (studyids == true) {
    rs.addCriterion(new SourcePropertyPrioritizedRankingCriterion(SourceProperty.STUDY_ID,sourceIdPriorityList,sourceMetaIndex));
  }
 else {
    rs.addCriterion(new SourcePropertyPrioritizedRankingCriterion(SourceProperty.SOURCE,sourceIdPriorityList,sourceMetaIndex));
  }
  draftSynthesisMethod.setRanker(rs);
  RelationshipConflictResolver rcr=new RelationshipConflictResolver(new RankResolutionMethod());
  draftSynthesisMethod.setConflictResolver(rcr);
  draftSynthesisMethod=new RootwardNodeCountSynthesisExpander(startNode);
  System.out.println(""String_Node_Str"" + draftSynthesisMethod.getDescription());
  Transaction tx=graphDb.beginTx();
  String synthTreeName=tempSynthTreeName;
  try {
    Node metadatanode=graphDb.createNode();
    metadatanode.createRelationshipTo(startNode,RelType.SYNTHMETADATAFOR);
    metadatanode.setProperty(""String_Node_Str"",synthTreeName);
    Date date=new Date();
    metadatanode.setProperty(""String_Node_Str"",date.toString());
    metadatanode.setProperty(""String_Node_Str"",sourceIdPriorityListString);
    if (getTaxonomyVersion() != null) {
      metadatanode.setProperty(""String_Node_Str"",getTaxonomyVersion());
    }
 else {
      metadatanode.setProperty(""String_Node_Str"",""String_Node_Str"");
    }
    metadatanode.setProperty(""String_Node_Str"",startNode.getId());
    synthMetaIndex.add(metadatanode,""String_Node_Str"",synthTreeName);
    this.graphDb.setGraphProperty(""String_Node_Str"",startNode.getId());
    tx.success();
  }
 catch (  Exception ex) {
    tx.failure();
    throw ex;
  }
 finally {
    tx.finish();
  }
  knownIdsInTree=new HashSet<Long>();
  tx=graphDb.beginTx();
  try {
    for (    Relationship rel : Traversal.description().breadthFirst().expand(draftSynthesisMethod).traverse(startNode).relationships()) {
      System.out.println(""String_Node_Str"" + rel.getId());
      Node parentNode=rel.getEndNode();
      Node curNode=rel.getStartNode();
      if (parentNode != null && test == false) {
        Relationship newRel=curNode.createRelationshipTo(parentNode,RelType.SYNTHCHILDOF);
        newRel.setProperty(""String_Node_Str"",synthTreeName);
        synthRelIndex.add(newRel,""String_Node_Str"",synthTreeName);
        HashSet<String> sources=new HashSet<String>();
        for (        Relationship rel2 : curNode.getRelationships(RelType.STREECHILDOF)) {
          if (rel2.hasProperty(""String_Node_Str"")) {
            sources.add(String.valueOf(rel2.getProperty(""String_Node_Str"")));
          }
        }
        String[] sourcesArray=new String[sources.size()];
        Iterator<String> sourcesIter=sources.iterator();
        for (int i=0; i < sources.size(); i++) {
          sourcesArray[i]=sourcesIter.next();
        }
        newRel.setProperty(""String_Node_Str"",sourcesArray);
      }
      knownIdsInTree.add(curNode.getId());
    }
    System.out.println(""String_Node_Str"" + draftSynthesisMethod.getDeadNodes().size());
    TLongArrayList deadnodes=new TLongArrayList(draftSynthesisMethod.getDeadNodes());
    System.out.println(""String_Node_Str"");
    TLongHashSet vd=new TLongHashSet();
    int actual=0;
    for (int i=0; i < deadnodes.size(); i++) {
      long cnd=deadnodes.get(i);
      if (vd.contains(cnd)) {
        continue;
      }
 else {
        vd.add(cnd);
      }
      Node cn=graphDb.getNodeById(cnd);
      if (cn.hasRelationship(RelType.STREECHILDOF,Direction.INCOMING) == false) {
        vd.add(cnd);
      }
 else {
        System.out.println(""String_Node_Str"" + cnd);
        actual++;
        boolean going=true;
        Node curnode=cn;
        while (going) {
          if (curnode.hasRelationship(RelType.SYNTHCHILDOF,Direction.INCOMING) == false) {
            vd.add(curnode.getId());
            Relationship tr=curnode.getSingleRelationship(RelType.SYNTHCHILDOF,Direction.OUTGOING);
            curnode=tr.getEndNode();
            System.out.println(""String_Node_Str"" + tr);
            synthRelIndex.remove(tr,""String_Node_Str"",synthTreeName);
            tr.delete();
          }
 else {
            break;
          }
        }
      }
    }
    System.out.println(""String_Node_Str"" + actual);
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + draftSynthesisMethod.getReport());
    tx.success();
  }
 catch (  Exception ex) {
    tx.failure();
    throw ex;
  }
 finally {
    tx.finish();
  }
  System.out.println(""String_Node_Str"");
  return true;
}"
50154,"private Node createNode(TLongBipartition b){
  Node node=gdb.createNode();
  if (VERBOSE) {
    System.out.println(node);
  }
  if (USING_TAXONOMY) {
    TLongBipartition tlb=getExpandedTaxonomyBipart(b);
    node.setProperty(NodeProperty.MRCA.propertyName,tlb.ingroup().toArray());
    node.setProperty(NodeProperty.OUTMRCA.propertyName,tlb.outgroup().toArray());
  }
 else {
    node.setProperty(NodeProperty.MRCA.propertyName,b.ingroup().toArray());
    node.setProperty(NodeProperty.OUTMRCA.propertyName,b.outgroup().toArray());
  }
  graphNodeForBipart.put(b,node);
  bipartForGraphNode.put(node,b);
  return node;
}","private Node createNode(TLongBipartition b){
  Node node=gdb.createNode();
  if (VERBOSE) {
    System.out.println(node);
  }
  if (USING_TAXONOMY) {
    TLongBipartition tlb=getExpandedTaxonomyBipart(b);
    bipartForGraphNodeExploded.put(node,tlb);
    graphNodeForBipartExploded.put(tlb,node);
    node.setProperty(NodeProperty.MRCA.propertyName,tlb.ingroup().toArray());
    node.setProperty(NodeProperty.OUTMRCA.propertyName,tlb.outgroup().toArray());
  }
 else {
    node.setProperty(NodeProperty.MRCA.propertyName,b.ingroup().toArray());
    node.setProperty(NodeProperty.OUTMRCA.propertyName,b.outgroup().toArray());
  }
  graphNodeForBipart.put(b,node);
  bipartForGraphNode.put(node,b);
  return node;
}"
50155,"/** 
 * Collect information from trees, including tip labels, nodes that are mapped to those tip labels, original bipartitions from trees, and their original internal nodes. Objects and associated information are stored in various class members for later use.
 * @param trees
 */
private void gatherTreeData(List<Tree> trees){
  System.out.print(""String_Node_Str"" + trees.size() + ""String_Node_Str"");
  long z=new Date().getTime();
  if (USING_TAXONOMY) {
    mapTipsToTaxa(trees);
  }
 else {
    importTipsFromTrees(trees);
  }
  nodeId=0;
  for (  Tree tree : trees) {
    Collection<TLongBipartition> treeBiparts=new ArrayList<TLongBipartition>();
    for (    TreeNode node : tree.internalNodes(NodeOrder.PREORDER)) {
      if (!node.isTheRoot()) {
        TLongBipartition b=getGraphBipartForTreeNode(node,tree);
        if (!bipartId.containsKey(b)) {
          bipart.add(b);
          bipartId.put(b,bipart.size() - 1);
        }
 else {
          b=bipart.get(bipartId.get(b));
        }
        if (treeNodesForBipart.get(b) == null) {
          treeNodesForBipart.put(b,new HashSet<TreeNode>());
        }
        treeNodesForBipart.get(b).add(node);
        bipartForTreeNode.put(node,b);
      }
    }
    bipartsByTreeNoDuplicates.add(treeBiparts);
  }
  System.out.println(""String_Node_Str"" + (new Date().getTime() - z) / (float)1000 + ""String_Node_Str"");
}","/** 
 * Collect information from trees, including tip labels, nodes that are mapped to those tip labels, original bipartitions from trees, and their original internal nodes. Objects and associated information are stored in various class members for later use.
 * @param trees
 */
private void gatherTreeData(List<Tree> trees){
  System.out.print(""String_Node_Str"" + trees.size() + ""String_Node_Str"");
  long z=new Date().getTime();
  if (USING_TAXONOMY) {
    mapTipsToTaxa(trees);
  }
 else {
    importTipsFromTrees(trees);
  }
  nodeId=0;
  for (  Tree tree : trees) {
    Collection<TLongBipartition> treeBiparts=new ArrayList<TLongBipartition>();
    for (    TreeNode node : tree.internalNodes(NodeOrder.PREORDER)) {
      if (!node.isTheRoot()) {
        TLongBipartition b=getGraphBipartForTreeNode(node,tree);
        if (!bipartId.containsKey(b)) {
          bipart.add(b);
          bipartId.put(b,bipart.size() - 1);
        }
 else {
          b=bipart.get(bipartId.get(b));
        }
        if (treeNodesForBipart.get(b) == null) {
          treeNodesForBipart.put(b,new HashSet<TreeNode>());
        }
        treeNodesForBipart.get(b).add(node);
        bipartForTreeNode.put(node,b);
        if (USING_TAXONOMY) {
          TLongBipartition be=getExpandedTaxonomyBipart(b);
          bipartForTreeNodeExploded.put(node,be);
          if (treeNodesForBipartExploded.get(b) == null) {
            treeNodesForBipartExploded.put(be,new HashSet<TreeNode>());
          }
          treeNodesForBipartExploded.get(be).add(node);
        }
      }
    }
    bipartsByTreeNoDuplicates.add(treeBiparts);
  }
  System.out.println(""String_Node_Str"" + (new Date().getTime() - z) / (float)1000 + ""String_Node_Str"");
}"
50156,"/** 
 * A parallel method to find nestedChildOf rels across input trees, so that many can be processed concurrently. The idea here is that we just process each tree independently, comparing it to all other trees, looking for all nestedChildOf rels where this tree could be a parent. For this, we can use the structure of the trees to stop short of doing a complete allxall comparison of tree nodes, which saves some time. We then perform a (seemingly unavoidable) allxall comparison of each tree's nodes against all the summed biparts. We store the resulting parent/child information in the form of a map where they keys are the bipart ids of child biparts and the values are sets of bipart ids for their parents.
 * @param i
 * @param trees
 * @return
 */
private void processBipartsForTree(int i,List<Tree> trees){
  for (  TreeNode c : trees.get(i).internalNodes(NodeOrder.POSTORDER)) {
    if (c.isTheRoot()) {
      continue;
    }
    int cid=bipartId.get(bipartForTreeNode.get(c));
    for (TreeNode p=c.getParent(); !p.isTheRoot(); p=p.getParent()) {
      int pid=bipartId.get(bipartForTreeNode.get(p));
      nestedParents.get(cid).add(pid);
      nestedChildren.get(pid).add(cid);
    }
  }
  Tree P=trees.get(i);
  List<TreeNode> pRootChildren=P.getRoot().getChildren();
  pRootChildren.removeIf(isTip());
  for (int j=0; j < trees.size(); j++) {
    if (i == j) {
      continue;
    }
    List<TreeNode> qRootChildren=trees.get(j).getRoot().getChildren();
    qRootChildren.removeIf(isTip());
    boolean treesHaveIdenticalTaxa=bipartForTreeNode.get(pRootChildren.get(0)).hasIdenticalTaxonSetAs(bipartForTreeNode.get(qRootChildren.get(0)));
    LinkedList<TreeNode> pStack=new LinkedList<TreeNode>();
    for (pStack.addAll(pRootChildren); !pStack.isEmpty(); ) {
      TreeNode p=pStack.pop();
      if (p.isExternal()) {
        continue;
      }
      int pid=bipartId.get(bipartForTreeNode.get(p));
      TLongBipartition bp=bipart.get(pid);
      LinkedList<TreeNode> qStack=new LinkedList<TreeNode>();
      for (qStack.addAll(qRootChildren); !qStack.isEmpty(); ) {
        TreeNode q=qStack.pop();
        if (q.isExternal()) {
          continue;
        }
        int qid=bipartId.get(bipartForTreeNode.get(q));
        TLongBipartition bq=bipart.get(qid);
        if (bq.isNestedPartitionOf(bp)) {
          nestedParents.get(qid).add(pid);
          nestedChildren.get(pid).add(qid);
          if (!treesHaveIdenticalTaxa) {
            nestedAugmentingParents.get(qid).add(pid);
          }
        }
        if (bq.ingroup().containsAny(bp.ingroup())) {
          for (          TreeNode qc : q.getChildren()) {
            qStack.push(qc);
          }
        }
      }
      for (      TreeNode qn : qRootChildren) {
        boolean pOverlapsWithTreeQ=false;
        if (qn.isExternal()) {
          if (bp.ingroup().contains(this.nodeIdForLabel.get(qn.getLabel()))) {
            pOverlapsWithTreeQ=true;
          }
        }
 else         if (bp.ingroup().containsAny(bipartForTreeNode.get(qn).ingroup())) {
          pOverlapsWithTreeQ=true;
        }
        if (pOverlapsWithTreeQ) {
          for (          TreeNode pc : p.getChildren()) {
            pStack.push(pc);
          }
        }
      }
    }
  }
  for (  TreeNode node : P.internalNodes(NodeOrder.PREORDER)) {
    if (node.isTheRoot()) {
      continue;
    }
    int originalId=bipartId.get(bipartForTreeNode.get(node));
    TLongBipartition nodeBipart=bipart.get(originalId);
    for (    Integer sid : summedBipartIds) {
      TLongBipartition summedBipart=bipart.get(sid);
      boolean identicalTaxa=summedBipart.hasIdenticalTaxonSetAs(nodeBipart);
      if (summedBipart.isNestedPartitionOf(nodeBipart)) {
        nestedParents.get(originalId).add(sid);
        if (identicalTaxa) {
          nestedAugmentingParents.get(originalId).add(sid);
        }
      }
      if (nodeBipart.isNestedPartitionOf(summedBipart)) {
        nestedParents.get(sid).add(originalId);
        if (identicalTaxa) {
          nestedAugmentingParents.get(sid).add(originalId);
        }
      }
    }
  }
  System.out.println(""String_Node_Str"" + i);
}","/** 
 * A parallel method to find nestedChildOf rels across input trees, so that many can be processed concurrently. The idea here is that we just process each tree independently, comparing it to all other trees, looking for all nestedChildOf rels where this tree could be a parent. For this, we can use the structure of the trees to stop short of doing a complete allxall comparison of tree nodes, which saves some time. We then perform a (seemingly unavoidable) allxall comparison of each tree's nodes against all the summed biparts. We store the resulting parent/child information in the form of a map where they keys are the bipart ids of child biparts and the values are sets of bipart ids for their parents.
 * @param i
 * @param trees
 * @return
 */
private void processBipartsForTree(int i,List<Tree> trees){
  for (  TreeNode c : trees.get(i).internalNodes(NodeOrder.POSTORDER)) {
    if (c.isTheRoot()) {
      continue;
    }
    int cid=bipartId.get(bipartForTreeNode.get(c));
    for (TreeNode p=c.getParent(); !p.isTheRoot(); p=p.getParent()) {
      int pid=bipartId.get(bipartForTreeNode.get(p));
      nestedParents.get(cid).add(pid);
      nestedChildren.get(pid).add(cid);
    }
  }
  Tree P=trees.get(i);
  List<TreeNode> pRootChildren=P.getRoot().getChildren();
  pRootChildren.removeIf(isTip());
  for (int j=0; j < trees.size(); j++) {
    if (i == j) {
      continue;
    }
    List<TreeNode> qRootChildren=trees.get(j).getRoot().getChildren();
    qRootChildren.removeIf(isTip());
    boolean treesHaveIdenticalTaxa=bipartForTreeNode.get(pRootChildren.get(0)).hasIdenticalTaxonSetAs(bipartForTreeNode.get(qRootChildren.get(0)));
    LinkedList<TreeNode> pStack=new LinkedList<TreeNode>();
    HashSet<TreeNode> pvisited=new HashSet<TreeNode>();
    for (pStack.addAll(pRootChildren); !pStack.isEmpty(); ) {
      TreeNode p=pStack.pop();
      if (p.isExternal()) {
        continue;
      }
      if (pvisited.contains(p)) {
        continue;
      }
 else {
        pvisited.add(p);
      }
      int pid=bipartId.get(bipartForTreeNode.get(p));
      TLongBipartition bp=bipart.get(pid);
      LinkedList<TreeNode> qStack=new LinkedList<TreeNode>();
      HashSet<TreeNode> qvisited=new HashSet<TreeNode>();
      for (qStack.addAll(qRootChildren); !qStack.isEmpty(); ) {
        TreeNode q=qStack.pop();
        if (q.isExternal()) {
          continue;
        }
        if (qvisited.contains(q)) {
          continue;
        }
 else {
          qvisited.add(q);
        }
        int qid=bipartId.get(bipartForTreeNode.get(q));
        TLongBipartition bq=bipart.get(qid);
        if (bq.isNestedPartitionOf(bp)) {
          nestedParents.get(qid).add(pid);
          nestedChildren.get(pid).add(qid);
          if (!treesHaveIdenticalTaxa) {
            nestedAugmentingParents.get(qid).add(pid);
          }
        }
        if (bq.ingroup().containsAny(bp.ingroup())) {
          for (          TreeNode qc : q.getChildren()) {
            qStack.push(qc);
          }
        }
      }
      for (      TreeNode qn : qRootChildren) {
        boolean pOverlapsWithTreeQ=false;
        if (qn.isExternal()) {
          if (bp.ingroup().contains(this.nodeIdForLabel.get(qn.getLabel()))) {
            pOverlapsWithTreeQ=true;
          }
        }
 else         if (bp.ingroup().containsAny(bipartForTreeNode.get(qn).ingroup())) {
          pOverlapsWithTreeQ=true;
        }
        if (pOverlapsWithTreeQ) {
          for (          TreeNode pc : p.getChildren()) {
            pStack.push(pc);
          }
        }
      }
    }
  }
  for (  TreeNode node : P.internalNodes(NodeOrder.PREORDER)) {
    if (node.isTheRoot()) {
      continue;
    }
    int originalId=bipartId.get(bipartForTreeNode.get(node));
    TLongBipartition nodeBipart=bipart.get(originalId);
    for (    Integer sid : summedBipartIds) {
      TLongBipartition summedBipart=bipart.get(sid);
      boolean identicalTaxa=summedBipart.hasIdenticalTaxonSetAs(nodeBipart);
      if (summedBipart.isNestedPartitionOf(nodeBipart)) {
        nestedParents.get(originalId).add(sid);
        if (identicalTaxa) {
          nestedAugmentingParents.get(originalId).add(sid);
        }
      }
      if (nodeBipart.isNestedPartitionOf(summedBipart)) {
        nestedParents.get(sid).add(originalId);
        if (identicalTaxa) {
          nestedAugmentingParents.get(sid).add(originalId);
        }
      }
    }
  }
  System.out.println(""String_Node_Str"" + i);
}"
50157,"private Set<Node> mapGraphNodes(TreeNode treeNode,Tree tree,boolean external){
  HashSet<Node> graphNodesForParent=graphNodesForTreeNode.get(treeNode.getParent());
  TLongBipartition nodeBipart;
  TLongBipartition nodeBipartExp=null;
  if (external == false) {
    nodeBipart=bipartForTreeNode.get(treeNode);
  }
 else {
    nodeBipart=getGraphBipartForTreeNode(treeNode,tree);
  }
  System.out.println(treeNode.getNewick(false) + ""String_Node_Str"" + rankForTreeNode.get(treeNode));
  System.out.println(""String_Node_Str"" + nodeBipart);
  System.out.println(""String_Node_Str"" + graphNodesForParent);
  if (USING_TAXONOMY) {
    nodeBipartExp=getExpandedTaxonomyBipart(nodeBipart);
  }
  HashSet<Node> graphNodes=new HashSet<Node>();
  HashSet<Node> taxNodesMatched=new HashSet<Node>();
  for (  Node parent : graphNodesForParent) {
    for (    Relationship r : parent.getRelationships(Direction.INCOMING,RelType.MRCACHILDOF)) {
      Node potentialChild=r.getStartNode();
      TLongBipartition childBipart;
      TLongBipartition childBipartExp=null;
      if (USING_TAXONOMY == false || taxonomyGraphNodesMap.containsKey(potentialChild) == false) {
        childBipart=bipartForGraphNode.get(potentialChild);
      }
 else {
        childBipart=taxonomyGraphNodesMap.get(potentialChild);
        childBipartExp=childBipart;
      }
      if (childBipart == null)       continue;
      if (taxonomyGraphNodesMap.containsKey(potentialChild) == false && taxonomyGraphNodesMap.containsKey(parent)) {
        childBipartExp=getExpandedTaxonomyBipart(childBipart);
      }
      if (USING_TAXONOMY && taxonomyGraphNodesMap.containsKey(parent)) {
        if (taxonomyGraphNodesMap.containsKey(potentialChild)) {
          if (parent.equals(potentialChild) == false && childBipartExp.ingroup().containsAll(nodeBipartExp.ingroup()) && childBipartExp.ingroup().containsAny(nodeBipartExp.outgroup()) == false && taxonomyGraphNodesMap.get(parent).ingroup().containsAll(childBipartExp.ingroup())) {
            graphNodes.add(potentialChild);
            taxNodesMatched.add(potentialChild);
            updateSTREEChildOf(potentialChild,parent,sourceForTreeNode.get(treeNode),rankForTreeNode.get(treeNode));
            boolean going=true;
            Node curchild=potentialChild;
            while (going) {
              going=false;
              for (              Relationship rc : curchild.getRelationships(RelType.TAXCHILDOF,Direction.INCOMING)) {
                Node tch=rc.getStartNode();
                if (taxonomyGraphNodesMap.containsKey(tch) == false)                 continue;
                TLongBipartition tchb=taxonomyGraphNodesMap.get(tch);
                if (parent.equals(tch) == false && tchb.ingroup().containsAll(nodeBipartExp.ingroup()) && tchb.ingroup().containsAny(nodeBipartExp.outgroup()) == false && taxonomyGraphNodesMap.get(parent).ingroup().containsAll(tchb.ingroup())) {
                  graphNodes.add(tch);
                  taxNodesMatched.add(tch);
                  updateSTREEChildOf(tch,curchild,sourceForTreeNode.get(treeNode),rankForTreeNode.get(treeNode));
                  going=true;
                  curchild=tch;
                  break;
                }
              }
            }
          }
        }
 else {
          if (childBipartExp.containsAll(nodeBipartExp) && taxonomyGraphNodesMap.get(parent).ingroup().containsAll(childBipartExp.ingroup()) && taxonomyGraphNodesMap.get(parent).ingroup().containsAny(childBipartExp.outgroup())) {
            graphNodes.add(potentialChild);
            updateSTREEChildOf(potentialChild,parent,sourceForTreeNode.get(treeNode),rankForTreeNode.get(treeNode));
          }
        }
      }
 else       if (USING_TAXONOMY && taxonomyGraphNodesMap.containsKey(potentialChild)) {
        if (childBipartExp.ingroup().containsAll(nodeBipartExp.ingroup()) && childBipartExp.ingroup().containsAny(nodeBipartExp.outgroup()) == false) {
          graphNodes.add(potentialChild);
          taxNodesMatched.add(potentialChild);
          updateSTREEChildOf(potentialChild,parent,sourceForTreeNode.get(treeNode),rankForTreeNode.get(treeNode));
          boolean going=true;
          Node curchild=potentialChild;
          while (going) {
            going=false;
            for (            Relationship rc : curchild.getRelationships(RelType.TAXCHILDOF,Direction.INCOMING)) {
              Node tch=rc.getStartNode();
              if (taxonomyGraphNodesMap.containsKey(tch) == false)               continue;
              TLongBipartition tchb=taxonomyGraphNodesMap.get(tch);
              if (tchb.ingroup().containsAll(nodeBipartExp.ingroup()) && tchb.ingroup().containsAny(nodeBipartExp.outgroup()) == false) {
                graphNodes.add(tch);
                taxNodesMatched.add(tch);
                updateSTREEChildOf(tch,curchild,sourceForTreeNode.get(treeNode),rankForTreeNode.get(treeNode));
                going=true;
                curchild=tch;
                break;
              }
            }
          }
        }
      }
 else {
        TLongBipartition testParent=bipartForGraphNode.get(parent);
        if (USING_TAXONOMY) {
        }
        if (childBipart.containsAll(nodeBipart) && childBipart.isNestedPartitionOf(testParent)) {
          graphNodes.add(potentialChild);
          updateSTREEChildOf(potentialChild,parent,sourceForTreeNode.get(treeNode),rankForTreeNode.get(treeNode));
        }
      }
    }
  }
  for (  Node gn : taxNodesMatched) {
    for (    Relationship trel : gn.getRelationships(Direction.INCOMING,RelType.MRCACHILDOF)) {
      if (graphNodes.contains(trel.getStartNode())) {
        updateSTREEChildOf(trel.getStartNode(),gn,sourceForTreeNode.get(treeNode),rankForTreeNode.get(treeNode));
      }
    }
  }
  return graphNodes;
}","private Set<Node> mapGraphNodes(TreeNode treeNode,Tree tree,boolean external){
  HashSet<Node> graphNodesForParent=graphNodesForTreeNode.get(treeNode.getParent());
  TLongBipartition nodeBipart;
  TLongBipartition nodeBipartExp=null;
  if (external == false) {
    nodeBipart=bipartForTreeNode.get(treeNode);
    int bpid=bipartId.get(nodeBipart);
    if (USING_TAXONOMY)     nodeBipartExp=bipartForTreeNodeExploded.get(treeNode);
  }
 else {
    nodeBipart=getGraphBipartForTreeNode(treeNode,tree);
    if (USING_TAXONOMY)     nodeBipartExp=getExpandedTaxonomyBipart(nodeBipart);
  }
  HashSet<Node> graphNodes=new HashSet<Node>();
  HashSet<Node> taxNodesMatched=new HashSet<Node>();
  for (  Node parent : graphNodesForParent) {
    for (    Relationship r : parent.getRelationships(Direction.INCOMING,RelType.MRCACHILDOF)) {
      Node potentialChild=r.getStartNode();
      TLongBipartition childBipart;
      TLongBipartition childBipartExp=null;
      if (USING_TAXONOMY == false || taxonomyGraphNodesMap.containsKey(potentialChild) == false) {
        childBipart=bipartForGraphNode.get(potentialChild);
      }
 else {
        childBipart=taxonomyGraphNodesMap.get(potentialChild);
        childBipartExp=childBipart;
      }
      if (childBipart == null)       continue;
      if (taxonomyGraphNodesMap.containsKey(potentialChild) == false && taxonomyGraphNodesMap.containsKey(parent)) {
        childBipartExp=bipartForGraphNodeExploded.get(potentialChild);
      }
      if (USING_TAXONOMY && taxonomyGraphNodesMap.containsKey(parent)) {
        if (taxonomyGraphNodesMap.containsKey(potentialChild)) {
          if (parent.equals(potentialChild) == false && childBipartExp.ingroup().containsAll(nodeBipartExp.ingroup()) && childBipartExp.ingroup().containsAny(nodeBipartExp.outgroup()) == false && taxonomyGraphNodesMap.get(parent).ingroup().containsAll(childBipartExp.ingroup())) {
            graphNodes.add(potentialChild);
            taxNodesMatched.add(potentialChild);
            updateSTREEChildOf(potentialChild,parent,sourceForTreeNode.get(treeNode),rankForTreeNode.get(treeNode));
            boolean going=true;
            Node curchild=potentialChild;
            while (going) {
              going=false;
              for (              Relationship rc : curchild.getRelationships(RelType.TAXCHILDOF,Direction.INCOMING)) {
                Node tch=rc.getStartNode();
                if (taxonomyGraphNodesMap.containsKey(tch) == false)                 continue;
                TLongBipartition tchb=taxonomyGraphNodesMap.get(tch);
                if (parent.equals(tch) == false && tchb.ingroup().containsAll(nodeBipartExp.ingroup()) && tchb.ingroup().containsAny(nodeBipartExp.outgroup()) == false && taxonomyGraphNodesMap.get(parent).ingroup().containsAll(tchb.ingroup())) {
                  graphNodes.add(tch);
                  taxNodesMatched.add(tch);
                  updateSTREEChildOf(tch,curchild,sourceForTreeNode.get(treeNode),rankForTreeNode.get(treeNode));
                  going=true;
                  curchild=tch;
                  break;
                }
              }
            }
          }
        }
 else {
          if (childBipartExp.containsAll(nodeBipartExp) && taxonomyGraphNodesMap.get(parent).ingroup().containsAll(childBipartExp.ingroup()) && taxonomyGraphNodesMap.get(parent).ingroup().containsAny(childBipartExp.outgroup())) {
            graphNodes.add(potentialChild);
            updateSTREEChildOf(potentialChild,parent,sourceForTreeNode.get(treeNode),rankForTreeNode.get(treeNode));
          }
        }
      }
 else       if (USING_TAXONOMY && taxonomyGraphNodesMap.containsKey(potentialChild)) {
        if (childBipartExp.ingroup().containsAll(nodeBipartExp.ingroup()) && childBipartExp.ingroup().containsAny(nodeBipartExp.outgroup()) == false) {
          graphNodes.add(potentialChild);
          taxNodesMatched.add(potentialChild);
          updateSTREEChildOf(potentialChild,parent,sourceForTreeNode.get(treeNode),rankForTreeNode.get(treeNode));
          boolean going=true;
          Node curchild=potentialChild;
          while (going) {
            going=false;
            for (            Relationship rc : curchild.getRelationships(RelType.TAXCHILDOF,Direction.INCOMING)) {
              Node tch=rc.getStartNode();
              if (taxonomyGraphNodesMap.containsKey(tch) == false)               continue;
              TLongBipartition tchb=taxonomyGraphNodesMap.get(tch);
              if (tchb.ingroup().containsAll(nodeBipartExp.ingroup()) && tchb.ingroup().containsAny(nodeBipartExp.outgroup()) == false) {
                graphNodes.add(tch);
                taxNodesMatched.add(tch);
                updateSTREEChildOf(tch,curchild,sourceForTreeNode.get(treeNode),rankForTreeNode.get(treeNode));
                going=true;
                curchild=tch;
                break;
              }
            }
          }
        }
      }
 else {
        TLongBipartition testParent=bipartForGraphNode.get(parent);
        if (childBipart.containsAll(nodeBipart) && childBipart.isNestedPartitionOf(testParent)) {
          graphNodes.add(potentialChild);
          updateSTREEChildOf(potentialChild,parent,sourceForTreeNode.get(treeNode),rankForTreeNode.get(treeNode));
        }
      }
    }
  }
  for (  Node gn : taxNodesMatched) {
    for (    Relationship trel : gn.getRelationships(Direction.INCOMING,RelType.MRCACHILDOF)) {
      if (graphNodes.contains(trel.getStartNode())) {
        updateSTREEChildOf(trel.getStartNode(),gn,sourceForTreeNode.get(treeNode),rankForTreeNode.get(treeNode));
      }
    }
  }
  return graphNodes;
}"
50158,"public static void main(String[] args) throws Exception {
  String dbname=""String_Node_Str"";
  runSimpleTest(nestedOverlap(),dbname);
}","public static void main(String[] args) throws Exception {
  String dbname=""String_Node_Str"";
  runSimpleTest(cycleConflictTrees(),dbname);
}"
50159,"private void createLicaNodesFromBiparts(List<Tree> trees){
  nestedParents=newIntegerListArray(bipart.length);
  nestedChildren=newIntegerListArray(bipart.length);
  nestedAugmentingParents=newIntegerListArray(bipart.length);
  System.out.println(""String_Node_Str"");
  long z=new Date().getTime();
  for (int i=0; i < trees.size(); i++) {
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ trees.get(i).internalNodeCount()+ ""String_Node_Str"");
    for (    TreeNode c : trees.get(i).internalNodes(NodeOrder.POSTORDER)) {
      if (c.isTheRoot()) {
        continue;
      }
      int cid=treeNodeIds.get(c);
      for (TreeNode p=c.getParent(); !p.isTheRoot(); p=p.getParent()) {
        int pid=treeNodeIds.get(p);
        nestedParents[pid].add(cid);
        nestedChildren[cid].add(pid);
      }
    }
    Tree P=trees.get(i);
    List<TreeNode> pRootChildren=P.getRoot().getChildren();
    for (int j=0; j < trees.size(); j++) {
      if (i == j) {
        continue;
      }
      List<TreeNode> qRootChildren=trees.get(j).getRoot().getChildren();
      boolean treesHaveIdenticalTaxa=original[treeNodeIds.get(pRootChildren.get(0))].hasIdenticalTaxonSetAs(original[treeNodeIds.get(qRootChildren.get(0))]);
      LinkedList<TreeNode> pStack=new LinkedList<TreeNode>();
      for (pStack.addAll(pRootChildren); !pStack.isEmpty(); ) {
        TreeNode p=pStack.pop();
        if (p.isExternal()) {
          continue;
        }
        int pid=treeNodeIds.get(p);
        TLongBipartition bp=original[pid];
        LinkedList<TreeNode> qStack=new LinkedList<TreeNode>();
        for (qStack.addAll(qRootChildren); !qStack.isEmpty(); ) {
          TreeNode q=qStack.pop();
          if (q.isExternal()) {
            continue;
          }
          int qid=treeNodeIds.get(q);
          TLongBipartition bq=original[qid];
          if (bq.isNestedPartitionOf(bp)) {
            nestedParents[pid].add(qid);
            nestedChildren[qid].add(pid);
            if (!treesHaveIdenticalTaxa) {
              nestedAugmentingParents[pid].add(qid);
            }
          }
          if (bq.ingroup().containsAny(bp.ingroup())) {
            for (            TreeNode qc : q.getChildren()) {
              qStack.push(qc);
            }
          }
        }
      }
    }
    for (    TreeNode node : P.internalNodes(NodeOrder.PREORDER)) {
      if (node.isTheRoot()) {
        continue;
      }
      final int child=treeNodeIds.get(node);
      List<Integer> moreParents=summedBipartIds.parallelStream().map(parent -> {
        return bipart[child].isNestedPartitionOf(bipart[parent]) ? parent : null;
      }
).collect(toList()).stream().filter(a -> a != null).collect(toList());
      for (      Integer parent : moreParents) {
        nestedParents[child].add(parent);
        nestedChildren[parent].add(child);
      }
    }
  }
  System.out.println(""String_Node_Str"" + (new Date().getTime() - z) / (float)1000 + ""String_Node_Str"");
  paths=new HashSet<Path>();
  System.out.print(""String_Node_Str"");
  z=new Date().getTime();
  Transaction tx=gdb.beginTx();
  for (int i=0; i < bipart.length; i++) {
    if (bipart[i].outgroup().size() > 0) {
      CompactLongSet pathResult=findPaths(i,new CompactLongSet(),new ArrayList<Integer>(),0,i);
      if (pathResult == null) {
        createNode(bipart[i]);
      }
    }
  }
  tx.success();
  tx.finish();
  System.out.println(""String_Node_Str"" + (new Date().getTime() - z) / (float)1000 + ""String_Node_Str"" + paths.size());
  if (VERBOSE) {
    for (    Path p : paths) {
      System.out.println(p);
    }
  }
  System.out.print(""String_Node_Str"");
  z=new Date().getTime();
  tx=gdb.beginTx();
  for (  Path p : paths) {
    generateNodesFromPaths(0,new CompactLongSet(),p.toArray());
  }
  tx.success();
  tx.finish();
  System.out.println(""String_Node_Str"" + (new Date().getTime() - z) / (float)1000 + ""String_Node_Str"");
}","private void createLicaNodesFromBiparts(List<Tree> trees){
  nestedParents=newIntegerListArray(bipart.length);
  nestedChildren=newIntegerListArray(bipart.length);
  nestedAugmentingParents=newIntegerListArray(bipart.length);
  System.out.println(""String_Node_Str"");
  long z=new Date().getTime();
  for (int i=0; i < trees.size(); i++) {
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ trees.get(i).internalNodeCount()+ ""String_Node_Str"");
    for (    TreeNode c : trees.get(i).internalNodes(NodeOrder.POSTORDER)) {
      if (c.isTheRoot()) {
        continue;
      }
      int cid=treeNodeIds.get(c);
      for (TreeNode p=c.getParent(); !p.isTheRoot(); p=p.getParent()) {
        int pid=treeNodeIds.get(p);
        nestedParents[pid].add(cid);
        nestedChildren[cid].add(pid);
      }
    }
    Tree P=trees.get(i);
    List<TreeNode> pRootChildren=P.getRoot().getChildren();
    for (int j=0; j < trees.size(); j++) {
      if (i == j) {
        continue;
      }
      List<TreeNode> qRootChildren=trees.get(j).getRoot().getChildren();
      boolean treesHaveIdenticalTaxa=original[treeNodeIds.get(pRootChildren.get(0))].hasIdenticalTaxonSetAs(original[treeNodeIds.get(qRootChildren.get(0))]);
      LinkedList<TreeNode> pStack=new LinkedList<TreeNode>();
      for (pStack.addAll(pRootChildren); !pStack.isEmpty(); ) {
        TreeNode p=pStack.pop();
        if (p.isExternal()) {
          continue;
        }
        int pid=treeNodeIds.get(p);
        TLongBipartition bp=original[pid];
        LinkedList<TreeNode> qStack=new LinkedList<TreeNode>();
        for (qStack.addAll(qRootChildren); !qStack.isEmpty(); ) {
          TreeNode q=qStack.pop();
          if (q.isExternal()) {
            continue;
          }
          int qid=treeNodeIds.get(q);
          TLongBipartition bq=original[qid];
          if (bq.isNestedPartitionOf(bp)) {
            nestedParents[qid].add(pid);
            nestedChildren[pid].add(qid);
            if (!treesHaveIdenticalTaxa) {
              nestedAugmentingParents[qid].add(pid);
            }
          }
          if (bq.ingroup().containsAny(bp.ingroup())) {
            for (            TreeNode qc : q.getChildren()) {
              qStack.push(qc);
            }
          }
        }
      }
    }
    for (    TreeNode node : P.internalNodes(NodeOrder.PREORDER)) {
      if (node.isTheRoot()) {
        continue;
      }
      final int child=treeNodeIds.get(node);
      List<Integer> moreParents=summedBipartIds.parallelStream().map(parent -> {
        return bipart[child].isNestedPartitionOf(bipart[parent]) ? parent : null;
      }
).collect(toList()).stream().filter(a -> a != null).collect(toList());
      for (      Integer parent : moreParents) {
        nestedParents[child].add(parent);
        nestedChildren[parent].add(child);
      }
    }
  }
  System.out.println(""String_Node_Str"" + (new Date().getTime() - z) / (float)1000 + ""String_Node_Str"");
  paths=new HashSet<Path>();
  System.out.print(""String_Node_Str"");
  z=new Date().getTime();
  Transaction tx=gdb.beginTx();
  for (int i=0; i < bipart.length; i++) {
    if (bipart[i].outgroup().size() > 0) {
      CompactLongSet pathResult=findPaths(i,new CompactLongSet(),new ArrayList<Integer>(),0,i);
      if (pathResult == null) {
        createNode(bipart[i]);
      }
    }
  }
  tx.success();
  tx.finish();
  System.out.println(""String_Node_Str"" + (new Date().getTime() - z) / (float)1000 + ""String_Node_Str"" + paths.size());
  if (VERBOSE) {
    for (    Path p : paths) {
      System.out.println(p);
    }
  }
  System.out.print(""String_Node_Str"");
  z=new Date().getTime();
  tx=gdb.beginTx();
  for (  Path p : paths) {
    generateNodesFromPaths(0,new CompactLongSet(),p.toArray());
  }
  tx.success();
  tx.finish();
  System.out.println(""String_Node_Str"" + (new Date().getTime() - z) / (float)1000 + ""String_Node_Str"");
}"
50160,"/** 
 * This creates all the MRCACHILDOF rels among all graph nodes. It uses an all by all pairwise comparison, which has quadratic order of growth. We do this because it makes tree loading trivial: after mapping a tree node x just to graph node(s) g(x), just look at all the graph nodes connected to g(x) by MRCACHILDOF rels to find all the graph nodes that may possibly be mapped to x's parent/child tree nodes.
 */
private void generateMRCAChildOfs(){
  System.out.print(""String_Node_Str"" + nodeForBipart.size() + ""String_Node_Str"");
  long z=new Date().getTime();
  System.out.print(""String_Node_Str"" + nestedChildren.size() + ""String_Node_Str"");
  Transaction tx=gdb.beginTx();
  for (int parentId=0; parentId < bipart.size(); parentId++) {
    for (    Integer childId : nestedChildren.get(parentId)) {
      Node parent=nodeForBipart.get(bipart.get(parentId));
      Node child=nodeForBipart.get(bipart.get(childId));
      updateMRCAChildOf(child,parent);
    }
  }
  tx.success();
  tx.finish();
  if (USING_TAXONOMY) {
    System.out.print(""String_Node_Str"");
    tx=gdb.beginTx();
    for (    Node taxnd : taxonomyGraphNodesMap.keySet()) {
      TLongBipartition taxbp=taxonomyGraphNodesMap.get(taxnd);
      for (      TLongBipartition ndbp : nodeForBipart.keySet()) {
        if (taxbp.ingroup().containsAll(ndbp.ingroup())) {
          if (taxbp.ingroup().containsAny(ndbp.outgroup()))           updateMRCAChildOf(nodeForBipart.get(ndbp),taxnd);
        }
 else         if (ndbp.ingroup().containsAny(taxbp.ingroup()) && taxbp.ingroup().containsAny(ndbp.outgroup()) == false && taxbp.ingroup().containsAll(ndbp.ingroup()) == false) {
          updateMRCAChildOf(taxnd,nodeForBipart.get(ndbp));
        }
      }
    }
    tx.success();
    tx.finish();
  }
  System.out.println(""String_Node_Str"" + (new Date().getTime() - z) / (float)1000 + ""String_Node_Str"");
}","/** 
 * This creates all the MRCACHILDOF rels among all graph nodes. It uses an all by all pairwise comparison, which has quadratic order of growth. We do this because it makes tree loading trivial: after mapping a tree node x just to graph node(s) g(x), just look at all the graph nodes connected to g(x) by MRCACHILDOF rels to find all the graph nodes that may possibly be mapped to x's parent/child tree nodes.
 */
private void generateMRCAChildOfs(){
  System.out.print(""String_Node_Str"");
  long z=new Date().getTime();
  System.out.print(""String_Node_Str"" + nestedChildren.size() + ""String_Node_Str"");
  Transaction tx=gdb.beginTx();
  for (int parentId=0; parentId < bipart.size(); parentId++) {
    for (    Integer childId : nestedChildren.get(parentId)) {
      Node parent=nodeForBipart.get(bipart.get(parentId));
      Node child=nodeForBipart.get(bipart.get(childId));
      updateMRCAChildOf(child,parent);
    }
  }
  tx.success();
  tx.finish();
  if (USING_TAXONOMY) {
    System.out.print(""String_Node_Str"");
    tx=gdb.beginTx();
    for (    Node taxnd : taxonomyGraphNodesMap.keySet()) {
      TLongBipartition taxbp=taxonomyGraphNodesMap.get(taxnd);
      for (      TLongBipartition ndbp : nodeForBipart.keySet()) {
        if (taxbp.ingroup().containsAll(ndbp.ingroup())) {
          if (taxbp.ingroup().containsAny(ndbp.outgroup()))           updateMRCAChildOf(nodeForBipart.get(ndbp),taxnd);
        }
 else         if (ndbp.ingroup().containsAny(taxbp.ingroup()) && taxbp.ingroup().containsAny(ndbp.outgroup()) == false && taxbp.ingroup().containsAll(ndbp.ingroup()) == false) {
          updateMRCAChildOf(taxnd,nodeForBipart.get(ndbp));
        }
      }
    }
    tx.success();
    tx.finish();
  }
  System.out.println(""String_Node_Str"" + (new Date().getTime() - z) / (float)1000 + ""String_Node_Str"");
}"
50161,"public static void main(String[] args) throws Exception {
  String dbname=""String_Node_Str"";
  runSimpleTest(trivialConflict(),dbname);
}","public static void main(String[] args) throws Exception {
  String dbname=""String_Node_Str"";
  runSimpleTest(conflictingAugmenting(),dbname);
}"
50162,"/** 
 * Get pairwise sums of all tree biparts and put all biparts into a single array for future use.
 */
private void gatherBipartitions(){
  TLongBipartition[] summed=new BipartSetSum(bipartsByTree).toArray();
  for (int i=0; i < original.length; i++) {
    bipart.add(i,original[i]);
  }
  for (int i=0; i < summed.length; i++) {
    int k=i + original.length;
    bipart.add(k,summed[i]);
    summedBipartIds.add(k);
  }
  System.out.println(""String_Node_Str"" + original.length + ""String_Node_Str""+ summedBipartIds.size()+ ""String_Node_Str""+ bipart.size());
}","/** 
 * Get pairwise sums of all tree biparts and put all biparts into a single array for future use.
 */
private void gatherBipartitions(){
  TLongBipartition[] summed=new BipartSetSum(bipartsByTree).toArray();
  for (int i=0; i < original.length; i++) {
    bipart.add(original[i]);
    bipartId.put(original[i],i);
  }
  for (int i=0; i < summed.length; i++) {
    int k=i + original.length;
    bipart.add(summed[i]);
    bipartId.put(summed[i],k);
    summedBipartIds.add(k);
  }
  System.out.println(""String_Node_Str"" + original.length + ""String_Node_Str""+ summedBipartIds.size()+ ""String_Node_Str""+ bipart.size());
}"
50163,"/** 
 * Map all the tree root nodes into the graph. This will create new nodes in the graph for any root nodes that cannot be mapped to preexisting nodes. This *must* be done before loading trees--tree loading uses a preorder traversal.
 * @param trees
 */
private void mapTreeRootNodes(List<Tree> trees){
  for (  Tree tree : trees) {
    Transaction tx=gdb.beginTx();
    TreeNode root=tree.getRoot();
    TLongBipartition rootBipart=getGraphBipartForTreeNode(root,tree);
    HashSet<Node> graphNodes=new HashSet<Node>();
    for (    TLongBipartition b : nodeForBipart.keySet()) {
      if (b.containsAll(rootBipart)) {
        graphNodes.add(nodeForBipart.get(b));
      }
    }
    if (USING_TAXONOMY) {
      for (      Node b : taxonomyGraphNodesMap.keySet()) {
        if (taxonomyGraphNodesMap.get(b).containsAll(rootBipart)) {
          graphNodes.add(b);
        }
      }
      if (VERBOSE) {
        System.out.println(root.getNewick(false) + ""String_Node_Str"" + graphNodes);
      }
    }
    if (graphNodes.size() < 1) {
      if (VERBOSE) {
        System.out.println(""String_Node_Str"" + rootBipart);
      }
      graphNodes.add(createNode(rootBipart));
    }
    tx.success();
    tx.finish();
    graphNodesForTreeNode.put(root,graphNodes);
  }
}","/** 
 * Map all the tree root nodes into the graph. This will create new nodes in the graph for any root nodes that cannot be mapped to preexisting nodes. This *must* be done before loading trees--tree loading uses a preorder traversal.
 * @param trees
 */
private void mapTreeRootNodes(List<Tree> trees){
  for (  Tree tree : trees) {
    Transaction tx=gdb.beginTx();
    TreeNode root=tree.getRoot();
    TLongBipartition rootBipart=getGraphBipartForTreeNode(root,tree);
    HashSet<Node> graphNodes=new HashSet<Node>();
    for (    TLongBipartition b : nodeForBipart.keySet()) {
      if (b.containsAll(rootBipart)) {
        graphNodes.add(nodeForBipart.get(b));
      }
    }
    if (USING_TAXONOMY) {
      for (      Node b : taxonomyGraphNodesMap.keySet()) {
        if (taxonomyGraphNodesMap.get(b).containsAll(rootBipart)) {
          graphNodes.add(b);
        }
      }
      if (VERBOSE) {
        System.out.println(root.getNewick(false) + ""String_Node_Str"" + graphNodes);
      }
    }
    if (graphNodes.size() < 1) {
      if (VERBOSE) {
        System.out.println(""String_Node_Str"" + rootBipart);
      }
      Node rootNode=createNode(rootBipart);
      graphNodes.add(rootNode);
      for (      TLongBipartition b : nodeForBipart.keySet()) {
        if (rootBipart.isNestedPartitionOf(b)) {
          rootNode.createRelationshipTo(nodeForBipart.get(b),RelType.MRCACHILDOF);
        }
        if (b.isNestedPartitionOf(rootBipart)) {
          nodeForBipart.get(b).createRelationshipTo(rootNode,RelType.MRCACHILDOF);
        }
      }
    }
    tx.success();
    tx.finish();
    graphNodesForTreeNode.put(root,graphNodes);
  }
}"
50164,"private void createLicaNodesFromBiparts(List<Tree> trees){
  nestedParents=newIntegerSetList(bipart.size());
  nestedChildren=newIntegerSetList(bipart.size());
  nestedAugmentingParents=newIntegerSetList(bipart.size());
  analogousBiparts=newIntegerSetList(bipart.size());
  System.out.println(""String_Node_Str"");
  long z=new Date().getTime();
  for (int i=0; i < trees.size(); i++) {
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ trees.get(i).internalNodeCount()+ ""String_Node_Str"");
    for (    TreeNode c : trees.get(i).internalNodes(NodeOrder.POSTORDER)) {
      if (c.isTheRoot()) {
        continue;
      }
      int cid=treeNodeIds.get(c);
      for (TreeNode p=c.getParent(); !p.isTheRoot(); p=p.getParent()) {
        int pid=treeNodeIds.get(p);
        nestedParents.get(cid).add(pid);
        nestedChildren.get(pid).add(cid);
      }
    }
    Tree P=trees.get(i);
    List<TreeNode> pRootChildren=P.getRoot().getChildren();
    for (int j=0; j < trees.size(); j++) {
      if (i == j) {
        continue;
      }
      List<TreeNode> qRootChildren=trees.get(j).getRoot().getChildren();
      boolean treesHaveIdenticalTaxa=original[treeNodeIds.get(pRootChildren.get(0))].hasIdenticalTaxonSetAs(original[treeNodeIds.get(qRootChildren.get(0))]);
      LinkedList<TreeNode> pStack=new LinkedList<TreeNode>();
      for (pStack.addAll(pRootChildren); !pStack.isEmpty(); ) {
        TreeNode p=pStack.pop();
        if (p.isExternal()) {
          continue;
        }
        int pid=treeNodeIds.get(p);
        TLongBipartition bp=original[pid];
        LinkedList<TreeNode> qStack=new LinkedList<TreeNode>();
        for (qStack.addAll(qRootChildren); !qStack.isEmpty(); ) {
          TreeNode q=qStack.pop();
          if (q.isExternal()) {
            continue;
          }
          int qid=treeNodeIds.get(q);
          TLongBipartition bq=original[qid];
          if (bq.isNestedPartitionOf(bp)) {
            nestedParents.get(qid).add(pid);
            nestedChildren.get(pid).add(qid);
            if (!treesHaveIdenticalTaxa) {
              nestedAugmentingParents.get(qid).add(pid);
            }
          }
          if (bq.ingroup().containsAny(bp.ingroup())) {
            for (            TreeNode qc : q.getChildren()) {
              qStack.push(qc);
            }
          }
        }
      }
    }
    for (    TreeNode node : P.internalNodes(NodeOrder.PREORDER)) {
      if (node.isTheRoot()) {
        continue;
      }
      final int child=treeNodeIds.get(node);
      List<Integer> moreParents=summedBipartIds.parallelStream().map(parent -> {
        return bipart.get(child).isNestedPartitionOf(bipart.get(parent)) ? parent : null;
      }
).collect(toList()).stream().filter(a -> a != null).collect(toList());
      for (      Integer parent : moreParents) {
        nestedParents.get(child).add(parent);
        nestedChildren.get(parent).add(child);
      }
    }
  }
  System.out.println(""String_Node_Str"" + (new Date().getTime() - z) / (float)1000 + ""String_Node_Str"");
  paths=new HashSet<Path>();
  System.out.print(""String_Node_Str"");
  z=new Date().getTime();
  Transaction tx=gdb.beginTx();
  for (int i=0; i < bipart.size(); i++) {
    if (bipart.get(i).outgroup().size() > 0) {
      CompactLongSet pathResult=findPaths(i,new CompactLongSet(),new ArrayList<Integer>(),0,i);
      if (pathResult == null) {
        createNode(bipart.get(i));
      }
    }
  }
  tx.success();
  tx.finish();
  System.out.println(""String_Node_Str"" + (new Date().getTime() - z) / (float)1000 + ""String_Node_Str"" + paths.size());
  if (VERBOSE) {
    for (    Path p : paths) {
      System.out.println(p);
    }
  }
  System.out.print(""String_Node_Str"");
  z=new Date().getTime();
  tx=gdb.beginTx();
  for (  Path p : paths) {
    generateNodesFromPaths(0,new CompactLongSet(),p.toArray());
  }
  tx.success();
  tx.finish();
  System.out.println(""String_Node_Str"" + (new Date().getTime() - z) / (float)1000 + ""String_Node_Str"");
}","private void createLicaNodesFromBiparts(List<Tree> trees){
  nestedParents=newIntegerSetList(bipart.size());
  nestedChildren=newIntegerSetList(bipart.size());
  nestedAugmentingParents=newIntegerSetList(bipart.size());
  analogousBiparts=newIntegerSetList(bipart.size());
  System.out.println(""String_Node_Str"");
  long z=new Date().getTime();
  for (int i=0; i < trees.size(); i++) {
    System.out.println(""String_Node_Str"" + i + ""String_Node_Str""+ trees.get(i).internalNodeCount()+ ""String_Node_Str"");
    for (    TreeNode c : trees.get(i).internalNodes(NodeOrder.POSTORDER)) {
      if (c.isTheRoot()) {
        continue;
      }
      int cid=treeNodeIds.get(c);
      for (TreeNode p=c.getParent(); !p.isTheRoot(); p=p.getParent()) {
        int pid=treeNodeIds.get(p);
        nestedParents.get(cid).add(pid);
        nestedChildren.get(pid).add(cid);
      }
    }
    Tree P=trees.get(i);
    List<TreeNode> pRootChildren=P.getRoot().getChildren();
    for (int j=0; j < trees.size(); j++) {
      if (i == j) {
        continue;
      }
      List<TreeNode> qRootChildren=trees.get(j).getRoot().getChildren();
      boolean treesHaveIdenticalTaxa=original[treeNodeIds.get(pRootChildren.get(0))].hasIdenticalTaxonSetAs(original[treeNodeIds.get(qRootChildren.get(0))]);
      LinkedList<TreeNode> pStack=new LinkedList<TreeNode>();
      for (pStack.addAll(pRootChildren); !pStack.isEmpty(); ) {
        TreeNode p=pStack.pop();
        if (p.isExternal()) {
          continue;
        }
        int pid=treeNodeIds.get(p);
        TLongBipartition bp=original[pid];
        LinkedList<TreeNode> qStack=new LinkedList<TreeNode>();
        for (qStack.addAll(qRootChildren); !qStack.isEmpty(); ) {
          TreeNode q=qStack.pop();
          if (q.isExternal()) {
            continue;
          }
          int qid=treeNodeIds.get(q);
          TLongBipartition bq=original[qid];
          if (bq.isNestedPartitionOf(bp)) {
            nestedParents.get(qid).add(pid);
            nestedChildren.get(pid).add(qid);
            if (!treesHaveIdenticalTaxa) {
              nestedAugmentingParents.get(qid).add(pid);
            }
          }
          if (bq.ingroup().containsAny(bp.ingroup())) {
            for (            TreeNode qc : q.getChildren()) {
              qStack.push(qc);
            }
          }
        }
        for (        TreeNode qn : qRootChildren) {
          if (bp.ingroup().containsAny(original[treeNodeIds.get(qn)].ingroup())) {
            for (            TreeNode pc : p.getChildren()) {
              pStack.push(pc);
            }
            break;
          }
        }
      }
    }
    for (    TreeNode node : P.internalNodes(NodeOrder.PREORDER)) {
      if (node.isTheRoot()) {
        continue;
      }
      final int child=treeNodeIds.get(node);
      List<Integer> moreParents=summedBipartIds.parallelStream().map(parent -> {
        return bipart.get(child).isNestedPartitionOf(bipart.get(parent)) ? parent : null;
      }
).collect(toList()).stream().filter(a -> a != null).collect(toList());
      for (      Integer parent : moreParents) {
        nestedParents.get(child).add(parent);
        nestedChildren.get(parent).add(child);
      }
    }
  }
  System.out.println(""String_Node_Str"" + (new Date().getTime() - z) / (float)1000 + ""String_Node_Str"");
  paths=new HashSet<Path>();
  System.out.print(""String_Node_Str"");
  z=new Date().getTime();
  Transaction tx=gdb.beginTx();
  for (int i=0; i < bipart.size(); i++) {
    if (bipart.get(i).outgroup().size() > 0) {
      CompactLongSet pathResult=findPaths(i,new CompactLongSet(),new ArrayList<Integer>(),0,i);
      if (pathResult == null) {
        createNode(bipart.get(i));
      }
    }
  }
  tx.success();
  tx.finish();
  System.out.println(""String_Node_Str"" + (new Date().getTime() - z) / (float)1000 + ""String_Node_Str"" + paths.size());
  if (VERBOSE) {
    for (    Path p : paths) {
      System.out.println(p);
    }
  }
  System.out.print(""String_Node_Str"");
  z=new Date().getTime();
  tx=gdb.beginTx();
  for (  Path p : paths) {
    generateNodesFromPaths(0,new CompactLongSet(),p.toArray());
  }
  tx.success();
  tx.finish();
  System.out.println(""String_Node_Str"" + (new Date().getTime() - z) / (float)1000 + ""String_Node_Str"");
}"
50165,"@Override public Evaluation evaluate(Path inPath){
  Node curNode=inPath.endNode();
  if (visited.contains(curNode.getId())) {
    return Evaluation.EXCLUDE_AND_PRUNE;
  }
  visited.add(curNode.getId());
  TLongBitArray curNodeMRCAIds=new TLongBitArray((long[])curNode.getProperty(""String_Node_Str""));
  TLongBitArray curNodeOutMRCAIds=null;
  boolean isTaxNode=false;
  if (curNode.hasProperty(""String_Node_Str"") == false) {
    isTaxNode=true;
  }
 else {
    curNodeOutMRCAIds=new TLongBitArray((long[])curNode.getProperty(""String_Node_Str""));
  }
  if (isTaxNode == false) {
    if (curNodeMRCAIds.containsAny(outgroupNodeIds) == false) {
      if (curNodeOutMRCAIds.containsAny(ingroupNodeIds) == false) {
        if (curNodeMRCAIds.containsAny(ingroupNodeIds) == true) {
          boolean passed=false;
          TLongHashSet visitedrels=new TLongHashSet();
          for (          Relationship rel : curNode.getRelationships(Direction.INCOMING,RelType.STREECHILDOF)) {
            if (visitedrels.contains(rel.getId()) || rel.hasProperty(""String_Node_Str"")) {
              continue;
            }
            TLongArrayList inids=new TLongArrayList((long[])rel.getProperty(""String_Node_Str""));
            visited.addAll(inids);
            TLongHashSet relmatched=new TLongHashSet();
            HashSet<Integer> childmatched=new HashSet<Integer>();
            for (int j=0; j < inids.size(); j++) {
              TLongBitArray trelj=new TLongBitArray((long[])graphdb.getRelationshipById(inids.get(j)).getProperty(""String_Node_Str""));
              for (int i=0; i < jadenode.getChildCount(); i++) {
                TLongBitArray chndi=new TLongBitArray((long[])jadenode.getChild(i).getObject(""String_Node_Str""));
                if (chndi.containsAny(trelj) == true) {
                  relmatched.add(inids.get(j));
                  childmatched.add(i);
                  break;
                }
              }
            }
            if (relmatched.size() >= 2 && childmatched.size() == jadenode.getChildCount()) {
              passed=true;
              break;
            }
          }
          if (passed == false) {
            return Evaluation.EXCLUDE_AND_CONTINUE;
          }
          TLongBitArray mrcaSearchIdsNotSetForThisNode=ingroupNodeIds.andNot(curNodeMRCAIds);
          if (mrcaSearchIdsNotSetForThisNode.size() > 0) {
            curNodeMRCAIds.addAll(mrcaSearchIdsNotSetForThisNode);
            curNodeMRCAIds.sort();
            if (updateDB) {
              curNode.setProperty(""String_Node_Str"",curNodeMRCAIds.toArray());
            }
          }
          TLongBitArray outmrcaSearchIdsNotSetForThisNode=outgroupNodeIds.andNot(curNodeOutMRCAIds);
          if (outmrcaSearchIdsNotSetForThisNode.size() > 0) {
            curNodeOutMRCAIds.addAll(outmrcaSearchIdsNotSetForThisNode);
            curNodeOutMRCAIds.sort();
            if (updateDB) {
              curNode.setProperty(""String_Node_Str"",curNodeOutMRCAIds.toArray());
            }
          }
          if (updateDB) {
            for (            Relationship parentRel : curNode.getRelationships(RelType.STREECHILDOF,Direction.OUTGOING)) {
              for (              Node ancestor : Traversal.description().breadthFirst().evaluator(new LongArrayPropertyContainsAllEvaluator(""String_Node_Str"",curNodeMRCAIds)).relationships(RelType.STREECHILDOF,Direction.OUTGOING).traverse(parentRel.getEndNode()).nodes()) {
                System.out.println(""String_Node_Str"" + ancestor + ""String_Node_Str"");
                TLongBitArray outmrcaAncestor=new TLongBitArray((long[])ancestor.getProperty(""String_Node_Str""));
                if (outmrcaAncestor.containsAny(ingroupNodeIds)) {
                  System.out.println(""String_Node_Str"");
                  LinkedList<String> names=new LinkedList<String>();
                  for (                  Long l : outmrcaAncestor.getIntersection(ingroupNodeIds)) {
                    names.add((String)graphdb.getNodeById(l).getProperty(""String_Node_Str""));
                  }
                  System.out.println(curNode + ""String_Node_Str"" + ancestor+ ""String_Node_Str""+ curNode+ ""String_Node_Str""+ Arrays.toString(names.toArray())+ ""String_Node_Str""+ ancestor);
                  throw new java.lang.IllegalStateException();
                }
                TLongBitArray mrcaNew=new TLongBitArray((long[])ancestor.getProperty(""String_Node_Str""));
                mrcaNew.addAll(curNodeMRCAIds);
                if (updateDB) {
                  ancestor.setProperty(""String_Node_Str"",mrcaNew.toArray());
                }
              }
            }
            for (            Relationship childRel : curNode.getRelationships(RelType.STREECHILDOF,Direction.INCOMING)) {
              for (              Node descendant : Traversal.description().breadthFirst().evaluator(new LongArrayPropertyContainsAllEvaluator(""String_Node_Str"",curNodeOutMRCAIds)).relationships(RelType.STREECHILDOF,Direction.INCOMING).traverse(childRel.getStartNode()).nodes()) {
                System.out.println(""String_Node_Str"" + descendant + ""String_Node_Str"");
                TLongBitArray mrcaDescendant=new TLongBitArray((long[])descendant.getProperty(""String_Node_Str""));
                if (mrcaDescendant.containsAny(outgroupNodeIds)) {
                  System.out.println(""String_Node_Str"");
                  LinkedList<String> names=new LinkedList<String>();
                  for (                  Long l : mrcaDescendant.getIntersection(outgroupNodeIds)) {
                    names.add((String)graphdb.getNodeById(l).getProperty(""String_Node_Str""));
                  }
                  System.out.println(curNode + ""String_Node_Str"" + descendant+ ""String_Node_Str""+ curNode+ ""String_Node_Str""+ Arrays.toString(names.toArray())+ ""String_Node_Str""+ descendant);
                  throw new java.lang.IllegalStateException();
                }
                TLongBitArray outMrcaNew=new TLongBitArray((long[])descendant.getProperty(""String_Node_Str""));
                outMrcaNew.addAll(curNodeOutMRCAIds);
                if (updateDB) {
                  descendant.setProperty(""String_Node_Str"",outMrcaNew.toArray());
                }
              }
            }
          }
          return Evaluation.INCLUDE_AND_PRUNE;
        }
      }
    }
  }
 else {
    if (curNodeMRCAIds.containsAny(outgroupNodeIds) == false) {
      if (curNodeMRCAIds.containsAll(ingroupNodeIds)) {
        return Evaluation.INCLUDE_AND_PRUNE;
      }
    }
  }
  return Evaluation.EXCLUDE_AND_CONTINUE;
}","@Override public Evaluation evaluate(Path inPath){
  Node curNode=inPath.endNode();
  if (visited.contains(curNode.getId())) {
    return Evaluation.EXCLUDE_AND_PRUNE;
  }
  visited.add(curNode.getId());
  TLongBitArray curNodeMRCAIds=new TLongBitArray((long[])curNode.getProperty(""String_Node_Str""));
  TLongBitArray curNodeOutMRCAIds=null;
  boolean isTaxNode=false;
  if (curNode.hasProperty(""String_Node_Str"") == false) {
    isTaxNode=true;
  }
 else {
    curNodeOutMRCAIds=new TLongBitArray((long[])curNode.getProperty(""String_Node_Str""));
  }
  if (isTaxNode == false) {
    if (curNodeMRCAIds.containsAny(outgroupNodeIds) == false) {
      if (curNodeOutMRCAIds.containsAny(ingroupNodeIds) == false) {
        if (curNodeMRCAIds.containsAny(ingroupNodeIds) == true) {
          boolean passed=false;
          TLongHashSet visitedrels=new TLongHashSet();
          for (          Relationship rel : curNode.getRelationships(Direction.INCOMING,RelType.STREECHILDOF)) {
            if (visitedrels.contains(rel.getId()) || rel.hasProperty(""String_Node_Str"")) {
              continue;
            }
            TLongArrayList inids=new TLongArrayList((long[])rel.getProperty(""String_Node_Str""));
            visited.addAll(inids);
            TLongHashSet relmatched=new TLongHashSet();
            HashSet<Integer> childmatched=new HashSet<Integer>();
            for (int j=0; j < inids.size(); j++) {
              TLongBitArray trelj=new TLongBitArray((long[])graphdb.getRelationshipById(inids.get(j)).getProperty(""String_Node_Str""));
              for (int i=0; i < jadenode.getChildCount(); i++) {
                TLongBitArray chndi=new TLongBitArray((long[])jadenode.getChild(i).getObject(""String_Node_Str""));
                if (chndi.containsAny(trelj) == true) {
                  relmatched.add(inids.get(j));
                  childmatched.add(i);
                  break;
                }
              }
            }
            if (relmatched.size() >= 2) {
              passed=true;
              break;
            }
          }
          if (passed == false) {
            return Evaluation.EXCLUDE_AND_CONTINUE;
          }
          TLongBitArray mrcaSearchIdsNotSetForThisNode=ingroupNodeIds.andNot(curNodeMRCAIds);
          if (mrcaSearchIdsNotSetForThisNode.size() > 0) {
            curNodeMRCAIds.addAll(mrcaSearchIdsNotSetForThisNode);
            curNodeMRCAIds.sort();
            if (updateDB) {
              curNode.setProperty(""String_Node_Str"",curNodeMRCAIds.toArray());
            }
          }
          TLongBitArray outmrcaSearchIdsNotSetForThisNode=outgroupNodeIds.andNot(curNodeOutMRCAIds);
          if (outmrcaSearchIdsNotSetForThisNode.size() > 0) {
            curNodeOutMRCAIds.addAll(outmrcaSearchIdsNotSetForThisNode);
            curNodeOutMRCAIds.sort();
            if (updateDB) {
              curNode.setProperty(""String_Node_Str"",curNodeOutMRCAIds.toArray());
            }
          }
          if (updateDB) {
            for (            Relationship parentRel : curNode.getRelationships(RelType.STREECHILDOF,Direction.OUTGOING)) {
              for (              Node ancestor : Traversal.description().breadthFirst().evaluator(new LongArrayPropertyContainsAllEvaluator(""String_Node_Str"",curNodeMRCAIds)).relationships(RelType.STREECHILDOF,Direction.OUTGOING).traverse(parentRel.getEndNode()).nodes()) {
                System.out.println(""String_Node_Str"" + ancestor + ""String_Node_Str"");
                TLongBitArray outmrcaAncestor=new TLongBitArray((long[])ancestor.getProperty(""String_Node_Str""));
                if (outmrcaAncestor.containsAny(ingroupNodeIds)) {
                  System.out.println(""String_Node_Str"");
                  LinkedList<String> names=new LinkedList<String>();
                  for (                  Long l : outmrcaAncestor.getIntersection(ingroupNodeIds)) {
                    names.add((String)graphdb.getNodeById(l).getProperty(""String_Node_Str""));
                  }
                  System.out.println(curNode + ""String_Node_Str"" + ancestor+ ""String_Node_Str""+ curNode+ ""String_Node_Str""+ Arrays.toString(names.toArray())+ ""String_Node_Str""+ ancestor);
                  throw new java.lang.IllegalStateException();
                }
                TLongBitArray mrcaNew=new TLongBitArray((long[])ancestor.getProperty(""String_Node_Str""));
                mrcaNew.addAll(curNodeMRCAIds);
                if (updateDB) {
                  ancestor.setProperty(""String_Node_Str"",mrcaNew.toArray());
                }
              }
            }
            for (            Relationship childRel : curNode.getRelationships(RelType.STREECHILDOF,Direction.INCOMING)) {
              for (              Node descendant : Traversal.description().breadthFirst().evaluator(new LongArrayPropertyContainsAllEvaluator(""String_Node_Str"",curNodeOutMRCAIds)).relationships(RelType.STREECHILDOF,Direction.INCOMING).traverse(childRel.getStartNode()).nodes()) {
                System.out.println(""String_Node_Str"" + descendant + ""String_Node_Str"");
                TLongBitArray mrcaDescendant=new TLongBitArray((long[])descendant.getProperty(""String_Node_Str""));
                if (mrcaDescendant.containsAny(outgroupNodeIds)) {
                  System.out.println(""String_Node_Str"");
                  LinkedList<String> names=new LinkedList<String>();
                  for (                  Long l : mrcaDescendant.getIntersection(outgroupNodeIds)) {
                    names.add((String)graphdb.getNodeById(l).getProperty(""String_Node_Str""));
                  }
                  System.out.println(curNode + ""String_Node_Str"" + descendant+ ""String_Node_Str""+ curNode+ ""String_Node_Str""+ Arrays.toString(names.toArray())+ ""String_Node_Str""+ descendant);
                  throw new java.lang.IllegalStateException();
                }
                TLongBitArray outMrcaNew=new TLongBitArray((long[])descendant.getProperty(""String_Node_Str""));
                outMrcaNew.addAll(curNodeOutMRCAIds);
                if (updateDB) {
                  descendant.setProperty(""String_Node_Str"",outMrcaNew.toArray());
                }
              }
            }
          }
          return Evaluation.INCLUDE_AND_PRUNE;
        }
      }
    }
  }
 else {
    if (curNodeMRCAIds.containsAny(outgroupNodeIds) == false) {
      if (curNodeMRCAIds.containsAll(ingroupNodeIds)) {
        return Evaluation.INCLUDE_AND_PRUNE;
      }
    }
  }
  return Evaluation.EXCLUDE_AND_CONTINUE;
}"
50166,"private BitMask getBitMask(BitMask mask){
  if (mask.size() > MAX_LONG_BITMASK_SIZE) {
    return new BitSetMask((BitSetMask)mask);
  }
 else {
    return new IntegerBitMask((IntegerBitMask)mask);
  }
}","private BitMask getBitMask(BitMask mask){
  if (mask.size() > MAX_LONG_BITMASK_SIZE) {
    return new BitSetMask((BitSetMask)mask);
  }
 else {
    return new LongBitMask((LongBitMask)mask);
  }
}"
50167,"private BitMask getEmptyBitMask(int size){
  if (size > MAX_LONG_BITMASK_SIZE) {
    return new BitSetMask(size);
  }
 else {
    return new IntegerBitMask(size);
  }
}","private BitMask getEmptyBitMask(int size){
  if (size > MAX_LONG_BITMASK_SIZE) {
    return new BitSetMask(size);
  }
 else {
    return new LongBitMask(size);
  }
}"
50168,"private static void simpleTest(){
  Long[] ids=new Long[]{44L,40L,1L};
  TLongBitArraySet a=new TLongBitArraySet();
  a.addAll(new int[]{7});
  TLongBitArraySet b=new TLongBitArraySet();
  b.addAll(new int[]{3});
  TLongBitArraySet c=new TLongBitArraySet();
  c.addAll(new int[]{1,2,4,5,6});
  TLongBitArraySet d=new TLongBitArraySet();
  d.addAll(new int[]{2,3,4,5,6,7});
  TLongBitArraySet[] descendants=new TLongBitArraySet[]{a,b,c};
  BruteWeightedIS B=new BruteWeightedIS(ids,descendants);
  System.out.println(""String_Node_Str"");
  printBest(B);
}","private static void simpleTest(){
  Long[] ids=new Long[]{44L,40L,1L};
  TLongBitArraySet a=new TLongBitArraySet();
  a.addAll(new int[]{7});
  TLongBitArraySet b=new TLongBitArraySet();
  b.addAll(new int[]{3});
  TLongBitArraySet c=new TLongBitArraySet();
  c.addAll(new int[]{1,2,4,5,6});
  TLongBitArraySet d=new TLongBitArraySet();
  d.addAll(new int[]{2,3,4,5,6,7});
  TLongBitArraySet[] descendants=new TLongBitArraySet[]{a,b,c};
  BruteWeightedIS B=new BruteWeightedIS(ids,descendants);
  Long[] e=new Long[]{44L,40L,1L};
  System.out.println(""String_Node_Str"" + Arrays.toString(e));
  System.out.println(""String_Node_Str"" + Arrays.toString(B.best()));
}"
50169,"private static void arbitrarySizeRandomTest(int numberOfSets){
  int setSize=10;
  int maxItemValue=1000;
  System.out.println(""String_Node_Str"" + Math.pow(2,numberOfSets));
  Long[] ids=new Long[numberOfSets];
  for (int i=0; i < numberOfSets; i++) {
    ids[i]=(long)i;
  }
  TLongBitArraySet[] descendants=new TLongBitArraySet[ids.length];
  for (int i=0; i < ids.length; i++) {
    TLongBitArraySet a=new TLongBitArraySet();
    for (int j=0; j < setSize; j++) {
      a.add(randomInt(maxItemValue));
    }
    descendants[i]=a;
  }
  BruteWeightedIS B=new BruteWeightedIS(ids,descendants);
  printBest(B);
}","private static void arbitrarySizeRandomTest(int numberOfSets){
  int setSize=10;
  int maxItemValue=1000;
  System.out.println(""String_Node_Str"" + Math.pow(2,numberOfSets));
  Long[] ids=new Long[numberOfSets];
  for (int i=0; i < numberOfSets; i++) {
    ids[i]=(long)i;
  }
  TLongBitArraySet[] descendants=new TLongBitArraySet[ids.length];
  for (int i=0; i < ids.length; i++) {
    TLongBitArraySet a=new TLongBitArraySet();
    for (int j=0; j < setSize; j++) {
      a.add(randomInt(maxItemValue));
    }
    descendants[i]=a;
  }
  BruteWeightedIS B=new BruteWeightedIS(ids,descendants);
  System.out.println(""String_Node_Str"" + Arrays.toString(B.best()));
}"
50170,"public BruteWeightedIS(Long[] ids,TLongBitArraySet[] descendants){
  MAX_LONG_BITMASK_SIZE=new IntegerBitMask(0).maxSize();
  MAX_BITSET_MASK_SIZE=new BitSetMask(0).maxSize();
  this.ids=ids;
  this.descendants=descendants;
  System.out.println(""String_Node_Str"");
  System.out.println(this);
  findBestSet();
}","public BruteWeightedIS(Long[] ids,TLongBitArraySet[] descendants){
  MAX_LONG_BITMASK_SIZE=new LongBitMask(0).maxSize();
  MAX_BITSET_MASK_SIZE=new BitSetMask(0).maxSize();
  this.ids=ids;
  this.descendants=descendants;
  System.out.println(""String_Node_Str"");
  System.out.println(this);
  findBestSet();
}"
50171,"public Node getTaxonomyMRCA(Iterable<Node> nodeset){
  Node mrca=null;
  ArrayList<Node> holder=null;
  int index=10000000;
  for (  Node curNode : nodeset) {
    if (holder != null) {
      for (      Node m : Traversal.description().relationships(RelType.TAXCHILDOF,Direction.OUTGOING).traverse(curNode).nodes()) {
        int foo=holder.indexOf(m);
        if (foo != -1) {
          if (foo < index) {
            index=foo;
          }
          break;
        }
      }
    }
 else {
      ArrayList<Node> graphPathToRoot=new ArrayList<Node>();
      for (      Node m : Traversal.description().relationships(RelType.TAXCHILDOF,Direction.OUTGOING).traverse(curNode).nodes()) {
        graphPathToRoot.add(0,m);
      }
      holder=graphPathToRoot;
    }
  }
  mrca=holder.get(index);
  return mrca;
}","public Node getTaxonomyMRCA(Iterable<Node> nodeset){
  Node mrca=null;
  ArrayList<Node> holder=null;
  int index=10000000;
  for (  Node curNode : nodeset) {
    if (holder != null) {
      for (      Node m : Traversal.description().relationships(RelType.TAXCHILDOF,Direction.OUTGOING).traverse(curNode).nodes()) {
        int foo=holder.indexOf(m);
        if (foo != -1) {
          if (foo < index) {
            index=foo;
          }
          break;
        }
      }
    }
 else {
      ArrayList<Node> graphPathToRoot=new ArrayList<Node>();
      for (      Node m : Traversal.description().relationships(RelType.TAXCHILDOF,Direction.OUTGOING).traverse(curNode).nodes()) {
        graphPathToRoot.add(0,m);
      }
      holder=graphPathToRoot;
    }
  }
  if (!holder.isEmpty()) {
    if (index == 10000000) {
      mrca=holder.get(0);
    }
 else {
      mrca=holder.get(index);
    }
  }
  return mrca;
}"
50172,"public Node getDraftTreeMRCA(Iterable<Node> nodeset){
  Node mrca=null;
  ArrayList<Node> holder=null;
  int index=10000000;
  for (  Node curNode : nodeset) {
    if (holder != null) {
      for (      Node m : Traversal.description().expand(new DraftTreePathExpander(Direction.OUTGOING)).traverse(curNode).nodes()) {
        int foo=holder.indexOf(m);
        if (foo != -1) {
          if (foo < index) {
            index=foo;
          }
          break;
        }
      }
    }
 else {
      ArrayList<Node> graphPathToRoot=new ArrayList<Node>();
      for (      Node m : Traversal.description().expand(new DraftTreePathExpander(Direction.OUTGOING)).traverse(curNode).nodes()) {
        graphPathToRoot.add(0,m);
      }
      holder=graphPathToRoot;
    }
  }
  mrca=holder.get(index);
  return mrca;
}","public Node getDraftTreeMRCA(Iterable<Node> nodeset){
  Node mrca=null;
  ArrayList<Node> holder=null;
  int index=10000000;
  for (  Node curNode : nodeset) {
    if (holder != null) {
      for (      Node m : Traversal.description().expand(new DraftTreePathExpander(Direction.OUTGOING)).traverse(curNode).nodes()) {
        int foo=holder.indexOf(m);
        if (foo != -1) {
          if (foo < index) {
            index=foo;
          }
          break;
        }
      }
    }
 else {
      ArrayList<Node> graphPathToRoot=new ArrayList<Node>();
      for (      Node m : Traversal.description().expand(new DraftTreePathExpander(Direction.OUTGOING)).traverse(curNode).nodes()) {
        graphPathToRoot.add(0,m);
      }
      holder=graphPathToRoot;
    }
  }
  if (!holder.isEmpty()) {
    if (index == 10000000) {
      mrca=holder.get(0);
    }
 else {
      mrca=holder.get(index);
    }
  }
  return mrca;
}"
50173,"public Node getTaxonomyMRCA(Iterable<Node> nodeset){
  Node mrca=null;
  ArrayList<Node> holder=null;
  int index=10000000;
  for (  Node curNode : nodeset) {
    if (holder != null) {
      for (      Node m : Traversal.description().relationships(RelType.TAXCHILDOF,Direction.OUTGOING).traverse(curNode).nodes()) {
        int foo=holder.indexOf(m);
        if (foo != -1) {
          if (foo < index) {
            index=foo;
          }
          break;
        }
      }
    }
 else {
      ArrayList<Node> graphPathToRoot=new ArrayList<Node>();
      for (      Node m : Traversal.description().relationships(RelType.TAXCHILDOF,Direction.OUTGOING).traverse(curNode).nodes()) {
        graphPathToRoot.add(0,m);
      }
      holder=graphPathToRoot;
    }
  }
  if (!holder.isEmpty()) {
    if (index == 10000000) {
      mrca=holder.get(0);
    }
 else {
      mrca=holder.get(index);
    }
  }
  return mrca;
}","public Node getTaxonomyMRCA(Iterable<Node> nodeset){
  Node mrca=null;
  ArrayList<Node> holder=null;
  int index=10000000;
  for (  Node curNode : nodeset) {
    if (holder != null) {
      for (      Node m : Traversal.description().relationships(RelType.TAXCHILDOF,Direction.OUTGOING).traverse(curNode).nodes()) {
        int foo=holder.indexOf(m);
        if (foo != -1) {
          if (foo < index) {
            index=foo;
          }
          break;
        }
      }
    }
 else {
      ArrayList<Node> graphPathToRoot=new ArrayList<Node>();
      for (      Node m : Traversal.description().relationships(RelType.TAXCHILDOF,Direction.OUTGOING).traverse(curNode).nodes()) {
        graphPathToRoot.add(0,m);
      }
      holder=graphPathToRoot;
    }
  }
  if (!holder.isEmpty()) {
    if (index == 10000000) {
      mrca=holder.get(holder.size() - 1);
    }
 else {
      mrca=holder.get(index);
    }
  }
  return mrca;
}"
50174,"public Node getDraftTreeMRCA(Iterable<Node> nodeset){
  Node mrca=null;
  ArrayList<Node> holder=null;
  int index=10000000;
  for (  Node curNode : nodeset) {
    if (holder != null) {
      for (      Node m : Traversal.description().expand(new DraftTreePathExpander(Direction.OUTGOING)).traverse(curNode).nodes()) {
        int foo=holder.indexOf(m);
        if (foo != -1) {
          if (foo < index) {
            index=foo;
          }
          break;
        }
      }
    }
 else {
      ArrayList<Node> graphPathToRoot=new ArrayList<Node>();
      for (      Node m : Traversal.description().expand(new DraftTreePathExpander(Direction.OUTGOING)).traverse(curNode).nodes()) {
        graphPathToRoot.add(0,m);
      }
      holder=graphPathToRoot;
    }
  }
  if (!holder.isEmpty()) {
    if (index == 10000000) {
      mrca=holder.get(0);
    }
 else {
      mrca=holder.get(index);
    }
  }
  return mrca;
}","public Node getDraftTreeMRCA(Iterable<Node> nodeset){
  Node mrca=null;
  ArrayList<Node> holder=null;
  int index=10000000;
  for (  Node curNode : nodeset) {
    if (holder != null) {
      for (      Node m : Traversal.description().expand(new DraftTreePathExpander(Direction.OUTGOING)).traverse(curNode).nodes()) {
        int foo=holder.indexOf(m);
        if (foo != -1) {
          if (foo < index) {
            index=foo;
          }
          break;
        }
      }
    }
 else {
      ArrayList<Node> graphPathToRoot=new ArrayList<Node>();
      for (      Node m : Traversal.description().expand(new DraftTreePathExpander(Direction.OUTGOING)).traverse(curNode).nodes()) {
        graphPathToRoot.add(0,m);
      }
      holder=graphPathToRoot;
    }
  }
  if (!holder.isEmpty()) {
    if (index == 10000000) {
      mrca=holder.get(holder.size() - 1);
    }
 else {
      mrca=holder.get(index);
    }
  }
  return mrca;
}"
50175,"public static HashMap<String,Object> reformatSourceID(String source){
  HashMap<String,Object> results=new HashMap<String,Object>();
  String[] res=source.split(""String_Node_Str"");
  String studyId=""String_Node_Str"";
  String treeId=""String_Node_Str"";
  String gitSha=""String_Node_Str"";
  if (res.length == 4) {
    studyId=res[0] + ""String_Node_Str"" + res[1];
    treeId=res[2];
    gitSha=res[3];
  }
 else   if (res.length == 4) {
    studyId=res[0];
    treeId=res[1];
    gitSha=res[2];
  }
 else {
    studyId=res[0];
  }
  results.put(""String_Node_Str"",studyId);
  results.put(""String_Node_Str"",treeId);
  results.put(""String_Node_Str"",gitSha);
  return (results);
}","public static HashMap<String,Object> reformatSourceID(String source){
  HashMap<String,Object> results=new HashMap<String,Object>();
  String[] res=source.split(""String_Node_Str"");
  String studyId=""String_Node_Str"";
  String treeId=""String_Node_Str"";
  String gitSha=""String_Node_Str"";
  if (res.length == 4) {
    studyId=res[0] + ""String_Node_Str"" + res[1];
    treeId=res[2];
    gitSha=res[3];
  }
 else   if (res.length == 3) {
    studyId=res[0];
    treeId=res[1];
    gitSha=res[2];
  }
 else   if (res.length == 2) {
    studyId=res[0];
    treeId=res[1];
  }
 else {
    studyId=res[0];
  }
  results.put(""String_Node_Str"",studyId);
  results.put(""String_Node_Str"",treeId);
  results.put(""String_Node_Str"",gitSha);
  return (results);
}"
50176,"@Description(""String_Node_Str"") @PluginTarget(GraphDatabaseService.class) public Representation about(@Source GraphDatabaseService graphDb) throws TaxonNotFoundException, MultipleHitsException {
  GraphDatabaseAgent gdb=new GraphDatabaseAgent(graphDb);
  GraphExplorer ge=new GraphExplorer(gdb);
  HashMap<String,Object> draftTreeInfo=null;
  try {
    Node meta=ge.getSynthesisMetaNode();
    if (meta != null) {
      String[] sourceList=(String[])meta.getProperty(""String_Node_Str"");
      Node startNode=gdb.getNodeById((Long)gdb.getGraphProperty(""String_Node_Str""));
      Integer numMRCA=((long[])startNode.getProperty(NodeProperty.MRCA.propertyName)).length;
      Integer numStudies=sourceList.length;
      draftTreeInfo=new HashMap<String,Object>();
      draftTreeInfo.put(""String_Node_Str"",meta.getProperty(""String_Node_Str""));
      draftTreeInfo.put(""String_Node_Str"",meta.getProperty(""String_Node_Str""));
      draftTreeInfo.put(""String_Node_Str"",ge.getTaxonomyVersion());
      draftTreeInfo.put(""String_Node_Str"",startNode.getId());
      draftTreeInfo.put(""String_Node_Str"",String.valueOf(startNode.getProperty(NodeProperty.NAME.propertyName)));
      draftTreeInfo.put(""String_Node_Str"",Long.valueOf((String)startNode.getProperty(NodeProperty.TAX_UID.propertyName)));
      draftTreeInfo.put(""String_Node_Str"",numMRCA);
      draftTreeInfo.put(""String_Node_Str"",numStudies);
      draftTreeInfo.put(""String_Node_Str"",sourceList);
    }
 else {
      draftTreeInfo=new HashMap<String,Object>();
      draftTreeInfo.put(""String_Node_Str"",""String_Node_Str"");
      return OTRepresentationConverter.convert(draftTreeInfo);
    }
  }
  finally {
    ge.shutdownDB();
  }
  return OTRepresentationConverter.convert(draftTreeInfo);
}","@Description(""String_Node_Str"") @PluginTarget(GraphDatabaseService.class) public Representation about(@Source GraphDatabaseService graphDb) throws TaxonNotFoundException, MultipleHitsException {
  GraphDatabaseAgent gdb=new GraphDatabaseAgent(graphDb);
  GraphExplorer ge=new GraphExplorer(gdb);
  HashMap<String,Object> draftTreeInfo=null;
  try {
    Node meta=ge.getSynthesisMetaNode();
    if (meta != null) {
      ArrayList<String> sourceList=ge.getSynthesisSourceList();
      Node startNode=gdb.getNodeById((Long)gdb.getGraphProperty(""String_Node_Str""));
      Integer numMRCA=((long[])startNode.getProperty(NodeProperty.MRCA.propertyName)).length;
      Integer numStudies=sourceList.size();
      draftTreeInfo=new HashMap<String,Object>();
      draftTreeInfo.put(""String_Node_Str"",meta.getProperty(""String_Node_Str""));
      draftTreeInfo.put(""String_Node_Str"",meta.getProperty(""String_Node_Str""));
      draftTreeInfo.put(""String_Node_Str"",ge.getTaxonomyVersion());
      draftTreeInfo.put(""String_Node_Str"",startNode.getId());
      draftTreeInfo.put(""String_Node_Str"",String.valueOf(startNode.getProperty(NodeProperty.NAME.propertyName)));
      draftTreeInfo.put(""String_Node_Str"",Long.valueOf((String)startNode.getProperty(NodeProperty.TAX_UID.propertyName)));
      draftTreeInfo.put(""String_Node_Str"",numMRCA);
      draftTreeInfo.put(""String_Node_Str"",numStudies);
      draftTreeInfo.put(""String_Node_Str"",sourceList);
    }
 else {
      draftTreeInfo=new HashMap<String,Object>();
      draftTreeInfo.put(""String_Node_Str"",""String_Node_Str"");
      return OTRepresentationConverter.convert(draftTreeInfo);
    }
  }
  finally {
    ge.shutdownDB();
  }
  return OTRepresentationConverter.convert(draftTreeInfo);
}"
50177,"@Description(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"") @PluginTarget(GraphDatabaseService.class) public Representation mrca(@Source GraphDatabaseService graphDb,@Description(""String_Node_Str"") @Parameter(name=""String_Node_Str"",optional=true) long[] nodeIds,@Description(""String_Node_Str"") @Parameter(name=""String_Node_Str"",optional=true) long[] ottIds) throws MultipleHitsException {
  if ((nodeIds == null || nodeIds.length < 1) && (ottIds == null || ottIds.length < 1)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ArrayList<Node> tips=new ArrayList<Node>();
  ArrayList<Long> invalidNodesIds=new ArrayList<Long>();
  ArrayList<Long> invalidOttIds=new ArrayList<Long>();
  ArrayList<Long> nodeIdsNotInSynth=new ArrayList<Long>();
  ArrayList<Long> ottIdsNotInSynth=new ArrayList<Long>();
  GraphExplorer ge=new GraphExplorer(graphDb);
  if (nodeIds != null && nodeIds.length > 0) {
    for (    long nodeId : nodeIds) {
      Node n=null;
      try {
        n=graphDb.getNodeById(nodeId);
      }
 catch (      NotFoundException e) {
      }
      if (n != null) {
        if (ge.nodeIsInSyntheticTree(n)) {
          tips.add(n);
        }
 else {
          nodeIdsNotInSynth.add(nodeId);
        }
      }
 else {
        invalidNodesIds.add(nodeId);
      }
    }
  }
  if (ottIds != null && ottIds.length > 0) {
    for (    long ottId : ottIds) {
      Node n=null;
      try {
        n=ge.findGraphTaxNodeByUID(String.valueOf(ottId));
      }
 catch (      TaxonNotFoundException e) {
      }
      if (n != null) {
        if (ge.nodeIsInSyntheticTree(n)) {
          tips.add(n);
        }
 else {
          ottIdsNotInSynth.add(ottId);
          tips.addAll(ge.getTaxonomyDescendantTips(n));
        }
      }
 else {
        invalidOttIds.add(ottId);
      }
    }
  }
  if (tips.size() < 1) {
    HashMap<String,Object> vals=new HashMap<String,Object>();
    vals.put(""String_Node_Str"",""String_Node_Str"");
    return OTRepresentationConverter.convert(vals);
  }
 else {
    HashMap<String,Object> vals=new HashMap<String,Object>();
    Node mrca=ge.getDraftTreeMRCAForNodes(tips,false);
    Node mrta=mrca;
    while (!mrta.hasProperty(NodeProperty.TAX_UID.propertyName)) {
      mrta=mrta.getSingleRelationship(RelType.SYNTHCHILDOF,Direction.OUTGOING).getEndNode();
    }
    vals.put(""String_Node_Str"",mrca.getId());
    String name=""String_Node_Str"";
    String unique=""String_Node_Str"";
    String rank=""String_Node_Str"";
    Long ottID=null;
    if (mrca.hasProperty(NodeProperty.TAX_UID.propertyName)) {
      name=(String)mrca.getProperty(NodeProperty.NAME.propertyName);
      unique=(String)mrca.getProperty(NodeProperty.NAME_UNIQUE.propertyName);
      rank=(String)mrca.getProperty(NodeProperty.TAX_RANK.propertyName);
      ottID=(Long)mrca.getProperty(NodeProperty.TAX_UID.propertyName);
    }
    vals.put(""String_Node_Str"",name);
    vals.put(""String_Node_Str"",unique);
    vals.put(""String_Node_Str"",rank);
    if (ottID != null) {
      vals.put(""String_Node_Str"",ottID);
    }
 else {
      vals.put(""String_Node_Str"",""String_Node_Str"");
    }
    vals.put(""String_Node_Str"",mrta.getProperty(NodeProperty.NAME.propertyName));
    vals.put(""String_Node_Str"",mrta.getProperty(NodeProperty.NAME_UNIQUE.propertyName));
    vals.put(""String_Node_Str"",mrta.getProperty(NodeProperty.TAX_RANK.propertyName));
    vals.put(""String_Node_Str"",mrta.getProperty(NodeProperty.TAX_UID.propertyName));
    vals.put(""String_Node_Str"",mrta.getId());
    vals.put(""String_Node_Str"",invalidNodesIds);
    vals.put(""String_Node_Str"",invalidOttIds);
    vals.put(""String_Node_Str"",nodeIdsNotInSynth);
    vals.put(""String_Node_Str"",ottIdsNotInSynth);
    ge.shutdownDB();
    return OTRepresentationConverter.convert(vals);
  }
}","@Description(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"") @PluginTarget(GraphDatabaseService.class) public Representation mrca(@Source GraphDatabaseService graphDb,@Description(""String_Node_Str"") @Parameter(name=""String_Node_Str"",optional=true) long[] nodeIds,@Description(""String_Node_Str"") @Parameter(name=""String_Node_Str"",optional=true) long[] ottIds) throws MultipleHitsException {
  if ((nodeIds == null || nodeIds.length < 1) && (ottIds == null || ottIds.length < 1)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ArrayList<Node> tips=new ArrayList<Node>();
  ArrayList<Long> invalidNodesIds=new ArrayList<Long>();
  ArrayList<Long> invalidOttIds=new ArrayList<Long>();
  ArrayList<Long> nodeIdsNotInSynth=new ArrayList<Long>();
  ArrayList<Long> ottIdsNotInSynth=new ArrayList<Long>();
  GraphExplorer ge=new GraphExplorer(graphDb);
  if (nodeIds != null && nodeIds.length > 0) {
    for (    long nodeId : nodeIds) {
      Node n=null;
      try {
        n=graphDb.getNodeById(nodeId);
      }
 catch (      NotFoundException e) {
      }
      if (n != null) {
        if (ge.nodeIsInSyntheticTree(n)) {
          tips.add(n);
        }
 else {
          nodeIdsNotInSynth.add(nodeId);
        }
      }
 else {
        invalidNodesIds.add(nodeId);
      }
    }
  }
  if (ottIds != null && ottIds.length > 0) {
    for (    long ottId : ottIds) {
      Node n=null;
      try {
        n=ge.findGraphTaxNodeByUID(String.valueOf(ottId));
      }
 catch (      TaxonNotFoundException e) {
      }
      if (n != null) {
        if (ge.nodeIsInSyntheticTree(n)) {
          tips.add(n);
        }
 else {
          ottIdsNotInSynth.add(ottId);
          tips.addAll(ge.getTaxonomyDescendantTips(n));
        }
      }
 else {
        invalidOttIds.add(ottId);
      }
    }
  }
  if (tips.size() < 1) {
    HashMap<String,Object> vals=new HashMap<String,Object>();
    vals.put(""String_Node_Str"",""String_Node_Str"");
    return OTRepresentationConverter.convert(vals);
  }
 else {
    HashMap<String,Object> vals=new HashMap<String,Object>();
    Node mrca=ge.getDraftTreeMRCAForNodes(tips,false);
    Node mrta=mrca;
    while (!mrta.hasProperty(NodeProperty.TAX_UID.propertyName)) {
      mrta=mrta.getSingleRelationship(RelType.SYNTHCHILDOF,Direction.OUTGOING).getEndNode();
    }
    vals.put(""String_Node_Str"",mrca.getId());
    String name=""String_Node_Str"";
    String unique=""String_Node_Str"";
    String rank=""String_Node_Str"";
    Long ottID=null;
    if (mrca.hasProperty(NodeProperty.TAX_UID.propertyName)) {
      name=(String)mrca.getProperty(NodeProperty.NAME.propertyName);
      unique=(String)mrca.getProperty(NodeProperty.NAME_UNIQUE.propertyName);
      rank=(String)mrca.getProperty(NodeProperty.TAX_RANK.propertyName);
      ottID=Long.valueOf((String)mrca.getProperty(NodeProperty.TAX_UID.propertyName));
    }
    vals.put(""String_Node_Str"",name);
    vals.put(""String_Node_Str"",unique);
    vals.put(""String_Node_Str"",rank);
    if (ottID != null) {
      vals.put(""String_Node_Str"",ottID);
    }
 else {
      vals.put(""String_Node_Str"",""String_Node_Str"");
    }
    vals.put(""String_Node_Str"",mrta.getProperty(NodeProperty.NAME.propertyName));
    vals.put(""String_Node_Str"",mrta.getProperty(NodeProperty.NAME_UNIQUE.propertyName));
    vals.put(""String_Node_Str"",mrta.getProperty(NodeProperty.TAX_RANK.propertyName));
    vals.put(""String_Node_Str"",mrta.getProperty(NodeProperty.TAX_UID.propertyName));
    vals.put(""String_Node_Str"",mrta.getId());
    vals.put(""String_Node_Str"",invalidNodesIds);
    vals.put(""String_Node_Str"",invalidOttIds);
    vals.put(""String_Node_Str"",nodeIdsNotInSynth);
    vals.put(""String_Node_Str"",ottIdsNotInSynth);
    ge.shutdownDB();
    return OTRepresentationConverter.convert(vals);
  }
}"
50178,"/** 
 * Reads a taxonomy file with rows formatted as: taxon_id,parent_id,Name with spaces allowed\n The source name is going to be OTTOL Creates the nodes and TAXCHILDOF relationship for a taxonomy tree Node objects will get a ""name"", ""mrca"", and ""nested_mrca"" properties They will also get tax_uid, tax_parent_uid, tax_rank, tax_source, tax_sourceid, tax_sourcepid, uniqname TAXCHILDOF relationships will get ""source"" of ""ottol"", ""childid"", and ""parentid"" properties with the addition of the new information in the ottol dumps the nodes will also get properties STREECHILDOF relationships will get ""source"" properties as ""taxonomy"" Nodes are indexed in graphNamedNodes with their name as the value for a ""name"" key This will load the taxonomy, adding 
 * @param filename file path to the taxonomy file
 * @param synonymfile file that has the synonyms as dumped by ottol dump
 * @throws TaxonNotFoundException 
 */
public void addInitialTaxonomyTableIntoGraph(String filename,String synonymfile,String taxonomyversion) throws TaxonNotFoundException {
  initContainersForTaxLoading();
  String str=""String_Node_Str"";
  int count=0;
  if (synonymfile.length() > 0) {
    synFileExists=true;
  }
  if (synFileExists) {
    synonymHash=new HashMap<String,ArrayList<ArrayList<String>>>();
    try {
      BufferedReader sbr=new BufferedReader(new FileReader(synonymfile));
      while ((str=sbr.readLine()) != null) {
        StringTokenizer st=new StringTokenizer(str,""String_Node_Str"");
        String name=st.nextToken();
        String parentuid=st.nextToken();
        String uid=parentuid;
        String type=""String_Node_Str"";
        String source=""String_Node_Str"";
        ArrayList<String> tar=new ArrayList<String>();
        tar.add(uid);
        tar.add(name);
        tar.add(type);
        tar.add(source);
        if (synonymHash.get(parentuid) == null) {
          ArrayList<ArrayList<String>> ttar=new ArrayList<ArrayList<String>>();
          synonymHash.put(parentuid,ttar);
        }
        synonymHash.get(parentuid).add(tar);
      }
      sbr.close();
    }
 catch (    Exception e) {
      e.printStackTrace();
      System.exit(0);
    }
    System.out.println(""String_Node_Str"" + synonymHash.size());
  }
  Transaction tx;
  ArrayList<String> templines=new ArrayList<String>();
  try {
    BufferedReader br=new BufferedReader(new FileReader(filename));
    while ((str=br.readLine()) != null) {
      if (count == 0) {
        if (str.startsWith(""String_Node_Str"")) {
          System.out.println(""String_Node_Str"" + str);
          continue;
        }
      }
      count+=1;
      templines.add(str);
      if (count % transactionFrequency == 0) {
        System.out.print(""String_Node_Str"" + count);
        System.out.print(""String_Node_Str"");
        tx=graphDb.beginTx();
        try {
          for (int i=0; i < templines.size(); i++) {
            processTaxInputLine(templines.get(i),taxonomyversion);
          }
          tx.success();
        }
  finally {
          tx.finish();
        }
        templines.clear();
      }
    }
    br.close();
    tx=graphDb.beginTx();
    try {
      for (int i=0; i < templines.size(); i++) {
        processTaxInputLine(templines.get(i),taxonomyversion);
      }
      tx.success();
    }
  finally {
      tx.finish();
    }
    templines.clear();
    ArrayList<String> temppar=new ArrayList<String>();
    count=0;
    for (    String key : taxUIDToNodeMap.keySet()) {
      count+=1;
      temppar.add(key);
      if (count % transactionFrequency == 0) {
        System.out.println(count);
        tx=graphDb.beginTx();
        try {
          for (int i=0; i < temppar.size(); i++) {
            try {
              addParentRelationshipForTaxUID(temppar.get(i));
            }
 catch (            java.lang.IllegalArgumentException io) {
              continue;
            }
          }
          tx.success();
        }
  finally {
          tx.finish();
        }
        temppar.clear();
      }
    }
    tx=graphDb.beginTx();
    try {
      for (int i=0; i < temppar.size(); i++) {
        try {
          addParentRelationshipForTaxUID(temppar.get(i));
        }
 catch (        java.lang.IllegalArgumentException io) {
          continue;
        }
      }
      tx.success();
    }
  finally {
      tx.finish();
    }
  }
 catch (  IOException ioe) {
  }
  initMrcaAndStreeRelsTax();
}","/** 
 * Reads a taxonomy file with rows formatted as: taxon_id,parent_id,Name with spaces allowed\n The source name is going to be OTTOL Creates the nodes and TAXCHILDOF relationship for a taxonomy tree Node objects will get a ""name"", ""mrca"", and ""nested_mrca"" properties They will also get tax_uid, tax_parent_uid, tax_rank, tax_source, tax_sourceid, tax_sourcepid, uniqname TAXCHILDOF relationships will get ""source"" of ""ottol"", ""childid"", and ""parentid"" properties with the addition of the new information in the ottol dumps the nodes will also get properties STREECHILDOF relationships will get ""source"" properties as ""taxonomy"" Nodes are indexed in graphNamedNodes with their name as the value for a ""name"" key This will load the taxonomy, adding 
 * @param filename file path to the taxonomy file
 * @param synonymfile file that has the synonyms as dumped by ottol dump
 * @throws TaxonNotFoundException 
 */
public void addInitialTaxonomyTableIntoGraph(String filename,String synonymfile,String taxonomyversion) throws TaxonNotFoundException {
  initContainersForTaxLoading();
  String str=""String_Node_Str"";
  int count=0;
  if (synonymfile.length() > 0) {
    synFileExists=true;
  }
  if (synFileExists) {
    synonymHash=new HashMap<String,ArrayList<ArrayList<String>>>();
    try {
      BufferedReader sbr=new BufferedReader(new FileReader(synonymfile));
      while ((str=sbr.readLine()) != null) {
        if (!str.trim().equals(""String_Node_Str"")) {
          StringTokenizer st=new StringTokenizer(str,""String_Node_Str"");
          String name=st.nextToken();
          String parentuid=st.nextToken();
          String uid=parentuid;
          String type=""String_Node_Str"";
          String source=""String_Node_Str"";
          ArrayList<String> tar=new ArrayList<String>();
          tar.add(uid);
          tar.add(name);
          tar.add(type);
          tar.add(source);
          if (synonymHash.get(parentuid) == null) {
            ArrayList<ArrayList<String>> ttar=new ArrayList<ArrayList<String>>();
            synonymHash.put(parentuid,ttar);
          }
          synonymHash.get(parentuid).add(tar);
        }
      }
      sbr.close();
    }
 catch (    Exception e) {
      e.printStackTrace();
      System.exit(0);
    }
    System.out.println(""String_Node_Str"" + synonymHash.size());
  }
  Transaction tx;
  ArrayList<String> templines=new ArrayList<String>();
  try {
    BufferedReader br=new BufferedReader(new FileReader(filename));
    while ((str=br.readLine()) != null) {
      if (!str.trim().equals(""String_Node_Str"")) {
        if (count == 0) {
          if (str.startsWith(""String_Node_Str"")) {
            System.out.println(""String_Node_Str"" + str);
            continue;
          }
        }
        count+=1;
        templines.add(str);
        if (count % transactionFrequency == 0) {
          System.out.print(""String_Node_Str"" + count);
          System.out.print(""String_Node_Str"");
          tx=graphDb.beginTx();
          try {
            for (int i=0; i < templines.size(); i++) {
              processTaxInputLine(templines.get(i),taxonomyversion);
            }
            tx.success();
          }
  finally {
            tx.finish();
          }
          templines.clear();
        }
      }
    }
    br.close();
    tx=graphDb.beginTx();
    try {
      for (int i=0; i < templines.size(); i++) {
        processTaxInputLine(templines.get(i),taxonomyversion);
      }
      tx.success();
    }
  finally {
      tx.finish();
    }
    templines.clear();
    ArrayList<String> temppar=new ArrayList<String>();
    count=0;
    for (    String key : taxUIDToNodeMap.keySet()) {
      count+=1;
      temppar.add(key);
      if (count % transactionFrequency == 0) {
        System.out.println(count);
        tx=graphDb.beginTx();
        try {
          for (int i=0; i < temppar.size(); i++) {
            try {
              addParentRelationshipForTaxUID(temppar.get(i));
            }
 catch (            java.lang.IllegalArgumentException io) {
              continue;
            }
          }
          tx.success();
        }
  finally {
          tx.finish();
        }
        temppar.clear();
      }
    }
    tx=graphDb.beginTx();
    try {
      for (int i=0; i < temppar.size(); i++) {
        try {
          addParentRelationshipForTaxUID(temppar.get(i));
        }
 catch (        java.lang.IllegalArgumentException io) {
          continue;
        }
      }
      tx.success();
    }
  finally {
      tx.finish();
    }
  }
 catch (  IOException ioe) {
  }
  initMrcaAndStreeRelsTax();
}"
50179,"/** 
 * Internal method to get an array of arrays representing the rootward paths of a given set of nodes, used to calculate mrca and associated procedures.
 * @param tips
 * @return
 */
private Map<Node,ArrayList<Node>> getTreeTipRootPathMap(Iterable<Node> tips){
  HashMap<Node,ArrayList<Node>> treeTipRootPathMap=new HashMap<Node,ArrayList<Node>>();
  for (  Node curTip : tips) {
    System.out.println(""String_Node_Str"" + curTip + (curTip.hasProperty(""String_Node_Str"") ? curTip.getProperty(""String_Node_Str"") : ""String_Node_Str""));
    ArrayList<Node> graphPathToRoot=new ArrayList<Node>();
    for (    Node m : Traversal.description().expand(new DraftTreePathExpander(Direction.OUTGOING)).traverse(curTip).nodes()) {
      if (m.hasProperty(""String_Node_Str"")) {
        System.out.println(m.getProperty(""String_Node_Str""));
      }
      graphPathToRoot.add(0,m);
    }
    if (graphPathToRoot.size() < 1) {
      throw new UnsupportedOperationException(""String_Node_Str"" + curTip + ""String_Node_Str"");
    }
    treeTipRootPathMap.put(curTip,graphPathToRoot);
  }
  return treeTipRootPathMap;
}","/** 
 * Internal method to get an array of arrays representing the rootward paths of a given set of nodes, used to calculate mrca and associated procedures. stopNode allows to set an mrca beyond which the traversal won't record the path.
 * @param tips
 * @param stopNode
 * @return
 */
private Map<Node,ArrayList<Node>> getTreeTipRootPathMap(Iterable<Node> tips,Node stopNode){
  if (stopNode != null) {
    System.out.println(""String_Node_Str"" + stopNode);
  }
  HashMap<Node,ArrayList<Node>> treeTipRootPathMap=new HashMap<Node,ArrayList<Node>>();
  for (  Node curTip : tips) {
    System.out.println(""String_Node_Str"" + curTip + (curTip.hasProperty(""String_Node_Str"") ? curTip.getProperty(""String_Node_Str"") : ""String_Node_Str""));
    ArrayList<Node> graphPathToRoot=new ArrayList<Node>();
    for (    Node m : Traversal.description().expand(new DraftTreePathExpander(Direction.OUTGOING)).traverse(curTip).nodes()) {
      if (stopNode != null && m.equals(stopNode)) {
        System.out.println(""String_Node_Str"" + stopNode);
        break;
      }
      if (m.hasProperty(""String_Node_Str"")) {
        System.out.println(m.getProperty(""String_Node_Str""));
      }
      graphPathToRoot.add(0,m);
    }
    if (graphPathToRoot.size() < 1) {
      throw new UnsupportedOperationException(""String_Node_Str"" + curTip + ""String_Node_Str"");
    }
    treeTipRootPathMap.put(curTip,graphPathToRoot);
  }
  return treeTipRootPathMap;
}"
50180,"/** 
 * Get a subtree out of the draft tree topology for the indicated tips.
 * @param tips
 * @return draftSubtree
 */
public JadeNode extractDraftSubtreeForTipNodes(Iterable<Node> tips){
  Map<Node,ArrayList<Node>> treeTipRootPathMap=getTreeTipRootPathMap(tips);
  HashMap<Node,JadeNode> graphNodeTreeNodeMap=new HashMap<Node,JadeNode>();
  HashMap<JadeNode,Node> treeNodeGraphNodeMap=new HashMap<JadeNode,Node>();
  HashMap<JadeNode,LinkedList<Node>> treeTipGraphMRCADescendantsMap=new HashMap<JadeNode,LinkedList<Node>>();
  for (  Node tipNode : treeTipRootPathMap.keySet()) {
    JadeNode treeTip=new JadeNode();
    treeTip.assocObject(""String_Node_Str"",tipNode);
    treeTip.setName((String)tipNode.getProperty(""String_Node_Str""));
    graphNodeTreeNodeMap.put(tipNode,treeTip);
    treeNodeGraphNodeMap.put(treeTip,tipNode);
    LinkedList<Node> tipDescendants=new LinkedList<Node>();
    for (    long nid : (long[])tipNode.getProperty(""String_Node_Str"")) {
      tipDescendants.add(graphDb.getNodeById(nid));
    }
    treeTipGraphMRCADescendantsMap.put(treeTip,tipDescendants);
  }
  HashMap<JadeNode,LinkedList<JadeNode>> treeNodeTreeTipDescendantsMap=new HashMap<JadeNode,LinkedList<JadeNode>>();
  LinkedList<JadeNode> stack=new LinkedList<JadeNode>();
  JadeNode root=new JadeNode();
  stack.add(root);
  treeNodeTreeTipDescendantsMap.put(root,new LinkedList<JadeNode>(graphNodeTreeNodeMap.values()));
  while (stack.size() > 0) {
    System.out.println(stack.size() + ""String_Node_Str"");
    JadeNode treeNode=stack.remove(0);
    LinkedList<Node> allDescendantGraphTips=new LinkedList<Node>();
    for (    JadeNode treeTip : treeNodeTreeTipDescendantsMap.get(treeNode)) {
      System.out.println(treeTip.getName());
      allDescendantGraphTips.addAll(treeTipGraphMRCADescendantsMap.get(treeTip));
    }
    Node graphNode=getDraftTreeMRCAForNodes(allDescendantGraphTips);
    treeNode.assocObject(""String_Node_Str"",graphNode);
    if (graphNode.hasProperty(""String_Node_Str"")) {
      treeNode.setName((String)graphNode.getProperty(""String_Node_Str""));
    }
    System.out.println(""String_Node_Str"" + treeNode.getName());
    HashMap<Node,LinkedList<JadeNode>> childNodeTreeTipDescendantsMap=new HashMap<Node,LinkedList<JadeNode>>();
    for (    JadeNode curDescendantTreeNode : treeNodeTreeTipDescendantsMap.get(treeNode)) {
      System.out.println(""String_Node_Str"" + curDescendantTreeNode.getName());
      Node curDescendantGraphNode=treeNodeGraphNodeMap.get(curDescendantTreeNode);
      Node curDeepestAncestor=null;
      if (treeTipRootPathMap.get(curDescendantGraphNode).size() > 0) {
        curDeepestAncestor=treeTipRootPathMap.get(curDescendantGraphNode).remove(0);
      }
 else {
        curDeepestAncestor=(Node)treeNode.getObject(""String_Node_Str"");
      }
      if (curDeepestAncestor.hasProperty(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"" + curDeepestAncestor.getProperty(""String_Node_Str""));
      }
      if (!childNodeTreeTipDescendantsMap.containsKey(curDeepestAncestor)) {
        childNodeTreeTipDescendantsMap.put(curDeepestAncestor,new LinkedList<JadeNode>());
      }
      childNodeTreeTipDescendantsMap.get(curDeepestAncestor).add(curDescendantTreeNode);
    }
    for (    Entry<Node,LinkedList<JadeNode>> childToAdd : childNodeTreeTipDescendantsMap.entrySet()) {
      LinkedList<JadeNode> childTreeTipDescendants=childToAdd.getValue();
      System.out.println(""String_Node_Str"");
      System.out.println(Arrays.toString(childTreeTipDescendants.toArray()));
      if (childTreeTipDescendants.size() == 1) {
        treeNode.addChild(childTreeTipDescendants.get(0));
        continue;
      }
      Node childGraphNode=childToAdd.getKey();
      JadeNode childTreeNode=new JadeNode();
      childTreeNode.assocObject(""String_Node_Str"",childGraphNode);
      if (childGraphNode.hasProperty(""String_Node_Str"")) {
        childTreeNode.setName((String)childGraphNode.getProperty(""String_Node_Str""));
      }
      if (childTreeTipDescendants.size() == 2) {
        for (        JadeNode treeTip : childTreeTipDescendants) {
          childTreeNode.addChild(treeTip);
        }
      }
 else {
        System.out.println(treeNode.getName() + ""String_Node_Str"");
        System.out.println(""String_Node_Str"");
        Node graphNodeForTip=treeNodeGraphNodeMap.get(childTreeTipDescendants.get(0));
        ArrayList<Node> startNodeAncestors=treeTipRootPathMap.get(graphNodeForTip);
        Node startShallowestAncestor=null;
        System.out.println(""String_Node_Str"");
        System.out.println(Arrays.toString(startNodeAncestors.toArray()));
        if (startNodeAncestors.size() > 0) {
          startShallowestAncestor=startNodeAncestors.get(startNodeAncestors.size() - 1);
        }
        boolean isPolytomy=true;
        for (        JadeNode treeTip : childTreeTipDescendants) {
          Node graphTip=treeNodeGraphNodeMap.get(treeTip);
          ArrayList<Node> curAncestors=treeTipRootPathMap.get(graphTip);
          Node curShallowestAncestor=curAncestors.get(curAncestors.size() - 1);
          if (!startShallowestAncestor.equals(curShallowestAncestor)) {
            stack.add(0,childTreeNode);
            treeNodeTreeTipDescendantsMap.put(childTreeNode,childTreeTipDescendants);
            isPolytomy=false;
            break;
          }
        }
        if (isPolytomy) {
          for (          JadeNode treeTip : childTreeTipDescendants) {
            childTreeNode.addChild(treeTip);
          }
        }
      }
      treeNode.addChild(childTreeNode);
    }
  }
  return root;
}","/** 
 * Get a subtree out of the draft tree topology for the indicated tips.
 * @param tips
 * @return draftSubtree
 */
public JadeNode extractDraftSubtreeForTipNodes(Iterable<Node> tips){
  Node mrca=getDraftTreeMRCAForNodes(tips);
  System.out.println(""String_Node_Str"" + mrca);
  Map<Node,ArrayList<Node>> treeTipToMRCAPathMap=getTreeTipRootPathMap(tips,mrca);
  HashMap<Node,JadeNode> graphNodeTreeNodeMap=new HashMap<Node,JadeNode>();
  HashMap<JadeNode,Node> treeNodeGraphNodeMap=new HashMap<JadeNode,Node>();
  HashMap<JadeNode,LinkedList<Node>> treeTipGraphMRCADescendantsMap=new HashMap<JadeNode,LinkedList<Node>>();
  for (  Node tipNode : treeTipToMRCAPathMap.keySet()) {
    JadeNode treeTip=new JadeNode();
    treeTip.assocObject(""String_Node_Str"",tipNode);
    treeTip.setName((String)tipNode.getProperty(""String_Node_Str""));
    graphNodeTreeNodeMap.put(tipNode,treeTip);
    treeNodeGraphNodeMap.put(treeTip,tipNode);
    LinkedList<Node> tipDescendants=new LinkedList<Node>();
    for (    long nid : (long[])tipNode.getProperty(""String_Node_Str"")) {
      tipDescendants.add(graphDb.getNodeById(nid));
    }
    treeTipGraphMRCADescendantsMap.put(treeTip,tipDescendants);
  }
  HashMap<JadeNode,LinkedList<JadeNode>> treeNodeTreeTipDescendantsMap=new HashMap<JadeNode,LinkedList<JadeNode>>();
  LinkedList<JadeNode> stack=new LinkedList<JadeNode>();
  JadeNode root=new JadeNode();
  stack.add(root);
  treeNodeTreeTipDescendantsMap.put(root,new LinkedList<JadeNode>(graphNodeTreeNodeMap.values()));
  while (stack.size() > 0) {
    System.out.println(stack.size() + ""String_Node_Str"");
    JadeNode treeNode=stack.remove(0);
    LinkedList<Node> allDescendantGraphTips=new LinkedList<Node>();
    for (    JadeNode treeTip : treeNodeTreeTipDescendantsMap.get(treeNode)) {
      System.out.println(treeTip.getName());
      allDescendantGraphTips.addAll(treeTipGraphMRCADescendantsMap.get(treeTip));
    }
    Node graphNode=getDraftTreeMRCAForNodes(allDescendantGraphTips);
    treeNode.assocObject(""String_Node_Str"",graphNode);
    if (graphNode.hasProperty(""String_Node_Str"")) {
      treeNode.setName((String)graphNode.getProperty(""String_Node_Str""));
    }
    System.out.println(""String_Node_Str"" + treeNode.getName());
    HashMap<Node,LinkedList<JadeNode>> childNodeTreeTipDescendantsMap=new HashMap<Node,LinkedList<JadeNode>>();
    for (    JadeNode curDescendantTreeNode : treeNodeTreeTipDescendantsMap.get(treeNode)) {
      System.out.println(""String_Node_Str"" + curDescendantTreeNode.getName());
      Node curDescendantGraphNode=treeNodeGraphNodeMap.get(curDescendantTreeNode);
      Node curDeepestAncestor=null;
      if (treeTipToMRCAPathMap.get(curDescendantGraphNode).size() > 0) {
        curDeepestAncestor=treeTipToMRCAPathMap.get(curDescendantGraphNode).remove(0);
      }
 else {
        curDeepestAncestor=(Node)treeNode.getObject(""String_Node_Str"");
      }
      if (curDeepestAncestor.hasProperty(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"" + curDeepestAncestor.getProperty(""String_Node_Str""));
      }
      if (!childNodeTreeTipDescendantsMap.containsKey(curDeepestAncestor)) {
        childNodeTreeTipDescendantsMap.put(curDeepestAncestor,new LinkedList<JadeNode>());
      }
      childNodeTreeTipDescendantsMap.get(curDeepestAncestor).add(curDescendantTreeNode);
    }
    for (    Entry<Node,LinkedList<JadeNode>> childToAdd : childNodeTreeTipDescendantsMap.entrySet()) {
      LinkedList<JadeNode> childTreeTipDescendants=childToAdd.getValue();
      System.out.println(""String_Node_Str"");
      System.out.println(Arrays.toString(childTreeTipDescendants.toArray()));
      if (childTreeTipDescendants.size() == 1) {
        treeNode.addChild(childTreeTipDescendants.get(0));
        continue;
      }
      Node childGraphNode=childToAdd.getKey();
      JadeNode childTreeNode=new JadeNode();
      childTreeNode.assocObject(""String_Node_Str"",childGraphNode);
      if (childGraphNode.hasProperty(""String_Node_Str"")) {
        childTreeNode.setName((String)childGraphNode.getProperty(""String_Node_Str""));
      }
      if (childTreeTipDescendants.size() == 2) {
        for (        JadeNode treeTip : childTreeTipDescendants) {
          childTreeNode.addChild(treeTip);
        }
      }
 else {
        System.out.println(treeNode.getName() + ""String_Node_Str"");
        System.out.println(""String_Node_Str"");
        Node graphNodeForTip=treeNodeGraphNodeMap.get(childTreeTipDescendants.get(0));
        ArrayList<Node> startNodeAncestors=treeTipToMRCAPathMap.get(graphNodeForTip);
        Node startShallowestAncestor=null;
        System.out.println(""String_Node_Str"");
        System.out.println(Arrays.toString(startNodeAncestors.toArray()));
        if (startNodeAncestors.size() > 0) {
          startShallowestAncestor=startNodeAncestors.get(startNodeAncestors.size() - 1);
        }
        boolean isPolytomy=true;
        for (        JadeNode treeTip : childTreeTipDescendants) {
          Node graphTip=treeNodeGraphNodeMap.get(treeTip);
          ArrayList<Node> curAncestors=treeTipToMRCAPathMap.get(graphTip);
          Node curShallowestAncestor=curAncestors.get(curAncestors.size() - 1);
          if (!startShallowestAncestor.equals(curShallowestAncestor)) {
            stack.add(0,childTreeNode);
            treeNodeTreeTipDescendantsMap.put(childTreeNode,childTreeTipDescendants);
            isPolytomy=false;
            break;
          }
        }
        if (isPolytomy) {
          for (          JadeNode treeTip : childTreeTipDescendants) {
            childTreeNode.addChild(treeTip);
          }
        }
      }
      treeNode.addChild(childTreeNode);
    }
  }
  return root;
}"
50181,"/** 
 * Get a subtree out of the draft tree topology for the indicated tips.
 * @param tips
 * @return draftSubtree
 */
public JadeNode extractDraftSubtreeForTipNodes(Iterable<Node> tips){
  Map<Node,ArrayList<Node>> treeTipRootPathMap=getTreeTipRootPathMap(tips);
  HashMap<Node,JadeNode> graphNodeTreeNodeMap=new HashMap<Node,JadeNode>();
  HashMap<JadeNode,Node> treeNodeGraphNodeMap=new HashMap<JadeNode,Node>();
  HashMap<JadeNode,LinkedList<Node>> treeTipGraphMRCADescendantsMap=new HashMap<JadeNode,LinkedList<Node>>();
  for (  Node tipNode : treeTipRootPathMap.keySet()) {
    JadeNode treeTip=new JadeNode();
    treeTip.assocObject(""String_Node_Str"",tipNode);
    treeTip.setName((String)tipNode.getProperty(""String_Node_Str""));
    graphNodeTreeNodeMap.put(tipNode,treeTip);
    treeNodeGraphNodeMap.put(treeTip,tipNode);
    LinkedList<Node> tipDescendants=new LinkedList<Node>();
    for (    long nid : (long[])tipNode.getProperty(""String_Node_Str"")) {
      tipDescendants.add(graphDb.getNodeById(nid));
    }
    treeTipGraphMRCADescendantsMap.put(treeTip,tipDescendants);
  }
  HashMap<JadeNode,LinkedList<JadeNode>> treeNodeTreeTipDescendantsMap=new HashMap<JadeNode,LinkedList<JadeNode>>();
  LinkedList<JadeNode> stack=new LinkedList<JadeNode>();
  JadeNode root=new JadeNode();
  stack.add(root);
  treeNodeTreeTipDescendantsMap.put(root,new LinkedList<JadeNode>(graphNodeTreeNodeMap.values()));
  while (stack.size() > 0) {
    System.out.println(stack.size() + ""String_Node_Str"");
    JadeNode treeNode=stack.remove(0);
    LinkedList<Node> allDescendantGraphTips=new LinkedList<Node>();
    for (    JadeNode treeTip : treeNodeTreeTipDescendantsMap.get(treeNode)) {
      System.out.println(treeTip.getName());
      allDescendantGraphTips.addAll(treeTipGraphMRCADescendantsMap.get(treeTip));
    }
    Node graphNode=getDraftTreeMRCAForNodes(allDescendantGraphTips);
    treeNode.assocObject(""String_Node_Str"",graphNode);
    if (graphNode.hasProperty(""String_Node_Str"")) {
      treeNode.setName((String)graphNode.getProperty(""String_Node_Str""));
    }
    System.out.println(""String_Node_Str"" + treeNode.getName());
    HashMap<Node,LinkedList<JadeNode>> childNodeTreeTipDescendantsMap=new HashMap<Node,LinkedList<JadeNode>>();
    for (    JadeNode curDescendantTreeNode : treeNodeTreeTipDescendantsMap.get(treeNode)) {
      System.out.println(""String_Node_Str"" + curDescendantTreeNode.getName());
      Node curDescendantGraphNode=treeNodeGraphNodeMap.get(curDescendantTreeNode);
      Node curDeepestAncestor=null;
      if (treeTipRootPathMap.get(curDescendantGraphNode).size() > 0) {
        curDeepestAncestor=treeTipRootPathMap.get(curDescendantGraphNode).remove(0);
      }
 else {
        curDeepestAncestor=(Node)treeNode.getObject(""String_Node_Str"");
      }
      if (curDeepestAncestor.hasProperty(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"" + curDeepestAncestor.getProperty(""String_Node_Str""));
      }
      if (!childNodeTreeTipDescendantsMap.containsKey(curDeepestAncestor)) {
        childNodeTreeTipDescendantsMap.put(curDeepestAncestor,new LinkedList<JadeNode>());
      }
      childNodeTreeTipDescendantsMap.get(curDeepestAncestor).add(curDescendantTreeNode);
    }
    for (    Entry<Node,LinkedList<JadeNode>> childToAdd : childNodeTreeTipDescendantsMap.entrySet()) {
      LinkedList<JadeNode> childTreeTipDescendants=childToAdd.getValue();
      if (childTreeTipDescendants.size() == 1) {
        treeNode.addChild(childTreeTipDescendants.get(0));
        continue;
      }
      Node childGraphNode=childToAdd.getKey();
      JadeNode childTreeNode=new JadeNode();
      childTreeNode.assocObject(""String_Node_Str"",childGraphNode);
      if (childGraphNode.hasProperty(""String_Node_Str"")) {
        childTreeNode.setName((String)childGraphNode.getProperty(""String_Node_Str""));
      }
      if (childTreeTipDescendants.size() == 2) {
        for (        JadeNode treeTip : childTreeTipDescendants) {
          childTreeNode.addChild(treeTip);
        }
      }
 else {
        System.out.println(treeNode.getName() + ""String_Node_Str"");
        ArrayList<Node> startNodeAncestors=treeTipRootPathMap.get(childTreeTipDescendants.get(0));
        Node startShallowestAncestor=null;
        if (startNodeAncestors != null && startNodeAncestors.size() > 0) {
          startShallowestAncestor=startNodeAncestors.get(startNodeAncestors.size() - 1);
        }
        boolean isPolytomy=true;
        for (        JadeNode treeTip : childTreeTipDescendants) {
          ArrayList<Node> curAncestors=treeTipRootPathMap.get(treeTip);
          Node curShallowestAncestor=curAncestors.get(curAncestors.size() - 1);
          if (!startShallowestAncestor.equals(curShallowestAncestor)) {
            stack.add(0,childTreeNode);
            treeNodeTreeTipDescendantsMap.put(childTreeNode,childTreeTipDescendants);
            isPolytomy=false;
            break;
          }
        }
        if (isPolytomy) {
          for (          JadeNode treeTip : childTreeTipDescendants) {
            childTreeNode.addChild(treeTip);
          }
        }
      }
      treeNode.addChild(childTreeNode);
    }
  }
  return root;
}","/** 
 * Get a subtree out of the draft tree topology for the indicated tips.
 * @param tips
 * @return draftSubtree
 */
public JadeNode extractDraftSubtreeForTipNodes(Iterable<Node> tips){
  Map<Node,ArrayList<Node>> treeTipRootPathMap=getTreeTipRootPathMap(tips);
  HashMap<Node,JadeNode> graphNodeTreeNodeMap=new HashMap<Node,JadeNode>();
  HashMap<JadeNode,Node> treeNodeGraphNodeMap=new HashMap<JadeNode,Node>();
  HashMap<JadeNode,LinkedList<Node>> treeTipGraphMRCADescendantsMap=new HashMap<JadeNode,LinkedList<Node>>();
  for (  Node tipNode : treeTipRootPathMap.keySet()) {
    JadeNode treeTip=new JadeNode();
    treeTip.assocObject(""String_Node_Str"",tipNode);
    treeTip.setName((String)tipNode.getProperty(""String_Node_Str""));
    graphNodeTreeNodeMap.put(tipNode,treeTip);
    treeNodeGraphNodeMap.put(treeTip,tipNode);
    LinkedList<Node> tipDescendants=new LinkedList<Node>();
    for (    long nid : (long[])tipNode.getProperty(""String_Node_Str"")) {
      tipDescendants.add(graphDb.getNodeById(nid));
    }
    treeTipGraphMRCADescendantsMap.put(treeTip,tipDescendants);
  }
  HashMap<JadeNode,LinkedList<JadeNode>> treeNodeTreeTipDescendantsMap=new HashMap<JadeNode,LinkedList<JadeNode>>();
  LinkedList<JadeNode> stack=new LinkedList<JadeNode>();
  JadeNode root=new JadeNode();
  stack.add(root);
  treeNodeTreeTipDescendantsMap.put(root,new LinkedList<JadeNode>(graphNodeTreeNodeMap.values()));
  while (stack.size() > 0) {
    System.out.println(stack.size() + ""String_Node_Str"");
    JadeNode treeNode=stack.remove(0);
    LinkedList<Node> allDescendantGraphTips=new LinkedList<Node>();
    for (    JadeNode treeTip : treeNodeTreeTipDescendantsMap.get(treeNode)) {
      System.out.println(treeTip.getName());
      allDescendantGraphTips.addAll(treeTipGraphMRCADescendantsMap.get(treeTip));
    }
    Node graphNode=getDraftTreeMRCAForNodes(allDescendantGraphTips);
    treeNode.assocObject(""String_Node_Str"",graphNode);
    if (graphNode.hasProperty(""String_Node_Str"")) {
      treeNode.setName((String)graphNode.getProperty(""String_Node_Str""));
    }
    System.out.println(""String_Node_Str"" + treeNode.getName());
    HashMap<Node,LinkedList<JadeNode>> childNodeTreeTipDescendantsMap=new HashMap<Node,LinkedList<JadeNode>>();
    for (    JadeNode curDescendantTreeNode : treeNodeTreeTipDescendantsMap.get(treeNode)) {
      System.out.println(""String_Node_Str"" + curDescendantTreeNode.getName());
      Node curDescendantGraphNode=treeNodeGraphNodeMap.get(curDescendantTreeNode);
      Node curDeepestAncestor=null;
      if (treeTipRootPathMap.get(curDescendantGraphNode).size() > 0) {
        curDeepestAncestor=treeTipRootPathMap.get(curDescendantGraphNode).remove(0);
      }
 else {
        curDeepestAncestor=(Node)treeNode.getObject(""String_Node_Str"");
      }
      if (curDeepestAncestor.hasProperty(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"" + curDeepestAncestor.getProperty(""String_Node_Str""));
      }
      if (!childNodeTreeTipDescendantsMap.containsKey(curDeepestAncestor)) {
        childNodeTreeTipDescendantsMap.put(curDeepestAncestor,new LinkedList<JadeNode>());
      }
      childNodeTreeTipDescendantsMap.get(curDeepestAncestor).add(curDescendantTreeNode);
    }
    for (    Entry<Node,LinkedList<JadeNode>> childToAdd : childNodeTreeTipDescendantsMap.entrySet()) {
      LinkedList<JadeNode> childTreeTipDescendants=childToAdd.getValue();
      System.out.println(""String_Node_Str"");
      System.out.println(Arrays.toString(childTreeTipDescendants.toArray()));
      if (childTreeTipDescendants.size() == 1) {
        treeNode.addChild(childTreeTipDescendants.get(0));
        continue;
      }
      Node childGraphNode=childToAdd.getKey();
      JadeNode childTreeNode=new JadeNode();
      childTreeNode.assocObject(""String_Node_Str"",childGraphNode);
      if (childGraphNode.hasProperty(""String_Node_Str"")) {
        childTreeNode.setName((String)childGraphNode.getProperty(""String_Node_Str""));
      }
      if (childTreeTipDescendants.size() == 2) {
        for (        JadeNode treeTip : childTreeTipDescendants) {
          childTreeNode.addChild(treeTip);
        }
      }
 else {
        System.out.println(treeNode.getName() + ""String_Node_Str"");
        System.out.println(""String_Node_Str"");
        Node graphNodeForTip=treeNodeGraphNodeMap.get(childTreeTipDescendants.get(0));
        ArrayList<Node> startNodeAncestors=treeTipRootPathMap.get(graphNodeForTip);
        Node startShallowestAncestor=null;
        System.out.println(""String_Node_Str"");
        System.out.println(Arrays.toString(startNodeAncestors.toArray()));
        if (startNodeAncestors.size() > 0) {
          startShallowestAncestor=startNodeAncestors.get(startNodeAncestors.size() - 1);
        }
        boolean isPolytomy=true;
        for (        JadeNode treeTip : childTreeTipDescendants) {
          Node graphTip=treeNodeGraphNodeMap.get(treeTip);
          ArrayList<Node> curAncestors=treeTipRootPathMap.get(graphTip);
          Node curShallowestAncestor=curAncestors.get(curAncestors.size() - 1);
          if (!startShallowestAncestor.equals(curShallowestAncestor)) {
            stack.add(0,childTreeNode);
            treeNodeTreeTipDescendantsMap.put(childTreeNode,childTreeTipDescendants);
            isPolytomy=false;
            break;
          }
        }
        if (isPolytomy) {
          for (          JadeNode treeTip : childTreeTipDescendants) {
            childTreeNode.addChild(treeTip);
          }
        }
      }
      treeNode.addChild(childTreeNode);
    }
  }
  return root;
}"
50182,"/** 
 * Get a subtree out of the draft tree topology for the indicated tips.
 * @param tips
 * @return draftSubtree
 */
public JadeNode extractDraftSubtreeForTipNodes(Iterable<Node> tips){
  Map<Node,ArrayList<Node>> treeTipRootPathMap=getTreeTipRootPathMap(tips);
  HashMap<Node,JadeNode> graphNodeTreeNodeMap=new HashMap<Node,JadeNode>();
  HashMap<JadeNode,Node> treeNodeGraphNodeMap=new HashMap<JadeNode,Node>();
  HashMap<JadeNode,LinkedList<Node>> treeTipGraphMRCADescendantsMap=new HashMap<JadeNode,LinkedList<Node>>();
  for (  Node tipNode : treeTipRootPathMap.keySet()) {
    JadeNode treeTip=new JadeNode();
    treeTip.assocObject(""String_Node_Str"",tipNode);
    treeTip.setName((String)tipNode.getProperty(""String_Node_Str""));
    graphNodeTreeNodeMap.put(tipNode,treeTip);
    treeNodeGraphNodeMap.put(treeTip,tipNode);
    LinkedList<Node> tipDescendants=new LinkedList<Node>();
    for (    long nid : (long[])tipNode.getProperty(""String_Node_Str"")) {
      tipDescendants.add(graphDb.getNodeById(nid));
    }
    treeTipGraphMRCADescendantsMap.put(treeTip,tipDescendants);
  }
  HashMap<JadeNode,LinkedList<JadeNode>> treeNodeTreeTipDescendantsMap=new HashMap<JadeNode,LinkedList<JadeNode>>();
  LinkedList<JadeNode> stack=new LinkedList<JadeNode>();
  JadeNode root=new JadeNode();
  stack.add(root);
  treeNodeTreeTipDescendantsMap.put(root,new LinkedList<JadeNode>(graphNodeTreeNodeMap.values()));
  while (stack.size() > 0) {
    System.out.println(stack.size() + ""String_Node_Str"");
    JadeNode treeNode=stack.remove(0);
    LinkedList<Node> allDescendantGraphTips=new LinkedList<Node>();
    for (    JadeNode treeTip : treeNodeTreeTipDescendantsMap.get(treeNode)) {
      System.out.println(treeTip.getName());
      allDescendantGraphTips.addAll(treeTipGraphMRCADescendantsMap.get(treeTip));
    }
    Node graphNode=LicaUtil.getDraftTreeLICA(allDescendantGraphTips);
    treeNode.assocObject(""String_Node_Str"",graphNode);
    if (graphNode.hasProperty(""String_Node_Str"")) {
      treeNode.setName((String)graphNode.getProperty(""String_Node_Str""));
    }
    System.out.println(""String_Node_Str"" + treeNode.getName());
    HashMap<Node,LinkedList<JadeNode>> childNodeTreeTipDescendantsMap=new HashMap<Node,LinkedList<JadeNode>>();
    for (    JadeNode curDescendantTreeNode : treeNodeTreeTipDescendantsMap.get(treeNode)) {
      System.out.println(""String_Node_Str"" + curDescendantTreeNode.getName());
      Node curDescendantGraphNode=treeNodeGraphNodeMap.get(curDescendantTreeNode);
      Node curDeepestAncestor=null;
      if (treeTipRootPathMap.get(curDescendantGraphNode).size() > 0) {
        curDeepestAncestor=treeTipRootPathMap.get(curDescendantGraphNode).remove(0);
      }
 else {
        curDeepestAncestor=(Node)treeNode.getObject(""String_Node_Str"");
      }
      if (curDeepestAncestor.hasProperty(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"" + curDeepestAncestor.getProperty(""String_Node_Str""));
      }
      if (!childNodeTreeTipDescendantsMap.containsKey(curDeepestAncestor)) {
        childNodeTreeTipDescendantsMap.put(curDeepestAncestor,new LinkedList<JadeNode>());
      }
      childNodeTreeTipDescendantsMap.get(curDeepestAncestor).add(curDescendantTreeNode);
    }
    for (    Entry<Node,LinkedList<JadeNode>> childToAdd : childNodeTreeTipDescendantsMap.entrySet()) {
      LinkedList<JadeNode> childTreeTipDescendants=childToAdd.getValue();
      if (childTreeTipDescendants.size() == 1) {
        treeNode.addChild(childTreeTipDescendants.get(0));
        continue;
      }
      Node childGraphNode=childToAdd.getKey();
      JadeNode childTreeNode=new JadeNode();
      childTreeNode.assocObject(""String_Node_Str"",childGraphNode);
      if (childGraphNode.hasProperty(""String_Node_Str"")) {
        childTreeNode.setName((String)childGraphNode.getProperty(""String_Node_Str""));
      }
      if (childTreeTipDescendants.size() == 2) {
        for (        JadeNode treeTip : childTreeTipDescendants) {
          childTreeNode.addChild(treeTip);
        }
      }
 else {
        System.out.println(treeNode.getName() + ""String_Node_Str"");
        ArrayList<Node> startNodeAncestors=treeTipRootPathMap.get(childTreeTipDescendants.get(0));
        Node startShallowestAncestor=null;
        if (startNodeAncestors.size() > 0) {
          startShallowestAncestor=startNodeAncestors.get(startNodeAncestors.size() - 1);
        }
        boolean isPolytomy=true;
        for (        JadeNode treeTip : childTreeTipDescendants) {
          ArrayList<Node> curAncestors=treeTipRootPathMap.get(treeTip);
          Node curShallowestAncestor=curAncestors.get(curAncestors.size() - 1);
          if (!startShallowestAncestor.equals(curShallowestAncestor)) {
            stack.add(0,childTreeNode);
            treeNodeTreeTipDescendantsMap.put(childTreeNode,childTreeTipDescendants);
            isPolytomy=false;
            break;
          }
        }
        if (isPolytomy) {
          for (          JadeNode treeTip : childTreeTipDescendants) {
            childTreeNode.addChild(treeTip);
          }
        }
      }
      treeNode.addChild(childTreeNode);
    }
  }
  return root;
}","/** 
 * Get a subtree out of the draft tree topology for the indicated tips.
 * @param tips
 * @return draftSubtree
 */
public JadeNode extractDraftSubtreeForTipNodes(Iterable<Node> tips){
  Map<Node,ArrayList<Node>> treeTipRootPathMap=getTreeTipRootPathMap(tips);
  HashMap<Node,JadeNode> graphNodeTreeNodeMap=new HashMap<Node,JadeNode>();
  HashMap<JadeNode,Node> treeNodeGraphNodeMap=new HashMap<JadeNode,Node>();
  HashMap<JadeNode,LinkedList<Node>> treeTipGraphMRCADescendantsMap=new HashMap<JadeNode,LinkedList<Node>>();
  for (  Node tipNode : treeTipRootPathMap.keySet()) {
    JadeNode treeTip=new JadeNode();
    treeTip.assocObject(""String_Node_Str"",tipNode);
    treeTip.setName((String)tipNode.getProperty(""String_Node_Str""));
    graphNodeTreeNodeMap.put(tipNode,treeTip);
    treeNodeGraphNodeMap.put(treeTip,tipNode);
    LinkedList<Node> tipDescendants=new LinkedList<Node>();
    for (    long nid : (long[])tipNode.getProperty(""String_Node_Str"")) {
      tipDescendants.add(graphDb.getNodeById(nid));
    }
    treeTipGraphMRCADescendantsMap.put(treeTip,tipDescendants);
  }
  HashMap<JadeNode,LinkedList<JadeNode>> treeNodeTreeTipDescendantsMap=new HashMap<JadeNode,LinkedList<JadeNode>>();
  LinkedList<JadeNode> stack=new LinkedList<JadeNode>();
  JadeNode root=new JadeNode();
  stack.add(root);
  treeNodeTreeTipDescendantsMap.put(root,new LinkedList<JadeNode>(graphNodeTreeNodeMap.values()));
  while (stack.size() > 0) {
    System.out.println(stack.size() + ""String_Node_Str"");
    JadeNode treeNode=stack.remove(0);
    LinkedList<Node> allDescendantGraphTips=new LinkedList<Node>();
    for (    JadeNode treeTip : treeNodeTreeTipDescendantsMap.get(treeNode)) {
      System.out.println(treeTip.getName());
      allDescendantGraphTips.addAll(treeTipGraphMRCADescendantsMap.get(treeTip));
    }
    Node graphNode=getDraftTreeMRCAForNodes(allDescendantGraphTips);
    treeNode.assocObject(""String_Node_Str"",graphNode);
    if (graphNode.hasProperty(""String_Node_Str"")) {
      treeNode.setName((String)graphNode.getProperty(""String_Node_Str""));
    }
    System.out.println(""String_Node_Str"" + treeNode.getName());
    HashMap<Node,LinkedList<JadeNode>> childNodeTreeTipDescendantsMap=new HashMap<Node,LinkedList<JadeNode>>();
    for (    JadeNode curDescendantTreeNode : treeNodeTreeTipDescendantsMap.get(treeNode)) {
      System.out.println(""String_Node_Str"" + curDescendantTreeNode.getName());
      Node curDescendantGraphNode=treeNodeGraphNodeMap.get(curDescendantTreeNode);
      Node curDeepestAncestor=null;
      if (treeTipRootPathMap.get(curDescendantGraphNode).size() > 0) {
        curDeepestAncestor=treeTipRootPathMap.get(curDescendantGraphNode).remove(0);
      }
 else {
        curDeepestAncestor=(Node)treeNode.getObject(""String_Node_Str"");
      }
      if (curDeepestAncestor.hasProperty(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"" + curDeepestAncestor.getProperty(""String_Node_Str""));
      }
      if (!childNodeTreeTipDescendantsMap.containsKey(curDeepestAncestor)) {
        childNodeTreeTipDescendantsMap.put(curDeepestAncestor,new LinkedList<JadeNode>());
      }
      childNodeTreeTipDescendantsMap.get(curDeepestAncestor).add(curDescendantTreeNode);
    }
    for (    Entry<Node,LinkedList<JadeNode>> childToAdd : childNodeTreeTipDescendantsMap.entrySet()) {
      LinkedList<JadeNode> childTreeTipDescendants=childToAdd.getValue();
      if (childTreeTipDescendants.size() == 1) {
        treeNode.addChild(childTreeTipDescendants.get(0));
        continue;
      }
      Node childGraphNode=childToAdd.getKey();
      JadeNode childTreeNode=new JadeNode();
      childTreeNode.assocObject(""String_Node_Str"",childGraphNode);
      if (childGraphNode.hasProperty(""String_Node_Str"")) {
        childTreeNode.setName((String)childGraphNode.getProperty(""String_Node_Str""));
      }
      if (childTreeTipDescendants.size() == 2) {
        for (        JadeNode treeTip : childTreeTipDescendants) {
          childTreeNode.addChild(treeTip);
        }
      }
 else {
        System.out.println(treeNode.getName() + ""String_Node_Str"");
        ArrayList<Node> startNodeAncestors=treeTipRootPathMap.get(childTreeTipDescendants.get(0));
        Node startShallowestAncestor=null;
        if (startNodeAncestors.size() > 0) {
          startShallowestAncestor=startNodeAncestors.get(startNodeAncestors.size() - 1);
        }
        boolean isPolytomy=true;
        for (        JadeNode treeTip : childTreeTipDescendants) {
          ArrayList<Node> curAncestors=treeTipRootPathMap.get(treeTip);
          Node curShallowestAncestor=curAncestors.get(curAncestors.size() - 1);
          if (!startShallowestAncestor.equals(curShallowestAncestor)) {
            stack.add(0,childTreeNode);
            treeNodeTreeTipDescendantsMap.put(childTreeNode,childTreeTipDescendants);
            isPolytomy=false;
            break;
          }
        }
        if (isPolytomy) {
          for (          JadeNode treeTip : childTreeTipDescendants) {
            childTreeNode.addChild(treeTip);
          }
        }
      }
      treeNode.addChild(childTreeNode);
    }
  }
  return root;
}"
50183,"/** 
 * Internal method to get an array of arrays representing the rootward paths of a given set of nodes, used to calculate mrca and associated procedures. stopNode allows to set an mrca beyond which the traversal won't record the path.
 * @param tips
 * @param stopNode
 * @return
 */
private Map<Node,ArrayList<Node>> getTreeTipRootPathMap(Iterable<Node> tips,Node stopNode){
  if (stopNode != null) {
    System.out.println(""String_Node_Str"" + stopNode);
  }
  HashMap<Node,ArrayList<Node>> treeTipRootPathMap=new HashMap<Node,ArrayList<Node>>();
  for (  Node curTip : tips) {
    System.out.println(""String_Node_Str"" + curTip + (curTip.hasProperty(""String_Node_Str"") ? curTip.getProperty(""String_Node_Str"") : ""String_Node_Str""));
    ArrayList<Node> graphPathToRoot=new ArrayList<Node>();
    for (    Node m : Traversal.description().expand(new DraftTreePathExpander(Direction.OUTGOING)).traverse(curTip).nodes()) {
      if (stopNode != null && m.equals(stopNode)) {
        System.out.println(""String_Node_Str"" + stopNode);
        break;
      }
      if (m.hasProperty(""String_Node_Str"")) {
        System.out.println(m.getProperty(""String_Node_Str""));
      }
      graphPathToRoot.add(0,m);
    }
    if (graphPathToRoot.size() < 1) {
      throw new UnsupportedOperationException(""String_Node_Str"" + curTip + ""String_Node_Str"");
    }
    treeTipRootPathMap.put(curTip,graphPathToRoot);
  }
  return treeTipRootPathMap;
}","/** 
 * Internal method to get an array of arrays representing the rootward paths of a given set of nodes, used to calculate mrca and associated procedures. stopNode allows to set an mrca beyond which the traversal won't record the path.
 * @param tips
 * @param stopNode
 * @return
 */
private Map<Node,ArrayList<Node>> getTreeTipRootPathMap(Iterable<Node> tips,Node stopNode){
  if (stopNode != null) {
    System.out.println(""String_Node_Str"" + stopNode);
  }
  HashMap<Node,ArrayList<Node>> treeTipRootPathMap=new HashMap<Node,ArrayList<Node>>();
  for (  Node curTip : tips) {
    ArrayList<Node> graphPathToRoot=new ArrayList<Node>();
    for (    Node m : Traversal.description().expand(new DraftTreePathExpander(Direction.OUTGOING)).traverse(curTip).nodes()) {
      if (stopNode != null && m.equals(stopNode)) {
        break;
      }
      graphPathToRoot.add(0,m);
    }
    if (graphPathToRoot.size() < 1) {
      throw new UnsupportedOperationException(""String_Node_Str"" + curTip + ""String_Node_Str"");
    }
    treeTipRootPathMap.put(curTip,graphPathToRoot);
  }
  return treeTipRootPathMap;
}"
50184,"/** 
 * Get a subtree out of the draft tree topology for the indicated tips.
 * @param tips
 * @return draftSubtree
 */
public JadeNode extractDraftSubtreeForTipNodes(Iterable<Node> tips){
  Node mrca=getDraftTreeMRCAForNodes(tips);
  System.out.println(""String_Node_Str"" + mrca);
  Map<Node,ArrayList<Node>> treeTipToMRCAPathMap=getTreeTipRootPathMap(tips,mrca);
  HashMap<Node,JadeNode> graphNodeTreeNodeMap=new HashMap<Node,JadeNode>();
  HashMap<JadeNode,Node> treeNodeGraphNodeMap=new HashMap<JadeNode,Node>();
  HashMap<JadeNode,LinkedList<Node>> treeTipGraphMRCADescendantsMap=new HashMap<JadeNode,LinkedList<Node>>();
  for (  Node tipNode : treeTipToMRCAPathMap.keySet()) {
    JadeNode treeTip=new JadeNode();
    treeTip.assocObject(""String_Node_Str"",tipNode);
    treeTip.setName((String)tipNode.getProperty(""String_Node_Str""));
    graphNodeTreeNodeMap.put(tipNode,treeTip);
    treeNodeGraphNodeMap.put(treeTip,tipNode);
    LinkedList<Node> tipDescendants=new LinkedList<Node>();
    for (    long nid : (long[])tipNode.getProperty(""String_Node_Str"")) {
      tipDescendants.add(graphDb.getNodeById(nid));
    }
    treeTipGraphMRCADescendantsMap.put(treeTip,tipDescendants);
  }
  HashMap<JadeNode,LinkedList<JadeNode>> treeNodeTreeTipDescendantsMap=new HashMap<JadeNode,LinkedList<JadeNode>>();
  LinkedList<JadeNode> stack=new LinkedList<JadeNode>();
  JadeNode root=new JadeNode();
  stack.add(root);
  treeNodeTreeTipDescendantsMap.put(root,new LinkedList<JadeNode>(graphNodeTreeNodeMap.values()));
  while (stack.size() > 0) {
    System.out.println(stack.size() + ""String_Node_Str"");
    JadeNode treeNode=stack.remove(0);
    LinkedList<Node> allDescendantGraphTips=new LinkedList<Node>();
    for (    JadeNode treeTip : treeNodeTreeTipDescendantsMap.get(treeNode)) {
      System.out.println(treeTip.getName());
      allDescendantGraphTips.addAll(treeTipGraphMRCADescendantsMap.get(treeTip));
    }
    Node graphNode=getDraftTreeMRCAForNodes(allDescendantGraphTips);
    treeNode.assocObject(""String_Node_Str"",graphNode);
    if (graphNode.hasProperty(""String_Node_Str"")) {
      treeNode.setName((String)graphNode.getProperty(""String_Node_Str""));
    }
    System.out.println(""String_Node_Str"" + treeNode.getName());
    HashMap<Node,LinkedList<JadeNode>> childNodeTreeTipDescendantsMap=new HashMap<Node,LinkedList<JadeNode>>();
    for (    JadeNode curDescendantTreeNode : treeNodeTreeTipDescendantsMap.get(treeNode)) {
      System.out.println(""String_Node_Str"" + curDescendantTreeNode.getName());
      Node curDescendantGraphNode=treeNodeGraphNodeMap.get(curDescendantTreeNode);
      Node curDeepestAncestor=null;
      if (treeTipToMRCAPathMap.get(curDescendantGraphNode).size() > 0) {
        curDeepestAncestor=treeTipToMRCAPathMap.get(curDescendantGraphNode).remove(0);
      }
 else {
        curDeepestAncestor=(Node)treeNode.getObject(""String_Node_Str"");
      }
      if (curDeepestAncestor.hasProperty(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"" + curDeepestAncestor.getProperty(""String_Node_Str""));
      }
      if (!childNodeTreeTipDescendantsMap.containsKey(curDeepestAncestor)) {
        childNodeTreeTipDescendantsMap.put(curDeepestAncestor,new LinkedList<JadeNode>());
      }
      childNodeTreeTipDescendantsMap.get(curDeepestAncestor).add(curDescendantTreeNode);
    }
    for (    Entry<Node,LinkedList<JadeNode>> childToAdd : childNodeTreeTipDescendantsMap.entrySet()) {
      LinkedList<JadeNode> childTreeTipDescendants=childToAdd.getValue();
      System.out.println(""String_Node_Str"");
      System.out.println(Arrays.toString(childTreeTipDescendants.toArray()));
      if (childTreeTipDescendants.size() == 1) {
        treeNode.addChild(childTreeTipDescendants.get(0));
        continue;
      }
      Node childGraphNode=childToAdd.getKey();
      JadeNode childTreeNode=new JadeNode();
      childTreeNode.assocObject(""String_Node_Str"",childGraphNode);
      if (childGraphNode.hasProperty(""String_Node_Str"")) {
        childTreeNode.setName((String)childGraphNode.getProperty(""String_Node_Str""));
      }
      if (childTreeTipDescendants.size() == 2) {
        for (        JadeNode treeTip : childTreeTipDescendants) {
          childTreeNode.addChild(treeTip);
        }
      }
 else {
        System.out.println(treeNode.getName() + ""String_Node_Str"");
        System.out.println(""String_Node_Str"");
        Node graphNodeForTip=treeNodeGraphNodeMap.get(childTreeTipDescendants.get(0));
        ArrayList<Node> startNodeAncestors=treeTipToMRCAPathMap.get(graphNodeForTip);
        Node startShallowestAncestor=null;
        System.out.println(""String_Node_Str"");
        System.out.println(Arrays.toString(startNodeAncestors.toArray()));
        if (startNodeAncestors.size() > 0) {
          startShallowestAncestor=startNodeAncestors.get(startNodeAncestors.size() - 1);
        }
        boolean isPolytomy=true;
        for (        JadeNode treeTip : childTreeTipDescendants) {
          Node graphTip=treeNodeGraphNodeMap.get(treeTip);
          ArrayList<Node> curAncestors=treeTipToMRCAPathMap.get(graphTip);
          Node curShallowestAncestor=curAncestors.get(curAncestors.size() - 1);
          if (!startShallowestAncestor.equals(curShallowestAncestor)) {
            stack.add(0,childTreeNode);
            treeNodeTreeTipDescendantsMap.put(childTreeNode,childTreeTipDescendants);
            isPolytomy=false;
            break;
          }
        }
        if (isPolytomy) {
          for (          JadeNode treeTip : childTreeTipDescendants) {
            childTreeNode.addChild(treeTip);
          }
        }
      }
      treeNode.addChild(childTreeNode);
    }
  }
  return root;
}","/** 
 * Get a subtree out of the draft tree topology for the indicated tips.
 * @param tips
 * @return draftSubtree
 */
public JadeNode extractDraftSubtreeForTipNodes(Iterable<Node> tips){
  Node mrca=getDraftTreeMRCAForNodes(tips);
  System.out.println(""String_Node_Str"" + mrca);
  Map<Node,ArrayList<Node>> treeTipToMRCAPathMap=getTreeTipRootPathMap(tips,mrca);
  HashMap<Node,JadeNode> graphNodeTreeNodeMap=new HashMap<Node,JadeNode>();
  HashMap<JadeNode,Node> treeNodeGraphNodeMap=new HashMap<JadeNode,Node>();
  HashMap<JadeNode,LinkedList<Node>> treeTipGraphMRCADescendantsMap=new HashMap<JadeNode,LinkedList<Node>>();
  for (  Node tipNode : treeTipToMRCAPathMap.keySet()) {
    JadeNode treeTip=new JadeNode();
    treeTip.assocObject(""String_Node_Str"",tipNode);
    treeTip.setName((String)tipNode.getProperty(""String_Node_Str""));
    graphNodeTreeNodeMap.put(tipNode,treeTip);
    treeNodeGraphNodeMap.put(treeTip,tipNode);
    LinkedList<Node> tipDescendants=new LinkedList<Node>();
    for (    long nid : (long[])tipNode.getProperty(""String_Node_Str"")) {
      tipDescendants.add(graphDb.getNodeById(nid));
    }
    treeTipGraphMRCADescendantsMap.put(treeTip,tipDescendants);
  }
  HashMap<JadeNode,LinkedList<JadeNode>> treeNodeTreeTipDescendantsMap=new HashMap<JadeNode,LinkedList<JadeNode>>();
  LinkedList<JadeNode> stack=new LinkedList<JadeNode>();
  JadeNode root=new JadeNode();
  stack.add(root);
  System.out.println(""String_Node_Str"");
  treeNodeTreeTipDescendantsMap.put(root,new LinkedList<JadeNode>(graphNodeTreeNodeMap.values()));
  while (stack.size() > 0) {
    System.out.println(stack.size() + ""String_Node_Str"");
    System.out.println(""String_Node_Str"" + root.getNewick(false) + ""String_Node_Str"");
    JadeNode treeNode=stack.remove(0);
    System.out.println(""String_Node_Str"" + treeNode.getName() + ""String_Node_Str"");
    LinkedList<Node> allDescendantGraphTips=new LinkedList<Node>();
    for (    JadeNode treeTip : treeNodeTreeTipDescendantsMap.get(treeNode)) {
      allDescendantGraphTips.addAll(treeTipGraphMRCADescendantsMap.get(treeTip));
    }
    Node graphNode=getDraftTreeMRCAForNodes(allDescendantGraphTips);
    treeNode.assocObject(""String_Node_Str"",graphNode);
    if (graphNode.hasProperty(""String_Node_Str"")) {
      treeNode.setName((String)graphNode.getProperty(""String_Node_Str""));
    }
    System.out.println(""String_Node_Str"" + graphNode + ""String_Node_Str""+ treeNode.getName()+ ""String_Node_Str"");
    HashMap<Node,LinkedList<JadeNode>> childNodeTreeTipDescendantsMap=new HashMap<Node,LinkedList<JadeNode>>();
    for (    JadeNode curDescendantTreeNode : treeNodeTreeTipDescendantsMap.get(treeNode)) {
      System.out.println(""String_Node_Str"" + curDescendantTreeNode.getName());
      Node curDescendantGraphNode=treeNodeGraphNodeMap.get(curDescendantTreeNode);
      Node curDeepestAncestor=null;
      if (treeTipToMRCAPathMap.get(curDescendantGraphNode).size() > 0) {
        curDeepestAncestor=treeTipToMRCAPathMap.get(curDescendantGraphNode).remove(0);
      }
 else {
        curDeepestAncestor=(Node)treeNode.getObject(""String_Node_Str"");
      }
      String ancestorName=""String_Node_Str"";
      if (curDeepestAncestor.hasProperty(""String_Node_Str"")) {
        ancestorName=(String)curDeepestAncestor.getProperty(""String_Node_Str"");
        System.out.println(""String_Node_Str"" + ancestorName);
      }
      if (!childNodeTreeTipDescendantsMap.containsKey(curDeepestAncestor)) {
        System.out.println(""String_Node_Str"");
        childNodeTreeTipDescendantsMap.put(curDeepestAncestor,new LinkedList<JadeNode>());
      }
      System.out.println(""String_Node_Str"" + curDescendantTreeNode.getName() + ""String_Node_Str""+ ancestorName);
      childNodeTreeTipDescendantsMap.get(curDeepestAncestor).add(curDescendantTreeNode);
    }
    if (childNodeTreeTipDescendantsMap.size() == 1) {
      Node onlyDescendant=childNodeTreeTipDescendantsMap.keySet().iterator().next();
      if (childNodeTreeTipDescendantsMap.get(onlyDescendant).size() > 1) {
        System.out.println(""String_Node_Str"" + treeNode.getName() + ""String_Node_Str"");
        stack.add(0,treeNode);
        continue;
      }
    }
    for (    Entry<Node,LinkedList<JadeNode>> childToAdd : childNodeTreeTipDescendantsMap.entrySet()) {
      LinkedList<JadeNode> childTreeTipDescendants=childToAdd.getValue();
      if (childTreeTipDescendants.size() == 1) {
        treeNode.addChild(childTreeTipDescendants.get(0));
        continue;
      }
      Node childGraphNode=childToAdd.getKey();
      JadeNode childTreeNode=new JadeNode();
      System.out.println(""String_Node_Str"" + treeNode.getName());
      childTreeNode.assocObject(""String_Node_Str"",childGraphNode);
      if (childGraphNode.hasProperty(""String_Node_Str"")) {
        childTreeNode.setName((String)childGraphNode.getProperty(""String_Node_Str""));
        System.out.println(""String_Node_Str"" + childTreeNode.getName());
      }
      if (childTreeTipDescendants.size() == 2) {
        for (        JadeNode treeTip : childTreeTipDescendants) {
          childTreeNode.addChild(treeTip);
        }
      }
 else {
        System.out.println(""String_Node_Str"" + treeNode.getName() + ""String_Node_Str"");
        Node graphNodeForTip=treeNodeGraphNodeMap.get(childTreeTipDescendants.get(0));
        ArrayList<Node> startNodeAncestors=treeTipToMRCAPathMap.get(graphNodeForTip);
        Node startShallowestAncestor=null;
        if (startNodeAncestors.size() > 0) {
          startShallowestAncestor=startNodeAncestors.get(startNodeAncestors.size() - 1);
        }
        boolean isPolytomy=true;
        for (        JadeNode treeTip : childTreeTipDescendants) {
          Node graphTip=treeNodeGraphNodeMap.get(treeTip);
          ArrayList<Node> curAncestors=treeTipToMRCAPathMap.get(graphTip);
          Node curShallowestAncestor=curAncestors.get(curAncestors.size() - 1);
          if (!startShallowestAncestor.equals(curShallowestAncestor)) {
            System.out.println(""String_Node_Str"");
            System.out.println(""String_Node_Str"" + childTreeNode.getName() + ""String_Node_Str"");
            stack.add(0,childTreeNode);
            treeNodeTreeTipDescendantsMap.put(childTreeNode,childTreeTipDescendants);
            isPolytomy=false;
            break;
          }
        }
        if (isPolytomy) {
          System.out.println(""String_Node_Str"");
          for (          JadeNode treeTip : childTreeTipDescendants) {
            System.out.println(""String_Node_Str"" + treeTip.getName() + ""String_Node_Str"");
            childTreeNode.addChild(treeTip);
          }
        }
      }
      treeNode.addChild(childTreeNode);
    }
  }
  System.out.println(""String_Node_Str"" + root.getNewick(false) + ""String_Node_Str"");
  return root;
}"
50185,"public int extractDraftSubTreeForNodeIDs(String[] args) throws MultipleHitsException {
  if (args.length != 4) {
    System.out.println(""String_Node_Str"");
    return 1;
  }
  System.out.println(args[1]);
  String[] nodeIds=args[1].trim().split(""String_Node_Str"");
  String outFileName=args[2];
  String graphname=args[3];
  GraphExplorer ge=new GraphExplorer(graphname);
  ArrayList<Node> tipNodes=new ArrayList<Node>();
  for (  String nodeId : nodeIds) {
    System.out.println(nodeId);
    Node tip=ge.graphDb.getNodeById(Long.valueOf(nodeId));
    if (tip != null) {
      System.out.println(""String_Node_Str"" + tip.getId());
      tipNodes.add(tip);
    }
  }
  JadeNode synthTreeRootNode=ge.extractDraftSubtreeForTipNodes(tipNodes);
  PrintWriter outFile=null;
  try {
    outFile=new PrintWriter(new FileWriter(outFileName));
    outFile.write(synthTreeRootNode.getNewick(true) + ""String_Node_Str"");
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    outFile.close();
    ge.shutdownDB();
  }
  return 0;
}","public int extractDraftSubTreeForNodeIDs(String[] args) throws MultipleHitsException {
  if (args.length != 4) {
    System.out.println(""String_Node_Str"");
    return 1;
  }
  String[] nodeIds=args[1].trim().split(""String_Node_Str"");
  String outFileName=args[2];
  String graphname=args[3];
  GraphExplorer ge=new GraphExplorer(graphname);
  ArrayList<Node> tipNodes=new ArrayList<Node>();
  for (  String nodeId : nodeIds) {
    Node tip=ge.graphDb.getNodeById(Long.valueOf(nodeId));
    if (tip != null) {
      tipNodes.add(tip);
    }
  }
  JadeNode synthTreeRootNode=ge.extractDraftSubtreeForTipNodes(tipNodes);
  PrintWriter outFile=null;
  try {
    outFile=new PrintWriter(new FileWriter(outFileName));
    outFile.write(synthTreeRootNode.getNewick(true) + ""String_Node_Str"");
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    outFile.close();
    ge.shutdownDB();
  }
  return 0;
}"
50186,"public int extractDraftSubTreeForOttIDs(String[] args) throws OttIdNotFoundException, MultipleHitsException, TaxonNotFoundException {
  if (args.length != 4) {
    System.out.println(""String_Node_Str"");
    return 1;
  }
  System.out.println(args[1]);
  String[] OTTids=args[1].trim().split(""String_Node_Str"");
  String outFileName=args[2];
  String graphname=args[3];
  GraphExplorer ge=new GraphExplorer(graphname);
  ArrayList<Node> tipNodes=new ArrayList<Node>();
  for (  String OTTid : OTTids) {
    System.out.println(OTTid);
    Node tip=ge.findGraphTaxNodeByUID(OTTid);
    if (tip != null) {
      System.out.println(""String_Node_Str"" + tip.getId());
      tipNodes.add(tip);
    }
  }
  JadeNode synthTreeRootNode=ge.extractDraftSubtreeForTipNodes(tipNodes);
  PrintWriter outFile=null;
  try {
    outFile=new PrintWriter(new FileWriter(outFileName));
    outFile.write(synthTreeRootNode.getNewick(true) + ""String_Node_Str"");
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    outFile.close();
    ge.shutdownDB();
  }
  return 0;
}","public int extractDraftSubTreeForOttIDs(String[] args) throws OttIdNotFoundException, MultipleHitsException, TaxonNotFoundException {
  if (args.length != 4) {
    System.out.println(""String_Node_Str"");
    return 1;
  }
  String[] OTTids=args[1].trim().split(""String_Node_Str"");
  String outFileName=args[2];
  String graphname=args[3];
  GraphExplorer ge=new GraphExplorer(graphname);
  ArrayList<Node> tipNodes=new ArrayList<Node>();
  for (  String OTTid : OTTids) {
    Node tip=ge.findGraphTaxNodeByUID(OTTid);
    if (tip != null) {
      tipNodes.add(tip);
    }
  }
  JadeNode synthTreeRootNode=ge.extractDraftSubtreeForTipNodes(tipNodes);
  PrintWriter outFile=null;
  try {
    outFile=new PrintWriter(new FileWriter(outFileName));
    outFile.write(synthTreeRootNode.getNewick(true) + ""String_Node_Str"");
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    outFile.close();
    ge.shutdownDB();
  }
  return 0;
}"
50187,"@Description(""String_Node_Str"" + ""String_Node_Str"") @PluginTarget(GraphDatabaseService.class) public Representation getDraftTreeSubtreeForNodes(@Source GraphDatabaseService graphDb,@Description(""String_Node_Str"") @Parameter(name=""String_Node_Str"",optional=true) long[] nodeIds,@Description(""String_Node_Str"") @Parameter(name=""String_Node_Str"",optional=true) long[] ottIds) throws MultipleHitsException, TaxonNotFoundException {
  if (nodeIds.length < 1 && ottIds.length < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ArrayList<Node> tips=new ArrayList<Node>();
  GraphExplorer ge=new GraphExplorer(graphDb);
  if (nodeIds != null && nodeIds.length > 0) {
    for (    long nodeId : nodeIds) {
      Node n=graphDb.getNodeById(nodeId);
      if (n != null) {
        tips.add(n);
      }
    }
  }
  if (ottIds != null && ottIds.length > 0) {
    for (    long ottId : ottIds) {
      Node n=ge.findGraphTaxNodeByUID(String.valueOf(ottId));
      if (n != null) {
        tips.add(n);
      }
    }
  }
  if (tips.size() < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else {
    HashMap<String,Object> vals=new HashMap<String,Object>();
    vals.put(""String_Node_Str"",tips);
    vals.put(""String_Node_Str"",ge.extractDraftSubtreeForTipNodes(tips).getNewick(true) + ""String_Node_Str"");
    return OTRepresentationConverter.convert(vals);
  }
}","@Description(""String_Node_Str"" + ""String_Node_Str"") @PluginTarget(GraphDatabaseService.class) public Representation getDraftTreeSubtreeForNodes(@Source GraphDatabaseService graphDb,@Description(""String_Node_Str"") @Parameter(name=""String_Node_Str"",optional=true) long[] nodeIds,@Description(""String_Node_Str"") @Parameter(name=""String_Node_Str"",optional=true) long[] ottIds) throws MultipleHitsException, TaxonNotFoundException {
  if ((nodeIds == null || nodeIds.length < 1) && (ottIds == null || ottIds.length < 1)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  ArrayList<Node> tips=new ArrayList<Node>();
  GraphExplorer ge=new GraphExplorer(graphDb);
  if (nodeIds != null && nodeIds.length > 0) {
    for (    long nodeId : nodeIds) {
      Node n=graphDb.getNodeById(nodeId);
      if (n != null) {
        tips.add(n);
      }
    }
  }
  if (ottIds != null && ottIds.length > 0) {
    for (    long ottId : ottIds) {
      Node n=ge.findGraphTaxNodeByUID(String.valueOf(ottId));
      if (n != null) {
        tips.add(n);
      }
    }
  }
  if (tips.size() < 1) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else {
    HashMap<String,Object> vals=new HashMap<String,Object>();
    vals.put(""String_Node_Str"",tips);
    vals.put(""String_Node_Str"",ge.extractDraftSubtreeForTipNodes(tips).getNewick(true) + ""String_Node_Str"");
    return OTRepresentationConverter.convert(vals);
  }
}"
50188,"private static JadeTree importTree(Map<String,JSONObject> otuMap,JSONArray nodeList,JSONArray edgeList,List<Object> studyMetaList,List<Object> treeMetaList,String treeID,Boolean verbose,MessageLogger msgLogger){
  msgLogger.indentMessageInt(1,""String_Node_Str"",""String_Node_Str"",nodeList.size());
  msgLogger.indentMessageInt(1,""String_Node_Str"",""String_Node_Str"",edgeList.size());
  Map<String,JadeNode> nodeMap=new HashMap<String,JadeNode>();
  JadeNode root=null;
  String ingroup=null;
  if (treeMetaList != null) {
    for (    Object meta : treeMetaList) {
      JSONObject j=(JSONObject)meta;
      if (((String)j.get(""String_Node_Str"")).compareTo(""String_Node_Str"") == 0) {
        if ((j.get(""String_Node_Str"")) != null) {
          ingroup=(String)j.get(""String_Node_Str"");
          msgLogger.indentMessageStr(1,""String_Node_Str"",""String_Node_Str"",ingroup);
        }
 else {
          throw new RuntimeException(""String_Node_Str"" + j);
        }
      }
    }
  }
  JadeNode arbitraryNode=null;
  boolean deprecatedOttID=false;
  for (  Object node : nodeList) {
    JSONObject j=(JSONObject)node;
    JadeNode jn=new JadeNode();
    String id=(String)j.get(""String_Node_Str"");
    nodeMap.put(id,jn);
    arbitraryNode=jn;
    jn.assocObject(""String_Node_Str"",id);
    if (ingroup != null && id.compareTo(ingroup) == 0) {
      msgLogger.indentMessage(1,""String_Node_Str"");
      root=jn;
    }
    String otuId=(String)j.get(""String_Node_Str"");
    if (otuId != null) {
      JSONObject otu=otuMap.get(otuId);
      if (otu == null) {
        msgLogger.indentMessageStr(2,""String_Node_Str"",""String_Node_Str"",otuId);
        return null;
      }
      String label=(String)otu.get(""String_Node_Str"");
      jn.setName(label);
      List<Object> metaList2=getMetaList(otu);
      if (metaList2 != null) {
        for (        Object meta : metaList2) {
          JSONObject m=(JSONObject)meta;
          String propname=(String)m.get(""String_Node_Str"");
          Object value=m.get(""String_Node_Str"");
          if (propname.equals(""String_Node_Str"")) {
            propname=""String_Node_Str"";
            deprecatedOttID=true;
          }
          if (propname.equals(""String_Node_Str"")) {
            if (value instanceof String) {
              value=Long.parseLong((String)value);
            }
 else             if (value instanceof Long) {
              ;
            }
 else             if (value instanceof Integer) {
              value=new Long((((Integer)value).intValue()));
            }
 else             if (value == null) {
              msgLogger.indentMessageStr(1,""String_Node_Str"",""String_Node_Str"",id);
            }
 else {
              System.err.println(""String_Node_Str"" + m);
              throw new RuntimeException(""String_Node_Str"" + value);
            }
          }
 else           if (propname.equals(""String_Node_Str"")) {
          }
 else           if (propname.equals(""String_Node_Str"")) {
          }
 else {
            msgLogger.indentMessageStrStr(1,""String_Node_Str"",""String_Node_Str"",propname,""String_Node_Str"",id);
          }
          jn.assocObject(propname,value);
        }
      }
    }
  }
  if (deprecatedOttID) {
    System.err.println(""String_Node_Str"" + treeID);
  }
  for (  Object edge : edgeList) {
    JSONObject j=(JSONObject)edge;
    JadeNode source=nodeMap.get(j.get(""String_Node_Str""));
    if (source == null) {
      msgLogger.indentMessageStr(2,""String_Node_Str"",""String_Node_Str"",(String)j.get(""String_Node_Str""));
      return null;
    }
    JadeNode target=nodeMap.get(j.get(""String_Node_Str""));
    if (target == null) {
      msgLogger.indentMessageStr(2,""String_Node_Str"",""String_Node_Str"",(String)j.get(""String_Node_Str""));
      return null;
    }
    Double length=(Double)j.get(""String_Node_Str"");
    if (length != null) {
      target.setBL(length);
    }
    source.addChild(target);
  }
  if (root == null) {
    for (JadeNode jn=arbitraryNode; jn != null; jn=jn.getParent()) {
      root=jn;
    }
  }
 else {
    root.setParent(null);
  }
  JadeTree tree=new JadeTree(root);
  int nc=tree.getExternalNodeCount();
  msgLogger.indentMessageInt(1,""String_Node_Str"",""String_Node_Str"",nc);
  if (studyMetaList != null) {
    associateMetadata(tree,studyMetaList,(verbose ? msgLogger : null));
  }
  if (treeMetaList != null) {
    associateMetadata(tree,treeMetaList,(verbose ? msgLogger : null));
  }
  tree.assocObject(""String_Node_Str"",treeID);
  return tree;
}","private static JadeTree importTree(Map<String,JSONObject> otuMap,JSONArray nodeList,JSONArray edgeList,List<Object> studyMetaList,List<Object> treeMetaList,String treeID,Boolean verbose,MessageLogger msgLogger){
  msgLogger.indentMessageInt(1,""String_Node_Str"",""String_Node_Str"",nodeList.size());
  msgLogger.indentMessageInt(1,""String_Node_Str"",""String_Node_Str"",edgeList.size());
  Map<String,JadeNode> nodeMap=new HashMap<String,JadeNode>();
  JadeNode root=null;
  String ingroup=null;
  if (treeMetaList != null) {
    for (    Object meta : treeMetaList) {
      JSONObject j=(JSONObject)meta;
      if (((String)j.get(""String_Node_Str"")).compareTo(""String_Node_Str"") == 0) {
        if ((j.get(""String_Node_Str"")) != null) {
          ingroup=(String)j.get(""String_Node_Str"");
          msgLogger.indentMessageStr(1,""String_Node_Str"",""String_Node_Str"",ingroup);
        }
 else {
          throw new RuntimeException(""String_Node_Str"" + j);
        }
      }
    }
  }
  JadeNode arbitraryNode=null;
  boolean deprecatedOttID=false;
  for (  Object node : nodeList) {
    JSONObject j=(JSONObject)node;
    JadeNode jn=new JadeNode();
    String id=(String)j.get(""String_Node_Str"");
    nodeMap.put(id,jn);
    arbitraryNode=jn;
    jn.assocObject(""String_Node_Str"",id);
    if (ingroup != null && id.compareTo(ingroup) == 0) {
      msgLogger.indentMessage(1,""String_Node_Str"");
      root=jn;
    }
    String otuId=(String)j.get(""String_Node_Str"");
    if (otuId != null) {
      JSONObject otu=otuMap.get(otuId);
      if (otu == null) {
        msgLogger.indentMessageStr(2,""String_Node_Str"",""String_Node_Str"",otuId);
        return null;
      }
      String label=(String)otu.get(""String_Node_Str"");
      jn.setName(label);
      List<Object> metaList2=getMetaList(otu);
      if (metaList2 != null) {
        for (        Object meta : metaList2) {
          JSONObject m=(JSONObject)meta;
          String propname=(String)m.get(""String_Node_Str"");
          Object value=m.get(""String_Node_Str"");
          if (propname.equals(""String_Node_Str"")) {
            propname=""String_Node_Str"";
            deprecatedOttID=true;
          }
          if (propname.equals(""String_Node_Str"")) {
            if (value instanceof String) {
              value=Long.parseLong((String)value);
            }
 else             if (value instanceof Long) {
              ;
            }
 else             if (value instanceof Integer) {
              value=new Long((((Integer)value).intValue()));
            }
 else             if (value == null) {
              msgLogger.indentMessageStr(1,""String_Node_Str"",""String_Node_Str"",id);
            }
 else {
              System.err.println(""String_Node_Str"" + m);
              throw new RuntimeException(""String_Node_Str"" + value);
            }
          }
 else           if (propname.equals(""String_Node_Str"")) {
          }
 else           if (propname.equals(""String_Node_Str"")) {
          }
 else           if (propname.equals(""String_Node_Str"")) {
          }
 else {
            msgLogger.indentMessageStrStr(1,""String_Node_Str"",""String_Node_Str"",propname,""String_Node_Str"",id);
          }
          jn.assocObject(propname,value);
        }
      }
    }
  }
  if (deprecatedOttID) {
    System.err.println(""String_Node_Str"" + treeID);
  }
  for (  Object edge : edgeList) {
    JSONObject j=(JSONObject)edge;
    JadeNode source=nodeMap.get(j.get(""String_Node_Str""));
    if (source == null) {
      msgLogger.indentMessageStr(2,""String_Node_Str"",""String_Node_Str"",(String)j.get(""String_Node_Str""));
      return null;
    }
    JadeNode target=nodeMap.get(j.get(""String_Node_Str""));
    if (target == null) {
      msgLogger.indentMessageStr(2,""String_Node_Str"",""String_Node_Str"",(String)j.get(""String_Node_Str""));
      return null;
    }
    Double length=(Double)j.get(""String_Node_Str"");
    if (length != null) {
      target.setBL(length);
    }
    source.addChild(target);
  }
  if (root == null) {
    for (JadeNode jn=arbitraryNode; jn != null; jn=jn.getParent()) {
      root=jn;
    }
  }
 else {
    root.setParent(null);
  }
  JadeTree tree=new JadeTree(root);
  int nc=tree.getExternalNodeCount();
  msgLogger.indentMessageInt(1,""String_Node_Str"",""String_Node_Str"",nc);
  if (studyMetaList != null) {
    associateMetadata(tree,studyMetaList,(verbose ? msgLogger : null));
  }
  if (treeMetaList != null) {
    associateMetadata(tree,treeMetaList,(verbose ? msgLogger : null));
  }
  tree.assocObject(""String_Node_Str"",treeID);
  return tree;
}"
50189,"@Description(""String_Node_Str"") @PluginTarget(GraphDatabaseService.class) public Representation getDraftTreeID(@Source GraphDatabaseService graphDb,@Description(""String_Node_Str"") @Parameter(name=""String_Node_Str"",optional=true) String startingTaxonOTTId) throws TaxonNotFoundException, MultipleHitsException {
  GraphExplorer ge=new GraphExplorer(graphDb);
  HashMap<String,Object> draftTreeInfo=null;
  Node startNode=null;
  try {
    if (startingTaxonOTTId == null || startingTaxonOTTId.length() == 0) {
      startNode=ge.getGraphRootNode();
    }
 else {
      startNode=ge.findGraphTaxNodeByUID(startingTaxonOTTId);
    }
    draftTreeInfo=new HashMap<String,Object>();
    draftTreeInfo.put(""String_Node_Str"",GraphBase.DRAFTTREENAME);
    draftTreeInfo.put(""String_Node_Str"",String.valueOf(startNode.getProperty(NodeProperty.NAME.propertyName)));
    draftTreeInfo.put(""String_Node_Str"",(Long)startNode.getProperty(NodeProperty.TAX_UID.propertyName));
    draftTreeInfo.put(""String_Node_Str"",startNode.getId());
  }
  finally {
    ge.shutdownDB();
  }
  return OpenTreeMachineRepresentationConverter.convert(draftTreeInfo);
}","@Description(""String_Node_Str"") @PluginTarget(GraphDatabaseService.class) public Representation getDraftTreeID(@Source GraphDatabaseService graphDb,@Description(""String_Node_Str"") @Parameter(name=""String_Node_Str"",optional=true) String startingTaxonOTTId) throws TaxonNotFoundException, MultipleHitsException {
  GraphExplorer ge=new GraphExplorer(graphDb);
  HashMap<String,Object> draftTreeInfo=null;
  Node startNode=null;
  try {
    if (startingTaxonOTTId == null || startingTaxonOTTId.length() == 0) {
      startNode=ge.getGraphRootNode();
    }
 else {
      startNode=ge.findGraphTaxNodeByUID(startingTaxonOTTId);
    }
    draftTreeInfo=new HashMap<String,Object>();
    draftTreeInfo.put(""String_Node_Str"",GraphBase.DRAFTTREENAME);
    draftTreeInfo.put(""String_Node_Str"",String.valueOf(startNode.getProperty(NodeProperty.NAME.propertyName)));
    draftTreeInfo.put(""String_Node_Str"",Long.valueOf((String)startNode.getProperty(NodeProperty.TAX_UID.propertyName)));
    draftTreeInfo.put(""String_Node_Str"",startNode.getId());
  }
  finally {
    ge.shutdownDB();
  }
  return OpenTreeMachineRepresentationConverter.convert(draftTreeInfo);
}"
50190,"@Override public Evaluation evaluate(Path inPath){
  Node curNode=inPath.endNode();
  if (visited.contains(curNode.getId())) {
    return Evaluation.EXCLUDE_AND_PRUNE;
  }
  visited.add(curNode.getId());
  TLongBitArray curNodeMRCAIds=new TLongBitArray((long[])curNode.getProperty(""String_Node_Str""));
  TLongBitArray curNodeOutMRCAIds=null;
  boolean isTaxNode=false;
  if (curNode.hasProperty(""String_Node_Str"") == false) {
    isTaxNode=true;
  }
 else {
    curNodeOutMRCAIds=new TLongBitArray((long[])curNode.getProperty(""String_Node_Str""));
  }
  if (isTaxNode == false) {
    if (curNodeMRCAIds.containsAny(outgroupNodeIds) == false) {
      if (curNodeOutMRCAIds.containsAny(ingroupNodeIds) == false) {
        if (curNodeMRCAIds.containsAny(ingroupNodeIds) == true) {
          boolean passed=false;
          TLongHashSet visitedrels=new TLongHashSet();
          for (          Relationship rel : curNode.getRelationships(Direction.INCOMING,RelType.STREECHILDOF)) {
            if (visitedrels.contains(rel.getId())) {
              continue;
            }
            TLongArrayList inids=new TLongArrayList((long[])rel.getProperty(""String_Node_Str""));
            visited.addAll(inids);
            TLongHashSet relmatched=new TLongHashSet();
            HashSet<Integer> childmatched=new HashSet<Integer>();
            for (int j=0; j < inids.size(); j++) {
              TLongBitArray trelj=new TLongBitArray((long[])graphdb.getRelationshipById(inids.get(j)).getProperty(""String_Node_Str""));
              for (int i=0; i < jadenode.getChildCount(); i++) {
                TLongBitArray chndi=new TLongBitArray((long[])jadenode.getChild(i).getObject(""String_Node_Str""));
                if (chndi.containsAny(trelj) == true) {
                  relmatched.add(inids.get(j));
                  childmatched.add(i);
                  break;
                }
              }
            }
            if (relmatched.size() >= 2 && childmatched.size() == jadenode.getChildCount()) {
              passed=true;
              break;
            }
          }
          if (passed == false) {
            return Evaluation.EXCLUDE_AND_CONTINUE;
          }
          TLongBitArray mrcaSearchIdsNotSetForThisNode=ingroupNodeIds.andNot(curNodeMRCAIds);
          if (mrcaSearchIdsNotSetForThisNode.size() > 0) {
            curNodeMRCAIds.addAll(mrcaSearchIdsNotSetForThisNode);
            curNodeMRCAIds.sort();
            curNode.setProperty(""String_Node_Str"",curNodeMRCAIds.toArray());
          }
          TLongBitArray outmrcaSearchIdsNotSetForThisNode=outgroupNodeIds.andNot(curNodeOutMRCAIds);
          if (outmrcaSearchIdsNotSetForThisNode.size() > 0) {
            curNodeOutMRCAIds.addAll(outmrcaSearchIdsNotSetForThisNode);
            curNodeOutMRCAIds.sort();
            curNode.setProperty(""String_Node_Str"",curNodeOutMRCAIds.toArray());
          }
          for (          Relationship parentRel : curNode.getRelationships(RelType.STREECHILDOF,Direction.OUTGOING)) {
            for (            Node ancestor : Traversal.description().breadthFirst().evaluator(new LongArrayPropertyContainsAllEvaluator(""String_Node_Str"",curNodeMRCAIds)).relationships(RelType.STREECHILDOF,Direction.OUTGOING).traverse(parentRel.getEndNode()).nodes()) {
              System.out.println(""String_Node_Str"" + ancestor + ""String_Node_Str"");
              TLongBitArray outmrcaAncestor=new TLongBitArray((long[])ancestor.getProperty(""String_Node_Str""));
              if (outmrcaAncestor.containsAny(ingroupNodeIds)) {
                System.out.println(""String_Node_Str"");
                LinkedList<String> names=new LinkedList<String>();
                for (                Long l : outmrcaAncestor.getIntersection(ingroupNodeIds)) {
                  names.add((String)graphdb.getNodeById(l).getProperty(""String_Node_Str""));
                }
                System.out.println(curNode + ""String_Node_Str"" + ancestor+ ""String_Node_Str""+ curNode+ ""String_Node_Str""+ Arrays.toString(names.toArray())+ ""String_Node_Str""+ ancestor);
                throw new java.lang.IllegalStateException();
              }
              TLongBitArray mrcaNew=new TLongBitArray((long[])ancestor.getProperty(""String_Node_Str""));
              mrcaNew.addAll(curNodeMRCAIds);
              ancestor.setProperty(""String_Node_Str"",mrcaNew.toArray());
            }
          }
          for (          Relationship childRel : curNode.getRelationships(RelType.STREECHILDOF,Direction.INCOMING)) {
            for (            Node descendant : Traversal.description().breadthFirst().evaluator(new LongArrayPropertyContainsAllEvaluator(""String_Node_Str"",curNodeOutMRCAIds)).relationships(RelType.STREECHILDOF,Direction.INCOMING).traverse(childRel.getStartNode()).nodes()) {
              System.out.println(""String_Node_Str"" + descendant + ""String_Node_Str"");
              TLongBitArray mrcaDescendant=new TLongBitArray((long[])descendant.getProperty(""String_Node_Str""));
              if (mrcaDescendant.containsAny(outgroupNodeIds)) {
                System.out.println(""String_Node_Str"");
                LinkedList<String> names=new LinkedList<String>();
                for (                Long l : mrcaDescendant.getIntersection(outgroupNodeIds)) {
                  names.add((String)graphdb.getNodeById(l).getProperty(""String_Node_Str""));
                }
                System.out.println(curNode + ""String_Node_Str"" + descendant+ ""String_Node_Str""+ curNode+ ""String_Node_Str""+ Arrays.toString(names.toArray())+ ""String_Node_Str""+ descendant);
                throw new java.lang.IllegalStateException();
              }
              TLongBitArray outMrcaNew=new TLongBitArray((long[])descendant.getProperty(""String_Node_Str""));
              outMrcaNew.addAll(curNodeOutMRCAIds);
              descendant.setProperty(""String_Node_Str"",outMrcaNew.toArray());
            }
          }
          return Evaluation.INCLUDE_AND_PRUNE;
        }
      }
    }
  }
 else {
    if (curNodeMRCAIds.containsAny(outgroupNodeIds) == false) {
      if (curNodeMRCAIds.containsAll(ingroupNodeIds)) {
        return Evaluation.INCLUDE_AND_PRUNE;
      }
    }
  }
  return Evaluation.EXCLUDE_AND_CONTINUE;
}","@Override public Evaluation evaluate(Path inPath){
  Node curNode=inPath.endNode();
  if (visited.contains(curNode.getId())) {
    return Evaluation.EXCLUDE_AND_PRUNE;
  }
  visited.add(curNode.getId());
  TLongBitArray curNodeMRCAIds=new TLongBitArray((long[])curNode.getProperty(""String_Node_Str""));
  TLongBitArray curNodeOutMRCAIds=null;
  boolean isTaxNode=false;
  if (curNode.hasProperty(""String_Node_Str"") == false) {
    isTaxNode=true;
  }
 else {
    curNodeOutMRCAIds=new TLongBitArray((long[])curNode.getProperty(""String_Node_Str""));
  }
  if (isTaxNode == false) {
    if (curNodeMRCAIds.containsAny(outgroupNodeIds) == false) {
      if (curNodeOutMRCAIds.containsAny(ingroupNodeIds) == false) {
        if (curNodeMRCAIds.containsAny(ingroupNodeIds) == true) {
          boolean passed=false;
          TLongHashSet visitedrels=new TLongHashSet();
          for (          Relationship rel : curNode.getRelationships(Direction.INCOMING,RelType.STREECHILDOF)) {
            if (visitedrels.contains(rel.getId()) || rel.hasProperty(""String_Node_Str"")) {
              continue;
            }
            TLongArrayList inids=new TLongArrayList((long[])rel.getProperty(""String_Node_Str""));
            visited.addAll(inids);
            TLongHashSet relmatched=new TLongHashSet();
            HashSet<Integer> childmatched=new HashSet<Integer>();
            for (int j=0; j < inids.size(); j++) {
              TLongBitArray trelj=new TLongBitArray((long[])graphdb.getRelationshipById(inids.get(j)).getProperty(""String_Node_Str""));
              for (int i=0; i < jadenode.getChildCount(); i++) {
                TLongBitArray chndi=new TLongBitArray((long[])jadenode.getChild(i).getObject(""String_Node_Str""));
                if (chndi.containsAny(trelj) == true) {
                  relmatched.add(inids.get(j));
                  childmatched.add(i);
                  break;
                }
              }
            }
            if (relmatched.size() >= 2 && childmatched.size() == jadenode.getChildCount()) {
              passed=true;
              break;
            }
          }
          if (passed == false) {
            return Evaluation.EXCLUDE_AND_CONTINUE;
          }
          TLongBitArray mrcaSearchIdsNotSetForThisNode=ingroupNodeIds.andNot(curNodeMRCAIds);
          if (mrcaSearchIdsNotSetForThisNode.size() > 0) {
            curNodeMRCAIds.addAll(mrcaSearchIdsNotSetForThisNode);
            curNodeMRCAIds.sort();
            curNode.setProperty(""String_Node_Str"",curNodeMRCAIds.toArray());
          }
          TLongBitArray outmrcaSearchIdsNotSetForThisNode=outgroupNodeIds.andNot(curNodeOutMRCAIds);
          if (outmrcaSearchIdsNotSetForThisNode.size() > 0) {
            curNodeOutMRCAIds.addAll(outmrcaSearchIdsNotSetForThisNode);
            curNodeOutMRCAIds.sort();
            curNode.setProperty(""String_Node_Str"",curNodeOutMRCAIds.toArray());
          }
          for (          Relationship parentRel : curNode.getRelationships(RelType.STREECHILDOF,Direction.OUTGOING)) {
            for (            Node ancestor : Traversal.description().breadthFirst().evaluator(new LongArrayPropertyContainsAllEvaluator(""String_Node_Str"",curNodeMRCAIds)).relationships(RelType.STREECHILDOF,Direction.OUTGOING).traverse(parentRel.getEndNode()).nodes()) {
              System.out.println(""String_Node_Str"" + ancestor + ""String_Node_Str"");
              TLongBitArray outmrcaAncestor=new TLongBitArray((long[])ancestor.getProperty(""String_Node_Str""));
              if (outmrcaAncestor.containsAny(ingroupNodeIds)) {
                System.out.println(""String_Node_Str"");
                LinkedList<String> names=new LinkedList<String>();
                for (                Long l : outmrcaAncestor.getIntersection(ingroupNodeIds)) {
                  names.add((String)graphdb.getNodeById(l).getProperty(""String_Node_Str""));
                }
                System.out.println(curNode + ""String_Node_Str"" + ancestor+ ""String_Node_Str""+ curNode+ ""String_Node_Str""+ Arrays.toString(names.toArray())+ ""String_Node_Str""+ ancestor);
                throw new java.lang.IllegalStateException();
              }
              TLongBitArray mrcaNew=new TLongBitArray((long[])ancestor.getProperty(""String_Node_Str""));
              mrcaNew.addAll(curNodeMRCAIds);
              ancestor.setProperty(""String_Node_Str"",mrcaNew.toArray());
            }
          }
          for (          Relationship childRel : curNode.getRelationships(RelType.STREECHILDOF,Direction.INCOMING)) {
            for (            Node descendant : Traversal.description().breadthFirst().evaluator(new LongArrayPropertyContainsAllEvaluator(""String_Node_Str"",curNodeOutMRCAIds)).relationships(RelType.STREECHILDOF,Direction.INCOMING).traverse(childRel.getStartNode()).nodes()) {
              System.out.println(""String_Node_Str"" + descendant + ""String_Node_Str"");
              TLongBitArray mrcaDescendant=new TLongBitArray((long[])descendant.getProperty(""String_Node_Str""));
              if (mrcaDescendant.containsAny(outgroupNodeIds)) {
                System.out.println(""String_Node_Str"");
                LinkedList<String> names=new LinkedList<String>();
                for (                Long l : mrcaDescendant.getIntersection(outgroupNodeIds)) {
                  names.add((String)graphdb.getNodeById(l).getProperty(""String_Node_Str""));
                }
                System.out.println(curNode + ""String_Node_Str"" + descendant+ ""String_Node_Str""+ curNode+ ""String_Node_Str""+ Arrays.toString(names.toArray())+ ""String_Node_Str""+ descendant);
                throw new java.lang.IllegalStateException();
              }
              TLongBitArray outMrcaNew=new TLongBitArray((long[])descendant.getProperty(""String_Node_Str""));
              outMrcaNew.addAll(curNodeOutMRCAIds);
              descendant.setProperty(""String_Node_Str"",outMrcaNew.toArray());
            }
          }
          return Evaluation.INCLUDE_AND_PRUNE;
        }
      }
    }
  }
 else {
    if (curNodeMRCAIds.containsAny(outgroupNodeIds) == false) {
      if (curNodeMRCAIds.containsAll(ingroupNodeIds)) {
        return Evaluation.INCLUDE_AND_PRUNE;
      }
    }
  }
  return Evaluation.EXCLUDE_AND_CONTINUE;
}"
50191,"/** 
 * There are three possibilities 1. the ottol id is present 2. there is no ottol id but the TNRS gets one with high probability 3. there is no ottol id and the TNRS is no help For 3 (the problematic one), we will add an entry in an index and add a name to the taxonomy. This is a special case when adding things from phylografter The names that are added need to be searched if there were not matches in  the TNRS this is similar to fixNamesFromTrees but it will not add the taxon if not found. it will try and prune
 * @param studyid
 * @param trees
 * @param graphDb
 * @throws IOException
 */
public static boolean fixNamesFromTrees(List<JadeTree> trees,GraphDatabaseAgent graphDb,boolean prune,MessageLogger logger) throws IOException {
  String urlbasecontext=""String_Node_Str"";
  String urlbasefetch=""String_Node_Str"";
  logger.message(""String_Node_Str"");
  for (int i=0; i < trees.size(); i++) {
    JadeTree currTree=trees.get(i);
    logger.indentMessageStr(1,""String_Node_Str"",""String_Node_Str"",(String)currTree.getObject(""String_Node_Str""));
    ArrayList<JadeNode> searchnds=new ArrayList<JadeNode>();
    HashMap<String,JadeNode> namenodemap=new HashMap<String,JadeNode>();
    ArrayList<JadeNode> matchednodes=new ArrayList<JadeNode>();
    for (int j=0; j < currTree.getExternalNodeCount(); j++) {
      JadeNode ndJ=currTree.getExternalNode(j);
      if (ndJ.getObject(""String_Node_Str"") == null) {
        logger.indentMessageStrStr(2,""String_Node_Str"",""String_Node_Str"",ndJ.getName(),""String_Node_Str"",(String)ndJ.getObject(""String_Node_Str""));
        searchnds.add(ndJ);
        namenodemap.put(ndJ.getName(),ndJ);
      }
    }
    if (searchnds.size() == 0) {
      logger.indentMessage(1,""String_Node_Str"");
    }
 else {
      StringBuffer sb=new StringBuffer();
      ArrayList<String> namelist=new ArrayList<String>();
      for (int j=0; j < currTree.getExternalNodeCount(); j++) {
        namelist.add(currTree.getExternalNode(j).getName());
      }
      HashMap<String,Object> namemap=new HashMap<String,Object>();
      namemap.put(""String_Node_Str"",namelist);
      String contextQueryParameters=new JSONObject(namemap).toJSONString();
      System.out.println(contextQueryParameters);
      ClientConfig cc=new DefaultClientConfig();
      Client c=Client.create(cc);
      WebResource contextQuery=c.resource(urlbasecontext);
      String contextResponseJSONStr=null;
      try {
        contextQuery.accept(MediaType.APPLICATION_JSON_TYPE).type(MediaType.APPLICATION_JSON_TYPE).post(String.class,contextQueryParameters);
      }
 catch (      Exception e) {
        System.out.println(""String_Node_Str"");
      }
      JSONObject contextResponse=(JSONObject)JSONValue.parse(contextResponseJSONStr);
      String cn=(String)contextResponse.get(""String_Node_Str"");
      ArrayList<String> namelist2=new ArrayList<String>();
      for (int j=0; j < searchnds.size(); j++) {
        if (searchnds.get(j).getObject(""String_Node_Str"") == null) {
          namelist2.add(searchnds.get(j).getName());
        }
      }
      HashMap<String,Object> namemap2=new HashMap<String,Object>();
      namemap2.put(""String_Node_Str"",namelist2);
      namemap2.put(""String_Node_Str"",cn);
      contextQueryParameters=new JSONObject(namemap2).toJSONString();
      cc=new DefaultClientConfig();
      c=Client.create(cc);
      contextQuery=c.resource(urlbasefetch);
      String tnrsResponseJSONStr=null;
      try {
        tnrsResponseJSONStr=contextQuery.accept(MediaType.APPLICATION_JSON_TYPE).type(MediaType.APPLICATION_JSON_TYPE).post(String.class,contextQueryParameters);
      }
 catch (      Exception x) {
        logger.indentMessageStr(1,""String_Node_Str"",""String_Node_Str"",contextQueryParameters);
      }
      if (tnrsResponseJSONStr != null) {
        contextResponse=(JSONObject)JSONValue.parse(tnrsResponseJSONStr);
        JSONArray unm=(JSONArray)contextResponse.get(""String_Node_Str"");
        logger.indentMessageInt(1,""String_Node_Str"",""String_Node_Str"",unm.size());
        JSONArray res=(JSONArray)contextResponse.get(""String_Node_Str"");
        for (        Object id : res) {
          JSONArray tres=(JSONArray)((JSONObject)id).get(""String_Node_Str"");
          String origname=(String)((JSONObject)id).get(""String_Node_Str"");
          for (          Object tid : tres) {
            Double score=(Double)((JSONObject)tid).get(""String_Node_Str"");
            boolean permat=(Boolean)((JSONObject)tid).get(""String_Node_Str"");
            String ottId=String.valueOf(((JSONObject)tid).get(""String_Node_Str""));
            String matchedName=(String)((JSONObject)tid).get(""String_Node_Str"");
            if (score >= 1) {
              Long tnrsottId=Long.valueOf(ottId);
              JadeNode fixedNode=namenodemap.get(origname);
              logger.indentMessageLongStrStrStr(2,""String_Node_Str"",""String_Node_Str"",tnrsottId,""String_Node_Str"",matchedName,""String_Node_Str"",origname,""String_Node_Str"",(String)fixedNode.getObject(""String_Node_Str""));
              fixedNode.assocObject(""String_Node_Str"",tnrsottId);
              matchednodes.add(namenodemap.get(origname));
              namenodemap.remove(origname);
              break;
            }
          }
        }
      }
      Index<Node> graphNodeIndex=graphDb.getNodeIndex(""String_Node_Str"");
      ArrayList<String> removenames=new ArrayList<String>();
      for (      String name : namenodemap.keySet()) {
        IndexHits<Node> hits=graphNodeIndex.get(""String_Node_Str"",name);
        if (hits.size() == 0) {
        }
 else         if (hits.size() == 1) {
          String uidString=(String)hits.getSingle().getProperty(""String_Node_Str"");
          Long lid=Long.valueOf(uidString);
          logger.indentMessageLong(2,""String_Node_Str"",name,lid);
          namenodemap.get(name).assocObject(""String_Node_Str"",Long.valueOf(lid));
          removenames.add(name);
        }
 else         if (hits.size() > 1) {
          logger.indentMessageInt(2,""String_Node_Str"",name,hits.size());
        }
        hits.close();
      }
      for (      String name : removenames) {
        namenodemap.remove(name);
      }
      if (namenodemap.size() > 0) {
        if (prune) {
          for (          String name : namenodemap.keySet()) {
            JadeNode jnode=namenodemap.get(name);
            logger.indentMessageStrStr(2,""String_Node_Str"",""String_Node_Str"",name,""String_Node_Str"",(String)jnode.getObject(""String_Node_Str""));
            try {
              currTree.pruneExternalNode(jnode);
            }
 catch (            Exception x) {
              logger.indentMessageStr(3,""String_Node_Str"",""String_Node_Str"",name);
              return false;
            }
          }
        }
 else {
          return false;
        }
      }
    }
    if (prune) {
      TLongHashSet tipottols=new TLongHashSet();
      HashSet<JadeNode> pru=new HashSet<JadeNode>();
      for (int j=0; j < currTree.getExternalNodeCount(); j++) {
        JadeNode currNd=currTree.getExternalNode(j);
        Long tid=(Long)currNd.getObject(""String_Node_Str"");
        if (tid == null) {
          logger.indentMessage(2,""String_Node_Str"");
          logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNd.getName(),""String_Node_Str"",(String)currNd.getObject(""String_Node_Str""));
          pru.add(currNd);
        }
 else         if (tipottols.contains(tid)) {
          logger.indentMessage(2,""String_Node_Str"");
          logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNd.getName(),""String_Node_Str"",(String)currNd.getObject(""String_Node_Str""));
          logger.indentMessageLong(3,""String_Node_Str"",""String_Node_Str"",tid);
          pru.add(currNd);
        }
 else {
          IndexHits<Node> hits=graphDb.getNodeIndex(""String_Node_Str"").get(""String_Node_Str"",String.valueOf(tid));
          if (hits.size() == 0) {
            logger.indentMessage(2,""String_Node_Str"");
            logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNd.getName(),""String_Node_Str"",(String)currNd.getObject(""String_Node_Str""));
            logger.indentMessageLong(3,""String_Node_Str"",""String_Node_Str"",tid);
            pru.add(currNd);
          }
 else {
            tipottols.add(tid);
          }
          hits.close();
        }
      }
      for (int j=0; j < currTree.getExternalNodeCount(); j++) {
        JadeNode currNdJ=currTree.getExternalNode(j);
        if (pru.contains(currNdJ)) {
          continue;
        }
        Long tid=(Long)currNdJ.getObject(""String_Node_Str"");
        IndexHits<Node> hits=graphDb.getNodeIndex(""String_Node_Str"").get(""String_Node_Str"",String.valueOf(tid));
        Node firstNode=hits.getSingle();
        hits.close();
        TLongArrayList t1=new TLongArrayList((long[])firstNode.getProperty(""String_Node_Str""));
        for (int k=0; k < currTree.getExternalNodeCount(); k++) {
          JadeNode currNdK=currTree.getExternalNode(k);
          if (pru.contains(currNdK) || k == j) {
            continue;
          }
          Long tid2=(Long)currNdK.getObject(""String_Node_Str"");
          IndexHits<Node> hits2=graphDb.getNodeIndex(""String_Node_Str"").get(""String_Node_Str"",String.valueOf(tid2));
          Node secondNode=hits2.getSingle();
          hits2.close();
          if (secondNode == null) {
            logger.indentMessageStr(2,""String_Node_Str"",""String_Node_Str"",String.valueOf(tid2));
            pru.add(currNdK);
          }
 else {
            TLongArrayList t2=new TLongArrayList((long[])secondNode.getProperty(""String_Node_Str""));
            if (LicaUtil.containsAnyt4jUnsorted(t1,t2)) {
              logger.indentMessage(2,""String_Node_Str"");
              if (t2.size() < t1.size()) {
                pru.add(currNdJ);
                logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNdK.getName(),""String_Node_Str"",(String)currNdK.getObject(""String_Node_Str""));
                logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNdJ.getName(),""String_Node_Str"",(String)currNdJ.getObject(""String_Node_Str""));
                break;
              }
 else {
                pru.add(currNdK);
                logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNdJ.getName(),""String_Node_Str"",(String)currNdJ.getObject(""String_Node_Str""));
                logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNdK.getName(),""String_Node_Str"",(String)currNdK.getObject(""String_Node_Str""));
              }
            }
          }
        }
      }
      for (      JadeNode tn : pru) {
        logger.indentMessageStrStr(2,""String_Node_Str"",""String_Node_Str"",tn.getName(),""String_Node_Str"",(String)tn.getObject(""String_Node_Str""));
        try {
          currTree.pruneExternalNode(tn);
        }
 catch (        Exception x) {
          logger.indentMessageStr(3,""String_Node_Str"",""String_Node_Str"",tn.getName());
          return false;
        }
      }
      currTree.processRoot();
      if (prune == true) {
        logger.indentMessageStr(1,""String_Node_Str"",""String_Node_Str"",currTree.getRoot().getNewick(false));
      }
    }
    logger.indentMessage(1,""String_Node_Str"");
    for (int k=0; k < currTree.getExternalNodeCount(); k++) {
      JadeNode ndK=currTree.getExternalNode(k);
      Long tid=(Long)ndK.getObject(""String_Node_Str"");
      IndexHits<Node> hits=graphDb.getNodeIndex(""String_Node_Str"").get(""String_Node_Str"",String.valueOf(tid));
      Node firstNode=hits.getSingle();
      hits.close();
      Node cnode=firstNode;
      if (cnode == null) {
        logger.indentMessageLongStrStr(2,""String_Node_Str"",""String_Node_Str"",tid,""String_Node_Str"",ndK.getName(),""String_Node_Str"",(String)ndK.getObject(""String_Node_Str""));
      }
 else {
        String cnodeName=(String)cnode.getProperty(""String_Node_Str"");
        StringBuffer sb=new StringBuffer();
        sb.append(cnodeName == null ? ""String_Node_Str"" : cnodeName);
        while (cnode.hasRelationship(Direction.OUTGOING,RelType.TAXCHILDOF)) {
          cnode=cnode.getSingleRelationship(RelType.TAXCHILDOF,Direction.OUTGOING).getEndNode();
          cnodeName=(String)cnode.getProperty(""String_Node_Str"");
          sb.append(""String_Node_Str"");
          sb.append(cnodeName == null ? ""String_Node_Str"" : cnodeName);
        }
        logger.indentMessageLongStrStr(2,""String_Node_Str"",""String_Node_Str"",tid,""String_Node_Str"",sb.toString(),""String_Node_Str"",(String)ndK.getObject(""String_Node_Str""));
      }
    }
  }
  return true;
}","/** 
 * There are three possibilities 1. the ottol id is present 2. there is no ottol id but the TNRS gets one with high probability 3. there is no ottol id and the TNRS is no help For 3 (the problematic one), we will add an entry in an index and add a name to the taxonomy. This is a special case when adding things from phylografter The names that are added need to be searched if there were not matches in  the TNRS this is similar to fixNamesFromTrees but it will not add the taxon if not found. it will try and prune
 * @param studyid
 * @param trees
 * @param graphDb
 * @throws IOException
 */
public static boolean fixNamesFromTrees(List<JadeTree> trees,GraphDatabaseAgent graphDb,boolean prune,MessageLogger logger) throws IOException {
  String urlbasecontext=""String_Node_Str"";
  String urlbasefetch=""String_Node_Str"";
  logger.message(""String_Node_Str"");
  for (int i=0; i < trees.size(); i++) {
    JadeTree currTree=trees.get(i);
    logger.indentMessageStr(1,""String_Node_Str"",""String_Node_Str"",(String)currTree.getObject(""String_Node_Str""));
    ArrayList<JadeNode> searchnds=new ArrayList<JadeNode>();
    HashMap<String,JadeNode> namenodemap=new HashMap<String,JadeNode>();
    ArrayList<JadeNode> matchednodes=new ArrayList<JadeNode>();
    for (int j=0; j < currTree.getExternalNodeCount(); j++) {
      JadeNode ndJ=currTree.getExternalNode(j);
      if (ndJ.getObject(""String_Node_Str"") == null) {
        logger.indentMessageStrStr(2,""String_Node_Str"",""String_Node_Str"",ndJ.getName(),""String_Node_Str"",(String)ndJ.getObject(""String_Node_Str""));
        searchnds.add(ndJ);
        namenodemap.put(ndJ.getName(),ndJ);
      }
    }
    if (searchnds.size() == 0) {
      logger.indentMessage(1,""String_Node_Str"");
    }
 else {
      StringBuffer sb=new StringBuffer();
      ArrayList<String> namelist=new ArrayList<String>();
      for (int j=0; j < currTree.getExternalNodeCount(); j++) {
        namelist.add(currTree.getExternalNode(j).getName());
      }
      HashMap<String,Object> namemap=new HashMap<String,Object>();
      namemap.put(""String_Node_Str"",namelist);
      String contextQueryParameters=new JSONObject(namemap).toJSONString();
      System.out.println(contextQueryParameters);
      ClientConfig cc=new DefaultClientConfig();
      Client c=Client.create(cc);
      WebResource contextQuery=c.resource(urlbasecontext);
      String contextResponseJSONStr=null;
      try {
        contextQuery.accept(MediaType.APPLICATION_JSON_TYPE).type(MediaType.APPLICATION_JSON_TYPE).post(String.class,contextQueryParameters);
      }
 catch (      Exception e) {
        System.out.println(""String_Node_Str"");
      }
      if (contextResponseJSONStr != null) {
        JSONObject contextResponse=(JSONObject)JSONValue.parse(contextResponseJSONStr);
        String cn=(String)contextResponse.get(""String_Node_Str"");
        ArrayList<String> namelist2=new ArrayList<String>();
        for (int j=0; j < searchnds.size(); j++) {
          if (searchnds.get(j).getObject(""String_Node_Str"") == null) {
            namelist2.add(searchnds.get(j).getName());
          }
        }
        HashMap<String,Object> namemap2=new HashMap<String,Object>();
        namemap2.put(""String_Node_Str"",namelist2);
        namemap2.put(""String_Node_Str"",cn);
        contextQueryParameters=new JSONObject(namemap2).toJSONString();
        cc=new DefaultClientConfig();
        c=Client.create(cc);
        contextQuery=c.resource(urlbasefetch);
        String tnrsResponseJSONStr=null;
        try {
          tnrsResponseJSONStr=contextQuery.accept(MediaType.APPLICATION_JSON_TYPE).type(MediaType.APPLICATION_JSON_TYPE).post(String.class,contextQueryParameters);
        }
 catch (        Exception x) {
          logger.indentMessageStr(1,""String_Node_Str"",""String_Node_Str"",contextQueryParameters);
        }
        if (tnrsResponseJSONStr != null) {
          contextResponse=(JSONObject)JSONValue.parse(tnrsResponseJSONStr);
          JSONArray unm=(JSONArray)contextResponse.get(""String_Node_Str"");
          logger.indentMessageInt(1,""String_Node_Str"",""String_Node_Str"",unm.size());
          JSONArray res=(JSONArray)contextResponse.get(""String_Node_Str"");
          for (          Object id : res) {
            JSONArray tres=(JSONArray)((JSONObject)id).get(""String_Node_Str"");
            String origname=(String)((JSONObject)id).get(""String_Node_Str"");
            for (            Object tid : tres) {
              Double score=(Double)((JSONObject)tid).get(""String_Node_Str"");
              boolean permat=(Boolean)((JSONObject)tid).get(""String_Node_Str"");
              String ottId=String.valueOf(((JSONObject)tid).get(""String_Node_Str""));
              String matchedName=(String)((JSONObject)tid).get(""String_Node_Str"");
              if (score >= 1) {
                Long tnrsottId=Long.valueOf(ottId);
                JadeNode fixedNode=namenodemap.get(origname);
                logger.indentMessageLongStrStrStr(2,""String_Node_Str"",""String_Node_Str"",tnrsottId,""String_Node_Str"",matchedName,""String_Node_Str"",origname,""String_Node_Str"",(String)fixedNode.getObject(""String_Node_Str""));
                fixedNode.assocObject(""String_Node_Str"",tnrsottId);
                matchednodes.add(namenodemap.get(origname));
                namenodemap.remove(origname);
                break;
              }
            }
          }
        }
        Index<Node> graphNodeIndex=graphDb.getNodeIndex(""String_Node_Str"");
        ArrayList<String> removenames=new ArrayList<String>();
        for (        String name : namenodemap.keySet()) {
          IndexHits<Node> hits=graphNodeIndex.get(""String_Node_Str"",name);
          if (hits.size() == 0) {
          }
 else           if (hits.size() == 1) {
            String uidString=(String)hits.getSingle().getProperty(""String_Node_Str"");
            Long lid=Long.valueOf(uidString);
            logger.indentMessageLong(2,""String_Node_Str"",name,lid);
            namenodemap.get(name).assocObject(""String_Node_Str"",Long.valueOf(lid));
            removenames.add(name);
          }
 else           if (hits.size() > 1) {
            logger.indentMessageInt(2,""String_Node_Str"",name,hits.size());
          }
          hits.close();
        }
        for (        String name : removenames) {
          namenodemap.remove(name);
        }
        if (namenodemap.size() > 0) {
          if (prune) {
            for (            String name : namenodemap.keySet()) {
              JadeNode jnode=namenodemap.get(name);
              logger.indentMessageStrStr(2,""String_Node_Str"",""String_Node_Str"",name,""String_Node_Str"",(String)jnode.getObject(""String_Node_Str""));
              try {
                currTree.pruneExternalNode(jnode);
              }
 catch (              Exception x) {
                logger.indentMessageStr(3,""String_Node_Str"",""String_Node_Str"",name);
                return false;
              }
            }
          }
 else {
            return false;
          }
        }
      }
    }
    if (prune) {
      TLongHashSet tipottols=new TLongHashSet();
      HashSet<JadeNode> pru=new HashSet<JadeNode>();
      for (int j=0; j < currTree.getExternalNodeCount(); j++) {
        JadeNode currNd=currTree.getExternalNode(j);
        Long tid=(Long)currNd.getObject(""String_Node_Str"");
        if (tid == null) {
          logger.indentMessage(2,""String_Node_Str"");
          logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNd.getName(),""String_Node_Str"",(String)currNd.getObject(""String_Node_Str""));
          pru.add(currNd);
        }
 else         if (tipottols.contains(tid)) {
          logger.indentMessage(2,""String_Node_Str"");
          logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNd.getName(),""String_Node_Str"",(String)currNd.getObject(""String_Node_Str""));
          logger.indentMessageLong(3,""String_Node_Str"",""String_Node_Str"",tid);
          pru.add(currNd);
        }
 else {
          IndexHits<Node> hits=graphDb.getNodeIndex(""String_Node_Str"").get(""String_Node_Str"",String.valueOf(tid));
          if (hits.size() == 0) {
            logger.indentMessage(2,""String_Node_Str"");
            logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNd.getName(),""String_Node_Str"",(String)currNd.getObject(""String_Node_Str""));
            logger.indentMessageLong(3,""String_Node_Str"",""String_Node_Str"",tid);
            pru.add(currNd);
          }
 else {
            tipottols.add(tid);
          }
          hits.close();
        }
      }
      for (int j=0; j < currTree.getExternalNodeCount(); j++) {
        JadeNode currNdJ=currTree.getExternalNode(j);
        if (pru.contains(currNdJ)) {
          continue;
        }
        Long tid=(Long)currNdJ.getObject(""String_Node_Str"");
        IndexHits<Node> hits=graphDb.getNodeIndex(""String_Node_Str"").get(""String_Node_Str"",String.valueOf(tid));
        Node firstNode=hits.getSingle();
        hits.close();
        TLongArrayList t1=new TLongArrayList((long[])firstNode.getProperty(""String_Node_Str""));
        for (int k=0; k < currTree.getExternalNodeCount(); k++) {
          JadeNode currNdK=currTree.getExternalNode(k);
          if (pru.contains(currNdK) || k == j) {
            continue;
          }
          Long tid2=(Long)currNdK.getObject(""String_Node_Str"");
          IndexHits<Node> hits2=graphDb.getNodeIndex(""String_Node_Str"").get(""String_Node_Str"",String.valueOf(tid2));
          Node secondNode=hits2.getSingle();
          hits2.close();
          if (secondNode == null) {
            logger.indentMessageStr(2,""String_Node_Str"",""String_Node_Str"",String.valueOf(tid2));
            pru.add(currNdK);
          }
 else {
            TLongArrayList t2=new TLongArrayList((long[])secondNode.getProperty(""String_Node_Str""));
            if (LicaUtil.containsAnyt4jUnsorted(t1,t2)) {
              logger.indentMessage(2,""String_Node_Str"");
              if (t2.size() < t1.size()) {
                pru.add(currNdJ);
                logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNdK.getName(),""String_Node_Str"",(String)currNdK.getObject(""String_Node_Str""));
                logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNdJ.getName(),""String_Node_Str"",(String)currNdJ.getObject(""String_Node_Str""));
                break;
              }
 else {
                pru.add(currNdK);
                logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNdJ.getName(),""String_Node_Str"",(String)currNdJ.getObject(""String_Node_Str""));
                logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNdK.getName(),""String_Node_Str"",(String)currNdK.getObject(""String_Node_Str""));
              }
            }
          }
        }
      }
      for (      JadeNode tn : pru) {
        logger.indentMessageStrStr(2,""String_Node_Str"",""String_Node_Str"",tn.getName(),""String_Node_Str"",(String)tn.getObject(""String_Node_Str""));
        try {
          currTree.pruneExternalNode(tn);
        }
 catch (        Exception x) {
          logger.indentMessageStr(3,""String_Node_Str"",""String_Node_Str"",tn.getName());
          return false;
        }
      }
      currTree.processRoot();
      if (prune == true) {
        logger.indentMessageStr(1,""String_Node_Str"",""String_Node_Str"",currTree.getRoot().getNewick(false));
      }
    }
    logger.indentMessage(1,""String_Node_Str"");
    for (int k=0; k < currTree.getExternalNodeCount(); k++) {
      JadeNode ndK=currTree.getExternalNode(k);
      Long tid=(Long)ndK.getObject(""String_Node_Str"");
      IndexHits<Node> hits=graphDb.getNodeIndex(""String_Node_Str"").get(""String_Node_Str"",String.valueOf(tid));
      Node firstNode=hits.getSingle();
      hits.close();
      Node cnode=firstNode;
      if (cnode == null) {
        logger.indentMessageLongStrStr(2,""String_Node_Str"",""String_Node_Str"",tid,""String_Node_Str"",ndK.getName(),""String_Node_Str"",(String)ndK.getObject(""String_Node_Str""));
      }
 else {
        String cnodeName=(String)cnode.getProperty(""String_Node_Str"");
        StringBuffer sb=new StringBuffer();
        sb.append(cnodeName == null ? ""String_Node_Str"" : cnodeName);
        while (cnode.hasRelationship(Direction.OUTGOING,RelType.TAXCHILDOF)) {
          cnode=cnode.getSingleRelationship(RelType.TAXCHILDOF,Direction.OUTGOING).getEndNode();
          cnodeName=(String)cnode.getProperty(""String_Node_Str"");
          sb.append(""String_Node_Str"");
          sb.append(cnodeName == null ? ""String_Node_Str"" : cnodeName);
        }
        logger.indentMessageLongStrStr(2,""String_Node_Str"",""String_Node_Str"",tid,""String_Node_Str"",sb.toString(),""String_Node_Str"",(String)ndK.getObject(""String_Node_Str""));
      }
    }
  }
  return true;
}"
50192,"/** 
 * This will get the list of studies that have been updated in phylografter since a particular date and to another date The resulting list of ids can then be fetched using the fetchTreesFromStudy
 * @param datefrom should be like 2010-01-01
 * @param dateto should be like 2013-03-19
 * @return list of study ids
 */
public static ArrayList<Long> getUpdateStudyList(String datefrom,String dateto){
  String urlbase=""String_Node_Str"" + datefrom + ""String_Node_Str""+ dateto+ ""String_Node_Str"";
  System.out.println(""String_Node_Str"" + urlbase);
  try {
    URL phurl=new URL(urlbase);
    URLConnection conn=phurl.openConnection();
    conn.connect();
    BufferedReader un=new BufferedReader(new InputStreamReader(conn.getInputStream()));
    String inl;
    JSONObject all=(JSONObject)JSONValue.parse(un);
    JSONArray root=(JSONArray)all.get(""String_Node_Str"");
    ArrayList<Long> stids=new ArrayList<Long>();
    for (    Object id : root) {
      Long j=(Long)id;
      stids.add(j);
    }
    return stids;
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
  return null;
}","/** 
 * This will get the list of studies that have been updated in phylografter since a particular date and to another date The resulting list of ids can then be fetched using the fetchTreesFromStudy
 * @param datefrom should be like 2010-01-01
 * @param dateto should be like 2013-03-19
 * @return list of study ids
 */
public static ArrayList<Long> getUpdateStudyList(String datefrom,String dateto){
  String urlbase=""String_Node_Str"" + datefrom + ""String_Node_Str""+ dateto+ ""String_Node_Str"";
  System.out.println(""String_Node_Str"" + urlbase);
  try {
    URL phurl=new URL(urlbase);
    URLConnection conn=phurl.openConnection();
    conn.connect();
    BufferedReader un=new BufferedReader(new InputStreamReader(conn.getInputStream()));
    JSONObject all=(JSONObject)JSONValue.parse(un);
    JSONArray root=(JSONArray)all.get(""String_Node_Str"");
    ArrayList<Long> stids=new ArrayList<Long>();
    for (    Object id : root) {
      Long j=(Long)id;
      stids.add(j);
    }
    return stids;
  }
 catch (  MalformedURLException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
  return null;
}"
50193,"/** 
 * There are three possibilities 1. the ottol id is present 2. there is no ottol id but the TNRS gets one with high probability 3. there is no ottol id and the TNRS is no help For 3 (the problematic one), we will add an entry in an index and add a name to the taxonomy. This is a special case when adding things from phylografter The names that are added need to be searched if there were not matches in  the TNRS this is similar to fixNamesFromTrees but it will not add the taxon if not found. it will try and prune
 * @param studyid
 * @param trees
 * @param graphDb
 * @throws IOException
 */
public static boolean fixNamesFromTrees(List<JadeTree> trees,GraphDatabaseAgent graphDb,boolean prune,MessageLogger logger) throws IOException {
  String urlbasecontext=""String_Node_Str"";
  String urlbasefetch=""String_Node_Str"";
  logger.message(""String_Node_Str"");
  for (int i=0; i < trees.size(); i++) {
    JadeTree currTree=trees.get(i);
    logger.indentMessageStr(1,""String_Node_Str"",""String_Node_Str"",(String)currTree.getObject(""String_Node_Str""));
    ArrayList<JadeNode> searchnds=new ArrayList<JadeNode>();
    HashMap<String,JadeNode> namenodemap=new HashMap<String,JadeNode>();
    ArrayList<JadeNode> matchednodes=new ArrayList<JadeNode>();
    for (int j=0; j < currTree.getExternalNodeCount(); j++) {
      JadeNode ndJ=currTree.getExternalNode(j);
      if (ndJ.getObject(""String_Node_Str"") == null) {
        logger.indentMessageStrStr(2,""String_Node_Str"",""String_Node_Str"",ndJ.getName(),""String_Node_Str"",(String)ndJ.getObject(""String_Node_Str""));
        searchnds.add(ndJ);
        namenodemap.put(ndJ.getName(),ndJ);
      }
    }
    if (searchnds.size() == 0) {
      logger.indentMessage(1,""String_Node_Str"");
    }
 else {
      StringBuffer sb=new StringBuffer();
      ArrayList<String> namelist=new ArrayList<String>();
      for (int j=0; j < currTree.getExternalNodeCount(); j++) {
        namelist.add(currTree.getExternalNode(j).getName());
      }
      HashMap<String,Object> namemap=new HashMap<String,Object>();
      namemap.put(""String_Node_Str"",namelist);
      String contextQueryParameters=new JSONObject(namemap).toJSONString();
      System.out.println(contextQueryParameters);
      ClientConfig cc=new DefaultClientConfig();
      Client c=Client.create(cc);
      WebResource contextQuery=c.resource(urlbasecontext);
      String contextResponseJSONStr=contextQuery.accept(MediaType.APPLICATION_JSON_TYPE).type(MediaType.APPLICATION_JSON_TYPE).post(String.class,contextQueryParameters);
      JSONObject contextResponse=(JSONObject)JSONValue.parse(contextResponseJSONStr);
      String cn=(String)contextResponse.get(""String_Node_Str"");
      ArrayList<String> namelist2=new ArrayList<String>();
      for (int j=0; j < searchnds.size(); j++) {
        if (searchnds.get(j).getObject(""String_Node_Str"") == null) {
          namelist2.add(searchnds.get(j).getName());
        }
      }
      HashMap<String,Object> namemap2=new HashMap<String,Object>();
      namemap2.put(""String_Node_Str"",namelist2);
      namemap2.put(""String_Node_Str"",cn);
      contextQueryParameters=new JSONObject(namemap2).toJSONString();
      cc=new DefaultClientConfig();
      c=Client.create(cc);
      contextQuery=c.resource(urlbasefetch);
      String tnrsResponseJSONStr=null;
      try {
        tnrsResponseJSONStr=contextQuery.accept(MediaType.APPLICATION_JSON_TYPE).type(MediaType.APPLICATION_JSON_TYPE).post(String.class,contextQueryParameters);
      }
 catch (      Exception x) {
        logger.indentMessageStr(1,""String_Node_Str"",""String_Node_Str"",contextQueryParameters);
      }
      if (tnrsResponseJSONStr != null) {
        contextResponse=(JSONObject)JSONValue.parse(tnrsResponseJSONStr);
        JSONArray unm=(JSONArray)contextResponse.get(""String_Node_Str"");
        logger.indentMessageInt(1,""String_Node_Str"",""String_Node_Str"",unm.size());
        JSONArray res=(JSONArray)contextResponse.get(""String_Node_Str"");
        for (        Object id : res) {
          JSONArray tres=(JSONArray)((JSONObject)id).get(""String_Node_Str"");
          String origname=(String)((JSONObject)id).get(""String_Node_Str"");
          for (          Object tid : tres) {
            Double score=(Double)((JSONObject)tid).get(""String_Node_Str"");
            boolean permat=(Boolean)((JSONObject)tid).get(""String_Node_Str"");
            String ottId=(String)((JSONObject)tid).get(""String_Node_Str"");
            String matchedName=(String)((JSONObject)tid).get(""String_Node_Str"");
            if (score >= 1) {
              Long tnrsottId=Long.valueOf(ottId);
              JadeNode fixedNode=namenodemap.get(origname);
              logger.indentMessageLongStrStrStr(2,""String_Node_Str"",""String_Node_Str"",tnrsottId,""String_Node_Str"",matchedName,""String_Node_Str"",origname,""String_Node_Str"",(String)fixedNode.getObject(""String_Node_Str""));
              fixedNode.assocObject(""String_Node_Str"",tnrsottId);
              matchednodes.add(namenodemap.get(origname));
              namenodemap.remove(origname);
              break;
            }
          }
        }
      }
      Index<Node> graphNodeIndex=graphDb.getNodeIndex(""String_Node_Str"");
      ArrayList<String> removenames=new ArrayList<String>();
      for (      String name : namenodemap.keySet()) {
        IndexHits<Node> hits=graphNodeIndex.get(""String_Node_Str"",name);
        if (hits.size() == 0) {
        }
 else         if (hits.size() == 1) {
          String uidString=(String)hits.getSingle().getProperty(""String_Node_Str"");
          Long lid=Long.valueOf(uidString);
          logger.indentMessageLong(2,""String_Node_Str"",name,lid);
          namenodemap.get(name).assocObject(""String_Node_Str"",Long.valueOf(lid));
          removenames.add(name);
        }
 else         if (hits.size() > 1) {
          logger.indentMessageInt(2,""String_Node_Str"",name,hits.size());
        }
        hits.close();
      }
      for (      String name : removenames) {
        namenodemap.remove(name);
      }
      if (namenodemap.size() > 0) {
        if (prune) {
          for (          String name : namenodemap.keySet()) {
            JadeNode jnode=namenodemap.get(name);
            logger.indentMessageStrStr(2,""String_Node_Str"",""String_Node_Str"",name,""String_Node_Str"",(String)jnode.getObject(""String_Node_Str""));
            try {
              currTree.pruneExternalNode(jnode);
            }
 catch (            Exception x) {
              logger.indentMessageStr(3,""String_Node_Str"",""String_Node_Str"",name);
              return false;
            }
          }
        }
 else {
          return false;
        }
      }
    }
    if (prune) {
      TLongHashSet tipottols=new TLongHashSet();
      HashSet<JadeNode> pru=new HashSet<JadeNode>();
      for (int j=0; j < currTree.getExternalNodeCount(); j++) {
        JadeNode currNd=currTree.getExternalNode(j);
        Long tid=(Long)currNd.getObject(""String_Node_Str"");
        if (tid == null) {
          logger.indentMessage(2,""String_Node_Str"");
          logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNd.getName(),""String_Node_Str"",(String)currNd.getObject(""String_Node_Str""));
          pru.add(currNd);
        }
 else         if (tipottols.contains(tid)) {
          logger.indentMessage(2,""String_Node_Str"");
          logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNd.getName(),""String_Node_Str"",(String)currNd.getObject(""String_Node_Str""));
          logger.indentMessageLong(3,""String_Node_Str"",""String_Node_Str"",tid);
          pru.add(currNd);
        }
 else {
          IndexHits<Node> hits=graphDb.getNodeIndex(""String_Node_Str"").get(""String_Node_Str"",String.valueOf(tid));
          if (hits.size() == 0) {
            logger.indentMessage(2,""String_Node_Str"");
            logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNd.getName(),""String_Node_Str"",(String)currNd.getObject(""String_Node_Str""));
            logger.indentMessageLong(3,""String_Node_Str"",""String_Node_Str"",tid);
            pru.add(currNd);
          }
 else {
            tipottols.add(tid);
          }
          hits.close();
        }
      }
      for (int j=0; j < currTree.getExternalNodeCount(); j++) {
        JadeNode currNdJ=currTree.getExternalNode(j);
        if (pru.contains(currNdJ)) {
          continue;
        }
        Long tid=(Long)currNdJ.getObject(""String_Node_Str"");
        IndexHits<Node> hits=graphDb.getNodeIndex(""String_Node_Str"").get(""String_Node_Str"",String.valueOf(tid));
        Node firstNode=hits.getSingle();
        hits.close();
        TLongArrayList t1=new TLongArrayList((long[])firstNode.getProperty(""String_Node_Str""));
        for (int k=0; k < currTree.getExternalNodeCount(); k++) {
          JadeNode currNdK=currTree.getExternalNode(k);
          if (pru.contains(currNdK) || k == j) {
            continue;
          }
          Long tid2=(Long)currNdK.getObject(""String_Node_Str"");
          IndexHits<Node> hits2=graphDb.getNodeIndex(""String_Node_Str"").get(""String_Node_Str"",String.valueOf(tid2));
          Node secondNode=hits2.getSingle();
          hits2.close();
          if (secondNode == null) {
            logger.indentMessageStr(2,""String_Node_Str"",""String_Node_Str"",String.valueOf(tid2));
            pru.add(currNdK);
          }
 else {
            TLongArrayList t2=new TLongArrayList((long[])secondNode.getProperty(""String_Node_Str""));
            if (LicaUtil.containsAnyt4jUnsorted(t1,t2)) {
              logger.indentMessage(2,""String_Node_Str"");
              if (t2.size() < t1.size()) {
                pru.add(currNdJ);
                logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNdK.getName(),""String_Node_Str"",(String)currNdK.getObject(""String_Node_Str""));
                logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNdJ.getName(),""String_Node_Str"",(String)currNdJ.getObject(""String_Node_Str""));
                break;
              }
 else {
                pru.add(currNdK);
                logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNdJ.getName(),""String_Node_Str"",(String)currNdJ.getObject(""String_Node_Str""));
                logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNdK.getName(),""String_Node_Str"",(String)currNdK.getObject(""String_Node_Str""));
              }
            }
          }
        }
      }
      for (      JadeNode tn : pru) {
        logger.indentMessageStrStr(2,""String_Node_Str"",""String_Node_Str"",tn.getName(),""String_Node_Str"",(String)tn.getObject(""String_Node_Str""));
        try {
          currTree.pruneExternalNode(tn);
        }
 catch (        Exception x) {
          logger.indentMessageStr(3,""String_Node_Str"",""String_Node_Str"",tn.getName());
          return false;
        }
      }
      currTree.processRoot();
      if (prune == true) {
        logger.indentMessageStr(1,""String_Node_Str"",""String_Node_Str"",currTree.getRoot().getNewick(false));
      }
    }
    logger.indentMessage(1,""String_Node_Str"");
    for (int k=0; k < currTree.getExternalNodeCount(); k++) {
      JadeNode ndK=currTree.getExternalNode(k);
      Long tid=(Long)ndK.getObject(""String_Node_Str"");
      IndexHits<Node> hits=graphDb.getNodeIndex(""String_Node_Str"").get(""String_Node_Str"",String.valueOf(tid));
      Node firstNode=hits.getSingle();
      hits.close();
      Node cnode=firstNode;
      if (cnode == null) {
        logger.indentMessageLongStrStr(2,""String_Node_Str"",""String_Node_Str"",tid,""String_Node_Str"",ndK.getName(),""String_Node_Str"",(String)ndK.getObject(""String_Node_Str""));
      }
 else {
        String cnodeName=(String)cnode.getProperty(""String_Node_Str"");
        StringBuffer sb=new StringBuffer();
        sb.append(cnodeName == null ? ""String_Node_Str"" : cnodeName);
        while (cnode.hasRelationship(Direction.OUTGOING,RelType.TAXCHILDOF)) {
          cnode=cnode.getSingleRelationship(RelType.TAXCHILDOF,Direction.OUTGOING).getEndNode();
          cnodeName=(String)cnode.getProperty(""String_Node_Str"");
          sb.append(""String_Node_Str"");
          sb.append(cnodeName == null ? ""String_Node_Str"" : cnodeName);
        }
        logger.indentMessageLongStrStr(2,""String_Node_Str"",""String_Node_Str"",tid,""String_Node_Str"",sb.toString(),""String_Node_Str"",(String)ndK.getObject(""String_Node_Str""));
      }
    }
  }
  return true;
}","/** 
 * There are three possibilities 1. the ottol id is present 2. there is no ottol id but the TNRS gets one with high probability 3. there is no ottol id and the TNRS is no help For 3 (the problematic one), we will add an entry in an index and add a name to the taxonomy. This is a special case when adding things from phylografter The names that are added need to be searched if there were not matches in  the TNRS this is similar to fixNamesFromTrees but it will not add the taxon if not found. it will try and prune
 * @param studyid
 * @param trees
 * @param graphDb
 * @throws IOException
 */
public static boolean fixNamesFromTrees(List<JadeTree> trees,GraphDatabaseAgent graphDb,boolean prune,MessageLogger logger) throws IOException {
  String urlbasecontext=""String_Node_Str"";
  String urlbasefetch=""String_Node_Str"";
  logger.message(""String_Node_Str"");
  for (int i=0; i < trees.size(); i++) {
    JadeTree currTree=trees.get(i);
    logger.indentMessageStr(1,""String_Node_Str"",""String_Node_Str"",(String)currTree.getObject(""String_Node_Str""));
    ArrayList<JadeNode> searchnds=new ArrayList<JadeNode>();
    HashMap<String,JadeNode> namenodemap=new HashMap<String,JadeNode>();
    ArrayList<JadeNode> matchednodes=new ArrayList<JadeNode>();
    for (int j=0; j < currTree.getExternalNodeCount(); j++) {
      JadeNode ndJ=currTree.getExternalNode(j);
      if (ndJ.getObject(""String_Node_Str"") == null) {
        logger.indentMessageStrStr(2,""String_Node_Str"",""String_Node_Str"",ndJ.getName(),""String_Node_Str"",(String)ndJ.getObject(""String_Node_Str""));
        searchnds.add(ndJ);
        namenodemap.put(ndJ.getName(),ndJ);
      }
    }
    if (searchnds.size() == 0) {
      logger.indentMessage(1,""String_Node_Str"");
    }
 else {
      StringBuffer sb=new StringBuffer();
      ArrayList<String> namelist=new ArrayList<String>();
      for (int j=0; j < currTree.getExternalNodeCount(); j++) {
        namelist.add(currTree.getExternalNode(j).getName());
      }
      HashMap<String,Object> namemap=new HashMap<String,Object>();
      namemap.put(""String_Node_Str"",namelist);
      String contextQueryParameters=new JSONObject(namemap).toJSONString();
      System.out.println(contextQueryParameters);
      ClientConfig cc=new DefaultClientConfig();
      Client c=Client.create(cc);
      WebResource contextQuery=c.resource(urlbasecontext);
      String contextResponseJSONStr=contextQuery.accept(MediaType.APPLICATION_JSON_TYPE).type(MediaType.APPLICATION_JSON_TYPE).post(String.class,contextQueryParameters);
      JSONObject contextResponse=(JSONObject)JSONValue.parse(contextResponseJSONStr);
      String cn=(String)contextResponse.get(""String_Node_Str"");
      ArrayList<String> namelist2=new ArrayList<String>();
      for (int j=0; j < searchnds.size(); j++) {
        if (searchnds.get(j).getObject(""String_Node_Str"") == null) {
          namelist2.add(searchnds.get(j).getName());
        }
      }
      HashMap<String,Object> namemap2=new HashMap<String,Object>();
      namemap2.put(""String_Node_Str"",namelist2);
      namemap2.put(""String_Node_Str"",cn);
      contextQueryParameters=new JSONObject(namemap2).toJSONString();
      cc=new DefaultClientConfig();
      c=Client.create(cc);
      contextQuery=c.resource(urlbasefetch);
      String tnrsResponseJSONStr=null;
      try {
        tnrsResponseJSONStr=contextQuery.accept(MediaType.APPLICATION_JSON_TYPE).type(MediaType.APPLICATION_JSON_TYPE).post(String.class,contextQueryParameters);
      }
 catch (      Exception x) {
        logger.indentMessageStr(1,""String_Node_Str"",""String_Node_Str"",contextQueryParameters);
      }
      if (tnrsResponseJSONStr != null) {
        contextResponse=(JSONObject)JSONValue.parse(tnrsResponseJSONStr);
        JSONArray unm=(JSONArray)contextResponse.get(""String_Node_Str"");
        logger.indentMessageInt(1,""String_Node_Str"",""String_Node_Str"",unm.size());
        JSONArray res=(JSONArray)contextResponse.get(""String_Node_Str"");
        for (        Object id : res) {
          JSONArray tres=(JSONArray)((JSONObject)id).get(""String_Node_Str"");
          String origname=(String)((JSONObject)id).get(""String_Node_Str"");
          for (          Object tid : tres) {
            Double score=(Double)((JSONObject)tid).get(""String_Node_Str"");
            boolean permat=(Boolean)((JSONObject)tid).get(""String_Node_Str"");
            String ottId=String.valueOf(((JSONObject)tid).get(""String_Node_Str""));
            String matchedName=(String)((JSONObject)tid).get(""String_Node_Str"");
            if (score >= 1) {
              Long tnrsottId=Long.valueOf(ottId);
              JadeNode fixedNode=namenodemap.get(origname);
              logger.indentMessageLongStrStrStr(2,""String_Node_Str"",""String_Node_Str"",tnrsottId,""String_Node_Str"",matchedName,""String_Node_Str"",origname,""String_Node_Str"",(String)fixedNode.getObject(""String_Node_Str""));
              fixedNode.assocObject(""String_Node_Str"",tnrsottId);
              matchednodes.add(namenodemap.get(origname));
              namenodemap.remove(origname);
              break;
            }
          }
        }
      }
      Index<Node> graphNodeIndex=graphDb.getNodeIndex(""String_Node_Str"");
      ArrayList<String> removenames=new ArrayList<String>();
      for (      String name : namenodemap.keySet()) {
        IndexHits<Node> hits=graphNodeIndex.get(""String_Node_Str"",name);
        if (hits.size() == 0) {
        }
 else         if (hits.size() == 1) {
          String uidString=(String)hits.getSingle().getProperty(""String_Node_Str"");
          Long lid=Long.valueOf(uidString);
          logger.indentMessageLong(2,""String_Node_Str"",name,lid);
          namenodemap.get(name).assocObject(""String_Node_Str"",Long.valueOf(lid));
          removenames.add(name);
        }
 else         if (hits.size() > 1) {
          logger.indentMessageInt(2,""String_Node_Str"",name,hits.size());
        }
        hits.close();
      }
      for (      String name : removenames) {
        namenodemap.remove(name);
      }
      if (namenodemap.size() > 0) {
        if (prune) {
          for (          String name : namenodemap.keySet()) {
            JadeNode jnode=namenodemap.get(name);
            logger.indentMessageStrStr(2,""String_Node_Str"",""String_Node_Str"",name,""String_Node_Str"",(String)jnode.getObject(""String_Node_Str""));
            try {
              currTree.pruneExternalNode(jnode);
            }
 catch (            Exception x) {
              logger.indentMessageStr(3,""String_Node_Str"",""String_Node_Str"",name);
              return false;
            }
          }
        }
 else {
          return false;
        }
      }
    }
    if (prune) {
      TLongHashSet tipottols=new TLongHashSet();
      HashSet<JadeNode> pru=new HashSet<JadeNode>();
      for (int j=0; j < currTree.getExternalNodeCount(); j++) {
        JadeNode currNd=currTree.getExternalNode(j);
        Long tid=(Long)currNd.getObject(""String_Node_Str"");
        if (tid == null) {
          logger.indentMessage(2,""String_Node_Str"");
          logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNd.getName(),""String_Node_Str"",(String)currNd.getObject(""String_Node_Str""));
          pru.add(currNd);
        }
 else         if (tipottols.contains(tid)) {
          logger.indentMessage(2,""String_Node_Str"");
          logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNd.getName(),""String_Node_Str"",(String)currNd.getObject(""String_Node_Str""));
          logger.indentMessageLong(3,""String_Node_Str"",""String_Node_Str"",tid);
          pru.add(currNd);
        }
 else {
          IndexHits<Node> hits=graphDb.getNodeIndex(""String_Node_Str"").get(""String_Node_Str"",String.valueOf(tid));
          if (hits.size() == 0) {
            logger.indentMessage(2,""String_Node_Str"");
            logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNd.getName(),""String_Node_Str"",(String)currNd.getObject(""String_Node_Str""));
            logger.indentMessageLong(3,""String_Node_Str"",""String_Node_Str"",tid);
            pru.add(currNd);
          }
 else {
            tipottols.add(tid);
          }
          hits.close();
        }
      }
      for (int j=0; j < currTree.getExternalNodeCount(); j++) {
        JadeNode currNdJ=currTree.getExternalNode(j);
        if (pru.contains(currNdJ)) {
          continue;
        }
        Long tid=(Long)currNdJ.getObject(""String_Node_Str"");
        IndexHits<Node> hits=graphDb.getNodeIndex(""String_Node_Str"").get(""String_Node_Str"",String.valueOf(tid));
        Node firstNode=hits.getSingle();
        hits.close();
        TLongArrayList t1=new TLongArrayList((long[])firstNode.getProperty(""String_Node_Str""));
        for (int k=0; k < currTree.getExternalNodeCount(); k++) {
          JadeNode currNdK=currTree.getExternalNode(k);
          if (pru.contains(currNdK) || k == j) {
            continue;
          }
          Long tid2=(Long)currNdK.getObject(""String_Node_Str"");
          IndexHits<Node> hits2=graphDb.getNodeIndex(""String_Node_Str"").get(""String_Node_Str"",String.valueOf(tid2));
          Node secondNode=hits2.getSingle();
          hits2.close();
          if (secondNode == null) {
            logger.indentMessageStr(2,""String_Node_Str"",""String_Node_Str"",String.valueOf(tid2));
            pru.add(currNdK);
          }
 else {
            TLongArrayList t2=new TLongArrayList((long[])secondNode.getProperty(""String_Node_Str""));
            if (LicaUtil.containsAnyt4jUnsorted(t1,t2)) {
              logger.indentMessage(2,""String_Node_Str"");
              if (t2.size() < t1.size()) {
                pru.add(currNdJ);
                logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNdK.getName(),""String_Node_Str"",(String)currNdK.getObject(""String_Node_Str""));
                logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNdJ.getName(),""String_Node_Str"",(String)currNdJ.getObject(""String_Node_Str""));
                break;
              }
 else {
                pru.add(currNdK);
                logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNdJ.getName(),""String_Node_Str"",(String)currNdJ.getObject(""String_Node_Str""));
                logger.indentMessageStrStr(3,""String_Node_Str"",""String_Node_Str"",currNdK.getName(),""String_Node_Str"",(String)currNdK.getObject(""String_Node_Str""));
              }
            }
          }
        }
      }
      for (      JadeNode tn : pru) {
        logger.indentMessageStrStr(2,""String_Node_Str"",""String_Node_Str"",tn.getName(),""String_Node_Str"",(String)tn.getObject(""String_Node_Str""));
        try {
          currTree.pruneExternalNode(tn);
        }
 catch (        Exception x) {
          logger.indentMessageStr(3,""String_Node_Str"",""String_Node_Str"",tn.getName());
          return false;
        }
      }
      currTree.processRoot();
      if (prune == true) {
        logger.indentMessageStr(1,""String_Node_Str"",""String_Node_Str"",currTree.getRoot().getNewick(false));
      }
    }
    logger.indentMessage(1,""String_Node_Str"");
    for (int k=0; k < currTree.getExternalNodeCount(); k++) {
      JadeNode ndK=currTree.getExternalNode(k);
      Long tid=(Long)ndK.getObject(""String_Node_Str"");
      IndexHits<Node> hits=graphDb.getNodeIndex(""String_Node_Str"").get(""String_Node_Str"",String.valueOf(tid));
      Node firstNode=hits.getSingle();
      hits.close();
      Node cnode=firstNode;
      if (cnode == null) {
        logger.indentMessageLongStrStr(2,""String_Node_Str"",""String_Node_Str"",tid,""String_Node_Str"",ndK.getName(),""String_Node_Str"",(String)ndK.getObject(""String_Node_Str""));
      }
 else {
        String cnodeName=(String)cnode.getProperty(""String_Node_Str"");
        StringBuffer sb=new StringBuffer();
        sb.append(cnodeName == null ? ""String_Node_Str"" : cnodeName);
        while (cnode.hasRelationship(Direction.OUTGOING,RelType.TAXCHILDOF)) {
          cnode=cnode.getSingleRelationship(RelType.TAXCHILDOF,Direction.OUTGOING).getEndNode();
          cnodeName=(String)cnode.getProperty(""String_Node_Str"");
          sb.append(""String_Node_Str"");
          sb.append(cnodeName == null ? ""String_Node_Str"" : cnodeName);
        }
        logger.indentMessageLongStrStr(2,""String_Node_Str"",""String_Node_Str"",tid,""String_Node_Str"",sb.toString(),""String_Node_Str"",(String)ndK.getObject(""String_Node_Str""));
      }
    }
  }
  return true;
}"
50194,"public int synthesizeDraftTreeWithListForTaxUID(String[] args) throws Exception {
  String graphname=args[3];
  GraphExplorer ge=new GraphExplorer(graphname);
  String ottolId=args[1];
  String startNodeIdStr=String.valueOf(ge.findGraphTaxNodeByUID(ottolId).getId());
  args[1]=startNodeIdStr;
  return synthesizeDraftTreeWithListForNodeId(args);
}","public int synthesizeDraftTreeWithListForTaxUID(String[] args) throws Exception {
  String graphname=args[3];
  GraphExplorer ge=new GraphExplorer(graphname);
  String ottolId=args[1];
  String startNodeIdStr=String.valueOf(ge.findGraphTaxNodeByUID(ottolId).getId());
  args[1]=startNodeIdStr;
  ge.shutdownDB();
  return synthesizeDraftTreeWithListForNodeId(args);
}"
50195,"public int extractDraftTreeForOttId(String[] args) throws OttolIdNotFoundException, MultipleHitsException, TaxonNotFoundException {
  String graphname=args[3];
  GraphExplorer ge=new GraphExplorer(graphname);
  String ottolId=args[1];
  String startNodeIdStr=String.valueOf(ge.findGraphTaxNodeByUID(ottolId).getId());
  args[1]=startNodeIdStr;
  return extractDraftTreeForNodeId(args);
}","public int extractDraftTreeForOttId(String[] args) throws OttolIdNotFoundException, MultipleHitsException, TaxonNotFoundException {
  String graphname=args[3];
  GraphExplorer ge=new GraphExplorer(graphname);
  String ottolId=args[1];
  String startNodeIdStr=String.valueOf(ge.findGraphTaxNodeByUID(ottolId).getId());
  args[1]=startNodeIdStr;
  ge.shutdownDB();
  return extractDraftTreeForNodeId(args);
}"
50196,"@Override public Evaluation evaluate(Path arg0){
  Node tn=arg0.endNode();
  if (visited.contains(tn.getId())) {
    return Evaluation.EXCLUDE_AND_PRUNE;
  }
  visited.add(tn.getId());
  TLongArrayList ttm=new TLongArrayList((long[])tn.getProperty(""String_Node_Str""));
  BitSet tm=new BitSet((int)ttm.max());
  for (int i=0; i < ttm.size(); i++) {
    tm.set((int)ttm.getQuick(i));
  }
  boolean taxnode=false;
  BitSet to=null;
  TLongArrayList tto=null;
  if (tn.hasProperty(""String_Node_Str"") == false) {
    taxnode=true;
  }
 else {
    tto=new TLongArrayList((long[])tn.getProperty(""String_Node_Str""));
    to=new BitSet((int)tto.max());
    for (int i=0; i < tto.size(); i++) {
      to.set((int)tto.getQuick(i));
    }
  }
  if (taxnode == false) {
    if (tm.intersects(outIdBS) == false) {
      if (to.intersects(inIdBS) == false) {
        if (tm.intersects(inIdBS) == true) {
          boolean tmt=false;
          boolean checkParents=false;
          BitSet inIdBS2=(BitSet)inIdBS.clone();
          inIdBS2.andNot(tm);
          for (int i=0; i < inIdBS2.length(); i++) {
            if (inIdBS2.get(i) == true) {
              ttm.add(i);
              tmt=true;
            }
          }
          if (tmt) {
            ttm.sort();
            tn.setProperty(""String_Node_Str"",ttm.toArray());
            checkParents=true;
          }
          tmt=false;
          BitSet outIdBS2=(BitSet)outIdBS.clone();
          outIdBS2.andNot(to);
          for (int i=0; i < outIdBS2.length(); i++) {
            if (outIdBS2.get(i) == true) {
              tto.add(i);
              tmt=true;
            }
          }
          if (tmt) {
            tto.sort();
            tn.setProperty(""String_Node_Str"",tto.toArray());
            checkParents=true;
          }
          if (checkParents) {
            for (            Node pNode : Traversal.description().breadthFirst().evaluator(new MRCAValidatingEvaluator(ttm,tto)).relationships(RelType.STREECHILDOF,Direction.OUTGOING).traverse(tn).nodes()) {
              System.out.println(""String_Node_Str"" + pNode + ""String_Node_Str"");
              pNode.setProperty(""String_Node_Str"",ttm.toArray());
              TLongArrayList ingroupIds=new TLongArrayList();
              for (              Relationship childRel : pNode.getRelationships(RelType.STREECHILDOF,Direction.INCOMING)) {
                ingroupIds.addAll((long[])childRel.getStartNode().getProperty(""String_Node_Str""));
              }
              tto.removeAll(ingroupIds);
              pNode.setProperty(""String_Node_Str"",tto.toArray());
            }
          }
          return Evaluation.INCLUDE_AND_PRUNE;
        }
      }
    }
  }
 else {
    if (outIdBS.intersects(tm) == false) {
      tm.and(inIdBS);
      if (inIdBS.cardinality() == tm.cardinality()) {
        return Evaluation.INCLUDE_AND_PRUNE;
      }
    }
  }
  return Evaluation.EXCLUDE_AND_CONTINUE;
}","@Override public Evaluation evaluate(Path arg0){
  Node tn=arg0.endNode();
  if (visited.contains(tn.getId())) {
    return Evaluation.EXCLUDE_AND_PRUNE;
  }
  visited.add(tn.getId());
  TLongArrayList ttm=new TLongArrayList((long[])tn.getProperty(""String_Node_Str""));
  BitSet tm=new BitSet((int)ttm.max());
  for (int i=0; i < ttm.size(); i++) {
    tm.set((int)ttm.getQuick(i));
  }
  boolean taxnode=false;
  BitSet to=null;
  TLongArrayList tto=null;
  if (tn.hasProperty(""String_Node_Str"") == false) {
    taxnode=true;
  }
 else {
    tto=new TLongArrayList((long[])tn.getProperty(""String_Node_Str""));
    to=new BitSet((int)tto.max());
    for (int i=0; i < tto.size(); i++) {
      to.set((int)tto.getQuick(i));
    }
  }
  if (taxnode == false) {
    if (tm.intersects(outIdBS) == false) {
      if (to.intersects(inIdBS) == false) {
        if (tm.intersects(inIdBS) == true) {
          boolean tmt=false;
          boolean checkParents=false;
          BitSet inIdBS2=(BitSet)inIdBS.clone();
          inIdBS2.andNot(tm);
          for (int i=0; i < inIdBS2.length(); i++) {
            if (inIdBS2.get(i) == true) {
              ttm.add(i);
              tmt=true;
            }
          }
          if (tmt) {
            ttm.sort();
            tn.setProperty(""String_Node_Str"",ttm.toArray());
            checkParents=true;
          }
          tmt=false;
          BitSet outIdBS2=(BitSet)outIdBS.clone();
          outIdBS2.andNot(to);
          for (int i=0; i < outIdBS2.length(); i++) {
            if (outIdBS2.get(i) == true) {
              tto.add(i);
              tmt=true;
            }
          }
          if (tmt) {
            tto.sort();
            tn.setProperty(""String_Node_Str"",tto.toArray());
            checkParents=true;
          }
          if (checkParents) {
            for (            Node pNode : Traversal.description().breadthFirst().evaluator(new MRCAValidatingEvaluator(ttm,tto)).relationships(RelType.STREECHILDOF,Direction.OUTGOING).traverse(tn).nodes()) {
              System.out.println(""String_Node_Str"" + pNode + ""String_Node_Str"");
              TLongArrayList mrcaNew=new TLongArrayList((long[])pNode.getProperty(""String_Node_Str""));
              mrcaNew.addAll(tto);
              pNode.setProperty(""String_Node_Str"",mrcaNew.toArray());
              tto.removeAll(mrcaNew);
              TLongArrayList outmrcaNew=new TLongArrayList((long[])pNode.getProperty(""String_Node_Str""));
              outmrcaNew.addAll(tto);
              pNode.setProperty(""String_Node_Str"",outmrcaNew.toArray());
            }
          }
          return Evaluation.INCLUDE_AND_PRUNE;
        }
      }
    }
  }
 else {
    if (outIdBS.intersects(tm) == false) {
      tm.and(inIdBS);
      if (inIdBS.cardinality() == tm.cardinality()) {
        return Evaluation.INCLUDE_AND_PRUNE;
      }
    }
  }
  return Evaluation.EXCLUDE_AND_CONTINUE;
}"
50197,"/** 
 * The synthesis method for creating the draft tree. Uses the refactored synthesis classes. This will store the synthesized topology as SYNTHCHILDOF relationships in the graph.
 * @param startNode this is the beginning node for analysis
 * @param preferredSourceIds this includes the list of preferred sources
 * @param test this will just run through the motions but won't store the synthesis 
 * @throws Exception 
 */
public boolean synthesizeAndStoreDraftTreeBranches(Node startNode,Iterable<String> preferredSourceIds,boolean test) throws Exception {
  ArrayList<Object> sourceIdPriorityList=new ArrayList<Object>();
  for (  String sourceId : preferredSourceIds) {
    sourceIdPriorityList.add(sourceId);
  }
  ArrayList<Object> justSourcePriorityList=new ArrayList<Object>();
  for (  String sourceId : preferredSourceIds) {
    justSourcePriorityList.add(sourceId.split(""String_Node_Str"")[0]);
  }
  ResolvingExpander draftSynthesisMethod=new ResolvingExpander();
  RelationshipFilter rf=new RelationshipFilter();
  HashSet<String> filteredsources=new HashSet<String>();
  IndexHits<Node> hits=sourceMetaIndex.query(""String_Node_Str"",""String_Node_Str"");
  while (hits.hasNext()) {
    Node n=hits.next();
    if (n.hasProperty(""String_Node_Str"")) {
      if (justSourcePriorityList.contains(n.getProperty(""String_Node_Str"")) == false) {
        filteredsources.add((String)n.getProperty(""String_Node_Str""));
      }
    }
 else {
      if (justSourcePriorityList.contains(n.getProperty(""String_Node_Str"")) == false) {
        filteredsources.add((String)n.getProperty(""String_Node_Str""));
      }
    }
  }
  System.out.println(""String_Node_Str"" + filteredsources);
  if (filteredsources.size() > 0) {
    rf.addCriterion(new SourcePropertyFilterCriterion(SourceProperty.STUDY_ID,FilterComparisonType.CONTAINS,new TestValue(filteredsources),sourceMetaIndex));
    draftSynthesisMethod.setFilter(rf);
  }
  RelationshipRanker rs=new RelationshipRanker();
  rs.addCriterion(new SourcePropertyPrioritizedRankingCriterion(SourceProperty.STUDY_ID,sourceIdPriorityList,sourceMetaIndex));
  rs.addCriterion(new SourcePropertyRankingCriterion(SourceProperty.YEAR,RankingOrder.DECREASING,sourceMetaIndex));
  draftSynthesisMethod.setRanker(rs);
  RelationshipConflictResolver rcr=new RelationshipConflictResolver(new RankResolutionMethod());
  draftSynthesisMethod.setConflictResolver(rcr);
  System.out.println(""String_Node_Str"" + draftSynthesisMethod.getDescription());
  Transaction tx=graphDb.beginTx();
  String synthTreeName=DRAFTTREENAME;
  try {
    Node metadatanode=graphDb.createNode();
    metadatanode.createRelationshipTo(startNode,RelType.SYNTHMETADATAFOR);
    metadatanode.setProperty(""String_Node_Str"",synthTreeName);
    Date date=new Date();
    metadatanode.setProperty(""String_Node_Str"",date.toString());
    metadatanode.setProperty(""String_Node_Str"",sourceIdPriorityList);
    tx.success();
  }
 catch (  Exception ex) {
    tx.failure();
    throw ex;
  }
 finally {
    tx.finish();
  }
  Node originalParent=null;
  knownIdsInTree=new HashSet<Long>();
  tx=graphDb.beginTx();
  try {
    for (    Relationship rel : Traversal.description().breadthFirst().expand(draftSynthesisMethod).traverse(startNode).relationships()) {
      Node parentNode=rel.getEndNode();
      Node curNode=rel.getStartNode();
      if (parentNode != null && test == false) {
        Relationship newRel=curNode.createRelationshipTo(parentNode,RelType.SYNTHCHILDOF);
        newRel.setProperty(""String_Node_Str"",synthTreeName);
        HashSet<String> sources=new HashSet<String>();
        for (        Relationship rel2 : curNode.getRelationships(RelType.STREECHILDOF)) {
          if (rel2.hasProperty(""String_Node_Str"")) {
            sources.add(String.valueOf(rel2.getProperty(""String_Node_Str"")));
          }
        }
        String[] sourcesArray=new String[sources.size()];
        Iterator<String> sourcesIter=sources.iterator();
        for (int i=0; i < sources.size(); i++) {
          sourcesArray[i]=sourcesIter.next();
        }
        newRel.setProperty(""String_Node_Str"",sourcesArray);
      }
      knownIdsInTree.add(curNode.getId());
    }
    tx.success();
  }
 catch (  Exception ex) {
    tx.failure();
    throw ex;
  }
 finally {
    tx.finish();
  }
  if (!test) {
    tx=graphDb.beginTx();
    try {
      addMissingChildrenToDraftTreeWhile(startNode,startNode);
      tx.success();
    }
 catch (    Exception ex) {
      tx.failure();
      ex.printStackTrace();
    }
 finally {
      tx.finish();
    }
  }
  System.out.println(""String_Node_Str"");
  return true;
}","/** 
 * The synthesis method for creating the draft tree. Uses the refactored synthesis classes. This will store the synthesized topology as SYNTHCHILDOF relationships in the graph.
 * @param startNode this is the beginning node for analysis
 * @param preferredSourceIds this includes the list of preferred sources
 * @param test this will just run through the motions but won't store the synthesis 
 * @throws Exception 
 */
public boolean synthesizeAndStoreDraftTreeBranches(Node startNode,Iterable<String> preferredSourceIds,boolean test) throws Exception {
  ArrayList<Object> sourceIdPriorityList=new ArrayList<Object>();
  for (  String sourceId : preferredSourceIds) {
    sourceIdPriorityList.add(sourceId);
  }
  ArrayList<Object> justSourcePriorityList=new ArrayList<Object>();
  for (  String sourceId : preferredSourceIds) {
    justSourcePriorityList.add(sourceId.split(""String_Node_Str"")[0]);
  }
  ResolvingExpander draftSynthesisMethod=new ResolvingExpander();
  RelationshipFilter rf=new RelationshipFilter();
  HashSet<String> filteredsources=new HashSet<String>();
  IndexHits<Node> hits=sourceMetaIndex.query(""String_Node_Str"",""String_Node_Str"");
  while (hits.hasNext()) {
    Node n=hits.next();
    if (n.hasProperty(""String_Node_Str"")) {
      if (justSourcePriorityList.contains(n.getProperty(""String_Node_Str"")) == false) {
        filteredsources.add((String)n.getProperty(""String_Node_Str""));
      }
    }
 else {
      if (justSourcePriorityList.contains(n.getProperty(""String_Node_Str"")) == false) {
        filteredsources.add((String)n.getProperty(""String_Node_Str""));
      }
    }
  }
  System.out.println(""String_Node_Str"" + filteredsources);
  if (filteredsources.size() > 0) {
    rf.addCriterion(new SourcePropertyFilterCriterion(SourceProperty.STUDY_ID,FilterComparisonType.CONTAINS,new TestValue(filteredsources),sourceMetaIndex));
    draftSynthesisMethod.setFilter(rf);
  }
  RelationshipRanker rs=new RelationshipRanker();
  rs.addCriterion(new SourcePropertyPrioritizedRankingCriterion(SourceProperty.STUDY_ID,sourceIdPriorityList,sourceMetaIndex));
  rs.addCriterion(new SourcePropertyRankingCriterion(SourceProperty.YEAR,RankingOrder.DECREASING,sourceMetaIndex));
  draftSynthesisMethod.setRanker(rs);
  RelationshipConflictResolver rcr=new RelationshipConflictResolver(new RankResolutionMethod());
  draftSynthesisMethod.setConflictResolver(rcr);
  System.out.println(""String_Node_Str"" + draftSynthesisMethod.getDescription());
  Transaction tx=graphDb.beginTx();
  String synthTreeName=DRAFTTREENAME;
  try {
    Node metadatanode=graphDb.createNode();
    metadatanode.createRelationshipTo(startNode,RelType.SYNTHMETADATAFOR);
    metadatanode.setProperty(""String_Node_Str"",synthTreeName);
    Date date=new Date();
    metadatanode.setProperty(""String_Node_Str"",date.toString());
    tx.success();
  }
 catch (  Exception ex) {
    tx.failure();
    throw ex;
  }
 finally {
    tx.finish();
  }
  Node originalParent=null;
  knownIdsInTree=new HashSet<Long>();
  tx=graphDb.beginTx();
  try {
    for (    Relationship rel : Traversal.description().breadthFirst().expand(draftSynthesisMethod).traverse(startNode).relationships()) {
      Node parentNode=rel.getEndNode();
      Node curNode=rel.getStartNode();
      if (parentNode != null && test == false) {
        Relationship newRel=curNode.createRelationshipTo(parentNode,RelType.SYNTHCHILDOF);
        newRel.setProperty(""String_Node_Str"",synthTreeName);
        HashSet<String> sources=new HashSet<String>();
        for (        Relationship rel2 : curNode.getRelationships(RelType.STREECHILDOF)) {
          if (rel2.hasProperty(""String_Node_Str"")) {
            sources.add(String.valueOf(rel2.getProperty(""String_Node_Str"")));
          }
        }
        String[] sourcesArray=new String[sources.size()];
        Iterator<String> sourcesIter=sources.iterator();
        for (int i=0; i < sources.size(); i++) {
          sourcesArray[i]=sourcesIter.next();
        }
        newRel.setProperty(""String_Node_Str"",sourcesArray);
      }
      knownIdsInTree.add(curNode.getId());
    }
    tx.success();
  }
 catch (  Exception ex) {
    tx.failure();
    throw ex;
  }
 finally {
    tx.finish();
  }
  if (!test) {
    tx=graphDb.beginTx();
    try {
      addMissingChildrenToDraftTreeWhile(startNode,startNode);
      tx.success();
    }
 catch (    Exception ex) {
      tx.failure();
      ex.printStackTrace();
    }
 finally {
      tx.finish();
    }
  }
  System.out.println(""String_Node_Str"");
  return true;
}"
50198,"/** 
 * @param args
 * @throws MultipleHitsException 
 */
public static void main(String[] args) throws MultipleHitsException {
  if (args.length < 1) {
    printHelp();
    System.exit(1);
  }
  String command=args[0];
  if (command.compareTo(""String_Node_Str"") == 0) {
    printHelp();
    System.exit(0);
  }
  System.err.println(""String_Node_Str"");
  int cmdReturnCode=0;
  try {
    MainRunner mr=new MainRunner();
    if (args.length < 2) {
      System.err.println(""String_Node_Str"");
      printHelp();
    }
    if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.taxonomyLoadParser(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0 || command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.graphImporterParser(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.graphArgusJSON(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0 || command.compareTo(""String_Node_Str"") == 0 || command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.graphExplorerParser(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.mrpDumpParser(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.graphListPruner(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.justTreeAnalysis(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0 || command.equalsIgnoreCase(""String_Node_Str"")) {
      cmdReturnCode=mr.sourceTreeExplorer(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0 || command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.listSources(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.graphExporter(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.graphExplorerBiparts(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.graphExplorerMapSupport(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.graphReloadTrees(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.graphDeleteTrees(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.csvDumpParser(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.getLicaNames(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0 || command.compareTo(""String_Node_Str"") == 0 || command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.treeUtils(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0 || command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.treeUtilsDB(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.synthesizeDraftTree(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.synthesizeDraftTreeWithList(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.extractDraftTree(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.extractDraftSubTreeForOttIDs(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.addTaxonomyMetadataNodeToIndex(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.nexson2newick(args);
    }
 else     if (command.equals(""String_Node_Str"")) {
      cmdReturnCode=mr.nodeInfo(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.makePrunedBipartsTestFiles(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.pg_loading(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.pg_loading_ind_studies(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.pgtesting(args);
    }
 else {
      System.err.println(""String_Node_Str"" + command + ""String_Node_Str"");
      cmdReturnCode=2;
    }
  }
 catch (  StoredEntityNotFoundException tnfx) {
    String action=""String_Node_Str"" + command + ""String_Node_Str"";
    tnfx.reportFailedAction(System.err,action);
  }
catch (  TreeIngestException tix) {
    String action=""String_Node_Str"" + command + ""String_Node_Str"";
    tix.reportFailedAction(System.err,action);
  }
catch (  DataFormatException dfx) {
    String action=""String_Node_Str"" + command + ""String_Node_Str"";
    dfx.reportFailedAction(System.err,action);
  }
  if (cmdReturnCode == 2) {
    printHelp();
  }
  System.exit(cmdReturnCode);
}","/** 
 * @param args
 * @throws Exception 
 */
public static void main(String[] args) throws Exception {
  if (args.length < 1) {
    printHelp();
    System.exit(1);
  }
  String command=args[0];
  if (command.compareTo(""String_Node_Str"") == 0) {
    printHelp();
    System.exit(0);
  }
  System.err.println(""String_Node_Str"");
  int cmdReturnCode=0;
  try {
    MainRunner mr=new MainRunner();
    if (args.length < 2) {
      System.err.println(""String_Node_Str"");
      printHelp();
    }
    if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.taxonomyLoadParser(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0 || command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.graphImporterParser(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.graphArgusJSON(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0 || command.compareTo(""String_Node_Str"") == 0 || command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.graphExplorerParser(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.mrpDumpParser(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.graphListPruner(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.justTreeAnalysis(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0 || command.equalsIgnoreCase(""String_Node_Str"")) {
      cmdReturnCode=mr.sourceTreeExplorer(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0 || command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.listSources(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.graphExporter(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.graphExplorerBiparts(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.graphExplorerMapSupport(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.graphReloadTrees(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.graphDeleteTrees(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.csvDumpParser(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.getLicaNames(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0 || command.compareTo(""String_Node_Str"") == 0 || command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.treeUtils(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0 || command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.treeUtilsDB(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.synthesizeDraftTree(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.synthesizeDraftTreeWithList(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.extractDraftTree(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.extractDraftSubTreeForOttIDs(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.addTaxonomyMetadataNodeToIndex(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.nexson2newick(args);
    }
 else     if (command.equals(""String_Node_Str"")) {
      cmdReturnCode=mr.nodeInfo(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.makePrunedBipartsTestFiles(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.pg_loading(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.pg_loading_ind_studies(args);
    }
 else     if (command.compareTo(""String_Node_Str"") == 0) {
      cmdReturnCode=mr.pgtesting(args);
    }
 else {
      System.err.println(""String_Node_Str"" + command + ""String_Node_Str"");
      cmdReturnCode=2;
    }
  }
 catch (  StoredEntityNotFoundException tnfx) {
    String action=""String_Node_Str"" + command + ""String_Node_Str"";
    tnfx.reportFailedAction(System.err,action);
  }
catch (  TreeIngestException tix) {
    String action=""String_Node_Str"" + command + ""String_Node_Str"";
    tix.reportFailedAction(System.err,action);
  }
catch (  DataFormatException dfx) {
    String action=""String_Node_Str"" + command + ""String_Node_Str"";
    dfx.reportFailedAction(System.err,action);
  }
  if (cmdReturnCode == 2) {
    printHelp();
  }
  System.exit(cmdReturnCode);
}"
50199,"public int synthesizeDraftTreeWithList(String[] args) throws OttolIdNotFoundException, MultipleHitsException, TaxonNotFoundException {
  boolean test=false;
  if (args.length != 4 && args.length != 5) {
    System.out.println(""String_Node_Str"");
    return 1;
  }
  if (args.length == 5) {
    System.out.println(""String_Node_Str"");
    test=true;
  }
  String ottolId=args[1];
  String slist=args[2];
  String graphname=args[3];
  boolean success=false;
  GraphExplorer ge=new GraphExplorer(graphname);
  try {
    LinkedList<String> preferredSources=new LinkedList<String>();
    String[] tsl=slist.split(""String_Node_Str"");
    for (int i=0; i < tsl.length; i++) {
      preferredSources.add(tsl[i]);
    }
    System.out.println(preferredSources);
    Node firstNode=ge.findGraphTaxNodeByUID(ottolId);
    if (firstNode == null) {
      throw new opentree.exceptions.OttolIdNotFoundException(ottolId);
    }
    success=ge.synthesizeAndStoreDraftTreeBranches(firstNode,preferredSources,test);
    System.out.println(""String_Node_Str"");
  }
 catch (  OttolIdNotFoundException oex) {
    oex.printStackTrace();
  }
 finally {
    ge.shutdownDB();
  }
  return (success ? 0 : -1);
}","public int synthesizeDraftTreeWithList(String[] args) throws Exception {
  boolean test=false;
  if (args.length != 4 && args.length != 5) {
    System.out.println(""String_Node_Str"");
    return 1;
  }
  if (args.length == 5) {
    System.out.println(""String_Node_Str"");
    test=true;
  }
  String ottolId=args[1];
  String slist=args[2];
  String graphname=args[3];
  boolean success=false;
  GraphExplorer ge=new GraphExplorer(graphname);
  try {
    LinkedList<String> preferredSources=new LinkedList<String>();
    String[] tsl=slist.split(""String_Node_Str"");
    for (int i=0; i < tsl.length; i++) {
      preferredSources.add(tsl[i]);
    }
    System.out.println(preferredSources);
    Node firstNode=ge.findGraphTaxNodeByUID(ottolId);
    if (firstNode == null) {
      throw new opentree.exceptions.OttolIdNotFoundException(ottolId);
    }
    success=ge.synthesizeAndStoreDraftTreeBranches(firstNode,preferredSources,test);
    System.out.println(""String_Node_Str"");
  }
 catch (  OttolIdNotFoundException oex) {
    oex.printStackTrace();
  }
 finally {
    ge.shutdownDB();
  }
  return (success ? 0 : -1);
}"
50200,"public int synthesizeDraftTree(String[] args) throws OttolIdNotFoundException, MultipleHitsException, TaxonNotFoundException {
  boolean test=false;
  if (args.length != 3) {
    System.out.println(""String_Node_Str"");
    return 1;
  }
  String ottolId=args[1];
  String graphname=args[2];
  boolean success=false;
  GraphExplorer ge=new GraphExplorer(graphname);
  try {
    LinkedList<String> preferredSources=new LinkedList<String>();
    preferredSources.add(""String_Node_Str"");
    preferredSources.add(""String_Node_Str"");
    Node firstNode=ge.findGraphTaxNodeByUID(ottolId);
    if (firstNode == null) {
      throw new opentree.exceptions.OttolIdNotFoundException(ottolId);
    }
    success=ge.synthesizeAndStoreDraftTreeBranches(firstNode,preferredSources,test);
  }
 catch (  OttolIdNotFoundException oex) {
    oex.printStackTrace();
  }
 finally {
    ge.shutdownDB();
  }
  return (success ? 0 : -1);
}","public int synthesizeDraftTree(String[] args) throws Exception {
  boolean test=false;
  if (args.length != 3) {
    System.out.println(""String_Node_Str"");
    return 1;
  }
  String ottolId=args[1];
  String graphname=args[2];
  boolean success=false;
  GraphExplorer ge=new GraphExplorer(graphname);
  try {
    LinkedList<String> preferredSources=new LinkedList<String>();
    preferredSources.add(""String_Node_Str"");
    preferredSources.add(""String_Node_Str"");
    Node firstNode=ge.findGraphTaxNodeByUID(ottolId);
    if (firstNode == null) {
      throw new opentree.exceptions.OttolIdNotFoundException(ottolId);
    }
    success=ge.synthesizeAndStoreDraftTreeBranches(firstNode,preferredSources,test);
  }
 catch (  OttolIdNotFoundException oex) {
    oex.printStackTrace();
  }
 finally {
    ge.shutdownDB();
  }
  return (success ? 0 : -1);
}"
50201,"/** 
 * Ingest the current JadeTree (in the jt data member) to the GoL. this should be done as a preorder traversal
 * @param focalgroup a taxonomic name of the ancestor of the leaves in the treethis is only used in disambiguating taxa when there are multiple hits  for a leaf's taxonomic name
 * @param sourcename the name to be registered as the ""source"" property forevery edge in this tree.
 * @throws TaxonNotFoundException 
 * @throws MultipleHitsException 
 * @todo we probably want a node in the graph representing the tree with an ISROOTOF edge from its root to the tree. We could attach annotations about the tree to this node. We have the index of the root node, but need to having and isroot would also be helpful. Unless we are indexing this we could just randomly choose one of the edges that is connected to the root node that is in the index
 */
public void addSetTreeToGraph(String focalgroup,String sourceName,boolean allTreesHaveAllTaxa,MessageLogger msgLogger) throws TreeIngestException, MultipleHitsException, TaxonNotFoundException {
  this.runTestOnly=false;
  this.allTreesHaveAllTaxa=allTreesHaveAllTaxa;
  this.logger=msgLogger;
  this.sourceName=sourceName;
  matchTaxaUsingNames(focalgroup);
  loadTree();
}","/** 
 * Ingest the current JadeTree (in the jt data member) to the GoL. this should be done as a preorder traversal
 * @param focalgroup a taxonomic name of the ancestor of the leaves in the treethis is only used in disambiguating taxa when there are multiple hits  for a leaf's taxonomic name
 * @param sourcename the name to be registered as the ""source"" property forevery edge in this tree.
 * @throws TaxonNotFoundException 
 * @throws MultipleHitsException 
 * @todo we probably want a node in the graph representing the tree with an ISROOTOF edge from its root to the tree. We could attach annotations about the tree to this node. We have the index of the root node, but need to having and isroot would also be helpful. Unless we are indexing this we could just randomly choose one of the edges that is connected to the root node that is in the index
 */
public void addSetTreeToGraph(String focalgroup,String sourceName,boolean allTreesHaveAllTaxa,MessageLogger msgLogger) throws TreeIngestException, MultipleHitsException, TaxonNotFoundException {
  this.runTestOnly=false;
  this.allTreesHaveAllTaxa=allTreesHaveAllTaxa;
  this.logger=msgLogger;
  this.sourceName=sourceName;
  matchTaxaUsingNames(focalgroup);
  loadTree();
  remapInputLeavesToDeepestTaxa();
}"
50202,"/** 
 * Ingest the current JadeTree (in the inputTree instance variable) to the GoL. This will assume that the JadeNodes all have a property set as ot:ottolid that will be the preset ottol id identifier that will be found by index. ALL THE NAMES HAVE TO BE SET FOR THIS FUNCTION
 * @param sourcename the name to be registered as the ""source"" property for every edge in this tree.
 * @param test don't add to the database
 */
public void addSetTreeToGraphWIdsSet(String sourceName,boolean allTreesHaveAllTaxa,boolean runTestOnly,MessageLogger msgLogger) throws TaxonNotFoundException, TreeIngestException {
  this.runTestOnly=runTestOnly;
  this.allTreesHaveAllTaxa=allTreesHaveAllTaxa;
  this.logger=msgLogger;
  this.sourceName=sourceName;
  matchTaxaUsingTaxUIDs();
  loadTree();
}","/** 
 * Ingest the current JadeTree (in the inputTree instance variable) to the GoL. This will assume that the JadeNodes all have a property set as ot:ottolid that will be the preset ottol id identifier that will be found by index. ALL THE NAMES HAVE TO BE SET FOR THIS FUNCTION
 * @param sourcename the name to be registered as the ""source"" property for every edge in this tree.
 * @param test don't add to the database
 */
public void addSetTreeToGraphWIdsSet(String sourceName,boolean allTreesHaveAllTaxa,boolean runTestOnly,MessageLogger msgLogger) throws TaxonNotFoundException, TreeIngestException {
  this.runTestOnly=runTestOnly;
  this.allTreesHaveAllTaxa=allTreesHaveAllTaxa;
  this.logger=msgLogger;
  this.sourceName=sourceName;
  matchTaxaUsingTaxUIDs();
  loadTree();
  remapInputLeavesToDeepestTaxa();
}"
50203,"@Override public Evaluation evaluate(Path arg0){
  Node tn=arg0.endNode();
  if (visited.contains(tn.getId())) {
    return Evaluation.EXCLUDE_AND_PRUNE;
  }
  visited.add(tn.getId());
  TLongArrayList ttm=new TLongArrayList((long[])tn.getProperty(""String_Node_Str""));
  BitSet tm=new BitSet((int)ttm.max());
  for (int i=0; i < ttm.size(); i++) {
    tm.set((int)ttm.getQuick(i));
  }
  boolean taxnode=false;
  BitSet to=null;
  TLongArrayList tto=null;
  if (tn.hasProperty(""String_Node_Str"") == false) {
    taxnode=true;
  }
 else {
    tto=new TLongArrayList((long[])tn.getProperty(""String_Node_Str""));
    to=new BitSet((int)tto.max());
    for (int i=0; i < tto.size(); i++) {
      to.set((int)tto.getQuick(i));
    }
  }
  if (taxnode == false) {
    if (tm.intersects(outIdBS) == false) {
      if (to.intersects(inIdBS) == false) {
        if (tm.intersects(inIdBS) == true) {
          boolean tmt=false;
          boolean checkParents=false;
          BitSet inIdBS2=(BitSet)inIdBS.clone();
          inIdBS2.andNot(tm);
          for (int i=0; i < inIdBS2.length(); i++) {
            if (inIdBS2.get(i) == true) {
              ttm.add(i);
              tmt=true;
            }
          }
          if (tmt) {
            ttm.sort();
            tn.setProperty(""String_Node_Str"",ttm.toArray());
            checkParents=true;
          }
          tmt=false;
          BitSet outIdBS2=(BitSet)outIdBS.clone();
          outIdBS2.andNot(to);
          for (int i=0; i < outIdBS2.length(); i++) {
            if (outIdBS2.get(i) == true) {
              tto.add(i);
              tmt=true;
            }
          }
          if (tmt) {
            tto.sort();
            tn.setProperty(""String_Node_Str"",tto.toArray());
            checkParents=true;
          }
          if (checkParents) {
            for (            Node pNode : Traversal.description().breadthFirst().evaluator(new MRCAValidatingEvaluator(ttm,tto)).relationships(RelType.STREECHILDOF,Direction.OUTGOING).traverse(tn).nodes()) {
              System.out.println(""String_Node_Str"" + pNode + ""String_Node_Str"");
              TLongArrayList mrcaNew=new TLongArrayList((long[])pNode.getProperty(""String_Node_Str""));
              mrcaNew.addAll(tto);
              pNode.setProperty(""String_Node_Str"",mrcaNew.toArray());
              tto.removeAll(mrcaNew);
              TLongArrayList outmrcaNew=new TLongArrayList((long[])pNode.getProperty(""String_Node_Str""));
              outmrcaNew.addAll(tto);
              pNode.setProperty(""String_Node_Str"",outmrcaNew.toArray());
            }
          }
          return Evaluation.INCLUDE_AND_PRUNE;
        }
      }
    }
  }
 else {
    if (outIdBS.intersects(tm) == false) {
      tm.and(inIdBS);
      if (inIdBS.cardinality() == tm.cardinality()) {
        return Evaluation.INCLUDE_AND_PRUNE;
      }
    }
  }
  return Evaluation.EXCLUDE_AND_CONTINUE;
}","@Override public Evaluation evaluate(Path arg0){
  Node tn=arg0.endNode();
  if (visited.contains(tn.getId())) {
    return Evaluation.EXCLUDE_AND_PRUNE;
  }
  visited.add(tn.getId());
  TLongArrayList ttm=new TLongArrayList((long[])tn.getProperty(""String_Node_Str""));
  BitSet tm=new BitSet((int)ttm.max());
  for (int i=0; i < ttm.size(); i++) {
    tm.set((int)ttm.getQuick(i));
  }
  boolean taxnode=false;
  BitSet to=null;
  TLongArrayList tto=null;
  if (tn.hasProperty(""String_Node_Str"") == false) {
    taxnode=true;
  }
 else {
    tto=new TLongArrayList((long[])tn.getProperty(""String_Node_Str""));
    to=new BitSet((int)tto.max());
    for (int i=0; i < tto.size(); i++) {
      to.set((int)tto.getQuick(i));
    }
  }
  if (taxnode == false) {
    if (tm.intersects(outIdBS) == false) {
      if (to.intersects(inIdBS) == false) {
        if (tm.intersects(inIdBS) == true) {
          boolean tmt=false;
          boolean checkParents=false;
          BitSet inIdBS2=(BitSet)inIdBS.clone();
          inIdBS2.andNot(tm);
          for (int i=0; i < inIdBS2.length(); i++) {
            if (inIdBS2.get(i) == true) {
              ttm.add(i);
              tmt=true;
            }
          }
          if (tmt) {
            ttm.sort();
            tn.setProperty(""String_Node_Str"",ttm.toArray());
            checkParents=true;
          }
          tmt=false;
          BitSet outIdBS2=(BitSet)outIdBS.clone();
          outIdBS2.andNot(to);
          for (int i=0; i < outIdBS2.length(); i++) {
            if (outIdBS2.get(i) == true) {
              tto.add(i);
              tmt=true;
            }
          }
          if (tmt) {
            tto.sort();
            tn.setProperty(""String_Node_Str"",tto.toArray());
            checkParents=true;
          }
          if (checkParents) {
            for (            Node pNode : Traversal.description().breadthFirst().evaluator(new MRCAValidatingEvaluator(ttm,tto)).relationships(RelType.STREECHILDOF,Direction.OUTGOING).traverse(tn).nodes()) {
              System.out.println(""String_Node_Str"" + pNode + ""String_Node_Str"");
              TLongArrayList outmrcaParent=new TLongArrayList((long[])pNode.getProperty(""String_Node_Str""));
              BitSet outmrcaParentBS=new BitSet((int)outmrcaParent.max());
              for (int i=0; i < outmrcaParent.size(); i++) {
                outmrcaParentBS.set((int)outmrcaParent.getQuick(i));
              }
              if (outmrcaParentBS.intersects(inIdBS2)) {
                throw new java.lang.IllegalStateException(""String_Node_Str"");
              }
              TLongArrayList mrcaNew=new TLongArrayList((long[])pNode.getProperty(""String_Node_Str""));
              mrcaNew.addAll(tto);
              pNode.setProperty(""String_Node_Str"",mrcaNew.toArray());
            }
          }
          return Evaluation.INCLUDE_AND_PRUNE;
        }
      }
    }
  }
 else {
    if (outIdBS.intersects(tm) == false) {
      tm.and(inIdBS);
      if (inIdBS.cardinality() == tm.cardinality()) {
        return Evaluation.INCLUDE_AND_PRUNE;
      }
    }
  }
  return Evaluation.EXCLUDE_AND_CONTINUE;
}"
50204,"@Override public Evaluation evaluate(Path inPath){
  Node curNode=inPath.endNode();
  if (curNode.hasProperty(""String_Node_Str"")) {
    return Evaluation.EXCLUDE_AND_CONTINUE;
  }
  TLongArrayList curNodeDescendantIds=new TLongArrayList((long[])curNode.getProperty(""String_Node_Str""));
  if (!curNodeDescendantIds.containsAll(mrcaTest)) {
    return Evaluation.INCLUDE_AND_CONTINUE;
  }
  TLongArrayList curNodeOutgroupIds=new TLongArrayList((long[])curNode.getProperty(""String_Node_Str""));
  if (!curNodeOutgroupIds.containsAll(outmrcaTest)) {
    return Evaluation.INCLUDE_AND_CONTINUE;
  }
  return Evaluation.EXCLUDE_AND_PRUNE;
}","@Override public Evaluation evaluate(Path inPath){
  Node curNode=inPath.endNode();
  if (curNode.hasProperty(""String_Node_Str"")) {
    return Evaluation.EXCLUDE_AND_CONTINUE;
  }
  TLongArrayList curNodeDescendantIds=new TLongArrayList((long[])curNode.getProperty(""String_Node_Str""));
  if (!curNodeDescendantIds.containsAll(mrcaTest)) {
    return Evaluation.INCLUDE_AND_CONTINUE;
  }
  return Evaluation.EXCLUDE_AND_PRUNE;
}"
50205,"/** 
 * The synthesis method for creating the draft tree. Uses the refactored synthesis classes. This will store the synthesized topology as SYNTHCHILDOF relationships in the graph.
 * @param startNode this is the beginning node for analysis
 * @param preferredSourceIds this includes the list of preferred sources
 * @param test this will just run through the motions but won't store the synthesis 
 * @throws Exception 
 */
public boolean synthesizeAndStoreDraftTreeBranches(Node startNode,Iterable<String> preferredSourceIds,boolean test) throws Exception {
  ArrayList<Object> sourceIdPriorityList=new ArrayList<Object>();
  for (  String sourceId : preferredSourceIds) {
    sourceIdPriorityList.add(sourceId);
  }
  ArrayList<Object> justSourcePriorityList=new ArrayList<Object>();
  for (  String sourceId : preferredSourceIds) {
    justSourcePriorityList.add(sourceId.split(""String_Node_Str"")[0]);
  }
  ResolvingExpander draftSynthesisMethod=new ResolvingExpander();
  RelationshipFilter rf=new RelationshipFilter();
  HashSet<String> filteredsources=new HashSet<String>();
  IndexHits<Node> hits=sourceMetaIndex.query(""String_Node_Str"",""String_Node_Str"");
  while (hits.hasNext()) {
    Node n=hits.next();
    if (n.hasProperty(""String_Node_Str"")) {
      if (justSourcePriorityList.contains(n.getProperty(""String_Node_Str"")) == false) {
        filteredsources.add((String)n.getProperty(""String_Node_Str""));
      }
    }
 else {
      if (justSourcePriorityList.contains(n.getProperty(""String_Node_Str"")) == false) {
        filteredsources.add((String)n.getProperty(""String_Node_Str""));
      }
    }
  }
  System.out.println(""String_Node_Str"" + filteredsources);
  if (filteredsources.size() > 0) {
    rf.addCriterion(new SourcePropertyFilterCriterion(SourceProperty.STUDY_ID,FilterComparisonType.CONTAINS,new TestValue(filteredsources),sourceMetaIndex));
    draftSynthesisMethod.setFilter(rf);
  }
  RelationshipRanker rs=new RelationshipRanker();
  rs.addCriterion(new SourcePropertyPrioritizedRankingCriterion(SourceProperty.STUDY_ID,sourceIdPriorityList,sourceMetaIndex));
  rs.addCriterion(new SourcePropertyRankingCriterion(SourceProperty.YEAR,RankingOrder.DECREASING,sourceMetaIndex));
  draftSynthesisMethod.setRanker(rs);
  RelationshipConflictResolver rcr=new RelationshipConflictResolver(new RankResolutionMethodInferredPath());
  draftSynthesisMethod.setConflictResolver(rcr);
  System.out.println(""String_Node_Str"" + draftSynthesisMethod.getDescription());
  Node originalParent=null;
  knownIdsInTree=new HashSet<Long>();
  Transaction tx=graphDb.beginTx();
  String synthTreeName=DRAFTTREENAME;
  try {
    for (    Relationship rel : Traversal.description().breadthFirst().expand(draftSynthesisMethod).traverse(startNode).relationships()) {
      System.out.println(""String_Node_Str"" + rel.getId());
      Node parentNode=rel.getEndNode();
      Node curNode=rel.getStartNode();
      if (parentNode != null && test == false) {
        Relationship newRel=curNode.createRelationshipTo(parentNode,RelType.SYNTHCHILDOF);
        newRel.setProperty(""String_Node_Str"",synthTreeName);
        HashSet<String> sources=new HashSet<String>();
        for (        Relationship rel2 : curNode.getRelationships(RelType.STREECHILDOF)) {
          if (rel2.hasProperty(""String_Node_Str"")) {
            sources.add(String.valueOf(rel2.getProperty(""String_Node_Str"")));
          }
        }
        String[] sourcesArray=new String[sources.size()];
        Iterator<String> sourcesIter=sources.iterator();
        for (int i=0; i < sources.size(); i++) {
          sourcesArray[i]=sourcesIter.next();
        }
        newRel.setProperty(""String_Node_Str"",sourcesArray);
      }
      knownIdsInTree.add(curNode.getId());
    }
    tx.success();
  }
 catch (  Exception ex) {
    tx.failure();
    throw ex;
  }
 finally {
    tx.finish();
  }
  if (!test) {
    tx=graphDb.beginTx();
    try {
      addMissingChildrenToDraftTreeWhile(startNode,startNode);
      tx.success();
    }
 catch (    Exception ex) {
      tx.failure();
      ex.printStackTrace();
    }
 finally {
      tx.finish();
    }
  }
  System.out.println(""String_Node_Str"");
  return true;
}","/** 
 * The synthesis method for creating the draft tree. Uses the refactored synthesis classes. This will store the synthesized topology as SYNTHCHILDOF relationships in the graph.
 * @param startNode this is the beginning node for analysis
 * @param preferredSourceIds this includes the list of preferred sources
 * @param test this will just run through the motions but won't store the synthesis 
 * @throws Exception 
 */
public boolean synthesizeAndStoreDraftTreeBranches(Node startNode,Iterable<String> preferredSourceIds,boolean test) throws Exception {
  ArrayList<Object> sourceIdPriorityList=new ArrayList<Object>();
  for (  String sourceId : preferredSourceIds) {
    sourceIdPriorityList.add(sourceId);
  }
  ArrayList<Object> justSourcePriorityList=new ArrayList<Object>();
  for (  String sourceId : preferredSourceIds) {
    justSourcePriorityList.add(sourceId.split(""String_Node_Str"")[0]);
  }
  ResolvingExpander draftSynthesisMethod=new ResolvingExpander();
  RelationshipFilter rf=new RelationshipFilter();
  HashSet<String> filteredsources=new HashSet<String>();
  IndexHits<Node> hits=sourceMetaIndex.query(""String_Node_Str"",""String_Node_Str"");
  while (hits.hasNext()) {
    Node n=hits.next();
    if (n.hasProperty(""String_Node_Str"")) {
      if (justSourcePriorityList.contains(n.getProperty(""String_Node_Str"")) == false) {
        filteredsources.add((String)n.getProperty(""String_Node_Str""));
      }
    }
 else {
      if (justSourcePriorityList.contains(n.getProperty(""String_Node_Str"")) == false) {
        filteredsources.add((String)n.getProperty(""String_Node_Str""));
      }
    }
  }
  System.out.println(""String_Node_Str"" + filteredsources);
  if (filteredsources.size() > 0) {
    rf.addCriterion(new SourcePropertyFilterCriterion(SourceProperty.STUDY_ID,FilterComparisonType.CONTAINS,new TestValue(filteredsources),sourceMetaIndex));
    draftSynthesisMethod.setFilter(rf);
  }
  RelationshipRanker rs=new RelationshipRanker();
  rs.addCriterion(new SourcePropertyPrioritizedRankingCriterion(SourceProperty.STUDY_ID,sourceIdPriorityList,sourceMetaIndex));
  rs.addCriterion(new SourcePropertyRankingCriterion(SourceProperty.YEAR,RankingOrder.DECREASING,sourceMetaIndex));
  draftSynthesisMethod.setRanker(rs);
  RelationshipConflictResolver rcr=new RelationshipConflictResolver(new RankResolutionMethodInferredPath());
  draftSynthesisMethod.setConflictResolver(rcr);
  System.out.println(""String_Node_Str"" + draftSynthesisMethod.getDescription());
  Node originalParent=null;
  knownIdsInTree=new HashSet<Long>();
  Transaction tx=graphDb.beginTx();
  String synthTreeName=DRAFTTREENAME;
  try {
    for (    Relationship rel : Traversal.description().breadthFirst().expand(draftSynthesisMethod).traverse(startNode).relationships()) {
      Node parentNode=rel.getEndNode();
      Node curNode=rel.getStartNode();
      if (parentNode != null && test == false) {
        Relationship newRel=curNode.createRelationshipTo(parentNode,RelType.SYNTHCHILDOF);
        newRel.setProperty(""String_Node_Str"",synthTreeName);
        HashSet<String> sources=new HashSet<String>();
        for (        Relationship rel2 : curNode.getRelationships(RelType.STREECHILDOF)) {
          if (rel2.hasProperty(""String_Node_Str"")) {
            sources.add(String.valueOf(rel2.getProperty(""String_Node_Str"")));
          }
        }
        String[] sourcesArray=new String[sources.size()];
        Iterator<String> sourcesIter=sources.iterator();
        for (int i=0; i < sources.size(); i++) {
          sourcesArray[i]=sourcesIter.next();
        }
        newRel.setProperty(""String_Node_Str"",sourcesArray);
      }
      knownIdsInTree.add(curNode.getId());
    }
    tx.success();
  }
 catch (  Exception ex) {
    tx.failure();
    throw ex;
  }
 finally {
    tx.finish();
  }
  if (!test) {
    tx=graphDb.beginTx();
    try {
      addMissingChildrenToDraftTreeWhile(startNode,startNode);
      tx.success();
    }
 catch (    Exception ex) {
      tx.failure();
      ex.printStackTrace();
    }
 finally {
      tx.finish();
    }
  }
  System.out.println(""String_Node_Str"");
  return true;
}"
50206,"/** 
 * Used to add missing external nodes to the draft tree stored in the graph.
 * @param startNode
 * @param taxRootNode
 */
private void addMissingChildrenToDraftTreeWhile(Node startNode,Node taxRootNode){
  String[] supportingSources=new String[1];
  supportingSources[0]=""String_Node_Str"";
  TLongArrayList taxaleft=new TLongArrayList((long[])startNode.getProperty(""String_Node_Str""));
  taxaleft.removeAll(knownIdsInTree);
  System.out.println(""String_Node_Str"" + taxaleft.size());
  while (taxaleft.size() > 0) {
    long tid=taxaleft.removeAt(0);
    Node taxNode=graphDb.getNodeById(tid);
    TLongArrayList ttmrca=new TLongArrayList((long[])taxNode.getProperty(""String_Node_Str""));
    if (taxNode.hasRelationship(Direction.OUTGOING,RelType.SYNTHCHILDOF))     continue;
    Node ptaxNode=taxNode.getSingleRelationship(RelType.TAXCHILDOF,Direction.OUTGOING).getEndNode();
    ArrayList<Node> nodesInTree=new ArrayList<Node>();
    for (    long cid : (long[])ptaxNode.getProperty(""String_Node_Str"")) {
      Node childNode=graphDb.getNodeById(cid);
      if (knownIdsInTree.contains(cid)) {
        nodesInTree.add(childNode);
      }
    }
    if (nodesInTree.size() > 1) {
      Node mrca=null;
      mrca=getLICAForDraftTreeNodes(nodesInTree);
      Relationship newRel=taxNode.createRelationshipTo(mrca,RelType.SYNTHCHILDOF);
      newRel.setProperty(""String_Node_Str"",DRAFTTREENAME);
      newRel.setProperty(""String_Node_Str"",supportingSources);
      knownIdsInTree.add(taxNode.getId());
    }
 else {
      Relationship newRel=taxNode.createRelationshipTo(ptaxNode,RelType.SYNTHCHILDOF);
      newRel.setProperty(""String_Node_Str"",DRAFTTREENAME);
      newRel.setProperty(""String_Node_Str"",supportingSources);
      taxaleft.add(ptaxNode.getId());
    }
  }
}","/** 
 * Used to add missing external nodes to the draft tree stored in the graph.
 * @param startNode
 * @param taxRootNode
 */
private void addMissingChildrenToDraftTreeWhile(Node startNode,Node taxRootNode){
  String[] supportingSources=new String[1];
  supportingSources[0]=""String_Node_Str"";
  TLongArrayList taxaleft=new TLongArrayList((long[])startNode.getProperty(""String_Node_Str""));
  taxaleft.removeAll(knownIdsInTree);
  System.out.println(""String_Node_Str"" + taxaleft.size());
  while (taxaleft.size() > 0) {
    System.out.println(""String_Node_Str"" + taxaleft.size());
    long tid=taxaleft.removeAt(0);
    Node taxNode=graphDb.getNodeById(tid);
    TLongArrayList ttmrca=new TLongArrayList((long[])taxNode.getProperty(""String_Node_Str""));
    if (taxNode.hasRelationship(Direction.OUTGOING,RelType.SYNTHCHILDOF))     continue;
    Node ptaxNode=taxNode.getSingleRelationship(RelType.TAXCHILDOF,Direction.OUTGOING).getEndNode();
    ArrayList<Node> nodesInTree=new ArrayList<Node>();
    for (    long cid : (long[])ptaxNode.getProperty(""String_Node_Str"")) {
      Node childNode=graphDb.getNodeById(cid);
      if (knownIdsInTree.contains(cid)) {
        nodesInTree.add(childNode);
      }
    }
    if (nodesInTree.size() > 1) {
      Node mrca=null;
      mrca=getLICAForDraftTreeNodes(nodesInTree);
      Relationship newRel=taxNode.createRelationshipTo(mrca,RelType.SYNTHCHILDOF);
      newRel.setProperty(""String_Node_Str"",DRAFTTREENAME);
      newRel.setProperty(""String_Node_Str"",supportingSources);
      knownIdsInTree.add(taxNode.getId());
    }
 else {
      Relationship newRel=taxNode.createRelationshipTo(ptaxNode,RelType.SYNTHCHILDOF);
      newRel.setProperty(""String_Node_Str"",DRAFTTREENAME);
      newRel.setProperty(""String_Node_Str"",supportingSources);
      taxaleft.add(ptaxNode.getId());
    }
  }
}"
50207,"@Override public Evaluation evaluate(Path arg0){
  Node tn=arg0.endNode();
  if (visited.contains(tn.getId())) {
    return Evaluation.EXCLUDE_AND_PRUNE;
  }
  visited.add(tn.getId());
  TLongArrayList ttm=new TLongArrayList((long[])tn.getProperty(""String_Node_Str""));
  BitSet tm=new BitSet((int)ttm.max());
  for (int i=0; i < ttm.size(); i++) {
    tm.set((int)ttm.getQuick(i));
  }
  boolean taxnode=false;
  BitSet to=null;
  TLongArrayList tto=null;
  if (tn.hasProperty(""String_Node_Str"") == false) {
    taxnode=true;
  }
 else {
    tto=new TLongArrayList((long[])tn.getProperty(""String_Node_Str""));
    to=new BitSet((int)tto.max());
    for (int i=0; i < tto.size(); i++) {
      to.set((int)tto.getQuick(i));
    }
  }
  if (taxnode == false) {
    if (tm.intersects(outIdBS) == false) {
      if (to.intersects(inIdBS) == false) {
        if (tm.intersects(inIdBS) == true) {
          boolean tmt=false;
          boolean checkParents=false;
          BitSet inIdBS2=(BitSet)inIdBS.clone();
          inIdBS2.andNot(tm);
          for (int i=0; i < inIdBS2.length(); i++) {
            if (inIdBS2.get(i) == true) {
              ttm.add(i);
              tmt=true;
            }
          }
          if (tmt) {
            ttm.sort();
            tn.setProperty(""String_Node_Str"",ttm.toArray());
            checkParents=true;
          }
          tmt=false;
          BitSet outIdBS2=(BitSet)outIdBS.clone();
          outIdBS2.andNot(to);
          for (int i=0; i < outIdBS2.length(); i++) {
            if (outIdBS2.get(i) == true) {
              tto.add(i);
              tmt=true;
            }
          }
          if (tmt) {
            tto.sort();
            tn.setProperty(""String_Node_Str"",tto.toArray());
            checkParents=true;
          }
          if (checkParents) {
            for (            Node pNode : Traversal.description().breadthFirst().evaluator(new MRCAValidatingEvaluator(ttm,tto)).relationships(RelType.STREECHILDOF,Direction.OUTGOING).traverse(tn).nodes()) {
              System.out.println(""String_Node_Str"" + pNode + ""String_Node_Str"");
              pNode.setProperty(""String_Node_Str"",ttm.toArray());
              pNode.setProperty(""String_Node_Str"",tto.toArray());
            }
          }
          return Evaluation.INCLUDE_AND_PRUNE;
        }
      }
    }
  }
 else {
    if (outIdBS.intersects(tm) == false) {
      tm.and(inIdBS);
      if (inIdBS.cardinality() == tm.cardinality()) {
        return Evaluation.INCLUDE_AND_PRUNE;
      }
    }
  }
  return Evaluation.EXCLUDE_AND_CONTINUE;
}","@Override public Evaluation evaluate(Path arg0){
  Node tn=arg0.endNode();
  if (visited.contains(tn.getId())) {
    return Evaluation.EXCLUDE_AND_PRUNE;
  }
  visited.add(tn.getId());
  TLongArrayList ttm=new TLongArrayList((long[])tn.getProperty(""String_Node_Str""));
  BitSet tm=new BitSet((int)ttm.max());
  for (int i=0; i < ttm.size(); i++) {
    tm.set((int)ttm.getQuick(i));
  }
  boolean taxnode=false;
  BitSet to=null;
  TLongArrayList tto=null;
  if (tn.hasProperty(""String_Node_Str"") == false) {
    taxnode=true;
  }
 else {
    tto=new TLongArrayList((long[])tn.getProperty(""String_Node_Str""));
    to=new BitSet((int)tto.max());
    for (int i=0; i < tto.size(); i++) {
      to.set((int)tto.getQuick(i));
    }
  }
  if (taxnode == false) {
    if (tm.intersects(outIdBS) == false) {
      if (to.intersects(inIdBS) == false) {
        if (tm.intersects(inIdBS) == true) {
          boolean tmt=false;
          boolean checkParents=false;
          BitSet inIdBS2=(BitSet)inIdBS.clone();
          inIdBS2.andNot(tm);
          for (int i=0; i < inIdBS2.length(); i++) {
            if (inIdBS2.get(i) == true) {
              ttm.add(i);
              tmt=true;
            }
          }
          if (tmt) {
            ttm.sort();
            tn.setProperty(""String_Node_Str"",ttm.toArray());
            checkParents=true;
          }
          tmt=false;
          BitSet outIdBS2=(BitSet)outIdBS.clone();
          outIdBS2.andNot(to);
          for (int i=0; i < outIdBS2.length(); i++) {
            if (outIdBS2.get(i) == true) {
              tto.add(i);
              tmt=true;
            }
          }
          if (tmt) {
            tto.sort();
            tn.setProperty(""String_Node_Str"",tto.toArray());
            checkParents=true;
          }
          if (checkParents) {
            for (            Node pNode : Traversal.description().breadthFirst().evaluator(new MRCAValidatingEvaluator(ttm,tto)).relationships(RelType.STREECHILDOF,Direction.OUTGOING).traverse(tn).nodes()) {
              System.out.println(""String_Node_Str"" + pNode + ""String_Node_Str"");
              pNode.setProperty(""String_Node_Str"",ttm.toArray());
              TLongArrayList ingroupIds=new TLongArrayList();
              for (              Relationship childRel : pNode.getRelationships(RelType.STREECHILDOF,Direction.INCOMING)) {
                ingroupIds.addAll((long[])childRel.getStartNode().getProperty(""String_Node_Str""));
              }
              tto.removeAll(ingroupIds);
              pNode.setProperty(""String_Node_Str"",tto.toArray());
            }
          }
          return Evaluation.INCLUDE_AND_PRUNE;
        }
      }
    }
  }
 else {
    if (outIdBS.intersects(tm) == false) {
      tm.and(inIdBS);
      if (inIdBS.cardinality() == tm.cardinality()) {
        return Evaluation.INCLUDE_AND_PRUNE;
      }
    }
  }
  return Evaluation.EXCLUDE_AND_CONTINUE;
}"
50208,"/** 
 * Resolve conflicts among the relationships stored in candidateRels. For more info, see description above for setConflictResolver, and also the ResolutionMethod classes. TODO: include the branch and bound option (new resolver?), size option (new resolver?), others?
 */
private void resolveConflicts(){
  if (resolver != null) {
    bestRels=resolver.resolveConflicts(candidateRels);
  }
 else {
    bestRels=candidateRels;
  }
  System.out.println(""String_Node_Str"");
  for (  Relationship rel : bestRels) {
    System.out.println(""String_Node_Str"" + rel.getId());
  }
}","/** 
 * Resolve conflicts among the relationships stored in candidateRels. For more info, see description above for setConflictResolver, and also the ResolutionMethod classes. TODO: include the branch and bound option (new resolver?), size option (new resolver?), others?
 */
private void resolveConflicts(){
  if (resolver != null) {
    bestRels=resolver.resolveConflicts(candidateRels);
  }
 else {
    bestRels=candidateRels;
  }
}"
50209,"/** 
 * The synthesis method for creating the draft tree. Uses the refactored synthesis classes. This will store the synthesized topology as SYNTHCHILDOF relationships in the graph.
 * @param startNode this is the beginning node for analysis
 * @param preferredSourceIds this includes the list of preferred sources
 * @param test this will just run through the motions but won't store the synthesis 
 * @throws OttolIdNotFoundException 
 */
public boolean synthesizeAndStoreDraftTreeBranches(Node startNode,Iterable<String> preferredSourceIds,boolean test) throws OttolIdNotFoundException {
  ArrayList<Object> sourceIdPriorityList=new ArrayList<Object>();
  for (  String sourceId : preferredSourceIds) {
    sourceIdPriorityList.add(sourceId);
  }
  ArrayList<Object> justSourcePriorityList=new ArrayList<Object>();
  for (  String sourceId : preferredSourceIds) {
    justSourcePriorityList.add(sourceId.split(""String_Node_Str"")[0]);
  }
  ResolvingExpander draftSynthesisMethod=new ResolvingExpander();
  RelationshipFilter rf=new RelationshipFilter();
  HashSet<String> filteredsources=new HashSet<String>();
  IndexHits<Node> hits=sourceMetaIndex.query(""String_Node_Str"",""String_Node_Str"");
  while (hits.hasNext()) {
    Node n=hits.next();
    if (n.hasProperty(""String_Node_Str"")) {
      if (justSourcePriorityList.contains(n.getProperty(""String_Node_Str"")) == false) {
        filteredsources.add((String)n.getProperty(""String_Node_Str""));
      }
    }
 else {
      if (justSourcePriorityList.contains(n.getProperty(""String_Node_Str"")) == false) {
        filteredsources.add((String)n.getProperty(""String_Node_Str""));
      }
    }
  }
  System.out.println(""String_Node_Str"" + filteredsources);
  if (filteredsources.size() > 0) {
    draftSynthesisMethod.setFilter(rf);
  }
  RelationshipRanker rs=new RelationshipRanker();
  rs.addCriterion(new SourcePropertyPrioritizedRankingCriterion(SourceProperty.STUDY_ID,sourceIdPriorityList,sourceMetaIndex));
  rs.addCriterion(new SourcePropertyRankingCriterion(SourceProperty.YEAR,RankingOrder.DECREASING,sourceMetaIndex));
  draftSynthesisMethod.setRanker(rs);
  RelationshipConflictResolver rcr=new RelationshipConflictResolver(new RankResolutionMethodInferredPath());
  draftSynthesisMethod.setConflictResolver(rcr);
  System.out.println(""String_Node_Str"" + draftSynthesisMethod.getDescription());
  Node originalParent=null;
  knownIdsInTree=new HashSet<Long>();
  Transaction tx=graphDb.beginTx();
  String synthTreeName=DRAFTTREENAME;
  try {
    for (    Relationship rel : Traversal.description().breadthFirst().expand(draftSynthesisMethod).traverse(startNode).relationships()) {
      Node parentNode=rel.getEndNode();
      Node curNode=rel.getStartNode();
      if (parentNode != null && test == false) {
        Relationship newRel=curNode.createRelationshipTo(parentNode,RelType.SYNTHCHILDOF);
        newRel.setProperty(""String_Node_Str"",synthTreeName);
        HashSet<String> sources=new HashSet<String>();
        for (        Relationship rel2 : curNode.getRelationships(RelType.STREECHILDOF)) {
          if (rel2.hasProperty(""String_Node_Str"")) {
            sources.add(String.valueOf(rel2.getProperty(""String_Node_Str"")));
          }
        }
        String[] sourcesArray=new String[sources.size()];
        Iterator<String> sourcesIter=sources.iterator();
        for (int i=0; i < sources.size(); i++) {
          sourcesArray[i]=sourcesIter.next();
        }
        newRel.setProperty(""String_Node_Str"",sourcesArray);
      }
      knownIdsInTree.add(curNode.getId());
    }
    tx.success();
  }
 catch (  Exception ex) {
    tx.failure();
    ex.printStackTrace();
  }
 finally {
    tx.finish();
  }
  if (!test) {
    tx=graphDb.beginTx();
    try {
      addMissingChildrenToDraftTree(startNode,startNode);
      tx.success();
    }
 catch (    Exception ex) {
      tx.failure();
      ex.printStackTrace();
    }
 finally {
      tx.finish();
    }
  }
  System.out.println(""String_Node_Str"");
  return true;
}","/** 
 * The synthesis method for creating the draft tree. Uses the refactored synthesis classes. This will store the synthesized topology as SYNTHCHILDOF relationships in the graph.
 * @param startNode this is the beginning node for analysis
 * @param preferredSourceIds this includes the list of preferred sources
 * @param test this will just run through the motions but won't store the synthesis 
 * @throws OttolIdNotFoundException 
 */
public boolean synthesizeAndStoreDraftTreeBranches(Node startNode,Iterable<String> preferredSourceIds,boolean test) throws OttolIdNotFoundException {
  ArrayList<Object> sourceIdPriorityList=new ArrayList<Object>();
  for (  String sourceId : preferredSourceIds) {
    sourceIdPriorityList.add(sourceId);
  }
  ArrayList<Object> justSourcePriorityList=new ArrayList<Object>();
  for (  String sourceId : preferredSourceIds) {
    justSourcePriorityList.add(sourceId.split(""String_Node_Str"")[0]);
  }
  ResolvingExpander draftSynthesisMethod=new ResolvingExpander();
  RelationshipFilter rf=new RelationshipFilter();
  rf.addCriterion(new SourcePropertyFilterCriterion(SourceProperty.YEAR,FilterComparisonType.GREATEROREQUAL,new TestValue(2000),sourceMetaIndex));
  HashSet<String> filteredsources=new HashSet<String>();
  IndexHits<Node> hits=sourceMetaIndex.query(""String_Node_Str"",""String_Node_Str"");
  while (hits.hasNext()) {
    Node n=hits.next();
    if (n.hasProperty(""String_Node_Str"")) {
      if (justSourcePriorityList.contains(n.getProperty(""String_Node_Str"")) == false) {
        filteredsources.add((String)n.getProperty(""String_Node_Str""));
      }
    }
 else {
      if (justSourcePriorityList.contains(n.getProperty(""String_Node_Str"")) == false) {
        filteredsources.add((String)n.getProperty(""String_Node_Str""));
      }
    }
  }
  System.out.println(""String_Node_Str"" + filteredsources);
  if (filteredsources.size() > 0) {
    rf.addCriterion(new SourcePropertyFilterCriterion(SourceProperty.STUDY_ID,FilterComparisonType.CONTAINS,new TestValue(filteredsources),sourceMetaIndex));
    draftSynthesisMethod.setFilter(rf);
  }
  RelationshipRanker rs=new RelationshipRanker();
  rs.addCriterion(new SourcePropertyPrioritizedRankingCriterion(SourceProperty.STUDY_ID,sourceIdPriorityList,sourceMetaIndex));
  rs.addCriterion(new SourcePropertyRankingCriterion(SourceProperty.YEAR,RankingOrder.DECREASING,sourceMetaIndex));
  draftSynthesisMethod.setRanker(rs);
  RelationshipConflictResolver rcr=new RelationshipConflictResolver(new RankResolutionMethodInferredPath());
  draftSynthesisMethod.setConflictResolver(rcr);
  System.out.println(""String_Node_Str"" + draftSynthesisMethod.getDescription());
  Node originalParent=null;
  knownIdsInTree=new HashSet<Long>();
  Transaction tx=graphDb.beginTx();
  String synthTreeName=DRAFTTREENAME;
  try {
    for (    Relationship rel : Traversal.description().breadthFirst().expand(draftSynthesisMethod).traverse(startNode).relationships()) {
      Node parentNode=rel.getEndNode();
      Node curNode=rel.getStartNode();
      if (parentNode != null && test == false) {
        Relationship newRel=curNode.createRelationshipTo(parentNode,RelType.SYNTHCHILDOF);
        newRel.setProperty(""String_Node_Str"",synthTreeName);
        HashSet<String> sources=new HashSet<String>();
        for (        Relationship rel2 : curNode.getRelationships(RelType.STREECHILDOF)) {
          if (rel2.hasProperty(""String_Node_Str"")) {
            sources.add(String.valueOf(rel2.getProperty(""String_Node_Str"")));
          }
        }
        String[] sourcesArray=new String[sources.size()];
        Iterator<String> sourcesIter=sources.iterator();
        for (int i=0; i < sources.size(); i++) {
          sourcesArray[i]=sourcesIter.next();
        }
        newRel.setProperty(""String_Node_Str"",sourcesArray);
      }
      knownIdsInTree.add(curNode.getId());
    }
    tx.success();
  }
 catch (  Exception ex) {
    tx.failure();
    ex.printStackTrace();
  }
 finally {
    tx.finish();
  }
  if (!test) {
    tx=graphDb.beginTx();
    try {
      addMissingChildrenToDraftTree(startNode,startNode);
      tx.success();
    }
 catch (    Exception ex) {
      tx.failure();
      ex.printStackTrace();
    }
 finally {
      tx.finish();
    }
  }
  System.out.println(""String_Node_Str"");
  return true;
}"
50210,"/** 
 * the return codes are 0 - no conflict 1 - regular conflict 2 - candidate contains saved and is compatible
 * @param candidate
 * @param saved
 * @return 
 */
private int testForConflict(Relationship candidate,Relationship saved){
  if (!candRelDescendantIdsMap.containsKey(candidate)) {
    storeDescendants(candidate);
  }
  if (!candRelDescendantIdsMap.containsKey(saved)) {
    storeDescendants(saved);
  }
  if (LicaUtil.containsAnyt4jUnsorted(candRelDescendantIdsMap.get(saved),candRelDescendantIdsMap.get(candidate))) {
    if (candRelDescendantIdsMap.get(candidate).containsAll(candRelDescendantIdsMap.get(saved))) {
      return 2;
    }
    return 1;
  }
 else {
    return 0;
  }
}","/** 
 * tests for conflict and returns a ConflictType from the enum above
 * @param candidate
 * @param saved
 * @return 
 */
private ConflictType testForConflict(Relationship rel1,Relationship rel2){
  if (!candRelDescendantIdsMap.containsKey(rel1)) {
    storeDescendants(rel1);
  }
  if (!candRelDescendantIdsMap.containsKey(rel2)) {
    storeDescendants(rel2);
  }
  if (LicaUtil.containsAnyt4jUnsorted(candRelDescendantIdsMap.get(rel2),candRelDescendantIdsMap.get(rel1))) {
    if (candRelDescendantIdsMap.get(rel1).containsAll(candRelDescendantIdsMap.get(rel2))) {
      return ConflictType.SECOND_SUBSETOF_FIRST;
    }
 else     if (candRelDescendantIdsMap.get(rel2).containsAll(candRelDescendantIdsMap.get(rel1))) {
      return ConflictType.FIRST_SUBSETOF_SECOND;
    }
    return ConflictType.INCOMPATIBLE;
  }
 else {
    return ConflictType.NO_CONFLICT;
  }
}"
50211,"@Override public Iterable<Relationship> resolveConflicts(Iterable<Relationship> rels){
  initialize();
  Iterator<Relationship> relsIter=rels.iterator();
  HashSet<Relationship> removeSaved=new HashSet<Relationship>();
  while (relsIter.hasNext()) {
    Relationship candidate=relsIter.next();
    System.out.println(""String_Node_Str"" + candidate.getId() + ""String_Node_Str"");
    boolean saveRel=true;
    HashSet<Relationship> tremoveSaved=new HashSet<Relationship>();
    for (    Relationship saved : bestRels) {
      int tfc=testForConflict(candidate,saved);
      if (tfc == 1) {
        saveRel=false;
        break;
      }
 else       if (tfc == 2) {
        System.out.println(""String_Node_Str"" + saved + ""String_Node_Str""+ candidate);
        tremoveSaved.add(saved);
      }
    }
    if (saveRel) {
      System.out.println(""String_Node_Str"" + candidate.getId() + ""String_Node_Str"");
      bestRels.add(candidate);
      removeSaved.addAll(tremoveSaved);
    }
 else {
      System.out.println(""String_Node_Str"" + candidate.getId() + ""String_Node_Str"");
    }
  }
  for (  Relationship rel : removeSaved) {
    System.out.println(""String_Node_Str"" + rel);
    bestRels.remove(rel);
  }
  return bestRels;
}","@Override public Iterable<Relationship> resolveConflicts(Iterable<Relationship> rels){
  initialize();
  Iterator<Relationship> relsIter=rels.iterator();
  HashSet<Relationship> savedRelsToRemove=new HashSet<Relationship>();
  while (relsIter.hasNext()) {
    Relationship candidate=relsIter.next();
    System.out.println(""String_Node_Str"" + getIdString(candidate) + ""String_Node_Str"");
    boolean candidatePassed=true;
    for (    Relationship saved : bestRels) {
      ConflictType tfc=testForConflict(candidate,saved);
      if (tfc == ConflictType.INCOMPATIBLE) {
        System.out.println(""String_Node_Str"" + getIdString(saved));
        System.out.println(""String_Node_Str"" + candidate.getId() + ""String_Node_Str"");
        candidatePassed=false;
        break;
      }
 else       if (tfc == ConflictType.FIRST_SUBSETOF_SECOND) {
        System.out.println(""String_Node_Str"" + candidate.getId() + ""String_Node_Str""+ getIdString(saved)+ ""String_Node_Str""+ getIdString(candidate.getEndNode())+ ""String_Node_Str"");
        candidatePassed=false;
        break;
      }
 else       if (tfc == ConflictType.SECOND_SUBSETOF_FIRST) {
        System.out.println(""String_Node_Str"" + getIdString(saved) + ""String_Node_Str""+ getIdString(candidate));
        savedRelsToRemove.add(saved);
      }
    }
    if (candidatePassed) {
      System.out.println(""String_Node_Str"" + candidate.getId() + ""String_Node_Str"");
      bestRels.add(candidate);
    }
    System.out.println(""String_Node_Str"");
  }
  for (  Relationship rel : savedRelsToRemove) {
    System.out.println(""String_Node_Str"" + getIdString(rel));
    bestRels.remove(rel);
  }
  return bestRels;
}"
50212,"private void storeDescendants(Relationship rel){
  TLongArrayList descendantIds=new TLongArrayList((long[])rel.getStartNode().getProperty(""String_Node_Str""));
  candRelDescendantIdsMap.put(rel,descendantIds);
  if (descendantIds.size() > 1) {
    String name=null;
    if (rel.getStartNode().hasProperty(""String_Node_Str"")) {
      name=String.valueOf(rel.getStartNode().getProperty(""String_Node_Str""));
    }
 else {
      name=rel.getStartNode().toString();
    }
    System.out.println(name + ""String_Node_Str"" + descendantIds.size()+ ""String_Node_Str"");
  }
}","private void storeDescendants(Relationship rel){
  TLongArrayList descendantIds=new TLongArrayList((long[])rel.getStartNode().getProperty(""String_Node_Str""));
  candRelDescendantIdsMap.put(rel,descendantIds);
  if (descendantIds.size() > 1) {
    System.out.println(""String_Node_Str"" + getIdString(rel.getStartNode()) + ""String_Node_Str""+ descendantIds.size()+ ""String_Node_Str"");
  }
}"
50213,"private static Boolean checkDeprecated(List<Object> metaData){
  Boolean deprecated=false;
  for (  Object meta : metaData) {
    JSONObject j=(JSONObject)meta;
    if (((String)j.get(""String_Node_Str"")).compareTo(""String_Node_Str"") == 0) {
      if ((j.get(""String_Node_Str"")) != null) {
        String currentTag=(String)j.get(""String_Node_Str"");
        if (currentTag.startsWith(""String_Node_Str""))         ;
{
          return true;
        }
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + j);
      }
    }
  }
  return deprecated;
}","private static Boolean checkDeprecated(List<Object> metaData){
  Boolean deprecated=false;
  for (  Object meta : metaData) {
    JSONObject j=(JSONObject)meta;
    if (((String)j.get(""String_Node_Str"")).compareTo(""String_Node_Str"") == 0) {
      if ((j.get(""String_Node_Str"")) != null) {
        String currentTag=(String)j.get(""String_Node_Str"");
        if (currentTag.startsWith(""String_Node_Str"")) {
          return true;
        }
      }
 else {
        throw new RuntimeException(""String_Node_Str"" + j);
      }
    }
  }
  return deprecated;
}"
50214,"/** 
 * This will return the MRCA using the taxonomic relationships. This only requires the nodes that we are looking for.
 * @param nodeSet
 * @return
 */
public static Node getTaxonomicLICA(List<Node> nodeSet){
  Node retaln=null;
  Node firstNode=nodeSet.get(0);
  Node innode=firstNode;
  ArrayList<Long> nodeSetLongs=new ArrayList<Long>();
  for (  Node nd : nodeSet) {
    nodeSetLongs.add(nd.getId());
  }
  boolean going=true;
  while (going) {
    innode=innode.getSingleRelationship(RelTypes.TAXCHILDOF,Direction.OUTGOING).getEndNode();
    long[] dbnodei=(long[])innode.getProperty(""String_Node_Str"");
    HashSet<Long> Ldbnodei=new HashSet<Long>();
    for (    long temp : dbnodei) {
      Ldbnodei.add(temp);
    }
    boolean containsall=Ldbnodei.containsAll(nodeSetLongs);
    if (containsall == true) {
      retaln=innode;
      going=false;
    }
    if (going == false) {
      break;
    }
  }
  return retaln;
}","/** 
 * This will return the MRCA using the taxonomic relationships. This only requires the nodes that we are looking for.
 * @param nodeSet
 * @return
 */
public static Node getTaxonomicLICA(List<Node> nodeSet){
  Node retaln=null;
  Node firstNode=nodeSet.get(0);
  Node innode=firstNode;
  ArrayList<Long> nodeSetLongs=new ArrayList<Long>();
  for (  Node nd : nodeSet) {
    nodeSetLongs.add(nd.getId());
  }
  boolean going=true;
  while (going) {
    try {
      innode=innode.getSingleRelationship(RelTypes.TAXCHILDOF,Direction.OUTGOING).getEndNode();
    }
 catch (    Exception e) {
      break;
    }
    long[] dbnodei=(long[])innode.getProperty(""String_Node_Str"");
    HashSet<Long> Ldbnodei=new HashSet<Long>();
    for (    long temp : dbnodei) {
      Ldbnodei.add(temp);
    }
    boolean containsall=Ldbnodei.containsAll(nodeSetLongs);
    if (containsall == true) {
      retaln=innode;
      going=false;
    }
    if (going == false) {
      break;
    }
  }
  return retaln;
}"
50215,"public int pg_loading(String[] args){
  GraphDatabaseAgent graphDb=new GraphDatabaseAgent(args[1]);
  if (args.length != 3) {
    graphDb.shutdownDb();
    return 1;
  }
  String directory=args[2];
  System.out.println(""String_Node_Str"" + directory + ""String_Node_Str""+ args[1]);
  File file=new File(directory);
  File[] files=file.listFiles();
  for (int i=0; i < files.length; i++) {
    if (i > 10) {
      break;
    }
    System.out.println(""String_Node_Str"" + files[i]);
    try {
      BufferedReader br=new BufferedReader(new FileReader(files[i]));
      List<JadeTree> jt=NexsonReader.readNexson(br);
      for (      JadeTree j : jt) {
        System.out.println(files[i] + ""String_Node_Str"" + j.getExternalNodeCount());
      }
      PhylografterConnector.fixNamesFromTrees(Long.valueOf(files[i].getName()),jt,graphDb);
      try {
        for (        JadeTree j : jt) {
          GraphImporter gi=new GraphImporter(graphDb);
          boolean doubname=false;
          HashSet<Long> ottols=new HashSet<Long>();
          for (int m=0; m < j.getExternalNodeCount(); m++) {
            System.out.println(j.getExternalNode(m).getName() + ""String_Node_Str"" + j.getExternalNode(m).getObject(""String_Node_Str""));
            if (j.getExternalNode(m).getObject(""String_Node_Str"") == null) {
              doubname=true;
              break;
            }
            if (ottols.contains((Long)j.getExternalNode(m).getObject(""String_Node_Str"")) == true) {
              doubname=true;
              break;
            }
 else {
              ottols.add((Long)j.getExternalNode(m).getObject(""String_Node_Str""));
            }
          }
          if (doubname == true) {
            System.out.println(""String_Node_Str"");
          }
 else {
            System.out.println(""String_Node_Str"");
            gi.setTree(j);
            String sourcename=""String_Node_Str"";
            if (j.getObject(""String_Node_Str"") != null) {
              sourcename=(String)j.getObject(""String_Node_Str"");
            }
            if (j.getObject(""String_Node_Str"") != null) {
              sourcename+=""String_Node_Str"" + (String)j.getObject(""String_Node_Str"");
            }
            Index<Node> sourceMetaIndex=graphDb.getNodeIndex(""String_Node_Str"");
            IndexHits<Node> hits=sourceMetaIndex.get(""String_Node_Str"",sourcename);
            if (hits.size() > 0) {
              System.out.println(""String_Node_Str"" + sourcename + ""String_Node_Str"");
            }
 else {
              gi.addSetTreeToGraphWIdsSet(sourcename);
            }
          }
        }
      }
 catch (      java.lang.NullPointerException e) {
        System.out.println(""String_Node_Str"" + files[i].getName());
        continue;
      }
catch (      TaxonNotFoundException e) {
        e.printStackTrace();
      }
catch (      TreeIngestException e) {
        e.printStackTrace();
      }
      br.close();
    }
 catch (    FileNotFoundException e) {
      e.printStackTrace();
    }
catch (    IOException e) {
      e.printStackTrace();
    }
catch (    java.lang.NullPointerException e) {
      e.printStackTrace();
    }
  }
  graphDb.shutdownDb();
  return 0;
}","public int pg_loading(String[] args){
  GraphDatabaseAgent graphDb=new GraphDatabaseAgent(args[1]);
  if (args.length != 3) {
    graphDb.shutdownDb();
    return 1;
  }
  String directory=args[2];
  System.out.println(""String_Node_Str"" + directory + ""String_Node_Str""+ args[1]);
  File file=new File(directory);
  File[] files=file.listFiles();
  for (int i=0; i < files.length; i++) {
    System.out.println(""String_Node_Str"" + files[i]);
    try {
      BufferedReader br=new BufferedReader(new FileReader(files[i]));
      List<JadeTree> jt=NexsonReader.readNexson(br);
      for (      JadeTree j : jt) {
        System.out.println(files[i] + ""String_Node_Str"" + j.getExternalNodeCount());
      }
      PhylografterConnector.fixNamesFromTrees(Long.valueOf(files[i].getName()),jt,graphDb);
      try {
        for (        JadeTree j : jt) {
          GraphImporter gi=new GraphImporter(graphDb);
          boolean doubname=false;
          HashSet<Long> ottols=new HashSet<Long>();
          for (int m=0; m < j.getExternalNodeCount(); m++) {
            System.out.println(j.getExternalNode(m).getName() + ""String_Node_Str"" + j.getExternalNode(m).getObject(""String_Node_Str""));
            if (j.getExternalNode(m).getObject(""String_Node_Str"") == null) {
              doubname=true;
              break;
            }
            if (ottols.contains((Long)j.getExternalNode(m).getObject(""String_Node_Str"")) == true) {
              doubname=true;
              break;
            }
 else {
              ottols.add((Long)j.getExternalNode(m).getObject(""String_Node_Str""));
            }
          }
          if (doubname == true) {
            System.out.println(""String_Node_Str"");
          }
 else {
            System.out.println(""String_Node_Str"");
            gi.setTree(j);
            String sourcename=""String_Node_Str"";
            if (j.getObject(""String_Node_Str"") != null) {
              sourcename=(String)j.getObject(""String_Node_Str"");
            }
            if (j.getObject(""String_Node_Str"") != null) {
              sourcename+=""String_Node_Str"" + (String)j.getObject(""String_Node_Str"");
            }
            Index<Node> sourceMetaIndex=graphDb.getNodeIndex(""String_Node_Str"");
            IndexHits<Node> hits=sourceMetaIndex.get(""String_Node_Str"",sourcename);
            if (hits.size() > 0) {
              System.out.println(""String_Node_Str"" + sourcename + ""String_Node_Str"");
            }
 else {
              gi.addSetTreeToGraphWIdsSet(sourcename);
            }
          }
        }
      }
 catch (      java.lang.NullPointerException e) {
        System.out.println(""String_Node_Str"" + files[i].getName());
        continue;
      }
catch (      TaxonNotFoundException e) {
        e.printStackTrace();
      }
catch (      TreeIngestException e) {
        e.printStackTrace();
      }
      br.close();
    }
 catch (    FileNotFoundException e) {
      e.printStackTrace();
    }
catch (    IOException e) {
      e.printStackTrace();
    }
catch (    java.lang.NullPointerException e) {
      e.printStackTrace();
    }
  }
  graphDb.shutdownDb();
  return 0;
}"
50216,"public static boolean writePropertyNameColonIfFound(StringBuffer buffer,Node nd,String propertyName,boolean prependComma){
  if (nd.hasProperty(propertyName)) {
    if (prependComma) {
      buffer.append(""String_Node_Str"");
    }
 else {
      buffer.append(""String_Node_Str"");
    }
    buffer.append(propertyName);
    buffer.append(""String_Node_Str"");
    return true;
  }
  return false;
}","public static boolean writePropertyNameColonIfFound(StringBuffer buffer,Node nd,String propertyName,boolean prependComma){
  if (nd.hasProperty(propertyName)) {
    if (prependComma) {
      buffer.append(""String_Node_Str"");
    }
    escapePropertyColon(buffer,propertyName);
    return true;
  }
  return false;
}"
50217,"public static void writeSourceToMetaMapForArgus(StringBuffer buffer,Object n2m){
  buffer.append(""String_Node_Str"");
  HashMap<String,Node> name2metanode=(HashMap<String,Node>)n2m;
  boolean first=true;
  for (  Map.Entry<String,Node> n2mEl : name2metanode.entrySet()) {
    if (first) {
      first=false;
    }
 else {
      buffer.append(""String_Node_Str"");
    }
    String source=n2mEl.getKey();
    Node metadataNode=n2mEl.getValue();
    buffer.append(""String_Node_Str"");
    buffer.append(source);
    buffer.append(""String_Node_Str"");
    if (metadataNode == null) {
      buffer.append(""String_Node_Str"");
    }
 else {
      boolean prevProperties=false;
      buffer.append(""String_Node_Str"");
      prevProperties=writeStringPropertyIfFound(buffer,metadataNode,""String_Node_Str"",prevProperties);
      prevProperties=writeStringPropertyIfFound(buffer,metadataNode,""String_Node_Str"",prevProperties);
      prevProperties=writeStringPropertyIfFound(buffer,metadataNode,""String_Node_Str"",prevProperties);
      prevProperties=writeStringPropertyIfFound(buffer,metadataNode,""String_Node_Str"",prevProperties);
      prevProperties=writeStringPropertyIfFound(buffer,metadataNode,""String_Node_Str"",prevProperties);
      prevProperties=writeIntegerPropertyIfFound(buffer,metadataNode,""String_Node_Str"",prevProperties);
      buffer.append(""String_Node_Str"");
    }
  }
  buffer.append(""String_Node_Str"");
}","public static void writeSourceToMetaMapForArgus(StringBuffer buffer,Object n2m){
  buffer.append(""String_Node_Str"");
  HashMap<String,Node> name2metanode=(HashMap<String,Node>)n2m;
  boolean first=true;
  for (  Map.Entry<String,Node> n2mEl : name2metanode.entrySet()) {
    if (first) {
      first=false;
    }
 else {
      buffer.append(""String_Node_Str"");
    }
    String source=n2mEl.getKey();
    Node metadataNode=n2mEl.getValue();
    if (source == null || source.length() == 0) {
      escapePropertyColon(buffer,""String_Node_Str"");
    }
 else {
      escapePropertyColon(buffer,source);
    }
    if (metadataNode == null) {
      buffer.append(""String_Node_Str"");
    }
 else {
      boolean wrotePrev=false;
      buffer.append(""String_Node_Str"");
      wrotePrev=writeStringPropertyIfFound(buffer,metadataNode,""String_Node_Str"",wrotePrev) || wrotePrev;
      wrotePrev=writeStringPropertyIfFound(buffer,metadataNode,""String_Node_Str"",wrotePrev) || wrotePrev;
      wrotePrev=writeStringPropertyIfFound(buffer,metadataNode,""String_Node_Str"",wrotePrev) || wrotePrev;
      wrotePrev=writeStringPropertyIfFound(buffer,metadataNode,""String_Node_Str"",wrotePrev) || wrotePrev;
      wrotePrev=writeStringPropertyIfFound(buffer,metadataNode,""String_Node_Str"",wrotePrev) || wrotePrev;
      wrotePrev=writeIntegerPropertyIfFound(buffer,metadataNode,""String_Node_Str"",wrotePrev) || wrotePrev;
      buffer.append(""String_Node_Str"");
    }
  }
  buffer.append(""String_Node_Str"");
}"
50218,"/** 
 * @param maxDepth is the max number of edges between the root and an included nodeif non-negative this can be used to prune off subtrees that exceed the threshold distance from the root. If maxDepth is negative, no threshold is applied
 */
private JadeTree reconstructSyntheticTreeHelper(String treeID,Node rootnode,int maxDepth){
  JadeNode root=new JadeNode();
  if (rootnode.hasProperty(""String_Node_Str"")) {
    root.setName((String)rootnode.getProperty(""String_Node_Str""));
  }
  root.assocObject(""String_Node_Str"",rootnode.getId());
  boolean printlengths=false;
  HashMap<Node,JadeNode> node2JadeNode=new HashMap<Node,JadeNode>();
  node2JadeNode.put(rootnode,root);
  TraversalDescription synthEdgeTraversal=Traversal.description().relationships(RelTypes.SYNTHCHILDOF,Direction.INCOMING);
  synthEdgeTraversal=synthEdgeTraversal.depthFirst();
  if (maxDepth >= 0) {
    synthEdgeTraversal=synthEdgeTraversal.evaluator(Evaluators.toDepth(maxDepth));
  }
  for (  Path path : synthEdgeTraversal.traverse(rootnode)) {
    Relationship furshestRel=path.lastRelationship();
    if (furshestRel != null && furshestRel.hasProperty(""String_Node_Str"")) {
      String rn=(String)furshestRel.getProperty(""String_Node_Str"");
      if (rn.equals(treeID)) {
        Node parNode=furshestRel.getEndNode();
        Node childNode=furshestRel.getStartNode();
        JadeNode jChild=new JadeNode();
        final long cid=childNode.getId();
        if (childNode.hasProperty(""String_Node_Str"")) {
          jChild.setName((String)childNode.getProperty(""String_Node_Str""));
        }
        jChild.assocObject(""String_Node_Str"",cid);
        if (furshestRel.hasProperty(""String_Node_Str"")) {
          printlengths=true;
          jChild.setBL((Double)furshestRel.getProperty(""String_Node_Str""));
        }
        node2JadeNode.get(parNode).addChild(jChild);
        node2JadeNode.put(childNode,jChild);
      }
    }
  }
  JadeTree tree=new JadeTree(root);
  tree.setHasBranchLengths(printlengths);
  return tree;
}","/** 
 * @param maxDepth is the max number of edges between the root and an included nodeif non-negative this can be used to prune off subtrees that exceed the threshold distance from the root. If maxDepth is negative, no threshold is applied
 */
private JadeTree reconstructSyntheticTreeHelper(String treeID,Node rootnode,int maxDepth){
  JadeNode root=new JadeNode();
  if (rootnode.hasProperty(""String_Node_Str"")) {
    root.setName((String)rootnode.getProperty(""String_Node_Str""));
  }
  root.assocObject(""String_Node_Str"",rootnode.getId());
  boolean printlengths=false;
  HashMap<Node,JadeNode> node2JadeNode=new HashMap<Node,JadeNode>();
  node2JadeNode.put(rootnode,root);
  TraversalDescription synthEdgeTraversal=Traversal.description().relationships(RelTypes.SYNTHCHILDOF,Direction.INCOMING);
  synthEdgeTraversal=synthEdgeTraversal.depthFirst();
  if (maxDepth >= 0) {
    synthEdgeTraversal=synthEdgeTraversal.evaluator(Evaluators.toDepth(maxDepth));
  }
  for (  Path path : synthEdgeTraversal.traverse(rootnode)) {
    Relationship furshestRel=path.lastRelationship();
    if (furshestRel != null && furshestRel.hasProperty(""String_Node_Str"")) {
      String rn=(String)furshestRel.getProperty(""String_Node_Str"");
      if (rn.equals(treeID)) {
        Node parNode=furshestRel.getEndNode();
        Node childNode=furshestRel.getStartNode();
        JadeNode jChild=new JadeNode();
        final long cid=childNode.getId();
        if (childNode.hasProperty(""String_Node_Str"")) {
          jChild.setName((String)childNode.getProperty(""String_Node_Str""));
        }
        jChild.assocObject(""String_Node_Str"",cid);
        if (furshestRel.hasProperty(""String_Node_Str"")) {
          printlengths=true;
          jChild.setBL((Double)furshestRel.getProperty(""String_Node_Str""));
        }
        node2JadeNode.get(parNode).addChild(jChild);
        node2JadeNode.put(childNode,jChild);
      }
    }
  }
  JadeTree tree=new JadeTree(root);
  root.assocObject(""String_Node_Str"",root.getNodeMaxDepth());
  tree.setHasBranchLengths(printlengths);
  return tree;
}"
50219,"/** 
 * @returns 0 for success, 1 for error, 2 for error with a request that the generic help be displayed
 */
public int graphImporterParser(String[] args) throws TaxonNotFoundException, DataFormatException, TreeIngestException {
  boolean readingNewick=false;
  boolean readingNexson=false;
  if (args[0].compareTo(""String_Node_Str"") == 0) {
    readingNewick=true;
  }
  if (args[0].compareTo(""String_Node_Str"") == 0) {
    readingNexson=true;
  }
 else {
    return 2;
  }
  String filename;
  String idfilename=""String_Node_Str"";
  String focalgroup;
  String sourcename;
  String graphname;
  if (readingNewick) {
    if (args.length != 6) {
      System.out.println(""String_Node_Str"");
      return 1;
    }
    filename=args[1];
    idfilename=args[2];
    focalgroup=args[3];
    sourcename=args[4];
    graphname=args[5];
  }
 else {
    if (args.length != 5) {
      System.out.println(""String_Node_Str"");
      return 1;
    }
    filename=args[1];
    focalgroup=args[2];
    sourcename=args[3];
    graphname=args[4];
  }
  int treeCounter=0;
  GraphImporter gi=new GraphImporter(graphname);
  try {
    if (gi.hasSoureTreeName(sourcename)) {
      String emsg=""String_Node_Str"" + sourcename + ""String_Node_Str"";
      throw new TreeIngestException(emsg);
    }
    System.out.println(""String_Node_Str"" + filename);
    ArrayList<JadeTree> jt=new ArrayList<JadeTree>();
    try {
      if (readingNewick) {
        System.out.println(""String_Node_Str"");
        TreeReader tr=new TreeReader();
        BufferedReader ibr=new BufferedReader(new FileReader(idfilename));
        String treeID;
        String ts=""String_Node_Str"";
        BufferedReader br=new BufferedReader(new FileReader(filename));
        int treeNum=0;
        while ((ts=br.readLine()) != null) {
          if (ts.length() > 1) {
            ++treeNum;
            treeID=""String_Node_Str"";
            while (treeID.length() == 0) {
              if (null == (treeID=ibr.readLine())) {
                String emsg=""String_Node_Str"" + filename + ""String_Node_Str""+ treeNum+ ""String_Node_Str""+ idfilename+ ""String_Node_Str"";
                throw new TreeIngestException(emsg);
              }
            }
            JadeTree newestTree=tr.readTree(ts);
            newestTree.assocObject(""String_Node_Str"",treeID);
            jt.add(newestTree);
            treeCounter++;
          }
        }
        br.close();
      }
 else {
        System.out.println(""String_Node_Str"");
        for (        JadeTree tree : NexsonReader.readNexson(filename)) {
          jt.add(tree);
          treeCounter++;
        }
      }
    }
 catch (    IOException ioe) {
    }
    System.out.println(treeCounter + ""String_Node_Str"");
    for (int i=0; i < jt.size(); i++) {
      System.out.println(""String_Node_Str"" + i);
      gi.setTree(jt.get(i));
      if (jt.get(i).getObject(""String_Node_Str"") != null) {
        sourcename=(String)jt.get(i).getObject(""String_Node_Str"");
      }
      if (jt.size() == 1) {
        gi.addSetTreeToGraph(focalgroup,sourcename);
        gi.updateAfterTreeIngest(false);
      }
 else {
        gi.addSetTreeToGraph(focalgroup,sourcename + ""String_Node_Str"" + String.valueOf(i));
        gi.deleteTreeBySource(sourcename + ""String_Node_Str"" + String.valueOf(i));
      }
    }
    if (jt.size() > 1) {
      for (int i=0; i < jt.size(); i++) {
        if (jt.get(i).getObject(""String_Node_Str"") != null) {
          sourcename=(String)jt.get(i).getObject(""String_Node_Str"");
        }
        System.out.println(""String_Node_Str"" + i);
        gi.setTree(jt.get(i));
        gi.addSetTreeToGraph(focalgroup,sourcename + ""String_Node_Str"" + String.valueOf(i));
      }
    }
  }
  finally {
    gi.shutdownDB();
  }
  return 0;
}","/** 
 * @returns 0 for success, 1 for error, 2 for error with a request that the generic help be displayed
 */
public int graphImporterParser(String[] args) throws TaxonNotFoundException, DataFormatException, TreeIngestException {
  boolean readingNewick=false;
  boolean readingNexson=false;
  if (args[0].compareTo(""String_Node_Str"") == 0) {
    readingNewick=true;
  }
 else   if (args[0].compareTo(""String_Node_Str"") == 0) {
    readingNexson=true;
  }
 else {
    System.out.println(""String_Node_Str"" + args[0] + ""String_Node_Str"");
    return 2;
  }
  String filename;
  String idfilename=""String_Node_Str"";
  String focalgroup;
  String sourcename;
  String graphname;
  if (readingNewick) {
    if (args.length != 6) {
      System.out.println(""String_Node_Str"");
      return 1;
    }
    filename=args[1];
    idfilename=args[2];
    focalgroup=args[3];
    sourcename=args[4];
    graphname=args[5];
  }
 else {
    if (args.length != 5) {
      System.out.println(""String_Node_Str"");
      return 1;
    }
    filename=args[1];
    focalgroup=args[2];
    sourcename=args[3];
    graphname=args[4];
  }
  int treeCounter=0;
  GraphImporter gi=new GraphImporter(graphname);
  try {
    if (gi.hasSoureTreeName(sourcename)) {
      String emsg=""String_Node_Str"" + sourcename + ""String_Node_Str"";
      throw new TreeIngestException(emsg);
    }
    System.out.println(""String_Node_Str"" + filename);
    ArrayList<JadeTree> jt=new ArrayList<JadeTree>();
    try {
      if (readingNewick) {
        System.out.println(""String_Node_Str"");
        TreeReader tr=new TreeReader();
        BufferedReader ibr=new BufferedReader(new FileReader(idfilename));
        String treeID;
        String ts=""String_Node_Str"";
        BufferedReader br=new BufferedReader(new FileReader(filename));
        int treeNum=0;
        while ((ts=br.readLine()) != null) {
          if (ts.length() > 1) {
            ++treeNum;
            treeID=""String_Node_Str"";
            while (treeID.length() == 0) {
              if (null == (treeID=ibr.readLine())) {
                String emsg=""String_Node_Str"" + filename + ""String_Node_Str""+ treeNum+ ""String_Node_Str""+ idfilename+ ""String_Node_Str"";
                throw new TreeIngestException(emsg);
              }
            }
            JadeTree newestTree=tr.readTree(ts);
            newestTree.assocObject(""String_Node_Str"",treeID);
            jt.add(newestTree);
            treeCounter++;
          }
        }
        br.close();
      }
 else {
        System.out.println(""String_Node_Str"");
        for (        JadeTree tree : NexsonReader.readNexson(filename)) {
          jt.add(tree);
          treeCounter++;
        }
      }
    }
 catch (    IOException ioe) {
    }
    System.out.println(treeCounter + ""String_Node_Str"");
    for (int i=0; i < jt.size(); i++) {
      System.out.println(""String_Node_Str"" + i);
      gi.setTree(jt.get(i));
      if (jt.get(i).getObject(""String_Node_Str"") != null) {
        sourcename=(String)jt.get(i).getObject(""String_Node_Str"");
      }
      if (jt.size() == 1) {
        gi.addSetTreeToGraph(focalgroup,sourcename);
        gi.updateAfterTreeIngest(false);
      }
 else {
        gi.addSetTreeToGraph(focalgroup,sourcename + ""String_Node_Str"" + String.valueOf(i));
        gi.deleteTreeBySource(sourcename + ""String_Node_Str"" + String.valueOf(i));
      }
    }
    if (jt.size() > 1) {
      for (int i=0; i < jt.size(); i++) {
        if (jt.get(i).getObject(""String_Node_Str"") != null) {
          sourcename=(String)jt.get(i).getObject(""String_Node_Str"");
        }
        System.out.println(""String_Node_Str"" + i);
        gi.setTree(jt.get(i));
        gi.addSetTreeToGraph(focalgroup,sourcename + ""String_Node_Str"" + String.valueOf(i));
      }
    }
  }
  finally {
    gi.shutdownDB();
  }
  return 0;
}"
50220,"/** 
 * Get the list of sources that have been loaded in the graph
 */
public String getSourceList(){
  StringBuffer sb=new StringBuffer();
  IndexHits<Node> hits=sourceMetaIndex.query(""String_Node_Str"");
  while (hits.hasNext()) {
    Node n=hits.next();
    sb.append(n.getProperty(""String_Node_Str"") + ""String_Node_Str"");
  }
  return sb.toString();
}","/** 
 * Get the list of sources that have been loaded in the graph
 */
public String getSourceList(){
  StringBuffer sb=new StringBuffer();
  IndexHits<Node> hits=sourceMetaIndex.query(""String_Node_Str"",""String_Node_Str"");
  while (hits.hasNext()) {
    Node n=hits.next();
    sb.append(n.getProperty(""String_Node_Str"") + ""String_Node_Str"");
  }
  return sb.toString();
}"
50221,"/** 
 * This function is the preorder function for constructing newick trees given a list of sources. This ONLY considers the sources. There should be a general function that considers some sort of hierarchy of decisions (WORKING ON THIS - CEH) TODO: this will need to eventually incorporate more functionality for deciding based on more than the sources
 * @param curnode
 * @param parent
 * @param sources
 * @param relcoming
 * @return
 */
private JadeNode preorderConstructNewickTieBreakerSOURCE(Node curnode,JadeNode parent,String[] sources,Relationship relcoming,boolean useTaxonomy){
  boolean ret=false;
  JadeNode newNode=new JadeNode();
  if (curnode.hasProperty(""String_Node_Str"")) {
    newNode.setName((String)curnode.getProperty(""String_Node_Str""));
    newNode.setName(GeneralUtils.cleanName(newNode.getName()));
  }
  if (parent == null) {
    ret=true;
  }
 else {
    parent.addChild(newNode);
    if (sinkLostChildrenStrict || sinkLostChildrenRelaxed) {
      knownIdsInTree.add(curnode.getId());
    }
    if (relcoming.hasProperty(""String_Node_Str"")) {
      newNode.setBL((Double)relcoming.getProperty(""String_Node_Str""));
    }
  }
  HashMap<Long,HashSet<Long>> candNodeDescendantIdsMap=new HashMap<Long,HashSet<Long>>();
  HashMap<Long,Integer> candNodeRankingMap=new HashMap<Long,Integer>();
  HashMap<Long,Relationship> candNodeRelationshipMap=new HashMap<Long,Relationship>();
  HashSet<Long> candidateNodeIds=new HashSet<Long>();
  for (  Relationship candRel : curnode.getRelationships(Direction.INCOMING,RelTypes.STREECHILDOF)) {
    if (useTaxonomy == false) {
      if (candRel.getProperty(""String_Node_Str"").equals(""String_Node_Str""))       continue;
    }
    Long cid=candRel.getStartNode().getId();
    if (candidateNodeIds.contains(cid) == false) {
      candidateNodeIds.add(cid);
      HashSet<Long> descIds=new HashSet<Long>();
      for (      long descId : (long[])graphDb.getNodeById(cid).getProperty(""String_Node_Str""))       descIds.add(descId);
      candNodeDescendantIdsMap.put(cid,descIds);
      candNodeRelationshipMap.put(cid,candRel);
      candNodeRankingMap.put(cid,sources.length);
    }
    if (candNodeRankingMap.get(cid) != 0) {
      String sourceName=(String)candRel.getProperty(""String_Node_Str"");
      for (int i=0; i < sources.length; i++) {
        if (sourceName.compareTo(sources[i]) == 0) {
          if (candNodeRankingMap.get(cid) > i) {
            candNodeRankingMap.put(cid,i);
            candNodeRelationshipMap.put(cid,candRel);
          }
          break;
        }
      }
    }
  }
  if (candidateNodeIds.size() == 0) {
    return null;
  }
  HashSet<Long> putativeLostChildIds=null;
  if (sinkLostChildrenStrict) {
    putativeLostChildIds=new HashSet<Long>();
  }
  HashSet<Long> nodesToExclude=new HashSet<Long>();
  for (  Long cid_i : candidateNodeIds) {
    if (nodesToExclude.contains(cid_i))     continue;
    HashSet<Long> descIds_i=candNodeDescendantIdsMap.get(cid_i);
    for (    Long cid_j : candidateNodeIds) {
      if (cid_j == cid_i || nodesToExclude.contains(cid_j))       continue;
      HashSet<Long> descIds_j=candNodeDescendantIdsMap.get(cid_j);
      HashSet<Long> descIds_iMinusj=new HashSet<Long>(descIds_i);
      descIds_iMinusj.removeAll(descIds_j);
      if ((descIds_i.size() - descIds_iMinusj.size()) > 0) {
        if (candNodeRankingMap.get(cid_i) < candNodeRankingMap.get(cid_j)) {
          nodesToExclude.add(cid_j);
          if (sinkLostChildrenStrict) {
            putativeLostChildIds.addAll(descIds_j);
          }
        }
 else {
          nodesToExclude.add(cid_i);
          if (sinkLostChildrenStrict) {
            putativeLostChildIds.addAll(descIds_i);
          }
 else {
            break;
          }
        }
      }
    }
  }
  candidateNodeIds.removeAll(nodesToExclude);
  if (candidateNodeIds.size() == 0) {
    return null;
  }
  if (sinkLostChildrenStrict) {
    HashSet<Long> impliedDescendantIds=new HashSet<Long>();
    for (    Long cid : candidateNodeIds) {
      for (      long descId : (long[])graphDb.getNodeById(cid).getProperty(""String_Node_Str""))       impliedDescendantIds.add(descId);
    }
    for (    Long childId : putativeLostChildIds) {
      if (!impliedDescendantIds.contains(childId) && !knownIdsInTree.contains(childId)) {
        JadeNode addlChild=new JadeNode();
        Node graphNodeForChild=graphDb.getNodeById(childId);
        if (graphNodeForChild.hasProperty(""String_Node_Str"")) {
          addlChild.setName((String)graphNodeForChild.getProperty(""String_Node_Str""));
          addlChild.setName(GeneralUtils.cleanName(addlChild.getName()));
        }
        newNode.addChild(addlChild);
        knownIdsInTree.add(childId);
      }
    }
  }
  for (  Long cid : candidateNodeIds) {
    preorderConstructNewickTieBreakerSOURCE(graphDb.getNodeById(cid),newNode,sources,candNodeRelationshipMap.get(cid),useTaxonomy);
  }
  if (ret == true) {
    return newNode;
  }
  return null;
}","/** 
 * This function is the preorder function for constructing newick trees given a list of sources. This ONLY considers the sources. There should be a general function that considers some sort of hierarchy of decisions TODO: this will need to eventually incorporate more functionality for deciding based on more than the sources
 * @param curnode
 * @param parent
 * @param sources
 * @param relcoming
 * @return
 */
private JadeNode preorderConstructNewickTieBreakerSOURCE(Node curnode,JadeNode parent,String[] sources,Relationship relcoming,boolean useTaxonomy){
  boolean ret=false;
  JadeNode newNode=new JadeNode();
  if (curnode.hasProperty(""String_Node_Str"")) {
    newNode.setName((String)curnode.getProperty(""String_Node_Str""));
    newNode.setName(GeneralUtils.cleanName(newNode.getName()));
  }
  if (parent == null) {
    ret=true;
  }
 else {
    parent.addChild(newNode);
    if (sinkLostChildrenStrict || sinkLostChildrenRelaxed) {
      knownIdsInTree.add(curnode.getId());
    }
    if (relcoming.hasProperty(""String_Node_Str"")) {
      newNode.setBL((Double)relcoming.getProperty(""String_Node_Str""));
    }
  }
  HashMap<Long,HashSet<Long>> candNodeDescendantIdsMap=new HashMap<Long,HashSet<Long>>();
  HashMap<Long,Integer> candNodeRankingMap=new HashMap<Long,Integer>();
  HashMap<Long,Relationship> candNodeRelationshipMap=new HashMap<Long,Relationship>();
  HashSet<Long> candidateNodeIds=new HashSet<Long>();
  for (  Relationship candRel : curnode.getRelationships(Direction.INCOMING,RelTypes.STREECHILDOF)) {
    if (useTaxonomy == false) {
      if (candRel.getProperty(""String_Node_Str"").equals(""String_Node_Str""))       continue;
    }
    Long cid=candRel.getStartNode().getId();
    if (candidateNodeIds.contains(cid) == false) {
      candidateNodeIds.add(cid);
      HashSet<Long> descIds=new HashSet<Long>();
      for (      long descId : (long[])graphDb.getNodeById(cid).getProperty(""String_Node_Str""))       descIds.add(descId);
      candNodeDescendantIdsMap.put(cid,descIds);
      candNodeRelationshipMap.put(cid,candRel);
      candNodeRankingMap.put(cid,sources.length);
    }
    if (candNodeRankingMap.get(cid) != 0) {
      String sourceName=(String)candRel.getProperty(""String_Node_Str"");
      for (int i=0; i < sources.length; i++) {
        if (sourceName.compareTo(sources[i]) == 0) {
          if (candNodeRankingMap.get(cid) > i) {
            candNodeRankingMap.put(cid,i);
            candNodeRelationshipMap.put(cid,candRel);
          }
          break;
        }
      }
    }
  }
  if (candidateNodeIds.size() == 0) {
    return null;
  }
  HashSet<Long> putativeLostChildIds=null;
  if (sinkLostChildrenStrict) {
    putativeLostChildIds=new HashSet<Long>();
  }
  HashSet<Long> nodesToExclude=new HashSet<Long>();
  for (  Long cid_i : candidateNodeIds) {
    if (nodesToExclude.contains(cid_i))     continue;
    HashSet<Long> descIds_i=candNodeDescendantIdsMap.get(cid_i);
    for (    Long cid_j : candidateNodeIds) {
      if (cid_j == cid_i || nodesToExclude.contains(cid_j))       continue;
      HashSet<Long> descIds_j=candNodeDescendantIdsMap.get(cid_j);
      HashSet<Long> descIds_iMinusj=new HashSet<Long>(descIds_i);
      descIds_iMinusj.removeAll(descIds_j);
      if ((descIds_i.size() - descIds_iMinusj.size()) > 0) {
        if (candNodeRankingMap.get(cid_i) < candNodeRankingMap.get(cid_j)) {
          nodesToExclude.add(cid_j);
          if (sinkLostChildrenStrict) {
            putativeLostChildIds.addAll(descIds_j);
          }
        }
 else {
          nodesToExclude.add(cid_i);
          if (sinkLostChildrenStrict) {
            putativeLostChildIds.addAll(descIds_i);
          }
 else {
            break;
          }
        }
      }
    }
  }
  candidateNodeIds.removeAll(nodesToExclude);
  if (candidateNodeIds.size() == 0) {
    return null;
  }
  if (sinkLostChildrenStrict) {
    HashSet<Long> impliedDescendantIds=new HashSet<Long>();
    for (    Long cid : candidateNodeIds) {
      for (      long descId : (long[])graphDb.getNodeById(cid).getProperty(""String_Node_Str""))       impliedDescendantIds.add(descId);
    }
    for (    Long childId : putativeLostChildIds) {
      if (!impliedDescendantIds.contains(childId) && !knownIdsInTree.contains(childId)) {
        JadeNode addlChild=new JadeNode();
        Node graphNodeForChild=graphDb.getNodeById(childId);
        if (graphNodeForChild.hasProperty(""String_Node_Str"")) {
          addlChild.setName((String)graphNodeForChild.getProperty(""String_Node_Str""));
          addlChild.setName(GeneralUtils.cleanName(addlChild.getName()));
        }
        newNode.addChild(addlChild);
        knownIdsInTree.add(childId);
      }
    }
  }
  for (  Long cid : candidateNodeIds) {
    preorderConstructNewickTieBreakerSOURCE(graphDb.getNodeById(cid),newNode,sources,candNodeRelationshipMap.get(cid),useTaxonomy);
  }
  if (ret == true) {
    return newNode;
  }
  return null;
}"
50222,"public void justTreeAnalysis(String[] args){
  if (args.length > 3) {
    System.out.println(""String_Node_Str"");
    return;
  }
  String filename=args[1];
  String graphname=args[2];
  int treeCounter=0;
  GraphImporter gi=new GraphImporter(graphname);
  String ts=""String_Node_Str"";
  ArrayList<JadeTree> jt=new ArrayList<JadeTree>();
  TreeReader tr=new TreeReader();
  try {
    BufferedReader br=new BufferedReader(new FileReader(filename));
    if (divineTreeFormat(br).compareTo(""String_Node_Str"") == 0) {
      System.out.println(""String_Node_Str"");
      TreeReader tr=new TreeReader();
      while ((ts=br.readLine()) != null) {
        if (ts.length() > 1) {
          jt.add(tr.readTree(ts));
          treeCounter++;
        }
      }
    }
 else {
      System.out.println(""String_Node_Str"");
      for (      JadeTree tree : NexsonReader.readNexson(filename)) {
        jt.add(tree);
        treeCounter++;
      }
    }
    br.close();
  }
 catch (  IOException ioe) {
  }
  System.out.println(treeCounter + ""String_Node_Str"");
  HashSet<String> names=new HashSet<String>();
  for (int i=0; i < jt.size(); i++) {
    for (int j=0; j < jt.get(i).getExternalNodeCount(); j++) {
      names.add(jt.get(i).getExternalNode(j).getName());
    }
  }
  PrintWriter outFile;
  try {
    outFile=new PrintWriter(new FileWriter(""String_Node_Str""));
    ArrayList<String> namesal=new ArrayList<String>();
    namesal.addAll(names);
    for (int i=0; i < namesal.size(); i++) {
      outFile.write((i + 2) + ""String_Node_Str"" + namesal.get(i)+ ""String_Node_Str"");
    }
    outFile.write(""String_Node_Str"");
    outFile.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  gi.addInitialTaxonomyTableIntoGraph(""String_Node_Str"",""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  for (int i=0; i < jt.size(); i++) {
    System.out.println(""String_Node_Str"" + i);
    gi.setTree(jt.get(i));
    try {
      gi.addProcessedTreeToGraph(""String_Node_Str"",""String_Node_Str"" + String.valueOf(i));
      gi.deleteTreeBySource(""String_Node_Str"" + String.valueOf(i));
    }
 catch (    TaxonNotFoundException tnfx) {
      System.err.println(""String_Node_Str"" + tnfx.getQuotedName() + ""String_Node_Str"");
      System.exit(1);
    }
catch (    TreeIngestException tix) {
      System.err.println(""String_Node_Str"" + tix.toString());
      System.exit(1);
    }
  }
  for (int i=0; i < jt.size(); i++) {
    System.out.println(""String_Node_Str"" + i);
    gi.setTree(jt.get(i));
    try {
      gi.addProcessedTreeToGraph(""String_Node_Str"",""String_Node_Str"" + String.valueOf(i));
    }
 catch (    TaxonNotFoundException tnfx) {
      System.err.println(""String_Node_Str"" + tnfx.getQuotedName() + ""String_Node_Str"");
      System.exit(1);
    }
catch (    TreeIngestException tix) {
      System.err.println(""String_Node_Str"" + tix.toString());
      System.exit(1);
    }
  }
  gi.shutdownDB();
}","public void justTreeAnalysis(String[] args){
  if (args.length > 3) {
    System.out.println(""String_Node_Str"");
    return;
  }
  String filename=args[1];
  String graphname=args[2];
  int treeCounter=0;
  GraphImporter gi=new GraphImporter(graphname);
  String ts=""String_Node_Str"";
  ArrayList<JadeTree> jt=new ArrayList<JadeTree>();
  try {
    BufferedReader br=new BufferedReader(new FileReader(filename));
    if (divineTreeFormat(br).compareTo(""String_Node_Str"") == 0) {
      System.out.println(""String_Node_Str"");
      TreeReader tr=new TreeReader();
      while ((ts=br.readLine()) != null) {
        if (ts.length() > 1) {
          jt.add(tr.readTree(ts));
          treeCounter++;
        }
      }
    }
 else {
      System.out.println(""String_Node_Str"");
      for (      JadeTree tree : NexsonReader.readNexson(filename)) {
        jt.add(tree);
        treeCounter++;
      }
    }
    br.close();
  }
 catch (  IOException ioe) {
  }
  System.out.println(treeCounter + ""String_Node_Str"");
  HashSet<String> names=new HashSet<String>();
  for (int i=0; i < jt.size(); i++) {
    for (int j=0; j < jt.get(i).getExternalNodeCount(); j++) {
      names.add(jt.get(i).getExternalNode(j).getName());
    }
  }
  PrintWriter outFile;
  try {
    outFile=new PrintWriter(new FileWriter(""String_Node_Str""));
    ArrayList<String> namesal=new ArrayList<String>();
    namesal.addAll(names);
    for (int i=0; i < namesal.size(); i++) {
      outFile.write((i + 2) + ""String_Node_Str"" + namesal.get(i)+ ""String_Node_Str"");
    }
    outFile.write(""String_Node_Str"");
    outFile.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  gi.addInitialTaxonomyTableIntoGraph(""String_Node_Str"",""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  for (int i=0; i < jt.size(); i++) {
    System.out.println(""String_Node_Str"" + i);
    gi.setTree(jt.get(i));
    try {
      gi.addProcessedTreeToGraph(""String_Node_Str"",""String_Node_Str"" + String.valueOf(i));
      gi.deleteTreeBySource(""String_Node_Str"" + String.valueOf(i));
    }
 catch (    TaxonNotFoundException tnfx) {
      System.err.println(""String_Node_Str"" + tnfx.getQuotedName() + ""String_Node_Str"");
      System.exit(1);
    }
catch (    TreeIngestException tix) {
      System.err.println(""String_Node_Str"" + tix.toString());
      System.exit(1);
    }
  }
  for (int i=0; i < jt.size(); i++) {
    System.out.println(""String_Node_Str"" + i);
    gi.setTree(jt.get(i));
    try {
      gi.addProcessedTreeToGraph(""String_Node_Str"",""String_Node_Str"" + String.valueOf(i));
    }
 catch (    TaxonNotFoundException tnfx) {
      System.err.println(""String_Node_Str"" + tnfx.getQuotedName() + ""String_Node_Str"");
      System.exit(1);
    }
catch (    TreeIngestException tix) {
      System.err.println(""String_Node_Str"" + tix.toString());
      System.exit(1);
    }
  }
  gi.shutdownDB();
}"
50223,"private static LinkedList<Node> getAncestorsPlusSelf(Node node,RelationshipExpander expander){
  LinkedList<Node> ancestors=new LinkedList<Node>();
  ancestors.add(node);
  Iterator<Relationship> relIterator=expander.expand(node).iterator();
  while (relIterator.hasNext()) {
    Relationship rel=relIterator.next();
    node=rel.getOtherNode(node);
    ancestors.add(node);
    relIterator=expander.expand(node).iterator();
  }
  return ancestors;
}","/** 
 * Returns a list of nodes starting at `node` and including every node  in the ""first"" path created using the RelationshipExpander to the root. For instance if `expander` was created using Traversal.expanderForTypes(RelTypes.MRCACHILDOF, Direction.OUTGOING) then this function will return `node` and all of its ancestors.
 * @param node starting Node
 * @param expander RelationshipExpander wraps a relationship that should not contain any cycles
 * @return LinkedList of nodes whichi starts with `node` and includeseach first node returned by the iterator created by calling   expander.expand(node).iterator();
 */
private static LinkedList<Node> getAncestorsPlusSelf(Node node,RelationshipExpander expander){
  LinkedList<Node> ancestors=new LinkedList<Node>();
  ancestors.add(node);
  Iterator<Relationship> relIterator=expander.expand(node).iterator();
  while (relIterator.hasNext()) {
    Relationship rel=relIterator.next();
    node=rel.getOtherNode(node);
    ancestors.add(node);
    relIterator=expander.expand(node).iterator();
  }
  return ancestors;
}"
50224,"private static void lookForCommonAncestor(LinkedList<Node> commonAncestors,Node currentNode,RelationshipExpander expander){
  while (currentNode != null) {
    for (int i=0; i < commonAncestors.size(); i++) {
      Node node=commonAncestors.get(i);
      if (node.getId() == currentNode.getId()) {
        for (int j=0; j < i; j++) {
          commonAncestors.pollFirst();
        }
        return;
      }
    }
    Iterator<Relationship> relIt=expander.expand(currentNode).iterator();
    if (relIt.hasNext()) {
      Relationship rel=relIt.next();
      currentNode=rel.getOtherNode(currentNode);
    }
 else {
      currentNode=null;
    }
  }
}","/** 
 * Shortens the commonAncestors list, such that it starts with the first element of commonAncestors which is an ancestor of currentNode. If none of the 
 * @param commonAncestors LinkedList of Nodes that should represent a node -> root path
 * @param expander RelationshipExpander wraps a relationship that should not contain any cycles (e.g. the node->root path via a Traversal.expanderForTypes(RelTypes.MRCACHILDOF, Direction.OUTGOING) )
 * @return true if a common ancestor is found, or false indicating that `commonAncestors` did not have a node in the path that started with `currentNode'
 */
private static boolean lookForCommonAncestor(LinkedList<Node> commonAncestors,Node currentNode,RelationshipExpander expander){
  while (currentNode != null) {
    for (int i=0; i < commonAncestors.size(); i++) {
      Node node=commonAncestors.get(i);
      if (node.getId() == currentNode.getId()) {
        for (int j=0; j < i; j++) {
          commonAncestors.pollFirst();
        }
        return true;
      }
    }
    Iterator<Relationship> relIt=expander.expand(currentNode).iterator();
    if (relIt.hasNext()) {
      Relationship rel=relIt.next();
      currentNode=rel.getOtherNode(currentNode);
    }
 else {
      currentNode=null;
    }
  }
  return false;
}"
50225,"/** 
 * @param nodeSet Set of nodes for which the LCA will be found.
 * @param relationshipType Relationship type used to look for the LCA
 * @param relationshipDirection Direction of the relationships used (seen from the descendant node)
 * @return The LCA node if there's one, null otherwise.
 */
public static Node lowestCommonAncestor(List<Node> nodeSet,RelationshipExpander expander){
  Node lowerCommonAncestor=null;
  if (nodeSet.size() > 1) {
    Node firstNode=nodeSet.get(0);
    LinkedList<Node> firstAncestors=getAncestorsPlusSelf(firstNode,expander);
    for (int i=1; i < nodeSet.size() && !firstAncestors.isEmpty(); i++) {
      Node currentNode=nodeSet.get(i);
      lookForCommonAncestor(firstAncestors,currentNode,expander);
    }
    if (!firstAncestors.isEmpty()) {
      lowerCommonAncestor=firstAncestors.get(0);
    }
  }
  return lowerCommonAncestor;
}","/** 
 * Return the lowest common ancestor of the nodes in `nodeSet` or null (if they do not share a common ancestor).
 * @param nodeSet Set of nodes for which the LCA will be found.
 * @param expander RelationshipExpander which determines which relationships will be traversed when looking for the least common ancestor
 * @return The LCA node if there's one, null otherwise.
 */
public static Node lowestCommonAncestor(List<Node> nodeSet,RelationshipExpander expander){
  Node lowerCommonAncestor=null;
  if (nodeSet.size() > 1) {
    Node firstNode=nodeSet.get(0);
    LinkedList<Node> firstAncestors=getAncestorsPlusSelf(firstNode,expander);
    for (int i=1; i < nodeSet.size() && !firstAncestors.isEmpty(); i++) {
      Node currentNode=nodeSet.get(i);
      if (!lookForCommonAncestor(firstAncestors,currentNode,expander)) {
        return null;
      }
    }
    if (!firstAncestors.isEmpty()) {
      lowerCommonAncestor=firstAncestors.get(0);
    }
  }
  return lowerCommonAncestor;
}"
50226,"private void processMRCAS(){
  for (int i=0; i < jt.getInternalNodeCount(); i++) {
    JadeNode tnode=jt.getInternalNode(i);
    ArrayList<JadeNode> nds=tnode.getTips();
    ArrayList<Node> hit_nodes=new ArrayList<Node>();
    for (int j=0; j < nds.size(); j++) {
      IndexHits<Node> hits=nodeIndex.get(""String_Node_Str"",nds.get(j).getName().replace(""String_Node_Str"",""String_Node_Str""));
      hit_nodes.add(hits.getSingle());
      Node tnode1=hits.getSingle();
      hits.close();
    }
    expander=Traversal.expanderForTypes(RelTypes.CHILDOF,Direction.OUTGOING);
    Node ancestor=AncestorUtil.lowestCommonAncestor(hit_nodes,expander);
    System.out.println(ancestor.getProperty(""String_Node_Str""));
  }
}","public void processMRCAS(){
  for (int i=0; i < jt.getInternalNodeCount(); i++) {
    JadeNode tnode=jt.getInternalNode(i);
    ArrayList<JadeNode> nds=tnode.getTips();
    ArrayList<Node> hit_nodes=new ArrayList<Node>();
    for (int j=0; j < nds.size(); j++) {
      IndexHits<Node> hits=nodeIndex.get(""String_Node_Str"",nds.get(j).getName().replace(""String_Node_Str"",""String_Node_Str""));
      hit_nodes.add(hits.getSingle());
      Node tnode1=hits.getSingle();
      hits.close();
    }
    expander=Traversal.expanderForTypes(RelTypes.MRCACHILDOF,Direction.OUTGOING);
    Node ancestor=AncestorUtil.lowestCommonAncestor(hit_nodes,expander);
    System.out.println(ancestor.getProperty(""String_Node_Str""));
  }
}"
50227,"public void preProcessTree(String filename){
  TreeReader tr=new TreeReader();
  String ts=""String_Node_Str"";
  try {
    BufferedReader br=new BufferedReader(new FileReader(filename));
    ts=br.readLine();
    br.close();
  }
 catch (  IOException ioe) {
  }
  tr.setTree(ts);
  jt=tr.readTree();
  processMRCAS();
}","public void preProcessTree(String filename){
  TreeReader tr=new TreeReader();
  String ts=""String_Node_Str"";
  try {
    BufferedReader br=new BufferedReader(new FileReader(filename));
    ts=br.readLine();
    br.close();
  }
 catch (  IOException ioe) {
  }
  tr.setTree(ts);
  jt=tr.readTree();
  System.out.println(""String_Node_Str"");
  System.exit(0);
}"
50228,"public static void printHelp(){
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.exit(0);
}","public static void printHelp(){
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.exit(0);
}"
50229,"/** 
 * @param args
 */
public static void main(String[] args){
  System.out.println(""String_Node_Str"");
  if (args.length < 3) {
    printHelp();
  }
 else   if (args[0] == ""String_Node_Str"") {
    printHelp();
  }
 else {
    System.out.println(""String_Node_Str"");
    MainRunner mr=new MainRunner();
    if (args.length != 3) {
      System.err.println(""String_Node_Str"");
      printHelp();
    }
    if (args[0].compareTo(""String_Node_Str"") == 0 || args[0].compareTo(""String_Node_Str"") == 0) {
      mr.taxonomyLoadParser(args);
    }
 else     if (args[0].compareTo(""String_Node_Str"") == 0) {
      mr.taxonomyQueryParser(args);
    }
 else     if (args[0].compareTo(""String_Node_Str"") == 0) {
      mr.graphImporterParser(args);
    }
  }
}","/** 
 * @param args
 */
public static void main(String[] args){
  System.out.println(""String_Node_Str"");
  if (args.length < 3) {
    printHelp();
  }
 else   if (args[0] == ""String_Node_Str"") {
    printHelp();
  }
 else {
    System.out.println(""String_Node_Str"");
    MainRunner mr=new MainRunner();
    if (args.length != 3) {
      System.err.println(""String_Node_Str"");
      printHelp();
    }
    if (args[0].compareTo(""String_Node_Str"") == 0 || args[0].compareTo(""String_Node_Str"") == 0) {
      mr.taxonomyLoadParser(args);
    }
 else     if (args[0].compareTo(""String_Node_Str"") == 0) {
      mr.taxonomyQueryParser(args);
    }
 else     if (args[0].compareTo(""String_Node_Str"") == 0 || args[0].compareTo(""String_Node_Str"") == 0) {
      mr.graphImporterParser(args);
    }
  }
}"
50230,"public void graphImporterParser(String[] args){
  String filename=args[1];
  String graphname=args[2];
  GraphImporter gi=new GraphImporter(graphname);
  if (args[0].compareTo(""String_Node_Str"") == 0) {
    System.out.println(""String_Node_Str"" + filename);
    gi.preProcessTree(filename);
  }
 else {
    System.err.println(""String_Node_Str"");
    gi.shutdownDB();
    printHelp();
  }
  gi.shutdownDB();
}","public void graphImporterParser(String[] args){
  String filename=args[1];
  String graphname=args[2];
  GraphImporter gi=new GraphImporter(graphname);
  if (args[0].compareTo(""String_Node_Str"") == 0) {
    System.out.println(""String_Node_Str"" + filename);
    gi.preProcessTree(filename);
    gi.processMRCAS();
  }
 else   if (args[0].compareTo(""String_Node_Str"") == 0) {
    System.out.println(""String_Node_Str"" + filename);
    gi.preProcessTree(filename);
    gi.initializeGraphDB();
  }
 else {
    System.err.println(""String_Node_Str"");
    gi.shutdownDB();
    printHelp();
  }
  gi.shutdownDB();
}"
50231,"public void buildTaxonomyTree(String name){
  IndexHits<Node> hits=nodeIndex.get(""String_Node_Str"",name);
  Node firstNode=hits.getSingle();
  hits.close();
  if (firstNode == null) {
    System.out.println(""String_Node_Str"");
    return;
  }
  TraversalDescription CHILDOF_TRAVERSAL=Traversal.description().relationships(RelTypes.CHILDOF,Direction.INCOMING);
  System.out.println(firstNode.getProperty(""String_Node_Str""));
  JadeNode root=new JadeNode();
  root.setName(((String)firstNode.getProperty(""String_Node_Str"")).replace(""String_Node_Str"",""String_Node_Str""));
  HashMap<Node,JadeNode> nodes=new HashMap<Node,JadeNode>();
  nodes.put(firstNode,root);
  int count=0;
  for (  Relationship friendrel : CHILDOF_TRAVERSAL.traverse(firstNode).relationships()) {
    count+=1;
    if (nodes.containsKey(friendrel.getStartNode()) == false) {
      JadeNode node=new JadeNode();
      node.setName(((String)friendrel.getStartNode().getProperty(""String_Node_Str"")).replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
      nodes.put(friendrel.getStartNode(),node);
    }
    if (nodes.containsKey(friendrel.getEndNode()) == false) {
      JadeNode node=new JadeNode();
      node.setName(((String)friendrel.getEndNode().getProperty(""String_Node_Str"")).replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
      nodes.put(friendrel.getEndNode(),node);
    }
    nodes.get(friendrel.getEndNode()).addChild(nodes.get(friendrel.getStartNode()));
    if (count % 100000 == 0)     System.out.println(count);
  }
  JadeTree tree=new JadeTree(root);
  PrintWriter outFile;
  try {
    outFile=new PrintWriter(new FileWriter(""String_Node_Str""));
    outFile.write(tree.getRoot().getNewick(false));
    outFile.write(""String_Node_Str"");
    outFile.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}","public void buildTaxonomyTree(String name){
  IndexHits<Node> hits=nodeIndex.get(""String_Node_Str"",name);
  Node firstNode=hits.getSingle();
  hits.close();
  if (firstNode == null) {
    System.out.println(""String_Node_Str"");
    return;
  }
  TraversalDescription CHILDOF_TRAVERSAL=Traversal.description().relationships(RelTypes.TAXCHILDOF,Direction.INCOMING);
  System.out.println(firstNode.getProperty(""String_Node_Str""));
  JadeNode root=new JadeNode();
  root.setName(((String)firstNode.getProperty(""String_Node_Str"")).replace(""String_Node_Str"",""String_Node_Str""));
  HashMap<Node,JadeNode> nodes=new HashMap<Node,JadeNode>();
  nodes.put(firstNode,root);
  int count=0;
  for (  Relationship friendrel : CHILDOF_TRAVERSAL.traverse(firstNode).relationships()) {
    count+=1;
    if (nodes.containsKey(friendrel.getStartNode()) == false) {
      JadeNode node=new JadeNode();
      node.setName(((String)friendrel.getStartNode().getProperty(""String_Node_Str"")).replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
      nodes.put(friendrel.getStartNode(),node);
    }
    if (nodes.containsKey(friendrel.getEndNode()) == false) {
      JadeNode node=new JadeNode();
      node.setName(((String)friendrel.getEndNode().getProperty(""String_Node_Str"")).replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str""));
      nodes.put(friendrel.getEndNode(),node);
    }
    nodes.get(friendrel.getEndNode()).addChild(nodes.get(friendrel.getStartNode()));
    if (count % 100000 == 0)     System.out.println(count);
  }
  JadeTree tree=new JadeTree(root);
  PrintWriter outFile;
  try {
    outFile=new PrintWriter(new FileWriter(""String_Node_Str""));
    outFile.write(tree.getRoot().getNewick(false));
    outFile.write(""String_Node_Str"");
    outFile.close();
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
}"
50232,"public void addAdditionalTaxonomyTableIntoGraph(String filename){
  String str=""String_Node_Str"";
  int count=0;
  HashMap<String,String> ndnames=new HashMap<String,String>();
  HashMap<String,String> parents=new HashMap<String,String>();
  Transaction tx;
  ArrayList<String> addnodes=new ArrayList<String>();
  try {
    BufferedReader br=new BufferedReader(new FileReader(filename));
    while ((str=br.readLine()) != null) {
      count+=1;
      String[] spls=str.split(""String_Node_Str"");
      parents.put(spls[0],spls[1]);
      String strname=spls[2];
      ndnames.put(spls[0],strname);
      IndexHits<Node> ih=nodeIndex.get(""String_Node_Str"",strname);
      try {
        if (ih.size() == 0) {
          addnodes.add(strname);
        }
      }
  finally {
        ih.close();
      }
      if (count % transaction_iter == 0) {
        System.out.print(count);
        System.out.print(""String_Node_Str"");
        System.out.print(addnodes.size());
        System.out.print(""String_Node_Str"");
        tx=graphDb.beginTx();
        try {
          for (int i=0; i < addnodes.size(); i++) {
            Node tnode=graphDb.createNode();
            tnode.setProperty(""String_Node_Str"",addnodes.get(i));
            nodeIndex.add(tnode,""String_Node_Str"",addnodes.get(i));
          }
          addnodes.clear();
          tx.success();
        }
  finally {
          tx.finish();
        }
      }
    }
    br.close();
  }
 catch (  IOException ioe) {
  }
  tx=graphDb.beginTx();
  try {
    for (int i=0; i < addnodes.size(); i++) {
      Node tnode=graphDb.createNode();
      tnode.setProperty(""String_Node_Str"",addnodes.get(i));
      nodeIndex.add(tnode,""String_Node_Str"",addnodes.get(i));
    }
    addnodes.clear();
    tx.success();
  }
  finally {
    tx.finish();
  }
  System.out.println(""String_Node_Str"");
  ArrayList<Node> rel_nd=new ArrayList<Node>();
  ArrayList<Node> rel_pnd=new ArrayList<Node>();
  ArrayList<String> rel_cid=new ArrayList<String>();
  ArrayList<String> rel_pid=new ArrayList<String>();
  try {
    count=0;
    BufferedReader br=new BufferedReader(new FileReader(filename));
    boolean verbose=false;
    while ((str=br.readLine()) != null) {
      count+=1;
      String[] spls=str.split(""String_Node_Str"");
      String strname=spls[2];
      String strparentname=""String_Node_Str"";
      if (spls[1].compareTo(""String_Node_Str"") != 0)       strparentname=ndnames.get(spls[1]);
      if (spls[1].compareTo(""String_Node_Str"") == 0)       continue;
      if (verbose)       System.out.println(str);
      ArrayList<String> path1=new ArrayList<String>();
      boolean going=true;
      boolean badpath=false;
      String cur=parents.get(spls[0]);
      if (verbose)       System.out.println(""String_Node_Str"" + cur);
      while (going == true) {
        if (cur == null) {
          going=false;
          badpath=true;
        }
 else         if (cur.compareTo(""String_Node_Str"") == 0) {
          going=false;
        }
 else {
          if (verbose)           System.out.println(""String_Node_Str"" + cur);
          path1.add(ndnames.get(cur));
          cur=parents.get(cur);
        }
      }
      if (badpath == true)       continue;
      Node matchnode=null;
      HashMap<Node,ArrayList<Integer>> itemcounts=new HashMap<Node,ArrayList<Integer>>();
      int bestcount=LARGE + LARGE;
      Node bestitem=null;
      ArrayList<String> bestpath=null;
      ArrayList<Node> bestpathitems=null;
      IndexHits<Node> hits=nodeIndex.get(""String_Node_Str"",strname);
      ArrayList<String> path2=null;
      ArrayList<Node> path2items=null;
      boolean first=true;
      try {
        for (        Node node : hits) {
          path2=new ArrayList<String>();
          path2items=new ArrayList<Node>();
          for (          Node currentNode : CHILDOF_TRAVERSAL.traverse(node).nodes()) {
            if (verbose)             System.out.println(""String_Node_Str"" + ((String)currentNode.getProperty(""String_Node_Str"")));
            if (((String)currentNode.getProperty(""String_Node_Str"")).compareTo(strname) != 0) {
              path2.add((String)currentNode.getProperty(""String_Node_Str""));
              path2items.add(currentNode);
              if (verbose)               System.out.println((String)currentNode.getProperty(""String_Node_Str""));
            }
          }
          itemcounts.put(node,stepsToMatch(path1,path2));
          if (verbose)           System.out.println(sum(itemcounts.get(node)));
          if (sum(itemcounts.get(node)) < bestcount || first == true) {
            first=false;
            bestcount=sum(itemcounts.get(node));
            bestitem=node;
            bestpath=new ArrayList<String>(path2);
            bestpathitems=new ArrayList<Node>(path2items);
          }
          path2.clear();
          path2items.clear();
          if (verbose)           System.out.println(bestcount);
          if (verbose)           System.out.println(""String_Node_Str"" + bestpath.get(1));
        }
      }
  finally {
        hits.close();
      }
      itemcounts.clear();
      matchnode=bestitem;
      if (spls[1].compareTo(""String_Node_Str"") != 0) {
        Node matchnodeparent=null;
        for (int i=0; i < bestpath.size(); i++) {
          if (bestpath.get(i).compareTo(strparentname) == 0) {
            matchnodeparent=bestpathitems.get(i);
          }
          if (verbose)           System.out.println(""String_Node_Str"" + bestpath.get(i) + ""String_Node_Str""+ strparentname);
        }
        if (matchnodeparent == null) {
          IndexHits<Node> hits2=nodeIndex.get(""String_Node_Str"",strparentname);
          try {
            for (            Node node2 : hits2) {
              matchnodeparent=node2;
            }
          }
  finally {
            hits2.close();
          }
        }
        rel_nd.add(matchnode);
        rel_pnd.add(matchnodeparent);
        rel_cid.add(spls[0]);
        rel_pid.add(spls[1]);
      }
      if (count % transaction_iter == 0) {
        System.out.println(count);
        tx=graphDb.beginTx();
        try {
          for (int i=0; i < rel_nd.size(); i++) {
            Relationship rel=rel_nd.get(i).createRelationshipTo(rel_pnd.get(i),RelTypes.CHILDOF);
            rel.setProperty(""String_Node_Str"",filename);
            rel.setProperty(""String_Node_Str"",rel_cid.get(i));
            rel.setProperty(""String_Node_Str"",rel_pid.get(i));
          }
          rel_nd.clear();
          rel_pnd.clear();
          rel_cid.clear();
          rel_pid.clear();
          tx.success();
        }
  finally {
          tx.finish();
        }
      }
      path1.clear();
    }
    tx=graphDb.beginTx();
    try {
      for (int i=0; i < rel_nd.size(); i++) {
        Relationship rel=rel_nd.get(i).createRelationshipTo(rel_pnd.get(i),RelTypes.CHILDOF);
        rel.setProperty(""String_Node_Str"",filename);
        rel.setProperty(""String_Node_Str"",rel_cid.get(i));
        rel.setProperty(""String_Node_Str"",rel_pid.get(i));
      }
      rel_nd.clear();
      rel_pnd.clear();
      rel_cid.clear();
      rel_pid.clear();
      tx.success();
    }
  finally {
      tx.finish();
    }
    br.close();
  }
 catch (  IOException ioe) {
  }
}","public void addAdditionalTaxonomyTableIntoGraph(String filename){
  String str=""String_Node_Str"";
  int count=0;
  HashMap<String,String> ndnames=new HashMap<String,String>();
  HashMap<String,String> parents=new HashMap<String,String>();
  Transaction tx;
  ArrayList<String> addnodes=new ArrayList<String>();
  try {
    BufferedReader br=new BufferedReader(new FileReader(filename));
    while ((str=br.readLine()) != null) {
      count+=1;
      String[] spls=str.split(""String_Node_Str"");
      parents.put(spls[0],spls[1]);
      String strname=spls[2];
      ndnames.put(spls[0],strname);
      IndexHits<Node> ih=nodeIndex.get(""String_Node_Str"",strname);
      try {
        if (ih.size() == 0) {
          addnodes.add(strname);
        }
      }
  finally {
        ih.close();
      }
      if (count % transaction_iter == 0) {
        System.out.print(count);
        System.out.print(""String_Node_Str"");
        System.out.print(addnodes.size());
        System.out.print(""String_Node_Str"");
        tx=graphDb.beginTx();
        try {
          for (int i=0; i < addnodes.size(); i++) {
            Node tnode=graphDb.createNode();
            tnode.setProperty(""String_Node_Str"",addnodes.get(i));
            nodeIndex.add(tnode,""String_Node_Str"",addnodes.get(i));
          }
          addnodes.clear();
          tx.success();
        }
  finally {
          tx.finish();
        }
      }
    }
    br.close();
  }
 catch (  IOException ioe) {
  }
  tx=graphDb.beginTx();
  try {
    for (int i=0; i < addnodes.size(); i++) {
      Node tnode=graphDb.createNode();
      tnode.setProperty(""String_Node_Str"",addnodes.get(i));
      nodeIndex.add(tnode,""String_Node_Str"",addnodes.get(i));
    }
    addnodes.clear();
    tx.success();
  }
  finally {
    tx.finish();
  }
  System.out.println(""String_Node_Str"");
  ArrayList<Node> rel_nd=new ArrayList<Node>();
  ArrayList<Node> rel_pnd=new ArrayList<Node>();
  ArrayList<String> rel_cid=new ArrayList<String>();
  ArrayList<String> rel_pid=new ArrayList<String>();
  try {
    count=0;
    BufferedReader br=new BufferedReader(new FileReader(filename));
    boolean verbose=false;
    while ((str=br.readLine()) != null) {
      count+=1;
      String[] spls=str.split(""String_Node_Str"");
      String strname=spls[2];
      String strparentname=""String_Node_Str"";
      if (spls[1].compareTo(""String_Node_Str"") != 0)       strparentname=ndnames.get(spls[1]);
      if (spls[1].compareTo(""String_Node_Str"") == 0)       continue;
      if (verbose)       System.out.println(str);
      ArrayList<String> path1=new ArrayList<String>();
      boolean going=true;
      boolean badpath=false;
      String cur=parents.get(spls[0]);
      if (verbose)       System.out.println(""String_Node_Str"" + cur);
      while (going == true) {
        if (cur == null) {
          going=false;
          badpath=true;
          System.out.println(""String_Node_Str"" + spls[0]);
        }
 else         if (cur.compareTo(""String_Node_Str"") == 0) {
          going=false;
        }
 else {
          if (verbose)           System.out.println(""String_Node_Str"" + cur);
          path1.add(ndnames.get(cur));
          cur=parents.get(cur);
        }
      }
      if (badpath == true)       continue;
      Node matchnode=null;
      HashMap<Node,ArrayList<Integer>> itemcounts=new HashMap<Node,ArrayList<Integer>>();
      int bestcount=LARGE + LARGE;
      Node bestitem=null;
      ArrayList<String> bestpath=null;
      ArrayList<Node> bestpathitems=null;
      IndexHits<Node> hits=nodeIndex.get(""String_Node_Str"",strname);
      ArrayList<String> path2=null;
      ArrayList<Node> path2items=null;
      boolean first=true;
      try {
        for (        Node node : hits) {
          path2=new ArrayList<String>();
          path2items=new ArrayList<Node>();
          for (          Node currentNode : CHILDOF_TRAVERSAL.traverse(node).nodes()) {
            if (verbose)             System.out.println(""String_Node_Str"" + ((String)currentNode.getProperty(""String_Node_Str"")));
            if (((String)currentNode.getProperty(""String_Node_Str"")).compareTo(strname) != 0) {
              path2.add((String)currentNode.getProperty(""String_Node_Str""));
              path2items.add(currentNode);
              if (verbose)               System.out.println((String)currentNode.getProperty(""String_Node_Str""));
            }
          }
          itemcounts.put(node,stepsToMatch(path1,path2));
          if (verbose)           System.out.println(sum(itemcounts.get(node)));
          if (sum(itemcounts.get(node)) < bestcount || first == true) {
            first=false;
            bestcount=sum(itemcounts.get(node));
            bestitem=node;
            bestpath=new ArrayList<String>(path2);
            bestpathitems=new ArrayList<Node>(path2items);
          }
          path2.clear();
          path2items.clear();
          if (verbose)           System.out.println(bestcount);
          if (verbose)           System.out.println(""String_Node_Str"" + bestpath.get(1));
        }
      }
  finally {
        hits.close();
      }
      itemcounts.clear();
      matchnode=bestitem;
      if (spls[1].compareTo(""String_Node_Str"") != 0) {
        Node matchnodeparent=null;
        for (int i=0; i < bestpath.size(); i++) {
          if (bestpath.get(i).compareTo(strparentname) == 0) {
            matchnodeparent=bestpathitems.get(i);
          }
          if (verbose)           System.out.println(""String_Node_Str"" + bestpath.get(i) + ""String_Node_Str""+ strparentname);
        }
        if (matchnodeparent == null) {
          IndexHits<Node> hits2=nodeIndex.get(""String_Node_Str"",strparentname);
          try {
            for (            Node node2 : hits2) {
              matchnodeparent=node2;
            }
          }
  finally {
            hits2.close();
          }
        }
        rel_nd.add(matchnode);
        rel_pnd.add(matchnodeparent);
        rel_cid.add(spls[0]);
        rel_pid.add(spls[1]);
      }
      if (count % transaction_iter == 0) {
        System.out.println(count);
        tx=graphDb.beginTx();
        try {
          for (int i=0; i < rel_nd.size(); i++) {
            Relationship rel=rel_nd.get(i).createRelationshipTo(rel_pnd.get(i),RelTypes.TAXCHILDOF);
            rel.setProperty(""String_Node_Str"",filename);
            rel.setProperty(""String_Node_Str"",rel_cid.get(i));
            rel.setProperty(""String_Node_Str"",rel_pid.get(i));
          }
          rel_nd.clear();
          rel_pnd.clear();
          rel_cid.clear();
          rel_pid.clear();
          tx.success();
        }
  finally {
          tx.finish();
        }
      }
      path1.clear();
    }
    tx=graphDb.beginTx();
    try {
      for (int i=0; i < rel_nd.size(); i++) {
        Relationship rel=rel_nd.get(i).createRelationshipTo(rel_pnd.get(i),RelTypes.TAXCHILDOF);
        rel.setProperty(""String_Node_Str"",filename);
        rel.setProperty(""String_Node_Str"",rel_cid.get(i));
        rel.setProperty(""String_Node_Str"",rel_pid.get(i));
      }
      rel_nd.clear();
      rel_pnd.clear();
      rel_cid.clear();
      rel_pid.clear();
      tx.success();
    }
  finally {
      tx.finish();
    }
    br.close();
  }
 catch (  IOException ioe) {
  }
}"
50233,"public void addInitialTaxonomyTableIntoGraph(String filename){
  String str=""String_Node_Str"";
  int count=0;
  HashMap<String,Node> dbnodes=new HashMap<String,Node>();
  HashMap<String,String> parents=new HashMap<String,String>();
  Transaction tx;
  ArrayList<String> templines=new ArrayList<String>();
  try {
    tx=graphDb.beginTx();
    try {
      Node node=graphDb.createNode();
      node.setProperty(""String_Node_Str"",""String_Node_Str"");
      nodeIndex.add(node,""String_Node_Str"",""String_Node_Str"");
      dbnodes.put(""String_Node_Str"",node);
      tx.success();
    }
  finally {
      tx.finish();
    }
    BufferedReader br=new BufferedReader(new FileReader(filename));
    while ((str=br.readLine()) != null) {
      count+=1;
      templines.add(str);
      if (count % transaction_iter == 0) {
        System.out.print(count);
        System.out.print(""String_Node_Str"");
        tx=graphDb.beginTx();
        try {
          for (int i=0; i < templines.size(); i++) {
            String[] spls=templines.get(i).split(""String_Node_Str"");
            if (spls[1].length() > 0) {
              Node tnode=graphDb.createNode();
              tnode.setProperty(""String_Node_Str"",spls[2]);
              nodeIndex.add(tnode,""String_Node_Str"",spls[2]);
              parents.put(spls[0],spls[1]);
              dbnodes.put(spls[0],tnode);
            }
          }
          tx.success();
        }
  finally {
          tx.finish();
        }
        templines.clear();
      }
    }
    br.close();
    tx=graphDb.beginTx();
    try {
      for (int i=0; i < templines.size(); i++) {
        String[] spls=templines.get(i).split(""String_Node_Str"");
        count+=1;
        if (spls[1].length() > 0) {
          Node tnode=graphDb.createNode();
          tnode.setProperty(""String_Node_Str"",spls[2]);
          nodeIndex.add(tnode,""String_Node_Str"",spls[2]);
          parents.put(spls[0],spls[1]);
          dbnodes.put(spls[0],tnode);
        }
      }
      tx.success();
    }
  finally {
      tx.finish();
    }
    templines.clear();
    ArrayList<String> temppar=new ArrayList<String>();
    count=0;
    for (    String key : dbnodes.keySet()) {
      count+=1;
      temppar.add(key);
      if (count % transaction_iter == 0) {
        System.out.println(count);
        tx=graphDb.beginTx();
        try {
          for (int i=0; i < temppar.size(); i++) {
            try {
              Relationship rel=dbnodes.get(temppar.get(i)).createRelationshipTo(dbnodes.get(parents.get(temppar.get(i))),RelTypes.CHILDOF);
              rel.setProperty(""String_Node_Str"",filename);
              rel.setProperty(""String_Node_Str"",temppar.get(i));
              rel.setProperty(""String_Node_Str"",parents.get(temppar.get(i)));
            }
 catch (            java.lang.IllegalArgumentException io) {
              continue;
            }
          }
          tx.success();
        }
  finally {
          tx.finish();
        }
        temppar.clear();
      }
    }
    tx=graphDb.beginTx();
    try {
      for (int i=0; i < temppar.size(); i++) {
        try {
          Relationship rel=dbnodes.get(temppar.get(i)).createRelationshipTo(dbnodes.get(parents.get(temppar.get(i))),RelTypes.CHILDOF);
          rel.setProperty(""String_Node_Str"",filename);
          rel.setProperty(""String_Node_Str"",temppar.get(i));
          rel.setProperty(""String_Node_Str"",parents.get(temppar.get(i)));
        }
 catch (        java.lang.IllegalArgumentException io) {
          continue;
        }
      }
      tx.success();
    }
  finally {
      tx.finish();
    }
  }
 catch (  IOException ioe) {
  }
}","public void addInitialTaxonomyTableIntoGraph(String filename){
  String str=""String_Node_Str"";
  int count=0;
  HashMap<String,Node> dbnodes=new HashMap<String,Node>();
  HashMap<String,String> parents=new HashMap<String,String>();
  Transaction tx;
  ArrayList<String> templines=new ArrayList<String>();
  try {
    tx=graphDb.beginTx();
    try {
      Node node=graphDb.createNode();
      node.setProperty(""String_Node_Str"",""String_Node_Str"");
      nodeIndex.add(node,""String_Node_Str"",""String_Node_Str"");
      dbnodes.put(""String_Node_Str"",node);
      tx.success();
    }
  finally {
      tx.finish();
    }
    BufferedReader br=new BufferedReader(new FileReader(filename));
    while ((str=br.readLine()) != null) {
      count+=1;
      templines.add(str);
      if (count % transaction_iter == 0) {
        System.out.print(count);
        System.out.print(""String_Node_Str"");
        tx=graphDb.beginTx();
        try {
          for (int i=0; i < templines.size(); i++) {
            String[] spls=templines.get(i).split(""String_Node_Str"");
            if (spls[1].length() > 0) {
              Node tnode=graphDb.createNode();
              tnode.setProperty(""String_Node_Str"",spls[2]);
              nodeIndex.add(tnode,""String_Node_Str"",spls[2]);
              parents.put(spls[0],spls[1]);
              dbnodes.put(spls[0],tnode);
            }
          }
          tx.success();
        }
  finally {
          tx.finish();
        }
        templines.clear();
      }
    }
    br.close();
    tx=graphDb.beginTx();
    try {
      for (int i=0; i < templines.size(); i++) {
        String[] spls=templines.get(i).split(""String_Node_Str"");
        count+=1;
        if (spls[1].length() > 0) {
          Node tnode=graphDb.createNode();
          tnode.setProperty(""String_Node_Str"",spls[2]);
          nodeIndex.add(tnode,""String_Node_Str"",spls[2]);
          parents.put(spls[0],spls[1]);
          dbnodes.put(spls[0],tnode);
        }
      }
      tx.success();
    }
  finally {
      tx.finish();
    }
    templines.clear();
    ArrayList<String> temppar=new ArrayList<String>();
    count=0;
    for (    String key : dbnodes.keySet()) {
      count+=1;
      temppar.add(key);
      if (count % transaction_iter == 0) {
        System.out.println(count);
        tx=graphDb.beginTx();
        try {
          for (int i=0; i < temppar.size(); i++) {
            try {
              Relationship rel=dbnodes.get(temppar.get(i)).createRelationshipTo(dbnodes.get(parents.get(temppar.get(i))),RelTypes.TAXCHILDOF);
              rel.setProperty(""String_Node_Str"",filename);
              rel.setProperty(""String_Node_Str"",temppar.get(i));
              rel.setProperty(""String_Node_Str"",parents.get(temppar.get(i)));
            }
 catch (            java.lang.IllegalArgumentException io) {
              continue;
            }
          }
          tx.success();
        }
  finally {
          tx.finish();
        }
        temppar.clear();
      }
    }
    tx=graphDb.beginTx();
    try {
      for (int i=0; i < temppar.size(); i++) {
        try {
          Relationship rel=dbnodes.get(temppar.get(i)).createRelationshipTo(dbnodes.get(parents.get(temppar.get(i))),RelTypes.TAXCHILDOF);
          rel.setProperty(""String_Node_Str"",filename);
          rel.setProperty(""String_Node_Str"",temppar.get(i));
          rel.setProperty(""String_Node_Str"",parents.get(temppar.get(i)));
        }
 catch (        java.lang.IllegalArgumentException io) {
          continue;
        }
      }
      tx.success();
    }
  finally {
      tx.finish();
    }
  }
 catch (  IOException ioe) {
  }
}"
50234,"/** 
 * Main method.
 * @param args command line args.
 * @throws com.martiansoftware.jsap.JSAPException error parsing
 * @throws java.io.IOException error parsing or executing.
 */
public static void main(final String[] args) throws JSAPException, IOException {
  new SuggestPositionSlicesMode().configure(args).execute();
}","/** 
 * Main method.
 * @param args command line args.
 * @throws com.martiansoftware.jsap.JSAPException error parsing
 * @throws java.io.IOException                    error parsing or executing.
 */
public static void main(final String[] args) throws JSAPException, IOException {
  new SuggestPositionSlicesMode().configure(args).execute();
}"
50235,"/** 
 * Configure.
 * @param args command line arguments
 * @return this object for chaining
 * @throws java.io.IOException error parsing
 * @throws com.martiansoftware.jsap.JSAPException error parsing
 */
@Override public AbstractCommandLineMode configure(final String[] args) throws IOException, JSAPException {
  final JSAPResult jsapResult=parseJsapArguments(args);
  final String[] inputFiles=jsapResult.getStringArray(""String_Node_Str"");
  basenames=AlignmentReaderImpl.getBasenames(inputFiles);
  annotationFilename=jsapResult.getString(""String_Node_Str"");
  outputFilename=jsapResult.getString(""String_Node_Str"");
  modulo=jsapResult.getInt(""String_Node_Str"");
  numberOfSlices=jsapResult.getInt(""String_Node_Str"");
  numBytesPerSlice=jsapResult.getInt(""String_Node_Str"");
  if (!(jsapResult.userSpecified(""String_Node_Str"") || jsapResult.userSpecified(""String_Node_Str""))) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  restrictPerChromosome=jsapResult.getBoolean(""String_Node_Str"");
  if (jsapResult.userSpecified(""String_Node_Str"") && jsapResult.userSpecified(""String_Node_Str"")) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  useModulo=jsapResult.userSpecified(""String_Node_Str"");
  if (!useModulo)   System.err.println(""String_Node_Str"" + numBytesPerSlice);
  return this;
}","/** 
 * Configure.
 * @param args command line arguments
 * @return this object for chaining
 * @throws java.io.IOException                    error parsing
 * @throws com.martiansoftware.jsap.JSAPException error parsing
 */
@Override public AbstractCommandLineMode configure(final String[] args) throws IOException, JSAPException {
  final JSAPResult jsapResult=parseJsapArguments(args);
  final String[] inputFiles=jsapResult.getStringArray(""String_Node_Str"");
  basenames=AlignmentReaderImpl.getBasenames(inputFiles);
  annotationFilename=jsapResult.getString(""String_Node_Str"");
  outputFilename=jsapResult.getString(""String_Node_Str"");
  modulo=jsapResult.getInt(""String_Node_Str"");
  numberOfSlices=jsapResult.getInt(""String_Node_Str"");
  numBytesPerSlice=jsapResult.getInt(""String_Node_Str"");
  if (!(jsapResult.userSpecified(""String_Node_Str"") || jsapResult.userSpecified(""String_Node_Str""))) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  restrictPerChromosome=jsapResult.getBoolean(""String_Node_Str"");
  if (jsapResult.userSpecified(""String_Node_Str"") && jsapResult.userSpecified(""String_Node_Str"")) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  useModulo=jsapResult.userSpecified(""String_Node_Str"");
  if (!useModulo)   System.err.println(""String_Node_Str"" + numBytesPerSlice);
  return this;
}"
50236,"/** 
 * Suggests slices to process a large alignment file in parallel.
 * @throws java.io.IOException error reading / writing
 */
@Override public void execute() throws IOException {
  PrintStream stream=null;
  try {
    stream=outputFilename == null ? System.out : new PrintStream(new FileOutputStream(outputFilename));
    ConcatSortedAlignmentReader input=new ConcatSortedAlignmentReader(basenames);
    input.readHeader();
    DoubleIndexedIdentifier ids=new DoubleIndexedIdentifier(input.getTargetIdentifiers());
    Ranges ranges=null;
    if (annotationFilename != null) {
      ranges=convertAnnotationsToRanges(annotationFilename,ids,input);
    }
    ReferenceLocation[] breakpoints=useModulo ? getReferenceLocationsWithModulo(stream,input,ids) : getReferenceLocationsWithBytes(stream,input,ids);
    if (ranges != null) {
      adjustBreakpointsWithAnnotations(breakpoints,ranges);
    }
    if (restrictPerChromosome) {
      breakpoints=restrictPerChromosome(breakpoints,input);
    }
    for (int i=0; i < breakpoints.length - 1; i++) {
      if (!restrictPerChromosome || (restrictPerChromosome && breakpoints[i].targetIndex == breakpoints[i + 1].targetIndex))       stream.printf(String.format(""String_Node_Str"",ids.getId(breakpoints[i].targetIndex),breakpoints[i].position,ids.getId(breakpoints[i].targetIndex),breakpoints[i].position,ids.getId(breakpoints[i + 1].targetIndex),breakpoints[i + 1].position,ids.getId(breakpoints[i + 1].targetIndex),breakpoints[i + 1].position));
    }
  }
  finally {
    if (stream != System.out) {
      IOUtils.closeQuietly(stream);
    }
  }
}","/** 
 * Suggests slices to process a large alignment file in parallel.
 * @throws java.io.IOException error reading / writing
 */
@Override public void execute() throws IOException {
  PrintStream stream=null;
  try {
    stream=outputFilename == null ? System.out : new PrintStream(new FileOutputStream(outputFilename));
    ConcatSortedAlignmentReader input=new ConcatSortedAlignmentReader(basenames);
    input.readHeader();
    DoubleIndexedIdentifier ids=new DoubleIndexedIdentifier(input.getTargetIdentifiers());
    Ranges ranges=null;
    if (annotationFilename != null) {
      ranges=convertAnnotationsToRanges(annotationFilename,ids,input);
    }
    ReferenceLocation[] breakpoints=useModulo ? getReferenceLocationsWithModulo(stream,input,ids) : getReferenceLocationsWithBytes(stream,input,ids);
    if (ranges != null) {
      adjustBreakpointsWithAnnotations(breakpoints,ranges);
    }
    breakpoints=removeDuplicates(breakpoints);
    if (restrictPerChromosome) {
      breakpoints=restrictPerChromosome(breakpoints,input);
    }
    assertPostcondition(breakpoints);
    for (int i=0; i < breakpoints.length - 1; i++) {
      final int startTargetIndex=breakpoints[i].targetIndex;
      final int endTargetIndex=breakpoints[i + 1].targetIndex;
      final int startPosition=breakpoints[i].position;
      final int endPosition=breakpoints[i + 1].position;
      if (!restrictPerChromosome || (restrictPerChromosome && startTargetIndex == endTargetIndex)) {
        stream.printf(String.format(""String_Node_Str"",ids.getId(startTargetIndex),startPosition,ids.getId(startTargetIndex),startPosition,ids.getId(endTargetIndex),endPosition,ids.getId(endTargetIndex),endPosition));
      }
    }
  }
  finally {
    if (stream != System.out) {
      IOUtils.closeQuietly(stream);
    }
    System.out.println(""String_Node_Str"");
  }
}"
50237,"private void recordNumAlignedReads(String[] inputFilenames){
  numMatchedReads=new int[samples.length];
  String[] sampleIds=AlignmentReaderImpl.getBasenames(inputFilenames);
  for (int i=0; i < sampleIds.length; i++) {
    sampleIds[i]=FilenameUtils.getName(sampleIds[i]);
    if (sampleIds[i].equals(samples[i])) {
      numMatchedReads[i]=Math.min(1,getNumMatchedReads(inputFilenames[i]));
    }
  }
}","private void recordNumAlignedReads(String[] inputFilenames){
  numMatchedReads=new int[samples.length];
  String[] sampleIds=AlignmentReaderImpl.getBasenames(inputFilenames);
  for (int i=0; i < sampleIds.length; i++) {
    sampleIds[i]=FilenameUtils.getName(sampleIds[i]);
    if (sampleIds[i].equals(samples[i])) {
      numMatchedReads[i]=Math.max(1,getNumMatchedReads(inputFilenames[i]));
    }
  }
}"
50238,"/** 
 * Simply order eir by to string, alphabetically.
 * @param eir1 first indel
 * @param eir2 second indel
 * @return sort order
 */
@Override public int compare(final EquivalentIndelRegion eir1,final EquivalentIndelRegion eir2){
  return eir1.to.compareTo(eir2.to);
}","/** 
 * Simply order eir by to string, alphabetically.
 * @param eir1 first indel
 * @param eir2 second indel
 * @return sort order
 */
public int compare(final EquivalentIndelRegion eir1,final EquivalentIndelRegion eir2){
  return eir1.to.compareTo(eir2.to);
}"
50239,"boolean isPossibleSomaticVariation(SampleCountInfo[] sampleCounts){
}","boolean isPossibleSomaticVariation(SampleCountInfo[] sampleCounts){
  for (  int sampleIndex : somaticSampleIndices) {
    SampleCountInfo somaticCounts=sampleCounts[sampleIndex];
    for (int genotypeIndex=0; genotypeIndex < somaticCounts.getGenotypeMaxIndex(); genotypeIndex++) {
      boolean parentHasGenotype=false;
      boolean strict=true;
      float maxGermlineOrParentsFrequency=0;
      int fatherSampleIndex=sample2FatherSampleIndex[sampleIndex];
      int minGermlineCoverage=Integer.MAX_VALUE;
      if (fatherSampleIndex != -1) {
        SampleCountInfo fatherCounts=sampleCounts[fatherSampleIndex];
        minGermlineCoverage=Math.min(fatherCounts.coverage(),minGermlineCoverage);
        parentHasGenotype|=fatherCounts.getGenotypeCount(genotypeIndex) > fatherCounts.failedCount;
        maxGermlineOrParentsFrequency=Math.max(maxGermlineOrParentsFrequency,fatherCounts.frequency(genotypeIndex));
      }
      int motherSampleIndex=sample2MotherSampleIndex[sampleIndex];
      if (motherSampleIndex != -1) {
        SampleCountInfo motherCounts=sampleCounts[motherSampleIndex];
        minGermlineCoverage=Math.min(motherCounts.coverage(),minGermlineCoverage);
        parentHasGenotype|=motherCounts.getGenotypeCount(genotypeIndex) > motherCounts.failedCount;
        maxGermlineOrParentsFrequency=Math.max(maxGermlineOrParentsFrequency,motherCounts.frequency(genotypeIndex));
      }
      boolean germlineHasPhenotype=false;
      int germlineSampleIndices[]=sample2GermlineSampleIndices[sampleIndex];
      for (      int germlineSampleIndex : germlineSampleIndices) {
        if (germlineSampleIndex != -1) {
          SampleCountInfo germlineCounts=sampleCounts[germlineSampleIndex];
          minGermlineCoverage=Math.min(germlineCounts.coverage(),minGermlineCoverage);
          germlineHasPhenotype|=germlineCounts.getGenotypeCount(genotypeIndex) >= 10;
          maxGermlineOrParentsFrequency=Math.max(maxGermlineOrParentsFrequency,germlineCounts.frequency(genotypeIndex));
        }
      }
      boolean somaticHasGenotype=somaticCounts.getGenotypeCount(genotypeIndex) > 0;
      if (parentHasGenotype || germlineHasPhenotype || !somaticHasGenotype) {
        isSomaticCandidate[sampleIndex][genotypeIndex]=false;
        isStrictSomaticCandidate[sampleIndex][genotypeIndex]=false;
      }
 else {
        int somaticCoverage=sampleCounts[sampleIndex].coverage();
        if (minGermlineCoverage < somaticCoverage / 2) {
          isSomaticCandidate[sampleIndex][genotypeIndex]=false;
        }
 else {
          if (somaticCounts.frequency(genotypeIndex) > 3 * maxGermlineOrParentsFrequency) {
            isSomaticCandidate[sampleIndex][genotypeIndex]=true;
          }
          isStrictSomaticCandidate[sampleIndex][genotypeIndex]=strict && isSomaticCandidate[sampleIndex][genotypeIndex];
        }
      }
    }
  }
  return isSomaticCandidate();
}"
50240,"@Test public void testAdjustStrandBias(){
  StrandBiasFilter adjuster1=new StrandBiasFilter(1);
  SampleCountInfo[] sampleCounts=makeTwoSampleCounts();
  sampleCounts[0].setGenotypeCount(SampleCountInfo.BASE_T_INDEX,1,true);
  sampleCounts[0].setGenotypeCount(SampleCountInfo.BASE_T_INDEX,1,false);
  sampleCounts[0].varCount++;
  assertEquals(5,sampleCounts[0].refCount);
  assertEquals(12,sampleCounts[0].varCount);
  assertEquals(10,sampleCounts[1].refCount);
  assertEquals(6,sampleCounts[1].varCount);
  IntArrayList scores=IntArrayList.wrap(new int[]{10,20,30,40,40,40,40});
  final DiscoverVariantPositionData list=makeListWithScoresStranded(sampleCounts,scores);
  int index=0;
  for (  PositionBaseInfo element : list) {
    if (element.to == 'T' && element.readerIndex == 0) {
      element.matchesForwardStrand=(index++ % 2) == 1;
    }
  }
  assertEquals(33,list.size());
  ObjectSet<PositionBaseInfo> filteredList=new ObjectArraySet<PositionBaseInfo>();
  adjuster1.filterGenotypes(list,sampleCounts,filteredList);
  System.out.println(""String_Node_Str"" + list);
  System.out.println(""String_Node_Str"" + filteredList);
  boolean foundForward=false;
  boolean foundReverse=false;
  for (  PositionBaseInfo element : list) {
    if (element.to == 'T' && element.readerIndex == 0 && element.matchesForwardStrand) {
      foundForward=true;
    }
    if (element.to == 'T' && element.readerIndex == 0 && !element.matchesForwardStrand) {
      foundReverse=true;
    }
  }
  assertTrue(foundForward);
  assertTrue(foundReverse);
  CountFixer fixer=new CountFixer();
  fixer.fix(list,sampleCounts,filteredList);
  for (  PositionBaseInfo element : list) {
    if (element.to == 'T' && element.readerIndex == 1) {
      fail(""String_Node_Str"");
    }
    if (element.to == 'C') {
      fail(""String_Node_Str"");
    }
  }
}","@Test public void testAdjustStrandBias(){
  StrandBiasFilter adjuster1=new StrandBiasFilter(1);
  SampleCountInfo[] sampleCounts=makeTwoSampleCounts();
  sampleCounts[0].setGenotypeCount(SampleCountInfo.BASE_T_INDEX,1,true);
  sampleCounts[0].setGenotypeCount(SampleCountInfo.BASE_T_INDEX,1,false);
  sampleCounts[0].varCount++;
  assertEquals(5,sampleCounts[0].refCount);
  assertEquals(12,sampleCounts[0].varCount);
  assertEquals(10,sampleCounts[1].refCount);
  assertEquals(6,sampleCounts[1].varCount);
  IntArrayList scores=IntArrayList.wrap(new int[]{10,20,30,40,40,40,40});
  final DiscoverVariantPositionData list=makeListWithScoresStranded(sampleCounts,scores);
  int index=0;
  for (  PositionBaseInfo element : list) {
    if (element.to == 'T' && element.readerIndex == 0) {
      element.matchesForwardStrand=(index++ % 2) == 1;
    }
  }
  assertEquals(33,list.size());
  ObjectSet<PositionBaseInfo> filteredList=new ObjectArraySet<PositionBaseInfo>();
  adjuster1.filterGenotypes(list,sampleCounts,filteredList);
  System.out.println(""String_Node_Str"" + list);
  System.out.println(""String_Node_Str"" + filteredList);
  boolean foundForward=false;
  boolean foundReverse=false;
  for (  PositionBaseInfo element : list) {
    if (element.to == 'T' && element.readerIndex == 0 && element.matchesForwardStrand) {
      foundForward=true;
    }
    if (element.to == 'T' && element.readerIndex == 0 && !element.matchesForwardStrand) {
      foundReverse=true;
    }
  }
  assertTrue(foundForward);
  assertTrue(foundReverse);
  CountFixer fixer=new CountFixer();
  fixer.fix(list,sampleCounts,filteredList);
  assertEquals(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",Arrays.toString(sampleCounts));
  for (  PositionBaseInfo element : list) {
    if (element.to == 'T' && element.readerIndex == 1) {
      fail(""String_Node_Str"");
    }
    if (element.to == 'C') {
      fail(""String_Node_Str"");
    }
  }
}"
50241,"private DiscoverVariantPositionData makeListWithScoresStranded(SampleCountInfo[] sampleCounts,IntArrayList qualityScores){
  IntIterator nextQualityIterator=qualityScores.iterator();
  DiscoverVariantPositionData list=new DiscoverVariantPositionData();
  for (  SampleCountInfo sampleInfo : sampleCounts) {
    for (int baseIndex=0; baseIndex < SampleCountInfo.BASE_MAX_INDEX; baseIndex++) {
      for (int i=0; i < sampleInfo.getGenotypeCount(baseIndex,true); i++) {
        PositionBaseInfo info=new PositionBaseInfo();
        nextQualityIterator=makeBase(true,qualityScores,nextQualityIterator,list,sampleInfo,baseIndex,info);
      }
      for (int i=0; i < sampleInfo.getGenotypeCount(baseIndex,false); i++) {
        PositionBaseInfo info=new PositionBaseInfo();
        nextQualityIterator=makeBase(false,qualityScores,nextQualityIterator,list,sampleInfo,baseIndex,info);
      }
    }
  }
  return list;
}","private DiscoverVariantPositionData makeListWithScoresStranded(SampleCountInfo[] sampleCounts,IntArrayList qualityScores){
  IntIterator nextQualityIterator=qualityScores.iterator();
  DiscoverVariantPositionData list=new DiscoverVariantPositionData();
  for (  SampleCountInfo sampleInfo : sampleCounts) {
    for (int baseIndex=0; baseIndex < SampleCountInfo.BASE_MAX_INDEX; baseIndex++) {
      for (int i=0; i < sampleInfo.getGenotypeCount(baseIndex,true); i++) {
        nextQualityIterator=makeBase(true,qualityScores,nextQualityIterator,list,sampleInfo,baseIndex);
      }
      for (int i=0; i < sampleInfo.getGenotypeCount(baseIndex,false); i++) {
        nextQualityIterator=makeBase(false,qualityScores,nextQualityIterator,list,sampleInfo,baseIndex);
      }
    }
  }
  return list;
}"
50242,"private DiscoverVariantPositionData makeListWithScores(SampleCountInfo[] sampleCounts,IntArrayList qualityScores){
  IntIterator nextQualityIterator=qualityScores.iterator();
  DiscoverVariantPositionData list=new DiscoverVariantPositionData();
  for (  SampleCountInfo sampleInfo : sampleCounts) {
    for (int baseIndex=0; baseIndex < SampleCountInfo.BASE_MAX_INDEX; baseIndex++) {
      for (int i=0; i < sampleInfo.getGenotypeCount(baseIndex); i++) {
        PositionBaseInfo info=new PositionBaseInfo();
        nextQualityIterator=makeBase(true,qualityScores,nextQualityIterator,list,sampleInfo,baseIndex,info);
      }
    }
  }
  return list;
}","private DiscoverVariantPositionData makeListWithScores(SampleCountInfo[] sampleCounts,IntArrayList qualityScores){
  IntIterator nextQualityIterator=qualityScores.iterator();
  DiscoverVariantPositionData list=new DiscoverVariantPositionData();
  for (  SampleCountInfo sampleInfo : sampleCounts) {
    for (int baseIndex=0; baseIndex < SampleCountInfo.BASE_MAX_INDEX; baseIndex++) {
      for (int i=0; i < sampleInfo.getGenotypeCount(baseIndex,true); i++) {
        nextQualityIterator=makeBase(true,qualityScores,nextQualityIterator,list,sampleInfo,baseIndex);
      }
    }
  }
  return list;
}"
50243,"@Test public void testAdjustVarCount(){
  QualityScoreFilter adjuster1=new QualityScoreFilter();
  adjuster1.setNoRandomSampling(true);
  LeftOverFilter adjuster2=new LeftOverFilter(0);
  SampleCountInfo[] sampleCounts=makeTwoSampleCounts();
  assertEquals(5,sampleCounts[0].refCount);
  assertEquals(11,sampleCounts[0].varCount);
  assertEquals(10,sampleCounts[1].refCount);
  assertEquals(6,sampleCounts[1].varCount);
  IntArrayList scores=IntArrayList.wrap(new int[]{10,20,30,40,40,40,40});
  final DiscoverVariantPositionData list=makeListWithScores(sampleCounts,scores);
  assertEquals(Arrays.toString(list.elements()),""String_Node_Str"");
  assertEquals(32,list.size());
  ObjectSet<PositionBaseInfo> filteredList=new ObjectArraySet<PositionBaseInfo>();
  adjuster1.filterGenotypes(list,sampleCounts,filteredList);
  adjuster2.filterGenotypes(list,sampleCounts,filteredList);
  System.out.println(""String_Node_Str"" + list);
  System.out.println(""String_Node_Str"" + filteredList);
  CountFixer fixer=new CountFixer();
  fixer.fix(list,sampleCounts,filteredList);
  assertEquals(Arrays.toString(sampleCounts),""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  assertEquals(""String_Node_Str"",filteredList.toString());
  assertEquals(20,filteredList.size());
  assertEquals(0,sampleCounts[0].refCount);
  assertEquals(0,sampleCounts[0].varCount);
  assertEquals(10,sampleCounts[1].refCount);
  assertEquals(6 - 6,sampleCounts[1].varCount);
}","@Test public void testAdjustVarCount(){
  QualityScoreFilter adjuster1=new QualityScoreFilter();
  adjuster1.setNoRandomSampling(true);
  LeftOverFilter adjuster2=new LeftOverFilter(0);
  SampleCountInfo[] sampleCounts=makeTwoSampleCounts();
  assertEquals(5,sampleCounts[0].refCount);
  assertEquals(11,sampleCounts[0].varCount);
  assertEquals(10,sampleCounts[1].refCount);
  assertEquals(6,sampleCounts[1].varCount);
  IntArrayList scores=IntArrayList.wrap(new int[]{10,20,30,40,40,40,40});
  final DiscoverVariantPositionData list=makeListWithScores(sampleCounts,scores);
  assertEquals(32,list.size());
  ObjectSet<PositionBaseInfo> filteredList=new ObjectArraySet<PositionBaseInfo>();
  adjuster1.filterGenotypes(list,sampleCounts,filteredList);
  adjuster2.filterGenotypes(list,sampleCounts,filteredList);
  System.out.println(""String_Node_Str"" + list);
  System.out.println(""String_Node_Str"" + filteredList);
  CountFixer fixer=new CountFixer();
  fixer.fix(list,sampleCounts,filteredList);
  assertEquals(20,filteredList.size());
  assertEquals(0,sampleCounts[0].refCount);
  assertEquals(0,sampleCounts[0].varCount);
  assertEquals(10,sampleCounts[1].refCount);
  assertEquals(6 - 6,sampleCounts[1].varCount);
}"
50244,"private IntIterator makeBase(boolean strandMatchedForward,IntArrayList qualityScores,IntIterator nextQualityIterator,DiscoverVariantPositionData list,SampleCountInfo sampleInfo,int baseIndex,PositionBaseInfo info){
  final char base=sampleInfo.base(baseIndex);
  info.to=base;
  if (base == 'A') {
    info.matchesReference=true;
    info.from=base;
    info.matchesForwardStrand=strandMatchedForward;
  }
  info.readerIndex=sampleInfo.sampleIndex;
  if (!nextQualityIterator.hasNext()) {
    nextQualityIterator=qualityScores.iterator();
  }
  info.readIndex=1;
  info.qualityScore=(byte)nextQualityIterator.nextInt();
  list.add(info);
  System.out.println(""String_Node_Str"" + info);
  return nextQualityIterator;
}","private IntIterator makeBase(boolean strandMatchedForward,IntArrayList qualityScores,IntIterator nextQualityIterator,DiscoverVariantPositionData list,SampleCountInfo sampleInfo,int baseIndex){
  PositionBaseInfo info=new PositionBaseInfo();
  final char base=sampleInfo.base(baseIndex);
  info.to=base;
  if (base == 'A') {
    info.matchesReference=true;
    info.from=base;
  }
  info.matchesForwardStrand=strandMatchedForward;
  info.readerIndex=sampleInfo.sampleIndex;
  if (!nextQualityIterator.hasNext()) {
    nextQualityIterator=qualityScores.iterator();
  }
  info.readIndex=1;
  info.qualityScore=(byte)nextQualityIterator.nextInt();
  list.add(info);
  System.out.println(""String_Node_Str"" + info);
  return nextQualityIterator;
}"
50245,"private ReferenceLocation[] restrictPerChromosome(ReferenceLocation[] breakpoints,ConcatSortedAlignmentReader reader){
  ObjectArrayList<ReferenceLocation> result=new ObjectArrayList<ReferenceLocation>();
  int lastTargetIndex=-1;
  int index=0;
  for (  ReferenceLocation breakpoint : breakpoints) {
    if (breakpoint.targetIndex != lastTargetIndex) {
      if (lastTargetIndex != -1) {
        result.add(new ReferenceLocation(lastTargetIndex,reader.getTargetLength(lastTargetIndex)));
        result.add(new ReferenceLocation(breakpoint.targetIndex,0));
        System.out.println(""String_Node_Str"" + lastTargetIndex);
      }
      lastTargetIndex=breakpoint.targetIndex;
    }
    result.add(breakpoint);
    index++;
  }
  return result.toArray(new ReferenceLocation[result.size()]);
}","private ReferenceLocation[] restrictPerChromosome(ReferenceLocation[] breakpoints,ConcatSortedAlignmentReader reader){
  ObjectArrayList<ReferenceLocation> result=new ObjectArrayList<ReferenceLocation>();
  int lastTargetIndex=-1;
  int index=0;
  for (  ReferenceLocation breakpoint : breakpoints) {
    if (breakpoint.targetIndex != lastTargetIndex) {
      if (lastTargetIndex != -1) {
        result.add(new ReferenceLocation(lastTargetIndex,reader.getTargetLength(lastTargetIndex)));
        result.add(new ReferenceLocation(breakpoint.targetIndex,0));
        System.out.println(""String_Node_Str"" + lastTargetIndex);
        numBreakPointAdded++;
      }
      lastTargetIndex=breakpoint.targetIndex;
    }
    result.add(breakpoint);
    index++;
  }
  return result.toArray(new ReferenceLocation[result.size()]);
}"
50246,"/** 
 * Suggests slices to process a large alignment file in parallel.
 * @throws java.io.IOException error reading / writing
 */
@Override public void execute() throws IOException {
  PrintStream stream=null;
  try {
    stream=outputFilename == null ? System.out : new PrintStream(new FileOutputStream(outputFilename));
    ConcatSortedAlignmentReader input=new ConcatSortedAlignmentReader(basenames);
    input.readHeader();
    DoubleIndexedIdentifier ids=new DoubleIndexedIdentifier(input.getTargetIdentifiers());
    Ranges ranges=null;
    if (annotationFilename != null) {
      ranges=convertAnnotationsToRanges(annotationFilename,ids,input);
    }
    ReferenceLocation[] breakpoints=useModulo ? getReferenceLocationsWithModulo(stream,input,ids) : getReferenceLocationsWithBytes(stream,input,ids);
    if (ranges != null) {
      adjustBreakpointsWithAnnotations(breakpoints,ranges);
    }
    if (restrictPerChromosome) {
      breakpoints=restrictPerChromosome(breakpoints,input);
    }
    for (int i=0; i < numberOfSlices; i++) {
      if (!restrictPerChromosome || (restrictPerChromosome && breakpoints[i].targetIndex == breakpoints[i + 1].targetIndex))       stream.printf(String.format(""String_Node_Str"",ids.getId(breakpoints[i].targetIndex),breakpoints[i].position,ids.getId(breakpoints[i].targetIndex),breakpoints[i].position,ids.getId(breakpoints[i + 1].targetIndex),breakpoints[i + 1].position,ids.getId(breakpoints[i + 1].targetIndex),breakpoints[i + 1].position));
    }
  }
  finally {
    if (stream != System.out) {
      IOUtils.closeQuietly(stream);
    }
  }
}","/** 
 * Suggests slices to process a large alignment file in parallel.
 * @throws java.io.IOException error reading / writing
 */
@Override public void execute() throws IOException {
  PrintStream stream=null;
  try {
    stream=outputFilename == null ? System.out : new PrintStream(new FileOutputStream(outputFilename));
    ConcatSortedAlignmentReader input=new ConcatSortedAlignmentReader(basenames);
    input.readHeader();
    DoubleIndexedIdentifier ids=new DoubleIndexedIdentifier(input.getTargetIdentifiers());
    Ranges ranges=null;
    if (annotationFilename != null) {
      ranges=convertAnnotationsToRanges(annotationFilename,ids,input);
    }
    ReferenceLocation[] breakpoints=useModulo ? getReferenceLocationsWithModulo(stream,input,ids) : getReferenceLocationsWithBytes(stream,input,ids);
    if (ranges != null) {
      adjustBreakpointsWithAnnotations(breakpoints,ranges);
    }
    if (restrictPerChromosome) {
      breakpoints=restrictPerChromosome(breakpoints,input);
    }
    for (int i=0; i < breakpoints.length - 1; i++) {
      if (!restrictPerChromosome || (restrictPerChromosome && breakpoints[i].targetIndex == breakpoints[i + 1].targetIndex))       stream.printf(String.format(""String_Node_Str"",ids.getId(breakpoints[i].targetIndex),breakpoints[i].position,ids.getId(breakpoints[i].targetIndex),breakpoints[i].position,ids.getId(breakpoints[i + 1].targetIndex),breakpoints[i + 1].position,ids.getId(breakpoints[i + 1].targetIndex),breakpoints[i + 1].position));
    }
  }
  finally {
    if (stream != System.out) {
      IOUtils.closeQuietly(stream);
    }
  }
}"
50247,"public void initStorage(int numSamples){
  super.initStorage(numSamples);
  distinctIndelsWithCount=new int[numSamples];
}","public void initStorage(int numSamples){
  super.initStorage(numSamples);
  if (distinctIndelsWithCount == null) {
    distinctIndelsWithCount=new int[numSamples];
  }
 else {
    Arrays.fill(distinctIndelsWithCount,0);
  }
}"
50248,"@Override public void filterGenotypes(DiscoverVariantPositionData list,SampleCountInfo[] sampleCounts,ObjectSet<PositionBaseInfo> filteredSet){
  Arrays.fill(distinctIndelsWithCount,0);
  int likelyIndelArtifact=0;
  for (  SampleCountInfo sci : sampleCounts) {
    for (    EquivalentIndelRegion indel : sci.getEquivalentIndelRegions()) {
      if (indel.getFrequency() > 0) {
        distinctIndelsWithCount[sci.sampleIndex]++;
      }
    }
    if (distinctIndelsWithCount[sci.sampleIndex] >= 2) {
      likelyIndelArtifact++;
    }
  }
  if (likelyIndelArtifact >= sampleCounts.length / 4) {
    for (    SampleCountInfo sci : sampleCounts) {
      final int disctingIndelsInSample=distinctIndelsWithCount[sci.sampleIndex];
      for (      EquivalentIndelRegion indel : sci.getEquivalentIndelRegions()) {
        indel.markFiltered();
      }
    }
  }
}","@Override public void filterGenotypes(DiscoverVariantPositionData list,SampleCountInfo[] sampleCounts,ObjectSet<PositionBaseInfo> filteredSet){
  resetCounters();
  initStorage(sampleCounts.length);
  int likelyIndelArtifact=0;
  for (  SampleCountInfo sci : sampleCounts) {
    for (    EquivalentIndelRegion indel : sci.getEquivalentIndelRegions()) {
      if (indel.getFrequency() > 0) {
        distinctIndelsWithCount[sci.sampleIndex]++;
      }
    }
    if (distinctIndelsWithCount[sci.sampleIndex] >= 2) {
      likelyIndelArtifact++;
    }
  }
  if (likelyIndelArtifact >= sampleCounts.length / 4) {
    for (    SampleCountInfo sci : sampleCounts) {
      final int disctingIndelsInSample=distinctIndelsWithCount[sci.sampleIndex];
      for (      EquivalentIndelRegion indel : sci.getEquivalentIndelRegions()) {
        indel.markFiltered();
      }
    }
  }
}"
50249,"/** 
 * Configure.
 * @param args command line arguments
 * @return this object for chaining
 * @throws java.io.IOException error parsing
 * @throws com.martiansoftware.jsap.JSAPException error parsing
 */
@Override public AbstractCommandLineMode configure(final String[] args) throws IOException, JSAPException {
  final JSAPResult jsapResult=parseJsapArguments(args);
  inputFilenames=jsapResult.getStringArray(""String_Node_Str"");
  String outputFile=jsapResult.getString(""String_Node_Str"");
  outputInfo=new OutputInfo(outputFile);
  String groupsDefinition=jsapResult.getString(""String_Node_Str"");
  String groupsDefinitionFile=jsapResult.getString(""String_Node_Str"");
  if (groupsDefinition != null && groupsDefinitionFile != null) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  if (groupsDefinitionFile != null) {
    groupsDefinition=parseGroupFile(groupsDefinitionFile,inputFilenames);
  }
  String compare=jsapResult.getString(""String_Node_Str"");
  deAnalyzer.parseGroupsDefinition(groupsDefinition,deCalculator,inputFilenames);
  groupComparisonsList=deAnalyzer.parseCompare(compare);
  boolean parallel=jsapResult.getBoolean(""String_Node_Str"",false);
  deAnalyzer.setRunInParallel(parallel);
  Map<String,String> sampleToGroupMap=deCalculator.getSampleToGroupMap();
  readerIndexToGroupIndex=new int[inputFilenames.length];
  groups=deAnalyzer.getGroups();
  numberOfGroups=groups.length;
  IndexedIdentifier groupIds=new IndexedIdentifier();
  for (  String group : groups) {
    groupIds.registerIdentifier(new MutableString(group));
  }
  maxThresholdPerSite=jsapResult.getInt(""String_Node_Str"");
  minimumVariationSupport=jsapResult.getInt(""String_Node_Str"");
  thresholdDistinctReadIndices=jsapResult.getInt(""String_Node_Str"");
  CompactAlignmentToAnnotationCountsMode.parseEval(jsapResult,deAnalyzer);
  for (  String sample : sampleToGroupMap.keySet()) {
    final String group=sampleToGroupMap.get(sample);
    System.out.printf(""String_Node_Str"",sample,group);
    for (int readerIndex=0; readerIndex < inputFilenames.length; readerIndex++) {
      if (AlignmentReaderImpl.getBasename(inputFilenames[readerIndex]).endsWith(sample)) {
        readerIndexToGroupIndex[readerIndex]=groupIds.get(new MutableString(group));
      }
    }
  }
  File statFile=jsapResult.getFile(""String_Node_Str"");
  if (statFile != null) {
    loadStatFile(statFile);
  }
 else {
    if (deAnalyzer.eval(""String_Node_Str"")) {
      System.err.println(""String_Node_Str"");
      System.exit(1);
    }
  }
  callIndels=jsapResult.getBoolean(""String_Node_Str"");
  diploid=jsapResult.getBoolean(""String_Node_Str"");
  realignmentFactory=configureProcessor(jsapResult);
  final String formatString=jsapResult.getString(""String_Node_Str"");
  final OutputFormat format=OutputFormat.valueOf(formatString.toUpperCase());
  SequenceVariationOutputFormat formatter=null;
switch (format) {
case VARIANT_DISCOVERY:
case BETWEEN_GROUPS:
    stopWhenDefaultGroupOptions();
  formatter=new BetweenGroupSequenceVariationOutputFormat();
break;
case COMPARE_GROUPS:
stopWhenDefaultGroupOptions();
formatter=new CompareGroupsVCFOutputFormat();
break;
case ALLELE_FREQUENCIES:
stopWhenDefaultGroupOptions();
formatter=new AlleleFrequencyOutputFormat();
break;
case GENOTYPES:
formatter=new GenotypesOutputFormat();
break;
case SOMATIC_VARIATIONS:
formatter=new SomaticVariationOutputFormat();
break;
case METHYLATION_REGIONS:
formatter=new MethylationRegionsOutputFormat();
methylFormat((MethylationFormat)formatter);
break;
case METHYLATION:
formatter=new MethylationRateVCFOutputFormat();
methylFormat((MethylationFormat)formatter);
break;
case INDEL_COUNTS:
formatter=new IndelCountOutputFormat();
callIndels=true;
break;
default :
ObjectArrayList<OutputFormat> values=ObjectArrayList.wrap(OutputFormat.values());
System.err.printf(""String_Node_Str"",values.toString());
System.exit(1);
}
genotypeFilters=new ObjectArrayList<GenotypeFilter>();
switch (format) {
case METHYLATION:
case METHYLATION_REGIONS:
if (callIndels) {
genotypeFilters.add(new RemoveIndelArtifactsFilter());
}
break;
case COMPARE_GROUPS:
case ALLELE_FREQUENCIES:
case BETWEEN_GROUPS:
case VARIANT_DISCOVERY:
genotypeFilters.add(new QualityScoreFilter());
genotypeFilters.add(new LeftOverFilter(minimumVariationSupport));
if (callIndels) {
genotypeFilters.add(new RemoveIndelArtifactsFilter());
}
if (!disableAtLeastQuarterFilter && callIndels) {
System.out.println(""String_Node_Str"");
genotypeFilters.add(new AtLeastAQuarterFilter());
}
if (diploid) {
genotypeFilters.add(new DiploidFilter());
}
break;
case GENOTYPES:
genotypeFilters.add(new QualityScoreFilter());
genotypeFilters.add(new LeftOverFilter(minimumVariationSupport));
if (callIndels) {
genotypeFilters.add(new RemoveIndelArtifactsFilter());
genotypeFilters.add(new CommonIndelArtifactFilter());
}
if (!disableAtLeastQuarterFilter) {
genotypeFilters.add(new AtLeastAQuarterFilter());
}
if (diploid) {
genotypeFilters.add(new DiploidFilter());
}
break;
case SOMATIC_VARIATIONS:
genotypeFilters.add(new QualityScoreFilter());
if (callIndels) {
genotypeFilters.add(new EntropicIndelArtifactFilter());
genotypeFilters.add(new RemoveIndelArtifactsFilter());
genotypeFilters.add(new CommonIndelArtifactFilter());
}
break;
case INDEL_COUNTS:
genotypeFilters.add(new QualityScoreFilter());
genotypeFilters.add(new LeftOverFilter(minimumVariationSupport));
genotypeFilters.add(new RemoveIndelArtifactsFilter());
if (!disableAtLeastQuarterFilter) {
genotypeFilters.add(new AtLeastAQuarterFilter());
}
if (diploid) {
genotypeFilters.add(new DiploidFilter());
}
break;
default :
throw new InternalError(""String_Node_Str"");
}
System.out.println(""String_Node_Str"");
for (final GenotypeFilter filter : genotypeFilters) {
System.out.println(filter.describe());
int numSamples=sampleToGroupMap.keySet().size();
filter.initStorage(numSamples);
}
String covInfoFilename=jsapResult.getString(""String_Node_Str"");
if (covInfoFilename != null) {
covInfo=CovariateInfo.parse(covInfoFilename);
}
final RandomAccessSequenceInterface genome=configureGenome(testGenome,jsapResult);
final int startFlapSize=jsapResult.getInt(""String_Node_Str"",100);
if (callIndels) {
System.err.println(""String_Node_Str"");
}
formatConfigurator.configureFormatter(formatter);
sortedPositionIterator=new DiscoverVariantIterateSortedAlignments(formatter);
sortedPositionIterator.setCallIndels(callIndels);
sortedPositionIterator.setGenome(genome);
sortedPositionIterator.setStartFlapLength(startFlapSize);
sortedPositionIterator.parseIncludeReferenceArgument(jsapResult);
sortedPositionIterator.setMinimumVariationSupport(minimumVariationSupport);
sortedPositionIterator.setThresholdDistinctReadIndices(thresholdDistinctReadIndices);
return this;
}","/** 
 * Configure.
 * @param args command line arguments
 * @return this object for chaining
 * @throws java.io.IOException error parsing
 * @throws com.martiansoftware.jsap.JSAPException error parsing
 */
@Override public AbstractCommandLineMode configure(final String[] args) throws IOException, JSAPException {
  final JSAPResult jsapResult=parseJsapArguments(args);
  inputFilenames=jsapResult.getStringArray(""String_Node_Str"");
  String outputFile=jsapResult.getString(""String_Node_Str"");
  outputInfo=new OutputInfo(outputFile);
  String groupsDefinition=jsapResult.getString(""String_Node_Str"");
  String groupsDefinitionFile=jsapResult.getString(""String_Node_Str"");
  if (groupsDefinition != null && groupsDefinitionFile != null) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  if (groupsDefinitionFile != null) {
    groupsDefinition=parseGroupFile(groupsDefinitionFile,inputFilenames);
  }
  String compare=jsapResult.getString(""String_Node_Str"");
  deAnalyzer.parseGroupsDefinition(groupsDefinition,deCalculator,inputFilenames);
  groupComparisonsList=deAnalyzer.parseCompare(compare);
  boolean parallel=jsapResult.getBoolean(""String_Node_Str"",false);
  deAnalyzer.setRunInParallel(parallel);
  Map<String,String> sampleToGroupMap=deCalculator.getSampleToGroupMap();
  readerIndexToGroupIndex=new int[inputFilenames.length];
  groups=deAnalyzer.getGroups();
  numberOfGroups=groups.length;
  IndexedIdentifier groupIds=new IndexedIdentifier();
  for (  String group : groups) {
    groupIds.registerIdentifier(new MutableString(group));
  }
  maxThresholdPerSite=jsapResult.getInt(""String_Node_Str"");
  minimumVariationSupport=jsapResult.getInt(""String_Node_Str"");
  thresholdDistinctReadIndices=jsapResult.getInt(""String_Node_Str"");
  CompactAlignmentToAnnotationCountsMode.parseEval(jsapResult,deAnalyzer);
  for (  String sample : sampleToGroupMap.keySet()) {
    final String group=sampleToGroupMap.get(sample);
    System.out.printf(""String_Node_Str"",sample,group);
    for (int readerIndex=0; readerIndex < inputFilenames.length; readerIndex++) {
      if (AlignmentReaderImpl.getBasename(inputFilenames[readerIndex]).endsWith(sample)) {
        readerIndexToGroupIndex[readerIndex]=groupIds.get(new MutableString(group));
      }
    }
  }
  File statFile=jsapResult.getFile(""String_Node_Str"");
  if (statFile != null) {
    loadStatFile(statFile);
  }
 else {
    if (deAnalyzer.eval(""String_Node_Str"")) {
      System.err.println(""String_Node_Str"");
      System.exit(1);
    }
  }
  callIndels=jsapResult.getBoolean(""String_Node_Str"");
  diploid=jsapResult.getBoolean(""String_Node_Str"");
  realignmentFactory=configureProcessor(jsapResult);
  final String formatString=jsapResult.getString(""String_Node_Str"");
  final OutputFormat format=OutputFormat.valueOf(formatString.toUpperCase());
  SequenceVariationOutputFormat formatter=null;
switch (format) {
case VARIANT_DISCOVERY:
case BETWEEN_GROUPS:
    stopWhenDefaultGroupOptions();
  formatter=new BetweenGroupSequenceVariationOutputFormat();
break;
case COMPARE_GROUPS:
stopWhenDefaultGroupOptions();
formatter=new CompareGroupsVCFOutputFormat();
break;
case ALLELE_FREQUENCIES:
stopWhenDefaultGroupOptions();
formatter=new AlleleFrequencyOutputFormat();
break;
case GENOTYPES:
formatter=new GenotypesOutputFormat();
break;
case SOMATIC_VARIATIONS:
formatter=new SomaticVariationOutputFormat();
break;
case METHYLATION_REGIONS:
formatter=new MethylationRegionsOutputFormat();
methylFormat((MethylationFormat)formatter);
break;
case METHYLATION:
formatter=new MethylationRateVCFOutputFormat();
methylFormat((MethylationFormat)formatter);
break;
case INDEL_COUNTS:
formatter=new IndelCountOutputFormat();
callIndels=true;
break;
default :
ObjectArrayList<OutputFormat> values=ObjectArrayList.wrap(OutputFormat.values());
System.err.printf(""String_Node_Str"",values.toString());
System.exit(1);
}
genotypeFilters=new ObjectArrayList<GenotypeFilter>();
switch (format) {
case METHYLATION:
case METHYLATION_REGIONS:
if (callIndels) {
genotypeFilters.add(new RemoveIndelArtifactsFilter());
}
break;
case COMPARE_GROUPS:
case ALLELE_FREQUENCIES:
case BETWEEN_GROUPS:
case VARIANT_DISCOVERY:
genotypeFilters.add(new QualityScoreFilter());
genotypeFilters.add(new LeftOverFilter(minimumVariationSupport));
if (callIndels) {
genotypeFilters.add(new RemoveIndelArtifactsFilter());
}
if (!disableAtLeastQuarterFilter && callIndels) {
System.out.println(""String_Node_Str"");
genotypeFilters.add(new AtLeastAQuarterFilter());
}
if (diploid) {
genotypeFilters.add(new DiploidFilter());
}
break;
case GENOTYPES:
genotypeFilters.add(new QualityScoreFilter());
genotypeFilters.add(new LeftOverFilter(minimumVariationSupport));
if (callIndels) {
genotypeFilters.add(new RemoveIndelArtifactsFilter());
genotypeFilters.add(new CommonIndelArtifactFilter());
}
if (!disableAtLeastQuarterFilter) {
genotypeFilters.add(new AtLeastAQuarterFilter());
}
if (diploid) {
genotypeFilters.add(new DiploidFilter());
}
break;
case SOMATIC_VARIATIONS:
genotypeFilters.add(new QualityScoreFilter());
if (callIndels) {
genotypeFilters.add(new EntropicIndelArtifactFilter());
genotypeFilters.add(new RemoveIndelArtifactsFilter());
genotypeFilters.add(new CommonIndelArtifactFilter());
}
break;
case INDEL_COUNTS:
genotypeFilters.add(new QualityScoreFilter());
genotypeFilters.add(new LeftOverFilter(minimumVariationSupport));
genotypeFilters.add(new RemoveIndelArtifactsFilter());
if (!disableAtLeastQuarterFilter) {
genotypeFilters.add(new AtLeastAQuarterFilter());
}
if (diploid) {
genotypeFilters.add(new DiploidFilter());
}
break;
default :
throw new InternalError(""String_Node_Str"");
}
System.out.println(""String_Node_Str"");
for (final GenotypeFilter filter : genotypeFilters) {
System.out.println(filter.describe());
}
String covInfoFilename=jsapResult.getString(""String_Node_Str"");
if (covInfoFilename != null) {
covInfo=CovariateInfo.parse(covInfoFilename);
}
final RandomAccessSequenceInterface genome=configureGenome(testGenome,jsapResult);
final int startFlapSize=jsapResult.getInt(""String_Node_Str"",100);
if (callIndels) {
System.err.println(""String_Node_Str"");
}
formatConfigurator.configureFormatter(formatter);
sortedPositionIterator=new DiscoverVariantIterateSortedAlignments(formatter);
sortedPositionIterator.setCallIndels(callIndels);
sortedPositionIterator.setGenome(genome);
sortedPositionIterator.setStartFlapLength(startFlapSize);
sortedPositionIterator.parseIncludeReferenceArgument(jsapResult);
sortedPositionIterator.setMinimumVariationSupport(minimumVariationSupport);
sortedPositionIterator.setThresholdDistinctReadIndices(thresholdDistinctReadIndices);
return this;
}"
50250,"private void appendPValueColumns(String[] inputFiles,ObjectSet<String> selection){
  String firstFile=inputFiles[0];
  try {
    VCFParser parser=new VCFParser(firstFile);
    parser.readHeader();
    GroupAssociations groupAssociations=parser.getGroupAssociations();
    ObjectArraySet<String> pValueColumns=groupAssociations.getColumnsWithGroup(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + pValueColumns);
    for (    String columnName : pValueColumns) {
      if (columnName.startsWith(""String_Node_Str"")) {
        selection.add(columnName.substring(""String_Node_Str"".length(),columnName.length()));
      }
 else {
        selection.add(columnName);
      }
    }
  }
 catch (  VCFParser.SyntaxException e) {
    LOG.error(""String_Node_Str"");
  }
catch (  IOException e) {
    LOG.error(""String_Node_Str"");
  }
}","private void appendPValueColumns(String[] inputFiles,ObjectSet<String> selection){
  String firstFile=inputFiles[0];
  try {
    VCFParser parser=new VCFParser(firstFile);
    parser.readHeader();
    GroupAssociations groupAssociations=parser.getGroupAssociations();
    ObjectArraySet<String> pValueColumns=groupAssociations.getColumnsWithGroup(""String_Node_Str"");
    if (pValueColumns != null) {
      System.out.println(""String_Node_Str"" + pValueColumns);
      for (      String columnName : pValueColumns) {
        if (columnName.startsWith(""String_Node_Str"")) {
          selection.add(columnName.substring(""String_Node_Str"".length(),columnName.length()));
        }
 else {
          selection.add(columnName);
        }
      }
    }
  }
 catch (  VCFParser.SyntaxException e) {
    LOG.error(""String_Node_Str"");
  }
catch (  IOException e) {
    LOG.error(""String_Node_Str"");
  }
}"
50251,"protected void estimateSomaticPValue(SampleCountInfo[] sampleCounts){
  pValues.clear();
  for (  int sampleIndex : somaticSampleIndices) {
    SampleCountInfo somaticCounts=sampleCounts[sampleIndex];
    int fatherSampleIndex=sample2FatherSampleIndex[sampleIndex];
    if (fatherSampleIndex != -1) {
      SampleCountInfo fatherCounts=sampleCounts[fatherSampleIndex];
      double fatherP=estimateP(somaticCounts,fatherCounts);
      pValues.add(fatherP);
    }
    int motherSampleIndex=sample2MotherSampleIndex[sampleIndex];
    if (fatherSampleIndex != -1) {
      SampleCountInfo motherCounts=sampleCounts[motherSampleIndex];
      double motherP=estimateP(somaticCounts,motherCounts);
      pValues.add(motherP);
    }
    int germlineSampleIndices[]=sample2GermlineSampleIndices[sampleIndex];
    for (    int germlineSampleIndex : germlineSampleIndices) {
      SampleCountInfo germlineCounts=sampleCounts[germlineSampleIndex];
      double germlineP=estimateP(somaticCounts,germlineCounts);
      pValues.add(germlineP);
    }
    double pValue=max(pValues);
    statsWriter.setInfo(somaticPValueIndex[sampleIndex],pValue);
  }
}","protected void estimateSomaticPValue(SampleCountInfo[] sampleCounts){
  for (  int sampleIndex : somaticSampleIndices) {
    pValues.clear();
    SampleCountInfo somaticCounts=sampleCounts[sampleIndex];
    int fatherSampleIndex=sample2FatherSampleIndex[sampleIndex];
    if (fatherSampleIndex != -1) {
      SampleCountInfo fatherCounts=sampleCounts[fatherSampleIndex];
      double fatherP=estimateP(somaticCounts,fatherCounts);
      pValues.add(fatherP);
    }
    int motherSampleIndex=sample2MotherSampleIndex[sampleIndex];
    if (fatherSampleIndex != -1) {
      SampleCountInfo motherCounts=sampleCounts[motherSampleIndex];
      double motherP=estimateP(somaticCounts,motherCounts);
      pValues.add(motherP);
    }
    int germlineSampleIndices[]=sample2GermlineSampleIndices[sampleIndex];
    for (    int germlineSampleIndex : germlineSampleIndices) {
      SampleCountInfo germlineCounts=sampleCounts[germlineSampleIndex];
      double germlineP=estimateP(somaticCounts,germlineCounts);
      pValues.add(germlineP);
    }
    double pValue=max(pValues);
    statsWriter.setInfo(somaticPValueIndex[sampleIndex],pValue);
  }
}"
50252,"private Alignments.AlignmentEntry realign(Alignments.AlignmentEntry entry,ObservedIndel indel,boolean shiftForward,int scoreDelta){
}","private Alignments.AlignmentEntry realign(Alignments.AlignmentEntry entry,ObservedIndel indel,boolean shiftForward,int scoreDelta){
  Alignments.AlignmentEntry.Builder builder=Alignments.AlignmentEntry.newBuilder(entry);
  builder.setScore(entry.getScore() + scoreDelta);
  final int indelLength=indel.positionSpan();
  builder.setTargetAlignedLength(builder.getTargetAlignedLength() + indelLength);
  int entryPosition=entry.getPosition();
  final int originalEntryPosition=entryPosition;
  if (!shiftForward && indel.isReadInsertion()) {
    entryPosition=entry.getPosition() - indelLength;
    builder.setPosition(entryPosition);
  }
  final int indelOffsetInAlignment=indel.getStart() - entryPosition;
  final int varCount=entry.getSequenceVariationsCount();
  final int targetIndex=entry.getTargetIndex();
  int score=0;
  final int direction=shiftForward ? 1 : -1;
  if (genome == null) {
    genomeNull.warn(LOG,""String_Node_Str"");
    return entry;
  }
  IntArraySet variantPositions=new IntArraySet();
  ObjectArrayList<Alignments.SequenceVariation> rewrittenVariations=new ObjectArrayList<Alignments.SequenceVariation>();
  for (int i=0; i < varCount; i++) {
    Alignments.SequenceVariation var=entry.getSequenceVariations(i);
    final int newGenomicPosition=var.getPosition() + (direction * indelLength) + originalEntryPosition - 1;
    for (int j=0; j < var.getTo().length(); ++j) {
      final char toBase=var.getTo().charAt(j);
      final int index=newGenomicPosition + j;
      if (index < 0 || index > genome.getLength(targetIndex)) {
        score+=-10;
      }
 else {
        final boolean compatible=genome.get(targetIndex,newGenomicPosition + j) == toBase;
        if (!compatible) {
          rewrittenVariations.add(var);
        }
        variantPositions.add(var.getPosition() + entryPosition + j - 1);
      }
    }
  }
  int startAlignment=shiftForward ? entryPosition + indelOffsetInAlignment : entryPosition;
  int endAlignment=shiftForward ? entry.getTargetAlignedLength() + entryPosition : indelOffsetInAlignment + entryPosition + (direction * indelLength);
  for (int pos=startAlignment; pos < endAlignment; pos++) {
    if (!variantPositions.contains(pos)) {
      final int realignedPos=pos + (direction * indelLength);
      if (realignedPos >= 0) {
        final char fromBase=genome.get(targetIndex,realignedPos);
        final char toBase=genome.get(targetIndex,pos);
        final boolean compatible=fromBase == toBase;
        if (!compatible) {
          Alignments.SequenceVariation.Builder varBuilder=Alignments.SequenceVariation.newBuilder();
          final int varPosition=direction * (realignedPos - entryPosition) + 1;
          varBuilder.setPosition(varPosition);
          varBuilder.setFrom(Character.toString(fromBase));
          varBuilder.setTo(Character.toString(toBase));
          varBuilder.setToQuality(byteArray((byte)Byte.MAX_VALUE));
          int readIndex=entry.getMatchingReverseStrand() ? entry.getQueryLength() - indelOffsetInAlignment + (shiftForward ? 1 : indelLength) : varPosition;
          varBuilder.setReadIndex(readIndex);
          rewrittenVariations.add(varBuilder.build());
        }
      }
 else {
        LOG.warn(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",entry.toString(),targetIndex,genome.getReferenceName(targetIndex),pos));
        return entry;
      }
    }
  }
  Alignments.SequenceVariation.Builder varBuilder=Alignments.SequenceVariation.newBuilder();
  final int varPosition=shiftForward ? indelOffsetInAlignment + 1 : indel.getStart() - entryPosition + 1;
  varBuilder.setPosition(varPosition);
  varBuilder.setFrom(indel.from);
  varBuilder.setTo(indel.to);
  int readIndex=entry.getMatchingReverseStrand() ? entry.getQueryLength() - indelOffsetInAlignment + (shiftForward ? 1 : indelLength) : varPosition;
  varBuilder.setReadIndex(readIndex);
  rewrittenVariations.add(varBuilder.build());
  builder=builder.clearSequenceVariations();
  for (  Alignments.SequenceVariation var : rewrittenVariations) {
    builder=builder.addSequenceVariations(var);
  }
  final Alignments.AlignmentEntry alignmentEntry=builder.build();
  return alignmentEntry;
}"
50253,"/** 
 * Load and sort annotations by their start position.
 * @param annotReader
 * @throws java.io.IOException
 */
public void loadAnnotations(final Reader annotReader) throws IOException {
  final ObjectArrayList<Interval> result=new ObjectArrayList<Interval>();
  final Object2ObjectMap<String,ObjectList<Annotation>> map=CompactAlignmentToAnnotationCountsMode.readAnnotations(annotReader);
  for (  final String key : map.keySet()) {
    final ObjectList<Annotation> list=map.get(key);
    if (list != null) {
      Collections.sort(list,compareAnnotationStart);
      for (      final Annotation element : list) {
        final Interval interval=new Interval();
        interval.referenceIndex=references.registerIdentifier(new MutableString(element.getChromosome()));
        interval.start=element.getStart();
        interval.end=element.getEnd();
        interval.id=element.getId();
        result.add(interval);
      }
      final Interval[] intervals=new Interval[list.size()];
      chromosomeToMap.put(key,result.toArray(intervals));
    }
  }
}","/** 
 * Load and sort annotations by their start position.
 * @param annotReader
 * @throws java.io.IOException
 */
public void loadAnnotations(final Reader annotReader) throws IOException {
}"
50254,"private Interval checkOverlap(final Interval[] intervals,final int insertionPoint,final int start,final int end){
  if (insertionPoint <= 0) {
    return null;
  }
  final Interval previous=intervals[insertionPoint - 1];
  if (previous.start <= start && previous.end >= end) {
    return previous;
  }
  return null;
}","private Interval checkOverlap(final Interval[] intervals,final int insertionPoint,final int start,final int end){
  if (insertionPoint <= 0) {
    return null;
  }
  final Interval previous=intervals[insertionPoint - 1];
  if (previous.start <= start && previous.end >= end) {
    return previous;
  }
  if (insertionPoint < intervals.length) {
    final Interval next=intervals[insertionPoint];
    if (next.start <= start && next.end >= end) {
      return next;
    }
  }
  return null;
}"
50255,"public void testLoad() throws IOException {
  RandomAccessAnnotations finder=new RandomAccessAnnotations();
  finder.loadAnnotations(""String_Node_Str"");
  assertNotNull(finder.find(""String_Node_Str"",11,200));
  assertNotNull(finder.find(""String_Node_Str"",10,310));
  assertNull(finder.find(""String_Node_Str"",8,9));
  assertNull(finder.find(""String_Node_Str"",311,312));
  assertNotNull(finder.find(""String_Node_Str"",1000,1001));
  assertNull(finder.find(""String_Node_Str"",1002,1003));
}","public void testLoad() throws IOException {
  RandomAccessAnnotations finder=new RandomAccessAnnotations();
  finder.loadAnnotations(""String_Node_Str"");
  final Interval interval1=finder.find(""String_Node_Str"",24165247,24165247);
  assertNotNull(interval1);
  final int chr4Index=finder.references.getInt(new MutableString(""String_Node_Str""));
  assertEquals(chr4Index,interval1.referenceIndex);
  final Interval interval2=finder.find(""String_Node_Str"",11838488,11843885);
  assertNotNull(interval2);
  final int chr11Index=finder.references.getInt(new MutableString(""String_Node_Str""));
  assertEquals(chr11Index,interval2.referenceIndex);
}"
50256,"/** 
 * Returns true if filename belongs to an alignment basename that can be read.
 * @param filename Filename of an alignment component.
 * @return True if the alignment can be read, false otherwise.
 */
public static boolean canRead(final String filename){
  final String filenameNoExtension=FilenameUtils.removeExtension(filename);
  String fileExtension=FilenameUtils.getExtension(filename);
  if (!ArrayUtils.contains(AlignmentReaderImpl.COMPACT_ALIGNMENT_FILE_REQUIRED_EXTS,""String_Node_Str"" + fileExtension) && !ArrayUtils.contains(AlignmentReaderImpl.COMPACT_ALIGNMENT_FILE_POSSIBLE_EXTS,""String_Node_Str"" + fileExtension)) {
    return false;
  }
  int count=0;
  for (  final String extension : AlignmentReaderImpl.COMPACT_ALIGNMENT_FILE_REQUIRED_EXTS) {
    if (RepositionableInputStream.resourceExist(filenameNoExtension + extension)) {
      count++;
    }
  }
  return count == AlignmentReaderImpl.COMPACT_ALIGNMENT_FILE_REQUIRED_EXTS.length;
}","/** 
 * Returns true if filename belongs to an alignment basename that can be read.
 * @param filename Filename of an alignment component.
 * @return True if the alignment can be read, false otherwise.
 */
public static boolean canRead(final String filename){
  final String filenameNoExtension=FilenameUtils.removeExtension(filename);
  String fileExtension=FilenameUtils.getExtension(filename);
  if (!ArrayUtils.contains(AlignmentReaderImpl.COMPACT_ALIGNMENT_FILE_REQUIRED_EXTS,fileExtension)) {
    return false;
  }
  int count=0;
  for (  final String extension : AlignmentReaderImpl.COMPACT_ALIGNMENT_FILE_REQUIRED_EXTS) {
    if (RepositionableInputStream.resourceExist(filenameNoExtension + extension)) {
      count++;
    }
  }
  return count == AlignmentReaderImpl.COMPACT_ALIGNMENT_FILE_REQUIRED_EXTS.length;
}"
50257,"private void writeAnnotationCounts(final Object2ObjectMap<String,ObjectList<Annotation>> allAnnots,final BufferedWriter writer,final String inputBasename,final DoubleIndexedIdentifier referenceIds,final AnnotationCountInterface[] algs,final IntSet referencesToProcess) throws IOException {
  if (doComparison) {
    int numberOfElements=0;
    int numberOfGenes=0;
    int numberOfExons=0;
    int numberOfIntrons=0;
    for (    final int referenceIndex : referencesToProcess) {
      final String chromosomeName=referenceIds.getId(referenceIndex).toString();
      if (!allAnnots.containsKey(chromosomeName)) {
        continue;
      }
      final ObjectList<Annotation> annots=allAnnots.get(chromosomeName);
      for (      final Annotation annot : annots) {
        final String geneID=annot.getId();
        final int numExons=annot.getSegments().size();
        final int numberIntrons=numExons - 1;
        if (includeAnnotationTypes.contains(""String_Node_Str"")) {
          final int index=deCalculator.defineElement(geneID,DifferentialExpressionCalculator.ElementType.GENE);
          deCalculator.defineElementLength(index,annot.getLength());
          numberOfGenes++;
          numberOfElements++;
        }
        if (includeAnnotationTypes.contains(""String_Node_Str"")) {
          for (int i=0; i < numExons; i++) {
            final Segment exonSegment=annot.getSegments().get(i);
            final String exonID=exonSegment.getId();
            final int index=deCalculator.defineElement(exonID,DifferentialExpressionCalculator.ElementType.EXON);
            deCalculator.defineElementLength(index,annot.getLength());
            numberOfExons++;
            numberOfElements++;
          }
        }
        if (includeAnnotationTypes.contains(""String_Node_Str"")) {
          for (int i=0; i < numExons; i++) {
            if (i < numberIntrons) {
              final Segment segment=annot.getSegments().get(i);
              final int intronStart=segment.getEnd() + 1;
              final Segment intronSegment=annot.getSegments().get(i + 1);
              final int intronEnd=intronSegment.getStart() - 1;
              final int intronLength=intronEnd - intronStart + 1;
              final String intronID=segment.getId() + ""String_Node_Str"" + intronSegment.getId();
              final int index=deCalculator.defineElement(intronID,DifferentialExpressionCalculator.ElementType.OTHER);
              deCalculator.defineElementLength(index,intronLength);
              numberOfIntrons++;
              numberOfElements++;
            }
          }
        }
      }
    }
    LOG.info(String.format(""String_Node_Str"",numberOfGenes,numberOfExons,numberOfIntrons,numberOfElements));
    deCalculator.reserve(numberOfElements,inputFilenames.length);
  }
  int numberOfAnnotationCountsWritten=0;
  for (  final int referenceIndex : referencesToProcess) {
    final String chromosomeName=referenceIds.getId(referenceIndex).toString();
    System.out.println(""String_Node_Str"" + chromosomeName);
    if (!allAnnots.containsKey(chromosomeName)) {
      continue;
    }
    final ObjectList<Annotation> annots=allAnnots.get(chromosomeName);
    algs[referenceIndex].sortReads();
    algs[referenceIndex].accumulate();
    algs[referenceIndex].baseCount();
    if (doComparison) {
      for (      final Annotation annot : annots) {
        final String geneID=annot.getId();
        deCalculator.defineElement(geneID);
      }
    }
    final String basename=FilenameUtils.getBaseName(inputBasename);
    final String sampleId=basename;
    for (    final Annotation annot : annots) {
      final String geneID=annot.getId();
      if (includeAnnotationTypes.contains(""String_Node_Str"")) {
        final int geneStart=annot.getStart();
        final int geneEnd=annot.getEnd();
        final int geneLength=geneEnd - geneStart + 1;
        final float geneDepth=algs[referenceIndex].averageReadsPerPosition(geneStart,geneEnd);
        final double geneOverlapReads=algs[referenceIndex].countReadsPartiallyOverlappingWithInterval(geneStart,geneEnd);
        final double geneInsideReads=algs[referenceIndex].countReadsStriclyWithinInterval(geneStart,geneEnd);
        final double geneExpression=algs[referenceIndex].geneExpressionCount(annot);
        final int numExons=annot.getSegments().size();
        final double geneRPKM=deCalculator.calculateNormalized(geneOverlapReads,annot.getLength(),deCalculator.getNumAlignedInSample(sampleId));
        if (writeAnnotationCounts) {
          writer.write(String.format(""String_Node_Str"",basename,geneID,""String_Node_Str"",""String_Node_Str"",annot.getChromosome(),annot.getStrand(),geneLength,geneStart,geneEnd,geneInsideReads,geneOverlapReads,geneRPKM,log2(geneRPKM),geneExpression,numExons));
        }
        numberOfAnnotationCountsWritten++;
        if (doComparison) {
          deCalculator.observe(basename,geneID,geneExpression);
        }
      }
      final int numberExons=annot.getSegments().size();
      final int numberIntrons=numberExons - 1;
      if (includeAnnotationTypes.contains(""String_Node_Str"") || includeAnnotationTypes.contains(""String_Node_Str"")) {
        for (int i=0; i < numberExons; i++) {
          final Segment segment=annot.getSegments().get(i);
          final int exonStart=segment.getStart();
          final int exonEnd=segment.getEnd();
          final String exonStrand=segment.getStrand();
          final int exonLength=segment.getLength();
          final String exonID=segment.getId();
          final float exonDepth=algs[referenceIndex].averageReadsPerPosition(exonStart,exonEnd);
          final double exonOverlapReads=algs[referenceIndex].countReadsPartiallyOverlappingWithInterval(exonStart,exonEnd);
          final double exonInsideReads=algs[referenceIndex].countReadsStriclyWithinInterval(exonStart,exonEnd);
          final double exonRPKM=deCalculator.calculateNormalized(exonOverlapReads,segment.getLength(),deCalculator.getNumAlignedInSample(sampleId));
          if (includeAnnotationTypes.contains(""String_Node_Str"")) {
            if (writeAnnotationCounts) {
              writer.write(String.format(""String_Node_Str"",basename,geneID,exonID,""String_Node_Str"",annot.getChromosome(),exonStrand,exonLength,exonStart,exonEnd,exonInsideReads,exonOverlapReads,exonRPKM,log2(exonRPKM)));
            }
            numberOfAnnotationCountsWritten++;
            if (doComparison && includeAnnotationTypes.contains(""String_Node_Str"")) {
              deCalculator.observe(basename,exonID,exonOverlapReads);
            }
          }
          if (i < numberIntrons) {
            final int intronStart=segment.getEnd() + 1;
            final Segment intronSegment=annot.getSegments().get(i + 1);
            final int intronEnd=intronSegment.getStart() - 1;
            final int intronLength=intronEnd - intronStart + 1;
            final String intronID=segment.getId() + ""String_Node_Str"" + intronSegment.getId();
            final float intronDepth=algs[referenceIndex].averageReadsPerPosition(intronStart,intronEnd);
            final double intronOverlapReads=algs[referenceIndex].countReadsPartiallyOverlappingWithInterval(intronStart,intronEnd);
            final double intronInsideReads=algs[referenceIndex].countReadsStriclyWithinInterval(intronStart,intronEnd);
            final double intronRPKM=deCalculator.calculateNormalized(intronOverlapReads,intronSegment.getLength(),deCalculator.getNumAlignedInSample(sampleId));
            if (intronLength > 0) {
              if (includeAnnotationTypes.contains(""String_Node_Str"")) {
                if (writeAnnotationCounts) {
                  writer.write(String.format(""String_Node_Str"",basename,geneID,intronID,""String_Node_Str"",annot.getChromosome(),exonStrand,exonLength,exonStart,exonEnd,intronInsideReads,intronOverlapReads,intronRPKM,log2(intronRPKM)));
                }
                numberOfAnnotationCountsWritten++;
                if (doComparison && includeAnnotationTypes.contains(""String_Node_Str"")) {
                  deCalculator.observe(basename,intronID,intronOverlapReads);
                }
              }
            }
          }
        }
      }
    }
    algs[referenceIndex]=null;
  }
  LOG.info(""String_Node_Str"" + numberOfAnnotationCountsWritten + ""String_Node_Str"");
  if (numberOfAnnotationCountsWritten == 0) {
    LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
}","private void writeAnnotationCounts(final Object2ObjectMap<String,ObjectList<Annotation>> allAnnots,final BufferedWriter writer,final String inputBasename,final DoubleIndexedIdentifier referenceIds,final AnnotationCountInterface[] algs,final IntSet referencesToProcess) throws IOException {
  if (doComparison) {
    int numberOfElements=0;
    int numberOfGenes=0;
    int numberOfExons=0;
    int numberOfIntrons=0;
    for (    final int referenceIndex : referencesToProcess) {
      final String chromosomeName=referenceIds.getId(referenceIndex).toString();
      if (!allAnnots.containsKey(chromosomeName)) {
        continue;
      }
      final ObjectList<Annotation> annots=allAnnots.get(chromosomeName);
      for (      final Annotation annot : annots) {
        final String geneID=annot.getId();
        final int numExons=annot.getSegments().size();
        final int numberIntrons=numExons - 1;
        if (includeAnnotationTypes.contains(""String_Node_Str"")) {
          final int index=deCalculator.defineElement(geneID,DifferentialExpressionCalculator.ElementType.GENE);
          deCalculator.defineElementLength(index,annot.getLength());
          numberOfGenes++;
          numberOfElements++;
        }
        if (includeAnnotationTypes.contains(""String_Node_Str"")) {
          for (int i=0; i < numExons; i++) {
            final Segment exonSegment=annot.getSegments().get(i);
            final String exonID=exonSegment.getId();
            final int index=deCalculator.defineElement(exonID,DifferentialExpressionCalculator.ElementType.EXON);
            deCalculator.defineElementLength(index,annot.getLength());
            numberOfExons++;
            numberOfElements++;
          }
        }
        if (includeAnnotationTypes.contains(""String_Node_Str"")) {
          for (int i=0; i < numExons; i++) {
            if (i < numberIntrons) {
              final Segment segment=annot.getSegments().get(i);
              final int intronStart=segment.getEnd() + 1;
              final Segment intronSegment=annot.getSegments().get(i + 1);
              final int intronEnd=intronSegment.getStart() - 1;
              final int intronLength=intronEnd - intronStart + 1;
              final String intronID=segment.getId() + ""String_Node_Str"" + intronSegment.getId();
              final int index=deCalculator.defineElement(intronID,DifferentialExpressionCalculator.ElementType.OTHER);
              deCalculator.defineElementLength(index,intronLength);
              numberOfIntrons++;
              numberOfElements++;
            }
          }
        }
      }
    }
    LOG.info(String.format(""String_Node_Str"",numberOfGenes,numberOfExons,numberOfIntrons,numberOfElements));
    deCalculator.reserve(numberOfElements,inputFilenames.length);
  }
  int numberOfAnnotationCountsWritten=0;
  for (  final int referenceIndex : referencesToProcess) {
    final String chromosomeName=referenceIds.getId(referenceIndex).toString();
    System.out.println(""String_Node_Str"" + chromosomeName);
    if (!allAnnots.containsKey(chromosomeName)) {
      continue;
    }
    final ObjectList<Annotation> annots=allAnnots.get(chromosomeName);
    algs[referenceIndex].sortReads();
    algs[referenceIndex].accumulate();
    algs[referenceIndex].baseCount();
    if (doComparison) {
      for (      final Annotation annot : annots) {
        final String geneID=annot.getId();
        deCalculator.defineElement(geneID);
      }
    }
    final String basename=FilenameUtils.getName(inputBasename);
    final String sampleId=inputBasename;
    for (    final Annotation annot : annots) {
      final String geneID=annot.getId();
      if (includeAnnotationTypes.contains(""String_Node_Str"")) {
        final int geneStart=annot.getStart();
        final int geneEnd=annot.getEnd();
        final int geneLength=geneEnd - geneStart + 1;
        final float geneDepth=algs[referenceIndex].averageReadsPerPosition(geneStart,geneEnd);
        final double geneOverlapReads=algs[referenceIndex].countReadsPartiallyOverlappingWithInterval(geneStart,geneEnd);
        final double geneInsideReads=algs[referenceIndex].countReadsStriclyWithinInterval(geneStart,geneEnd);
        final double geneExpression=algs[referenceIndex].geneExpressionCount(annot);
        final int numExons=annot.getSegments().size();
        final double geneRPKM=deCalculator.calculateNormalized(geneOverlapReads,annot.getLength(),deCalculator.getNumAlignedInSample(sampleId));
        if (writeAnnotationCounts) {
          writer.write(String.format(""String_Node_Str"",basename,geneID,""String_Node_Str"",""String_Node_Str"",annot.getChromosome(),annot.getStrand(),geneLength,geneStart,geneEnd,geneInsideReads,geneOverlapReads,geneRPKM,log2(geneRPKM),geneExpression,numExons));
        }
        numberOfAnnotationCountsWritten++;
        if (doComparison) {
          deCalculator.observe(basename,geneID,geneExpression);
        }
      }
      final int numberExons=annot.getSegments().size();
      final int numberIntrons=numberExons - 1;
      if (includeAnnotationTypes.contains(""String_Node_Str"") || includeAnnotationTypes.contains(""String_Node_Str"")) {
        for (int i=0; i < numberExons; i++) {
          final Segment segment=annot.getSegments().get(i);
          final int exonStart=segment.getStart();
          final int exonEnd=segment.getEnd();
          final String exonStrand=segment.getStrand();
          final int exonLength=segment.getLength();
          final String exonID=segment.getId();
          final float exonDepth=algs[referenceIndex].averageReadsPerPosition(exonStart,exonEnd);
          final double exonOverlapReads=algs[referenceIndex].countReadsPartiallyOverlappingWithInterval(exonStart,exonEnd);
          final double exonInsideReads=algs[referenceIndex].countReadsStriclyWithinInterval(exonStart,exonEnd);
          final double exonRPKM=deCalculator.calculateNormalized(exonOverlapReads,segment.getLength(),deCalculator.getNumAlignedInSample(sampleId));
          if (includeAnnotationTypes.contains(""String_Node_Str"")) {
            if (writeAnnotationCounts) {
              writer.write(String.format(""String_Node_Str"",basename,geneID,exonID,""String_Node_Str"",annot.getChromosome(),exonStrand,exonLength,exonStart,exonEnd,exonInsideReads,exonOverlapReads,exonRPKM,log2(exonRPKM)));
            }
            numberOfAnnotationCountsWritten++;
            if (doComparison && includeAnnotationTypes.contains(""String_Node_Str"")) {
              deCalculator.observe(basename,exonID,exonOverlapReads);
            }
          }
          if (i < numberIntrons) {
            final int intronStart=segment.getEnd() + 1;
            final Segment intronSegment=annot.getSegments().get(i + 1);
            final int intronEnd=intronSegment.getStart() - 1;
            final int intronLength=intronEnd - intronStart + 1;
            final String intronID=segment.getId() + ""String_Node_Str"" + intronSegment.getId();
            final float intronDepth=algs[referenceIndex].averageReadsPerPosition(intronStart,intronEnd);
            final double intronOverlapReads=algs[referenceIndex].countReadsPartiallyOverlappingWithInterval(intronStart,intronEnd);
            final double intronInsideReads=algs[referenceIndex].countReadsStriclyWithinInterval(intronStart,intronEnd);
            final double intronRPKM=deCalculator.calculateNormalized(intronOverlapReads,intronSegment.getLength(),deCalculator.getNumAlignedInSample(sampleId));
            if (intronLength > 0) {
              if (includeAnnotationTypes.contains(""String_Node_Str"")) {
                if (writeAnnotationCounts) {
                  writer.write(String.format(""String_Node_Str"",basename,geneID,intronID,""String_Node_Str"",annot.getChromosome(),exonStrand,exonLength,exonStart,exonEnd,intronInsideReads,intronOverlapReads,intronRPKM,log2(intronRPKM)));
                }
                numberOfAnnotationCountsWritten++;
                if (doComparison && includeAnnotationTypes.contains(""String_Node_Str"")) {
                  deCalculator.observe(basename,intronID,intronOverlapReads);
                }
              }
            }
          }
        }
      }
    }
    algs[referenceIndex]=null;
  }
  LOG.info(""String_Node_Str"" + numberOfAnnotationCountsWritten + ""String_Node_Str"");
  if (numberOfAnnotationCountsWritten == 0) {
    LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  }
}"
50258,"protected MutableString trimRight(int length,MutableString sequence,ByteString qualityScores,ByteArrayList newQualScores,MutableString[] adapters){
  int currentLength=sequence.length();
  for (  MutableString adapter : adapters) {
    final int adaptLength=adapter.length();
    for (int j=minRightLength; j < adaptLength; j++) {
      if (sequence.endsWith(adapter.subSequence(j,adaptLength))) {
        final int trimedLength=adaptLength - j;
        if (trimedLength > 10) {
          System.out.printf(""String_Node_Str"",trimedLength,sequence,adapter);
        }
        if (currentLength == length) {
          copy(qualityScores,newQualScores);
        }
        if (!qualityScores.isEmpty()) {
          newQualScores.removeElements(currentLength - trimedLength,Math.min(currentLength + 1,newQualScores.size()));
        }
        numTrimmedRight++;
        return sequence.substring(0,currentLength - trimedLength);
      }
    }
  }
  return sequence;
}","protected MutableString trimRight(int length,MutableString sequence,ByteString qualityScores,ByteArrayList newQualScores,MutableString[] adapters){
  int currentLength=sequence.length();
  for (  MutableString adapter : adapters) {
    final int adaptLength=adapter.length();
    for (int j=minRightLength; j < adaptLength; j++) {
      if (sequence.endsWith(adapter.subSequence(j,adaptLength))) {
        final int trimedLength=adaptLength - j;
        if (trimedLength > 10) {
          System.out.printf(""String_Node_Str"",trimedLength,sequence,adapter);
        }
        if (currentLength == length) {
          if (newQualScores.size() == 0) {
            copy(qualityScores,newQualScores);
          }
        }
        if (!qualityScores.isEmpty()) {
          newQualScores.removeElements(currentLength - trimedLength,Math.min(currentLength + 1,newQualScores.size()));
        }
        numTrimmedRight++;
        return sequence.substring(0,currentLength - trimedLength);
      }
    }
  }
  return sequence;
}"
50259,"protected MutableString trimLeft(int length,MutableString sequence,ByteString qualityScores,ByteArrayList newQualScores,MutableString[] adapters){
  int currentLength=sequence.length();
  for (  MutableString adapter : adapters) {
    final int adaptLength=adapter.length();
    for (int j=adaptLength; j >= minLeftLength; --j) {
      if (sequence.startsWith(adapter.subSequence(0,j))) {
        final int trimedLength=j;
        if (trimedLength > 10) {
          System.out.printf(""String_Node_Str"",trimedLength,sequence,adapter);
        }
        if (currentLength == length) {
          copy(qualityScores,newQualScores);
        }
        if (!qualityScores.isEmpty()) {
          newQualScores.removeElements(0,trimedLength);
        }
        numTrimmedLeft++;
        return sequence.substring(trimedLength,currentLength);
      }
    }
  }
  return sequence;
}","protected MutableString trimLeft(int length,MutableString sequence,ByteString qualityScores,ByteArrayList newQualScores,MutableString[] adapters){
  int currentLength=sequence.length();
  for (  MutableString adapter : adapters) {
    final int adaptLength=adapter.length();
    for (int j=adaptLength; j >= minLeftLength; --j) {
      if (sequence.startsWith(adapter.subSequence(0,j))) {
        final int trimedLength=j;
        if (trimedLength > 10) {
          System.out.printf(""String_Node_Str"",trimedLength,sequence,adapter);
        }
        if (currentLength == length) {
          if (newQualScores.size() == 0) {
            copy(qualityScores,newQualScores);
          }
        }
        if (!qualityScores.isEmpty()) {
          newQualScores.removeElements(0,trimedLength);
        }
        numTrimmedLeft++;
        return sequence.substring(trimedLength,currentLength);
      }
    }
  }
  return sequence;
}"
50260,"/** 
 * Returns true if filename belongs to an alignment basename that can be read.
 * @param filename Filename of an alignment component.
 * @return True if the alignment can be read, false otherwise.
 */
public static boolean canRead(final String filename){
  final String filenameNoExtension=FilenameUtils.removeExtension(filename);
  int count=0;
  for (  final String extension : AlignmentReaderImpl.COMPACT_ALIGNMENT_FILE_REQUIRED_EXTS) {
    if (RepositionableInputStream.resourceExist(filenameNoExtension + extension)) {
      count++;
    }
  }
  return count == AlignmentReaderImpl.COMPACT_ALIGNMENT_FILE_REQUIRED_EXTS.length;
}","/** 
 * Returns true if filename belongs to an alignment basename that can be read.
 * @param filename Filename of an alignment component.
 * @return True if the alignment can be read, false otherwise.
 */
public static boolean canRead(final String filename){
  final String filenameNoExtension=FilenameUtils.removeExtension(filename);
  String fileExtension=FilenameUtils.getExtension(filename);
  if (!ArrayUtils.contains(AlignmentReaderImpl.COMPACT_ALIGNMENT_FILE_REQUIRED_EXTS,fileExtension)) {
    return false;
  }
  int count=0;
  for (  final String extension : AlignmentReaderImpl.COMPACT_ALIGNMENT_FILE_REQUIRED_EXTS) {
    if (RepositionableInputStream.resourceExist(filenameNoExtension + extension)) {
      count++;
    }
  }
  return count == AlignmentReaderImpl.COMPACT_ALIGNMENT_FILE_REQUIRED_EXTS.length;
}"
50261,"@Override public int getReferenceIndex(String referenceId){
  return (int)namesToIndices.getInt(referenceId);
}","@Override public int getReferenceIndex(final String referenceId){
  return (int)namesToIndices.getInt(referenceId);
}"
50262,"public void print(int referenceIndex){
  for (int i=0; i < getLength(referenceIndex); i++) {
    if (i % basesPerLine[referenceIndex] == 0) {
      System.out.println(""String_Node_Str"" + i + ""String_Node_Str"");
    }
    System.out.print(get(referenceIndex,i));
  }
}","public void print(final int referenceIndex){
  for (int i=0; i < getLength(referenceIndex); i++) {
    if (i % basesPerLine[referenceIndex] == 0) {
      System.out.println(""String_Node_Str"" + i + ""String_Node_Str"");
    }
    System.out.print(get(referenceIndex,i));
  }
}"
50263,"@Override public void getRange(int referenceIndex,int position,int length,MutableString bases){
}","@Override public void getRange(final int referenceIndex,final int position,final int length,final MutableString bases){
}"
50264,"@Override public int getLength(int targetIndex){
  return (int)lengths[targetIndex];
}","@Override public int getLength(final int targetIndex){
  return (int)lengths[targetIndex];
}"
50265,"@Override public String getReferenceName(int index){
  return names[index];
}","@Override public String getReferenceName(final int index){
  return names[index];
}"
50266,"public PicardFastaIndexedSequence(String filename) throws FileNotFoundException {
  delegate=new IndexedFastaSequenceFile(new File(filename));
  indexDelegate=new FastaSequenceIndex(new File(filename + ""String_Node_Str""));
  final int numContigs=indexDelegate.size();
  if (!delegate.isIndexed())   throw new FileNotFoundException(""String_Node_Str"" + filename);
  lengths=new int[numContigs];
  names=new String[numContigs];
  basesPerLine=new long[numContigs];
  final LineIterator lineIt=new LineIterator(new FileReader(filename + ""String_Node_Str""));
  int index=0;
  while (lineIt.hasNext()) {
    String line=lineIt.nextLine();
    String[] tokens=line.split(""String_Node_Str"");
    names[index]=tokens[0];
    namesToIndices.put(tokens[0],index);
    lengths[index]=Integer.parseInt(tokens[1]);
    basesPerLine[index]=Long.parseLong(tokens[2]);
    index++;
  }
}","public PicardFastaIndexedSequence(final String filename) throws FileNotFoundException {
  delegate=new IndexedFastaSequenceFile(new File(filename));
  indexDelegate=new FastaSequenceIndex(new File(filename + ""String_Node_Str""));
  final int numContigs=indexDelegate.size();
  if (!delegate.isIndexed())   throw new FileNotFoundException(""String_Node_Str"" + filename);
  lengths=new int[numContigs];
  names=new String[numContigs];
  basesPerLine=new long[numContigs];
  final LineIterator lineIt=new LineIterator(new FileReader(filename + ""String_Node_Str""));
  int index=0;
  while (lineIt.hasNext()) {
    final String line=lineIt.nextLine();
    final String[] tokens=line.split(""String_Node_Str"");
    names[index]=tokens[0];
    namesToIndices.put(tokens[0],index);
    lengths[index]=Integer.parseInt(tokens[1]);
    basesPerLine[index]=Long.parseLong(tokens[2]);
    index++;
  }
}"
50267,"public void testRoundTrips() throws IOException {
  File dir=new File(""String_Node_Str"");
  File[] files=dir.listFiles(new FilenameFilter(){
    @Override public boolean accept(    File file,    String s){
      if (s.startsWith(""String_Node_Str"") && s.endsWith(""String_Node_Str""))       return true;
 else       return false;
    }
  }
);
  for (  File inputFile : files) {
    String filename=inputFile.getAbsolutePath();
    boolean preserveSoftClips=true;
    boolean preserveAllReadQuals=true;
    String importedBasename=importFile(filename,preserveSoftClips,preserveAllReadQuals);
    String exportedSamFilename=exportFile(importedBasename);
    TestFiles tester=new TestFiles();
    tester.assertEquals(inputFile,new File(exportedSamFilename));
  }
}","public void testRoundTrips() throws IOException {
  File dir=new File(""String_Node_Str"");
  File[] files=dir.listFiles(new FilenameFilter(){
    @Override public boolean accept(    File file,    String s){
      if (s.startsWith(""String_Node_Str"") && s.endsWith(""String_Node_Str""))       return true;
 else       return false;
    }
  }
);
  for (  File inputFile : files) {
    String filename=inputFile.getAbsolutePath();
    boolean preserveSoftClips=true;
    boolean preserveAllReadQuals=true;
    String importedBasename=importFile(filename,preserveSoftClips,preserveAllReadQuals);
    String exportedSamFilename=exportFile(importedBasename,null);
    TestFiles tester=new TestFiles();
    tester.assertEquals(inputFile,new File(exportedSamFilename));
  }
}"
50268,"private String exportFile(String importedBasename) throws IOException {
  final String outputFilename=FilenameUtils.concat(BASE_TEST_DIR,""String_Node_Str"" + counterSam++ + ""String_Node_Str"");
  CompactToSAMMode exporter=new CompactToSAMMode();
  exporter.setInputBasename(importedBasename);
  exporter.setOutput(outputFilename);
  RandomAccessSequenceInterface genomeTestSupport=new RandomAccessSequenceInterface(){
    @Override public char get(    int referenceIndex,    int position){
      return 'A';
    }
    @Override public int getLength(    int targetIndex){
      return Integer.MAX_VALUE;
    }
    @Override public void getRange(    int referenceIndex,    int position,    int length,    MutableString bases){
      bases.setLength(0);
      for (int i=0; i < length; i++) {
        bases.append('A');
      }
    }
    @Override public int getReferenceIndex(    String referenceId){
      return 0;
    }
    @Override public String getReferenceName(    int index){
      return ""String_Node_Str"";
    }
    @Override public int size(){
      return 5;
    }
  }
;
  exporter.setGenome(genomeTestSupport);
  exporter.execute();
  return outputFilename;
}","private String exportFile(String importedBasename,String genomePath) throws IOException {
  final String outputFilename=FilenameUtils.concat(BASE_TEST_DIR,""String_Node_Str"" + counterSam++ + ""String_Node_Str"");
  CompactToSAMMode exporter=new CompactToSAMMode();
  exporter.setInputBasename(importedBasename);
  exporter.setOutput(outputFilename);
  if (genomePath != null) {
    exporter.setGenome(new PicardFastaIndexedSequence(genomePath));
  }
 else {
    RandomAccessSequenceInterface genomeTestSupport=new RandomAccessSequenceInterface(){
      @Override public char get(      int referenceIndex,      int position){
        return 'A';
      }
      @Override public int getLength(      int targetIndex){
        return Integer.MAX_VALUE;
      }
      @Override public void getRange(      int referenceIndex,      int position,      int length,      MutableString bases){
        bases.setLength(0);
        for (int i=0; i < length; i++) {
          bases.append('A');
        }
      }
      @Override public int getReferenceIndex(      String referenceId){
        return 0;
      }
      @Override public String getReferenceName(      int index){
        return ""String_Node_Str"";
      }
      @Override public int size(){
        return 5;
      }
    }
;
    exporter.setGenome(genomeTestSupport);
  }
  exporter.execute();
  return outputFilename;
}"
50269,"private String importFile(String filename,boolean preserveSoftClips,boolean preserveAllReadQuals) throws IOException {
  SAMToCompactMode importer=new SAMToCompactMode();
  importer.setInputFile(filename);
  final String outputFilename=FilenameUtils.concat(BASE_TEST_DIR,""String_Node_Str"" + counterGoby++);
  importer.setOutputFile(outputFilename);
  importer.setPreserveSoftClips(preserveSoftClips);
  importer.setPreserveReadQualityScores(true);
  importer.setPreserveAllTags(true);
  importer.execute();
  return outputFilename;
}","private String importFile(String filename,boolean preserveSoftClips,boolean preserveAllReadQuals) throws IOException {
  SAMToCompactMode importer=new SAMToCompactMode();
  importer.setInputFile(filename);
  final String outputFilename=FilenameUtils.concat(BASE_TEST_DIR,""String_Node_Str"" + counterGoby++);
  importer.setOutputFile(outputFilename);
  importer.setPreserveReadName(true);
  importer.setPreserveSoftClips(preserveSoftClips);
  importer.setPreserveReadQualityScores(true);
  importer.setPreserveAllTags(true);
  importer.execute();
  return outputFilename;
}"
50270,"@Test public void testEncodeDecodeOneSequence() throws IOException {
  final RandomAccessSequenceInterface cache=new PicardFastaIndexedSequence(""String_Node_Str"");
  int i=0;
  assertEquals('A',cache.get(0,i++));
  assertEquals('C',cache.get(0,i++));
  assertEquals('T',cache.get(0,i++));
  assertEquals('G',cache.get(0,i++));
  assertEquals('N',cache.get(0,i++));
  assertEquals('N',cache.get(0,i++));
  assertEquals('N',cache.get(0,i++));
  assertEquals('A',cache.get(0,i++));
  assertEquals('C',cache.get(0,i++));
  assertEquals('T',cache.get(0,i++));
  assertEquals('G',cache.get(0,i++));
  try {
    cache.get(0,i++);
    fail();
  }
 catch (  AssertionError e) {
  }
}","@Test public void testEncodeDecodeOneSequence() throws IOException {
  final RandomAccessSequenceInterface cache=new PicardFastaIndexedSequence(""String_Node_Str"");
  int i=0;
  assertEquals('A',cache.get(0,i++));
  assertEquals('C',cache.get(0,i++));
  assertEquals('T',cache.get(0,i++));
  assertEquals('G',cache.get(0,i++));
  assertEquals('N',cache.get(0,i++));
  assertEquals('N',cache.get(0,i++));
  assertEquals('N',cache.get(0,i++));
  assertEquals('A',cache.get(0,i++));
  assertEquals('C',cache.get(0,i++));
  assertEquals('T',cache.get(0,i++));
  assertEquals('G',cache.get(0,i++));
  try {
    cache.get(0,i++);
    fail();
  }
 catch (  AssertionError e) {
  }
catch (  StringIndexOutOfBoundsException e) {
  }
}"
50271,"@Override public int getReferenceIndex(String referenceId){
  return (int)namesToIndices.getInt(referenceId);
}","@Override public int getReferenceIndex(final String referenceId){
  return (int)namesToIndices.getInt(referenceId);
}"
50272,"public void print(int referenceIndex){
  for (int i=0; i < getLength(referenceIndex); i++) {
    if (i % basesPerLine[referenceIndex] == 0) {
      System.out.println(""String_Node_Str"" + i + ""String_Node_Str"");
    }
    System.out.print(get(referenceIndex,i));
  }
}","public void print(final int referenceIndex){
  for (int i=0; i < getLength(referenceIndex); i++) {
    if (i % basesPerLine[referenceIndex] == 0) {
      System.out.println(""String_Node_Str"" + i + ""String_Node_Str"");
    }
    System.out.print(get(referenceIndex,i));
  }
}"
50273,"@Override public void getRange(int referenceIndex,int position,int length,MutableString bases){
}","@Override public void getRange(final int referenceIndex,final int position,final int length,final MutableString bases){
}"
50274,"@Override public int getLength(int targetIndex){
  return (int)lengths[targetIndex];
}","@Override public int getLength(final int targetIndex){
  return (int)lengths[targetIndex];
}"
50275,"@Override public String getReferenceName(int index){
  return names[index];
}","@Override public String getReferenceName(final int index){
  return names[index];
}"
50276,"public PicardFastaIndexedSequence(String filename) throws FileNotFoundException {
  delegate=new IndexedFastaSequenceFile(new File(filename));
  indexDelegate=new FastaSequenceIndex(new File(filename + ""String_Node_Str""));
  final int numContigs=indexDelegate.size();
  if (!delegate.isIndexed())   throw new FileNotFoundException(""String_Node_Str"" + filename);
  lengths=new int[numContigs];
  names=new String[numContigs];
  basesPerLine=new long[numContigs];
  final LineIterator lineIt=new LineIterator(new FileReader(filename + ""String_Node_Str""));
  int index=0;
  while (lineIt.hasNext()) {
    String line=lineIt.nextLine();
    String[] tokens=line.split(""String_Node_Str"");
    names[index]=tokens[0];
    namesToIndices.put(tokens[0],index);
    lengths[index]=Integer.parseInt(tokens[1]);
    basesPerLine[index]=Long.parseLong(tokens[2]);
    index++;
  }
}","public PicardFastaIndexedSequence(final String filename) throws FileNotFoundException {
  delegate=new IndexedFastaSequenceFile(new File(filename));
  indexDelegate=new FastaSequenceIndex(new File(filename + ""String_Node_Str""));
  final int numContigs=indexDelegate.size();
  if (!delegate.isIndexed())   throw new FileNotFoundException(""String_Node_Str"" + filename);
  lengths=new int[numContigs];
  names=new String[numContigs];
  basesPerLine=new long[numContigs];
  final LineIterator lineIt=new LineIterator(new FileReader(filename + ""String_Node_Str""));
  int index=0;
  while (lineIt.hasNext()) {
    final String line=lineIt.nextLine();
    final String[] tokens=line.split(""String_Node_Str"");
    names[index]=tokens[0];
    namesToIndices.put(tokens[0],index);
    lengths[index]=Integer.parseInt(tokens[1]);
    basesPerLine[index]=Long.parseLong(tokens[2]);
    index++;
  }
}"
50277,"public void testRoundTrips() throws IOException {
  File dir=new File(""String_Node_Str"");
  File[] files=dir.listFiles(new FilenameFilter(){
    @Override public boolean accept(    File file,    String s){
      if (s.startsWith(""String_Node_Str"") && s.endsWith(""String_Node_Str""))       return true;
 else       return false;
    }
  }
);
  for (  File inputFile : files) {
    String filename=inputFile.getAbsolutePath();
    boolean preserveSoftClips=true;
    boolean preserveAllReadQuals=true;
    String importedBasename=importFile(filename,preserveSoftClips,preserveAllReadQuals);
    String exportedSamFilename=exportFile(importedBasename);
    TestFiles tester=new TestFiles();
    tester.assertEquals(inputFile,new File(exportedSamFilename));
  }
}","public void testRoundTrips() throws IOException {
  File dir=new File(""String_Node_Str"");
  File[] files=dir.listFiles(new FilenameFilter(){
    @Override public boolean accept(    File file,    String s){
      if (s.startsWith(""String_Node_Str"") && s.endsWith(""String_Node_Str""))       return true;
 else       return false;
    }
  }
);
  for (  File inputFile : files) {
    String filename=inputFile.getAbsolutePath();
    boolean preserveSoftClips=true;
    boolean preserveAllReadQuals=true;
    String importedBasename=importFile(filename,preserveSoftClips,preserveAllReadQuals);
    String exportedSamFilename=exportFile(importedBasename,null);
    TestFiles tester=new TestFiles();
    tester.assertEquals(inputFile,new File(exportedSamFilename));
  }
}"
50278,"private String exportFile(String importedBasename) throws IOException {
  final String outputFilename=FilenameUtils.concat(BASE_TEST_DIR,""String_Node_Str"" + counterSam++ + ""String_Node_Str"");
  CompactToSAMMode exporter=new CompactToSAMMode();
  exporter.setInputBasename(importedBasename);
  exporter.setOutput(outputFilename);
  RandomAccessSequenceInterface genomeTestSupport=new RandomAccessSequenceInterface(){
    @Override public char get(    int referenceIndex,    int position){
      return 'A';
    }
    @Override public int getLength(    int targetIndex){
      return Integer.MAX_VALUE;
    }
    @Override public void getRange(    int referenceIndex,    int position,    int length,    MutableString bases){
      bases.setLength(0);
      for (int i=0; i < length; i++) {
        bases.append('A');
      }
    }
    @Override public int getReferenceIndex(    String referenceId){
      return 0;
    }
    @Override public String getReferenceName(    int index){
      return ""String_Node_Str"";
    }
    @Override public int size(){
      return 5;
    }
  }
;
  exporter.setGenome(genomeTestSupport);
  exporter.execute();
  return outputFilename;
}","private String exportFile(String importedBasename,String genomePath) throws IOException {
  final String outputFilename=FilenameUtils.concat(BASE_TEST_DIR,""String_Node_Str"" + counterSam++ + ""String_Node_Str"");
  CompactToSAMMode exporter=new CompactToSAMMode();
  exporter.setInputBasename(importedBasename);
  exporter.setOutput(outputFilename);
  if (genomePath != null) {
    exporter.setGenome(new PicardFastaIndexedSequence(genomePath));
  }
 else {
    RandomAccessSequenceInterface genomeTestSupport=new RandomAccessSequenceInterface(){
      @Override public char get(      int referenceIndex,      int position){
        return 'A';
      }
      @Override public int getLength(      int targetIndex){
        return Integer.MAX_VALUE;
      }
      @Override public void getRange(      int referenceIndex,      int position,      int length,      MutableString bases){
        bases.setLength(0);
        for (int i=0; i < length; i++) {
          bases.append('A');
        }
      }
      @Override public int getReferenceIndex(      String referenceId){
        return 0;
      }
      @Override public String getReferenceName(      int index){
        return ""String_Node_Str"";
      }
      @Override public int size(){
        return 5;
      }
    }
;
    exporter.setGenome(genomeTestSupport);
  }
  exporter.execute();
  return outputFilename;
}"
50279,"private String importFile(String filename,boolean preserveSoftClips,boolean preserveAllReadQuals) throws IOException {
  SAMToCompactMode importer=new SAMToCompactMode();
  importer.setInputFile(filename);
  final String outputFilename=FilenameUtils.concat(BASE_TEST_DIR,""String_Node_Str"" + counterGoby++);
  importer.setOutputFile(outputFilename);
  importer.setPreserveSoftClips(preserveSoftClips);
  importer.setPreserveReadQualityScores(true);
  importer.setPreserveAllTags(true);
  importer.execute();
  return outputFilename;
}","private String importFile(String filename,boolean preserveSoftClips,boolean preserveAllReadQuals) throws IOException {
  SAMToCompactMode importer=new SAMToCompactMode();
  importer.setInputFile(filename);
  final String outputFilename=FilenameUtils.concat(BASE_TEST_DIR,""String_Node_Str"" + counterGoby++);
  importer.setOutputFile(outputFilename);
  importer.setPreserveReadName(true);
  importer.setPreserveSoftClips(preserveSoftClips);
  importer.setPreserveReadQualityScores(true);
  importer.setPreserveAllTags(true);
  importer.execute();
  return outputFilename;
}"
50280,"@Test public void testEncodeDecodeOneSequence() throws IOException {
  final RandomAccessSequenceInterface cache=new PicardFastaIndexedSequence(""String_Node_Str"");
  int i=0;
  assertEquals('A',cache.get(0,i++));
  assertEquals('C',cache.get(0,i++));
  assertEquals('T',cache.get(0,i++));
  assertEquals('G',cache.get(0,i++));
  assertEquals('N',cache.get(0,i++));
  assertEquals('N',cache.get(0,i++));
  assertEquals('N',cache.get(0,i++));
  assertEquals('A',cache.get(0,i++));
  assertEquals('C',cache.get(0,i++));
  assertEquals('T',cache.get(0,i++));
  assertEquals('G',cache.get(0,i++));
  try {
    cache.get(0,i++);
    fail();
  }
 catch (  AssertionError e) {
  }
}","@Test public void testEncodeDecodeOneSequence() throws IOException {
  final RandomAccessSequenceInterface cache=new PicardFastaIndexedSequence(""String_Node_Str"");
  int i=0;
  assertEquals('A',cache.get(0,i++));
  assertEquals('C',cache.get(0,i++));
  assertEquals('T',cache.get(0,i++));
  assertEquals('G',cache.get(0,i++));
  assertEquals('N',cache.get(0,i++));
  assertEquals('N',cache.get(0,i++));
  assertEquals('N',cache.get(0,i++));
  assertEquals('A',cache.get(0,i++));
  assertEquals('C',cache.get(0,i++));
  assertEquals('T',cache.get(0,i++));
  assertEquals('G',cache.get(0,i++));
  try {
    cache.get(0,i++);
    fail();
  }
 catch (  AssertionError e) {
  }
catch (  StringIndexOutOfBoundsException e) {
  }
}"
50281,"private synchronized void writeStats() throws IOException {
  if (!statsWritten) {
    stats.put(""String_Node_Str"",FilenameUtils.getName(basename));
    stats.put(""String_Node_Str"",Integer.toString(permutator.getBiggestSmallIndex()));
    stats.put(""String_Node_Str"",Integer.toString(permutator.getSmallestIndex()));
    stats.put(""String_Node_Str"",Integer.toString(getNumQueries()));
    stats.put(""String_Node_Str"",basename);
    stats.put(""String_Node_Str"",Integer.toString(numberOfAlignedReads));
    stats.store(statsWriter,""String_Node_Str"");
    statsWritten=true;
  }
}","private synchronized void writeStats() throws IOException {
  if (!statsWritten) {
    stats.put(""String_Node_Str"",FilenameUtils.getName(basename));
    stats.put(""String_Node_Str"",Integer.toString(permutator.getSmallestIndex()));
    stats.put(""String_Node_Str"",Integer.toString(permutator.getBiggestSmallIndex()));
    stats.put(""String_Node_Str"",Integer.toString(getNumQueries()));
    stats.put(""String_Node_Str"",basename);
    stats.put(""String_Node_Str"",Integer.toString(numberOfAlignedReads));
    stats.store(statsWriter,""String_Node_Str"");
    statsWritten=true;
  }
}"
50282,"public void printStats(final PrintStream out){
  this.entriesChunkWriter.printStats(out);
  out.println(""String_Node_Str"" + minQueryIndex);
  out.println(""String_Node_Str"" + maxQueryIndex);
  out.println(""String_Node_Str"" + getNumQueries());
  out.println(""String_Node_Str"" + (maxTargetIndex + 1));
}","public void printStats(final PrintStream out){
  this.entriesChunkWriter.printStats(out);
  out.println(""String_Node_Str"" + permutator.getSmallestIndex());
  out.println(""String_Node_Str"" + permutator.getBiggestSmallIndex());
  out.println(""String_Node_Str"" + getNumQueries());
  out.println(""String_Node_Str"" + (maxTargetIndex + 1));
}"
50283,"/** 
 * Before each file, reset the state, report the filename about to be processed.
 * @param inputFilename the filename to be processed.
 */
private void processingStart(final String inputFilename){
  System.out.printf(""String_Node_Str"",inputFilename);
  numQualScoresSampled=0;
  sumQualScores=0;
  minQualScore=Integer.MAX_VALUE;
  maxQualScore=Integer.MIN_VALUE;
}","/** 
 * Before each file, reset the state, report the filename about to be processed.
 * @param inputFilename the filename to be processed.
 */
private void processingStart(final String inputFilename){
  System.out.printf(""String_Node_Str"",inputFilename);
  numQualScoresSampled=0;
  sumQualScores=0;
  minQualScore=Integer.MAX_VALUE;
  maxQualScore=Integer.MIN_VALUE;
  qualityScoresFound=false;
}"
50284,"/** 
 * Process ONE compact-reads file.
 * @param inputFilename the filename to process
 * @return the number of read entries processed
 * @throws IOException error reading file
 */
private int processCompactReadsFile(final String inputFilename) throws IOException {
  int i=0;
  for (  final Reads.ReadEntry entry : new ReadsReader(inputFilename)) {
    final byte[] qualityScores=entry.getQualityScores().toByteArray();
    final boolean hasQualityScores=entry.hasQualityScores() && !ArrayUtils.isEmpty(qualityScores);
    if (hasQualityScores) {
      for (      final int qualScore : qualityScores) {
        minQualScore=Math.min(qualScore,minQualScore);
        maxQualScore=Math.max(qualScore,maxQualScore);
        numQualScoresSampled++;
        sumQualScores+=Math.abs(qualScore);
      }
      if (++i == numberOfReadEntriesToProcess) {
        break;
      }
    }
  }
  return i;
}","/** 
 * Process ONE compact-reads file.
 * @param inputFilename the filename to process
 * @return the number of read entries processed
 * @throws IOException error reading file
 */
private int processCompactReadsFile(final String inputFilename) throws IOException {
  int i=0;
  for (  final Reads.ReadEntry entry : new ReadsReader(inputFilename)) {
    final byte[] qualityScores=entry.getQualityScores().toByteArray();
    final boolean hasQualityScores=entry.hasQualityScores() && !ArrayUtils.isEmpty(qualityScores);
    if (hasQualityScores) {
      qualityScoresFound=true;
      for (      final int qualScore : qualityScores) {
        minQualScore=Math.min(qualScore,minQualScore);
        maxQualScore=Math.max(qualScore,maxQualScore);
        numQualScoresSampled++;
        sumQualScores+=Math.abs(qualScore);
      }
      if (++i == numberOfReadEntriesToProcess) {
        break;
      }
    }
  }
  return i;
}"
50285,"/** 
 * Process ONE FASTQ file.
 * @param inputFilename the filename to process
 * @return the number of read entries processed
 * @throws IOException error reading file
 */
private int processFastqFile(final String inputFilename) throws IOException {
  int i=0;
  for (  final FastXEntry entry : new FastXReader(inputFilename)) {
    final MutableString quality=entry.getQuality();
    if (quality.length() != 0) {
      for (      final int qualScore : quality.array()) {
        minQualScore=Math.min(qualScore,minQualScore);
        maxQualScore=Math.max(qualScore,maxQualScore);
        numQualScoresSampled++;
        sumQualScores+=Math.abs(qualScore);
      }
      if (++i == numberOfReadEntriesToProcess) {
        break;
      }
    }
  }
  return i;
}","/** 
 * Process ONE FASTQ file.
 * @param inputFilename the filename to process
 * @return the number of read entries processed
 * @throws IOException error reading file
 */
private int processFastqFile(final String inputFilename) throws IOException {
  int i=0;
  for (  final FastXEntry entry : new FastXReader(inputFilename)) {
    final MutableString quality=entry.getQuality();
    if (quality.length() != 0) {
      qualityScoresFound=true;
      for (      final int qualScore : quality.array()) {
        minQualScore=Math.min(qualScore,minQualScore);
        maxQualScore=Math.max(qualScore,maxQualScore);
        numQualScoresSampled++;
        sumQualScores+=Math.abs(qualScore);
      }
      if (++i == numberOfReadEntriesToProcess) {
        break;
      }
    }
  }
  return i;
}"
50286,"/** 
 * After each file, report the details for the file.
 * @param numEntries the number of read entries processed.
 */
private void processingEnd(final int numEntries){
  System.out.printf(""String_Node_Str"",numEntries);
  final int avgQualScore=(int)(sumQualScores / numQualScoresSampled);
  final String likelyEncoding;
  if (avgQualScore <= 41) {
    likelyEncoding=""String_Node_Str"";
  }
 else   if (avgQualScore <= 83) {
    likelyEncoding=""String_Node_Str"";
  }
 else {
    likelyEncoding=""String_Node_Str"";
  }
  System.out.printf(""String_Node_Str"",minQualScore);
  System.out.printf(""String_Node_Str"",maxQualScore);
  System.out.printf(""String_Node_Str"",avgQualScore);
  System.out.printf(""String_Node_Str"",likelyEncoding);
  likelyEncodings.add(likelyEncoding);
  avgQualScores.add(avgQualScore);
}","/** 
 * After each file, report the details for the file.
 * @param numEntries the number of read entries processed.
 */
private void processingEnd(final int numEntries){
  System.out.printf(""String_Node_Str"",numEntries);
  final int avgQualScore=(int)(sumQualScores / numQualScoresSampled);
  final String likelyEncoding;
  if (!qualityScoresFound) {
    likelyEncoding=""String_Node_Str"";
  }
 else   if (avgQualScore <= 41) {
    likelyEncoding=""String_Node_Str"";
  }
 else   if (avgQualScore <= 83) {
    likelyEncoding=""String_Node_Str"";
  }
 else {
    likelyEncoding=""String_Node_Str"";
  }
  System.out.printf(""String_Node_Str"",minQualScore);
  System.out.printf(""String_Node_Str"",maxQualScore);
  System.out.printf(""String_Node_Str"",avgQualScore);
  System.out.printf(""String_Node_Str"",likelyEncoding);
  likelyEncodings.add(likelyEncoding);
  avgQualScores.add(avgQualScore);
}"
50287,"/** 
 * Make comparisons of every record at a specific alignment start position.
 * @return The total of the comparison failures for all of the records compared
 */
private int makeComparisons(){
  int resultSum=0;
  if (!sources.isEmpty()) {
    for (    final SAMRecord source : sources) {
      SAMRecord dest=null;
      Alignments.AlignmentEntry gobyDest=null;
      final String sourceClippedRead=usableReadOf(source);
      final LinkedList<Integer> indexesList=destclippedReadToIndexesMap.get(sourceClippedRead);
      int leastDiffIndex=-1;
      int leastDiffValue=Integer.MAX_VALUE;
      if (indexesList != null) {
        final boolean tempOutputFailedComparisons=outputFailedComparisons;
        final int tempComparisonFailureCount=comparisonFailureCount;
        outputFailedComparisons=false;
        for (        final int currentDestIndex : indexesList) {
          dest=dests.get(currentDestIndex);
          if (!gobyDests.isEmpty()) {
            gobyDest=gobyDests.get(currentDestIndex);
          }
          final int currentDiffValue=super.compare(source,dest,gobyDest);
          if (currentDiffValue < leastDiffValue) {
            leastDiffValue=currentDiffValue;
            leastDiffIndex=currentDestIndex;
            if (currentDiffValue == 0) {
              break;
            }
          }
        }
        outputFailedComparisons=tempOutputFailedComparisons;
        comparisonFailureCount=tempComparisonFailureCount;
        if (leastDiffIndex != -1) {
          indexesList.removeFirstOccurrence(leastDiffIndex);
          if (leastDiffValue > 0) {
            super.compare(source,dest,gobyDest);
            if (outputFailedComparisons) {
              dest=dests.get(leastDiffIndex);
              if (!gobyDests.isEmpty()) {
                gobyDest=gobyDests.get(leastDiffIndex);
              }
              dumpComparison(source,dest,gobyDest);
            }
          }
        }
      }
      if (leastDiffIndex == -1) {
        readNum++;
        comparisonFailureCount++;
        System.out.println(""String_Node_Str"" + source.getReadName());
      }
 else {
        resultSum+=leastDiffValue;
      }
    }
  }
  resetForPosition();
  return resultSum;
}","/** 
 * Make comparisons of every record at a specific alignment start position.
 * @return The total of the comparison failures for all of the records compared
 */
private int makeComparisons(){
  int resultSum=0;
  if (!sources.isEmpty()) {
    for (    final SAMRecord source : sources) {
      SAMRecord dest=null;
      Alignments.AlignmentEntry gobyDest=null;
      final String sourceClippedRead=usableReadOf(source);
      final LinkedList<Integer> indexesList=destclippedReadToIndexesMap.get(sourceClippedRead);
      int leastDiffIndex=-1;
      int leastDiffValue=Integer.MAX_VALUE;
      if (indexesList != null) {
        final boolean tempOutputFailedComparisons=outputFailedComparisons;
        final int tempComparisonFailureCount=comparisonFailureCount;
        outputFailedComparisons=false;
        for (        final int currentDestIndex : indexesList) {
          dest=dests.get(currentDestIndex);
          if (!gobyDests.isEmpty()) {
            gobyDest=gobyDests.get(currentDestIndex);
          }
          final int currentDiffValue=super.compare(source,dest,gobyDest);
          if (currentDiffValue < leastDiffValue) {
            leastDiffValue=currentDiffValue;
            leastDiffIndex=currentDestIndex;
            if (currentDiffValue == 0) {
              break;
            }
          }
        }
        outputFailedComparisons=tempOutputFailedComparisons;
        comparisonFailureCount=tempComparisonFailureCount;
        if (leastDiffIndex != -1) {
          indexesList.removeFirstOccurrence(leastDiffIndex);
          if (leastDiffValue > 0) {
            if (outputFailedComparisons) {
              dest=dests.get(leastDiffIndex);
              if (!gobyDests.isEmpty()) {
                gobyDest=gobyDests.get(leastDiffIndex);
              }
              super.compare(source,dest,gobyDest);
              dumpComparison(source,dest,gobyDest);
            }
          }
        }
      }
      if (leastDiffIndex == -1) {
        readNum++;
        comparisonFailureCount++;
        System.out.println(""String_Node_Str"" + source.getReadName());
      }
 else {
        resultSum+=leastDiffValue;
      }
    }
  }
  resetForPosition();
  return resultSum;
}"
50288,"private void alignmentToReadSet(final String basename) throws IOException {
  final AlignmentReaderImpl reader=new AlignmentReaderImpl(basename);
  reader.readHeader();
  final ReadSet outputSet=new ReadSet();
  final int maxQueryIndex=reader.getSmallestSplitQueryIndex();
  final int minQueryIndex=reader.getLargestSplitQueryIndex();
  final IntSet matchingIndices=new IntOpenHashSet();
  for (  final Alignments.AlignmentEntry entry : reader) {
    final int queryIndex=entry.getQueryIndex();
    matchingIndices.add(queryIndex);
  }
  final boolean alignmentHasPermutation=reader.getQueryIndicesWerePermuted();
  final PermutationReaderInterface permReader=alignmentHasPermutation ? new PermutationReader(basename) : new NoOpPermutationReader();
  reader.close();
  final AlignmentTooManyHitsReader tmhReader=new AlignmentTooManyHitsReader(basename);
  for (int smallIndex=minQueryIndex; smallIndex <= maxQueryIndex; ++smallIndex) {
    final int queryIndex=permReader.getQueryIndex(smallIndex);
    if (matchingReads) {
      if (matchingIndices.contains(smallIndex)) {
        if (passesTmhFilter(tmhReader,smallIndex)) {
          if (preFilter == null || preFilter.contains(queryIndex)) {
            outputSet.add(queryIndex,1);
          }
        }
      }
    }
    if (nonMatchingReads) {
      if (!matchingIndices.contains(smallIndex)) {
        if (passesTmhFilter(tmhReader,smallIndex)) {
          if (preFilter == null || preFilter.contains(queryIndex)) {
            outputSet.add(queryIndex,1);
          }
        }
      }
    }
  }
  outputSet.save(basename,suffix);
  System.out.printf(""String_Node_Str"",outputSet.size());
}","private void alignmentToReadSet(final String basename) throws IOException {
  final AlignmentReaderImpl reader=new AlignmentReaderImpl(basename);
  reader.readHeader();
  final ReadSet outputSet=new ReadSet();
  final int minQueryIndex=reader.getSmallestSplitQueryIndex();
  final int maxQueryIndex=reader.getLargestSplitQueryIndex();
  final IntSet matchingIndices=new IntOpenHashSet();
  for (  final Alignments.AlignmentEntry entry : reader) {
    final int queryIndex=entry.getQueryIndex();
    matchingIndices.add(queryIndex);
  }
  final boolean alignmentHasPermutation=reader.getQueryIndicesWerePermuted();
  final PermutationReaderInterface permReader=alignmentHasPermutation ? new PermutationReader(basename) : new NoOpPermutationReader();
  reader.close();
  final AlignmentTooManyHitsReader tmhReader=new AlignmentTooManyHitsReader(basename);
  for (int smallIndex=minQueryIndex; smallIndex <= maxQueryIndex; ++smallIndex) {
    final int queryIndex=permReader.getQueryIndex(smallIndex);
    if (matchingReads) {
      if (matchingIndices.contains(smallIndex)) {
        if (passesTmhFilter(tmhReader,smallIndex)) {
          if (preFilter == null || preFilter.contains(queryIndex)) {
            outputSet.add(queryIndex,1);
          }
        }
      }
    }
    if (nonMatchingReads) {
      if (!matchingIndices.contains(smallIndex)) {
        if (passesTmhFilter(tmhReader,smallIndex)) {
          if (preFilter == null || preFilter.contains(queryIndex)) {
            outputSet.add(queryIndex,1);
          }
        }
      }
    }
  }
  outputSet.save(basename,suffix);
  System.out.printf(""String_Node_Str"",outputSet.size());
}"
50289,"/** 
 * This version does a quick concat. It does NO filtering. It gathers no stats, but, will quickly concat multiple compact-reads files together using NIO. It should be noted that this method is >MUCH< faster. Copy all of the input files except the last MessageChunksWriter.DELIMITER_LENGTH bytes of the first n-1 input files and the entire last input file to the output file.
 * @throws IOException
 */
private void performQuickConcat() throws IOException {
  System.out.println(""String_Node_Str"");
  File outputFile=new File(outputFilename);
  if (outputFile.exists()) {
    System.err.println(""String_Node_Str"");
    return;
  }
  outputFile.createNewFile();
  FileChannel input=null;
  FileChannel output=null;
  long maxChunkSize=10 * 1024 * 1024;
  try {
    output=new FileOutputStream(outputFile).getChannel();
    int lastFileNumToCopy=inputFiles.size() - 1;
    int curFileNum=0;
    for (    final File inputFile : inputFiles) {
      System.out.printf(""String_Node_Str"",inputFile);
      input=new FileInputStream(inputFile).getChannel();
      long bytesToCopy=input.size();
      if (curFileNum++ < lastFileNumToCopy) {
        bytesToCopy-=(MessageChunksWriter.DELIMITER_LENGTH + MessageChunksWriter.SIZE_OF_MESSAGE_LENGTH);
      }
      long position=0;
      while (position < bytesToCopy) {
        long bytesToCopyThisTime=Math.min(maxChunkSize,bytesToCopy - position);
        position+=input.transferTo(position,bytesToCopyThisTime,output);
      }
      input.close();
      input=null;
    }
    System.out.printf(""String_Node_Str"",lastFileNumToCopy + 1);
  }
  finally {
    if (input != null) {
      input.close();
    }
    if (output != null) {
      output.close();
    }
  }
}","/** 
 * This version does a quick concat. It does NO filtering. It gathers no stats, but, will quickly concat multiple compact-reads files together using NIO. It should be noted that this method is >MUCH< faster. Copy all of the input files except the last MessageChunksWriter.DELIMITER_LENGTH bytes of the first n-1 input files and the entire last input file to the output file.
 * @throws IOException
 */
private void performQuickConcat() throws IOException {
  System.out.println(""String_Node_Str"");
  File outputFile=new File(outputFilename);
  if (outputFile.exists()) {
    System.err.println(""String_Node_Str"");
    return;
  }
  outputFile.createNewFile();
  FileChannel input=null;
  FileChannel output=null;
  long maxChunkSize=10 * 1024 * 1024;
  try {
    output=new FileOutputStream(outputFile).getChannel();
    int lastFileNumToCopy=inputFiles.size() - 1;
    int curFileNum=0;
    for (    final File inputFile : inputFiles) {
      System.out.printf(""String_Node_Str"",inputFile);
      input=new FileInputStream(inputFile).getChannel();
      long bytesToCopy=input.size();
      if (curFileNum++ < lastFileNumToCopy) {
        bytesToCopy-=(MessageChunksWriter.DELIMITER_LENGTH + 1 + MessageChunksWriter.SIZE_OF_MESSAGE_LENGTH);
      }
      long position=0;
      while (position < bytesToCopy) {
        long bytesToCopyThisTime=Math.min(maxChunkSize,bytesToCopy - position);
        position+=input.transferTo(position,bytesToCopyThisTime,output);
      }
      input.close();
      input=null;
    }
    System.out.printf(""String_Node_Str"",lastFileNumToCopy + 1);
  }
  finally {
    if (input != null) {
      input.close();
    }
    if (output != null) {
      output.close();
    }
  }
}"
50290,"/** 
 * Support for splitting the entries on the file system. Seek the input to start and start looking for the beginning of a new collection. When found, return all entries in the collection through hasNext, next(). Will possibly return additional collection of entries, but will stop returning new entries if the position in the input stream is past end.
 * @param start The start index for the split
 * @param end   The end index for the split
 * @param input The input stream containing the data
 * @throws IOException if there is a problem reading from the stream
 */
public FastBufferedMessageChunksReader(final long start,long end,final FastBufferedInputStream input) throws IOException {
  super();
  this.startOffset=start;
  this.endOffset=end;
  if (start < 0L) {
    throw new IllegalArgumentException(""String_Node_Str"" + start + ""String_Node_Str"");
  }
  if (end != Long.MAX_VALUE && end < 0L) {
    throw new IllegalArgumentException(""String_Node_Str"" + end + ""String_Node_Str"");
  }
  if (start > end) {
    throw new IllegalArgumentException(""String_Node_Str"" + start + ""String_Node_Str""+ end+ ""String_Node_Str"");
  }
  if (end != Long.MAX_VALUE && start != end) {
    end+=MessageChunksWriter.DELIMITER_LENGTH + 4;
  }
  this.end=end;
  this.input=input;
  reposition(start,end);
}","/** 
 * Support for splitting the entries on the file system. Seek the input to start and start looking for the beginning of a new collection. When found, return all entries in the collection through hasNext, next(). Will possibly return additional collection of entries, but will stop returning new entries if the position in the input stream is past end.
 * @param start The start index for the split
 * @param end   The end index for the split
 * @param input The input stream containing the data
 * @throws IOException if there is a problem reading from the stream
 */
public FastBufferedMessageChunksReader(final long start,long end,final FastBufferedInputStream input) throws IOException {
  super();
  this.startOffset=start;
  this.endOffset=end;
  if (start < 0L) {
    throw new IllegalArgumentException(""String_Node_Str"" + start + ""String_Node_Str"");
  }
  if (end != Long.MAX_VALUE && end < 0L) {
    throw new IllegalArgumentException(""String_Node_Str"" + end + ""String_Node_Str"");
  }
  if (start > end) {
    throw new IllegalArgumentException(""String_Node_Str"" + start + ""String_Node_Str""+ end+ ""String_Node_Str"");
  }
  if (end != Long.MAX_VALUE && start != end) {
    end+=MessageChunksWriter.DELIMITER_LENGTH + 4;
  }
  this.end=end;
  this.input=input;
  supportedCodecRegistrationCodes=ChunkCodecHelper.registrationCodes();
  reposition(start,end);
}"
50291,"/** 
 * Record all intra-group sample pairs for latter use.
 * @param groupIndex
 */
public void recordPairForGroup(int groupIndex){
  samplePairsForGroup[groupIndex]=new ObjectArrayList<SamplePair>();
  IntSet sampleIndicesInGroup=new IntAVLTreeSet();
  for (int sampleIndex=0; sampleIndex < numSamples; sampleIndex++) {
    if (sampleIndexToGroupIndex[sampleIndex] == groupIndex) {
      sampleIndicesInGroup.add(sampleIndex);
    }
  }
  for (  int sampleIndexA : sampleIndicesInGroup) {
    for (    int sampleIndexB : sampleIndicesInGroup) {
      if (sampleIndexA < sampleIndexB) {
        samplePairsForGroup[groupIndex].add(new SamplePair(sampleIndexA,sampleIndexB));
      }
    }
  }
}","/** 
 * Record all intra-group sample pairs for latter use.
 * @param groupIndex
 */
public void recordPairForGroup(int groupIndex){
  samplePairsForGroup[groupIndex]=new ObjectArrayList<SamplePair>();
  IntSet sampleIndicesInGroup=new IntAVLTreeSet();
  for (int sampleIndex=0; sampleIndex < numSamples; sampleIndex++) {
    if (sampleIndexToGroupIndex[sampleIndex] == groupIndex) {
      sampleIndicesInGroup.add(sampleIndex);
    }
  }
  final ObjectArraySet<SamplePair> set=new ObjectArraySet<SamplePair>();
  for (  final int sampleIndexA : sampleIndicesInGroup) {
    for (    final int sampleIndexB : sampleIndicesInGroup) {
      if (sampleIndexA != sampleIndexB) {
        set.add(new SamplePair(sampleIndexA,sampleIndexB));
      }
    }
  }
  samplePairsForGroup[groupIndex].addAll(set);
}"
50292,"private void buildAnnotationRecordForOutput(String chromosome,int pos,int anno){
  if (annotations.pastChosenAnnotation(anno,chromosome,pos)) {
    Annotation annoOut=annotations.getAnnotation(anno);
    FormatFieldCounter counter=counterMap.get(anno);
    StringBuilder lineToOutput=new StringBuilder(""String_Node_Str"");
    try {
      if (writeObservations) {
        identifiers[0]=""String_Node_Str"";
        identifiers[1]=annoOut.getChromosome();
        identifiers[2]=String.valueOf(annoOut.getStart());
        identifiers[3]=String.valueOf(annoOut.getEnd());
        identifiers[4]=annoOut.getId();
        obsWriter.setElementIds(identifiers);
      }
      lineToOutput.append(annoOut.getChromosome());
      lineToOutput.append(""String_Node_Str"");
      lineToOutput.append(String.valueOf(annoOut.getStart()));
      lineToOutput.append(""String_Node_Str"");
      lineToOutput.append(String.valueOf(annoOut.getEnd())).append(""String_Node_Str"");
      lineToOutput.append(annoOut.getId());
      if (writeCounts) {
        for (int currentContext=0; currentContext < contexts.length; currentContext++) {
          for (int sampleIndex=0; sampleIndex < numSamples; sampleIndex++) {
            lineToOutput.append(""String_Node_Str"");
            final int unMethylatedCCounterPerSample=counter.getUnmethylatedCCountPerSample(currentContext,sampleIndex);
            lineToOutput.append(unMethylatedCCounterPerSample);
          }
        }
        for (int currentContext=0; currentContext < contexts.length; currentContext++) {
          for (int sampleIndex=0; sampleIndex < numSamples; sampleIndex++) {
            lineToOutput.append(""String_Node_Str"");
            final int methylatedCCounterPerSample=counter.getMethylatedCCountPerSample(currentContext,sampleIndex);
            lineToOutput.append(methylatedCCounterPerSample);
          }
        }
      }
      for (int currentContext=0; currentContext < contexts.length; currentContext++) {
        for (int sampleIndex=0; sampleIndex < numSamples; sampleIndex++) {
          lineToOutput.append(""String_Node_Str"");
          final double methylationRatePerSample=counter.getMethylationRatePerSample(currentContext,sampleIndex);
          lineToOutput.append(formatDouble(methylationRatePerSample));
        }
      }
      if (writeCounts) {
        for (int currentContext=0; currentContext < contexts.length; currentContext++) {
          for (int groupIndex=0; groupIndex < numGroups; groupIndex++) {
            lineToOutput.append(""String_Node_Str"");
            final int unMethylatedCCounterPerGroup=counter.getUnmethylatedCcountPerGroup(currentContext,groupIndex);
            lineToOutput.append(unMethylatedCCounterPerGroup);
          }
        }
        for (int currentContext=0; currentContext < contexts.length; currentContext++) {
          for (int groupIndex=0; groupIndex < numGroups; groupIndex++) {
            lineToOutput.append(""String_Node_Str"");
            final int methylatedCCounterPerGroup=counter.getMethylatedCCountPerGroup(currentContext,groupIndex);
            lineToOutput.append(methylatedCCounterPerGroup);
          }
        }
      }
      for (int currentContext=0; currentContext < contexts.length; currentContext++) {
        for (int groupIndex=0; groupIndex < numGroups; groupIndex++) {
          lineToOutput.append(""String_Node_Str"");
          lineToOutput.append(formatDouble(counter.getMethylationRatePerGroup(currentContext,groupIndex)));
        }
      }
      if (writeNumSites) {
        for (int currentContext=0; currentContext < contexts.length; currentContext++) {
          for (int sampleIndex=0; sampleIndex < numSamples; sampleIndex++) {
            lineToOutput.append(""String_Node_Str"");
            final int numSitesPerSample=counter.getNumberOfSitesPerSample(currentContext,sampleIndex);
            lineToOutput.append(numSitesPerSample);
          }
        }
        for (int currentContext=0; currentContext < contexts.length; currentContext++) {
          for (int groupIndex=0; groupIndex < numGroups; groupIndex++) {
            lineToOutput.append(""String_Node_Str"");
            final int numSitesPerGroup=counter.getNumberOfSitesPerGroup(currentContext,groupIndex);
            lineToOutput.append(numSitesPerGroup);
          }
        }
      }
      for (int currentContext=0; currentContext < contexts.length; currentContext++) {
        for (        final GroupComparison comparison : groupComparisons) {
          final int indexGroup1=comparison.indexGroup1;
          final int indexGroup2=comparison.indexGroup2;
          double fisherP=Double.NaN;
          final boolean ok=checkCounts(counter,currentContext);
          if (ok) {
            fisherP=fisherRInstalled ? FisherExactRCalculator.getFisherPValue(counter.getUnmethylatedCcountPerGroup(currentContext,indexGroup1),counter.getMethylatedCCountPerGroup(currentContext,indexGroup1),counter.getUnmethylatedCcountPerGroup(currentContext,indexGroup2),counter.getMethylatedCCountPerGroup(currentContext,indexGroup2)) : Double.NaN;
          }
 else {
            LOG.error(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",counter.getUnmethylatedCcountPerGroup(currentContext,indexGroup1),counter.getMethylatedCCountPerGroup(currentContext,indexGroup1),counter.getUnmethylatedCcountPerGroup(currentContext,indexGroup2),counter.getMethylatedCCountPerGroup(currentContext,indexGroup2)));
          }
          lineToOutput.append(""String_Node_Str"");
          lineToOutput.append(formatDouble(fisherP));
        }
      }
      for (int currentContext=0; currentContext < contexts.length; currentContext++) {
        for (        final GroupComparison comparison : groupComparisons) {
          final int indexGroup1=comparison.indexGroup1;
          final int indexGroup2=comparison.indexGroup2;
          final double deltaMR=Math.abs(counter.getMethylationRatePerGroup(currentContext,indexGroup1) - counter.getMethylationRatePerGroup(currentContext,indexGroup2));
          lineToOutput.append(""String_Node_Str"");
          lineToOutput.append(formatDouble(deltaMR));
        }
      }
      if (estimateIntraGroupDifferences) {
        obsWriter.setTypeOfPair(ObservationWriter.TypeOfPair.WITHIN_GROUP_PAIR);
        for (int currentContext=0; currentContext < contexts.length; currentContext++) {
          identifiers[0]=contexts[currentContext];
          for (          final GroupComparison comparison : groupComparisons) {
            obsWriter.setNullComparison(comparison.nameGroup1);
            empiricalPValueEstimator.estimateNullDensity(currentContext,comparison.indexGroup1,counter);
            obsWriter.setNullComparison(comparison.nameGroup2);
            empiricalPValueEstimator.estimateNullDensity(currentContext,comparison.indexGroup2,counter);
          }
        }
      }
      if (estimateIntraGroupP) {
        obsWriter.setTypeOfPair(ObservationWriter.TypeOfPair.BETWEEN_GROUP_PAIR);
        for (int contextIndex=0; contextIndex < contexts.length; contextIndex++) {
          identifiers[0]=contexts[contextIndex];
          for (          final GroupComparison comparison : groupComparisons) {
            obsWriter.setComparison(comparison);
            final double p=empiricalPValueEstimator.estimateEmpiricalPValue(contextIndex,comparison,counter);
            lineToOutput.append(""String_Node_Str"");
            lineToOutput.append(formatDouble(p));
          }
        }
      }
      outputWriter.append(lineToOutput.toString());
      outputWriter.append(""String_Node_Str"");
      counterMap.remove(anno);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
}","private void buildAnnotationRecordForOutput(String chromosome,int pos,int anno){
  if (annotations.pastChosenAnnotation(anno,chromosome,pos)) {
    Annotation annoOut=annotations.getAnnotation(anno);
    FormatFieldCounter counter=counterMap.get(anno);
    StringBuilder lineToOutput=new StringBuilder(""String_Node_Str"");
    try {
      if (writeObservations) {
        identifiers[0]=""String_Node_Str"";
        identifiers[1]=annoOut.getChromosome();
        identifiers[2]=String.valueOf(annoOut.getStart());
        identifiers[3]=String.valueOf(annoOut.getEnd());
        identifiers[4]=annoOut.getId();
        obsWriter.setElementIds(identifiers);
      }
      lineToOutput.append(annoOut.getChromosome());
      lineToOutput.append(""String_Node_Str"");
      lineToOutput.append(String.valueOf(annoOut.getStart()));
      lineToOutput.append(""String_Node_Str"");
      lineToOutput.append(String.valueOf(annoOut.getEnd())).append(""String_Node_Str"");
      lineToOutput.append(annoOut.getId());
      if (writeCounts) {
        for (int currentContext=0; currentContext < contexts.length; currentContext++) {
          for (int sampleIndex=0; sampleIndex < numSamples; sampleIndex++) {
            lineToOutput.append(""String_Node_Str"");
            final int unMethylatedCCounterPerSample=counter.getUnmethylatedCCountPerSample(currentContext,sampleIndex);
            lineToOutput.append(unMethylatedCCounterPerSample);
          }
        }
        for (int currentContext=0; currentContext < contexts.length; currentContext++) {
          for (int sampleIndex=0; sampleIndex < numSamples; sampleIndex++) {
            lineToOutput.append(""String_Node_Str"");
            final int methylatedCCounterPerSample=counter.getMethylatedCCountPerSample(currentContext,sampleIndex);
            lineToOutput.append(methylatedCCounterPerSample);
          }
        }
      }
      for (int currentContext=0; currentContext < contexts.length; currentContext++) {
        for (int sampleIndex=0; sampleIndex < numSamples; sampleIndex++) {
          lineToOutput.append(""String_Node_Str"");
          final double methylationRatePerSample=counter.getMethylationRatePerSample(currentContext,sampleIndex);
          lineToOutput.append(formatDouble(methylationRatePerSample));
        }
      }
      if (writeCounts) {
        for (int currentContext=0; currentContext < contexts.length; currentContext++) {
          for (int groupIndex=0; groupIndex < numGroups; groupIndex++) {
            lineToOutput.append(""String_Node_Str"");
            final int unMethylatedCCounterPerGroup=counter.getUnmethylatedCcountPerGroup(currentContext,groupIndex);
            lineToOutput.append(unMethylatedCCounterPerGroup);
          }
        }
        for (int currentContext=0; currentContext < contexts.length; currentContext++) {
          for (int groupIndex=0; groupIndex < numGroups; groupIndex++) {
            lineToOutput.append(""String_Node_Str"");
            final int methylatedCCounterPerGroup=counter.getMethylatedCCountPerGroup(currentContext,groupIndex);
            lineToOutput.append(methylatedCCounterPerGroup);
          }
        }
      }
      for (int currentContext=0; currentContext < contexts.length; currentContext++) {
        for (int groupIndex=0; groupIndex < numGroups; groupIndex++) {
          lineToOutput.append(""String_Node_Str"");
          lineToOutput.append(formatDouble(counter.getMethylationRatePerGroup(currentContext,groupIndex)));
        }
      }
      if (writeNumSites) {
        for (int currentContext=0; currentContext < contexts.length; currentContext++) {
          for (int sampleIndex=0; sampleIndex < numSamples; sampleIndex++) {
            lineToOutput.append(""String_Node_Str"");
            final int numSitesPerSample=counter.getNumberOfSitesPerSample(currentContext,sampleIndex);
            lineToOutput.append(numSitesPerSample);
          }
        }
        for (int currentContext=0; currentContext < contexts.length; currentContext++) {
          for (int groupIndex=0; groupIndex < numGroups; groupIndex++) {
            lineToOutput.append(""String_Node_Str"");
            final int numSitesPerGroup=counter.getNumberOfSitesPerGroup(currentContext,groupIndex);
            lineToOutput.append(numSitesPerGroup);
          }
        }
      }
      for (int currentContext=0; currentContext < contexts.length; currentContext++) {
        for (        final GroupComparison comparison : groupComparisons) {
          final int indexGroup1=comparison.indexGroup1;
          final int indexGroup2=comparison.indexGroup2;
          double fisherP=Double.NaN;
          final boolean ok=checkCounts(counter,currentContext);
          if (ok) {
            fisherP=fisherRInstalled ? FisherExactRCalculator.getFisherPValue(counter.getUnmethylatedCcountPerGroup(currentContext,indexGroup1),counter.getMethylatedCCountPerGroup(currentContext,indexGroup1),counter.getUnmethylatedCcountPerGroup(currentContext,indexGroup2),counter.getMethylatedCCountPerGroup(currentContext,indexGroup2)) : Double.NaN;
          }
 else {
            LOG.error(String.format(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",counter.getUnmethylatedCcountPerGroup(currentContext,indexGroup1),counter.getMethylatedCCountPerGroup(currentContext,indexGroup1),counter.getUnmethylatedCcountPerGroup(currentContext,indexGroup2),counter.getMethylatedCCountPerGroup(currentContext,indexGroup2)));
          }
          lineToOutput.append(""String_Node_Str"");
          lineToOutput.append(formatDouble(fisherP));
        }
      }
      for (int currentContext=0; currentContext < contexts.length; currentContext++) {
        for (        final GroupComparison comparison : groupComparisons) {
          final int indexGroup1=comparison.indexGroup1;
          final int indexGroup2=comparison.indexGroup2;
          final double deltaMR=Math.abs(counter.getMethylationRatePerGroup(currentContext,indexGroup1) - counter.getMethylationRatePerGroup(currentContext,indexGroup2));
          lineToOutput.append(""String_Node_Str"");
          lineToOutput.append(formatDouble(deltaMR));
        }
      }
      if (estimateIntraGroupDifferences) {
        obsWriter.setTypeOfPair(ObservationWriter.TypeOfPair.WITHIN_GROUP_PAIR);
        for (int currentContext=0; currentContext < contexts.length; currentContext++) {
          identifiers[0]=contexts[currentContext];
          int groupIndex=0;
          for (          String group : groups) {
            empiricalPValueEstimator.estimateNullDensity(currentContext,groupIndex,counter);
            groupIndex++;
          }
        }
      }
      if (estimateIntraGroupP) {
        obsWriter.setTypeOfPair(ObservationWriter.TypeOfPair.BETWEEN_GROUP_PAIR);
        for (int contextIndex=0; contextIndex < contexts.length; contextIndex++) {
          identifiers[0]=contexts[contextIndex];
          for (          final GroupComparison comparison : groupComparisons) {
            obsWriter.setComparison(comparison);
            final double p=empiricalPValueEstimator.estimateEmpiricalPValue(contextIndex,comparison,counter);
            lineToOutput.append(""String_Node_Str"");
            lineToOutput.append(formatDouble(p));
          }
        }
      }
      outputWriter.append(lineToOutput.toString());
      outputWriter.append(""String_Node_Str"");
      counterMap.remove(anno);
    }
 catch (    IOException e) {
      throw new RuntimeException(e);
    }
  }
}"
50293,"/** 
 * Read the header of this alignment.
 * @throws java.io.IOException If an error occurs.
 */
@Override public final void readHeader() throws IOException {
  if (!isHeaderLoaded()) {
    final IntSet targetNumbers=new IntArraySet();
    int readerIndex=0;
    ObjectList<String> alignerNames=new ObjectArrayList<String>();
    ObjectList<String> alignerVersions=new ObjectArrayList<String>();
    numberOfQueries=0;
    smallestQueryIndex=Integer.MAX_VALUE;
    largestQueryIndex=adjustQueryIndices ? Integer.MIN_VALUE : 0;
    readOriginPermutations=new int[readers.length][];
    for (    final AlignmentReader reader : readers) {
      reader.readHeader();
      String alignerName=reader.getAlignerName();
      String alignerVersion=reader.getAlignerVersion();
      if (!(alignerNames.contains(alignerName) && alignerVersions.contains(alignerVersion))) {
        alignerNames.add(alignerName);
        alignerVersions.add(alignerVersion);
      }
      smallestQueryIndex=Math.min(reader.getSmallestSplitQueryIndex(),smallestQueryIndex);
      largestQueryIndex=adjustQueryIndices ? Math.max(largestQueryIndex,0) + 1 + reader.getLargestSplitQueryIndex() : Math.max(reader.getLargestSplitQueryIndex(),largestQueryIndex);
      targetNumbers.add(reader.getNumberOfTargets());
      final int numQueriesForReader=reader.getNumberOfQueries();
      numQueriesPerReader[readerIndex]=numQueriesForReader;
      numberOfQueries+=numQueriesForReader;
      numberOfAlignedReads+=reader.getNumberOfAlignedReads();
      mergeReadOrigins(readerIndex,reader.getReadOriginInfo().getPbList());
      readerIndex++;
    }
    alignerName=alignerNames.toString();
    alignerVersion=alignerVersions.toString();
    if (targetNumbers.size() != 1) {
      throw new IllegalArgumentException(""String_Node_Str"" + targetNumbers.toString());
    }
 else {
      this.numberOfTargets=targetNumbers.iterator().nextInt();
    }
    targetIdentifiers=new IndexedIdentifier();
    boolean error=false;
    for (    final AlignmentReader reader : readers) {
      IndexedIdentifier targetIds=reader.getTargetIdentifiers();
      for (      MutableString key : targetIds.keySet()) {
        if (!targetIdentifiers.containsKey(key)) {
          targetIdentifiers.put(key,targetIds.getInt(key));
        }
 else {
          final int globalValue=targetIdentifiers.getInt(key);
          final int localValue=targetIds.getInt(key);
          if (globalValue != localValue) {
            error=true;
            LOG.error(String.format(""String_Node_Str"",key,globalValue,localValue,reader.basename()));
          }
        }
      }
    }
    if (error) {
      throw new RuntimeException(""String_Node_Str"");
    }
    targetLengths=new int[targetIdentifiers.size()];
    for (int targetIndex=0; targetIndex < targetIdentifiers.size(); targetIndex++) {
      int maxLength=-1;
      for (      final AlignmentReader reader : readers) {
        final int[] readerLengths=reader.getTargetLength();
        if (readerLengths != null && readerLengths.length > targetIndex) {
          maxLength=Math.max(readerLengths[targetIndex],maxLength);
          targetLengths[targetIndex]=maxLength;
        }
      }
    }
    for (int i=0; i < queryIndexOffset.length; i++) {
      queryIndexOffset[i]=adjustQueryIndices ? i == 0 ? 0 : readers[i - 1].getLargestSplitQueryIndex() + 1 : 0;
    }
  }
  setHeaderLoaded(true);
}","/** 
 * Read the header of this alignment.
 * @throws java.io.IOException If an error occurs.
 */
@Override public final void readHeader() throws IOException {
  if (!isHeaderLoaded()) {
    final IntSet targetNumbers=new IntArraySet();
    int readerIndex=0;
    ObjectList<String> alignerNames=new ObjectArrayList<String>();
    ObjectList<String> alignerVersions=new ObjectArrayList<String>();
    numberOfQueries=0;
    smallestQueryIndex=Integer.MAX_VALUE;
    largestQueryIndex=adjustQueryIndices ? Integer.MIN_VALUE : 0;
    readOriginPermutations=new int[readers.length][];
    for (    final AlignmentReader reader : readers) {
      reader.readHeader();
      String alignerName=reader.getAlignerName();
      String alignerVersion=reader.getAlignerVersion();
      if (!(alignerNames.contains(alignerName) && alignerVersions.contains(alignerVersion))) {
        alignerNames.add(alignerName);
        alignerVersions.add(alignerVersion);
      }
      smallestQueryIndex=Math.min(reader.getSmallestSplitQueryIndex(),smallestQueryIndex);
      largestQueryIndex=adjustQueryIndices ? Math.max(largestQueryIndex,0) + 1 + reader.getLargestSplitQueryIndex() : Math.max(reader.getLargestSplitQueryIndex(),largestQueryIndex);
      targetNumbers.add(reader.getNumberOfTargets());
      final int numQueriesForReader=reader.getNumberOfQueries();
      numQueriesPerReader[readerIndex]=numQueriesForReader;
      numberOfQueries+=numQueriesForReader;
      numberOfAlignedReads+=reader.getNumberOfAlignedReads();
      mergeReadOrigins(readerIndex,reader.getReadOriginInfo().getPbList(),readers.length);
      readerIndex++;
    }
    alignerName=alignerNames.toString();
    alignerVersion=alignerVersions.toString();
    if (targetNumbers.size() != 1) {
      throw new IllegalArgumentException(""String_Node_Str"" + targetNumbers.toString());
    }
 else {
      this.numberOfTargets=targetNumbers.iterator().nextInt();
    }
    targetIdentifiers=new IndexedIdentifier();
    boolean error=false;
    for (    final AlignmentReader reader : readers) {
      IndexedIdentifier targetIds=reader.getTargetIdentifiers();
      for (      MutableString key : targetIds.keySet()) {
        if (!targetIdentifiers.containsKey(key)) {
          targetIdentifiers.put(key,targetIds.getInt(key));
        }
 else {
          final int globalValue=targetIdentifiers.getInt(key);
          final int localValue=targetIds.getInt(key);
          if (globalValue != localValue) {
            error=true;
            LOG.error(String.format(""String_Node_Str"",key,globalValue,localValue,reader.basename()));
          }
        }
      }
    }
    if (error) {
      throw new RuntimeException(""String_Node_Str"");
    }
    targetLengths=new int[targetIdentifiers.size()];
    for (int targetIndex=0; targetIndex < targetIdentifiers.size(); targetIndex++) {
      int maxLength=-1;
      for (      final AlignmentReader reader : readers) {
        final int[] readerLengths=reader.getTargetLength();
        if (readerLengths != null && readerLengths.length > targetIndex) {
          maxLength=Math.max(readerLengths[targetIndex],maxLength);
          targetLengths[targetIndex]=maxLength;
        }
      }
    }
    for (int i=0; i < queryIndexOffset.length; i++) {
      queryIndexOffset[i]=adjustQueryIndices ? i == 0 ? 0 : readers[i - 1].getLargestSplitQueryIndex() + 1 : 0;
    }
  }
  setHeaderLoaded(true);
}"
50294,"private void mergeReadOrigins(int readerIndex,List<Alignments.ReadOriginInfo> readOriginInfo){
  for (  Alignments.ReadOriginInfo roi : readOriginInfo) {
    final int[] permutation=new int[readOriginInfo.size()];
    readOriginPermutations[readerIndex]=permutation;
    for (int i=0; i < permutation.length; i++) {
      final int newReadOriginIndex=nextAvailableReadOriginIndex++;
      permutation[roi.getOriginIndex()]=newReadOriginIndex;
      Alignments.ReadOriginInfo.Builder newRoi=Alignments.ReadOriginInfo.newBuilder(roi);
      newRoi.setOriginIndex(newReadOriginIndex);
      mergedReadOriginInfoList.add(newRoi.build());
    }
  }
}","private void mergeReadOrigins(int readerIndex,List<Alignments.ReadOriginInfo> readOriginInfo,int numberOfReaders){
  for (  Alignments.ReadOriginInfo roi : readOriginInfo) {
    final int[] permutation=new int[readOriginInfo.size()];
    readOriginPermutations[readerIndex]=permutation;
    for (int i=0; i < numberOfReaders; i++) {
      final int newReadOriginIndex=nextAvailableReadOriginIndex++;
      permutation[roi.getOriginIndex()]=newReadOriginIndex;
      Alignments.ReadOriginInfo.Builder newRoi=Alignments.ReadOriginInfo.newBuilder(roi);
      newRoi.setOriginIndex(newReadOriginIndex);
      mergedReadOriginInfoList.add(newRoi.build());
    }
  }
}"
50295,"@Before public void setUp() throws IOException {
{
    outputBasename1=FilenameUtils.concat(BASE_TEST_DIR,""String_Node_Str"");
    final AlignmentWriterImpl writer=new AlignmentWriterImpl(outputBasename1);
    writer.setNumAlignmentEntriesPerChunk(1000);
    writer.setAlignerName(""String_Node_Str"");
    writer.setAlignerVersion(""String_Node_Str"");
    writer.setReadOriginInfo(buildReadGroup(0,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    final int numQuery=10;
    int position=100;
    final int score=30;
    for (int targetIndex=0; targetIndex < numTargets; targetIndex++) {
      for (int queryIndex=0; queryIndex < numQuery; queryIndex++) {
        Alignments.AlignmentEntry.Builder newEntry=Alignments.AlignmentEntry.newBuilder();
        newEntry.setQueryIndex(queryIndex);
        newEntry.setTargetIndex(targetIndex);
        newEntry.setScore((float)score);
        newEntry.setPosition(position++);
        newEntry.setMatchingReverseStrand(false);
        newEntry.setMultiplicity(1);
        newEntry.setQueryLength(constantQueryLength);
        newEntry.setReadOriginIndex(0);
        writer.appendEntry(newEntry.build());
        numEntriesIn101++;
        count101++;
      }
    }
    numQueries101=numQuery;
    writer.close();
    AlignmentTooManyHitsWriter tmhWriter=new AlignmentTooManyHitsWriter(outputBasename1,2);
    for (int queryIndex=0; queryIndex < numQuery; queryIndex++) {
      tmhWriter.append(queryIndex,10,30);
    }
    tmhWriter.close();
  }
{
    outputBasename2=FilenameUtils.concat(BASE_TEST_DIR,""String_Node_Str"");
    final AlignmentWriterImpl writer=new AlignmentWriterImpl(outputBasename2);
    writer.setAlignerName(""String_Node_Str"");
    writer.setAlignerVersion(""String_Node_Str"");
    writer.setNumAlignmentEntriesPerChunk(1000);
    writer.setReadOriginInfo(buildReadGroup(0,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    final int numQuery=13;
    int position=1;
    final int score=50;
    for (int targetIndex=0; targetIndex < numTargets; targetIndex++) {
      for (int queryIndex=0; queryIndex < numQuery; queryIndex++) {
        Alignments.AlignmentEntry.Builder newEntry=Alignments.AlignmentEntry.newBuilder();
        newEntry.setQueryIndex(queryIndex);
        newEntry.setTargetIndex(targetIndex);
        newEntry.setScore((float)score);
        newEntry.setPosition(position++);
        newEntry.setMatchingReverseStrand(false);
        newEntry.setMultiplicity(1);
        newEntry.setQueryLength(constantQueryLength);
        newEntry.setReadOriginIndex(0);
        writer.appendEntry(newEntry.build());
        numEntriesIn102++;
        count102++;
      }
    }
    numQueries102=numQuery;
    writer.close();
    AlignmentTooManyHitsWriter tmhWriter=new AlignmentTooManyHitsWriter(outputBasename2,2);
    for (int queryIndex=0; queryIndex < numQuery; queryIndex++) {
      tmhWriter.append(queryIndex,1,30);
    }
    tmhWriter.close();
  }
}","@Before public void setUp() throws IOException {
{
    outputBasename1=FilenameUtils.concat(BASE_TEST_DIR,""String_Node_Str"");
    final AlignmentWriterImpl writer=new AlignmentWriterImpl(outputBasename1);
    writer.setNumAlignmentEntriesPerChunk(1000);
    writer.setAlignerName(""String_Node_Str"");
    writer.setAlignerVersion(""String_Node_Str"");
    writer.setReadOriginInfo(buildReadGroup(0,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    writer.addReadOriginInfo(buildReadGroup(1,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    writer.addReadOriginInfo(buildReadGroup(2,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    final int numQuery=10;
    int position=100;
    final int score=30;
    for (int targetIndex=0; targetIndex < numTargets; targetIndex++) {
      for (int queryIndex=0; queryIndex < numQuery; queryIndex++) {
        Alignments.AlignmentEntry.Builder newEntry=Alignments.AlignmentEntry.newBuilder();
        newEntry.setQueryIndex(queryIndex);
        newEntry.setTargetIndex(targetIndex);
        newEntry.setScore((float)score);
        newEntry.setPosition(position++);
        newEntry.setMatchingReverseStrand(false);
        newEntry.setMultiplicity(1);
        newEntry.setQueryLength(constantQueryLength);
        newEntry.setReadOriginIndex(0);
        writer.appendEntry(newEntry.build());
        numEntriesIn101++;
        count101++;
      }
    }
    numQueries101=numQuery;
    writer.close();
    AlignmentTooManyHitsWriter tmhWriter=new AlignmentTooManyHitsWriter(outputBasename1,2);
    for (int queryIndex=0; queryIndex < numQuery; queryIndex++) {
      tmhWriter.append(queryIndex,10,30);
    }
    tmhWriter.close();
  }
{
    outputBasename2=FilenameUtils.concat(BASE_TEST_DIR,""String_Node_Str"");
    final AlignmentWriterImpl writer=new AlignmentWriterImpl(outputBasename2);
    writer.setAlignerName(""String_Node_Str"");
    writer.setAlignerVersion(""String_Node_Str"");
    writer.setNumAlignmentEntriesPerChunk(1000);
    writer.setReadOriginInfo(buildReadGroup(0,""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
    final int numQuery=13;
    int position=1;
    final int score=50;
    for (int targetIndex=0; targetIndex < numTargets; targetIndex++) {
      for (int queryIndex=0; queryIndex < numQuery; queryIndex++) {
        Alignments.AlignmentEntry.Builder newEntry=Alignments.AlignmentEntry.newBuilder();
        newEntry.setQueryIndex(queryIndex);
        newEntry.setTargetIndex(targetIndex);
        newEntry.setScore((float)score);
        newEntry.setPosition(position++);
        newEntry.setMatchingReverseStrand(false);
        newEntry.setMultiplicity(1);
        newEntry.setQueryLength(constantQueryLength);
        newEntry.setReadOriginIndex(0);
        writer.appendEntry(newEntry.build());
        numEntriesIn102++;
        count102++;
      }
    }
    numQueries102=numQuery;
    writer.close();
    AlignmentTooManyHitsWriter tmhWriter=new AlignmentTooManyHitsWriter(outputBasename2,2);
    for (int queryIndex=0; queryIndex < numQuery; queryIndex++) {
      tmhWriter.append(queryIndex,1,30);
    }
    tmhWriter.close();
  }
}"
50296,"/** 
 * Record all the between-group sample pairs that exist for the given group comparison.
 * @param comparison group comparison of interest.
 */
public void recordPairForGroupComparison(final GroupComparison comparison){
  samplePairsForGroupComparisons[comparison.index]=new ObjectArrayList<SamplePair>();
  final IntSet sampleIndicesInGroup1=new IntAVLTreeSet();
  final IntSet sampleIndicesInGroup2=new IntAVLTreeSet();
  for (int sampleIndex=0; sampleIndex < numSamples; sampleIndex++) {
    if (sampleIndexToGroupIndex[sampleIndex] == comparison.indexGroup1) {
      sampleIndicesInGroup1.add(sampleIndex);
    }
  }
  for (int sampleIndex=0; sampleIndex < numSamples; sampleIndex++) {
    if (sampleIndexToGroupIndex[sampleIndex] == comparison.indexGroup2) {
      sampleIndicesInGroup2.add(sampleIndex);
    }
  }
  for (  final int sampleIndexA : sampleIndicesInGroup1) {
    for (    final int sampleIndexB : sampleIndicesInGroup2) {
      if (sampleIndexA < sampleIndexB) {
        samplePairsForGroupComparisons[comparison.index].add(new SamplePair(sampleIndexA,sampleIndexB));
      }
    }
  }
}","/** 
 * Record all the between-group sample pairs that exist for the given group comparison.
 * @param comparison group comparison of interest.
 */
public void recordPairForGroupComparison(final GroupComparison comparison){
  samplePairsForGroupComparisons[comparison.index]=new ObjectArrayList<SamplePair>();
  final IntSet sampleIndicesInGroup1=new IntAVLTreeSet();
  final IntSet sampleIndicesInGroup2=new IntAVLTreeSet();
  for (int sampleIndex=0; sampleIndex < numSamples; sampleIndex++) {
    if (sampleIndexToGroupIndex[sampleIndex] == comparison.indexGroup1) {
      sampleIndicesInGroup1.add(sampleIndex);
    }
  }
  for (int sampleIndex=0; sampleIndex < numSamples; sampleIndex++) {
    if (sampleIndexToGroupIndex[sampleIndex] == comparison.indexGroup2) {
      sampleIndicesInGroup2.add(sampleIndex);
    }
  }
  if (comparison.index == 2) {
    System.out.println(""String_Node_Str"");
  }
  final ObjectArraySet<SamplePair> set=new ObjectArraySet<SamplePair>();
  for (  final int sampleIndexA : sampleIndicesInGroup1) {
    for (    final int sampleIndexB : sampleIndicesInGroup2) {
      set.add(new SamplePair(sampleIndexA,sampleIndexB));
    }
  }
  samplePairsForGroupComparisons[comparison.index].addAll(set);
}"
50297,"/** 
 * Construct a sample pair enumerator.
 * @param sampleIndexToGroupIndex the mapping between sample indices and group indices.
 * @param numSamples The number of samples under study.
 * @param numGroups  The number of groups under study.
 * @param numPairComparisons The maximum number of between group comparisons to consider.
 */
public SamplePairEnumerator(final int[] sampleIndexToGroupIndex,int numSamples,int numGroups,int numPairComparisons){
  samplePairsForGroup=new ObjectArrayList[numGroups];
  this.sampleIndexToGroupIndex=sampleIndexToGroupIndex;
  this.numSamples=numSamples;
  this.numGroups=numGroups;
  this.samplePairsForGroupComparisons=new ObjectArrayList[numPairComparisons];
}","/** 
 * Construct a sample pair enumerator.
 * @param sampleIndexToGroupIndex the mapping between sample indices and group indices.
 * @param numSamples              The number of samples under study.
 * @param numGroups               The number of groups under study.
 * @param numPairComparisons      The maximum number of between group comparisons to consider.
 */
public SamplePairEnumerator(final int[] sampleIndexToGroupIndex,int numSamples,int numGroups,int numPairComparisons){
  samplePairsForGroup=new ObjectArrayList[numGroups];
  this.sampleIndexToGroupIndex=sampleIndexToGroupIndex;
  this.numSamples=numSamples;
  this.numGroups=numGroups;
  this.samplePairsForGroupComparisons=new ObjectArrayList[numPairComparisons];
}"
50298,"private void write(ObjectArrayList<String> elementIds){
  outputWriter.print(label);
  outputWriter.print(""String_Node_Str"");
  boolean stop=false;
  for (  final String elementId : elementIds) {
    outputWriter.print('\t');
    outputWriter.print(elementId);
  }
  if (elementIds.get(5).equals(""String_Node_Str"")) {
    System.out.println(elementIds);
  }
  final double p=estimator.estimateEmpiricalPValue(valuesACollector.toArray(new IntArrayList[valuesACollector.size()]),valuesBCollector.toArray(new IntArrayList[valuesBCollector.size()]),covariatesACollector.toArray(new IntArrayList[covariatesACollector.size()]),covariatesBCollector.toArray(new IntArrayList[covariatesBCollector.size()]));
  if (index < 1000) {
    if (p > 0.05) {
      numFN++;
    }
 else {
      numTP++;
    }
  }
  if (index >= 1000) {
    if (p <= 0.05) {
      numFP++;
    }
 else {
      numTN++;
    }
    numOther++;
  }
  index++;
  outputWriter.printf(""String_Node_Str"",p);
}","private void write(ObjectArrayList<String> elementIds){
  outputWriter.print(label);
  outputWriter.print(""String_Node_Str"");
  boolean stop=false;
  for (  final String elementId : elementIds) {
    outputWriter.print('\t');
    outputWriter.print(elementId);
  }
  if (elementIds.get(5).equals(""String_Node_Str"")) {
    System.out.println(elementIds);
  }
  final double p=estimator.estimateEmpiricalPValue(valuesACollector.toArray(new IntArrayList[valuesACollector.size()]),valuesBCollector.toArray(new IntArrayList[valuesBCollector.size()]),covariatesACollector.toArray(new IntArrayList[covariatesACollector.size()]),covariatesBCollector.toArray(new IntArrayList[covariatesBCollector.size()]));
  final double alpha=0.05;
  if (index < 1000) {
    if (p > alpha) {
      numFN++;
    }
 else {
      numTP++;
    }
  }
  if (index >= 1000) {
    if (p <= alpha) {
      numFP++;
    }
 else {
      numTN++;
    }
    numOther++;
  }
  index++;
  outputWriter.printf(""String_Node_Str"",p);
}"
50299,"/** 
 * Obtain dynamic options from the client of this class and configure this estimator.  For configure to work, the client class must have a static registered dynamicOptionClient that was constructed with  localDynamicOptions
 * @param numberOfContexts Number of discrete contexts to use. One null distribution is estimated for each context.
 * @param clientDoc        parsed dynamic options for the client of this class.
 */
public void configure(final int numberOfContexts,final DynamicOptionClient clientDoc){
  Boolean estimateIntraGroupDifferences=clientDoc.getBoolean(""String_Node_Str"");
  Boolean estimateIntraGroupP=clientDoc.getBoolean(""String_Node_Str"");
  serializedFilename=clientDoc.getString(""String_Node_Str"");
  if (estimateIntraGroupP && serializedFilename != null) {
    try {
      LOG.debug(""String_Node_Str"" + serializedFilename);
      estimator=DensityEstimator.load(serializedFilename);
      statAdaptor=estimator.getStatAdaptor();
      densityLoadedFromDisk=true;
    }
 catch (    Exception e) {
      throw new RuntimeException(""String_Node_Str"" + serializedFilename);
    }
  }
  String combinatorName=clientDoc.getString(""String_Node_Str"");
  try {
    LOG.debug(""String_Node_Str"" + combinatorName);
switch (combinatorNames.valueOf(combinatorName)) {
case max:
      combinator=new MaxCombinator();
    break;
case sum:
  combinator=new SummedCombinator();
break;
case qfast:
combinator=new QFast();
break;
case median:
combinator=new MedianCombinator();
break;
default :
new InternalError(""String_Node_Str"" + combinatorName);
}
}
 catch (IllegalArgumentException e) {
LOG.error(String.format(""String_Node_Str"",combinatorName));
combinator=new MaxCombinator();
}
if (statAdaptor != null) {
LOG.info(""String_Node_Str"" + statAdaptor.statName());
}
 else {
String statisticName=clientDoc.getString(""String_Node_Str"");
LOG.info(""String_Node_Str"" + statisticName);
try {
switch (statisticNames.valueOf(statisticName)) {
case delta:
statAdaptor=new DeltaStatisticAdaptor();
break;
case stat4:
statAdaptor=new Stat4StatisticAdaptor();
break;
case dMR:
statAdaptor=new MethylationRateDifferenceStatisticAdaptor();
break;
case fisher:
statAdaptor=new FisherExactTestAdaptor();
break;
case ptest_mci:
statAdaptor=new PTestMciProviderStatisticAdaptor();
break;
case ptest:
statAdaptor=new PTestStatisticAdaptor();
break;
case stat5_mci:
statAdaptor=new Stat5MciProviderStatisticAdaptor();
break;
default :
case stat5:
statAdaptor=new Stat5StatisticAdaptor();
break;
}
}
 catch (IllegalArgumentException e) {
LOG.error(String.format(""String_Node_Str"",statisticName));
statAdaptor=new Stat5StatisticAdaptor();
}
}
BinningStrategy binningStrategy=null;
if (!densityLoadedFromDisk) {
final String binningStrategyName=clientDoc.getString(""String_Node_Str"");
LOG.debug(""String_Node_Str"" + binningStrategyName);
if (binningStrategyName != null) {
try {
switch (binningStrategyNames.valueOf(binningStrategyName)) {
case log2:
binningStrategy=new Log2BinningStrategy();
break;
case log10:
binningStrategy=new Log10BinningStrategy();
break;
case s100linear:
binningStrategy=new LinearBinningStrategy();
break;
default :
case fasts100log10:
case fastslog10:
binningStrategy=new FastSmallAndLog10BinningStrategy();
break;
}
}
 catch (IllegalArgumentException e) {
LOG.error(String.format(""String_Node_Str"",binningStrategyName));
binningStrategy=new FastSmallAndLog10BinningStrategy();
}
}
}
 else {
binningStrategy=estimator.getBinningStrategy();
}
if (estimator == null) {
estimator=new DensityEstimator(numberOfContexts,statAdaptor);
if (!densityLoadedFromDisk) {
estimator.setBinningStrategy(binningStrategy);
}
}
}","/** 
 * Obtain dynamic options from the client of this class and configure this estimator.  For configure to work, the client class must have a static registered dynamicOptionClient that was constructed with  localDynamicOptions
 * @param numberOfContexts Number of discrete contexts to use. One null distribution is estimated for each context.
 * @param clientDoc        parsed dynamic options for the client of this class.
 */
public void configure(final int numberOfContexts,final DynamicOptionClient clientDoc){
}"
50300,"private synchronized void writeStats() throws IOException {
  if (!statsWritten) {
    stats.put(""String_Node_Str"",FilenameUtils.getBaseName(basename));
    stats.put(""String_Node_Str"",Integer.toString(permutator.getBiggestSmallIndex()));
    stats.put(""String_Node_Str"",Integer.toString(permutator.getSmallestIndex()));
    stats.put(""String_Node_Str"",Integer.toString(getNumQueries()));
    stats.put(""String_Node_Str"",basename);
    stats.put(""String_Node_Str"",Integer.toString(numberOfAlignedReads));
    stats.store(statsWriter,""String_Node_Str"");
    statsWritten=true;
  }
}","private synchronized void writeStats() throws IOException {
  if (!statsWritten) {
    stats.put(""String_Node_Str"",FilenameUtils.getName(basename));
    stats.put(""String_Node_Str"",Integer.toString(permutator.getBiggestSmallIndex()));
    stats.put(""String_Node_Str"",Integer.toString(permutator.getSmallestIndex()));
    stats.put(""String_Node_Str"",Integer.toString(getNumQueries()));
    stats.put(""String_Node_Str"",basename);
    stats.put(""String_Node_Str"",Integer.toString(numberOfAlignedReads));
    stats.store(statsWriter,""String_Node_Str"");
    statsWritten=true;
  }
}"
50301,"public void finish(RandomAccessSequenceCache randomAccessGenome,AlignmentToPileupMode.OutputFormat outputFormat){
  if (randomAccessGenome != null) {
    Sequence seq=new Sequence();
    MutableString clippedBases=new MutableString();
    for (int position=startPosition - maxVariationLength; position <= endPosition + 50; position++) {
      final String targetId=getReferenceId(startReferenceIndex).toString();
      clippedBases.append(randomAccessGenome.get(targetId,position));
    }
    seq.basename=""String_Node_Str"" + randomAccessGenome.getBasename() + ""String_Node_Str"";
    writeSequence(outputFormat,seq,seq.basename,clippedBases);
  }
  for (  String basename : basenameIds) {
    int i=0;
    for (    Sequence seq : sequenceBuffers) {
      if (seq.basename.equals(basename)) {
        final MutableString bases=sequenceBuffers.get(i).bases;
        if (bases.length() > startFlapStart) {
          final String shortBasename=FilenameUtils.getBaseName(AlignmentReaderImpl.getBasename(seq.basename));
          final MutableString clippedBases=bases.substring(Math.max(0,startFlapStart - maxVariationLength));
          writeSequence(outputFormat,seq,shortBasename,clippedBases);
        }
      }
      i++;
    }
  }
}","public void finish(RandomAccessSequenceCache randomAccessGenome,AlignmentToPileupMode.OutputFormat outputFormat){
  if (randomAccessGenome != null) {
    Sequence seq=new Sequence();
    MutableString clippedBases=new MutableString();
    for (int position=startPosition - maxVariationLength; position <= endPosition + 50; position++) {
      final String targetId=getReferenceId(startReferenceIndex).toString();
      clippedBases.append(randomAccessGenome.get(targetId,position));
    }
    seq.basename=""String_Node_Str"" + randomAccessGenome.getBasename() + ""String_Node_Str"";
    writeSequence(outputFormat,seq,seq.basename,clippedBases);
  }
  for (  String basename : basenameIds) {
    int i=0;
    for (    Sequence seq : sequenceBuffers) {
      if (seq.basename.equals(basename)) {
        final MutableString bases=sequenceBuffers.get(i).bases;
        if (bases.length() > startFlapStart) {
          final String shortBasename=FilenameUtils.getName(AlignmentReaderImpl.getBasename(seq.basename));
          final MutableString clippedBases=bases.substring(Math.max(0,startFlapStart - maxVariationLength));
          writeSequence(outputFormat,seq,shortBasename,clippedBases);
        }
      }
      i++;
    }
  }
}"
50302,"public void write(final AlignmentWriterImpl writer) throws IOException {
  try {
    writer.setTargetIdentifiers(alignmentReader.getTargetIdentifiers());
    writer.setQueryIdentifiers(alignmentReader.getQueryIdentifiers());
    final int[] targetLengths=alignmentReader.getTargetLength();
    if (targetLengths != null) {
      writer.setTargetLengths(targetLengths);
    }
    writer.setLargestSplitQueryIndex(alignmentReader.getLargestSplitQueryIndex());
    writer.setSmallestSplitQueryIndex(alignmentReader.getSmallestSplitQueryIndex());
    writer.setSorted(true);
    writer.setAlignerName(alignmentReader.getAlignerName());
    writer.setAlignerVersion(alignmentReader.getAlignerVersion());
    writer.setStatistics(alignmentReader.getStatistics());
    writer.putStatistic(""String_Node_Str"",FilenameUtils.getBaseName(basename));
    writer.putStatistic(""String_Node_Str"",basename);
    for (    final Alignments.AlignmentEntry entry : entries) {
      writer.appendEntry(entry);
    }
  }
  finally {
    writer.close();
  }
}","public void write(final AlignmentWriterImpl writer) throws IOException {
  try {
    writer.setTargetIdentifiers(alignmentReader.getTargetIdentifiers());
    writer.setQueryIdentifiers(alignmentReader.getQueryIdentifiers());
    final int[] targetLengths=alignmentReader.getTargetLength();
    if (targetLengths != null) {
      writer.setTargetLengths(targetLengths);
    }
    writer.setLargestSplitQueryIndex(alignmentReader.getLargestSplitQueryIndex());
    writer.setSmallestSplitQueryIndex(alignmentReader.getSmallestSplitQueryIndex());
    writer.setSorted(true);
    writer.setAlignerName(alignmentReader.getAlignerName());
    writer.setAlignerVersion(alignmentReader.getAlignerVersion());
    writer.setStatistics(alignmentReader.getStatistics());
    writer.putStatistic(""String_Node_Str"",FilenameUtils.getName(basename));
    writer.putStatistic(""String_Node_Str"",basename);
    for (    final Alignments.AlignmentEntry entry : entries) {
      writer.appendEntry(entry);
    }
  }
  finally {
    writer.close();
  }
}"
50303,"/** 
 * Determine if an sampleId is provided on the command line.
 * @param inputFilenames
 * @param sampleId
 * @return
 */
private boolean isInputFilename(String[] inputFilenames,String sampleId){
  for (  final String input : inputFilenames) {
    String commandLineBasename=FilenameUtils.getBaseName(input);
    if (commandLineBasename.equals(FilenameUtils.getBaseName(sampleId))) {
      return true;
    }
  }
  return false;
}","/** 
 * Determine if a sampleId is provided on the command line.
 * @param inputFilenames
 * @param sampleId
 * @return
 */
private boolean isInputFilename(String[] inputFilenames,String sampleId){
  for (  final String input : inputFilenames) {
    String commandLineBasename=FilenameUtils.getName(AlignmentReaderImpl.getBasename(input));
    if (commandLineBasename.equals(FilenameUtils.getName(AlignmentReaderImpl.getBasename(sampleId)))) {
      return true;
    }
  }
  return false;
}"
50304,"public String[] getSamples(){
  if (readIndexStats != null) {
    int numberOfSamples=readIndexStats.size();
    samples=new String[numberOfSamples];
    if (readIndexStats.size() == 0) {
      System.err.println(""String_Node_Str"");
      System.exit(1);
    }
    for (    ReadIndexStats stat : readIndexStats) {
      samples[stat.readerIndex]=stat.basename;
    }
    return samples;
  }
 else {
    samples=AlignmentReaderImpl.getBasenames(inputFilenames);
    for (int i=0; i < samples.length; i++) {
      samples[i]=FilenameUtils.getBaseName(samples[i]);
    }
    return samples;
  }
}","public String[] getSamples(){
  if (readIndexStats != null) {
    int numberOfSamples=readIndexStats.size();
    samples=new String[numberOfSamples];
    if (readIndexStats.size() == 0) {
      System.err.println(""String_Node_Str"");
      System.exit(1);
    }
    for (    ReadIndexStats stat : readIndexStats) {
      samples[stat.readerIndex]=stat.basename;
    }
    return samples;
  }
 else {
    samples=AlignmentReaderImpl.getBasenames(inputFilenames);
    for (int i=0; i < samples.length; i++) {
      samples[i]=FilenameUtils.getName(samples[i]);
    }
    return samples;
  }
}"
50305,"/** 
 * Perform the concatenation.
 * @throws java.io.IOException
 */
@Override public void execute() throws IOException {
  final String[] basenames=AlignmentReaderImpl.getBasenames(inputFilenames);
  final boolean allSorted=ConcatenateAlignmentMode.isAllSorted(basenames);
  if (!allSorted) {
    System.out.println(""String_Node_Str"");
    System.exit(10);
  }
  if (readIndexStats != null) {
    int readerIndex=0;
    for (    String basename : basenames) {
      boolean found=false;
      for (      ReadIndexStats stat : readIndexStats) {
        if (FilenameUtils.getBaseName(basename).equals(stat.basename)) {
          stat.readerIndex=readerIndex;
          found=true;
        }
      }
      if (!found) {
        System.err.printf(""String_Node_Str"",basename);
        System.err.flush();
      }
      readerIndex++;
    }
    Collections.sort(readIndexStats,new Comparator<ReadIndexStats>(){
      public int compare(      ReadIndexStats readIndexStats,      ReadIndexStats readIndexStatsFirst){
        return readIndexStats.readerIndex - readIndexStatsFirst.readerIndex;
      }
    }
);
    final int sampleToGroupAssociationNumber=this.deCalculator.getSampleToGroupMap().keySet().size();
    numberOfReadIndices=new int[inputFilenames.length];
    ObjectSet<ReadIndexStats> toRemove=new ObjectArraySet<ReadIndexStats>();
    for (    ReadIndexStats stat : readIndexStats) {
      if (stat.readerIndex == -1) {
        toRemove.add(stat);
        continue;
      }
      numberOfReadIndices[stat.readerIndex]=Math.max(numberOfReadIndices[stat.readerIndex],stat.countReferenceBases.length);
    }
    readIndexStats.removeAll(toRemove);
  }
  sortedPositionIterator.allocateStorage(basenames.length,numberOfGroups);
  sortedPositionIterator.initialize(this,outputInfo,genotypeFilters);
  sortedPositionIterator.setAlignmentReaderFactory(new NonAmbiguousAlignmentReaderFactory());
  sortedPositionIterator.setAlignmentProcessorFactory(realignmentFactory);
  sortedPositionIterator.setOverrideReferenceWithGenome(overrideReferenceWithGenome);
  sortedPositionIterator.setMaxThreshold(maxThresholdPerSite);
  sortedPositionIterator.iterate(basenames);
  sortedPositionIterator.finish();
}","/** 
 * Perform the concatenation.
 * @throws java.io.IOException
 */
@Override public void execute() throws IOException {
  final String[] basenames=AlignmentReaderImpl.getBasenames(inputFilenames);
  final boolean allSorted=ConcatenateAlignmentMode.isAllSorted(basenames);
  if (!allSorted) {
    System.out.println(""String_Node_Str"");
    System.exit(10);
  }
  if (readIndexStats != null) {
    int readerIndex=0;
    for (    String basename : basenames) {
      boolean found=false;
      for (      ReadIndexStats stat : readIndexStats) {
        if (FilenameUtils.getName(basename).equals(stat.basename)) {
          stat.readerIndex=readerIndex;
          found=true;
        }
      }
      if (!found) {
        System.err.printf(""String_Node_Str"",basename);
        System.err.flush();
      }
      readerIndex++;
    }
    Collections.sort(readIndexStats,new Comparator<ReadIndexStats>(){
      public int compare(      ReadIndexStats readIndexStats,      ReadIndexStats readIndexStatsFirst){
        return readIndexStats.readerIndex - readIndexStatsFirst.readerIndex;
      }
    }
);
    final int sampleToGroupAssociationNumber=this.deCalculator.getSampleToGroupMap().keySet().size();
    numberOfReadIndices=new int[inputFilenames.length];
    ObjectSet<ReadIndexStats> toRemove=new ObjectArraySet<ReadIndexStats>();
    for (    ReadIndexStats stat : readIndexStats) {
      if (stat.readerIndex == -1) {
        toRemove.add(stat);
        continue;
      }
      numberOfReadIndices[stat.readerIndex]=Math.max(numberOfReadIndices[stat.readerIndex],stat.countReferenceBases.length);
    }
    readIndexStats.removeAll(toRemove);
  }
  sortedPositionIterator.allocateStorage(basenames.length,numberOfGroups);
  sortedPositionIterator.initialize(this,outputInfo,genotypeFilters);
  sortedPositionIterator.setAlignmentReaderFactory(new NonAmbiguousAlignmentReaderFactory());
  sortedPositionIterator.setAlignmentProcessorFactory(realignmentFactory);
  sortedPositionIterator.setOverrideReferenceWithGenome(overrideReferenceWithGenome);
  sortedPositionIterator.setMaxThreshold(maxThresholdPerSite);
  sortedPositionIterator.iterate(basenames);
  sortedPositionIterator.finish();
}"
50306,"@Override public void processAlignmentEntry(final AlignmentReader alignmentReader,final Alignments.AlignmentEntry alignmentEntry){
  String basename=alignmentReader.basename();
  basename=FilenameUtils.getBaseName(basename);
switch (outputFormat) {
case CONCISE:
{
      if (alignmentEntry.getSequenceVariationsCount() > 0) {
        outputStream.print(String.format(""String_Node_Str"",alignmentEntry.getQueryIndex(),getReferenceId(alignmentEntry.getTargetIndex())));
        boolean variations=false;
        for (        final Alignments.SequenceVariation var : alignmentEntry.getSequenceVariationsList()) {
          final int positionOnReference=alignmentEntry.getPosition() + var.getPosition();
          final int referenceIndex=alignmentEntry.getTargetIndex();
          boolean keepVar=true;
          keepVar=determineKeepVariation(positionOnReference,referenceIndex,keepVar);
          if (keepVar) {
            variations=true;
            outputStream.print(String.format(""String_Node_Str"",positionOnReference,var.getReadIndex(),var.getFrom(),var.getTo()));
          }
        }
        if (variations) {
          outputStream.println();
        }
      }
    }
  break;
case TSV:
case TAB_DELIMITED:
{
  final boolean variations=false;
  for (  final Alignments.SequenceVariation var : alignmentEntry.getSequenceVariationsList()) {
    final int positionOnReference=alignmentEntry.getPosition() + var.getPosition();
    final int readIndex=var.getReadIndex();
    final String from=var.getFrom();
    final String to=var.getTo();
    final int referenceIndex=alignmentEntry.getTargetIndex();
    final byte[] qualityScores;
    if (var.hasToQuality()) {
      System.out.println(""String_Node_Str"");
      qualityScores=var.getToQuality().toByteArray();
    }
 else {
      System.out.println(""String_Node_Str"");
      qualityScores=null;
    }
    boolean keepVar=true;
    keepVar=determineKeepVariation(positionOnReference,referenceIndex,keepVar);
    if (keepVar && !isAllNs(to)) {
      printTab(alignmentEntry,basename,positionOnReference,readIndex,from,to,qualityScores);
    }
  }
}
break;
case TAB_SINGLE_BASE:
{
for (final Alignments.SequenceVariation var : alignmentEntry.getSequenceVariationsList()) {
final int positionOnReference=alignmentEntry.getPosition() + var.getPosition();
final int readIndex=var.getReadIndex();
final String from=var.getFrom();
final String to=var.getTo();
final int fromLength=from.length();
final int toLength=to.length();
final int referenceIndex=alignmentEntry.getTargetIndex();
final byte[] qualityScores;
if (var.hasToQuality()) {
  qualityScores=var.getToQuality().toByteArray();
}
 else {
  qualityScores=null;
}
boolean keepVar=true;
keepVar=determineKeepVariation(positionOnReference,referenceIndex,keepVar);
if (keepVar && !isAllNs(to)) {
  final int maxLength=Math.max(fromLength,toLength);
  int fromOffset=0;
  int toOffset=0;
  int readIndexIncrementValue=(alignmentEntry.getMatchingReverseStrand() ? -1 : 1);
  byte[] toScore;
  if (qualityScores != null) {
    toScore=new byte[1];
  }
 else {
    toScore=null;
  }
  for (int i=0; i < maxLength; i++) {
    final char fromChar=var.getFrom().charAt(i);
    final char toChar=var.getTo().charAt(i);
    if (qualityScores != null) {
      if (i < qualityScores.length) {
        toScore[0]=qualityScores[i];
      }
 else {
        toScore=null;
      }
    }
    printTab(alignmentEntry,basename,positionOnReference + fromOffset,readIndex + toOffset,i < fromLength ? Character.toString(fromChar) : ""String_Node_Str"",i < toLength ? Character.toString(toChar) : ""String_Node_Str"",toScore);
    if (fromChar != '-') {
      fromOffset+=1;
    }
    if (toChar != '-') {
      toOffset+=readIndexIncrementValue;
    }
  }
}
}
}
break;
}
}","@Override public void processAlignmentEntry(final AlignmentReader alignmentReader,final Alignments.AlignmentEntry alignmentEntry){
  String basename=alignmentReader.basename();
  basename=FilenameUtils.getName(AlignmentReaderImpl.getBasename(basename));
switch (outputFormat) {
case CONCISE:
{
      if (alignmentEntry.getSequenceVariationsCount() > 0) {
        outputStream.print(String.format(""String_Node_Str"",alignmentEntry.getQueryIndex(),getReferenceId(alignmentEntry.getTargetIndex())));
        boolean variations=false;
        for (        final Alignments.SequenceVariation var : alignmentEntry.getSequenceVariationsList()) {
          final int positionOnReference=alignmentEntry.getPosition() + var.getPosition();
          final int referenceIndex=alignmentEntry.getTargetIndex();
          boolean keepVar=true;
          keepVar=determineKeepVariation(positionOnReference,referenceIndex,keepVar);
          if (keepVar) {
            variations=true;
            outputStream.print(String.format(""String_Node_Str"",positionOnReference,var.getReadIndex(),var.getFrom(),var.getTo()));
          }
        }
        if (variations) {
          outputStream.println();
        }
      }
    }
  break;
case TSV:
case TAB_DELIMITED:
{
  final boolean variations=false;
  for (  final Alignments.SequenceVariation var : alignmentEntry.getSequenceVariationsList()) {
    final int positionOnReference=alignmentEntry.getPosition() + var.getPosition();
    final int readIndex=var.getReadIndex();
    final String from=var.getFrom();
    final String to=var.getTo();
    final int referenceIndex=alignmentEntry.getTargetIndex();
    final byte[] qualityScores;
    if (var.hasToQuality()) {
      System.out.println(""String_Node_Str"");
      qualityScores=var.getToQuality().toByteArray();
    }
 else {
      System.out.println(""String_Node_Str"");
      qualityScores=null;
    }
    boolean keepVar=true;
    keepVar=determineKeepVariation(positionOnReference,referenceIndex,keepVar);
    if (keepVar && !isAllNs(to)) {
      printTab(alignmentEntry,basename,positionOnReference,readIndex,from,to,qualityScores);
    }
  }
}
break;
case TAB_SINGLE_BASE:
{
for (final Alignments.SequenceVariation var : alignmentEntry.getSequenceVariationsList()) {
final int positionOnReference=alignmentEntry.getPosition() + var.getPosition();
final int readIndex=var.getReadIndex();
final String from=var.getFrom();
final String to=var.getTo();
final int fromLength=from.length();
final int toLength=to.length();
final int referenceIndex=alignmentEntry.getTargetIndex();
final byte[] qualityScores;
if (var.hasToQuality()) {
  qualityScores=var.getToQuality().toByteArray();
}
 else {
  qualityScores=null;
}
boolean keepVar=true;
keepVar=determineKeepVariation(positionOnReference,referenceIndex,keepVar);
if (keepVar && !isAllNs(to)) {
  final int maxLength=Math.max(fromLength,toLength);
  int fromOffset=0;
  int toOffset=0;
  int readIndexIncrementValue=(alignmentEntry.getMatchingReverseStrand() ? -1 : 1);
  byte[] toScore;
  if (qualityScores != null) {
    toScore=new byte[1];
  }
 else {
    toScore=null;
  }
  for (int i=0; i < maxLength; i++) {
    final char fromChar=var.getFrom().charAt(i);
    final char toChar=var.getTo().charAt(i);
    if (qualityScores != null) {
      if (i < qualityScores.length) {
        toScore[0]=qualityScores[i];
      }
 else {
        toScore=null;
      }
    }
    printTab(alignmentEntry,basename,positionOnReference + fromOffset,readIndex + toOffset,i < fromLength ? Character.toString(fromChar) : ""String_Node_Str"",i < toLength ? Character.toString(toChar) : ""String_Node_Str"",toScore);
    if (fromChar != '-') {
      fromOffset+=1;
    }
    if (toChar != '-') {
      toOffset+=readIndexIncrementValue;
    }
  }
}
}
}
break;
}
}"
50307,"private void analyzeCigar(int position,String cigar,ObjectArrayList<Limits> list){
  Matcher matcher=CIGAR_REGEX.matcher(cigar);
  int previousCigarIndex=0;
  int cigarIndex=0;
  int previousPosition=position;
  int previousPositionInRead=0;
  int positionInRead=0;
  int initialRefPosition=position;
  while (matcher.find()) {
    final int cigarLength=matcher.group(1).length() + matcher.group(2).length();
    final int readBasesLength=Integer.parseInt(matcher.group(1));
    final char op=matcher.group(2).charAt(0);
switch (op) {
case 'N':
      list.add(new Limits(previousPosition,previousCigarIndex,cigarIndex,previousPositionInRead,positionInRead,previousPosition,position));
    previousCigarIndex=cigarIndex + cigarLength;
  previousPositionInRead=positionInRead;
position+=readBasesLength;
previousPosition=position;
break;
case 'I':
if (usingGenome) {
positionInRead+=readBasesLength;
position+=readBasesLength;
}
break;
case 'D':
if (usingGenome) {
insertSomeInRef(position,initialRefPosition,readBasesLength);
}
break;
case 'S':
if (usingGenome) {
insertSomeInRef(position,initialRefPosition,readBasesLength);
}
break;
default :
positionInRead+=readBasesLength;
position+=readBasesLength;
break;
}
cigarIndex+=cigarLength;
}
list.add(new Limits(previousPosition,previousCigarIndex,cigarIndex,previousPositionInRead,positionInRead,previousPosition,position));
}","private void analyzeCigar(int position,String cigar,ObjectArrayList<Limits> list){
  Matcher matcher=CIGAR_REGEX.matcher(cigar);
  int previousCigarIndex=0;
  int cigarIndex=0;
  int previousPosition=position;
  int previousPositionInRead=0;
  int positionInRead=0;
  int initialRefPosition=position;
  while (matcher.find()) {
    final int cigarLength=matcher.group(1).length() + matcher.group(2).length();
    final int readBasesLength=Integer.parseInt(matcher.group(1));
    final char op=matcher.group(2).charAt(0);
switch (op) {
case 'N':
      list.add(new Limits(previousPosition,previousCigarIndex,cigarIndex,previousPositionInRead,positionInRead,previousPosition,position));
    previousCigarIndex=cigarIndex + cigarLength;
  previousPositionInRead=positionInRead;
position+=readBasesLength;
previousPosition=position;
break;
case 'I':
if (usingGenome) {
positionInRead+=readBasesLength;
position+=readBasesLength;
}
break;
case 'D':
if (usingGenome) {
insertSomeInRef(position,initialRefPosition,readBasesLength);
}
break;
case 'S':
if (usingGenome) {
insertSomeInRef(position,initialRefPosition,readBasesLength);
}
positionInRead+=readBasesLength;
previousPositionInRead+=readBasesLength;
break;
default :
positionInRead+=readBasesLength;
position+=readBasesLength;
break;
}
cigarIndex+=cigarLength;
}
list.add(new Limits(previousPosition,previousCigarIndex,cigarIndex,previousPositionInRead,positionInRead,previousPosition,position));
}"
50308,"/** 
 * Build an ExportableAlignmentEntryData object from an alignment entry.
 * @param alignmentEntry     a Goby alignment entry
 * @param actualReadsSrc     the actual reads from the original reads file. Only provided during tests.
 * @param actualQualitiesSrc the actual qualities from the original reads file. Only provided during tests.
 */
public void buildFrom(final Alignments.AlignmentEntry alignmentEntry,final CharList actualReadsSrc,final ByteList actualQualitiesSrc){
  reset();
  reverseStrand=alignmentEntry.getMatchingReverseStrand();
  setActualReads(actualReadsSrc,reverseStrand);
  setActualQuals(actualQualitiesSrc,reverseStrand);
  startClip=alignmentEntry.getQueryPosition();
  queryLength=alignmentEntry.getQueryLength();
  queryAlignedLength=alignmentEntry.getQueryAlignedLength();
  targetAlignedLength=alignmentEntry.getTargetAlignedLength();
  endClip=queryLength - queryAlignedLength - startClip;
  final int startPosition=alignmentEntry.getPosition();
  this.alignmentEntry=alignmentEntry;
  if (hasReadGroups) {
    final int readOriginIndex=alignmentEntry.getReadOriginIndex();
    final Alignments.ReadOriginInfo info=readOriginInfo.getInfo(readOriginIndex);
    if (info == null) {
      invalid=true;
      invalidMessage.append(String.format(""String_Node_Str"",readOriginIndex));
      if (debug) {
        LOG.debug(invalidMessage.toString());
      }
    }
 else {
      readGroup=info.getOriginId();
    }
  }
  int numInserts=0;
  for (  final Alignments.SequenceVariation seqvar : alignmentEntry.getSequenceVariationsList()) {
    final String froms=seqvar.getFrom();
    final String tos=seqvar.getTo();
    final int fromsLength=froms.length();
    final int tosLength=tos.length();
    if (fromsLength != tosLength) {
      invalid=true;
      invalidMessage.append(""String_Node_Str"").append(alignmentEntry.getQueryIndex()).append(""String_Node_Str"");
      if (debug) {
        LOG.debug(invalidMessage.toString());
      }
      return;
    }
    for (int i=0; i < froms.length(); i++) {
      final char from=froms.charAt(i);
      final char to=tos.charAt(i);
      if (from == '-' && to == '-') {
        invalid=true;
        invalidMessage.append(""String_Node_Str"").append(alignmentEntry.getQueryIndex()).append(""String_Node_Str"");
        if (debug) {
          LOG.debug(invalidMessage.toString());
        }
        return;
      }
      if (from == '-') {
        numInserts+=1;
      }
    }
  }
  final boolean predefinedQuals=alignmentEntry.hasReadQualityScores();
  final int endOfLoop=targetAlignedLength + startClip + endClip+ numInserts;
  final int targetIndex=alignmentEntry.getTargetIndex();
  final char[] predefStartClips=alignmentEntry.hasSoftClippedBasesLeft() ? alignmentEntry.getSoftClippedBasesLeft().toCharArray() : null;
  final char[] predefEndClips=alignmentEntry.hasSoftClippedBasesRight() ? alignmentEntry.getSoftClippedBasesRight().toCharArray() : null;
  for (int i=0; i < endOfLoop; i++) {
    final char base=genome.get(targetIndex,i + startPosition - startClip);
    if (i < startClip) {
      if (predefStartClips != null) {
        final char clipBase=predefStartClips[i];
        if (clipBase == '=') {
          readBases.add(base);
        }
 else {
          readBases.add(clipBase);
        }
      }
 else {
        readBases.add('N');
      }
    }
 else {
      readBases.add(base);
    }
    refBases.add(base);
    if (!predefinedQuals) {
      qualities.add(UNKNOWN_MAPPING_VALUE);
    }
  }
  if (predefinedQuals) {
    for (    final byte value : alignmentEntry.getReadQualityScores().toByteArray()) {
      qualities.add(value);
    }
    hasQualities=true;
  }
  if (!alignmentEntry.getSequenceVariationsList().isEmpty()) {
    if (debug) {
      LOG.debug(""String_Node_Str"");
      LOG.debug(""String_Node_Str"" + toString());
    }
  }
  for (  final Alignments.SequenceVariation seqvar : alignmentEntry.getSequenceVariationsList()) {
    if (debug) {
      LOG.debug(seqVarToString(seqvar));
    }
    final String froms=seqvar.getFrom();
    final String tos=seqvar.getTo();
    final int startRefPosition=seqvar.getPosition();
    final byte[] toQuals=seqvar.hasToQuality() ? seqvar.getToQuality().toByteArray() : null;
    for (int i=0; i < froms.length(); i++) {
      final char from=froms.charAt(i);
      final char to=tos.charAt(i);
      final Byte toQual=toQuals == null ? null : (byte)qualityEncoding.phredQualityScoreToAsciiEncoding(toQuals[i]);
      final int refPosition=startRefPosition + i - 1;
      if (from == '-') {
        refBases.add(refPosition + 1,from);
        readBases.add(refPosition + 1,to);
        if (toQual != null) {
          qualities.add(refPosition + 1,toQual);
          hasQualities=true;
        }
      }
 else       if (to == '-') {
        if (refBases.get(refPosition) != from) {
          invalid=false;
          invalidMessage.append(""String_Node_Str"").append(alignmentEntry.getQueryIndex()).append(""String_Node_Str"").append(from).append(""String_Node_Str"").append(refBases.get(refPosition)).append('\n');
          if (debug) {
            LOG.debug(invalidMessage.toString());
          }
          if (invalid) {
            return;
          }
        }
        readBases.set(refPosition,to);
        deleteQualityIndexes.addFirst(refPosition);
      }
 else {
        if (refBases.get(refPosition) != from) {
          invalid=false;
          invalidMessage.append(""String_Node_Str"").append(alignmentEntry.getQueryIndex()).append(""String_Node_Str"").append(from).append(""String_Node_Str"").append(refBases.get(refPosition)).append('\n');
          if (debug) {
            LOG.debug(invalidMessage.toString());
          }
          if (invalid) {
            return;
          }
        }
        readBases.set(refPosition,to);
        if (toQual != null) {
          qualities.set(refPosition,toQual);
          hasQualities=true;
        }
      }
    }
  }
  for (  final int deleteQualityIndex : deleteQualityIndexes) {
    qualities.remove(deleteQualityIndex);
  }
  if (numInserts > 0) {
    refBases.size(refBases.size() - numInserts);
    readBases.size(readBases.size() - numInserts);
    qualities.size(qualities.size() - numInserts);
  }
  if (endClip > 0) {
    final int readSize=readBases.size();
    for (int i=0; i < endClip; i++) {
      char clipBase;
      if (predefEndClips == null) {
        clipBase='N';
      }
 else {
        clipBase=predefEndClips[i];
        if (clipBase == '=') {
          clipBase='N';
        }
      }
      readBases.set(readSize - i - 1,clipBase);
    }
  }
  for (  final char readBase : readBases) {
    if (readBase != '-') {
      readBasesOriginal.append(readBase);
    }
  }
  observeReadRefDifferences();
  endTargetPositionZeroBased=alignmentEntry.getPosition() + startClip + alignmentEntry.getTargetAlignedLength();
  if (debug) {
    LOG.debug(""String_Node_Str"" + toString());
  }
}","/** 
 * Build an ExportableAlignmentEntryData object from an alignment entry.
 * @param alignmentEntry     a Goby alignment entry
 * @param actualReadsSrc     the actual reads from the original reads file. Only provided during tests.
 * @param actualQualitiesSrc the actual qualities from the original reads file. Only provided during tests.
 */
public void buildFrom(final Alignments.AlignmentEntry alignmentEntry,final CharList actualReadsSrc,final ByteList actualQualitiesSrc){
  reset();
  reverseStrand=alignmentEntry.getMatchingReverseStrand();
  setActualReads(actualReadsSrc,reverseStrand);
  setActualQuals(actualQualitiesSrc,reverseStrand);
  startClip=alignmentEntry.getQueryPosition();
  queryLength=alignmentEntry.getQueryLength();
  queryAlignedLength=alignmentEntry.getQueryAlignedLength();
  targetAlignedLength=alignmentEntry.getTargetAlignedLength();
  endClip=queryLength - queryAlignedLength - startClip;
  final int startPosition=alignmentEntry.getPosition();
  this.alignmentEntry=alignmentEntry;
  if (hasReadGroups) {
    final int readOriginIndex=alignmentEntry.getReadOriginIndex();
    final Alignments.ReadOriginInfo info=readOriginInfo.getInfo(readOriginIndex);
    if (info == null) {
      invalid=true;
      invalidMessage.append(String.format(""String_Node_Str"",readOriginIndex));
      if (debug) {
        LOG.debug(invalidMessage.toString());
      }
    }
 else {
      readGroup=info.getOriginId();
    }
  }
  int numInserts=0;
  for (  final Alignments.SequenceVariation seqvar : alignmentEntry.getSequenceVariationsList()) {
    final String froms=seqvar.getFrom();
    final String tos=seqvar.getTo();
    final int fromsLength=froms.length();
    final int tosLength=tos.length();
    if (fromsLength != tosLength) {
      invalid=true;
      invalidMessage.append(""String_Node_Str"").append(alignmentEntry.getQueryIndex()).append(""String_Node_Str"");
      if (debug) {
        LOG.debug(invalidMessage.toString());
      }
      return;
    }
    for (int i=0; i < froms.length(); i++) {
      final char from=froms.charAt(i);
      final char to=tos.charAt(i);
      if (from == '-' && to == '-') {
        invalid=true;
        invalidMessage.append(""String_Node_Str"").append(alignmentEntry.getQueryIndex()).append(""String_Node_Str"");
        if (debug) {
          LOG.debug(invalidMessage.toString());
        }
        return;
      }
      if (from == '-') {
        numInserts+=1;
      }
    }
  }
  final boolean predefinedQuals=alignmentEntry.hasReadQualityScores();
  final int endOfLoop=targetAlignedLength + startClip + endClip+ numInserts;
  final int targetIndex=alignmentEntry.getTargetIndex();
  final char[] predefStartClips=alignmentEntry.hasSoftClippedBasesLeft() ? alignmentEntry.getSoftClippedBasesLeft().toCharArray() : null;
  final char[] predefEndClips=alignmentEntry.hasSoftClippedBasesRight() ? alignmentEntry.getSoftClippedBasesRight().toCharArray() : null;
  for (int i=0; i < endOfLoop; i++) {
    final int genomePosition=i + startPosition - startClip;
    final char base=genomePosition >= 0 ? genome.get(targetIndex,i + startPosition - startClip) : 'N';
    if (i < startClip) {
      if (predefStartClips != null) {
        final char clipBase=predefStartClips[i];
        if (clipBase == '=') {
          readBases.add(base);
        }
 else {
          readBases.add(clipBase);
        }
      }
 else {
        readBases.add('N');
      }
    }
 else {
      readBases.add(base);
    }
    refBases.add(base);
    if (!predefinedQuals) {
      qualities.add(UNKNOWN_MAPPING_VALUE);
    }
  }
  if (predefinedQuals) {
    for (    final byte value : alignmentEntry.getReadQualityScores().toByteArray()) {
      qualities.add(value);
    }
    hasQualities=true;
  }
  if (!alignmentEntry.getSequenceVariationsList().isEmpty()) {
    if (debug) {
      LOG.debug(""String_Node_Str"");
      LOG.debug(""String_Node_Str"" + toString());
    }
  }
  for (  final Alignments.SequenceVariation seqvar : alignmentEntry.getSequenceVariationsList()) {
    if (debug) {
      LOG.debug(seqVarToString(seqvar));
    }
    final String froms=seqvar.getFrom();
    final String tos=seqvar.getTo();
    final int startRefPosition=seqvar.getPosition();
    final byte[] toQuals=seqvar.hasToQuality() ? seqvar.getToQuality().toByteArray() : null;
    for (int i=0; i < froms.length(); i++) {
      final char from=froms.charAt(i);
      final char to=tos.charAt(i);
      final Byte toQual=toQuals == null ? null : (byte)qualityEncoding.phredQualityScoreToAsciiEncoding(toQuals[i]);
      final int refPosition=startRefPosition + i - 1;
      if (from == '-') {
        refBases.add(refPosition + 1,from);
        readBases.add(refPosition + 1,to);
        if (toQual != null) {
          qualities.add(refPosition + 1,toQual);
          hasQualities=true;
        }
      }
 else       if (to == '-') {
        if (refBases.get(refPosition) != from) {
          invalid=false;
          invalidMessage.append(""String_Node_Str"").append(alignmentEntry.getQueryIndex()).append(""String_Node_Str"").append(from).append(""String_Node_Str"").append(refBases.get(refPosition)).append('\n');
          if (debug) {
            LOG.debug(invalidMessage.toString());
          }
          if (invalid) {
            return;
          }
        }
        readBases.set(refPosition,to);
        deleteQualityIndexes.addFirst(refPosition);
      }
 else {
        if (refBases.get(refPosition) != from) {
          invalid=false;
          invalidMessage.append(""String_Node_Str"").append(alignmentEntry.getQueryIndex()).append(""String_Node_Str"").append(from).append(""String_Node_Str"").append(refBases.get(refPosition)).append('\n');
          if (debug) {
            LOG.debug(invalidMessage.toString());
          }
          if (invalid) {
            return;
          }
        }
        readBases.set(refPosition,to);
        if (toQual != null) {
          qualities.set(refPosition,toQual);
          hasQualities=true;
        }
      }
    }
  }
  for (  final int deleteQualityIndex : deleteQualityIndexes) {
    qualities.remove(deleteQualityIndex);
  }
  if (numInserts > 0) {
    refBases.size(refBases.size() - numInserts);
    readBases.size(readBases.size() - numInserts);
    qualities.size(qualities.size() - numInserts);
  }
  if (endClip > 0) {
    final int readSize=readBases.size();
    for (int i=0; i < endClip; i++) {
      char clipBase;
      if (predefEndClips == null) {
        readBases.set(readSize - i - 1,'N');
      }
 else {
        readBases.set(readSize - i - 1,predefEndClips[i]);
      }
    }
  }
  for (  final char readBase : readBases) {
    if (readBase != '-') {
      readBasesOriginal.append(readBase);
    }
  }
  observeReadRefDifferences();
  endTargetPositionZeroBased=alignmentEntry.getPosition() + startClip + targetAlignedLength;
  if (debug) {
    LOG.debug(""String_Node_Str"" + toString());
  }
}"
50309,"private void readMinimalUnary(final String label,final int numEntriesInChunk,final InputBitStream bitInput,final IntList list) throws IOException {
  final int size=bitInput.readNibble();
  if (size == 0) {
    return;
  }
  final int min=bitInput.readNibble();
  final int max=bitInput.readNibble();
  final int b=max - min + 1;
  final int log2b=Math.max(1,Fast.mostSignificantBit(b));
  for (int i=0; i < size; i++) {
    final int reducedReadIndex=bitInput.readMinimalBinary(max - min + 1,log2b);
    list.add(reducedReadIndex + min);
  }
}","private void readMinimalUnary(final String label,final int numEntriesInChunk,final InputBitStream bitInput,final IntList list) throws IOException {
  final int size=bitInput.readNibble();
  if (size == 0) {
    return;
  }
  final int min=bitInput.readNibble();
  final int max=bitInput.readNibble();
  final int b=max - min + 1;
  final int log2b=Fast.mostSignificantBit(b);
  for (int i=0; i < size; i++) {
    final int reducedReadIndex=bitInput.readMinimalBinary(max - min + 1,log2b);
    list.add(reducedReadIndex + min);
  }
}"
50310,"private void writeQueryIndices(final String label,final IntList list,final OutputBitStream out) throws IOException {
  boolean success=tryWriteDeltas(label,list,out);
  if (success) {
    return;
  }
 else {
    out.writeDelta(MINIMAL_BINARY_ENCODING_SCHEME);
  }
  int min=Integer.MAX_VALUE;
  int max=Integer.MIN_VALUE;
  final int size=list.size();
  for (  final int value : list) {
    min=Math.min(value,min);
    max=Math.max(value,max);
  }
  out.writeNibble(size);
  if (size == 0) {
    return;
  }
  out.writeNibble(min);
  out.writeNibble(max);
  final long writtenStart=out.writtenBits();
  final int b=max - min + 1;
  final int log2b=Math.max(1,Fast.mostSignificantBit(b));
  for (  final int value : list) {
    out.writeMinimalBinary(value - min,b,log2b);
  }
  if (debug(1)) {
    final long writtenStop=out.writtenBits();
    final long written=writtenStop - writtenStart;
    recordStats(label,list,written);
  }
}","private void writeQueryIndices(final String label,final IntList list,final OutputBitStream out) throws IOException {
  boolean success=tryWriteDeltas(label,list,out);
  if (success) {
    return;
  }
 else {
    out.writeDelta(MINIMAL_BINARY_ENCODING_SCHEME);
  }
  int min=Integer.MAX_VALUE;
  int max=Integer.MIN_VALUE;
  final int size=list.size();
  for (  final int value : list) {
    min=Math.min(value,min);
    max=Math.max(value,max);
  }
  out.writeNibble(size);
  if (size == 0) {
    return;
  }
  out.writeNibble(min);
  out.writeNibble(max);
  final long writtenStart=out.writtenBits();
  final int b=max - min + 1;
  final int log2b=Fast.mostSignificantBit(b);
  for (  final int value : list) {
    out.writeMinimalBinary(value - min,b,log2b);
  }
  if (debug(1)) {
    final long writtenStop=out.writtenBits();
    final long written=writtenStop - writtenStart;
    recordStats(label,list,written);
  }
}"
50311,"private void readAsDeltas(String label,int numEntriesInChunk,InputBitStream bitInput,IntList list) throws IOException {
  IntArrayList deltas=new IntArrayList();
  int previous=bitInput.readNibble();
  list.add(previous);
  decodeArithmetic(label,numEntriesInChunk - 1,bitInput,deltas);
  for (  int delta : deltas) {
    final int newValue=Fast.nat2int(delta) + previous;
    list.add(newValue);
    previous=newValue;
  }
}","private void readAsDeltas(String label,int numEntriesInChunk,InputBitStream bitInput,IntList list) throws IOException {
  IntArrayList deltas=new IntArrayList();
  int previous=bitInput.readNibble();
  decodeArithmetic(label,numEntriesInChunk - 1,bitInput,deltas);
  list.add(previous);
  for (  int delta : deltas) {
    final int newValue=Fast.nat2int(delta) + previous;
    list.add(newValue);
    previous=newValue;
  }
}"
50312,"protected final void decodeArithmetic(final String label,final int numEntriesInChunk,final InputBitStream bitInput,final IntList list) throws IOException {
  if (debug(2)) {
    System.err.flush();
    System.err.println(""String_Node_Str"" + label + ""String_Node_Str""+ bitInput.available());
    System.err.flush();
  }
  if (numEntriesInChunk == 0) {
    return;
  }
  final int size=bitInput.readNibble();
  if (size == 0) {
    return;
  }
  final boolean hasNegatives=bitInput.readBit() == 1;
  final int numTokens=bitInput.readNibble();
  final int[] distinctvalue=new int[numTokens];
  for (int i=0; i < numTokens; i++) {
    final int token=bitInput.readNibble();
    final int anInt=hasNegatives ? Fast.nat2int(token) : token - 1;
    distinctvalue[i]=anInt;
  }
  if (hasNegatives) {
    Arrays.sort(distinctvalue);
  }
  final FastArithmeticDecoder decoder=new FastArithmeticDecoder(numTokens);
  for (int i=0; i < size; i++) {
    final int tokenValue=distinctvalue[decoder.decode(bitInput)];
    list.add(tokenValue);
  }
  decoder.reposition(bitInput);
}","protected final void decodeArithmetic(final String label,final int numEntriesInChunk,final InputBitStream bitInput,final IntList list) throws IOException {
  if (debug(2)) {
    System.err.flush();
    System.err.println(""String_Node_Str"" + label + ""String_Node_Str""+ bitInput.available());
    System.err.flush();
  }
  final int size=bitInput.readNibble();
  if (size == 0) {
    return;
  }
  final boolean hasNegatives=bitInput.readBit() == 1;
  final int numTokens=bitInput.readNibble();
  final int[] distinctvalue=new int[numTokens];
  for (int i=0; i < numTokens; i++) {
    final int token=bitInput.readNibble();
    final int anInt=hasNegatives ? Fast.nat2int(token) : token - 1;
    distinctvalue[i]=anInt;
  }
  if (hasNegatives) {
    Arrays.sort(distinctvalue);
  }
  final FastArithmeticDecoder decoder=new FastArithmeticDecoder(numTokens);
  for (int i=0; i < size; i++) {
    final int tokenValue=distinctvalue[decoder.decode(bitInput)];
    list.add(tokenValue);
  }
  decoder.reposition(bitInput);
}"
50313,"private void readMinimalUnary(final String label,final int numEntriesInChunk,final InputBitStream bitInput,final IntList list) throws IOException {
  final int size=bitInput.readNibble();
  if (size == 0) {
    return;
  }
  final int min=bitInput.readNibble();
  final int max=bitInput.readNibble();
  for (int i=0; i < size; i++) {
    final int reducedReadIndex=bitInput.readMinimalBinary(max - min + 1);
    list.add(reducedReadIndex + min);
  }
}","private void readMinimalUnary(final String label,final int numEntriesInChunk,final InputBitStream bitInput,final IntList list) throws IOException {
  final int size=bitInput.readNibble();
  if (size == 0) {
    return;
  }
  final int min=bitInput.readNibble();
  final int max=bitInput.readNibble();
  final int b=max - min + 1;
  final int log2b=Math.max(1,Fast.mostSignificantBit(b));
  for (int i=0; i < size; i++) {
    final int reducedReadIndex=bitInput.readMinimalBinary(max - min + 1,log2b);
    list.add(reducedReadIndex + min);
  }
}"
50314,"private void writeQueryIndices(final String label,final IntList list,final OutputBitStream out) throws IOException {
  boolean success=tryWriteDeltas(label,list,out);
  if (success) {
    return;
  }
 else {
    out.writeDelta(MINIMAL_BINARY_ENCODING_SCHEME);
  }
  int min=Integer.MAX_VALUE;
  int max=Integer.MIN_VALUE;
  final int size=list.size();
  for (  final int value : list) {
    min=Math.min(value,min);
    max=Math.max(value,max);
  }
  out.writeNibble(size);
  if (size == 0) {
    return;
  }
  out.writeNibble(min);
  out.writeNibble(max);
  final long writtenStart=out.writtenBits();
  final int b=max - min + 1;
  final int log2b=Fast.mostSignificantBit(b);
  for (  final int value : list) {
    out.writeMinimalBinary(value - min,b,log2b);
  }
  if (debug(1)) {
    final long writtenStop=out.writtenBits();
    final long written=writtenStop - writtenStart;
    recordStats(label,list,written);
  }
}","private void writeQueryIndices(final String label,final IntList list,final OutputBitStream out) throws IOException {
  boolean success=tryWriteDeltas(label,list,out);
  if (success) {
    return;
  }
 else {
    out.writeDelta(MINIMAL_BINARY_ENCODING_SCHEME);
  }
  int min=Integer.MAX_VALUE;
  int max=Integer.MIN_VALUE;
  final int size=list.size();
  for (  final int value : list) {
    min=Math.min(value,min);
    max=Math.max(value,max);
  }
  out.writeNibble(size);
  if (size == 0) {
    return;
  }
  out.writeNibble(min);
  out.writeNibble(max);
  final long writtenStart=out.writtenBits();
  final int b=max - min + 1;
  final int log2b=Math.max(1,Fast.mostSignificantBit(b));
  for (  final int value : list) {
    out.writeMinimalBinary(value - min,b,log2b);
  }
  if (debug(1)) {
    final long writtenStop=out.writtenBits();
    final long written=writtenStop - writtenStart;
    recordStats(label,list,written);
  }
}"
50315,"public void roundTripBug() throws IOException {
  final HybridChunkCodec1 codec=new HybridChunkCodec1();
  codec.setHandler(new AlignmentCollectionHandler());
  Alignments.AlignmentCollection.Builder collection=loadCollection(""String_Node_Str"",10000 * 117 - 5000,10000);
  assertRoundTripMatchExpected(codec,collection);
}","@Test public void roundTripBug() throws IOException {
  final HybridChunkCodec1 codec=new HybridChunkCodec1();
  codec.setHandler(new AlignmentCollectionHandler());
  Alignments.AlignmentCollection.Builder collection=loadCollection(""String_Node_Str"",10000 * 117 - 5000,10000);
  assertRoundTripMatchExpected(codec,collection);
}"
50316,"public void roundTripLarge() throws IOException {
  final HybridChunkCodec1 codec=new HybridChunkCodec1();
  codec.setHandler(new AlignmentCollectionHandler());
  Alignments.AlignmentCollection.Builder collection=loadCollection(""String_Node_Str"",0,100);
  assertRoundTripMatchExpected(codec,collection,false);
}","@Test public void roundTripLarge() throws IOException {
  final HybridChunkCodec1 codec=new HybridChunkCodec1();
  codec.setHandler(new AlignmentCollectionHandler());
  Alignments.AlignmentCollection.Builder collection=loadCollection(""String_Node_Str"",0,100);
  assertRoundTripMatchExpected(codec,collection,false);
}"
50317,"@Override public Message decompressCollection(Message reducedCollection,byte[] compressedBytes) throws IOException {
  reset();
  byte[] moreRoom=new byte[compressedBytes.length + 100];
  System.arraycopy(compressedBytes,0,moreRoom,0,compressedBytes.length);
  final Alignments.AlignmentCollection alignmentCollection=(Alignments.AlignmentCollection)reducedCollection;
  final Alignments.AlignmentCollection.Builder result=Alignments.AlignmentCollection.newBuilder();
  final InputBitStream bitInput=new InputBitStream(new FastByteArrayInputStream(moreRoom));
  final int numEntriesInChunk=alignmentCollection.getAlignmentEntriesCount();
  final int streamVersion=decompressBits(bitInput,numEntriesInChunk);
  int originalIndex=0;
  for (int templateIndex=0; templateIndex < numEntriesInChunk; templateIndex++) {
    final int templatePositionIndex=varPositionIndex;
    final int templateVarFromToIndex=varFromToIndex;
    final int templateVarHasToQualsIndex=varToQualsLength;
    while (multiplicities.get(templateIndex) >= 1) {
      result.addAlignmentEntries(andBack(templateIndex,originalIndex,alignmentCollection.getAlignmentEntries(templateIndex),streamVersion));
      if (multiplicities.get(templateIndex) >= 1) {
        varPositionIndex=templatePositionIndex;
        varFromToIndex=templateVarFromToIndex;
        varToQualsLength=templateVarHasToQualsIndex;
      }
      originalIndex++;
    }
  }
  ++chunkIndex;
  return result.build();
}","@Override public Message decompressCollection(Message reducedCollection,byte[] compressedBytes) throws IOException {
  reset();
  byte[] moreRoom=new byte[compressedBytes.length + 100];
  System.arraycopy(compressedBytes,0,moreRoom,0,compressedBytes.length);
  final Alignments.AlignmentCollection alignmentCollection=(Alignments.AlignmentCollection)reducedCollection;
  final Alignments.AlignmentCollection.Builder result=Alignments.AlignmentCollection.newBuilder();
  final InputBitStream bitInput=new InputBitStream(new FastByteArrayInputStream(moreRoom));
  final int numEntriesInChunk=alignmentCollection.getAlignmentEntriesCount();
  final int streamVersion=decompressBits(bitInput,numEntriesInChunk);
  int originalIndex=0;
  for (int templateIndex=0; templateIndex < numEntriesInChunk; templateIndex++) {
    final int templatePositionIndex=varPositionIndex;
    final int templateVarFromToIndex=varFromToIndex;
    final int templateVarHasToQualsIndex=varToQualLengthIndex;
    while (multiplicities.get(templateIndex) >= 1) {
      result.addAlignmentEntries(andBack(templateIndex,originalIndex,alignmentCollection.getAlignmentEntries(templateIndex),streamVersion));
      if (multiplicities.get(templateIndex) >= 1) {
        varPositionIndex=templatePositionIndex;
        varFromToIndex=templateVarFromToIndex;
      }
      originalIndex++;
    }
  }
  ++chunkIndex;
  return result.build();
}"
50318,"private Alignments.AlignmentEntry andBack(final int index,int originalIndex,final Alignments.AlignmentEntry reduced,int streamVersion){
  final Alignments.AlignmentEntry.Builder result=Alignments.AlignmentEntry.newBuilder(reduced);
  final int multiplicity=multiplicities.get(index);
  final int k=multiplicity - 1;
  multiplicities.set(index,k);
  if (!multiplicityFieldsAllMissing) {
    result.setMultiplicity(1);
  }
  final int queryIndex=queryIndices.getInt(originalIndex);
  result.setQueryIndex(queryIndex);
  if (originalIndex == 0 || reduced.hasPosition() || reduced.hasTargetIndex()) {
    previousPosition=reduced.getPosition();
    previousTargetIndex=reduced.getTargetIndex();
  }
 else {
    final int deltaPos=deltaPositions.getInt(deltaPosIndex);
    final int deltaTarget=deltaTargetIndices.getInt(deltaPosIndex);
    final int position=previousPosition + deltaPos;
    final int targetIndex=previousTargetIndex + deltaTarget;
    result.setPosition(position);
    result.setTargetIndex(targetIndex);
    previousPosition+=deltaPos;
    previousTargetIndex+=deltaTarget;
    deltaPosIndex++;
  }
  if (streamVersion >= 2) {
    final int numReadQualScores=numReadQualityScores.get(index);
    if (numReadQualScores > 0) {
      final byte[] scores=new byte[numReadQualScores];
      for (int i=0; i < numReadQualScores; i++) {
        scores[i]=(byte)allReadQualityScores.getInt(qualScoreIndex++);
      }
      result.setReadQualityScores(ByteString.copyFrom(scores));
    }
  }
  int anInt=mappingQualities.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setMappingQuality(anInt);
  }
  anInt=fragmentIndices.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setFragmentIndex(anInt);
  }
  anInt=matchingReverseStrand.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setMatchingReverseStrand(anInt == 1);
  }
  anInt=numberOfMismatches.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setNumberOfMismatches(anInt);
  }
  anInt=numberOfIndels.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setNumberOfIndels(anInt);
  }
  final int queryLength=queryLengths.getInt(index);
  if (queryLength != MISSING_VALUE) {
    result.setQueryLength(queryLength);
  }
  anInt=queryAlignedLengths.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setQueryAlignedLength(anInt);
  }
  anInt=queryPositions.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setQueryPosition(anInt);
  }
  anInt=targetAlignedLengths.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setTargetAlignedLength(anInt);
  }
  anInt=sampleIndices.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setSampleIndex(anInt);
  }
  anInt=readOriginIndices.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setReadOriginIndex(anInt);
  }
  anInt=pairFlags.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setPairFlags(anInt);
  }
  anInt=scores.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setScore(Float.intBitsToFloat(anInt));
  }
  final boolean entryMatchingReverseStrand=result.hasMatchingReverseStrand() ? result.getMatchingReverseStrand() : false;
  Alignments.RelatedAlignmentEntry link=pairLinks.decode(originalIndex,entryMatchingReverseStrand,reduced.getPairAlignmentLink());
  if (link != null) {
    result.setPairAlignmentLink(link);
  }
  link=forwardSpliceLinks.decode(originalIndex,entryMatchingReverseStrand,reduced.getSplicedForwardAlignmentLink());
  if (link != null) {
    result.setSplicedForwardAlignmentLink(link);
  }
  link=backwardSpliceLinks.decode(originalIndex,entryMatchingReverseStrand,reduced.getSplicedBackwardAlignmentLink());
  if (link != null) {
    result.setSplicedBackwardAlignmentLink(link);
  }
  decodeInsertSize(result,index);
  final boolean templateHasSequenceVariations=reduced.getSequenceVariationsCount() > 0;
  final int numVariations=variationCount.getInt(index);
  for (int varIndex=0; varIndex < numVariations; varIndex++) {
    final Alignments.SequenceVariation template=templateHasSequenceVariations ? reduced.getSequenceVariations(varIndex) : null;
    final Alignments.SequenceVariation.Builder varBuilder=templateHasSequenceVariations ? Alignments.SequenceVariation.newBuilder(template) : Alignments.SequenceVariation.newBuilder();
    from.setLength(0);
    to.setLength(0);
    final int fromLength=fromLengths.getInt(varPositionIndex);
    final int toLength=toLengths.getInt(varPositionIndex);
    final int position=varPositions.getInt(varPositionIndex);
    varBuilder.setPosition(position);
    final int recodedReadIndex=varReadIndex.getInt(varPositionIndex);
    final int readIndex=entryMatchingReverseStrand ? recodedReadIndex + (queryLength - position) - 5 : -recodedReadIndex + position + 5;
    varBuilder.setReadIndex(readIndex);
    final int toQualLength=varToQualLength.getInt(varToQualsLength);
    varToQualsLength++;
    final byte[] quals=getQualArray(toQualLength);
    ++varPositionIndex;
    final int maxLength=Math.max(fromLength,toLength);
    for (int i=0; i < maxLength; i++) {
      final int fromTo=varFromTo.getInt(varFromToIndex++);
      if (i < fromLength) {
        from.append((char)(fromTo >> 8));
      }
      if (i < toLength) {
        to.append((char)(fromTo & 0xFF));
      }
      if (i < toQualLength) {
        if (varQualIndex < varQuals.size()) {
          quals[i]=(byte)varQuals.getInt(varQualIndex);
          ++varQualIndex;
        }
      }
    }
    varBuilder.setFrom(from.toString());
    varBuilder.setTo(to.toString());
    if (toQualLength > 0) {
      varBuilder.setToQuality(ByteString.copyFrom(quals));
    }
    if (templateHasSequenceVariations) {
      result.setSequenceVariations(varIndex,varBuilder);
    }
 else {
      result.addSequenceVariations(varBuilder);
    }
  }
  return result.build();
}","private Alignments.AlignmentEntry andBack(final int index,int originalIndex,final Alignments.AlignmentEntry reduced,int streamVersion){
  final Alignments.AlignmentEntry.Builder result=Alignments.AlignmentEntry.newBuilder(reduced);
  final int multiplicity=multiplicities.get(index);
  final int k=multiplicity - 1;
  multiplicities.set(index,k);
  if (!multiplicityFieldsAllMissing) {
    result.setMultiplicity(1);
  }
  final int queryIndex=queryIndices.getInt(originalIndex);
  result.setQueryIndex(queryIndex);
  if (originalIndex == 0 || reduced.hasPosition() || reduced.hasTargetIndex()) {
    previousPosition=reduced.getPosition();
    previousTargetIndex=reduced.getTargetIndex();
  }
 else {
    final int deltaPos=deltaPositions.getInt(deltaPosIndex);
    final int deltaTarget=deltaTargetIndices.getInt(deltaPosIndex);
    final int position=previousPosition + deltaPos;
    final int targetIndex=previousTargetIndex + deltaTarget;
    result.setPosition(position);
    result.setTargetIndex(targetIndex);
    previousPosition+=deltaPos;
    previousTargetIndex+=deltaTarget;
    deltaPosIndex++;
  }
  if (streamVersion >= 2) {
    final int numReadQualScores=numReadQualityScores.get(index);
    if (numReadQualScores > 0) {
      final byte[] scores=new byte[numReadQualScores];
      for (int i=0; i < numReadQualScores; i++) {
        scores[i]=(byte)allReadQualityScores.getInt(qualScoreIndex++);
      }
      result.setReadQualityScores(ByteString.copyFrom(scores));
    }
  }
  int anInt=mappingQualities.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setMappingQuality(anInt);
  }
  anInt=fragmentIndices.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setFragmentIndex(anInt);
  }
  anInt=matchingReverseStrand.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setMatchingReverseStrand(anInt == 1);
  }
  anInt=numberOfMismatches.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setNumberOfMismatches(anInt);
  }
  anInt=numberOfIndels.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setNumberOfIndels(anInt);
  }
  final int queryLength=queryLengths.getInt(index);
  if (queryLength != MISSING_VALUE) {
    result.setQueryLength(queryLength);
  }
  anInt=queryAlignedLengths.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setQueryAlignedLength(anInt);
  }
  anInt=queryPositions.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setQueryPosition(anInt);
  }
  anInt=targetAlignedLengths.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setTargetAlignedLength(anInt);
  }
  anInt=sampleIndices.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setSampleIndex(anInt);
  }
  anInt=readOriginIndices.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setReadOriginIndex(anInt);
  }
  anInt=pairFlags.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setPairFlags(anInt);
  }
  anInt=scores.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setScore(Float.intBitsToFloat(anInt));
  }
  final boolean entryMatchingReverseStrand=result.hasMatchingReverseStrand() ? result.getMatchingReverseStrand() : false;
  Alignments.RelatedAlignmentEntry link=pairLinks.decode(originalIndex,entryMatchingReverseStrand,reduced.getPairAlignmentLink());
  if (link != null) {
    result.setPairAlignmentLink(link);
  }
  link=forwardSpliceLinks.decode(originalIndex,entryMatchingReverseStrand,reduced.getSplicedForwardAlignmentLink());
  if (link != null) {
    result.setSplicedForwardAlignmentLink(link);
  }
  link=backwardSpliceLinks.decode(originalIndex,entryMatchingReverseStrand,reduced.getSplicedBackwardAlignmentLink());
  if (link != null) {
    result.setSplicedBackwardAlignmentLink(link);
  }
  decodeInsertSize(result,index);
  final boolean templateHasSequenceVariations=reduced.getSequenceVariationsCount() > 0;
  final int numVariations=variationCount.getInt(index);
  for (int varIndex=0; varIndex < numVariations; varIndex++) {
    final Alignments.SequenceVariation template=templateHasSequenceVariations ? reduced.getSequenceVariations(varIndex) : null;
    final Alignments.SequenceVariation.Builder varBuilder=templateHasSequenceVariations ? Alignments.SequenceVariation.newBuilder(template) : Alignments.SequenceVariation.newBuilder();
    from.setLength(0);
    to.setLength(0);
    final int fromLength=fromLengths.getInt(varPositionIndex);
    final int toLength=toLengths.getInt(varPositionIndex);
    final int position=varPositions.getInt(varPositionIndex);
    varBuilder.setPosition(position);
    final int recodedReadIndex=varReadIndex.getInt(varPositionIndex);
    final int readIndex=entryMatchingReverseStrand ? recodedReadIndex + (queryLength - position) - 5 : -recodedReadIndex + position + 5;
    varBuilder.setReadIndex(readIndex);
    final int toQualLength=varToQualLength.getInt(varToQualLengthIndex);
    varToQualLengthIndex++;
    final byte[] quals=getQualArray(toQualLength);
    ++varPositionIndex;
    final int maxLength=Math.max(fromLength,toLength);
    for (int i=0; i < maxLength; i++) {
      final int fromTo=varFromTo.getInt(varFromToIndex++);
      if (i < fromLength) {
        from.append((char)(fromTo >> 8));
      }
      if (i < toLength) {
        to.append((char)(fromTo & 0xFF));
      }
      if (i < toQualLength) {
        if (varQualIndex < varQuals.size()) {
          quals[i]=(byte)varQuals.getInt(varQualIndex);
          ++varQualIndex;
        }
      }
    }
    varBuilder.setFrom(from.toString());
    varBuilder.setTo(to.toString());
    if (toQualLength > 0) {
      varBuilder.setToQuality(ByteString.copyFrom(quals));
    }
    if (templateHasSequenceVariations) {
      result.setSequenceVariations(varIndex,varBuilder);
    }
 else {
      result.addSequenceVariations(varBuilder);
    }
  }
  return result.build();
}"
50319,"private Alignments.AlignmentEntry transform(final int index,int indexInReducedCollection,final Alignments.AlignmentEntry source){
  final Alignments.AlignmentEntry.Builder result=Alignments.AlignmentEntry.newBuilder(source);
  final int position=source.getPosition();
  final int targetIndex=source.getTargetIndex();
  if (index > 0 && targetIndex == previousTargetIndex) {
    result.clearPosition();
    result.clearTargetIndex();
    deltaPositions.add(position - previousPosition);
    deltaTargetIndices.add(targetIndex - previousTargetIndex);
  }
  final int queryIndex=source.getQueryIndex();
  queryIndices.add(queryIndex);
  previousPosition=position;
  previousTargetIndex=targetIndex;
  if (debug(1) && source.hasQueryLength()) {
    writtenBases+=source.getQueryAlignedLength();
  }
  result.clearQueryIndex();
  recordVariationQualitiesAndClear(result,result.getSequenceVariationsList());
  final boolean entryMatchingReverseStrand=source.getMatchingReverseStrand();
  Alignments.RelatedAlignmentEntry link=pairLinks.code(source.hasPairAlignmentLink(),entryMatchingReverseStrand,source.getPairAlignmentLink());
  if (link == null) {
    result.clearPairAlignmentLink();
  }
 else {
    result.setPairAlignmentLink(link);
  }
  link=forwardSpliceLinks.code(source.hasSplicedForwardAlignmentLink(),entryMatchingReverseStrand,source.getSplicedForwardAlignmentLink());
  if (link == null) {
    result.clearSplicedForwardAlignmentLink();
  }
 else {
    result.setSplicedForwardAlignmentLink(link);
  }
  link=backwardSpliceLinks.code(source.hasSplicedBackwardAlignmentLink(),entryMatchingReverseStrand,source.getSplicedBackwardAlignmentLink());
  if (link == null) {
    result.clearSplicedBackwardAlignmentLink();
  }
 else {
    result.setSplicedBackwardAlignmentLink(link);
  }
  final Alignments.AlignmentEntry partial=result.clone().build();
  if (previousPartial != null && indexInReducedCollection >= 1 && fastEquals(previousPartial,partial)) {
    int m=multiplicities.get(indexInReducedCollection - 1);
    multiplicities.set(indexInReducedCollection - 1,m + 1);
    countAggregatedWithMultiplicity++;
    return null;
  }
 else {
    previousPartial=partial;
    multiplicityFieldsAllMissing&=!source.hasMultiplicity();
    multiplicities.add(Math.max(1,source.getMultiplicity()));
  }
  queryLengths.add(source.hasQueryLength() ? source.getQueryLength() : MISSING_VALUE);
  mappingQualities.add(source.hasMappingQuality() ? source.getMappingQuality() : MISSING_VALUE);
  matchingReverseStrand.add(source.hasMatchingReverseStrand() ? source.getMatchingReverseStrand() ? 1 : 0 : MISSING_VALUE);
  numberOfIndels.add(source.hasNumberOfIndels() ? source.getNumberOfIndels() : MISSING_VALUE);
  numberOfMismatches.add(source.hasNumberOfMismatches() ? source.getNumberOfMismatches() : MISSING_VALUE);
  if (source.hasInsertSize()) {
    final int readPos=source.getPosition();
    final int matePos=source.getPairAlignmentLink().getPosition();
    final int length=source.getTargetAlignedLength();
    final int pos1=source.getMatchingReverseStrand() ? length + readPos : readPos + 1;
    final int pos2=EntryFlagHelper.isMateReverseStrand(source) ? length + matePos : matePos + 1;
    final int insertSize=source.getInsertSize();
    int insertSizeDiff=pos2 - pos1 - insertSize;
    if (insertSize != 0) {
    }
    if (insertSize == 0) {
      insertSizeDiff=MISSING_VALUE;
    }
    insertSizes.add(source.hasInsertSize() ? insertSizeDiff : MISSING_VALUE);
  }
 else {
    insertSizes.add(MISSING_VALUE);
  }
  queryAlignedLengths.add(source.hasQueryAlignedLength() ? source.getQueryAlignedLength() : MISSING_VALUE);
  targetAlignedLengths.add(source.hasTargetAlignedLength() ? source.getTargetAlignedLength() : MISSING_VALUE);
  fragmentIndices.add(source.hasFragmentIndex() ? source.getFragmentIndex() : MISSING_VALUE);
  variationCount.add(source.getSequenceVariationsCount());
  queryPositions.add(source.hasQueryPosition() ? source.getQueryPosition() : MISSING_VALUE);
  sampleIndices.add(source.hasSampleIndex() ? source.getSampleIndex() : MISSING_VALUE);
  readOriginIndices.add(source.hasReadOriginIndex() && storeReadOrigins ? source.getReadOriginIndex() : MISSING_VALUE);
  pairFlags.add(source.hasPairFlags() ? source.getPairFlags() : MISSING_VALUE);
  scores.add(source.hasScore() ? Float.floatToIntBits(source.getScore()) : MISSING_VALUE);
  if (source.hasReadQualityScores()) {
    final ByteString quals=source.getReadQualityScores();
    final int size=quals.size();
    numReadQualityScores.add(size);
    for (int i=0; i < size; i++) {
      allReadQualityScores.add(quals.byteAt(i));
    }
  }
 else {
    numReadQualityScores.add(0);
  }
  result.clearQueryLength();
  result.clearMappingQuality();
  result.clearMatchingReverseStrand();
  result.clearMultiplicity();
  result.clearNumberOfIndels();
  result.clearNumberOfMismatches();
  result.clearInsertSize();
  result.clearQueryAlignedLength();
  result.clearTargetAlignedLength();
  result.clearQueryPosition();
  result.clearFragmentIndex();
  result.clearReadQualityScores();
  result.clearSampleIndex();
  result.clearReadOriginIndex();
  result.clearPairFlags();
  result.clearScore();
  boolean canFullyRemoveThisOne=true;
  boolean canFullyRemoveCollection=true;
  int seqVarIndex=0;
  for (  final Alignments.SequenceVariation seqVar : result.getSequenceVariationsList()) {
    encodeVar(source.getMatchingReverseStrand(),source.getQueryLength(),seqVar);
    Alignments.SequenceVariation.Builder varBuilder=Alignments.SequenceVariation.newBuilder(seqVar);
    varBuilder.clearPosition();
    varBuilder.clearFrom();
    varBuilder.clearTo();
    varBuilder.clearToQuality();
    varBuilder.clearReadIndex();
    if (!fastEquals(EMPTY_SEQ_VAR,varBuilder.build())) {
      canFullyRemoveThisOne=false;
      canFullyRemoveCollection=false;
    }
    if (canFullyRemoveThisOne) {
      result.removeSequenceVariations(seqVarIndex);
      seqVarIndex--;
    }
    seqVarIndex++;
  }
  if (canFullyRemoveCollection) {
    result.clearSequenceVariations();
  }
  final Alignments.AlignmentEntry alignmentEntry=result.build();
  return alignmentEntry;
}","private Alignments.AlignmentEntry transform(final int index,int indexInReducedCollection,final Alignments.AlignmentEntry source){
  final Alignments.AlignmentEntry.Builder result=Alignments.AlignmentEntry.newBuilder(source);
  final int position=source.getPosition();
  final int targetIndex=source.getTargetIndex();
  if (index > 0 && targetIndex == previousTargetIndex) {
    result.clearPosition();
    result.clearTargetIndex();
    deltaPositions.add(position - previousPosition);
    deltaTargetIndices.add(targetIndex - previousTargetIndex);
  }
  final int queryIndex=source.getQueryIndex();
  queryIndices.add(queryIndex);
  previousPosition=position;
  previousTargetIndex=targetIndex;
  if (debug(1) && source.hasQueryLength()) {
    writtenBases+=source.getQueryAlignedLength();
  }
  result.clearQueryIndex();
  recordVariationQualitiesAndClear(source,result,result.getSequenceVariationsList());
  final boolean entryMatchingReverseStrand=source.getMatchingReverseStrand();
  Alignments.RelatedAlignmentEntry link=pairLinks.code(source.hasPairAlignmentLink(),entryMatchingReverseStrand,source.getPairAlignmentLink());
  if (link == null) {
    result.clearPairAlignmentLink();
  }
 else {
    result.setPairAlignmentLink(link);
  }
  link=forwardSpliceLinks.code(source.hasSplicedForwardAlignmentLink(),entryMatchingReverseStrand,source.getSplicedForwardAlignmentLink());
  if (link == null) {
    result.clearSplicedForwardAlignmentLink();
  }
 else {
    result.setSplicedForwardAlignmentLink(link);
  }
  link=backwardSpliceLinks.code(source.hasSplicedBackwardAlignmentLink(),entryMatchingReverseStrand,source.getSplicedBackwardAlignmentLink());
  if (link == null) {
    result.clearSplicedBackwardAlignmentLink();
  }
 else {
    result.setSplicedBackwardAlignmentLink(link);
  }
  final Alignments.AlignmentEntry partial=result.clone().build();
  if (previousPartial != null && indexInReducedCollection >= 1 && fastEquals(previousPartial,partial)) {
    int m=multiplicities.get(indexInReducedCollection - 1);
    multiplicities.set(indexInReducedCollection - 1,m + 1);
    countAggregatedWithMultiplicity++;
    return null;
  }
 else {
    previousPartial=partial;
    multiplicityFieldsAllMissing&=!source.hasMultiplicity();
    multiplicities.add(Math.max(1,source.getMultiplicity()));
  }
  queryLengths.add(source.hasQueryLength() ? source.getQueryLength() : MISSING_VALUE);
  mappingQualities.add(source.hasMappingQuality() ? source.getMappingQuality() : MISSING_VALUE);
  matchingReverseStrand.add(source.hasMatchingReverseStrand() ? source.getMatchingReverseStrand() ? 1 : 0 : MISSING_VALUE);
  numberOfIndels.add(source.hasNumberOfIndels() ? source.getNumberOfIndels() : MISSING_VALUE);
  numberOfMismatches.add(source.hasNumberOfMismatches() ? source.getNumberOfMismatches() : MISSING_VALUE);
  if (source.hasInsertSize()) {
    final int readPos=source.getPosition();
    final int matePos=source.getPairAlignmentLink().getPosition();
    final int length=source.getTargetAlignedLength();
    final int pos1=source.getMatchingReverseStrand() ? length + readPos : readPos + 1;
    final int pos2=EntryFlagHelper.isMateReverseStrand(source) ? length + matePos : matePos + 1;
    final int insertSize=source.getInsertSize();
    int insertSizeDiff=pos2 - pos1 - insertSize;
    if (insertSize != 0) {
    }
    if (insertSize == 0) {
      insertSizeDiff=MISSING_VALUE;
    }
    insertSizes.add(source.hasInsertSize() ? insertSizeDiff : MISSING_VALUE);
  }
 else {
    insertSizes.add(MISSING_VALUE);
  }
  queryAlignedLengths.add(source.hasQueryAlignedLength() ? source.getQueryAlignedLength() : MISSING_VALUE);
  targetAlignedLengths.add(source.hasTargetAlignedLength() ? source.getTargetAlignedLength() : MISSING_VALUE);
  fragmentIndices.add(source.hasFragmentIndex() ? source.getFragmentIndex() : MISSING_VALUE);
  variationCount.add(source.getSequenceVariationsCount());
  queryPositions.add(source.hasQueryPosition() ? source.getQueryPosition() : MISSING_VALUE);
  sampleIndices.add(source.hasSampleIndex() ? source.getSampleIndex() : MISSING_VALUE);
  readOriginIndices.add(source.hasReadOriginIndex() && storeReadOrigins ? source.getReadOriginIndex() : MISSING_VALUE);
  pairFlags.add(source.hasPairFlags() ? source.getPairFlags() : MISSING_VALUE);
  scores.add(source.hasScore() ? Float.floatToIntBits(source.getScore()) : MISSING_VALUE);
  if (source.hasReadQualityScores()) {
    final ByteString quals=source.getReadQualityScores();
    final int size=quals.size();
    numReadQualityScores.add(size);
    for (int i=0; i < size; i++) {
      allReadQualityScores.add(quals.byteAt(i));
    }
  }
 else {
    numReadQualityScores.add(0);
  }
  result.clearQueryLength();
  result.clearMappingQuality();
  result.clearMatchingReverseStrand();
  result.clearMultiplicity();
  result.clearNumberOfIndels();
  result.clearNumberOfMismatches();
  result.clearInsertSize();
  result.clearQueryAlignedLength();
  result.clearTargetAlignedLength();
  result.clearQueryPosition();
  result.clearFragmentIndex();
  result.clearReadQualityScores();
  result.clearSampleIndex();
  result.clearReadOriginIndex();
  result.clearPairFlags();
  result.clearScore();
  boolean canFullyRemoveThisOne=true;
  boolean canFullyRemoveCollection=true;
  int seqVarIndex=0;
  for (  final Alignments.SequenceVariation seqVar : result.getSequenceVariationsList()) {
    encodeVar(source.getMatchingReverseStrand(),source.getQueryLength(),seqVar);
    Alignments.SequenceVariation.Builder varBuilder=Alignments.SequenceVariation.newBuilder(seqVar);
    varBuilder.clearPosition();
    varBuilder.clearFrom();
    varBuilder.clearTo();
    varBuilder.clearToQuality();
    varBuilder.clearReadIndex();
    if (!fastEquals(EMPTY_SEQ_VAR,varBuilder.build())) {
      canFullyRemoveThisOne=false;
      canFullyRemoveCollection=false;
    }
    if (canFullyRemoveThisOne) {
      result.removeSequenceVariations(seqVarIndex);
      seqVarIndex--;
    }
    seqVarIndex++;
  }
  if (canFullyRemoveCollection) {
    result.clearSequenceVariations();
  }
  final Alignments.AlignmentEntry alignmentEntry=result.build();
  return alignmentEntry;
}"
50320,"private void recordVariationQualitiesAndClear(Alignments.AlignmentEntry.Builder result,List<Alignments.SequenceVariation> sequenceVariationsList){
  int index=0;
  for (  final Alignments.SequenceVariation seqVar : sequenceVariationsList) {
    final String from=seqVar.getFrom();
    final ByteString toQualities=seqVar.getToQuality();
    final boolean hasToQuals=seqVar.hasToQuality();
    final int toQualSize=toQualities.size();
    varToQualLength.add(toQualSize);
    final int toQualsLength=hasToQuals ? seqVar.getToQuality().size() : 0;
    for (int i=0; i < toQualsLength; i++) {
      if (hasToQuals && i < toQualSize) {
        varQuals.add(toQualities.byteAt(i));
      }
    }
    Alignments.SequenceVariation.Builder varBuilder=Alignments.SequenceVariation.newBuilder(seqVar);
    varBuilder.clearToQuality();
    result.setSequenceVariations(index,varBuilder.buildPartial());
    index++;
  }
}","private void recordVariationQualitiesAndClear(Alignments.AlignmentEntry source,Alignments.AlignmentEntry.Builder result,List<Alignments.SequenceVariation> sequenceVariationsList){
  int index=0;
  for (  final Alignments.SequenceVariation seqVar : sequenceVariationsList) {
    final String from=seqVar.getFrom();
    final ByteString toQualities=seqVar.getToQuality();
    final boolean hasToQuals=seqVar.hasToQuality();
    final int toQualSize=hasToQuals ? toQualities.size() : 0;
    varToQualLength.add(toQualSize);
    for (int i=0; i < toQualSize; i++) {
      varQuals.add(toQualities.byteAt(i));
    }
    Alignments.SequenceVariation.Builder varBuilder=Alignments.SequenceVariation.newBuilder(seqVar);
    varBuilder.clearToQuality();
    result.setSequenceVariations(index,varBuilder.buildPartial());
    index++;
  }
}"
50321,"private void encodeVar(boolean entryOnReverseStrand,int queryLenth,final Alignments.SequenceVariation seqVar){
  final String from=seqVar.getFrom();
  final String to=seqVar.getTo();
  final ByteString toQualities=seqVar.getToQuality();
  final int fromLength=from.length();
  final int toLength=to.length();
  final boolean hasToQuals=seqVar.hasToQuality();
  final int position=seqVar.getPosition();
  varPositions.add(position);
  final int readIndex=seqVar.getReadIndex();
  final int recodedReadIndex=entryOnReverseStrand ? readIndex - (queryLenth - position) + 5 : 5 + position - readIndex;
  varReadIndex.add(recodedReadIndex);
  fromLengths.add(fromLength);
  toLengths.add(toLength);
  final int maxLength=Math.max(fromLength,toLength);
  for (int i=0; i < maxLength; i++) {
    final char baseFrom=i < fromLength ? from.charAt(i) : '\0';
    final char baseTo=i < toLength ? to.charAt(i) : '\0';
    final byte byteFrom=(byte)baseFrom;
    final byte byteTo=(byte)baseTo;
    varFromTo.add(byteFrom << 8 | byteTo);
  }
}","private void encodeVar(boolean entryOnReverseStrand,int queryLenth,final Alignments.SequenceVariation seqVar){
  final String from=seqVar.getFrom();
  final String to=seqVar.getTo();
  final int fromLength=from.length();
  final int toLength=to.length();
  final int position=seqVar.getPosition();
  varPositions.add(position);
  final int readIndex=seqVar.getReadIndex();
  final int recodedReadIndex=entryOnReverseStrand ? readIndex - (queryLenth - position) + 5 : 5 + position - readIndex;
  varReadIndex.add(recodedReadIndex);
  fromLengths.add(fromLength);
  toLengths.add(toLength);
  final int maxLength=Math.max(fromLength,toLength);
  for (int i=0; i < maxLength; i++) {
    final char baseFrom=i < fromLength ? from.charAt(i) : '\0';
    final char baseTo=i < toLength ? to.charAt(i) : '\0';
    final byte byteFrom=(byte)baseFrom;
    final byte byteTo=(byte)baseTo;
    varFromTo.add(byteFrom << 8 | byteTo);
  }
}"
50322,"private void reset(){
  multiplicityFieldsAllMissing=true;
  previousPosition=-1;
  previousTargetIndex=-1;
  deltaPositions.clear();
  deltaTargetIndices.clear();
  queryLengths.clear();
  mappingQualities.clear();
  matchingReverseStrand.clear();
  multiplicity.clear();
  numberOfIndels.clear();
  queryAlignedLengths.clear();
  targetAlignedLengths.clear();
  numberOfMismatches.clear();
  insertSizes.clear();
  queryIndices.clear();
  queryPositions.clear();
  fragmentIndices.clear();
  queryIndices.clear();
  variationCount.clear();
  varPositions.clear();
  fromLengths.clear();
  toLengths.clear();
  varReadIndex.clear();
  varFromTo.clear();
  varQuals.clear();
  varQualIndex=0;
  varPositionIndex=0;
  varFromToIndex=0;
  varToQualLength.clear();
  varToQualsLength=0;
  multiplicities.clear();
  countAggregatedWithMultiplicity=0;
  previousPartial=null;
  deltaPosIndex=0;
  pairLinks.reset();
  forwardSpliceLinks.reset();
  backwardSpliceLinks.reset();
  qualScoreIndex=0;
  numReadQualityScores.clear();
  allReadQualityScores.clear();
  sampleIndices.clear();
  readOriginIndices.clear();
  pairFlags.clear();
  scores.clear();
}","private void reset(){
  multiplicityFieldsAllMissing=true;
  previousPosition=-1;
  previousTargetIndex=-1;
  deltaPositions.clear();
  deltaTargetIndices.clear();
  queryLengths.clear();
  mappingQualities.clear();
  matchingReverseStrand.clear();
  multiplicity.clear();
  numberOfIndels.clear();
  queryAlignedLengths.clear();
  targetAlignedLengths.clear();
  numberOfMismatches.clear();
  insertSizes.clear();
  queryIndices.clear();
  queryPositions.clear();
  fragmentIndices.clear();
  queryIndices.clear();
  variationCount.clear();
  varPositions.clear();
  fromLengths.clear();
  toLengths.clear();
  varReadIndex.clear();
  varFromTo.clear();
  varQuals.clear();
  varQualIndex=0;
  varPositionIndex=0;
  varFromToIndex=0;
  varToQualLength.clear();
  varToQualLengthIndex=0;
  multiplicities.clear();
  countAggregatedWithMultiplicity=0;
  previousPartial=null;
  deltaPosIndex=0;
  pairLinks.reset();
  forwardSpliceLinks.reset();
  backwardSpliceLinks.reset();
  qualScoreIndex=0;
  numReadQualityScores.clear();
  allReadQualityScores.clear();
  sampleIndices.clear();
  readOriginIndices.clear();
  pairFlags.clear();
  scores.clear();
}"
50323,"protected final void decodeArithmetic(final String label,final int numEntriesInChunk,final InputBitStream bitInput,final IntList list) throws IOException {
  if (debug(2)) {
    System.err.flush();
    System.err.println(""String_Node_Str"" + label + ""String_Node_Str""+ bitInput.available());
    System.err.flush();
  }
  if (numEntriesInChunk == 0) {
    return;
  }
  final int size=bitInput.readNibble();
  if (size == 0) {
    return;
  }
  final boolean hasNegatives=bitInput.readBit() == 1;
  final int numTokens=bitInput.readNibble();
  final int[] distinctvalue=new int[numTokens];
  for (int i=0; i < numTokens; i++) {
    final int nat=bitInput.readNibble() - 1;
    final int anInt=hasNegatives ? Fast.nat2int(nat) : nat;
    distinctvalue[i]=anInt;
  }
  final FastArithmeticDecoder decoder=new FastArithmeticDecoder(numTokens);
  for (int i=0; i < size; i++) {
    final int tokenValue=distinctvalue[decoder.decode(bitInput)];
    list.add(tokenValue);
  }
  decoder.reposition(bitInput);
}","protected final void decodeArithmetic(final String label,final int numEntriesInChunk,final InputBitStream bitInput,final IntList list) throws IOException {
  if (debug(2)) {
    System.err.flush();
    System.err.println(""String_Node_Str"" + label + ""String_Node_Str""+ bitInput.available());
    System.err.flush();
  }
  if (numEntriesInChunk == 0) {
    return;
  }
  final int size=bitInput.readNibble();
  if (size == 0) {
    return;
  }
  final boolean hasNegatives=bitInput.readBit() == 1;
  final int numTokens=bitInput.readNibble();
  final int[] distinctvalue=new int[numTokens];
  for (int i=0; i < numTokens; i++) {
    final int token=bitInput.readNibble();
    final int anInt=hasNegatives ? Fast.nat2int(token) : token - 1;
    distinctvalue[i]=anInt;
  }
  if (hasNegatives) {
    Arrays.sort(distinctvalue);
  }
  final FastArithmeticDecoder decoder=new FastArithmeticDecoder(numTokens);
  for (int i=0; i < size; i++) {
    final int tokenValue=distinctvalue[decoder.decode(bitInput)];
    list.add(tokenValue);
  }
  decoder.reposition(bitInput);
}"
50324,"private Alignments.AlignmentEntry andBack(final int index,int originalIndex,final Alignments.AlignmentEntry reduced){
  final Alignments.AlignmentEntry.Builder result=Alignments.AlignmentEntry.newBuilder(reduced);
  final int multiplicity=multiplicities.get(index);
  final int k=multiplicity - 1;
  multiplicities.set(index,k);
  if (!multiplicityFieldsAllMissing) {
    result.setMultiplicity(1);
  }
  final int queryIndex=queryIndices.getInt(originalIndex);
  result.setQueryIndex(queryIndex);
  if (originalIndex == 0 || reduced.hasPosition() || reduced.hasTargetIndex()) {
    previousPosition=reduced.getPosition();
    previousTargetIndex=reduced.getTargetIndex();
  }
 else {
    final int deltaPos=deltaPositions.getInt(deltaPosIndex);
    final int deltaTarget=deltaTargetIndices.getInt(deltaPosIndex);
    final int position=previousPosition + deltaPos;
    final int targetIndex=previousTargetIndex + deltaTarget;
    result.setPosition(position);
    result.setTargetIndex(targetIndex);
    previousPosition+=deltaPos;
    previousTargetIndex+=deltaTarget;
    deltaPosIndex++;
  }
  int anInt=mappingQualities.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setMappingQuality(anInt);
  }
  anInt=fragmentIndices.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setFragmentIndex(anInt);
  }
  anInt=matchingReverseStrand.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setMatchingReverseStrand(anInt == 1);
  }
  anInt=numberOfMismatches.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setNumberOfMismatches(anInt);
  }
  anInt=numberOfIndels.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setNumberOfIndels(anInt);
  }
  anInt=queryLengths.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setQueryLength(anInt);
  }
  anInt=queryAlignedLengths.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setQueryAlignedLength(anInt);
  }
  anInt=queryPositions.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setQueryPosition(anInt);
  }
  anInt=targetAlignedLengths.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setTargetAlignedLength(anInt);
  }
  final boolean entryMatchingReverseStrand=result.hasMatchingReverseStrand() ? result.getMatchingReverseStrand() : false;
  Alignments.RelatedAlignmentEntry link=pairLinks.decode(originalIndex,entryMatchingReverseStrand,reduced.getPairAlignmentLink());
  if (link != null) {
    result.setPairAlignmentLink(link);
  }
  link=forwardSpliceLinks.decode(originalIndex,entryMatchingReverseStrand,reduced.getSplicedForwardAlignmentLink());
  if (link != null) {
    result.setSplicedForwardAlignmentLink(link);
  }
  link=backwardSpliceLinks.decode(originalIndex,entryMatchingReverseStrand,reduced.getSplicedBackwardAlignmentLink());
  if (link != null) {
    result.setSplicedBackwardAlignmentLink(link);
  }
  final boolean templateHasSequenceVariations=reduced.getSequenceVariationsCount() > 0;
  final int numVariations=variationCount.getInt(index);
  for (int varIndex=0; varIndex < numVariations; varIndex++) {
    final Alignments.SequenceVariation template=templateHasSequenceVariations ? reduced.getSequenceVariations(varIndex) : null;
    final Alignments.SequenceVariation.Builder varBuilder=templateHasSequenceVariations ? Alignments.SequenceVariation.newBuilder(template) : Alignments.SequenceVariation.newBuilder();
    from.setLength(0);
    to.setLength(0);
    final int fromLength=fromLengths.getInt(varPositionIndex);
    final int toLength=toLengths.getInt(varPositionIndex);
    varBuilder.setPosition(varPositions.getInt(varPositionIndex));
    varBuilder.setReadIndex(varReadIndex.getInt(varPositionIndex));
    final int toQualLength=varToQualLength.getInt(varToQualsLength);
    varToQualsLength++;
    final byte[] quals=getQualArray(toQualLength);
    ++varPositionIndex;
    final int maxLength=Math.max(fromLength,toLength);
    for (int i=0; i < maxLength; i++) {
      final int fromTo=varFromTo.getInt(varFromToIndex++);
      if (i < fromLength) {
        from.append((char)(fromTo >> 8));
      }
      if (i < toLength) {
        to.append((char)(fromTo & 0xFF));
      }
      if (i < toQualLength) {
        if (varQualIndex < varQuals.size()) {
          quals[i]=(byte)varQuals.getInt(varQualIndex);
          ++varQualIndex;
        }
      }
    }
    varBuilder.setFrom(from.toString());
    varBuilder.setTo(to.toString());
    if (toQualLength > 0) {
      varBuilder.setToQuality(ByteString.copyFrom(quals));
    }
    if (templateHasSequenceVariations) {
      result.setSequenceVariations(varIndex,varBuilder);
    }
 else {
      result.addSequenceVariations(varBuilder);
    }
  }
  return result.build();
}","private Alignments.AlignmentEntry andBack(final int index,int originalIndex,final Alignments.AlignmentEntry reduced){
  final Alignments.AlignmentEntry.Builder result=Alignments.AlignmentEntry.newBuilder(reduced);
  final int multiplicity=multiplicities.get(index);
  final int k=multiplicity - 1;
  multiplicities.set(index,k);
  if (!multiplicityFieldsAllMissing) {
    result.setMultiplicity(1);
  }
  final int queryIndex=queryIndices.getInt(originalIndex);
  result.setQueryIndex(queryIndex);
  if (originalIndex == 0 || reduced.hasPosition() || reduced.hasTargetIndex()) {
    previousPosition=reduced.getPosition();
    previousTargetIndex=reduced.getTargetIndex();
  }
 else {
    final int deltaPos=deltaPositions.getInt(deltaPosIndex);
    final int deltaTarget=deltaTargetIndices.getInt(deltaPosIndex);
    final int position=previousPosition + deltaPos;
    final int targetIndex=previousTargetIndex + deltaTarget;
    result.setPosition(position);
    result.setTargetIndex(targetIndex);
    previousPosition+=deltaPos;
    previousTargetIndex+=deltaTarget;
    deltaPosIndex++;
  }
  int anInt=mappingQualities.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setMappingQuality(anInt);
  }
  anInt=fragmentIndices.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setFragmentIndex(anInt);
  }
  anInt=matchingReverseStrand.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setMatchingReverseStrand(anInt == 1);
  }
  anInt=numberOfMismatches.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setNumberOfMismatches(anInt);
  }
  anInt=numberOfIndels.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setNumberOfIndels(anInt);
  }
  final int queryLength=queryLengths.getInt(index);
  if (queryLength != MISSING_VALUE) {
    result.setQueryLength(queryLength);
  }
  anInt=queryAlignedLengths.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setQueryAlignedLength(anInt);
  }
  anInt=queryPositions.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setQueryPosition(anInt);
  }
  anInt=targetAlignedLengths.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setTargetAlignedLength(anInt);
  }
  final boolean entryMatchingReverseStrand=result.hasMatchingReverseStrand() ? result.getMatchingReverseStrand() : false;
  Alignments.RelatedAlignmentEntry link=pairLinks.decode(originalIndex,entryMatchingReverseStrand,reduced.getPairAlignmentLink());
  if (link != null) {
    result.setPairAlignmentLink(link);
  }
  link=forwardSpliceLinks.decode(originalIndex,entryMatchingReverseStrand,reduced.getSplicedForwardAlignmentLink());
  if (link != null) {
    result.setSplicedForwardAlignmentLink(link);
  }
  link=backwardSpliceLinks.decode(originalIndex,entryMatchingReverseStrand,reduced.getSplicedBackwardAlignmentLink());
  if (link != null) {
    result.setSplicedBackwardAlignmentLink(link);
  }
  final boolean templateHasSequenceVariations=reduced.getSequenceVariationsCount() > 0;
  final int numVariations=variationCount.getInt(index);
  for (int varIndex=0; varIndex < numVariations; varIndex++) {
    final Alignments.SequenceVariation template=templateHasSequenceVariations ? reduced.getSequenceVariations(varIndex) : null;
    final Alignments.SequenceVariation.Builder varBuilder=templateHasSequenceVariations ? Alignments.SequenceVariation.newBuilder(template) : Alignments.SequenceVariation.newBuilder();
    from.setLength(0);
    to.setLength(0);
    final int fromLength=fromLengths.getInt(varPositionIndex);
    final int toLength=toLengths.getInt(varPositionIndex);
    final int position=varPositions.getInt(varPositionIndex);
    varBuilder.setPosition(position);
    final int recodedReadIndex=varReadIndex.getInt(varPositionIndex);
    final int readIndex=entryMatchingReverseStrand ? recodedReadIndex + (queryLength - position) - 5 : -recodedReadIndex + position + 5;
    varBuilder.setReadIndex(readIndex);
    final int toQualLength=varToQualLength.getInt(varToQualsLength);
    varToQualsLength++;
    final byte[] quals=getQualArray(toQualLength);
    ++varPositionIndex;
    final int maxLength=Math.max(fromLength,toLength);
    for (int i=0; i < maxLength; i++) {
      final int fromTo=varFromTo.getInt(varFromToIndex++);
      if (i < fromLength) {
        from.append((char)(fromTo >> 8));
      }
      if (i < toLength) {
        to.append((char)(fromTo & 0xFF));
      }
      if (i < toQualLength) {
        if (varQualIndex < varQuals.size()) {
          quals[i]=(byte)varQuals.getInt(varQualIndex);
          ++varQualIndex;
        }
      }
    }
    varBuilder.setFrom(from.toString());
    varBuilder.setTo(to.toString());
    if (toQualLength > 0) {
      varBuilder.setToQuality(ByteString.copyFrom(quals));
    }
    if (templateHasSequenceVariations) {
      result.setSequenceVariations(varIndex,varBuilder);
    }
 else {
      result.addSequenceVariations(varBuilder);
    }
  }
  return result.build();
}"
50325,"private Alignments.AlignmentEntry transform(final int index,int indexInReducedCollection,final Alignments.AlignmentEntry source){
  final Alignments.AlignmentEntry.Builder result=Alignments.AlignmentEntry.newBuilder(source);
  final int position=source.getPosition();
  final int targetIndex=source.getTargetIndex();
  if (index > 0 && targetIndex == previousTargetIndex) {
    result.clearPosition();
    result.clearTargetIndex();
    deltaPositions.add(position - previousPosition);
    deltaTargetIndices.add(targetIndex - previousTargetIndex);
  }
  final int queryIndex=source.getQueryIndex();
  queryIndices.add(queryIndex);
  previousPosition=position;
  previousTargetIndex=targetIndex;
  if (debug(1) && source.hasQueryLength()) {
    writtenBases+=source.getQueryLength();
  }
  result.clearQueryIndex();
  recordVariationQualitiesAndClear(result,result.getSequenceVariationsList());
  final boolean entryMatchingReverseStrand=source.getMatchingReverseStrand();
  Alignments.RelatedAlignmentEntry link=pairLinks.code(source.hasPairAlignmentLink(),entryMatchingReverseStrand,source.getPairAlignmentLink());
  if (link == null) {
    result.clearPairAlignmentLink();
  }
 else {
    result.setPairAlignmentLink(link);
  }
  link=forwardSpliceLinks.code(source.hasSplicedForwardAlignmentLink(),entryMatchingReverseStrand,source.getSplicedForwardAlignmentLink());
  if (link == null) {
    result.clearSplicedForwardAlignmentLink();
  }
 else {
    result.setSplicedForwardAlignmentLink(link);
  }
  link=backwardSpliceLinks.code(source.hasSplicedBackwardAlignmentLink(),entryMatchingReverseStrand,source.getSplicedBackwardAlignmentLink());
  if (link == null) {
    result.clearSplicedBackwardAlignmentLink();
  }
 else {
    result.setSplicedBackwardAlignmentLink(link);
  }
  final Alignments.AlignmentEntry partial=result.clone().build();
  if (previousPartial != null && indexInReducedCollection >= 1 && fastEquals(previousPartial,partial)) {
    int m=multiplicities.get(indexInReducedCollection - 1);
    multiplicities.set(indexInReducedCollection - 1,m + 1);
    countAggregatedWithMultiplicity++;
    return null;
  }
 else {
    previousPartial=partial;
    multiplicityFieldsAllMissing&=!source.hasMultiplicity();
    multiplicities.add(Math.max(1,source.getMultiplicity()));
  }
  queryLengths.add(source.hasQueryLength() ? source.getQueryLength() : MISSING_VALUE);
  mappingQualities.add(source.hasMappingQuality() ? source.getMappingQuality() : MISSING_VALUE);
  matchingReverseStrand.add(source.hasMatchingReverseStrand() ? source.getMatchingReverseStrand() ? 1 : 0 : MISSING_VALUE);
  numberOfIndels.add(source.hasNumberOfIndels() ? source.getNumberOfIndels() : MISSING_VALUE);
  numberOfMismatches.add(source.hasNumberOfMismatches() ? source.getNumberOfMismatches() : MISSING_VALUE);
  queryAlignedLengths.add(source.hasQueryAlignedLength() ? source.getQueryAlignedLength() : MISSING_VALUE);
  targetAlignedLengths.add(source.hasTargetAlignedLength() ? source.getTargetAlignedLength() : MISSING_VALUE);
  fragmentIndices.add(source.hasFragmentIndex() ? source.getFragmentIndex() : MISSING_VALUE);
  variationCount.add(source.getSequenceVariationsCount());
  queryPositions.add(source.hasQueryPosition() ? source.getQueryPosition() : MISSING_VALUE);
  result.clearQueryLength();
  result.clearMappingQuality();
  result.clearMatchingReverseStrand();
  result.clearMultiplicity();
  result.clearNumberOfIndels();
  result.clearNumberOfMismatches();
  result.clearQueryAlignedLength();
  result.clearTargetAlignedLength();
  result.clearQueryPosition();
  result.clearFragmentIndex();
  boolean canFullyRemoveThisOne=true;
  boolean canFullyRemoveCollection=true;
  int seqVarIndex=0;
  for (  final Alignments.SequenceVariation seqVar : result.getSequenceVariationsList()) {
    encodeVar(seqVar);
    Alignments.SequenceVariation.Builder varBuilder=Alignments.SequenceVariation.newBuilder(seqVar);
    varBuilder.clearPosition();
    varBuilder.clearFrom();
    varBuilder.clearTo();
    varBuilder.clearToQuality();
    varBuilder.clearReadIndex();
    if (!fastEquals(EMPTY_SEQ_VAR,varBuilder.build())) {
      canFullyRemoveThisOne=false;
      canFullyRemoveCollection=false;
    }
    if (canFullyRemoveThisOne) {
      result.removeSequenceVariations(seqVarIndex);
      seqVarIndex--;
    }
    seqVarIndex++;
  }
  if (canFullyRemoveCollection) {
    result.clearSequenceVariations();
  }
  final Alignments.AlignmentEntry alignmentEntry=result.build();
  return alignmentEntry;
}","private Alignments.AlignmentEntry transform(final int index,int indexInReducedCollection,final Alignments.AlignmentEntry source){
  final Alignments.AlignmentEntry.Builder result=Alignments.AlignmentEntry.newBuilder(source);
  final int position=source.getPosition();
  final int targetIndex=source.getTargetIndex();
  if (index > 0 && targetIndex == previousTargetIndex) {
    result.clearPosition();
    result.clearTargetIndex();
    deltaPositions.add(position - previousPosition);
    deltaTargetIndices.add(targetIndex - previousTargetIndex);
  }
  final int queryIndex=source.getQueryIndex();
  queryIndices.add(queryIndex);
  previousPosition=position;
  previousTargetIndex=targetIndex;
  if (debug(1) && source.hasQueryLength()) {
    writtenBases+=source.getQueryLength();
  }
  result.clearQueryIndex();
  recordVariationQualitiesAndClear(result,result.getSequenceVariationsList());
  final boolean entryMatchingReverseStrand=source.getMatchingReverseStrand();
  Alignments.RelatedAlignmentEntry link=pairLinks.code(source.hasPairAlignmentLink(),entryMatchingReverseStrand,source.getPairAlignmentLink());
  if (link == null) {
    result.clearPairAlignmentLink();
  }
 else {
    result.setPairAlignmentLink(link);
  }
  link=forwardSpliceLinks.code(source.hasSplicedForwardAlignmentLink(),entryMatchingReverseStrand,source.getSplicedForwardAlignmentLink());
  if (link == null) {
    result.clearSplicedForwardAlignmentLink();
  }
 else {
    result.setSplicedForwardAlignmentLink(link);
  }
  link=backwardSpliceLinks.code(source.hasSplicedBackwardAlignmentLink(),entryMatchingReverseStrand,source.getSplicedBackwardAlignmentLink());
  if (link == null) {
    result.clearSplicedBackwardAlignmentLink();
  }
 else {
    result.setSplicedBackwardAlignmentLink(link);
  }
  final Alignments.AlignmentEntry partial=result.clone().build();
  if (previousPartial != null && indexInReducedCollection >= 1 && fastEquals(previousPartial,partial)) {
    int m=multiplicities.get(indexInReducedCollection - 1);
    multiplicities.set(indexInReducedCollection - 1,m + 1);
    countAggregatedWithMultiplicity++;
    return null;
  }
 else {
    previousPartial=partial;
    multiplicityFieldsAllMissing&=!source.hasMultiplicity();
    multiplicities.add(Math.max(1,source.getMultiplicity()));
  }
  queryLengths.add(source.hasQueryLength() ? source.getQueryLength() : MISSING_VALUE);
  mappingQualities.add(source.hasMappingQuality() ? source.getMappingQuality() : MISSING_VALUE);
  matchingReverseStrand.add(source.hasMatchingReverseStrand() ? source.getMatchingReverseStrand() ? 1 : 0 : MISSING_VALUE);
  numberOfIndels.add(source.hasNumberOfIndels() ? source.getNumberOfIndels() : MISSING_VALUE);
  numberOfMismatches.add(source.hasNumberOfMismatches() ? source.getNumberOfMismatches() : MISSING_VALUE);
  queryAlignedLengths.add(source.hasQueryAlignedLength() ? source.getQueryAlignedLength() : MISSING_VALUE);
  targetAlignedLengths.add(source.hasTargetAlignedLength() ? source.getTargetAlignedLength() : MISSING_VALUE);
  fragmentIndices.add(source.hasFragmentIndex() ? source.getFragmentIndex() : MISSING_VALUE);
  variationCount.add(source.getSequenceVariationsCount());
  queryPositions.add(source.hasQueryPosition() ? source.getQueryPosition() : MISSING_VALUE);
  result.clearQueryLength();
  result.clearMappingQuality();
  result.clearMatchingReverseStrand();
  result.clearMultiplicity();
  result.clearNumberOfIndels();
  result.clearNumberOfMismatches();
  result.clearQueryAlignedLength();
  result.clearTargetAlignedLength();
  result.clearQueryPosition();
  result.clearFragmentIndex();
  boolean canFullyRemoveThisOne=true;
  boolean canFullyRemoveCollection=true;
  int seqVarIndex=0;
  for (  final Alignments.SequenceVariation seqVar : result.getSequenceVariationsList()) {
    encodeVar(source.getMatchingReverseStrand(),source.getQueryLength(),seqVar);
    Alignments.SequenceVariation.Builder varBuilder=Alignments.SequenceVariation.newBuilder(seqVar);
    varBuilder.clearPosition();
    varBuilder.clearFrom();
    varBuilder.clearTo();
    varBuilder.clearToQuality();
    varBuilder.clearReadIndex();
    if (!fastEquals(EMPTY_SEQ_VAR,varBuilder.build())) {
      canFullyRemoveThisOne=false;
      canFullyRemoveCollection=false;
    }
    if (canFullyRemoveThisOne) {
      result.removeSequenceVariations(seqVarIndex);
      seqVarIndex--;
    }
    seqVarIndex++;
  }
  if (canFullyRemoveCollection) {
    result.clearSequenceVariations();
  }
  final Alignments.AlignmentEntry alignmentEntry=result.build();
  return alignmentEntry;
}"
50326,"private void encodeVar(final Alignments.SequenceVariation seqVar){
  final String from=seqVar.getFrom();
  final String to=seqVar.getTo();
  final ByteString toQualities=seqVar.getToQuality();
  final int fromLength=from.length();
  final int toLength=to.length();
  final boolean hasToQuals=seqVar.hasToQuality();
  varPositions.add(seqVar.getPosition());
  varReadIndex.add(seqVar.getReadIndex());
  fromLengths.add(fromLength);
  toLengths.add(toLength);
  final int maxLength=Math.max(fromLength,toLength);
  for (int i=0; i < maxLength; i++) {
    final char baseFrom=i < fromLength ? from.charAt(i) : '\0';
    final char baseTo=i < toLength ? to.charAt(i) : '\0';
    final byte byteFrom=(byte)baseFrom;
    final byte byteTo=(byte)baseTo;
    varFromTo.add(byteFrom << 8 | byteTo);
  }
}","private void encodeVar(boolean entryOnReverseStrand,int queryLenth,final Alignments.SequenceVariation seqVar){
  final String from=seqVar.getFrom();
  final String to=seqVar.getTo();
  final ByteString toQualities=seqVar.getToQuality();
  final int fromLength=from.length();
  final int toLength=to.length();
  final boolean hasToQuals=seqVar.hasToQuality();
  final int position=seqVar.getPosition();
  varPositions.add(position);
  final int readIndex=seqVar.getReadIndex();
  final int recodedReadIndex=entryOnReverseStrand ? readIndex - (queryLenth - position) + 5 : 5 + position - readIndex;
  varReadIndex.add(recodedReadIndex);
  fromLengths.add(fromLength);
  toLengths.add(toLength);
  final int maxLength=Math.max(fromLength,toLength);
  for (int i=0; i < maxLength; i++) {
    final char baseFrom=i < fromLength ? from.charAt(i) : '\0';
    final char baseTo=i < toLength ? to.charAt(i) : '\0';
    final byte byteFrom=(byte)baseFrom;
    final byte byteTo=(byte)baseTo;
    varFromTo.add(byteFrom << 8 | byteTo);
  }
}"
50327,"private ObjectArrayList<Alignments.AlignmentEntry.Builder> buildEntriesCollection(AlignmentExample[] examples){
  ObjectArrayList<Alignments.AlignmentEntry.Builder> list=new ObjectArrayList<Alignments.AlignmentEntry.Builder>();
  for (  AlignmentExample entry : examples) {
    Alignments.AlignmentEntry.Builder alignmentBuilder=Alignments.AlignmentEntry.newBuilder();
    alignmentBuilder.setPosition(entry.position);
    alignmentBuilder.setMappingQuality(entry.mappingQuality);
    alignmentBuilder.setQueryIndex(entry.query_index);
    alignmentBuilder.setMatchingReverseStrand(true);
    alignmentBuilder.setTargetIndex(entry.targetIndex);
    Alignments.SequenceVariation.Builder sequenceVariation1=Alignments.SequenceVariation.newBuilder();
    sequenceVariation1.setFrom(entry.var1_from);
    sequenceVariation1.setTo(entry.var1_to);
    sequenceVariation1.setPosition(entry.var1_position);
    sequenceVariation1.setReadIndex(entry.var1_readIndex);
    alignmentBuilder.addSequenceVariations(sequenceVariation1.build());
    Alignments.SequenceVariation.Builder sequenceVariation2=Alignments.SequenceVariation.newBuilder();
    sequenceVariation2.setFrom(entry.var2_from);
    sequenceVariation2.setTo(entry.var2_to);
    sequenceVariation2.setPosition(entry.var2_position);
    sequenceVariation2.setReadIndex(entry.var2_readIndex);
    alignmentBuilder.addSequenceVariations(sequenceVariation2.build());
    list.add(alignmentBuilder);
  }
  return list;
}","private ObjectArrayList<Alignments.AlignmentEntry.Builder> buildEntriesCollection(AlignmentExample[] examples){
  ObjectArrayList<Alignments.AlignmentEntry.Builder> list=new ObjectArrayList<Alignments.AlignmentEntry.Builder>();
  for (  AlignmentExample entry : examples) {
    Alignments.AlignmentEntry.Builder alignmentBuilder=Alignments.AlignmentEntry.newBuilder();
    alignmentBuilder.setPosition(entry.position);
    alignmentBuilder.setMappingQuality(entry.mappingQuality);
    alignmentBuilder.setQueryIndex(entry.query_index);
    alignmentBuilder.setMatchingReverseStrand(true);
    alignmentBuilder.setTargetIndex(entry.targetIndex);
    alignmentBuilder.setQueryLength(1003);
    Alignments.SequenceVariation.Builder sequenceVariation1=Alignments.SequenceVariation.newBuilder();
    sequenceVariation1.setFrom(entry.var1_from);
    sequenceVariation1.setTo(entry.var1_to);
    sequenceVariation1.setPosition(entry.var1_position);
    sequenceVariation1.setReadIndex(entry.var1_readIndex);
    alignmentBuilder.addSequenceVariations(sequenceVariation1.build());
    Alignments.SequenceVariation.Builder sequenceVariation2=Alignments.SequenceVariation.newBuilder();
    sequenceVariation2.setFrom(entry.var2_from);
    sequenceVariation2.setTo(entry.var2_to);
    sequenceVariation2.setPosition(entry.var2_position);
    sequenceVariation2.setReadIndex(entry.var2_readIndex);
    alignmentBuilder.addSequenceVariations(sequenceVariation2.build());
    list.add(alignmentBuilder);
  }
  return list;
}"
50328,"private void importReadGroups(SAMFileHeader samHeader,IndexedIdentifier readGroups){
  if (samHeader.getReadGroups().size() > 0) {
    for (    SAMReadGroupRecord rg : samHeader.getReadGroups()) {
      String sample=rg.getSample();
      String library=rg.getLibrary();
      String platform=rg.getPlatform();
      String platformUnit=rg.getPlatformUnit();
      String id=rg.getId();
      int readGroupIndex=readGroups.registerIdentifier(new MutableString(id));
      Alignments.ReadOriginInfo.Builder roi=Alignments.ReadOriginInfo.newBuilder();
      roi.setOriginIndex(readGroupIndex);
      if (library != null) {
        roi.setLibrary(library);
      }
      if (platform != null) {
        roi.setPlatform(platform);
      }
      if (platformUnit != null) {
        roi.setPlatformUnit(platformUnit);
      }
      if (sample != null) {
        roi.setSample(sample);
      }
      readOriginInfoBuilderList.add(roi);
    }
  }
}","private void importReadGroups(SAMFileHeader samHeader,IndexedIdentifier readGroups){
  if (samHeader.getReadGroups().size() > 0) {
    for (    SAMReadGroupRecord rg : samHeader.getReadGroups()) {
      String sample=rg.getSample();
      String library=rg.getLibrary();
      String platform=rg.getPlatform();
      String platformUnit=rg.getPlatformUnit();
      String id=rg.getId();
      int readGroupIndex=readGroups.registerIdentifier(new MutableString(id));
      Alignments.ReadOriginInfo.Builder roi=Alignments.ReadOriginInfo.newBuilder();
      roi.setOriginIndex(readGroupIndex);
      roi.setOriginId(id);
      if (library != null) {
        roi.setLibrary(library);
      }
      if (platform != null) {
        roi.setPlatform(platform);
      }
      if (platformUnit != null) {
        roi.setPlatformUnit(platformUnit);
      }
      if (sample != null) {
        roi.setSample(sample);
      }
      readOriginInfoBuilderList.add(roi);
    }
  }
}"
50329,"public void setSource(final int queryIndex,final CharSequence sourceQuery,final CharSequence sourceQual,final CharSequence cigar,final CharSequence md,final int position,final boolean reverseStrand,int readLength){
  this.queryLength=readLength;
  if (debug && LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"");
    LOG.debug(""String_Node_Str"" + (position - 1));
    LOG.debug(""String_Node_Str"" + queryIndex);
  }
  reset();
  this.queryIndex=queryIndex;
  this.sourceQuery.setLength(0);
  if (sourceQuery != null) {
    this.sourceQuery.append(sourceQuery);
    queryLength=sourceQuery.length();
  }
  this.sourceQual.setLength(0);
  if (sourceQual != null) {
    this.sourceQual.append(sourceQual);
  }
  this.cigar.setLength(0);
  if (cigar != null) {
    this.cigar.append(cigar);
  }
  this.md.setLength(0);
  if (md != null) {
    this.md.append(md);
  }
  this.position=position - 1;
  this.reverseStrand=reverseStrand;
  constructRefAndQuery();
  findSequenceVariations();
  SamSequenceVariation.merge(sequenceVariations);
}","public void setSource(final int queryIndex,final CharSequence sourceQuery,final CharSequence sourceQual,final CharSequence cigar,final CharSequence md,final int position,final boolean reverseStrand,int readLength){
  this.queryLength=readLength;
  if (debug && LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"");
    LOG.debug(""String_Node_Str"" + (position - 1));
    LOG.debug(""String_Node_Str"" + queryIndex);
  }
  reset();
  this.queryIndex=queryIndex;
  this.sourceQuery.setLength(0);
  if (sourceQuery != null) {
    this.sourceQuery.append(sourceQuery);
    queryLength=sourceQuery.length();
  }
  this.sourceQual.setLength(0);
  if (sourceQual != null) {
    this.sourceQual.append(sourceQual);
  }
  this.cigar.setLength(0);
  if (cigar != null) {
    this.cigar.append(cigar);
  }
  this.md.setLength(0);
  if (md != null) {
    this.md.append(md);
    this.md.toUpperCase();
  }
  this.position=position - 1;
  this.reverseStrand=reverseStrand;
  constructRefAndQuery();
  findSequenceVariations();
  SamSequenceVariation.merge(sequenceVariations);
}"
50330,"private void applyMd(){
  if (debug && LOG.isDebugEnabled()) {
    LOG.debug(String.format(""String_Node_Str"",md));
  }
  int position=numLeftClipped;
  Matcher matcher=MD_REGEX.matcher(md);
  while (matcher.find()) {
    String mdPart=matcher.group();
    if (NUMERIC_REGEX.matcher(mdPart).matches()) {
      int length=Integer.parseInt(mdPart);
      position+=length;
    }
 else     if (mdPart.charAt(0) == '^') {
      for (int i=1; i < mdPart.length(); i++) {
        ref.setCharAt(position++,mdPart.charAt(i));
      }
    }
 else {
      for (int i=0; i < mdPart.length(); i++) {
        ref.setCharAt(position++,Character.toLowerCase(mdPart.charAt(i)));
        numMisMatches++;
      }
    }
  }
}","private void applyMd(){
  if (debug && LOG.isDebugEnabled()) {
    LOG.debug(String.format(""String_Node_Str"",md));
  }
  int position=numLeftClipped;
  final Matcher matcher=MD_REGEX.matcher(md);
  while (matcher.find()) {
    final String mdPart=matcher.group();
    if (NUMERIC_REGEX.matcher(mdPart).matches()) {
      try {
        final int length=Integer.parseInt(mdPart);
        position+=length;
      }
 catch (      NumberFormatException e) {
        System.out.println(""String_Node_Str"");
      }
    }
 else     if (mdPart.charAt(0) == '^') {
      for (int i=1; i < mdPart.length(); i++) {
        ref.setCharAt(position++,mdPart.charAt(i));
      }
    }
 else {
      for (int i=0; i < mdPart.length(); i++) {
        ref.setCharAt(position++,Character.toLowerCase(mdPart.charAt(i)));
        numMisMatches++;
      }
    }
  }
}"
50331,"private void analyzeCigar(int position,String cigar,ObjectArrayList<Limits> list){
  Matcher matcher=CIGAR_REGEX.matcher(cigar);
  int previousCigarIndex=0;
  int cigarIndex=0;
  int previousPosition=position;
  int previousPositionInRead=0;
  int positionInRead=0;
  int initialRefPosition=position;
  while (matcher.find()) {
    final int cigarLength=matcher.group(1).length() + matcher.group(2).length();
    final int readBasesLength=Integer.parseInt(matcher.group(1));
    final char op=matcher.group(2).charAt(0);
switch (op) {
case 'N':
      list.add(new Limits(previousPosition,previousCigarIndex,cigarIndex,previousPositionInRead,positionInRead,previousPosition,position));
    previousCigarIndex=cigarIndex + cigarLength;
  previousPositionInRead=positionInRead;
position+=readBasesLength;
previousPosition=position;
break;
case 'I':
positionInRead+=readBasesLength;
position+=readBasesLength;
break;
case 'D':
for (int j=0; j < readBasesLength; j++) {
refSequence.insert(position - initialRefPosition,'?');
}
break;
case 'S':
try {
for (int j=0; j < readBasesLength; j++) {
final int index=position - initialRefPosition;
if (index >= refSequence.length()) break;
refSequence.insert(index,'-');
}
}
 catch (StringIndexOutOfBoundsException e) {
System.out.println(""String_Node_Str"");
}
break;
default :
positionInRead+=readBasesLength;
position+=readBasesLength;
break;
}
cigarIndex+=cigarLength;
}
list.add(new Limits(previousPosition,previousCigarIndex,cigarIndex,previousPositionInRead,positionInRead,previousPosition,position));
}","private void analyzeCigar(int position,String cigar,ObjectArrayList<Limits> list){
  Matcher matcher=CIGAR_REGEX.matcher(cigar);
  int previousCigarIndex=0;
  int cigarIndex=0;
  int previousPosition=position;
  int previousPositionInRead=0;
  int positionInRead=0;
  int initialRefPosition=position;
  while (matcher.find()) {
    final int cigarLength=matcher.group(1).length() + matcher.group(2).length();
    final int readBasesLength=Integer.parseInt(matcher.group(1));
    final char op=matcher.group(2).charAt(0);
switch (op) {
case 'N':
      list.add(new Limits(previousPosition,previousCigarIndex,cigarIndex,previousPositionInRead,positionInRead,previousPosition,position));
    previousCigarIndex=cigarIndex + cigarLength;
  previousPositionInRead=positionInRead;
position+=readBasesLength;
previousPosition=position;
break;
case 'I':
positionInRead+=readBasesLength;
position+=readBasesLength;
break;
case 'D':
insertSomeInRef(position,initialRefPosition,readBasesLength);
break;
case 'S':
insertSomeInRef(position,initialRefPosition,readBasesLength);
break;
default :
positionInRead+=readBasesLength;
position+=readBasesLength;
break;
}
cigarIndex+=cigarLength;
}
list.add(new Limits(previousPosition,previousCigarIndex,cigarIndex,previousPositionInRead,positionInRead,previousPosition,position));
}"
50332,"/** 
 * Configure.
 * @param args command line arguments
 * @return this object for chaining
 * @throws java.io.IOException error parsing
 * @throws com.martiansoftware.jsap.JSAPException error parsing
 */
@Override public AbstractCommandLineMode configure(final String[] args) throws IOException, JSAPException {
  super.configure(args);
  final JSAPResult jsapResult=parseJsapArguments(args);
  bsmap=jsapResult.getBoolean(""String_Node_Str"");
  String genomeFilename=jsapResult.getString(""String_Node_Str"");
  if (genomeFilename != null) {
    System.err.println(""String_Node_Str"" + genomeFilename);
    genome=new DualRandomAccessSequenceCache();
    try {
      genome.load(genomeFilename);
    }
 catch (    ClassNotFoundException e) {
      System.err.println(""String_Node_Str"");
      System.exit(1);
    }
    System.err.println(""String_Node_Str"");
  }
  numberOfReadsFromCommandLine=jsapResult.getInt(""String_Node_Str"");
  qualityEncoding=QualityEncoding.valueOf(jsapResult.getString(""String_Node_Str"").toUpperCase());
  sortedInput=jsapResult.getBoolean(""String_Node_Str"");
  this.largestQueryIndex=numberOfReadsFromCommandLine;
  this.smallestQueryIndex=0;
  debug=Util.log4JIsConfigured();
  DynamicOptionRegistry.register(MessageChunksWriter.doc());
  DynamicOptionRegistry.register(AlignmentWriter.doc());
  DynamicOptionRegistry.register(QueryIndexPermutation.doc());
  return this;
}","/** 
 * Configure.
 * @param args command line arguments
 * @return this object for chaining
 * @throws java.io.IOException error parsing
 * @throws com.martiansoftware.jsap.JSAPException error parsing
 */
@Override public AbstractCommandLineMode configure(final String[] args) throws IOException, JSAPException {
  super.configure(args);
  final JSAPResult jsapResult=parseJsapArguments(args);
  bsmap=jsapResult.getBoolean(""String_Node_Str"");
  String genomeFilename=jsapResult.getString(""String_Node_Str"");
  if (genomeFilename != null) {
    System.err.println(""String_Node_Str"" + genomeFilename);
    DualRandomAccessSequenceCache aGenome=new DualRandomAccessSequenceCache();
    try {
      aGenome.load(genomeFilename);
      genome=aGenome;
    }
 catch (    ClassNotFoundException e) {
      System.err.println(""String_Node_Str"");
      System.exit(1);
    }
    System.err.println(""String_Node_Str"");
  }
  numberOfReadsFromCommandLine=jsapResult.getInt(""String_Node_Str"");
  qualityEncoding=QualityEncoding.valueOf(jsapResult.getString(""String_Node_Str"").toUpperCase());
  sortedInput=jsapResult.getBoolean(""String_Node_Str"");
  this.largestQueryIndex=numberOfReadsFromCommandLine;
  this.smallestQueryIndex=0;
  debug=Util.log4JIsConfigured();
  DynamicOptionRegistry.register(MessageChunksWriter.doc());
  DynamicOptionRegistry.register(AlignmentWriter.doc());
  DynamicOptionRegistry.register(QueryIndexPermutation.doc());
  return this;
}"
50333,"/** 
 * Adjust reference names to match genome.
 * @param genome
 * @param referenceName
 * @return
 */
private final String map(DualRandomAccessSequenceCache genome,final String referenceName){
  if (genome.getReferenceIndex(referenceName) == -1) {
    if (referenceName.contentEquals(""String_Node_Str"")) {
      return ""String_Node_Str"";
    }
    if (referenceName.startsWith(""String_Node_Str"")) {
      return referenceName.substring(3);
    }
 else {
      return referenceName;
    }
  }
 else {
    return referenceName;
  }
}","/** 
 * Adjust reference names to match genome.
 * @param genome
 * @param referenceName
 * @return
 */
private final String map(RandomAccessSequenceInterface genome,final String referenceName){
  if (genome.getReferenceIndex(referenceName) == -1) {
    if (referenceName.contentEquals(""String_Node_Str"")) {
      return ""String_Node_Str"";
    }
    if (referenceName.startsWith(""String_Node_Str"")) {
      return referenceName.substring(3);
    }
 else {
      return referenceName;
    }
  }
 else {
    return referenceName;
  }
}"
50334,"private void findSequenceVariations(){
  char refChar, queryChar;
  int readIndex, refPosition;
  int genomicLength=ref.length();
  int paddedLength=numLeftClipped + genomicLength + numRightClipped;
  boolean tooBig=false;
  int tooBigReadIndex=0, tooBigRefPosition=0;
  refPositions.size(10);
  readIndexes.size(paddedLength);
  refPositions.size(paddedLength);
  refPosition=0;
  readIndex=0;
  for (int i=0; i < paddedLength; i++) {
    if (i < numLeftClipped) {
      readIndex++;
    }
 else     if (i >= (genomicLength + numLeftClipped)) {
      readIndex++;
    }
 else {
      refChar=Character.toUpperCase(ref.charAt(i - numLeftClipped));
      if (refChar != '-') {
        refPosition++;
      }
      if (reverseStrand) {
        final int index=genomicLength - (i - numLeftClipped) - 1;
        if (index >= query.length()) {
          System.out.printf(""String_Node_Str"",index,query);
        }
 else {
          queryChar=Character.toUpperCase(query.charAt(index));
          if (queryChar != '-') {
            readIndex++;
          }
        }
      }
 else {
        final int index=i - numLeftClipped;
        if (index >= query.length()) {
          System.out.printf(""String_Node_Str"",index,query);
        }
 else {
          queryChar=Character.toUpperCase(query.charAt(index));
          if (queryChar != '-') {
            readIndex++;
          }
        }
      }
    }
    refPositions.set(i,refPosition);
    if (reverseStrand) {
      readIndexes.set(paddedLength - i - 1,readIndex);
    }
 else {
      readIndexes.set(i,readIndex);
    }
  }
  if (debug && LOG.isDebugEnabled()) {
    debugSequences();
    logval.setLength(0);
    logval.append(""String_Node_Str"");
    for (int i=0; i < paddedLength; i++) {
      logval.append(String.format(""String_Node_Str"",refPositions.get(i) % 10));
    }
    LOG.debug(logval.toString());
    logval.setLength(0);
    logval.append(""String_Node_Str"");
    for (int i=0; i < paddedLength; i++) {
      logval.append(String.format(""String_Node_Str"",readIndexes.get(i) % 10));
    }
    LOG.debug(logval.toString());
    LOG.debug(""String_Node_Str"");
    logval.setLength(0);
    for (int i=0; i < paddedLength; i++) {
      if (i < numLeftClipped) {
        refChar='_';
      }
 else       if (i >= (genomicLength + numLeftClipped)) {
        refChar='_';
      }
 else {
        refChar=ref.charAt(i - numLeftClipped);
      }
      logval.append(String.format(""String_Node_Str"",i,refChar,refPositions.get(i)));
    }
    LOG.debug(logval.toString());
    LOG.debug(""String_Node_Str"");
    logval.setLength(0);
    for (int i=0; i < paddedLength; i++) {
      if (i < numLeftClipped) {
        queryChar='_';
      }
 else       if (i >= (numLeftClipped + genomicLength)) {
        queryChar='_';
      }
 else {
        queryChar=query.charAt(i - numLeftClipped);
      }
      logval.append(String.format(""String_Node_Str"",i,queryChar,readIndexes.get(i)));
    }
    LOG.debug(logval.toString());
    LOG.debug(String.format(""String_Node_Str"",numLeftClipped,numRightClipped));
  }
  for (int queryI=numLeftClipped; queryI < numLeftClipped + genomicLength; queryI++) {
    refPosition=refPositions.get(queryI);
    readIndex=readIndexes.get(queryI);
    final int i=queryI - numLeftClipped;
    if (readIndex > queryLength && !tooBig) {
      tooBig=true;
      tooBigReadIndex=readIndex;
      tooBigRefPosition=refPosition;
    }
    refChar=Character.toUpperCase(ref.charAt(i));
    queryChar=Character.toUpperCase(query.charAt(i));
    boolean hasQual;
    byte qualChar;
    if (qual.length() > 0 && queryChar != '-') {
      hasQual=true;
      qualChar=qualityEncoding.asciiEncodingToPhredQualityScore(qual.charAt(i));
    }
 else {
      hasQual=false;
      qualChar=minQualValue;
    }
    if (refChar != queryChar) {
      sequenceVariations.add(new SamSequenceVariation(refPosition,refChar,readIndex,queryChar,hasQual,qualChar));
    }
  }
  if (tooBig) {
    if (debug && LOG.isDebugEnabled()) {
      LOG.debug(String.format(""String_Node_Str"",tooBigReadIndex,tooBigRefPosition));
      LOG.debug(String.format(""String_Node_Str"",queryIndex));
      if (sourceQuery.length() > 0) {
        LOG.debug(String.format(""String_Node_Str"",sourceQuery));
      }
 else {
        LOG.debug(""String_Node_Str"");
      }
    }
  }
}","private void findSequenceVariations(){
  char refChar, queryChar;
  int readIndex, refPosition;
  int genomicLength=ref.length();
  int paddedLength=numLeftClipped + genomicLength + numRightClipped;
  boolean tooBig=false;
  int tooBigReadIndex=0, tooBigRefPosition=0;
  refPositions.size(10);
  readIndexes.size(paddedLength);
  refPositions.size(paddedLength);
  refPosition=0;
  readIndex=0;
  for (int i=0; i < paddedLength; i++) {
    if (i < numLeftClipped) {
      readIndex++;
    }
 else     if (i >= (genomicLength + numLeftClipped)) {
      readIndex++;
    }
 else {
      refChar=Character.toUpperCase(ref.charAt(i - numLeftClipped));
      if (refChar != '-') {
        refPosition++;
      }
      if (reverseStrand) {
        final int index=genomicLength - (i - numLeftClipped) - 1;
        queryChar=Character.toUpperCase(query.charAt(index));
      }
 else {
        final int index=i - numLeftClipped;
        queryChar=Character.toUpperCase(query.charAt(index));
      }
      if (queryChar != '-') {
        readIndex++;
      }
    }
    refPositions.set(i,refPosition);
    if (reverseStrand) {
      readIndexes.set(paddedLength - i - 1,readIndex);
    }
 else {
      readIndexes.set(i,readIndex);
    }
  }
  if (debug && LOG.isDebugEnabled()) {
    debugSequences();
    logval.setLength(0);
    logval.append(""String_Node_Str"");
    for (int i=0; i < paddedLength; i++) {
      logval.append(String.format(""String_Node_Str"",refPositions.get(i) % 10));
    }
    LOG.debug(logval.toString());
    logval.setLength(0);
    logval.append(""String_Node_Str"");
    for (int i=0; i < paddedLength; i++) {
      logval.append(String.format(""String_Node_Str"",readIndexes.get(i) % 10));
    }
    LOG.debug(logval.toString());
    LOG.debug(""String_Node_Str"");
    logval.setLength(0);
    for (int i=0; i < paddedLength; i++) {
      if (i < numLeftClipped) {
        refChar='_';
      }
 else       if (i >= (genomicLength + numLeftClipped)) {
        refChar='_';
      }
 else {
        refChar=ref.charAt(i - numLeftClipped);
      }
      logval.append(String.format(""String_Node_Str"",i,refChar,refPositions.get(i)));
    }
    LOG.debug(logval.toString());
    LOG.debug(""String_Node_Str"");
    logval.setLength(0);
    for (int i=0; i < paddedLength; i++) {
      if (i < numLeftClipped) {
        queryChar='_';
      }
 else       if (i >= (numLeftClipped + genomicLength)) {
        queryChar='_';
      }
 else {
        queryChar=query.charAt(i - numLeftClipped);
      }
      logval.append(String.format(""String_Node_Str"",i,queryChar,readIndexes.get(i)));
    }
    LOG.debug(logval.toString());
    LOG.debug(String.format(""String_Node_Str"",numLeftClipped,numRightClipped));
  }
  for (int queryI=numLeftClipped; queryI < numLeftClipped + genomicLength; queryI++) {
    refPosition=refPositions.get(queryI);
    readIndex=readIndexes.get(queryI);
    final int i=queryI - numLeftClipped;
    if (readIndex > queryLength && !tooBig) {
      tooBig=true;
      tooBigReadIndex=readIndex;
      tooBigRefPosition=refPosition;
    }
    refChar=Character.toUpperCase(ref.charAt(i));
    queryChar=Character.toUpperCase(query.charAt(i));
    boolean hasQual;
    byte qualChar;
    if (qual.length() > 0 && queryChar != '-') {
      hasQual=true;
      qualChar=qualityEncoding.asciiEncodingToPhredQualityScore(qual.charAt(i));
    }
 else {
      hasQual=false;
      qualChar=minQualValue;
    }
    if (refChar != queryChar) {
      sequenceVariations.add(new SamSequenceVariation(refPosition,refChar,readIndex,queryChar,hasQual,qualChar));
    }
  }
  if (tooBig) {
    if (debug && LOG.isDebugEnabled()) {
      LOG.debug(String.format(""String_Node_Str"",tooBigReadIndex,tooBigRefPosition));
      LOG.debug(String.format(""String_Node_Str"",queryIndex));
      if (sourceQuery.length() > 0) {
        LOG.debug(String.format(""String_Node_Str"",sourceQuery));
      }
 else {
        LOG.debug(""String_Node_Str"");
      }
    }
  }
}"
50335,"/** 
 * @param queryIndex
 * @param sourceQuery
 * @param sourceQual
 * @param cigar
 * @param md
 * @param position      one-based position
 * @param reverseStrand
 */
public void setSource(final int queryIndex,final CharSequence sourceQuery,final CharSequence sourceQual,final CharSequence cigar,final CharSequence md,final int position,final boolean reverseStrand){
  final String cigarString=cigar.toString();
  if (!cigarString.contains(N_STRING)) {
    numEntries=1;
    cursorIndex=0;
    initializeHelpers();
    helpers.get(0).setSource(queryIndex,sourceQuery,sourceQual,cigar,md,position,reverseStrand);
  }
 else {
    final Limits[] limits=getLimits(position,cigarString,md);
    numEntries=limits.length;
    initializeHelpers();
    for (int i=0; i < numEntries; i++) {
      final Limits limit=limits[i];
      helpers.get(i).setSource(queryIndex,sourceQuery.subSequence(limit.readStart,limit.readEnd),sourceQual.subSequence(limit.readStart,limit.readEnd),cigarString.substring(limit.cigarStart,limit.cigarEnd),limit.md,limit.position + 1,reverseStrand);
    }
  }
}","/** 
 * @param queryIndex
 * @param sourceQuery
 * @param sourceQual
 * @param cigar
 * @param md
 * @param position      one-based position
 * @param reverseStrand
 */
public void setSource(final int queryIndex,final CharSequence sourceQuery,final CharSequence sourceQual,final CharSequence cigar,final CharSequence md,final int position,final boolean reverseStrand){
  final String cigarString=cigar.toString();
  if (!cigarString.contains(N_STRING)) {
    numEntries=1;
    cursorIndex=0;
    initializeHelpers();
    helpers.get(0).setSource(queryIndex,sourceQuery,sourceQual,cigar,md,position,reverseStrand);
  }
 else {
    final Limits[] limits=getLimits(position,cigarString,md);
    numEntries=limits.length;
    initializeHelpers();
    for (int i=0; i < numEntries; i++) {
      final Limits limit=limits[i];
      helpers.get(i).setSource(queryIndex,sourceQuery.subSequence(limit.readStart,limit.readEnd),sourceQual.subSequence(limit.readStart,limit.readEnd),cigarString.substring(limit.cigarStart,limit.cigarEnd),limit.md,limit.position,reverseStrand);
    }
  }
}"
50336,"public void setSourceWithReference(final int queryIndex,final SAMRecord samRecord,final String sourceReference){
  final String cigarString=samRecord.getCigarString();
  if (!cigarString.contains(N_STRING)) {
    numEntries=1;
    cursorIndex=0;
    initializeHelpers();
    helpers.get(0).setSourceWithReference(queryIndex,samRecord,sourceReference);
  }
 else {
    final CharSequence sourceQuery=samRecord.getReadString();
    final CharSequence sourceQual=samRecord.getBaseQualityString();
    final int position=samRecord.getAlignmentStart();
    final boolean reverseStrand=samRecord.getReadNegativeStrandFlag();
    refSequence.append(sourceReference);
    final Limits[] limits=getLimits(position,cigarString,""String_Node_Str"");
    numEntries=limits.length;
    initializeHelpers();
    for (int i=0; i < numEntries; i++) {
      final Limits limit=limits[i];
      final int refStartIndex=limit.refStart - position;
      final int refEndIndex=refStartIndex + limit.refEnd - limit.refStart;
      try {
        helpers.get(i).setSourceWithReference(queryIndex,refSequence.subSequence(refStartIndex,Math.min(refEndIndex,sourceReference.length() - 1)),sourceQuery.subSequence(limit.readStart,limit.readEnd),sourceQual.subSequence(limit.readStart,limit.readEnd),limit.position + 1,reverseStrand);
      }
 catch (      IndexOutOfBoundsException e) {
        System.out.printf(""String_Node_Str"",refStartIndex,refEndIndex,sourceReference.length(),samRecord.getCigarString(),e);
      }
    }
  }
}","public void setSourceWithReference(final int queryIndex,final SAMRecord samRecord,final String sourceReference){
  final String cigarString=samRecord.getCigarString();
  final int position=samRecord.getAlignmentStart();
  refSequence.append(sourceReference);
  final Limits[] limits=getLimits(position,cigarString,null);
  final CharSequence sourceQuery=samRecord.getReadString();
  final CharSequence sourceQual=samRecord.getBaseQualityString();
  final boolean reverseStrand=samRecord.getReadNegativeStrandFlag();
  numEntries=limits.length;
  initializeHelpers();
  for (int i=0; i < numEntries; i++) {
    final Limits limit=limits[i];
    final int refStartIndex=limit.refStart - position;
    final int refEndIndex=refStartIndex + limit.refEnd - limit.refStart;
    try {
      final CharSequence sourceRef=refSequence.subSequence(refStartIndex,Math.min(refEndIndex,sourceReference.length() - 1));
      helpers.get(i).setSourceWithReference(queryIndex,sourceRef,sourceQuery.subSequence(limit.readStart,limit.readEnd),sourceQual.subSequence(limit.readStart,limit.readEnd),limit.position,reverseStrand);
    }
 catch (    IndexOutOfBoundsException e) {
      System.out.printf(""String_Node_Str"",refStartIndex,refEndIndex,sourceReference.length(),samRecord.getCigarString(),e);
    }
  }
}"
50337,"private void analyzeCigar(int position,String cigar,ObjectArrayList<Limits> list){
  Matcher matcher=CIGAR_REGEX.matcher(cigar);
  int previousCigarIndex=0;
  int cigarIndex=0;
  int previousPosition=position;
  int previousPositionInRead=0;
  int positionInRead=0;
  int initialRefPosition=position;
  while (matcher.find()) {
    final int cigarLength=matcher.group(1).length() + matcher.group(2).length();
    final int readBasesLength=Integer.parseInt(matcher.group(1));
    final char op=matcher.group(2).charAt(0);
switch (op) {
case 'N':
      list.add(new Limits(previousPosition,previousCigarIndex,cigarIndex,previousPositionInRead,positionInRead,previousPosition,position));
    previousCigarIndex=cigarIndex + cigarLength;
  previousPositionInRead=positionInRead;
position+=readBasesLength;
previousPosition=position;
break;
case 'I':
positionInRead+=readBasesLength;
position+=readBasesLength;
break;
case 'D':
positionInRead+=0;
position+=0;
break;
case 'S':
for (int j=0; j < readBasesLength; j++) {
refSequence.insert(position - initialRefPosition,'-');
}
break;
default :
positionInRead+=readBasesLength;
position+=readBasesLength;
break;
}
cigarIndex+=cigarLength;
}
list.add(new Limits(previousPosition,previousCigarIndex,cigarIndex,previousPositionInRead,positionInRead,previousPosition,position));
}","private void analyzeCigar(int position,String cigar,ObjectArrayList<Limits> list){
  Matcher matcher=CIGAR_REGEX.matcher(cigar);
  int previousCigarIndex=0;
  int cigarIndex=0;
  int previousPosition=position;
  int previousPositionInRead=0;
  int positionInRead=0;
  int initialRefPosition=position;
  while (matcher.find()) {
    final int cigarLength=matcher.group(1).length() + matcher.group(2).length();
    final int readBasesLength=Integer.parseInt(matcher.group(1));
    final char op=matcher.group(2).charAt(0);
switch (op) {
case 'N':
      list.add(new Limits(previousPosition,previousCigarIndex,cigarIndex,previousPositionInRead,positionInRead,previousPosition,position));
    previousCigarIndex=cigarIndex + cigarLength;
  previousPositionInRead=positionInRead;
position+=readBasesLength;
previousPosition=position;
break;
case 'I':
positionInRead+=readBasesLength;
position+=readBasesLength;
break;
case 'D':
for (int j=0; j < readBasesLength; j++) {
refSequence.insert(position - initialRefPosition,'?');
}
break;
case 'S':
try {
for (int j=0; j < readBasesLength; j++) {
final int index=position - initialRefPosition;
if (index >= refSequence.length()) break;
refSequence.insert(index,'-');
}
}
 catch (StringIndexOutOfBoundsException e) {
System.out.println(""String_Node_Str"");
}
break;
default :
positionInRead+=readBasesLength;
position+=readBasesLength;
break;
}
cigarIndex+=cigarLength;
}
list.add(new Limits(previousPosition,previousCigarIndex,cigarIndex,previousPositionInRead,positionInRead,previousPosition,position));
}"
50338,"private boolean isForward(final Alignments.AlignmentEntry.Builder entry,final Alignments.RelatedAlignmentEntry pairAlignmentLink){
  final int targetIndex=entry.getTargetIndex();
  final int position=entry.getPosition();
  final int linkedTargetIndex=pairAlignmentLink.getTargetIndex();
  final int linkedPosition=pairAlignmentLink.getPosition();
  if (linkedTargetIndex == targetIndex) {
    return linkedPosition > position;
  }
 else {
    return linkedTargetIndex > targetIndex;
  }
}","private boolean isForward(final Alignments.AlignmentEntry.Builder entry,final Alignments.RelatedAlignmentEntry pairAlignmentLink){
  final int targetIndex=entry.getTargetIndex();
  final int position=entry.getPosition();
  final int linkedTargetIndex=pairAlignmentLink.getTargetIndex();
  final int linkedPosition=pairAlignmentLink.getPosition();
  if (linkedTargetIndex == targetIndex) {
    return linkedPosition >= position;
  }
 else {
    return linkedTargetIndex > targetIndex;
  }
}"
50339,"@Override protected int scan(final ReadSet readIndexFilter,final IndexedIdentifier targetIds,final AlignmentWriter writer,final AlignmentTooManyHitsWriter tmhWriter) throws IOException {
  int numAligns=0;
  final ProgressLogger progress=new ProgressLogger(LOG);
  SAMFileReader.setDefaultValidationStringency(SAMFileReader.ValidationStringency.SILENT);
  final InputStream stream=""String_Node_Str"".equals(inputFile) ? System.in : new FileInputStream(inputFile);
  final SAMFileReader parser=new SAMFileReader(stream);
  boolean hasPaired=false;
  progress.start();
  final SAMRecordIterator samIterator=parser.iterator();
  SamHelper samHelper=new SamHelper();
  samHelper.setQualityEncoding(qualityEncoding);
  numberOfReads=0;
  SAMRecord prevRecord=null;
  final SAMFileHeader fileHeader=parser.getFileHeader();
  if (fileHeader.getSequenceDictionary().isEmpty()) {
    System.err.println(""String_Node_Str"");
    if (runningFromCommandLine) {
      System.exit(0);
    }
  }
  if (sortedInput) {
    final int numTargets=fileHeader.getSequenceDictionary().size();
    final int[] targetLengths=new int[numTargets];
    for (int i=0; i < numTargets; i++) {
      final SAMSequenceRecord seq=fileHeader.getSequence(i);
      final int targetIndex=getTargetIndex(targetIds,seq.getSequenceName(),thirdPartyInput);
      targetLengths[targetIndex]=seq.getSequenceLength();
    }
    writer.setTargetLengths(targetLengths);
    writer.setSorted(true);
  }
  while (samIterator.hasNext()) {
    samHelper.reset();
    numberOfReads++;
    final SAMRecord samRecord=samIterator.next();
    if (samRecord.getReadUnmappedFlag()) {
      if (debug && LOG.isDebugEnabled()) {
        LOG.debug(String.format(""String_Node_Str"",samRecord.getReadName()));
      }
      continue;
    }
    if (sortedInput) {
      if (prevRecord != null) {
        final int compare=prevRecord.getAlignmentStart() - samRecord.getAlignmentStart();
        if (compare > 0) {
          final String message=String.format(""String_Node_Str"",samRecord.toString(),prevRecord.toString());
          System.err.println(""String_Node_Str"" + message);
          LOG.warn(message);
          System.exit(0);
        }
      }
    }
    prevRecord=samRecord;
    int readMaxOccurence=1;
    final boolean readIsPaired=samRecord.getReadPairedFlag();
    final boolean b=readIsPaired && !samRecord.getReadUnmappedFlag();
    if (b) {
      hasPaired=true;
      readMaxOccurence++;
    }
    final Object xoString=samRecord.getAttribute(""String_Node_Str"");
    final int numTotalHits=xoString == null ? 1 : hasPaired ? 1 : (Integer)xoString;
    if (hasPaired) {
      readMaxOccurence=readIsPaired ? 2 : 1;
    }
 else {
      readMaxOccurence=numTotalHits;
    }
    final String readName=samRecord.getReadName();
    final int queryIndex=thirdPartyInput ? nameToQueryIndices.getQueryIndex(readName,readMaxOccurence) : Integer.parseInt(readName);
    final int targetIndex=getTargetIndex(targetIds,samRecord.getReferenceName(),thirdPartyInput);
    final int fragmentIndex;
    final int mateFragmentIndex;
    if (readIsPaired) {
      if (samRecord.getFirstOfPairFlag()) {
        fragmentIndex=0;
        mateFragmentIndex=1;
      }
 else {
        fragmentIndex=1;
        mateFragmentIndex=0;
      }
    }
 else {
      fragmentIndex=0;
      mateFragmentIndex=1;
    }
    if (bsmap) {
      final String specifiedReference=(String)samRecord.getAttribute(""String_Node_Str"");
      final String directions=(String)samRecord.getAttribute(""String_Node_Str"");
      final boolean reverseStrand=directions.equals(""String_Node_Str"") || directions.equals(""String_Node_Str"");
      samHelper.setSourceWithReference(queryIndex,samRecord.getReadString(),samRecord.getBaseQualityString(),specifiedReference,samRecord.getAlignmentStart(),reverseStrand);
    }
 else {
      samHelper.setSource(queryIndex,samRecord.getReadString(),samRecord.getBaseQualityString(),samRecord.getCigarString(),(String)samRecord.getAttribute(""String_Node_Str""),samRecord.getAlignmentStart(),samRecord.getReadNegativeStrandFlag());
    }
    int multiplicity=1;
    if (readIndexFilter != null) {
      multiplicity=readIndexFilter.getMultiplicity(queryIndex);
    }
    largestQueryIndex=Math.max(queryIndex,largestQueryIndex);
    smallestQueryIndex=Math.min(queryIndex,smallestQueryIndex);
    final Alignments.AlignmentEntry.Builder currentEntry=Alignments.AlignmentEntry.newBuilder();
    currentEntry.setMultiplicity(multiplicity);
    currentEntry.setQueryIndex(samHelper.getQueryIndex());
    currentEntry.setTargetIndex(targetIndex);
    currentEntry.setPosition(samHelper.getPosition());
    currentEntry.setQueryPosition(samHelper.getQueryPosition());
    currentEntry.setFragmentIndex(fragmentIndex);
    currentEntry.setQueryLength(samHelper.getQueryLength());
    currentEntry.setScore(samHelper.getScore());
    currentEntry.setNumberOfIndels(samHelper.getNumDeletions() + samHelper.getNumInsertions());
    currentEntry.setNumberOfMismatches(samHelper.getNumMisMatches());
    currentEntry.setMatchingReverseStrand(samHelper.isReverseStrand());
    currentEntry.setQueryAlignedLength(samHelper.getQueryAlignedLength());
    currentEntry.setTargetAlignedLength(samHelper.getTargetAlignedLength());
    currentEntry.setPairFlags(samRecord.getFlags());
    currentEntry.setMappingQuality(samRecord.getMappingQuality());
    if (hasPaired) {
      currentEntry.setInsertSize(samRecord.getInferredInsertSize());
    }
    if (readIsPaired) {
      if (!samRecord.getMateUnmappedFlag()) {
        final Alignments.RelatedAlignmentEntry.Builder relatedBuilder=Alignments.RelatedAlignmentEntry.newBuilder();
        final int mateTargetIndex=getTargetIndex(targetIds,samRecord.getMateReferenceName(),thirdPartyInput);
        final int mateAlignmentStart=samRecord.getMateAlignmentStart() - 1;
        relatedBuilder.setFragmentIndex(mateFragmentIndex);
        relatedBuilder.setPosition(mateAlignmentStart);
        relatedBuilder.setTargetIndex(mateTargetIndex);
        currentEntry.setPairAlignmentLink(relatedBuilder);
      }
    }
    for (    final SamSequenceVariation var : samHelper.getSequenceVariations()) {
      appendNewSequenceVariation(currentEntry,var,samHelper.getQueryLength());
      if (debug && LOG.isDebugEnabled()) {
        LOG.debug(String.format(""String_Node_Str"",var.toString(),queryIndex));
      }
    }
    final Alignments.AlignmentEntry alignmentEntry=currentEntry.build();
    if (qualityFilter.keepEntry(samHelper.getQueryLength(),alignmentEntry)) {
      if (numTotalHits <= mParameter) {
        writer.appendEntry(alignmentEntry);
        numAligns+=multiplicity;
        if (debug && LOG.isDebugEnabled()) {
          LOG.debug(String.format(""String_Node_Str"",queryIndex));
        }
      }
 else {
        tmhWriter.append(queryIndex,numTotalHits,samHelper.getQueryLength());
        if (debug && LOG.isDebugEnabled()) {
          LOG.debug(String.format(""String_Node_Str"",queryIndex));
        }
        while (queryIndex == nameToQueryIndices.getQueryIndex(samRecord.getReadName(),0))         ;
      }
    }
 else {
      if (debug && LOG.isDebugEnabled()) {
        LOG.debug(String.format(""String_Node_Str"",queryIndex));
      }
    }
    progress.lightUpdate();
  }
  samIterator.close();
  if (readIndexFilter != null) {
    writer.putStatistic(""String_Node_Str"",readIndexFilterFile.getName());
  }
  writer.putStatistic(""String_Node_Str"",numAligns);
  writer.setNumQueries(Math.max(numberOfReads,numberOfReadsFromCommandLine));
  writer.printStats(System.out);
  final SAMFileHeader samHeader=fileHeader;
  final SAMSequenceDictionary samSequenceDictionary=samHeader.getSequenceDictionary();
  final List<SAMSequenceRecord> samSequenceRecords=samSequenceDictionary.getSequences();
  int targetCount=targetIds.size();
  if (targetIds.size() != 0 && (targetIds.size() != samSequenceRecords.size())) {
    LOG.warn(""String_Node_Str"" + targetIds.size() + ""String_Node_Str""+ samSequenceRecords.size());
  }
  targetCount=Math.max(samSequenceRecords.size(),targetCount);
  final int[] targetLengths=new int[targetCount];
  for (  final SAMSequenceRecord samSequenceRecord : samSequenceRecords) {
    final int index=samSequenceRecord.getSequenceIndex();
    if (debug && LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + samSequenceRecord.getSequenceName() + ""String_Node_Str""+ index);
    }
    targetLengths[index]=samSequenceRecord.getSequenceLength();
  }
  writer.setTargetLengths(targetLengths);
  progress.stop();
  return numAligns;
}","@Override protected int scan(final ReadSet readIndexFilter,final IndexedIdentifier targetIds,final AlignmentWriter writer,final AlignmentTooManyHitsWriter tmhWriter) throws IOException {
  int numAligns=0;
  final ProgressLogger progress=new ProgressLogger(LOG);
  SAMFileReader.setDefaultValidationStringency(SAMFileReader.ValidationStringency.SILENT);
  final InputStream stream=""String_Node_Str"".equals(inputFile) ? System.in : new FileInputStream(inputFile);
  final SAMFileReader parser=new SAMFileReader(stream);
  boolean hasPaired=false;
  progress.start();
  final SAMRecordIterator samIterator=parser.iterator();
  SamHelper samHelper=new SamHelper();
  samHelper.setQualityEncoding(qualityEncoding);
  numberOfReads=0;
  SAMRecord prevRecord=null;
  final SAMFileHeader fileHeader=parser.getFileHeader();
  if (fileHeader.getSequenceDictionary().isEmpty()) {
    System.err.println(""String_Node_Str"");
    if (runningFromCommandLine) {
      System.exit(0);
    }
  }
  if (sortedInput) {
    final int numTargets=fileHeader.getSequenceDictionary().size();
    final int[] targetLengths=new int[numTargets];
    for (int i=0; i < numTargets; i++) {
      final SAMSequenceRecord seq=fileHeader.getSequence(i);
      final int targetIndex=getTargetIndex(targetIds,seq.getSequenceName(),thirdPartyInput);
      targetLengths[targetIndex]=seq.getSequenceLength();
    }
    writer.setTargetLengths(targetLengths);
    writer.setSorted(true);
  }
  while (samIterator.hasNext()) {
    samHelper.reset();
    numberOfReads++;
    final SAMRecord samRecord=samIterator.next();
    if (samRecord.getReadUnmappedFlag()) {
      if (debug && LOG.isDebugEnabled()) {
        LOG.debug(String.format(""String_Node_Str"",samRecord.getReadName()));
      }
      continue;
    }
    final int targetIndex=getTargetIndex(targetIds,samRecord.getReferenceName(),thirdPartyInput);
    if (sortedInput) {
      if (prevRecord != null && prevRecord.getReferenceIndex() == targetIndex) {
        final int compare=prevRecord.getAlignmentStart() - samRecord.getAlignmentStart();
        if (compare > 0) {
          final String message=String.format(""String_Node_Str"",samRecord.toString(),prevRecord.toString());
          System.err.println(""String_Node_Str"" + message);
          LOG.warn(message);
          System.exit(0);
        }
      }
    }
    prevRecord=samRecord;
    int readMaxOccurence=1;
    final boolean readIsPaired=samRecord.getReadPairedFlag();
    final boolean b=readIsPaired && !samRecord.getReadUnmappedFlag();
    if (b) {
      hasPaired=true;
      readMaxOccurence++;
    }
    final Object xoString=samRecord.getAttribute(""String_Node_Str"");
    final int numTotalHits=xoString == null ? 1 : hasPaired ? 1 : (Integer)xoString;
    if (hasPaired) {
      readMaxOccurence=readIsPaired ? 2 : 1;
    }
 else {
      readMaxOccurence=numTotalHits;
    }
    final String readName=samRecord.getReadName();
    final int queryIndex=thirdPartyInput ? nameToQueryIndices.getQueryIndex(readName,readMaxOccurence) : Integer.parseInt(readName);
    final int fragmentIndex;
    final int mateFragmentIndex;
    if (readIsPaired) {
      if (samRecord.getFirstOfPairFlag()) {
        fragmentIndex=0;
        mateFragmentIndex=1;
      }
 else {
        fragmentIndex=1;
        mateFragmentIndex=0;
      }
    }
 else {
      fragmentIndex=0;
      mateFragmentIndex=1;
    }
    if (bsmap) {
      final String specifiedReference=(String)samRecord.getAttribute(""String_Node_Str"");
      final String directions=(String)samRecord.getAttribute(""String_Node_Str"");
      final boolean reverseStrand=directions.equals(""String_Node_Str"") || directions.equals(""String_Node_Str"");
      samHelper.setSourceWithReference(queryIndex,samRecord.getReadString(),samRecord.getBaseQualityString(),specifiedReference,samRecord.getAlignmentStart(),reverseStrand);
    }
 else {
      samHelper.setSource(queryIndex,samRecord.getReadString(),samRecord.getBaseQualityString(),samRecord.getCigarString(),(String)samRecord.getAttribute(""String_Node_Str""),samRecord.getAlignmentStart(),samRecord.getReadNegativeStrandFlag());
    }
    int multiplicity=1;
    if (readIndexFilter != null) {
      multiplicity=readIndexFilter.getMultiplicity(queryIndex);
    }
    largestQueryIndex=Math.max(queryIndex,largestQueryIndex);
    smallestQueryIndex=Math.min(queryIndex,smallestQueryIndex);
    final Alignments.AlignmentEntry.Builder currentEntry=Alignments.AlignmentEntry.newBuilder();
    currentEntry.setMultiplicity(multiplicity);
    currentEntry.setQueryIndex(samHelper.getQueryIndex());
    currentEntry.setTargetIndex(targetIndex);
    currentEntry.setPosition(samHelper.getPosition());
    currentEntry.setQueryPosition(samHelper.getQueryPosition());
    currentEntry.setFragmentIndex(fragmentIndex);
    currentEntry.setQueryLength(samHelper.getQueryLength());
    currentEntry.setScore(samHelper.getScore());
    currentEntry.setNumberOfIndels(samHelper.getNumDeletions() + samHelper.getNumInsertions());
    currentEntry.setNumberOfMismatches(samHelper.getNumMisMatches());
    currentEntry.setMatchingReverseStrand(samHelper.isReverseStrand());
    currentEntry.setQueryAlignedLength(samHelper.getQueryAlignedLength());
    currentEntry.setTargetAlignedLength(samHelper.getTargetAlignedLength());
    currentEntry.setPairFlags(samRecord.getFlags());
    currentEntry.setMappingQuality(samRecord.getMappingQuality());
    if (hasPaired) {
      currentEntry.setInsertSize(samRecord.getInferredInsertSize());
    }
    if (readIsPaired) {
      if (!samRecord.getMateUnmappedFlag()) {
        final Alignments.RelatedAlignmentEntry.Builder relatedBuilder=Alignments.RelatedAlignmentEntry.newBuilder();
        final int mateTargetIndex=getTargetIndex(targetIds,samRecord.getMateReferenceName(),thirdPartyInput);
        final int mateAlignmentStart=samRecord.getMateAlignmentStart() - 1;
        relatedBuilder.setFragmentIndex(mateFragmentIndex);
        relatedBuilder.setPosition(mateAlignmentStart);
        relatedBuilder.setTargetIndex(mateTargetIndex);
        currentEntry.setPairAlignmentLink(relatedBuilder);
      }
    }
    for (    final SamSequenceVariation var : samHelper.getSequenceVariations()) {
      appendNewSequenceVariation(currentEntry,var,samHelper.getQueryLength());
      if (debug && LOG.isDebugEnabled()) {
        LOG.debug(String.format(""String_Node_Str"",var.toString(),queryIndex));
      }
    }
    final Alignments.AlignmentEntry alignmentEntry=currentEntry.build();
    if (qualityFilter.keepEntry(samHelper.getQueryLength(),alignmentEntry)) {
      if (numTotalHits <= mParameter) {
        writer.appendEntry(alignmentEntry);
        numAligns+=multiplicity;
        if (debug && LOG.isDebugEnabled()) {
          LOG.debug(String.format(""String_Node_Str"",queryIndex));
        }
      }
 else {
        tmhWriter.append(queryIndex,numTotalHits,samHelper.getQueryLength());
        if (debug && LOG.isDebugEnabled()) {
          LOG.debug(String.format(""String_Node_Str"",queryIndex));
        }
        while (queryIndex == nameToQueryIndices.getQueryIndex(samRecord.getReadName(),0))         ;
      }
    }
 else {
      if (debug && LOG.isDebugEnabled()) {
        LOG.debug(String.format(""String_Node_Str"",queryIndex));
      }
    }
    progress.lightUpdate();
  }
  samIterator.close();
  if (readIndexFilter != null) {
    writer.putStatistic(""String_Node_Str"",readIndexFilterFile.getName());
  }
  writer.putStatistic(""String_Node_Str"",numAligns);
  writer.setNumQueries(Math.max(numberOfReads,numberOfReadsFromCommandLine));
  writer.printStats(System.out);
  final SAMFileHeader samHeader=fileHeader;
  final SAMSequenceDictionary samSequenceDictionary=samHeader.getSequenceDictionary();
  final List<SAMSequenceRecord> samSequenceRecords=samSequenceDictionary.getSequences();
  int targetCount=targetIds.size();
  if (targetIds.size() != 0 && (targetIds.size() != samSequenceRecords.size())) {
    LOG.warn(""String_Node_Str"" + targetIds.size() + ""String_Node_Str""+ samSequenceRecords.size());
  }
  targetCount=Math.max(samSequenceRecords.size(),targetCount);
  final int[] targetLengths=new int[targetCount];
  for (  final SAMSequenceRecord samSequenceRecord : samSequenceRecords) {
    final int index=samSequenceRecord.getSequenceIndex();
    if (debug && LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + samSequenceRecord.getSequenceName() + ""String_Node_Str""+ index);
    }
    targetLengths[index]=samSequenceRecord.getSequenceLength();
  }
  writer.setTargetLengths(targetLengths);
  progress.stop();
  return numAligns;
}"
50340,"@Override protected int scan(final ReadSet readIndexFilter,final IndexedIdentifier targetIds,final AlignmentWriter writer,final AlignmentTooManyHitsWriter tmhWriter) throws IOException {
  int numAligns=0;
  final ProgressLogger progress=new ProgressLogger(LOG);
  SAMFileReader.setDefaultValidationStringency(SAMFileReader.ValidationStringency.SILENT);
  final InputStream stream=""String_Node_Str"".equals(inputFile) ? System.in : new FileInputStream(inputFile);
  final SAMFileReader parser=new SAMFileReader(stream);
  boolean hasPaired=false;
  progress.start();
  final SAMRecordIterator samIterator=parser.iterator();
  SamHelper samHelper=new SamHelper();
  samHelper.setQualityEncoding(qualityEncoding);
  numberOfReads=0;
  SAMRecord prevRecord=null;
  final SAMFileHeader fileHeader=parser.getFileHeader();
  if (fileHeader.getSequenceDictionary().size() == 0) {
    System.err.println(""String_Node_Str"");
    System.exit(0);
  }
  if (sortedInput) {
    final int numTargets=fileHeader.getSequenceDictionary().size();
    final int[] targetLengths=new int[numTargets];
    for (int i=0; i < numTargets; i++) {
      final SAMSequenceRecord seq=fileHeader.getSequence(i);
      final int targetIndex=getTargetIndex(targetIds,seq.getSequenceName(),thirdPartyInput);
      targetLengths[targetIndex]=seq.getSequenceLength();
    }
    writer.setTargetLengths(targetLengths);
    writer.setSorted(true);
  }
  while (samIterator.hasNext()) {
    samHelper.reset();
    numberOfReads++;
    final SAMRecord samRecord=samIterator.next();
    if (samRecord.getReadUnmappedFlag()) {
      if (debug && LOG.isDebugEnabled()) {
        LOG.debug(String.format(""String_Node_Str"",samRecord.getReadName()));
      }
      continue;
    }
    if (sortedInput) {
      if (prevRecord != null) {
        final int compare=prevRecord.getAlignmentStart() - samRecord.getAlignmentStart();
        if (compare > 0) {
          final String message=String.format(""String_Node_Str"",samRecord.toString(),prevRecord.toString());
          System.err.println(""String_Node_Str"" + message);
          LOG.warn(message);
          System.exit(0);
        }
      }
    }
    prevRecord=samRecord;
    int readMaxOccurence=1;
    final boolean readIsPaired=samRecord.getReadPairedFlag();
    final boolean b=readIsPaired && !samRecord.getReadUnmappedFlag();
    if (b) {
      hasPaired=true;
      readMaxOccurence++;
    }
    final Object xoString=samRecord.getAttribute(""String_Node_Str"");
    final int numTotalHits=xoString == null ? 1 : hasPaired ? 1 : (Integer)xoString;
    if (hasPaired) {
      readMaxOccurence=readIsPaired ? 2 : 1;
    }
 else {
      readMaxOccurence=numTotalHits;
    }
    final String readName=samRecord.getReadName();
    final int queryIndex=thirdPartyInput ? nameToQueryIndices.getQueryIndex(readName,readMaxOccurence) : Integer.parseInt(readName);
    final int targetIndex=getTargetIndex(targetIds,samRecord.getReferenceName(),thirdPartyInput);
    final int fragmentIndex;
    final int mateFragmentIndex;
    if (readIsPaired) {
      if (samRecord.getFirstOfPairFlag()) {
        fragmentIndex=0;
        mateFragmentIndex=1;
      }
 else {
        fragmentIndex=1;
        mateFragmentIndex=0;
      }
    }
 else {
      fragmentIndex=0;
      mateFragmentIndex=1;
    }
    if (bsmap) {
      final String specifiedReference=(String)samRecord.getAttribute(""String_Node_Str"");
      final String directions=(String)samRecord.getAttribute(""String_Node_Str"");
      final boolean reverseStrand=directions.equals(""String_Node_Str"") || directions.equals(""String_Node_Str"");
      samHelper.setSourceWithReference(queryIndex,samRecord.getReadString(),samRecord.getBaseQualityString(),specifiedReference,samRecord.getAlignmentStart(),reverseStrand);
    }
 else {
      samHelper.setSource(queryIndex,samRecord.getReadString(),samRecord.getBaseQualityString(),samRecord.getCigarString(),(String)samRecord.getAttribute(""String_Node_Str""),samRecord.getAlignmentStart(),samRecord.getReadNegativeStrandFlag());
    }
    int multiplicity=1;
    if (readIndexFilter != null) {
      multiplicity=readIndexFilter.getMultiplicity(queryIndex);
    }
    largestQueryIndex=Math.max(queryIndex,largestQueryIndex);
    smallestQueryIndex=Math.min(queryIndex,smallestQueryIndex);
    final Alignments.AlignmentEntry.Builder currentEntry=Alignments.AlignmentEntry.newBuilder();
    currentEntry.setMultiplicity(multiplicity);
    currentEntry.setQueryIndex(samHelper.getQueryIndex());
    currentEntry.setTargetIndex(targetIndex);
    currentEntry.setPosition(samHelper.getPosition());
    currentEntry.setQueryPosition(samHelper.getQueryPosition());
    currentEntry.setFragmentIndex(fragmentIndex);
    currentEntry.setQueryLength(samHelper.getQueryLength());
    currentEntry.setScore(samHelper.getScore());
    currentEntry.setNumberOfIndels(samHelper.getNumDeletions() + samHelper.getNumInsertions());
    currentEntry.setNumberOfMismatches(samHelper.getNumMisMatches());
    currentEntry.setMatchingReverseStrand(samHelper.isReverseStrand());
    currentEntry.setQueryAlignedLength(samHelper.getQueryAlignedLength());
    currentEntry.setTargetAlignedLength(samHelper.getTargetAlignedLength());
    currentEntry.setPairFlags(samRecord.getFlags());
    currentEntry.setMappingQuality(samRecord.getMappingQuality());
    if (hasPaired) {
      currentEntry.setInsertSize(samRecord.getInferredInsertSize());
    }
    if (readIsPaired) {
      if (!samRecord.getMateUnmappedFlag()) {
        final Alignments.RelatedAlignmentEntry.Builder relatedBuilder=Alignments.RelatedAlignmentEntry.newBuilder();
        final int mateTargetIndex=getTargetIndex(targetIds,samRecord.getMateReferenceName(),thirdPartyInput);
        final int mateAlignmentStart=samRecord.getMateAlignmentStart() - 1;
        relatedBuilder.setFragmentIndex(mateFragmentIndex);
        relatedBuilder.setPosition(mateAlignmentStart);
        relatedBuilder.setTargetIndex(mateTargetIndex);
        currentEntry.setPairAlignmentLink(relatedBuilder);
      }
    }
    for (    final SamSequenceVariation var : samHelper.getSequenceVariations()) {
      appendNewSequenceVariation(currentEntry,var,samHelper.getQueryLength());
      if (debug && LOG.isDebugEnabled()) {
        LOG.debug(String.format(""String_Node_Str"",var.toString(),queryIndex));
      }
    }
    final Alignments.AlignmentEntry alignmentEntry=currentEntry.build();
    if (qualityFilter.keepEntry(samHelper.getQueryLength(),alignmentEntry)) {
      if (numTotalHits <= mParameter) {
        writer.appendEntry(alignmentEntry);
        numAligns+=multiplicity;
        if (debug && LOG.isDebugEnabled()) {
          LOG.debug(String.format(""String_Node_Str"",queryIndex));
        }
      }
 else {
        tmhWriter.append(queryIndex,numTotalHits,samHelper.getQueryLength());
        if (debug && LOG.isDebugEnabled()) {
          LOG.debug(String.format(""String_Node_Str"",queryIndex));
        }
        while (queryIndex == nameToQueryIndices.getQueryIndex(samRecord.getReadName(),0))         ;
      }
    }
 else {
      if (debug && LOG.isDebugEnabled()) {
        LOG.debug(String.format(""String_Node_Str"",queryIndex));
      }
    }
    progress.lightUpdate();
  }
  samIterator.close();
  if (readIndexFilter != null) {
    writer.putStatistic(""String_Node_Str"",readIndexFilterFile.getName());
  }
  writer.putStatistic(""String_Node_Str"",numAligns);
  writer.setNumQueries(Math.max(numberOfReads,numberOfReadsFromCommandLine));
  writer.printStats(System.out);
  final SAMFileHeader samHeader=fileHeader;
  final SAMSequenceDictionary samSequenceDictionary=samHeader.getSequenceDictionary();
  final List<SAMSequenceRecord> samSequenceRecords=samSequenceDictionary.getSequences();
  int targetCount=targetIds.size();
  if (targetIds.size() != 0 && (targetIds.size() != samSequenceRecords.size())) {
    LOG.warn(""String_Node_Str"" + targetIds.size() + ""String_Node_Str""+ samSequenceRecords.size());
  }
  targetCount=Math.max(samSequenceRecords.size(),targetCount);
  final int[] targetLengths=new int[targetCount];
  for (  final SAMSequenceRecord samSequenceRecord : samSequenceRecords) {
    final int index=samSequenceRecord.getSequenceIndex();
    if (debug && LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + samSequenceRecord.getSequenceName() + ""String_Node_Str""+ index);
    }
    targetLengths[index]=samSequenceRecord.getSequenceLength();
  }
  writer.setTargetLengths(targetLengths);
  progress.stop();
  return numAligns;
}","@Override protected int scan(final ReadSet readIndexFilter,final IndexedIdentifier targetIds,final AlignmentWriter writer,final AlignmentTooManyHitsWriter tmhWriter) throws IOException {
  int numAligns=0;
  final ProgressLogger progress=new ProgressLogger(LOG);
  SAMFileReader.setDefaultValidationStringency(SAMFileReader.ValidationStringency.SILENT);
  final InputStream stream=""String_Node_Str"".equals(inputFile) ? System.in : new FileInputStream(inputFile);
  final SAMFileReader parser=new SAMFileReader(stream);
  boolean hasPaired=false;
  progress.start();
  final SAMRecordIterator samIterator=parser.iterator();
  SamHelper samHelper=new SamHelper();
  samHelper.setQualityEncoding(qualityEncoding);
  numberOfReads=0;
  SAMRecord prevRecord=null;
  final SAMFileHeader fileHeader=parser.getFileHeader();
  if (fileHeader.getSequenceDictionary().isEmpty()) {
    System.err.println(""String_Node_Str"");
    if (runningFromCommandLine) {
      System.exit(0);
    }
  }
  if (sortedInput) {
    final int numTargets=fileHeader.getSequenceDictionary().size();
    final int[] targetLengths=new int[numTargets];
    for (int i=0; i < numTargets; i++) {
      final SAMSequenceRecord seq=fileHeader.getSequence(i);
      final int targetIndex=getTargetIndex(targetIds,seq.getSequenceName(),thirdPartyInput);
      targetLengths[targetIndex]=seq.getSequenceLength();
    }
    writer.setTargetLengths(targetLengths);
    writer.setSorted(true);
  }
  while (samIterator.hasNext()) {
    samHelper.reset();
    numberOfReads++;
    final SAMRecord samRecord=samIterator.next();
    if (samRecord.getReadUnmappedFlag()) {
      if (debug && LOG.isDebugEnabled()) {
        LOG.debug(String.format(""String_Node_Str"",samRecord.getReadName()));
      }
      continue;
    }
    if (sortedInput) {
      if (prevRecord != null) {
        final int compare=prevRecord.getAlignmentStart() - samRecord.getAlignmentStart();
        if (compare > 0) {
          final String message=String.format(""String_Node_Str"",samRecord.toString(),prevRecord.toString());
          System.err.println(""String_Node_Str"" + message);
          LOG.warn(message);
          System.exit(0);
        }
      }
    }
    prevRecord=samRecord;
    int readMaxOccurence=1;
    final boolean readIsPaired=samRecord.getReadPairedFlag();
    final boolean b=readIsPaired && !samRecord.getReadUnmappedFlag();
    if (b) {
      hasPaired=true;
      readMaxOccurence++;
    }
    final Object xoString=samRecord.getAttribute(""String_Node_Str"");
    final int numTotalHits=xoString == null ? 1 : hasPaired ? 1 : (Integer)xoString;
    if (hasPaired) {
      readMaxOccurence=readIsPaired ? 2 : 1;
    }
 else {
      readMaxOccurence=numTotalHits;
    }
    final String readName=samRecord.getReadName();
    final int queryIndex=thirdPartyInput ? nameToQueryIndices.getQueryIndex(readName,readMaxOccurence) : Integer.parseInt(readName);
    final int targetIndex=getTargetIndex(targetIds,samRecord.getReferenceName(),thirdPartyInput);
    final int fragmentIndex;
    final int mateFragmentIndex;
    if (readIsPaired) {
      if (samRecord.getFirstOfPairFlag()) {
        fragmentIndex=0;
        mateFragmentIndex=1;
      }
 else {
        fragmentIndex=1;
        mateFragmentIndex=0;
      }
    }
 else {
      fragmentIndex=0;
      mateFragmentIndex=1;
    }
    if (bsmap) {
      final String specifiedReference=(String)samRecord.getAttribute(""String_Node_Str"");
      final String directions=(String)samRecord.getAttribute(""String_Node_Str"");
      final boolean reverseStrand=directions.equals(""String_Node_Str"") || directions.equals(""String_Node_Str"");
      samHelper.setSourceWithReference(queryIndex,samRecord.getReadString(),samRecord.getBaseQualityString(),specifiedReference,samRecord.getAlignmentStart(),reverseStrand);
    }
 else {
      samHelper.setSource(queryIndex,samRecord.getReadString(),samRecord.getBaseQualityString(),samRecord.getCigarString(),(String)samRecord.getAttribute(""String_Node_Str""),samRecord.getAlignmentStart(),samRecord.getReadNegativeStrandFlag());
    }
    int multiplicity=1;
    if (readIndexFilter != null) {
      multiplicity=readIndexFilter.getMultiplicity(queryIndex);
    }
    largestQueryIndex=Math.max(queryIndex,largestQueryIndex);
    smallestQueryIndex=Math.min(queryIndex,smallestQueryIndex);
    final Alignments.AlignmentEntry.Builder currentEntry=Alignments.AlignmentEntry.newBuilder();
    currentEntry.setMultiplicity(multiplicity);
    currentEntry.setQueryIndex(samHelper.getQueryIndex());
    currentEntry.setTargetIndex(targetIndex);
    currentEntry.setPosition(samHelper.getPosition());
    currentEntry.setQueryPosition(samHelper.getQueryPosition());
    currentEntry.setFragmentIndex(fragmentIndex);
    currentEntry.setQueryLength(samHelper.getQueryLength());
    currentEntry.setScore(samHelper.getScore());
    currentEntry.setNumberOfIndels(samHelper.getNumDeletions() + samHelper.getNumInsertions());
    currentEntry.setNumberOfMismatches(samHelper.getNumMisMatches());
    currentEntry.setMatchingReverseStrand(samHelper.isReverseStrand());
    currentEntry.setQueryAlignedLength(samHelper.getQueryAlignedLength());
    currentEntry.setTargetAlignedLength(samHelper.getTargetAlignedLength());
    currentEntry.setPairFlags(samRecord.getFlags());
    currentEntry.setMappingQuality(samRecord.getMappingQuality());
    if (hasPaired) {
      currentEntry.setInsertSize(samRecord.getInferredInsertSize());
    }
    if (readIsPaired) {
      if (!samRecord.getMateUnmappedFlag()) {
        final Alignments.RelatedAlignmentEntry.Builder relatedBuilder=Alignments.RelatedAlignmentEntry.newBuilder();
        final int mateTargetIndex=getTargetIndex(targetIds,samRecord.getMateReferenceName(),thirdPartyInput);
        final int mateAlignmentStart=samRecord.getMateAlignmentStart() - 1;
        relatedBuilder.setFragmentIndex(mateFragmentIndex);
        relatedBuilder.setPosition(mateAlignmentStart);
        relatedBuilder.setTargetIndex(mateTargetIndex);
        currentEntry.setPairAlignmentLink(relatedBuilder);
      }
    }
    for (    final SamSequenceVariation var : samHelper.getSequenceVariations()) {
      appendNewSequenceVariation(currentEntry,var,samHelper.getQueryLength());
      if (debug && LOG.isDebugEnabled()) {
        LOG.debug(String.format(""String_Node_Str"",var.toString(),queryIndex));
      }
    }
    final Alignments.AlignmentEntry alignmentEntry=currentEntry.build();
    if (qualityFilter.keepEntry(samHelper.getQueryLength(),alignmentEntry)) {
      if (numTotalHits <= mParameter) {
        writer.appendEntry(alignmentEntry);
        numAligns+=multiplicity;
        if (debug && LOG.isDebugEnabled()) {
          LOG.debug(String.format(""String_Node_Str"",queryIndex));
        }
      }
 else {
        tmhWriter.append(queryIndex,numTotalHits,samHelper.getQueryLength());
        if (debug && LOG.isDebugEnabled()) {
          LOG.debug(String.format(""String_Node_Str"",queryIndex));
        }
        while (queryIndex == nameToQueryIndices.getQueryIndex(samRecord.getReadName(),0))         ;
      }
    }
 else {
      if (debug && LOG.isDebugEnabled()) {
        LOG.debug(String.format(""String_Node_Str"",queryIndex));
      }
    }
    progress.lightUpdate();
  }
  samIterator.close();
  if (readIndexFilter != null) {
    writer.putStatistic(""String_Node_Str"",readIndexFilterFile.getName());
  }
  writer.putStatistic(""String_Node_Str"",numAligns);
  writer.setNumQueries(Math.max(numberOfReads,numberOfReadsFromCommandLine));
  writer.printStats(System.out);
  final SAMFileHeader samHeader=fileHeader;
  final SAMSequenceDictionary samSequenceDictionary=samHeader.getSequenceDictionary();
  final List<SAMSequenceRecord> samSequenceRecords=samSequenceDictionary.getSequences();
  int targetCount=targetIds.size();
  if (targetIds.size() != 0 && (targetIds.size() != samSequenceRecords.size())) {
    LOG.warn(""String_Node_Str"" + targetIds.size() + ""String_Node_Str""+ samSequenceRecords.size());
  }
  targetCount=Math.max(samSequenceRecords.size(),targetCount);
  final int[] targetLengths=new int[targetCount];
  for (  final SAMSequenceRecord samSequenceRecord : samSequenceRecords) {
    final int index=samSequenceRecord.getSequenceIndex();
    if (debug && LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + samSequenceRecord.getSequenceName() + ""String_Node_Str""+ index);
    }
    targetLengths[index]=samSequenceRecord.getSequenceLength();
  }
  writer.setTargetLengths(targetLengths);
  progress.stop();
  return numAligns;
}"
50341,"/** 
 * Main method.
 * @param args command line args.
 * @throws com.martiansoftware.jsap.JSAPException error parsing
 * @throws java.io.IOException error parsing or executing.
 */
public static void main(final String[] args) throws JSAPException, IOException {
  new SAMToCompactMode().configure(args).execute();
}","/** 
 * Main method.
 * @param args command line args.
 * @throws com.martiansoftware.jsap.JSAPException error parsing
 * @throws java.io.IOException error parsing or executing.
 */
public static void main(final String[] args) throws JSAPException, IOException {
  final SAMToCompactMode processor=new SAMToCompactMode();
  processor.configure(args);
  processor.runningFromCommandLine=true;
  processor.execute();
}"
50342,"@Override public void run(){
  final String threadId=String.format(""String_Node_Str"",Thread.currentThread().getId());
  final List<String> mergeFromBasenames=new LinkedList<String>();
  try {
    System.gc();
    final SortMergeSplit merged=toMerge.get(0);
    final int numSplits=toMerge.size();
    for (int i=1; i < numSplits; i++) {
      merged.addRangesFomSplit(toMerge.get(i));
      merged.numFiles+=toMerge.get(i).numFiles;
    }
    merged.ranges=mergeRangeList(merged.ranges);
    LOG.debug(String.format(""String_Node_Str"",threadId,numSplits,ArrayUtils.toString(toMerge),ArrayUtils.toString(merged)));
    for (    final SortMergeSplit mergeFrom : toMerge) {
      final String inputBasename=tempDir + ""String_Node_Str"" + mergeFrom.tag;
      mergeFromBasenames.add(inputBasename);
    }
    final ConcatSortedAlignmentReader concatReader=new ConcatSortedAlignmentReader(false,mergeFromBasenames.toArray(new String[mergeFromBasenames.size()]));
    concatReader.readHeader();
    merged.makeNewTag();
    final String subBasename;
    final String subOutputFilename;
    if (lastMerge) {
      subBasename=FilenameUtils.getName(basename);
      subOutputFilename=outputFilename;
    }
 else {
      subBasename=""String_Node_Str"" + merged.tag;
      subOutputFilename=tempDir + ""String_Node_Str"" + subBasename;
    }
    final AlignmentWriter writer=new AlignmentWriter(subOutputFilename);
    writer.setSorted(true);
    if (concatReader.getTargetLength() != null) {
      writer.setTargetLengths(concatReader.getTargetLength());
    }
    for (    final Alignments.AlignmentEntry entry : concatReader) {
      writer.appendEntry(entry);
    }
    writer.close();
    numMergesExecuted.incrementAndGet();
    sortedSplits.add(merged);
  }
 catch (  IOException e) {
    LOG.error(String.format(""String_Node_Str"",threadId,e.getMessage()));
    exceptions.add(e);
  }
catch (  Throwable t) {
    LOG.error(String.format(""String_Node_Str"",threadId,t.getMessage()));
    exceptions.add(t);
  }
 finally {
    for (    final String mergeFromBasename : mergeFromBasenames) {
      deleteFile(new File(mergeFromBasename + ""String_Node_Str""),true);
      deleteFile(new File(mergeFromBasename + ""String_Node_Str""),true);
      deleteFile(new File(mergeFromBasename + ""String_Node_Str""),true);
      deleteFile(new File(mergeFromBasename + ""String_Node_Str""),true);
    }
  }
}","@Override public void run(){
  final String threadId=String.format(""String_Node_Str"",Thread.currentThread().getId());
  final List<String> mergeFromBasenames=new LinkedList<String>();
  try {
    System.gc();
    final SortMergeSplit merged=toMerge.get(0);
    final int numSplits=toMerge.size();
    for (int i=1; i < numSplits; i++) {
      merged.addRangesFomSplit(toMerge.get(i));
      merged.numFiles+=toMerge.get(i).numFiles;
    }
    merged.ranges=mergeRangeList(merged.ranges);
    LOG.debug(String.format(""String_Node_Str"",threadId,numSplits,ArrayUtils.toString(toMerge),ArrayUtils.toString(merged)));
    for (    final SortMergeSplit mergeFrom : toMerge) {
      final String inputBasename=tempDir + ""String_Node_Str"" + mergeFrom.tag;
      mergeFromBasenames.add(inputBasename);
    }
    final ConcatSortedAlignmentReader concatReader=new ConcatSortedAlignmentReader(false,mergeFromBasenames.toArray(new String[mergeFromBasenames.size()]));
    concatReader.readHeader();
    merged.makeNewTag();
    final String subBasename;
    final String subOutputFilename;
    if (lastMerge) {
      subBasename=FilenameUtils.getName(basename);
      subOutputFilename=outputFilename;
    }
 else {
      subBasename=""String_Node_Str"" + merged.tag;
      subOutputFilename=tempDir + ""String_Node_Str"" + subBasename;
    }
    final AlignmentWriter writer=new AlignmentWriter(subOutputFilename);
    if (concatReader.getTargetLength() != null) {
      writer.setTargetLengths(concatReader.getTargetLength());
    }
    writer.setTargetIdentifiers(concatReader.getTargetIdentifiers());
    writer.setSorted(true);
    for (    final Alignments.AlignmentEntry entry : concatReader) {
      writer.appendEntry(entry);
    }
    writer.close();
    numMergesExecuted.incrementAndGet();
    sortedSplits.add(merged);
  }
 catch (  IOException e) {
    LOG.error(String.format(""String_Node_Str"",threadId,e.getMessage()));
    exceptions.add(e);
  }
catch (  Throwable t) {
    LOG.error(String.format(""String_Node_Str"",threadId,t.getMessage()));
    exceptions.add(t);
  }
 finally {
    for (    final String mergeFromBasename : mergeFromBasenames) {
      deleteFile(new File(mergeFromBasename + ""String_Node_Str""),true);
      deleteFile(new File(mergeFromBasename + ""String_Node_Str""),true);
      deleteFile(new File(mergeFromBasename + ""String_Node_Str""),true);
      deleteFile(new File(mergeFromBasename + ""String_Node_Str""),true);
    }
  }
}"
50343,"/** 
 * Subsequent merge of multiple splits
 * @param toMerge   the splits to sort
 * @param lastMerge
 */
private void mergeSplits(final List<SortMergeSplit> toMerge,final boolean lastMerge){
  numSortMergesRunning.incrementAndGet();
  final Runnable toRun=new Runnable(){
    @Override public void run(){
      final String threadId=String.format(""String_Node_Str"",Thread.currentThread().getId());
      final List<String> mergeFromBasenames=new LinkedList<String>();
      try {
        System.gc();
        final SortMergeSplit merged=toMerge.get(0);
        final int numSplits=toMerge.size();
        for (int i=1; i < numSplits; i++) {
          merged.addRangesFomSplit(toMerge.get(i));
          merged.numFiles+=toMerge.get(i).numFiles;
        }
        merged.ranges=mergeRangeList(merged.ranges);
        LOG.debug(String.format(""String_Node_Str"",threadId,numSplits,ArrayUtils.toString(toMerge),ArrayUtils.toString(merged)));
        for (        final SortMergeSplit mergeFrom : toMerge) {
          final String inputBasename=tempDir + ""String_Node_Str"" + mergeFrom.tag;
          mergeFromBasenames.add(inputBasename);
        }
        final ConcatSortedAlignmentReader concatReader=new ConcatSortedAlignmentReader(false,mergeFromBasenames.toArray(new String[mergeFromBasenames.size()]));
        concatReader.readHeader();
        merged.makeNewTag();
        final String subBasename;
        final String subOutputFilename;
        if (lastMerge) {
          subBasename=FilenameUtils.getName(basename);
          subOutputFilename=outputFilename;
        }
 else {
          subBasename=""String_Node_Str"" + merged.tag;
          subOutputFilename=tempDir + ""String_Node_Str"" + subBasename;
        }
        final AlignmentWriter writer=new AlignmentWriter(subOutputFilename);
        writer.setSorted(true);
        if (concatReader.getTargetLength() != null) {
          writer.setTargetLengths(concatReader.getTargetLength());
        }
        for (        final Alignments.AlignmentEntry entry : concatReader) {
          writer.appendEntry(entry);
        }
        writer.close();
        numMergesExecuted.incrementAndGet();
        sortedSplits.add(merged);
      }
 catch (      IOException e) {
        LOG.error(String.format(""String_Node_Str"",threadId,e.getMessage()));
        exceptions.add(e);
      }
catch (      Throwable t) {
        LOG.error(String.format(""String_Node_Str"",threadId,t.getMessage()));
        exceptions.add(t);
      }
 finally {
        for (        final String mergeFromBasename : mergeFromBasenames) {
          deleteFile(new File(mergeFromBasename + ""String_Node_Str""),true);
          deleteFile(new File(mergeFromBasename + ""String_Node_Str""),true);
          deleteFile(new File(mergeFromBasename + ""String_Node_Str""),true);
          deleteFile(new File(mergeFromBasename + ""String_Node_Str""),true);
        }
      }
    }
  }
;
  if (executorService != null) {
    executorService.submit(toRun);
  }
 else {
    toRun.run();
  }
}","/** 
 * Subsequent merge of multiple splits
 * @param toMerge   the splits to sort
 * @param lastMerge
 */
private void mergeSplits(final List<SortMergeSplit> toMerge,final boolean lastMerge){
  numSortMergesRunning.incrementAndGet();
  final Runnable toRun=new Runnable(){
    @Override public void run(){
      final String threadId=String.format(""String_Node_Str"",Thread.currentThread().getId());
      final List<String> mergeFromBasenames=new LinkedList<String>();
      try {
        System.gc();
        final SortMergeSplit merged=toMerge.get(0);
        final int numSplits=toMerge.size();
        for (int i=1; i < numSplits; i++) {
          merged.addRangesFomSplit(toMerge.get(i));
          merged.numFiles+=toMerge.get(i).numFiles;
        }
        merged.ranges=mergeRangeList(merged.ranges);
        LOG.debug(String.format(""String_Node_Str"",threadId,numSplits,ArrayUtils.toString(toMerge),ArrayUtils.toString(merged)));
        for (        final SortMergeSplit mergeFrom : toMerge) {
          final String inputBasename=tempDir + ""String_Node_Str"" + mergeFrom.tag;
          mergeFromBasenames.add(inputBasename);
        }
        final ConcatSortedAlignmentReader concatReader=new ConcatSortedAlignmentReader(false,mergeFromBasenames.toArray(new String[mergeFromBasenames.size()]));
        concatReader.readHeader();
        merged.makeNewTag();
        final String subBasename;
        final String subOutputFilename;
        if (lastMerge) {
          subBasename=FilenameUtils.getName(basename);
          subOutputFilename=outputFilename;
        }
 else {
          subBasename=""String_Node_Str"" + merged.tag;
          subOutputFilename=tempDir + ""String_Node_Str"" + subBasename;
        }
        final AlignmentWriter writer=new AlignmentWriter(subOutputFilename);
        if (concatReader.getTargetLength() != null) {
          writer.setTargetLengths(concatReader.getTargetLength());
        }
        writer.setTargetIdentifiers(concatReader.getTargetIdentifiers());
        writer.setSorted(true);
        for (        final Alignments.AlignmentEntry entry : concatReader) {
          writer.appendEntry(entry);
        }
        writer.close();
        numMergesExecuted.incrementAndGet();
        sortedSplits.add(merged);
      }
 catch (      IOException e) {
        LOG.error(String.format(""String_Node_Str"",threadId,e.getMessage()));
        exceptions.add(e);
      }
catch (      Throwable t) {
        LOG.error(String.format(""String_Node_Str"",threadId,t.getMessage()));
        exceptions.add(t);
      }
 finally {
        for (        final String mergeFromBasename : mergeFromBasenames) {
          deleteFile(new File(mergeFromBasename + ""String_Node_Str""),true);
          deleteFile(new File(mergeFromBasename + ""String_Node_Str""),true);
          deleteFile(new File(mergeFromBasename + ""String_Node_Str""),true);
          deleteFile(new File(mergeFromBasename + ""String_Node_Str""),true);
        }
      }
    }
  }
;
  if (executorService != null) {
    executorService.submit(toRun);
  }
 else {
    toRun.run();
  }
}"
50344,"public void setQueryIdentifiers(final IndexedIdentifier queryIdentifiers){
  this.queryIdentifiers=queryIdentifiers;
  for (  final int index : queryIdentifiers.values()) {
    int permIndex=permutator.permutate(index);
    maxQueryIndex=Math.max(maxQueryIndex,index);
  }
}","public void setQueryIdentifiers(final IndexedIdentifier queryIdentifiers){
  this.queryIdentifiers=queryIdentifiers;
  for (  final int index : queryIdentifiers.values()) {
    permutator.permutate(index,2);
  }
}"
50345,"public PermutationWriter(final String basename){
  this.basename=AlignmentReaderImpl.getBasename(basename);
  DataOutputStream o=null;
  try {
    o=new DataOutputStream(new FastBufferedOutputStream(new FileOutputStream(basename + ""String_Node_Str"")));
  }
 catch (  FileNotFoundException e) {
    LOG.error(e);
    o=null;
  }
  output=o;
}","public PermutationWriter(final String basename){
}"
50346,"@Override protected int scan(final ReadSet readIndexFilter,final IndexedIdentifier targetIds,final AlignmentWriter writer,final AlignmentTooManyHitsWriter tmhWriter) throws IOException {
  int numAligns=0;
  final ProgressLogger progress=new ProgressLogger(LOG);
  SAMFileReader.setDefaultValidationStringency(SAMFileReader.ValidationStringency.SILENT);
  final SAMFileReader parser=new SAMFileReader(new File(inputFile));
  progress.start();
  final SAMRecordIterator samIterator=parser.iterator();
  SamHelper samHelper=new SamHelper();
  samHelper.setQualityEncoding(qualityEncoding);
  numberOfReads=0;
  final SAMRecordCoordinateComparator samComparator=new SAMRecordCoordinateComparator();
  SAMRecord prevRecord=null;
  final SAMFileHeader fileHeader=parser.getFileHeader();
  if (sortedInput) {
    final int numTargets=fileHeader.getSequenceDictionary().size();
    final int[] targetLengths=new int[numTargets];
    for (int i=0; i < numTargets; i++) {
      final SAMSequenceRecord seq=fileHeader.getSequence(i);
      final int targetIndex=getTargetIndex(targetIds,seq.getSequenceName(),thirdPartyInput);
      targetLengths[targetIndex]=seq.getSequenceLength();
    }
    writer.setTargetLengths(targetLengths);
    writer.setSorted(true);
  }
  while (samIterator.hasNext()) {
    samHelper.reset();
    numberOfReads++;
    final SAMRecord samRecord=samIterator.next();
    if (samRecord.getReadUnmappedFlag()) {
      if (debug && LOG.isDebugEnabled()) {
        LOG.debug(String.format(""String_Node_Str"",samRecord.getReadName()));
      }
      continue;
    }
    if (sortedInput) {
      if (prevRecord != null) {
        final int compare=prevRecord.getAlignmentStart() - samRecord.getAlignmentStart();
        if (compare > 0) {
          final String message=String.format(""String_Node_Str"",samRecord.toString(),prevRecord.toString());
          System.err.println(""String_Node_Str"" + message);
          LOG.warn(message);
          System.exit(0);
        }
      }
    }
    prevRecord=samRecord;
    int readMaxOccurence=1;
    final boolean readIsPaired=samRecord.getReadPairedFlag();
    final boolean b=readIsPaired && !samRecord.getReadUnmappedFlag();
    if (b) {
      readMaxOccurence++;
    }
    final Object xoString=samRecord.getAttribute(""String_Node_Str"");
    final int numTotalHits=xoString == null ? 1 : (Integer)xoString;
    readMaxOccurence=Math.max(numTotalHits * (readIsPaired ? 2 : 1),readMaxOccurence);
    final String readName=samRecord.getReadName();
    final int queryIndex=nameToQueryIndices.getQueryIndex(readName,readMaxOccurence);
    final int targetIndex=getTargetIndex(targetIds,samRecord.getReferenceName(),thirdPartyInput);
    final int fragmentIndex;
    final int mateFragmentIndex;
    if (readIsPaired) {
      if (samRecord.getFirstOfPairFlag()) {
        fragmentIndex=0;
        mateFragmentIndex=1;
      }
 else {
        fragmentIndex=1;
        mateFragmentIndex=0;
      }
    }
 else {
      fragmentIndex=0;
      mateFragmentIndex=1;
    }
    if (bsmap) {
      final String specifiedReference=(String)samRecord.getAttribute(""String_Node_Str"");
      final String directions=(String)samRecord.getAttribute(""String_Node_Str"");
      final boolean reverseStrand=directions.equals(""String_Node_Str"") || directions.equals(""String_Node_Str"");
      samHelper.setSourceWithReference(queryIndex,samRecord.getReadString(),samRecord.getBaseQualityString(),specifiedReference,samRecord.getAlignmentStart(),reverseStrand);
    }
 else {
      samHelper.setSource(queryIndex,samRecord.getReadString(),samRecord.getBaseQualityString(),samRecord.getCigarString(),(String)samRecord.getAttribute(""String_Node_Str""),samRecord.getAlignmentStart(),samRecord.getReadNegativeStrandFlag());
    }
    int multiplicity=1;
    if (readIndexFilter != null) {
      multiplicity=readIndexFilter.getMultiplicity(queryIndex);
    }
    largestQueryIndex=Math.max(queryIndex,largestQueryIndex);
    smallestQueryIndex=Math.min(queryIndex,smallestQueryIndex);
    final Alignments.AlignmentEntry.Builder currentEntry=Alignments.AlignmentEntry.newBuilder();
    currentEntry.setMultiplicity(multiplicity);
    currentEntry.setQueryIndex(samHelper.getQueryIndex());
    currentEntry.setTargetIndex(targetIndex);
    currentEntry.setPosition(samHelper.getPosition());
    currentEntry.setQueryPosition(samHelper.getQueryPosition());
    currentEntry.setFragmentIndex(fragmentIndex);
    currentEntry.setQueryLength(samHelper.getQueryLength());
    currentEntry.setScore(samHelper.getScore());
    currentEntry.setNumberOfIndels(samHelper.getNumDeletions() + samHelper.getNumInsertions());
    currentEntry.setNumberOfMismatches(samHelper.getNumMisMatches());
    currentEntry.setMatchingReverseStrand(samHelper.isReverseStrand());
    currentEntry.setQueryAlignedLength(samHelper.getQueryAlignedLength());
    currentEntry.setTargetAlignedLength(samHelper.getTargetAlignedLength());
    currentEntry.setPairFlags(samRecord.getFlags());
    if (readIsPaired) {
      if (!samRecord.getMateUnmappedFlag()) {
        final Alignments.RelatedAlignmentEntry.Builder relatedBuilder=Alignments.RelatedAlignmentEntry.newBuilder();
        final int mateTargetIndex=getTargetIndex(targetIds,samRecord.getMateReferenceName(),thirdPartyInput);
        final int mateAlignmentStart=samRecord.getMateAlignmentStart() - 1;
        relatedBuilder.setFragmentIndex(mateFragmentIndex);
        relatedBuilder.setPosition(mateAlignmentStart);
        relatedBuilder.setTargetIndex(mateTargetIndex);
        currentEntry.setPairAlignmentLink(relatedBuilder);
      }
    }
    for (    final SamSequenceVariation var : samHelper.getSequenceVariations()) {
      appendNewSequenceVariation(currentEntry,var,samHelper.getQueryLength());
      if (debug && LOG.isDebugEnabled()) {
        LOG.debug(String.format(""String_Node_Str"",var.toString(),queryIndex));
      }
    }
    final Alignments.AlignmentEntry alignmentEntry=currentEntry.build();
    if (qualityFilter.keepEntry(samHelper.getQueryLength(),alignmentEntry)) {
      if (numTotalHits <= mParameter) {
        writer.appendEntry(alignmentEntry);
        numAligns+=multiplicity;
        if (debug && LOG.isDebugEnabled()) {
          LOG.debug(String.format(""String_Node_Str"",queryIndex));
        }
      }
 else {
        tmhWriter.append(queryIndex,numTotalHits,samHelper.getQueryLength());
        if (debug && LOG.isDebugEnabled()) {
          LOG.debug(String.format(""String_Node_Str"",queryIndex));
        }
        while (queryIndex == nameToQueryIndices.getQueryIndex(samRecord.getReadName(),0))         ;
      }
    }
 else {
      if (debug && LOG.isDebugEnabled()) {
        LOG.debug(String.format(""String_Node_Str"",queryIndex));
      }
    }
    progress.lightUpdate();
  }
  samIterator.close();
  if (readIndexFilter != null) {
    writer.putStatistic(""String_Node_Str"",readIndexFilterFile.getName());
  }
  writer.putStatistic(""String_Node_Str"",numAligns);
  writer.setNumQueries(Math.max(numberOfReads,numberOfReadsFromCommandLine));
  writer.printStats(System.out);
  final SAMFileHeader samHeader=fileHeader;
  final SAMSequenceDictionary samSequenceDictionary=samHeader.getSequenceDictionary();
  final List<SAMSequenceRecord> samSequenceRecords=samSequenceDictionary.getSequences();
  int targetCount=targetIds.size();
  if (targetIds.size() != 0 && (targetIds.size() != samSequenceRecords.size())) {
    LOG.warn(""String_Node_Str"" + targetIds.size() + ""String_Node_Str""+ samSequenceRecords.size());
  }
  targetCount=Math.max(samSequenceRecords.size(),targetCount);
  final int[] targetLengths=new int[targetCount];
  for (  final SAMSequenceRecord samSequenceRecord : samSequenceRecords) {
    final int index=samSequenceRecord.getSequenceIndex();
    if (debug && LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + samSequenceRecord.getSequenceName() + ""String_Node_Str""+ index);
    }
    targetLengths[index]=samSequenceRecord.getSequenceLength();
  }
  writer.setTargetLengths(targetLengths);
  progress.stop();
  return numAligns;
}","@Override protected int scan(final ReadSet readIndexFilter,final IndexedIdentifier targetIds,final AlignmentWriter writer,final AlignmentTooManyHitsWriter tmhWriter) throws IOException {
  int numAligns=0;
  final ProgressLogger progress=new ProgressLogger(LOG);
  SAMFileReader.setDefaultValidationStringency(SAMFileReader.ValidationStringency.SILENT);
  final SAMFileReader parser=new SAMFileReader(new File(inputFile));
  progress.start();
  final SAMRecordIterator samIterator=parser.iterator();
  SamHelper samHelper=new SamHelper();
  samHelper.setQualityEncoding(qualityEncoding);
  numberOfReads=0;
  SAMRecord prevRecord=null;
  final SAMFileHeader fileHeader=parser.getFileHeader();
  if (sortedInput) {
    final int numTargets=fileHeader.getSequenceDictionary().size();
    final int[] targetLengths=new int[numTargets];
    for (int i=0; i < numTargets; i++) {
      final SAMSequenceRecord seq=fileHeader.getSequence(i);
      final int targetIndex=getTargetIndex(targetIds,seq.getSequenceName(),thirdPartyInput);
      targetLengths[targetIndex]=seq.getSequenceLength();
    }
    writer.setTargetLengths(targetLengths);
    writer.setSorted(true);
  }
  while (samIterator.hasNext()) {
    samHelper.reset();
    numberOfReads++;
    final SAMRecord samRecord=samIterator.next();
    if (samRecord.getReadUnmappedFlag()) {
      if (debug && LOG.isDebugEnabled()) {
        LOG.debug(String.format(""String_Node_Str"",samRecord.getReadName()));
      }
      continue;
    }
    if (sortedInput) {
      if (prevRecord != null) {
        final int compare=prevRecord.getAlignmentStart() - samRecord.getAlignmentStart();
        if (compare > 0) {
          final String message=String.format(""String_Node_Str"",samRecord.toString(),prevRecord.toString());
          System.err.println(""String_Node_Str"" + message);
          LOG.warn(message);
          System.exit(0);
        }
      }
    }
    prevRecord=samRecord;
    int readMaxOccurence=1;
    final boolean readIsPaired=samRecord.getReadPairedFlag();
    final boolean b=readIsPaired && !samRecord.getReadUnmappedFlag();
    if (b) {
      readMaxOccurence++;
    }
    final Object xoString=samRecord.getAttribute(""String_Node_Str"");
    final int numTotalHits=xoString == null ? 1 : (Integer)xoString;
    readMaxOccurence=Math.max(numTotalHits * (readIsPaired ? 2 : 1),readMaxOccurence);
    final String readName=samRecord.getReadName();
    final int queryIndex=nameToQueryIndices.getQueryIndex(readName,readMaxOccurence);
    final int targetIndex=getTargetIndex(targetIds,samRecord.getReferenceName(),thirdPartyInput);
    final int fragmentIndex;
    final int mateFragmentIndex;
    if (readIsPaired) {
      if (samRecord.getFirstOfPairFlag()) {
        fragmentIndex=0;
        mateFragmentIndex=1;
      }
 else {
        fragmentIndex=1;
        mateFragmentIndex=0;
      }
    }
 else {
      fragmentIndex=0;
      mateFragmentIndex=1;
    }
    if (bsmap) {
      final String specifiedReference=(String)samRecord.getAttribute(""String_Node_Str"");
      final String directions=(String)samRecord.getAttribute(""String_Node_Str"");
      final boolean reverseStrand=directions.equals(""String_Node_Str"") || directions.equals(""String_Node_Str"");
      samHelper.setSourceWithReference(queryIndex,samRecord.getReadString(),samRecord.getBaseQualityString(),specifiedReference,samRecord.getAlignmentStart(),reverseStrand);
    }
 else {
      samHelper.setSource(queryIndex,samRecord.getReadString(),samRecord.getBaseQualityString(),samRecord.getCigarString(),(String)samRecord.getAttribute(""String_Node_Str""),samRecord.getAlignmentStart(),samRecord.getReadNegativeStrandFlag());
    }
    int multiplicity=1;
    if (readIndexFilter != null) {
      multiplicity=readIndexFilter.getMultiplicity(queryIndex);
    }
    largestQueryIndex=Math.max(queryIndex,largestQueryIndex);
    smallestQueryIndex=Math.min(queryIndex,smallestQueryIndex);
    final Alignments.AlignmentEntry.Builder currentEntry=Alignments.AlignmentEntry.newBuilder();
    currentEntry.setMultiplicity(multiplicity);
    currentEntry.setQueryIndex(samHelper.getQueryIndex());
    currentEntry.setTargetIndex(targetIndex);
    currentEntry.setPosition(samHelper.getPosition());
    currentEntry.setQueryPosition(samHelper.getQueryPosition());
    currentEntry.setFragmentIndex(fragmentIndex);
    currentEntry.setQueryLength(samHelper.getQueryLength());
    currentEntry.setScore(samHelper.getScore());
    currentEntry.setNumberOfIndels(samHelper.getNumDeletions() + samHelper.getNumInsertions());
    currentEntry.setNumberOfMismatches(samHelper.getNumMisMatches());
    currentEntry.setMatchingReverseStrand(samHelper.isReverseStrand());
    currentEntry.setQueryAlignedLength(samHelper.getQueryAlignedLength());
    currentEntry.setTargetAlignedLength(samHelper.getTargetAlignedLength());
    currentEntry.setPairFlags(samRecord.getFlags());
    if (readIsPaired) {
      if (!samRecord.getMateUnmappedFlag()) {
        final Alignments.RelatedAlignmentEntry.Builder relatedBuilder=Alignments.RelatedAlignmentEntry.newBuilder();
        final int mateTargetIndex=getTargetIndex(targetIds,samRecord.getMateReferenceName(),thirdPartyInput);
        final int mateAlignmentStart=samRecord.getMateAlignmentStart() - 1;
        relatedBuilder.setFragmentIndex(mateFragmentIndex);
        relatedBuilder.setPosition(mateAlignmentStart);
        relatedBuilder.setTargetIndex(mateTargetIndex);
        currentEntry.setPairAlignmentLink(relatedBuilder);
      }
    }
    for (    final SamSequenceVariation var : samHelper.getSequenceVariations()) {
      appendNewSequenceVariation(currentEntry,var,samHelper.getQueryLength());
      if (debug && LOG.isDebugEnabled()) {
        LOG.debug(String.format(""String_Node_Str"",var.toString(),queryIndex));
      }
    }
    final Alignments.AlignmentEntry alignmentEntry=currentEntry.build();
    if (qualityFilter.keepEntry(samHelper.getQueryLength(),alignmentEntry)) {
      if (numTotalHits <= mParameter) {
        writer.appendEntry(alignmentEntry);
        numAligns+=multiplicity;
        if (debug && LOG.isDebugEnabled()) {
          LOG.debug(String.format(""String_Node_Str"",queryIndex));
        }
      }
 else {
        tmhWriter.append(queryIndex,numTotalHits,samHelper.getQueryLength());
        if (debug && LOG.isDebugEnabled()) {
          LOG.debug(String.format(""String_Node_Str"",queryIndex));
        }
        while (queryIndex == nameToQueryIndices.getQueryIndex(samRecord.getReadName(),0))         ;
      }
    }
 else {
      if (debug && LOG.isDebugEnabled()) {
        LOG.debug(String.format(""String_Node_Str"",queryIndex));
      }
    }
    progress.lightUpdate();
  }
  samIterator.close();
  if (readIndexFilter != null) {
    writer.putStatistic(""String_Node_Str"",readIndexFilterFile.getName());
  }
  writer.putStatistic(""String_Node_Str"",numAligns);
  writer.setNumQueries(Math.max(numberOfReads,numberOfReadsFromCommandLine));
  writer.printStats(System.out);
  final SAMFileHeader samHeader=fileHeader;
  final SAMSequenceDictionary samSequenceDictionary=samHeader.getSequenceDictionary();
  final List<SAMSequenceRecord> samSequenceRecords=samSequenceDictionary.getSequences();
  int targetCount=targetIds.size();
  if (targetIds.size() != 0 && (targetIds.size() != samSequenceRecords.size())) {
    LOG.warn(""String_Node_Str"" + targetIds.size() + ""String_Node_Str""+ samSequenceRecords.size());
  }
  targetCount=Math.max(samSequenceRecords.size(),targetCount);
  final int[] targetLengths=new int[targetCount];
  for (  final SAMSequenceRecord samSequenceRecord : samSequenceRecords) {
    final int index=samSequenceRecord.getSequenceIndex();
    if (debug && LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + samSequenceRecord.getSequenceName() + ""String_Node_Str""+ index);
    }
    targetLengths[index]=samSequenceRecord.getSequenceLength();
  }
  writer.setTargetLengths(targetLengths);
  progress.stop();
  return numAligns;
}"
50347,"public void setMinQualValue(final byte minQualValue){
  this.minQualValue=minQualValue;
}","public void setMinQualValue(final char minQualValue){
  this.minQualValue=(byte)minQualValue;
}"
50348,"private void applyCigar(){
  if (debug && LOG.isDebugEnabled()) {
    LOG.debug(String.format(""String_Node_Str"",cigar));
  }
  int posInReads=0;
  numInsertions=0;
  numDeletions=0;
  numMisMatches=0;
  Matcher matcher=CIGAR_REGEX.matcher(cigar);
  while (matcher.find()) {
    int length=Integer.parseInt(matcher.group(1));
    char op=matcher.group(2).charAt(0);
switch (op) {
case 'S':
      for (int i=0; i < length; i++) {
        ref.append('-');
        query.append('-');
        qual.append(minQualValue);
      }
    posInReads+=length;
  break;
case 'M':
query.append(sourceQuery.substring(posInReads,posInReads + length));
if (sourceQual.length() != 0) {
qual.append(sourceQual.substring(posInReads,posInReads + length));
}
ref.append(sourceQuery.substring(posInReads,posInReads + length));
posInReads+=length;
break;
case 'I':
query.append(sourceQuery.substring(posInReads,posInReads + length));
if (sourceQual.length() != 0) {
qual.append(sourceQual.substring(posInReads,posInReads + length));
}
for (int i=0; i < length; i++) {
ref.append('-');
}
numInsertions+=length;
posInReads+=length;
break;
case 'D':
for (int i=0; i < length; i++) {
query.append('-');
if (sourceQual.length() != 0) {
qual.append(minQualValue);
}
ref.append('?');
}
numDeletions+=length;
break;
}
}
for (int i=0; i < query.length(); i++) {
if (query.charAt(i) == '-' && ref.charAt(i) == '-') {
numLeftClipped++;
}
 else {
break;
}
}
for (int i=query.length() - 1; i >= 0; i--) {
if (query.charAt(i) == '-' && ref.charAt(i) == '-') {
numRightClipped++;
}
 else {
break;
}
}
}","private void applyCigar(){
  if (debug && LOG.isDebugEnabled()) {
    LOG.debug(String.format(""String_Node_Str"",cigar));
  }
  int posInReads=0;
  numInsertions=0;
  numDeletions=0;
  numMisMatches=0;
  Matcher matcher=CIGAR_REGEX.matcher(cigar);
  while (matcher.find()) {
    int length=Integer.parseInt(matcher.group(1));
    char op=matcher.group(2).charAt(0);
switch (op) {
case 'S':
      for (int i=0; i < length; i++) {
        ref.append('-');
        query.append('-');
        qual.append((char)minQualValue);
      }
    posInReads+=length;
  break;
case 'M':
query.append(sourceQuery.substring(posInReads,posInReads + length));
if (sourceQual.length() != 0) {
qual.append(sourceQual.substring(posInReads,posInReads + length));
}
ref.append(sourceQuery.substring(posInReads,posInReads + length));
posInReads+=length;
break;
case 'I':
query.append(sourceQuery.substring(posInReads,posInReads + length));
if (sourceQual.length() != 0) {
qual.append(sourceQual.substring(posInReads,posInReads + length));
}
for (int i=0; i < length; i++) {
ref.append('-');
}
numInsertions+=length;
posInReads+=length;
break;
case 'D':
for (int i=0; i < length; i++) {
query.append('-');
if (sourceQual.length() != 0) {
qual.append((char)minQualValue);
}
ref.append('?');
}
numDeletions+=length;
break;
}
}
for (int i=0; i < query.length(); i++) {
if (query.charAt(i) == '-' && ref.charAt(i) == '-') {
numLeftClipped++;
}
 else {
break;
}
}
for (int i=query.length() - 1; i >= 0; i--) {
if (query.charAt(i) == '-' && ref.charAt(i) == '-') {
numRightClipped++;
}
 else {
break;
}
}
}"
50349,"private Alignments.AlignmentEntry andBack(final int index,int originalIndex,final Alignments.AlignmentEntry reduced){
  final Alignments.AlignmentEntry.Builder result=Alignments.AlignmentEntry.newBuilder(reduced);
  final int multiplicity=multiplicities.get(index);
  final int k=multiplicity - 1;
  multiplicities.set(index,k);
  if (!multiplicityFieldsAllMissing) {
    result.setMultiplicity(1);
  }
  final int queryIndex=queryIndices.getInt(originalIndex);
  result.setQueryIndex(queryIndex);
  if (originalIndex == 0 || reduced.hasPosition() || reduced.hasTargetIndex()) {
    previousPosition=reduced.getPosition();
    previousTargetIndex=reduced.getTargetIndex();
  }
 else {
    final int deltaPos=deltaPositions.getInt(deltaPosIndex);
    final int deltaTarget=deltaTargetIndices.getInt(deltaPosIndex);
    final int position=previousPosition + deltaPos;
    final int targetIndex=previousTargetIndex + deltaTarget;
    result.setPosition(position);
    result.setTargetIndex(targetIndex);
    previousPosition+=deltaPos;
    previousTargetIndex+=deltaTarget;
    deltaPosIndex++;
  }
  int anInt=mappingQualities.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setMappingQuality(anInt);
  }
  anInt=fragmentIndices.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setFragmentIndex(anInt);
  }
  anInt=matchingReverseStrand.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setMatchingReverseStrand(anInt == 1);
  }
  anInt=numberOfMismatches.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setNumberOfMismatches(anInt);
  }
  anInt=numberOfIndels.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setNumberOfIndels(anInt);
  }
  anInt=queryLengths.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setQueryLength(anInt);
  }
  anInt=queryAlignedLengths.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setQueryAlignedLength(anInt);
  }
  anInt=queryPositions.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setQueryPosition(anInt);
  }
  anInt=targetAlignedLengths.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setTargetAlignedLength(anInt);
  }
  Alignments.RelatedAlignmentEntry link=pairLinks.decode(originalIndex,reduced.getPairAlignmentLink());
  if (link != null) {
    result.setPairAlignmentLink(link);
  }
  link=forwardSpliceLinks.decode(originalIndex,reduced.getSplicedForwardAlignmentLink());
  if (link != null) {
    result.setSplicedForwardAlignmentLink(link);
  }
  link=backwardSpliceLinks.decode(originalIndex,reduced.getSplicedBackwardAlignmentLink());
  if (link != null) {
    result.setSplicedBackwardAlignmentLink(link);
  }
  final boolean templateHasSequenceVariations=reduced.getSequenceVariationsCount() > 0;
  final int numVariations=variationCount.getInt(index);
  if (queryIndex == 72) {
    System.out.println(""String_Node_Str"");
  }
  for (int varIndex=0; varIndex < numVariations; varIndex++) {
    final Alignments.SequenceVariation template=templateHasSequenceVariations ? reduced.getSequenceVariations(varIndex) : null;
    final Alignments.SequenceVariation.Builder varBuilder=templateHasSequenceVariations ? Alignments.SequenceVariation.newBuilder(template) : Alignments.SequenceVariation.newBuilder();
    from.setLength(0);
    to.setLength(0);
    final int fromLength=fromLengths.getInt(varPositionIndex);
    final int toLength=toLengths.getInt(varPositionIndex);
    varBuilder.setPosition(varPositions.getInt(varPositionIndex));
    varBuilder.setReadIndex(varReadIndex.getInt(varPositionIndex));
    final boolean hasToQual=varHasToQuals.getInt(varPositionIndex) == 1;
    final byte[] quals=hasToQual ? new byte[toLength] : null;
    ++varPositionIndex;
    final int maxLength=Math.max(fromLength,toLength);
    for (int i=0; i < maxLength; i++) {
      final int fromTo=varFromTo.getInt(varFromToIndex++);
      if (i < fromLength) {
        from.append((char)(fromTo >> 8));
      }
      if (i < toLength) {
        to.append((char)(fromTo & 0xFF));
      }
      if (hasToQual) {
        quals[i]=(byte)varQuals.getInt(varQualIndex);
        ++varQualIndex;
      }
    }
    varBuilder.setFrom(from.toString());
    varBuilder.setTo(to.toString());
    if (hasToQual) {
      varBuilder.setToQuality(ByteString.copyFrom(quals));
    }
    if (templateHasSequenceVariations) {
      result.setSequenceVariations(varIndex,varBuilder);
    }
 else {
      result.addSequenceVariations(varBuilder);
    }
  }
  return result.build();
}","private Alignments.AlignmentEntry andBack(final int index,int originalIndex,final Alignments.AlignmentEntry reduced){
  final Alignments.AlignmentEntry.Builder result=Alignments.AlignmentEntry.newBuilder(reduced);
  final int multiplicity=multiplicities.get(index);
  final int k=multiplicity - 1;
  multiplicities.set(index,k);
  if (!multiplicityFieldsAllMissing) {
    result.setMultiplicity(1);
  }
  final int queryIndex=queryIndices.getInt(originalIndex);
  result.setQueryIndex(queryIndex);
  if (originalIndex == 0 || reduced.hasPosition() || reduced.hasTargetIndex()) {
    previousPosition=reduced.getPosition();
    previousTargetIndex=reduced.getTargetIndex();
  }
 else {
    final int deltaPos=deltaPositions.getInt(deltaPosIndex);
    final int deltaTarget=deltaTargetIndices.getInt(deltaPosIndex);
    final int position=previousPosition + deltaPos;
    final int targetIndex=previousTargetIndex + deltaTarget;
    result.setPosition(position);
    result.setTargetIndex(targetIndex);
    previousPosition+=deltaPos;
    previousTargetIndex+=deltaTarget;
    deltaPosIndex++;
  }
  int anInt=mappingQualities.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setMappingQuality(anInt);
  }
  anInt=fragmentIndices.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setFragmentIndex(anInt);
  }
  anInt=matchingReverseStrand.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setMatchingReverseStrand(anInt == 1);
  }
  anInt=numberOfMismatches.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setNumberOfMismatches(anInt);
  }
  anInt=numberOfIndels.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setNumberOfIndels(anInt);
  }
  anInt=queryLengths.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setQueryLength(anInt);
  }
  anInt=queryAlignedLengths.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setQueryAlignedLength(anInt);
  }
  anInt=queryPositions.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setQueryPosition(anInt);
  }
  anInt=targetAlignedLengths.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setTargetAlignedLength(anInt);
  }
  Alignments.RelatedAlignmentEntry link=pairLinks.decode(originalIndex,reduced.getPairAlignmentLink());
  if (link != null) {
    result.setPairAlignmentLink(link);
  }
  link=forwardSpliceLinks.decode(originalIndex,reduced.getSplicedForwardAlignmentLink());
  if (link != null) {
    result.setSplicedForwardAlignmentLink(link);
  }
  link=backwardSpliceLinks.decode(originalIndex,reduced.getSplicedBackwardAlignmentLink());
  if (link != null) {
    result.setSplicedBackwardAlignmentLink(link);
  }
  final boolean templateHasSequenceVariations=reduced.getSequenceVariationsCount() > 0;
  final int numVariations=variationCount.getInt(index);
  for (int varIndex=0; varIndex < numVariations; varIndex++) {
    final Alignments.SequenceVariation template=templateHasSequenceVariations ? reduced.getSequenceVariations(varIndex) : null;
    final Alignments.SequenceVariation.Builder varBuilder=templateHasSequenceVariations ? Alignments.SequenceVariation.newBuilder(template) : Alignments.SequenceVariation.newBuilder();
    from.setLength(0);
    to.setLength(0);
    final int fromLength=fromLengths.getInt(varPositionIndex);
    final int toLength=toLengths.getInt(varPositionIndex);
    varBuilder.setPosition(varPositions.getInt(varPositionIndex));
    varBuilder.setReadIndex(varReadIndex.getInt(varPositionIndex));
    final boolean hasToQual=varHasToQuals.getInt(varHasToQualsIndex) == 1;
    varHasToQualsIndex++;
    final byte[] quals=hasToQual ? new byte[toLength] : null;
    ++varPositionIndex;
    final int maxLength=Math.max(fromLength,toLength);
    for (int i=0; i < maxLength; i++) {
      final int fromTo=varFromTo.getInt(varFromToIndex++);
      if (i < fromLength) {
        from.append((char)(fromTo >> 8));
      }
      if (i < toLength) {
        to.append((char)(fromTo & 0xFF));
      }
      if (hasToQual) {
        quals[i]=(byte)varQuals.getInt(varQualIndex);
        ++varQualIndex;
      }
    }
    varBuilder.setFrom(from.toString());
    varBuilder.setTo(to.toString());
    if (hasToQual) {
      varBuilder.setToQuality(ByteString.copyFrom(quals));
    }
    if (templateHasSequenceVariations) {
      result.setSequenceVariations(varIndex,varBuilder);
    }
 else {
      result.addSequenceVariations(varBuilder);
    }
  }
  return result.build();
}"
50350,"private void recordVariationQualitiesAndClear(Alignments.AlignmentEntry.Builder result,List<Alignments.SequenceVariation> sequenceVariationsList){
  int index=0;
  for (  final Alignments.SequenceVariation seqVar : sequenceVariationsList) {
    final String from=seqVar.getFrom();
    final ByteString toQualities=seqVar.getToQuality();
    final int length=from.length();
    final boolean hasToQuals=seqVar.hasToQuality();
    varHasToQuals.add(hasToQuals ? 1 : 0);
    for (int i=0; i < length; i++) {
      if (hasToQuals && i < toQualities.size()) {
        varQuals.add(toQualities.byteAt(i));
      }
 else {
        varQuals.add(NO_VALUE);
      }
    }
    Alignments.SequenceVariation.Builder varBuilder=Alignments.SequenceVariation.newBuilder(seqVar);
    varBuilder.clearToQuality();
    result.setSequenceVariations(index,varBuilder.buildPartial());
    index++;
  }
}","private void recordVariationQualitiesAndClear(Alignments.AlignmentEntry.Builder result,List<Alignments.SequenceVariation> sequenceVariationsList){
  int index=0;
  for (  final Alignments.SequenceVariation seqVar : sequenceVariationsList) {
    final String from=seqVar.getFrom();
    final ByteString toQualities=seqVar.getToQuality();
    final int length=from.length();
    final boolean hasToQuals=seqVar.hasToQuality();
    varHasToQuals.add(hasToQuals ? 1 : 0);
    for (int i=0; i < length; i++) {
      if (hasToQuals && i < toQualities.size()) {
        varQuals.add(toQualities.byteAt(i));
      }
    }
    Alignments.SequenceVariation.Builder varBuilder=Alignments.SequenceVariation.newBuilder(seqVar);
    varBuilder.clearToQuality();
    result.setSequenceVariations(index,varBuilder.buildPartial());
    index++;
  }
}"
50351,"private void encodeVar(final Alignments.SequenceVariation seqVar){
  final String from=seqVar.getFrom();
  final String to=seqVar.getTo();
  final ByteString toQualities=seqVar.getToQuality();
  final int fromLength=from.length();
  final int toLength=to.length();
  final boolean hasToQuals=seqVar.hasToQuality();
  varPositions.add(seqVar.getPosition());
  varPositionIndex++;
  varReadIndex.add(seqVar.getReadIndex());
  fromLengths.add(fromLength);
  toLengths.add(toLength);
  final int maxLength=Math.max(fromLength,toLength);
  for (int i=0; i < maxLength; i++) {
    final char baseFrom=i < fromLength ? from.charAt(i) : '\0';
    final char baseTo=i < toLength ? to.charAt(i) : '\0';
    final byte byteFrom=(byte)baseFrom;
    final byte byteTo=(byte)baseTo;
    varFromTo.add(byteFrom << 8 | byteTo);
  }
}","private void encodeVar(final Alignments.SequenceVariation seqVar){
  final String from=seqVar.getFrom();
  final String to=seqVar.getTo();
  final ByteString toQualities=seqVar.getToQuality();
  final int fromLength=from.length();
  final int toLength=to.length();
  final boolean hasToQuals=seqVar.hasToQuality();
  varPositions.add(seqVar.getPosition());
  varReadIndex.add(seqVar.getReadIndex());
  fromLengths.add(fromLength);
  toLengths.add(toLength);
  final int maxLength=Math.max(fromLength,toLength);
  for (int i=0; i < maxLength; i++) {
    final char baseFrom=i < fromLength ? from.charAt(i) : '\0';
    final char baseTo=i < toLength ? to.charAt(i) : '\0';
    final byte byteFrom=(byte)baseFrom;
    final byte byteTo=(byte)baseTo;
    varFromTo.add(byteFrom << 8 | byteTo);
  }
}"
50352,"private void reset(){
  multiplicityFieldsAllMissing=true;
  previousPosition=-1;
  previousTargetIndex=-1;
  deltaPositions.clear();
  deltaTargetIndices.clear();
  queryLengths.clear();
  mappingQualities.clear();
  matchingReverseStrand.clear();
  multiplicity.clear();
  numberOfIndels.clear();
  queryAlignedLengths.clear();
  targetAlignedLengths.clear();
  numberOfMismatches.clear();
  queryIndices.clear();
  queryPositions.clear();
  fragmentIndices.clear();
  queryIndices.clear();
  variationCount.clear();
  varPositions.clear();
  fromLengths.clear();
  toLengths.clear();
  varReadIndex.clear();
  varFromTo.clear();
  varQuals.clear();
  varQualIndex=0;
  varPositionIndex=0;
  varFromToIndex=0;
  varHasToQuals.clear();
  multiplicities.clear();
  countAggregatedWithMultiplicity=0;
  previousPartial=null;
  deltaPosIndex=0;
  pairLinks.reset();
  forwardSpliceLinks.reset();
  backwardSpliceLinks.reset();
}","private void reset(){
  multiplicityFieldsAllMissing=true;
  previousPosition=-1;
  previousTargetIndex=-1;
  deltaPositions.clear();
  deltaTargetIndices.clear();
  queryLengths.clear();
  mappingQualities.clear();
  matchingReverseStrand.clear();
  multiplicity.clear();
  numberOfIndels.clear();
  queryAlignedLengths.clear();
  targetAlignedLengths.clear();
  numberOfMismatches.clear();
  queryIndices.clear();
  queryPositions.clear();
  fragmentIndices.clear();
  queryIndices.clear();
  variationCount.clear();
  varPositions.clear();
  fromLengths.clear();
  toLengths.clear();
  varReadIndex.clear();
  varFromTo.clear();
  varQuals.clear();
  varQualIndex=0;
  varPositionIndex=0;
  varFromToIndex=0;
  varHasToQuals.clear();
  varHasToQualsIndex=0;
  multiplicities.clear();
  countAggregatedWithMultiplicity=0;
  previousPartial=null;
  deltaPosIndex=0;
  pairLinks.reset();
  forwardSpliceLinks.reset();
  backwardSpliceLinks.reset();
}"
50353,"private Alignments.AlignmentCollection.Builder loadCollection(String filename,int firstElementToLoad,int maxElementsToLoad) throws IOException {
  final Alignments.AlignmentCollection.Builder collectionBuilder=Alignments.AlignmentCollection.newBuilder();
  AlignmentReaderImpl reader=new AlignmentReaderImpl(filename);
  QueryIndexPermutation permutator=new QueryIndexPermutationImpl();
  try {
    int counter=0;
    for (    Alignments.AlignmentEntry entry : reader) {
      if (counter >= firstElementToLoad) {
        collectionBuilder.addAlignmentEntries(permutator.makeSmallIndices(entry));
        if (counter++ > maxElementsToLoad) {
          break;
        }
      }
    }
    return collectionBuilder;
  }
  finally {
    reader.close();
  }
}","private Alignments.AlignmentCollection.Builder loadCollection(String filename,int firstElementToLoad,int maxElementsToLoad) throws IOException {
  final Alignments.AlignmentCollection.Builder collectionBuilder=Alignments.AlignmentCollection.newBuilder();
  AlignmentReaderImpl reader=new AlignmentReaderImpl(filename);
  QueryIndexPermutation permutator=new QueryIndexPermutationImpl();
  try {
    int counter=0;
    for (    Alignments.AlignmentEntry entry : reader) {
      if (counter >= firstElementToLoad) {
        collectionBuilder.addAlignmentEntries(permutator.makeSmallIndices(entry));
        if (counter > maxElementsToLoad) {
          break;
        }
      }
      counter++;
    }
    return collectionBuilder;
  }
  finally {
    reader.close();
  }
}"
50354,"public void roundTripPairedEnd() throws IOException {
  final AlignmentChunkCodec1 codec=new AlignmentChunkCodec1();
  codec.setHandler(new AlignmentCollectionHandler());
  Alignments.AlignmentCollection.Builder collection=loadCollection(""String_Node_Str"",0,1000);
  assertRoundTripMatchExpected(codec,collection);
}","public void roundTripPairedEnd() throws IOException {
  final AlignmentChunkCodec1 codec=new AlignmentChunkCodec1();
  codec.setHandler(new AlignmentCollectionHandler());
  Alignments.AlignmentCollection.Builder collection=loadCollection(""String_Node_Str"",600,700);
  assertRoundTripMatchExpected(codec,collection);
}"
50355,"@Override public Message decompressCollection(Message reducedCollection,byte[] compressedBytes) throws IOException {
  reset();
  byte[] moreRoom=new byte[compressedBytes.length + 100];
  System.arraycopy(compressedBytes,0,moreRoom,0,compressedBytes.length);
  final Alignments.AlignmentCollection alignmentCollection=(Alignments.AlignmentCollection)reducedCollection;
  final Alignments.AlignmentCollection.Builder result=Alignments.AlignmentCollection.newBuilder();
  final InputBitStream bitInput=new InputBitStream(new FastByteArrayInputStream(moreRoom));
  final int numEntriesInChunk=alignmentCollection.getAlignmentEntriesCount();
  decompressBits(bitInput,numEntriesInChunk);
  int originalIndex=0;
  for (int templateIndex=0; templateIndex < numEntriesInChunk; templateIndex++) {
    final int templatePositionIndex=varPositionIndex;
    final int templateVarFromToIndex=varFromToIndex;
    while (multiplicities.get(templateIndex) >= 1) {
      result.addAlignmentEntries(andBack(templateIndex,originalIndex,alignmentCollection.getAlignmentEntries(templateIndex)));
      if (multiplicities.get(templateIndex) >= 1) {
        varPositionIndex=templatePositionIndex;
        varFromToIndex=templateVarFromToIndex;
      }
      originalIndex++;
    }
  }
  ++chunkIndex;
  return result.build();
}","@Override public Message decompressCollection(Message reducedCollection,byte[] compressedBytes) throws IOException {
  reset();
  byte[] moreRoom=new byte[compressedBytes.length + 100];
  System.arraycopy(compressedBytes,0,moreRoom,0,compressedBytes.length);
  final Alignments.AlignmentCollection alignmentCollection=(Alignments.AlignmentCollection)reducedCollection;
  final Alignments.AlignmentCollection.Builder result=Alignments.AlignmentCollection.newBuilder();
  final InputBitStream bitInput=new InputBitStream(new FastByteArrayInputStream(moreRoom));
  final int numEntriesInChunk=alignmentCollection.getAlignmentEntriesCount();
  decompressBits(bitInput,numEntriesInChunk);
  int originalIndex=0;
  for (int templateIndex=0; templateIndex < numEntriesInChunk; templateIndex++) {
    final int templatePositionIndex=varPositionIndex;
    final int templateVarFromToIndex=varFromToIndex;
    final int templateVarHasToQualsIndex=varToQualsLength;
    while (multiplicities.get(templateIndex) >= 1) {
      result.addAlignmentEntries(andBack(templateIndex,originalIndex,alignmentCollection.getAlignmentEntries(templateIndex)));
      if (multiplicities.get(templateIndex) >= 1) {
        varPositionIndex=templatePositionIndex;
        varFromToIndex=templateVarFromToIndex;
        varToQualsLength=templateVarHasToQualsIndex;
      }
      originalIndex++;
    }
  }
  ++chunkIndex;
  return result.build();
}"
50356,"private void writeCompressed(final OutputBitStream out) throws IOException {
  out.writeBit(multiplicityFieldsAllMissing);
  writeArithmetic(""String_Node_Str"",deltaPositions,out);
  writeArithmetic(""String_Node_Str"",deltaTargetIndices,out);
  writeArithmetic(""String_Node_Str"",queryLengths,out);
  writeArithmetic(""String_Node_Str"",mappingQualities,out);
  writeArithmetic(""String_Node_Str"",matchingReverseStrand,out);
  writeArithmetic(""String_Node_Str"",numberOfIndels,out);
  writeArithmetic(""String_Node_Str"",numberOfMismatches,out);
  writeArithmetic(""String_Node_Str"",queryAlignedLengths,out);
  writeArithmetic(""String_Node_Str"",targetAlignedLengths,out);
  writeArithmetic(""String_Node_Str"",queryPositions,out);
  writeArithmetic(""String_Node_Str"",fragmentIndices,out);
  writeArithmetic(""String_Node_Str"",variationCount,out);
  writeArithmetic(""String_Node_Str"",varPositions,out);
  writeArithmetic(""String_Node_Str"",fromLengths,out);
  writeArithmetic(""String_Node_Str"",toLengths,out);
  writeArithmetic(""String_Node_Str"",varReadIndex,out);
  writeArithmetic(""String_Node_Str"",varFromTo,out);
  writeArithmetic(""String_Node_Str"",varQuals,out);
  writeArithmetic(""String_Node_Str"",varHasToQuals,out);
  writeArithmetic(""String_Node_Str"",multiplicities,out);
  pairLinks.write(out);
  forwardSpliceLinks.write(out);
  backwardSpliceLinks.write(out);
  writeQueryIndices(""String_Node_Str"",queryIndices,out);
}","private void writeCompressed(final OutputBitStream out) throws IOException {
  out.writeBit(multiplicityFieldsAllMissing);
  writeArithmetic(""String_Node_Str"",deltaPositions,out);
  writeArithmetic(""String_Node_Str"",deltaTargetIndices,out);
  writeArithmetic(""String_Node_Str"",queryLengths,out);
  writeArithmetic(""String_Node_Str"",mappingQualities,out);
  writeArithmetic(""String_Node_Str"",matchingReverseStrand,out);
  writeArithmetic(""String_Node_Str"",numberOfIndels,out);
  writeArithmetic(""String_Node_Str"",numberOfMismatches,out);
  writeArithmetic(""String_Node_Str"",queryAlignedLengths,out);
  writeArithmetic(""String_Node_Str"",targetAlignedLengths,out);
  writeArithmetic(""String_Node_Str"",queryPositions,out);
  writeArithmetic(""String_Node_Str"",fragmentIndices,out);
  writeArithmetic(""String_Node_Str"",variationCount,out);
  writeArithmetic(""String_Node_Str"",varPositions,out);
  writeArithmetic(""String_Node_Str"",fromLengths,out);
  writeArithmetic(""String_Node_Str"",toLengths,out);
  writeArithmetic(""String_Node_Str"",varReadIndex,out);
  writeArithmetic(""String_Node_Str"",varFromTo,out);
  writeArithmetic(""String_Node_Str"",varQuals,out);
  writeArithmetic(""String_Node_Str"",varToQualLength,out);
  writeArithmetic(""String_Node_Str"",multiplicities,out);
  pairLinks.write(out);
  forwardSpliceLinks.write(out);
  backwardSpliceLinks.write(out);
  writeQueryIndices(""String_Node_Str"",queryIndices,out);
}"
50357,"private Alignments.AlignmentEntry andBack(final int index,int originalIndex,final Alignments.AlignmentEntry reduced){
  final Alignments.AlignmentEntry.Builder result=Alignments.AlignmentEntry.newBuilder(reduced);
  final int multiplicity=multiplicities.get(index);
  final int k=multiplicity - 1;
  multiplicities.set(index,k);
  if (!multiplicityFieldsAllMissing) {
    result.setMultiplicity(1);
  }
  final int queryIndex=queryIndices.getInt(originalIndex);
  result.setQueryIndex(queryIndex);
  if (originalIndex == 0 || reduced.hasPosition() || reduced.hasTargetIndex()) {
    previousPosition=reduced.getPosition();
    previousTargetIndex=reduced.getTargetIndex();
  }
 else {
    final int deltaPos=deltaPositions.getInt(deltaPosIndex);
    final int deltaTarget=deltaTargetIndices.getInt(deltaPosIndex);
    final int position=previousPosition + deltaPos;
    final int targetIndex=previousTargetIndex + deltaTarget;
    result.setPosition(position);
    result.setTargetIndex(targetIndex);
    previousPosition+=deltaPos;
    previousTargetIndex+=deltaTarget;
    deltaPosIndex++;
  }
  int anInt=mappingQualities.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setMappingQuality(anInt);
  }
  anInt=fragmentIndices.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setFragmentIndex(anInt);
  }
  anInt=matchingReverseStrand.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setMatchingReverseStrand(anInt == 1);
  }
  anInt=numberOfMismatches.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setNumberOfMismatches(anInt);
  }
  anInt=numberOfIndels.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setNumberOfIndels(anInt);
  }
  anInt=queryLengths.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setQueryLength(anInt);
  }
  anInt=queryAlignedLengths.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setQueryAlignedLength(anInt);
  }
  anInt=queryPositions.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setQueryPosition(anInt);
  }
  anInt=targetAlignedLengths.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setTargetAlignedLength(anInt);
  }
  Alignments.RelatedAlignmentEntry link=pairLinks.decode(originalIndex,reduced.getPairAlignmentLink());
  if (link != null) {
    result.setPairAlignmentLink(link);
  }
  link=forwardSpliceLinks.decode(originalIndex,reduced.getSplicedForwardAlignmentLink());
  if (link != null) {
    result.setSplicedForwardAlignmentLink(link);
  }
  link=backwardSpliceLinks.decode(originalIndex,reduced.getSplicedBackwardAlignmentLink());
  if (link != null) {
    result.setSplicedBackwardAlignmentLink(link);
  }
  final boolean templateHasSequenceVariations=reduced.getSequenceVariationsCount() > 0;
  final int numVariations=variationCount.getInt(index);
  for (int varIndex=0; varIndex < numVariations; varIndex++) {
    final Alignments.SequenceVariation template=templateHasSequenceVariations ? reduced.getSequenceVariations(varIndex) : null;
    final Alignments.SequenceVariation.Builder varBuilder=templateHasSequenceVariations ? Alignments.SequenceVariation.newBuilder(template) : Alignments.SequenceVariation.newBuilder();
    from.setLength(0);
    to.setLength(0);
    final int fromLength=fromLengths.getInt(varPositionIndex);
    final int toLength=toLengths.getInt(varPositionIndex);
    varBuilder.setPosition(varPositions.getInt(varPositionIndex));
    varBuilder.setReadIndex(varReadIndex.getInt(varPositionIndex));
    final boolean hasToQual=varHasToQuals.getInt(varHasToQualsIndex) == 1;
    varHasToQualsIndex++;
    final byte[] quals=hasToQual ? new byte[toLength] : null;
    ++varPositionIndex;
    final int maxLength=Math.max(fromLength,toLength);
    for (int i=0; i < maxLength; i++) {
      final int fromTo=varFromTo.getInt(varFromToIndex++);
      if (i < fromLength) {
        from.append((char)(fromTo >> 8));
      }
      if (i < toLength) {
        to.append((char)(fromTo & 0xFF));
      }
      if (hasToQual) {
        quals[i]=(byte)varQuals.getInt(varQualIndex);
        ++varQualIndex;
      }
    }
    varBuilder.setFrom(from.toString());
    varBuilder.setTo(to.toString());
    if (hasToQual) {
      varBuilder.setToQuality(ByteString.copyFrom(quals));
    }
    if (templateHasSequenceVariations) {
      result.setSequenceVariations(varIndex,varBuilder);
    }
 else {
      result.addSequenceVariations(varBuilder);
    }
  }
  return result.build();
}","private Alignments.AlignmentEntry andBack(final int index,int originalIndex,final Alignments.AlignmentEntry reduced){
  final Alignments.AlignmentEntry.Builder result=Alignments.AlignmentEntry.newBuilder(reduced);
  final int multiplicity=multiplicities.get(index);
  final int k=multiplicity - 1;
  multiplicities.set(index,k);
  if (!multiplicityFieldsAllMissing) {
    result.setMultiplicity(1);
  }
  final int queryIndex=queryIndices.getInt(originalIndex);
  result.setQueryIndex(queryIndex);
  if (originalIndex == 0 || reduced.hasPosition() || reduced.hasTargetIndex()) {
    previousPosition=reduced.getPosition();
    previousTargetIndex=reduced.getTargetIndex();
  }
 else {
    final int deltaPos=deltaPositions.getInt(deltaPosIndex);
    final int deltaTarget=deltaTargetIndices.getInt(deltaPosIndex);
    final int position=previousPosition + deltaPos;
    final int targetIndex=previousTargetIndex + deltaTarget;
    result.setPosition(position);
    result.setTargetIndex(targetIndex);
    previousPosition+=deltaPos;
    previousTargetIndex+=deltaTarget;
    deltaPosIndex++;
  }
  int anInt=mappingQualities.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setMappingQuality(anInt);
  }
  anInt=fragmentIndices.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setFragmentIndex(anInt);
  }
  anInt=matchingReverseStrand.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setMatchingReverseStrand(anInt == 1);
  }
  anInt=numberOfMismatches.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setNumberOfMismatches(anInt);
  }
  anInt=numberOfIndels.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setNumberOfIndels(anInt);
  }
  anInt=queryLengths.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setQueryLength(anInt);
  }
  anInt=queryAlignedLengths.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setQueryAlignedLength(anInt);
  }
  anInt=queryPositions.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setQueryPosition(anInt);
  }
  anInt=targetAlignedLengths.getInt(index);
  if (anInt != MISSING_VALUE) {
    result.setTargetAlignedLength(anInt);
  }
  Alignments.RelatedAlignmentEntry link=pairLinks.decode(originalIndex,reduced.getPairAlignmentLink());
  if (link != null) {
    result.setPairAlignmentLink(link);
  }
  link=forwardSpliceLinks.decode(originalIndex,reduced.getSplicedForwardAlignmentLink());
  if (link != null) {
    result.setSplicedForwardAlignmentLink(link);
  }
  link=backwardSpliceLinks.decode(originalIndex,reduced.getSplicedBackwardAlignmentLink());
  if (link != null) {
    result.setSplicedBackwardAlignmentLink(link);
  }
  final boolean templateHasSequenceVariations=reduced.getSequenceVariationsCount() > 0;
  final int numVariations=variationCount.getInt(index);
  for (int varIndex=0; varIndex < numVariations; varIndex++) {
    final Alignments.SequenceVariation template=templateHasSequenceVariations ? reduced.getSequenceVariations(varIndex) : null;
    final Alignments.SequenceVariation.Builder varBuilder=templateHasSequenceVariations ? Alignments.SequenceVariation.newBuilder(template) : Alignments.SequenceVariation.newBuilder();
    from.setLength(0);
    to.setLength(0);
    final int fromLength=fromLengths.getInt(varPositionIndex);
    final int toLength=toLengths.getInt(varPositionIndex);
    varBuilder.setPosition(varPositions.getInt(varPositionIndex));
    varBuilder.setReadIndex(varReadIndex.getInt(varPositionIndex));
    final int toQualLength=varToQualLength.getInt(varToQualsLength);
    varToQualsLength++;
    final byte[] quals=new byte[toQualLength];
    ++varPositionIndex;
    final int maxLength=Math.max(fromLength,toLength);
    for (int i=0; i < maxLength; i++) {
      final int fromTo=varFromTo.getInt(varFromToIndex++);
      if (i < fromLength) {
        from.append((char)(fromTo >> 8));
      }
      if (i < toLength) {
        to.append((char)(fromTo & 0xFF));
      }
      if (i < toQualLength) {
        if (varQualIndex < varQuals.size()) {
          quals[i]=(byte)varQuals.getInt(varQualIndex);
          ++varQualIndex;
        }
 else {
          System.out.println(""String_Node_Str"");
        }
      }
    }
    varBuilder.setFrom(from.toString());
    varBuilder.setTo(to.toString());
    if (toQualLength > 0) {
      varBuilder.setToQuality(ByteString.copyFrom(quals));
    }
    if (templateHasSequenceVariations) {
      result.setSequenceVariations(varIndex,varBuilder);
    }
 else {
      result.addSequenceVariations(varBuilder);
    }
  }
  return result.build();
}"
50358,"private void recordVariationQualitiesAndClear(Alignments.AlignmentEntry.Builder result,List<Alignments.SequenceVariation> sequenceVariationsList){
  int index=0;
  for (  final Alignments.SequenceVariation seqVar : sequenceVariationsList) {
    final String from=seqVar.getFrom();
    final ByteString toQualities=seqVar.getToQuality();
    final int length=from.length();
    final boolean hasToQuals=seqVar.hasToQuality();
    varHasToQuals.add(hasToQuals ? 1 : 0);
    for (int i=0; i < length; i++) {
      if (hasToQuals && i < toQualities.size()) {
        varQuals.add(toQualities.byteAt(i));
      }
    }
    Alignments.SequenceVariation.Builder varBuilder=Alignments.SequenceVariation.newBuilder(seqVar);
    varBuilder.clearToQuality();
    result.setSequenceVariations(index,varBuilder.buildPartial());
    index++;
  }
}","private void recordVariationQualitiesAndClear(Alignments.AlignmentEntry.Builder result,List<Alignments.SequenceVariation> sequenceVariationsList){
  int index=0;
  for (  final Alignments.SequenceVariation seqVar : sequenceVariationsList) {
    final String from=seqVar.getFrom();
    final ByteString toQualities=seqVar.getToQuality();
    final boolean hasToQuals=seqVar.hasToQuality();
    final int toQualSize=toQualities.size();
    varToQualLength.add(toQualSize);
    final int toQualsLength=hasToQuals ? seqVar.getToQuality().size() : 0;
    for (int i=0; i < toQualsLength; i++) {
      if (hasToQuals && i < toQualSize) {
        varQuals.add(toQualities.byteAt(i));
      }
    }
    Alignments.SequenceVariation.Builder varBuilder=Alignments.SequenceVariation.newBuilder(seqVar);
    varBuilder.clearToQuality();
    result.setSequenceVariations(index,varBuilder.buildPartial());
    index++;
  }
}"
50359,"private void reset(){
  multiplicityFieldsAllMissing=true;
  previousPosition=-1;
  previousTargetIndex=-1;
  deltaPositions.clear();
  deltaTargetIndices.clear();
  queryLengths.clear();
  mappingQualities.clear();
  matchingReverseStrand.clear();
  multiplicity.clear();
  numberOfIndels.clear();
  queryAlignedLengths.clear();
  targetAlignedLengths.clear();
  numberOfMismatches.clear();
  queryIndices.clear();
  queryPositions.clear();
  fragmentIndices.clear();
  queryIndices.clear();
  variationCount.clear();
  varPositions.clear();
  fromLengths.clear();
  toLengths.clear();
  varReadIndex.clear();
  varFromTo.clear();
  varQuals.clear();
  varQualIndex=0;
  varPositionIndex=0;
  varFromToIndex=0;
  varHasToQuals.clear();
  varHasToQualsIndex=0;
  multiplicities.clear();
  countAggregatedWithMultiplicity=0;
  previousPartial=null;
  deltaPosIndex=0;
  pairLinks.reset();
  forwardSpliceLinks.reset();
  backwardSpliceLinks.reset();
}","private void reset(){
  multiplicityFieldsAllMissing=true;
  previousPosition=-1;
  previousTargetIndex=-1;
  deltaPositions.clear();
  deltaTargetIndices.clear();
  queryLengths.clear();
  mappingQualities.clear();
  matchingReverseStrand.clear();
  multiplicity.clear();
  numberOfIndels.clear();
  queryAlignedLengths.clear();
  targetAlignedLengths.clear();
  numberOfMismatches.clear();
  queryIndices.clear();
  queryPositions.clear();
  fragmentIndices.clear();
  queryIndices.clear();
  variationCount.clear();
  varPositions.clear();
  fromLengths.clear();
  toLengths.clear();
  varReadIndex.clear();
  varFromTo.clear();
  varQuals.clear();
  varQualIndex=0;
  varPositionIndex=0;
  varFromToIndex=0;
  varToQualLength.clear();
  varToQualsLength=0;
  multiplicities.clear();
  countAggregatedWithMultiplicity=0;
  previousPartial=null;
  deltaPosIndex=0;
  pairLinks.reset();
  forwardSpliceLinks.reset();
  backwardSpliceLinks.reset();
}"
50360,"private void decompressBits(InputBitStream bitInput,final int numEntriesInChunk) throws IOException {
  multiplicityFieldsAllMissing=bitInput.readBit() == 1;
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,deltaPositions);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,deltaTargetIndices);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,queryLengths);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,mappingQualities);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,matchingReverseStrand);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,numberOfIndels);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,numberOfMismatches);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,queryAlignedLengths);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,targetAlignedLengths);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,queryPositions);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,fragmentIndices);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,variationCount);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,varPositions);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,fromLengths);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,toLengths);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,varReadIndex);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,varFromTo);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,varQuals);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,varHasToQuals);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,multiplicities);
  pairLinks.read(numEntriesInChunk,bitInput);
  forwardSpliceLinks.read(numEntriesInChunk,bitInput);
  backwardSpliceLinks.read(numEntriesInChunk,bitInput);
  decodeQueryIndices(""String_Node_Str"",numEntriesInChunk,bitInput,queryIndices);
}","private void decompressBits(InputBitStream bitInput,final int numEntriesInChunk) throws IOException {
  multiplicityFieldsAllMissing=bitInput.readBit() == 1;
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,deltaPositions);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,deltaTargetIndices);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,queryLengths);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,mappingQualities);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,matchingReverseStrand);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,numberOfIndels);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,numberOfMismatches);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,queryAlignedLengths);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,targetAlignedLengths);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,queryPositions);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,fragmentIndices);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,variationCount);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,varPositions);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,fromLengths);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,toLengths);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,varReadIndex);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,varFromTo);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,varQuals);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,varToQualLength);
  decodeArithmetic(""String_Node_Str"",numEntriesInChunk,bitInput,multiplicities);
  pairLinks.read(numEntriesInChunk,bitInput);
  forwardSpliceLinks.read(numEntriesInChunk,bitInput);
  backwardSpliceLinks.read(numEntriesInChunk,bitInput);
  decodeQueryIndices(""String_Node_Str"",numEntriesInChunk,bitInput,queryIndices);
}"
50361,"/** 
 * Combine tab delimited files and adjusts P-values for multiple testing.
 * @throws java.io.IOException error reading / writing
 */
@Override public void execute() throws IOException {
  Writer stream=null;
  try {
    stream=outputFilename == null ? new OutputStreamWriter(System.out) : outputFilename.endsWith(""String_Node_Str"") ? new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(outputFilename))) : new FileWriter(outputFilename);
    DifferentialExpressionResults data=new DifferentialExpressionResults(10000000);
    ObjectList<String> columnIdList=vcf ? getVCFColumns(inputFiles) : getTSVColumns(inputFiles);
    ObjectSet<String> selection=new ObjectOpenHashSet<String>();
    for (    String col : columnIdList) {
      selection.addAll(ObjectArrayList.wrap(selectedPValueColumns));
      for (      String filter : columnSelectionFilter) {
        if (col.contains(filter)) {
          selection.add(col);
          System.out.printf(""String_Node_Str"",col);
        }
      }
      System.out.println(""String_Node_Str"" + col);
    }
    selectedPValueColumns=selection.toArray(new String[selection.size()]);
    DifferentialExpressionCalculator deCalculator=new DifferentialExpressionCalculator();
    if (vcf) {
      loadVCF(inputFiles,data,deCalculator,columnIdList);
    }
 else {
      loadTSV(inputFiles,data,deCalculator,columnIdList);
    }
    BenjaminiHochbergAdjustment fdr=new BenjaminiHochbergAdjustment();
    fdr.setNumberAboveThreshold(numIgnoredObservations);
    for (    String column : selectedPValueColumns) {
      System.out.println(""String_Node_Str"" + column);
      fdr.adjust(data,column.toLowerCase());
    }
    recordTopHits(data);
    for (int i=0; i < data.getNumberOfStatistics(); i++) {
      MutableString statisticId=data.getStatisticIdForIndex(i);
      final String statId=statisticId.toString();
      if (!contains(selectedPValueColumns,statId)) {
        adjustedColumnIds.add(statId);
      }
    }
    Collections.sort(data,new ElementIndexComparator());
    if (vcf) {
      combineVCF(inputFiles,data,deCalculator,columnIdList,stream);
    }
 else {
      combineTSV(inputFiles,data,deCalculator,columnIdList,stream);
    }
  }
  finally {
    if (outputFilename != null) {
      IOUtils.closeQuietly(stream);
    }
  }
}","/** 
 * Combine tab delimited files and adjusts P-values for multiple testing.
 * @throws java.io.IOException error reading / writing
 */
@Override public void execute() throws IOException {
  Writer stream=null;
  try {
    stream=outputFilename == null ? new OutputStreamWriter(System.out) : outputFilename.endsWith(""String_Node_Str"") ? new OutputStreamWriter(new GZIPOutputStream(new FileOutputStream(outputFilename))) : new FileWriter(outputFilename);
    DifferentialExpressionResults data=new DifferentialExpressionResults(10000000);
    ObjectList<String> columnIdList=vcf ? getVCFColumns(inputFiles) : getTSVColumns(inputFiles);
    ObjectSet<String> selection=new ObjectOpenHashSet<String>();
    selection.addAll(ObjectArrayList.wrap(selectedPValueColumns));
    for (    String col : columnIdList) {
      selection.addAll(ObjectArrayList.wrap(selectedPValueColumns));
      for (      String filter : columnSelectionFilter) {
        if (col.contains(filter)) {
          selection.add(col);
          System.out.printf(""String_Node_Str"",col);
        }
      }
      System.out.println(""String_Node_Str"" + col);
    }
    selectedPValueColumns=selection.toArray(new String[selection.size()]);
    DifferentialExpressionCalculator deCalculator=new DifferentialExpressionCalculator();
    if (vcf) {
      loadVCF(inputFiles,data,deCalculator,columnIdList);
    }
 else {
      loadTSV(inputFiles,data,deCalculator,columnIdList);
    }
    BenjaminiHochbergAdjustment fdr=new BenjaminiHochbergAdjustment();
    fdr.setNumberAboveThreshold(numIgnoredObservations);
    for (    String column : selectedPValueColumns) {
      System.out.println(""String_Node_Str"" + column);
      fdr.adjust(data,column.toLowerCase());
    }
    recordTopHits(data);
    for (int i=0; i < data.getNumberOfStatistics(); i++) {
      MutableString statisticId=data.getStatisticIdForIndex(i);
      final String statId=statisticId.toString();
      if (!contains(selectedPValueColumns,statId)) {
        adjustedColumnIds.add(statId);
      }
    }
    Collections.sort(data,new ElementIndexComparator());
    if (vcf) {
      combineVCF(inputFiles,data,deCalculator,columnIdList,stream);
    }
 else {
      combineTSV(inputFiles,data,deCalculator,columnIdList,stream);
    }
  }
  finally {
    if (outputFilename != null) {
      IOUtils.closeQuietly(stream);
    }
  }
}"
50362,"private int writeFisherColumn(int i,int j,GroupComparison comparison,String context) throws IOException {
  StringBuilder comparisonName=new StringBuilder();
  comparisonName.append(""String_Node_Str"");
  comparisonName.append(comparison.nameGroup1);
  comparisonName.append(""String_Node_Str"");
  comparisonName.append(comparison.nameGroup2);
  comparisonName.append(""String_Node_Str"");
  if (!aggregateAllContexts) {
    comparisonName.append(""String_Node_Str"");
    comparisonName.append(context);
    comparisonName.append(""String_Node_Str"");
  }
  outputWriter.append(comparisonName.toString());
  if (i == groupComparisons.size() & j == contexts.length) {
    outputWriter.append('\n');
  }
 else {
    outputWriter.append('\t');
  }
  j++;
  return j;
}","private int writeFisherColumn(int i,int j,GroupComparison comparison,String context) throws IOException {
  StringBuilder comparisonName=new StringBuilder();
  comparisonName.append(""String_Node_Str"");
  comparisonName.append(comparison.nameGroup1);
  comparisonName.append(""String_Node_Str"");
  comparisonName.append(comparison.nameGroup2);
  comparisonName.append(""String_Node_Str"");
  if (!aggregateAllContexts) {
    comparisonName.append(""String_Node_Str"");
    comparisonName.append(context);
    comparisonName.append(""String_Node_Str"");
  }
  outputWriter.append(comparisonName.toString());
  if (i == groupComparisons.size() & j == contexts.length * groupComparisons.size()) {
    outputWriter.append('\n');
  }
 else {
    outputWriter.append('\t');
  }
  j++;
  return j;
}"
50363,"@Override public void writeRecord(final DiscoverVariantIterateSortedAlignments iterator,final SampleCountInfo[] sampleCounts,final int referenceIndex,int position,final DiscoverVariantPositionData list,final int groupIndexA,final int groupIndexB){
  position=position + 1;
  final char refBase=sampleCounts[0].referenceBase;
  if (refBase != 'C' && refBase != 'G') {
    return;
  }
  fillMethylationCountArrays(sampleCounts,list,position,refBase,mci,readerIndexToGroupIndex);
  if (eventCountAtSite < minimumEventThreshold) {
    return;
  }
  statWriter.setInfo(depthFieldIndex,list.size());
  final CharSequence currentReferenceId=iterator.getReferenceId(referenceIndex);
  statWriter.setChromosome(currentReferenceId);
  statWriter.setPosition(position);
  statWriter.setReferenceAllele(Character.toString(sampleCounts[0].referenceBase));
  final String biomartRegionSpan=String.format(""String_Node_Str"",currentReferenceId,position,position);
  statWriter.setInfo(biomartFieldIndex,biomartRegionSpan);
  statWriter.setInfo(strandFieldIndex,Character.toString(strandAtSite));
  final String genomicContext=findGenomicContext(referenceIndex,position);
  statWriter.setInfo(genomicContextIndex,genomicContext);
  for (int groupIndex=0; groupIndex < numberOfGroups; groupIndex++) {
    statWriter.setInfo(notMethylatedCCountsIndex[groupIndex],mci.unmethylatedCCountsPerGroup[groupIndex]);
    statWriter.setInfo(methylatedCCountsIndex[groupIndex],mci.methylatedCCountPerGroup[groupIndex]);
  }
  for (int sampleIndex=0; sampleIndex < numberOfSamples; sampleIndex++) {
    final float numerator=mci.methylatedCCountsPerSample[sampleIndex];
    final float denominator=numerator + mci.unmethylatedCCountPerSample[sampleIndex];
    final float methylationRate=numerator * 100 / denominator;
    statWriter.setSampleValue(methylationRateFieldIndex,sampleIndex,Math.round(methylationRate));
    statWriter.setSampleValue(unconvertedCytosineFieldIndex,sampleIndex,mci.methylatedCCountsPerSample[sampleIndex]);
    statWriter.setSampleValue(convertedCytosineFieldIndex,sampleIndex,mci.unmethylatedCCountPerSample[sampleIndex]);
  }
  for (  final GroupComparison comparison : groupComparisons) {
    final int indexGroup1=comparison.indexGroup1;
    final int indexGroup2=comparison.indexGroup2;
    final double denominator=(double)(mci.unmethylatedCCountsPerGroup[indexGroup1]) * (double)(mci.methylatedCCountPerGroup[indexGroup2]);
    final double oddsRatio=denominator == 0 ? Double.NaN : ((double)(mci.unmethylatedCCountsPerGroup[indexGroup2]) * (double)(mci.methylatedCCountPerGroup[indexGroup1])) / denominator;
    final double logOddsRatioSE;
    if (mci.methylatedCCountPerGroup[indexGroup1] < 10 || mci.methylatedCCountPerGroup[indexGroup2] < 10 || mci.unmethylatedCCountsPerGroup[indexGroup1] < 10 || mci.unmethylatedCCountsPerGroup[indexGroup2] < 10) {
      logOddsRatioSE=Double.NaN;
    }
 else {
      logOddsRatioSE=Math.sqrt(1d / mci.unmethylatedCCountsPerGroup[indexGroup2] + 1d / mci.methylatedCCountPerGroup[indexGroup1] + 1d / mci.methylatedCCountPerGroup[indexGroup2] + 1d / mci.unmethylatedCCountsPerGroup[indexGroup1]);
    }
    final double log2OddsRatio=Math.log(oddsRatio) / Math.log(2);
    final double log2OddsRatioZValue=log2OddsRatio / logOddsRatioSE;
    double fisherP=Double.NaN;
    if (eventCountAtSite >= minimumEventThreshold) {
      final boolean ok=checkCounts();
      if (ok) {
        fisherP=fisherRInstalled ? FisherExactRCalculator.getFisherPValue(mci.unmethylatedCCountsPerGroup[indexGroup2],mci.methylatedCCountPerGroup[indexGroup2],mci.unmethylatedCCountsPerGroup[indexGroup1],mci.methylatedCCountPerGroup[indexGroup1]) : Double.NaN;
      }
 else {
        System.err.printf(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",currentReferenceId,referenceIndex,position,mci.unmethylatedCCountsPerGroup[indexGroup2],mci.methylatedCCountPerGroup[indexGroup2],mci.unmethylatedCCountsPerGroup[indexGroup1],mci.methylatedCCountPerGroup[indexGroup1]);
      }
    }
    final double totalCsObservedgroup1=mci.methylatedCCountPerGroup[indexGroup1] + mci.unmethylatedCCountsPerGroup[indexGroup1];
    final double totalCsObservedgroup2=mci.methylatedCCountPerGroup[indexGroup2] + mci.unmethylatedCCountsPerGroup[indexGroup2];
    double group1MR;
    if (totalCsObservedgroup1 == 0) {
      group1MR=Double.NaN;
    }
 else {
      group1MR=mci.methylatedCCountPerGroup[indexGroup1] * 100 / totalCsObservedgroup1;
    }
    double group2MR;
    if (totalCsObservedgroup2 == 0) {
      group2MR=Double.NaN;
    }
 else {
      group2MR=mci.methylatedCCountPerGroup[indexGroup2] * 100 / totalCsObservedgroup2;
    }
    final int deltaMR=(int)Math.round(Math.abs(group1MR - group2MR));
    statWriter.setInfo(log2OddsRatioColumnIndex[comparison.index],log2OddsRatio);
    statWriter.setInfo(log2OddsRatioStandardErrorColumnIndex[comparison.index],logOddsRatioSE);
    statWriter.setInfo(log2OddsRatioZColumnIndex[comparison.index],log2OddsRatioZValue);
    statWriter.setInfo(fisherExactPValueColumnIndex[comparison.index],fisherP);
    statWriter.setInfo(deltaMRColumnIndex[comparison.index],deltaMR);
  }
  genotypeFormatter.writeGenotypes(statWriter,sampleCounts,position);
  for (int sampleIndex=0; sampleIndex < numberOfSamples; sampleIndex++) {
    final int firstIndex=sampleIndex;
    final int secondIndex=convertIndex(sampleIndex,strandAtSite);
    if (strandAtSite == '+') {
      final int otherIndex=convertIndex(sampleIndex,'-');
      statWriter.setSampleValue(methylationRateFieldIndex,otherIndex,""String_Node_Str"");
      statWriter.setSampleValue(convertedCytosineFieldIndex,otherIndex,""String_Node_Str"");
      statWriter.setSampleValue(unconvertedCytosineFieldIndex,otherIndex,""String_Node_Str"");
      statWriter.setSampleValue(genotypeFormatter.getGenotypeFieldIndex(),otherIndex,""String_Node_Str"");
      statWriter.setSampleValue(genotypeFormatter.getBaseCountFieldIndex(),otherIndex,""String_Node_Str"");
      statWriter.setSampleValue(genotypeFormatter.getFailBaseCountFieldIndex(),otherIndex,""String_Node_Str"");
      statWriter.setSampleValue(genotypeFormatter.getGoodBaseCountFieldIndex(),otherIndex,""String_Node_Str"");
    }
 else {
      statWriter.switchSampleValue(methylationRateFieldIndex,firstIndex,secondIndex,""String_Node_Str"");
      statWriter.switchSampleValue(convertedCytosineFieldIndex,firstIndex,secondIndex,""String_Node_Str"");
      statWriter.switchSampleValue(unconvertedCytosineFieldIndex,firstIndex,secondIndex,""String_Node_Str"");
      statWriter.switchSampleValue(genotypeFormatter.getGenotypeFieldIndex(),firstIndex,secondIndex,""String_Node_Str"");
      statWriter.switchSampleValue(genotypeFormatter.getBaseCountFieldIndex(),firstIndex,secondIndex,""String_Node_Str"");
      statWriter.switchSampleValue(genotypeFormatter.getFailBaseCountFieldIndex(),firstIndex,secondIndex,""String_Node_Str"");
      statWriter.switchSampleValue(genotypeFormatter.getGoodBaseCountFieldIndex(),firstIndex,secondIndex,""String_Node_Str"");
    }
  }
  statWriter.writeRecord();
}","@Override public void writeRecord(final DiscoverVariantIterateSortedAlignments iterator,final SampleCountInfo[] sampleCounts,final int referenceIndex,int position,final DiscoverVariantPositionData list,final int groupIndexA,final int groupIndexB){
  position=position + 1;
  final char refBase=sampleCounts[0].referenceBase;
  if (refBase != 'C' && refBase != 'G') {
    return;
  }
  fillMethylationCountArrays(sampleCounts,list,position,refBase,mci,readerIndexToGroupIndex);
  if (mci.eventCountAtSite < minimumEventThreshold) {
    return;
  }
  statWriter.setInfo(depthFieldIndex,list.size());
  final CharSequence currentReferenceId=iterator.getReferenceId(referenceIndex);
  statWriter.setChromosome(currentReferenceId);
  statWriter.setPosition(position);
  statWriter.setReferenceAllele(Character.toString(sampleCounts[0].referenceBase));
  final String biomartRegionSpan=String.format(""String_Node_Str"",currentReferenceId,position,position);
  statWriter.setInfo(biomartFieldIndex,biomartRegionSpan);
  statWriter.setInfo(strandFieldIndex,Character.toString(mci.strandAtSite));
  final String genomicContext=findGenomicContext(referenceIndex,position);
  statWriter.setInfo(genomicContextIndex,genomicContext);
  for (int groupIndex=0; groupIndex < numberOfGroups; groupIndex++) {
    statWriter.setInfo(notMethylatedCCountsIndex[groupIndex],mci.unmethylatedCCountsPerGroup[groupIndex]);
    statWriter.setInfo(methylatedCCountsIndex[groupIndex],mci.methylatedCCountPerGroup[groupIndex]);
  }
  for (int sampleIndex=0; sampleIndex < numberOfSamples; sampleIndex++) {
    final float numerator=mci.methylatedCCountsPerSample[sampleIndex];
    final float denominator=numerator + mci.unmethylatedCCountPerSample[sampleIndex];
    final float methylationRate=numerator * 100 / denominator;
    statWriter.setSampleValue(methylationRateFieldIndex,sampleIndex,Math.round(methylationRate));
    statWriter.setSampleValue(unconvertedCytosineFieldIndex,sampleIndex,mci.methylatedCCountsPerSample[sampleIndex]);
    statWriter.setSampleValue(convertedCytosineFieldIndex,sampleIndex,mci.unmethylatedCCountPerSample[sampleIndex]);
  }
  for (  final GroupComparison comparison : groupComparisons) {
    final int indexGroup1=comparison.indexGroup1;
    final int indexGroup2=comparison.indexGroup2;
    final double denominator=(double)(mci.unmethylatedCCountsPerGroup[indexGroup1]) * (double)(mci.methylatedCCountPerGroup[indexGroup2]);
    final double oddsRatio=denominator == 0 ? Double.NaN : ((double)(mci.unmethylatedCCountsPerGroup[indexGroup2]) * (double)(mci.methylatedCCountPerGroup[indexGroup1])) / denominator;
    final double logOddsRatioSE;
    if (mci.methylatedCCountPerGroup[indexGroup1] < 10 || mci.methylatedCCountPerGroup[indexGroup2] < 10 || mci.unmethylatedCCountsPerGroup[indexGroup1] < 10 || mci.unmethylatedCCountsPerGroup[indexGroup2] < 10) {
      logOddsRatioSE=Double.NaN;
    }
 else {
      logOddsRatioSE=Math.sqrt(1d / mci.unmethylatedCCountsPerGroup[indexGroup2] + 1d / mci.methylatedCCountPerGroup[indexGroup1] + 1d / mci.methylatedCCountPerGroup[indexGroup2] + 1d / mci.unmethylatedCCountsPerGroup[indexGroup1]);
    }
    final double log2OddsRatio=Math.log(oddsRatio) / Math.log(2);
    final double log2OddsRatioZValue=log2OddsRatio / logOddsRatioSE;
    double fisherP=Double.NaN;
    if (mci.eventCountAtSite >= minimumEventThreshold) {
      final boolean ok=checkCounts();
      if (ok) {
        fisherP=fisherRInstalled ? FisherExactRCalculator.getFisherPValue(mci.unmethylatedCCountsPerGroup[indexGroup2],mci.methylatedCCountPerGroup[indexGroup2],mci.unmethylatedCCountsPerGroup[indexGroup1],mci.methylatedCCountPerGroup[indexGroup1]) : Double.NaN;
      }
 else {
        System.err.printf(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",currentReferenceId,referenceIndex,position,mci.unmethylatedCCountsPerGroup[indexGroup2],mci.methylatedCCountPerGroup[indexGroup2],mci.unmethylatedCCountsPerGroup[indexGroup1],mci.methylatedCCountPerGroup[indexGroup1]);
      }
    }
    final double totalCsObservedgroup1=mci.methylatedCCountPerGroup[indexGroup1] + mci.unmethylatedCCountsPerGroup[indexGroup1];
    final double totalCsObservedgroup2=mci.methylatedCCountPerGroup[indexGroup2] + mci.unmethylatedCCountsPerGroup[indexGroup2];
    double group1MR;
    if (totalCsObservedgroup1 == 0) {
      group1MR=Double.NaN;
    }
 else {
      group1MR=mci.methylatedCCountPerGroup[indexGroup1] * 100 / totalCsObservedgroup1;
    }
    double group2MR;
    if (totalCsObservedgroup2 == 0) {
      group2MR=Double.NaN;
    }
 else {
      group2MR=mci.methylatedCCountPerGroup[indexGroup2] * 100 / totalCsObservedgroup2;
    }
    final int deltaMR=(int)Math.round(Math.abs(group1MR - group2MR));
    statWriter.setInfo(log2OddsRatioColumnIndex[comparison.index],log2OddsRatio);
    statWriter.setInfo(log2OddsRatioStandardErrorColumnIndex[comparison.index],logOddsRatioSE);
    statWriter.setInfo(log2OddsRatioZColumnIndex[comparison.index],log2OddsRatioZValue);
    statWriter.setInfo(fisherExactPValueColumnIndex[comparison.index],fisherP);
    statWriter.setInfo(deltaMRColumnIndex[comparison.index],deltaMR);
  }
  genotypeFormatter.writeGenotypes(statWriter,sampleCounts,position);
  for (int sampleIndex=0; sampleIndex < numberOfSamples; sampleIndex++) {
    final int firstIndex=sampleIndex;
    final int secondIndex=convertIndex(sampleIndex,mci.strandAtSite);
    if (mci.strandAtSite == '+') {
      final int otherIndex=convertIndex(sampleIndex,'-');
      statWriter.setSampleValue(methylationRateFieldIndex,otherIndex,""String_Node_Str"");
      statWriter.setSampleValue(convertedCytosineFieldIndex,otherIndex,""String_Node_Str"");
      statWriter.setSampleValue(unconvertedCytosineFieldIndex,otherIndex,""String_Node_Str"");
      statWriter.setSampleValue(genotypeFormatter.getGenotypeFieldIndex(),otherIndex,""String_Node_Str"");
      statWriter.setSampleValue(genotypeFormatter.getBaseCountFieldIndex(),otherIndex,""String_Node_Str"");
      statWriter.setSampleValue(genotypeFormatter.getFailBaseCountFieldIndex(),otherIndex,""String_Node_Str"");
      statWriter.setSampleValue(genotypeFormatter.getGoodBaseCountFieldIndex(),otherIndex,""String_Node_Str"");
    }
 else {
      statWriter.switchSampleValue(methylationRateFieldIndex,firstIndex,secondIndex,""String_Node_Str"");
      statWriter.switchSampleValue(convertedCytosineFieldIndex,firstIndex,secondIndex,""String_Node_Str"");
      statWriter.switchSampleValue(unconvertedCytosineFieldIndex,firstIndex,secondIndex,""String_Node_Str"");
      statWriter.switchSampleValue(genotypeFormatter.getGenotypeFieldIndex(),firstIndex,secondIndex,""String_Node_Str"");
      statWriter.switchSampleValue(genotypeFormatter.getBaseCountFieldIndex(),firstIndex,secondIndex,""String_Node_Str"");
      statWriter.switchSampleValue(genotypeFormatter.getFailBaseCountFieldIndex(),firstIndex,secondIndex,""String_Node_Str"");
      statWriter.switchSampleValue(genotypeFormatter.getGoodBaseCountFieldIndex(),firstIndex,secondIndex,""String_Node_Str"");
    }
  }
  statWriter.writeRecord();
}"
50364,"/** 
 * Load and sort annotations by their start position.
 * @param annotReader
 * @throws java.io.IOException
 */
public void loadAnnotations(final Reader annotReader) throws IOException {
  final ObjectArrayList<Annotation> result=new ObjectArrayList<Annotation>();
  final Object2ObjectMap<String,ObjectList<Annotation>> map=CompactAlignmentToAnnotationCountsMode.readAnnotations(annotReader);
  for (int referenceIndex=0; referenceIndex < genome.size(); referenceIndex++) {
    final ObjectList<Annotation> list=map.get(genome.getReferenceName(referenceIndex));
    Collections.sort(list,compareAnnotationStart);
    result.addAll(list);
  }
  annotations=new Annotation[result.size()];
  result.toArray(annotations);
}","/** 
 * Load and sort annotations by their start position.
 * @param annotReader
 * @throws java.io.IOException
 */
public void loadAnnotations(final Reader annotReader) throws IOException {
  final ObjectArrayList<Annotation> result=new ObjectArrayList<Annotation>();
  final Object2ObjectMap<String,ObjectList<Annotation>> map=CompactAlignmentToAnnotationCountsMode.readAnnotations(annotReader);
  for (int referenceIndex=0; referenceIndex < genome.size(); referenceIndex++) {
    final ObjectList<Annotation> list=map.get(genome.getReferenceName(referenceIndex));
    if (list != null) {
      Collections.sort(list,compareAnnotationStart);
      result.addAll(list);
    }
  }
  annotations=new Annotation[result.size()];
  result.toArray(annotations);
}"
50365,"/** 
 * This method sets the annotationIndex to the index of the first occurrence of annotations on this chromosome
 * @param refIndex
 */
public void advanceToChromosome(int refIndex){
  while (hasMoreAnnotations()) {
    final Annotation ann=nextAnnotation();
    if (chromosome1StrictlyBefore2(genome.getReferenceIndex(ann.getChromosome()),refIndex)) {
      advanceToNextAnnotation();
    }
 else {
      if (chromosome1StrictlyBefore2(refIndex,genome.getReferenceIndex(ann.getChromosome()))) {
        annotationIndex-=1;
        break;
      }
 else {
        break;
      }
    }
  }
}","/** 
 * This method sets the annotationIndex to the index of the first occurrence of annotations on this chromosome
 * @param refIndex
 */
public void advanceToChromosome(int refIndex){
  while (hasMoreAnnotations()) {
    final Annotation ann=nextAnnotation();
    if (chromosome1StrictlyBefore2(genome.getReferenceIndex(ann.getChromosome()),refIndex)) {
      advanceToNextAnnotation();
    }
 else {
      if (chromosome1StrictlyBefore2(refIndex,genome.getReferenceIndex(ann.getChromosome()))) {
        annotationIndex-=1;
        annotationIndex=Math.max(0,annotationIndex);
        break;
      }
 else {
        break;
      }
    }
  }
}"
50366,"/** 
 * Configure.
 * @param args command line arguments
 * @return this object for chaining
 * @throws java.io.IOException error parsing
 * @throws com.martiansoftware.jsap.JSAPException error parsing
 */
@Override public AbstractCommandLineMode configure(final String[] args) throws IOException, JSAPException {
  final JSAPResult jsapResult=parseJsapArguments(args);
  registeredDOClients.add(QualityScoreFilter.doc);
  registeredDOClients.add(VCFAveragingWriter.doc);
  dymamicOptions=jsapResult.getStringArray(""String_Node_Str"");
  for (  final String dymamicOption : dymamicOptions) {
    boolean parsed=false;
    for (    final DynamicOptionClient doc : registeredDOClients) {
      if (doc.acceptsOption(dymamicOption)) {
        parsed=true;
        break;
      }
    }
    if (!parsed) {
      System.err.println(""String_Node_Str"" + dymamicOption);
      System.exit(1);
    }
  }
  inputFilenames=jsapResult.getStringArray(""String_Node_Str"");
  outputFile=jsapResult.getString(""String_Node_Str"");
  outWriter=""String_Node_Str"".equals(outputFile) ? new PrintWriter(System.out) : new PrintWriter(outputFile);
  String groupsDefinition=jsapResult.getString(""String_Node_Str"");
  String groupsDefinitionFile=jsapResult.getString(""String_Node_Str"");
  if (groupsDefinition != null && groupsDefinitionFile != null) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  if (groupsDefinitionFile != null) {
    groupsDefinition=parseGroupFile(groupsDefinitionFile,inputFilenames);
  }
  String compare=jsapResult.getString(""String_Node_Str"");
  deAnalyzer.parseGroupsDefinition(groupsDefinition,deCalculator,inputFilenames);
  groupComparisonsList=deAnalyzer.parseCompare(compare);
  boolean parallel=jsapResult.getBoolean(""String_Node_Str"",false);
  deAnalyzer.setRunInParallel(parallel);
  Map<String,String> sampleToGroupMap=deCalculator.getSampleToGroupMap();
  readerIndexToGroupIndex=new int[inputFilenames.length];
  groups=deAnalyzer.getGroups();
  numberOfGroups=groups.length;
  IndexedIdentifier groupIds=new IndexedIdentifier();
  for (  String group : groups) {
    groupIds.registerIdentifier(new MutableString(group));
  }
  maxThresholdPerSite=jsapResult.getInt(""String_Node_Str"");
  minimumVariationSupport=jsapResult.getInt(""String_Node_Str"");
  thresholdDistinctReadIndices=jsapResult.getInt(""String_Node_Str"");
  CompactAlignmentToAnnotationCountsMode.parseEval(jsapResult,deAnalyzer);
  for (  String sample : sampleToGroupMap.keySet()) {
    final String group=sampleToGroupMap.get(sample);
    System.out.printf(""String_Node_Str"",sample,group);
    for (int readerIndex=0; readerIndex < inputFilenames.length; readerIndex++) {
      if (AlignmentReaderImpl.getBasename(inputFilenames[readerIndex]).endsWith(sample)) {
        readerIndexToGroupIndex[readerIndex]=groupIds.get(new MutableString(group));
      }
    }
  }
  File statFile=jsapResult.getFile(""String_Node_Str"");
  if (statFile != null) {
    loadStatFile(statFile);
  }
 else {
    if (deAnalyzer.eval(""String_Node_Str"")) {
      System.err.println(""String_Node_Str"");
      System.exit(1);
    }
  }
  callIndels=jsapResult.getBoolean(""String_Node_Str"");
  realignmentFactory=configureProcessor(jsapResult);
  final String formatString=jsapResult.getString(""String_Node_Str"");
  final OutputFormat format=OutputFormat.valueOf(formatString.toUpperCase());
  SequenceVariationOutputFormat formatter=null;
switch (format) {
case VARIANT_DISCOVERY:
case BETWEEN_GROUPS:
    stopWhenDefaultGroupOptions();
  formatter=new BetweenGroupSequenceVariationOutputFormat();
break;
case COMPARE_GROUPS:
stopWhenDefaultGroupOptions();
formatter=new CompareGroupsVCFOutputFormat();
break;
case ALLELE_FREQUENCIES:
stopWhenDefaultGroupOptions();
formatter=new AlleleFrequencyOutputFormat();
break;
case GENOTYPES:
formatter=new GenotypesOutputFormat();
break;
case METHYLATION_REGIONS:
formatter=new MethylationRegionsOutputFormat();
methylFormat((MethylationRateVCFOutputFormat)formatter);
break;
case METHYLATION:
formatter=new MethylationRateVCFOutputFormat();
methylFormat((MethylationRateVCFOutputFormat)formatter);
break;
case INDEL_COUNTS:
formatter=new IndelCountOutputFormat();
callIndels=true;
break;
default :
ObjectArrayList<OutputFormat> values=ObjectArrayList.wrap(OutputFormat.values());
System.err.printf(""String_Node_Str"",values.toString());
System.exit(1);
}
genotypeFilters=new ObjectArrayList<GenotypeFilter>();
switch (format) {
case METHYLATION:
case METHYLATION_REGIONS:
if (callIndels) {
genotypeFilters.add(new RemoveIndelArtifactsFilter());
}
break;
case COMPARE_GROUPS:
case ALLELE_FREQUENCIES:
case BETWEEN_GROUPS:
case VARIANT_DISCOVERY:
genotypeFilters.add(new QualityScoreFilter());
genotypeFilters.add(new LeftOverFilter());
if (callIndels) {
genotypeFilters.add(new RemoveIndelArtifactsFilter());
}
if (!disableAtLeastQuarterFilter && callIndels) {
System.out.println(""String_Node_Str"");
genotypeFilters.add(new AtLeastAQuarterFilter());
}
break;
case GENOTYPES:
genotypeFilters.add(new QualityScoreFilter());
genotypeFilters.add(new LeftOverFilter());
if (callIndels) {
genotypeFilters.add(new RemoveIndelArtifactsFilter());
}
if (!disableAtLeastQuarterFilter) {
genotypeFilters.add(new AtLeastAQuarterFilter());
}
break;
case INDEL_COUNTS:
genotypeFilters.add(new QualityScoreFilter());
genotypeFilters.add(new LeftOverFilter());
genotypeFilters.add(new RemoveIndelArtifactsFilter());
if (!disableAtLeastQuarterFilter) {
genotypeFilters.add(new AtLeastAQuarterFilter());
}
break;
default :
throw new InternalError(""String_Node_Str"");
}
System.out.println(""String_Node_Str"");
for (final GenotypeFilter filter : genotypeFilters) {
System.out.println(filter.describe());
}
final RandomAccessSequenceInterface genome=configureGenome(testGenome,jsapResult);
final int startFlapSize=jsapResult.getInt(""String_Node_Str"",100);
if (callIndels) {
System.err.println(""String_Node_Str"");
}
formatConfigurator.configureFormatter(formatter);
sortedPositionIterator=new DiscoverVariantIterateSortedAlignments(formatter);
sortedPositionIterator.setCallIndels(callIndels);
sortedPositionIterator.setGenome(genome);
sortedPositionIterator.setStartFlapLength(startFlapSize);
sortedPositionIterator.parseIncludeReferenceArgument(jsapResult);
sortedPositionIterator.setMinimumVariationSupport(minimumVariationSupport);
sortedPositionIterator.setThresholdDistinctReadIndices(thresholdDistinctReadIndices);
return this;
}","/** 
 * Configure.
 * @param args command line arguments
 * @return this object for chaining
 * @throws java.io.IOException error parsing
 * @throws com.martiansoftware.jsap.JSAPException error parsing
 */
@Override public AbstractCommandLineMode configure(final String[] args) throws IOException, JSAPException {
  final JSAPResult jsapResult=parseJsapArguments(args);
  registeredDOClients.add(QualityScoreFilter.doc);
  registeredDOClients.add(VCFAveragingWriter.doc);
  registeredDOClients.add(MethylationRegionsOutputFormat.doc);
  dymamicOptions=jsapResult.getStringArray(""String_Node_Str"");
  for (  final String dymamicOption : dymamicOptions) {
    boolean parsed=false;
    for (    final DynamicOptionClient doc : registeredDOClients) {
      if (doc.acceptsOption(dymamicOption)) {
        parsed=true;
        break;
      }
    }
    if (!parsed) {
      System.err.println(""String_Node_Str"" + dymamicOption);
      System.exit(1);
    }
  }
  inputFilenames=jsapResult.getStringArray(""String_Node_Str"");
  outputFile=jsapResult.getString(""String_Node_Str"");
  outWriter=""String_Node_Str"".equals(outputFile) ? new PrintWriter(System.out) : new PrintWriter(outputFile);
  String groupsDefinition=jsapResult.getString(""String_Node_Str"");
  String groupsDefinitionFile=jsapResult.getString(""String_Node_Str"");
  if (groupsDefinition != null && groupsDefinitionFile != null) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  if (groupsDefinitionFile != null) {
    groupsDefinition=parseGroupFile(groupsDefinitionFile,inputFilenames);
  }
  String compare=jsapResult.getString(""String_Node_Str"");
  deAnalyzer.parseGroupsDefinition(groupsDefinition,deCalculator,inputFilenames);
  groupComparisonsList=deAnalyzer.parseCompare(compare);
  boolean parallel=jsapResult.getBoolean(""String_Node_Str"",false);
  deAnalyzer.setRunInParallel(parallel);
  Map<String,String> sampleToGroupMap=deCalculator.getSampleToGroupMap();
  readerIndexToGroupIndex=new int[inputFilenames.length];
  groups=deAnalyzer.getGroups();
  numberOfGroups=groups.length;
  IndexedIdentifier groupIds=new IndexedIdentifier();
  for (  String group : groups) {
    groupIds.registerIdentifier(new MutableString(group));
  }
  maxThresholdPerSite=jsapResult.getInt(""String_Node_Str"");
  minimumVariationSupport=jsapResult.getInt(""String_Node_Str"");
  thresholdDistinctReadIndices=jsapResult.getInt(""String_Node_Str"");
  CompactAlignmentToAnnotationCountsMode.parseEval(jsapResult,deAnalyzer);
  for (  String sample : sampleToGroupMap.keySet()) {
    final String group=sampleToGroupMap.get(sample);
    System.out.printf(""String_Node_Str"",sample,group);
    for (int readerIndex=0; readerIndex < inputFilenames.length; readerIndex++) {
      if (AlignmentReaderImpl.getBasename(inputFilenames[readerIndex]).endsWith(sample)) {
        readerIndexToGroupIndex[readerIndex]=groupIds.get(new MutableString(group));
      }
    }
  }
  File statFile=jsapResult.getFile(""String_Node_Str"");
  if (statFile != null) {
    loadStatFile(statFile);
  }
 else {
    if (deAnalyzer.eval(""String_Node_Str"")) {
      System.err.println(""String_Node_Str"");
      System.exit(1);
    }
  }
  callIndels=jsapResult.getBoolean(""String_Node_Str"");
  realignmentFactory=configureProcessor(jsapResult);
  final String formatString=jsapResult.getString(""String_Node_Str"");
  final OutputFormat format=OutputFormat.valueOf(formatString.toUpperCase());
  SequenceVariationOutputFormat formatter=null;
switch (format) {
case VARIANT_DISCOVERY:
case BETWEEN_GROUPS:
    stopWhenDefaultGroupOptions();
  formatter=new BetweenGroupSequenceVariationOutputFormat();
break;
case COMPARE_GROUPS:
stopWhenDefaultGroupOptions();
formatter=new CompareGroupsVCFOutputFormat();
break;
case ALLELE_FREQUENCIES:
stopWhenDefaultGroupOptions();
formatter=new AlleleFrequencyOutputFormat();
break;
case GENOTYPES:
formatter=new GenotypesOutputFormat();
break;
case METHYLATION_REGIONS:
formatter=new MethylationRegionsOutputFormat();
methylFormat((MethylationFormat)formatter);
break;
case METHYLATION:
formatter=new MethylationRateVCFOutputFormat();
methylFormat((MethylationFormat)formatter);
break;
case INDEL_COUNTS:
formatter=new IndelCountOutputFormat();
callIndels=true;
break;
default :
ObjectArrayList<OutputFormat> values=ObjectArrayList.wrap(OutputFormat.values());
System.err.printf(""String_Node_Str"",values.toString());
System.exit(1);
}
genotypeFilters=new ObjectArrayList<GenotypeFilter>();
switch (format) {
case METHYLATION:
case METHYLATION_REGIONS:
if (callIndels) {
genotypeFilters.add(new RemoveIndelArtifactsFilter());
}
break;
case COMPARE_GROUPS:
case ALLELE_FREQUENCIES:
case BETWEEN_GROUPS:
case VARIANT_DISCOVERY:
genotypeFilters.add(new QualityScoreFilter());
genotypeFilters.add(new LeftOverFilter());
if (callIndels) {
genotypeFilters.add(new RemoveIndelArtifactsFilter());
}
if (!disableAtLeastQuarterFilter && callIndels) {
System.out.println(""String_Node_Str"");
genotypeFilters.add(new AtLeastAQuarterFilter());
}
break;
case GENOTYPES:
genotypeFilters.add(new QualityScoreFilter());
genotypeFilters.add(new LeftOverFilter());
if (callIndels) {
genotypeFilters.add(new RemoveIndelArtifactsFilter());
}
if (!disableAtLeastQuarterFilter) {
genotypeFilters.add(new AtLeastAQuarterFilter());
}
break;
case INDEL_COUNTS:
genotypeFilters.add(new QualityScoreFilter());
genotypeFilters.add(new LeftOverFilter());
genotypeFilters.add(new RemoveIndelArtifactsFilter());
if (!disableAtLeastQuarterFilter) {
genotypeFilters.add(new AtLeastAQuarterFilter());
}
break;
default :
throw new InternalError(""String_Node_Str"");
}
System.out.println(""String_Node_Str"");
for (final GenotypeFilter filter : genotypeFilters) {
System.out.println(filter.describe());
}
final RandomAccessSequenceInterface genome=configureGenome(testGenome,jsapResult);
final int startFlapSize=jsapResult.getInt(""String_Node_Str"",100);
if (callIndels) {
System.err.println(""String_Node_Str"");
}
formatConfigurator.configureFormatter(formatter);
sortedPositionIterator=new DiscoverVariantIterateSortedAlignments(formatter);
sortedPositionIterator.setCallIndels(callIndels);
sortedPositionIterator.setGenome(genome);
sortedPositionIterator.setStartFlapLength(startFlapSize);
sortedPositionIterator.parseIncludeReferenceArgument(jsapResult);
sortedPositionIterator.setMinimumVariationSupport(minimumVariationSupport);
sortedPositionIterator.setThresholdDistinctReadIndices(thresholdDistinctReadIndices);
return this;
}"
50367,"private void methylFormat(MethylationRateVCFOutputFormat formatter){
  int tmp=minimumVariationSupport;
  this.minimumVariationSupport=-1;
  this.thresholdDistinctReadIndices=1;
  ((MethylationRateVCFOutputFormat)formatter).setMinimumEventThreshold(tmp);
  System.out.println(""String_Node_Str"");
}","private void methylFormat(MethylationFormat formatter){
  int tmp=minimumVariationSupport;
  this.minimumVariationSupport=-1;
  this.thresholdDistinctReadIndices=1;
  formatter.setMinimumEventThreshold(tmp);
  System.out.println(""String_Node_Str"");
}"
50368,"private void parseCurrentLine(){
  Arrays.fill(columnStarts,0);
  Arrays.fill(columnEnds,0);
  Arrays.fill(fieldStarts,0);
  Arrays.fill(fieldEnds,0);
  columnStarts[0]=0;
  int columnIndex=0;
  int fieldIndex=0;
  lineLength=line.length();
  final int[] lineFieldIndexToColumnIndex=new int[numberOfFields];
  Arrays.fill(lineFieldIndexToColumnIndex,-1);
  previousColumnFieldIndices.clear();
  final char[] chrs=line.toCharArray();
  for (int i=0; i < lineLength; i++) {
    final char c=chrs[i];
    if (c == columnSeparatorCharacter) {
      fieldPermutation[columnIndex]=columnIndex;
      columnEnds[columnIndex]=i;
      if (columnIndex + 1 < numberOfColumns) {
        columnStarts[columnIndex + 1]=i + 1;
      }
    }
    if (c == columnSeparatorCharacter || c == fieldSeparatorCharacter || (columnIndex >= formatColumnIndex && c == formatFieldSeparatorCharacter)) {
      if (TSV) {
        fieldEnds[columnIndex]=columnEnds[columnIndex];
        fieldStarts[columnIndex]=columnStarts[columnIndex];
        fieldIndex=columnIndex;
        lineFieldIndexToColumnIndex[fieldIndex]=columnIndex;
      }
 else {
        fieldEnds[fieldIndex]=i;
        if (fieldIndex + 1 < numberOfFields) {
          fieldStarts[fieldIndex + 1]=i + 1;
        }
        previousColumnFieldIndices.add(fieldIndex);
        fieldIndex++;
      }
    }
    if (c == columnSeparatorCharacter) {
      if (TSV) {
        lineFieldIndexToColumnIndex[fieldIndex]=columnIndex;
      }
      push(columnIndex,lineFieldIndexToColumnIndex,previousColumnFieldIndices);
      columnIndex++;
    }
  }
  int numberOfFieldsOnLine=Math.min(fieldIndex,fieldEnds.length - 1);
  int numberOfColumnsOnLine=Math.min(columnIndex,columnEnds.length - 1);
  columnStarts[0]=0;
  columnEnds[numberOfColumnsOnLine - (TSV ? 1 : 0)]=line.length();
  fieldStarts[0]=0;
  fieldEnds[numberOfFieldsOnLine - (TSV ? 1 : 0)]=line.length();
  previousColumnFieldIndices.add(fieldIndex);
  push(columnIndex,lineFieldIndexToColumnIndex,previousColumnFieldIndices);
  if (cacheFieldPermutation && computedFieldPermutation)   return;
  Arrays.fill(fieldPermutation,-1);
  for (  ColumnInfo c : columns) {
    c.formatIndex=0;
  }
  for (int lineFieldIndex=0; lineFieldIndex <= numberOfFieldsOnLine; lineFieldIndex++) {
    final int start=fieldStarts[lineFieldIndex];
    final int end=fieldEnds[lineFieldIndex];
    final int cIndex=lineFieldIndexToColumnIndex[lineFieldIndex];
    if (cIndex >= columnList.size()) {
      break;
    }
    final ColumnInfo column=columnList.get(cIndex);
    int colMinGlobalFieldIndex=Integer.MAX_VALUE;
    int colMaxGlobalFieldIndex=Integer.MIN_VALUE;
    final ColumnFields fields=column.fields;
    fields.rebuildList();
    for (int fi=0; fi < fields.size(); ++fi) {
      final ColumnField f=fields.get(fi);
      colMinGlobalFieldIndex=Math.min(colMinGlobalFieldIndex,f.globalFieldIndex);
      colMaxGlobalFieldIndex=Math.max(colMaxGlobalFieldIndex,f.globalFieldIndex);
    }
    final int formatColumnIndex=TSV ? -1 : formatColumn.columnIndex;
    final int startFormatColumn=TSV ? 0 : columnStarts[formatColumnIndex];
    final int endFormatColumn=TSV ? 0 : columnEnds[formatColumnIndex];
    final String[] formatTokens=split(line,formatFieldSeparatorCharacter,startFormatColumn,endFormatColumn);
    for (int fi=0; fi < fields.size(); ++fi) {
      final ColumnField f=fields.get(fi);
      if (fieldPermutation[f.globalFieldIndex] != -1) {
        continue;
      }
      if (colMaxGlobalFieldIndex == colMinGlobalFieldIndex) {
        fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
        break;
      }
 else {
        int j=start;
        final String id=f.id;
        int matchLength=0;
        for (int i=0; i < id.length(); i++) {
          if (j >= end) {
            break;
          }
          final char linechar=line.charAt(j);
          if (id.charAt(i) != linechar) {
            matchLength=-1;
            break;
          }
          matchLength++;
          j++;
        }
        if (matchLength == id.length() && line.charAt(j) == '=' || (j == end && f.type == ColumnType.Flag)) {
          fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
          if (f.type != ColumnType.Flag) {
            fieldStarts[lineFieldIndex]+=f.id.length() + 1;
          }
          break;
        }
 else {
          if (column.useFormat && column.formatIndex < formatTokens.length) {
            if (f.id.equals(formatTokens[column.formatIndex])) {
              fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
              column.formatIndex++;
              break;
            }
          }
        }
      }
    }
  }
  computedFieldPermutation=true;
}","private void parseCurrentLine(){
  Arrays.fill(columnStarts,0);
  Arrays.fill(columnEnds,0);
  Arrays.fill(fieldStarts,0);
  Arrays.fill(fieldEnds,0);
  columnStarts[0]=0;
  int columnIndex=0;
  int fieldIndex=0;
  lineLength=line.length();
  final int[] lineFieldIndexToColumnIndex=new int[numberOfFields];
  Arrays.fill(lineFieldIndexToColumnIndex,-1);
  previousColumnFieldIndices.clear();
  final char[] chrs=line.toCharArray();
  for (int i=0; i < lineLength; i++) {
    final char c=chrs[i];
    if (c == columnSeparatorCharacter) {
      fieldPermutation[columnIndex]=columnIndex;
      columnEnds[columnIndex]=i;
      if (columnIndex + 1 < numberOfColumns) {
        columnStarts[columnIndex + 1]=i + 1;
      }
    }
    if (c == columnSeparatorCharacter || c == fieldSeparatorCharacter || (columnIndex >= formatColumnIndex && c == formatFieldSeparatorCharacter)) {
      if (TSV) {
        fieldEnds[columnIndex]=columnEnds[columnIndex];
        fieldStarts[columnIndex]=columnStarts[columnIndex];
        fieldIndex=columnIndex;
        lineFieldIndexToColumnIndex[fieldIndex]=columnIndex;
      }
 else {
        fieldEnds[fieldIndex]=i;
        if (fieldIndex + 1 < numberOfFields) {
          fieldStarts[fieldIndex + 1]=i + 1;
        }
        previousColumnFieldIndices.add(fieldIndex);
        fieldIndex++;
        fieldIndex=Math.min(fieldEnds.length - 1,fieldIndex);
        fieldIndex=Math.min(fieldStarts.length - 1,fieldIndex);
      }
    }
    if (c == columnSeparatorCharacter) {
      if (TSV) {
        lineFieldIndexToColumnIndex[fieldIndex]=columnIndex;
      }
      push(columnIndex,lineFieldIndexToColumnIndex,previousColumnFieldIndices);
      columnIndex++;
    }
  }
  int numberOfFieldsOnLine=Math.min(fieldIndex,fieldEnds.length - 1);
  int numberOfColumnsOnLine=Math.min(columnIndex,columnEnds.length - 1);
  columnStarts[0]=0;
  columnEnds[numberOfColumnsOnLine - (TSV ? 1 : 0)]=line.length();
  fieldStarts[0]=0;
  fieldEnds[numberOfFieldsOnLine - (TSV ? 1 : 0)]=line.length();
  previousColumnFieldIndices.add(fieldIndex);
  push(columnIndex,lineFieldIndexToColumnIndex,previousColumnFieldIndices);
  if (cacheFieldPermutation && computedFieldPermutation)   return;
  Arrays.fill(fieldPermutation,-1);
  for (  ColumnInfo c : columns) {
    c.formatIndex=0;
  }
  for (int lineFieldIndex=0; lineFieldIndex <= numberOfFieldsOnLine; lineFieldIndex++) {
    final int start=fieldStarts[lineFieldIndex];
    final int end=fieldEnds[lineFieldIndex];
    final int cIndex=lineFieldIndexToColumnIndex[lineFieldIndex];
    if (cIndex >= columnList.size()) {
      break;
    }
    final ColumnInfo column=columnList.get(cIndex);
    int colMinGlobalFieldIndex=Integer.MAX_VALUE;
    int colMaxGlobalFieldIndex=Integer.MIN_VALUE;
    final ColumnFields fields=column.fields;
    fields.rebuildList();
    for (int fi=0; fi < fields.size(); ++fi) {
      final ColumnField f=fields.get(fi);
      colMinGlobalFieldIndex=Math.min(colMinGlobalFieldIndex,f.globalFieldIndex);
      colMaxGlobalFieldIndex=Math.max(colMaxGlobalFieldIndex,f.globalFieldIndex);
    }
    final int formatColumnIndex=TSV ? -1 : formatColumn.columnIndex;
    final int startFormatColumn=TSV ? 0 : columnStarts[formatColumnIndex];
    final int endFormatColumn=TSV ? 0 : columnEnds[formatColumnIndex];
    final String[] formatTokens=split(line,formatFieldSeparatorCharacter,startFormatColumn,endFormatColumn);
    for (int fi=0; fi < fields.size(); ++fi) {
      final ColumnField f=fields.get(fi);
      if (fieldPermutation[f.globalFieldIndex] != -1) {
        continue;
      }
      if (colMaxGlobalFieldIndex == colMinGlobalFieldIndex) {
        fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
        break;
      }
 else {
        int j=start;
        final String id=f.id;
        int matchLength=0;
        for (int i=0; i < id.length(); i++) {
          if (j >= end) {
            break;
          }
          final char linechar=line.charAt(j);
          if (id.charAt(i) != linechar) {
            matchLength=-1;
            break;
          }
          matchLength++;
          j++;
        }
        if (matchLength == id.length() && line.charAt(j) == '=' || (j == end && f.type == ColumnType.Flag)) {
          fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
          if (f.type != ColumnType.Flag) {
            fieldStarts[lineFieldIndex]+=f.id.length() + 1;
          }
          break;
        }
 else {
          if (column.useFormat && column.formatIndex < formatTokens.length) {
            if (f.id.equals(formatTokens[column.formatIndex])) {
              fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
              column.formatIndex++;
              break;
            }
          }
        }
      }
    }
  }
  computedFieldPermutation=true;
}"
50369,"@Override public void writeRecord(final DiscoverVariantIterateSortedAlignments iterator,final SampleCountInfo[] sampleCounts,final int referenceIndex,int position,final ObjectArrayList<PositionBaseInfo> list,final int groupIndexA,final int groupIndexB){
  position=position + 1;
  fillVariantCountArrays(sampleCounts);
  CharSequence currentReferenceId=iterator.getReferenceId(referenceIndex);
  statsWriter.setId(""String_Node_Str"");
  statsWriter.setInfo(biomartFieldIndex,String.format(""String_Node_Str"",currentReferenceId,position,position));
  statsWriter.setChromosome(currentReferenceId);
  statsWriter.setPosition(position);
  writeGenotypes(statsWriter,sampleCounts,position);
  writeZygozity(sampleCounts);
  if (!alleleSet.isEmpty()) {
    statsWriter.writeRecord();
  }
}","@Override public void writeRecord(final DiscoverVariantIterateSortedAlignments iterator,final SampleCountInfo[] sampleCounts,final int referenceIndex,int position,final ObjectArrayList<PositionBaseInfo> list,final int groupIndexA,final int groupIndexB){
  position=position + 1;
  fillVariantCountArrays(sampleCounts);
  CharSequence currentReferenceId=iterator.getReferenceId(referenceIndex);
  statsWriter.setId(""String_Node_Str"");
  statsWriter.setInfo(biomartFieldIndex,String.format(""String_Node_Str"",currentReferenceId,position,position));
  statsWriter.setChromosome(currentReferenceId);
  statsWriter.setPosition(position);
  int location=8930369;
  if (position == location || position - 1 == location || position + 1 == location) {
    System.out.println(""String_Node_Str"");
  }
  writeGenotypes(statsWriter,sampleCounts,position);
  writeZygozity(sampleCounts);
  if (!alleleSet.isEmpty()) {
    statsWriter.writeRecord();
  }
}"
50370,"public void writeGenotypes(VCFWriter statsWriter,SampleCountInfo[] sampleCounts,int position){
  boolean referenceAlleleSetForIndel=false;
  siteObserved=false;
  boolean siteHasIndel=false;
  referenceSet.clear();
  statsWriter.clearAlternateAlleles();
  for (int sampleIndex=0; sampleIndex < numberOfSamples; sampleIndex++) {
    alleleSet.clear();
    SampleCountInfo sci=sampleCounts[sampleIndex];
    int totalCount=0;
    for (int genotypeIndex=0; genotypeIndex < sci.getGenotypeMaxIndex(); ++genotypeIndex) {
      final int sampleCount=sci.getGenotypeCount(genotypeIndex);
      totalCount+=sampleCount;
    }
    statsWriter.setSampleValue(goodBaseCountFieldIndex,sampleIndex,totalCount);
    statsWriter.setSampleValue(failBaseCountFieldIndex,sampleIndex,sci.failedCount);
    int baseIndex=0;
    int altGenotypeCount=0;
    genotypeBuffer.setLength(0);
    final MutableString baseCountString=new MutableString();
    for (int genotypeIndex=0; genotypeIndex < sci.getGenotypeMaxIndex(); ++genotypeIndex) {
      final int sampleCount=sci.getGenotypeCount(genotypeIndex);
      String genotype=sci.getGenotypeString(genotypeIndex);
      if (sampleCount > 0 && genotypeIndex != SampleCountInfo.BASE_OTHER_INDEX) {
        siteObserved=true;
        if (sci.isIndel(genotypeIndex)) {
          siteHasIndel=true;
        }
        if (!sci.isReferenceGenotype(genotypeIndex)) {
          statsWriter.addAlternateAllele(genotype);
          altGenotypeCount++;
          updateReferenceSet(sci.getReferenceGenotype());
        }
 else {
          if (sci.isIndel(genotypeIndex)) {
            siteHasIndel=true;
            genotype=sci.getReferenceGenotype();
          }
          updateReferenceSet(genotype);
        }
        alleleSet.add(genotype);
        genotypeBuffer.append(genotype);
        genotypeBuffer.append('/');
      }
      baseCountString.append(genotype);
      baseCountString.append('=');
      baseCountString.append(Integer.toString(sampleCount));
      baseCountString.append(',');
    }
    if (alleleSet.size() == 1) {
      genotypeBuffer.append(genotypeBuffer.copy());
    }
    baseCountString.setLength(baseCountString.length() - 1);
    statsWriter.setSampleValue(baseCountFieldIndex,sampleIndex,baseCountString);
    if (siteObserved) {
      if (genotypeBuffer.length() > 1) {
        genotypeBuffer.setLength(genotypeBuffer.length() - 1);
      }
      if (referenceSet.size() <= 1) {
        if (referenceSet.isEmpty()) {
          statsWriter.setReferenceAllele(sci.getReferenceGenotype());
        }
 else {
          statsWriter.setReferenceAllele(referenceSet.toArray(singleton)[0]);
        }
      }
 else {
        LOG.error(String.format(""String_Node_Str"",position,referenceSet));
        int maxLength=0;
        for (        final String ref : referenceSet) {
          if (ref.length() > maxLength) {
            statsWriter.setReferenceAllele(ref);
            maxLength=ref.length();
          }
        }
      }
      statsWriter.setSampleValue(genotypeFieldIndex,sampleIndex,statsWriter.codeGenotype(genotypeBuffer.toString()));
    }
 else {
      statsWriter.setSampleValue(genotypeFieldIndex,sampleIndex,""String_Node_Str"");
    }
  }
  if (indelFlagFieldIndex != -1) {
    statsWriter.setFlag(indelFlagFieldIndex,siteHasIndel);
  }
}","public void writeGenotypes(VCFWriter statsWriter,SampleCountInfo[] sampleCounts,int position){
  boolean referenceAlleleSetForIndel=false;
  siteObserved=false;
  boolean siteHasIndel=false;
  referenceSet.clear();
  statsWriter.clearAlternateAlleles();
  alleleSet.clear();
  for (int sampleIndex=0; sampleIndex < numberOfSamples; sampleIndex++) {
    SampleCountInfo sci=sampleCounts[sampleIndex];
    int totalCount=0;
    for (int genotypeIndex=0; genotypeIndex < sci.getGenotypeMaxIndex(); ++genotypeIndex) {
      final int sampleCount=sci.getGenotypeCount(genotypeIndex);
      totalCount+=sampleCount;
    }
    statsWriter.setSampleValue(goodBaseCountFieldIndex,sampleIndex,totalCount);
    statsWriter.setSampleValue(failBaseCountFieldIndex,sampleIndex,sci.failedCount);
    int baseIndex=0;
    int altGenotypeCount=0;
    genotypeBuffer.setLength(0);
    final MutableString baseCountString=new MutableString();
    for (int genotypeIndex=0; genotypeIndex < sci.getGenotypeMaxIndex(); ++genotypeIndex) {
      final int sampleCount=sci.getGenotypeCount(genotypeIndex);
      String genotype=sci.getGenotypeString(genotypeIndex);
      if (sampleCount > 0 && genotypeIndex != SampleCountInfo.BASE_OTHER_INDEX) {
        siteObserved=true;
        if (sci.isIndel(genotypeIndex)) {
          siteHasIndel=true;
        }
        if (!sci.isReferenceGenotype(genotypeIndex)) {
          statsWriter.addAlternateAllele(genotype);
          altGenotypeCount++;
          updateReferenceSet(sci.getReferenceGenotype());
        }
 else {
          if (sci.isIndel(genotypeIndex)) {
            siteHasIndel=true;
            genotype=sci.getReferenceGenotype();
          }
          updateReferenceSet(genotype);
        }
        alleleSet.add(genotype);
        genotypeBuffer.append(genotype);
        genotypeBuffer.append('/');
      }
      baseCountString.append(genotype);
      baseCountString.append('=');
      baseCountString.append(Integer.toString(sampleCount));
      baseCountString.append(',');
    }
    if (alleleSet.size() == 1) {
      genotypeBuffer.append(genotypeBuffer.copy());
    }
    baseCountString.setLength(baseCountString.length() - 1);
    statsWriter.setSampleValue(baseCountFieldIndex,sampleIndex,baseCountString);
    if (siteObserved) {
      if (genotypeBuffer.length() > 1) {
        genotypeBuffer.setLength(genotypeBuffer.length() - 1);
      }
      if (referenceSet.size() <= 1) {
        if (referenceSet.isEmpty()) {
          statsWriter.setReferenceAllele(sci.getReferenceGenotype());
        }
 else {
          statsWriter.setReferenceAllele(referenceSet.toArray(singleton)[0]);
        }
      }
 else {
        LOG.error(String.format(""String_Node_Str"",position,referenceSet));
        int maxLength=0;
        for (        final String ref : referenceSet) {
          if (ref.length() > maxLength) {
            statsWriter.setReferenceAllele(ref);
            maxLength=ref.length();
          }
        }
      }
      statsWriter.setSampleValue(genotypeFieldIndex,sampleIndex,statsWriter.codeGenotype(genotypeBuffer.toString()));
    }
 else {
      statsWriter.setSampleValue(genotypeFieldIndex,sampleIndex,""String_Node_Str"");
    }
  }
  if (indelFlagFieldIndex != -1) {
    statsWriter.setFlag(indelFlagFieldIndex,siteHasIndel);
  }
}"
50371,"/** 
 * Score the realignment of an entry with respect to a potential indel.
 * @param entry            The entry to score as if it was realigned with respect to the indel
 * @param indel            The indel under consideration.
 * @param shiftForward     Whether the indel should be introduced by shifting bases forward
 * @param currentBestScore The current maximum score over a set of indels under consideration.  @return The score obtained when realigning the entry with respect to the provided indel.
 * @param genome           The genome to use to lookup reference bases
 * @return The score that would be observed if the indel was inserted into the alignment represented by entry.
 */
public final int score(final Alignments.AlignmentEntry entry,final ObservedIndel indel,final boolean shiftForward,final int currentBestScore,final RandomAccessSequenceInterface genome){
  int entryPosition=entry.getPosition();
  int indelOffsetInAlignment=indel.getStart() - entryPosition;
  int indelLength=indel.positionSpan();
  int varCount=entry.getSequenceVariationsCount();
  int targetIndex=entry.getTargetIndex();
  int score=0;
  int direction=shiftForward ? 1 : -1;
  if (genome == null) {
    genomeNull.warn(LOG,""String_Node_Str"");
    return Integer.MIN_VALUE;
  }
  final int targetLength=genome.getLength(targetIndex);
  IntArraySet variantPositions=new IntArraySet();
  for (int i=0; i < varCount; i++) {
    Alignments.SequenceVariation var=entry.getSequenceVariations(i);
    final int newGenomicPosition=var.getPosition() + (direction * indelLength) + entryPosition - 1;
    for (int j=0; j < var.getTo().length(); ++j) {
      final char toBase=var.getTo().charAt(j);
      final int index=newGenomicPosition + j;
      if (index < 0 || index > genome.getLength(targetIndex)) {
        score+=-10;
      }
 else {
        final boolean compatible=genome.get(targetIndex,newGenomicPosition + j) == toBase;
        score+=compatible ? 1 : 0;
        variantPositions.add(var.getPosition() + entryPosition + j - 1);
      }
    }
  }
  int startAlignment=shiftForward ? entryPosition + indelOffsetInAlignment : entryPosition;
  int endAlignment=shiftForward ? entry.getTargetAlignedLength() + entryPosition : indelOffsetInAlignment + entryPosition + (direction * indelLength);
  for (int pos=startAlignment; pos < endAlignment; pos++) {
    if (!variantPositions.contains(pos)) {
      final int realignedPos=pos + (direction * indelLength);
      if (realignedPos < 0 || realignedPos >= targetLength) {
        score+=-10;
      }
 else {
        final char refBase=genome.get(targetIndex,pos);
        final char newRefBase=genome.get(targetIndex,realignedPos);
        score+=(refBase == newRefBase) ? 0 : -1;
      }
    }
  }
  return score;
}","/** 
 * Score the realignment of an entry with respect to a potential indel.
 * @param entry            The entry to score as if it was realigned with respect to the indel
 * @param indel            The indel under consideration.
 * @param shiftForward     Whether the indel should be introduced by shifting bases forward
 * @param currentBestScore The current maximum score over a set of indels under consideration.  @return The score obtained when realigning the entry with respect to the provided indel.
 * @param genome           The genome to use to lookup reference bases
 * @return The score that would be observed if the indel was inserted into the alignment represented by entry.
 */
public final int score(final Alignments.AlignmentEntry entry,final ObservedIndel indel,final boolean shiftForward,final int currentBestScore,final RandomAccessSequenceInterface genome){
  int entryPosition=entry.getPosition();
  int indelOffsetInAlignment=indel.getStart() - entryPosition;
  int indelLength=indel.positionSpan();
  int varCount=entry.getSequenceVariationsCount();
  int targetIndex=entry.getTargetIndex();
  int score=0;
  int direction=shiftForward ? 1 : -1;
  if (genome == null) {
    genomeNull.warn(LOG,""String_Node_Str"");
    return Integer.MIN_VALUE;
  }
  final int targetLength=genome.getLength(targetIndex);
  IntArraySet variantPositions=new IntArraySet();
  for (int i=0; i < varCount; i++) {
    Alignments.SequenceVariation var=entry.getSequenceVariations(i);
    final int newGenomicPosition=var.getPosition() + (direction * indelLength) + entryPosition - 1;
    for (int j=0; j < var.getTo().length(); ++j) {
      final char toBase=var.getTo().charAt(j);
      final int index=newGenomicPosition + j;
      if (index < 0 || index > genome.getLength(targetIndex)) {
        score+=-10;
      }
 else {
        final boolean compatible=genome.get(targetIndex,newGenomicPosition + j) == toBase;
        score+=compatible ? 1 : 0;
        variantPositions.add(var.getPosition() + entryPosition + j - 1);
      }
    }
  }
  int startAlignment=shiftForward ? entryPosition + indelOffsetInAlignment : entryPosition;
  int endAlignment=shiftForward ? entry.getTargetAlignedLength() + entryPosition : indelOffsetInAlignment + entryPosition + (direction * indelLength);
  endAlignment=Math.min(endAlignment,genome.getLength(targetIndex) - 1);
  for (int pos=startAlignment; pos < endAlignment; pos++) {
    if (!variantPositions.contains(pos)) {
      final int realignedPos=pos + (direction * indelLength);
      if (realignedPos < 0 || realignedPos >= targetLength) {
        score+=-10;
      }
 else {
        final char refBase=genome.get(targetIndex,pos);
        final char newRefBase=genome.get(targetIndex,realignedPos);
        score+=(refBase == newRefBase) ? 0 : -1;
      }
    }
  }
  return score;
}"
50372,"private String convertCode(String genotypeCode,VCFParser parser,String ref,String alts){
  String[] tokens=genotypeCode.split(""String_Node_Str"");
  buffer.setLength(0);
  String[] altArray=alts.split(""String_Node_Str"");
  list.clear();
  for (  String token : tokens) {
    try {
      if (""String_Node_Str"".equals(token)) {
        return ""String_Node_Str"";
      }
      int index=Integer.parseInt(token);
      if (index == 0) {
        list.add(""String_Node_Str"");
      }
 else {
        list.add(altArray[index - 1]);
      }
    }
 catch (    NumberFormatException e) {
      LOG.info(""String_Node_Str"" + genotypeCode);
      return ""String_Node_Str"";
    }
  }
  Collections.sort(list);
  for (  String allele : list) {
    buffer.append(allele);
    buffer.append('/');
  }
  return buffer.toString();
}","private String convertCode(String genotypeCode,VCFParser parser,String ref,String alts){
  String[] tokens=genotypeCode.split(""String_Node_Str"");
  buffer.setLength(0);
  String[] altArray=alts.split(""String_Node_Str"");
  list.clear();
  for (  String token : tokens) {
    try {
      if (""String_Node_Str"".equals(token)) {
        return ""String_Node_Str"";
      }
      int index=Integer.parseInt(token);
      if (index == 0) {
        list.add(""String_Node_Str"");
      }
 else {
        list.add(altArray[index - 1]);
      }
    }
 catch (    NumberFormatException e) {
      LOG.info(""String_Node_Str"" + genotypeCode);
      return ""String_Node_Str"" + genotypeCode;
    }
  }
  Collections.sort(list);
  for (  String allele : list) {
    buffer.append(allele);
    buffer.append('/');
  }
  return buffer.toString();
}"
50373,"private void parseCurrentLine(){
  Arrays.fill(columnStarts,0);
  Arrays.fill(columnEnds,0);
  Arrays.fill(fieldStarts,0);
  Arrays.fill(fieldEnds,0);
  columnStarts[0]=0;
  int columnIndex=0;
  int fieldIndex=0;
  lineLength=line.length();
  final int[] lineFieldIndexToColumnIndex=new int[numberOfFields];
  Arrays.fill(lineFieldIndexToColumnIndex,-1);
  previousColumnFieldIndices.clear();
  final char[] chrs=line.toCharArray();
  for (int i=0; i < lineLength; i++) {
    final char c=chrs[i];
    if (c == columnSeparatorCharacter) {
      fieldPermutation[columnIndex]=columnIndex;
      columnEnds[columnIndex]=i;
      if (columnIndex + 1 < numberOfColumns) {
        columnStarts[columnIndex + 1]=i + 1;
      }
    }
    if (c == columnSeparatorCharacter || c == fieldSeparatorCharacter || (columnIndex >= formatColumnIndex && c == formatFieldSeparatorCharacter)) {
      if (TSV) {
        fieldEnds[columnIndex]=columnEnds[columnIndex];
        fieldStarts[columnIndex]=columnStarts[columnIndex];
        fieldIndex=columnIndex;
        lineFieldIndexToColumnIndex[fieldIndex]=columnIndex;
      }
 else {
        fieldEnds[fieldIndex]=i;
        if (fieldIndex + 1 < numberOfFields) {
          fieldStarts[fieldIndex + 1]=i + 1;
        }
        previousColumnFieldIndices.add(fieldIndex);
        fieldIndex++;
      }
    }
    if (c == columnSeparatorCharacter) {
      if (TSV) {
        lineFieldIndexToColumnIndex[fieldIndex]=columnIndex;
      }
      push(columnIndex,lineFieldIndexToColumnIndex,previousColumnFieldIndices);
      columnIndex++;
    }
  }
  int numberOfFieldsOnLine=fieldIndex;
  int numberOfColumnsOnLine=columnIndex;
  columnStarts[0]=0;
  columnEnds[numberOfColumnsOnLine - (TSV ? 1 : 0)]=line.length();
  fieldStarts[0]=0;
  fieldEnds[numberOfFieldsOnLine - (TSV ? 1 : 0)]=line.length();
  previousColumnFieldIndices.add(fieldIndex);
  push(columnIndex,lineFieldIndexToColumnIndex,previousColumnFieldIndices);
  if (cacheFieldPermutation && computedFieldPermutation)   return;
  Arrays.fill(fieldPermutation,-1);
  for (  ColumnInfo c : columns) {
    c.formatIndex=0;
  }
  for (int lineFieldIndex=0; lineFieldIndex <= numberOfFieldsOnLine; lineFieldIndex++) {
    final int start=fieldStarts[lineFieldIndex];
    final int end=fieldEnds[lineFieldIndex];
    final int cIndex=lineFieldIndexToColumnIndex[lineFieldIndex];
    if (cIndex >= columnList.size()) {
      break;
    }
    final ColumnInfo column=columnList.get(cIndex);
    int colMinGlobalFieldIndex=Integer.MAX_VALUE;
    int colMaxGlobalFieldIndex=Integer.MIN_VALUE;
    final ColumnFields fields=column.fields;
    fields.rebuildList();
    for (int fi=0; fi < fields.size(); ++fi) {
      final ColumnField f=fields.get(fi);
      colMinGlobalFieldIndex=Math.min(colMinGlobalFieldIndex,f.globalFieldIndex);
      colMaxGlobalFieldIndex=Math.max(colMaxGlobalFieldIndex,f.globalFieldIndex);
    }
    final int formatColumnIndex=TSV ? -1 : formatColumn.columnIndex;
    final int startFormatColumn=TSV ? 0 : columnStarts[formatColumnIndex];
    final int endFormatColumn=TSV ? 0 : columnEnds[formatColumnIndex];
    final String[] formatTokens=split(line,formatFieldSeparatorCharacter,startFormatColumn,endFormatColumn);
    for (int fi=0; fi < fields.size(); ++fi) {
      final ColumnField f=fields.get(fi);
      if (fieldPermutation[f.globalFieldIndex] != -1) {
        continue;
      }
      if (colMaxGlobalFieldIndex == colMinGlobalFieldIndex) {
        fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
        break;
      }
 else {
        int j=start;
        final String id=f.id;
        int matchLength=0;
        for (int i=0; i < id.length(); i++) {
          if (j >= end) {
            break;
          }
          final char linechar=line.charAt(j);
          if (id.charAt(i) != linechar) {
            matchLength=-1;
            break;
          }
          matchLength++;
          j++;
        }
        if (matchLength == id.length() && line.charAt(j) == '=' || (j == end && f.type == ColumnType.Flag)) {
          fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
          if (f.type != ColumnType.Flag) {
            fieldStarts[lineFieldIndex]+=f.id.length() + 1;
          }
          break;
        }
 else {
          if (column.useFormat && column.formatIndex < formatTokens.length) {
            if (f.id.equals(formatTokens[column.formatIndex])) {
              fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
              column.formatIndex++;
              break;
            }
          }
        }
      }
    }
  }
  computedFieldPermutation=true;
}","private void parseCurrentLine(){
  Arrays.fill(columnStarts,0);
  Arrays.fill(columnEnds,0);
  Arrays.fill(fieldStarts,0);
  Arrays.fill(fieldEnds,0);
  columnStarts[0]=0;
  int columnIndex=0;
  int fieldIndex=0;
  lineLength=line.length();
  final int[] lineFieldIndexToColumnIndex=new int[numberOfFields];
  Arrays.fill(lineFieldIndexToColumnIndex,-1);
  previousColumnFieldIndices.clear();
  final char[] chrs=line.toCharArray();
  for (int i=0; i < lineLength; i++) {
    final char c=chrs[i];
    if (c == columnSeparatorCharacter) {
      fieldPermutation[columnIndex]=columnIndex;
      columnEnds[columnIndex]=i;
      if (columnIndex + 1 < numberOfColumns) {
        columnStarts[columnIndex + 1]=i + 1;
      }
    }
    if (c == columnSeparatorCharacter || c == fieldSeparatorCharacter || (columnIndex >= formatColumnIndex && c == formatFieldSeparatorCharacter)) {
      if (TSV) {
        fieldEnds[columnIndex]=columnEnds[columnIndex];
        fieldStarts[columnIndex]=columnStarts[columnIndex];
        fieldIndex=columnIndex;
        lineFieldIndexToColumnIndex[fieldIndex]=columnIndex;
      }
 else {
        fieldEnds[fieldIndex]=i;
        if (fieldIndex + 1 < numberOfFields) {
          fieldStarts[fieldIndex + 1]=i + 1;
        }
        previousColumnFieldIndices.add(fieldIndex);
        fieldIndex++;
      }
    }
    if (c == columnSeparatorCharacter) {
      if (TSV) {
        lineFieldIndexToColumnIndex[fieldIndex]=columnIndex;
      }
      push(columnIndex,lineFieldIndexToColumnIndex,previousColumnFieldIndices);
      columnIndex++;
    }
  }
  int numberOfFieldsOnLine=Math.min(fieldIndex,fieldEnds.length - 1);
  int numberOfColumnsOnLine=Math.min(columnIndex,columnEnds.length - 1);
  columnStarts[0]=0;
  columnEnds[numberOfColumnsOnLine - (TSV ? 1 : 0)]=line.length();
  fieldStarts[0]=0;
  fieldEnds[numberOfFieldsOnLine - (TSV ? 1 : 0)]=line.length();
  previousColumnFieldIndices.add(fieldIndex);
  push(columnIndex,lineFieldIndexToColumnIndex,previousColumnFieldIndices);
  if (cacheFieldPermutation && computedFieldPermutation)   return;
  Arrays.fill(fieldPermutation,-1);
  for (  ColumnInfo c : columns) {
    c.formatIndex=0;
  }
  for (int lineFieldIndex=0; lineFieldIndex <= numberOfFieldsOnLine; lineFieldIndex++) {
    final int start=fieldStarts[lineFieldIndex];
    final int end=fieldEnds[lineFieldIndex];
    final int cIndex=lineFieldIndexToColumnIndex[lineFieldIndex];
    if (cIndex >= columnList.size()) {
      break;
    }
    final ColumnInfo column=columnList.get(cIndex);
    int colMinGlobalFieldIndex=Integer.MAX_VALUE;
    int colMaxGlobalFieldIndex=Integer.MIN_VALUE;
    final ColumnFields fields=column.fields;
    fields.rebuildList();
    for (int fi=0; fi < fields.size(); ++fi) {
      final ColumnField f=fields.get(fi);
      colMinGlobalFieldIndex=Math.min(colMinGlobalFieldIndex,f.globalFieldIndex);
      colMaxGlobalFieldIndex=Math.max(colMaxGlobalFieldIndex,f.globalFieldIndex);
    }
    final int formatColumnIndex=TSV ? -1 : formatColumn.columnIndex;
    final int startFormatColumn=TSV ? 0 : columnStarts[formatColumnIndex];
    final int endFormatColumn=TSV ? 0 : columnEnds[formatColumnIndex];
    final String[] formatTokens=split(line,formatFieldSeparatorCharacter,startFormatColumn,endFormatColumn);
    for (int fi=0; fi < fields.size(); ++fi) {
      final ColumnField f=fields.get(fi);
      if (fieldPermutation[f.globalFieldIndex] != -1) {
        continue;
      }
      if (colMaxGlobalFieldIndex == colMinGlobalFieldIndex) {
        fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
        break;
      }
 else {
        int j=start;
        final String id=f.id;
        int matchLength=0;
        for (int i=0; i < id.length(); i++) {
          if (j >= end) {
            break;
          }
          final char linechar=line.charAt(j);
          if (id.charAt(i) != linechar) {
            matchLength=-1;
            break;
          }
          matchLength++;
          j++;
        }
        if (matchLength == id.length() && line.charAt(j) == '=' || (j == end && f.type == ColumnType.Flag)) {
          fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
          if (f.type != ColumnType.Flag) {
            fieldStarts[lineFieldIndex]+=f.id.length() + 1;
          }
          break;
        }
 else {
          if (column.useFormat && column.formatIndex < formatTokens.length) {
            if (f.id.equals(formatTokens[column.formatIndex])) {
              fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
              column.formatIndex++;
              break;
            }
          }
        }
      }
    }
  }
  computedFieldPermutation=true;
}"
50374,"public Alignments.AlignmentEntry skipTo(int targetIndex,int position) throws IOException {
  if (possibleEntry != null) {
    if (possibleEntry.getTargetIndex() >= targetIndex && possibleEntry.getPosition() >= position) {
      return possibleEntry;
    }
 else {
      possibleEntry=null;
    }
  }
  while (possibleEntry == null) {
    possibleEntry=delegate.skipTo(targetIndex,position);
    if (possibleEntry == null) {
      return null;
    }
    if (!ambiguousQueryIndices.get(possibleEntry.getQueryIndex())) {
      final Alignments.AlignmentEntry tmp=possibleEntry;
      possibleEntry=null;
      return tmp;
    }
  }
  return null;
}","public Alignments.AlignmentEntry skipTo(int targetIndex,int position) throws IOException {
  if (possibleEntry != null) {
    if (possibleEntry.getTargetIndex() >= targetIndex && possibleEntry.getPosition() >= position) {
      return possibleEntry;
    }
 else {
      possibleEntry=null;
    }
  }
  while (possibleEntry == null) {
    possibleEntry=delegate.skipTo(targetIndex,position);
    if (possibleEntry == null) {
      return null;
    }
    if (!ambiguousQueryIndices.get(possibleEntry.getQueryIndex())) {
      final Alignments.AlignmentEntry tmp=possibleEntry;
      possibleEntry=null;
      return tmp;
    }
 else {
      possibleEntry=null;
    }
  }
  return null;
}"
50375,"/** 
 * Return true if the basename is on the command line as an input basename.
 * @param basename
 * @return
 */
private boolean isInputBasename(final String basename,final String[] inputFilenames){
  for (  final String inputFilename : inputFilenames) {
    if (FilenameUtils.getBaseName(AlignmentReaderImpl.getBasename(inputFilename)).equals(basename)) {
      return true;
    }
  }
  return false;
}","/** 
 * Return true if the basename is on the command line as an input basename.
 * @param basename
 * @param inputFilenames
 * @return
 */
private boolean isInputBasename(final String basename,final String[] inputFilenames){
  for (  final String inputFilename : inputFilenames) {
    if (FilenameUtils.getBaseName(AlignmentReaderImpl.getBasename(inputFilename)).equals(basename)) {
      return true;
    }
  }
  return false;
}"
50376,"public String[] getGroupComparison(){
  String[] result=new String[2];
  GroupComparison val=groupComparisons.get(0);
  result[0]=val.nameGroup1;
  result[1]=val.nameGroup1;
  return result;
}","public String[] getGroupComparison(){
  String[] result=new String[2];
  GroupComparison val=groupComparisons.get(0);
  result[0]=val.nameGroup1;
  result[1]=val.nameGroup2;
  return result;
}"
50377,"/** 
 * Return the element index of element identified by id.
 * @param elementId id of the element.
 * @return index of the element.
 */
public int getElementIndex(String elementId){
  return elementLabels.getInt(new MutableString(elementId));
}","/** 
 * Return the element index of element identified by id.
 * @param elementId id of the element.
 * @return index of the element.
 */
public int getElementIndex(final String elementId){
  return elementLabels.getInt(new MutableString(elementId));
}"
50378,"@Override public void appendCountAtPosition(final int count,final int position) throws IOException {
  if (position != previousPosition + 1 && count != 0) {
    counts.add(0);
    positions.add(position - 1);
  }
  counts.add(count);
  positions.add(position);
  if (positions.size() >= 2) {
    final int i=counts.size() - 2;
    final int j=counts.size() - 1;
    if (counts.getInt(i) == counts.getInt(j)) {
      positions.removeElements(i,j);
      counts.removeElements(i,j);
    }
  }
  while (positions.size() > 2) {
    final int diffPos=positions.getInt(1) - (positions.getInt(0) + 1);
    int aCount=counts.getInt(1);
    if (aCount < 0) {
      System.out.printf(""String_Node_Str"",aCount,positions.getInt(0));
      aCount=0;
    }
    delegate.appendCount(aCount,diffPos + 1);
    positions.removeElements(0,1);
    counts.removeElements(0,1);
    previousCount=count;
  }
  previousPosition=position;
}","@Override public void appendCountAtPosition(final int count,final int position) throws IOException {
  if (position != previousPosition + 1 && count != 0) {
    counts.add(0);
    positions.add(position - 1);
  }
  counts.add(count);
  positions.add(position);
  if (positions.size() >= 2) {
    final int i=counts.size() - 2;
    final int j=counts.size() - 1;
    if (counts.getInt(i) == counts.getInt(j)) {
      positions.removeElements(i,j);
      counts.removeElements(i,j);
    }
  }
  while (positions.size() > 2) {
    int diffPos=positions.getInt(1) - (positions.getInt(0) + 1);
    int aCount=counts.getInt(1);
    if (aCount < 0) {
      System.out.println(counts);
      System.out.println(positions);
      System.out.printf(""String_Node_Str"",aCount,positions.getInt(0));
      aCount=0;
    }
    if (diffPos < 0) {
      System.out.printf(""String_Node_Str"",diffPos,positions.getInt(1),positions.getInt(0));
      System.out.println(counts);
      System.out.println(positions);
      diffPos=0;
    }
    delegate.appendCount(aCount,diffPos + 1);
    positions.removeElements(0,1);
    counts.removeElements(0,1);
    previousCount=count;
  }
  previousPosition=position;
}"
50379,"@Override public void processPositions(int referenceIndex,int position,DiscoverVariantPositionData positionBaseInfos){
  try {
    if (referenceIndex != lastReferenceIndex) {
      if (writerI != null) {
        finishWriter();
      }
      writerI=archiveWriter.newCountWriter(referenceIndex,getReferenceId(referenceIndex).toString());
      helperI=new CountWriterHelper2(writerI);
      lastReferenceIndex=referenceIndex;
    }
    helperI.appendCountAtPosition(positionBaseInfos.size(),position);
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
  }
}","@Override public void processPositions(int referenceIndex,int position,DiscoverVariantPositionData positionBaseInfos){
  try {
    if (referenceIndex != lastReferenceIndex) {
      if (writerI != null) {
        finishWriter();
      }
      writerI=archiveWriter.newCountWriter(referenceIndex,getReferenceId(referenceIndex).toString());
      helperI=new CountWriterHelper2(writerI);
      lastReferenceIndex=referenceIndex;
      lastPosition=-1;
    }
    if (position > lastPosition) {
      helperI.appendCountAtPosition(positionBaseInfos.size(),position);
      lastPosition=position;
    }
  }
 catch (  IOException e) {
    LOG.error(""String_Node_Str"",e);
  }
}"
50380,"public int getNumAlignedReadsInSample(){
  return numAlignedReadsInSample;
}","public long getNumAlignedReadsInSample(){
  return numAlignedReadsInSample;
}"
50381,"@Override public void prepareDataStructuresForReference(final AlignmentReader alignmentReader,final int referenceIndex){
  AnnotationCountInterface algo=new AnnotationCount();
  algo=chooseAlgorithm(weightParams,weights,algo);
  algs[referenceIndex]=algo;
  algs[referenceIndex].startPopulating();
  referencesSelected.add(referenceIndex);
}","@Override public void prepareDataStructuresForReference(final AlignmentReader alignmentReader,final int referenceIndex){
  if (numAlignedReadsInSample == -1) {
    numAlignedReadsInSample=alignmentReader.getNumberOfAlignedReads();
  }
  AnnotationCountInterface algo=new AnnotationCount();
  algo=chooseAlgorithm(weightParams,weights,algo);
  algs[referenceIndex]=algo;
  algs[referenceIndex].startPopulating();
  referencesSelected.add(referenceIndex);
}"
50382,"@Override public void processAlignmentEntry(final AlignmentReader alignmentReader,final Alignments.AlignmentEntry alignmentEntry){
  final int referenceIndex=alignmentEntry.getTargetIndex();
  final int startPosition=alignmentEntry.getPosition();
  final int alignmentLength=alignmentEntry.getQueryAlignedLength();
  for (int i=0; i < alignmentEntry.getMultiplicity(); ++i) {
    algs[referenceIndex].populate(startPosition,startPosition + alignmentLength,alignmentEntry.getQueryIndex());
    ++numAlignedReadsInSample;
  }
}","@Override public void processAlignmentEntry(final AlignmentReader alignmentReader,final Alignments.AlignmentEntry alignmentEntry){
  final int referenceIndex=alignmentEntry.getTargetIndex();
  final int startPosition=alignmentEntry.getPosition();
  final int alignmentLength=alignmentEntry.getQueryAlignedLength();
  for (int i=0; i < alignmentEntry.getMultiplicity(); ++i) {
    algs[referenceIndex].populate(startPosition,startPosition + alignmentLength,alignmentEntry.getQueryIndex());
  }
}"
50383,"/** 
 * Configure.
 * @param args command line arguments
 * @return this object for chaining
 * @throws IOException   error parsing
 * @throws JSAPException error parsing
 */
@Override public AbstractCommandLineMode configure(final String[] args) throws IOException, JSAPException {
  final JSAPResult jsapResult=parseJsapArguments(args);
  parseGenomicRange(jsapResult);
  parallel=jsapResult.getBoolean(""String_Node_Str"",false);
  writeAnnotationCounts=jsapResult.getBoolean(""String_Node_Str"");
  omitNonInformativeColumns=jsapResult.getBoolean(""String_Node_Str"");
  inputFilenames=jsapResult.getStringArray(""String_Node_Str"");
  outputFilename=jsapResult.getString(""String_Node_Str"");
  filterAmbiguousReads=jsapResult.getBoolean(""String_Node_Str"");
  if (filterAmbiguousReads) {
    System.out.println(""String_Node_Str"");
  }
  statsFilename=jsapResult.getString(""String_Node_Str"");
  final String groupsDefinition=jsapResult.getString(""String_Node_Str"");
  deAnalyzer.parseGroupsDefinition(groupsDefinition,deCalculator,inputFilenames);
  final String compare=jsapResult.getString(""String_Node_Str"");
  if (compare == null) {
    doComparison=false;
  }
 else {
    doComparison=true;
  }
  if (doComparison) {
    deAnalyzer.parseCompare(compare);
  }
  deAnalyzer.setRunInParallel(parallel);
  includeReferenceNameCommas=jsapResult.getString(""String_Node_Str"");
  includeReferenceNames=new ObjectOpenHashSet<String>();
  if (includeReferenceNameCommas != null) {
    includeReferenceNames.addAll(Arrays.asList(includeReferenceNameCommas.split(""String_Node_Str"")));
    System.out.println(""String_Node_Str"");
    for (    final String name : includeReferenceNames) {
      System.out.println(name);
    }
    filterByReferenceNames=true;
  }
  parseAnnotations(jsapResult);
  normalizationMethods=deAnalyzer.parseNormalization(jsapResult);
  parseEval(jsapResult,deAnalyzer);
  infoOutput=jsapResult.getString(""String_Node_Str"");
  weightParams=configureWeights(jsapResult);
  return this;
}","/** 
 * Configure.
 * @param args command line arguments
 * @return this object for chaining
 * @throws IOException   error parsing
 * @throws JSAPException error parsing
 */
@Override public AbstractCommandLineMode configure(final String[] args) throws IOException, JSAPException {
  final JSAPResult jsapResult=parseJsapArguments(args);
  parseGenomicRange(jsapResult);
  parallel=jsapResult.getBoolean(""String_Node_Str"",false);
  writeAnnotationCounts=jsapResult.getBoolean(""String_Node_Str"");
  omitNonInformativeColumns=jsapResult.getBoolean(""String_Node_Str"");
  inputFilenames=jsapResult.getStringArray(""String_Node_Str"");
  outputFilename=jsapResult.getString(""String_Node_Str"");
  filterAmbiguousReads=jsapResult.getBoolean(""String_Node_Str"");
  if (filterAmbiguousReads) {
    System.out.println(""String_Node_Str"");
  }
  statsFilename=jsapResult.getString(""String_Node_Str"");
  final String groupsDefinition=jsapResult.getString(""String_Node_Str"");
  deAnalyzer.parseGroupsDefinition(groupsDefinition,deCalculator,inputFilenames);
  final String compare=jsapResult.getString(""String_Node_Str"");
  if (compare == null) {
    doComparison=false;
  }
 else {
    doComparison=true;
  }
  if (doComparison) {
    deAnalyzer.parseCompare(compare);
  }
  deAnalyzer.setRunInParallel(parallel);
  includeReferenceNameCommas=jsapResult.getString(""String_Node_Str"");
  includeReferenceNames=new ObjectOpenHashSet<String>();
  if (includeReferenceNameCommas != null) {
    includeReferenceNames.addAll(Arrays.asList(includeReferenceNameCommas.split(""String_Node_Str"")));
    System.out.println(""String_Node_Str"");
    for (    final String name : includeReferenceNames) {
      System.out.println(name);
    }
    filterByReferenceNames=true;
  }
  parseAnnotations(jsapResult);
  normalizationMethods=deAnalyzer.parseNormalization(jsapResult);
  parseEval(jsapResult,deAnalyzer);
  infoOutputFilename=jsapResult.getString(""String_Node_Str"");
  weightParams=configureWeights(jsapResult);
  return this;
}"
50384,"private void processOneBasename(final Object2ObjectMap<String,ObjectList<Annotation>> allAnnots,BufferedWriter writer,final String inputFile,final String inputBasename,GenomicRange range) throws IOException {
  WeightsInfo weights=null;
  if (weightParams.useWeights) {
    weights=loadWeights(inputBasename,weightParams.useWeights,weightParams.weightId);
    if (weights != null) {
      System.err.println(""String_Node_Str"");
    }
  }
  final AlignmentReaderFactory factory=filterAmbiguousReads ? new NonAmbiguousAlignmentReaderFactory() : new DefaultAlignmentReaderFactory();
  final int numberOfReferences;
  final DoubleIndexedIdentifier referenceIds;
{
    final AlignmentReader reader=factory.createReader(inputBasename);
    reader.readHeader();
    numberOfReferences=reader.getNumberOfTargets();
    referenceIds=new DoubleIndexedIdentifier(reader.getTargetIdentifiers());
    reader.close();
  }
  System.out.println(String.format(""String_Node_Str"",numberOfReferences));
  if (genomicRange != null) {
    genomicRange.resolveChromosomeIndices(referenceIds);
  }
  final AnnotationCountIterateAlignments iterateAlignment=new AnnotationCountIterateAlignments();
  iterateAlignment.setWeightInfo(weightParams,weights);
  iterateAlignment.parseIncludeReferenceArgument(includeReferenceNameCommas);
  System.out.println(""String_Node_Str"" + inputBasename + ""String_Node_Str"");
  iterateAlignment.setAlignmentReaderFactory(factory);
  iterateAlignment.iterate(genomicRange,inputBasename);
  final int numAlignedReadsInSample=iterateAlignment.getNumAlignedReadsInSample();
  final AnnotationCountInterface[] algs=iterateAlignment.getAlgs();
  final IntSet referencesToProcess=iterateAlignment.getReferencesSelected();
  final String sampleId=FilenameUtils.getBaseName(inputBasename);
  deCalculator.setNumAlignedInSample(sampleId,numAlignedReadsInSample);
  if (outputFilename == null) {
    if (writeAnnotationCounts) {
      final String outputFileTmp=FilenameUtils.removeExtension(inputFile) + ""String_Node_Str"";
      writer=new BufferedWriter(new FileWriter(outputFileTmp));
      writer.write(""String_Node_Str"");
    }
  }
  writeAnnotationCounts(allAnnots,writer,inputBasename,referenceIds,algs,referencesToProcess);
  if (outputFilename == null) {
    IOUtils.closeQuietly(writer);
  }
}","private void processOneBasename(final Object2ObjectMap<String,ObjectList<Annotation>> allAnnots,BufferedWriter writer,final String inputFile,final String inputBasename,GenomicRange range) throws IOException {
  WeightsInfo weights=null;
  if (weightParams.useWeights) {
    weights=loadWeights(inputBasename,weightParams.useWeights,weightParams.weightId);
    if (weights != null) {
      System.err.println(""String_Node_Str"");
    }
  }
  final AlignmentReaderFactory factory=filterAmbiguousReads ? new NonAmbiguousAlignmentReaderFactory() : new DefaultAlignmentReaderFactory();
  final int numberOfReferences;
  final DoubleIndexedIdentifier referenceIds;
{
    final AlignmentReader reader=factory.createReader(inputBasename);
    reader.readHeader();
    numberOfReferences=reader.getNumberOfTargets();
    referenceIds=new DoubleIndexedIdentifier(reader.getTargetIdentifiers());
    reader.close();
  }
  System.out.println(String.format(""String_Node_Str"",numberOfReferences));
  if (genomicRange != null) {
    genomicRange.resolveChromosomeIndices(referenceIds);
  }
  final AnnotationCountIterateAlignments iterateAlignment=new AnnotationCountIterateAlignments();
  iterateAlignment.setWeightInfo(weightParams,weights);
  iterateAlignment.parseIncludeReferenceArgument(includeReferenceNameCommas);
  System.out.println(""String_Node_Str"" + inputBasename + ""String_Node_Str"");
  iterateAlignment.setAlignmentReaderFactory(factory);
  iterateAlignment.iterate(genomicRange,inputBasename);
  final long numAlignedReadsInSample=iterateAlignment.getNumAlignedReadsInSample();
  final AnnotationCountInterface[] algs=iterateAlignment.getAlgs();
  final IntSet referencesToProcess=iterateAlignment.getReferencesSelected();
  final String sampleId=FilenameUtils.getBaseName(inputBasename);
  deCalculator.setNumAlignedInSample(sampleId,numAlignedReadsInSample);
  if (outputFilename == null) {
    if (writeAnnotationCounts) {
      final String outputFileTmp=FilenameUtils.removeExtension(inputFile) + ""String_Node_Str"";
      writer=new BufferedWriter(new FileWriter(outputFileTmp));
      writer.write(""String_Node_Str"");
    }
  }
  writeAnnotationCounts(allAnnots,writer,inputBasename,referenceIds,algs,referencesToProcess);
  if (outputFilename == null) {
    IOUtils.closeQuietly(writer);
  }
}"
50385,"private Object2ObjectMap<String,ObjectList<Annotation>> filterAnnotations(Object2ObjectMap<String,ObjectList<Annotation>> map,GenomicRange genomicRange){
  if (genomicRange == null) {
    return map;
  }
  Object2ObjectMap<String,ObjectList<Annotation>> filtered=new Object2ObjectArrayMap<String,ObjectList<Annotation>>();
  for (  Map.Entry<String,ObjectList<Annotation>> entry : map.entrySet()) {
    String key=entry.getKey();
    String chromosome=key;
    for (    final Annotation value : entry.getValue()) {
      chromosome=value.getChromosome();
      int segmentStart=value.getStart() - 1;
      int segmentEnd=value.getEnd() - 1;
      if (genomicRange.fullyContains(chromosome,segmentStart,segmentEnd)) {
        ObjectList<Annotation> chromosomeList=filtered.get(key);
        if (chromosomeList == null) {
          chromosomeList=new ObjectArrayList<Annotation>();
          filtered.put(key,chromosomeList);
        }
        chromosomeList.add(value);
      }
    }
  }
  return filtered;
}","private Object2ObjectMap<String,ObjectList<Annotation>> filterAnnotations(Object2ObjectMap<String,ObjectList<Annotation>> map,GenomicRange genomicRange){
  if (genomicRange == null) {
    return map;
  }
  Object2ObjectMap<String,ObjectList<Annotation>> filtered=new Object2ObjectArrayMap<String,ObjectList<Annotation>>();
  for (  Map.Entry<String,ObjectList<Annotation>> entry : map.entrySet()) {
    String key=entry.getKey();
    String chromosome=key;
    for (    final Annotation value : entry.getValue()) {
      chromosome=value.getChromosome();
      int segmentStart=value.getStart() - 1;
      int segmentEnd=value.getEnd() - 1;
      if (genomicRange.fullyContains(chromosome,segmentStart,segmentEnd)) {
        ObjectList<Annotation> chromosomeList=filtered.get(key);
        if (chromosomeList == null) {
          chromosomeList=new ObjectArrayList<Annotation>();
          filtered.put(key,chromosomeList);
        }
        chromosomeList.add(value);
      }
      AnnotationLength annotationLength=new AnnotationLength();
      annotationLength.id=value.getId();
      annotationLength.length=value.getLength();
      infoOutInstance.lengths.add(annotationLength);
    }
  }
  return filtered;
}"
50386,"private void writeInfoOutput() throws JAXBException, IOException {
  if (infoOutput != null) {
    final JAXBContext jc=JAXBContext.newInstance(InfoOutput.class);
    final Marshaller m=jc.createMarshaller();
    InfoOutput infoOutInstance=new InfoOutput();
    for (    String sampleId : deCalculator.samples()) {
      SampleTotalCount stc=new SampleTotalCount();
      stc.sampleId=sampleId;
      stc.totalCount=deCalculator.getNumAlignedInSample(sampleId);
      infoOutInstance.totalCounts.add(stc);
    }
    for (    MutableString elementId : deCalculator.getElementIds()) {
      AnnotationLength ae=new AnnotationLength();
      ae.length=deCalculator.getElementLength(elementId);
      ae.id=elementId.toString();
      infoOutInstance.lengths.add(ae);
    }
    FileWriter fileWriter=new FileWriter(infoOutput);
    m.marshal(infoOutInstance,fileWriter);
    fileWriter.close();
  }
}","private void writeInfoOutput() throws JAXBException, IOException {
  if (infoOutputFilename != null) {
    final JAXBContext jc=JAXBContext.newInstance(InfoOutput.class);
    final Marshaller m=jc.createMarshaller();
    for (    String sampleId : deCalculator.samples()) {
      SampleTotalCount stc=new SampleTotalCount();
      stc.sampleId=sampleId;
      stc.totalCount=deCalculator.getNumAlignedInSample(sampleId);
      System.out.println(stc);
      infoOutInstance.totalCounts.add(stc);
    }
    FileWriter fileWriter=new FileWriter(infoOutputFilename);
    m.marshal(infoOutInstance,fileWriter);
    fileWriter.close();
  }
}"
50387,"/** 
 * Load the input file into deCalculator.
 * @param inputFilename tab-delimited intut file produced by alignment-to-annotation-counts
 * @param sampleIds     sample identifiers.
 * @throws IOException if an error occurs reading the input file.
 */
private void loadInput(final String inputFilename,final int numElements,final String[] sampleIds) throws IOException {
  final TSVReader reader=new TSVReader(new FileReader(inputFilename),'\t');
  if (reader.hasNext()) {
    reader.next();
  }
  deCalculator.reserve(numElements,sampleIds.length);
  int numLines=0;
  while (reader.hasNext()) {
    if (reader.isCommentLine()) {
      reader.skip();
    }
 else {
      reader.next();
      numLines++;
      final String elementId=reader.getString();
      final String elementType=reader.getString();
      deCalculator.defineElement(elementId,DifferentialExpressionCalculator.ElementType.valueOf(elementType));
      for (      final String sample : sampleIds) {
        deCalculator.observe(sample,elementId,reader.getDouble());
      }
    }
  }
}","/** 
 * Load the input file into deCalculator.
 * @param inputFilename tab-delimited intut file produced by alignment-to-annotation-counts
 * @param sampleIds     sample identifiers.
 * @throws IOException if an error occurs reading the input file.
 */
private void loadInput(final String inputFilename,final int numElements,final String[] sampleIds) throws IOException {
  final TSVReader reader=new TSVReader(new FileReader(inputFilename),'\t');
  if (reader.hasNext()) {
    reader.next();
  }
  deCalculator.reserve(numElements,sampleIds.length);
  int numLines=0;
  while (reader.hasNext()) {
    if (reader.isCommentLine()) {
      reader.skip();
    }
 else {
      reader.next();
      numLines++;
      final String elementId=reader.getString();
      final String elementType=reader.getString();
      if (!""String_Node_Str"".equals(elementId)) {
        deCalculator.defineElement(elementId,DifferentialExpressionCalculator.ElementType.valueOf(elementType));
        for (        final String sample : sampleIds) {
          deCalculator.observe(sample,elementId,reader.getDouble());
        }
      }
    }
  }
}"
50388,"/** 
 * Declare a new statistic.
 * @param statisticId Identifier for the new statistic.
 * @return the index of the statistic.
 */
public int declareStatistic(final MutableString statisticId){
  final int index=statisticIds.registerIdentifier(statisticId);
  if (statisticId.startsWith(""String_Node_Str"")) {
    averageCountPerGroupIndexes.add(sortedStatisticIds.size());
  }
  sortedStatisticIds.add(statisticId);
  return index;
}","/** 
 * Declare a new statistic.
 * @param statisticId Identifier for the new statistic.
 * @return the index of the statistic.
 */
public int declareStatistic(final MutableString statisticId){
  final int index=statisticIds.registerIdentifier(statisticId);
  sortedStatisticIds.add(statisticId);
  return index;
}"
50389,"public void writeGenotypes(VCFWriter statsWriter,SampleCountInfo[] sampleCounts,int position){
  boolean referenceAlleleSetForIndel=false;
  siteObserved=false;
  boolean siteHasIndel=false;
  referenceSet.clear();
  for (int sampleIndex=0; sampleIndex < numberOfSamples; sampleIndex++) {
    alleleSet.clear();
    SampleCountInfo sci=sampleCounts[sampleIndex];
    int totalCount=0;
    for (int genotypeIndex=0; genotypeIndex < sci.getGenotypeMaxIndex(); ++genotypeIndex) {
      final int sampleCount=sci.getGenotypeCount(genotypeIndex);
      totalCount+=sampleCount;
    }
    statsWriter.setSampleValue(goodBaseCountFieldIndex,sampleIndex,totalCount);
    statsWriter.setSampleValue(failBaseCountFieldIndex,sampleIndex,sci.failedCount);
    int baseIndex=0;
    int altGenotypeCount=0;
    genotypeBuffer.setLength(0);
    final MutableString baseCountString=new MutableString();
    statsWriter.clearAlternateAlleles();
    for (int genotypeIndex=0; genotypeIndex < sci.getGenotypeMaxIndex(); ++genotypeIndex) {
      final int sampleCount=sci.getGenotypeCount(genotypeIndex);
      String genotype=sci.getGenotypeString(genotypeIndex);
      if (sampleCount > 0 && genotypeIndex != SampleCountInfo.BASE_OTHER_INDEX) {
        siteObserved=true;
        if (sci.isIndel(genotypeIndex)) {
          siteHasIndel=true;
        }
        if (!sci.isReferenceGenotype(genotypeIndex)) {
          statsWriter.addAlternateAllele(genotype);
          altGenotypeCount++;
          updateReferenceSet(sci.getReferenceGenotype());
        }
 else {
          if (sci.isIndel(genotypeIndex)) {
            siteHasIndel=true;
            genotype=sci.getReferenceGenotype();
          }
          updateReferenceSet(genotype);
        }
        alleleSet.add(genotype);
        genotypeBuffer.append(genotype);
        genotypeBuffer.append('/');
      }
      baseCountString.append(genotype);
      baseCountString.append('=');
      baseCountString.append(Integer.toString(sampleCount));
      baseCountString.append(',');
    }
    if (alleleSet.size() == 1) {
      genotypeBuffer.append(genotypeBuffer.copy());
    }
    baseCountString.setLength(baseCountString.length() - 1);
    statsWriter.setSampleValue(baseCountFieldIndex,sampleIndex,baseCountString);
    if (siteObserved) {
      if (genotypeBuffer.length() > 1) {
        genotypeBuffer.setLength(genotypeBuffer.length() - 1);
      }
      if (referenceSet.size() <= 1) {
        if (referenceSet.isEmpty()) {
          statsWriter.setReferenceAllele(sci.getReferenceGenotype());
        }
 else {
          statsWriter.setReferenceAllele(referenceSet.toArray(singleton)[0]);
        }
      }
 else {
        LOG.error(String.format(""String_Node_Str"",position,referenceSet));
        int maxLength=0;
        for (        final String ref : referenceSet) {
          if (ref.length() > maxLength) {
            statsWriter.setReferenceAllele(ref);
            maxLength=ref.length();
          }
        }
      }
      statsWriter.setSampleValue(genotypeFieldIndex,sampleIndex,statsWriter.codeGenotype(genotypeBuffer.toString()));
    }
 else {
      statsWriter.setSampleValue(genotypeFieldIndex,sampleIndex,""String_Node_Str"");
    }
  }
  if (indelFlagFieldIndex != -1) {
    statsWriter.setFlag(indelFlagFieldIndex,siteHasIndel);
  }
}","public void writeGenotypes(VCFWriter statsWriter,SampleCountInfo[] sampleCounts,int position){
  boolean referenceAlleleSetForIndel=false;
  siteObserved=false;
  boolean siteHasIndel=false;
  referenceSet.clear();
  statsWriter.clearAlternateAlleles();
  for (int sampleIndex=0; sampleIndex < numberOfSamples; sampleIndex++) {
    alleleSet.clear();
    SampleCountInfo sci=sampleCounts[sampleIndex];
    int totalCount=0;
    for (int genotypeIndex=0; genotypeIndex < sci.getGenotypeMaxIndex(); ++genotypeIndex) {
      final int sampleCount=sci.getGenotypeCount(genotypeIndex);
      totalCount+=sampleCount;
    }
    statsWriter.setSampleValue(goodBaseCountFieldIndex,sampleIndex,totalCount);
    statsWriter.setSampleValue(failBaseCountFieldIndex,sampleIndex,sci.failedCount);
    int baseIndex=0;
    int altGenotypeCount=0;
    genotypeBuffer.setLength(0);
    final MutableString baseCountString=new MutableString();
    for (int genotypeIndex=0; genotypeIndex < sci.getGenotypeMaxIndex(); ++genotypeIndex) {
      final int sampleCount=sci.getGenotypeCount(genotypeIndex);
      String genotype=sci.getGenotypeString(genotypeIndex);
      if (sampleCount > 0 && genotypeIndex != SampleCountInfo.BASE_OTHER_INDEX) {
        siteObserved=true;
        if (sci.isIndel(genotypeIndex)) {
          siteHasIndel=true;
        }
        if (!sci.isReferenceGenotype(genotypeIndex)) {
          statsWriter.addAlternateAllele(genotype);
          altGenotypeCount++;
          updateReferenceSet(sci.getReferenceGenotype());
        }
 else {
          if (sci.isIndel(genotypeIndex)) {
            siteHasIndel=true;
            genotype=sci.getReferenceGenotype();
          }
          updateReferenceSet(genotype);
        }
        alleleSet.add(genotype);
        genotypeBuffer.append(genotype);
        genotypeBuffer.append('/');
      }
      baseCountString.append(genotype);
      baseCountString.append('=');
      baseCountString.append(Integer.toString(sampleCount));
      baseCountString.append(',');
    }
    if (alleleSet.size() == 1) {
      genotypeBuffer.append(genotypeBuffer.copy());
    }
    baseCountString.setLength(baseCountString.length() - 1);
    statsWriter.setSampleValue(baseCountFieldIndex,sampleIndex,baseCountString);
    if (siteObserved) {
      if (genotypeBuffer.length() > 1) {
        genotypeBuffer.setLength(genotypeBuffer.length() - 1);
      }
      if (referenceSet.size() <= 1) {
        if (referenceSet.isEmpty()) {
          statsWriter.setReferenceAllele(sci.getReferenceGenotype());
        }
 else {
          statsWriter.setReferenceAllele(referenceSet.toArray(singleton)[0]);
        }
      }
 else {
        LOG.error(String.format(""String_Node_Str"",position,referenceSet));
        int maxLength=0;
        for (        final String ref : referenceSet) {
          if (ref.length() > maxLength) {
            statsWriter.setReferenceAllele(ref);
            maxLength=ref.length();
          }
        }
      }
      statsWriter.setSampleValue(genotypeFieldIndex,sampleIndex,statsWriter.codeGenotype(genotypeBuffer.toString()));
    }
 else {
      statsWriter.setSampleValue(genotypeFieldIndex,sampleIndex,""String_Node_Str"");
    }
  }
  if (indelFlagFieldIndex != -1) {
    statsWriter.setFlag(indelFlagFieldIndex,siteHasIndel);
  }
}"
50390,"public void writeGenotypes(VCFWriter statsWriter,SampleCountInfo[] sampleCounts,int position){
  boolean referenceAlleleSetForIndel=false;
  siteObserved=false;
  boolean siteHasIndel=false;
  referenceSet.clear();
  for (int sampleIndex=0; sampleIndex < numberOfSamples; sampleIndex++) {
    alleleSet.clear();
    SampleCountInfo sci=sampleCounts[sampleIndex];
    int totalCount=0;
    for (int genotypeIndex=0; genotypeIndex < sci.getGenotypeMaxIndex(); ++genotypeIndex) {
      final int sampleCount=sci.getGenotypeCount(genotypeIndex);
      totalCount+=sampleCount;
    }
    statsWriter.setSampleValue(goodBaseCountFieldIndex,sampleIndex,totalCount);
    statsWriter.setSampleValue(failBaseCountFieldIndex,sampleIndex,sci.failedCount);
    int baseIndex=0;
    int altGenotypeCount=0;
    genotypeBuffer.setLength(0);
    final MutableString baseCountString=new MutableString();
    for (int genotypeIndex=0; genotypeIndex < sci.getGenotypeMaxIndex(); ++genotypeIndex) {
      final int sampleCount=sci.getGenotypeCount(genotypeIndex);
      String genotype=sci.getGenotypeString(genotypeIndex);
      if (sampleCount > 0 && genotypeIndex != SampleCountInfo.BASE_OTHER_INDEX) {
        siteObserved=true;
        if (sci.isIndel(genotypeIndex)) {
          siteHasIndel=true;
        }
        if (!sci.isReferenceGenotype(genotypeIndex)) {
          statsWriter.addAlternateAllele(genotype);
          altGenotypeCount++;
          updateReferenceSet(sci.getReferenceGenotype());
        }
 else {
          if (sci.isIndel(genotypeIndex)) {
            siteHasIndel=true;
            genotype=sci.getReferenceGenotype();
          }
          updateReferenceSet(genotype);
        }
        alleleSet.add(genotype);
        genotypeBuffer.append(genotype);
        genotypeBuffer.append('/');
      }
      baseCountString.append(genotype);
      baseCountString.append('=');
      baseCountString.append(Integer.toString(sampleCount));
      baseCountString.append(',');
    }
    if (alleleSet.size() == 1) {
      genotypeBuffer.append(genotypeBuffer.copy());
    }
    baseCountString.setLength(baseCountString.length() - 1);
    statsWriter.setSampleValue(baseCountFieldIndex,sampleIndex,baseCountString);
    if (siteObserved) {
      if (genotypeBuffer.length() > 1) {
        genotypeBuffer.setLength(genotypeBuffer.length() - 1);
      }
      if (referenceSet.size() <= 1) {
        if (referenceSet.isEmpty()) {
          statsWriter.setReferenceAllele(sci.getReferenceGenotype());
        }
 else {
          statsWriter.setReferenceAllele(referenceSet.toArray(singleton)[0]);
        }
      }
 else {
        LOG.error(String.format(""String_Node_Str"",position,referenceSet));
        int maxLength=0;
        for (        final String ref : referenceSet) {
          if (ref.length() > maxLength) {
            statsWriter.setReferenceAllele(ref);
            maxLength=ref.length();
          }
        }
      }
      statsWriter.setSampleValue(genotypeFieldIndex,sampleIndex,statsWriter.codeGenotype(genotypeBuffer.toString()));
    }
 else {
      statsWriter.setSampleValue(genotypeFieldIndex,sampleIndex,""String_Node_Str"");
    }
  }
  if (indelFlagFieldIndex != -1) {
    statsWriter.setFlag(indelFlagFieldIndex,siteHasIndel);
  }
}","public void writeGenotypes(VCFWriter statsWriter,SampleCountInfo[] sampleCounts,int position){
  boolean referenceAlleleSetForIndel=false;
  siteObserved=false;
  boolean siteHasIndel=false;
  referenceSet.clear();
  for (int sampleIndex=0; sampleIndex < numberOfSamples; sampleIndex++) {
    alleleSet.clear();
    SampleCountInfo sci=sampleCounts[sampleIndex];
    int totalCount=0;
    for (int genotypeIndex=0; genotypeIndex < sci.getGenotypeMaxIndex(); ++genotypeIndex) {
      final int sampleCount=sci.getGenotypeCount(genotypeIndex);
      totalCount+=sampleCount;
    }
    statsWriter.setSampleValue(goodBaseCountFieldIndex,sampleIndex,totalCount);
    statsWriter.setSampleValue(failBaseCountFieldIndex,sampleIndex,sci.failedCount);
    int baseIndex=0;
    int altGenotypeCount=0;
    genotypeBuffer.setLength(0);
    final MutableString baseCountString=new MutableString();
    statsWriter.clearAlternateAlleles();
    for (int genotypeIndex=0; genotypeIndex < sci.getGenotypeMaxIndex(); ++genotypeIndex) {
      final int sampleCount=sci.getGenotypeCount(genotypeIndex);
      String genotype=sci.getGenotypeString(genotypeIndex);
      if (sampleCount > 0 && genotypeIndex != SampleCountInfo.BASE_OTHER_INDEX) {
        siteObserved=true;
        if (sci.isIndel(genotypeIndex)) {
          siteHasIndel=true;
        }
        if (!sci.isReferenceGenotype(genotypeIndex)) {
          statsWriter.addAlternateAllele(genotype);
          altGenotypeCount++;
          updateReferenceSet(sci.getReferenceGenotype());
        }
 else {
          if (sci.isIndel(genotypeIndex)) {
            siteHasIndel=true;
            genotype=sci.getReferenceGenotype();
          }
          updateReferenceSet(genotype);
        }
        alleleSet.add(genotype);
        genotypeBuffer.append(genotype);
        genotypeBuffer.append('/');
      }
      baseCountString.append(genotype);
      baseCountString.append('=');
      baseCountString.append(Integer.toString(sampleCount));
      baseCountString.append(',');
    }
    if (alleleSet.size() == 1) {
      genotypeBuffer.append(genotypeBuffer.copy());
    }
    baseCountString.setLength(baseCountString.length() - 1);
    statsWriter.setSampleValue(baseCountFieldIndex,sampleIndex,baseCountString);
    if (siteObserved) {
      if (genotypeBuffer.length() > 1) {
        genotypeBuffer.setLength(genotypeBuffer.length() - 1);
      }
      if (referenceSet.size() <= 1) {
        if (referenceSet.isEmpty()) {
          statsWriter.setReferenceAllele(sci.getReferenceGenotype());
        }
 else {
          statsWriter.setReferenceAllele(referenceSet.toArray(singleton)[0]);
        }
      }
 else {
        LOG.error(String.format(""String_Node_Str"",position,referenceSet));
        int maxLength=0;
        for (        final String ref : referenceSet) {
          if (ref.length() > maxLength) {
            statsWriter.setReferenceAllele(ref);
            maxLength=ref.length();
          }
        }
      }
      statsWriter.setSampleValue(genotypeFieldIndex,sampleIndex,statsWriter.codeGenotype(genotypeBuffer.toString()));
    }
 else {
      statsWriter.setSampleValue(genotypeFieldIndex,sampleIndex,""String_Node_Str"");
    }
  }
  if (indelFlagFieldIndex != -1) {
    statsWriter.setFlag(indelFlagFieldIndex,siteHasIndel);
  }
}"
50391,"private MutableString constructAlleleString(ObjectArrayList<String> alleles,ObjectArrayList<String> excludedAlleles){
  buffer.setLength(0);
  int max=alleles.size();
  int index=0;
  for (  String allele : alleles) {
    index++;
    if (!excludedAlleles.contains(allele)) {
      buffer.append(allele);
      if (index != max)       buffer.append(',');
    }
  }
  if (buffer.length() == 0) {
    buffer.append('.');
  }
  return buffer;
}","private MutableString constructAlleleString(ObjectArrayList<String> refAlleles){
  buffer.setLength(0);
  int max=refAlleles.size();
  int index=0;
  for (  String allele : refAlleles) {
    buffer.append(allele);
    if (++index != max)     buffer.append(',');
  }
  if (buffer.length() == 0) {
    buffer.append('.');
  }
  return buffer;
}"
50392,"private RandomAccessSequenceInterface configureGenome(JSAPResult jsapResult) throws IOException {
  if (testGenome != null) {
    return testGenome;
  }
  final String genome=jsapResult.getString(""String_Node_Str"");
  RandomAccessSequenceCache cache=null;
  if (genome != null) {
    try {
      System.err.println(""String_Node_Str"" + genome);
      cache=new RandomAccessSequenceCache();
      cache.load(genome);
    }
 catch (    ClassNotFoundException e) {
      System.err.println(""String_Node_Str"");
      e.printStackTrace();
      System.exit(1);
    }
  }
  return cache;
}","public static RandomAccessSequenceInterface configureGenome(RandomAccessSequenceInterface testGenome,JSAPResult jsapResult) throws IOException {
  if (testGenome != null) {
    return testGenome;
  }
  final String genome=jsapResult.getString(""String_Node_Str"");
  RandomAccessSequenceCache cache=null;
  if (genome != null) {
    try {
      System.err.println(""String_Node_Str"" + genome);
      cache=new RandomAccessSequenceCache();
      cache.load(genome);
    }
 catch (    ClassNotFoundException e) {
      System.err.println(""String_Node_Str"");
      e.printStackTrace();
      System.exit(1);
    }
  }
  return cache;
}"
50393,"/** 
 * Construct an index for counts data given as a byte array.
 * @param countBytes The compressed counts data to read with CountsReader
 * @param indexPart  The data output where to write the index.
 * @throws IOException If an error occurs writing the index or reading the counts.
 */
public void buildIndex(byte[] countBytes,DataOutput indexPart) throws IOException {
  final InputStream stream=new ByteArrayInputStream(countBytes);
  InputBitStream inputBitStream=new InputBitStream(stream);
  final CountsReaderI reader=new CountsReader(inputBitStream);
  int transitionNum=0;
  long bitsWritten=0;
  while (reader.hasNextTransition()) {
    reader.nextTransition();
    int position=reader.getPosition();
    int count=reader.getCount();
    ++transitionNum;
    if (transitionNum % transitionsPerIndex == 0) {
      offsets.add((int)bitsWritten);
      positions.add(position);
      counts.add(count);
      ++numIndexEntries;
    }
    bitsWritten=inputBitStream.readBits();
  }
  indexPart.writeInt(numIndexEntries);
  BinIO.storeInts(positions.toIntArray(),indexPart);
  BinIO.storeInts(offsets.toIntArray(),indexPart);
  BinIO.storeInts(counts.toIntArray(),indexPart);
}","/** 
 * Construct an index for counts data given as a byte array.
 * @param countBytes The compressed counts data to read with CountsReader
 * @param indexPart  The data output where to write the index.
 * @throws IOException If an error occurs writing the index or reading the counts.
 */
public void buildIndex(byte[] countBytes,DataOutput indexPart) throws IOException {
}"
50394,"/** 
 * Reposition the reader on a genomic position. In contrast to skipTo, this method reposition to any position, including position that occured before the position returned last by getPosition().
 * @param position Position to seek to.
 * @throws IOException If an error occurs accessing the index or counts data.
 */
public void reposition(final int position) throws IOException {
  if (!hasIndex) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final int r=Arrays.binarySearch(positions,position);
  final int ip=r >= 0 ? r : -(r + 1);
  final int index=r >= 0 ? r : Math.max(0,ip);
  int priorIndex=index - 1;
  if (priorIndex < 0 || index >= positions.length) {
    this.position=position;
    this.count=0;
    deltaCount=0;
    nextTransitionLoaded=false;
    input.position(0);
    endOfStream=false;
    return;
  }
  if (positions[index] == position) {
    this.position=position;
    this.count=counts[index];
    deltaCount=0;
    nextTransitionLoaded=false;
    input.position(offsets[index]);
    endOfStream=false;
    input.readGamma();
    length=input.readGamma();
    return;
  }
 else {
    this.position=positions[priorIndex];
    count=priorIndex < 0 ? 0 : counts[priorIndex];
    input.position(offsets[priorIndex]);
    endOfStream=false;
    nextTransitionLoaded=false;
    currentCount=count;
    deltaCount=0;
    length=0;
    input.readGamma();
    length=input.readGamma();
    while (hasNextTransition()) {
      nextTransition();
      if (getPosition() >= position) {
        break;
      }
    }
  }
}","/** 
 * Reposition the reader on a genomic position. In contrast to skipTo, this method reposition to any position, including position that occured before the position returned last by getPosition().
 * @param position Position to seek to.
 * @throws IOException If an error occurs accessing the index or counts data.
 */
public void reposition(final int position) throws IOException {
  if (!hasIndex) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final int r=Arrays.binarySearch(positions,position);
  final int ip=r >= 0 ? r : -(r + 1);
  final int index=r >= 0 ? r : Math.max(0,ip);
  int priorIndex=index - 1;
  if (index == positions.length) {
    endOfStream=true;
    return;
  }
  if (priorIndex < 0 || index >= positions.length) {
    this.position=position;
    this.count=0;
    deltaCount=0;
    nextTransitionLoaded=false;
    input.position(0);
    endOfStream=false;
    return;
  }
  if (positions[index] == position) {
    this.position=position;
    this.count=counts[index];
    deltaCount=0;
    nextTransitionLoaded=false;
    input.position(offsets[index]);
    endOfStream=false;
    input.readGamma();
    length=input.readGamma();
    return;
  }
 else {
    this.position=positions[priorIndex];
    count=priorIndex < 0 ? 0 : counts[priorIndex];
    input.position(offsets[priorIndex]);
    endOfStream=false;
    nextTransitionLoaded=false;
    currentCount=count;
    deltaCount=0;
    length=0;
    input.readGamma();
    length=input.readGamma();
    while (hasNextTransition()) {
      nextTransition();
      if (getPosition() >= position) {
        break;
      }
    }
  }
}"
50395,"public boolean hasNextDataLine(){
  if (hasNextDataLine) {
    return true;
  }
  hasNextDataLine=lineIterator.hasNext();
  if (hasNextDataLine) {
    line=lineIterator.next();
    parseCurrentLine();
  }
  return hasNextDataLine;
}","public boolean hasNextDataLine(){
  if (hasNextDataLine) {
    return true;
  }
  hasNextDataLine=lineIterator.hasNext();
  if (hasNextDataLine) {
    line=lineIterator.next();
    if (!TSV) {
      parseCurrentLine();
    }
 else {
      parseTSVLine();
    }
  }
  return hasNextDataLine;
}"
50396,"/** 
 * Read the header of this file. Headers in the VCF format are supported, as well as TSV single header lines (with or without first character #.
 * @throws SyntaxException When the syntax of the VCF file is incorrect.
 */
public void readHeader() throws SyntaxException {
  if (headerParsed)   return;
  headerParsed=true;
  globalFieldIndex=0;
  fieldIndexToName=new Int2ObjectOpenHashMap<String>();
  bufferedReader=new FastBufferedReader(input);
  lineIterator=new LineIterator(bufferedReader);
  int lineNumber=1;
  while (lineIterator.hasNext()) {
    line=lineIterator.next();
    if (line.startsWith(""String_Node_Str"")) {
      TSV=false;
    }
    if (!line.startsWith(""String_Node_Str"")) {
      if (TSV && lineNumber == 1 && headerLineNotParsed) {
        parseHeaderLine(new MutableString(""String_Node_Str"" + line));
      }
 else {
        parseCurrentLine();
        hasNextDataLine=true;
      }
      break;
    }
    if (line.startsWith(""String_Node_Str"")) {
      TSV=false;
      processMetaInfoLine(line);
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      parseHeaderLine(line);
    }
    lineNumber++;
  }
}","/** 
 * Read the header of this file. Headers in the VCF format are supported, as well as TSV single header lines (with or without first character #.
 * @throws SyntaxException When the syntax of the VCF file is incorrect.
 */
public void readHeader() throws SyntaxException {
  if (headerParsed)   return;
  headerParsed=true;
  globalFieldIndex=0;
  fieldIndexToName=new Int2ObjectOpenHashMap<String>();
  bufferedReader=new FastBufferedReader(input);
  lineIterator=new LineIterator(bufferedReader);
  int lineNumber=1;
  while (lineIterator.hasNext()) {
    line=lineIterator.next();
    if (line.startsWith(""String_Node_Str"")) {
      TSV=false;
    }
    if (!line.startsWith(""String_Node_Str"")) {
      if (TSV && lineNumber == 1 && headerLineNotParsed) {
        parseHeaderLine(new MutableString(""String_Node_Str"" + line));
      }
 else {
        if (!TSV) {
          parseCurrentLine();
        }
 else {
          parseTSVLine();
        }
        hasNextDataLine=true;
      }
      break;
    }
    if (line.startsWith(""String_Node_Str"")) {
      TSV=false;
      processMetaInfoLine(line);
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      parseHeaderLine(line);
    }
    lineNumber++;
  }
}"
50397,"private void parseCurrentLine(){
  Arrays.fill(columnStarts,0);
  Arrays.fill(columnEnds,0);
  Arrays.fill(fieldStarts,0);
  Arrays.fill(fieldEnds,0);
  columnStarts[0]=0;
  int columnIndex=0;
  int fieldIndex=0;
  lineLength=line.length();
  int lineFieldIndexToColumnIndex[]=new int[numberOfFields];
  Arrays.fill(lineFieldIndexToColumnIndex,-1);
  previousColumnFieldIndices.clear();
  for (int i=0; i < lineLength; i++) {
    final char c=line.charAt(i);
    if (c == columnSeparatorCharacter) {
      columnEnds[columnIndex]=i;
      if (columnIndex + 1 < numberOfColumns) {
        columnStarts[columnIndex + 1]=i + 1;
      }
    }
    if (c == columnSeparatorCharacter || c == fieldSeparatorCharacter || (columnIndex >= formatColumnIndex && c == formatFieldSeparatorCharacter)) {
      if (TSV) {
        fieldEnds[columnIndex]=columnEnds[columnIndex];
        fieldStarts[columnIndex]=columnStarts[columnIndex];
        fieldIndex=columnIndex;
        lineFieldIndexToColumnIndex[fieldIndex]=columnIndex;
      }
 else {
        fieldEnds[fieldIndex]=i;
        if (fieldIndex + 1 < numberOfFields) {
          fieldStarts[fieldIndex + 1]=i + 1;
        }
        previousColumnFieldIndices.add(fieldIndex);
        fieldIndex++;
      }
    }
    if (c == columnSeparatorCharacter) {
      if (TSV) {
        lineFieldIndexToColumnIndex[fieldIndex]=columnIndex;
      }
      push(columnIndex,lineFieldIndexToColumnIndex,previousColumnFieldIndices);
      columnIndex++;
    }
  }
  int numberOfFieldsOnLine=fieldIndex;
  int numberOfColumnsOnLine=columnIndex;
  columnStarts[0]=0;
  columnEnds[numberOfColumnsOnLine - (TSV ? 1 : 0)]=line.length();
  fieldStarts[0]=0;
  fieldEnds[numberOfFieldsOnLine - (TSV ? 1 : 0)]=line.length();
  previousColumnFieldIndices.add(fieldIndex);
  push(columnIndex,lineFieldIndexToColumnIndex,previousColumnFieldIndices);
  Arrays.fill(fieldPermutation,-1);
  for (  ColumnInfo c : columns) {
    c.formatIndex=0;
  }
  for (int lineFieldIndex=0; lineFieldIndex <= numberOfFieldsOnLine; lineFieldIndex++) {
    int start=fieldStarts[lineFieldIndex];
    int end=fieldEnds[lineFieldIndex];
    final int cIndex=lineFieldIndexToColumnIndex[lineFieldIndex];
    if (cIndex >= columnList.size()) {
      break;
    }
    ColumnInfo column=columnList.get(cIndex);
    int colMinGlobalFieldIndex=Integer.MAX_VALUE;
    int colMaxGlobalFieldIndex=Integer.MIN_VALUE;
    final ColumnFields fields=column.fields;
    fields.rebuildList();
    for (int fi=0; fi < fields.size(); ++fi) {
      ColumnField f=fields.get(fi);
      colMinGlobalFieldIndex=Math.min(colMinGlobalFieldIndex,f.globalFieldIndex);
      colMaxGlobalFieldIndex=Math.max(colMaxGlobalFieldIndex,f.globalFieldIndex);
    }
    final int formatColumnIndex=TSV ? -1 : formatColumn.columnIndex;
    final int startFormatColumn=TSV ? 0 : columnStarts[formatColumnIndex];
    final int endFormatColumn=TSV ? 0 : columnEnds[formatColumnIndex];
    final String[] formatTokens=split(line,formatFieldSeparatorCharacter,startFormatColumn,endFormatColumn);
    for (int fi=0; fi < fields.size(); ++fi) {
      final ColumnField f=fields.get(fi);
      if (fieldPermutation[f.globalFieldIndex] != -1) {
        continue;
      }
      if (colMaxGlobalFieldIndex == colMinGlobalFieldIndex) {
        fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
        break;
      }
 else {
        int j=start;
        final String id=f.id;
        int matchLength=0;
        for (int i=0; i < id.length(); i++) {
          if (j >= end) {
            break;
          }
          final char linechar=line.charAt(j);
          if (id.charAt(i) != linechar) {
            matchLength=-1;
            break;
          }
          matchLength++;
          j++;
        }
        if (matchLength == id.length() && line.charAt(j) == '=' || (j == end && f.type == ColumnType.Flag)) {
          fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
          if (f.type != ColumnType.Flag) {
            fieldStarts[lineFieldIndex]+=f.id.length() + 1;
          }
          break;
        }
 else {
          if (column.useFormat && column.formatIndex < formatTokens.length) {
            if (f.id.equals(formatTokens[column.formatIndex])) {
              fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
              column.formatIndex++;
              break;
            }
          }
        }
      }
    }
  }
}","private void parseCurrentLine(){
  Arrays.fill(columnStarts,0);
  Arrays.fill(columnEnds,0);
  Arrays.fill(fieldStarts,0);
  Arrays.fill(fieldEnds,0);
  columnStarts[0]=0;
  int columnIndex=0;
  int fieldIndex=0;
  lineLength=line.length();
  int lineFieldIndexToColumnIndex[]=new int[numberOfFields];
  Arrays.fill(lineFieldIndexToColumnIndex,-1);
  previousColumnFieldIndices.clear();
  for (int i=0; i < lineLength; i++) {
    final char c=line.charAt(i);
    if (c == columnSeparatorCharacter) {
      fieldPermutation[columnIndex]=columnIndex;
      columnEnds[columnIndex]=i;
      if (columnIndex + 1 < numberOfColumns) {
        columnStarts[columnIndex + 1]=i + 1;
      }
    }
    if (c == columnSeparatorCharacter || c == fieldSeparatorCharacter || (columnIndex >= formatColumnIndex && c == formatFieldSeparatorCharacter)) {
      if (TSV) {
        fieldEnds[columnIndex]=columnEnds[columnIndex];
        fieldStarts[columnIndex]=columnStarts[columnIndex];
        fieldIndex=columnIndex;
        lineFieldIndexToColumnIndex[fieldIndex]=columnIndex;
      }
 else {
        fieldEnds[fieldIndex]=i;
        if (fieldIndex + 1 < numberOfFields) {
          fieldStarts[fieldIndex + 1]=i + 1;
        }
        previousColumnFieldIndices.add(fieldIndex);
        fieldIndex++;
      }
    }
    if (c == columnSeparatorCharacter) {
      if (TSV) {
        lineFieldIndexToColumnIndex[fieldIndex]=columnIndex;
      }
      push(columnIndex,lineFieldIndexToColumnIndex,previousColumnFieldIndices);
      columnIndex++;
    }
  }
  int numberOfFieldsOnLine=fieldIndex;
  int numberOfColumnsOnLine=columnIndex;
  columnStarts[0]=0;
  columnEnds[numberOfColumnsOnLine - (TSV ? 1 : 0)]=line.length();
  fieldStarts[0]=0;
  fieldEnds[numberOfFieldsOnLine - (TSV ? 1 : 0)]=line.length();
  previousColumnFieldIndices.add(fieldIndex);
  push(columnIndex,lineFieldIndexToColumnIndex,previousColumnFieldIndices);
  Arrays.fill(fieldPermutation,-1);
  for (  ColumnInfo c : columns) {
    c.formatIndex=0;
  }
  for (int lineFieldIndex=0; lineFieldIndex <= numberOfFieldsOnLine; lineFieldIndex++) {
    int start=fieldStarts[lineFieldIndex];
    int end=fieldEnds[lineFieldIndex];
    final int cIndex=lineFieldIndexToColumnIndex[lineFieldIndex];
    if (cIndex >= columnList.size()) {
      break;
    }
    ColumnInfo column=columnList.get(cIndex);
    int colMinGlobalFieldIndex=Integer.MAX_VALUE;
    int colMaxGlobalFieldIndex=Integer.MIN_VALUE;
    final ColumnFields fields=column.fields;
    fields.rebuildList();
    for (int fi=0; fi < fields.size(); ++fi) {
      ColumnField f=fields.get(fi);
      colMinGlobalFieldIndex=Math.min(colMinGlobalFieldIndex,f.globalFieldIndex);
      colMaxGlobalFieldIndex=Math.max(colMaxGlobalFieldIndex,f.globalFieldIndex);
    }
    final int formatColumnIndex=TSV ? -1 : formatColumn.columnIndex;
    final int startFormatColumn=TSV ? 0 : columnStarts[formatColumnIndex];
    final int endFormatColumn=TSV ? 0 : columnEnds[formatColumnIndex];
    final String[] formatTokens=split(line,formatFieldSeparatorCharacter,startFormatColumn,endFormatColumn);
    for (int fi=0; fi < fields.size(); ++fi) {
      final ColumnField f=fields.get(fi);
      if (fieldPermutation[f.globalFieldIndex] != -1) {
        continue;
      }
      if (colMaxGlobalFieldIndex == colMinGlobalFieldIndex) {
        fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
        break;
      }
 else {
        int j=start;
        final String id=f.id;
        int matchLength=0;
        for (int i=0; i < id.length(); i++) {
          if (j >= end) {
            break;
          }
          final char linechar=line.charAt(j);
          if (id.charAt(i) != linechar) {
            matchLength=-1;
            break;
          }
          matchLength++;
          j++;
        }
        if (matchLength == id.length() && line.charAt(j) == '=' || (j == end && f.type == ColumnType.Flag)) {
          fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
          if (f.type != ColumnType.Flag) {
            fieldStarts[lineFieldIndex]+=f.id.length() + 1;
          }
          break;
        }
 else {
          if (column.useFormat && column.formatIndex < formatTokens.length) {
            if (f.id.equals(formatTokens[column.formatIndex])) {
              fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
              column.formatIndex++;
              break;
            }
          }
        }
      }
    }
  }
}"
50398,"private void parseCurrentLine(){
  Arrays.fill(columnStarts,0);
  Arrays.fill(columnEnds,0);
  Arrays.fill(fieldStarts,0);
  Arrays.fill(fieldEnds,0);
  columnStarts[0]=0;
  int columnIndex=0;
  int fieldIndex=0;
  lineLength=line.length();
  int lineFieldIndexToColumnIndex[]=new int[numberOfFields];
  Arrays.fill(lineFieldIndexToColumnIndex,-1);
  previousColumnFieldIndices.clear();
  for (int i=0; i < lineLength; i++) {
    final char c=line.charAt(i);
    if (c == columnSeparatorCharacter) {
      columnEnds[columnIndex]=i;
      if (columnIndex + 1 < numberOfColumns) {
        columnStarts[columnIndex + 1]=i + 1;
      }
    }
    if (c == columnSeparatorCharacter || c == fieldSeparatorCharacter || (columnIndex >= formatColumnIndex && c == formatFieldSeparatorCharacter)) {
      if (TSV) {
        fieldEnds[columnIndex]=columnEnds[columnIndex];
        fieldStarts[columnIndex]=columnStarts[columnIndex];
        fieldIndex=columnIndex;
        lineFieldIndexToColumnIndex[fieldIndex]=columnIndex;
      }
 else {
        fieldEnds[fieldIndex]=i;
        if (fieldIndex + 1 < numberOfFields) {
          fieldStarts[fieldIndex + 1]=i + 1;
        }
        previousColumnFieldIndices.add(fieldIndex);
        fieldIndex++;
      }
    }
    if (c == columnSeparatorCharacter) {
      push(columnIndex,lineFieldIndexToColumnIndex,previousColumnFieldIndices);
      columnIndex++;
    }
  }
  int numberOfFieldsOnLine=fieldIndex;
  int numberOfColumnsOnLine=columnIndex;
  columnStarts[0]=0;
  columnEnds[numberOfColumnsOnLine]=line.length();
  fieldStarts[0]=0;
  fieldEnds[numberOfFieldsOnLine]=line.length();
  previousColumnFieldIndices.add(fieldIndex);
  push(columnIndex,lineFieldIndexToColumnIndex,previousColumnFieldIndices);
  Arrays.fill(fieldPermutation,-1);
  for (  ColumnInfo c : columns) {
    c.formatIndex=0;
  }
  for (int lineFieldIndex=0; lineFieldIndex <= numberOfFieldsOnLine; lineFieldIndex++) {
    int start=fieldStarts[lineFieldIndex];
    int end=fieldEnds[lineFieldIndex];
    final int cIndex=lineFieldIndexToColumnIndex[lineFieldIndex];
    ColumnInfo column=columnList.get(cIndex);
    int colMinGlobalFieldIndex=Integer.MAX_VALUE;
    int colMaxGlobalFieldIndex=Integer.MIN_VALUE;
    final ColumnFields fields=column.fields;
    fields.rebuildList();
    for (int fi=0; fi < fields.size(); ++fi) {
      ColumnField f=fields.get(fi);
      colMinGlobalFieldIndex=Math.min(colMinGlobalFieldIndex,f.globalFieldIndex);
      colMaxGlobalFieldIndex=Math.max(colMaxGlobalFieldIndex,f.globalFieldIndex);
    }
    final int formatColumnIndex=TSV ? -1 : formatColumn.columnIndex;
    final int startFormatColumn=TSV ? 0 : columnStarts[formatColumnIndex];
    final int endFormatColumn=TSV ? 0 : columnEnds[formatColumnIndex];
    final String[] formatTokens=split(line,formatFieldSeparatorCharacter,startFormatColumn,endFormatColumn);
    for (int fi=0; fi < fields.size(); ++fi) {
      final ColumnField f=fields.get(fi);
      if (fieldPermutation[f.globalFieldIndex] != -1) {
        continue;
      }
      if (colMaxGlobalFieldIndex == colMinGlobalFieldIndex) {
        fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
        break;
      }
 else {
        int j=start;
        final String id=f.id;
        int matchLength=0;
        for (int i=0; i < id.length(); i++) {
          if (j >= end) {
            break;
          }
          final char linechar=line.charAt(j);
          if (id.charAt(i) != linechar) {
            matchLength=-1;
            break;
          }
          matchLength++;
          j++;
        }
        if (matchLength == id.length() && line.charAt(j) == '=' || (j == end && f.type == ColumnType.Flag)) {
          fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
          if (f.type != ColumnType.Flag) {
            fieldStarts[lineFieldIndex]+=f.id.length() + 1;
          }
          break;
        }
 else {
          if (column.useFormat && column.formatIndex < formatTokens.length) {
            if (f.id.equals(formatTokens[column.formatIndex])) {
              fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
              column.formatIndex++;
              break;
            }
          }
        }
      }
    }
  }
}","private void parseCurrentLine(){
  Arrays.fill(columnStarts,0);
  Arrays.fill(columnEnds,0);
  Arrays.fill(fieldStarts,0);
  Arrays.fill(fieldEnds,0);
  columnStarts[0]=0;
  int columnIndex=0;
  int fieldIndex=0;
  lineLength=line.length();
  int lineFieldIndexToColumnIndex[]=new int[numberOfFields];
  Arrays.fill(lineFieldIndexToColumnIndex,-1);
  previousColumnFieldIndices.clear();
  for (int i=0; i < lineLength; i++) {
    final char c=line.charAt(i);
    if (c == columnSeparatorCharacter) {
      columnEnds[columnIndex]=i;
      if (columnIndex + 1 < numberOfColumns) {
        columnStarts[columnIndex + 1]=i + 1;
      }
    }
    if (c == columnSeparatorCharacter || c == fieldSeparatorCharacter || (columnIndex >= formatColumnIndex && c == formatFieldSeparatorCharacter)) {
      if (TSV) {
        fieldEnds[columnIndex]=columnEnds[columnIndex];
        fieldStarts[columnIndex]=columnStarts[columnIndex];
        fieldIndex=columnIndex;
        lineFieldIndexToColumnIndex[fieldIndex]=columnIndex;
      }
 else {
        fieldEnds[fieldIndex]=i;
        if (fieldIndex + 1 < numberOfFields) {
          fieldStarts[fieldIndex + 1]=i + 1;
        }
        previousColumnFieldIndices.add(fieldIndex);
        fieldIndex++;
      }
    }
    if (c == columnSeparatorCharacter) {
      if (TSV) {
        lineFieldIndexToColumnIndex[fieldIndex]=columnIndex;
      }
      push(columnIndex,lineFieldIndexToColumnIndex,previousColumnFieldIndices);
      columnIndex++;
    }
  }
  int numberOfFieldsOnLine=fieldIndex;
  int numberOfColumnsOnLine=columnIndex;
  columnStarts[0]=0;
  columnEnds[numberOfColumnsOnLine - (TSV ? 1 : 0)]=line.length();
  fieldStarts[0]=0;
  fieldEnds[numberOfFieldsOnLine - (TSV ? 1 : 0)]=line.length();
  previousColumnFieldIndices.add(fieldIndex);
  push(columnIndex,lineFieldIndexToColumnIndex,previousColumnFieldIndices);
  Arrays.fill(fieldPermutation,-1);
  for (  ColumnInfo c : columns) {
    c.formatIndex=0;
  }
  for (int lineFieldIndex=0; lineFieldIndex <= numberOfFieldsOnLine; lineFieldIndex++) {
    int start=fieldStarts[lineFieldIndex];
    int end=fieldEnds[lineFieldIndex];
    final int cIndex=lineFieldIndexToColumnIndex[lineFieldIndex];
    if (cIndex >= columnList.size()) {
      break;
    }
    ColumnInfo column=columnList.get(cIndex);
    int colMinGlobalFieldIndex=Integer.MAX_VALUE;
    int colMaxGlobalFieldIndex=Integer.MIN_VALUE;
    final ColumnFields fields=column.fields;
    fields.rebuildList();
    for (int fi=0; fi < fields.size(); ++fi) {
      ColumnField f=fields.get(fi);
      colMinGlobalFieldIndex=Math.min(colMinGlobalFieldIndex,f.globalFieldIndex);
      colMaxGlobalFieldIndex=Math.max(colMaxGlobalFieldIndex,f.globalFieldIndex);
    }
    final int formatColumnIndex=TSV ? -1 : formatColumn.columnIndex;
    final int startFormatColumn=TSV ? 0 : columnStarts[formatColumnIndex];
    final int endFormatColumn=TSV ? 0 : columnEnds[formatColumnIndex];
    final String[] formatTokens=split(line,formatFieldSeparatorCharacter,startFormatColumn,endFormatColumn);
    for (int fi=0; fi < fields.size(); ++fi) {
      final ColumnField f=fields.get(fi);
      if (fieldPermutation[f.globalFieldIndex] != -1) {
        continue;
      }
      if (colMaxGlobalFieldIndex == colMinGlobalFieldIndex) {
        fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
        break;
      }
 else {
        int j=start;
        final String id=f.id;
        int matchLength=0;
        for (int i=0; i < id.length(); i++) {
          if (j >= end) {
            break;
          }
          final char linechar=line.charAt(j);
          if (id.charAt(i) != linechar) {
            matchLength=-1;
            break;
          }
          matchLength++;
          j++;
        }
        if (matchLength == id.length() && line.charAt(j) == '=' || (j == end && f.type == ColumnType.Flag)) {
          fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
          if (f.type != ColumnType.Flag) {
            fieldStarts[lineFieldIndex]+=f.id.length() + 1;
          }
          break;
        }
 else {
          if (column.useFormat && column.formatIndex < formatTokens.length) {
            if (f.id.equals(formatTokens[column.formatIndex])) {
              fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
              column.formatIndex++;
              break;
            }
          }
        }
      }
    }
  }
}"
50399,"@Test public void testParseNoFormatTSV() throws FileNotFoundException, VCFParser.SyntaxException {
  VCFParser parser=new VCFParser(new FileReader(""String_Node_Str""));
  parser.readHeader();
  Columns cols=parser.getColumns();
  assertNotNull(""String_Node_Str"",cols.find(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",cols.find(""String_Node_Str""));
}","@Test public void testParseNoFormatTSV() throws FileNotFoundException, VCFParser.SyntaxException {
  VCFParser parser=new VCFParser(new FileReader(""String_Node_Str""));
  parser.readHeader();
  Columns cols=parser.getColumns();
  assertNotNull(""String_Node_Str"",cols.find(""String_Node_Str""));
  assertNotNull(""String_Node_Str"",cols.find(""String_Node_Str""));
  int lastColumnIndex=parser.getGlobalFieldIndex(""String_Node_Str"",""String_Node_Str"");
  while (parser.hasNextDataLine()) {
    String colValue=parser.getFieldValue(lastColumnIndex).toString();
    System.out.println(colValue);
    assertFalse(""String_Node_Str"",colValue.contains(""String_Node_Str""));
    parser.next();
  }
}"
50400,"/** 
 * Obtain indices associated with each countReader defined in the archive. These indices are the index of each reference sequence for which counts where written to this archive.
 * @return set of reference sequence indices.
 */
public IntSet getIndices(){
  final IntSet result=new IntArraySet();
  final Collection<CompoundDirectoryEntry> directory=compoundReader.getDirectory();
  for (  final CompoundDirectoryEntry entry : directory) {
    final String name=entry.getName();
    final String[] tokens=name.split(""String_Node_Str"");
    if (tokens.length < 1) {
      return null;
    }
    result.add(Integer.parseInt(tokens[0]));
  }
  return result;
}","/** 
 * Obtain indices associated with each countReader defined in the archive. These indices are the index of each reference sequence for which counts where written to this archive.
 * @return set of reference sequence indices.
 */
public IntSet getIndices(){
  final IntSet result=new IntArraySet();
  final Collection<CompoundDirectoryEntry> directory=compoundReader.getDirectory();
  for (  final CompoundDirectoryEntry entry : directory) {
    final String name=entry.getName();
    if (!name.startsWith(""String_Node_Str"")) {
      final String[] tokens=name.split(""String_Node_Str"");
      if (tokens.length < 1) {
        return null;
      }
      result.add(Integer.parseInt(tokens[0]));
    }
  }
  return result;
}"
50401,"/** 
 * Obtain the number of count information available in this archive.
 * @return an integer.
 */
public int getNumberOfIndices(){
  return compoundReader.getDirectory().size();
}","/** 
 * Obtain the number of count information available in this archive.
 * @return an integer.
 */
public int getNumberOfIndices(){
  return identifierToIndexMap.size();
}"
50402,"/** 
 * Obtain identifiers associated with each countReader defined in the archive.
 * @return set of count information identifiers, or null if identifiers were not written in the archive.
 */
public ObjectSet<String> getIdentifiers(){
  final ObjectSet<String> result=new ObjectOpenHashSet<String>();
  final Collection<CompoundDirectoryEntry> directory=compoundReader.getDirectory();
  for (  final CompoundDirectoryEntry entry : directory) {
    final String name=entry.getName();
    final String[] tokens=name.split(""String_Node_Str"");
    if (tokens.length < 2) {
      return null;
    }
    result.add(tokens[1]);
  }
  return result;
}","/** 
 * Obtain identifiers associated with each countReader defined in the archive.
 * @return set of count information identifiers, or null if identifiers were not written in the archive.
 */
public ObjectSet<String> getIdentifiers(){
  final ObjectSet<String> result=new ObjectOpenHashSet<String>();
  final Collection<CompoundDirectoryEntry> directory=compoundReader.getDirectory();
  for (  final CompoundDirectoryEntry entry : directory) {
    final String name=entry.getName();
    if (!name.startsWith(""String_Node_Str"")) {
      final String[] tokens=name.split(""String_Node_Str"");
      if (tokens.length < 2) {
        return null;
      }
      result.add(tokens[1]);
    }
  }
  return result;
}"
50403,"/** 
 * Advance up to or past the specified position. The reader is advanced until the position returned by getPosition() is at least equal, or greater to the specified position.
 * @param position
 * @throws IOException
 */
public void skipTo(final int position) throws IOException {
  while (hasNextTransition() && this.position < position) {
    nextTransition();
  }
}","/** 
 * Advance up to or past the specified position. The reader is advanced until the position returned by getPosition() is at least equal, or greater to the specified position.
 * @param position
 * @throws IOException
 */
public void skipTo(final int position) throws IOException {
  while (hasNextTransition()) {
    nextTransition();
    if (getPosition() >= position) {
      break;
    }
  }
}"
50404,"@Test public void testComputeStarts5() throws IOException {
  initializeTestDirectory();
  final Random random=new Random();
  random.setSeed(023);
  final ComputeStartCount computer=new ComputeStartCount(ComputeStartCount.POSITIVE_STRAND_ONLY);
  for (int i=0; i < 100000; i++) {
    final int start=chooseRandom(random,1,10000);
    final int length=chooseRandom(random,10,100);
    computer.populate(start,start + length,true);
  }
  computer.populate(10010,10020,true);
  computer.populate(10010,10020,true);
  computer.populate(10011,10020,true);
  final String filename=""String_Node_Str"";
  final CountsWriter writer=new CountsWriter(new FileOutputStream(filename));
  computer.baseCount(writer);
  writer.close();
  final CountsReader reader=new CountsReader(new FileInputStream(filename));
  reader.skipTo(10003);
  assertEquals(2,reader.getCount());
  assertEquals(10010,reader.getPosition());
  reader.nextTransition();
  assertEquals(1,reader.getCount());
  assertEquals(10011,reader.getPosition());
  reader.close();
}","@Test public void testComputeStarts5() throws IOException {
  initializeTestDirectory();
  final Random random=new Random();
  random.setSeed(023);
  final ComputeStartCount computer=new ComputeStartCount(ComputeStartCount.POSITIVE_STRAND_ONLY);
  for (int i=0; i < 100000; i++) {
    final int start=chooseRandom(random,1,10000);
    final int length=chooseRandom(random,10,100);
    computer.populate(start,start + length,true);
  }
  computer.populate(10010,10020,true);
  computer.populate(10010,10020,true);
  computer.populate(10011,10020,true);
  final String filename=""String_Node_Str"";
  final CountsWriter writer=new CountsWriter(new FileOutputStream(filename));
  computer.baseCount(writer);
  writer.close();
  final CountsReader reader=new CountsReader(new FileInputStream(filename));
  reader.skipTo(10003);
  assertEquals(2,reader.getCount());
  assertEquals(10010,reader.getPosition());
  reader.hasNextTransition();
  reader.nextTransition();
  assertEquals(10011,reader.getPosition());
  assertEquals(1,reader.getCount());
  reader.close();
}"
50405,"public void setSampleValue(String formatToken,int sampleIndex,String value){
  int formatFieldIndex=formatTypeToFormatFieldIndex.get(formatToken);
  setSampleValue(formatFieldIndex,sampleIndex,value);
}","public void setSampleValue(String formatToken,int sampleIndex,String value){
  int formatFieldIndex=formatTypeToFormatFieldIndex.getInt(formatToken);
  setSampleValue(formatFieldIndex,sampleIndex,value);
}"
50406,"public ColumnField find(final int fieldIndex){
  return indexMap.get(fieldIndex);
}","public ColumnField find(final int fieldIndex){
  rebuildMap();
  return indexMap.get(fieldIndex);
}"
50407,"/** 
 * Add an element to the pool.
 * @param element element to add.
 */
public final void add(final T element){
  ++numElements;
  while (array.size() <= numElements) {
    array.add(null);
  }
  array.set(tailIndex,element);
  if (((Alignments.AlignmentEntry)element).getQueryIndex() == 540) {
    System.out.println(""String_Node_Str"");
  }
  advanceTailIndex();
}","/** 
 * Add an element to the pool.
 * @param element element to add.
 */
public final void add(final T element){
  ++numElements;
  capacity=Math.max(capacity,tailIndex + 1);
  while (array.size() <= capacity) {
    array.add(null);
  }
  array.set(tailIndex,element);
  advanceTailIndex();
}"
50408,"private void advanceTailIndex(){
  ++tailIndex;
  if (tailIndex > numElements) {
    tailIndex=0;
  }
}","private void advanceTailIndex(){
  tailIndex=tailIndex % capacity + 1;
}"
50409,"private void advanceHeadIndex(){
  ++headIndex;
  if (headIndex > numElements) {
    headIndex=0;
  }
}","private void advanceHeadIndex(){
  headIndex=headIndex % capacity + 1;
}"
50410,"/** 
 * Run the mode.
 */
@Override public void execute(){
  for (  String basename : inputBasenames) {
    try {
      final AlignmentReaderImpl alignment=new AlignmentReaderImpl(basename);
      alignment.readHeader();
      alignment.close();
      final IndexedIdentifier referenceIds=alignment.getTargetIdentifiers();
      final DoubleIndexedIdentifier backwards=new DoubleIndexedIdentifier(referenceIds);
      CountsArchiveReader archiveReader=new CountsArchiveReader(basename);
      CountsArchiveReader annotationArchiveReader=new CountsArchiveReader(annotationBasename);
      LongArrayList depthTallyInAnnotation=new LongArrayList(10000);
      LongArrayList depthTallyOutsideAnnotation=new LongArrayList(10000);
      ObjectOpenHashSet<String> archiveIdentifiers=new ObjectOpenHashSet<String>();
      archiveIdentifiers.addAll(annotationArchiveReader.getIdentifiers());
      long sumDepth=0;
      int countDepth=0;
      long countAllBases=0;
      for (int referenceIndex=0; referenceIndex < archiveReader.getNumberOfIndices(); referenceIndex++) {
        CountsReader reader=archiveReader.getCountReader(referenceIndex);
        String countArchiveRefId=backwards.getId(referenceIndex).toString();
        if (archiveIdentifiers.contains(countArchiveRefId)) {
          System.out.println(countArchiveRefId);
          CountsReader annotationReader=annotationArchiveReader.getCountReader(countArchiveRefId);
          AnyTransitionCountsIterator orIterator=new AnyTransitionCountsIterator(reader,annotationReader);
          while (orIterator.hasNextTransition()) {
            orIterator.nextTransition();
            int annotationCount=orIterator.getCount(1);
            int readerCount=orIterator.getCount(0);
            int position=orIterator.getPosition();
            int length=orIterator.getLength();
            int end=position + length;
            boolean inAnnotation=annotationCount == 1;
            LongArrayList update=inAnnotation ? depthTallyInAnnotation : depthTallyOutsideAnnotation;
            int depth=readerCount;
            if (depth != 0) {
              sumDepth+=depth;
              countDepth++;
            }
            grow(depthTallyInAnnotation,depth);
            grow(depthTallyOutsideAnnotation,depth);
            update.set(depth,update.get(depth) + length);
            countAllBases+=length;
          }
        }
 else {
          System.out.printf(""String_Node_Str"",countArchiveRefId);
        }
      }
      System.out.printf(""String_Node_Str"",divide(sumDepth,countDepth));
      System.out.printf(""String_Node_Str"",100d * divide(sum(depthTallyInAnnotation,1),sum(depthTallyOutsideAnnotation,1) + sum(depthTallyInAnnotation,1)));
      final int length=depthTallyInAnnotation.size();
      long[] cumulativeCaptured=new long[length];
      long[] cumulativeNotCaptured=new long[length];
      for (int depth=length - 2; depth >= 0; --depth) {
        cumulativeCaptured[depth]=cumulativeCaptured[depth + 1] + depthTallyInAnnotation.get(depth);
        cumulativeNotCaptured[depth]=cumulativeNotCaptured[depth + 1] + depthTallyOutsideAnnotation.get(depth);
      }
      System.out.printf(""String_Node_Str"",100d * divide(cumulativeCaptured[0],countAllBases));
      double[] fractionOfBasesCoveredCumulative=new double[length];
      for (int i=0; i < length; i++) {
        fractionOfBasesCoveredCumulative[i]=((double)cumulativeCaptured[i]) / ((double)(cumulativeCaptured[i] + cumulativeNotCaptured[i]));
      }
      for (int depth=0; depth < 100; depth++) {
        System.out.printf(""String_Node_Str"",depth,divide(cumulativeCaptured[depth],countAllBases) * 100,divide(cumulativeNotCaptured[depth],countAllBases) * 100);
      }
    }
 catch (    IOException e) {
      System.err.println(""String_Node_Str"" + basename);
      e.printStackTrace();
    }
  }
}","/** 
 * Run the mode.
 */
@Override public void execute(){
  for (  String basename : inputBasenames) {
    try {
      final AlignmentReaderImpl alignment=new AlignmentReaderImpl(basename);
      alignment.readHeader();
      alignment.close();
      final IndexedIdentifier referenceIds=alignment.getTargetIdentifiers();
      final DoubleIndexedIdentifier backwards=new DoubleIndexedIdentifier(referenceIds);
      CountsArchiveReader archiveReader=new CountsArchiveReader(basename);
      CountsArchiveReader annotationArchiveReader=new CountsArchiveReader(annotationBasename);
      LongArrayList depthTallyInAnnotation=new LongArrayList(10000);
      LongArrayList depthTallyOutsideAnnotation=new LongArrayList(10000);
      ObjectOpenHashSet<String> archiveIdentifiers=new ObjectOpenHashSet<String>();
      archiveIdentifiers.addAll(annotationArchiveReader.getIdentifiers());
      long sumDepth=0;
      int countDepth=0;
      long sumDepthAnnot=0;
      int countDepthAnnot=0;
      long countAllBases=0;
      for (int referenceIndex=0; referenceIndex < archiveReader.getNumberOfIndices(); referenceIndex++) {
        CountsReader reader=archiveReader.getCountReader(referenceIndex);
        String countArchiveRefId=backwards.getId(referenceIndex).toString();
        if (archiveIdentifiers.contains(countArchiveRefId)) {
          System.out.println(countArchiveRefId);
          CountsReader annotationReader=annotationArchiveReader.getCountReader(countArchiveRefId);
          AnyTransitionCountsIterator orIterator=new AnyTransitionCountsIterator(reader,annotationReader);
          while (orIterator.hasNextTransition()) {
            orIterator.nextTransition();
            int annotationCount=orIterator.getCount(1);
            int readerCount=orIterator.getCount(0);
            int position=orIterator.getPosition();
            int length=orIterator.getLength();
            int end=position + length;
            boolean inAnnotation=annotationCount == 1;
            LongArrayList update=inAnnotation ? depthTallyInAnnotation : depthTallyOutsideAnnotation;
            int depth=readerCount;
            if (depth != 0) {
              sumDepth+=depth;
              countDepth++;
              if (inAnnotation) {
                sumDepthAnnot+=depth;
                countDepthAnnot++;
              }
            }
            grow(depthTallyInAnnotation,depth);
            grow(depthTallyOutsideAnnotation,depth);
            final int numBases=depth * length;
            update.set(depth,update.get(depth) + numBases);
            countAllBases+=depth * length;
          }
        }
 else {
          System.out.printf(""String_Node_Str"",countArchiveRefId);
        }
      }
      System.out.printf(""String_Node_Str"",divide(sumDepth,countDepth));
      System.out.printf(""String_Node_Str"",divide(sumDepthAnnot,countDepthAnnot));
      System.out.printf(""String_Node_Str"",100d * divide(sum(depthTallyInAnnotation,1),sum(depthTallyOutsideAnnotation,1) + sum(depthTallyInAnnotation,1)));
      final int length=depthTallyInAnnotation.size();
      long[] cumulativeCaptured=new long[length];
      long[] cumulativeNotCaptured=new long[length];
      long sumCaptured=(long)sum(depthTallyInAnnotation,0);
      long sumNotCaptured=(long)sum(depthTallyOutsideAnnotation,0);
      for (int depth=0; depth < length; ++depth) {
        cumulativeCaptured[depth]=sumCaptured;
        sumCaptured-=depthTallyInAnnotation.get(depth);
        cumulativeNotCaptured[depth]=sumNotCaptured;
        sumNotCaptured-=depthTallyOutsideAnnotation.get(depth);
      }
      System.out.printf(""String_Node_Str"",100d * divide(cumulativeCaptured[0],countAllBases));
      double[] fractionOfBasesCoveredCumulative=new double[length];
      for (int i=0; i < length; i++) {
        fractionOfBasesCoveredCumulative[i]=((double)cumulativeCaptured[i]) / ((double)(cumulativeCaptured[i] + cumulativeNotCaptured[i]));
      }
      for (int depth=0; depth < 300; depth++) {
        System.out.printf(""String_Node_Str"",depth,divide(cumulativeCaptured[depth],countAllBases) * 100,divide(cumulativeNotCaptured[depth],countAllBases) * 100);
      }
    }
 catch (    IOException e) {
      System.err.println(""String_Node_Str"" + basename);
      e.printStackTrace();
    }
  }
}"
50411,"private int constructTargetIndexPermutations(int mergedReferenceIndex,final IndexedIdentifier mergedTargetIdentifiers,final Int2IntMap mergedTargetLengths,final AlignmentReaderImpl reader){
  final int[] targetLengths=reader.getTargetLength();
  final int targetLengthCount=ArrayUtils.getLength(targetLengths);
  final Int2IntMap tempPermutation=new Int2IntOpenHashMap();
  final IndexedIdentifier targetIdentifers=reader.getTargetIdentifiers();
  final DoubleIndexedIdentifier backward=new DoubleIndexedIdentifier(targetIdentifers);
  for (int i=0; i < reader.getNumberOfTargets(); i++) {
    final int newIndex=mergedReferenceIndex++;
    tempPermutation.put(i,newIndex);
    final MutableString targetId=backward.getId(i);
    if (targetId != null) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"" + targetId + ""String_Node_Str""+ newIndex);
      }
      mergedTargetIdentifiers.put(targetId,newIndex);
      final int targetLength;
      if (i < targetLengthCount) {
        targetLength=targetLengths[i];
      }
 else {
        targetLength=0;
      }
      mergedTargetLengths.put(newIndex,targetLength);
    }
  }
  int size=0;
  for (  final int key : tempPermutation.keySet()) {
    size=Math.max(key + 1,size);
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + size);
  }
  final int[] newPermutation=new int[size];
  for (  final int key : tempPermutation.keySet()) {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + key);
    }
    newPermutation[key]=tempPermutation.get(key);
  }
  referenceIndexPermutation.add(newPermutation);
  return mergedReferenceIndex;
}","private int constructTargetIndexPermutations(int mergedReferenceIndex,final IndexedIdentifier mergedTargetIdentifiers,final Int2IntMap mergedTargetLengths,final AlignmentReaderImpl reader){
  final int[] targetLengths=reader.getTargetLength();
  final int targetLengthCount=ArrayUtils.getLength(targetLengths);
  final Int2IntMap tempPermutation=new Int2IntOpenHashMap();
  final IndexedIdentifier targetIdentifers=reader.getTargetIdentifiers();
  final DoubleIndexedIdentifier backward=new DoubleIndexedIdentifier(targetIdentifers);
  for (int i=0; i < reader.getNumberOfTargets(); i++) {
    MutableString id=backward.size() != 0 ? backward.getId(i) : new MutableString(String.valueOf(mergedTargetIdentifiers.size()));
    final int newIndex=mergedTargetIdentifiers.registerIdentifier(id);
    tempPermutation.put(i,newIndex);
    final MutableString targetId=backward.getId(i);
    if (targetId != null) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"" + targetId + ""String_Node_Str""+ newIndex);
      }
      mergedTargetIdentifiers.registerIdentifier(targetId);
      final int targetLength;
      if (i < targetLengthCount) {
        targetLength=targetLengths[i];
      }
 else {
        targetLength=0;
      }
      mergedTargetLengths.put(newIndex,targetLength);
    }
 else {
    }
  }
  int size=0;
  for (  final int key : tempPermutation.keySet()) {
    size=Math.max(key + 1,size);
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + size);
  }
  final int[] newPermutation=new int[size];
  for (  final int key : tempPermutation.keySet()) {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + key);
    }
    newPermutation[key]=tempPermutation.get(key);
  }
  referenceIndexPermutation.add(newPermutation);
  return mergedTargetIdentifiers.size();
}"
50412,"/** 
 * Read the index. The header is also loaded.
 * @throws IOException If an error occurs loading the index or header.
 */
public final void readIndex() throws IOException {
  if (indexed && !indexLoaded) {
    readHeader();
    final GZIPInputStream indexStream=new GZIPInputStream(new FileInputStream(basename + ""String_Node_Str""));
    final CodedInputStream codedInput=CodedInputStream.newInstance(indexStream);
    codedInput.setSizeLimit(Integer.MAX_VALUE);
    final Alignments.AlignmentIndex index=Alignments.AlignmentIndex.parseFrom(codedInput);
    indexOffsets.clear();
    indexAbsolutePositions.clear();
    for (    final long offset : index.getOffsetsList()) {
      indexOffsets.add(offset);
    }
    for (    final long absolutePosition : index.getAbsolutePositionsList()) {
      indexAbsolutePositions.add(absolutePosition);
    }
    indexAbsolutePositions.trim();
    indexOffsets.trim();
    targetPositionOffsets=new long[targetLengths.length];
    for (int targetIndex=0; targetIndex < targetLengths.length; targetIndex++) {
      targetPositionOffsets[targetIndex]+=targetLengths[targetIndex];
      targetPositionOffsets[targetIndex]+=targetIndex < 1 ? 0 : targetPositionOffsets[targetIndex - 1];
    }
    indexLoaded=true;
  }
}","/** 
 * Read the index. The header is also loaded.
 * @throws IOException If an error occurs loading the index or header.
 */
public final void readIndex() throws IOException {
  if (indexed && !indexLoaded) {
    readHeader();
    final GZIPInputStream indexStream=new GZIPInputStream(new FileInputStream(basename + ""String_Node_Str""));
    final CodedInputStream codedInput=CodedInputStream.newInstance(indexStream);
    codedInput.setSizeLimit(Integer.MAX_VALUE);
    final Alignments.AlignmentIndex index=Alignments.AlignmentIndex.parseFrom(codedInput);
    indexOffsets.clear();
    indexAbsolutePositions.clear();
    for (    final long offset : index.getOffsetsList()) {
      indexOffsets.add(offset);
    }
    for (    final long absolutePosition : index.getAbsolutePositionsList()) {
      indexAbsolutePositions.add(absolutePosition);
    }
    indexAbsolutePositions.trim();
    indexOffsets.trim();
    targetPositionOffsets=new long[targetLengths.length];
    for (int targetIndex=0; targetIndex < targetLengths.length; targetIndex++) {
      targetPositionOffsets[targetIndex]+=targetLengths[targetIndex];
      targetPositionOffsets[targetIndex]+=targetIndex < 1 ? 0 : targetPositionOffsets[targetIndex - 1];
    }
    targetPositionOffsets[0]=0;
    indexLoaded=true;
  }
}"
50413,"private void parseCurrentLine(){
  Arrays.fill(columnStarts,0);
  Arrays.fill(columnEnds,0);
  Arrays.fill(fieldStarts,0);
  Arrays.fill(fieldEnds,0);
  columnStarts[0]=0;
  int columnIndex=0;
  int fieldIndex=0;
  lineLength=line.length();
  int lineFieldIndexToColumnIndex[]=new int[numberOfFields];
  Arrays.fill(lineFieldIndexToColumnIndex,-1);
  IntArrayList previousColumnFieldIndices=new IntArrayList();
  for (int i=0; i < lineLength; i++) {
    final char c=line.charAt(i);
    if (c == columnSeparatorCharacter) {
      columnEnds[columnIndex]=i;
      if (columnIndex + 1 < numberOfColumns) {
        columnStarts[columnIndex + 1]=i + 1;
      }
    }
    if (c == columnSeparatorCharacter || c == fieldSeparatorCharacter || (columnIndex >= formatColumnIndex && c == formatFieldSeparatorCharacter)) {
      if (TSV) {
        fieldEnds[columnIndex]=columnEnds[columnIndex];
        fieldStarts[columnIndex]=columnStarts[columnIndex];
        fieldIndex=columnIndex;
        lineFieldIndexToColumnIndex[fieldIndex]=columnIndex;
      }
 else {
        fieldEnds[fieldIndex]=i;
        if (fieldIndex + 1 < numberOfFields) {
          fieldStarts[fieldIndex + 1]=i + 1;
        }
        previousColumnFieldIndices.add(fieldIndex);
        fieldIndex++;
      }
    }
    if (c == columnSeparatorCharacter) {
      push(columnIndex,lineFieldIndexToColumnIndex,previousColumnFieldIndices);
      columnIndex++;
    }
  }
  int numberOfFieldsOnLine=fieldIndex;
  int numberOfColumnsOnLine=columnIndex;
  columnStarts[0]=0;
  columnEnds[numberOfColumnsOnLine]=line.length();
  fieldStarts[0]=0;
  fieldEnds[numberOfFieldsOnLine]=line.length();
  previousColumnFieldIndices.add(fieldIndex);
  push(columnIndex,lineFieldIndexToColumnIndex,previousColumnFieldIndices);
  Arrays.fill(fieldPermutation,-1);
  for (  ColumnInfo c : columns) {
    c.formatIndex=0;
  }
  for (int lineFieldIndex=0; lineFieldIndex <= numberOfFieldsOnLine; lineFieldIndex++) {
    int start=fieldStarts[lineFieldIndex];
    int end=fieldEnds[lineFieldIndex];
    final int cIndex=lineFieldIndexToColumnIndex[lineFieldIndex];
    ColumnInfo column=columnList.get(cIndex);
    int colMinGlobalFieldIndex=Integer.MAX_VALUE;
    int colMaxGlobalFieldIndex=Integer.MIN_VALUE;
    for (    ColumnField f : column.fields) {
      colMinGlobalFieldIndex=Math.min(colMinGlobalFieldIndex,f.globalFieldIndex);
      colMaxGlobalFieldIndex=Math.max(colMaxGlobalFieldIndex,f.globalFieldIndex);
    }
    int formatColumnIndex=TSV ? -1 : formatColumn.columnIndex;
    int startFormatColumn=TSV ? 0 : columnStarts[formatColumnIndex];
    int endFormatColumn=TSV ? 0 : columnEnds[formatColumnIndex];
    MutableString formatSpan=line.substring(startFormatColumn,endFormatColumn);
    formatSpan.compact();
    String[] formatTokens=formatSpan.toString().split(Character.toString(formatFieldSeparatorCharacter));
    for (    ColumnField f : column.fields) {
      if (colMaxGlobalFieldIndex == colMinGlobalFieldIndex) {
        fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
      }
 else {
        int j=start;
        final String id=f.id;
        int matchLength=0;
        for (int i=0; i < id.length(); i++) {
          if (j > end) {
            break;
          }
          char linechar=line.charAt(j);
          if (id.charAt(i) != linechar) {
            matchLength=-1;
            break;
          }
          matchLength++;
          j++;
        }
        if (matchLength == id.length() && line.charAt(j) == '=' || (j == end && f.type == ColumnType.Flag)) {
          fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
          if (f.type != ColumnType.Flag) {
            fieldStarts[lineFieldIndex]+=f.id.length() + 1;
          }
        }
 else {
          if (column.useFormat && column.formatIndex < formatTokens.length) {
            if (f.id.equals(formatTokens[column.formatIndex])) {
              fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
              column.formatIndex++;
              break;
            }
          }
        }
      }
    }
  }
}","private void parseCurrentLine(){
  Arrays.fill(columnStarts,0);
  Arrays.fill(columnEnds,0);
  Arrays.fill(fieldStarts,0);
  Arrays.fill(fieldEnds,0);
  columnStarts[0]=0;
  int columnIndex=0;
  int fieldIndex=0;
  lineLength=line.length();
  int lineFieldIndexToColumnIndex[]=new int[numberOfFields];
  Arrays.fill(lineFieldIndexToColumnIndex,-1);
  IntArrayList previousColumnFieldIndices=new IntArrayList();
  for (int i=0; i < lineLength; i++) {
    final char c=line.charAt(i);
    if (c == columnSeparatorCharacter) {
      columnEnds[columnIndex]=i;
      if (columnIndex + 1 < numberOfColumns) {
        columnStarts[columnIndex + 1]=i + 1;
      }
    }
    if (c == columnSeparatorCharacter || c == fieldSeparatorCharacter || (columnIndex >= formatColumnIndex && c == formatFieldSeparatorCharacter)) {
      if (TSV) {
        fieldEnds[columnIndex]=columnEnds[columnIndex];
        fieldStarts[columnIndex]=columnStarts[columnIndex];
        fieldIndex=columnIndex;
        lineFieldIndexToColumnIndex[fieldIndex]=columnIndex;
      }
 else {
        fieldEnds[fieldIndex]=i;
        if (fieldIndex + 1 < numberOfFields) {
          fieldStarts[fieldIndex + 1]=i + 1;
        }
        previousColumnFieldIndices.add(fieldIndex);
        fieldIndex++;
      }
    }
    if (c == columnSeparatorCharacter) {
      push(columnIndex,lineFieldIndexToColumnIndex,previousColumnFieldIndices);
      columnIndex++;
    }
  }
  int numberOfFieldsOnLine=fieldIndex;
  int numberOfColumnsOnLine=columnIndex;
  columnStarts[0]=0;
  columnEnds[numberOfColumnsOnLine]=line.length();
  fieldStarts[0]=0;
  fieldEnds[numberOfFieldsOnLine]=line.length();
  previousColumnFieldIndices.add(fieldIndex);
  push(columnIndex,lineFieldIndexToColumnIndex,previousColumnFieldIndices);
  Arrays.fill(fieldPermutation,-1);
  for (  ColumnInfo c : columns) {
    c.formatIndex=0;
  }
  for (int lineFieldIndex=0; lineFieldIndex <= numberOfFieldsOnLine; lineFieldIndex++) {
    int start=fieldStarts[lineFieldIndex];
    int end=fieldEnds[lineFieldIndex];
    final int cIndex=lineFieldIndexToColumnIndex[lineFieldIndex];
    ColumnInfo column=columnList.get(cIndex);
    int colMinGlobalFieldIndex=Integer.MAX_VALUE;
    int colMaxGlobalFieldIndex=Integer.MIN_VALUE;
    for (    ColumnField f : column.fields) {
      colMinGlobalFieldIndex=Math.min(colMinGlobalFieldIndex,f.globalFieldIndex);
      colMaxGlobalFieldIndex=Math.max(colMaxGlobalFieldIndex,f.globalFieldIndex);
    }
    int formatColumnIndex=TSV ? -1 : formatColumn.columnIndex;
    int startFormatColumn=TSV ? 0 : columnStarts[formatColumnIndex];
    int endFormatColumn=TSV ? 0 : columnEnds[formatColumnIndex];
    MutableString formatSpan=line.substring(startFormatColumn,endFormatColumn);
    formatSpan.compact();
    String[] formatTokens=formatSpan.toString().split(Character.toString(formatFieldSeparatorCharacter));
    for (    ColumnField f : column.fields) {
      if (colMaxGlobalFieldIndex == colMinGlobalFieldIndex) {
        fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
      }
 else {
        int j=start;
        final String id=f.id;
        int matchLength=0;
        for (int i=0; i < id.length(); i++) {
          if (j >= end) {
            break;
          }
          char linechar=line.charAt(j);
          if (id.charAt(i) != linechar) {
            matchLength=-1;
            break;
          }
          matchLength++;
          j++;
        }
        if (matchLength == id.length() && line.charAt(j) == '=' || (j == end && f.type == ColumnType.Flag)) {
          fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
          if (f.type != ColumnType.Flag) {
            fieldStarts[lineFieldIndex]+=f.id.length() + 1;
          }
        }
 else {
          if (column.useFormat && column.formatIndex < formatTokens.length) {
            if (f.id.equals(formatTokens[column.formatIndex])) {
              fieldPermutation[f.globalFieldIndex]=lineFieldIndex;
              column.formatIndex++;
              break;
            }
          }
        }
      }
    }
  }
}"
50414,"public SimulateBisulfiteReads(){
  random=new Random();
}","public SimulateBisulfiteReads(){
  random=new Random(seed);
}"
50415,"private void process(DoubleList methylationRates,CharSequence segmentBases) throws IOException {
  PrintWriter writer=new PrintWriter(new FileWriter(outputFilename));
  final String trueRateFilenam=FilenameUtils.removeExtension(outputFilename) + ""String_Node_Str"";
  PrintWriter trueRateWriter=new PrintWriter(new FileWriter(trueRateFilenam));
  methylationForward=new Int2DoubleOpenHashMap();
  methylationReverse=new Int2DoubleOpenHashMap();
  final int segmentLength=segmentBases.length();
  DoubleIterator it=methylationRates.iterator();
  for (int i=0; i < segmentBases.length(); i++) {
    if (segmentBases.charAt(i) == 'C') {
      if (!it.hasNext()) {
        it=methylationRates.iterator();
      }
      methylationForward.put(i,it.nextDouble());
      trueRateWriter.printf(""String_Node_Str"",i,methylationForward.get(i));
    }
  }
  it=methylationRates.iterator();
  CharSequence reverseStrandSegment=reverseComplement(segmentBases);
  for (int i=reverseStrandSegment.length() - 1; i >= 0; i--) {
    if (reverseStrandSegment.charAt(i) == 'C') {
      if (!it.hasNext()) {
        it=methylationRates.iterator();
      }
      final int positionInSegment=i;
      methylationReverse.put(positionInSegment,it.nextDouble());
      trueRateWriter.printf(""String_Node_Str"",positionInSegment,methylationReverse.get(positionInSegment));
    }
  }
  for (int repeatCount=0; repeatCount < 10000; repeatCount++) {
    int startReadPosition=choose(0,segmentBases.length() - 1 - readLength);
    boolean matchedReverseStrand=random.nextBoolean();
    final CharSequence selectedReadRegion=segmentBases.subSequence(startReadPosition,startReadPosition + readLength);
    CharSequence readBases=matchedReverseStrand ? reverseComplement(selectedReadRegion) : selectedReadRegion;
    MutableString sequenceInitial=new MutableString();
    MutableString sequenceTreated=new MutableString();
    MutableString log=new MutableString();
    for (int i=0; i < readLength; i++) {
      final int basePositionInSegment=i;
      char base=readBases.charAt(basePositionInSegment);
      sequenceInitial.append(base);
      if (base == 'C') {
        boolean isBaseMethylated=random.nextDouble() < getMethylationRateAtPosition(segmentLength,matchedReverseStrand,i,startReadPosition);
        if (!isBaseMethylated) {
          base='T';
        }
 else {
          log.append(""String_Node_Str"");
          log.append(i + startReadPosition);
          log.append(' ');
        }
      }
      sequenceTreated.append(base);
    }
    writer.printf(""String_Node_Str"",repeatCount,refChoice,startReadPosition,matchedReverseStrand ? ""String_Node_Str"" : ""String_Node_Str"",log,sequenceTreated);
  }
  writer.close();
  trueRateWriter.close();
}","private void process(DoubleList methylationRates,CharSequence segmentBases,int from) throws IOException {
  PrintWriter writer=new PrintWriter(new FileWriter(outputFilename));
  final String trueRateFilename=FilenameUtils.removeExtension(outputFilename) + ""String_Node_Str"";
  PrintWriter trueRateWriter=new PrintWriter(new FileWriter(trueRateFilename));
  methylationForward=new Int2DoubleOpenHashMap();
  methylationReverse=new Int2DoubleOpenHashMap();
  final int segmentLength=segmentBases.length();
  DoubleIterator it=methylationRates.iterator();
  for (int i=0; i < segmentBases.length(); i++) {
    if (segmentBases.charAt(i) == 'C') {
      if (!it.hasNext()) {
        it=methylationRates.iterator();
      }
      methylationForward.put(i,it.nextDouble());
      trueRateWriter.printf(""String_Node_Str"",i,methylationForward.get(i),i + from);
    }
  }
  it=methylationRates.iterator();
  CharSequence reverseStrandSegment=reverseComplement(segmentBases);
  for (int i=reverseStrandSegment.length() - 1; i >= 0; i--) {
    if (reverseStrandSegment.charAt(i) == 'C') {
      if (!it.hasNext()) {
        it=methylationRates.iterator();
      }
      final int positionInSegment=i;
      methylationReverse.put(positionInSegment,it.nextDouble());
      trueRateWriter.printf(""String_Node_Str"",positionInSegment,methylationReverse.get(positionInSegment),i + from);
    }
  }
  for (int repeatCount=0; repeatCount < 10000; repeatCount++) {
    int startReadPosition=choose(0,segmentBases.length() - 1 - readLength);
    boolean matchedReverseStrand=random.nextBoolean();
    final CharSequence selectedReadRegion=segmentBases.subSequence(startReadPosition,startReadPosition + readLength);
    CharSequence readBases=matchedReverseStrand ? reverseComplement(selectedReadRegion) : selectedReadRegion;
    MutableString sequenceInitial=new MutableString();
    MutableString sequenceTreated=new MutableString();
    MutableString log=new MutableString();
    for (int i=0; i < readLength; i++) {
      final int basePositionInSegment=i;
      char base=readBases.charAt(basePositionInSegment);
      sequenceInitial.append(base);
      if (base == 'C') {
        final boolean b=random.nextDouble() < getMethylationRateAtPosition(segmentLength,matchedReverseStrand,i,startReadPosition);
        boolean isBaseMethylated=b;
        if (!isBaseMethylated) {
          if (bisulfiteTreatment) {
            base='T';
          }
 else {
            base='C';
          }
        }
 else {
          log.append(bisulfiteTreatment ? ""String_Node_Str"" : ""String_Node_Str"");
          log.append(i + startReadPosition + from);
          log.append(' ');
          log.append(""String_Node_Str"");
          log.append(matchedReverseStrand ? readLength - i : i);
          log.append(' ');
          base=matchedReverseStrand ? 'C' : 'G';
        }
      }
      sequenceTreated.append(base);
    }
    MutableString coveredPositions=new MutableString();
    MutableString qualityScores=new MutableString();
    for (int i=0; i < readLength; i++) {
      final char c=QualityEncoding.ILLUMINA.phredQualityScoreToAsciiEncoding((byte)40);
      qualityScores.append(c);
    }
    for (int i=startReadPosition + from; i < startReadPosition + from + readLength; i++) {
      coveredPositions.append(i);
      coveredPositions.append(""String_Node_Str"");
    }
    writer.printf(""String_Node_Str"",repeatCount,refChoice,startReadPosition,matchedReverseStrand ? ""String_Node_Str"" : ""String_Node_Str"",log,coveredPositions,sequenceTreated,qualityScores);
  }
  writer.close();
  trueRateWriter.close();
}"
50416,"public static void main(String[] args) throws IOException {
  String fastaReference=CLI.getOption(args,""String_Node_Str"",null);
  String outputFilename=CLI.getOption(args,""String_Node_Str"",""String_Node_Str"");
  String regionTrueRates=CLI.getOption(args,""String_Node_Str"",""String_Node_Str"");
  String refChoice=CLI.getOption(args,""String_Node_Str"",""String_Node_Str"");
  int from=CLI.getIntOption(args,""String_Node_Str"",0);
  int to=CLI.getIntOption(args,""String_Node_Str"",0);
  if (to < from) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  int readLength=CLI.getIntOption(args,""String_Node_Str"",40);
  String methylationRateFilename=CLI.getOption(args,""String_Node_Str"",""String_Node_Str"");
  SimulateBisulfiteReads processor=new SimulateBisulfiteReads();
  processor.readLength=readLength;
  processor.outputFilename=outputFilename;
  processor.regionTrueRates=regionTrueRates;
  processor.process(refChoice,fastaReference,from,to,methylationRateFilename);
}","public static void main(String[] args) throws IOException {
  String fastaReference=CLI.getOption(args,""String_Node_Str"",null);
  String outputFilename=CLI.getOption(args,""String_Node_Str"",""String_Node_Str"");
  String regionTrueRates=CLI.getOption(args,""String_Node_Str"",""String_Node_Str"");
  String refChoice=CLI.getOption(args,""String_Node_Str"",""String_Node_Str"");
  int from=CLI.getIntOption(args,""String_Node_Str"",0);
  int to=CLI.getIntOption(args,""String_Node_Str"",0);
  if (to < from) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  int readLength=CLI.getIntOption(args,""String_Node_Str"",50);
  String methylationRateFilename=CLI.getOption(args,""String_Node_Str"",""String_Node_Str"");
  SimulateBisulfiteReads processor=new SimulateBisulfiteReads();
  final boolean bisulfite=CLI.isKeywordGiven(args,""String_Node_Str"");
  if (bisulfite) {
    System.out.println(""String_Node_Str"");
  }
  processor.bisulfiteTreatment=bisulfite;
  processor.readLength=readLength;
  processor.outputFilename=outputFilename;
  processor.regionTrueRates=regionTrueRates;
  processor.process(refChoice,fastaReference,from,to,methylationRateFilename);
}"
50417,"private CharSequence reverseComplement(CharSequence selectedReadRegion){
  MutableString s=new MutableString();
  s.setLength(selectedReadRegion.length());
  int j=0;
  for (int i=s.length() - 1; i >= 0; i--) {
    char base=selectedReadRegion.charAt(i);
switch (base) {
case 'A':
      base='T';
    break;
case 'C':
  base='G';
break;
case 'T':
base='C';
break;
case 'G':
base='C';
break;
default :
base='N';
break;
}
s.charAt(j++,base);
}
return s;
}","private CharSequence reverseComplement(CharSequence selectedReadRegion){
  MutableString s=new MutableString();
  s.setLength(selectedReadRegion.length());
  int j=0;
  for (int i=s.length() - 1; i >= 0; i--) {
    char base=selectedReadRegion.charAt(i);
switch (base) {
case 'A':
      base='T';
    break;
case 'C':
  base='G';
break;
case 'T':
base='A';
break;
case 'G':
base='C';
break;
default :
base='N';
break;
}
s.charAt(j++,base);
}
return s;
}"
50418,"public void processPositions(int referenceIndex,int position,ObjectArrayList<edu.cornell.med.icb.goby.alignments.PositionBaseInfo> list){
  int sumVariantCounts=0;
  for (int sampleIndex=0; sampleIndex < numberOfSamples; sampleIndex++) {
    sampleCounts[sampleIndex].counts[SampleCountInfo.BASE_A_INDEX]=0;
    sampleCounts[sampleIndex].counts[SampleCountInfo.BASE_T_INDEX]=0;
    sampleCounts[sampleIndex].counts[SampleCountInfo.BASE_C_INDEX]=0;
    sampleCounts[sampleIndex].counts[SampleCountInfo.BASE_G_INDEX]=0;
    sampleCounts[sampleIndex].counts[SampleCountInfo.BASE_OTHER_INDEX]=0;
    sampleCounts[sampleIndex].referenceBase='?';
    sampleCounts[sampleIndex].distinctReadIndices.clear();
    sampleCounts[sampleIndex].sampleIndex=sampleIndex;
    sampleCounts[sampleIndex].varCount=0;
    sampleCounts[sampleIndex].refCount=0;
  }
  if (list != null) {
    IntSet distinctReadIndices=new IntArraySet();
    char refBase=setReferenceAllele(list);
    for (    edu.cornell.med.icb.goby.alignments.PositionBaseInfo info : list) {
      final int sampleIndex=info.readerIndex;
      distinctReadIndices.add(info.readIndex);
      if (info.matchesReference) {
        sampleCounts[sampleIndex].referenceBase=info.from;
        sampleCounts[sampleIndex].refCount++;
        incrementBaseCounter(info.from,sampleIndex);
      }
 else {
        sampleCounts[sampleIndex].varCount++;
        sumVariantCounts++;
        sampleCounts[sampleIndex].referenceBase=refBase;
        sampleCounts[sampleIndex].distinctReadIndices.add(info.readIndex);
        incrementBaseCounter(info.to,sampleIndex);
      }
    }
    if (distinctReadIndices.size() >= thresholdDistinctReadIndices && sumVariantCounts > minimumVariationSupport) {
      int groupIndexA=0;
      int groupIndexB=1;
      if (!isWithinStartFlap(referenceIndex,position)) {
        if (baseFilters.length != 0) {
          ObjectArrayList<edu.cornell.med.icb.goby.alignments.PositionBaseInfo> filteredList=new ObjectArrayList<edu.cornell.med.icb.goby.alignments.PositionBaseInfo>();
          for (          BaseFilter filter : baseFilters) {
            filter.filterBases(list,sampleCounts,filteredList);
          }
          CountFixer fixer=new CountFixer();
          fixer.fix(list,sampleCounts,filteredList);
        }
      }
      format.writeRecord(this,sampleCounts,referenceIndex,position,list,groupIndexA,groupIndexB);
    }
  }
}","public void processPositions(int referenceIndex,int position,ObjectArrayList<edu.cornell.med.icb.goby.alignments.PositionBaseInfo> list){
  int sumVariantCounts=0;
  for (int sampleIndex=0; sampleIndex < numberOfSamples; sampleIndex++) {
    sampleCounts[sampleIndex].counts[SampleCountInfo.BASE_A_INDEX]=0;
    sampleCounts[sampleIndex].counts[SampleCountInfo.BASE_T_INDEX]=0;
    sampleCounts[sampleIndex].counts[SampleCountInfo.BASE_C_INDEX]=0;
    sampleCounts[sampleIndex].counts[SampleCountInfo.BASE_G_INDEX]=0;
    sampleCounts[sampleIndex].counts[SampleCountInfo.BASE_OTHER_INDEX]=0;
    sampleCounts[sampleIndex].referenceBase='?';
    sampleCounts[sampleIndex].distinctReadIndices.clear();
    sampleCounts[sampleIndex].sampleIndex=sampleIndex;
    sampleCounts[sampleIndex].varCount=0;
    sampleCounts[sampleIndex].refCount=0;
    sampleCounts[sampleIndex].failedCount=0;
  }
  if (list != null) {
    IntSet distinctReadIndices=new IntArraySet();
    char refBase=setReferenceAllele(list);
    for (    edu.cornell.med.icb.goby.alignments.PositionBaseInfo info : list) {
      final int sampleIndex=info.readerIndex;
      distinctReadIndices.add(info.readIndex);
      if (info.matchesReference) {
        sampleCounts[sampleIndex].referenceBase=info.from;
        sampleCounts[sampleIndex].refCount++;
        incrementBaseCounter(info.from,sampleIndex);
      }
 else {
        sampleCounts[sampleIndex].varCount++;
        sumVariantCounts++;
        sampleCounts[sampleIndex].referenceBase=refBase;
        sampleCounts[sampleIndex].distinctReadIndices.add(info.readIndex);
        incrementBaseCounter(info.to,sampleIndex);
      }
    }
    if (distinctReadIndices.size() >= thresholdDistinctReadIndices && sumVariantCounts > minimumVariationSupport) {
      int groupIndexA=0;
      int groupIndexB=1;
      if (!isWithinStartFlap(referenceIndex,position)) {
        if (baseFilters.length != 0) {
          ObjectArrayList<edu.cornell.med.icb.goby.alignments.PositionBaseInfo> filteredList=new ObjectArrayList<edu.cornell.med.icb.goby.alignments.PositionBaseInfo>();
          for (          BaseFilter filter : baseFilters) {
            filter.filterBases(list,sampleCounts,filteredList);
          }
          CountFixer fixer=new CountFixer();
          fixer.fix(list,sampleCounts,filteredList);
        }
      }
      format.writeRecord(this,sampleCounts,referenceIndex,position,list,groupIndexA,groupIndexB);
    }
  }
}"
50419,"private void writeZygozity(SampleCountInfo[] sampleCounts){
  for (int sampleIndex=0; sampleIndex < numberOfSamples; sampleIndex++) {
    SampleCountInfo sci=sampleCounts[sampleIndex];
    String zygozity;
switch (alleleSet.size()) {
case 0:
      zygozity=""String_Node_Str"";
    break;
case 1:
  zygozity=""String_Node_Str"";
genotypeBuffer.setLength(0);
genotypeBuffer.append(String.format(""String_Node_Str"",sci.referenceBase,sci.referenceBase));
break;
case 2:
zygozity=""String_Node_Str"";
break;
default :
zygozity=""String_Node_Str"";
break;
}
statsWriter.setSampleValue(zygFieldIndex,sampleIndex,zygozity);
}
}","private void writeZygozity(SampleCountInfo[] sampleCounts){
  for (int sampleIndex=0; sampleIndex < numberOfSamples; sampleIndex++) {
    SampleCountInfo sci=sampleCounts[sampleIndex];
    String zygozity;
switch (alleleSet.size()) {
case 0:
      zygozity=""String_Node_Str"";
    break;
case 1:
  zygozity=""String_Node_Str"";
break;
case 2:
zygozity=""String_Node_Str"";
break;
default :
zygozity=""String_Node_Str"";
break;
}
statsWriter.setSampleValue(zygFieldIndex,sampleIndex,zygozity);
}
}"
50420,"public void writeGenotypes(VCFWriter statsWriter,SampleCountInfo[] sampleCounts){
  for (int sampleIndex=0; sampleIndex < numberOfSamples; sampleIndex++) {
    alleleSet.clear();
    SampleCountInfo sci=sampleCounts[sampleIndex];
    int totalCount=0;
    for (    int sampleCount : sci.counts) {
      totalCount+=sampleCount;
    }
    statsWriter.setSampleValue(goodBaseCountFieldIndex,sampleIndex,totalCount);
    statsWriter.setSampleValue(failBaseCountFieldIndex,sampleIndex,sci.failedCount);
    int baseIndex=0;
    int genotypeCount=0;
    genotypeBuffer.setLength(0);
    char refBase='.';
    String referenceAllele=""String_Node_Str"";
    boolean siteObserved=false;
    for (    int count : sci.counts) {
      final char base=sci.base(baseIndex);
      if (count > 0) {
        siteObserved=true;
        alleleSet.add(base);
        if (base != sci.referenceBase) {
          statsWriter.addAlternateAllele(Character.toString(base));
          genotypeBuffer.append(String.format(""String_Node_Str"",base));
          genotypeCount++;
        }
 else {
          referenceAllele=Character.toString(sci.referenceBase);
          genotypeBuffer.append(String.format(""String_Node_Str"",base));
        }
      }
      baseIndex++;
    }
    if (siteObserved) {
      if (genotypeBuffer.length() > 1) {
        genotypeBuffer.setLength(genotypeBuffer.length() - 1);
      }
      statsWriter.setReferenceAllele(referenceAllele);
      statsWriter.setSampleValue(genotypeFieldIndex,sampleIndex,statsWriter.codeGenotype(genotypeBuffer.toString()));
      MutableString baseCountString=new MutableString();
      baseIndex=0;
      for (      int count : sci.counts) {
        final char base=sci.base(baseIndex);
        baseCountString.append(base);
        baseCountString.append('=');
        baseCountString.append(Integer.toString(count));
        baseIndex++;
        baseCountString.append(',');
      }
      baseCountString.setLength(baseCountString.length() - 1);
      statsWriter.setSampleValue(baseCountFieldIndex,sampleIndex,baseCountString);
    }
 else {
      statsWriter.setSampleValue(genotypeFieldIndex,sampleIndex,""String_Node_Str"");
    }
  }
}","public void writeGenotypes(VCFWriter statsWriter,SampleCountInfo[] sampleCounts){
  for (int sampleIndex=0; sampleIndex < numberOfSamples; sampleIndex++) {
    alleleSet.clear();
    SampleCountInfo sci=sampleCounts[sampleIndex];
    int totalCount=0;
    for (    int sampleCount : sci.counts) {
      totalCount+=sampleCount;
    }
    System.out.printf(""String_Node_Str"",totalCount,sci.failedCount);
    statsWriter.setSampleValue(goodBaseCountFieldIndex,sampleIndex,totalCount);
    statsWriter.setSampleValue(failBaseCountFieldIndex,sampleIndex,sci.failedCount);
    int baseIndex=0;
    int genotypeCount=0;
    genotypeBuffer.setLength(0);
    char refBase='.';
    String referenceAllele=""String_Node_Str"";
    boolean siteObserved=false;
    for (    int count : sci.counts) {
      final char base=sci.base(baseIndex);
      if (count > 0) {
        siteObserved=true;
        alleleSet.add(base);
        if (base != sci.referenceBase) {
          statsWriter.addAlternateAllele(Character.toString(base));
          genotypeBuffer.append(String.format(""String_Node_Str"",base));
          genotypeCount++;
        }
 else {
          referenceAllele=Character.toString(sci.referenceBase);
          genotypeBuffer.append(String.format(""String_Node_Str"",base));
        }
      }
      baseIndex++;
    }
    if (siteObserved) {
      if (genotypeBuffer.length() > 1) {
        genotypeBuffer.setLength(genotypeBuffer.length() - 1);
      }
      statsWriter.setReferenceAllele(referenceAllele);
      statsWriter.setSampleValue(genotypeFieldIndex,sampleIndex,statsWriter.codeGenotype(genotypeBuffer.toString()));
      MutableString baseCountString=new MutableString();
      baseIndex=0;
      for (      int count : sci.counts) {
        final char base=sci.base(baseIndex);
        baseCountString.append(base);
        baseCountString.append('=');
        baseCountString.append(Integer.toString(count));
        baseIndex++;
        baseCountString.append(',');
      }
      baseCountString.setLength(baseCountString.length() - 1);
      statsWriter.setSampleValue(baseCountFieldIndex,sampleIndex,baseCountString);
    }
 else {
      statsWriter.setSampleValue(genotypeFieldIndex,sampleIndex,""String_Node_Str"");
    }
  }
}"
50421,"/** 
 * Read the header of this file. Headers in the VCF format are supported, as well as TSV single header lines (with or without first character #.
 * @throws SyntaxException When the syntax of the VCF file is incorrect.
 */
public void readHeader() throws SyntaxException {
  globalFieldIndex=0;
  fieldIndexToName=new Int2ObjectOpenHashMap<String>();
  bufferedReader=new FastBufferedReader(input);
  lineIterator=new LineIterator(bufferedReader);
  int lineNumber=1;
  while (lineIterator.hasNext()) {
    line=lineIterator.next();
    if (!line.startsWith(""String_Node_Str"")) {
      if (lineNumber == 1) {
        parseHeaderLine(new MutableString(""String_Node_Str"" + line));
      }
 else {
        parseCurrentLine();
        hasNextDataLine=true;
      }
      break;
    }
    if (line.startsWith(""String_Node_Str"")) {
      TSV=false;
      processMetaInfoLine(line);
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      parseHeaderLine(line);
    }
    lineNumber++;
  }
}","/** 
 * Read the header of this file. Headers in the VCF format are supported, as well as TSV single header lines (with or without first character #.
 * @throws SyntaxException When the syntax of the VCF file is incorrect.
 */
public void readHeader() throws SyntaxException {
  if (headerParsed)   return;
  headerParsed=true;
  globalFieldIndex=0;
  fieldIndexToName=new Int2ObjectOpenHashMap<String>();
  bufferedReader=new FastBufferedReader(input);
  lineIterator=new LineIterator(bufferedReader);
  int lineNumber=1;
  while (lineIterator.hasNext()) {
    line=lineIterator.next();
    if (line.startsWith(""String_Node_Str"")) {
      TSV=false;
    }
    if (!line.startsWith(""String_Node_Str"")) {
      if (TSV && lineNumber == 1 && headerLineNotParsed) {
        parseHeaderLine(new MutableString(""String_Node_Str"" + line));
      }
 else {
        parseCurrentLine();
        hasNextDataLine=true;
      }
      break;
    }
    if (line.startsWith(""String_Node_Str"")) {
      TSV=false;
      processMetaInfoLine(line);
    }
 else     if (line.startsWith(""String_Node_Str"")) {
      parseHeaderLine(line);
    }
    lineNumber++;
  }
}"
50422,"/** 
 * Returns the value of the field. The field is identified by a global index that runs from zero (inclusive) to countAllFields() (exclusive).
 * @param globalFieldIndex a global index that runs from zero to countAllFields()
 * @return Value of this field.
 */
public CharSequence getFieldValue(int globalFieldIndex){
}","/** 
 * Returns the value of the field. The field is identified by a global index that runs from zero (inclusive) to countAllFields() (exclusive).
 * @param globalFieldIndex a global index that runs from zero to countAllFields()
 * @return Value of this field.
 */
public CharSequence getFieldValue(final int globalFieldIndex){
}"
50423,"private void parseHeaderLine(MutableString line){
  line=line.substring(1);
  String[] columnNames=line.toString().split(""String_Node_Str"");
  for (  String columnName : columnNames) {
    defineFixedColumn(columnName);
    if (!columns.hasColumnName(columnName)) {
      ColumnInfo formatColumn=columns.find(""String_Node_Str"");
      ColumnField[] fields;
      if (formatColumn != null) {
        fields=new ColumnField[formatColumn.fields.size()];
        int i=0;
        for (        ColumnField f : formatColumn.fields) {
          fields[i]=(new ColumnField(f.id,f.numberOfValues,f.type,f.description));
          i++;
        }
      }
 else {
        fields=new ColumnField[]{new ColumnField(""String_Node_Str"",1,ColumnType.String,""String_Node_Str"")};
      }
      ColumnInfo newCol=new ColumnInfo(columnName,fields);
      newCol.useFormat=true;
      columns.add(newCol);
    }
  }
  formatColumn=columns.find(""String_Node_Str"");
  for (  ColumnInfo column : columns) {
    if (column.columnIndex == -1) {
      column.columnIndex=globalColumnIndex++;
    }
    for (    ColumnField field : column.fields) {
      if (field.globalFieldIndex == -1) {
        field.globalFieldIndex=globalFieldIndex++;
      }
      final String name;
      if (column.fields.size() == 1) {
        name=column.columnName;
      }
 else {
        name=String.format(""String_Node_Str"",column.columnName,field.id);
      }
      fieldIndexToName.put(field.globalFieldIndex,name);
    }
  }
  formatColumnIndex=TSV ? -1 : formatColumn.columnIndex;
  numberOfColumns=globalColumnIndex;
  columnStarts=new int[numberOfColumns];
  columnEnds=new int[numberOfColumns];
  numberOfFields=TSV ? numberOfColumns : globalFieldIndex;
  fieldStarts=new int[numberOfFields];
  fieldEnds=new int[numberOfFields];
  fieldPermutation=new int[numberOfFields];
  columnList.addAll(columns);
  Collections.sort(columnList,COLUMN_SORT);
  for (  ColumnInfo column : columnList) {
    fieldList.addAll(column.fields);
  }
}","private void parseHeaderLine(MutableString line){
  headerLineNotParsed=false;
  line=line.substring(1);
  String[] columnNames=line.toString().split(""String_Node_Str"");
  for (  String columnName : columnNames) {
    defineFixedColumn(columnName);
    if (!columns.hasColumnName(columnName)) {
      ColumnInfo formatColumn=columns.find(""String_Node_Str"");
      ColumnField[] fields;
      if (formatColumn != null) {
        fields=new ColumnField[formatColumn.fields.size()];
        int i=0;
        for (        ColumnField f : formatColumn.fields) {
          fields[i]=(new ColumnField(f.id,f.numberOfValues,f.type,f.description));
          fields[i].globalFieldIndex=-1;
          i++;
        }
      }
 else {
        fields=new ColumnField[]{new ColumnField(""String_Node_Str"",1,ColumnType.String,""String_Node_Str"")};
        fields[0].globalFieldIndex=-1;
      }
      ColumnInfo newCol=new ColumnInfo(columnName,fields);
      newCol.useFormat=true;
      columns.add(newCol);
    }
  }
  formatColumn=columns.find(""String_Node_Str"");
  for (  ColumnInfo column : columns) {
    if (column.columnIndex == -1) {
      column.columnIndex=globalColumnIndex++;
    }
    for (    ColumnField field : column.fields) {
      if (field.globalFieldIndex == -1) {
        field.globalFieldIndex=globalFieldIndex++;
      }
      final String name;
      if (column.fields.size() == 1) {
        name=column.columnName;
      }
 else {
        name=String.format(""String_Node_Str"",column.columnName,field.id);
      }
      fieldIndexToName.put(field.globalFieldIndex,name);
    }
  }
  formatColumnIndex=TSV ? -1 : formatColumn.columnIndex;
  numberOfColumns=globalColumnIndex;
  columnStarts=new int[numberOfColumns];
  columnEnds=new int[numberOfColumns];
  numberOfFields=TSV ? numberOfColumns : globalFieldIndex;
  fieldStarts=new int[numberOfFields];
  fieldEnds=new int[numberOfFields];
  fieldPermutation=new int[numberOfFields];
  columnList.addAll(columns);
  Collections.sort(columnList,COLUMN_SORT);
  for (  ColumnInfo column : columnList) {
    fieldList.addAll(column.fields);
  }
}"
50424,"protected void adjustRefVarCounts(SampleCountInfo[] sampleCounts,int[] removed){
}","protected void adjustRefVarCounts(SampleCountInfo[] sampleCounts){
}"
50425,"/** 
 * Adjust list and sampleCounts to remove/reduce the effect of sequencing errors.
 * @param list Variation or reference bases at position
 * @param sampleCounts Counts for alleles at position each each sample under study.
 */
public abstract void filterBases(ObjectArrayList<PositionBaseInfo> list,SampleCountInfo[] sampleCounts,ObjectArrayList<PositionBaseInfo> filteredList);","/** 
 * Adjust list and sampleCounts to remove/reduce the effect of sequencing errors.
 * @param list         Variation or reference bases at position
 * @param sampleCounts Counts for alleles at position each each sample under study.
 */
public abstract void filterBases(ObjectArrayList<PositionBaseInfo> list,SampleCountInfo[] sampleCounts,ObjectArrayList<PositionBaseInfo> filteredList);"
50426,"public void filterBases(ObjectArrayList<PositionBaseInfo> list,SampleCountInfo[] sampleCounts,ObjectArrayList<PositionBaseInfo> filteredList){
  if (!fisherRInstalled) {
    if (firstReport) {
      System.err.println(""String_Node_Str"");
      firstReport=false;
    }
    return;
  }
  for (  SampleCountInfo sci : sampleCounts) {
    final ReadIndexStats stats=readIndexStats.get(sci.sampleIndex);
    ObjectArrayList<PositionBaseInfo> considered=new ObjectArrayList<PositionBaseInfo>();
    for (int baseIndex=SampleCountInfo.BASE_A_INDEX; baseIndex < SampleCountInfo.BASE_MAX_INDEX; baseIndex++) {
      considered.clear();
      int observedReferenceCount=0;
      double expectedVariationRate=0;
      int expectedVariationCount=0;
      int expectedReferenceCount=0;
      int observedVariationCount=0;
      int totalCount=0;
      for (      int count : sci.counts) {
        totalCount+=count;
      }
      observedVariationCount=sci.counts[baseIndex];
      if (observedVariationCount == 0) {
        continue;
      }
      long sum=0;
      for (      PositionBaseInfo info : list) {
        if (info.readerIndex != sci.sampleIndex)         continue;
        final int readIndex=info.readIndex;
        if (readIndex < 1 || readIndex > stats.countVariationBases.length || readIndex > stats.countReferenceBases.length) {
          continue;
        }
        long variationBases=stats.countVariationBases[readIndex - 1];
        long referenceBases=stats.countReferenceBases[readIndex - 1];
        expectedVariationRate+=variationBases;
        sum+=variationBases + referenceBases;
        if (info.to == sci.base(baseIndex)) {
          considered.add(info);
        }
      }
      expectedVariationRate/=sum;
      expectedVariationCount=(int)Math.round(expectedVariationRate * (double)(totalCount));
      expectedReferenceCount=(int)Math.round((1 - expectedVariationRate) * (double)(totalCount));
      int count00=expectedVariationCount;
      int count10=observedVariationCount;
      int count01=totalCount - count00;
      int count11=totalCount - count01;
      Double pValue;
{
        contingencyValue value=new contingencyValue(count00,count10,count01,count11);
        pValue=(Double)fisherPCache.get(value);
        if (pValue == null) {
          pValue=estimatePValue(count00,count10,count01,count11);
          fisherPCache.put(value,pValue);
        }
      }
      if (pValue > pValueThreshold) {
        int numErroneouslyCalledBases=sci.counts[baseIndex];
        sci.counts[baseIndex]=0;
        filteredList.addAll(considered);
        char base=sci.base(baseIndex);
        if (base == sci.referenceBase) {
          sci.refCount=0;
        }
 else {
          sci.varCount-=numErroneouslyCalledBases;
        }
      }
    }
  }
  numScreened+=list.size();
  numFiltered+=filteredList.size();
}","public void filterBases(ObjectArrayList<PositionBaseInfo> list,SampleCountInfo[] sampleCounts,ObjectArrayList<PositionBaseInfo> filteredList){
  if (!fisherRInstalled) {
    if (firstReport) {
      System.err.println(""String_Node_Str"");
      firstReport=false;
    }
    return;
  }
  initStorage(sampleCounts.length);
  resetCounters();
  for (  SampleCountInfo sci : sampleCounts) {
    final ReadIndexStats stats=readIndexStats.get(sci.sampleIndex);
    ObjectArrayList<PositionBaseInfo> considered=new ObjectArrayList<PositionBaseInfo>();
    for (int baseIndex=SampleCountInfo.BASE_A_INDEX; baseIndex < SampleCountInfo.BASE_MAX_INDEX; baseIndex++) {
      considered.clear();
      int observedReferenceCount=0;
      double expectedVariationRate=0;
      int expectedVariationCount=0;
      int expectedReferenceCount=0;
      int observedVariationCount=0;
      int totalCount=0;
      for (      int count : sci.counts) {
        totalCount+=count;
      }
      observedVariationCount=sci.counts[baseIndex];
      if (observedVariationCount == 0) {
        continue;
      }
      long sum=0;
      for (      PositionBaseInfo info : list) {
        if (info.readerIndex != sci.sampleIndex)         continue;
        final int readIndex=info.readIndex;
        if (readIndex < 1 || readIndex > stats.countVariationBases.length || readIndex > stats.countReferenceBases.length) {
          continue;
        }
        long variationBases=stats.countVariationBases[readIndex - 1];
        long referenceBases=stats.countReferenceBases[readIndex - 1];
        expectedVariationRate+=variationBases;
        sum+=variationBases + referenceBases;
        if (info.to == sci.base(baseIndex)) {
          considered.add(info);
        }
      }
      expectedVariationRate/=sum;
      expectedVariationCount=(int)Math.round(expectedVariationRate * (double)(totalCount));
      expectedReferenceCount=(int)Math.round((1 - expectedVariationRate) * (double)(totalCount));
      int count00=expectedVariationCount;
      int count10=observedVariationCount;
      int count01=totalCount - count00;
      int count11=totalCount - count01;
      Double pValue;
{
        contingencyValue value=new contingencyValue(count00,count10,count01,count11);
        pValue=(Double)fisherPCache.get(value);
        if (pValue == null) {
          pValue=estimatePValue(count00,count10,count01,count11);
          fisherPCache.put(value,pValue);
        }
      }
      if (pValue > pValueThreshold) {
        int numErroneouslyCalledBases=sci.counts[baseIndex];
        sci.counts[baseIndex]=0;
        filteredList.addAll(considered);
        char base=sci.base(baseIndex);
        int sampleIndex=sci.sampleIndex;
        if (base == sci.referenceBase) {
          refCountRemovedPerSample[sampleIndex]++;
        }
 else {
          varCountRemovedPerSample[sampleIndex]++;
        }
      }
    }
  }
  numScreened+=list.size();
  numFiltered+=filteredList.size();
  adjustRefVarCounts(sampleCounts);
}"
50427,"public void filterBases(ObjectArrayList<PositionBaseInfo> list,SampleCountInfo[] sampleCounts,ObjectArrayList<PositionBaseInfo> filteredList){
  resetCounters();
  int removedBaseCount=filteredList.size() / sampleCounts.length;
  int removedBaseCountThreshold=removedBaseCount * MULTIPLIER;
  Arrays.fill(removed,0);
  for (  PositionBaseInfo positionBaseInfo : list) {
    numScreened++;
    final int sampleIndex=positionBaseInfo.readerIndex;
    char base=positionBaseInfo.matchesReference ? positionBaseInfo.from : positionBaseInfo.to;
    final SampleCountInfo sampleCountInfo=sampleCounts[sampleIndex];
    final int baseIndex=sampleCountInfo.baseIndex(base);
    final int count=sampleCountInfo.counts[baseIndex];
    if (count == 0)     continue;
    if (count < removedBaseCountThreshold) {
      removed[baseIndex]++;
      sampleCountInfo.counts[baseIndex]=0;
      filteredList.add(positionBaseInfo);
      numFiltered++;
    }
  }
  adjustRefVarCounts(sampleCounts,removed);
}","public void filterBases(ObjectArrayList<PositionBaseInfo> list,SampleCountInfo[] sampleCounts,ObjectArrayList<PositionBaseInfo> filteredList){
  resetCounters();
  initStorage(sampleCounts.length);
  int removedBaseCount=filteredList.size() / sampleCounts.length;
  int removedBaseCountThreshold=removedBaseCount * MULTIPLIER;
  Arrays.fill(removed,0);
  int removedVarCount=0;
  for (  PositionBaseInfo positionBaseInfo : list) {
    numScreened++;
    final int sampleIndex=positionBaseInfo.readerIndex;
    char base=positionBaseInfo.matchesReference ? positionBaseInfo.from : positionBaseInfo.to;
    final SampleCountInfo sampleCountInfo=sampleCounts[sampleIndex];
    final int baseIndex=sampleCountInfo.baseIndex(base);
    final int count=sampleCountInfo.counts[baseIndex];
    if (count == 0)     continue;
    if (count < removedBaseCountThreshold) {
      sampleCountInfo.counts[baseIndex]--;
      if (base == sampleCountInfo.referenceBase) {
        refCountRemovedPerSample[sampleIndex]++;
      }
 else {
        varCountRemovedPerSample[sampleIndex]++;
      }
      filteredList.add(positionBaseInfo);
      numFiltered++;
    }
  }
  adjustRefVarCounts(sampleCounts);
}"
50428,"@Override public String toString(){
  return matchesReference ? ""String_Node_Str"" + from : from + ""String_Node_Str"" + to+ ""String_Node_Str""+ qualityScore;
}","@Override public String toString(){
  return matchesReference ? String.format(""String_Node_Str"",from,readerIndex) : String.format(""String_Node_Str"",from,to,qualityScore,readerIndex);
}"
50429,"public void filterBases(ObjectArrayList<PositionBaseInfo> list,SampleCountInfo[] sampleCounts,ObjectArrayList<PositionBaseInfo> filteredList){
  resetCounters();
  Arrays.fill(removed,0);
  for (  PositionBaseInfo info : list) {
    numScreened++;
    if (!info.matchesReference && info.qualityScore < scoreThreshold) {
      filteredList.add(info);
      final SampleCountInfo countInfo=sampleCounts[info.readerIndex];
      final int baseIndex=countInfo.baseIndex(info.to);
      countInfo.counts[baseIndex]--;
      removed[baseIndex]++;
      numFiltered++;
    }
  }
  adjustRefVarCounts(sampleCounts,removed);
}","public void filterBases(ObjectArrayList<PositionBaseInfo> list,SampleCountInfo[] sampleCounts,ObjectArrayList<PositionBaseInfo> filteredList){
  resetCounters();
  initStorage(sampleCounts.length);
  Arrays.fill(removed,0);
  int removedVarCount=0;
  for (  PositionBaseInfo info : list) {
    numScreened++;
    if (!info.matchesReference && info.qualityScore < scoreThreshold) {
      filteredList.add(info);
      final SampleCountInfo countInfo=sampleCounts[info.readerIndex];
      final int baseIndex=countInfo.baseIndex(info.to);
      countInfo.counts[baseIndex]--;
      removed[baseIndex]++;
      this.varCountRemovedPerSample[info.readerIndex]++;
      numFiltered++;
    }
  }
  adjustRefVarCounts(sampleCounts);
}"
50430,"private void parseHeaderLine(MutableString line){
  line=line.substring(1);
  String[] columnNames=line.toString().split(""String_Node_Str"");
  for (  String columnName : columnNames) {
    defineFixedColumn(columnName);
    if (!columns.hasColumnName(columnName)) {
      ColumnInfo formatColumn=columns.find(""String_Node_Str"");
      ColumnField[] fields;
      if (formatColumn != null) {
        fields=new ColumnField[formatColumn.fields.size()];
        int i=0;
        for (        ColumnField f : formatColumn.fields) {
          fields[i]=(new ColumnField(f.id,f.numberOfValues,f.type,f.description));
          i++;
        }
      }
 else {
        fields=new ColumnField[]{new ColumnField(""String_Node_Str"",1,ColumnType.String,""String_Node_Str"")};
      }
      ColumnInfo newCol=new ColumnInfo(columnName,fields);
      newCol.useFormat=true;
      columns.add(newCol);
    }
  }
  formatColumn=columns.find(""String_Node_Str"");
  for (  ColumnInfo column : columns) {
    if (column.columnIndex == -1) {
      column.columnIndex=globalColumnIndex++;
    }
    for (    ColumnField field : column.fields) {
      if (field.globalFieldIndex == -1) {
        field.globalFieldIndex=globalFieldIndex++;
      }
      final String name;
      if (column.fields.size() == 1) {
        name=column.columnName;
      }
 else {
        name=String.format(""String_Node_Str"",column.columnName,field.id);
      }
      fieldIndexToName.put(field.globalFieldIndex,name);
    }
  }
  formatColumnIndex=formatColumn.columnIndex;
  numberOfColumns=globalColumnIndex;
  columnStarts=new int[numberOfColumns];
  columnEnds=new int[numberOfColumns];
  numberOfFields=TSV ? numberOfColumns : globalFieldIndex;
  fieldStarts=new int[numberOfFields];
  fieldEnds=new int[numberOfFields];
  fieldPermutation=new int[numberOfFields];
  columnList.addAll(columns);
  Collections.sort(columnList,COLUMN_SORT);
  for (  ColumnInfo column : columnList) {
    fieldList.addAll(column.fields);
  }
}","private void parseHeaderLine(MutableString line){
  line=line.substring(1);
  String[] columnNames=line.toString().split(""String_Node_Str"");
  for (  String columnName : columnNames) {
    defineFixedColumn(columnName);
    if (!columns.hasColumnName(columnName)) {
      ColumnInfo formatColumn=columns.find(""String_Node_Str"");
      ColumnField[] fields;
      if (formatColumn != null) {
        fields=new ColumnField[formatColumn.fields.size()];
        int i=0;
        for (        ColumnField f : formatColumn.fields) {
          fields[i]=(new ColumnField(f.id,f.numberOfValues,f.type,f.description));
          i++;
        }
      }
 else {
        fields=new ColumnField[]{new ColumnField(""String_Node_Str"",1,ColumnType.String,""String_Node_Str"")};
      }
      ColumnInfo newCol=new ColumnInfo(columnName,fields);
      newCol.useFormat=true;
      columns.add(newCol);
    }
  }
  formatColumn=columns.find(""String_Node_Str"");
  for (  ColumnInfo column : columns) {
    if (column.columnIndex == -1) {
      column.columnIndex=globalColumnIndex++;
    }
    for (    ColumnField field : column.fields) {
      if (field.globalFieldIndex == -1) {
        field.globalFieldIndex=globalFieldIndex++;
      }
      final String name;
      if (column.fields.size() == 1) {
        name=column.columnName;
      }
 else {
        name=String.format(""String_Node_Str"",column.columnName,field.id);
      }
      fieldIndexToName.put(field.globalFieldIndex,name);
    }
  }
  formatColumnIndex=TSV ? -1 : formatColumn.columnIndex;
  numberOfColumns=globalColumnIndex;
  columnStarts=new int[numberOfColumns];
  columnEnds=new int[numberOfColumns];
  numberOfFields=TSV ? numberOfColumns : globalFieldIndex;
  fieldStarts=new int[numberOfFields];
  fieldEnds=new int[numberOfFields];
  fieldPermutation=new int[numberOfFields];
  columnList.addAll(columns);
  Collections.sort(columnList,COLUMN_SORT);
  for (  ColumnInfo column : columnList) {
    fieldList.addAll(column.fields);
  }
}"
50431,"@Override public void processAlignmentEntry(final AlignmentReader alignmentReader,final Alignments.AlignmentEntry alignmentEntry){
  String basename=alignmentReader.basename();
  basename=FilenameUtils.getBaseName(basename);
switch (outputFormat) {
case CONCISE:
{
      if (alignmentEntry.getSequenceVariationsCount() > 0) {
        outputStream.print(String.format(""String_Node_Str"",alignmentEntry.getQueryIndex(),getReferenceId(alignmentEntry.getTargetIndex())));
        boolean variations=false;
        for (        final Alignments.SequenceVariation var : alignmentEntry.getSequenceVariationsList()) {
          variations=true;
          final int positionOnReference=alignmentEntry.getPosition() + var.getPosition();
          final int referenceIndex=alignmentEntry.getTargetIndex();
          boolean keepVar=true;
          keepVar=determineKeepVariation(positionOnReference,referenceIndex,keepVar);
          if (keepVar) {
            outputStream.print(String.format(""String_Node_Str"",positionOnReference,var.getReadIndex(),var.getFrom(),var.getTo()));
          }
        }
        if (variations) {
          outputStream.println();
        }
      }
    }
  break;
case TSV:
case TAB_DELIMITED:
{
  final boolean variations=false;
  for (  final Alignments.SequenceVariation var : alignmentEntry.getSequenceVariationsList()) {
    final int positionOnReference=alignmentEntry.getPosition() + var.getPosition();
    final int readIndex=var.getReadIndex();
    final String from=var.getFrom();
    final String to=var.getTo();
    final int referenceIndex=alignmentEntry.getTargetIndex();
    boolean keepVar=true;
    keepVar=determineKeepVariation(positionOnReference,referenceIndex,keepVar);
    if (keepVar && !isAllNs(to)) {
      printTab(alignmentEntry,basename,positionOnReference,readIndex,from,to);
    }
  }
}
break;
case TAB_SINGLE_BASE:
{
boolean variations=false;
for (final Alignments.SequenceVariation var : alignmentEntry.getSequenceVariationsList()) {
final int positionOnReference=alignmentEntry.getPosition() + var.getPosition();
final int readIndex=var.getReadIndex();
final String from=var.getFrom();
final String to=var.getTo();
final int fromLength=from.length();
final int toLength=to.length();
final int referenceIndex=alignmentEntry.getTargetIndex();
boolean keepVar=true;
keepVar=determineKeepVariation(positionOnReference,referenceIndex,keepVar);
if (keepVar && !isAllNs(to)) {
  variations=true;
  final int maxLength=Math.max(fromLength,toLength);
  for (int i=0; i < maxLength; i++) {
    final int offset=+i * (alignmentEntry.getMatchingReverseStrand() ? -1 : 1);
    printTab(alignmentEntry,basename,positionOnReference + offset,readIndex + offset,i < fromLength ? from.substring(i,i + 1) : ""String_Node_Str"",i < toLength ? to.substring(i,i + 1) : ""String_Node_Str"");
  }
}
}
}
break;
}
}","@Override public void processAlignmentEntry(final AlignmentReader alignmentReader,final Alignments.AlignmentEntry alignmentEntry){
  String basename=alignmentReader.basename();
  basename=FilenameUtils.getBaseName(basename);
switch (outputFormat) {
case CONCISE:
{
      if (alignmentEntry.getSequenceVariationsCount() > 0) {
        outputStream.print(String.format(""String_Node_Str"",alignmentEntry.getQueryIndex(),getReferenceId(alignmentEntry.getTargetIndex())));
        boolean variations=false;
        for (        final Alignments.SequenceVariation var : alignmentEntry.getSequenceVariationsList()) {
          variations=true;
          final int positionOnReference=alignmentEntry.getPosition() + var.getPosition();
          final int referenceIndex=alignmentEntry.getTargetIndex();
          boolean keepVar=true;
          keepVar=determineKeepVariation(positionOnReference,referenceIndex,keepVar);
          if (keepVar) {
            outputStream.print(String.format(""String_Node_Str"",positionOnReference,var.getReadIndex(),var.getFrom(),var.getTo()));
          }
        }
        if (variations) {
          outputStream.println();
        }
      }
    }
  break;
case TSV:
case TAB_DELIMITED:
{
  final boolean variations=false;
  for (  final Alignments.SequenceVariation var : alignmentEntry.getSequenceVariationsList()) {
    final int positionOnReference=alignmentEntry.getPosition() + var.getPosition();
    final int readIndex=var.getReadIndex();
    final String from=var.getFrom();
    final String to=var.getTo();
    final int referenceIndex=alignmentEntry.getTargetIndex();
    boolean keepVar=true;
    keepVar=determineKeepVariation(positionOnReference,referenceIndex,keepVar);
    if (keepVar && !isAllNs(to)) {
      printTab(alignmentEntry,basename,positionOnReference,readIndex,from,to);
    }
  }
}
break;
case TAB_SINGLE_BASE:
{
boolean variations=false;
for (final Alignments.SequenceVariation var : alignmentEntry.getSequenceVariationsList()) {
final int positionOnReference=alignmentEntry.getPosition() + var.getPosition();
final int readIndex=var.getReadIndex();
final String from=var.getFrom();
final String to=var.getTo();
final int fromLength=from.length();
final int toLength=to.length();
final int referenceIndex=alignmentEntry.getTargetIndex();
boolean keepVar=true;
keepVar=determineKeepVariation(positionOnReference,referenceIndex,keepVar);
if (keepVar && !isAllNs(to)) {
  variations=true;
  final int maxLength=Math.max(fromLength,toLength);
  int offset=-1;
  for (int i=0; i < maxLength; i++) {
    char toChar=var.getTo().charAt(i);
    offset+=toChar == '-' ? 0 : (alignmentEntry.getMatchingReverseStrand() ? -1 : 1);
    printTab(alignmentEntry,basename,positionOnReference + offset,readIndex + offset,i < fromLength ? from.substring(i,i + 1) : ""String_Node_Str"",i < toLength ? to.substring(i,i + 1) : ""String_Node_Str"");
  }
}
}
}
break;
}
}"
50432,"@Override public void processAlignmentEntry(final AlignmentReader alignmentReader,final Alignments.AlignmentEntry alignmentEntry){
  numAlignmentEntries+=alignmentEntry.getMultiplicity();
  referenceBaseCount+=alignmentEntry.getQueryLength();
  for (  final Alignments.SequenceVariation var : alignmentEntry.getSequenceVariationsList()) {
    int toLength=var.getTo().length();
    for (int i=0; i < toLength; i++) {
      if (var.getReadIndex() < 0) {
        System.out.printf(""String_Node_Str"",var.getReadIndex());
      }
      final int readIndex=var.getReadIndex() + (alignmentEntry.getMatchingReverseStrand() ? 0 : 1) * i;
      final int value=readIndexVariationTally.get(readIndex);
      final int changedBases=alignmentEntry.getMultiplicity();
      readIndexVariationTally.put(readIndex,value + changedBases);
      referenceBaseCount-=changedBases;
    }
  }
}","@Override public void processAlignmentEntry(final AlignmentReader alignmentReader,final Alignments.AlignmentEntry alignmentEntry){
  numAlignmentEntries+=alignmentEntry.getMultiplicity();
  referenceBaseCount+=alignmentEntry.getQueryLength();
  for (  final Alignments.SequenceVariation var : alignmentEntry.getSequenceVariationsList()) {
    int toLength=var.getTo().length();
    int readIndex=var.getReadIndex();
    for (int i=0; i < toLength; i++) {
      if (var.getReadIndex() < 0) {
        System.out.printf(""String_Node_Str"",var.getReadIndex());
      }
      char toChar=var.getTo().charAt(i);
      readIndex+=toChar == '-' ? 0 : (alignmentEntry.getMatchingReverseStrand() ? -1 : 1);
      final int value=readIndexVariationTally.get(readIndex);
      final int changedBases=alignmentEntry.getMultiplicity();
      readIndexVariationTally.put(readIndex,value + changedBases);
      referenceBaseCount-=changedBases;
    }
  }
}"
50433,"public void initialize(DifferentialExpressionAnalysis deAnalyzer,DifferentialExpressionCalculator deCalculator,String[] groups,ObjectArrayList<DiscoverSequenceVariantsMode.ReadIndexStats> readIndexStats,PrintWriter outWriter){
  if (deAnalyzer.eval(""String_Node_Str"") || deAnalyzer.eval(""String_Node_Str"")) {
    final Rengine rEngine=GobyRengine.getInstance().getRengine();
    fisherRInstalled=rEngine != null && rEngine.isAlive();
  }
  if (deAnalyzer.eval(""String_Node_Str"") && groups.length != 2) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  statWriter=new StatisticsWriter(outWriter);
  this.groups=groups;
  this.readIndexStats=readIndexStats;
  refIdColumnIndex=statWriter.defineColumn(""String_Node_Str"");
  positionColumnIndex=statWriter.defineColumn(""String_Node_Str"");
  log2OddsRatioColumnIndex=StatisticsWriter.COLUMN_NOT_DEFINED;
  fisherExactPValueColumnIndex=-1;
  numberOfGroups=groups.length;
  samples=deCalculator.samples();
  numberOfSamples=samples.length;
  refCountsPerGroup=new int[numberOfGroups];
  variantsCountPerGroup=new int[numberOfGroups];
  distinctReadIndexCountPerGroup=new int[numberOfGroups];
  averageVariantQualityScorePerGroup=new float[numberOfGroups];
  refCountsPerSample=new int[numberOfSamples];
  variantsCountPerSample=new int[numberOfSamples];
  this.deAnalyzer=deAnalyzer;
  this.deCalculator=deCalculator;
  if (this.deAnalyzer.eval(""String_Node_Str"")) {
    log2OddsRatioColumnIndex=statWriter.defineColumn(""String_Node_Str"",groups[0],groups[1]);
    log2OddsRatioStandardErrorColumnIndex=statWriter.defineColumn(""String_Node_Str"");
    log2OddsRatioZColumnIndex=statWriter.defineColumn(""String_Node_Str"");
    fisherExactPValueColumnIndex=statWriter.defineColumn(""String_Node_Str"",groups[0],groups[1]);
  }
  statWriter.defineColumnSet(groups,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  for (  String group : groups) {
    if (deAnalyzer.eval(""String_Node_Str"")) {
      statWriter.defineColumn(""String_Node_Str"",group);
    }
    statWriter.defineColumn(""String_Node_Str"",group);
  }
  if (deAnalyzer.eval(""String_Node_Str"")) {
    statWriter.defineColumnSet(deCalculator.samples(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  statWriter.writeHeader();
}","public void initialize(DifferentialExpressionAnalysis deAnalyzer,DifferentialExpressionCalculator deCalculator,String[] groups,ObjectArrayList<DiscoverSequenceVariantsMode.ReadIndexStats> readIndexStats,PrintWriter outWriter){
  if (deAnalyzer.eval(""String_Node_Str"") || deAnalyzer.eval(""String_Node_Str"")) {
    final Rengine rEngine=GobyRengine.getInstance().getRengine();
    fisherRInstalled=rEngine != null && rEngine.isAlive();
  }
  if (deAnalyzer.eval(""String_Node_Str"") && groups.length != 2) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  statWriter=new StatisticsWriter(outWriter);
  this.groups=groups;
  this.readIndexStats=readIndexStats;
  refIdColumnIndex=statWriter.defineColumn(""String_Node_Str"");
  positionColumnIndex=statWriter.defineColumn(""String_Node_Str"");
  log2OddsRatioColumnIndex=StatisticsWriter.COLUMN_NOT_DEFINED;
  fisherExactPValueColumnIndex=-1;
  numberOfGroups=groups.length;
  String[] deCalcSamples=deCalculator.samples();
  numberOfSamples=deCalcSamples.length;
  samples=new String[numberOfSamples];
  for (  DiscoverSequenceVariantsMode.ReadIndexStats stat : readIndexStats) {
    samples[stat.readerIndex]=stat.basename;
  }
  refCountsPerGroup=new int[numberOfGroups];
  variantsCountPerGroup=new int[numberOfGroups];
  distinctReadIndexCountPerGroup=new int[numberOfGroups];
  averageVariantQualityScorePerGroup=new float[numberOfGroups];
  refCountsPerSample=new int[numberOfSamples];
  variantsCountPerSample=new int[numberOfSamples];
  this.deAnalyzer=deAnalyzer;
  this.deCalculator=deCalculator;
  if (this.deAnalyzer.eval(""String_Node_Str"")) {
    log2OddsRatioColumnIndex=statWriter.defineColumn(""String_Node_Str"",groups[0],groups[1]);
    log2OddsRatioStandardErrorColumnIndex=statWriter.defineColumn(""String_Node_Str"");
    log2OddsRatioZColumnIndex=statWriter.defineColumn(""String_Node_Str"");
    fisherExactPValueColumnIndex=statWriter.defineColumn(""String_Node_Str"",groups[0],groups[1]);
  }
  statWriter.defineColumnSet(groups,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  for (  String group : groups) {
    if (deAnalyzer.eval(""String_Node_Str"")) {
      statWriter.defineColumn(""String_Node_Str"",group);
    }
    statWriter.defineColumn(""String_Node_Str"",group);
  }
  if (deAnalyzer.eval(""String_Node_Str"")) {
    statWriter.defineColumnSet(deCalculator.samples(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  }
  statWriter.writeHeader();
}"
50434,"private byte[] trimQualityScores(byte[] qualityScores,int trimReadStartLength,int trimReadLength,int initialLength){
  if (qualityScores == null)   return null;
  byte[] trimmedScores=new byte[Math.min(initialLength,trimReadLength) - trimReadStartLength];
  int trimmedIndex=0;
  for (int i=0; i < Math.min(initialLength,trimReadLength); i++) {
    if (i >= trimReadStartLength) {
      trimmedScores[trimmedIndex]=qualityScores[i];
    }
 else {
      if (i > trimReadLength)       return trimmedScores;
    }
    trimmedIndex++;
  }
  return trimmedScores;
}","private byte[] trimQualityScores(byte[] qualityScores,int trimReadStartLength,int trimReadLength,int initialLength){
  if (qualityScores == null)   return null;
  int offset=trimReadStartLength;
  if (offset < 0)   offset=0;
  byte[] trimmedScores=new byte[Math.min(initialLength,trimReadLength) - offset];
  int trimmedIndex=0;
  for (int i=0; i < Math.min(initialLength,trimReadLength); i++) {
    if (i >= trimReadStartLength) {
      trimmedScores[trimmedIndex]=qualityScores[i];
    }
 else {
      if (i > trimReadLength)       return trimmedScores;
    }
    trimmedIndex++;
  }
  return trimmedScores;
}"
50435,"/** 
 * Reformat compact reads.
 * @throws IOException
 */
@Override public void execute() throws IOException {
  final int numToProcess=inputFilenames.length;
  int numProcessed=0;
  final MutableString sequence=new MutableString();
  final MutableString sequencePair=new MutableString();
  ReadSet readIndexFilter=new ReadSet();
  if (readIndexFilterFile == null) {
    readIndexFilter=null;
  }
 else {
    readIndexFilter.load(readIndexFilterFile);
  }
  for (  final String inputFilename : inputFilenames) {
    int splitIndex=0;
    final String outputBasename;
    final String outputFilename;
    if (numToProcess == 1 && StringUtils.isNotBlank(outputFile)) {
      outputBasename=outputFile;
      boolean hasCompactExtension=false;
      for (      final String extension : FileExtensionHelper.COMPACT_READS_FILE_EXTS) {
        if (outputFile.endsWith(extension)) {
          hasCompactExtension=true;
          break;
        }
      }
      if (hasCompactExtension) {
        outputFilename=outputFile;
      }
 else {
        outputFilename=getOutputFilename(outputBasename,++splitIndex);
      }
    }
 else {
      outputBasename=stripCompactReadExtensions(inputFilename);
      outputFilename=getOutputFilename(outputBasename,++splitIndex);
    }
    if (inputFilename.equals(outputFilename)) {
      System.err.println(""String_Node_Str"");
      System.exit(2);
    }
    System.out.printf(""String_Node_Str"",++numProcessed,numToProcess,inputFilename,outputFilename);
    outputFilenames.add(outputFilename);
    ReadsWriter writer=new ReadsWriter(new FileOutputStream(outputFilename));
    writer.setNumEntriesPerChunk(sequencePerChunk);
    final ReadsReader readsReader;
    final FastBufferedInputStream inputFileStream=new FastBufferedInputStream(new FileInputStream(inputFilename));
    if (hasStartOrEndPosition) {
      readsReader=new ReadsReader(startPosition,endPosition,inputFileStream);
    }
 else {
      readsReader=new ReadsReader(inputFileStream);
    }
    int entriesInOutputFile=0;
    for (    final Reads.ReadEntry entry : readsReader) {
      if (readIndexFilter == null || readIndexFilter.contains(entry.getReadIndex())) {
        final int readLength=entry.getReadLength();
        if (readLength < minReadLength || readLength > maxReadLength) {
          continue;
        }
        for (int i=0; i < entry.getMetaDataCount(); i++) {
          Reads.MetaData metaData=entry.getMetaData(i);
          writer.appendMetaData(metaData.getKey(),metaData.getValue());
        }
        if (pushDescription && entry.hasDescription()) {
          writer.setDescription(entry.getDescription());
        }
        if (pushIdentifier && entry.hasReadIdentifier()) {
          writer.setIdentifier(entry.getReadIdentifier());
        }
        processSequenceAndQualityScores(entry,sequence,sequencePair,writer,false);
        processSequenceAndQualityScores(entry,sequence,sequencePair,writer,true);
        writer.appendEntry(entry.getReadIndex());
        entriesInOutputFile++;
        if (entriesInOutputFile > sequencePerOutput) {
          writer.close();
          final String newOutputFilename=getOutputFilename(outputBasename,++splitIndex);
          outputFilenames.add(newOutputFilename);
          System.out.printf(""String_Node_Str"",newOutputFilename);
          writer=new ReadsWriter(new FileOutputStream(newOutputFilename));
          writer.setNumEntriesPerChunk(sequencePerChunk);
          entriesInOutputFile=0;
        }
      }
    }
    writer.close();
    writer.printStats(System.out);
  }
}","/** 
 * Reformat compact reads.
 * @throws IOException
 */
@Override public void execute() throws IOException {
  final int numToProcess=inputFilenames.length;
  int numProcessed=0;
  final MutableString sequence=new MutableString();
  final MutableString sequencePair=new MutableString();
  ReadSet readIndexFilter=new ReadSet();
  if (readIndexFilterFile == null) {
    readIndexFilter=null;
  }
 else {
    readIndexFilter.load(readIndexFilterFile);
  }
  for (  final String inputFilename : inputFilenames) {
    int splitIndex=0;
    final String outputBasename;
    final String outputFilename;
    if (numToProcess == 1 && StringUtils.isNotBlank(outputFile)) {
      outputBasename=outputFile;
      boolean hasCompactExtension=false;
      for (      final String extension : FileExtensionHelper.COMPACT_READS_FILE_EXTS) {
        if (outputFile.endsWith(extension)) {
          hasCompactExtension=true;
          break;
        }
      }
      if (hasCompactExtension) {
        outputFilename=outputFile;
      }
 else {
        outputFilename=getOutputFilename(outputBasename,++splitIndex);
      }
    }
 else {
      outputBasename=stripCompactReadExtensions(inputFilename);
      outputFilename=getOutputFilename(outputBasename,++splitIndex);
    }
    if (inputFilename.equals(outputFilename)) {
      System.err.println(""String_Node_Str"");
      System.exit(2);
    }
    System.out.printf(""String_Node_Str"",++numProcessed,numToProcess,inputFilename,outputFilename);
    outputFilenames.add(outputFilename);
    ReadsWriter writer=new ReadsWriter(new FileOutputStream(outputFilename));
    writer.setNumEntriesPerChunk(sequencePerChunk);
    final ReadsReader readsReader;
    final FastBufferedInputStream inputFileStream=new FastBufferedInputStream(new FileInputStream(inputFilename));
    if (hasStartOrEndPosition) {
      readsReader=new ReadsReader(startPosition,endPosition,inputFileStream);
    }
 else {
      readsReader=new ReadsReader(inputFileStream);
    }
    int entriesInOutputFile=0;
    DistinctIntValueCounter allEntries=new DistinctIntValueCounter();
    int numReadsKept=0;
    for (    final Reads.ReadEntry entry : readsReader) {
      allEntries.observe(entry.getReadIndex());
      if (readIndexFilter == null || readIndexFilter.contains(entry.getReadIndex())) {
        final int readLength=entry.getReadLength();
        if (readLength < minReadLength || readLength > maxReadLength) {
          continue;
        }
        for (int i=0; i < entry.getMetaDataCount(); i++) {
          Reads.MetaData metaData=entry.getMetaData(i);
          writer.appendMetaData(metaData.getKey(),metaData.getValue());
        }
        if (pushDescription && entry.hasDescription()) {
          writer.setDescription(entry.getDescription());
        }
        if (pushIdentifier && entry.hasReadIdentifier()) {
          writer.setIdentifier(entry.getReadIdentifier());
        }
        processSequenceAndQualityScores(entry,sequence,sequencePair,writer,false);
        processSequenceAndQualityScores(entry,sequence,sequencePair,writer,true);
        writer.appendEntry(entry.getReadIndex());
        numReadsKept++;
        entriesInOutputFile++;
        if (entriesInOutputFile > sequencePerOutput) {
          writer.close();
          final String newOutputFilename=getOutputFilename(outputBasename,++splitIndex);
          outputFilenames.add(newOutputFilename);
          System.out.printf(""String_Node_Str"",newOutputFilename);
          writer=new ReadsWriter(new FileOutputStream(newOutputFilename));
          writer.setNumEntriesPerChunk(sequencePerChunk);
          entriesInOutputFile=0;
        }
      }
    }
    float rate=allEntries.count();
    rate-=numReadsKept;
    rate/=allEntries.count();
    if (readIndexFilter != null)     System.out.printf(""String_Node_Str"",rate);
    writer.close();
    writer.printStats(System.out);
  }
}"
50436,"/** 
 * Skip all entries that have position before (targetIndex,position). This method will use the alignment index to skip directly to the closest chunk start before the entry identified by targetIndex and position.
 * @param targetIndex The index of the target sequence to skip to.
 * @param position    The position on the target sequence.
 * @return The next entry, at position or past position (if not entry at position is found).
 * @throws IOException If an error occurs reading the alignment header. The header is accessed to check that the alignment is sorted.
 */
public final Alignments.AlignmentEntry skipTo(final int targetIndex,final int position) throws IOException {
{
    Bucket bucket;
    while (!entryHeap.isEmpty()) {
      bucket=entryHeap.first();
      if (bucket.entry.getTargetIndex() < targetIndex || bucket.entry.getPosition() < position) {
        Bucket removed=entryHeap.dequeue();
        nextLoadedForReader[removed.readerIndex]=false;
      }
 else {
        break;
      }
    }
  }
  for (  final int readerIndex : readersWithMoreEntries) {
    if (!nextLoadedForReader[readerIndex]) {
      activeIndex=readerIndex;
      final AlignmentReader reader=readers[activeIndex];
      final Alignments.AlignmentEntry alignmentEntry=reader.skipTo(targetIndex,position);
      if (alignmentEntry == null) {
        readersWithMoreEntries.remove(activeIndex);
      }
 else {
        nextLoadedForReader[readerIndex]=true;
        final Bucket bucket=buckets[readerIndex];
        bucket.entry=alignmentEntry;
        bucket.readerIndex=readerIndex;
        entryHeap.enqueue(bucket);
      }
    }
  }
  if (entryHeap.isEmpty())   return null;
  final Bucket bucket=entryHeap.dequeue();
  nextLoadedForReader[bucket.readerIndex]=false;
  hasNext=false;
  final Alignments.AlignmentEntry alignmentEntry=bucket.entry;
  final int newQueryIndex=mergedQueryIndex(alignmentEntry.getQueryIndex());
  if (adjustQueryIndices) {
    return alignmentEntry.newBuilderForType().mergeFrom(alignmentEntry).setQueryIndex(newQueryIndex).build();
  }
 else {
    return alignmentEntry;
  }
}","/** 
 * Skip all entries that have position before (targetIndex,position). This method will use the alignment index to skip directly to the closest chunk start before the entry identified by targetIndex and position.
 * @param targetIndex The index of the target sequence to skip to.
 * @param position    The position on the target sequence.
 * @return The next entry, at position or past position (if not entry at position is found).
 * @throws IOException If an error occurs reading the alignment header. The header is accessed to check that the alignment is sorted.
 */
public final Alignments.AlignmentEntry skipTo(final int targetIndex,final int position) throws IOException {
{
    Bucket bucket;
    while (!entryHeap.isEmpty()) {
      bucket=entryHeap.first();
      if (bucket.entry.getTargetIndex() < targetIndex || bucket.entry.getPosition() < position) {
        Bucket removed=entryHeap.dequeue();
        nextLoadedForReader[removed.readerIndex]=false;
      }
 else {
        break;
      }
    }
  }
  for (  final int readerIndex : readersWithMoreEntries) {
    if (!nextLoadedForReader[readerIndex]) {
      activeIndex=readerIndex;
      final AlignmentReader reader=readers[activeIndex];
      final Alignments.AlignmentEntry alignmentEntry=reader.skipTo(targetIndex,position);
      if (alignmentEntry == null) {
        readersWithMoreEntries.remove(activeIndex);
      }
 else {
        nextLoadedForReader[readerIndex]=true;
        final Bucket bucket=buckets[readerIndex];
        bucket.entry=alignmentEntry;
        bucket.readerIndex=readerIndex;
        entryHeap.enqueue(bucket);
      }
    }
  }
  if (entryHeap.isEmpty())   return null;
  final Bucket bucket=entryHeap.dequeue();
  nextLoadedForReader[bucket.readerIndex]=false;
  hasNext=false;
  final Alignments.AlignmentEntry alignmentEntry=bucket.entry;
  activeIndex=bucket.readerIndex;
  final int newQueryIndex=mergedQueryIndex(alignmentEntry.getQueryIndex());
  if (adjustQueryIndices) {
    return alignmentEntry.newBuilderForType().mergeFrom(alignmentEntry).setQueryIndex(newQueryIndex).build();
  }
 else {
    return alignmentEntry;
  }
}"
50437,"public void processPositions(int referenceIndex,int position,ObjectArrayList<IterateSortedAlignmentsListImpl.PositionBaseInfo> list){
  int sumVariantCounts=0;
  for (int i=0; i < numberOfGroups; i++) {
    refCounts[i]=0;
    variantsCount[i]=0;
    distinctReadIndexCount[i]=0;
    averageVariantQualityScore[i]=0;
  }
  if (list != null) {
    IntSet distinctReadIndices=new IntArraySet();
    for (    IterateSortedAlignmentsListImpl.PositionBaseInfo info : list) {
      final int groupIndex=readerIndexToGroupIndex[info.readerIndex];
      refCounts[groupIndex]+=info.matchesReference ? 1 : 0;
      variantsCount[groupIndex]+=info.matchesReference ? 0 : 1;
      if (!info.matchesReference) {
        sumVariantCounts+=1;
        averageVariantQualityScore[groupIndex]+=info.qualityScore;
      }
      distinctReadIndices.add(info.readIndex);
    }
    for (int groupIndex=0; groupIndex < numberOfGroups; groupIndex++) {
      averageVariantQualityScore[groupIndex]/=variantsCount[groupIndex];
      distinctReadIndexCount[groupIndex]=distinctReadIndices.size();
    }
    if (distinctReadIndices.size() >= thresholdDistinctReadIndices && sumVariantCounts > minimumVariationSupport) {
      int groupIndexA=0;
      int groupIndexB=1;
      if (!isWithinStartFlap(referenceIndex,position)) {
        CharSequence currentReferenceId=this.getReferenceId(referenceIndex);
        statWriter.setValue(refIdColumnIndex,currentReferenceId);
        statWriter.setValue(positionColumnIndex,position + 1);
        if (deAnalyzer.eval(""String_Node_Str"")) {
          final double denominator=(double)refCounts[groupIndexA] * (double)variantsCount[groupIndexB];
          double oddsRatio=denominator == 0 ? 1 : ((double)refCounts[groupIndexB] * (double)variantsCount[groupIndexA]) / denominator;
          double fisherP=Double.NaN;
          boolean ok=checkCounts();
          if (ok) {
            fisherP=fisherRInstalled ? FisherExactRCalculator.getFisherPValue(refCounts[groupIndexB],variantsCount[groupIndexB],refCounts[groupIndexA],variantsCount[groupIndexA]) : Double.NaN;
          }
 else {
            System.err.printf(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",currentReferenceId,referenceIndex,position + 1,refCounts[groupIndexB],variantsCount[groupIndexB],refCounts[groupIndexA],variantsCount[groupIndexA]);
          }
          statWriter.setValue(oddsRatioColumnIndex,oddsRatio);
          statWriter.setValue(fisherExactPValueColumnIndex,fisherP);
        }
        for (int groupIndex=0; groupIndex < numberOfGroups; groupIndex++) {
          statWriter.setValue(refCounts[groupIndex],""String_Node_Str"",groups[groupIndex]);
          statWriter.setValue(variantsCount[groupIndex],""String_Node_Str"",groups[groupIndex]);
          statWriter.setValue(distinctReadIndexCount[groupIndex],""String_Node_Str"",groups[groupIndex]);
          statWriter.setValue(averageVariantQualityScore[groupIndex],""String_Node_Str"",groups[groupIndex]);
          if (deAnalyzer.eval(""String_Node_Str"")) {
            statWriter.setValue(estimateWithinGroupDiscoveryPalue(position,groupIndex,list,variantsCount,refCounts),""String_Node_Str"",groups[groupIndex]);
          }
          summarizeVariations(statWriter,list,groupIndex);
        }
        statWriter.writeRecord();
      }
    }
  }
}","public void processPositions(int referenceIndex,int position,ObjectArrayList<IterateSortedAlignmentsListImpl.PositionBaseInfo> list){
  int sumVariantCounts=0;
  for (int i=0; i < numberOfGroups; i++) {
    refCounts[i]=0;
    variantsCount[i]=0;
    distinctReadIndexCount[i]=0;
    averageVariantQualityScore[i]=0;
  }
  if (list != null) {
    IntSet distinctReadIndices=new IntArraySet();
    for (    IterateSortedAlignmentsListImpl.PositionBaseInfo info : list) {
      final int groupIndex=readerIndexToGroupIndex[info.readerIndex];
      refCounts[groupIndex]+=info.matchesReference ? 1 : 0;
      variantsCount[groupIndex]+=info.matchesReference ? 0 : 1;
      if (!info.matchesReference) {
        sumVariantCounts+=1;
        averageVariantQualityScore[groupIndex]+=info.qualityScore;
        distinctReadIndices.add(info.readIndex);
      }
    }
    for (int groupIndex=0; groupIndex < numberOfGroups; groupIndex++) {
      averageVariantQualityScore[groupIndex]/=variantsCount[groupIndex];
      distinctReadIndexCount[groupIndex]=distinctReadIndices.size();
    }
    if (distinctReadIndices.size() >= thresholdDistinctReadIndices && sumVariantCounts > minimumVariationSupport) {
      int groupIndexA=0;
      int groupIndexB=1;
      if (!isWithinStartFlap(referenceIndex,position)) {
        CharSequence currentReferenceId=this.getReferenceId(referenceIndex);
        statWriter.setValue(refIdColumnIndex,currentReferenceId);
        statWriter.setValue(positionColumnIndex,position + 1);
        if (deAnalyzer.eval(""String_Node_Str"")) {
          final double denominator=(double)refCounts[groupIndexA] * (double)variantsCount[groupIndexB];
          double oddsRatio=denominator == 0 ? 1 : ((double)refCounts[groupIndexB] * (double)variantsCount[groupIndexA]) / denominator;
          double fisherP=Double.NaN;
          boolean ok=checkCounts();
          if (ok) {
            fisherP=fisherRInstalled ? FisherExactRCalculator.getFisherPValue(refCounts[groupIndexB],variantsCount[groupIndexB],refCounts[groupIndexA],variantsCount[groupIndexA]) : Double.NaN;
          }
 else {
            System.err.printf(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"",currentReferenceId,referenceIndex,position + 1,refCounts[groupIndexB],variantsCount[groupIndexB],refCounts[groupIndexA],variantsCount[groupIndexA]);
          }
          statWriter.setValue(oddsRatioColumnIndex,oddsRatio);
          statWriter.setValue(fisherExactPValueColumnIndex,fisherP);
        }
        for (int groupIndex=0; groupIndex < numberOfGroups; groupIndex++) {
          statWriter.setValue(refCounts[groupIndex],""String_Node_Str"",groups[groupIndex]);
          statWriter.setValue(variantsCount[groupIndex],""String_Node_Str"",groups[groupIndex]);
          statWriter.setValue(distinctReadIndexCount[groupIndex],""String_Node_Str"",groups[groupIndex]);
          statWriter.setValue(averageVariantQualityScore[groupIndex],""String_Node_Str"",groups[groupIndex]);
          if (deAnalyzer.eval(""String_Node_Str"")) {
            statWriter.setValue(estimateWithinGroupDiscoveryPalue(position,groupIndex,list,variantsCount,refCounts),""String_Node_Str"",groups[groupIndex]);
          }
          summarizeVariations(statWriter,list,groupIndex);
        }
        statWriter.writeRecord();
      }
    }
  }
}"
50438,"public abstract void observeReferenceBase(ConcatSortedAlignmentReader sortedReaders,Alignments.AlignmentEntry alignmentEntry,Int2ObjectMap<T> positionToBases,int currentReferenceIndex,int currentRefPosition,int currentReadIndex);","/** 
 * Implement this call-back method to observe reference bases.
 * @param sortedReaders The concat read that contains the variation.
 * @param alignmentEntry The alignment entry that contains the variation
 * @param positionToBases Map keyed by reference position, used to accumulate information for each position.
 * @param currentReferenceIndex Index of the reference sequence where the variant occurs.
 * @param currentRefPosition Position where the variant occurs in the reference.
 * @param currentReadIndex Index in the read where the variant occurs.
 */
public abstract void observeReferenceBase(ConcatSortedAlignmentReader sortedReaders,Alignments.AlignmentEntry alignmentEntry,Int2ObjectMap<T> positionToBases,int currentReferenceIndex,int currentRefPosition,int currentReadIndex);"
50439,"public abstract void observeVariantBase(ConcatSortedAlignmentReader sortedReaders,Alignments.AlignmentEntry alignmentEntry,Int2ObjectMap<T> positionToBases,Alignments.SequenceVariation var,char toChar,char fromChar,int currentReferenceIndex,int currentRefPosition,int currentReadIndex);","/** 
 * Implement this call-back method to observe variant bases.
 * @param sortedReaders The concat read that contains the variation.
 * @param alignmentEntry The alignment entry that contains the variation
 * @param positionToBases Map keyed by reference position, used to accumulate information for each position.
 * @param var The sequence variation from the alignment entry that triggered emiting this observation.
 * @param toChar The base character in the read
 * @param fromChar The base character in the reference.
 * @param currentReferenceIndex Index of the reference sequence where the variant occurs.
 * @param currentRefPosition Position where the variant occurs in the reference.
 * @param currentReadIndex Index in the read where the variant occurs.
 */
public abstract void observeVariantBase(ConcatSortedAlignmentReader sortedReaders,Alignments.AlignmentEntry alignmentEntry,Int2ObjectMap<T> positionToBases,Alignments.SequenceVariation var,char toChar,char fromChar,int currentReferenceIndex,int currentRefPosition,int currentReadIndex);"
50440,"public void observeVariantBase(ConcatSortedAlignmentReader sortedReaders,Alignments.AlignmentEntry alignmentEntry,Int2ObjectMap<ObjectArrayList<PositionBaseInfo>> positionToBases,Alignments.SequenceVariation var,char toChar,char fromChar,int currentReferenceIndex,int currentRefPosition,int currentReadIndex){
  PositionBaseInfo info=new PositionBaseInfo();
  info.readerIndex=sortedReaders.activeIndex;
  info.readIndex=currentReadIndex;
  info.from=fromChar;
  info.to=toChar;
  info.matchesReference=false;
  info.position=currentRefPosition;
  addToFuture(positionToBases,info);
}","public void observeVariantBase(ConcatSortedAlignmentReader sortedReaders,Alignments.AlignmentEntry alignmentEntry,Int2ObjectMap<ObjectArrayList<IterateSortedAlignmentsListImpl.PositionBaseInfo>> positionToBases,Alignments.SequenceVariation var,char toChar,char fromChar,int currentReferenceIndex,int currentRefPosition,int currentReadIndex){
  PositionBaseInfo info=new PositionBaseInfo();
  info.readerIndex=sortedReaders.activeIndex;
  info.readIndex=currentReadIndex;
  info.from=fromChar;
  info.to=toChar;
  info.matchesReference=false;
  info.position=currentRefPosition;
  addToFuture(positionToBases,info);
}"
50441,"public void observeReferenceBase(ConcatSortedAlignmentReader sortedReaders,Alignments.AlignmentEntry alignmentEntry,Int2ObjectMap<ObjectArrayList<PositionBaseInfo>> positionToBases,int currentReferenceIndex,int currentRefPosition,int currentReadIndex){
  PositionBaseInfo info=new PositionBaseInfo();
  info.readerIndex=sortedReaders.activeIndex;
  info.readIndex=currentReadIndex;
  info.from='\0';
  info.to='\0';
  info.matchesReference=true;
  info.position=currentRefPosition;
  info.qualityScore=40;
  addToFuture(positionToBases,info);
}","public void observeReferenceBase(ConcatSortedAlignmentReader sortedReaders,Alignments.AlignmentEntry alignmentEntry,Int2ObjectMap<ObjectArrayList<IterateSortedAlignmentsListImpl.PositionBaseInfo>> positionToBases,int currentReferenceIndex,int currentRefPosition,int currentReadIndex){
  PositionBaseInfo info=new PositionBaseInfo();
  info.readerIndex=sortedReaders.activeIndex;
  info.readIndex=currentReadIndex;
  info.from='\0';
  info.to='\0';
  info.matchesReference=true;
  info.position=currentRefPosition;
  info.qualityScore=40;
  addToFuture(positionToBases,info);
}"
50442,"@Test public void testIterateSortedReferenceInsertions() throws IOException {
  final String basename=""String_Node_Str"";
  final String basenamePath=FilenameUtils.concat(BASE_TEST_DIR,basename);
  final AlignmentWriter writer=new AlignmentWriter(basenamePath);
  writer.setNumAlignmentEntriesPerChunk(1);
  final int numTargets=3;
  final int[] targetLengths=new int[numTargets];
  for (int referenceIndex=0; referenceIndex < numTargets; referenceIndex++) {
    targetLengths[referenceIndex]=1000;
  }
  writer.setTargetLengths(targetLengths);
  writer.setSorted(true);
  Alignments.AlignmentEntry.Builder newEntry;
  newEntry=prepareAlignmentEntryWithReferenceInsertion(0,1,100,30,false,new int[]{4,3});
  writer.appendEntry(newEntry.build());
  writer.close();
  writer.printStats(System.out);
  final Int2IntMap positionMap=new Int2IntOpenHashMap();
  final IntSet variantReadIndices=new IntOpenHashSet();
  IterateSortedAlignmentsListImpl iterator=new IterateSortedAlignmentsListImpl(){
    @Override public void observeVariantBase(    ConcatSortedAlignmentReader sortedReaders,    Alignments.AlignmentEntry alignmentEntry,    Int2ObjectMap<ObjectArrayList<PositionBaseInfo>> positionToBases,    Alignments.SequenceVariation var,    char toChar,    char fromChar,    int currentReferenceIndex,    int currentRefPosition,    int currentReadIndex){
      variantReadIndices.add(currentReadIndex);
    }
    @Override public void processPositions(    int referenceIndex,    int intermediatePosition,    ObjectArrayList<PositionBaseInfo> positionBaseInfos){
      int coverage=0;
      for (      PositionBaseInfo info : positionBaseInfos) {
        coverage+=info.to != '-' ? 1 : 0;
      }
      positionMap.put(intermediatePosition,coverage);
      System.out.printf(""String_Node_Str"",referenceIndex,coverage);
    }
  }
;
  iterator.iterate(basenamePath);
  for (int i=0; i < 100; i++) {
    assertEquals(""String_Node_Str"" + i,0,positionMap.get(i));
  }
  for (int i=100; i < 103; i++) {
    assertEquals(""String_Node_Str"" + i,1,positionMap.get(i));
  }
  for (int i=103; i < 106; i++) {
    assertEquals(""String_Node_Str"" + i,0,positionMap.get(i));
  }
  for (int i=106; i < 137; i++) {
    assertEquals(""String_Node_Str"" + i,1,positionMap.get(i));
  }
  for (int i=138; i < 150; i++) {
    assertEquals(""String_Node_Str"" + i,0,positionMap.get(i));
  }
}","@Test public void testIterateSortedReferenceInsertions() throws IOException {
  final String basename=""String_Node_Str"";
  final String basenamePath=FilenameUtils.concat(BASE_TEST_DIR,basename);
  final AlignmentWriter writer=new AlignmentWriter(basenamePath);
  writer.setNumAlignmentEntriesPerChunk(1);
  final int numTargets=3;
  final int[] targetLengths=new int[numTargets];
  for (int referenceIndex=0; referenceIndex < numTargets; referenceIndex++) {
    targetLengths[referenceIndex]=1000;
  }
  writer.setTargetLengths(targetLengths);
  writer.setSorted(true);
  Alignments.AlignmentEntry.Builder newEntry;
  newEntry=prepareAlignmentEntryWithReferenceInsertion(0,1,100,30,false,new int[]{4,3});
  writer.appendEntry(newEntry.build());
  writer.close();
  writer.printStats(System.out);
  final Int2IntMap positionMap=new Int2IntOpenHashMap();
  final IntSet variantReadIndices=new IntOpenHashSet();
  IterateSortedAlignmentsListImpl iterator=new IterateSortedAlignmentsListImpl(){
    @Override public void observeVariantBase(    ConcatSortedAlignmentReader sortedReaders,    Alignments.AlignmentEntry alignmentEntry,    Int2ObjectMap<ObjectArrayList<IterateSortedAlignmentsListImpl.PositionBaseInfo>> positionToBases,    Alignments.SequenceVariation var,    char toChar,    char fromChar,    int currentReferenceIndex,    int currentRefPosition,    int currentReadIndex){
      variantReadIndices.add(currentReadIndex);
    }
    @Override public void processPositions(    int referenceIndex,    int intermediatePosition,    ObjectArrayList<PositionBaseInfo> positionBaseInfos){
      int coverage=0;
      for (      PositionBaseInfo info : positionBaseInfos) {
        coverage+=info.to != '-' ? 1 : 0;
      }
      positionMap.put(intermediatePosition,coverage);
      System.out.printf(""String_Node_Str"",referenceIndex,coverage);
    }
  }
;
  iterator.iterate(basenamePath);
  for (int i=0; i < 100; i++) {
    assertEquals(""String_Node_Str"" + i,0,positionMap.get(i));
  }
  for (int i=100; i < 103; i++) {
    assertEquals(""String_Node_Str"" + i,1,positionMap.get(i));
  }
  for (int i=103; i < 106; i++) {
    assertEquals(""String_Node_Str"" + i,0,positionMap.get(i));
  }
  for (int i=106; i < 137; i++) {
    assertEquals(""String_Node_Str"" + i,1,positionMap.get(i));
  }
  for (int i=138; i < 150; i++) {
    assertEquals(""String_Node_Str"" + i,0,positionMap.get(i));
  }
}"
50443,"@Test public void testIterateSortedTwoMutations() throws IOException {
  final String basename=""String_Node_Str"";
  final String basenamePath=FilenameUtils.concat(BASE_TEST_DIR,basename);
  final AlignmentWriter writer=new AlignmentWriter(basenamePath);
  writer.setNumAlignmentEntriesPerChunk(1);
  final int numTargets=3;
  final int[] targetLengths=new int[numTargets];
  for (int referenceIndex=0; referenceIndex < numTargets; referenceIndex++) {
    targetLengths[referenceIndex]=1000;
  }
  writer.setTargetLengths(targetLengths);
  writer.setSorted(true);
  Alignments.AlignmentEntry.Builder newEntry;
  newEntry=prepareAlignmentEntry(0,1,100,3,true,new int[]{2,31,34},35);
  writer.appendEntry(newEntry.build());
  writer.close();
  writer.printStats(System.out);
  final IntSet variantReadIndices=new IntOpenHashSet();
  final IntSet variantPositionOnRef=new IntOpenHashSet();
  IterateSortedAlignmentsListImpl iterator=new IterateSortedAlignmentsListImpl(){
    public void processPositions(    int referenceIndex,    int intermediatePosition,    ObjectArrayList<PositionBaseInfo> positionBaseInfos){
    }
    @Override public void observeVariantBase(    ConcatSortedAlignmentReader sortedReaders,    Alignments.AlignmentEntry alignmentEntry,    Int2ObjectMap<ObjectArrayList<PositionBaseInfo>> positionToBases,    Alignments.SequenceVariation var,    char toChar,    char fromChar,    int currentReferenceIndex,    int currentRefPosition,    int currentReadIndex){
      variantReadIndices.add(currentReadIndex);
      variantPositionOnRef.add(currentRefPosition);
    }
  }
;
  iterator.iterate(basenamePath);
  assertTrue(variantReadIndices.contains(34));
  assertTrue(variantReadIndices.contains(2));
  assertTrue(variantReadIndices.contains(5));
  assertTrue(variantPositionOnRef.contains(101));
  assertTrue(variantPositionOnRef.contains(130));
  assertTrue(variantPositionOnRef.contains(133));
}","@Test public void testIterateSortedTwoMutations() throws IOException {
  final String basename=""String_Node_Str"";
  final String basenamePath=FilenameUtils.concat(BASE_TEST_DIR,basename);
  final AlignmentWriter writer=new AlignmentWriter(basenamePath);
  writer.setNumAlignmentEntriesPerChunk(1);
  final int numTargets=3;
  final int[] targetLengths=new int[numTargets];
  for (int referenceIndex=0; referenceIndex < numTargets; referenceIndex++) {
    targetLengths[referenceIndex]=1000;
  }
  writer.setTargetLengths(targetLengths);
  writer.setSorted(true);
  Alignments.AlignmentEntry.Builder newEntry;
  newEntry=prepareAlignmentEntry(0,1,100,3,true,new int[]{2,31,34},35);
  writer.appendEntry(newEntry.build());
  writer.close();
  writer.printStats(System.out);
  final IntSet variantReadIndices=new IntOpenHashSet();
  final IntSet variantPositionOnRef=new IntOpenHashSet();
  IterateSortedAlignmentsListImpl iterator=new IterateSortedAlignmentsListImpl(){
    public void processPositions(    int referenceIndex,    int intermediatePosition,    ObjectArrayList<PositionBaseInfo> positionBaseInfos){
    }
    @Override public void observeVariantBase(    ConcatSortedAlignmentReader sortedReaders,    Alignments.AlignmentEntry alignmentEntry,    Int2ObjectMap<ObjectArrayList<IterateSortedAlignmentsListImpl.PositionBaseInfo>> positionToBases,    Alignments.SequenceVariation var,    char toChar,    char fromChar,    int currentReferenceIndex,    int currentRefPosition,    int currentReadIndex){
      variantReadIndices.add(currentReadIndex);
      variantPositionOnRef.add(currentRefPosition);
    }
  }
;
  iterator.iterate(basenamePath);
  assertTrue(variantReadIndices.contains(34));
  assertTrue(variantReadIndices.contains(2));
  assertTrue(variantReadIndices.contains(5));
  assertTrue(variantPositionOnRef.contains(101));
  assertTrue(variantPositionOnRef.contains(130));
  assertTrue(variantPositionOnRef.contains(133));
}"
50444,"@Override public void observeVariantBase(ConcatSortedAlignmentReader sortedReaders,Alignments.AlignmentEntry alignmentEntry,Int2ObjectMap<ObjectArrayList<PositionBaseInfo>> positionToBases,Alignments.SequenceVariation var,char toChar,char fromChar,int currentReferenceIndex,int currentRefPosition,int currentReadIndex){
  variantReadIndices.add(currentReadIndex);
}","@Override public void observeVariantBase(ConcatSortedAlignmentReader sortedReaders,Alignments.AlignmentEntry alignmentEntry,Int2ObjectMap<ObjectArrayList<IterateSortedAlignmentsListImpl.PositionBaseInfo>> positionToBases,Alignments.SequenceVariation var,char toChar,char fromChar,int currentReferenceIndex,int currentRefPosition,int currentReadIndex){
  variantReadIndices.add(currentReadIndex);
}"
50445,"private byte[] trimQualityScores(byte[] qualityScores,int trimReadStartLength,int trimReadLength,int initialLength){
  byte[] trimmedScores=new byte[Math.min(initialLength,trimReadLength) - trimReadStartLength];
  int trimmedIndex=0;
  for (int i=0; i < Math.min(initialLength,trimReadLength); i++) {
    if (i > trimReadStartLength) {
      trimmedScores[trimmedIndex]=qualityScores[i];
    }
 else {
      if (i > trimReadLength)       return trimmedScores;
    }
    trimmedIndex++;
  }
  return trimmedScores;
}","private byte[] trimQualityScores(byte[] qualityScores,int trimReadStartLength,int trimReadLength,int initialLength){
  if (qualityScores == null)   return null;
  byte[] trimmedScores=new byte[Math.min(initialLength,trimReadLength) - trimReadStartLength];
  int trimmedIndex=0;
  for (int i=0; i < Math.min(initialLength,trimReadLength); i++) {
    if (i >= trimReadStartLength) {
      trimmedScores[trimmedIndex]=qualityScores[i];
    }
 else {
      if (i > trimReadLength)       return trimmedScores;
    }
    trimmedIndex++;
  }
  return trimmedScores;
}"
50446,"private CharSequence byteToString(final byte[] input){
  final MutableString buffer=new MutableString();
  for (int i=0; i < buffer.length(); i++) {
    buffer.setCharAt(i,(char)input[i]);
  }
  return buffer;
}","private CharSequence byteToString(final byte[] input){
  final MutableString buffer=new MutableString();
  buffer.setLength(input.length);
  for (int i=0; i < input.length; i++) {
    buffer.setCharAt(i,(char)input[i]);
  }
  return buffer;
}"
50447,"/** 
 * Display sequence variations.
 * @throws java.io.IOException error reading / writing
 */
@Override public void execute() throws IOException {
  final ReadsWriter writer=new ReadsWriter(new FileOutputStream(outputFilename));
  try {
    final ProgressLogger progress=new ProgressLogger(LOG);
    final SAMFileReader parser=new SAMFileReader(new File(inputFilename));
    parser.setValidationStringency(SAMFileReader.ValidationStringency.SILENT);
    progress.start();
    for (    final SAMRecord samRecord : parser) {
      final String readId=samRecord.getReadName();
      writer.setIdentifier(readId);
      writer.setSequence(byteToString(samRecord.getReadBases()));
      writer.setQualityScores(remove33(samRecord.getReadBases()));
      writer.appendEntry();
      progress.lightUpdate();
    }
  }
  finally {
    writer.close();
  }
}","/** 
 * Display sequence variations.
 * @throws java.io.IOException error reading / writing
 */
@Override public void execute() throws IOException {
  final ReadsWriter writer=new ReadsWriter(new FileOutputStream(outputFilename));
  try {
    final ProgressLogger progress=new ProgressLogger(LOG);
    final SAMFileReader parser=new SAMFileReader(new File(inputFilename));
    parser.setValidationStringency(SAMFileReader.ValidationStringency.SILENT);
    progress.start();
    for (    final SAMRecord samRecord : parser) {
      final String readId=samRecord.getReadName();
      writer.setIdentifier(readId);
      writer.setSequence(byteToString(samRecord.getReadBases()));
      writer.setQualityScores(remove33(samRecord.getBaseQualities()));
      writer.appendEntry();
      progress.lightUpdate();
    }
  }
  finally {
    writer.close();
  }
}"
50448,"@Test public void testParalell(){
  final Random randomEngine=new Random();
  final DifferentialExpressionCalculator deCalc=new DifferentialExpressionCalculator(){
    @Override public double getNormalizedExpressionValue(    final String sample,    final NormalizationMethod method,    final MutableString elementId){
      if (sample.startsWith(""String_Node_Str"")) {
        return 2 * Math.abs(randomEngine.nextGaussian());
      }
 else {
        return Math.abs(randomEngine.nextGaussian());
      }
    }
    @Override public int getOverlapCount(    final String sample,    final MutableString elementId){
      final NormalizationMethod normalizationMethod=new AlignedCountNormalization();
      return (int)(getNormalizedExpressionValue(sample,normalizationMethod,elementId) * 100);
    }
  }
;
  deCalc.setRunInParallel(true);
  deCalc.defineElement(""String_Node_Str"");
  deCalc.defineElement(""String_Node_Str"");
  deCalc.defineGroup(""String_Node_Str"");
  deCalc.defineGroup(""String_Node_Str"");
  final int numReplicates=2000;
  deCalc.reserve(2,numReplicates * 2);
  for (int i=0; i < numReplicates; i++) {
    deCalc.associateSampleToGroup(""String_Node_Str"" + i,""String_Node_Str"");
    deCalc.associateSampleToGroup(""String_Node_Str"" + i,""String_Node_Str"");
  }
  for (  final String sampleId : deCalc.samples()) {
    final MutableString id1=new MutableString(""String_Node_Str"");
    final MutableString id2=new MutableString(""String_Node_Str"");
    deCalc.observe(sampleId,""String_Node_Str"",deCalc.getOverlapCount(sampleId,id1));
    deCalc.observe(sampleId,""String_Node_Str"",deCalc.getOverlapCount(sampleId,id2));
  }
  DifferentialExpressionResults list=new DifferentialExpressionResults();
  DifferentialExpressionInfo info1=new DifferentialExpressionInfo(""String_Node_Str"");
  DifferentialExpressionInfo info2=new DifferentialExpressionInfo(""String_Node_Str"");
  final FoldChangeCalculator foldChange=new FoldChangeCalculator(list);
  final AverageCalculator average=new AverageCalculator(list);
  final TTestCalculator tTest=new TTestCalculator(list);
  final FisherExactRCalculator fisher=new FisherExactRCalculator(list);
  final NormalizationMethod normalizationMethod=new AlignedCountNormalization();
  list.add(info1);
  list.add(info2);
  list=foldChange.evaluate(deCalc,normalizationMethod,list,""String_Node_Str"",""String_Node_Str"");
  list=average.evaluate(deCalc,normalizationMethod,list,""String_Node_Str"",""String_Node_Str"");
  list=tTest.evaluate(deCalc,normalizationMethod,list,""String_Node_Str"",""String_Node_Str"");
  list=fisher.evaluate(deCalc,normalizationMethod,list,""String_Node_Str"",""String_Node_Str"");
  final MutableString foldChangeIndex=foldChange.statisticIds.get(0);
  final DifferentialExpressionInfo info=list.get(0);
  assertEquals(""String_Node_Str"",1.4139327824612316d,list.getStatistic(info,foldChangeIndex),.1);
  assertTrue(""String_Node_Str"",list.getStatistic(info1,tTest.statisticIds.get(0)) < 0.01);
  assertTrue(""String_Node_Str"",list.getStatistic(info1,fisher.statisticIds.get(0)) > 0.05);
}","@Test public void testParalell(){
  final Random randomEngine=new Random();
  final DifferentialExpressionCalculator deCalc=new DifferentialExpressionCalculator(){
    @Override public double getNormalizedExpressionValue(    final String sample,    final NormalizationMethod method,    final MutableString elementId){
      if (sample.startsWith(""String_Node_Str"")) {
        return 2 * Math.abs(randomEngine.nextGaussian());
      }
 else {
        return Math.abs(randomEngine.nextGaussian());
      }
    }
    @Override public int getOverlapCount(    final String sample,    final MutableString elementId){
      final NormalizationMethod normalizationMethod=new AlignedCountNormalization();
      return (int)(getNormalizedExpressionValue(sample,normalizationMethod,elementId) * 100);
    }
  }
;
  deCalc.setRunInParallel(true);
  deCalc.defineElement(""String_Node_Str"");
  deCalc.defineElement(""String_Node_Str"");
  deCalc.defineGroup(""String_Node_Str"");
  deCalc.defineGroup(""String_Node_Str"");
  final int numReplicates=2000;
  deCalc.reserve(2,numReplicates * 2);
  for (int i=0; i < numReplicates; i++) {
    deCalc.associateSampleToGroup(""String_Node_Str"" + i,""String_Node_Str"");
    deCalc.associateSampleToGroup(""String_Node_Str"" + i,""String_Node_Str"");
  }
  for (  final String sampleId : deCalc.samples()) {
    final MutableString id1=new MutableString(""String_Node_Str"");
    final MutableString id2=new MutableString(""String_Node_Str"");
    deCalc.observe(sampleId,""String_Node_Str"",deCalc.getOverlapCount(sampleId,id1));
    deCalc.observe(sampleId,""String_Node_Str"",deCalc.getOverlapCount(sampleId,id2));
  }
  DifferentialExpressionResults list=new DifferentialExpressionResults();
  DifferentialExpressionInfo info1=new DifferentialExpressionInfo(""String_Node_Str"");
  DifferentialExpressionInfo info2=new DifferentialExpressionInfo(""String_Node_Str"");
  final FoldChangeCalculator foldChange=new FoldChangeCalculator(list);
  final AverageCalculator average=new AverageCalculator(list);
  final TTestCalculator tTest=new TTestCalculator(list);
  final FisherExactRCalculator fisher=new FisherExactRCalculator(list);
  final NormalizationMethod normalizationMethod=new AlignedCountNormalization();
  list.add(info1);
  list.add(info2);
  list=foldChange.evaluate(deCalc,normalizationMethod,list,""String_Node_Str"",""String_Node_Str"");
  list=average.evaluate(deCalc,normalizationMethod,list,""String_Node_Str"",""String_Node_Str"");
  list=tTest.evaluate(deCalc,normalizationMethod,list,""String_Node_Str"",""String_Node_Str"");
  list=fisher.evaluate(deCalc,normalizationMethod,list,""String_Node_Str"",""String_Node_Str"");
  final MutableString foldChangeIndex=foldChange.statisticIds.get(0);
  final DifferentialExpressionInfo info=list.get(0);
  assertEquals(""String_Node_Str"",1.4139327824612316d,list.getStatistic(info,foldChangeIndex),.1);
  assertTrue(""String_Node_Str"",list.getStatistic(info1,tTest.statisticIds.get(0)) < 0.01);
}"
50449,"/** 
 * Returns the next alignment entry from the input stream.
 * @return the alignment read entry from the input stream.
 */
public Alignments.AlignmentEntry next(){
  if (!alignmentEntryReader.hasNext(collection,numberOfEntries())) {
    throw new NoSuchElementException();
  }
  return collection.getAlignmentEntries(alignmentEntryReader.incrementEntryIndex());
}","/** 
 * Returns the next alignment entry from the input stream.
 * @return the alignment read entry from the input stream.
 */
public Alignments.AlignmentEntry next(){
  if (!hasNext()) {
    throw new NoSuchElementException();
  }
  try {
    return nextEntry;
  }
  finally {
    alignmentEntryReader.incrementEntryIndex();
    nextEntry=null;
  }
}"
50450,"/** 
 * Returns true if the input has more entries.
 * @return true if the input has more entries, false otherwise.
 */
public boolean hasNext(){
  final boolean hasNext=alignmentEntryReader.hasNext(collection,numberOfEntries());
  if (!hasNext) {
    collection=null;
  }
  final GZIPInputStream uncompressStream=alignmentEntryReader.getUncompressStream();
  try {
    if (uncompressStream != null) {
      collection=Alignments.AlignmentCollection.parseFrom(uncompressStream);
      if (collection.getAlignmentEntriesCount() == 0) {
        return false;
      }
    }
  }
 catch (  IOException e) {
    throw new GobyRuntimeException(e);
  }
  return hasNext;
}","/** 
 * Returns true if the input has more entries.
 * @return true if the input has more entries, false otherwise.
 */
public boolean hasNext(){
  if (nextEntry != null) {
    return true;
  }
  final boolean hasNext=alignmentEntryReader.hasNext(collection,numberOfEntries());
  if (!hasNext) {
    collection=null;
  }
  final GZIPInputStream uncompressStream=alignmentEntryReader.getUncompressStream();
  try {
    if (uncompressStream != null) {
      collection=Alignments.AlignmentCollection.parseFrom(uncompressStream);
      if (collection.getAlignmentEntriesCount() == 0) {
        return false;
      }
    }
  }
 catch (  IOException e) {
    throw new GobyRuntimeException(e);
  }
  if (collection == null)   return false;
  nextEntry=collection.getAlignmentEntries(alignmentEntryReader.getEntryIndex());
  final int entryTargetIndex=nextEntry.getTargetIndex();
  if (entryTargetIndex > endReferenceIndex || (entryTargetIndex == endReferenceIndex && nextEntry.getPosition() > endPosition)) {
    nextEntry=null;
    return false;
  }
  return hasNext;
}"
50451,"private void repositionInternal(final int targetIndex,final int position) throws IOException {
  if (!indexLoaded) {
    return;
  }
  final int absolutePosition=recodePosition(targetIndex,position);
  int offsetIndex=Arrays.binarySearch(indexAbsolutePositions.elements(),absolutePosition);
  offsetIndex=offsetIndex < 0 ? -1 - offsetIndex : offsetIndex;
  offsetIndex=offsetIndex >= indexOffsets.size() ? indexOffsets.size() - 1 : offsetIndex;
  if (offsetIndex < 0) {
    return;
  }
  final long newPosition=indexOffsets.getLong(offsetIndex);
  final long currentPosition=alignmentEntryReader.position();
  if (newPosition > currentPosition) {
    alignmentEntryReader.seek(newPosition);
  }
}","private void repositionInternal(final int targetIndex,final int position) throws IOException {
  if (!indexLoaded) {
    return;
  }
  final int absolutePosition=recodePosition(targetIndex,position);
  int offsetIndex=Arrays.binarySearch(indexAbsolutePositions.elements(),absolutePosition);
  offsetIndex=offsetIndex < 0 ? -1 - offsetIndex : offsetIndex;
  offsetIndex=offsetIndex >= indexOffsets.size() ? indexOffsets.size() - 1 : offsetIndex - 1;
  if (offsetIndex < 0) {
    return;
  }
  final long newPosition=indexOffsets.getLong(offsetIndex);
  final long currentPosition=alignmentEntryReader.position();
  if (newPosition > currentPosition) {
    alignmentEntryReader.seek(newPosition);
  }
}"
50452,"private void reposition(final long start,final long end) throws IOException {
  input.position(start);
  int b;
  int contiguousZeroBytes=0;
  int skipped=0;
  long position=0;
  while (position < end && (b=input.read()) != -1) {
    if (b == MessageChunksWriter.DELIMITER_CONTENT) {
      contiguousZeroBytes++;
    }
 else {
      contiguousZeroBytes=0;
    }
    ++skipped;
    if (contiguousZeroBytes == MessageChunksWriter.DELIMITER_LENGTH) {
      in=new DataInputStream(input);
      final long seekPosition=start + skipped - contiguousZeroBytes;
      input.position(seekPosition);
      break;
    }
    position=start + skipped;
  }
}","private void reposition(final long start,final long end) throws IOException {
  input.position(start);
  int b;
  int contiguousZeroBytes=0;
  long skipped=0;
  long position=0;
  while (position < end && (b=input.read()) != -1) {
    if (b == MessageChunksWriter.DELIMITER_CONTENT) {
      contiguousZeroBytes++;
    }
 else {
      contiguousZeroBytes=0;
    }
    ++skipped;
    if (contiguousZeroBytes == MessageChunksWriter.DELIMITER_LENGTH) {
      in=new DataInputStream(input);
      final long seekPosition=start + skipped - contiguousZeroBytes;
      input.position(seekPosition);
      break;
    }
    position=start + skipped;
  }
}"
50453,"/** 
 * Perform the concatenation.
 * @throws java.io.IOException
 */
@Override public void execute() throws IOException {
  final String outputFilename=outputFile;
  final String[] basenames=AlignmentReader.getBasenames(inputFilenames);
  final boolean allSorted=ConcatenateAlignmentMode.isAllSorted(basenames);
  if (!allSorted) {
    System.out.println(""String_Node_Str"");
    System.exit(10);
  }
  if (readIndexStats != null) {
    int readerIndex=0;
    for (    String basename : basenames) {
      boolean found=false;
      for (      ReadIndexStats stat : readIndexStats) {
        if (FilenameUtils.getBaseName(basename).equals(stat.basename)) {
          stat.readerIndex=readerIndex;
          found=true;
        }
      }
      if (!found) {
        System.err.printf(""String_Node_Str"",basename);
      }
      readerIndex++;
    }
    Collections.sort(readIndexStats,new Comparator<ReadIndexStats>(){
      public int compare(      ReadIndexStats readIndexStats,      ReadIndexStats readIndexStatsFirst){
        return readIndexStats.readerIndex - readIndexStatsFirst.readerIndex;
      }
    }
);
    numberOfReadIndices=new int[this.deCalculator.getSampleToGroupMap().keySet().size()];
    ObjectSet<ReadIndexStats> toRemove=new ObjectArraySet<ReadIndexStats>();
    for (    ReadIndexStats stat : readIndexStats) {
      if (stat.readerIndex == -1) {
        toRemove.add(stat);
        continue;
      }
      numberOfReadIndices[stat.readerIndex]=Math.max(numberOfReadIndices[stat.readerIndex],stat.countReferenceBases.length);
    }
    readIndexStats.removeAll(toRemove);
    for (    ReadIndexStats stat : readIndexStats) {
      for (int readIndex=0; readIndex < numberOfReadIndices[stat.readerIndex]; readIndex++) {
        stat.countReferenceBases[readIndex]/=numberOfReadIndices[stat.readerIndex];
      }
    }
  }
  ConcatSortedAlignmentReader sortedReaders=new ConcatSortedAlignmentReader(basenames);
  int lastPosition=-1;
  int lastTargetIndex=-1;
  ObjectArrayList<Alignments.AlignmentEntry> entriesAtPosition=new ObjectArrayList<Alignments.AlignmentEntry>();
  IntArrayList readerIndices=new IntArrayList();
  DoubleIndexedIdentifier targetIds=new DoubleIndexedIdentifier(sortedReaders.getTargetIdentifiers());
  outWriter.printf(""String_Node_Str"");
  if (deAnalyzer.eval(""String_Node_Str"")) {
    outWriter.printf(""String_Node_Str"",groups[0],groups[1],groups[0],groups[1]);
  }
  for (  String group : groups) {
    outWriter.printf(""String_Node_Str"",group,group,group,group);
    if (deAnalyzer.eval(""String_Node_Str"")) {
      outWriter.printf(""String_Node_Str"",group);
    }
  }
  outWriter.printf(""String_Node_Str"");
  for (  Alignments.AlignmentEntry entry : sortedReaders) {
    if (currentReferenceId == null) {
      currentReferenceId=targetIds.getId(entry.getTargetIndex());
      currentReferenceIndex=entry.getTargetIndex();
    }
    final int position=entry.getPosition();
    final int targetIndex=entry.getTargetIndex();
    if (targetIndex != lastTargetIndex || position != lastPosition) {
      if (entriesAtPosition.size() != 0) {
        pushVariations(entriesAtPosition,readerIndices);
      }
      processVariations(lastPosition);
      if (targetIndex != lastTargetIndex) {
        variationPool.reset();
        currentReferenceId=targetIds.getId(entry.getTargetIndex());
      }
      variationPool.removePosition(lastPosition);
      entriesAtPosition.clear();
      readerIndices.clear();
      lastPosition=position;
      lastTargetIndex=targetIndex;
    }
    entriesAtPosition.add(entry);
    readerIndices.add(sortedReaders.getReaderIndex());
  }
  outWriter.flush();
}","/** 
 * Perform the concatenation.
 * @throws java.io.IOException
 */
@Override public void execute() throws IOException {
  final String outputFilename=outputFile;
  final String[] basenames=AlignmentReader.getBasenames(inputFilenames);
  final boolean allSorted=ConcatenateAlignmentMode.isAllSorted(basenames);
  if (!allSorted) {
    System.out.println(""String_Node_Str"");
    System.exit(10);
  }
  if (readIndexStats != null) {
    int readerIndex=0;
    for (    String basename : basenames) {
      boolean found=false;
      for (      ReadIndexStats stat : readIndexStats) {
        if (FilenameUtils.getBaseName(basename).equals(stat.basename)) {
          stat.readerIndex=readerIndex;
          found=true;
        }
      }
      if (!found) {
        System.err.printf(""String_Node_Str"",basename);
      }
      readerIndex++;
    }
    Collections.sort(readIndexStats,new Comparator<ReadIndexStats>(){
      public int compare(      ReadIndexStats readIndexStats,      ReadIndexStats readIndexStatsFirst){
        return readIndexStats.readerIndex - readIndexStatsFirst.readerIndex;
      }
    }
);
    numberOfReadIndices=new int[this.deCalculator.getSampleToGroupMap().keySet().size()];
    ObjectSet<ReadIndexStats> toRemove=new ObjectArraySet<ReadIndexStats>();
    for (    ReadIndexStats stat : readIndexStats) {
      if (stat.readerIndex == -1) {
        toRemove.add(stat);
        continue;
      }
      numberOfReadIndices[stat.readerIndex]=Math.max(numberOfReadIndices[stat.readerIndex],stat.countReferenceBases.length);
    }
    readIndexStats.removeAll(toRemove);
    for (    ReadIndexStats stat : readIndexStats) {
      for (int i=0; i < stat.countReferenceBases.length; i++) {
        System.out.printf(""String_Node_Str"",stat.basename,i + 1,stat.countReferenceBases[i]);
      }
    }
  }
  ConcatSortedAlignmentReader sortedReaders=new ConcatSortedAlignmentReader(basenames);
  int lastPosition=-1;
  int lastTargetIndex=-1;
  ObjectArrayList<Alignments.AlignmentEntry> entriesAtPosition=new ObjectArrayList<Alignments.AlignmentEntry>();
  IntArrayList readerIndices=new IntArrayList();
  DoubleIndexedIdentifier targetIds=new DoubleIndexedIdentifier(sortedReaders.getTargetIdentifiers());
  outWriter.printf(""String_Node_Str"");
  if (deAnalyzer.eval(""String_Node_Str"")) {
    outWriter.printf(""String_Node_Str"",groups[0],groups[1],groups[0],groups[1]);
  }
  for (  String group : groups) {
    outWriter.printf(""String_Node_Str"",group,group,group,group);
    if (deAnalyzer.eval(""String_Node_Str"")) {
      outWriter.printf(""String_Node_Str"",group);
    }
  }
  outWriter.printf(""String_Node_Str"");
  for (  Alignments.AlignmentEntry entry : sortedReaders) {
    if (currentReferenceId == null) {
      currentReferenceId=targetIds.getId(entry.getTargetIndex());
      currentReferenceIndex=entry.getTargetIndex();
    }
    final int position=entry.getPosition();
    final int targetIndex=entry.getTargetIndex();
    if (targetIndex != lastTargetIndex || position != lastPosition) {
      if (entriesAtPosition.size() != 0) {
        pushVariations(entriesAtPosition,readerIndices);
      }
      processVariations(lastPosition);
      if (targetIndex != lastTargetIndex) {
        variationPool.reset();
        currentReferenceId=targetIds.getId(entry.getTargetIndex());
      }
      variationPool.removePosition(lastPosition);
      entriesAtPosition.clear();
      readerIndices.clear();
      lastPosition=position;
      lastTargetIndex=targetIndex;
    }
    entriesAtPosition.add(entry);
    readerIndices.add(sortedReaders.getReaderIndex());
  }
  outWriter.flush();
}"
50454,"public void observeVariantBase(ConcatSortedAlignmentReader sortedReaders,Int2ObjectMap<CountsAtPosition> positionToBases,Alignments.SequenceVariation var,char toChar,char fromChar,int currentRefPosition,int currentReadIndex){
  final int readIndex=var.getReadIndex();
  maxReadIndex=Math.max(maxReadIndex,readIndex);
  int count=readIndexVariationTally[readIndex];
  readIndexVariationTally[readIndex]=count + 1;
}","public void observeVariantBase(ConcatSortedAlignmentReader sortedReaders,Int2ObjectMap<CountsAtPosition> positionToBases,Alignments.SequenceVariation var,char toChar,char fromChar,int currentRefPosition,int currentReadIndex){
  maxReadIndex=Math.max(maxReadIndex,currentReadIndex);
  int count=readIndexVariationTally[currentReadIndex];
  readIndexVariationTally[currentReadIndex]=count + 1;
}"
50455,"@Override public void processAlignmentEntry(final AlignmentReader alignmentReader,final Alignments.AlignmentEntry alignmentEntry){
  System.out.printf(""String_Node_Str"",alignmentEntry.getQueryIndex(),alignmentEntry.getTargetIndex(),getReferenceId(alignmentEntry.getTargetIndex()),alignmentEntry.getScore());
}","@Override public void processAlignmentEntry(final AlignmentReader alignmentReader,final Alignments.AlignmentEntry alignmentEntry){
  System.out.printf(""String_Node_Str"" + ""String_Node_Str"",alignmentEntry.getQueryIndex(),alignmentEntry.getTargetIndex(),getReferenceId(alignmentEntry.getTargetIndex()),alignmentEntry.getScore());
}"
50456,"@Test public void testIterateSortedReferenceInsertions() throws IOException {
  final String basename=""String_Node_Str"";
  final String basenamePath=FilenameUtils.concat(BASE_TEST_DIR,basename);
  final AlignmentWriter writer=new AlignmentWriter(basenamePath);
  writer.setNumAlignmentEntriesPerChunk(1);
  final int numTargets=3;
  final int[] targetLengths=new int[numTargets];
  for (int referenceIndex=0; referenceIndex < numTargets; referenceIndex++) {
    targetLengths[referenceIndex]=1000;
  }
  writer.setTargetLengths(targetLengths);
  writer.setSorted(true);
  Alignments.AlignmentEntry.Builder newEntry;
  newEntry=prepareAlignmentEntryWithReferenceInsertion(0,1,100,30,false,new int[]{4,3});
  writer.appendEntry(newEntry.build());
  writer.close();
  writer.printStats(System.out);
  final Int2IntMap positionMap=new Int2IntOpenHashMap();
  IterateSortedAlignmentsListImpl iterator=new IterateSortedAlignmentsListImpl(){
    @Override public void processPositions(    int position,    ObjectArrayList<PositionBaseInfo> positionBaseInfos){
      int coverage=0;
      for (      PositionBaseInfo info : positionBaseInfos) {
        coverage+=info.to != '-' ? 1 : 0;
      }
      positionMap.put(position,coverage);
      System.out.printf(""String_Node_Str"",position,coverage);
    }
  }
;
  iterator.iterate(basenamePath);
  for (int i=0; i < 100; i++) {
    assertEquals(""String_Node_Str"" + i,0,positionMap.get(i));
  }
  for (int i=100; i < 104; i++) {
    assertEquals(""String_Node_Str"" + i,1,positionMap.get(i));
  }
  for (int i=104; i < 107; i++) {
    assertEquals(""String_Node_Str"" + i,0,positionMap.get(i));
  }
  for (int i=107; i < 137; i++) {
    assertEquals(""String_Node_Str"" + i,1,positionMap.get(i));
  }
  for (int i=138; i < 150; i++) {
    assertEquals(""String_Node_Str"" + i,0,positionMap.get(i));
  }
}","@Test public void testIterateSortedReferenceInsertions() throws IOException {
  final String basename=""String_Node_Str"";
  final String basenamePath=FilenameUtils.concat(BASE_TEST_DIR,basename);
  final AlignmentWriter writer=new AlignmentWriter(basenamePath);
  writer.setNumAlignmentEntriesPerChunk(1);
  final int numTargets=3;
  final int[] targetLengths=new int[numTargets];
  for (int referenceIndex=0; referenceIndex < numTargets; referenceIndex++) {
    targetLengths[referenceIndex]=1000;
  }
  writer.setTargetLengths(targetLengths);
  writer.setSorted(true);
  Alignments.AlignmentEntry.Builder newEntry;
  newEntry=prepareAlignmentEntryWithReferenceInsertion(0,1,100,30,false,new int[]{4,3});
  writer.appendEntry(newEntry.build());
  writer.close();
  writer.printStats(System.out);
  final Int2IntMap positionMap=new Int2IntOpenHashMap();
  final IntSet variantReadIndices=new IntOpenHashSet();
  IterateSortedAlignmentsListImpl iterator=new IterateSortedAlignmentsListImpl(){
    @Override public void observeVariantBase(    ConcatSortedAlignmentReader sortedReaders,    Int2ObjectMap<ObjectArrayList<PositionBaseInfo>> positionToBases,    Alignments.SequenceVariation var,    char toChar,    char fromChar,    int currentRefPosition,    int currentReadIndex){
      variantReadIndices.add(currentReadIndex);
    }
    @Override public void processPositions(    int position,    ObjectArrayList<PositionBaseInfo> positionBaseInfos){
      int coverage=0;
      for (      PositionBaseInfo info : positionBaseInfos) {
        coverage+=info.to != '-' ? 1 : 0;
      }
      positionMap.put(position,coverage);
      System.out.printf(""String_Node_Str"",position,coverage);
    }
  }
;
  iterator.iterate(basenamePath);
  for (int i=0; i < 100; i++) {
    assertEquals(""String_Node_Str"" + i,0,positionMap.get(i));
  }
  for (int i=100; i < 103; i++) {
    assertEquals(""String_Node_Str"" + i,1,positionMap.get(i));
  }
  for (int i=103; i < 106; i++) {
    assertEquals(""String_Node_Str"" + i,0,positionMap.get(i));
  }
  for (int i=106; i < 137; i++) {
    assertEquals(""String_Node_Str"" + i,1,positionMap.get(i));
  }
  for (int i=138; i < 150; i++) {
    assertEquals(""String_Node_Str"" + i,0,positionMap.get(i));
  }
}"
50457,"private Alignments.AlignmentEntry.Builder prepareAlignmentEntry(final int queryIndex,final int targetIndex,final int position,final float score,final boolean matchesReverseStrand,int[] variationIndices){
  Alignments.AlignmentEntry.Builder newEntry=Alignments.AlignmentEntry.newBuilder();
  newEntry.setQueryIndex(queryIndex);
  newEntry.setTargetIndex(targetIndex);
  newEntry.setScore(score);
  newEntry.setPosition(position);
  newEntry.setMatchingReverseStrand(matchesReverseStrand);
  newEntry.setMultiplicity(1);
  newEntry.setQueryLength(35);
  for (  int variaIndex : variationIndices) {
    Alignments.SequenceVariation.Builder varBuilder=Alignments.SequenceVariation.newBuilder();
    varBuilder.setFrom(""String_Node_Str"");
    varBuilder.setTo(""String_Node_Str"");
    varBuilder.setReadIndex(1);
    varBuilder.setPosition(variaIndex);
    newEntry.addSequenceVariations(varBuilder.build());
  }
  return newEntry;
}","private Alignments.AlignmentEntry.Builder prepareAlignmentEntry(final int queryIndex,final int targetIndex,final int position,final float score,final boolean matchesReverseStrand,int[] variationIndices,int queryLength){
  Alignments.AlignmentEntry.Builder newEntry=Alignments.AlignmentEntry.newBuilder();
  newEntry.setQueryIndex(queryIndex);
  newEntry.setTargetIndex(targetIndex);
  newEntry.setScore(score);
  newEntry.setPosition(position);
  newEntry.setMatchingReverseStrand(matchesReverseStrand);
  newEntry.setMultiplicity(1);
  newEntry.setQueryLength(queryLength);
  for (  int variaIndex : variationIndices) {
    Alignments.SequenceVariation.Builder varBuilder=Alignments.SequenceVariation.newBuilder();
    varBuilder.setFrom(""String_Node_Str"");
    varBuilder.setTo(""String_Node_Str"");
    varBuilder.setReadIndex(1);
    varBuilder.setPosition(variaIndex);
    newEntry.addSequenceVariations(varBuilder.build());
  }
  return newEntry;
}"
50458,"/** 
 * Configure.
 * @param args command line arguments
 * @return this object for chaining
 * @throws java.io.IOException error parsing
 * @throws com.martiansoftware.jsap.JSAPException error parsing
 */
@Override public AbstractCommandLineMode configure(final String[] args) throws IOException, JSAPException {
  final JSAPResult jsapResult=parseJsapArguments(args);
  inputFilenames=jsapResult.getStringArray(""String_Node_Str"");
  outputFile=jsapResult.getString(""String_Node_Str"");
  outWriter=""String_Node_Str"".equals(outputFile) ? new PrintWriter(System.out) : new PrintWriter(outputFile);
  final String groupsDefinition=jsapResult.getString(""String_Node_Str"");
  deAnalyzer.parseGroupsDefinition(groupsDefinition,deCalculator,inputFilenames);
  final String compare=jsapResult.getString(""String_Node_Str"");
  deAnalyzer.parseCompare(compare);
  Map<String,String> sampleToGroupMap=deCalculator.getSampleToGroupMap();
  readerIndexToGroupIndex=new int[inputFilenames.length];
  IndexedIdentifier groupIds=new IndexedIdentifier();
  for (  String group : sampleToGroupMap.values()) {
    groupIds.registerIdentifier(new MutableString(group));
  }
  minimumVariationSupport=jsapResult.getInt(""String_Node_Str"");
  thresholdDistinctReadIndices=jsapResult.getInt(""String_Node_Str"");
  CompactAlignmentToAnnotationCountsMode.parseEval(jsapResult,deAnalyzer);
  numberOfGroups=deAnalyzer.getGroups().length;
  groups=deAnalyzer.getGroups();
  variationPool=new SequenceVariationPool(numberOfGroups);
  for (  String sample : sampleToGroupMap.keySet()) {
    final String group=sampleToGroupMap.get(sample);
    System.out.printf(""String_Node_Str"",sample,group);
    for (int readerIndex=0; readerIndex < inputFilenames.length; readerIndex++) {
      if (AlignmentReader.getBasename(inputFilenames[readerIndex]).endsWith(sample)) {
        readerIndexToGroupIndex[readerIndex]=groupIds.get(new MutableString(group));
      }
    }
  }
  File statFile=jsapResult.getFile(""String_Node_Str"");
  if (statFile != null) {
    loadStatFile(statFile);
  }
 else {
    if (deAnalyzer.eval(""String_Node_Str"")) {
      System.err.println(""String_Node_Str"");
      System.exit(1);
    }
  }
  refCount=new int[numberOfGroups];
  variantsCount=new int[numberOfGroups];
  distinctReadIndexCount=new int[numberOfGroups];
  if (deAnalyzer.eval(""String_Node_Str"") || deAnalyzer.eval(""String_Node_Str"")) {
    final Rengine rEngine=GobyRengine.getInstance().getRengine();
    fisherRInstalled=rEngine != null && rEngine.isAlive();
  }
  return this;
}","/** 
 * Configure.
 * @param args command line arguments
 * @return this object for chaining
 * @throws java.io.IOException error parsing
 * @throws com.martiansoftware.jsap.JSAPException error parsing
 */
@Override public AbstractCommandLineMode configure(final String[] args) throws IOException, JSAPException {
  final JSAPResult jsapResult=parseJsapArguments(args);
  inputFilenames=jsapResult.getStringArray(""String_Node_Str"");
  outputFile=jsapResult.getString(""String_Node_Str"");
  outWriter=""String_Node_Str"".equals(outputFile) ? new PrintWriter(System.out) : new PrintWriter(outputFile);
  final String groupsDefinition=jsapResult.getString(""String_Node_Str"");
  deAnalyzer.parseGroupsDefinition(groupsDefinition,deCalculator,inputFilenames);
  final String compare=jsapResult.getString(""String_Node_Str"");
  deAnalyzer.parseCompare(compare);
  Map<String,String> sampleToGroupMap=deCalculator.getSampleToGroupMap();
  readerIndexToGroupIndex=new int[inputFilenames.length];
  IndexedIdentifier groupIds=new IndexedIdentifier();
  for (  String group : sampleToGroupMap.values()) {
    groupIds.registerIdentifier(new MutableString(group));
  }
  minimumVariationSupport=jsapResult.getInt(""String_Node_Str"");
  thresholdDistinctReadIndices=jsapResult.getInt(""String_Node_Str"");
  CompactAlignmentToAnnotationCountsMode.parseEval(jsapResult,deAnalyzer);
  numberOfGroups=deAnalyzer.getGroups().length;
  groups=deAnalyzer.getGroups();
  variationPool=new SequenceVariationPool(numberOfGroups);
  for (  String sample : sampleToGroupMap.keySet()) {
    final String group=sampleToGroupMap.get(sample);
    System.out.printf(""String_Node_Str"",sample,group);
    for (int readerIndex=0; readerIndex < inputFilenames.length; readerIndex++) {
      if (AlignmentReader.getBasename(inputFilenames[readerIndex]).endsWith(sample)) {
        readerIndexToGroupIndex[readerIndex]=groupIds.get(new MutableString(group));
      }
    }
  }
  File statFile=jsapResult.getFile(""String_Node_Str"");
  if (statFile != null) {
    loadStatFile(statFile);
  }
 else {
    if (deAnalyzer.eval(""String_Node_Str"")) {
      System.err.println(""String_Node_Str"");
      System.exit(1);
    }
  }
  refCount=new int[numberOfGroups];
  variantsCount=new int[numberOfGroups];
  distinctReadIndexCount=new int[numberOfGroups];
  if (deAnalyzer.eval(""String_Node_Str"") || deAnalyzer.eval(""String_Node_Str"")) {
    final Rengine rEngine=GobyRengine.getInstance().getRengine();
    fisherRInstalled=rEngine != null && rEngine.isAlive();
  }
  if (deAnalyzer.eval(""String_Node_Str"") && groups.length != 2) {
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  return this;
}"
50459,"/** 
 * Perform the concatenation.
 * @throws java.io.IOException
 */
@Override public void execute() throws IOException {
  final String outputFilename=outputFile;
  final String[] basenames=AlignmentReader.getBasenames(inputFilenames);
  final boolean allSorted=ConcatenateAlignmentMode.isAllSorted(basenames);
  if (!allSorted) {
    System.out.println(""String_Node_Str"");
    System.exit(10);
  }
  if (readIndexStats != null) {
    int readerIndex=0;
    for (    String basename : basenames) {
      boolean found=false;
      for (      ReadIndexStats stat : readIndexStats) {
        if (FilenameUtils.getBaseName(basename).equals(stat.basename)) {
          stat.readerIndex=readerIndex;
          found=true;
        }
      }
      if (!found) {
        System.err.printf(""String_Node_Str"",basename);
      }
      readerIndex++;
    }
    Collections.sort(readIndexStats,new Comparator<ReadIndexStats>(){
      public int compare(      ReadIndexStats readIndexStats,      ReadIndexStats readIndexStatsFirst){
        return readIndexStats.readerIndex - readIndexStatsFirst.readerIndex;
      }
    }
);
    for (    ReadIndexStats stat : readIndexStats) {
      for (int readIndex=0; readIndex < numberOfReadIndices; readIndex++) {
        stat.countReferenceBases[readIndex]/=numberOfReadIndices;
      }
    }
  }
  ConcatSortedAlignmentReader sortedReaders=new ConcatSortedAlignmentReader(basenames);
  int lastPosition=-1;
  int lastTargetIndex=-1;
  ObjectArrayList<Alignments.AlignmentEntry> entriesAtPosition=new ObjectArrayList<Alignments.AlignmentEntry>();
  IntArrayList readerIndices=new IntArrayList();
  DoubleIndexedIdentifier targetIds=new DoubleIndexedIdentifier(sortedReaders.getTargetIdentifiers());
  outWriter.printf(""String_Node_Str"");
  if (deAnalyzer.eval(""String_Node_Str"")) {
    outWriter.printf(""String_Node_Str"",groups[0],groups[1],groups[0],groups[1]);
  }
  for (  String group : groups) {
    outWriter.printf(""String_Node_Str"",group,group,group,group);
    if (deAnalyzer.eval(""String_Node_Str"")) {
      outWriter.printf(""String_Node_Str"",group);
    }
  }
  outWriter.printf(""String_Node_Str"");
  for (  Alignments.AlignmentEntry entry : sortedReaders) {
    if (currentReferenceId == null) {
      currentReferenceId=targetIds.getId(entry.getTargetIndex());
      currentReferenceIndex=entry.getTargetIndex();
    }
    final int position=entry.getPosition();
    final int targetIndex=entry.getTargetIndex();
    if (targetIndex != lastTargetIndex || position != lastPosition) {
      if (entriesAtPosition.size() != 0) {
        pushVariations(entriesAtPosition,readerIndices);
      }
      processVariations(lastPosition);
      if (targetIndex != lastTargetIndex) {
        variationPool.reset();
        currentReferenceId=targetIds.getId(entry.getTargetIndex());
      }
      variationPool.removePosition(lastPosition);
      entriesAtPosition.clear();
      readerIndices.clear();
      lastPosition=position;
      lastTargetIndex=targetIndex;
    }
    entriesAtPosition.add(entry);
    readerIndices.add(sortedReaders.getReaderIndex());
  }
  outWriter.flush();
}","/** 
 * Perform the concatenation.
 * @throws java.io.IOException
 */
@Override public void execute() throws IOException {
  final String outputFilename=outputFile;
  final String[] basenames=AlignmentReader.getBasenames(inputFilenames);
  final boolean allSorted=ConcatenateAlignmentMode.isAllSorted(basenames);
  if (!allSorted) {
    System.out.println(""String_Node_Str"");
    System.exit(10);
  }
  if (readIndexStats != null) {
    int readerIndex=0;
    for (    String basename : basenames) {
      boolean found=false;
      for (      ReadIndexStats stat : readIndexStats) {
        if (FilenameUtils.getBaseName(basename).equals(stat.basename)) {
          stat.readerIndex=readerIndex;
          found=true;
        }
      }
      if (!found) {
        System.err.printf(""String_Node_Str"",basename);
      }
      readerIndex++;
    }
    Collections.sort(readIndexStats,new Comparator<ReadIndexStats>(){
      public int compare(      ReadIndexStats readIndexStats,      ReadIndexStats readIndexStatsFirst){
        return readIndexStats.readerIndex - readIndexStatsFirst.readerIndex;
      }
    }
);
    numberOfReadIndices=new int[this.deCalculator.getSampleToGroupMap().keySet().size()];
    ObjectSet<ReadIndexStats> toRemove=new ObjectArraySet<ReadIndexStats>();
    for (    ReadIndexStats stat : readIndexStats) {
      if (stat.readerIndex == -1) {
        toRemove.add(stat);
        continue;
      }
      numberOfReadIndices[stat.readerIndex]=Math.max(numberOfReadIndices[stat.readerIndex],stat.countReferenceBases.length);
    }
    readIndexStats.removeAll(toRemove);
    for (    ReadIndexStats stat : readIndexStats) {
      for (int readIndex=0; readIndex < numberOfReadIndices[stat.readerIndex]; readIndex++) {
        stat.countReferenceBases[readIndex]/=numberOfReadIndices[stat.readerIndex];
      }
    }
  }
  ConcatSortedAlignmentReader sortedReaders=new ConcatSortedAlignmentReader(basenames);
  int lastPosition=-1;
  int lastTargetIndex=-1;
  ObjectArrayList<Alignments.AlignmentEntry> entriesAtPosition=new ObjectArrayList<Alignments.AlignmentEntry>();
  IntArrayList readerIndices=new IntArrayList();
  DoubleIndexedIdentifier targetIds=new DoubleIndexedIdentifier(sortedReaders.getTargetIdentifiers());
  outWriter.printf(""String_Node_Str"");
  if (deAnalyzer.eval(""String_Node_Str"")) {
    outWriter.printf(""String_Node_Str"",groups[0],groups[1],groups[0],groups[1]);
  }
  for (  String group : groups) {
    outWriter.printf(""String_Node_Str"",group,group,group,group);
    if (deAnalyzer.eval(""String_Node_Str"")) {
      outWriter.printf(""String_Node_Str"",group);
    }
  }
  outWriter.printf(""String_Node_Str"");
  for (  Alignments.AlignmentEntry entry : sortedReaders) {
    if (currentReferenceId == null) {
      currentReferenceId=targetIds.getId(entry.getTargetIndex());
      currentReferenceIndex=entry.getTargetIndex();
    }
    final int position=entry.getPosition();
    final int targetIndex=entry.getTargetIndex();
    if (targetIndex != lastTargetIndex || position != lastPosition) {
      if (entriesAtPosition.size() != 0) {
        pushVariations(entriesAtPosition,readerIndices);
      }
      processVariations(lastPosition);
      if (targetIndex != lastTargetIndex) {
        variationPool.reset();
        currentReferenceId=targetIds.getId(entry.getTargetIndex());
      }
      variationPool.removePosition(lastPosition);
      entriesAtPosition.clear();
      readerIndices.clear();
      lastPosition=position;
      lastTargetIndex=targetIndex;
    }
    entriesAtPosition.add(entry);
    readerIndices.add(sortedReaders.getReaderIndex());
  }
  outWriter.flush();
}"
50460,"/** 
 * Print statistics about an alignment file in the Goby compact form.
 * @param file The file to display statistics about
 * @throws IOException if the file cannot be read
 */
private void describeCompactAlignment(final File file) throws IOException {
  final String basename=AlignmentReader.getBasename(file.toString());
  stream.printf(""String_Node_Str"",basename);
  final AlignmentReader reader=new AlignmentReader(basename);
  reader.readHeader();
  stream.println(""String_Node_Str"");
  stream.printf(""String_Node_Str"",reader.isSorted());
  stream.printf(""String_Node_Str"",reader.isIndexed());
  stream.printf(""String_Node_Str"",reader.getNumberOfTargets());
  final int[] targetLengthsFromHeader=reader.getTargetLength();
  stream.printf(""String_Node_Str"",ArrayUtils.getLength(reader.getTargetLength()));
  stream.printf(""String_Node_Str"",reader.getSmallestSplitQueryIndex());
  stream.printf(""String_Node_Str"",reader.getLargestSplitQueryIndex());
  final SummaryStatistics targetLengthStats=new SummaryStatistics();
  if (targetLengthsFromHeader != null) {
    for (    final double d : targetLengthsFromHeader) {
      targetLengthStats.addValue(d);
    }
  }
  stream.printf(""String_Node_Str"",(int)targetLengthStats.getMin());
  stream.printf(""String_Node_Str"",(int)targetLengthStats.getMax());
  stream.printf(""String_Node_Str"",targetLengthStats.getMean());
  stream.println();
  stream.printf(""String_Node_Str"",reader.getNumberOfQueries());
  final int[] queryLengthsFromHeader=reader.getQueryLengths();
  stream.printf(""String_Node_Str"",ArrayUtils.getLength(queryLengthsFromHeader));
  final SummaryStatistics queryLengthStats=new SummaryStatistics();
  if (queryLengthsFromHeader != null) {
    stream.println(""String_Node_Str"");
  }
  stream.println(""String_Node_Str"" + reader.isConstantQueryLengths());
  stream.printf(""String_Node_Str"",reader.getQueryIdentifiers() != null && !reader.getQueryIdentifiers().isEmpty());
  stream.printf(""String_Node_Str"",reader.getTargetIdentifiers() != null && !reader.getTargetIdentifiers().isEmpty());
  stream.println();
  final IntSet alignedQueryIndices=new IntOpenHashSet();
  describeAmbigousReads(basename,reader.getNumberOfQueries(),alignedQueryIndices);
  int maxQueryIndex=-1;
  int maxTargetIndex=-1;
  int numEntries=0;
  long numLogicalAlignmentEntries=0;
  long total=0;
  double avgScore=0;
  int sumNumVariations=0;
  for (  final Alignments.AlignmentEntry entry : reader) {
    numberOfReads++;
    numEntries++;
    numLogicalAlignmentEntries+=entry.getMultiplicity();
    total+=entry.getQueryAlignedLength();
    avgScore+=entry.getScore();
    maxQueryIndex=Math.max(maxQueryIndex,entry.getQueryIndex());
    maxTargetIndex=Math.max(maxTargetIndex,entry.getTargetIndex());
    cumulativeReadLength+=entry.getQueryAlignedLength();
    minReadLength=Math.min(minReadLength,entry.getQueryAlignedLength());
    maxReadLength=Math.max(maxReadLength,entry.getQueryAlignedLength());
    sumNumVariations+=entry.getSequenceVariationsCount();
    alignedQueryIndices.add(entry.getQueryIndex());
    final double queryLength;
    if (entry.hasQueryLength()) {
      queryLength=entry.getQueryLength();
    }
 else {
      queryLength=reader.getQueryLength(entry.getQueryIndex());
    }
    queryLengthStats.addValue(queryLength);
  }
  avgScore/=(double)numLogicalAlignmentEntries;
  final int numQuerySequences=maxQueryIndex + 1;
  stream.printf(""String_Node_Str"",numQuerySequences);
  final int numTargetSequences=maxTargetIndex + 1;
  final double avgNumVariationsPerQuery=((double)sumNumVariations) / (double)numQuerySequences;
  stream.printf(""String_Node_Str"",numTargetSequences);
  stream.printf(""String_Node_Str"",numLogicalAlignmentEntries);
  stream.printf(""String_Node_Str"",alignedQueryIndices.size());
  stream.printf(""String_Node_Str"",(double)alignedQueryIndices.size() / (double)(long)numQuerySequences * 100.0d);
  stream.printf(""String_Node_Str"",numEntries > 0 ? divide(total,numEntries) : -1);
  stream.printf(""String_Node_Str"",avgScore);
  stream.printf(""String_Node_Str"",avgNumVariationsPerQuery);
  final long size=file.length();
  stream.printf(""String_Node_Str"",divide(size,numLogicalAlignmentEntries));
  stream.printf(""String_Node_Str"",(int)queryLengthStats.getMin());
  stream.printf(""String_Node_Str"",(int)queryLengthStats.getMax());
  stream.printf(""String_Node_Str"",queryLengthStats.getMean());
}","/** 
 * Print statistics about an alignment file in the Goby compact form.
 * @param file The file to display statistics about
 * @throws IOException if the file cannot be read
 */
private void describeCompactAlignment(final File file) throws IOException {
  final String basename=AlignmentReader.getBasename(file.toString());
  stream.printf(""String_Node_Str"",basename);
  final AlignmentReader reader=new AlignmentReader(basename);
  reader.readHeader();
  stream.println(""String_Node_Str"");
  stream.printf(""String_Node_Str"",reader.isSorted());
  stream.printf(""String_Node_Str"",reader.isIndexed());
  stream.printf(""String_Node_Str"",reader.getNumberOfTargets());
  final int[] targetLengthsFromHeader=reader.getTargetLength();
  stream.printf(""String_Node_Str"",ArrayUtils.getLength(reader.getTargetLength()));
  stream.printf(""String_Node_Str"",reader.getSmallestSplitQueryIndex());
  stream.printf(""String_Node_Str"",reader.getLargestSplitQueryIndex());
  final SummaryStatistics targetLengthStats=new SummaryStatistics();
  if (targetLengthsFromHeader != null) {
    for (    final double d : targetLengthsFromHeader) {
      targetLengthStats.addValue(d);
    }
  }
  stream.printf(""String_Node_Str"",(int)targetLengthStats.getMin());
  stream.printf(""String_Node_Str"",(int)targetLengthStats.getMax());
  stream.printf(""String_Node_Str"",targetLengthStats.getMean());
  stream.println();
  stream.printf(""String_Node_Str"",reader.getNumberOfQueries());
  final int[] queryLengthsFromHeader=reader.getQueryLengths();
  stream.printf(""String_Node_Str"",ArrayUtils.getLength(queryLengthsFromHeader));
  final SummaryStatistics queryLengthStats=new SummaryStatistics();
  if (queryLengthsFromHeader != null) {
    stream.println(""String_Node_Str"");
  }
  stream.println(""String_Node_Str"" + reader.isConstantQueryLengths());
  stream.printf(""String_Node_Str"",reader.getQueryIdentifiers() != null && !reader.getQueryIdentifiers().isEmpty());
  stream.printf(""String_Node_Str"",reader.getTargetIdentifiers() != null && !reader.getTargetIdentifiers().isEmpty());
  stream.println();
  final IntSet alignedQueryIndices=new IntOpenHashSet();
  describeAmbigousReads(basename,reader.getNumberOfQueries(),alignedQueryIndices);
  int maxQueryIndex=-1;
  int maxTargetIndex=-1;
  int numEntries=0;
  long numLogicalAlignmentEntries=0;
  long total=0;
  double avgScore=0;
  int sumNumVariations=0;
  for (  final Alignments.AlignmentEntry entry : reader) {
    numberOfReads++;
    numEntries++;
    numLogicalAlignmentEntries+=entry.getMultiplicity();
    total+=entry.getQueryAlignedLength();
    avgScore+=entry.getScore();
    maxQueryIndex=Math.max(maxQueryIndex,entry.getQueryIndex());
    maxTargetIndex=Math.max(maxTargetIndex,entry.getTargetIndex());
    cumulativeReadLength+=entry.getQueryAlignedLength();
    minReadLength=Math.min(minReadLength,entry.getQueryAlignedLength());
    maxReadLength=Math.max(maxReadLength,entry.getQueryAlignedLength());
    sumNumVariations+=entry.getSequenceVariationsCount();
    alignedQueryIndices.add(entry.getQueryIndex());
    if (entry.hasQueryLength()) {
      final double queryLength=entry.getQueryLength();
      queryLengthStats.addValue(queryLength);
    }
 else     if (reader.hasQueryLengths() || reader.isConstantQueryLengths()) {
      final double queryLength=reader.getQueryLength(entry.getQueryIndex());
      queryLengthStats.addValue(queryLength);
    }
  }
  avgScore/=(double)numLogicalAlignmentEntries;
  final int numQuerySequences=maxQueryIndex + 1;
  stream.printf(""String_Node_Str"",numQuerySequences);
  final int numTargetSequences=maxTargetIndex + 1;
  final double avgNumVariationsPerQuery=((double)sumNumVariations) / (double)numQuerySequences;
  stream.printf(""String_Node_Str"",numTargetSequences);
  stream.printf(""String_Node_Str"",numLogicalAlignmentEntries);
  stream.printf(""String_Node_Str"",alignedQueryIndices.size());
  stream.printf(""String_Node_Str"",(double)alignedQueryIndices.size() / (double)(long)numQuerySequences * 100.0d);
  stream.printf(""String_Node_Str"",numEntries > 0 ? divide(total,numEntries) : -1);
  stream.printf(""String_Node_Str"",avgScore);
  stream.printf(""String_Node_Str"",avgNumVariationsPerQuery);
  final long size=file.length();
  stream.printf(""String_Node_Str"",divide(size,numLogicalAlignmentEntries));
  stream.printf(""String_Node_Str"",(int)queryLengthStats.getMin());
  stream.printf(""String_Node_Str"",(int)queryLengthStats.getMax());
  stream.printf(""String_Node_Str"",queryLengthStats.getMean());
}"
50461,"/** 
 * Print statistics about an alignment file in the Goby compact form.
 * @param file The file to display statistics about
 * @throws IOException if the file cannot be read
 */
private void describeCompactAlignment(final File file) throws IOException {
}","/** 
 * Print statistics about an alignment file in the Goby compact form.
 * @param file The file to display statistics about
 * @throws IOException if the file cannot be read
 */
private void describeCompactAlignment(final File file) throws IOException {
  final String basename=AlignmentReader.getBasename(file.toString());
  stream.printf(""String_Node_Str"",basename);
  final AlignmentReader reader=new AlignmentReader(basename);
  reader.readHeader();
  stream.println(""String_Node_Str"");
  stream.printf(""String_Node_Str"",reader.isSorted());
  stream.printf(""String_Node_Str"",reader.isIndexed());
  stream.printf(""String_Node_Str"",reader.getNumberOfTargets());
  final int[] targetLength=reader.getTargetLength();
  stream.printf(""String_Node_Str"",ArrayUtils.getLength(reader.getTargetLength()));
  stream.printf(""String_Node_Str"",reader.getSmallestSplitQueryIndex());
  stream.printf(""String_Node_Str"",reader.getLargestSplitQueryIndex());
  final SummaryStatistics targetLengthStats=new SummaryStatistics();
  if (targetLength != null) {
    for (    final double d : targetLength) {
      targetLengthStats.addValue(d);
    }
  }
  stream.printf(""String_Node_Str"",(int)targetLengthStats.getMin());
  stream.printf(""String_Node_Str"",(int)targetLengthStats.getMax());
  stream.printf(""String_Node_Str"",targetLengthStats.getMean());
  stream.println();
  stream.printf(""String_Node_Str"",reader.getNumberOfQueries());
  final int[] queryLength=reader.getQueryLengths();
  stream.printf(""String_Node_Str"",ArrayUtils.getLength(queryLength));
  final SummaryStatistics queryLengthStats=new SummaryStatistics();
  if (queryLength != null) {
    System.out.println(""String_Node_Str"");
    for (    final double d : queryLength) {
      queryLengthStats.addValue(d);
    }
  }
  stream.println(""String_Node_Str"" + reader.isConstantQueryLengths());
  stream.printf(""String_Node_Str"",reader.getQueryIdentifiers() != null && !reader.getQueryIdentifiers().isEmpty());
  stream.printf(""String_Node_Str"",reader.getTargetIdentifiers() != null && !reader.getTargetIdentifiers().isEmpty());
  stream.println();
  final IntSet alignedQueryIndices=new IntOpenHashSet();
  describeAmbigousReads(basename,reader.getNumberOfQueries(),alignedQueryIndices);
  int maxQueryIndex=-1;
  int maxTargetIndex=-1;
  int numEntries=0;
  long numLogicalAlignmentEntries=0;
  long total=0;
  double avgScore=0;
  int sumNumVariations=0;
  for (  final Alignments.AlignmentEntry entry : reader) {
    numberOfReads++;
    numEntries++;
    numLogicalAlignmentEntries+=entry.getMultiplicity();
    total+=entry.getQueryAlignedLength();
    avgScore+=entry.getScore();
    maxQueryIndex=Math.max(maxQueryIndex,entry.getQueryIndex());
    maxTargetIndex=Math.max(maxTargetIndex,entry.getTargetIndex());
    cumulativeReadLength+=entry.getQueryAlignedLength();
    minReadLength=Math.min(minReadLength,entry.getQueryAlignedLength());
    maxReadLength=Math.max(maxReadLength,entry.getQueryAlignedLength());
    sumNumVariations+=entry.getSequenceVariationsCount();
    alignedQueryIndices.add(entry.getQueryIndex());
  }
  avgScore/=(double)numLogicalAlignmentEntries;
  final int numQuerySequences=maxQueryIndex + 1;
  stream.printf(""String_Node_Str"",numQuerySequences);
  final int numTargetSequences=maxTargetIndex + 1;
  final double avgNumVariationsPerQuery=((double)sumNumVariations) / (double)numQuerySequences;
  stream.printf(""String_Node_Str"",numTargetSequences);
  stream.printf(""String_Node_Str"",numLogicalAlignmentEntries);
  stream.printf(""String_Node_Str"",alignedQueryIndices.size());
  stream.printf(""String_Node_Str"",(double)alignedQueryIndices.size() / (double)(long)numQuerySequences * 100.0d);
  stream.printf(""String_Node_Str"",numEntries > 0 ? divide(total,numEntries) : -1);
  stream.printf(""String_Node_Str"",avgScore);
  stream.printf(""String_Node_Str"",avgNumVariationsPerQuery);
  final long size=file.length();
  stream.printf(""String_Node_Str"",divide(size,numLogicalAlignmentEntries));
  stream.printf(""String_Node_Str"",(int)queryLengthStats.getMin());
  stream.printf(""String_Node_Str"",(int)queryLengthStats.getMax());
  stream.printf(""String_Node_Str"",queryLengthStats.getMean());
}"
50462,"/** 
 * Configure.
 * @param args command line arguments
 * @return this object for chaining
 * @throws java.io.IOException error parsing
 * @throws com.martiansoftware.jsap.JSAPException error parsing
 */
@Override public AbstractCommandLineMode configure(final String[] args) throws IOException, JSAPException {
  final JSAPResult jsapResult=parseJsapArguments(args);
  final String inputFile=jsapResult.getString(""String_Node_Str"");
  basename=AlignmentReader.getBasename(inputFile);
  outputFilename=jsapResult.getString(""String_Node_Str"");
  alignmentIterator=new SortIterateAlignments();
  alignmentIterator.parseIncludeReferenceArgument(jsapResult);
  if (jsapResult.contains(""String_Node_Str"") || jsapResult.contains(""String_Node_Str"")) {
    hasStartOrEndPosition=true;
    startPosition=jsapResult.getLong(""String_Node_Str"",0L);
    endPosition=jsapResult.getLong(""String_Node_Str"",Long.MAX_VALUE);
  }
  if (startPosition < 0L) {
    throw new JSAPException(""String_Node_Str"");
  }
  if (endPosition < 0L) {
    throw new JSAPException(""String_Node_Str"");
  }
  if (startPosition > endPosition) {
    throw new JSAPException(""String_Node_Str"");
  }
  return this;
}","/** 
 * Configure.
 * @param args command line arguments
 * @return this object for chaining
 * @throws java.io.IOException error parsing
 * @throws com.martiansoftware.jsap.JSAPException error parsing
 */
@Override public AbstractCommandLineMode configure(final String[] args) throws IOException, JSAPException {
  final JSAPResult jsapResult=parseJsapArguments(args);
  final String inputFile=jsapResult.getString(""String_Node_Str"");
  basename=AlignmentReader.getBasename(inputFile);
  outputFilename=jsapResult.getString(""String_Node_Str"");
  alignmentIterator=new SortIterateAlignments();
  alignmentIterator.parseIncludeReferenceArgument(jsapResult);
  endPosition=Long.MAX_VALUE;
  if (jsapResult.contains(""String_Node_Str"") || jsapResult.contains(""String_Node_Str"")) {
    hasStartOrEndPosition=true;
    startPosition=jsapResult.getLong(""String_Node_Str"",0L);
    endPosition=jsapResult.getLong(""String_Node_Str"",Long.MAX_VALUE);
  }
  if (startPosition < 0L) {
    throw new JSAPException(""String_Node_Str"");
  }
  if (endPosition < 0L) {
    throw new JSAPException(""String_Node_Str"");
  }
  if (startPosition > endPosition) {
    throw new JSAPException(""String_Node_Str"");
  }
  return this;
}"
50463,"/** 
 * Returns whether this read has query lentgh information.
 * @return True or false.
 */
public boolean hasQueryLengths(){
  if (constantQueryLengths) {
    return true;
  }
 else {
    return queryLengths != null;
  }
}","/** 
 * Returns whether this read has query length information.
 * @return True or false.
 */
public boolean hasQueryLengths(){
  return ArrayUtils.isNotEmpty(queryLengths);
}"
50464,"private void writeHeader() throws IOException {
  if (!headerWritten) {
    final Alignments.AlignmentHeader.Builder headerBuilder=Alignments.AlignmentHeader.newBuilder();
    headerBuilder.setLargestSplitQueryIndex(maxQueryIndex);
    headerBuilder.setSmallestSplitQueryIndex(minQueryIndex);
    headerBuilder.setNumberOfTargets(maxTargetIndex + 1);
    headerBuilder.setNumberOfQueries(getNumQueries());
    headerBuilder.setSorted(sortedState);
    headerBuilder.setIndexed(sortedState);
    headerBuilder.setQueryNameMapping(getMapping(queryIdentifiers,queryIdentifiersArray));
    headerBuilder.setTargetNameMapping(getMapping(targetIdentifiers,targetIdentifiersArray));
    headerBuilder.setNumberOfAlignedReads(numberOfAlignedReads);
    compactQueryLengths(queryLengths);
    if (isConstantQueryLength) {
      headerBuilder.setConstantQueryLength(constantQueryLength);
    }
 else     if (queryLengths != null) {
      headerBuilder.addAllQueryLength(IntArrayList.wrap(queryLengths));
    }
    if (targetLengths != null) {
      headerBuilder.addAllTargetLength(IntArrayList.wrap(targetLengths));
    }
    headerBuilder.build().writeTo(headerOutput);
    headerWritten=true;
  }
}","private void writeHeader() throws IOException {
  if (!headerWritten) {
    final Alignments.AlignmentHeader.Builder headerBuilder=Alignments.AlignmentHeader.newBuilder();
    headerBuilder.setLargestSplitQueryIndex(maxQueryIndex);
    headerBuilder.setSmallestSplitQueryIndex(minQueryIndex);
    headerBuilder.setNumberOfTargets(maxTargetIndex + 1);
    headerBuilder.setNumberOfQueries(getNumQueries());
    headerBuilder.setSorted(sortedState);
    headerBuilder.setIndexed(sortedState);
    headerBuilder.setQueryNameMapping(getMapping(queryIdentifiers,queryIdentifiersArray));
    headerBuilder.setTargetNameMapping(getMapping(targetIdentifiers,targetIdentifiersArray));
    headerBuilder.setNumberOfAlignedReads(numberOfAlignedReads);
    compactQueryLengths();
    if (isConstantQueryLength) {
      headerBuilder.setConstantQueryLength(constantQueryLength);
    }
 else     if (queryLengths != null) {
      headerBuilder.addAllQueryLength(IntArrayList.wrap(queryLengths));
    }
    if (targetLengths != null) {
      headerBuilder.addAllTargetLength(IntArrayList.wrap(targetLengths));
    }
    headerBuilder.build().writeTo(headerOutput);
    headerWritten=true;
  }
}"
50465,"public void setQueryLength(int queryLength){
  newEntry.setQueryLength(queryLength);
}","/** 
 * Set the query legnth for the next alignment extry.
 * @param queryLength The query length of the next alignment entry to append
 * @deprecated use{@link #appendEntry(edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry)}.
 */
@Deprecated public void setQueryLength(final int queryLength){
  newEntry.setQueryLength(queryLength);
}"
50466,"public final void setQueryIndex(final int queryIndex){
  newEntry.setQueryIndex(queryIndex);
}","/** 
 * Set the query index for the next alignment extry.
 * @param queryIndex The query index of the next alignment entry to append
 * @deprecated use{@link #appendEntry(edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry)}.
 */
@Deprecated public final void setQueryIndex(final int queryIndex){
  newEntry.setQueryIndex(queryIndex);
}"
50467,"public final void setAlignmentScore(final float score){
  newEntry.setScore(score);
}","/** 
 * Set the score for the next alignment extry.
 * @param score The score of the next alignment entry to append
 * @deprecated use{@link #appendEntry(edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry)}.
 */
@Deprecated public final void setAlignmentScore(final float score){
  newEntry.setScore(score);
}"
50468,"public void setQueryLengths(int[] queryLengths){
}","public void setQueryLengths(final int[] queryLengths){
}"
50469,"private void writeIndexEntry(Alignments.AlignmentEntry builtEntry) throws IOException {
  if (firstEntryInChunk) {
    firstTargetIndexInChunk=builtEntry.getTargetIndex();
    firstPositionInChunk=builtEntry.getPosition();
    firstEntryInChunk=false;
  }
  int currentChunkOffset=entriesChunkWriter.writeAsNeeded(collectionBuilder,builtEntry.getMultiplicity());
  if (sortedState && currentChunkOffset != previousChunkOffset) {
    pushIndex(previousChunkOffset,firstTargetIndexInChunk,firstPositionInChunk);
    previousChunkOffset=currentChunkOffset;
    firstEntryInChunk=true;
  }
 else {
    firstEntryInChunk=false;
  }
}","private void writeIndexEntry(final Alignments.AlignmentEntry builtEntry) throws IOException {
  if (firstEntryInChunk) {
    firstTargetIndexInChunk=builtEntry.getTargetIndex();
    firstPositionInChunk=builtEntry.getPosition();
    firstEntryInChunk=false;
  }
  final int currentChunkOffset=entriesChunkWriter.writeAsNeeded(collectionBuilder,builtEntry.getMultiplicity());
  if (sortedState && currentChunkOffset != previousChunkOffset) {
    pushIndex(previousChunkOffset,firstTargetIndexInChunk,firstPositionInChunk);
    previousChunkOffset=currentChunkOffset;
    firstEntryInChunk=true;
  }
 else {
    firstEntryInChunk=false;
  }
}"
50470,"/** 
 * {@inheritDoc}
 */
public void close() throws IOException {
  if (sortedState)   writeIndex();
  writeHeader();
  writeStats();
  IOUtils.closeQuietly(headerOutput);
  entriesChunkWriter.close(collectionBuilder);
  IOUtils.closeQuietly(alignmentEntries);
  IOUtils.closeQuietly(statsWriter);
}","/** 
 * {@inheritDoc}
 */
public void close() throws IOException {
  if (sortedState) {
    writeIndex();
  }
  writeHeader();
  writeStats();
  IOUtils.closeQuietly(headerOutput);
  entriesChunkWriter.close(collectionBuilder);
  IOUtils.closeQuietly(alignmentEntries);
  IOUtils.closeQuietly(statsWriter);
}"
50471,"public void setLargestSplitQueryIndex(int largestQueryIndex){
  maxQueryIndex=largestQueryIndex;
}","public void setLargestSplitQueryIndex(final int largestQueryIndex){
  maxQueryIndex=largestQueryIndex;
}"
50472,"public void setSorted(boolean sortedState){
  this.sortedState=sortedState;
  if (sortedState) {
    if (targetPositionOffsets == null) {
      throw new UnsupportedOperationException(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
}","public void setSorted(final boolean sortedState){
  this.sortedState=sortedState;
  if (sortedState) {
    if (targetPositionOffsets == null) {
      throw new UnsupportedOperationException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    }
  }
}"
50473,"public final void setTargetPosition(final int position){
  newEntry.setPosition(position);
}","/** 
 * Set the target position for the next alignment extry.
 * @param position The target position of the next alignment entry to append
 * @deprecated use{@link #appendEntry(edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry)}.
 */
@Deprecated public final void setTargetPosition(final int position){
  newEntry.setPosition(position);
}"
50474,"private void pushIndex(int previousChunkOffset,int firstTargetIndexInChunk,int firstPositionInChunk){
  final int newOffset=Math.max(previousChunkOffset - 8,0);
  final int size=indexOffsets.size();
  if (size == 0 || newOffset != indexOffsets.get(size - 1)) {
    indexOffsets.add(newOffset);
    final long codedPosition=recodePosition(firstTargetIndexInChunk,firstPositionInChunk);
    indexAbsolutePositions.add(codedPosition);
  }
}","private void pushIndex(final int previousChunkOffset,final int firstTargetIndexInChunk,final int firstPositionInChunk){
  final int newOffset=Math.max(previousChunkOffset - 8,0);
  final int size=indexOffsets.size();
  if (size == 0 || newOffset != indexOffsets.get(size - 1)) {
    indexOffsets.add(newOffset);
    final long codedPosition=recodePosition(firstTargetIndexInChunk,firstPositionInChunk);
    indexAbsolutePositions.add(codedPosition);
  }
}"
50475,"/** 
 * Obtain the alignment entry that is being prepared. Set values on the entry, then call appendAlignmentEntry()
 * @return the current alignment entry.
 */
public Alignments.AlignmentEntry.Builder getAlignmentEntry(){
  return newEntry;
}","/** 
 * Obtain the alignment entry that is being prepared. Set values on the entry, then call   {@link #appendEntry()}.
 * @return the current alignment entry.
 * @deprecated use{@link #appendEntry(edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry)}.
 */
@Deprecated public Alignments.AlignmentEntry.Builder getAlignmentEntry(){
  return newEntry;
}"
50476,"public final void setAlignmentEntry(final int queryIndex,final int referenceIndex,final int position,final float score,final boolean matchesReverseStrand){
  newEntry.setQueryIndex(queryIndex);
  newEntry.setTargetIndex(referenceIndex);
  newEntry.setScore(score);
  newEntry.setPosition(position);
  newEntry.setMatchingReverseStrand(matchesReverseStrand);
  newEntry.setMultiplicity(1);
}","/** 
 * Set fields for the next alignment extry.
 * @param queryIndex The query index of the next alignment entry to append
 * @param targetIndex The target index of the next alignment entry to append
 * @param position The target position of the next alignment entry to append
 * @param score The score of the next alignment entry to append
 * @param matchesReverseStrand true if the entry matches the reverse strand
 * @deprecated use{@link #appendEntry(edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry)}.
 */
@Deprecated public final void setAlignmentEntry(final int queryIndex,final int targetIndex,final int position,final float score,final boolean matchesReverseStrand){
  newEntry.setQueryIndex(queryIndex);
  newEntry.setTargetIndex(targetIndex);
  newEntry.setScore(score);
  newEntry.setPosition(position);
  newEntry.setMatchingReverseStrand(matchesReverseStrand);
  newEntry.setMultiplicity(1);
}"
50477,"/** 
 * Replace queryLength with constantQueryLength where the length is the same for all queries. Use a smaller queryLength array if we are storing just a slice of a larger alignment. In this case, the smaller array has size (maxQueryIndex-minQueryIndex+1)
 * @param queryLengths An array of integers where each element indicates the length of a query
 */
private void compactQueryLengths(final int[] queryLengths){
  if (queryLengths == null) {
    return;
  }
  final IntSet uniqueLengths=new IntOpenHashSet();
  for (  final int length : queryLengths) {
    if (length != 0) {
      uniqueLengths.add(length);
    }
  }
  if (uniqueLengths.size() == 1) {
    constantQueryLength=uniqueLengths.iterator().nextInt();
    isConstantQueryLength=true;
    this.queryLengths=null;
  }
 else {
    if (actualNumberOfQueries != Integer.MIN_VALUE) {
      int smallerLength=maxQueryIndex - minQueryIndex + 1;
      if (smallerLength != getNumQueries()) {
        int[] smaller=new int[smallerLength];
        System.arraycopy(queryLengths,minQueryIndex,smaller,0,smallerLength);
        this.queryLengths=smaller;
      }
    }
 else {
      this.queryLengths=queryLengths;
    }
  }
}","/** 
 * Replace queryLength with constantQueryLength where the length is the same for all queries. Use a smaller queryLength array if we are storing just a slice of a larger alignment. In this case, the smaller array has size (maxQueryIndex-minQueryIndex+1)
 */
private void compactQueryLengths(){
  if (uniqueQueryLengths.size() == 1) {
    if (queryLengths != null) {
      constantQueryLength=uniqueQueryLengths.iterator().nextInt();
    }
 else {
      constantQueryLength=0;
    }
    isConstantQueryLength=true;
    this.queryLengths=null;
  }
 else {
    if (queryLengths != null) {
      if (actualNumberOfQueries != Integer.MIN_VALUE) {
        final int smallerLength=maxQueryIndex - minQueryIndex + 1;
        if (smallerLength != getNumQueries()) {
          final int[] smaller=new int[smallerLength];
          System.arraycopy(queryLengths,minQueryIndex,smaller,0,smallerLength);
          this.queryLengths=smaller;
        }
      }
    }
  }
}"
50478,"public final void setTargetIndex(final int referenceIndex){
  newEntry.setTargetIndex(referenceIndex);
}","/** 
 * Set the target index for the next alignment extry.
 * @param targetIndex The target index of the next alignment entry to append
 * @deprecated use{@link #appendEntry(edu.cornell.med.icb.goby.alignments.Alignments.AlignmentEntry)}.
 */
@Deprecated public final void setTargetIndex(final int targetIndex){
  newEntry.setTargetIndex(targetIndex);
}"
50479,"public void setSmallestSplitQueryIndex(int smallestQueryIndex){
  minQueryIndex=smallestQueryIndex;
}","public void setSmallestSplitQueryIndex(final int smallestQueryIndex){
  minQueryIndex=smallestQueryIndex;
}"
50480,"/** 
 * Print statistics about an alignment file in the Goby compact form.
 * @param file The file to display statistics about
 * @throws IOException if the file cannot be read
 */
private void describeCompactAlignment(final File file) throws IOException {
  final String basename=AlignmentReader.getBasename(file.toString());
  writer.printf(""String_Node_Str"",basename);
  final AlignmentReader reader=new AlignmentReader(basename);
  reader.readHeader();
  writer.println(""String_Node_Str"");
  writer.printf(""String_Node_Str"",reader.getNumberOfTargets());
  final int[] targetLength=reader.getTargetLength();
  writer.printf(""String_Node_Str"",ArrayUtils.getLength(reader.getTargetLength()));
  final SummaryStatistics targetLengthStats=new SummaryStatistics();
  if (targetLength != null) {
    for (    final double d : targetLength) {
      targetLengthStats.addValue(d);
    }
  }
  writer.printf(""String_Node_Str"",(int)targetLengthStats.getMin());
  writer.printf(""String_Node_Str"",(int)targetLengthStats.getMax());
  writer.printf(""String_Node_Str"",targetLengthStats.getMean());
  writer.println();
  writer.printf(""String_Node_Str"",reader.getNumberOfQueries());
  final int[] queryLength=reader.getQueryLengths();
  writer.printf(""String_Node_Str"",ArrayUtils.getLength(queryLength));
  final SummaryStatistics queryLengthStats=new SummaryStatistics();
  if (queryLength != null) {
    for (    final double d : queryLength) {
      queryLengthStats.addValue(d);
    }
  }
  writer.printf(""String_Node_Str"",(int)queryLengthStats.getMin());
  writer.printf(""String_Node_Str"",(int)queryLengthStats.getMax());
  writer.printf(""String_Node_Str"",queryLengthStats.getMean());
  writer.println(""String_Node_Str"" + reader.isConstantQueryLengths());
  writer.printf(""String_Node_Str"",reader.getQueryIdentifiers() != null && !reader.getTargetIdentifiers().isEmpty());
  writer.printf(""String_Node_Str"",reader.getTargetIdentifiers() != null && !reader.getTargetIdentifiers().isEmpty());
  writer.println();
  final IntSet alignedQueryIndices=new IntOpenHashSet();
  describeAmbigousReads(basename,reader.getNumberOfQueries(),alignedQueryIndices);
  int maxQueryIndex=-1;
  int maxTargetIndex=-1;
  int numEntries=0;
  long numLogicalAlignmentEntries=0;
  long total=0;
  double avgScore=0;
  int sumNumVariations=0;
  for (  final Alignments.AlignmentEntry entry : reader) {
    numberOfReads++;
    numEntries++;
    numLogicalAlignmentEntries+=entry.getMultiplicity();
    total+=entry.getQueryAlignedLength();
    avgScore+=entry.getScore();
    maxQueryIndex=Math.max(maxQueryIndex,entry.getQueryIndex());
    maxTargetIndex=Math.max(maxTargetIndex,entry.getTargetIndex());
    cumulativeReadLength+=entry.getQueryAlignedLength();
    minReadLength=Math.min(minReadLength,entry.getQueryAlignedLength());
    maxReadLength=Math.max(maxReadLength,entry.getQueryAlignedLength());
    sumNumVariations+=entry.getSequenceVariationsCount();
    alignedQueryIndices.add(entry.getQueryIndex());
  }
  avgScore/=(double)numLogicalAlignmentEntries;
  final int numQuerySequences=maxQueryIndex + 1;
  writer.printf(""String_Node_Str"",numQuerySequences);
  final int numTargetSequences=maxTargetIndex + 1;
  final double avgNumVariationsPerQuery=((double)sumNumVariations) / (double)numQuerySequences;
  writer.printf(""String_Node_Str"",numTargetSequences);
  writer.printf(""String_Node_Str"",numLogicalAlignmentEntries);
  writer.printf(""String_Node_Str"",alignedQueryIndices.size());
  writer.printf(""String_Node_Str"",(double)alignedQueryIndices.size() / (double)(long)numQuerySequences * 100.0d);
  writer.printf(""String_Node_Str"",numEntries > 0 ? total / numEntries : -1);
  writer.printf(""String_Node_Str"",avgScore);
  writer.printf(""String_Node_Str"",avgNumVariationsPerQuery);
  final long size=file.length();
  writer.printf(""String_Node_Str"",divide(size,numLogicalAlignmentEntries));
}","/** 
 * Print statistics about an alignment file in the Goby compact form.
 * @param file The file to display statistics about
 * @throws IOException if the file cannot be read
 */
private void describeCompactAlignment(final File file) throws IOException {
  final String basename=AlignmentReader.getBasename(file.toString());
  writer.printf(""String_Node_Str"",basename);
  final AlignmentReader reader=new AlignmentReader(basename);
  reader.readHeader();
  writer.println(""String_Node_Str"");
  writer.printf(""String_Node_Str"",reader.getNumberOfTargets());
  final int[] targetLength=reader.getTargetLength();
  writer.printf(""String_Node_Str"",ArrayUtils.getLength(reader.getTargetLength()));
  final SummaryStatistics targetLengthStats=new SummaryStatistics();
  if (targetLength != null) {
    for (    final double d : targetLength) {
      targetLengthStats.addValue(d);
    }
  }
  writer.printf(""String_Node_Str"",(int)targetLengthStats.getMin());
  writer.printf(""String_Node_Str"",(int)targetLengthStats.getMax());
  writer.printf(""String_Node_Str"",targetLengthStats.getMean());
  writer.println();
  writer.printf(""String_Node_Str"",reader.getNumberOfQueries());
  final int[] queryLength=reader.getQueryLengths();
  writer.printf(""String_Node_Str"",ArrayUtils.getLength(queryLength));
  final SummaryStatistics queryLengthStats=new SummaryStatistics();
  if (queryLength != null) {
    for (    final double d : queryLength) {
      queryLengthStats.addValue(d);
    }
  }
  writer.printf(""String_Node_Str"",(int)queryLengthStats.getMin());
  writer.printf(""String_Node_Str"",(int)queryLengthStats.getMax());
  writer.printf(""String_Node_Str"",queryLengthStats.getMean());
  writer.println(""String_Node_Str"" + reader.isConstantQueryLengths());
  writer.printf(""String_Node_Str"",reader.getQueryIdentifiers() != null && !reader.getQueryIdentifiers().isEmpty());
  writer.printf(""String_Node_Str"",reader.getTargetIdentifiers() != null && !reader.getTargetIdentifiers().isEmpty());
  writer.println();
  final IntSet alignedQueryIndices=new IntOpenHashSet();
  describeAmbigousReads(basename,reader.getNumberOfQueries(),alignedQueryIndices);
  int maxQueryIndex=-1;
  int maxTargetIndex=-1;
  int numEntries=0;
  long numLogicalAlignmentEntries=0;
  long total=0;
  double avgScore=0;
  int sumNumVariations=0;
  for (  final Alignments.AlignmentEntry entry : reader) {
    numberOfReads++;
    numEntries++;
    numLogicalAlignmentEntries+=entry.getMultiplicity();
    total+=entry.getQueryAlignedLength();
    avgScore+=entry.getScore();
    maxQueryIndex=Math.max(maxQueryIndex,entry.getQueryIndex());
    maxTargetIndex=Math.max(maxTargetIndex,entry.getTargetIndex());
    cumulativeReadLength+=entry.getQueryAlignedLength();
    minReadLength=Math.min(minReadLength,entry.getQueryAlignedLength());
    maxReadLength=Math.max(maxReadLength,entry.getQueryAlignedLength());
    sumNumVariations+=entry.getSequenceVariationsCount();
    alignedQueryIndices.add(entry.getQueryIndex());
  }
  avgScore/=(double)numLogicalAlignmentEntries;
  final int numQuerySequences=maxQueryIndex + 1;
  writer.printf(""String_Node_Str"",numQuerySequences);
  final int numTargetSequences=maxTargetIndex + 1;
  final double avgNumVariationsPerQuery=((double)sumNumVariations) / (double)numQuerySequences;
  writer.printf(""String_Node_Str"",numTargetSequences);
  writer.printf(""String_Node_Str"",numLogicalAlignmentEntries);
  writer.printf(""String_Node_Str"",alignedQueryIndices.size());
  writer.printf(""String_Node_Str"",(double)alignedQueryIndices.size() / (double)(long)numQuerySequences * 100.0d);
  writer.printf(""String_Node_Str"",numEntries > 0 ? total / numEntries : -1);
  writer.printf(""String_Node_Str"",avgScore);
  writer.printf(""String_Node_Str"",avgNumVariationsPerQuery);
  final long size=file.length();
  writer.printf(""String_Node_Str"",divide(size,numLogicalAlignmentEntries));
}"
50481,"/** 
 * Configure.
 * @param args command line arguments
 * @return this object for chaining
 * @throws java.io.IOException error parsing
 * @throws com.martiansoftware.jsap.JSAPException error parsing
 */
@Override public AbstractCommandLineMode configure(final String[] args) throws IOException, JSAPException {
  final JSAPResult jsapResult=parseJsapArguments(args);
  inputFiles=jsapResult.getStringArray(""String_Node_Str"");
  final ObjectSet<String> basenameSet=new ObjectOpenHashSet<String>();
  for (  final String inputFile : inputFiles) {
    basenameSet.add(AlignmentReader.getBasename(inputFile));
  }
  basenames=basenameSet.toArray(new String[basenameSet.size()]);
  statsFilename=jsapResult.getString(""String_Node_Str"");
  outputFile=jsapResult.getString(""String_Node_Str"");
  final String groupsDefinition=jsapResult.getString(""String_Node_Str"");
  deAnalyzer.parseGroupsDefinition(groupsDefinition,deCalculator,inputFiles);
  final String compare=jsapResult.getString(""String_Node_Str"");
  if (compare == null) {
    doComparison=false;
  }
 else {
    doComparison=true;
  }
  if (doComparison) {
    deAnalyzer.parseCompare(compare);
  }
  final String needCountsFiles=jsapResult.getString(""String_Node_Str"");
  normalizationMethods=deAnalyzer.parseNormalization(jsapResult);
  return this;
}","/** 
 * Configure.
 * @param args command line arguments
 * @return this object for chaining
 * @throws java.io.IOException error parsing
 * @throws com.martiansoftware.jsap.JSAPException error parsing
 */
@Override public AbstractCommandLineMode configure(final String[] args) throws IOException, JSAPException {
  final JSAPResult jsapResult=parseJsapArguments(args);
  inputFiles=jsapResult.getStringArray(""String_Node_Str"");
  final ObjectSet<String> basenameSet=new ObjectOpenHashSet<String>();
  for (  final String inputFile : inputFiles) {
    basenameSet.add(AlignmentReader.getBasename(inputFile));
  }
  basenames=basenameSet.toArray(new String[basenameSet.size()]);
  statsFilename=jsapResult.getString(""String_Node_Str"");
  outputFile=jsapResult.getString(""String_Node_Str"");
  final String groupsDefinition=jsapResult.getString(""String_Node_Str"");
  deAnalyzer.parseGroupsDefinition(groupsDefinition,deCalculator,inputFiles);
  final String compare=jsapResult.getString(""String_Node_Str"");
  if (compare == null) {
    doComparison=false;
  }
 else {
    doComparison=true;
  }
  if (doComparison) {
    deAnalyzer.parseCompare(compare);
  }
  normalizationMethods=deAnalyzer.parseNormalization(jsapResult);
  return this;
}"
50482,"/** 
 * Run the map2text mode.
 * @throws java.io.IOException error reading / writing
 */
@Override public void execute() throws IOException {
  for (  final String basename : basenames) {
    if (outputFile == null) {
      outputFile=basename;
    }
    outputFile+=""String_Node_Str"";
    processTranscriptAlignment(basename);
    outputFile=null;
  }
  if (doComparison) {
    final PrintWriter statsOutput=new PrintWriter(statsFilename);
    DifferentialExpressionResults results=null;
    results=deAnalyzer.evaluateDifferentialExpressionStatistics(deCalculator,doComparison,normalizationMethods);
    results.write(statsOutput,'\t',deCalculator);
    IOUtils.closeQuietly(statsOutput);
  }
}","/** 
 * Run the map2text mode.
 * @throws java.io.IOException error reading / writing
 */
@Override public void execute() throws IOException {
  for (  final String basename : basenames) {
    if (outputFile == null) {
      outputFile=basename;
    }
    outputFile+=""String_Node_Str"";
    processTranscriptAlignment(basename);
    outputFile=null;
  }
  if (doComparison) {
    PrintWriter statsOutput=null;
    try {
      statsOutput=new PrintWriter(statsFilename);
      final DifferentialExpressionResults results=deAnalyzer.evaluateDifferentialExpressionStatistics(deCalculator,doComparison,normalizationMethods);
      results.write(statsOutput,'\t',deCalculator);
    }
  finally {
      IOUtils.closeQuietly(statsOutput);
    }
  }
}"
50483,"public void write(final PrintWriter printWriter,final char delimiter,final InformativeColumns informativeColumns,final DifferentialExpressionCalculator deCalculator){
  printWriter.append(elementId);
  printWriter.append(delimiter);
  String elementType=deCalculator.getElementType(elementId).toString();
  printWriter.append(elementType);
  for (int i=0; i < statistics.size(); i++) {
    if (informativeColumns == null || informativeColumns.isColumnInformative(i)) {
      printWriter.append(delimiter);
      final double value=statistics.get(i);
      printWriter.append(String.format(""String_Node_Str"",value));
    }
  }
}","public void write(final Writer writer,final char delimiter,final InformativeColumns informativeColumns,final DifferentialExpressionCalculator deCalculator) throws IOException {
  writer.append(elementId);
  writer.append(delimiter);
  final String elementType=deCalculator.getElementType(elementId).toString();
  writer.append(elementType);
  for (int i=0; i < statistics.size(); i++) {
    if (informativeColumns == null || informativeColumns.isColumnInformative(i)) {
      writer.append(delimiter);
      final double value=statistics.get(i);
      writer.append(String.format(""String_Node_Str"",value));
    }
  }
}"
50484,"/** 
 * Write results with delimiter.
 * @param printWriter
 * @param delimiter
 * @param deCalculator
 */
public void write(final PrintWriter printWriter,final char delimiter,final DifferentialExpressionCalculator deCalculator){
  InformativeColumns informativeColumns=null;
  if (omitNonInformativeColumns) {
    informativeColumns=new InformativeColumns(sortedStatisticIds.size(),new InformativeNonZeroNonNaN());
    for (    final DifferentialExpressionInfo info : this.subList(0,size())) {
      if (info.checkInformativeColumns(informativeColumns)) {
        break;
      }
    }
  }
  printWriter.append(""String_Node_Str"");
  printWriter.append(delimiter);
  printWriter.append(""String_Node_Str"");
  for (int i=0; i < sortedStatisticIds.size(); i++) {
    if (informativeColumns == null || informativeColumns.isColumnInformative(i)) {
      printWriter.append(delimiter);
      printWriter.append(sortedStatisticIds.get(i));
    }
  }
  printWriter.append(""String_Node_Str"");
  for (  final DifferentialExpressionInfo info : this.subList(0,size())) {
    if (info.informative(getAverageCountPerGroupIndexes())) {
      info.write(printWriter,delimiter,informativeColumns,deCalculator);
      printWriter.append(""String_Node_Str"");
    }
  }
  printWriter.flush();
}","/** 
 * Write results with delimiter.
 * @param writer
 * @param delimiter
 * @param deCalculator
 */
public void write(final Writer writer,final char delimiter,final DifferentialExpressionCalculator deCalculator) throws IOException {
  InformativeColumns informativeColumns=null;
  if (omitNonInformativeColumns) {
    informativeColumns=new InformativeColumns(sortedStatisticIds.size(),new InformativeNonZeroNonNaN());
    for (    final DifferentialExpressionInfo info : this.subList(0,size())) {
      if (info.checkInformativeColumns(informativeColumns)) {
        break;
      }
    }
  }
  writer.append(""String_Node_Str"");
  writer.append(delimiter);
  writer.append(""String_Node_Str"");
  for (int i=0; i < sortedStatisticIds.size(); i++) {
    if (informativeColumns == null || informativeColumns.isColumnInformative(i)) {
      writer.append(delimiter);
      writer.append(sortedStatisticIds.get(i));
    }
  }
  writer.append(""String_Node_Str"");
  for (  final DifferentialExpressionInfo info : this.subList(0,size())) {
    if (info.informative(getAverageCountPerGroupIndexes())) {
      info.write(writer,delimiter,informativeColumns,deCalculator);
      writer.append(""String_Node_Str"");
    }
  }
  writer.flush();
}"
50485,"@Test public void testFisherExact() throws MathException {
  final DifferentialExpressionCalculator deCalc=new DifferentialExpressionCalculator();
  final int numReplicates=2;
  deCalc.defineElement(""String_Node_Str"");
  deCalc.defineElement(""String_Node_Str"");
  deCalc.defineGroup(""String_Node_Str"");
  deCalc.defineGroup(""String_Node_Str"");
  deCalc.reserve(2,numReplicates * 2);
  for (int i=1; i <= numReplicates; i++) {
    deCalc.associateSampleToGroup(""String_Node_Str"" + i,""String_Node_Str"");
    deCalc.associateSampleToGroup(""String_Node_Str"" + i,""String_Node_Str"");
  }
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",7);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",3);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",15);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",5);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",15);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",15);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",20);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",20);
  final DifferentialExpressionInfo info=new DifferentialExpressionInfo(""String_Node_Str"");
  final DifferentialExpressionResults results=new DifferentialExpressionResults();
  final FisherExactRCalculator fisher=new FisherExactRCalculator(results);
  if (fisher.installed()) {
    final NormalizationMethod normalizationMethod=new AlignedCountNormalization();
    fisher.evaluate(deCalc,normalizationMethod,results,info,""String_Node_Str"",""String_Node_Str"");
    assertEquals(""String_Node_Str"",0.5044757698516504,results.getStatistic(info,fisher.statisticIds.get(0)),0.001);
    final int totalCountInA=1700;
    final int totalCountInB=170;
    final int sumCountInA=90;
    final int sumCountInB=45;
    final int sumCountNotInA=totalCountInA - sumCountInA;
    final int sumCountNotInB=totalCountInB - sumCountInB;
    final FisherExact.Result result=FisherExact.fexact(sumCountInA,sumCountNotInA,sumCountInB,sumCountNotInB);
    final double pValue=result.getPValue();
    final double proportionTotalA=divide(totalCountInA,(totalCountInA + totalCountInB));
    final double proportionTotalB=divide(totalCountInB,(totalCountInA + totalCountInB));
    final ChiSquareTest chisquare=new ChiSquareTestImpl();
    final double nGroups=2;
    final double[] expected={divide(sumCountInA + sumCountInB,nGroups) * proportionTotalA * nGroups,divide(sumCountInA + sumCountInB,nGroups) * proportionTotalB * nGroups};
    final long[] observed={sumCountInA,sumCountInB};
    double chiPValue=0;
    chiPValue=Math.abs(chisquare.chiSquareTest(expected,observed));
    assertTrue(""String_Node_Str"" + chiPValue,chiPValue < 0.001);
    assertTrue(""String_Node_Str"" + pValue,pValue < 0.001);
  }
}","@Test public void testFisherExact() throws MathException {
  final DifferentialExpressionCalculator deCalc=new DifferentialExpressionCalculator();
  final int numReplicates=2;
  deCalc.defineElement(""String_Node_Str"");
  deCalc.defineElement(""String_Node_Str"");
  deCalc.defineGroup(""String_Node_Str"");
  deCalc.defineGroup(""String_Node_Str"");
  deCalc.reserve(2,numReplicates * 2);
  for (int i=1; i <= numReplicates; i++) {
    deCalc.associateSampleToGroup(""String_Node_Str"" + i,""String_Node_Str"");
    deCalc.associateSampleToGroup(""String_Node_Str"" + i,""String_Node_Str"");
  }
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",7);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",3);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",15);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",5);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",15);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",15);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",20);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",20);
  final DifferentialExpressionInfo info=new DifferentialExpressionInfo(""String_Node_Str"");
  final DifferentialExpressionResults results=new DifferentialExpressionResults();
  final FisherExactRCalculator fisher=new FisherExactRCalculator(results);
  if (fisher.installed()) {
    final NormalizationMethod normalizationMethod=new AlignedCountNormalization();
    fisher.evaluate(deCalc,normalizationMethod,results,info,""String_Node_Str"",""String_Node_Str"");
    assertEquals(""String_Node_Str"",0.5044757698516504,results.getStatistic(info,fisher.statisticIds.get(0)),0.001);
    final int totalCountInA=1700;
    final int totalCountInB=170;
    final int sumCountInA=90;
    final int sumCountInB=45;
    final int sumCountNotInA=totalCountInA - sumCountInA;
    final int sumCountNotInB=totalCountInB - sumCountInB;
    final FisherExact.Result result=FisherExact.fexact(sumCountInA,sumCountNotInA,sumCountInB,sumCountNotInB);
    final double pValue=result.getPValue();
    final double proportionTotalA=divide(totalCountInA,(totalCountInA + totalCountInB));
    final double proportionTotalB=divide(totalCountInB,(totalCountInA + totalCountInB));
    final ChiSquareTest chisquare=new ChiSquareTestImpl();
    final double nGroups=2;
    final double[] expected={divide(sumCountInA + sumCountInB,nGroups) * proportionTotalA * nGroups,divide(sumCountInA + sumCountInB,nGroups) * proportionTotalB * nGroups};
    final long[] observed={sumCountInA,sumCountInB};
    final double chiPValue=Math.abs(chisquare.chiSquareTest(expected,observed));
    assertTrue(""String_Node_Str"" + chiPValue,chiPValue < 0.001);
    assertTrue(""String_Node_Str"" + pValue,pValue < 0.001);
  }
}"
50486,"@Test public void testChiSquare() throws MathException {
  final DifferentialExpressionCalculator deCalc=new DifferentialExpressionCalculator();
  final int numReplicates=2;
  deCalc.defineElement(""String_Node_Str"");
  deCalc.defineElement(""String_Node_Str"");
  deCalc.defineGroup(""String_Node_Str"");
  deCalc.defineGroup(""String_Node_Str"");
  deCalc.reserve(2,numReplicates * 2);
  for (int i=1; i <= numReplicates; i++) {
    deCalc.associateSampleToGroup(""String_Node_Str"" + i,""String_Node_Str"");
    deCalc.associateSampleToGroup(""String_Node_Str"" + i,""String_Node_Str"");
  }
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",7);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",3);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",15);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",5);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",15);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",15);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",20);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",20);
  final DifferentialExpressionInfo info=new DifferentialExpressionInfo(""String_Node_Str"");
  final DifferentialExpressionResults results=new DifferentialExpressionResults();
  final ChiSquareTestCalculator calc=new ChiSquareTestCalculator(results);
  final NormalizationMethod normalizationMethod=new AlignedCountNormalization();
  calc.evaluate(deCalc,normalizationMethod,results,info,""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",0.456056540250256,results.getStatistic(info,calc.statisticIds.get(0)),0.001);
  final ChiSquareTest chisquare=new ChiSquareTestImpl();
  final double[] expected={30,12};
  final long[] observed={0,100};
  double chiPValue=0;
  chiPValue=chisquare.chiSquareTest(expected,observed);
  assertTrue(""String_Node_Str"" + chiPValue,chiPValue < 0.001);
}","@Test public void testChiSquare() throws MathException {
  final DifferentialExpressionCalculator deCalc=new DifferentialExpressionCalculator();
  final int numReplicates=2;
  deCalc.defineElement(""String_Node_Str"");
  deCalc.defineElement(""String_Node_Str"");
  deCalc.defineGroup(""String_Node_Str"");
  deCalc.defineGroup(""String_Node_Str"");
  deCalc.reserve(2,numReplicates * 2);
  for (int i=1; i <= numReplicates; i++) {
    deCalc.associateSampleToGroup(""String_Node_Str"" + i,""String_Node_Str"");
    deCalc.associateSampleToGroup(""String_Node_Str"" + i,""String_Node_Str"");
  }
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",7);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",3);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",15);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",5);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",15);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",15);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",20);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",20);
  final DifferentialExpressionInfo info=new DifferentialExpressionInfo(""String_Node_Str"");
  final DifferentialExpressionResults results=new DifferentialExpressionResults();
  final ChiSquareTestCalculator calc=new ChiSquareTestCalculator(results);
  final NormalizationMethod normalizationMethod=new AlignedCountNormalization();
  calc.evaluate(deCalc,normalizationMethod,results,info,""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",0.456056540250256,results.getStatistic(info,calc.statisticIds.get(0)),0.001);
  final ChiSquareTest chisquare=new ChiSquareTestImpl();
  final double[] expected={30,12};
  final long[] observed={0,100};
  final double chiPValue=chisquare.chiSquareTest(expected,observed);
  assertTrue(""String_Node_Str"" + chiPValue,chiPValue < 0.001);
}"
50487,"@Test public void testFisher() throws MathException {
  final DifferentialExpressionCalculator deCalc=new DifferentialExpressionCalculator();
  final int numReplicates=2;
  deCalc.defineElement(""String_Node_Str"");
  deCalc.defineElement(""String_Node_Str"");
  deCalc.defineGroup(""String_Node_Str"");
  deCalc.defineGroup(""String_Node_Str"");
  deCalc.reserve(2,numReplicates * 2);
  for (int i=1; i <= numReplicates; i++) {
    deCalc.associateSampleToGroup(""String_Node_Str"" + i,""String_Node_Str"");
    deCalc.associateSampleToGroup(""String_Node_Str"" + i,""String_Node_Str"");
  }
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",7);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",3);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",15);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",5);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",15);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",15);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",20);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",20);
  final DifferentialExpressionInfo info=new DifferentialExpressionInfo(""String_Node_Str"");
  final DifferentialExpressionResults results=new DifferentialExpressionResults();
  final FisherExactTestCalculator fisher=new FisherExactTestCalculator(results);
  final NormalizationMethod normalizationMethod=new AlignedCountNormalization();
  fisher.evaluate(deCalc,normalizationMethod,results,info,""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",0.5044757698516504,results.getStatistic(info,fisher.statisticIds.get(0)),0.001);
  final Fisher fisherTest=new Fisher();
  final int totalCountInA=1700;
  final int totalCountInB=170;
  final int sumCountInA=90;
  final int sumCountInB=45;
  fisherTest.fisher(totalCountInA,sumCountInA,totalCountInA + totalCountInB,sumCountInA + sumCountInB);
  final double pValue=fisherTest.getTwotail();
  final double proportionTotalA=divide(totalCountInA,(totalCountInA + totalCountInB));
  final double proportionTotalB=divide(totalCountInB,(totalCountInA + totalCountInB));
  final ChiSquareTest chisquare=new ChiSquareTestImpl();
  final double nGroups=2;
  final double[] expected={divide(sumCountInA + sumCountInB,nGroups) * proportionTotalA * nGroups,divide(sumCountInA + sumCountInB,nGroups) * proportionTotalB * nGroups};
  final long[] observed={sumCountInA,sumCountInB};
  double chiPValue=0;
  chiPValue=Math.abs(chisquare.chiSquareTest(expected,observed));
  assertTrue(""String_Node_Str"" + chiPValue,chiPValue < 0.001);
}","@Test public void testFisher() throws MathException {
  final DifferentialExpressionCalculator deCalc=new DifferentialExpressionCalculator();
  final int numReplicates=2;
  deCalc.defineElement(""String_Node_Str"");
  deCalc.defineElement(""String_Node_Str"");
  deCalc.defineGroup(""String_Node_Str"");
  deCalc.defineGroup(""String_Node_Str"");
  deCalc.reserve(2,numReplicates * 2);
  for (int i=1; i <= numReplicates; i++) {
    deCalc.associateSampleToGroup(""String_Node_Str"" + i,""String_Node_Str"");
    deCalc.associateSampleToGroup(""String_Node_Str"" + i,""String_Node_Str"");
  }
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",7);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",3);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",15);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",5);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",15);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",15);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",20);
  deCalc.observe(""String_Node_Str"",""String_Node_Str"",20);
  final DifferentialExpressionInfo info=new DifferentialExpressionInfo(""String_Node_Str"");
  final DifferentialExpressionResults results=new DifferentialExpressionResults();
  final FisherExactTestCalculator fisher=new FisherExactTestCalculator(results);
  final NormalizationMethod normalizationMethod=new AlignedCountNormalization();
  fisher.evaluate(deCalc,normalizationMethod,results,info,""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",0.5044757698516504,results.getStatistic(info,fisher.statisticIds.get(0)),0.001);
  final Fisher fisherTest=new Fisher();
  final int totalCountInA=1700;
  final int totalCountInB=170;
  final int sumCountInA=90;
  final int sumCountInB=45;
  fisherTest.fisher(totalCountInA,sumCountInA,totalCountInA + totalCountInB,sumCountInA + sumCountInB);
  final double pValue=fisherTest.getTwotail();
  final double proportionTotalA=divide(totalCountInA,(totalCountInA + totalCountInB));
  final double proportionTotalB=divide(totalCountInB,(totalCountInA + totalCountInB));
  final ChiSquareTest chisquare=new ChiSquareTestImpl();
  final double nGroups=2;
  final double[] expected={divide(sumCountInA + sumCountInB,nGroups) * proportionTotalA * nGroups,divide(sumCountInA + sumCountInB,nGroups) * proportionTotalB * nGroups};
  final long[] observed={sumCountInA,sumCountInB};
  final double chiPValue=Math.abs(chisquare.chiSquareTest(expected,observed));
  assertTrue(""String_Node_Str"" + chiPValue,chiPValue < 0.001);
}"
50488,"@Test public void testAverage(){
  final Random randomEngine=new Random();
  final DifferentialExpressionCalculator deCalc=new DifferentialExpressionCalculator(){
    @Override public double getNormalizedExpressionValue(    final String sample,    final NormalizationMethod method,    final MutableString elementId){
      if (sample.startsWith(""String_Node_Str"")) {
        return 2 * Math.abs(randomEngine.nextDouble());
      }
 else {
        return Math.abs(randomEngine.nextDouble());
      }
    }
  }
;
  deCalc.defineElement(""String_Node_Str"");
  deCalc.defineElement(""String_Node_Str"");
  deCalc.defineGroup(""String_Node_Str"");
  deCalc.defineGroup(""String_Node_Str"");
  final int numReplicates=20000;
  deCalc.reserve(2,numReplicates * 2);
  for (int i=0; i < numReplicates; i++) {
    deCalc.associateSampleToGroup(""String_Node_Str"" + i,""String_Node_Str"");
    deCalc.associateSampleToGroup(""String_Node_Str"" + i,""String_Node_Str"");
  }
  final DifferentialExpressionInfo info=new DifferentialExpressionInfo(""String_Node_Str"");
  final DifferentialExpressionResults results=new DifferentialExpressionResults();
  final AverageCalculator averageCalculator=new AverageCalculator(results);
  results.add(info);
  final NormalizationMethod normalizationMethod=new AlignedCountNormalization();
  averageCalculator.evaluate(deCalc,normalizationMethod,results,info,""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",1d,results.getStatistic(info,averageCalculator.getStatisticId(""String_Node_Str"",""String_Node_Str"",normalizationMethod)),.1);
  assertEquals(""String_Node_Str"",0.5d,results.getStatistic(info,averageCalculator.getStatisticId(""String_Node_Str"",""String_Node_Str"",normalizationMethod)),.1);
  System.out.println(results);
  try {
    results.write(new PrintWriter(""String_Node_Str""),'\t',deCalc.getElementLabelToElementTypeMap());
  }
 catch (  FileNotFoundException e) {
    fail(e.getMessage());
  }
}","@Test public void testAverage() throws IOException {
  final Random randomEngine=new Random();
  final DifferentialExpressionCalculator deCalc=new DifferentialExpressionCalculator(){
    @Override public double getNormalizedExpressionValue(    final String sample,    final NormalizationMethod method,    final MutableString elementId){
      if (sample.startsWith(""String_Node_Str"")) {
        return 2 * Math.abs(randomEngine.nextDouble());
      }
 else {
        return Math.abs(randomEngine.nextDouble());
      }
    }
  }
;
  deCalc.defineElement(""String_Node_Str"");
  deCalc.defineElement(""String_Node_Str"");
  deCalc.defineGroup(""String_Node_Str"");
  deCalc.defineGroup(""String_Node_Str"");
  final int numReplicates=20000;
  deCalc.reserve(2,numReplicates * 2);
  for (int i=0; i < numReplicates; i++) {
    deCalc.associateSampleToGroup(""String_Node_Str"" + i,""String_Node_Str"");
    deCalc.associateSampleToGroup(""String_Node_Str"" + i,""String_Node_Str"");
  }
  final DifferentialExpressionInfo info=new DifferentialExpressionInfo(""String_Node_Str"");
  final DifferentialExpressionResults results=new DifferentialExpressionResults();
  final AverageCalculator averageCalculator=new AverageCalculator(results);
  results.add(info);
  final NormalizationMethod normalizationMethod=new AlignedCountNormalization();
  averageCalculator.evaluate(deCalc,normalizationMethod,results,info,""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"",1d,results.getStatistic(info,averageCalculator.getStatisticId(""String_Node_Str"",""String_Node_Str"",normalizationMethod)),.1);
  assertEquals(""String_Node_Str"",0.5d,results.getStatistic(info,averageCalculator.getStatisticId(""String_Node_Str"",""String_Node_Str"",normalizationMethod)),.1);
  System.out.println(results);
  results.write(new PrintWriter(""String_Node_Str""),'\t',deCalc);
}"
50489,"public void merge(final List<File> inputFiles,final String outputFile) throws IOException {
  referenceIndexPermutation=new ObjectArrayList<int[]>();
  int maxNumberOfReads=0;
  if (verbose) {
    System.out.println(""String_Node_Str"");
    System.out.flush();
  }
  int mergedReferenceIndex=0;
  final IndexedIdentifier mergedTargetIdentifiers=new IndexedIdentifier();
  final IntSet numberOfReads=new IntArraySet();
  for (  final File inputFile : inputFiles) {
    final AlignmentReader reader=new AlignmentReader(inputFile.toString());
    reader.readHeader();
    message(""String_Node_Str"" + reader.getNumberOfTargets() + ""String_Node_Str"");
    mergedReferenceIndex=constructTargetIndexPermutations(mergedReferenceIndex,mergedTargetIdentifiers,reader);
    numberOfReads.add(reader.getNumberOfQueries());
    reader.close();
  }
  if (numberOfReads.size() != 1) {
    message(""String_Node_Str"" + numberOfReads);
    return;
  }
  maxNumberOfReads=numberOfReads.iterator().next();
  message(""String_Node_Str"" + maxNumberOfReads);
  final AbstractAlignmentEntryFilter entryFilter=getFilter(maxNumberOfReads);
  entryFilter.setHeader(mergedTargetIdentifiers);
  ProgressLogger progress=new ProgressLogger(LOG);
  progress.expectedUpdates=inputFiles.size();
  progress.start();
  float totalNumberOfLogicalEntries=0;
  message(""String_Node_Str"");
  int totalNumberOfEntries=0;
  for (  final File inputFile : inputFiles) {
    message(""String_Node_Str"" + inputFile.getName());
    final AlignmentReader reader=new AlignmentReader(inputFile.toString());
    while (reader.hasNext()) {
      final Alignments.AlignmentEntry entry=reader.next();
      entryFilter.inspectEntry(entry);
      ++totalNumberOfEntries;
      totalNumberOfLogicalEntries+=entry.getMultiplicity();
    }
    progress.update();
    reader.close();
  }
  progress.stop();
  entryFilter.postProcessing();
  message(String.format(""String_Node_Str"",(int)totalNumberOfLogicalEntries));
  message(""String_Node_Str"");
  prepareMergedTooManyHits(outputFile,maxNumberOfReads,inputFiles.toArray(new File[inputFiles.size()]));
  message(""String_Node_Str"");
  int wrote=0;
  int skipped=0;
  int skippedTooManyHits=0;
  int skippedNotBestScore=0;
  final AlignmentWriter writer=new AlignmentWriter(outputFile);
  progress=new ProgressLogger(LOG);
  progress.expectedUpdates=totalNumberOfEntries;
  progress.start();
  if (mergedTargetIdentifiers.size() > 0) {
    writer.setTargetIdentifiers(mergedTargetIdentifiers);
  }
  int inputFileIndex=0;
  final AlignmentTooManyHitsReader tmhReader=new AlignmentTooManyHitsReader(outputFile);
  final IntSet queriesIndicesAligned=new IntOpenHashSet();
  for (  final File inputFile : inputFiles) {
    final String basename=inputFile.toString();
    final AlignmentReader reader=new AlignmentReader(basename);
    final AlignmentTooManyHitsReader specificTmhReader=new AlignmentTooManyHitsReader(basename);
    while (reader.hasNext()) {
      final Alignments.AlignmentEntry entry=reader.next();
      progress.lightUpdate();
      if (entryFilter.shouldRetainEntry(entry)) {
        final int queryIndex=entry.getQueryIndex();
        final int matchLength=specificTmhReader.getLengthOfMatch(queryIndex);
        if (!tmhReader.isQueryAmbiguous(queryIndex,k,matchLength)) {
          final int newTargetIndex=referenceIndexPermutation.get(inputFileIndex)[entry.getTargetIndex()];
          writer.appendEntry(entry,newTargetIndex);
          wrote+=entry.getMultiplicity();
          queriesIndicesAligned.add(entry.getQueryIndex());
        }
 else {
          skipped+=entry.getMultiplicity();
          skippedTooManyHits+=entry.getMultiplicity();
        }
      }
 else {
        skipped+=entry.getMultiplicity();
        skippedNotBestScore+=entry.getMultiplicity();
      }
      if (((wrote + skipped) % 1000000) == 0) {
        printStatus((int)totalNumberOfLogicalEntries,wrote,skipped,skippedTooManyHits,skippedNotBestScore);
      }
    }
    reader.close();
    inputFileIndex++;
  }
  progress.stop();
  writer.setNumTargets(mergedReferenceIndex);
  printStatus((int)totalNumberOfLogicalEntries,wrote,skipped,skippedTooManyHits,skippedNotBestScore);
  if (verbose) {
    writer.printStats(System.out);
  }
  final float numQuerySequences=maxNumberOfReads;
  final float percentWritten=((float)wrote) * 100f / totalNumberOfLogicalEntries;
  final float skippedPercent=((float)skipped * 100f / totalNumberOfLogicalEntries);
  final float skippedTooManyHitsPercent=((float)skippedTooManyHits) * 100f / totalNumberOfLogicalEntries;
  final float skippedNotBestScorePercent=((float)skippedNotBestScore * 100f / totalNumberOfLogicalEntries);
  float percentAligned=queriesIndicesAligned.size();
  percentAligned/=numQuerySequences;
  percentAligned*=100f;
  final double percentEntriesRetained=((double)wrote) / numQuerySequences * 100d;
  writer.putStatistic(""String_Node_Str"",wrote);
  writer.putStatistic(""String_Node_Str"",percentWritten);
  writer.putStatistic(""String_Node_Str"",totalNumberOfLogicalEntries);
  writer.putStatistic(""String_Node_Str"",totalNumberOfEntries);
  writer.putStatistic(""String_Node_Str"",skippedPercent);
  writer.putStatistic(""String_Node_Str"",skippedTooManyHitsPercent);
  writer.putStatistic(""String_Node_Str"",skippedTooManyHits);
  writer.putStatistic(""String_Node_Str"",skippedNotBestScorePercent);
  writer.putStatistic(""String_Node_Str"",skippedNotBestScore);
  writer.putStatistic(""String_Node_Str"",percentEntriesRetained);
  writer.putStatistic(""String_Node_Str"",maxNumberOfReads);
  writer.putStatistic(""String_Node_Str"",mergedTargetIdentifiers.size());
  writer.putStatistic(""String_Node_Str"",queriesIndicesAligned.size());
  writer.putStatistic(""String_Node_Str"",percentAligned);
  writer.close();
  message(""String_Node_Str"" + percentAligned);
}","public void merge(final List<File> inputFiles,final String outputFile) throws IOException {
  referenceIndexPermutation=new ObjectArrayList<int[]>();
  int maxNumberOfReads=0;
  if (verbose) {
    System.out.println(""String_Node_Str"");
    System.out.flush();
  }
  int mergedReferenceIndex=0;
  final IndexedIdentifier mergedTargetIdentifiers=new IndexedIdentifier();
  final IntSet numberOfReads=new IntArraySet();
  for (  final File inputFile : inputFiles) {
    final AlignmentReader reader=new AlignmentReader(inputFile.toString());
    reader.readHeader();
    message(""String_Node_Str"" + reader.getNumberOfTargets() + ""String_Node_Str"");
    mergedReferenceIndex=constructTargetIndexPermutations(mergedReferenceIndex,mergedTargetIdentifiers,reader);
    numberOfReads.add(reader.getNumberOfQueries());
    reader.close();
  }
  if (numberOfReads.size() != 1) {
    message(""String_Node_Str"" + numberOfReads);
    return;
  }
  maxNumberOfReads=numberOfReads.iterator().next();
  message(""String_Node_Str"" + maxNumberOfReads);
  final AbstractAlignmentEntryFilter entryFilter=getFilter(maxNumberOfReads);
  entryFilter.setHeader(mergedTargetIdentifiers);
  ProgressLogger progress=new ProgressLogger(LOG);
  progress.expectedUpdates=inputFiles.size();
  progress.start();
  float totalNumberOfLogicalEntries=0;
  message(""String_Node_Str"");
  int totalNumberOfEntries=0;
  for (  final File inputFile : inputFiles) {
    message(""String_Node_Str"" + inputFile.getName());
    final AlignmentReader reader=new AlignmentReader(inputFile.toString());
    reader.readHeader();
    entryFilter.setHeader(reader.getTargetIdentifiers());
    while (reader.hasNext()) {
      final Alignments.AlignmentEntry entry=reader.next();
      entryFilter.inspectEntry(entry);
      ++totalNumberOfEntries;
      totalNumberOfLogicalEntries+=entry.getMultiplicity();
    }
    progress.update();
    reader.close();
  }
  progress.stop();
  entryFilter.postProcessing();
  message(String.format(""String_Node_Str"",(int)totalNumberOfLogicalEntries));
  message(""String_Node_Str"");
  prepareMergedTooManyHits(outputFile,maxNumberOfReads,inputFiles.toArray(new File[inputFiles.size()]));
  message(""String_Node_Str"");
  int wrote=0;
  int skipped=0;
  int skippedTooManyHits=0;
  int skippedNotBestScore=0;
  final AlignmentWriter writer=new AlignmentWriter(outputFile);
  progress=new ProgressLogger(LOG);
  progress.expectedUpdates=totalNumberOfEntries;
  progress.start();
  if (mergedTargetIdentifiers.size() > 0) {
    writer.setTargetIdentifiers(mergedTargetIdentifiers);
  }
  int inputFileIndex=0;
  final AlignmentTooManyHitsReader tmhReader=new AlignmentTooManyHitsReader(outputFile);
  final IntSet queriesIndicesAligned=new IntOpenHashSet();
  for (  final File inputFile : inputFiles) {
    final String basename=inputFile.toString();
    final AlignmentReader reader=new AlignmentReader(basename);
    reader.readHeader();
    entryFilter.setHeader(reader.getTargetIdentifiers());
    final AlignmentTooManyHitsReader specificTmhReader=new AlignmentTooManyHitsReader(basename);
    while (reader.hasNext()) {
      final Alignments.AlignmentEntry entry=reader.next();
      progress.lightUpdate();
      if (entryFilter.shouldRetainEntry(entry)) {
        final int queryIndex=entry.getQueryIndex();
        final int matchLength=specificTmhReader.getLengthOfMatch(queryIndex);
        if (!tmhReader.isQueryAmbiguous(queryIndex,k,matchLength)) {
          final int newTargetIndex=referenceIndexPermutation.get(inputFileIndex)[entry.getTargetIndex()];
          writer.appendEntry(entry,newTargetIndex);
          wrote+=entry.getMultiplicity();
          queriesIndicesAligned.add(entry.getQueryIndex());
        }
 else {
          skipped+=entry.getMultiplicity();
          skippedTooManyHits+=entry.getMultiplicity();
        }
      }
 else {
        skipped+=entry.getMultiplicity();
        skippedNotBestScore+=entry.getMultiplicity();
      }
      if (((wrote + skipped) % 1000000) == 0) {
        printStatus((int)wrote + skipped,wrote,skipped,skippedTooManyHits,skippedNotBestScore);
      }
    }
    reader.close();
    inputFileIndex++;
  }
  progress.stop();
  writer.setNumTargets(mergedReferenceIndex);
  printStatus((int)totalNumberOfLogicalEntries,wrote,skipped,skippedTooManyHits,skippedNotBestScore);
  if (verbose) {
    writer.printStats(System.out);
  }
  entryFilter.printStats();
  final float numQuerySequences=maxNumberOfReads;
  final float percentWritten=((float)wrote) * 100f / totalNumberOfLogicalEntries;
  final float skippedPercent=((float)skipped * 100f / totalNumberOfLogicalEntries);
  final float skippedTooManyHitsPercent=((float)skippedTooManyHits) * 100f / totalNumberOfLogicalEntries;
  final float skippedNotBestScorePercent=((float)skippedNotBestScore * 100f / totalNumberOfLogicalEntries);
  float percentAligned=queriesIndicesAligned.size();
  percentAligned/=numQuerySequences;
  percentAligned*=100f;
  final double percentEntriesRetained=((double)wrote) / numQuerySequences * 100d;
  writer.putStatistic(""String_Node_Str"",wrote);
  writer.putStatistic(""String_Node_Str"",percentWritten);
  writer.putStatistic(""String_Node_Str"",totalNumberOfLogicalEntries);
  writer.putStatistic(""String_Node_Str"",totalNumberOfEntries);
  writer.putStatistic(""String_Node_Str"",skippedPercent);
  writer.putStatistic(""String_Node_Str"",skippedTooManyHitsPercent);
  writer.putStatistic(""String_Node_Str"",skippedTooManyHits);
  writer.putStatistic(""String_Node_Str"",skippedNotBestScorePercent);
  writer.putStatistic(""String_Node_Str"",skippedNotBestScore);
  writer.putStatistic(""String_Node_Str"",percentEntriesRetained);
  writer.putStatistic(""String_Node_Str"",maxNumberOfReads);
  writer.putStatistic(""String_Node_Str"",mergedTargetIdentifiers.size());
  writer.putStatistic(""String_Node_Str"",queriesIndicesAligned.size());
  writer.putStatistic(""String_Node_Str"",percentAligned);
  writer.close();
  message(""String_Node_Str"" + percentAligned);
}"
50490,"/** 
 * Constructor.
 * @param geneTranscriptFile the gene-transcripts-map file to read
 * @param kVal               the k value for the filter
 * @throws java.io.FileNotFoundException if the gene-transcripts-map didn't exist
 */
public TranscriptBestScoreAlignmentFilter(final String geneTranscriptFile,final int kVal,final int maxNumberOfReads) throws FileNotFoundException {
  transcriptFilter=new TranscriptsAlignmentFilter(geneTranscriptFile,kVal);
  bestScoreFilter=new BestScoreOnlyAlignmentFilter(kVal,maxNumberOfReads);
}","/** 
 * Constructor.
 * @param geneTranscriptFile the gene-transcripts-map file to read
 * @param kVal               the k value for the filter
 * @param maxNumberOfReads   Maximum number of reads.
 * @throws java.io.FileNotFoundException if the gene-transcripts-map didn't exist
 */
public TranscriptBestScoreAlignmentFilter(final String geneTranscriptFile,final int kVal,final int maxNumberOfReads) throws FileNotFoundException {
  transcriptFilter=new TranscriptsAlignmentFilter(geneTranscriptFile,kVal);
  bestScoreFilter=new BestScoreOnlyAlignmentFilter(kVal,maxNumberOfReads);
}"
50491,"@Override public boolean shouldRetainEntry(final Alignments.AlignmentEntry entry){
  if (!bestScoreFilter.shouldRetainEntry(entry)) {
    return false;
  }
 else {
    return transcriptFilter.shouldRetainEntry(entry);
  }
}","@Override public boolean shouldRetainEntry(final Alignments.AlignmentEntry entry){
  entryCount+=entry.getMultiplicity();
  if (!bestScoreFilter.shouldRetainEntry(entry)) {
    notBestScoreCount+=entry.getMultiplicity();
    return false;
  }
 else {
    final boolean notGeneAmbiguous=transcriptFilter.shouldRetainEntry(entry);
    if (!notGeneAmbiguous) {
      geneAmbiguityCount+=entry.getMultiplicity();
    }
    return notGeneAmbiguous;
  }
}"
50492,"/** 
 * Constructor.
 * @param geneTranscriptFile the gene-transcripts-map file to read
 * @param kVal the k value for the filter
 * @throws java.io.FileNotFoundException if the gene-transcripts-map didn't exist
 */
public TranscriptsAlignmentFilter(final String geneTranscriptFile,final int kVal) throws FileNotFoundException {
  LOG.debug(""String_Node_Str"");
  this.gtr=new GeneTranscriptRelationships();
  transcriptsIndexedIdentifiers=gtr.load(geneTranscriptFile);
  readIndexToGeneIdSetMap=new Int2ObjectOpenHashMap<IntSet>();
  k=kVal;
  numInspected=0;
}","/** 
 * Constructor.
 * @param geneTranscriptFile the gene-transcripts-map file to read
 * @param kVal               the k value for the filter
 * @throws java.io.FileNotFoundException if the gene-transcripts-map didn't exist
 */
public TranscriptsAlignmentFilter(final String geneTranscriptFile,final int kVal) throws FileNotFoundException {
  LOG.debug(""String_Node_Str"");
  this.gtr=new GeneTranscriptRelationships();
  transcriptsIndexedIdentifiers=gtr.load(geneTranscriptFile);
  readIndexToGeneIdSetMap=new Int2ObjectOpenHashMap<IntSet>();
  k=kVal;
  numInspected=0;
}"
50493,"/** 
 * Inspect an entry (will be called during a first pass of reading the entries).
 * @param entry the entry
 */
@Override public void inspectEntry(final Alignments.AlignmentEntry entry){
  numInspected++;
  final int readNameIndex=entry.getQueryIndex();
  IntSet geneIdSet=readIndexToGeneIdSetMap.get(readNameIndex);
  if (geneIdSet != null && geneIdSet.size() > k) {
    return;
  }
  final int transcriptIndex=alignmentReferenceIndexToTranscriptIndex[entry.getTargetIndex()];
  final int geneIndex=gtr.transcript2Gene(transcriptIndex);
  if (geneIdSet == null) {
    geneIdSet=new IntArraySet();
    readIndexToGeneIdSetMap.put(readNameIndex,geneIdSet);
  }
  if (geneIdSet.size() <= k) {
    geneIdSet.add(geneIndex);
  }
}","/** 
 * Inspect an entry (will be called during a first pass of reading the entries).
 * @param entry the entry
 */
@Override public void inspectEntry(final Alignments.AlignmentEntry entry){
  numInspected++;
  final int queryIndex=entry.getQueryIndex();
  IntSet geneIdSet=readIndexToGeneIdSetMap.get(queryIndex);
  if (geneIdSet != null && geneIdSet.size() > k) {
    return;
  }
  final int transcriptIndex=alignmentReferenceIndexToTranscriptIndex[entry.getTargetIndex()];
  final int geneIndex=gtr.transcript2Gene(transcriptIndex);
  if (geneIdSet == null) {
    geneIdSet=new IntArraySet();
    readIndexToGeneIdSetMap.put(queryIndex,geneIdSet);
  }
  if (geneIdSet.size() <= k) {
    geneIdSet.add(geneIndex);
    boolean verbose=false;
    if (verbose && geneIdSet.size() >= 5) {
      System.out.print(""String_Node_Str"");
      for (      int geneIndex2 : geneIdSet) {
        if (geneIndex2 == geneIndex)         System.out.printf(""String_Node_Str"",entry.getPosition(),entry.getScore());
        System.out.printf(""String_Node_Str"",gtr.getGeneId(geneIndex2));
      }
      System.out.println(""String_Node_Str"");
    }
  }
}"
50494,"private static int processInsertionsOnly(String cigar,String mdAttribute,MutableString readSequence,MutableString transformedSequence,int[] positionAdjustment){
}","private static int processInsertionsOnly(String cigar,String mdAttribute,MutableString readSequence,MutableString transformedSequence,IntList positionAdjustment){
}"
50495,"/** 
 * Interpret the CIGAR string and MD SAM attribute and reconstruct the reference sequence given the read sequence. The reference passed as a argument is cleared before appending bases.
 * @param CIGAR             The CIGAR string.
 * @param mdAttribute       The SAM MD attribute
 * @param readSequence      The sequence of the read.
 * @param referenceSequence The sequence of the reference that will be reconstructed.
 * @return alignedReadStartPosition The position on the read that starts to align.
 */
public static int produceReferenceSequence(String CIGAR,String mdAttribute,MutableString readSequence,MutableString readPostInsertions,MutableString referenceSequence){
  Pattern matchPattern=attributeMD_pattern;
  referenceSequence.setLength(0);
  readPostInsertions.setLength(0);
  int end=0;
  int positionInReadSequence=0;
  int[] positionAdjustment=new int[readSequence.length()];
  int readStartAlignedPosition=processInsertionsOnly(CIGAR,mdAttribute,readSequence,readPostInsertions,positionAdjustment);
  Matcher matchMatcher=matchPattern.matcher(mdAttribute);
  int currentAdjustment=0;
  while (matchMatcher.find(end)) {
    String matchChars=matchMatcher.group(1);
    String variationChars=matchMatcher.group(2);
    if (matchChars != null) {
      int matchLength=Integer.parseInt(matchChars);
      int regionAdjustment=currentAdjustment;
      for (int i=positionInReadSequence; i < matchLength; i++) {
        regionAdjustment+=positionAdjustment[i];
      }
      final CharSequence matchingSequence=readPostInsertions.subSequence(positionInReadSequence,positionInReadSequence + matchLength + regionAdjustment);
      referenceSequence.append(matchingSequence);
      positionInReadSequence+=matchLength;
    }
    if (variationChars != null) {
      if (variationChars.charAt(0) == '^') {
        int mutationLength=variationChars.length() - 1;
        final String toAppend=variationChars.substring(1);
        referenceSequence.append(toAppend);
        System.out.println(""String_Node_Str"" + variationChars + ""String_Node_Str""+ toAppend);
        for (int i=0; i < mutationLength; ++i) {
          readSequence.insert(positionInReadSequence,'-');
          readPostInsertions.insert(positionInReadSequence,'-');
        }
        positionInReadSequence+=mutationLength;
      }
 else {
        int mutationLength=variationChars.length();
        referenceSequence.append(variationChars);
        positionInReadSequence+=mutationLength;
      }
    }
    end=matchMatcher.end();
  }
  return readStartAlignedPosition;
}","/** 
 * Interpret the CIGAR string and MD SAM attribute and reconstruct the reference sequence given the read sequence. The reference passed as a argument is cleared before appending bases.
 * @param CIGAR             The CIGAR string.
 * @param mdAttribute       The SAM MD attribute
 * @param readSequence      The sequence of the read.
 * @param referenceSequence The sequence of the reference that will be reconstructed.
 * @return alignedReadStartPosition The position on the read that starts to align.
 */
public static int produceReferenceSequence(String CIGAR,String mdAttribute,MutableString readSequence,MutableString readPostInsertions,MutableString referenceSequence){
  Pattern matchPattern=attributeMD_pattern;
  referenceSequence.setLength(0);
  readPostInsertions.setLength(0);
  int end=0;
  int positionInReadSequence=0;
  IntList positionAdjustment=new IntArrayList();
  positionAdjustment.size(readSequence.length());
  int readStartAlignedPosition=processInsertionsOnly(CIGAR,mdAttribute,readSequence,readPostInsertions,positionAdjustment);
  Matcher matchMatcher=matchPattern.matcher(mdAttribute);
  int currentAdjustment=0;
  while (matchMatcher.find(end)) {
    String matchChars=matchMatcher.group(1);
    String variationChars=matchMatcher.group(2);
    if (matchChars != null) {
      int matchLength=Integer.parseInt(matchChars);
      int regionAdjustment=currentAdjustment;
      for (int i=positionInReadSequence; i < matchLength; i++) {
        regionAdjustment+=positionAdjustment.getInt(i);
      }
      final CharSequence matchingSequence=readPostInsertions.subSequence(positionInReadSequence,positionInReadSequence + matchLength + regionAdjustment);
      referenceSequence.append(matchingSequence);
      positionInReadSequence+=matchLength;
    }
    if (variationChars != null) {
      if (variationChars.charAt(0) == '^') {
        int mutationLength=variationChars.length() - 1;
        final String toAppend=variationChars.substring(1);
        referenceSequence.append(toAppend);
        for (int i=0; i < mutationLength; ++i) {
          readSequence.insert(positionInReadSequence,'-');
          readPostInsertions.insert(positionInReadSequence,'-');
        }
        positionInReadSequence+=mutationLength;
      }
 else {
        int mutationLength=variationChars.length();
        referenceSequence.append(variationChars);
        positionInReadSequence+=mutationLength;
      }
    }
    end=matchMatcher.end();
  }
  return readStartAlignedPosition;
}"
50496,"/** 
 * Main method.
 * @param args command line args.
 * @throws com.martiansoftware.jsap.JSAPException error parsing
 * @throws java.io.IOException error parsing or executing.
 */
public static void main(final String[] args) throws JSAPException, IOException {
  new AlignmentToTextMode().configure(args).execute();
}","/** 
 * Main method.
 * @param args command line args.
 * @throws JSAPException error parsing
 * @throws IOException error parsing or executing.
 */
public static void main(final String[] args) throws JSAPException, IOException {
  new AlignmentToTextMode().configure(args).execute();
}"
50497,"/** 
 * Configure.
 * @param args command line arguments
 * @return this object for chaining
 * @throws java.io.IOException error parsing
 * @throws com.martiansoftware.jsap.JSAPException error parsing
 */
@Override public AbstractCommandLineMode configure(final String[] args) throws IOException, JSAPException {
  final JSAPResult jsapResult=parseJsapArguments(args);
  inputFile=jsapResult.getString(""String_Node_Str"");
  basename=AlignmentReader.getBasename(inputFile);
  outputFile=jsapResult.getString(""String_Node_Str"");
  return this;
}","/** 
 * Configure.
 * @param args command line arguments
 * @return this object for chaining
 * @throws IOException error parsing
 * @throws JSAPException error parsing
 */
@Override public AbstractCommandLineMode configure(final String[] args) throws IOException, JSAPException {
  final JSAPResult jsapResult=parseJsapArguments(args);
  final String inputFile=jsapResult.getString(""String_Node_Str"");
  basename=AlignmentReader.getBasename(inputFile);
  outputFile=jsapResult.getString(""String_Node_Str"");
  return this;
}"
50498,"/** 
 * Run the map2text mode.
 * @throws java.io.IOException error reading / writing
 */
@Override public void execute() throws IOException {
  final AlignmentReader reader=new AlignmentReader(basename);
  reader.readHeader();
  final int numberOfReferences=reader.getNumberOfTargets();
  final DoubleIndexedIdentifier referenceIds=new DoubleIndexedIdentifier(reader.getTargetIdentifiers());
  reader.close();
  System.out.println(String.format(""String_Node_Str"",numberOfReferences));
  final IntSet referencesToProcess=new IntOpenHashSet();
  for (int referenceIndex=0; referenceIndex < numberOfReferences; referenceIndex++) {
    referencesToProcess.add(referenceIndex);
  }
  final AlignmentReader referenceReader=new AlignmentReader(inputFile);
  referenceReader.readHeader();
  final PrintWriter writer=outputFile == null ? new PrintWriter(System.out) : new PrintWriter(new FileWriter(outputFile));
  System.out.println(""String_Node_Str"");
  boolean hasReadIds=referenceReader.getQueryIdentifiers().size() > 0;
  DoubleIndexedIdentifier readIds=new DoubleIndexedIdentifier(referenceReader.getQueryIdentifiers());
  for (  final Alignments.AlignmentEntry alignmentEntry : referenceReader) {
    final int referenceIndex=alignmentEntry.getTargetIndex();
    final String referenceName=referenceIds.getId(referenceIndex).toString();
    if (referencesToProcess.contains(referenceIndex)) {
      final int startPosition=alignmentEntry.getPosition();
      final int alignmentLength=alignmentEntry.getQueryAlignedLength();
      for (int i=0; i < alignmentEntry.getMultiplicity(); ++i) {
        final int queryIndex=alignmentEntry.getQueryIndex();
        writer.write(String.format(""String_Node_Str"",hasReadIds ? readIds.getId(queryIndex) : Integer.toString(queryIndex),referenceName,alignmentEntry.getNumberOfIndels(),alignmentEntry.getNumberOfMismatches(),alignmentEntry.getScore(),startPosition,alignmentLength,alignmentEntry.getMatchingReverseStrand()));
      }
    }
  }
  writer.close();
  reader.close();
}","/** 
 * Run the map2text mode.
 * @throws java.io.IOException error reading / writing
 */
@Override public void execute() throws IOException {
  AlignmentReader reader=null;
  PrintWriter writer=null;
  try {
    reader=new AlignmentReader(basename);
    reader.readHeader();
    final int numberOfReferences=reader.getNumberOfTargets();
    final DoubleIndexedIdentifier referenceIds=new DoubleIndexedIdentifier(reader.getTargetIdentifiers());
    final int[] referenceLengths=reader.getTargetLength();
    System.out.println(""String_Node_Str"" + numberOfReferences + ""String_Node_Str"");
    final IntSet referencesToProcess=new IntOpenHashSet();
    for (int referenceIndex=0; referenceIndex < numberOfReferences; referenceIndex++) {
      referencesToProcess.add(referenceIndex);
    }
    System.out.println(""String_Node_Str"");
    writer=outputFile == null ? new PrintWriter(System.out) : new PrintWriter(outputFile);
    final boolean hasReadIds=reader.getQueryIdentifiers().size() > 0;
    final DoubleIndexedIdentifier readIds=new DoubleIndexedIdentifier(reader.getQueryIdentifiers());
    for (    final Alignments.AlignmentEntry alignmentEntry : reader) {
      final int referenceIndex=alignmentEntry.getTargetIndex();
      final String referenceName=referenceIds.getId(referenceIndex).toString();
      if (referencesToProcess.contains(referenceIndex)) {
        final int startPosition=alignmentEntry.getPosition();
        final int alignmentLength=alignmentEntry.getQueryAlignedLength();
        for (int i=0; i < alignmentEntry.getMultiplicity(); ++i) {
          final int queryIndex=alignmentEntry.getQueryIndex();
          writer.write(String.format(""String_Node_Str"",hasReadIds ? readIds.getId(queryIndex) : queryIndex,referenceName,alignmentEntry.getNumberOfIndels(),alignmentEntry.getNumberOfMismatches(),alignmentEntry.getScore(),startPosition,alignmentLength,alignmentEntry.getMatchingReverseStrand()));
        }
      }
    }
  }
  finally {
    IOUtils.closeQuietly(writer);
    if (reader != null) {
      reader.close();
    }
  }
}"
50499,"/** 
 * Perform the split transcripts mode.
 * @throws IOException error reading / writing
 */
@Override public void execute() throws IOException {
  if (!config.validate()) {
    throw new IOException(""String_Node_Str"");
  }
  final GeneTranscriptRelationships gtr=new GeneTranscriptRelationships();
  final IndexedIdentifier transcriptIdents=new IndexedIdentifier();
  final Int2ObjectMap<MutableString> transcriptIndexToIdMap=new Int2ObjectOpenHashMap<MutableString>();
  int entries=0;
  for (  final FastXEntry entry : new FastXReader(config.getInputFile())) {
    entries++;
    parseHeader(entry.getEntryHeader());
    final MutableString transcriptId=transcriptHeader.get(""String_Node_Str"");
    final MutableString geneId=transcriptHeader.get(""String_Node_Str"");
    final int transcriptIndex=transcriptIdents.registerIdentifier(transcriptId);
    gtr.addRelationship(geneId,transcriptIndex);
    transcriptIndexToIdMap.put(transcriptIndex,transcriptId);
  }
  LOG.info(""String_Node_Str"");
  final Int2IntMap transcriptIndex2FileIndex=new Int2IntOpenHashMap();
  final String configOutputFilename=config.getOutputBase() + ""String_Node_Str"";
  final String configOutputPath=FilenameUtils.getPath(configOutputFilename);
  if (StringUtils.isNotBlank(configOutputPath)) {
    LOG.info(""String_Node_Str"" + configOutputPath);
    FileUtils.forceMkdir(new File(configOutputPath));
  }
  PrintWriter configOutput=null;
  try {
    configOutput=new PrintWriter(configOutputFilename);
    configOutput.println(""String_Node_Str"");
    final Int2IntMap fileIndex2NumberOfEntries=new Int2IntOpenHashMap();
    fileIndex2NumberOfEntries.defaultReturnValue(0);
    transcriptIndex2FileIndex.defaultReturnValue(-1);
    final int initialNumberOfFiles=getNumberOfFiles(gtr,transcriptIndex2FileIndex);
    for (int geneIndex=0; geneIndex < gtr.getNumberOfGenes(); geneIndex++) {
      final MutableString geneId=gtr.getGeneId(geneIndex);
      final IntSet transcriptIndices=gtr.getTranscriptSet(geneIndex);
      int fileNum=0;
      for (      final int transcriptIndex : transcriptIndices) {
        if (transcriptIndex2FileIndex.get(transcriptIndex) != -1) {
          LOG.warn(""String_Node_Str"" + transcriptIndex);
          continue;
        }
        final int maxEntriesPerFile=config.getMaxEntriesPerFile();
        final int numberOfEntriesInOriginalBucket=fileIndex2NumberOfEntries.get(fileNum);
        final int adjustedFileIndex=fileNum + initialNumberOfFiles * (numberOfEntriesInOriginalBucket / maxEntriesPerFile);
        transcriptIndex2FileIndex.put(transcriptIndex,adjustedFileIndex);
        fileIndex2NumberOfEntries.put(fileNum,fileIndex2NumberOfEntries.get(fileNum) + 1);
        final MutableString transcriptId=transcriptIndexToIdMap.get(transcriptIndex);
        configOutput.printf(""String_Node_Str"",geneId,transcriptId);
        fileNum++;
      }
    }
  }
  finally {
    IOUtils.closeQuietly(configOutput);
  }
  final int numFiles=getFileIndices(transcriptIndex2FileIndex).size();
  if (LOG.isInfoEnabled()) {
    LOG.info(NumberFormat.getInstance().format(entries) + ""String_Node_Str"" + numFiles+ ""String_Node_Str"");
    final int maxEntriesPerFile=config.getMaxEntriesPerFile();
    if (maxEntriesPerFile < Integer.MAX_VALUE) {
      LOG.info(""String_Node_Str"" + maxEntriesPerFile + ""String_Node_Str"");
    }
  }
  final NumberFormat fileNumberFormatter=getNumberFormatter(numFiles - 1);
  final ProgressLogger progressLogger=new ProgressLogger();
  progressLogger.expectedUpdates=entries;
  progressLogger.itemsName=""String_Node_Str"";
  progressLogger.start();
  for (  final int fileIndex : getFileIndices(transcriptIndex2FileIndex)) {
    final String filename=config.getOutputBase() + ""String_Node_Str"" + fileNumberFormatter.format(fileIndex)+ ""String_Node_Str"";
    PrintStream printStream=null;
    try {
      printStream=new PrintStream(new GZIPOutputStream(new FileOutputStream(filename)));
      for (      final FastXEntry entry : new FastXReader(config.getInputFile())) {
        parseHeader(entry.getEntryHeader());
        final MutableString transcriptId=transcriptHeader.get(""String_Node_Str"");
        final MutableString geneId=transcriptHeader.get(""String_Node_Str"");
        final int transcriptIndex=transcriptIdents.getInt(transcriptId);
        final int transcriptFileIndex=transcriptIndex2FileIndex.get(transcriptIndex);
        if (transcriptFileIndex == fileIndex) {
          printStream.print(entry.getHeaderSymbol());
          printStream.print(transcriptId);
          printStream.print(""String_Node_Str"");
          printStream.println(geneId);
          printStream.println(entry.getEntrySansHeader());
          progressLogger.lightUpdate();
        }
      }
    }
  finally {
      IOUtils.closeQuietly(printStream);
    }
  }
  progressLogger.done();
}","/** 
 * Perform the split transcripts mode.
 * @throws IOException error reading / writing
 */
@Override public void execute() throws IOException {
  if (!config.validate()) {
    throw new IOException(""String_Node_Str"");
  }
  final GeneTranscriptRelationships gtr=new GeneTranscriptRelationships();
  final IndexedIdentifier transcriptIdents=new IndexedIdentifier();
  final Int2ObjectMap<MutableString> transcriptIndexToIdMap=new Int2ObjectOpenHashMap<MutableString>();
  int entries=0;
  for (  final FastXEntry entry : new FastXReader(config.getInputFile())) {
    entries++;
    parseHeader(entry.getEntryHeader());
    final MutableString transcriptId=transcriptHeader.get(""String_Node_Str"");
    final MutableString geneId=transcriptHeader.get(""String_Node_Str"");
    final int transcriptIndex=transcriptIdents.registerIdentifier(transcriptId);
    gtr.addRelationship(geneId,transcriptIndex);
    transcriptIndexToIdMap.put(transcriptIndex,transcriptId);
  }
  LOG.info(""String_Node_Str"");
  final Int2IntMap transcriptIndex2FileIndex=new Int2IntOpenHashMap();
  final String configOutputFilename=config.getOutputBase() + ""String_Node_Str"";
  final String configOutputPath=FilenameUtils.getFullPath(configOutputFilename);
  if (StringUtils.isNotBlank(configOutputPath)) {
    LOG.info(""String_Node_Str"" + configOutputPath);
    FileUtils.forceMkdir(new File(configOutputPath));
  }
  PrintWriter configOutput=null;
  try {
    configOutput=new PrintWriter(configOutputFilename);
    configOutput.println(""String_Node_Str"");
    final Int2IntMap fileIndex2NumberOfEntries=new Int2IntOpenHashMap();
    fileIndex2NumberOfEntries.defaultReturnValue(0);
    transcriptIndex2FileIndex.defaultReturnValue(-1);
    final int initialNumberOfFiles=getNumberOfFiles(gtr,transcriptIndex2FileIndex);
    for (int geneIndex=0; geneIndex < gtr.getNumberOfGenes(); geneIndex++) {
      final MutableString geneId=gtr.getGeneId(geneIndex);
      final IntSet transcriptIndices=gtr.getTranscriptSet(geneIndex);
      int fileNum=0;
      for (      final int transcriptIndex : transcriptIndices) {
        if (transcriptIndex2FileIndex.get(transcriptIndex) != -1) {
          LOG.warn(""String_Node_Str"" + transcriptIndex);
          continue;
        }
        final int maxEntriesPerFile=config.getMaxEntriesPerFile();
        final int numberOfEntriesInOriginalBucket=fileIndex2NumberOfEntries.get(fileNum);
        final int adjustedFileIndex=fileNum + initialNumberOfFiles * (numberOfEntriesInOriginalBucket / maxEntriesPerFile);
        transcriptIndex2FileIndex.put(transcriptIndex,adjustedFileIndex);
        fileIndex2NumberOfEntries.put(fileNum,fileIndex2NumberOfEntries.get(fileNum) + 1);
        final MutableString transcriptId=transcriptIndexToIdMap.get(transcriptIndex);
        configOutput.printf(""String_Node_Str"",geneId,transcriptId);
        fileNum++;
      }
    }
  }
  finally {
    IOUtils.closeQuietly(configOutput);
  }
  final int numFiles=getFileIndices(transcriptIndex2FileIndex).size();
  if (LOG.isInfoEnabled()) {
    LOG.info(NumberFormat.getInstance().format(entries) + ""String_Node_Str"" + numFiles+ ""String_Node_Str"");
    final int maxEntriesPerFile=config.getMaxEntriesPerFile();
    if (maxEntriesPerFile < Integer.MAX_VALUE) {
      LOG.info(""String_Node_Str"" + maxEntriesPerFile + ""String_Node_Str"");
    }
  }
  final NumberFormat fileNumberFormatter=getNumberFormatter(numFiles - 1);
  final ProgressLogger progressLogger=new ProgressLogger();
  progressLogger.expectedUpdates=entries;
  progressLogger.itemsName=""String_Node_Str"";
  progressLogger.start();
  for (  final int fileIndex : getFileIndices(transcriptIndex2FileIndex)) {
    final String filename=config.getOutputBase() + ""String_Node_Str"" + fileNumberFormatter.format(fileIndex)+ ""String_Node_Str"";
    PrintStream printStream=null;
    try {
      printStream=new PrintStream(new GZIPOutputStream(new FileOutputStream(filename)));
      for (      final FastXEntry entry : new FastXReader(config.getInputFile())) {
        parseHeader(entry.getEntryHeader());
        final MutableString transcriptId=transcriptHeader.get(""String_Node_Str"");
        final MutableString geneId=transcriptHeader.get(""String_Node_Str"");
        final int transcriptIndex=transcriptIdents.getInt(transcriptId);
        final int transcriptFileIndex=transcriptIndex2FileIndex.get(transcriptIndex);
        if (transcriptFileIndex == fileIndex) {
          printStream.print(entry.getHeaderSymbol());
          printStream.print(transcriptId);
          printStream.print(""String_Node_Str"");
          printStream.println(geneId);
          printStream.println(entry.getEntrySansHeader());
          progressLogger.lightUpdate();
        }
      }
    }
  finally {
      IOUtils.closeQuietly(printStream);
    }
  }
  progressLogger.done();
}"
50500,"public boolean isEntryComplete(){
  return entryComplete;
}","/** 
 * Is the entry is complete?
 * @return true if the entry is complete
 */
public boolean isEntryComplete(){
  return entryComplete;
}"
50501,"public final int[] getQueryLength(){
}","/** 
 * Returns query lengths. An array of size the number of query sequences, where each element indicates the length of the query sequence.
 */
public final int[] getQueryLength(){
}"
50502,"/** 
 * Initialize the reader to read a segment of the input. Sequences represented by a collection which starts between the input position start and end will be returned upon subsequent calls to hasNext(), next().
 * @param start  Start offset in the input file.
 * @param end    End offset in the input file.
 * @param stream Stream over the input file
 * @throws IOException If an error occurs reading the input.
 */
public AlignmentReader(final long start,final long end,final FastBufferedInputStream stream) throws IOException {
  alignmentEntryReader=new FastBufferedMessageChunksReader(start,end,stream);
}","/** 
 * Initialize the reader to read a segment of the input. Sequences represented by a collection which starts between the input position start and end will be returned upon subsequent calls to   {@link #hasNext()},   {@link #next()}.
 * @param start Start offset in the input file.
 * @param end  End offset in the input file.
 * @param stream Stream over the input file
 * @throws IOException If an error occurs reading the input.
 */
public AlignmentReader(final long start,final long end,final FastBufferedInputStream stream) throws IOException {
  super();
  alignmentEntryReader=new FastBufferedMessageChunksReader(start,end,stream);
}"
50503,"public Alignments.AlignmentEntry next(){
  return nextAlignmentEntry();
}","/** 
 * Returns the next alignment entry from the input stream.
 * @return the alignment read entry from the input stream.
 */
public Alignments.AlignmentEntry next(){
  if (!alignmentEntryReader.hasNext(collection,numberOfEntries())) {
    throw new NoSuchElementException();
  }
  return collection.getAlignmentEntries(alignmentEntryReader.incrementEntryIndex());
}"
50504,"public boolean hasNext(){
  return hasNextAligmentEntry();
}","/** 
 * Returns true if the input has more entries.
 * @return true if the input has more entries, false otherwise.
 */
public boolean hasNext(){
  final boolean hasNext=alignmentEntryReader.hasNext(collection,numberOfEntries());
  if (!hasNext) {
    collection=null;
  }
  final GZIPInputStream uncompressStream=alignmentEntryReader.getUncompressStream();
  try {
    if (uncompressStream != null) {
      collection=Alignments.AlignmentCollection.parseFrom(uncompressStream);
      if (collection.getAlignmentEntriesCount() == 0) {
        return false;
      }
    }
  }
 catch (  IOException e) {
    throw new GobyRuntimeException(e);
  }
  return hasNext;
}"
50505,"/** 
 * Return the basenames corresponding to the input filenames. Less basename than filenames may be returned (if several filenames reduce to the same baseline after removing the extension).
 */
public static String[] getBasenames(final String... inputFiles){
  final ObjectSet<String> result=new ObjectArraySet<String>();
  for (  final String filename : inputFiles) {
    result.add(getBasename(filename));
  }
  return result.toArray(new String[result.size()]);
}","/** 
 * Return the basenames corresponding to the input filenames. Less basename than filenames may be returned (if several filenames reduce to the same baseline after removing the extension).
 * @param filenames The names of the files to get the basnames for
 * @return An array of basenames
 */
public static String[] getBasenames(final String... filenames){
  final ObjectSet<String> result=new ObjectArraySet<String>();
  if (filenames != null) {
    for (    final String filename : filenames) {
      result.add(getBasename(filename));
    }
  }
  return result.toArray(new String[result.size()]);
}"
50506,"/** 
 * Return the basename corresponding to the input filename.
 */
public static String getBasename(final String inputFile){
  for (  final String ext : new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}) {
    if (inputFile.endsWith(ext)) {
      return inputFile.replace(ext,""String_Node_Str"");
    }
  }
  return inputFile;
}","/** 
 * Return the basename corresponding to the input alignment filename.  Note that if the filename does have the extension known to be a compact alignemt the returned value is the original filename
 * @param filename The name of the file to get the basname for
 * @return basename for the alignment file
 */
public static String getBasename(final String filename){
  for (  final String ext : FileExtensionHelper.COMPACT_ALIGNMENT_FILE_EXTS) {
    if (StringUtils.endsWith(filename,ext)) {
      return StringUtils.removeEnd(filename,ext);
    }
  }
  return filename;
}"
50507,"/** 
 * Returns true if the query matched at least k number of locations in the reference, at the specified match length or less. TODO : discuss removal of 2nd argument from this method as result does not depend on its value TODO : see comments at isQueryAmbiguous above
 * @param queryIndex The index of the query sequence.
 * @param k          The parameter k.
 * @param matchLength    The match length.
 * @return True or false.
 */
public final boolean isQueryAmbiguous(final int queryIndex,final int k,final int matchLength){
  if (matchLength < getLengthOfMatch(queryIndex)) {
    return true;
  }
 else {
    return isQueryAmbiguous(queryIndex,k);
  }
}","/** 
 * Returns true if the query matched at least k number of locations in the reference, at the specified match length or less. TODO : discuss removal of 2nd argument from this method as result does not depend on its value TODO : see comments at isQueryAmbiguous above
 * @param queryIndex The index of the query sequence.
 * @param k The parameter k.
 * @param matchLength The match length.
 * @return True or false.
 */
public final boolean isQueryAmbiguous(final int queryIndex,final int k,final int matchLength){
  if (matchLength < getLengthOfMatch(queryIndex)) {
    return true;
  }
 else {
    return isQueryAmbiguous(queryIndex,k);
  }
}"
50508,"public Type analyze(AstNode node,TypeScope env,Set<Type> nonGen){
  int id=_id++;
  if (node instanceof Program) {
    for (    Instruction inst : ((Program)node).instructions) {
      if (inst instanceof LetBinding) {
        LetBinding let=(LetBinding)inst;
        if (let.args.size() > 0) {
          env.define(let.name,Type.Function(new Type.Variable(),new Type.Variable()));
        }
      }
    }
    for (    Instruction inst : ((Program)node).instructions) {
      try {
        Type type=analyze(inst,env,nonGen);
      }
 catch (      TypeError e) {
        System.err.println(""String_Node_Str"" + env);
        throw new RuntimeException(""String_Node_Str"" + inst,e);
      }
    }
    return null;
  }
 else   if (node instanceof Expr.ENum) {
    return Type.INT;
  }
 else   if (node instanceof Expr.EBool) {
    return Type.BOOL;
  }
 else   if (node instanceof Expr.EStr) {
    return Type.STR;
  }
 else   if (node instanceof Expr.EChar) {
    return Type.CHAR;
  }
 else   if (node == Expr.EUnit) {
    return Type.UNIT;
  }
 else   if (node instanceof Expr.EList) {
    Type valueType=new Type.Variable();
    for (    Expr expr : ((Expr.EList)node).values) {
      unify(valueType,analyze(expr,env,nonGen));
    }
    return Type.List(valueType);
  }
 else   if (node instanceof Expr.ETuple) {
    List<Type> valuesTypes=new ArrayList<Type>();
    for (    Expr expr : ((Expr.ETuple)node).values) {
      valuesTypes.add(analyze(expr,env,nonGen));
    }
    return Type.Product(valuesTypes);
  }
 else   if (node instanceof Expr.ERecord) {
    Expr.ERecord rec=(Expr.ERecord)node;
    Map<String,Type> valuesTypes=new HashMap<String,Type>();
    for (    Map.Entry<String,Expr> entry : rec.values.entrySet()) {
      valuesTypes.put(entry.getKey(),analyze(entry.getValue(),env,nonGen));
    }
    return new Type.RecordType(valuesTypes);
  }
 else   if (node instanceof Expr.EName) {
    return getType(((Expr.EName)node).name,env,nonGen);
  }
 else   if (node instanceof Expr.EAccessor) {
    Expr.EAccessor acc=(Expr.EAccessor)node;
    Type objType=analyze(acc.obj,env,nonGen);
    Type.Variable res=new Type.Variable();
    Type.RecordType desiredType=new Type.RecordType(Collections.<String,Type>singletonMap(acc.field,res));
    unify(objType,desiredType);
    return res;
  }
 else   if (node instanceof Expr.EAp) {
    Expr.EAp ap=(Expr.EAp)node;
    Type funcType=analyze(ap.fn,env,nonGen);
    Type argType=analyze(ap.arg,env,nonGen);
    Type.Variable resType=new Type.Variable();
    try {
      unify(Type.Function(argType,resType),funcType);
    }
 catch (    TypeError e) {
      throw new TypeError(""String_Node_Str"" + ap,Type.Function(argType,resType),funcType,e);
    }
    return resType;
  }
 else   if (node instanceof Expr.EIf) {
    Expr.EIf eif=(Expr.EIf)node;
    Type condType=analyze(eif.cond,env,nonGen);
    if (!isException(condType)) {
      unify(condType,Type.BOOL);
    }
    Type thenType=null;
    for (    Instruction instr : eif.thenInstructions) {
      thenType=analyze(instr,env,nonGen);
    }
    Type elseType=null;
    for (    Instruction instr : eif.elseInstructions) {
      elseType=analyze(instr,env,nonGen);
    }
    if (!isException(thenType) && !isException(elseType)) {
      unify(thenType,elseType);
    }
    return isException(thenType) ? elseType : thenType;
  }
 else   if (node instanceof Expr.PatterMatching) {
    Expr.PatterMatching patmat=(Expr.PatterMatching)node;
    Type inputType=analyze(patmat.input,env,nonGen);
    Type resType=new Type.Variable();
    boolean allExceptions=true;
    for (    Expr.PatterMatching.Case pcase : patmat.cases) {
      TypeScope newScope=env.child();
      Type patType=visit(pcase.pattern,newScope,nonGen);
      if (!isException(inputType)) {
        unify(patType,inputType);
      }
      Type caseType=null;
      for (      Instruction instruction : pcase.outcome) {
        caseType=analyze(instruction,newScope,nonGen);
      }
      if (!isException(caseType)) {
        unify(caseType,resType);
        resType=caseType;
        allExceptions=false;
      }
    }
    return allExceptions ? Type.EXCEPTION : resType;
  }
 else   if (node instanceof Expr.EThrow) {
    Expr.EThrow ethrow=(Expr.EThrow)node;
    Type exType=analyze(ethrow.exception,env);
    unify(exType,Type.EXCEPTION);
    return Type.EXCEPTION;
  }
 else   if (node instanceof Expr.TryCatch) {
    Expr.TryCatch tc=(Expr.TryCatch)node;
    Type tryType=null;
    for (    Instruction instr : tc.tryBody) {
      tryType=analyze(instr,env,nonGen);
    }
    tryType=prune(tryType);
    System.err.println(""String_Node_Str"" + tryType.getClass());
    System.err.println(""String_Node_Str"" + (tryType == Type.EXCEPTION));
    Type.Variable resType=new Type.Variable();
    if (!isException(tryType)) {
      System.err.println(""String_Node_Str"");
      unify(tryType,resType);
    }
    for (    Expr.PatterMatching.Case pcase : tc.catchCases) {
      TypeScope newScope=env.child();
      Type patType=visit(pcase.pattern,newScope,nonGen);
      unify(patType,Type.EXCEPTION);
      Type caseType=null;
      for (      Instruction instruction : pcase.outcome) {
        caseType=analyze(instruction,newScope,nonGen);
      }
      unify(caseType,resType);
    }
    return resType;
  }
 else   if (node instanceof Expr.ELam) {
    Expr.ELam lam=(Expr.ELam)node;
    TypeScope newEnv=env.child();
    Set<Type> newNonGen=new HashSet<Type>(nonGen);
    List<Type> argTypes=new ArrayList<Type>();
    for (    Named arg : lam.args) {
      Type argType=new Type.Variable();
      argTypes.add(argType);
      newEnv.define(arg.name,argType);
      newNonGen.add(argType);
    }
    Type resultType=null;
    for (    Instruction instr : lam.instructions) {
      resultType=analyze(instr,newEnv,newNonGen);
    }
    if (lam.type != null) {
      unify(resultType,lam.type);
    }
    return Type.Function(argTypes,resultType);
  }
 else   if (node instanceof LetBinding) {
    LetBinding let=(LetBinding)node;
    TypeScope newEnv=env.child();
    Set<Type> newNonGen=new HashSet<Type>(nonGen);
    List<Type> argTypes=new ArrayList<Type>();
    Type.Variable letTypeVar=new Type.Variable();
    newEnv.define(let.name,letTypeVar);
    newNonGen.add(letTypeVar);
    for (    Named arg : let.args) {
      Type argType=new Type.Variable();
      argTypes.add(argType);
      newEnv.define(arg.name,argType);
      newNonGen.add(argType);
    }
    Type resultType=null;
    for (    Instruction instr : let.instructions) {
      resultType=analyze(instr,newEnv,newNonGen);
    }
    if (let.type != null) {
      unify(resultType,let.type);
    }
    Type letType=Type.Function(argTypes,resultType);
    env.define(let.name,letType);
    return letType;
  }
 else   if (node instanceof DestructuringLetBinding) {
    DestructuringLetBinding let=(DestructuringLetBinding)node;
    TypeScope newEnv=env.child();
    Set<Type> newNonGen=new HashSet<Type>(nonGen);
    List<Type> argTypes=new ArrayList<Type>();
    Type letTypeVar=visit(let.main,newEnv,newNonGen);
    newNonGen.add(letTypeVar);
    for (    Pattern arg : let.args) {
      Type argType=visit(arg,newEnv,newNonGen);
      argTypes.add(argType);
    }
    Type resultType=null;
    for (    Instruction instr : let.instructions) {
      resultType=analyze(instr,newEnv,newNonGen);
    }
    Type letType=Type.Function(argTypes,resultType);
    define(let.main,letType,env);
    return letType;
  }
 else   if (node instanceof DataDecl) {
    DataDecl dataDecl=(DataDecl)node;
    for (    DataDecl.TypeConstructor tyCon : dataDecl.typeConstructors) {
      env.define(tyCon.name,Type.TyCon(tyCon,dataDecl));
    }
    return dataDecl.type;
  }
 else   if (node instanceof ExceptionDecl) {
    ExceptionDecl dataDecl=(ExceptionDecl)node;
    env.define(dataDecl.name,new Type.ExceptionCon(dataDecl.name,dataDecl.types));
    return Type.EXCEPTION;
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + node.getClass());
  }
}","public Type analyze(AstNode node,TypeScope env,Set<Type> nonGen){
  int id=_id++;
  if (node instanceof Program) {
    for (    Instruction inst : ((Program)node).instructions) {
      if (inst instanceof LetBinding) {
        LetBinding let=(LetBinding)inst;
        if (let.args.size() > 0) {
          env.define(let.name,Type.Function(new Type.Variable(),new Type.Variable()));
        }
      }
    }
    for (    Instruction inst : ((Program)node).instructions) {
      try {
        Type type=analyze(inst,env,nonGen);
      }
 catch (      TypeError e) {
        System.err.println(""String_Node_Str"" + env);
        throw new RuntimeException(""String_Node_Str"" + inst,e);
      }
    }
    return null;
  }
 else   if (node instanceof Expr.ENum) {
    return Type.INT;
  }
 else   if (node instanceof Expr.EBool) {
    return Type.BOOL;
  }
 else   if (node instanceof Expr.EStr) {
    return Type.STR;
  }
 else   if (node instanceof Expr.EChar) {
    return Type.CHAR;
  }
 else   if (node == Expr.EUnit) {
    return Type.UNIT;
  }
 else   if (node instanceof Expr.EList) {
    Type valueType=new Type.Variable();
    for (    Expr expr : ((Expr.EList)node).values) {
      unify(valueType,analyze(expr,env,nonGen));
    }
    return Type.List(valueType);
  }
 else   if (node instanceof Expr.ETuple) {
    List<Type> valuesTypes=new ArrayList<Type>();
    for (    Expr expr : ((Expr.ETuple)node).values) {
      valuesTypes.add(analyze(expr,env,nonGen));
    }
    return Type.Product(valuesTypes);
  }
 else   if (node instanceof Expr.ERecord) {
    Expr.ERecord rec=(Expr.ERecord)node;
    Map<String,Type> valuesTypes=new HashMap<String,Type>();
    for (    Map.Entry<String,Expr> entry : rec.values.entrySet()) {
      valuesTypes.put(entry.getKey(),analyze(entry.getValue(),env,nonGen));
    }
    return new Type.RecordType(valuesTypes);
  }
 else   if (node instanceof Expr.EName) {
    return getType(((Expr.EName)node).name,env,nonGen);
  }
 else   if (node instanceof Expr.EAccessor) {
    Expr.EAccessor acc=(Expr.EAccessor)node;
    Type objType=analyze(acc.obj,env,nonGen);
    Type.Variable res=new Type.Variable();
    Type.RecordType desiredType=new Type.RecordType(Collections.<String,Type>singletonMap(acc.field,res));
    unify(objType,desiredType);
    return res;
  }
 else   if (node instanceof Expr.EAp) {
    Expr.EAp ap=(Expr.EAp)node;
    Type funcType=analyze(ap.fn,env,nonGen);
    Type argType=analyze(ap.arg,env,nonGen);
    Type.Variable resType=new Type.Variable();
    try {
      unify(Type.Function(argType,resType),funcType);
    }
 catch (    TypeError e) {
      throw new TypeError(""String_Node_Str"" + ap,Type.Function(argType,resType),funcType,e);
    }
    return resType;
  }
 else   if (node instanceof Expr.EIf) {
    Expr.EIf eif=(Expr.EIf)node;
    Type condType=analyze(eif.cond,env,nonGen);
    if (!isException(condType)) {
      unify(condType,Type.BOOL);
    }
    Type thenType=null;
    for (    Instruction instr : eif.thenInstructions) {
      thenType=analyze(instr,env,nonGen);
    }
    Type elseType=null;
    for (    Instruction instr : eif.elseInstructions) {
      elseType=analyze(instr,env,nonGen);
    }
    if (!isException(thenType) && !isException(elseType)) {
      unify(thenType,elseType);
    }
    return isException(thenType) ? elseType : thenType;
  }
 else   if (node instanceof Expr.PatterMatching) {
    Expr.PatterMatching patmat=(Expr.PatterMatching)node;
    Type inputType=analyze(patmat.input,env,nonGen);
    Type resType=new Type.Variable();
    boolean allExceptions=true;
    for (    Expr.PatterMatching.Case pcase : patmat.cases) {
      TypeScope newScope=env.child();
      Type patType=visit(pcase.pattern,newScope,nonGen);
      if (!isException(inputType)) {
        unify(patType,inputType);
      }
      Type caseType=null;
      for (      Instruction instruction : pcase.outcome) {
        caseType=analyze(instruction,newScope,nonGen);
      }
      if (!isException(caseType)) {
        unify(caseType,resType);
        resType=caseType;
        allExceptions=false;
      }
    }
    return allExceptions ? Type.EXCEPTION : resType;
  }
 else   if (node instanceof Expr.EThrow) {
    Expr.EThrow ethrow=(Expr.EThrow)node;
    Type exType=analyze(ethrow.exception,env,nonGen);
    unify(exType,Type.EXCEPTION);
    return Type.EXCEPTION;
  }
 else   if (node instanceof Expr.TryCatch) {
    Expr.TryCatch tc=(Expr.TryCatch)node;
    Type tryType=null;
    for (    Instruction instr : tc.tryBody) {
      tryType=analyze(instr,env,nonGen);
    }
    tryType=prune(tryType);
    System.err.println(""String_Node_Str"" + tryType.getClass());
    System.err.println(""String_Node_Str"" + (tryType == Type.EXCEPTION));
    Type.Variable resType=new Type.Variable();
    if (!isException(tryType)) {
      System.err.println(""String_Node_Str"");
      unify(tryType,resType);
    }
    for (    Expr.PatterMatching.Case pcase : tc.catchCases) {
      TypeScope newScope=env.child();
      Type patType=visit(pcase.pattern,newScope,nonGen);
      unify(patType,Type.EXCEPTION);
      Type caseType=null;
      for (      Instruction instruction : pcase.outcome) {
        caseType=analyze(instruction,newScope,nonGen);
      }
      unify(caseType,resType);
    }
    return resType;
  }
 else   if (node instanceof Expr.ELam) {
    Expr.ELam lam=(Expr.ELam)node;
    TypeScope newEnv=env.child();
    Set<Type> newNonGen=new HashSet<Type>(nonGen);
    List<Type> argTypes=new ArrayList<Type>();
    for (    Named arg : lam.args) {
      Type argType=new Type.Variable();
      argTypes.add(argType);
      newEnv.define(arg.name,argType);
      newNonGen.add(argType);
    }
    Type resultType=null;
    for (    Instruction instr : lam.instructions) {
      resultType=analyze(instr,newEnv,newNonGen);
    }
    if (lam.type != null) {
      unify(resultType,lam.type);
    }
    return Type.Function(argTypes,resultType);
  }
 else   if (node instanceof LetBinding) {
    LetBinding let=(LetBinding)node;
    TypeScope newEnv=env.child();
    Set<Type> newNonGen=new HashSet<Type>(nonGen);
    List<Type> argTypes=new ArrayList<Type>();
    Type.Variable letTypeVar=new Type.Variable();
    newEnv.define(let.name,letTypeVar);
    newNonGen.add(letTypeVar);
    for (    Named arg : let.args) {
      Type argType=new Type.Variable();
      argTypes.add(argType);
      newEnv.define(arg.name,argType);
      newNonGen.add(argType);
    }
    Type resultType=null;
    for (    Instruction instr : let.instructions) {
      resultType=analyze(instr,newEnv,newNonGen);
    }
    if (let.type != null) {
      unify(resultType,let.type);
    }
    Type letType=Type.Function(argTypes,resultType);
    env.define(let.name,letType);
    return letType;
  }
 else   if (node instanceof DestructuringLetBinding) {
    DestructuringLetBinding let=(DestructuringLetBinding)node;
    TypeScope newEnv=env.child();
    Set<Type> newNonGen=new HashSet<Type>(nonGen);
    List<Type> argTypes=new ArrayList<Type>();
    Type letTypeVar=visit(let.main,newEnv,newNonGen);
    newNonGen.add(letTypeVar);
    for (    Pattern arg : let.args) {
      Type argType=visit(arg,newEnv,newNonGen);
      argTypes.add(argType);
    }
    Type resultType=null;
    for (    Instruction instr : let.instructions) {
      resultType=analyze(instr,newEnv,newNonGen);
    }
    Type letType=Type.Function(argTypes,resultType);
    define(let.main,letType,env);
    return letType;
  }
 else   if (node instanceof DataDecl) {
    DataDecl dataDecl=(DataDecl)node;
    for (    DataDecl.TypeConstructor tyCon : dataDecl.typeConstructors) {
      env.define(tyCon.name,Type.TyCon(tyCon,dataDecl));
    }
    return dataDecl.type;
  }
 else   if (node instanceof ExceptionDecl) {
    ExceptionDecl dataDecl=(ExceptionDecl)node;
    env.define(dataDecl.name,new Type.ExceptionCon(dataDecl.name,dataDecl.types));
    return Type.EXCEPTION;
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + node.getClass());
  }
}"
50509,"public void delHop(final int i){
  isDirty=true;
  if (!hops.isEmpty() && (i > -1)) {
    hops.remove(i);
    calcHopsTotals();
  }
}","public void delHop(final int i){
  isDirty=true;
  if (!hops.isEmpty() && (i > -1) && (i < hops.size())) {
    hops.remove(i);
    calcHopsTotals();
  }
}"
50510,"public void delMalt(final int i){
  isDirty=true;
  if (!fermentables.isEmpty() && (i > -1)) {
    fermentables.remove(i);
    calcMaltTotals();
  }
}","public void delMalt(final int i){
  isDirty=true;
  if (!fermentables.isEmpty() && (i > -1) && (i < fermentables.size())) {
    fermentables.remove(i);
    calcMaltTotals();
  }
}"
50511,"public void delNote(final int i){
  isDirty=true;
  if (!notes.isEmpty() && (i > -1)) {
    notes.remove(i);
  }
}","public void delNote(final int i){
  isDirty=true;
  if (!notes.isEmpty() && (i > -1) && (i < notes.size())) {
    notes.remove(i);
  }
}"
50512,"public void delSalt(final int i){
  this.brewingSalts.remove(i);
}","public void delSalt(final int i){
  if (!brewingSalts.isEmpty() && (i > -1) && (i < brewingSalts.size()))   this.brewingSalts.remove(i);
}"
50513,"public void delMisc(final int i){
  isDirty=true;
  if (!misc.isEmpty() && (i > -1)) {
    misc.remove(i);
    calcMiscCost();
  }
}","public void delMisc(final int i){
  isDirty=true;
  if (!misc.isEmpty() && (i > -1) && (i < misc.size())) {
    misc.remove(i);
    calcMiscCost();
  }
}"
50514,"public FermentStep delFermentStep(final int i){
  isDirty=true;
  FermentStep temp=null;
  if (!fermentationSteps.isEmpty() && (i > -1)) {
    temp=fermentationSteps.remove(i);
    Collections.sort(fermentationSteps);
    calcFermentTotals();
  }
  return temp;
}","public FermentStep delFermentStep(final int i){
  isDirty=true;
  FermentStep temp=null;
  if (!fermentationSteps.isEmpty() && (i > -1) && (i < fermentationSteps.size())) {
    temp=fermentationSteps.remove(i);
    Collections.sort(fermentationSteps);
    calcFermentTotals();
  }
  return temp;
}"
50515,"public FindDialog(JFrame frame){
  super(frame);
  String recipeDir=opt.getProperty(""String_Node_Str"");
  if (recipeDir.equalsIgnoreCase(""String_Node_Str"")) {
    try {
      recipeDir=SBStringUtils.getAppPath(""String_Node_Str"");
    }
 catch (    UnsupportedEncodingException e) {
      JOptionPane.showMessageDialog(frame,""String_Node_Str"");
    }
  }
  currentDir=new File(recipeDir);
  initGUI();
  dirLocationText.setText(currentDir.getAbsolutePath());
  loadRecipes(currentDir);
}","public FindDialog(JFrame frame){
  super(frame);
  String recipeDir=""String_Node_Str"";
  if (opt.getProperty(""String_Node_Str"") != null)   recipeDir=opt.getProperty(""String_Node_Str"");
  if (recipeDir.equalsIgnoreCase(""String_Node_Str"")) {
    try {
      recipeDir=SBStringUtils.getAppPath(""String_Node_Str"");
    }
 catch (    UnsupportedEncodingException e) {
      JOptionPane.showMessageDialog(frame,""String_Node_Str"");
    }
  }
  currentDir=new File(recipeDir);
  initGUI();
  dirLocationText.setText(currentDir.getAbsolutePath());
  loadRecipes(currentDir);
}"
50516,"public StrangeSwing(){
  super();
  preferences=Options.getInstance();
  DB=Database.getInstance();
  String path=SBStringUtils.getAppPath(""String_Node_Str"");
  Debug.print(""String_Node_Str"" + path);
  File maltFile=new File(path,""String_Node_Str"");
  File hopsFile=new File(path,""String_Node_Str"");
  if (!maltFile.exists() || !hopsFile.exists()) {
    Object[] options={""String_Node_Str"",""String_Node_Str""};
    int choice=JOptionPane.showOptionDialog(null,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.ERROR_MESSAGE,null,options,options[0]);
    if (choice == 0) {
      fileChooser.resetChoosableFileFilters();
      fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
      String[] ext={""String_Node_Str""};
      String desc=""String_Node_Str"";
      sbFileFilter openFileFilter=new sbFileFilter(ext,desc);
      fileChooser.setFileFilter(openFileFilter);
      int returnVal=fileChooser.showOpenDialog(null);
      if (returnVal == JFileChooser.APPROVE_OPTION) {
        File file=fileChooser.getSelectedFile();
        path=file.getPath();
        Debug.print(""String_Node_Str"" + path + ""String_Node_Str"");
        fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
      }
 else       System.exit(1);
    }
 else     System.exit(1);
  }
  DB.readDB(path);
  cmbStyleModel.setList(DB.styleDB);
  cmbYeastModel.setList(DB.yeastDB);
  cmbMaltModel.setList(DB.fermDB);
  cmbHopsModel.setList(DB.hopsDB);
  carbPanel.setList(DB.primeSugarDB);
  waterTreatmentPanel.setList(DB.waterDB);
  initGUI();
  cmbSizeUnitsModel.setList(Quantity.getListofUnits(""String_Node_Str""));
  cmbMaltUnitsModel.setList(Quantity.getListofUnits(""String_Node_Str""));
  cmbHopsUnitsModel.setList(Quantity.getListofUnits(""String_Node_Str""));
  path=SBStringUtils.getAppPath(""String_Node_Str"");
  Debug.print(""String_Node_Str"" + path);
  fileChooser.setCurrentDirectory(new File(path));
  addColumnWidthListeners();
  miscPanel.setList(DB.miscDB);
  stylePanel.setList(DB.styleDB);
  addListeners();
  myRecipe=new Recipe();
  currentFile=null;
  myRecipe.setDirty(false);
  attachRecipeData();
  displayRecipe();
}","public StrangeSwing(){
  super();
  preferences=Options.getInstance();
  DB=Database.getInstance();
  String path=SBStringUtils.getAppPath(""String_Node_Str"");
  Debug.print(""String_Node_Str"" + path);
  File maltFile=new File(path,""String_Node_Str"");
  File hopsFile=new File(path,""String_Node_Str"");
  if (!maltFile.exists() || !hopsFile.exists()) {
    Object[] options={""String_Node_Str"",""String_Node_Str""};
    int choice=JOptionPane.showOptionDialog(null,""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.ERROR_MESSAGE,null,options,options[0]);
    if (choice == 0) {
      fileChooser.resetChoosableFileFilters();
      fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
      String[] ext={""String_Node_Str""};
      String desc=""String_Node_Str"";
      sbFileFilter openFileFilter=new sbFileFilter(ext,desc);
      fileChooser.setFileFilter(openFileFilter);
      int returnVal=fileChooser.showOpenDialog(null);
      if (returnVal == JFileChooser.APPROVE_OPTION) {
        File file=fileChooser.getSelectedFile();
        path=file.getPath();
        Debug.print(""String_Node_Str"" + path + ""String_Node_Str"");
        fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
      }
 else       System.exit(1);
    }
 else     System.exit(1);
  }
  DB.readDB(path);
  cmbStyleModel.setList(DB.styleDB);
  cmbYeastModel.setList(DB.yeastDB);
  cmbMaltModel.setList(DB.fermDB);
  cmbHopsModel.setList(DB.hopsDB);
  carbPanel.setList(DB.primeSugarDB);
  initGUI();
  cmbSizeUnitsModel.setList(Quantity.getListofUnits(""String_Node_Str""));
  cmbMaltUnitsModel.setList(Quantity.getListofUnits(""String_Node_Str""));
  cmbHopsUnitsModel.setList(Quantity.getListofUnits(""String_Node_Str""));
  path=SBStringUtils.getAppPath(""String_Node_Str"");
  Debug.print(""String_Node_Str"" + path);
  fileChooser.setCurrentDirectory(new File(path));
  addColumnWidthListeners();
  miscPanel.setList(DB.miscDB);
  stylePanel.setList(DB.styleDB);
  addListeners();
  myRecipe=new Recipe();
  currentFile=null;
  myRecipe.setDirty(false);
  attachRecipeData();
  displayRecipe();
}"
50517,"private void initGUI(){
  try {
    this.setSize(preferences.getIProperty(""String_Node_Str""),preferences.getIProperty(""String_Node_Str""));
    this.setLocation(preferences.getIProperty(""String_Node_Str""),preferences.getIProperty(""String_Node_Str""));
    imgURL=getClass().getClassLoader().getResource(""String_Node_Str"");
    icon=new ImageIcon(imgURL);
    this.setIconImage(icon.getImage());
    this.setTitle(""String_Node_Str"" + version + ""String_Node_Str""+ edition+ ""String_Node_Str"");
    this.addWindowListener(new WindowAdapter(){
      public void windowClosed(      WindowEvent evt){
        System.exit(1);
      }
    }
);
{
      GridBagLayout jPanel2Layout=new GridBagLayout();
      jPanel2Layout.columnWeights=new double[]{0.1};
      jPanel2Layout.columnWidths=new int[]{7};
      jPanel2Layout.rowWeights=new double[]{0.1,0.1,0.9,0.1};
      pnlMain.setLayout(jPanel2Layout);
      this.getContentPane().add(pnlMain,BorderLayout.CENTER);
{
        pnlMain.add(jTabbedPane1,new GridBagConstraints(0,1,1,1,0.1,0.1,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
{
          GridBagLayout pnlDetailsLayout=new GridBagLayout();
          pnlDetailsLayout.columnWeights=new double[]{0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1};
          pnlDetailsLayout.columnWidths=new int[]{7,7,7,7,7,7,7,7,7,7};
          pnlDetailsLayout.rowWeights=new double[]{0.1,0.1,0.1,0.1,0.1,0.1,0.1};
          pnlDetailsLayout.rowHeights=new int[]{7,7,7,7,7,7,7};
          pnlDetails.setLayout(pnlDetailsLayout);
          pnlDetails.setPreferredSize(new java.awt.Dimension(20,16));
{
            pnlDetails.add(lblBrewer,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblBrewer.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(brewerNameText,new GridBagConstraints(1,0,2,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            brewerNameText.setPreferredSize(new java.awt.Dimension(69,20));
            brewerNameText.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(lblDate,new GridBagConstraints(0,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblDate.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(lblStyle,new GridBagConstraints(0,2,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblStyle.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(lblYeast,new GridBagConstraints(0,3,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblYeast.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(lblPreBoil,new GridBagConstraints(0,4,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblPreBoil.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(lblFinalWortVol,new GridBagConstraints(0,5,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblFinalWortVol.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(lblEffic,new GridBagConstraints(3,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblEffic.setText(""String_Node_Str"");
            lblEffic.setPreferredSize(new java.awt.Dimension(31,14));
          }
{
            pnlDetails.add(lblAtten,new GridBagConstraints(3,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblAtten.setText(""String_Node_Str"");
            lblAtten.setPreferredSize(new java.awt.Dimension(34,14));
          }
{
            pnlDetails.add(lblOG,new GridBagConstraints(5,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblOG.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(lblFG,new GridBagConstraints(5,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblFG.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(lblIBU,new GridBagConstraints(7,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblIBU.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(lblAlc,new GridBagConstraints(7,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblAlc.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(lblColour,new GridBagConstraints(7,2,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblColour.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(txtDate,new GridBagConstraints(1,1,2,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            txtDate.setPreferredSize(new java.awt.Dimension(73,20));
            txtDate.setDateStyle(DateFormat.SHORT);
            txtDate.setLocale(preferences.getLocale());
          }
{
            SmartComboBox.enable(cmbStyle);
            pnlDetails.add(cmbStyle,new GridBagConstraints(1,2,5,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            cmbStyle.setModel(cmbStyleModel);
            cmbStyle.setMaximumSize(new java.awt.Dimension(100,32767));
            cmbStyle.setPreferredSize(new java.awt.Dimension(190,20));
          }
{
            pnlDetails.add(preBoilText,new GridBagConstraints(1,4,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            preBoilText.setText(""String_Node_Str"");
            preBoilText.setPreferredSize(new java.awt.Dimension(37,20));
          }
{
            pnlDetails.add(finalWortVolText,new GridBagConstraints(1,5,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            finalWortVolText.setText(""String_Node_Str"");
            finalWortVolText.setPreferredSize(new java.awt.Dimension(46,20));
          }
{
            pnlDetails.add(lblComments,new GridBagConstraints(6,4,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblComments.setText(""String_Node_Str"");
          }
{
            SpinnerNumberModel spnEfficModel=new SpinnerNumberModel(75.0,0.0,100.0,1.0);
            pnlDetails.add(spnEffic,new GridBagConstraints(4,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            spnEffic.setModel(spnEfficModel);
            spnEffic.setMaximumSize(new java.awt.Dimension(70,32767));
            spnEffic.addChangeListener(this);
            spnEffic.setEditor(new JSpinner.NumberEditor(spnEffic,""String_Node_Str""));
            spnEffic.getEditor().setPreferredSize(new java.awt.Dimension(28,16));
            spnEffic.setPreferredSize(new java.awt.Dimension(53,18));
          }
{
            SpinnerNumberModel spnAttenModel=new SpinnerNumberModel(75.0,0.0,100.0,1.0);
            pnlDetails.add(spnAtten,new GridBagConstraints(4,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            spnAtten.setModel(spnAttenModel);
            spnAtten.addChangeListener(this);
            spnAtten.setEditor(new JSpinner.NumberEditor(spnAtten,""String_Node_Str""));
            spnAtten.setPreferredSize(new java.awt.Dimension(49,20));
          }
{
            SpinnerNumberModel spnOgModel=new SpinnerNumberModel(1.000,0.900,2.000,0.001);
            pnlDetails.add(spnOG,new GridBagConstraints(6,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            spnOG.setModel(spnOgModel);
            spnOG.addChangeListener(this);
            spnOG.setEditor(new JSpinner.NumberEditor(spnOG,""String_Node_Str""));
            spnOG.getEditor().setPreferredSize(new java.awt.Dimension(20,16));
            spnOG.setPreferredSize(new java.awt.Dimension(67,18));
          }
{
            SpinnerNumberModel spnFgModel=new SpinnerNumberModel(1.000,0.900,2.000,0.001);
            pnlDetails.add(spnFG,new GridBagConstraints(6,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            spnFG.setModel(spnFgModel);
            spnFG.setEditor(new JSpinner.NumberEditor(spnFG,""String_Node_Str""));
            spnFG.setPreferredSize(new java.awt.Dimension(69,20));
            spnFG.addChangeListener(this);
          }
{
            pnlDetails.add(lblIBUvalue,new GridBagConstraints(8,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblIBUvalue.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(lblColourValue,new GridBagConstraints(8,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblColourValue.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(lblAlcValue,new GridBagConstraints(8,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblAlcValue.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(scpComments,new GridBagConstraints(7,4,3,2,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
{
              scpComments.setViewportView(txtComments);
              txtComments.setText(""String_Node_Str"");
              txtComments.setWrapStyleWord(true);
              txtComments.setLineWrap(true);
              scpComments.setPreferredSize(new java.awt.Dimension(263,40));
              txtComments.addFocusListener(this);
            }
          }
{
            SmartComboBox.enable(cmbYeast);
            pnlDetails.add(cmbYeast,new GridBagConstraints(1,3,5,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            cmbYeast.setModel(cmbYeastModel);
            cmbYeast.setPreferredSize(new java.awt.Dimension(193,20));
          }
{
            SmartComboBox.enable(cmbSizeUnits);
            pnlDetails.add(cmbSizeUnits,new GridBagConstraints(2,4,2,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            cmbSizeUnits.setModel(cmbSizeUnitsModel);
          }
{
            pnlDetails.add(lblSizeUnits,new GridBagConstraints(2,5,2,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            lblSizeUnits.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(boilTimeLable,new GridBagConstraints(4,4,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            boilTimeLable.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(evapLabel,new GridBagConstraints(4,5,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            evapLabel.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(boilMinText,new GridBagConstraints(5,4,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            boilMinText.setText(""String_Node_Str"");
            boilMinText.setPreferredSize(new java.awt.Dimension(22,20));
          }
{
            pnlDetails.add(evapText,new GridBagConstraints(5,5,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            evapText.setText(""String_Node_Str"");
            evapText.setPreferredSize(new java.awt.Dimension(23,20));
          }
{
            SmartComboBox.enable(alcMethodCombo);
            pnlDetails.add(alcMethodCombo,new GridBagConstraints(9,0,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            alcMethodCombo.setPreferredSize(new java.awt.Dimension(71,20));
          }
{
            SmartComboBox.enable(ibuMethodCombo);
            pnlDetails.add(ibuMethodCombo,new GridBagConstraints(9,1,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            ibuMethodCombo.setPreferredSize(new java.awt.Dimension(72,20));
          }
{
            SmartComboBox.enable(colourMethodCombo);
            pnlDetails.add(colourMethodCombo,new GridBagConstraints(9,2,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            colourMethodCombo.setPreferredSize(new java.awt.Dimension(52,20));
          }
          ComboBoxModel evapMethodComboModel=new DefaultComboBoxModel(new String[]{""String_Node_Str"",""String_Node_Str""});
{
            pnlMain.add(jPanel1,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            FlowLayout jPanel1Layout=new FlowLayout();
            jPanel1Layout.setAlignment(FlowLayout.LEFT);
            jPanel1.setLayout(jPanel1Layout);
            getContentPane().add(mainToolBar,BorderLayout.NORTH);
            mainToolBar.setFloatable(false);
            mainToolBar.setRollover(true);
            mainToolBar.add(saveButton);
            saveButton.setMnemonic(java.awt.event.KeyEvent.VK_S);
            saveButton.setIcon(new ImageIcon(getClass().getClassLoader().getResource(""String_Node_Str"")));
            saveButton.setToolTipText(""String_Node_Str"");
            mainToolBar.add(findButton);
            findButton.setIcon(new ImageIcon(getClass().getClassLoader().getResource(""String_Node_Str"")));
            findButton.setToolTipText(""String_Node_Str"");
            mainToolBar.add(printButton);
            printButton.setIcon(new ImageIcon(getClass().getClassLoader().getResource(""String_Node_Str"")));
            printButton.setToolTipText(""String_Node_Str"");
            mainToolBar.add(copyButton);
            copyButton.setIcon(new ImageIcon(getClass().getClassLoader().getResource(""String_Node_Str"")));
            copyButton.setToolTipText(""String_Node_Str"");
{
              jPanel1.add(lblName);
              lblName.setText(""String_Node_Str"");
            }
{
              jPanel1.add(txtName);
              txtName.setText(""String_Node_Str"");
              txtName.setPreferredSize(new java.awt.Dimension(297,20));
            }
          }
          SmartComboBox.enable(evapMethodCombo);
          pnlDetails.add(evapMethodCombo,new GridBagConstraints(6,5,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
          evapMethodCombo.setModel(evapMethodComboModel);
          evapMethodCombo.setPreferredSize(new java.awt.Dimension(64,20));
          pnlDetails.add(colourPanel,new GridBagConstraints(9,3,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
          colourPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
          colourPanel.setPreferredSize(new java.awt.Dimension(93,32));
        }
{
          jTabbedPane1.addTab(""String_Node_Str"",null,pnlDetails,null);
          jTabbedPane1.addTab(""String_Node_Str"",null,stylePanel,null);
          jTabbedPane1.addTab(""String_Node_Str"",null,miscPanel,null);
          jTabbedPane1.addTab(""String_Node_Str"",null,notesPanel,null);
          jTabbedPane1.addTab(""String_Node_Str"",null,dilutionPanel,null);
          jTabbedPane1.addTab(""String_Node_Str"",null,mashPanel,null);
          jTabbedPane1.addTab(""String_Node_Str"",null,waterTreatmentPanel,null);
          jTabbedPane1.addTab(""String_Node_Str"",null,fermentPanel,null);
          jTabbedPane1.addTab(""String_Node_Str"",null,carbPanel,null);
          jTabbedPane1.addTab(""String_Node_Str"",null,waterPanel,null);
          jTabbedPane1.addTab(""String_Node_Str"",null,costPanel,null);
          jTabbedPane1.addTab(""String_Node_Str"",null,settingsPanel,null);
          jTabbedPane1.addChangeListener(this);
        }
      }
{
        BoxLayout pnlMaltsLayout=new BoxLayout(pnlTables,javax.swing.BoxLayout.Y_AXIS);
        pnlMain.add(pnlTables,new GridBagConstraints(0,2,1,1,0.5,0.5,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
        pnlTables.setLayout(pnlMaltsLayout);
{
          pnlTables.add(pnlMalt);
          BorderLayout pnlMaltLayout1=new BorderLayout();
          pnlMalt.setBorder(BorderFactory.createTitledBorder(new LineBorder(new java.awt.Color(0,0,0),1,false),""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP,new java.awt.Font(""String_Node_Str"",1,12),new java.awt.Color(51,51,51)));
          pnlMalt.setLayout(pnlMaltLayout1);
{
            pnlMalt.add(jScrollPane1,BorderLayout.CENTER);
{
              maltTableModel=new MaltTableModel(this);
              maltTable=new SBTable(""String_Node_Str""){
                public String getToolTipText(                MouseEvent e){
                  java.awt.Point p=e.getPoint();
                  int rowIndex=rowAtPoint(p);
                  return SBStringUtils.multiLineToolTip(40,maltTableModel.getDescriptionAt(rowIndex));
                }
              }
;
              jScrollPane1.setViewportView(maltTable);
              maltTable.setModel(maltTableModel);
              maltTable.getTableHeader().setReorderingAllowed(false);
              TableColumn maltColumn=maltTable.getColumnModel().getColumn(2);
              SmartComboBox.enable(maltComboBox);
              maltComboBox.setModel(cmbMaltModel);
              maltColumn.setCellEditor(new SBComboBoxCellEditor(maltComboBox));
              maltColumn=maltTable.getColumnModel().getColumn(3);
              maltColumn.setCellEditor(maltAmountEditor);
              SmartComboBox.enable(maltUnitsComboBox);
              maltUnitsComboBox.setModel(cmbMaltUnitsModel);
              maltColumn=maltTable.getColumnModel().getColumn(4);
              maltColumn.setCellEditor(new SBComboBoxCellEditor(maltUnitsComboBox));
            }
          }
{
            pnlMalt.add(tblMaltTotals,BorderLayout.SOUTH);
            tblMaltTotals.setModel(tblMaltTotalsModel);
            tblMaltTotals.getTableHeader().setEnabled(false);
            tblMaltTotals.setAutoCreateColumnsFromModel(false);
            SmartComboBox.enable(maltTotalUnitsComboBox);
            maltTotalUnitsComboModel.setList(Quantity.getListofUnits(""String_Node_Str""));
            maltTotalUnitsComboBox.setModel(maltTotalUnitsComboModel);
            TableColumn t=tblMaltTotals.getColumnModel().getColumn(4);
            t.setCellEditor(new SBComboBoxCellEditor(maltTotalUnitsComboBox));
          }
        }
{
          pnlTables.add(pnlMaltButtons);
          FlowLayout pnlMaltButtonsLayout=new FlowLayout();
          pnlMaltButtonsLayout.setAlignment(FlowLayout.LEFT);
          pnlMaltButtonsLayout.setVgap(0);
          pnlMaltButtons.setLayout(pnlMaltButtonsLayout);
          pnlMaltButtons.setPreferredSize(new java.awt.Dimension(592,27));
{
            pnlMaltButtons.add(tlbMalt);
            tlbMalt.setPreferredSize(new java.awt.Dimension(386,20));
            tlbMalt.setFloatable(false);
{
              tlbMalt.add(btnAddMalt);
              btnAddMalt.setText(""String_Node_Str"");
            }
{
              tlbMalt.add(btnDelMalt);
              btnDelMalt.setText(""String_Node_Str"");
            }
          }
        }
{
          BorderLayout pnlHopsLayout=new BorderLayout();
          pnlHops.setBorder(BorderFactory.createTitledBorder(new LineBorder(new java.awt.Color(0,0,0),1,false),""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP,new java.awt.Font(""String_Node_Str"",1,12),new java.awt.Color(51,51,51)));
          pnlHops.setLayout(pnlHopsLayout);
          pnlTables.add(pnlHops);
{
            pnlHops.add(tblHopsTotals,BorderLayout.SOUTH);
            tblHopsTotals.setModel(tblHopsTotalsModel);
            tblHopsTotals.setAutoCreateColumnsFromModel(false);
            SmartComboBox.enable(hopsTotalUnitsComboBox);
            hopsTotalUnitsComboModel.setList(Quantity.getListofUnits(""String_Node_Str""));
            hopsTotalUnitsComboBox.setModel(hopsTotalUnitsComboModel);
            TableColumn t=tblHopsTotals.getColumnModel().getColumn(4);
            t.setCellEditor(new SBComboBoxCellEditor(hopsTotalUnitsComboBox));
          }
{
            pnlHops.add(jScrollPane2,BorderLayout.CENTER);
{
              hopsTableModel=new HopsTableModel(this);
              hopsTable=new SBTable(""String_Node_Str""){
                public String getToolTipText(                MouseEvent e){
                  java.awt.Point p=e.getPoint();
                  int rowIndex=rowAtPoint(p);
                  return SBStringUtils.multiLineToolTip(40,hopsTableModel.getDescriptionAt(rowIndex));
                }
              }
;
              jScrollPane2.setViewportView(hopsTable);
              hopsTable.setModel(hopsTableModel);
              hopsTable.getTableHeader().setReorderingAllowed(false);
              TableColumn hopColumn=hopsTable.getColumnModel().getColumn(0);
              SmartComboBox.enable(hopComboBox);
              hopComboBox.setModel(cmbHopsModel);
              hopColumn.setCellEditor(new SBComboBoxCellEditor(hopComboBox));
              hopColumn=hopsTable.getColumnModel().getColumn(2);
              hopColumn.setCellEditor(hopAcidEditor);
              hopColumn=hopsTable.getColumnModel().getColumn(3);
              hopColumn.setCellEditor(hopAmountEditor);
              SmartComboBox.enable(hopsUnitsComboBox);
              hopsUnitsComboBox.setModel(cmbHopsUnitsModel);
              hopColumn=hopsTable.getColumnModel().getColumn(4);
              hopColumn.setCellEditor(new SBComboBoxCellEditor(hopsUnitsComboBox));
              JComboBox hopsFormComboBox=new JComboBox(Hop.forms);
              SmartComboBox.enable(hopsFormComboBox);
              hopColumn=hopsTable.getColumnModel().getColumn(1);
              hopColumn.setCellEditor(new SBComboBoxCellEditor(hopsFormComboBox));
              JComboBox hopsAddComboBox=new JComboBox(Hop.addTypes);
              SmartComboBox.enable(hopsAddComboBox);
              hopColumn=hopsTable.getColumnModel().getColumn(5);
              hopColumn.setCellEditor(new SBComboBoxCellEditor(hopsAddComboBox));
              hopColumn=hopsTable.getColumnModel().getColumn(6);
              hopColumn.setCellEditor(hopTimeEditor);
            }
          }
        }
{
          FlowLayout pnlHopsButtonsLayout=new FlowLayout();
          pnlHopsButtonsLayout.setAlignment(FlowLayout.LEFT);
          pnlHopsButtonsLayout.setVgap(0);
          pnlHopsButtons.setLayout(pnlHopsButtonsLayout);
          pnlTables.add(pnlHopsButtons);
          pnlHopsButtons.setPreferredSize(new java.awt.Dimension(512,16));
{
            pnlHopsButtons.add(tlbHops);
            tlbHops.setPreferredSize(new java.awt.Dimension(413,19));
            tlbHops.setFloatable(false);
{
              tlbHops.add(btnAddHop);
              btnAddHop.setText(""String_Node_Str"");
              btnAddHop.addActionListener(this);
            }
{
              tlbHops.add(btnDelHop);
              btnDelHop.setText(""String_Node_Str"");
              btnDelHop.addActionListener(this);
            }
          }
        }
      }
{
        FlowLayout statusPanelLayout=new FlowLayout();
        statusPanelLayout.setAlignment(FlowLayout.LEFT);
        statusPanelLayout.setHgap(2);
        statusPanelLayout.setVgap(2);
        statusPanel.setLayout(statusPanelLayout);
        pnlMain.add(statusPanel,new GridBagConstraints(0,3,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
{
          statusPanel.add(fileNamePanel);
          fileNamePanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
{
            fileNamePanel.add(fileNameLabel);
            fileNameLabel.setText(""String_Node_Str"");
            fileNameLabel.setFont(new java.awt.Font(""String_Node_Str"",1,10));
          }
        }
{
          statusPanel.add(ibuMethodPanel);
          ibuMethodPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
{
            ibuMethodPanel.add(ibuMethodLabel);
            ibuMethodLabel.setText(""String_Node_Str"");
            ibuMethodLabel.setFont(new java.awt.Font(""String_Node_Str"",1,10));
          }
        }
{
          statusPanel.add(alcMethodPanel);
          alcMethodPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
{
            alcMethodPanel.add(alcMethodLabel);
            alcMethodLabel.setText(""String_Node_Str"");
            alcMethodLabel.setFont(new java.awt.Font(""String_Node_Str"",1,10));
          }
        }
      }
    }
{
      setJMenuBar(mainMenuBar);
{
        mainMenuBar.add(fileMenu);
        fileMenu.setText(""String_Node_Str"");
{
          fileMenu.add(newFileMenuItem);
          newFileMenuItem.setText(""String_Node_Str"");
        }
{
          fileMenu.add(openFileMenuItem);
          openFileMenuItem.setText(""String_Node_Str"");
          openFileMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O,ActionEvent.CTRL_MASK));
        }
{
          imgURL=getClass().getClassLoader().getResource(""String_Node_Str"");
          icon=new ImageIcon(imgURL);
          findFileMenuItem.setIcon(icon);
          findFileMenuItem.setText(""String_Node_Str"");
          findFileMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F,ActionEvent.CTRL_MASK));
          fileMenu.add(findFileMenuItem);
        }
{
          imgURL=getClass().getClassLoader().getResource(""String_Node_Str"");
          icon=new ImageIcon(imgURL);
          saveMenuItem.setText(""String_Node_Str"");
          saveMenuItem.setIcon(icon);
          fileMenu.add(saveMenuItem);
          saveMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S,ActionEvent.CTRL_MASK));
        }
{
          imgURL=getClass().getClassLoader().getResource(""String_Node_Str"");
          icon=new ImageIcon(imgURL);
          saveAsMenuItem.setText(""String_Node_Str"");
          saveAsMenuItem.setIcon(icon);
          fileMenu.add(saveAsMenuItem);
        }
{
          fileMenu.add(exportMenu);
          exportMenu.setText(""String_Node_Str"");
{
            exportMenu.add(exportHTMLmenu);
            exportHTMLmenu.setText(""String_Node_Str"");
            exportMenu.add(exportTextMenuItem);
            exportTextMenuItem.setText(""String_Node_Str"");
          }
        }
{
          fileMenu.add(clipboardMenuItem);
          imgURL=getClass().getClassLoader().getResource(""String_Node_Str"");
          icon=new ImageIcon(imgURL);
          printMenuItem.setIcon(icon);
          fileMenu.add(printMenuItem);
        }
{
          fileMenu.add(jSeparator2);
        }
{
          fileMenu.add(exitMenuItem);
          exitMenuItem.setText(""String_Node_Str"");
          exitMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Q,ActionEvent.CTRL_MASK));
        }
      }
{
        mainMenuBar.add(editMenu);
        editMenu.setText(""String_Node_Str"");
{
          editMenu.add(editPrefsMenuItem);
          editPrefsMenuItem.setText(""String_Node_Str"");
        }
{
          editMenu.add(jSeparator1);
        }
{
          editMenu.add(deleteMenuItem);
          deleteMenuItem.setText(""String_Node_Str"");
          deleteMenuItem.setEnabled(false);
        }
      }
{
        mainMenuBar.add(mnuTools);
        mnuTools.setText(""String_Node_Str"");
{
          mnuTools.add(scaleRecipeMenuItem);
          scaleRecipeMenuItem.setText(""String_Node_Str"");
          scaleRecipeMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_R,ActionEvent.CTRL_MASK));
          mnuTools.add(maltPercentMenuItem);
          maltPercentMenuItem.setText(""String_Node_Str"");
          maltPercentMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_M,ActionEvent.CTRL_MASK));
          mnuTools.add(refractometerMenuItem);
          refractometerMenuItem.setText(""String_Node_Str"");
          mnuTools.add(extractPotentialMenuItem);
          extractPotentialMenuItem.setText(""String_Node_Str"");
          mnuTools.add(hydrometerToolMenuItem);
          hydrometerToolMenuItem.setText(""String_Node_Str"");
          mnuTools.add(conversionToolMenuItem);
          conversionToolMenuItem.setText(""String_Node_Str"");
        }
      }
{
        mainMenuBar.add(helpMenu);
        helpMenu.setText(""String_Node_Str"");
{
          helpMenu.add(helpMenuItem);
          helpMenuItem.setText(""String_Node_Str"");
        }
{
          helpMenu.add(aboutMenuItem);
          aboutMenuItem.setText(""String_Node_Str"");
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","private void initGUI(){
  try {
    this.setSize(preferences.getIProperty(""String_Node_Str""),preferences.getIProperty(""String_Node_Str""));
    this.setLocation(preferences.getIProperty(""String_Node_Str""),preferences.getIProperty(""String_Node_Str""));
    imgURL=getClass().getClassLoader().getResource(""String_Node_Str"");
    icon=new ImageIcon(imgURL);
    this.setIconImage(icon.getImage());
    this.setTitle(""String_Node_Str"" + version + ""String_Node_Str""+ edition+ ""String_Node_Str"");
    this.addWindowListener(new WindowAdapter(){
      public void windowClosed(      WindowEvent evt){
        System.exit(1);
      }
    }
);
{
      GridBagLayout jPanel2Layout=new GridBagLayout();
      jPanel2Layout.columnWeights=new double[]{0.1};
      jPanel2Layout.columnWidths=new int[]{7};
      jPanel2Layout.rowWeights=new double[]{0.1,0.1,0.9,0.1};
      pnlMain.setLayout(jPanel2Layout);
      this.getContentPane().add(pnlMain,BorderLayout.CENTER);
{
        pnlMain.add(jTabbedPane1,new GridBagConstraints(0,1,1,1,0.1,0.1,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
{
          GridBagLayout pnlDetailsLayout=new GridBagLayout();
          pnlDetailsLayout.columnWeights=new double[]{0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1};
          pnlDetailsLayout.columnWidths=new int[]{7,7,7,7,7,7,7,7,7,7};
          pnlDetailsLayout.rowWeights=new double[]{0.1,0.1,0.1,0.1,0.1,0.1,0.1};
          pnlDetailsLayout.rowHeights=new int[]{7,7,7,7,7,7,7};
          pnlDetails.setLayout(pnlDetailsLayout);
          pnlDetails.setPreferredSize(new java.awt.Dimension(20,16));
{
            pnlDetails.add(lblBrewer,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblBrewer.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(brewerNameText,new GridBagConstraints(1,0,2,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            brewerNameText.setPreferredSize(new java.awt.Dimension(69,20));
            brewerNameText.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(lblDate,new GridBagConstraints(0,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblDate.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(lblStyle,new GridBagConstraints(0,2,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblStyle.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(lblYeast,new GridBagConstraints(0,3,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblYeast.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(lblPreBoil,new GridBagConstraints(0,4,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblPreBoil.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(lblFinalWortVol,new GridBagConstraints(0,5,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblFinalWortVol.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(lblEffic,new GridBagConstraints(3,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblEffic.setText(""String_Node_Str"");
            lblEffic.setPreferredSize(new java.awt.Dimension(31,14));
          }
{
            pnlDetails.add(lblAtten,new GridBagConstraints(3,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblAtten.setText(""String_Node_Str"");
            lblAtten.setPreferredSize(new java.awt.Dimension(34,14));
          }
{
            pnlDetails.add(lblOG,new GridBagConstraints(5,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblOG.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(lblFG,new GridBagConstraints(5,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblFG.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(lblIBU,new GridBagConstraints(7,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblIBU.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(lblAlc,new GridBagConstraints(7,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblAlc.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(lblColour,new GridBagConstraints(7,2,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblColour.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(txtDate,new GridBagConstraints(1,1,2,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            txtDate.setPreferredSize(new java.awt.Dimension(73,20));
            txtDate.setDateStyle(DateFormat.SHORT);
            txtDate.setLocale(preferences.getLocale());
          }
{
            SmartComboBox.enable(cmbStyle);
            pnlDetails.add(cmbStyle,new GridBagConstraints(1,2,5,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            cmbStyle.setModel(cmbStyleModel);
            cmbStyle.setMaximumSize(new java.awt.Dimension(100,32767));
            cmbStyle.setPreferredSize(new java.awt.Dimension(190,20));
          }
{
            pnlDetails.add(preBoilText,new GridBagConstraints(1,4,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            preBoilText.setText(""String_Node_Str"");
            preBoilText.setPreferredSize(new java.awt.Dimension(37,20));
          }
{
            pnlDetails.add(finalWortVolText,new GridBagConstraints(1,5,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            finalWortVolText.setText(""String_Node_Str"");
            finalWortVolText.setPreferredSize(new java.awt.Dimension(46,20));
          }
{
            pnlDetails.add(lblComments,new GridBagConstraints(6,4,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblComments.setText(""String_Node_Str"");
          }
{
            SpinnerNumberModel spnEfficModel=new SpinnerNumberModel(75.0,0.0,100.0,1.0);
            pnlDetails.add(spnEffic,new GridBagConstraints(4,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            spnEffic.setModel(spnEfficModel);
            spnEffic.setMaximumSize(new java.awt.Dimension(70,32767));
            spnEffic.addChangeListener(this);
            spnEffic.setEditor(new JSpinner.NumberEditor(spnEffic,""String_Node_Str""));
            spnEffic.getEditor().setPreferredSize(new java.awt.Dimension(28,16));
            spnEffic.setPreferredSize(new java.awt.Dimension(53,18));
          }
{
            SpinnerNumberModel spnAttenModel=new SpinnerNumberModel(75.0,0.0,100.0,1.0);
            pnlDetails.add(spnAtten,new GridBagConstraints(4,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            spnAtten.setModel(spnAttenModel);
            spnAtten.addChangeListener(this);
            spnAtten.setEditor(new JSpinner.NumberEditor(spnAtten,""String_Node_Str""));
            spnAtten.setPreferredSize(new java.awt.Dimension(49,20));
          }
{
            SpinnerNumberModel spnOgModel=new SpinnerNumberModel(1.000,0.900,2.000,0.001);
            pnlDetails.add(spnOG,new GridBagConstraints(6,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            spnOG.setModel(spnOgModel);
            spnOG.addChangeListener(this);
            spnOG.setEditor(new JSpinner.NumberEditor(spnOG,""String_Node_Str""));
            spnOG.getEditor().setPreferredSize(new java.awt.Dimension(20,16));
            spnOG.setPreferredSize(new java.awt.Dimension(67,18));
          }
{
            SpinnerNumberModel spnFgModel=new SpinnerNumberModel(1.000,0.900,2.000,0.001);
            pnlDetails.add(spnFG,new GridBagConstraints(6,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            spnFG.setModel(spnFgModel);
            spnFG.setEditor(new JSpinner.NumberEditor(spnFG,""String_Node_Str""));
            spnFG.setPreferredSize(new java.awt.Dimension(69,20));
            spnFG.addChangeListener(this);
          }
{
            pnlDetails.add(lblIBUvalue,new GridBagConstraints(8,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblIBUvalue.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(lblColourValue,new GridBagConstraints(8,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblColourValue.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(lblAlcValue,new GridBagConstraints(8,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblAlcValue.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(scpComments,new GridBagConstraints(7,4,3,2,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
{
              scpComments.setViewportView(txtComments);
              txtComments.setText(""String_Node_Str"");
              txtComments.setWrapStyleWord(true);
              txtComments.setLineWrap(true);
              scpComments.setPreferredSize(new java.awt.Dimension(263,40));
              txtComments.addFocusListener(this);
            }
          }
{
            SmartComboBox.enable(cmbYeast);
            pnlDetails.add(cmbYeast,new GridBagConstraints(1,3,5,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            cmbYeast.setModel(cmbYeastModel);
            cmbYeast.setPreferredSize(new java.awt.Dimension(193,20));
          }
{
            SmartComboBox.enable(cmbSizeUnits);
            pnlDetails.add(cmbSizeUnits,new GridBagConstraints(2,4,2,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            cmbSizeUnits.setModel(cmbSizeUnitsModel);
          }
{
            pnlDetails.add(lblSizeUnits,new GridBagConstraints(2,5,2,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            lblSizeUnits.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(boilTimeLable,new GridBagConstraints(4,4,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            boilTimeLable.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(evapLabel,new GridBagConstraints(4,5,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            evapLabel.setText(""String_Node_Str"");
          }
{
            pnlDetails.add(boilMinText,new GridBagConstraints(5,4,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            boilMinText.setText(""String_Node_Str"");
            boilMinText.setPreferredSize(new java.awt.Dimension(22,20));
          }
{
            pnlDetails.add(evapText,new GridBagConstraints(5,5,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            evapText.setText(""String_Node_Str"");
            evapText.setPreferredSize(new java.awt.Dimension(23,20));
          }
{
            SmartComboBox.enable(alcMethodCombo);
            pnlDetails.add(alcMethodCombo,new GridBagConstraints(9,0,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            alcMethodCombo.setPreferredSize(new java.awt.Dimension(71,20));
          }
{
            SmartComboBox.enable(ibuMethodCombo);
            pnlDetails.add(ibuMethodCombo,new GridBagConstraints(9,1,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            ibuMethodCombo.setPreferredSize(new java.awt.Dimension(72,20));
          }
{
            SmartComboBox.enable(colourMethodCombo);
            pnlDetails.add(colourMethodCombo,new GridBagConstraints(9,2,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            colourMethodCombo.setPreferredSize(new java.awt.Dimension(52,20));
          }
          ComboBoxModel evapMethodComboModel=new DefaultComboBoxModel(new String[]{""String_Node_Str"",""String_Node_Str""});
{
            pnlMain.add(jPanel1,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            FlowLayout jPanel1Layout=new FlowLayout();
            jPanel1Layout.setAlignment(FlowLayout.LEFT);
            jPanel1.setLayout(jPanel1Layout);
            getContentPane().add(mainToolBar,BorderLayout.NORTH);
            mainToolBar.setFloatable(false);
            mainToolBar.setRollover(true);
            mainToolBar.add(saveButton);
            saveButton.setMnemonic(java.awt.event.KeyEvent.VK_S);
            saveButton.setIcon(new ImageIcon(getClass().getClassLoader().getResource(""String_Node_Str"")));
            saveButton.setToolTipText(""String_Node_Str"");
            mainToolBar.add(findButton);
            findButton.setIcon(new ImageIcon(getClass().getClassLoader().getResource(""String_Node_Str"")));
            findButton.setToolTipText(""String_Node_Str"");
            mainToolBar.add(printButton);
            printButton.setIcon(new ImageIcon(getClass().getClassLoader().getResource(""String_Node_Str"")));
            printButton.setToolTipText(""String_Node_Str"");
            mainToolBar.add(copyButton);
            copyButton.setIcon(new ImageIcon(getClass().getClassLoader().getResource(""String_Node_Str"")));
            copyButton.setToolTipText(""String_Node_Str"");
{
              jPanel1.add(lblName);
              lblName.setText(""String_Node_Str"");
            }
{
              jPanel1.add(txtName);
              txtName.setText(""String_Node_Str"");
              txtName.setPreferredSize(new java.awt.Dimension(297,20));
            }
          }
          SmartComboBox.enable(evapMethodCombo);
          pnlDetails.add(evapMethodCombo,new GridBagConstraints(6,5,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
          evapMethodCombo.setModel(evapMethodComboModel);
          evapMethodCombo.setPreferredSize(new java.awt.Dimension(64,20));
          pnlDetails.add(colourPanel,new GridBagConstraints(9,3,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
          colourPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
          colourPanel.setPreferredSize(new java.awt.Dimension(93,32));
        }
{
          jTabbedPane1.addTab(""String_Node_Str"",null,pnlDetails,null);
          jTabbedPane1.addTab(""String_Node_Str"",null,stylePanel,null);
          jTabbedPane1.addTab(""String_Node_Str"",null,miscPanel,null);
          jTabbedPane1.addTab(""String_Node_Str"",null,notesPanel,null);
          jTabbedPane1.addTab(""String_Node_Str"",null,dilutionPanel,null);
          jTabbedPane1.addTab(""String_Node_Str"",null,mashPanel,null);
          jTabbedPane1.addTab(""String_Node_Str"",null,fermentPanel,null);
          jTabbedPane1.addTab(""String_Node_Str"",null,carbPanel,null);
          jTabbedPane1.addTab(""String_Node_Str"",null,waterPanel,null);
          jTabbedPane1.addTab(""String_Node_Str"",null,costPanel,null);
          jTabbedPane1.addTab(""String_Node_Str"",null,settingsPanel,null);
          jTabbedPane1.addChangeListener(this);
        }
      }
{
        BoxLayout pnlMaltsLayout=new BoxLayout(pnlTables,javax.swing.BoxLayout.Y_AXIS);
        pnlMain.add(pnlTables,new GridBagConstraints(0,2,1,1,0.5,0.5,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
        pnlTables.setLayout(pnlMaltsLayout);
{
          pnlTables.add(pnlMalt);
          BorderLayout pnlMaltLayout1=new BorderLayout();
          pnlMalt.setBorder(BorderFactory.createTitledBorder(new LineBorder(new java.awt.Color(0,0,0),1,false),""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP,new java.awt.Font(""String_Node_Str"",1,12),new java.awt.Color(51,51,51)));
          pnlMalt.setLayout(pnlMaltLayout1);
{
            pnlMalt.add(jScrollPane1,BorderLayout.CENTER);
{
              maltTableModel=new MaltTableModel(this);
              maltTable=new SBTable(""String_Node_Str""){
                public String getToolTipText(                MouseEvent e){
                  java.awt.Point p=e.getPoint();
                  int rowIndex=rowAtPoint(p);
                  return SBStringUtils.multiLineToolTip(40,maltTableModel.getDescriptionAt(rowIndex));
                }
              }
;
              jScrollPane1.setViewportView(maltTable);
              maltTable.setModel(maltTableModel);
              maltTable.getTableHeader().setReorderingAllowed(false);
              TableColumn maltColumn=maltTable.getColumnModel().getColumn(2);
              SmartComboBox.enable(maltComboBox);
              maltComboBox.setModel(cmbMaltModel);
              maltColumn.setCellEditor(new SBComboBoxCellEditor(maltComboBox));
              maltColumn=maltTable.getColumnModel().getColumn(3);
              maltColumn.setCellEditor(maltAmountEditor);
              SmartComboBox.enable(maltUnitsComboBox);
              maltUnitsComboBox.setModel(cmbMaltUnitsModel);
              maltColumn=maltTable.getColumnModel().getColumn(4);
              maltColumn.setCellEditor(new SBComboBoxCellEditor(maltUnitsComboBox));
            }
          }
{
            pnlMalt.add(tblMaltTotals,BorderLayout.SOUTH);
            tblMaltTotals.setModel(tblMaltTotalsModel);
            tblMaltTotals.getTableHeader().setEnabled(false);
            tblMaltTotals.setAutoCreateColumnsFromModel(false);
            SmartComboBox.enable(maltTotalUnitsComboBox);
            maltTotalUnitsComboModel.setList(Quantity.getListofUnits(""String_Node_Str""));
            maltTotalUnitsComboBox.setModel(maltTotalUnitsComboModel);
            TableColumn t=tblMaltTotals.getColumnModel().getColumn(4);
            t.setCellEditor(new SBComboBoxCellEditor(maltTotalUnitsComboBox));
          }
        }
{
          pnlTables.add(pnlMaltButtons);
          FlowLayout pnlMaltButtonsLayout=new FlowLayout();
          pnlMaltButtonsLayout.setAlignment(FlowLayout.LEFT);
          pnlMaltButtonsLayout.setVgap(0);
          pnlMaltButtons.setLayout(pnlMaltButtonsLayout);
          pnlMaltButtons.setPreferredSize(new java.awt.Dimension(592,27));
{
            pnlMaltButtons.add(tlbMalt);
            tlbMalt.setPreferredSize(new java.awt.Dimension(386,20));
            tlbMalt.setFloatable(false);
{
              tlbMalt.add(btnAddMalt);
              btnAddMalt.setText(""String_Node_Str"");
            }
{
              tlbMalt.add(btnDelMalt);
              btnDelMalt.setText(""String_Node_Str"");
            }
          }
        }
{
          BorderLayout pnlHopsLayout=new BorderLayout();
          pnlHops.setBorder(BorderFactory.createTitledBorder(new LineBorder(new java.awt.Color(0,0,0),1,false),""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP,new java.awt.Font(""String_Node_Str"",1,12),new java.awt.Color(51,51,51)));
          pnlHops.setLayout(pnlHopsLayout);
          pnlTables.add(pnlHops);
{
            pnlHops.add(tblHopsTotals,BorderLayout.SOUTH);
            tblHopsTotals.setModel(tblHopsTotalsModel);
            tblHopsTotals.setAutoCreateColumnsFromModel(false);
            SmartComboBox.enable(hopsTotalUnitsComboBox);
            hopsTotalUnitsComboModel.setList(Quantity.getListofUnits(""String_Node_Str""));
            hopsTotalUnitsComboBox.setModel(hopsTotalUnitsComboModel);
            TableColumn t=tblHopsTotals.getColumnModel().getColumn(4);
            t.setCellEditor(new SBComboBoxCellEditor(hopsTotalUnitsComboBox));
          }
{
            pnlHops.add(jScrollPane2,BorderLayout.CENTER);
{
              hopsTableModel=new HopsTableModel(this);
              hopsTable=new SBTable(""String_Node_Str""){
                public String getToolTipText(                MouseEvent e){
                  java.awt.Point p=e.getPoint();
                  int rowIndex=rowAtPoint(p);
                  return SBStringUtils.multiLineToolTip(40,hopsTableModel.getDescriptionAt(rowIndex));
                }
              }
;
              jScrollPane2.setViewportView(hopsTable);
              hopsTable.setModel(hopsTableModel);
              hopsTable.getTableHeader().setReorderingAllowed(false);
              TableColumn hopColumn=hopsTable.getColumnModel().getColumn(0);
              SmartComboBox.enable(hopComboBox);
              hopComboBox.setModel(cmbHopsModel);
              hopColumn.setCellEditor(new SBComboBoxCellEditor(hopComboBox));
              hopColumn=hopsTable.getColumnModel().getColumn(2);
              hopColumn.setCellEditor(hopAcidEditor);
              hopColumn=hopsTable.getColumnModel().getColumn(3);
              hopColumn.setCellEditor(hopAmountEditor);
              SmartComboBox.enable(hopsUnitsComboBox);
              hopsUnitsComboBox.setModel(cmbHopsUnitsModel);
              hopColumn=hopsTable.getColumnModel().getColumn(4);
              hopColumn.setCellEditor(new SBComboBoxCellEditor(hopsUnitsComboBox));
              JComboBox hopsFormComboBox=new JComboBox(Hop.forms);
              SmartComboBox.enable(hopsFormComboBox);
              hopColumn=hopsTable.getColumnModel().getColumn(1);
              hopColumn.setCellEditor(new SBComboBoxCellEditor(hopsFormComboBox));
              JComboBox hopsAddComboBox=new JComboBox(Hop.addTypes);
              SmartComboBox.enable(hopsAddComboBox);
              hopColumn=hopsTable.getColumnModel().getColumn(5);
              hopColumn.setCellEditor(new SBComboBoxCellEditor(hopsAddComboBox));
              hopColumn=hopsTable.getColumnModel().getColumn(6);
              hopColumn.setCellEditor(hopTimeEditor);
            }
          }
        }
{
          FlowLayout pnlHopsButtonsLayout=new FlowLayout();
          pnlHopsButtonsLayout.setAlignment(FlowLayout.LEFT);
          pnlHopsButtonsLayout.setVgap(0);
          pnlHopsButtons.setLayout(pnlHopsButtonsLayout);
          pnlTables.add(pnlHopsButtons);
          pnlHopsButtons.setPreferredSize(new java.awt.Dimension(512,16));
{
            pnlHopsButtons.add(tlbHops);
            tlbHops.setPreferredSize(new java.awt.Dimension(413,19));
            tlbHops.setFloatable(false);
{
              tlbHops.add(btnAddHop);
              btnAddHop.setText(""String_Node_Str"");
              btnAddHop.addActionListener(this);
            }
{
              tlbHops.add(btnDelHop);
              btnDelHop.setText(""String_Node_Str"");
              btnDelHop.addActionListener(this);
            }
          }
        }
      }
{
        FlowLayout statusPanelLayout=new FlowLayout();
        statusPanelLayout.setAlignment(FlowLayout.LEFT);
        statusPanelLayout.setHgap(2);
        statusPanelLayout.setVgap(2);
        statusPanel.setLayout(statusPanelLayout);
        pnlMain.add(statusPanel,new GridBagConstraints(0,3,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
{
          statusPanel.add(fileNamePanel);
          fileNamePanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
{
            fileNamePanel.add(fileNameLabel);
            fileNameLabel.setText(""String_Node_Str"");
            fileNameLabel.setFont(new java.awt.Font(""String_Node_Str"",1,10));
          }
        }
{
          statusPanel.add(ibuMethodPanel);
          ibuMethodPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
{
            ibuMethodPanel.add(ibuMethodLabel);
            ibuMethodLabel.setText(""String_Node_Str"");
            ibuMethodLabel.setFont(new java.awt.Font(""String_Node_Str"",1,10));
          }
        }
{
          statusPanel.add(alcMethodPanel);
          alcMethodPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
{
            alcMethodPanel.add(alcMethodLabel);
            alcMethodLabel.setText(""String_Node_Str"");
            alcMethodLabel.setFont(new java.awt.Font(""String_Node_Str"",1,10));
          }
        }
      }
    }
{
      setJMenuBar(mainMenuBar);
{
        mainMenuBar.add(fileMenu);
        fileMenu.setText(""String_Node_Str"");
{
          fileMenu.add(newFileMenuItem);
          newFileMenuItem.setText(""String_Node_Str"");
        }
{
          fileMenu.add(openFileMenuItem);
          openFileMenuItem.setText(""String_Node_Str"");
          openFileMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O,ActionEvent.CTRL_MASK));
        }
{
          imgURL=getClass().getClassLoader().getResource(""String_Node_Str"");
          icon=new ImageIcon(imgURL);
          findFileMenuItem.setIcon(icon);
          findFileMenuItem.setText(""String_Node_Str"");
          findFileMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F,ActionEvent.CTRL_MASK));
          fileMenu.add(findFileMenuItem);
        }
{
          imgURL=getClass().getClassLoader().getResource(""String_Node_Str"");
          icon=new ImageIcon(imgURL);
          saveMenuItem.setText(""String_Node_Str"");
          saveMenuItem.setIcon(icon);
          fileMenu.add(saveMenuItem);
          saveMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S,ActionEvent.CTRL_MASK));
        }
{
          imgURL=getClass().getClassLoader().getResource(""String_Node_Str"");
          icon=new ImageIcon(imgURL);
          saveAsMenuItem.setText(""String_Node_Str"");
          saveAsMenuItem.setIcon(icon);
          fileMenu.add(saveAsMenuItem);
        }
{
          fileMenu.add(exportMenu);
          exportMenu.setText(""String_Node_Str"");
{
            exportMenu.add(exportHTMLmenu);
            exportHTMLmenu.setText(""String_Node_Str"");
            exportMenu.add(exportTextMenuItem);
            exportTextMenuItem.setText(""String_Node_Str"");
          }
        }
{
          fileMenu.add(clipboardMenuItem);
          imgURL=getClass().getClassLoader().getResource(""String_Node_Str"");
          icon=new ImageIcon(imgURL);
          printMenuItem.setIcon(icon);
          fileMenu.add(printMenuItem);
        }
{
          fileMenu.add(jSeparator2);
        }
{
          fileMenu.add(exitMenuItem);
          exitMenuItem.setText(""String_Node_Str"");
          exitMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Q,ActionEvent.CTRL_MASK));
        }
      }
{
        mainMenuBar.add(editMenu);
        editMenu.setText(""String_Node_Str"");
{
          editMenu.add(editPrefsMenuItem);
          editPrefsMenuItem.setText(""String_Node_Str"");
        }
{
          editMenu.add(jSeparator1);
        }
{
          editMenu.add(deleteMenuItem);
          deleteMenuItem.setText(""String_Node_Str"");
          deleteMenuItem.setEnabled(false);
        }
      }
{
        mainMenuBar.add(mnuTools);
        mnuTools.setText(""String_Node_Str"");
{
          mnuTools.add(scaleRecipeMenuItem);
          scaleRecipeMenuItem.setText(""String_Node_Str"");
          scaleRecipeMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_R,ActionEvent.CTRL_MASK));
          mnuTools.add(maltPercentMenuItem);
          maltPercentMenuItem.setText(""String_Node_Str"");
          maltPercentMenuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_M,ActionEvent.CTRL_MASK));
          mnuTools.add(refractometerMenuItem);
          refractometerMenuItem.setText(""String_Node_Str"");
          mnuTools.add(extractPotentialMenuItem);
          extractPotentialMenuItem.setText(""String_Node_Str"");
          mnuTools.add(hydrometerToolMenuItem);
          hydrometerToolMenuItem.setText(""String_Node_Str"");
          mnuTools.add(conversionToolMenuItem);
          conversionToolMenuItem.setText(""String_Node_Str"");
        }
      }
{
        mainMenuBar.add(helpMenu);
        helpMenu.setText(""String_Node_Str"");
{
          helpMenu.add(helpMenuItem);
          helpMenuItem.setText(""String_Node_Str"");
        }
{
          helpMenu.add(aboutMenuItem);
          aboutMenuItem.setText(""String_Node_Str"");
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
50518,"public void attachRecipeData(){
  cmbStyleModel.addOrInsert(myRecipe.getStyleObj());
  cmbYeastModel.addOrInsert(myRecipe.getYeastObj());
  cmbSizeUnitsModel.addOrInsert(myRecipe.getVolUnits());
  maltTableModel.setData(myRecipe);
  hopsTableModel.setData(myRecipe);
  miscPanel.setData(myRecipe);
  notesPanel.setData(myRecipe);
  stylePanel.setData(myRecipe);
  dilutionPanel.setData(myRecipe);
  mashPanel.setData(myRecipe);
  waterPanel.setData(myRecipe);
  costPanel.setData(myRecipe);
  settingsPanel.setData(myRecipe);
  fermentPanel.setData(myRecipe);
  carbPanel.setData(myRecipe);
  waterTreatmentPanel.setData(myRecipe);
  maltTable.updateUI();
  hopsTable.updateUI();
  alcMethodComboModel.setSelectedItem(myRecipe.getAlcMethod());
  ibuMethodComboModel.setSelectedItem(myRecipe.getIBUMethod());
  colourMethodCombo.setSelectedItem(myRecipe.getColourMethod());
  evapMethodCombo.setSelectedItem(myRecipe.getEvapMethod());
  Yeast y=(Yeast)cmbYeastModel.getSelectedItem();
  String st=SBStringUtils.multiLineToolTip(40,y.getDescription());
  cmbYeast.setToolTipText(st);
  Style s=(Style)cmbStyleModel.getSelectedItem();
  st=SBStringUtils.multiLineToolTip(40,s.getDescription());
  cmbStyle.setToolTipText(st);
  myRecipe.setVersion(version);
}","public void attachRecipeData(){
  cmbStyleModel.addOrInsert(myRecipe.getStyleObj());
  cmbYeastModel.addOrInsert(myRecipe.getYeastObj());
  cmbSizeUnitsModel.addOrInsert(myRecipe.getVolUnits());
  maltTableModel.setData(myRecipe);
  hopsTableModel.setData(myRecipe);
  miscPanel.setData(myRecipe);
  notesPanel.setData(myRecipe);
  stylePanel.setData(myRecipe);
  dilutionPanel.setData(myRecipe);
  mashPanel.setData(myRecipe);
  waterPanel.setData(myRecipe);
  costPanel.setData(myRecipe);
  settingsPanel.setData(myRecipe);
  fermentPanel.setData(myRecipe);
  carbPanel.setData(myRecipe);
  maltTable.updateUI();
  hopsTable.updateUI();
  alcMethodComboModel.setSelectedItem(myRecipe.getAlcMethod());
  ibuMethodComboModel.setSelectedItem(myRecipe.getIBUMethod());
  colourMethodCombo.setSelectedItem(myRecipe.getColourMethod());
  evapMethodCombo.setSelectedItem(myRecipe.getEvapMethod());
  Yeast y=(Yeast)cmbYeastModel.getSelectedItem();
  String st=SBStringUtils.multiLineToolTip(40,y.getDescription());
  cmbYeast.setToolTipText(st);
  Style s=(Style)cmbStyleModel.getSelectedItem();
  st=SBStringUtils.multiLineToolTip(40,s.getDescription());
  cmbStyle.setToolTipText(st);
  myRecipe.setVersion(version);
}"
50519,"public void stateChanged(ChangeEvent e){
  if (dontUpdate) {
    return;
  }
  Object o=e.getSource();
  if (o == jTabbedPane1) {
    JTabbedPane pane=(JTabbedPane)o;
    Component tab=pane.getSelectedComponent();
    if (tab == pnlDetails) {
      displayRecipe();
    }
 else     if (tab == stylePanel) {
      stylePanel.setStyleData();
    }
 else     if (tab == miscPanel) {
    }
 else     if (tab == notesPanel) {
    }
 else     if (tab == dilutionPanel) {
      dilutionPanel.displayDilution();
    }
 else     if (tab == mashPanel) {
      mashPanel.displayMash();
    }
 else     if (tab == waterTreatmentPanel) {
      waterTreatmentPanel.displayWaterTreatment();
    }
 else     if (tab == fermentPanel) {
      fermentPanel.displayFerment();
    }
 else     if (tab == carbPanel) {
      carbPanel.displayCarb();
    }
 else     if (tab == waterPanel) {
      waterPanel.displayWater();
    }
 else     if (tab == costPanel) {
      costPanel.displayCost();
    }
 else     if (tab == settingsPanel) {
    }
  }
 else   if (o == spnAtten) {
    myRecipe.setAttenuation(Double.parseDouble(spnAtten.getValue().toString()));
    displayRecipe();
  }
 else   if (o == spnOG) {
    myRecipe.setEstOg(Double.parseDouble(spnOG.getValue().toString()));
    displayRecipe();
  }
 else   if (o == spnFG) {
    myRecipe.setEstFg(Double.parseDouble(spnFG.getValue().toString()));
    displayRecipe();
  }
 else   if (o == spnEffic) {
    myRecipe.setEfficiency(Double.parseDouble(spnEffic.getValue().toString()));
    displayRecipe();
  }
}","public void stateChanged(ChangeEvent e){
  if (dontUpdate) {
    return;
  }
  Object o=e.getSource();
  if (o == jTabbedPane1) {
    JTabbedPane pane=(JTabbedPane)o;
    Component tab=pane.getSelectedComponent();
    if (tab == pnlDetails) {
      displayRecipe();
    }
 else     if (tab == stylePanel) {
      stylePanel.setStyleData();
    }
 else     if (tab == miscPanel) {
    }
 else     if (tab == notesPanel) {
    }
 else     if (tab == dilutionPanel) {
      dilutionPanel.displayDilution();
    }
 else     if (tab == mashPanel) {
      mashPanel.displayMash();
    }
 else     if (tab == fermentPanel) {
      fermentPanel.displayFerment();
    }
 else     if (tab == carbPanel) {
      carbPanel.displayCarb();
    }
 else     if (tab == waterPanel) {
      waterPanel.displayWater();
    }
 else     if (tab == costPanel) {
      costPanel.displayCost();
    }
 else     if (tab == settingsPanel) {
    }
  }
 else   if (o == spnAtten) {
    myRecipe.setAttenuation(Double.parseDouble(spnAtten.getValue().toString()));
    displayRecipe();
  }
 else   if (o == spnOG) {
    myRecipe.setEstOg(Double.parseDouble(spnOG.getValue().toString()));
    displayRecipe();
  }
 else   if (o == spnFG) {
    myRecipe.setEstFg(Double.parseDouble(spnFG.getValue().toString()));
    displayRecipe();
  }
 else   if (o == spnEffic) {
    myRecipe.setEfficiency(Double.parseDouble(spnEffic.getValue().toString()));
    displayRecipe();
  }
}"
50520,"public void actionPerformed(ActionEvent e){
  Object o=e.getSource();
  if (o == kettleTxt) {
    double x=SBStringUtils.round(myRecipe.getKettleLoss(myRecipe.getVolUnits()),2);
    double y=SBStringUtils.round(Double.parseDouble(kettleTxt.getText()),2);
    if (x != y) {
      myRecipe.setKettleLoss(new Quantity(myRecipe.getVolUnits(),Double.parseDouble(kettleTxt.getText())));
    }
  }
 else   if (o == miscLossTxt) {
    double x=SBStringUtils.round(myRecipe.getMiscLoss(myRecipe.getVolUnits()),2);
    double y=SBStringUtils.round(Double.parseDouble(miscLossTxt.getText()),2);
    if (x != y) {
      myRecipe.setKettleLoss(new Quantity(myRecipe.getVolUnits(),Double.parseDouble(miscLossTxt.getText())));
    }
  }
 else   if (o == trubLossTxt) {
    double x=SBStringUtils.round(myRecipe.getTrubLoss(myRecipe.getVolUnits()),2);
    double y=SBStringUtils.round(Double.parseDouble(trubLossTxt.getText()),2);
    if (x != y) {
      myRecipe.setTrubLoss(new Quantity(myRecipe.getVolUnits(),Double.parseDouble(trubLossTxt.getText())));
    }
  }
 else   if (o == collectTxt) {
    double x=SBStringUtils.round(myRecipe.getPreBoilVol(myRecipe.getVolUnits()),2);
    double y=SBStringUtils.round(Double.parseDouble(collectTxt.getText()),2);
    if (x != y) {
      myRecipe.setPreBoil(new Quantity(myRecipe.getVolUnits(),Double.parseDouble(collectTxt.getText())));
    }
  }
 else   if (o == postBoilTxt) {
    double x=SBStringUtils.round(myRecipe.getPostBoilVol(myRecipe.getVolUnits()),2);
    double y=SBStringUtils.round(Double.parseDouble(postBoilTxt.getText()),2);
    if (x != y) {
      myRecipe.setPostBoil(new Quantity(myRecipe.getVolUnits(),Double.parseDouble(postBoilTxt.getText())));
    }
  }
 else   if (o == finalVolTxt) {
    double x=SBStringUtils.round(myRecipe.getFinalWortVol(myRecipe.getVolUnits()),2);
    double y=SBStringUtils.round(Double.parseDouble(finalVolTxt.getText()),2);
    if (x != y) {
      myRecipe.setFinalWortVol(new Quantity(myRecipe.getVolUnits(),Double.parseDouble(finalVolTxt.getText())));
    }
  }
  displayWater();
}","public void actionPerformed(ActionEvent e){
  Object o=e.getSource();
  if (o == kettleTxt) {
    double x=SBStringUtils.round(myRecipe.getKettleLoss(myRecipe.getVolUnits()),2);
    double y=SBStringUtils.round(Double.parseDouble(kettleTxt.getText()),2);
    if (x != y) {
      myRecipe.setKettleLoss(new Quantity(myRecipe.getVolUnits(),Double.parseDouble(kettleTxt.getText())));
    }
  }
 else   if (o == miscLossTxt) {
    double x=SBStringUtils.round(myRecipe.getMiscLoss(myRecipe.getVolUnits()),2);
    double y=SBStringUtils.round(Double.parseDouble(miscLossTxt.getText()),2);
    if (x != y) {
      myRecipe.setMiscLoss(new Quantity(myRecipe.getVolUnits(),Double.parseDouble(miscLossTxt.getText())));
    }
  }
 else   if (o == trubLossTxt) {
    double x=SBStringUtils.round(myRecipe.getTrubLoss(myRecipe.getVolUnits()),2);
    double y=SBStringUtils.round(Double.parseDouble(trubLossTxt.getText()),2);
    if (x != y) {
      myRecipe.setTrubLoss(new Quantity(myRecipe.getVolUnits(),Double.parseDouble(trubLossTxt.getText())));
    }
  }
 else   if (o == collectTxt) {
    double x=SBStringUtils.round(myRecipe.getPreBoilVol(myRecipe.getVolUnits()),2);
    double y=SBStringUtils.round(Double.parseDouble(collectTxt.getText()),2);
    if (x != y) {
      myRecipe.setPreBoil(new Quantity(myRecipe.getVolUnits(),Double.parseDouble(collectTxt.getText())));
    }
  }
 else   if (o == postBoilTxt) {
    double x=SBStringUtils.round(myRecipe.getPostBoilVol(myRecipe.getVolUnits()),2);
    double y=SBStringUtils.round(Double.parseDouble(postBoilTxt.getText()),2);
    if (x != y) {
      myRecipe.setPostBoil(new Quantity(myRecipe.getVolUnits(),Double.parseDouble(postBoilTxt.getText())));
    }
  }
 else   if (o == finalVolTxt) {
    double x=SBStringUtils.round(myRecipe.getFinalWortVol(myRecipe.getVolUnits()),2);
    double y=SBStringUtils.round(Double.parseDouble(finalVolTxt.getText()),2);
    if (x != y) {
      myRecipe.setFinalWortVol(new Quantity(myRecipe.getVolUnits(),Double.parseDouble(finalVolTxt.getText())));
    }
  }
  displayWater();
}"
50521,"public void setCost(String c){
  if (c.substring(0,1).equals(""String_Node_Str"")) {
    c=c.substring(1,c.length());
  }
  try {
    costPerU=Double.parseDouble(c);
  }
 catch (  NumberFormatException m) {
    Debug.print(""String_Node_Str"" + c);
  }
}","public void setCost(String c){
  if (c.substring(0,1).equals(""String_Node_Str"")) {
    c=c.substring(1,c.length());
  }
  try {
    NumberFormat format=NumberFormat.getInstance(Locale.getDefault());
    Number number=format.parse(c.trim());
    costPerU=number.doubleValue();
  }
 catch (  NumberFormatException m) {
    Debug.print(""String_Node_Str"" + c);
  }
catch (  ParseException e) {
    Debug.print(""String_Node_Str"" + c);
  }
}"
50522,"/** 
 * Handles a string of the form ""d u"", where d is a double amount, and u is a string of units.  For importing the quantity attribute from QBrew xml.
 * @param a
 */
public void setAmountAndUnits(String a){
  int i=a.indexOf(""String_Node_Str"");
  String d=a.substring(0,i);
  String u=a.substring(i);
  Double dAmount=0.0;
  try {
    dAmount=Double.parseDouble(d.trim());
  }
 catch (  NumberFormatException m) {
    Debug.print(""String_Node_Str"" + d + ""String_Node_Str"");
    return;
  }
  amount.setAmount(dAmount);
  amount.setUnits(u.trim());
}","/** 
 * Handles a string of the form ""d u"", where d is a double amount, and u is a string of units.  For importing the quantity attribute from QBrew xml.
 * @param a
 */
public void setAmountAndUnits(String a){
  int i=a.indexOf(""String_Node_Str"");
  String d=a.substring(0,i);
  String u=a.substring(i);
  Double dAmount=0.0;
  try {
    NumberFormat format=NumberFormat.getInstance(Locale.getDefault());
    Number number=format.parse(d.trim());
    dAmount=number.doubleValue();
  }
 catch (  NumberFormatException m) {
    Debug.print(""String_Node_Str"" + d + ""String_Node_Str"");
    return;
  }
catch (  ParseException e) {
    Debug.print(""String_Node_Str"" + d + ""String_Node_Str"");
    return;
  }
  amount.setAmount(dAmount);
  amount.setUnits(u.trim());
}"
50523,"public int getIProperty(String key){
  if (props.getProperty(key) != null) {
    try {
      return Integer.parseInt(props.getProperty(key));
    }
 catch (    NumberFormatException m) {
      Debug.print(key + ""String_Node_Str"" + props.getProperty(key));
    }
  }
 else {
    Debug.print(""String_Node_Str"" + key);
  }
  return 0;
}","public int getIProperty(String key){
  if (props.getProperty(key) != null) {
    try {
      NumberFormat format=NumberFormat.getInstance(Locale.getDefault());
      Number number=format.parse(props.getProperty(key));
      return number.intValue();
    }
 catch (    NumberFormatException m) {
      Debug.print(key + ""String_Node_Str"" + props.getProperty(key));
    }
catch (    ParseException e) {
      Debug.print(key + ""String_Node_Str"" + props.getProperty(key));
    }
  }
 else {
    Debug.print(""String_Node_Str"" + key);
  }
  return 0;
}"
50524,"public double getDProperty(String key){
  try {
    return Double.parseDouble(props.getProperty(key));
  }
 catch (  NumberFormatException m) {
    Debug.print(""String_Node_Str"" + key + ""String_Node_Str""+ ""String_Node_Str""+ props.getProperty(key));
  }
  return 0.0;
}","public double getDProperty(String key){
  try {
    NumberFormat format=NumberFormat.getInstance(Locale.getDefault());
    Number number=format.parse(props.getProperty(key));
    return number.doubleValue();
  }
 catch (  NumberFormatException m) {
    Debug.print(""String_Node_Str"" + key + ""String_Node_Str""+ ""String_Node_Str""+ props.getProperty(key));
  }
catch (  ParseException e) {
    Debug.print(""String_Node_Str"" + key + ""String_Node_Str""+ ""String_Node_Str""+ props.getProperty(key));
  }
  return 0.0;
}"
50525,"public float getFProperty(String key){
  try {
    return Float.parseFloat(props.getProperty(key));
  }
 catch (  NumberFormatException m) {
    Debug.print(""String_Node_Str"" + key + ""String_Node_Str""+ ""String_Node_Str""+ props.getProperty(key));
  }
  return (float)0.0;
}","public float getFProperty(String key){
  try {
    NumberFormat format=NumberFormat.getInstance(Locale.getDefault());
    Number number=format.parse(props.getProperty(key));
    return number.floatValue();
  }
 catch (  NumberFormatException m) {
    Debug.print(""String_Node_Str"" + key + ""String_Node_Str""+ ""String_Node_Str""+ props.getProperty(key));
  }
catch (  ParseException e) {
    Debug.print(""String_Node_Str"" + key + ""String_Node_Str""+ ""String_Node_Str""+ props.getProperty(key));
  }
  return (float)0.0;
}"
50526,"public void actionPerformed(ActionEvent e){
  Object o=e.getSource();
  if (myRecipe != null) {
    if (o == comboPrime) {
      updatePrimeSugar((String)comboPrime.getSelectedItem(),myRecipe.getPrimeSugarU());
      displayCarb();
    }
 else     if (o == textBottleTemp) {
      try {
        myRecipe.setBottleTemp(Double.parseDouble(textBottleTemp.getText()));
      }
 catch (      NumberFormatException m) {
        Debug.print(""String_Node_Str"");
        textBottleTemp.setText(Double.toString(myRecipe.getBottleTemp()));
      }
      displayCarb();
      updatePrimeSugar((String)comboPrime.getSelectedItem(),myRecipe.getPrimeSugarU());
    }
 else     if (o == textServTemp) {
      try {
        myRecipe.setServTemp(Double.parseDouble(textServTemp.getText()));
      }
 catch (      NumberFormatException m) {
        Debug.print(""String_Node_Str"");
        textServTemp.setText(Double.toString(myRecipe.getServTemp()));
      }
      displayCarb();
      updatePrimeSugar((String)comboPrime.getSelectedItem(),myRecipe.getPrimeSugarU());
    }
 else     if (o == checkKegged) {
      myRecipe.setKegged(checkKegged.isSelected());
      displayCarb();
    }
 else     if (o == comboTubingID) {
      String tubeID=(String)comboTubingID.getSelectedItem();
      Options.getInstance().setProperty(""String_Node_Str"",tubeID);
      displayCarb();
    }
 else     if (o == textHeight) {
      try {
        double height=Double.parseDouble(textHeight.getText());
        Options.getInstance().setDProperty(""String_Node_Str"",height);
      }
 catch (      NumberFormatException m) {
        Debug.print(""String_Node_Str"");
        textHeight.setText(Double.toString(Options.getInstance().getDProperty(""String_Node_Str"")));
      }
      displayCarb();
    }
 else     if (o == textTargetVol) {
      try {
        myRecipe.setTargetVol(Double.parseDouble(textTargetVol.getText()));
      }
 catch (      NumberFormatException m) {
        Debug.print(""String_Node_Str"");
        textTargetVol.setText(Double.toString(myRecipe.getTargetVol()));
      }
      displayCarb();
    }
  }
}","public void actionPerformed(ActionEvent e){
  Object o=e.getSource();
  if (myRecipe != null) {
    if (o == comboPrime) {
      updatePrimeSugar((String)comboPrime.getSelectedItem(),myRecipe.getPrimeSugarU());
      displayCarb();
    }
 else     if (o == textBottleTemp) {
      try {
        NumberFormat format=NumberFormat.getInstance(Locale.getDefault());
        Number number=format.parse(textBottleTemp.getText().trim());
        myRecipe.setBottleTemp(number.doubleValue());
      }
 catch (      NumberFormatException m) {
        Debug.print(""String_Node_Str"");
        textBottleTemp.setText(Double.toString(myRecipe.getBottleTemp()));
      }
catch (      ParseException m) {
        Debug.print(""String_Node_Str"");
        textBottleTemp.setText(Double.toString(myRecipe.getBottleTemp()));
      }
      displayCarb();
      updatePrimeSugar((String)comboPrime.getSelectedItem(),myRecipe.getPrimeSugarU());
    }
 else     if (o == textServTemp) {
      try {
        NumberFormat format=NumberFormat.getInstance(Locale.getDefault());
        Number number=format.parse(textServTemp.getText().trim());
        myRecipe.setServTemp(number.doubleValue());
      }
 catch (      NumberFormatException m) {
        Debug.print(""String_Node_Str"");
        textServTemp.setText(Double.toString(myRecipe.getServTemp()));
      }
catch (      ParseException m) {
        Debug.print(""String_Node_Str"");
        textServTemp.setText(Double.toString(myRecipe.getServTemp()));
      }
      displayCarb();
      updatePrimeSugar((String)comboPrime.getSelectedItem(),myRecipe.getPrimeSugarU());
    }
 else     if (o == checkKegged) {
      myRecipe.setKegged(checkKegged.isSelected());
      displayCarb();
    }
 else     if (o == comboTubingID) {
      String tubeID=(String)comboTubingID.getSelectedItem();
      Options.getInstance().setProperty(""String_Node_Str"",tubeID);
      displayCarb();
    }
 else     if (o == textHeight) {
      try {
        NumberFormat format=NumberFormat.getInstance(Locale.getDefault());
        Number number=format.parse(textHeight.getText().trim());
        Options.getInstance().setDProperty(""String_Node_Str"",number.doubleValue());
      }
 catch (      NumberFormatException m) {
        Debug.print(""String_Node_Str"");
        textHeight.setText(Double.toString(Options.getInstance().getDProperty(""String_Node_Str"")));
      }
catch (      ParseException m) {
        Debug.print(""String_Node_Str"");
        textHeight.setText(Double.toString(Options.getInstance().getDProperty(""String_Node_Str"")));
      }
      displayCarb();
    }
 else     if (o == textTargetVol) {
      try {
        NumberFormat format=NumberFormat.getInstance(Locale.getDefault());
        Number number=format.parse(textTargetVol.getText().trim());
        myRecipe.setTargetVol(number.doubleValue());
      }
 catch (      NumberFormatException m) {
        Debug.print(""String_Node_Str"");
        textTargetVol.setText(Double.toString(myRecipe.getTargetVol()));
      }
catch (      ParseException m) {
        Debug.print(""String_Node_Str"");
        textTargetVol.setText(Double.toString(myRecipe.getTargetVol()));
      }
      displayCarb();
    }
  }
}"
50527,"public void actionPerformed(ActionEvent e){
  Object o=e.getSource();
  if (o == yeastTxt) {
    try {
      myRecipe.getYeastObj().setCost(SBStringUtils.myNF.parse(yeastTxt.getText()).doubleValue());
    }
 catch (    ParseException e1) {
      e1.printStackTrace();
    }
    displayCost();
  }
  if (o == otherTxt) {
    try {
      myRecipe.setOtherCost(SBStringUtils.myNF.parse(otherTxt.getText()).doubleValue());
    }
 catch (    ParseException e1) {
      e1.printStackTrace();
    }
    displayCost();
  }
  if (o == bottleSizeTxt) {
    try {
      myRecipe.setBottleSize(Double.parseDouble(bottleSizeTxt.getText()));
    }
 catch (    NumberFormatException m) {
      Debug.print(""String_Node_Str"");
      bottleSizeTxt.setText(Double.toString(myRecipe.getBottleSize()));
    }
    displayCost();
  }
  if (o == bottleSizeUCmb) {
    myRecipe.setBottleU(bottleSizeUCmbModel.getSelectedItem().toString());
    displayCost();
  }
}","public void actionPerformed(ActionEvent e){
  Object o=e.getSource();
  if (o == yeastTxt) {
    try {
      myRecipe.getYeastObj().setCost(SBStringUtils.myNF.parse(yeastTxt.getText()).doubleValue());
    }
 catch (    ParseException e1) {
      e1.printStackTrace();
    }
    displayCost();
  }
  if (o == otherTxt) {
    try {
      myRecipe.setOtherCost(SBStringUtils.myNF.parse(otherTxt.getText()).doubleValue());
    }
 catch (    ParseException e1) {
      e1.printStackTrace();
    }
    displayCost();
  }
  if (o == bottleSizeTxt) {
    try {
      NumberFormat format=NumberFormat.getInstance(Locale.getDefault());
      Number number=format.parse(bottleSizeTxt.getText().trim());
      myRecipe.setBottleSize(number.doubleValue());
    }
 catch (    NumberFormatException m) {
      Debug.print(""String_Node_Str"");
      bottleSizeTxt.setText(Double.toString(myRecipe.getBottleSize()));
    }
catch (    ParseException m) {
      Debug.print(""String_Node_Str"");
      bottleSizeTxt.setText(Double.toString(myRecipe.getBottleSize()));
    }
    displayCost();
  }
  if (o == bottleSizeUCmb) {
    myRecipe.setBottleU(bottleSizeUCmbModel.getSelectedItem().toString());
    displayCost();
  }
}"
50528,"public void stateChanged(ChangeEvent e){
  if (dontUpdate == true) {
    return;
  }
  Object o=e.getSource();
  if (myRecipe != null) {
    if (o == postBoilText) {
      try {
        myRecipe.setPostBoil(new Quantity(myRecipe.getVolUnits(),Double.parseDouble(postBoilText.getValue().toString())));
      }
 catch (      NumberFormatException m) {
        Debug.print(""String_Node_Str"");
        postBoilText.setValue(myRecipe.getPostBoilVol().toString());
      }
      displayDilution();
    }
  }
}","public void stateChanged(ChangeEvent e){
  if (dontUpdate == true) {
    return;
  }
  Object o=e.getSource();
  if (myRecipe != null) {
    if (o == postBoilText) {
      try {
        NumberFormat format=NumberFormat.getInstance(Locale.getDefault());
        Number number=format.parse(postBoilText.toString().trim());
        myRecipe.setPostBoil(new Quantity(myRecipe.getVolUnits(),number.doubleValue()));
      }
 catch (      NumberFormatException m) {
        Debug.print(""String_Node_Str"");
        postBoilText.setValue(myRecipe.getPostBoilVol().toString());
      }
catch (      ParseException m) {
        Debug.print(""String_Node_Str"");
        postBoilText.setValue(myRecipe.getPostBoilVol().toString());
      }
      displayDilution();
    }
  }
}"
50529,"public void setValueAt(Object value,int row,int col){
  try {
switch (col) {
case 0:
      data.setFermentStepType(row,value.toString());
case 1:
    try {
      data.setFermentStepTime(row,Integer.parseInt(value.toString()));
    }
 catch (    NumberFormatException m) {
      m.printStackTrace();
    }
  break;
case 2:
try {
  data.setFermentStepTemp(row,Double.parseDouble(value.toString()));
}
 catch (NumberFormatException m) {
  m.printStackTrace();
}
break;
case 3:
data.setFermentStepTempU(row,value.toString());
break;
}
}
 catch (Exception e) {
}
;
data.calcFermentTotals();
fireTableCellUpdated(row,col);
fireTableDataChanged();
}","public void setValueAt(Object value,int row,int col){
  try {
switch (col) {
case 0:
      data.setFermentStepType(row,value.toString());
case 1:
    try {
      NumberFormat format=NumberFormat.getInstance(Locale.getDefault());
      Number number=format.parse(value.toString().trim());
      data.setFermentStepTime(row,number.intValue());
    }
 catch (    NumberFormatException m) {
      m.printStackTrace();
    }
  break;
case 2:
try {
  NumberFormat format=NumberFormat.getInstance(Locale.getDefault());
  Number number=format.parse(value.toString().trim());
  data.setFermentStepTemp(row,number.doubleValue());
}
 catch (NumberFormatException m) {
  m.printStackTrace();
}
break;
case 3:
data.setFermentStepTempU(row,value.toString());
break;
}
}
 catch (Exception e) {
}
;
data.calcFermentTotals();
fireTableCellUpdated(row,col);
fireTableDataChanged();
}"
50530,"public void setValueAt(Object value,int row,int col){
  try {
switch (col) {
case 0:
      data.setHopName(row,value.toString());
    if (value instanceof Hop) {
      Hop h=(Hop)value;
      data.setHopAlpha(row,h.getAlpha());
    }
  break;
case 1:
data.setHopType(row,value.toString());
break;
case 2:
try {
data.setHopAlpha(row,Double.parseDouble(value.toString()));
}
 catch (NumberFormatException m) {
Debug.print(""String_Node_Str"" + value.toString() + ""String_Node_Str"");
}
break;
case 3:
try {
data.setHopAmount(row,Double.parseDouble(value.toString()));
}
 catch (NumberFormatException m) {
Debug.print(""String_Node_Str"" + value.toString() + ""String_Node_Str"");
}
break;
case 4:
break;
case 5:
data.setHopAdd(row,value.toString());
break;
case 6:
try {
data.setHopMinutes(row,(int)Double.parseDouble(value.toString()));
}
 catch (NumberFormatException m) {
Debug.print(""String_Node_Str"" + value.toString() + ""String_Node_Str"");
}
break;
case 7:
break;
case 8:
data.setHopCost(row,value.toString());
break;
}
}
 catch (Exception e) {
}
;
app.myRecipe.calcHopsTotals();
fireTableCellUpdated(row,col);
fireTableDataChanged();
app.displayRecipe();
}","public void setValueAt(Object value,int row,int col){
  try {
switch (col) {
case 0:
      data.setHopName(row,value.toString());
    if (value instanceof Hop) {
      Hop h=(Hop)value;
      data.setHopAlpha(row,h.getAlpha());
    }
  break;
case 1:
data.setHopType(row,value.toString());
break;
case 2:
try {
NumberFormat format=NumberFormat.getInstance(Locale.getDefault());
Number number=format.parse(value.toString().trim());
data.setHopAlpha(row,number.doubleValue());
}
 catch (NumberFormatException m) {
Debug.print(""String_Node_Str"" + value.toString() + ""String_Node_Str"");
}
break;
case 3:
try {
NumberFormat format=NumberFormat.getInstance(Locale.getDefault());
Number number=format.parse(value.toString().trim());
data.setHopAmount(row,number.doubleValue());
}
 catch (NumberFormatException m) {
Debug.print(""String_Node_Str"" + value.toString() + ""String_Node_Str"");
}
break;
case 4:
break;
case 5:
data.setHopAdd(row,value.toString());
break;
case 6:
try {
NumberFormat format=NumberFormat.getInstance(Locale.getDefault());
Number number=format.parse(value.toString().trim());
data.setHopMinutes(row,number.intValue());
}
 catch (NumberFormatException m) {
Debug.print(""String_Node_Str"" + value.toString() + ""String_Node_Str"");
}
break;
case 7:
break;
case 8:
data.setHopCost(row,value.toString());
break;
}
}
 catch (Exception e) {
}
;
app.myRecipe.calcHopsTotals();
fireTableCellUpdated(row,col);
fireTableDataChanged();
app.displayRecipe();
}"
50531,"public void setValueAt(Object value,int row,int col){
  Debug.print(""String_Node_Str"" + row + ""String_Node_Str""+ col);
  try {
switch (col) {
case 0:
      data.setMaltSteep(row,new Boolean(value.toString()).booleanValue());
    break;
case 1:
  data.setMaltMashed(row,new Boolean(value.toString()).booleanValue());
break;
case 2:
data.setMaltName(row,value.toString());
if (value instanceof Fermentable) {
Fermentable m=(Fermentable)value;
data.setMaltPppg(row,m.getPppg());
data.setMaltLov(row,m.getLov());
data.setMaltSteep(row,m.getSteep());
data.setMaltMashed(row,m.getMashed());
}
break;
case 3:
try {
data.setMaltAmount(row,Double.parseDouble(value.toString()));
}
 catch (NumberFormatException m) {
Debug.print(""String_Node_Str"" + value.toString() + ""String_Node_Str"");
}
break;
case 4:
break;
case 5:
try {
data.setMaltPppg(row,Double.parseDouble(value.toString()));
}
 catch (NumberFormatException m) {
Debug.print(""String_Node_Str"" + value.toString() + ""String_Node_Str"");
}
break;
case 6:
try {
data.setMaltLov(row,Double.parseDouble(value.toString()));
}
 catch (NumberFormatException m) {
Debug.print(""String_Node_Str"" + value.toString() + ""String_Node_Str"");
}
break;
case 7:
data.setMaltCost(row,value.toString());
break;
case 8:
break;
}
}
 catch (Exception e) {
}
;
app.myRecipe.calcMaltTotals();
fireTableCellUpdated(row,col);
fireTableDataChanged();
app.displayRecipe();
}","public void setValueAt(Object value,int row,int col){
  Debug.print(""String_Node_Str"" + row + ""String_Node_Str""+ col);
  try {
switch (col) {
case 0:
      data.setMaltSteep(row,new Boolean(value.toString()).booleanValue());
    break;
case 1:
  data.setMaltMashed(row,new Boolean(value.toString()).booleanValue());
break;
case 2:
data.setMaltName(row,value.toString());
if (value instanceof Fermentable) {
Fermentable m=(Fermentable)value;
data.setMaltPppg(row,m.getPppg());
data.setMaltLov(row,m.getLov());
data.setMaltSteep(row,m.getSteep());
data.setMaltMashed(row,m.getMashed());
}
break;
case 3:
try {
NumberFormat format=NumberFormat.getInstance(Locale.getDefault());
Number number=format.parse(value.toString().trim());
data.setMaltAmount(row,number.doubleValue());
}
 catch (NumberFormatException m) {
Debug.print(""String_Node_Str"" + value.toString() + ""String_Node_Str"");
}
break;
case 4:
break;
case 5:
try {
NumberFormat format=NumberFormat.getInstance(Locale.getDefault());
Number number=format.parse(value.toString().trim());
data.setMaltPppg(row,number.doubleValue());
}
 catch (NumberFormatException m) {
Debug.print(""String_Node_Str"" + value.toString() + ""String_Node_Str"");
}
break;
case 6:
try {
NumberFormat format=NumberFormat.getInstance(Locale.getDefault());
Number number=format.parse(value.toString().trim());
data.setMaltLov(row,number.doubleValue());
}
 catch (NumberFormatException m) {
Debug.print(""String_Node_Str"" + value.toString() + ""String_Node_Str"");
}
break;
case 7:
data.setMaltCost(row,value.toString());
break;
case 8:
break;
}
}
 catch (Exception e) {
}
;
app.myRecipe.calcMaltTotals();
fireTableCellUpdated(row,col);
fireTableDataChanged();
app.displayRecipe();
}"
50532,"public void actionPerformed(ActionEvent e){
  if (dontUpdate) {
    return;
  }
  Object o=e.getSource();
  if (o == txtName)   myRecipe.setName(txtName.getText());
 else   if (o == brewerNameText)   myRecipe.setBrewer(brewerNameText.getText());
 else   if (o == preBoilText) {
    if (myRecipe.getPreBoilVol(myRecipe.getVolUnits()) != Double.parseDouble(preBoilText.getText())) {
      myRecipe.setPreBoil(new Quantity(myRecipe.getVolUnits(),Double.parseDouble(preBoilText.getText())));
      displayRecipe();
    }
  }
 else   if (o == finalWortVolText) {
    if (myRecipe.getFinalWortVol(myRecipe.getVolUnits()) != Double.parseDouble(finalWortVolText.getText())) {
      myRecipe.setPostBoil(new Quantity(myRecipe.getVolUnits(),Double.parseDouble(finalWortVolText.getText())));
      displayRecipe();
    }
  }
 else   if (o == evapText) {
    myRecipe.setEvap(Double.parseDouble(evapText.getText()));
    displayRecipe();
  }
 else   if (o == boilMinText) {
    String s=boilMinText.getText();
    if (s.indexOf('.') > 0) {
      s=s.substring(0,s.indexOf('.'));
    }
    myRecipe.setBoilMinutes(Integer.parseInt(s));
    displayRecipe();
  }
 else   if (o == maltTotalUnitsComboBox) {
    String u=(String)maltTotalUnitsComboModel.getSelectedItem();
    if (myRecipe != null) {
      myRecipe.setMaltUnits(u);
      displayRecipe();
    }
  }
 else   if (o == btnAddMalt) {
    if (myRecipe != null) {
      Fermentable f=new Fermentable(myRecipe.getMaltUnits());
      myRecipe.addMalt(f);
      maltTable.updateUI();
      displayRecipe();
    }
  }
 else   if (o == btnDelMalt) {
    if (myRecipe != null) {
      int i=maltTable.getSelectedRow();
      myRecipe.delMalt(i);
      maltTable.updateUI();
      displayRecipe();
    }
  }
 else   if (o == hopsTotalUnitsComboBox) {
    String u=(String)hopsTotalUnitsComboModel.getSelectedItem();
    if (myRecipe != null) {
      myRecipe.setHopsUnits(u);
      displayRecipe();
    }
  }
 else   if (o == btnAddHop) {
    if (myRecipe != null) {
      Hop h=new Hop(myRecipe.getHopUnits(),preferences.getProperty(""String_Node_Str""));
      myRecipe.addHop(h);
      hopsTable.updateUI();
      displayRecipe();
    }
  }
 else   if (o == btnDelHop) {
    if (myRecipe != null) {
      int i=hopsTable.getSelectedRow();
      myRecipe.delHop(i);
      hopsTable.updateUI();
      displayRecipe();
    }
  }
 else   if (o == cmbYeast) {
    Yeast y=(Yeast)cmbYeastModel.getSelectedItem();
    if (myRecipe != null && y != myRecipe.getYeastObj()) {
      myRecipe.setYeast(y);
    }
    String st=SBStringUtils.multiLineToolTip(40,y.getDescription());
    cmbYeast.setToolTipText(st);
  }
 else   if (o == cmbSizeUnits) {
    String q=(String)cmbSizeUnits.getSelectedItem();
    if (myRecipe != null && q != myRecipe.getVolUnits()) {
      myRecipe.setVolUnits(q);
      displayRecipe();
    }
  }
 else   if (o == alcMethodCombo) {
    recipeSettingsActionPerformed(e);
  }
 else   if (o == ibuMethodCombo) {
    recipeSettingsActionPerformed(e);
  }
 else   if (o == colourMethodCombo) {
    recipeSettingsActionPerformed(e);
  }
 else   if (o == evapMethodCombo) {
    recipeSettingsActionPerformed(e);
  }
 else   if (o == maltComboBox) {
    Fermentable f=(Fermentable)cmbMaltModel.getSelectedItem();
    int i=maltTable.getSelectedRow();
    if (myRecipe != null && i != -1) {
      Fermentable f2=myRecipe.getFermentable(i);
      if (f2 != null) {
        f2.setLov(f.getLov());
        f2.setPppg(f.getPppg());
        f2.setDescription(f.getDescription());
        f2.setMashed(f.getMashed());
        f2.setSteep(f.getSteep());
        f2.setCost(f.getCostPerU());
      }
    }
  }
 else   if (o == maltUnitsComboBox) {
    String u=(String)cmbMaltUnitsModel.getSelectedItem();
    int i=maltTable.getSelectedRow();
    if (myRecipe != null && i != -1) {
      Fermentable f2=myRecipe.getFermentable(i);
      if (f2 != null) {
        f2.convertTo(u);
        myRecipe.calcMaltTotals();
        displayRecipe();
      }
    }
  }
 else   if (o == hopComboBox) {
    Hop h=(Hop)cmbHopsModel.getSelectedItem();
    int i=hopsTable.getSelectedRow();
    if (myRecipe != null && i != -1) {
      Hop h2=myRecipe.getHop(i);
      h2.setAlpha(h.getAlpha());
      h2.setDescription(h.getDescription());
      h2.setCost(h.getCostPerU());
    }
  }
 else   if (o == hopsUnitsComboBox) {
    String u=(String)cmbHopsUnitsModel.getSelectedItem();
    int i=hopsTable.getSelectedRow();
    if (myRecipe != null && i != -1) {
      Hop h=myRecipe.getHop(i);
      h.convertTo(u);
      myRecipe.calcHopsTotals();
      displayRecipe();
    }
  }
 else   if (o == txtDate) {
    java.util.Date newDate=txtDate.getDate();
    java.util.Date oldDate=myRecipe.getCreated().getTime();
    if (!oldDate.equals(newDate)) {
      myRecipe.setCreated(newDate);
    }
  }
 else   if (o == cmbStyle) {
    Style st=(Style)cmbStyleModel.getSelectedItem();
    if (myRecipe != null && st != myRecipe.getStyleObj()) {
      myRecipe.setStyle(st);
      stylePanel.setStyle(st);
    }
    cmbStyle.setToolTipText(SBStringUtils.multiLineToolTip(50,st.getDescription()));
  }
 else   if (o == saveButton) {
    saveFile();
  }
 else   if (o == findButton) {
    FindDialog fd=new FindDialog(this);
    fd.setModal(true);
    fd.setVisible(true);
  }
 else   if (o == printButton) {
    PrintDialog pd=new PrintDialog(this);
    pd.setModal(true);
    pd.setVisible(true);
  }
 else   if (o == copyButton) {
    Clipboard clipboard=getToolkit().getSystemClipboard();
    StringSelection ss=new StringSelection(myRecipe.toText());
    clipboard.setContents(ss,ss);
  }
 else   if (o == aboutMenuItem) {
    aboutDlg=new AboutDialog(this,version + ""String_Node_Str"" + edition);
    aboutDlg.setVisible(true);
  }
 else   if (o == helpMenuItem) {
    String urlString=SBStringUtils.getAppPath(""String_Node_Str"") + ""String_Node_Str"";
    Debug.print(urlString);
    AbstractLogger logger=new SystemLogger();
    BrowserLauncher launcher;
    try {
      launcher=new BrowserLauncher(logger);
      BrowserLauncherRunner runner=new BrowserLauncherRunner(launcher,urlString,null);
      Thread launcherThread=new Thread(runner);
      launcherThread.start();
    }
 catch (    BrowserLaunchingInitializingException ex) {
      ex.printStackTrace();
    }
catch (    UnsupportedOperatingSystemException ex) {
      ex.printStackTrace();
    }
  }
 else   if (o == conversionToolMenuItem) {
    ConversionDialog convTool=new ConversionDialog(this);
    convTool.setModal(true);
    convTool.setVisible(true);
  }
 else   if (o == hydrometerToolMenuItem) {
    HydrometerToolDialog hydroTool=new HydrometerToolDialog(this);
    hydroTool.setModal(true);
    hydroTool.setVisible(true);
  }
 else   if (o == extractPotentialMenuItem) {
    PotentialExtractCalcDialog extCalc=new PotentialExtractCalcDialog(this);
    extCalc.setModal(true);
    extCalc.setVisible(true);
  }
 else   if (o == refractometerMenuItem) {
    RefractometerDialog refract=new RefractometerDialog(this);
    refract.setModal(true);
    refract.setVisible(true);
  }
 else   if (o == maltPercentMenuItem) {
    MaltPercentDialog maltPercent=new MaltPercentDialog(this);
    maltPercent.setModal(true);
    maltPercent.setVisible(true);
  }
 else   if (o == scalRecipeMenuItem) {
    ScaleRecipeDialog scaleRecipe=new ScaleRecipeDialog(this);
    scaleRecipe.setModal(true);
    scaleRecipe.setVisible(true);
  }
 else   if (o == editPrefsMenuItem) {
    PreferencesDialog d=new PreferencesDialog(this);
    d.setVisible(true);
  }
 else   if (o == exitMenuItem) {
    processWindowEvent(new WindowEvent(this,WindowEvent.WINDOW_CLOSING));
    System.exit(0);
  }
 else   if (o == printMenuItem) {
    PrintDialog pd=new PrintDialog(this);
    pd.setModal(true);
    pd.setVisible(true);
  }
 else   if (o == clipboardMenuItem) {
    Clipboard clipboard=getToolkit().getSystemClipboard();
    StringSelection s=new StringSelection(myRecipe.toText());
    clipboard.setContents(s,s);
  }
 else   if (o == exportTextMenuItem) {
    fileChooser.resetChoosableFileFilters();
    String[] ext={""String_Node_Str""};
    sbFileFilter saveFileFilter=new sbFileFilter(ext,""String_Node_Str"");
    fileChooser.setFileFilter(saveFileFilter);
    fileChooser.setSelectedFile(new File(myRecipe.getName() + ""String_Node_Str""));
    int returnVal=fileChooser.showSaveDialog(mainMenuBar);
    if (returnVal == JFileChooser.APPROVE_OPTION) {
      File file=fileChooser.getSelectedFile();
      try {
        FileWriter out=new FileWriter(file);
        out.write(myRecipe.toText());
        out.close();
      }
 catch (      Exception ex) {
        showError(ex);
      }
    }
 else {
      Debug.print(""String_Node_Str"");
    }
  }
 else   if (o == exportHTMLmenu) {
    fileChooser.resetChoosableFileFilters();
    String[] ext={""String_Node_Str"",""String_Node_Str""};
    sbFileFilter saveFileFilter=new sbFileFilter(ext,""String_Node_Str"");
    fileChooser.setFileFilter(saveFileFilter);
    fileChooser.setSelectedFile(new File(myRecipe.getName() + ""String_Node_Str""));
    int returnVal=fileChooser.showSaveDialog(mainMenuBar);
    if (returnVal == JFileChooser.APPROVE_OPTION) {
      File file=fileChooser.getSelectedFile();
      try {
        saveAsHTML(file,""String_Node_Str"",null);
      }
 catch (      Exception ex) {
        showError(ex);
      }
    }
 else {
      Debug.print(""String_Node_Str"");
    }
  }
 else   if (o == saveAsMenuItem) {
    saveAs();
  }
 else   if (o == saveMenuItem) {
    saveFile();
  }
 else   if (o == findFileMenuItem) {
    FindDialog fd=new FindDialog(this);
    fd.setModal(true);
    fd.setVisible(true);
  }
 else   if (o == openFileMenuItem) {
    fileChooser.resetChoosableFileFilters();
    String[] ext={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    String desc=""String_Node_Str"";
    sbFileFilter openFileFilter=new sbFileFilter(ext,desc);
    fileChooser.setFileFilter(openFileFilter);
    int returnVal=fileChooser.showOpenDialog(mainMenuBar);
    if (returnVal == JFileChooser.APPROVE_OPTION) {
      File file=fileChooser.getSelectedFile();
      Debug.print(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
      OpenImport oi=new OpenImport();
      myRecipe=oi.openFile(file);
      currentFile=file;
      if (oi.getFileType().equals(""String_Node_Str"")) {
        JOptionPane.showMessageDialog(null,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
      }
      if (oi.getFileType().equals(""String_Node_Str"")) {
        JOptionPane.showMessageDialog(null,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
      }
      attachRecipeData();
      checkIngredientsInDB();
      myRecipe.setDirty(false);
      myRecipe.calcMaltTotals();
      myRecipe.calcHopsTotals();
      myRecipe.mash.calcMashSchedule();
      displayRecipe();
    }
 else {
      Debug.print(""String_Node_Str"");
    }
  }
 else   if (o == newFileMenuItem) {
    setRecipe(new Recipe(),null);
    myRecipe.setDirty(false);
    displayRecipe();
  }
}","public void actionPerformed(ActionEvent e){
  if (dontUpdate) {
    return;
  }
  Object o=e.getSource();
  if (o == txtName)   myRecipe.setName(txtName.getText());
 else   if (o == brewerNameText)   myRecipe.setBrewer(brewerNameText.getText());
 else   if (o == preBoilText) {
    double x=round(myRecipe.getPreBoilVol(myRecipe.getVolUnits()),2);
    double y=round(Double.parseDouble(preBoilText.getText()),2);
    if (x != y) {
      Debug.print(""String_Node_Str"" + x + ""String_Node_Str""+ y);
      myRecipe.setPreBoil(new Quantity(myRecipe.getVolUnits(),Double.parseDouble(preBoilText.getText())));
      displayRecipe();
    }
  }
 else   if (o == finalWortVolText) {
    double x=round(myRecipe.getFinalWortVol(myRecipe.getVolUnits()),2);
    double y=round(Double.parseDouble(finalWortVolText.getText()),2);
    if (x != y) {
      Debug.print(""String_Node_Str"" + x + ""String_Node_Str""+ y);
      myRecipe.setPostBoil(new Quantity(myRecipe.getVolUnits(),Double.parseDouble(finalWortVolText.getText())));
      displayRecipe();
    }
  }
 else   if (o == evapText) {
    myRecipe.setEvap(Double.parseDouble(evapText.getText()));
    displayRecipe();
  }
 else   if (o == boilMinText) {
    String s=boilMinText.getText();
    if (s.indexOf('.') > 0) {
      s=s.substring(0,s.indexOf('.'));
    }
    myRecipe.setBoilMinutes(Integer.parseInt(s));
    displayRecipe();
  }
 else   if (o == maltTotalUnitsComboBox) {
    String u=(String)maltTotalUnitsComboModel.getSelectedItem();
    if (myRecipe != null) {
      myRecipe.setMaltUnits(u);
      displayRecipe();
    }
  }
 else   if (o == btnAddMalt) {
    if (myRecipe != null) {
      Fermentable f=new Fermentable(myRecipe.getMaltUnits());
      myRecipe.addMalt(f);
      maltTable.updateUI();
      displayRecipe();
    }
  }
 else   if (o == btnDelMalt) {
    if (myRecipe != null) {
      int i=maltTable.getSelectedRow();
      myRecipe.delMalt(i);
      maltTable.updateUI();
      displayRecipe();
    }
  }
 else   if (o == hopsTotalUnitsComboBox) {
    String u=(String)hopsTotalUnitsComboModel.getSelectedItem();
    if (myRecipe != null) {
      myRecipe.setHopsUnits(u);
      displayRecipe();
    }
  }
 else   if (o == btnAddHop) {
    if (myRecipe != null) {
      Hop h=new Hop(myRecipe.getHopUnits(),preferences.getProperty(""String_Node_Str""));
      myRecipe.addHop(h);
      hopsTable.updateUI();
      displayRecipe();
    }
  }
 else   if (o == btnDelHop) {
    if (myRecipe != null) {
      int i=hopsTable.getSelectedRow();
      myRecipe.delHop(i);
      hopsTable.updateUI();
      displayRecipe();
    }
  }
 else   if (o == cmbYeast) {
    Yeast y=(Yeast)cmbYeastModel.getSelectedItem();
    if (myRecipe != null && y != myRecipe.getYeastObj()) {
      myRecipe.setYeast(y);
    }
    String st=SBStringUtils.multiLineToolTip(40,y.getDescription());
    cmbYeast.setToolTipText(st);
  }
 else   if (o == cmbSizeUnits) {
    String q=(String)cmbSizeUnits.getSelectedItem();
    if (myRecipe != null && q != myRecipe.getVolUnits()) {
      myRecipe.setVolUnits(q);
      displayRecipe();
    }
  }
 else   if (o == alcMethodCombo) {
    recipeSettingsActionPerformed(e);
  }
 else   if (o == ibuMethodCombo) {
    recipeSettingsActionPerformed(e);
  }
 else   if (o == colourMethodCombo) {
    recipeSettingsActionPerformed(e);
  }
 else   if (o == evapMethodCombo) {
    recipeSettingsActionPerformed(e);
  }
 else   if (o == maltComboBox) {
    Fermentable f=(Fermentable)cmbMaltModel.getSelectedItem();
    int i=maltTable.getSelectedRow();
    if (myRecipe != null && i != -1) {
      Fermentable f2=myRecipe.getFermentable(i);
      if (f2 != null) {
        f2.setLov(f.getLov());
        f2.setPppg(f.getPppg());
        f2.setDescription(f.getDescription());
        f2.setMashed(f.getMashed());
        f2.setSteep(f.getSteep());
        f2.setCost(f.getCostPerU());
      }
    }
  }
 else   if (o == maltUnitsComboBox) {
    String u=(String)cmbMaltUnitsModel.getSelectedItem();
    int i=maltTable.getSelectedRow();
    if (myRecipe != null && i != -1) {
      Fermentable f2=myRecipe.getFermentable(i);
      if (f2 != null) {
        f2.convertTo(u);
        myRecipe.calcMaltTotals();
        displayRecipe();
      }
    }
  }
 else   if (o == hopComboBox) {
    Hop h=(Hop)cmbHopsModel.getSelectedItem();
    int i=hopsTable.getSelectedRow();
    if (myRecipe != null && i != -1) {
      Hop h2=myRecipe.getHop(i);
      h2.setAlpha(h.getAlpha());
      h2.setDescription(h.getDescription());
      h2.setCost(h.getCostPerU());
    }
  }
 else   if (o == hopsUnitsComboBox) {
    String u=(String)cmbHopsUnitsModel.getSelectedItem();
    int i=hopsTable.getSelectedRow();
    if (myRecipe != null && i != -1) {
      Hop h=myRecipe.getHop(i);
      h.convertTo(u);
      myRecipe.calcHopsTotals();
      displayRecipe();
    }
  }
 else   if (o == txtDate) {
    java.util.Date newDate=txtDate.getDate();
    java.util.Date oldDate=myRecipe.getCreated().getTime();
    if (!oldDate.equals(newDate)) {
      myRecipe.setCreated(newDate);
    }
  }
 else   if (o == cmbStyle) {
    Style st=(Style)cmbStyleModel.getSelectedItem();
    if (myRecipe != null && st != myRecipe.getStyleObj()) {
      myRecipe.setStyle(st);
      stylePanel.setStyle(st);
    }
    cmbStyle.setToolTipText(SBStringUtils.multiLineToolTip(50,st.getDescription()));
  }
 else   if (o == saveButton) {
    saveFile();
  }
 else   if (o == findButton) {
    FindDialog fd=new FindDialog(this);
    fd.setModal(true);
    fd.setVisible(true);
  }
 else   if (o == printButton) {
    PrintDialog pd=new PrintDialog(this);
    pd.setModal(true);
    pd.setVisible(true);
  }
 else   if (o == copyButton) {
    Clipboard clipboard=getToolkit().getSystemClipboard();
    StringSelection ss=new StringSelection(myRecipe.toText());
    clipboard.setContents(ss,ss);
  }
 else   if (o == aboutMenuItem) {
    aboutDlg=new AboutDialog(this,version + ""String_Node_Str"" + edition);
    aboutDlg.setVisible(true);
  }
 else   if (o == helpMenuItem) {
    String urlString=SBStringUtils.getAppPath(""String_Node_Str"") + ""String_Node_Str"";
    Debug.print(urlString);
    AbstractLogger logger=new SystemLogger();
    BrowserLauncher launcher;
    try {
      launcher=new BrowserLauncher(logger);
      BrowserLauncherRunner runner=new BrowserLauncherRunner(launcher,urlString,null);
      Thread launcherThread=new Thread(runner);
      launcherThread.start();
    }
 catch (    BrowserLaunchingInitializingException ex) {
      ex.printStackTrace();
    }
catch (    UnsupportedOperatingSystemException ex) {
      ex.printStackTrace();
    }
  }
 else   if (o == conversionToolMenuItem) {
    ConversionDialog convTool=new ConversionDialog(this);
    convTool.setModal(true);
    convTool.setVisible(true);
  }
 else   if (o == hydrometerToolMenuItem) {
    HydrometerToolDialog hydroTool=new HydrometerToolDialog(this);
    hydroTool.setModal(true);
    hydroTool.setVisible(true);
  }
 else   if (o == extractPotentialMenuItem) {
    PotentialExtractCalcDialog extCalc=new PotentialExtractCalcDialog(this);
    extCalc.setModal(true);
    extCalc.setVisible(true);
  }
 else   if (o == refractometerMenuItem) {
    RefractometerDialog refract=new RefractometerDialog(this);
    refract.setModal(true);
    refract.setVisible(true);
  }
 else   if (o == maltPercentMenuItem) {
    MaltPercentDialog maltPercent=new MaltPercentDialog(this);
    maltPercent.setModal(true);
    maltPercent.setVisible(true);
  }
 else   if (o == scalRecipeMenuItem) {
    ScaleRecipeDialog scaleRecipe=new ScaleRecipeDialog(this);
    scaleRecipe.setModal(true);
    scaleRecipe.setVisible(true);
  }
 else   if (o == editPrefsMenuItem) {
    PreferencesDialog d=new PreferencesDialog(this);
    d.setVisible(true);
  }
 else   if (o == exitMenuItem) {
    processWindowEvent(new WindowEvent(this,WindowEvent.WINDOW_CLOSING));
    System.exit(0);
  }
 else   if (o == printMenuItem) {
    PrintDialog pd=new PrintDialog(this);
    pd.setModal(true);
    pd.setVisible(true);
  }
 else   if (o == clipboardMenuItem) {
    Clipboard clipboard=getToolkit().getSystemClipboard();
    StringSelection s=new StringSelection(myRecipe.toText());
    clipboard.setContents(s,s);
  }
 else   if (o == exportTextMenuItem) {
    fileChooser.resetChoosableFileFilters();
    String[] ext={""String_Node_Str""};
    sbFileFilter saveFileFilter=new sbFileFilter(ext,""String_Node_Str"");
    fileChooser.setFileFilter(saveFileFilter);
    fileChooser.setSelectedFile(new File(myRecipe.getName() + ""String_Node_Str""));
    int returnVal=fileChooser.showSaveDialog(mainMenuBar);
    if (returnVal == JFileChooser.APPROVE_OPTION) {
      File file=fileChooser.getSelectedFile();
      try {
        FileWriter out=new FileWriter(file);
        out.write(myRecipe.toText());
        out.close();
      }
 catch (      Exception ex) {
        showError(ex);
      }
    }
 else {
      Debug.print(""String_Node_Str"");
    }
  }
 else   if (o == exportHTMLmenu) {
    fileChooser.resetChoosableFileFilters();
    String[] ext={""String_Node_Str"",""String_Node_Str""};
    sbFileFilter saveFileFilter=new sbFileFilter(ext,""String_Node_Str"");
    fileChooser.setFileFilter(saveFileFilter);
    fileChooser.setSelectedFile(new File(myRecipe.getName() + ""String_Node_Str""));
    int returnVal=fileChooser.showSaveDialog(mainMenuBar);
    if (returnVal == JFileChooser.APPROVE_OPTION) {
      File file=fileChooser.getSelectedFile();
      try {
        saveAsHTML(file,""String_Node_Str"",null);
      }
 catch (      Exception ex) {
        showError(ex);
      }
    }
 else {
      Debug.print(""String_Node_Str"");
    }
  }
 else   if (o == saveAsMenuItem) {
    saveAs();
  }
 else   if (o == saveMenuItem) {
    saveFile();
  }
 else   if (o == findFileMenuItem) {
    FindDialog fd=new FindDialog(this);
    fd.setModal(true);
    fd.setVisible(true);
  }
 else   if (o == openFileMenuItem) {
    fileChooser.resetChoosableFileFilters();
    String[] ext={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    String desc=""String_Node_Str"";
    sbFileFilter openFileFilter=new sbFileFilter(ext,desc);
    fileChooser.setFileFilter(openFileFilter);
    int returnVal=fileChooser.showOpenDialog(mainMenuBar);
    if (returnVal == JFileChooser.APPROVE_OPTION) {
      File file=fileChooser.getSelectedFile();
      Debug.print(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
      OpenImport oi=new OpenImport();
      myRecipe=oi.openFile(file);
      currentFile=file;
      if (oi.getFileType().equals(""String_Node_Str"")) {
        JOptionPane.showMessageDialog(null,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
      }
      if (oi.getFileType().equals(""String_Node_Str"")) {
        JOptionPane.showMessageDialog(null,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
      }
      attachRecipeData();
      checkIngredientsInDB();
      myRecipe.setDirty(false);
      myRecipe.calcMaltTotals();
      myRecipe.calcHopsTotals();
      myRecipe.mash.calcMashSchedule();
      displayRecipe();
    }
 else {
      Debug.print(""String_Node_Str"");
    }
  }
 else   if (o == newFileMenuItem) {
    setRecipe(new Recipe(),null);
    myRecipe.setDirty(false);
    displayRecipe();
  }
}"
50533,"public void displayRecipe(){
  if (myRecipe == null)   return;
  dontUpdate=true;
  txtName.setText(myRecipe.getName());
  brewerNameText.setText(myRecipe.getBrewer());
  preBoilText.setValue(new Double(myRecipe.getPreBoilVol(myRecipe.getVolUnits())));
  lblSizeUnits.setText(myRecipe.getVolUnits());
  finalWortVolText.setValue(new Double(myRecipe.getFinalWortVol(myRecipe.getVolUnits())));
  boilMinText.setText(SBStringUtils.format(myRecipe.getBoilMinutes(),0));
  evapText.setText(SBStringUtils.format(myRecipe.getEvap(),1));
  spnEffic.setValue(new Double(myRecipe.getEfficiency()));
  spnAtten.setValue(new Double(myRecipe.getAttenuation()));
  spnOG.setValue(new Double(myRecipe.getEstOg()));
  spnFG.setValue(new Double(myRecipe.getEstFg()));
  txtComments.setText(myRecipe.getComments());
  lblIBUvalue.setText(SBStringUtils.format(myRecipe.getIbu(),1));
  lblColourValue.setText(SBStringUtils.format(myRecipe.getColour(),1));
  lblAlcValue.setText(SBStringUtils.format(myRecipe.getAlcohol(),1));
  try {
    txtDate.setDate(myRecipe.getCreated().getTime());
  }
 catch (  PropertyVetoException e) {
    e.printStackTrace();
  }
  Costs=SBStringUtils.myNF.format(myRecipe.getTotalMaltCost());
  tblMaltTotalsModel.setDataVector(new String[][]{{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + SBStringUtils.format(myRecipe.getTotalMalt(),1),myRecipe.getMaltUnits(),""String_Node_Str"" + SBStringUtils.format(myRecipe.getEstOg(),3),""String_Node_Str"" + SBStringUtils.format(myRecipe.getColour(),1),Costs,""String_Node_Str""}},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  Costs=SBStringUtils.myNF.format(myRecipe.getTotalHopsCost());
  tblHopsTotalsModel.setDataVector(new String[][]{{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + SBStringUtils.format(myRecipe.getTotalHops(),1),myRecipe.getHopUnits(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + SBStringUtils.format(myRecipe.getIbu(),1),Costs}},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  String fileName=""String_Node_Str"";
  if (currentFile != null) {
    fileName=currentFile.getName();
  }
  fileNameLabel.setText(""String_Node_Str"" + fileName);
  ibuMethodLabel.setText(""String_Node_Str"" + myRecipe.getIBUMethod());
  alcMethodLabel.setText(""String_Node_Str"" + myRecipe.getAlcMethod());
  double colour=myRecipe.getColour(BrewCalcs.SRM);
  if (preferences.getProperty(""String_Node_Str"").equals(""String_Node_Str""))   colourPanel.setBackground(BrewCalcs.calcRGB(1,colour,preferences.getIProperty(""String_Node_Str""),preferences.getIProperty(""String_Node_Str""),preferences.getIProperty(""String_Node_Str""),preferences.getIProperty(""String_Node_Str"")));
 else   colourPanel.setBackground(BrewCalcs.calcRGB(2,colour,preferences.getIProperty(""String_Node_Str""),preferences.getIProperty(""String_Node_Str""),preferences.getIProperty(""String_Node_Str""),preferences.getIProperty(""String_Node_Str"")));
  String title=""String_Node_Str"" + version + ""String_Node_Str""+ edition;
  String file=""String_Node_Str"";
  String dirty=""String_Node_Str"";
  if (currentFile != null) {
    file=""String_Node_Str"" + currentFile.getAbsolutePath();
  }
 else {
    file=""String_Node_Str"";
  }
  if (myRecipe.getDirty()) {
    dirty=""String_Node_Str"";
  }
 else {
    dirty=""String_Node_Str"";
  }
  this.setTitle(title + file + dirty);
  dontUpdate=false;
}","public void displayRecipe(){
  if (myRecipe == null)   return;
  dontUpdate=true;
  txtName.setText(myRecipe.getName());
  brewerNameText.setText(myRecipe.getBrewer());
  preBoilText.setText(SBStringUtils.format(myRecipe.getPreBoilVol(myRecipe.getVolUnits()),2));
  lblSizeUnits.setText(myRecipe.getVolUnits());
  finalWortVolText.setText(SBStringUtils.format(myRecipe.getFinalWortVol(myRecipe.getVolUnits()),2));
  boilMinText.setText(SBStringUtils.format(myRecipe.getBoilMinutes(),0));
  evapText.setText(SBStringUtils.format(myRecipe.getEvap(),1));
  spnEffic.setValue(new Double(myRecipe.getEfficiency()));
  spnAtten.setValue(new Double(myRecipe.getAttenuation()));
  spnOG.setValue(new Double(myRecipe.getEstOg()));
  spnFG.setValue(new Double(myRecipe.getEstFg()));
  txtComments.setText(myRecipe.getComments());
  lblIBUvalue.setText(SBStringUtils.format(myRecipe.getIbu(),1));
  lblColourValue.setText(SBStringUtils.format(myRecipe.getColour(),1));
  lblAlcValue.setText(SBStringUtils.format(myRecipe.getAlcohol(),1));
  try {
    txtDate.setDate(myRecipe.getCreated().getTime());
  }
 catch (  PropertyVetoException e) {
    e.printStackTrace();
  }
  Costs=SBStringUtils.myNF.format(myRecipe.getTotalMaltCost());
  tblMaltTotalsModel.setDataVector(new String[][]{{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + SBStringUtils.format(myRecipe.getTotalMalt(),1),myRecipe.getMaltUnits(),""String_Node_Str"" + SBStringUtils.format(myRecipe.getEstOg(),3),""String_Node_Str"" + SBStringUtils.format(myRecipe.getColour(),1),Costs,""String_Node_Str""}},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  Costs=SBStringUtils.myNF.format(myRecipe.getTotalHopsCost());
  tblHopsTotalsModel.setDataVector(new String[][]{{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + SBStringUtils.format(myRecipe.getTotalHops(),1),myRecipe.getHopUnits(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + SBStringUtils.format(myRecipe.getIbu(),1),Costs}},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  String fileName=""String_Node_Str"";
  if (currentFile != null) {
    fileName=currentFile.getName();
  }
  fileNameLabel.setText(""String_Node_Str"" + fileName);
  ibuMethodLabel.setText(""String_Node_Str"" + myRecipe.getIBUMethod());
  alcMethodLabel.setText(""String_Node_Str"" + myRecipe.getAlcMethod());
  double colour=myRecipe.getColour(BrewCalcs.SRM);
  if (preferences.getProperty(""String_Node_Str"").equals(""String_Node_Str""))   colourPanel.setBackground(BrewCalcs.calcRGB(1,colour,preferences.getIProperty(""String_Node_Str""),preferences.getIProperty(""String_Node_Str""),preferences.getIProperty(""String_Node_Str""),preferences.getIProperty(""String_Node_Str"")));
 else   colourPanel.setBackground(BrewCalcs.calcRGB(2,colour,preferences.getIProperty(""String_Node_Str""),preferences.getIProperty(""String_Node_Str""),preferences.getIProperty(""String_Node_Str""),preferences.getIProperty(""String_Node_Str"")));
  String title=""String_Node_Str"" + version + ""String_Node_Str""+ edition;
  String file=""String_Node_Str"";
  String dirty=""String_Node_Str"";
  if (currentFile != null) {
    file=""String_Node_Str"" + currentFile.getAbsolutePath();
  }
 else {
    file=""String_Node_Str"";
  }
  if (myRecipe.getDirty()) {
    dirty=""String_Node_Str"";
  }
 else {
    dirty=""String_Node_Str"";
  }
  this.setTitle(title + file + dirty);
  dontUpdate=false;
}"
50534,"public void displayWaterTreatment(){
  WaterProfile source=myRecipe.getSourceWater();
  WaterProfile target=myRecipe.getTargetWater();
  comboSource.setSelectedItem(source.getName());
  comboTarget.setSelectedItem(target.getName());
  textCaS.setText(SBStringUtils.format(source.getCa(),1));
  textClS.setText(SBStringUtils.format(source.getCl(),1));
  textMgS.setText(SBStringUtils.format(source.getMg(),1));
  textNaS.setText(SBStringUtils.format(source.getNa(),1));
  textSo4S.setText(SBStringUtils.format(source.getSo4(),1));
  textCarbonateS.setText(SBStringUtils.format(source.getHco3(),1));
  textHardnessS.setText(SBStringUtils.format(source.getHardness(),1));
  textAlkS.setText(SBStringUtils.format(source.getAlkalinity(),1));
  textTDSS.setText(SBStringUtils.format(source.getTds(),1));
  textMashPHS.setText(SBStringUtils.format(source.getPh(),1));
  textCaT.setText(SBStringUtils.format(target.getCa(),1));
  textClT.setText(SBStringUtils.format(target.getCl(),1));
  textMgT.setText(SBStringUtils.format(target.getMg(),1));
  textNaT.setText(SBStringUtils.format(target.getNa(),1));
  textSo4T.setText(SBStringUtils.format(target.getSo4(),1));
  textCarbonateT.setText(SBStringUtils.format(target.getHco3(),1));
  textHardnessT.setText(SBStringUtils.format(target.getHardness(),1));
  textAlkT.setText(SBStringUtils.format(target.getAlkalinity(),1));
  textTDST.setText(SBStringUtils.format(target.getTds(),1));
  textMashPHT.setText(SBStringUtils.format(target.getPh(),1));
  WaterProfile diff=new WaterProfile();
  diff.setCa(target.getCa() - source.getCa());
  diff.setCl(target.getCl() - source.getCl());
  diff.setMg(target.getMg() - source.getMg());
  diff.setNa(target.getNa() - source.getNa());
  diff.setSo4(target.getSo4() - source.getSo4());
  diff.setHco3(target.getHco3() - source.getHco3());
  diff.setHardness(target.getHardness() - source.getHardness());
  diff.setAlkalinity(target.getAlkalinity() - source.getAlkalinity());
  diff.setTds(target.getTds() - source.getTds());
  diff.setPh(source.getPh() - source.getPh());
  textCaD.setText(SBStringUtils.format(diff.getCa(),1));
  textClD.setText(SBStringUtils.format(diff.getCl(),1));
  textMgD.setText(SBStringUtils.format(diff.getMg(),1));
  textNaD.setText(SBStringUtils.format(diff.getNa(),1));
  textSo4D.setText(SBStringUtils.format(diff.getSo4(),1));
  textCarbonateD.setText(SBStringUtils.format(diff.getHco3(),1));
  textHardnessD.setText(SBStringUtils.format(diff.getHardness(),1));
  textAlkD.setText(SBStringUtils.format(diff.getAlkalinity(),1));
  textTDSD.setText(SBStringUtils.format(diff.getTds(),1));
  textMashPHD.setText(SBStringUtils.format(diff.getPh(),1));
  WaterProfile resultWater;
  resultWater=BrewCalcs.calculateSalts(myRecipe.getSalts(),diff,1);
  textCaR.setText(SBStringUtils.format(resultWater.getCa(),1));
  textClR.setText(SBStringUtils.format(resultWater.getCl(),1));
  textMgR.setText(SBStringUtils.format(resultWater.getMg(),1));
  textNaR.setText(SBStringUtils.format(resultWater.getNa(),1));
  textSo4R.setText(SBStringUtils.format(resultWater.getSo4(),1));
  textCarbonateR.setText(SBStringUtils.format(resultWater.getHco3(),1));
  textHardnessR.setText(SBStringUtils.format(resultWater.getHardness(),1));
  textAlkR.setText(SBStringUtils.format(resultWater.getAlkalinity(),1));
  textTDSR.setText(SBStringUtils.format(resultWater.getTds(),1));
  textMashPHR.setText(SBStringUtils.format(resultWater.getPh(),1));
  for (int i=0; i < saltName.length; i++) {
    Salt s=myRecipe.getSaltByName(saltName[i]);
    if (myRecipe.getSaltByName(saltName[i]) != null) {
      textSaltsAmount[i].setText(SBStringUtils.format(s.getAmount(),2));
    }
 else {
      textSaltsAmount[i].setText(""String_Node_Str"");
    }
  }
  textSourcePH.setText(SBStringUtils.format(8.5,1));
  textSourceAlk.setText(SBStringUtils.format(300,1));
  textTargetPH.setText(SBStringUtils.format(5.4,1));
  comboAcid.setSelectedItem(myRecipe.getAcid().getName());
  lAcidUnit.setText(myRecipe.getAcid().getAcidUnit());
  double millEs=BrewCalcs.acidMillequivelantsPerLiter(8.5,300,5.4);
  double moles=BrewCalcs.molesByAcid(myRecipe.getAcid(),millEs,5.4);
  double acidPerL=BrewCalcs.acidAmountPerL(myRecipe.getAcid(),moles);
  textAcidAmount.setText(SBStringUtils.format(Quantity.convertUnit(Quantity.L,Quantity.GAL,acidPerL),2));
}","public void displayWaterTreatment(){
  WaterProfile source=myRecipe.getSourceWater();
  WaterProfile target=myRecipe.getTargetWater();
  comboSource.setSelectedItem(source.getName());
  comboTarget.setSelectedItem(target.getName());
  textCaS.setText(SBStringUtils.format(source.getCa(),1));
  textClS.setText(SBStringUtils.format(source.getCl(),1));
  textMgS.setText(SBStringUtils.format(source.getMg(),1));
  textNaS.setText(SBStringUtils.format(source.getNa(),1));
  textSo4S.setText(SBStringUtils.format(source.getSo4(),1));
  textCarbonateS.setText(SBStringUtils.format(source.getHco3(),1));
  textHardnessS.setText(SBStringUtils.format(source.getHardness(),1));
  textAlkS.setText(SBStringUtils.format(source.getAlkalinity(),1));
  textTDSS.setText(SBStringUtils.format(source.getTds(),1));
  textMashPHS.setText(SBStringUtils.format(source.getPh(),1));
  textCaT.setText(SBStringUtils.format(target.getCa(),1));
  textClT.setText(SBStringUtils.format(target.getCl(),1));
  textMgT.setText(SBStringUtils.format(target.getMg(),1));
  textNaT.setText(SBStringUtils.format(target.getNa(),1));
  textSo4T.setText(SBStringUtils.format(target.getSo4(),1));
  textCarbonateT.setText(SBStringUtils.format(target.getHco3(),1));
  textHardnessT.setText(SBStringUtils.format(target.getHardness(),1));
  textAlkT.setText(SBStringUtils.format(target.getAlkalinity(),1));
  textTDST.setText(SBStringUtils.format(target.getTds(),1));
  textMashPHT.setText(SBStringUtils.format(target.getPh(),1));
  WaterProfile diff=new WaterProfile();
  diff.setCa(target.getCa() - source.getCa());
  diff.setCl(target.getCl() - source.getCl());
  diff.setMg(target.getMg() - source.getMg());
  diff.setNa(target.getNa() - source.getNa());
  diff.setSo4(target.getSo4() - source.getSo4());
  diff.setHco3(target.getHco3() - source.getHco3());
  diff.setHardness(target.getHardness() - source.getHardness());
  diff.setAlkalinity(target.getAlkalinity() - source.getAlkalinity());
  diff.setTds(target.getTds() - source.getTds());
  diff.setPh(source.getPh() - source.getPh());
  textCaD.setText(SBStringUtils.format(diff.getCa(),1));
  textClD.setText(SBStringUtils.format(diff.getCl(),1));
  textMgD.setText(SBStringUtils.format(diff.getMg(),1));
  textNaD.setText(SBStringUtils.format(diff.getNa(),1));
  textSo4D.setText(SBStringUtils.format(diff.getSo4(),1));
  textCarbonateD.setText(SBStringUtils.format(diff.getHco3(),1));
  textHardnessD.setText(SBStringUtils.format(diff.getHardness(),1));
  textAlkD.setText(SBStringUtils.format(diff.getAlkalinity(),1));
  textTDSD.setText(SBStringUtils.format(diff.getTds(),1));
  textMashPHD.setText(SBStringUtils.format(diff.getPh(),1));
  WaterProfile resultWater;
  resultWater=BrewCalcs.calculateSalts(myRecipe.getSalts(),diff,1);
  textCaR.setText(SBStringUtils.format(resultWater.getCa(),1));
  textClR.setText(SBStringUtils.format(resultWater.getCl(),1));
  textMgR.setText(SBStringUtils.format(resultWater.getMg(),1));
  textNaR.setText(SBStringUtils.format(resultWater.getNa(),1));
  textSo4R.setText(SBStringUtils.format(resultWater.getSo4(),1));
  textCarbonateR.setText(SBStringUtils.format(resultWater.getHco3(),1));
  textHardnessR.setText(SBStringUtils.format(resultWater.getHardness(),1));
  textAlkR.setText(SBStringUtils.format(resultWater.getAlkalinity(),1));
  textTDSR.setText(SBStringUtils.format(resultWater.getTds(),1));
  textMashPHR.setText(SBStringUtils.format(resultWater.getPh(),1));
  for (int i=0; i < saltName.length; i++) {
    Salt s=myRecipe.getSaltByName(saltName[i]);
    if (myRecipe.getSaltByName(saltName[i]) != null) {
      textSaltsAmount[i].setText(SBStringUtils.format(s.getAmount(),2));
    }
 else {
      textSaltsAmount[i].setText(""String_Node_Str"");
    }
  }
  comboAcid.setSelectedItem(myRecipe.getAcid().getName());
  lAcidUnit.setText(myRecipe.getAcid().getAcidUnit());
  double millEs=BrewCalcs.acidMillequivelantsPerLiter(Double.parseDouble(textSourcePH.getText()),Double.parseDouble(textSourceAlk.getText()),Double.parseDouble(textTargetPH.getText()));
  double moles=BrewCalcs.molesByAcid(myRecipe.getAcid(),millEs,Double.parseDouble(textTargetPH.getText()));
  double acidPerL=BrewCalcs.acidAmountPerL(myRecipe.getAcid(),moles);
  textAcidAmount.setText(SBStringUtils.format(Quantity.convertUnit(Quantity.GAL,Quantity.L,acidPerL),2));
}"
50535,"private void initGUI(){
  try {
    this.setLayout(new BoxLayout(this,BoxLayout.X_AXIS));
    this.add(panelWater);
    panelWater.setLayout(waterGridBag);
    panelWater.setBorder(BorderFactory.createTitledBorder(new LineBorder(new java.awt.Color(0,0,0),1,false),""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP,new java.awt.Font(""String_Node_Str"",1,12),new java.awt.Color(51,51,51)));
    this.add(panelSalt);
    panelSalt.setLayout(saltGridBag);
    panelSalt.setBorder(BorderFactory.createTitledBorder(new LineBorder(new java.awt.Color(0,0,0),1,false),""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP,new java.awt.Font(""String_Node_Str"",1,12),new java.awt.Color(51,51,51)));
    this.add(panelAcid);
    panelAcid.setLayout(saltGridBag);
    panelAcid.setBorder(BorderFactory.createTitledBorder(new LineBorder(new java.awt.Color(0,0,0),1,false),""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP,new java.awt.Font(""String_Node_Str"",1,12),new java.awt.Color(51,51,51)));
{
      constraints.fill=GridBagConstraints.HORIZONTAL;
{
        constraints.gridx=0;
        constraints.gridy=0;
        constraints.gridwidth=2;
        panelWater.add(comboSource,constraints);
        comboSource.addActionListener(this);
        constraints.gridx=2;
        panelWater.add(comboTarget,constraints);
        comboTarget.addActionListener(this);
        constraints.gridwidth=1;
      }
{
        constraints.gridx=1;
        constraints.gridy=1;
        panelWater.add(lSource,constraints);
        constraints.gridx=2;
        panelWater.add(lTarget,constraints);
        constraints.gridx=3;
        panelWater.add(lDiff,constraints);
        constraints.gridx=4;
        panelWater.add(lTreated,constraints);
      }
{
        constraints.gridx=0;
        constraints.gridy=2;
        panelWater.add(lCa,constraints);
        constraints.gridy=3;
        panelWater.add(lCl,constraints);
        constraints.gridy=4;
        panelWater.add(lMg,constraints);
        constraints.gridy=5;
        panelWater.add(lNa,constraints);
        constraints.gridy=6;
        panelWater.add(lSo4,constraints);
        constraints.gridy=7;
        panelWater.add(lCarbonate,constraints);
        constraints.gridy=8;
        panelWater.add(lHardness,constraints);
        constraints.gridy=9;
        panelWater.add(lAlk,constraints);
        constraints.gridy=10;
        panelWater.add(lTDS,constraints);
        constraints.gridy=11;
        panelWater.add(lMashPH,constraints);
      }
      constraints.ipadx=60;
{
        constraints.gridx=1;
        constraints.gridy=2;
        panelWater.add(textCaS,constraints);
        constraints.gridy=3;
        panelWater.add(textClS,constraints);
        constraints.gridy=4;
        panelWater.add(textMgS,constraints);
        constraints.gridy=5;
        panelWater.add(textNaS,constraints);
        constraints.gridy=6;
        panelWater.add(textSo4S,constraints);
        constraints.gridy=7;
        panelWater.add(textCarbonateS,constraints);
        constraints.gridy=8;
        panelWater.add(textHardnessS,constraints);
        constraints.gridy=9;
        panelWater.add(textAlkS,constraints);
        constraints.gridy=10;
        panelWater.add(textTDSS,constraints);
        constraints.gridy=11;
        panelWater.add(textMashPHS,constraints);
      }
{
        constraints.gridx=2;
        constraints.gridy=2;
        panelWater.add(textCaT,constraints);
        textCaT.setEditable(false);
        constraints.gridy=3;
        panelWater.add(textClT,constraints);
        textClT.setEditable(false);
        constraints.gridy=4;
        panelWater.add(textMgT,constraints);
        textMgT.setEditable(false);
        constraints.gridy=5;
        panelWater.add(textNaT,constraints);
        textNaT.setEditable(false);
        constraints.gridy=6;
        panelWater.add(textSo4T,constraints);
        textSo4T.setEditable(false);
        constraints.gridy=7;
        panelWater.add(textCarbonateT,constraints);
        textCarbonateT.setEditable(false);
        constraints.gridy=8;
        panelWater.add(textHardnessT,constraints);
        textHardnessT.setEditable(false);
        constraints.gridy=9;
        panelWater.add(textAlkT,constraints);
        textAlkT.setEditable(false);
        constraints.gridy=10;
        panelWater.add(textTDST,constraints);
        textTDST.setEditable(false);
        constraints.gridy=11;
        panelWater.add(textMashPHT,constraints);
        textMashPHT.setEditable(false);
      }
{
        constraints.gridx=3;
        constraints.gridy=2;
        panelWater.add(textCaD,constraints);
        textCaD.setEditable(false);
        constraints.gridy=3;
        panelWater.add(textClD,constraints);
        textClD.setEditable(false);
        constraints.gridy=4;
        panelWater.add(textMgD,constraints);
        textMgD.setEditable(false);
        constraints.gridy=5;
        panelWater.add(textNaD,constraints);
        textNaD.setEditable(false);
        constraints.gridy=6;
        panelWater.add(textSo4D,constraints);
        textSo4D.setEditable(false);
        constraints.gridy=7;
        panelWater.add(textCarbonateD,constraints);
        textCarbonateD.setEditable(false);
        constraints.gridy=8;
        panelWater.add(textHardnessD,constraints);
        textHardnessD.setEditable(false);
        constraints.gridy=9;
        panelWater.add(textAlkD,constraints);
        textAlkD.setEditable(false);
        constraints.gridy=10;
        panelWater.add(textTDSD,constraints);
        textTDSD.setEditable(false);
        constraints.gridy=11;
        panelWater.add(textMashPHD,constraints);
        textMashPHD.setEditable(false);
      }
{
        constraints.gridx=4;
        constraints.gridy=2;
        panelWater.add(textCaR,constraints);
        textCaR.setEditable(false);
        constraints.gridy=3;
        panelWater.add(textClR,constraints);
        textClR.setEditable(false);
        constraints.gridy=4;
        panelWater.add(textMgR,constraints);
        textMgR.setEditable(false);
        constraints.gridy=5;
        panelWater.add(textNaR,constraints);
        textNaR.setEditable(false);
        constraints.gridy=6;
        panelWater.add(textSo4R,constraints);
        textSo4R.setEditable(false);
        constraints.gridy=7;
        panelWater.add(textCarbonateR,constraints);
        textCarbonateR.setEditable(false);
        constraints.gridy=8;
        panelWater.add(textHardnessR,constraints);
        textHardnessR.setEditable(false);
        constraints.gridy=9;
        panelWater.add(textAlkR,constraints);
        textAlkR.setEditable(false);
        constraints.gridy=10;
        panelWater.add(textTDSR,constraints);
        textTDSR.setEditable(false);
        constraints.gridy=11;
        panelWater.add(textMashPHR,constraints);
        textMashPHR.setEditable(false);
      }
      constraints.ipadx=0;
    }
{
    }
{
      constraints.gridx=0;
      constraints.gridy=0;
      panelAcid.add(lSourcePH,constraints);
      constraints.gridx=1;
      constraints.gridwidth=2;
      panelAcid.add(textSourcePH,constraints);
      textSourcePH.addActionListener(this);
      textSourcePH.addKeyListener(this);
      constraints.gridwidth=1;
      constraints.gridx=0;
      constraints.gridy=1;
      panelAcid.add(lSourceAlk,constraints);
      constraints.gridx=1;
      constraints.gridwidth=2;
      panelAcid.add(textSourceAlk,constraints);
      textSourceAlk.addActionListener(this);
      textSourceAlk.addKeyListener(this);
      constraints.gridwidth=1;
      constraints.gridx=0;
      constraints.gridy=2;
      panelAcid.add(lTargetPH,constraints);
      constraints.gridx=1;
      constraints.gridwidth=2;
      panelAcid.add(textTargetPH,constraints);
      textTargetPH.addActionListener(this);
      textTargetPH.addKeyListener(this);
      constraints.gridwidth=1;
      constraints.gridx=0;
      constraints.gridy=3;
      panelAcid.add(lAcid,constraints);
      constraints.gridx=1;
      constraints.gridwidth=2;
      panelAcid.add(comboAcid,constraints);
      comboAcid.addActionListener(this);
      constraints.gridwidth=1;
      constraints.gridx=0;
      constraints.gridy=4;
      panelAcid.add(lAdd,constraints);
      constraints.gridx=1;
      panelAcid.add(textAcidAmount,constraints);
      textAcidAmount.setEditable(false);
      constraints.gridx=2;
      panelAcid.add(lAcidUnit,constraints);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","private void initGUI(){
  try {
    this.setLayout(new BoxLayout(this,BoxLayout.X_AXIS));
    this.add(panelWater);
    panelWater.setLayout(waterGridBag);
    panelWater.setBorder(BorderFactory.createTitledBorder(new LineBorder(new java.awt.Color(0,0,0),1,false),""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP,new java.awt.Font(""String_Node_Str"",1,12),new java.awt.Color(51,51,51)));
    this.add(panelSalt);
    panelSalt.setLayout(saltGridBag);
    panelSalt.setBorder(BorderFactory.createTitledBorder(new LineBorder(new java.awt.Color(0,0,0),1,false),""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP,new java.awt.Font(""String_Node_Str"",1,12),new java.awt.Color(51,51,51)));
    this.add(panelAcid);
    panelAcid.setLayout(saltGridBag);
    panelAcid.setBorder(BorderFactory.createTitledBorder(new LineBorder(new java.awt.Color(0,0,0),1,false),""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP,new java.awt.Font(""String_Node_Str"",1,12),new java.awt.Color(51,51,51)));
{
      constraints.fill=GridBagConstraints.HORIZONTAL;
{
        constraints.gridx=0;
        constraints.gridy=0;
        constraints.gridwidth=2;
        panelWater.add(comboSource,constraints);
        comboSource.addActionListener(this);
        constraints.gridx=2;
        panelWater.add(comboTarget,constraints);
        comboTarget.addActionListener(this);
        constraints.gridwidth=1;
      }
{
        constraints.gridx=1;
        constraints.gridy=1;
        panelWater.add(lSource,constraints);
        constraints.gridx=2;
        panelWater.add(lTarget,constraints);
        constraints.gridx=3;
        panelWater.add(lDiff,constraints);
        constraints.gridx=4;
        panelWater.add(lTreated,constraints);
      }
{
        constraints.gridx=0;
        constraints.gridy=2;
        panelWater.add(lCa,constraints);
        constraints.gridy=3;
        panelWater.add(lCl,constraints);
        constraints.gridy=4;
        panelWater.add(lMg,constraints);
        constraints.gridy=5;
        panelWater.add(lNa,constraints);
        constraints.gridy=6;
        panelWater.add(lSo4,constraints);
        constraints.gridy=7;
        panelWater.add(lCarbonate,constraints);
        constraints.gridy=8;
        panelWater.add(lHardness,constraints);
        constraints.gridy=9;
        panelWater.add(lAlk,constraints);
        constraints.gridy=10;
        panelWater.add(lTDS,constraints);
        constraints.gridy=11;
        panelWater.add(lMashPH,constraints);
      }
      constraints.ipadx=60;
{
        constraints.gridx=1;
        constraints.gridy=2;
        panelWater.add(textCaS,constraints);
        constraints.gridy=3;
        panelWater.add(textClS,constraints);
        constraints.gridy=4;
        panelWater.add(textMgS,constraints);
        constraints.gridy=5;
        panelWater.add(textNaS,constraints);
        constraints.gridy=6;
        panelWater.add(textSo4S,constraints);
        constraints.gridy=7;
        panelWater.add(textCarbonateS,constraints);
        constraints.gridy=8;
        panelWater.add(textHardnessS,constraints);
        constraints.gridy=9;
        panelWater.add(textAlkS,constraints);
        constraints.gridy=10;
        panelWater.add(textTDSS,constraints);
        constraints.gridy=11;
        panelWater.add(textMashPHS,constraints);
      }
{
        constraints.gridx=2;
        constraints.gridy=2;
        panelWater.add(textCaT,constraints);
        textCaT.setEditable(false);
        constraints.gridy=3;
        panelWater.add(textClT,constraints);
        textClT.setEditable(false);
        constraints.gridy=4;
        panelWater.add(textMgT,constraints);
        textMgT.setEditable(false);
        constraints.gridy=5;
        panelWater.add(textNaT,constraints);
        textNaT.setEditable(false);
        constraints.gridy=6;
        panelWater.add(textSo4T,constraints);
        textSo4T.setEditable(false);
        constraints.gridy=7;
        panelWater.add(textCarbonateT,constraints);
        textCarbonateT.setEditable(false);
        constraints.gridy=8;
        panelWater.add(textHardnessT,constraints);
        textHardnessT.setEditable(false);
        constraints.gridy=9;
        panelWater.add(textAlkT,constraints);
        textAlkT.setEditable(false);
        constraints.gridy=10;
        panelWater.add(textTDST,constraints);
        textTDST.setEditable(false);
        constraints.gridy=11;
        panelWater.add(textMashPHT,constraints);
        textMashPHT.setEditable(false);
      }
{
        constraints.gridx=3;
        constraints.gridy=2;
        panelWater.add(textCaD,constraints);
        textCaD.setEditable(false);
        constraints.gridy=3;
        panelWater.add(textClD,constraints);
        textClD.setEditable(false);
        constraints.gridy=4;
        panelWater.add(textMgD,constraints);
        textMgD.setEditable(false);
        constraints.gridy=5;
        panelWater.add(textNaD,constraints);
        textNaD.setEditable(false);
        constraints.gridy=6;
        panelWater.add(textSo4D,constraints);
        textSo4D.setEditable(false);
        constraints.gridy=7;
        panelWater.add(textCarbonateD,constraints);
        textCarbonateD.setEditable(false);
        constraints.gridy=8;
        panelWater.add(textHardnessD,constraints);
        textHardnessD.setEditable(false);
        constraints.gridy=9;
        panelWater.add(textAlkD,constraints);
        textAlkD.setEditable(false);
        constraints.gridy=10;
        panelWater.add(textTDSD,constraints);
        textTDSD.setEditable(false);
        constraints.gridy=11;
        panelWater.add(textMashPHD,constraints);
        textMashPHD.setEditable(false);
      }
{
        constraints.gridx=4;
        constraints.gridy=2;
        panelWater.add(textCaR,constraints);
        textCaR.setEditable(false);
        constraints.gridy=3;
        panelWater.add(textClR,constraints);
        textClR.setEditable(false);
        constraints.gridy=4;
        panelWater.add(textMgR,constraints);
        textMgR.setEditable(false);
        constraints.gridy=5;
        panelWater.add(textNaR,constraints);
        textNaR.setEditable(false);
        constraints.gridy=6;
        panelWater.add(textSo4R,constraints);
        textSo4R.setEditable(false);
        constraints.gridy=7;
        panelWater.add(textCarbonateR,constraints);
        textCarbonateR.setEditable(false);
        constraints.gridy=8;
        panelWater.add(textHardnessR,constraints);
        textHardnessR.setEditable(false);
        constraints.gridy=9;
        panelWater.add(textAlkR,constraints);
        textAlkR.setEditable(false);
        constraints.gridy=10;
        panelWater.add(textTDSR,constraints);
        textTDSR.setEditable(false);
        constraints.gridy=11;
        panelWater.add(textMashPHR,constraints);
        textMashPHR.setEditable(false);
      }
      constraints.ipadx=0;
    }
{
    }
{
      constraints.gridx=0;
      constraints.gridy=0;
      panelAcid.add(lSourcePH,constraints);
      constraints.gridx=1;
      constraints.gridwidth=2;
      panelAcid.add(textSourcePH,constraints);
      textSourcePH.addActionListener(this);
      textSourcePH.addKeyListener(this);
      constraints.gridwidth=1;
      constraints.gridx=0;
      constraints.gridy=1;
      panelAcid.add(lSourceAlk,constraints);
      constraints.gridx=1;
      constraints.gridwidth=2;
      panelAcid.add(textSourceAlk,constraints);
      textSourceAlk.addActionListener(this);
      textSourceAlk.addKeyListener(this);
      constraints.gridwidth=1;
      constraints.gridx=0;
      constraints.gridy=2;
      panelAcid.add(lTargetPH,constraints);
      constraints.gridx=1;
      constraints.gridwidth=2;
      panelAcid.add(textTargetPH,constraints);
      textTargetPH.addActionListener(this);
      textTargetPH.addKeyListener(this);
      constraints.gridwidth=1;
      constraints.gridx=0;
      constraints.gridy=3;
      panelAcid.add(lAcid,constraints);
      constraints.gridx=1;
      constraints.gridwidth=2;
      panelAcid.add(comboAcid,constraints);
      comboAcid.addActionListener(this);
      constraints.gridwidth=1;
      constraints.gridx=0;
      constraints.gridy=4;
      panelAcid.add(lAdd,constraints);
      constraints.gridx=1;
      constraints.weightx=1;
      panelAcid.add(textAcidAmount,constraints);
      constraints.weightx=0;
      textAcidAmount.setEditable(false);
      constraints.gridx=2;
      panelAcid.add(lAcidUnit,constraints);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
50536,"public MashPanel(Recipe r){
  super();
  initGUI();
  myRecipe=r;
  if (myRecipe != null) {
    mashModel.setData(myRecipe.getMash());
  }
  displayMash();
  tblMash.updateUI();
  String[] names=md.getNames();
  for (int i=0; i < names.length; i++) {
    JMenuItem m=new JMenuItem(names[i]);
    m.addActionListener(this);
    mashMenu.add(m);
  }
}","public MashPanel(Recipe r){
  super();
  myRecipe=r;
  mashModel=new MashTableModel();
  if (myRecipe != null) {
    mashModel.setData(myRecipe.getMash());
  }
  initGUI();
  displayMash();
  tblMash.updateUI();
  String[] names=md.getNames();
  for (int i=0; i < names.length; i++) {
    JMenuItem m=new JMenuItem(names[i]);
    m.addActionListener(this);
    mashMenu.add(m);
  }
}"
50537,"public void addOrInsert(Object o){
  int i=0;
  boolean found=false;
  boolean empty=false;
  while (i < list.size() && !found && !empty) {
    if (o.getClass().getName().toString().equals(""String_Node_Str"")) {
      Yeast y=(Yeast)list.get(i);
      Yeast y2=(Yeast)o;
      found=y.getName().equalsIgnoreCase(y2.getName());
      empty=y.getName().equals(""String_Node_Str"");
    }
 else     if (o.getClass().getName().toString().equals(""String_Node_Str"")) {
      Fermentable f=(Fermentable)list.get(i);
      Fermentable f2=(Fermentable)o;
      found=f.getName().equalsIgnoreCase(f2.getName());
      empty=f.getName().equals(""String_Node_Str"");
    }
 else     if (o.getClass().getName().toString().equals(""String_Node_Str"")) {
      Hop h=(Hop)list.get(i);
      Hop h2=(Hop)o;
      found=h.getName().equalsIgnoreCase(h2.getName());
      empty=h.getName().equals(""String_Node_Str"");
    }
 else     if (o.getClass().getName().toString().equals(""String_Node_Str"")) {
      Style s=(Style)list.get(i);
      Style s2=(Style)o;
      found=s.getName().equalsIgnoreCase(s2.getName());
      empty=s.getName().equals(""String_Node_Str"");
      Debug.print(""String_Node_Str"" + s.name + ""String_Node_Str""+ s2.name);
    }
 else     if (o.getClass().getName().toString().equals(""String_Node_Str"")) {
      String q=(String)list.get(i);
      String q2=(String)o;
      found=q.equalsIgnoreCase(q2);
      empty=q.equals(""String_Node_Str"");
    }
    i++;
  }
  if (!found) {
    list.add(o);
    selected=o;
  }
 else {
    selected=list.get(i - 1);
  }
}","public void addOrInsert(Object o){
  int i=0;
  boolean found=false;
  boolean empty=false;
  while (i < list.size() && !found && !empty) {
    if (o.getClass().getName().toString().equals(""String_Node_Str"")) {
      Yeast y=(Yeast)list.get(i);
      Yeast y2=(Yeast)o;
      found=y.getName().equalsIgnoreCase(y2.getName());
    }
 else     if (o.getClass().getName().toString().equals(""String_Node_Str"")) {
      Fermentable f=(Fermentable)list.get(i);
      Fermentable f2=(Fermentable)o;
      found=f.getName().equalsIgnoreCase(f2.getName());
    }
 else     if (o.getClass().getName().toString().equals(""String_Node_Str"")) {
      Hop h=(Hop)list.get(i);
      Hop h2=(Hop)o;
      found=h.getName().equalsIgnoreCase(h2.getName());
    }
 else     if (o.getClass().getName().toString().equals(""String_Node_Str"")) {
      Style s=(Style)list.get(i);
      Style s2=(Style)o;
      found=s.getName().equalsIgnoreCase(s2.getName());
    }
 else     if (o.getClass().getName().toString().equals(""String_Node_Str"")) {
      String q=(String)list.get(i);
      String q2=(String)o;
      found=q.equalsIgnoreCase(q2);
      empty=q.equals(""String_Node_Str"");
    }
    i++;
  }
  if (!found) {
    list.add(o);
    selected=o;
  }
 else {
    selected=list.get(i - 1);
  }
}"
50538,"double CalcRager(double amount,double size,double sg,double time,double AA){
  double ibu, utilization, ga;
  double x=(time - 31.32) / 18.27;
  double tanhx=(Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x));
  utilization=18.11 + (13.86 * tanhx / 18.27);
  ga=sg < 1.050 ? 0.0 : 0.2;
  ibu=amount * (utilization / 100) * (AA / 100.0)* 7490;
  ibu/=size * (1 + ga);
  return ibu;
}","double CalcRager(double amount,double size,double sg,double time,double AA){
  double ibu, utilization, ga;
  double x=(time - 31.32) / 18.27;
  double tanhx=(Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x));
  utilization=18.11 + (13.86 * tanhx / 18.27);
  ga=sg < 1.050 ? 0.0 : ((sg - 1.050) / 0.2);
  ibu=amount * (utilization / 100) * (AA / 100.0)* 7490;
  ibu/=size * (1 + ga);
  return ibu;
}"
50539,"public void setDiluted(Boolean b){
  diluted=b;
}","public void setDiluted(boolean b){
  diluted=b;
}"
50540,"public String toXML(){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"" + getName() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + getAmountAs(getUnits()) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + getUnitsAbrv() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + pppg + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + lov + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + mashed + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + steeped + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + getCostPerU() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + getDescription() + ""String_Node_Str"");
  sb.append(""String_Node_Str"");
  return sb.toString();
}","public String toXML(){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"" + getName() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + getAmountAs(getUnits()) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + getUnitsAbrv() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + pppg + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + lov + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + mashed + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + steeped + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + getCostPerU() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + SBStringUtils.subEntities(getDescription()) + ""String_Node_Str"");
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
50541,"public String toXML(){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"" + getName() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + getAmountAs(getUnits()) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + getMinutes() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + getUnitsAbrv() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + getType() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + alpha + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + getCostPerU() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + add + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + getDescription() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + getDate() + ""String_Node_Str"");
  sb.append(""String_Node_Str"");
  return sb.toString();
}","public String toXML(){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"" + getName() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + getAmountAs(getUnits()) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + getMinutes() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + getUnitsAbrv() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + getType() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + alpha + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + getCostPerU() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + add + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + SBStringUtils.subEntities(getDescription()) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + getDate() + ""String_Node_Str"");
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
50542,"public String toXML(){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"" + getName() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + getAmountAs(getUnits()) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + getUnits() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + stage + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + time + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + comments + ""String_Node_Str"");
  sb.append(""String_Node_Str"");
  return sb.toString();
}","public String toXML(){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"" + getName() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + getAmountAs(getUnits()) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + getUnits() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + stage + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + time + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + SBStringUtils.subEntities(comments) + ""String_Node_Str"");
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
50543,"private String checkFileType(File f){
  if (f.getPath().endsWith(""String_Node_Str""))   return ""String_Node_Str"";
  if (f.getPath().endsWith(""String_Node_Str"") || (f.getPath().endsWith(""String_Node_Str""))) {
    try {
      FileReader in=new FileReader(f);
      BufferedReader inb=new BufferedReader(in);
      String c;
      int i=0;
      while ((c=inb.readLine()) != null && i < 10) {
        if (c.indexOf(""String_Node_Str"") > -1)         return ""String_Node_Str"";
        if (c.indexOf(""String_Node_Str"") > -1)         return ""String_Node_Str"";
        if (c.indexOf(""String_Node_Str"") > -1)         return ""String_Node_Str"";
        i++;
      }
    }
 catch (    FileNotFoundException e) {
      e.printStackTrace();
    }
catch (    IOException e) {
      e.printStackTrace();
    }
  }
  return ""String_Node_Str"";
}","private String checkFileType(File f){
  if (f.getPath().endsWith(""String_Node_Str""))   return ""String_Node_Str"";
  if (f.getPath().endsWith(""String_Node_Str"") || (f.getPath().endsWith(""String_Node_Str""))) {
    try {
      FileReader in=new FileReader(f);
      BufferedReader inb=new BufferedReader(in);
      String c;
      int i=0;
      while ((c=inb.readLine()) != null && i < 10) {
        if (c.indexOf(""String_Node_Str"") > -1)         return ""String_Node_Str"";
        if (c.indexOf(""String_Node_Str"") > -1)         return ""String_Node_Str"";
        if (c.indexOf(""String_Node_Str"") > -1)         return ""String_Node_Str"";
        i++;
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  return ""String_Node_Str"";
}"
50544,"public String getColourMethod(){
  return ""String_Node_Str"";
}","public String getColourMethod(){
  return colourMethod;
}"
50545,"public void calcHopsTotals(){
  double ibuTotal=0;
  totalHopsCost=0;
  totalHopsOz=0;
  for (int i=0; i < hops.size(); i++) {
    double adjPreSize, aveOg=0;
    Hop h=((Hop)hops.get(i));
    if (h.getAdd().equalsIgnoreCase(""String_Node_Str"") || h.getAdd().equalsIgnoreCase(""String_Node_Str"")) {
      if (h.getMinutes() > 0)       adjPreSize=postBoilVol.getValueAs(""String_Node_Str"") + (preBoilVol.getValueAs(""String_Node_Str"") - postBoilVol.getValueAs(""String_Node_Str"")) / (boilMinutes / h.getMinutes());
 else       adjPreSize=postBoilVol.getValueAs(""String_Node_Str"");
      aveOg=1 + (((estOg - 1) + ((estOg - 1) / (adjPreSize / postBoilVol.getValueAs(""String_Node_Str"")))) / 2);
      if (ibuCalcMethod.equals(""String_Node_Str""))       h.setIBU(calcTinseth(h.getAmountAs(""String_Node_Str""),postBoilVol.getValueAs(""String_Node_Str""),aveOg,h.getMinutes(),h.getAlpha(),ibuHopUtil));
 else       if (ibuCalcMethod.equals(""String_Node_Str""))       h.setIBU(CalcRager(h.getAmountAs(""String_Node_Str""),postBoilVol.getValueAs(""String_Node_Str""),aveOg,h.getMinutes(),h.getAlpha()));
 else       h.setIBU(CalcGaretz(h.getAmountAs(""String_Node_Str""),postBoilVol.getValueAs(""String_Node_Str""),aveOg,h.getMinutes(),preBoilVol.getValueAs(""String_Node_Str""),1,h.getAlpha()));
      if (h.getType().equalsIgnoreCase(""String_Node_Str"")) {
        h.setIBU(h.getIBU() * (1.0 + (pelletHopPct / 100)));
      }
      ibuTotal+=h.getIBU();
    }
    totalHopsCost+=h.getCostPerU() * h.getAmountAs(""String_Node_Str"");
    totalHopsOz+=h.getAmountAs(""String_Node_Str"");
  }
  ibu=ibuTotal;
}","public void calcHopsTotals(){
  double ibuTotal=0;
  totalHopsCost=0;
  totalHopsOz=0;
  for (int i=0; i < hops.size(); i++) {
    double adjPreSize, aveOg=0;
    Hop h=((Hop)hops.get(i));
    if (h.getAdd().equalsIgnoreCase(""String_Node_Str"") || h.getAdd().equalsIgnoreCase(""String_Node_Str"")) {
      if (h.getMinutes() > 0)       adjPreSize=postBoilVol.getValueAs(""String_Node_Str"") + (preBoilVol.getValueAs(""String_Node_Str"") - postBoilVol.getValueAs(""String_Node_Str"")) / (boilMinutes / h.getMinutes());
 else       adjPreSize=postBoilVol.getValueAs(""String_Node_Str"");
      aveOg=1 + (((estOg - 1) + ((estOg - 1) / (adjPreSize / postBoilVol.getValueAs(""String_Node_Str"")))) / 2);
      if (ibuCalcMethod.equals(""String_Node_Str""))       h.setIBU(calcTinseth(h.getAmountAs(""String_Node_Str""),postBoilVol.getValueAs(""String_Node_Str""),aveOg,h.getMinutes(),h.getAlpha(),ibuHopUtil));
 else       if (ibuCalcMethod.equals(""String_Node_Str""))       h.setIBU(CalcRager(h.getAmountAs(""String_Node_Str""),postBoilVol.getValueAs(""String_Node_Str""),aveOg,h.getMinutes(),h.getAlpha()));
 else       h.setIBU(CalcGaretz(h.getAmountAs(""String_Node_Str""),postBoilVol.getValueAs(""String_Node_Str""),aveOg,h.getMinutes(),preBoilVol.getValueAs(""String_Node_Str""),1,h.getAlpha()));
      if (h.getType().equalsIgnoreCase(""String_Node_Str"")) {
        h.setIBU(h.getIBU() * (1.0 + (pelletHopPct / 100)));
      }
      ibuTotal+=h.getIBU();
    }
    totalHopsCost+=h.getCostPerU() * h.getAmountAs(h.getUnits());
    totalHopsOz+=h.getAmountAs(""String_Node_Str"");
  }
  ibu=ibuTotal;
}"
50546,"public void calcMaltTotals(){
  double maltPoints=0;
  double mcu=0;
  totalMaltLbs=0;
  totalMaltCost=0;
  totalMashLbs=0;
  for (int i=0; i < fermentables.size(); i++) {
    Fermentable m=((Fermentable)fermentables.get(i));
    totalMaltLbs+=(m.getAmountAs(""String_Node_Str""));
    if (m.getMashed()) {
      maltPoints+=(m.getPppg() - 1) * m.getAmountAs(""String_Node_Str"") * efficiency / postBoilVol.getValueAs(""String_Node_Str"");
      totalMashLbs+=(m.getAmountAs(""String_Node_Str""));
    }
 else     maltPoints+=(m.getPppg() - 1) * m.getAmountAs(""String_Node_Str"") * 100 / postBoilVol.getValueAs(""String_Node_Str"");
    mcu+=m.getLov() * m.getAmountAs(""String_Node_Str"") / postBoilVol.getValueAs(""String_Node_Str"");
    totalMaltCost+=m.getCostPerU() * m.getAmountAs(""String_Node_Str"");
  }
  for (int i=0; i < fermentables.size(); i++) {
    Fermentable m=((Fermentable)fermentables.get(i));
    m.setPercent((m.getAmountAs(""String_Node_Str"") / totalMaltLbs * 100));
  }
  estOg=(maltPoints / 100) + 1;
  estFg=1 + ((estOg - 1) * ((100 - attenuation) / 100));
  srm=calcColour(mcu);
  mash.setMaltWeight(totalMashLbs);
  calcAlcohol(getAlcMethod());
  chillShrinkQTS=getPostBoilVol(""String_Node_Str"") * 0.03;
  spargeQTS=getPreBoilVol(""String_Node_Str"") - (mash.getTotalWaterQts() - mash.getAbsorbedQts());
  totalWaterQTS=mash.getTotalWaterQts() + spargeQTS;
  finalWortVolQTS=postBoilVol.getValueAs(""String_Node_Str"") - (chillShrinkQTS + Quantity.convertUnit(getVolUnits(),""String_Node_Str"",kettleLoss) + Quantity.convertUnit(getVolUnits(),""String_Node_Str"",trubLoss)+ Quantity.convertUnit(getVolUnits(),""String_Node_Str"",miscLoss));
}","public void calcMaltTotals(){
  double maltPoints=0;
  double mcu=0;
  totalMaltLbs=0;
  totalMaltCost=0;
  totalMashLbs=0;
  for (int i=0; i < fermentables.size(); i++) {
    Fermentable m=((Fermentable)fermentables.get(i));
    totalMaltLbs+=(m.getAmountAs(""String_Node_Str""));
    if (m.getMashed()) {
      maltPoints+=(m.getPppg() - 1) * m.getAmountAs(""String_Node_Str"") * efficiency / postBoilVol.getValueAs(""String_Node_Str"");
      totalMashLbs+=(m.getAmountAs(""String_Node_Str""));
    }
 else     maltPoints+=(m.getPppg() - 1) * m.getAmountAs(""String_Node_Str"") * 100 / postBoilVol.getValueAs(""String_Node_Str"");
    mcu+=m.getLov() * m.getAmountAs(""String_Node_Str"") / postBoilVol.getValueAs(""String_Node_Str"");
    totalMaltCost+=m.getCostPerU() * m.getAmountAs(m.getUnits());
  }
  for (int i=0; i < fermentables.size(); i++) {
    Fermentable m=((Fermentable)fermentables.get(i));
    m.setPercent((m.getAmountAs(""String_Node_Str"") / totalMaltLbs * 100));
  }
  estOg=(maltPoints / 100) + 1;
  estFg=1 + ((estOg - 1) * ((100 - attenuation) / 100));
  srm=calcColour(mcu);
  mash.setMaltWeight(totalMashLbs);
  calcAlcohol(getAlcMethod());
  chillShrinkQTS=getPostBoilVol(""String_Node_Str"") * 0.03;
  spargeQTS=getPreBoilVol(""String_Node_Str"") - (mash.getTotalWaterQts() - mash.getAbsorbedQts());
  totalWaterQTS=mash.getTotalWaterQts() + spargeQTS;
  finalWortVolQTS=postBoilVol.getValueAs(""String_Node_Str"") - (chillShrinkQTS + Quantity.convertUnit(getVolUnits(),""String_Node_Str"",kettleLoss) + Quantity.convertUnit(getVolUnits(),""String_Node_Str"",trubLoss)+ Quantity.convertUnit(getVolUnits(),""String_Node_Str"",miscLoss));
}"
50547,"public FindDialog(JFrame frame){
  super(frame);
  recipes=new ArrayList();
  files=new ArrayList();
  inst=(StrangeSwing)frame;
  currentDir=new java.io.File(""String_Node_Str"");
  initGUI();
  dirLocationText.setText(currentDir.getAbsolutePath());
}","public FindDialog(JFrame frame){
  super(frame);
  recipes=new ArrayList();
  files=new ArrayList();
  inst=(StrangeSwing)frame;
  String slash=System.getProperty(""String_Node_Str"");
  currentDir=new java.io.File(""String_Node_Str"");
  try {
    currentDir=new File(currentDir.getCanonicalPath() + slash + ""String_Node_Str"");
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  initGUI();
  dirLocationText.setText(currentDir.getAbsolutePath());
  loadRecipes(currentDir);
}"
50548,"public Object getValueAt(int row,int col){
  try {
switch (col) {
case 0:
      return data.getMaltName(row);
case 1:
    return new Double(SBStringUtils.df1.format(data.getMaltAmountAs(row,data.getMaltUnits(row))));
case 2:
  return data.getMaltUnits(row);
case 3:
return new Double(SBStringUtils.df3.format(data.getMaltPppg(row)));
case 4:
return new Double(SBStringUtils.df0.format(data.getMaltLov(row)));
case 5:
return new Double(data.getMaltCostPerU(row));
case 6:
return SBStringUtils.df1.format(new Double(data.getMaltPercent(row)));
}
}
 catch (Exception e) {
}
;
return ""String_Node_Str"";
}","public Object getValueAt(int row,int col){
  try {
switch (col) {
case 0:
      return data.getMaltName(row);
case 1:
    return SBStringUtils.df1.format(data.getMaltAmountAs(row,data.getMaltUnits(row)));
case 2:
  return data.getMaltUnits(row);
case 3:
return SBStringUtils.df3.format(data.getMaltPppg(row));
case 4:
return SBStringUtils.df0.format(data.getMaltLov(row));
case 5:
return new Double(data.getMaltCostPerU(row));
case 6:
return SBStringUtils.df1.format(new Double(data.getMaltPercent(row)));
}
}
 catch (Exception e) {
}
;
return ""String_Node_Str"";
}"
50549,"public Object getValueAt(int row,int col){
  try {
switch (col) {
case 0:
      return data.getStepType(row);
case 1:
    return data.getStepMethod(row);
case 2:
  return new Double(data.getStepStartTemp(row));
case 3:
return new Double(data.getStepEndTemp(row));
case 4:
return new Integer(data.getStepRampMin(row));
case 5:
return new Integer(data.getStepMin(row));
}
}
 catch (Exception e) {
Debug.print(e.toString());
}
;
return ""String_Node_Str"";
}","public Object getValueAt(int row,int col){
  try {
switch (col) {
case 0:
      return data.getStepType(row);
case 1:
    return data.getStepMethod(row);
case 2:
  return SBStringUtils.df1.format(data.getStepStartTemp(row));
case 3:
return SBStringUtils.df1.format(data.getStepEndTemp(row));
case 4:
return new Integer(data.getStepRampMin(row));
case 5:
return new Integer(data.getStepMin(row));
}
}
 catch (Exception e) {
Debug.print(e.toString());
}
;
return ""String_Node_Str"";
}"
50550,"public String getVolAbrv(String unit){
  return getAbrvFromUnit(getTypeFromUnit(unit),unit);
}","public static String getVolAbrv(String unit){
  Quantity q=new Quantity();
  q.setUnits(unit);
  return q.abrv;
}"
50551,"private String getAbrvFromUnit(String t,String s){
  int i=0;
  Converter[] u;
  if (t == ""String_Node_Str"")   u=volUnits;
 else   u=weightUnits;
  while (i < u.length && u[i].unit != s) {
    i++;
  }
  if (i >= u.length)   return null;
 else   return u[i].abrv;
}","private String getAbrvFromUnit(String t,String s){
  int i=0;
  Converter[] u;
  if (t == ""String_Node_Str"")   u=volUnits;
 else   u=weightUnits;
  while (i < u.length && !u[i].unit.equalsIgnoreCase(s)) {
    i++;
  }
  if (i >= u.length)   return null;
 else   return u[i].abrv;
}"
50552,"public void addOrInsert(Object o){
  int i=0;
  boolean found=false;
  while (i < list.size() && !found) {
    if (DEBUG)     System.out.println(o.getClass().getName().toString());
    if (o.getClass().getName().toString().equals(""String_Node_Str"")) {
      Yeast y=(Yeast)list.get(i);
      Yeast y2=(Yeast)o;
      found=y.getName().equalsIgnoreCase(y2.getName());
    }
 else     if (o.getClass().getName().toString().equals(""String_Node_Str"")) {
      Fermentable f=(Fermentable)list.get(i);
      Fermentable f2=(Fermentable)o;
      found=f.getName().equalsIgnoreCase(f2.getName());
    }
 else     if (o.getClass().getName().toString().equals(""String_Node_Str"")) {
      Hop h=(Hop)list.get(i);
      Hop h2=(Hop)o;
      found=h.getName().equalsIgnoreCase(h2.getName());
    }
 else     if (o.getClass().getName().toString().equals(""String_Node_Str"")) {
      Style s=(Style)list.get(i);
      Style s2=(Style)o;
      found=s.getName().equalsIgnoreCase(s2.getName());
    }
 else     if (o.getClass().getName().toString().equals(""String_Node_Str"")) {
      String q=(String)list.get(i);
      String q2=(String)o;
      found=q.equalsIgnoreCase(q2);
    }
    i++;
  }
  if (!found) {
    list.add(o);
    selected=o;
  }
 else   selected=list.get(i - 1);
}","public void addOrInsert(Object o){
  int i=0;
  boolean found=false;
  while (i < list.size() && !found) {
    if (o.getClass().getName().toString().equals(""String_Node_Str"")) {
      Yeast y=(Yeast)list.get(i);
      Yeast y2=(Yeast)o;
      found=y.getName().equalsIgnoreCase(y2.getName());
    }
 else     if (o.getClass().getName().toString().equals(""String_Node_Str"")) {
      Fermentable f=(Fermentable)list.get(i);
      Fermentable f2=(Fermentable)o;
      found=f.getName().equalsIgnoreCase(f2.getName());
    }
 else     if (o.getClass().getName().toString().equals(""String_Node_Str"")) {
      Hop h=(Hop)list.get(i);
      Hop h2=(Hop)o;
      found=h.getName().equalsIgnoreCase(h2.getName());
    }
 else     if (o.getClass().getName().toString().equals(""String_Node_Str"")) {
      Style s=(Style)list.get(i);
      Style s2=(Style)o;
      found=s.getName().equalsIgnoreCase(s2.getName());
    }
 else     if (o.getClass().getName().toString().equals(""String_Node_Str"")) {
      String q=(String)list.get(i);
      String q2=(String)o;
      found=q.equalsIgnoreCase(q2);
    }
    i++;
  }
  if (!found) {
    list.add(o);
    selected=o;
  }
 else {
    selected=list.get(i - 1);
  }
}"
50553,"public void displayWater(){
  String recipeUnitsAbrv=new Quantity().getVolAbrv(myRecipe.getVolUnits());
  String mashUnitsAbrv=new Quantity().getVolAbrv(myRecipe.mash.getMashVolUnits());
  totalWaterLbl.setText(myRecipe.getTotalWater());
  totalUnitsLbl.setText(recipeUnitsAbrv);
  usedMashLbl.setText(myRecipe.mash.getTotalWaterStr());
  usedInMashUnitsLbl.setText(mashUnitsAbrv);
  absorbedLbl.setText(myRecipe.mash.getAbsorbedStr());
  absorbedUnitsLbl.setText(mashUnitsAbrv);
  spargeWithLbl.setText(myRecipe.getSparge());
  spargeUnitsLbl.setText(mashUnitsAbrv);
  collectTxt.setValue(new Double(myRecipe.getPreBoilVol(myRecipe.getVolUnits())));
  collectUnitsLbl.setText(recipeUnitsAbrv);
  postBoilTxt.setValue(new Double(myRecipe.getPostBoilVol(myRecipe.getVolUnits())));
  postBoilUnitsLbl.setText(recipeUnitsAbrv);
  chillShrinkLbl.setText(myRecipe.getChillShrink());
  kettleTxt.setValue(new Double(myRecipe.getKettleLoss()));
  kettleUnitsLbl.setText(recipeUnitsAbrv);
  trubLossTxt.setValue(new Double(myRecipe.getTrubLoss()));
  trubLossUnitsLbl.setText(recipeUnitsAbrv);
  miscLossTxt.setValue(new Double(myRecipe.getMiscLoss()));
  miscLosUnitsLbl.setText(recipeUnitsAbrv);
  finalVolTxt.setValue(new Double(myRecipe.getFinalWortVol()));
  finalUnitsLbl.setText(recipeUnitsAbrv);
}","public void displayWater(){
  String recipeUnitsAbrv=Quantity.getVolAbrv(myRecipe.getVolUnits());
  String mashUnitsAbrv=Quantity.getVolAbrv(myRecipe.mash.getMashVolUnits());
  totalWaterLbl.setText(myRecipe.getTotalWater());
  totalUnitsLbl.setText(recipeUnitsAbrv);
  usedMashLbl.setText(myRecipe.mash.getTotalWaterStr());
  usedInMashUnitsLbl.setText(mashUnitsAbrv);
  absorbedLbl.setText(myRecipe.mash.getAbsorbedStr());
  absorbedUnitsLbl.setText(mashUnitsAbrv);
  spargeWithLbl.setText(myRecipe.getSparge());
  spargeUnitsLbl.setText(mashUnitsAbrv);
  collectTxt.setValue(new Double(myRecipe.getPreBoilVol(myRecipe.getVolUnits())));
  collectUnitsLbl.setText(recipeUnitsAbrv);
  postBoilTxt.setValue(new Double(myRecipe.getPostBoilVol(myRecipe.getVolUnits())));
  postBoilUnitsLbl.setText(recipeUnitsAbrv);
  chillShrinkLbl.setText(myRecipe.getChillShrink());
  kettleTxt.setValue(new Double(myRecipe.getKettleLoss()));
  kettleUnitsLbl.setText(recipeUnitsAbrv);
  trubLossTxt.setValue(new Double(myRecipe.getTrubLoss()));
  trubLossUnitsLbl.setText(recipeUnitsAbrv);
  miscLossTxt.setValue(new Double(myRecipe.getMiscLoss()));
  miscLosUnitsLbl.setText(recipeUnitsAbrv);
  finalVolTxt.setValue(new Double(myRecipe.getFinalWortVol()));
  finalUnitsLbl.setText(recipeUnitsAbrv);
}"
50554,"public String toXML(){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"" + SBStringUtils.subEntities(name) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + SBStringUtils.subEntities(brewer) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + SBStringUtils.subEntities(comments) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + efficiency + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + SBStringUtils.df3.format(estOg) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + SBStringUtils.df3.format(estFg) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + style.getName() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + mashed + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + SBStringUtils.df1.format(srm) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + SBStringUtils.df1.format(ibu) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + SBStringUtils.df1.format(alcohol) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + boilMinutes + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + preBoilVol.getValue() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + postBoilVol.getValue() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + postBoilVol.getUnits() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + maltUnits + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + hopUnits + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + yeast.getName() + ""String_Node_Str"");
  SimpleDateFormat df=new SimpleDateFormat(""String_Node_Str"");
  sb.append(""String_Node_Str"" + df.format(created.getTime()) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + attenuation + ""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"" + alcMethod + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + ibuCalcMethod + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + colourMethod + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + evap + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + evapMethod + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + kettleLoss + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + trubLoss + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + miscLoss + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + pelletHopPct + ""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (int i=0; i < fermentables.size(); i++) {
    Fermentable m=(Fermentable)fermentables.get(i);
    sb.append(m.toXML());
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (int i=0; i < hops.size(); i++) {
    Hop h=(Hop)hops.get(i);
    sb.append(h.toXML());
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (int i=0; i < misc.size(); i++) {
    Misc mi=(Misc)misc.get(i);
    sb.append(mi.toXML());
  }
  sb.append(""String_Node_Str"");
  sb.append(mash.toXml());
  sb.append(""String_Node_Str"");
  for (int i=0; i < notes.size(); i++) {
    sb.append(((Note)notes.get(i)).toXML());
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  return sb.toString();
}","public String toXML(){
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"" + SBStringUtils.subEntities(name) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + SBStringUtils.subEntities(brewer) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + SBStringUtils.subEntities(comments) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + efficiency + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + SBStringUtils.df3.format(estOg) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + SBStringUtils.df3.format(estFg) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + style.getName() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + mashed + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + SBStringUtils.df1.format(srm) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + SBStringUtils.df1.format(ibu) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + SBStringUtils.df1.format(alcohol) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + boilMinutes + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + preBoilVol.getValue() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + postBoilVol.getValue() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + postBoilVol.getUnits() + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + maltUnits + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + hopUnits + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + yeast.getName() + ""String_Node_Str"");
  SimpleDateFormat df=new SimpleDateFormat(""String_Node_Str"");
  sb.append(""String_Node_Str"" + df.format(created.getTime()) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + attenuation + ""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"" + alcMethod + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + ibuCalcMethod + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + colourMethod + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + evap + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + evapMethod + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + kettleLoss + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + trubLoss + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + miscLoss + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + pelletHopPct + ""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (int i=0; i < fermentables.size(); i++) {
    Fermentable m=(Fermentable)fermentables.get(i);
    sb.append(m.toXML());
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (int i=0; i < hops.size(); i++) {
    Hop h=(Hop)hops.get(i);
    sb.append(h.toXML());
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  for (int i=0; i < misc.size(); i++) {
    Misc mi=(Misc)misc.get(i);
    sb.append(mi.toXML());
  }
  sb.append(""String_Node_Str"");
  sb.append(mash.toXml());
  sb.append(""String_Node_Str"");
  for (int i=0; i < notes.size(); i++) {
    sb.append(((Note)notes.get(i)).toXML());
  }
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  return sb.toString();
}"
50555,"private void calcAlcohol(String method){
  double oPlato=sGToPlato(estOg);
  double fPlato=sGToPlato(estFg);
  double q=0.22 + 0.001 * oPlato;
  double re=(q * oPlato + fPlato) / (1.0 + q);
  alcohol=(oPlato - re) / (2.0665 - 0.010665 * oPlato);
  if (method == ""String_Node_Str"")   alcohol=alcohol * estFg / 0.794;
}","private void calcAlcohol(String method){
  double oPlato=sGToPlato(estOg);
  double fPlato=sGToPlato(estFg);
  double q=0.22 + 0.001 * oPlato;
  double re=(q * oPlato + fPlato) / (1.0 + q);
  alcohol=(oPlato - re) / (2.0665 - 0.010665 * oPlato);
  if (method.equalsIgnoreCase(""String_Node_Str""))   alcohol=alcohol * estFg / 0.794;
}"
50556,"public String toText(){
  MessageFormat mf;
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"" + name + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + brewer + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + SBStringUtils.df1.format(postBoilVol.getValue()) + ""String_Node_Str""+ postBoilVol.getUnits()+ ""String_Node_Str"");
  sb.append(""String_Node_Str"" + style.getName() + ""String_Node_Str"");
  mf=new MessageFormat(""String_Node_Str"");
  Object[] objs={new Double(estOg),new Double(estFg),new Double(alcohol)};
  sb.append(mf.format(objs));
  sb.append(""String_Node_Str"");
  sb.append(padLeft(""String_Node_Str"",30,' ') + ""String_Node_Str"");
  mf=new MessageFormat(""String_Node_Str"");
  for (int i=0; i < fermentables.size(); i++) {
    Fermentable f=(Fermentable)fermentables.get(i);
    Object[] objf={padLeft(f.getName(),30,' '),padRight(""String_Node_Str"" + SBStringUtils.df2.format(f.getAmountAs(f.getUnits())),6,' '),f.getUnits(),new Double(f.getPppg()),padRight(""String_Node_Str"" + SBStringUtils.df1.format(f.getLov()),6,' '),new Double(f.getPercent())};
    sb.append(mf.format(objf));
  }
  sb.append(""String_Node_Str"");
  sb.append(padLeft(""String_Node_Str"",20,' ') + ""String_Node_Str"");
  mf=new MessageFormat(""String_Node_Str"");
  for (int i=0; i < hops.size(); i++) {
    Hop h=(Hop)hops.get(i);
    Object[] objh={padLeft(h.getName(),20,' '),padRight(""String_Node_Str"" + SBStringUtils.df2.format(h.getAmountAs(h.getUnits())),6,' '),h.getUnits(),padRight(""String_Node_Str"" + h.getAlpha(),5,' '),padRight(""String_Node_Str"" + SBStringUtils.df1.format(h.getMinutes()),6,' '),padRight(""String_Node_Str"" + SBStringUtils.df1.format(h.getIBU()),5,' ')};
    sb.append(mf.format(objh));
  }
  sb.append(""String_Node_Str"");
  sb.append(padLeft(""String_Node_Str"",10,' ') + ""String_Node_Str"");
  mf=new MessageFormat(""String_Node_Str"");
  for (int i=0; i < mash.getStepSize(); i++) {
    Object[] objm={padLeft(mash.getStepType(i),10,' '),padRight(""String_Node_Str"" + mash.getStepStartTemp(i),6,' '),padRight(""String_Node_Str"" + mash.getStepEndTemp(i),6,' '),padRight(""String_Node_Str"" + mash.getStepRampMin(i),4,' '),padRight(""String_Node_Str"" + mash.getStepMin(i),6,' ')};
    sb.append(mf.format(objm));
  }
  return sb.toString();
}","public String toText(){
  MessageFormat mf;
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"" + name + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + brewer + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + SBStringUtils.df1.format(postBoilVol.getValue()) + ""String_Node_Str""+ postBoilVol.getUnits()+ ""String_Node_Str"");
  sb.append(""String_Node_Str"" + style.getName() + ""String_Node_Str"");
  mf=new MessageFormat(""String_Node_Str"");
  Object[] objs={new Double(estOg),new Double(estFg),new Double(alcohol),new Double(ibu)};
  sb.append(mf.format(objs));
  sb.append(""String_Node_Str"" + alcMethod + ""String_Node_Str""+ ibuCalcMethod+ ""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(padLeft(""String_Node_Str"",30,' ') + ""String_Node_Str"");
  mf=new MessageFormat(""String_Node_Str"");
  for (int i=0; i < fermentables.size(); i++) {
    Fermentable f=(Fermentable)fermentables.get(i);
    Object[] objf={padLeft(f.getName(),30,' '),padRight(""String_Node_Str"" + SBStringUtils.df2.format(f.getAmountAs(f.getUnits())),6,' '),f.getUnits(),new Double(f.getPppg()),padRight(""String_Node_Str"" + SBStringUtils.df1.format(f.getLov()),6,' '),new Double(f.getPercent())};
    sb.append(mf.format(objf));
  }
  sb.append(""String_Node_Str"");
  sb.append(padLeft(""String_Node_Str"",20,' ') + ""String_Node_Str"");
  mf=new MessageFormat(""String_Node_Str"");
  for (int i=0; i < hops.size(); i++) {
    Hop h=(Hop)hops.get(i);
    Object[] objh={padLeft(h.getName(),20,' '),padRight(""String_Node_Str"" + SBStringUtils.df2.format(h.getAmountAs(h.getUnits())),6,' '),h.getUnits(),padRight(""String_Node_Str"" + h.getAlpha(),5,' '),padRight(""String_Node_Str"" + SBStringUtils.df1.format(h.getMinutes()),6,' '),padRight(""String_Node_Str"" + SBStringUtils.df1.format(h.getIBU()),5,' ')};
    sb.append(mf.format(objh));
  }
  sb.append(""String_Node_Str"");
  sb.append(padLeft(""String_Node_Str"",10,' ') + ""String_Node_Str"");
  mf=new MessageFormat(""String_Node_Str"");
  for (int i=0; i < mash.getStepSize(); i++) {
    Object[] objm={padLeft(mash.getStepType(i),10,' '),padRight(""String_Node_Str"" + mash.getStepStartTemp(i),6,' '),padRight(""String_Node_Str"" + mash.getStepEndTemp(i),6,' '),padRight(""String_Node_Str"" + mash.getStepRampMin(i),4,' '),padRight(""String_Node_Str"" + mash.getStepMin(i),6,' ')};
    sb.append(mf.format(objm));
  }
  return sb.toString();
}"
50557,"private void initGUI(){
  try {
    GridBagLayout thisLayout=new GridBagLayout();
    thisLayout.columnWeights=new double[]{0.1,0.1,0.1};
    thisLayout.columnWidths=new int[]{7,7,7};
    thisLayout.rowWeights=new double[]{0.1,0.8,0.1,0.1,0.1,0.1};
    thisLayout.rowHeights=new int[]{7,7,7,7,7,7};
    getContentPane().setLayout(thisLayout);
    setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
    this.setTitle(""String_Node_Str"");
{
{
      }
      titlePanel=new JPanel();
      FlowLayout titlePanelLayout=new FlowLayout();
      titlePanelLayout.setAlignment(FlowLayout.LEFT);
      titlePanel.setLayout(titlePanelLayout);
      this.getContentPane().add(titlePanel,new GridBagConstraints(0,0,2,1,0.0,0.0,GridBagConstraints.NORTH,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
{
        titleLabel=new JLabel();
        titlePanel.add(titleLabel);
        titleLabel.setText(""String_Node_Str"");
        titleLabel.setFont(new java.awt.Font(""String_Node_Str"",0,12));
      }
{
        recipeNameLabel=new JLabel();
        titlePanel.add(recipeNameLabel);
        recipeNameLabel.setText(""String_Node_Str"");
      }
    }
{
      tablePanel=new JPanel();
      BorderLayout pnlTableLayout=new BorderLayout();
      tablePanel.setLayout(pnlTableLayout);
      this.getContentPane().add(tablePanel,new GridBagConstraints(0,1,2,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
      tablePanel.setName(""String_Node_Str"");
      tablePanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
{
        jScrollPane1=new JScrollPane();
        tablePanel.add(jScrollPane1,BorderLayout.CENTER);
        jScrollPane1.setPreferredSize(new java.awt.Dimension(424,-32));
{
          mashModel=new MashTableModel(this);
          tblMash=new JTable();
          jScrollPane1.setViewportView(tblMash);
          tblMash.setModel(mashModel);
          tblMash.setAutoCreateColumnsFromModel(false);
          tblMash.getTableHeader().setReorderingAllowed(false);
          tblMash.addMouseListener(new MouseAdapter(){
            public void mouseClicked(            MouseEvent evt){
              int i=tblMash.getSelectedRow();
              directionsTextArea.setText(myRecipe.mash.getStepDirections(i));
            }
          }
);
          String[] types={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
          JComboBox typesComboBox=new JComboBox(types);
          TableColumn mashColumn=tblMash.getColumnModel().getColumn(0);
          mashColumn.setCellEditor(new DefaultCellEditor(typesComboBox));
          String[] methods={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
          JComboBox methodComboBox=new JComboBox(methods);
          mashColumn=tblMash.getColumnModel().getColumn(1);
          mashColumn.setCellEditor(new DefaultCellEditor(methodComboBox));
        }
      }
{
        buttonsPanel=new JPanel();
        FlowLayout buttonsPanelLayout=new FlowLayout();
        buttonsPanelLayout.setAlignment(FlowLayout.LEFT);
        buttonsPanel.setLayout(buttonsPanelLayout);
        tablePanel.add(buttonsPanel,BorderLayout.SOUTH);
{
          addStepButton=new JButton();
          buttonsPanel.add(addStepButton);
          addStepButton.setText(""String_Node_Str"");
          addStepButton.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              addStepButtonActionPerformed(evt);
            }
          }
);
        }
{
          delStepButton=new JButton();
          buttonsPanel.add(delStepButton);
          delStepButton.setText(""String_Node_Str"");
          delStepButton.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              delStepButtonActionPerformed(evt);
            }
          }
);
        }
{
          weightPanel=new JPanel();
          BoxLayout statsPanelLayout=new BoxLayout(weightPanel,javax.swing.BoxLayout.X_AXIS);
          weightPanel.setLayout(statsPanelLayout);
          buttonsPanel.add(weightPanel);
          weightPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
          weightPanel.setPreferredSize(new java.awt.Dimension(98,39));
{
            totalMashLabel=new JLabel();
            weightPanel.add(totalMashLabel);
            totalMashLabel.setPreferredSize(new java.awt.Dimension(118,13));
            totalMashLabel.setText(""String_Node_Str"");
          }
        }
{
          timePanel=new JPanel();
          BoxLayout timePanelLayout=new BoxLayout(timePanel,javax.swing.BoxLayout.X_AXIS);
          timePanel.setLayout(timePanelLayout);
          buttonsPanel.add(timePanel);
          timePanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
          timePanel.setPreferredSize(new java.awt.Dimension(79,43));
{
            totalTimeLabel=new JLabel();
            timePanel.add(totalTimeLabel);
            totalTimeLabel.setText(""String_Node_Str"");
            totalTimeLabel.setPreferredSize(new java.awt.Dimension(111,17));
          }
        }
{
          volPanel=new JPanel();
          BoxLayout volPanelLayout=new BoxLayout(volPanel,javax.swing.BoxLayout.X_AXIS);
          volPanel.setLayout(volPanelLayout);
          buttonsPanel.add(volPanel);
          volPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
          volPanel.setPreferredSize(new java.awt.Dimension(117,42));
{
            volLabel=new JLabel();
            volPanel.add(volLabel);
            volLabel.setText(""String_Node_Str"");
          }
        }
      }
    }
{
      settingsPanel=new JPanel();
      FlowLayout settingsPanelLayout=new FlowLayout();
      settingsPanelLayout.setAlignment(FlowLayout.LEFT);
      settingsPanel.setLayout(settingsPanelLayout);
      this.getContentPane().add(settingsPanel,new GridBagConstraints(0,2,2,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
{
        tempPanel=new JPanel();
        settingsPanel.add(tempPanel);
        tempPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
{
          tempFrb=new JRadioButton();
          tempPanel.add(tempFrb);
          tempFrb.setText(""String_Node_Str"");
          tempFrb.addActionListener(this);
        }
{
          tempCrb=new JRadioButton();
          tempPanel.add(tempCrb);
          tempCrb.setText(""String_Node_Str"");
          tempCrb.addActionListener(this);
        }
        tempUnitsButtonGroup=new ButtonGroup();
        tempUnitsButtonGroup.add(tempFrb);
        tempUnitsButtonGroup.add(tempCrb);
      }
{
        volUnitsPanel=new JPanel();
        settingsPanel.add(volUnitsPanel);
        volUnitsPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
{
          volUnitsComboModel=new ComboModel();
          volUnitsComboModel.setList(new Quantity().getListofUnits(""String_Node_Str""));
          volUnitsCombo=new JComboBox();
          volUnitsPanel.add(volUnitsCombo);
          volUnitsCombo.setModel(volUnitsComboModel);
          volUnitsCombo.addActionListener(this);
        }
      }
{
        ratioPanel=new JPanel();
        settingsPanel.add(ratioPanel);
        ratioPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
{
          ratioLabel=new JLabel();
          ratioPanel.add(ratioLabel);
          ratioLabel.setText(""String_Node_Str"");
        }
{
          ratioText=new JTextField();
          ratioPanel.add(ratioText);
          ratioText.setText(""String_Node_Str"");
          ratioText.addFocusListener(this);
          ratioText.addActionListener(this);
        }
{
          ComboBoxModel ratioUnitsComboModel=new DefaultComboBoxModel(new String[]{""String_Node_Str"",""String_Node_Str""});
          ratioUnitsCombo=new JComboBox();
          ratioPanel.add(ratioUnitsCombo);
          ratioUnitsCombo.setModel(ratioUnitsComboModel);
          ratioUnitsCombo.addActionListener(this);
        }
      }
    }
{
      directionsPanel=new JPanel();
      getContentPane().add(directionsPanel,new GridBagConstraints(0,3,2,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
      BorderLayout directionsPanelLayout=new BorderLayout();
      directionsPanel.setLayout(directionsPanelLayout);
      directionsPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
      directionsPanel.setPreferredSize(new java.awt.Dimension(181,75));
{
        directionsTextArea=new JTextArea();
        directionsPanel.add(directionsTextArea,BorderLayout.CENTER);
        directionsTextArea.setText(""String_Node_Str"");
        directionsTextArea.setPreferredSize(new java.awt.Dimension(171,38));
        directionsTextArea.setEditable(false);
        directionsTextArea.setLineWrap(true);
      }
    }
{
      pnlButtons=new JPanel();
      FlowLayout pnlButtonsLayout=new FlowLayout();
      pnlButtonsLayout.setAlignment(FlowLayout.RIGHT);
      pnlButtons.setLayout(pnlButtonsLayout);
      getContentPane().add(pnlButtons,new GridBagConstraints(1,6,2,1,0.0,0.0,GridBagConstraints.SOUTH,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
{
        btnOk=new JButton();
        pnlButtons.add(btnOk);
        btnOk.setText(""String_Node_Str"");
        btnOk.addActionListener(this);
      }
    }
{
      moreSettingsPanel=new JPanel();
      FlowLayout moreSettingsPanelLayout=new FlowLayout();
      moreSettingsPanelLayout.setAlignment(FlowLayout.LEFT);
      moreSettingsPanel.setLayout(moreSettingsPanelLayout);
      this.getContentPane().add(moreSettingsPanel,new GridBagConstraints(1,3,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
    }
{
      waterUsePanel=new JPanel();
      GridBagLayout waterUsePanelLayout=new GridBagLayout();
      waterUsePanelLayout.rowWeights=new double[]{0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1};
      waterUsePanelLayout.rowHeights=new int[]{7,7,7,7,7,7,7,7,7,7,7,7};
      waterUsePanelLayout.columnWeights=new double[]{0.1,0.1};
      waterUsePanelLayout.columnWidths=new int[]{7,7};
      waterUsePanel.setLayout(waterUsePanelLayout);
      getContentPane().add(waterUsePanel,new GridBagConstraints(2,1,1,3,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
      waterUsePanel.setBorder(BorderFactory.createTitledBorder(null,""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP));
{
        jLabel1=new JLabel();
        waterUsePanel.add(jLabel1,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel1.setText(""String_Node_Str"");
      }
{
        jLabel2=new JLabel();
        waterUsePanel.add(jLabel2,new GridBagConstraints(0,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel2.setText(""String_Node_Str"");
      }
{
        jLabel3=new JLabel();
        waterUsePanel.add(jLabel3,new GridBagConstraints(0,2,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel3.setText(""String_Node_Str"");
      }
{
        jLabel4=new JLabel();
        waterUsePanel.add(jLabel4,new GridBagConstraints(0,3,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel4.setText(""String_Node_Str"");
      }
{
        jLabel5=new JLabel();
        waterUsePanel.add(jLabel5,new GridBagConstraints(0,4,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel5.setText(""String_Node_Str"");
      }
{
        jLabel6=new JLabel();
        waterUsePanel.add(jLabel6,new GridBagConstraints(0,5,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel6.setText(""String_Node_Str"");
      }
{
        jLabel7=new JLabel();
        waterUsePanel.add(jLabel7,new GridBagConstraints(0,7,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel7.setText(""String_Node_Str"");
      }
{
        jLabel8=new JLabel();
        waterUsePanel.add(jLabel8,new GridBagConstraints(0,6,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel8.setText(""String_Node_Str"");
      }
{
        jLabel9=new JLabel();
        waterUsePanel.add(jLabel9,new GridBagConstraints(0,8,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel9.setText(""String_Node_Str"");
      }
{
        jLabel10=new JLabel();
        waterUsePanel.add(jLabel10,new GridBagConstraints(0,9,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel10.setText(""String_Node_Str"");
      }
{
        jLabel11=new JLabel();
        waterUsePanel.add(jLabel11,new GridBagConstraints(0,10,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel11.setText(""String_Node_Str"");
      }
{
        totalWaterLbl=new JLabel();
        waterUsePanel.add(totalWaterLbl,new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        totalWaterLbl.setText(""String_Node_Str"");
      }
{
        absorbedLbl=new JLabel();
        waterUsePanel.add(absorbedLbl,new GridBagConstraints(1,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        absorbedLbl.setText(""String_Node_Str"");
      }
{
        usedMashLbl=new JLabel();
        waterUsePanel.add(usedMashLbl,new GridBagConstraints(1,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        usedMashLbl.setText(""String_Node_Str"");
      }
{
        spargeWithLbl=new JLabel();
        waterUsePanel.add(spargeWithLbl,new GridBagConstraints(1,3,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        spargeWithLbl.setText(""String_Node_Str"");
      }
{
        collectUnitsLbl=new JLabel();
        waterUsePanel.add(collectUnitsLbl,new GridBagConstraints(2,4,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        collectUnitsLbl.setText(""String_Node_Str"");
      }
{
        spargeUnitsLbl=new JLabel();
        waterUsePanel.add(spargeUnitsLbl,new GridBagConstraints(2,3,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        spargeUnitsLbl.setText(""String_Node_Str"");
      }
{
        absorbedUnitsLbl=new JLabel();
        waterUsePanel.add(absorbedUnitsLbl,new GridBagConstraints(2,2,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        absorbedUnitsLbl.setText(""String_Node_Str"");
      }
{
        usedInMashUnitsLbl=new JLabel();
        waterUsePanel.add(usedInMashUnitsLbl,new GridBagConstraints(2,1,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        usedInMashUnitsLbl.setText(""String_Node_Str"");
      }
{
        totalUnitsLbl=new JLabel();
        waterUsePanel.add(totalUnitsLbl,new GridBagConstraints(2,0,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        totalUnitsLbl.setText(""String_Node_Str"");
      }
{
        postBoilUnitsLbl=new JLabel();
        waterUsePanel.add(postBoilUnitsLbl,new GridBagConstraints(2,5,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        postBoilUnitsLbl.setText(""String_Node_Str"");
      }
{
        collectTxt=new JFormattedTextField();
        collectTxt.addFocusListener(this);
        collectTxt.addActionListener(this);
        waterUsePanel.add(collectTxt,new GridBagConstraints(1,4,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
        collectTxt.setText(""String_Node_Str"");
      }
{
        postBoilTxt=new JFormattedTextField();
        postBoilTxt.addFocusListener(this);
        postBoilTxt.addActionListener(this);
        waterUsePanel.add(postBoilTxt,new GridBagConstraints(1,5,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
        postBoilTxt.setText(""String_Node_Str"");
      }
{
        chillShrinkLbl=new JLabel();
        waterUsePanel.add(chillShrinkLbl,new GridBagConstraints(1,6,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        chillShrinkLbl.setText(""String_Node_Str"");
      }
{
        kettleTxt=new JFormattedTextField();
        kettleTxt.addFocusListener(this);
        kettleTxt.addActionListener(this);
        waterUsePanel.add(kettleTxt,new GridBagConstraints(1,7,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
        kettleTxt.setText(""String_Node_Str"");
      }
{
        kettleUnitsLbl=new JLabel();
        waterUsePanel.add(kettleUnitsLbl,new GridBagConstraints(2,7,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        kettleUnitsLbl.setText(""String_Node_Str"");
      }
{
        trubLossTxt=new JFormattedTextField();
        trubLossTxt.addFocusListener(this);
        trubLossTxt.addActionListener(this);
        waterUsePanel.add(trubLossTxt,new GridBagConstraints(1,8,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
        trubLossTxt.setText(""String_Node_Str"");
      }
{
        miscLossTxt=new JFormattedTextField();
        miscLossTxt.addFocusListener(this);
        miscLossTxt.addActionListener(this);
        waterUsePanel.add(miscLossTxt,new GridBagConstraints(1,9,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
        miscLossTxt.setText(""String_Node_Str"");
      }
{
        finalVolTxt=new JFormattedTextField();
        finalVolTxt.addFocusListener(this);
        finalVolTxt.addActionListener(this);
        waterUsePanel.add(finalVolTxt,new GridBagConstraints(1,10,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
        finalVolTxt.setText(""String_Node_Str"");
      }
{
        trubLossUnitsLbl=new JLabel();
        waterUsePanel.add(trubLossUnitsLbl,new GridBagConstraints(2,8,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        trubLossUnitsLbl.setText(""String_Node_Str"");
      }
{
        miscLosUnitsLbl=new JLabel();
        waterUsePanel.add(miscLosUnitsLbl,new GridBagConstraints(2,9,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        miscLosUnitsLbl.setText(""String_Node_Str"");
      }
{
        finalUnitsLbl=new JLabel();
        waterUsePanel.add(finalUnitsLbl,new GridBagConstraints(2,10,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        finalUnitsLbl.setText(""String_Node_Str"");
      }
    }
{
      grainTempPanel=new JPanel();
      getContentPane().add(grainTempPanel,new GridBagConstraints(0,4,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
      BoxLayout grainTempPanelLayout=new BoxLayout(grainTempPanel,javax.swing.BoxLayout.X_AXIS);
      grainTempPanel.setLayout(grainTempPanelLayout);
      grainTempPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
      grainTempPanel.setPreferredSize(new java.awt.Dimension(94,45));
{
        grainTempText=new JTextField();
        grainTempPanel.add(grainTempText);
        grainTempText.setText(""String_Node_Str"");
        grainTempText.setPreferredSize(new java.awt.Dimension(67,15));
        grainTempText.addFocusListener(this);
        grainTempText.addActionListener(this);
      }
{
        grainTempULabel=new JLabel();
        grainTempPanel.add(grainTempULabel);
        grainTempULabel.setText(""String_Node_Str"");
      }
    }
{
      tempLostPanel=new JPanel();
      getContentPane().add(tempLostPanel,new GridBagConstraints(1,4,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
      BoxLayout tempLostPanelLayout=new BoxLayout(tempLostPanel,javax.swing.BoxLayout.X_AXIS);
      tempLostPanel.setLayout(tempLostPanelLayout);
      tempLostPanel.setPreferredSize(new java.awt.Dimension(104,45));
      tempLostPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
{
        tunLossTxt=new JTextField();
        tempLostPanel.add(tunLossTxt);
        tunLossTxt.addFocusListener(this);
        tunLossTxt.addActionListener(this);
      }
{
        tempLostULabel=new JLabel();
        tempLostPanel.add(tempLostULabel);
        tempLostULabel.setText(""String_Node_Str"");
      }
    }
    boilTempPanel=new JPanel();
    BoxLayout boilTempPanelLayout=new BoxLayout(boilTempPanel,javax.swing.BoxLayout.X_AXIS);
    boilTempPanel.setLayout(boilTempPanelLayout);
    getContentPane().add(boilTempPanel,new GridBagConstraints(0,5,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
    boilTempPanel.setBorder(BorderFactory.createTitledBorder(null,""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP));
    boilTempTxt=new JTextField();
    boilTempPanel.add(boilTempTxt);
    boilTempTxt.setText(""String_Node_Str"");
    boilTempTxt.addFocusListener(this);
    boilTempTxt.addActionListener(this);
    jLabel12=new JLabel();
    boilTempPanel.add(jLabel12);
    jLabel12.setText(""String_Node_Str"");
    pack();
    this.setSize(550,400);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","private void initGUI(){
  try {
    GridBagLayout thisLayout=new GridBagLayout();
    thisLayout.columnWeights=new double[]{0.1,0.1,0.1};
    thisLayout.columnWidths=new int[]{7,7,7};
    thisLayout.rowWeights=new double[]{0.1,0.8,0.1,0.1,0.1,0.1};
    thisLayout.rowHeights=new int[]{7,7,7,7,7,7};
    getContentPane().setLayout(thisLayout);
    setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
    this.setTitle(""String_Node_Str"");
{
{
      }
      titlePanel=new JPanel();
      FlowLayout titlePanelLayout=new FlowLayout();
      titlePanelLayout.setAlignment(FlowLayout.LEFT);
      titlePanel.setLayout(titlePanelLayout);
      this.getContentPane().add(titlePanel,new GridBagConstraints(0,0,2,1,0.0,0.0,GridBagConstraints.NORTH,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
{
        titleLabel=new JLabel();
        titlePanel.add(titleLabel);
        titleLabel.setText(""String_Node_Str"");
        titleLabel.setFont(new java.awt.Font(""String_Node_Str"",0,12));
      }
{
        recipeNameLabel=new JLabel();
        titlePanel.add(recipeNameLabel);
        recipeNameLabel.setText(""String_Node_Str"");
      }
    }
{
      tablePanel=new JPanel();
      BorderLayout pnlTableLayout=new BorderLayout();
      tablePanel.setLayout(pnlTableLayout);
      this.getContentPane().add(tablePanel,new GridBagConstraints(0,1,2,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
      tablePanel.setName(""String_Node_Str"");
      tablePanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
{
        jScrollPane1=new JScrollPane();
        tablePanel.add(jScrollPane1,BorderLayout.CENTER);
        jScrollPane1.setPreferredSize(new java.awt.Dimension(424,-32));
{
          mashModel=new MashTableModel(this);
          tblMash=new JTable();
          jScrollPane1.setViewportView(tblMash);
          tblMash.setModel(mashModel);
          tblMash.setAutoCreateColumnsFromModel(false);
          tblMash.getTableHeader().setReorderingAllowed(false);
          tblMash.addMouseListener(new MouseAdapter(){
            public void mouseClicked(            MouseEvent evt){
              int i=tblMash.getSelectedRow();
              directionsTextArea.setText(myRecipe.mash.getStepDirections(i));
            }
          }
);
          String[] types={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
          JComboBox typesComboBox=new JComboBox(types);
          TableColumn mashColumn=tblMash.getColumnModel().getColumn(0);
          mashColumn.setCellEditor(new DefaultCellEditor(typesComboBox));
          String[] methods={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
          JComboBox methodComboBox=new JComboBox(methods);
          mashColumn=tblMash.getColumnModel().getColumn(1);
          mashColumn.setCellEditor(new DefaultCellEditor(methodComboBox));
        }
      }
{
        buttonsPanel=new JPanel();
        FlowLayout buttonsPanelLayout=new FlowLayout();
        buttonsPanelLayout.setAlignment(FlowLayout.LEFT);
        buttonsPanel.setLayout(buttonsPanelLayout);
        tablePanel.add(buttonsPanel,BorderLayout.SOUTH);
{
          addStepButton=new JButton();
          buttonsPanel.add(addStepButton);
          addStepButton.setText(""String_Node_Str"");
          addStepButton.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              addStepButtonActionPerformed(evt);
            }
          }
);
        }
{
          delStepButton=new JButton();
          buttonsPanel.add(delStepButton);
          delStepButton.setText(""String_Node_Str"");
          delStepButton.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              delStepButtonActionPerformed(evt);
            }
          }
);
        }
{
          weightPanel=new JPanel();
          BoxLayout statsPanelLayout=new BoxLayout(weightPanel,javax.swing.BoxLayout.X_AXIS);
          weightPanel.setLayout(statsPanelLayout);
          buttonsPanel.add(weightPanel);
          weightPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
          weightPanel.setPreferredSize(new java.awt.Dimension(98,39));
{
            totalMashLabel=new JLabel();
            weightPanel.add(totalMashLabel);
            totalMashLabel.setPreferredSize(new java.awt.Dimension(118,13));
            totalMashLabel.setText(""String_Node_Str"");
          }
        }
{
          timePanel=new JPanel();
          BoxLayout timePanelLayout=new BoxLayout(timePanel,javax.swing.BoxLayout.X_AXIS);
          timePanel.setLayout(timePanelLayout);
          buttonsPanel.add(timePanel);
          timePanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
          timePanel.setPreferredSize(new java.awt.Dimension(79,43));
{
            totalTimeLabel=new JLabel();
            timePanel.add(totalTimeLabel);
            totalTimeLabel.setText(""String_Node_Str"");
            totalTimeLabel.setPreferredSize(new java.awt.Dimension(111,17));
          }
        }
{
          volPanel=new JPanel();
          BoxLayout volPanelLayout=new BoxLayout(volPanel,javax.swing.BoxLayout.X_AXIS);
          volPanel.setLayout(volPanelLayout);
          buttonsPanel.add(volPanel);
          volPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
          volPanel.setPreferredSize(new java.awt.Dimension(117,42));
{
            volLabel=new JLabel();
            volPanel.add(volLabel);
            volLabel.setText(""String_Node_Str"");
          }
        }
      }
    }
{
      settingsPanel=new JPanel();
      FlowLayout settingsPanelLayout=new FlowLayout();
      settingsPanelLayout.setAlignment(FlowLayout.LEFT);
      settingsPanel.setLayout(settingsPanelLayout);
      this.getContentPane().add(settingsPanel,new GridBagConstraints(0,2,2,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
{
        tempPanel=new JPanel();
        settingsPanel.add(tempPanel);
        tempPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
{
          tempFrb=new JRadioButton();
          tempPanel.add(tempFrb);
          tempFrb.setText(""String_Node_Str"");
          tempFrb.addActionListener(this);
        }
{
          tempCrb=new JRadioButton();
          tempPanel.add(tempCrb);
          tempCrb.setText(""String_Node_Str"");
          tempCrb.addActionListener(this);
        }
        tempUnitsButtonGroup=new ButtonGroup();
        tempUnitsButtonGroup.add(tempFrb);
        tempUnitsButtonGroup.add(tempCrb);
      }
{
        volUnitsPanel=new JPanel();
        settingsPanel.add(volUnitsPanel);
        volUnitsPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
{
          volUnitsComboModel=new ComboModel();
          volUnitsComboModel.setList(new Quantity().getListofUnits(""String_Node_Str""));
          volUnitsCombo=new JComboBox();
          volUnitsPanel.add(volUnitsCombo);
          volUnitsCombo.setModel(volUnitsComboModel);
          volUnitsCombo.addActionListener(this);
        }
      }
{
        ratioPanel=new JPanel();
        settingsPanel.add(ratioPanel);
        ratioPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
{
          ratioLabel=new JLabel();
          ratioPanel.add(ratioLabel);
          ratioLabel.setText(""String_Node_Str"");
        }
{
          ratioText=new JTextField();
          ratioPanel.add(ratioText);
          ratioText.setText(""String_Node_Str"");
          ratioText.addFocusListener(this);
          ratioText.addActionListener(this);
        }
{
          ComboBoxModel ratioUnitsComboModel=new DefaultComboBoxModel(new String[]{""String_Node_Str"",""String_Node_Str""});
          ratioUnitsCombo=new JComboBox();
          ratioPanel.add(ratioUnitsCombo);
          ratioUnitsCombo.setModel(ratioUnitsComboModel);
          ratioUnitsCombo.addActionListener(this);
        }
      }
    }
{
      directionsPanel=new JPanel();
      getContentPane().add(directionsPanel,new GridBagConstraints(0,3,2,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
      BorderLayout directionsPanelLayout=new BorderLayout();
      directionsPanel.setLayout(directionsPanelLayout);
      directionsPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
      directionsPanel.setPreferredSize(new java.awt.Dimension(181,75));
{
        directionsTextArea=new JTextArea();
        directionsPanel.add(directionsTextArea,BorderLayout.CENTER);
        directionsTextArea.setText(""String_Node_Str"");
        directionsTextArea.setPreferredSize(new java.awt.Dimension(171,38));
        directionsTextArea.setEditable(false);
        directionsTextArea.setLineWrap(true);
      }
    }
{
      pnlButtons=new JPanel();
      FlowLayout pnlButtonsLayout=new FlowLayout();
      pnlButtonsLayout.setAlignment(FlowLayout.RIGHT);
      pnlButtons.setLayout(pnlButtonsLayout);
      getContentPane().add(pnlButtons,new GridBagConstraints(1,6,2,1,0.0,0.0,GridBagConstraints.SOUTH,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
{
        btnOk=new JButton();
        pnlButtons.add(btnOk);
        btnOk.setText(""String_Node_Str"");
        btnOk.addActionListener(this);
      }
    }
{
      moreSettingsPanel=new JPanel();
      FlowLayout moreSettingsPanelLayout=new FlowLayout();
      moreSettingsPanelLayout.setAlignment(FlowLayout.LEFT);
      moreSettingsPanel.setLayout(moreSettingsPanelLayout);
      this.getContentPane().add(moreSettingsPanel,new GridBagConstraints(1,3,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
    }
{
      waterUsePanel=new JPanel();
      GridBagLayout waterUsePanelLayout=new GridBagLayout();
      waterUsePanelLayout.rowWeights=new double[]{0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1};
      waterUsePanelLayout.rowHeights=new int[]{7,7,7,7,7,7,7,7,7,7,7,7};
      waterUsePanelLayout.columnWeights=new double[]{0.1,0.1};
      waterUsePanelLayout.columnWidths=new int[]{7,7};
      waterUsePanel.setLayout(waterUsePanelLayout);
      getContentPane().add(waterUsePanel,new GridBagConstraints(2,1,1,3,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
      waterUsePanel.setBorder(BorderFactory.createTitledBorder(null,""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP));
{
        jLabel1=new JLabel();
        waterUsePanel.add(jLabel1,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel1.setText(""String_Node_Str"");
      }
{
        jLabel2=new JLabel();
        waterUsePanel.add(jLabel2,new GridBagConstraints(0,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel2.setText(""String_Node_Str"");
      }
{
        jLabel3=new JLabel();
        waterUsePanel.add(jLabel3,new GridBagConstraints(0,2,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel3.setText(""String_Node_Str"");
      }
{
        jLabel4=new JLabel();
        waterUsePanel.add(jLabel4,new GridBagConstraints(0,3,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel4.setText(""String_Node_Str"");
      }
{
        jLabel5=new JLabel();
        waterUsePanel.add(jLabel5,new GridBagConstraints(0,4,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel5.setText(""String_Node_Str"");
      }
{
        jLabel6=new JLabel();
        waterUsePanel.add(jLabel6,new GridBagConstraints(0,5,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel6.setText(""String_Node_Str"");
      }
{
        jLabel7=new JLabel();
        waterUsePanel.add(jLabel7,new GridBagConstraints(0,7,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel7.setText(""String_Node_Str"");
      }
{
        jLabel8=new JLabel();
        waterUsePanel.add(jLabel8,new GridBagConstraints(0,6,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel8.setText(""String_Node_Str"");
      }
{
        jLabel9=new JLabel();
        waterUsePanel.add(jLabel9,new GridBagConstraints(0,8,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel9.setText(""String_Node_Str"");
      }
{
        jLabel10=new JLabel();
        waterUsePanel.add(jLabel10,new GridBagConstraints(0,9,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel10.setText(""String_Node_Str"");
      }
{
        jLabel11=new JLabel();
        waterUsePanel.add(jLabel11,new GridBagConstraints(0,10,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel11.setText(""String_Node_Str"");
      }
{
        totalWaterLbl=new JLabel();
        waterUsePanel.add(totalWaterLbl,new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        totalWaterLbl.setText(""String_Node_Str"");
      }
{
        absorbedLbl=new JLabel();
        waterUsePanel.add(absorbedLbl,new GridBagConstraints(1,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        absorbedLbl.setText(""String_Node_Str"");
      }
{
        usedMashLbl=new JLabel();
        waterUsePanel.add(usedMashLbl,new GridBagConstraints(1,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        usedMashLbl.setText(""String_Node_Str"");
      }
{
        spargeWithLbl=new JLabel();
        waterUsePanel.add(spargeWithLbl,new GridBagConstraints(1,3,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        spargeWithLbl.setText(""String_Node_Str"");
      }
{
        collectUnitsLbl=new JLabel();
        waterUsePanel.add(collectUnitsLbl,new GridBagConstraints(2,4,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        collectUnitsLbl.setText(""String_Node_Str"");
      }
{
        spargeUnitsLbl=new JLabel();
        waterUsePanel.add(spargeUnitsLbl,new GridBagConstraints(2,3,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        spargeUnitsLbl.setText(""String_Node_Str"");
      }
{
        absorbedUnitsLbl=new JLabel();
        waterUsePanel.add(absorbedUnitsLbl,new GridBagConstraints(2,2,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        absorbedUnitsLbl.setText(""String_Node_Str"");
      }
{
        usedInMashUnitsLbl=new JLabel();
        waterUsePanel.add(usedInMashUnitsLbl,new GridBagConstraints(2,1,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        usedInMashUnitsLbl.setText(""String_Node_Str"");
      }
{
        totalUnitsLbl=new JLabel();
        waterUsePanel.add(totalUnitsLbl,new GridBagConstraints(2,0,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        totalUnitsLbl.setText(""String_Node_Str"");
      }
{
        postBoilUnitsLbl=new JLabel();
        waterUsePanel.add(postBoilUnitsLbl,new GridBagConstraints(2,5,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        postBoilUnitsLbl.setText(""String_Node_Str"");
      }
{
        collectTxt=new JFormattedTextField();
        collectTxt.addFocusListener(this);
        collectTxt.addActionListener(this);
        waterUsePanel.add(collectTxt,new GridBagConstraints(1,4,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
        collectTxt.setText(""String_Node_Str"");
      }
{
        postBoilTxt=new JFormattedTextField();
        postBoilTxt.addFocusListener(this);
        postBoilTxt.addActionListener(this);
        waterUsePanel.add(postBoilTxt,new GridBagConstraints(1,5,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
        postBoilTxt.setText(""String_Node_Str"");
      }
{
        chillShrinkLbl=new JLabel();
        waterUsePanel.add(chillShrinkLbl,new GridBagConstraints(1,6,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        chillShrinkLbl.setText(""String_Node_Str"");
      }
{
        kettleTxt=new JFormattedTextField();
        kettleTxt.addFocusListener(this);
        kettleTxt.addActionListener(this);
        waterUsePanel.add(kettleTxt,new GridBagConstraints(1,7,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
        kettleTxt.setText(""String_Node_Str"");
      }
{
        kettleUnitsLbl=new JLabel();
        waterUsePanel.add(kettleUnitsLbl,new GridBagConstraints(2,7,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        kettleUnitsLbl.setText(""String_Node_Str"");
      }
{
        trubLossTxt=new JFormattedTextField();
        trubLossTxt.addFocusListener(this);
        trubLossTxt.addActionListener(this);
        waterUsePanel.add(trubLossTxt,new GridBagConstraints(1,8,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
        trubLossTxt.setText(""String_Node_Str"");
      }
{
        miscLossTxt=new JFormattedTextField();
        miscLossTxt.addFocusListener(this);
        miscLossTxt.addActionListener(this);
        waterUsePanel.add(miscLossTxt,new GridBagConstraints(1,9,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
        miscLossTxt.setText(""String_Node_Str"");
      }
{
        finalVolTxt=new JFormattedTextField();
        finalVolTxt.addFocusListener(this);
        finalVolTxt.addActionListener(this);
        waterUsePanel.add(finalVolTxt,new GridBagConstraints(1,10,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
        finalVolTxt.setText(""String_Node_Str"");
      }
{
        trubLossUnitsLbl=new JLabel();
        waterUsePanel.add(trubLossUnitsLbl,new GridBagConstraints(2,8,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        trubLossUnitsLbl.setText(""String_Node_Str"");
      }
{
        miscLosUnitsLbl=new JLabel();
        waterUsePanel.add(miscLosUnitsLbl,new GridBagConstraints(2,9,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        miscLosUnitsLbl.setText(""String_Node_Str"");
      }
{
        finalUnitsLbl=new JLabel();
        waterUsePanel.add(finalUnitsLbl,new GridBagConstraints(2,10,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        finalUnitsLbl.setText(""String_Node_Str"");
      }
    }
{
      grainTempPanel=new JPanel();
      getContentPane().add(grainTempPanel,new GridBagConstraints(0,4,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
      BoxLayout grainTempPanelLayout=new BoxLayout(grainTempPanel,javax.swing.BoxLayout.X_AXIS);
      grainTempPanel.setLayout(grainTempPanelLayout);
      grainTempPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
      grainTempPanel.setPreferredSize(new java.awt.Dimension(94,45));
{
        grainTempText=new JTextField();
        grainTempPanel.add(grainTempText);
        grainTempText.setText(""String_Node_Str"");
        grainTempText.setPreferredSize(new java.awt.Dimension(67,15));
        grainTempText.addFocusListener(this);
        grainTempText.addActionListener(this);
      }
{
        grainTempULabel=new JLabel();
        grainTempPanel.add(grainTempULabel);
        grainTempULabel.setText(""String_Node_Str"");
      }
    }
{
      tempLostPanel=new JPanel();
      getContentPane().add(tempLostPanel,new GridBagConstraints(1,4,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
      BoxLayout tempLostPanelLayout=new BoxLayout(tempLostPanel,javax.swing.BoxLayout.X_AXIS);
      tempLostPanel.setLayout(tempLostPanelLayout);
      tempLostPanel.setPreferredSize(new java.awt.Dimension(104,45));
      tempLostPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
{
        tunLossTxt=new JTextField();
        tempLostPanel.add(tunLossTxt);
        tunLossTxt.addFocusListener(this);
        tunLossTxt.addActionListener(this);
      }
{
        tempLostULabel=new JLabel();
        tempLostPanel.add(tempLostULabel);
        tempLostULabel.setText(""String_Node_Str"");
      }
    }
    boilTempPanel=new JPanel();
    BoxLayout boilTempPanelLayout=new BoxLayout(boilTempPanel,javax.swing.BoxLayout.X_AXIS);
    boilTempPanel.setLayout(boilTempPanelLayout);
    getContentPane().add(boilTempPanel,new GridBagConstraints(0,5,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
    boilTempPanel.setBorder(BorderFactory.createTitledBorder(null,""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP));
    boilTempTxt=new JTextField();
    boilTempPanel.add(boilTempTxt);
    boilTempTxt.setText(""String_Node_Str"");
    boilTempTxt.addFocusListener(this);
    boilTempTxt.addActionListener(this);
    jLabel12=new JLabel();
    boilTempPanel.add(jLabel12);
    jLabel12.setText(""String_Node_Str"");
    pack();
    this.setSize(600,530);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
50558,"public MashTableModel(MashManager m){
  mashManager=m;
}","public MashTableModel(){
  mashManager=null;
}"
50559,"private void layoutUi(){
  JPanel buttons=new JPanel();
  okButton=new JButton(""String_Node_Str"");
  okButton.addActionListener(this);
  JButton cancelButton=new JButton(""String_Node_Str"");
  cancelButton.addActionListener(this);
  buttons.setLayout(new FlowLayout(FlowLayout.RIGHT));
  buttons.add(cancelButton);
  buttons.add(okButton);
  getContentPane().setLayout(new BorderLayout());
  this.setFocusTraversalKeysEnabled(false);
{
    jTabbedPane1=new JTabbedPane();
    getContentPane().add(jTabbedPane1,BorderLayout.CENTER);
{
      pnlCalculations=new JPanel();
      jTabbedPane1.addTab(""String_Node_Str"",null,pnlCalculations,null);
{
        try {
{
            GridBagLayout thisLayout=new GridBagLayout();
            thisLayout.rowWeights=new double[]{0.1,0.1,0.1,0.1};
            thisLayout.rowHeights=new int[]{7,7,7,7};
            thisLayout.columnWeights=new double[]{0.1,0.2};
            thisLayout.columnWidths=new int[]{7,7};
            pnlCalculations.setLayout(thisLayout);
            pnlCalculations.setPreferredSize(new java.awt.Dimension(524,372));
{
{
                bgHopsCalc=new ButtonGroup();
{
                  pnlHops=new JPanel();
                  GridLayout pnlHopsLayout=new GridLayout(2,2);
                  pnlHopsLayout.setColumns(2);
                  pnlHopsLayout.setHgap(5);
                  pnlHopsLayout.setVgap(5);
                  pnlHopsLayout.setRows(2);
                  pnlHops.setLayout(pnlHopsLayout);
                  pnlCalculations.add(pnlHops,new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.NORTHWEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
                  pnlHops.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
{
                    jLabelc1=new JLabel();
                    pnlHops.add(jLabelc1);
                    jLabelc1.setText(""String_Node_Str"");
                  }
{
                    txtPellet=new JTextField();
                    pnlHops.add(txtPellet);
                    txtPellet.setPreferredSize(new java.awt.Dimension(20,20));
                  }
{
                    jLabelc2=new JLabel();
                    pnlHops.add(jLabelc2);
                    jLabelc2.setText(""String_Node_Str"");
                  }
{
                    txtTinsethUtil=new JTextField();
                    pnlHops.add(txtTinsethUtil);
                    txtTinsethUtil.setText(""String_Node_Str"");
                  }
                }
{
                  pnlAlc=new JPanel();
                  BoxLayout pnlAlcLayout=new BoxLayout(pnlAlc,javax.swing.BoxLayout.Y_AXIS);
                  pnlAlc.setLayout(pnlAlcLayout);
                  pnlCalculations.add(pnlAlc,new GridBagConstraints(0,1,1,1,0.0,0.0,GridBagConstraints.NORTH,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
                  pnlAlc.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
{
                    rbABV=new JRadioButton();
                    pnlAlc.add(rbABV);
                    bgAlc.add(rbABV);
                    rbABV.setText(""String_Node_Str"");
                  }
{
                    rbABW=new JRadioButton();
                    pnlAlc.add(rbABW);
                    bgAlc.add(rbABW);
                    rbABW.setText(""String_Node_Str"");
                  }
                }
{
                  pnlHopTimes=new JPanel();
                  GridLayout pnlHopTimesLayout=new GridLayout(3,2);
                  pnlHopTimesLayout.setColumns(2);
                  pnlHopTimesLayout.setHgap(5);
                  pnlHopTimesLayout.setVgap(5);
                  pnlHopTimesLayout.setRows(3);
                  pnlHopTimes.setLayout(pnlHopTimesLayout);
                  pnlCalculations.add(pnlHopTimes,new GridBagConstraints(1,1,1,1,0.0,0.0,GridBagConstraints.NORTHWEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
                  pnlHopTimes.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
{
                    jLabelc3=new JLabel();
                    pnlHopTimes.add(jLabelc3);
                    jLabelc3.setText(""String_Node_Str"");
                  }
{
                    txtDryHopTime=new JTextField();
                    pnlHopTimes.add(txtDryHopTime);
                    txtDryHopTime.setText(""String_Node_Str"");
                  }
{
                    jLabelc4=new JLabel();
                    pnlHopTimes.add(jLabelc4);
                    jLabelc4.setText(""String_Node_Str"");
                  }
{
                    txtFWHTime=new JTextField();
                    pnlHopTimes.add(txtFWHTime);
                    txtFWHTime.setText(""String_Node_Str"");
                  }
{
                    jLabelc5=new JLabel();
                    pnlHopTimes.add(jLabelc5);
                    jLabelc5.setText(""String_Node_Str"");
                  }
{
                    txtMashHopTime=new JTextField();
                    pnlHopTimes.add(txtMashHopTime);
                    txtMashHopTime.setText(""String_Node_Str"");
                  }
                }
              }
              pnlHopsCalc=new JPanel();
              BoxLayout pnlHopsCalcLayout=new BoxLayout(pnlHopsCalc,javax.swing.BoxLayout.Y_AXIS);
              pnlHopsCalc.setLayout(pnlHopsCalcLayout);
              pnlCalculations.add(pnlHopsCalc,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.NORTH,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
              pnlCalculations.add(getPnlWaterUsage(),new GridBagConstraints(1,2,1,2,0.0,0.0,GridBagConstraints.NORTHWEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
              pnlCalculations.add(getPnlColourOptions(),new GridBagConstraints(0,2,1,1,0.0,0.0,GridBagConstraints.NORTH,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
              pnlCalculations.add(getPnlEvaporation(),new GridBagConstraints(0,3,1,1,0.0,0.0,GridBagConstraints.NORTH,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
              pnlHopsCalc.setPreferredSize(new java.awt.Dimension(117,107));
              pnlHopsCalc.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
{
                rbTinseth=new JRadioButton();
                pnlHopsCalc.add(rbTinseth);
                rbTinseth.setText(""String_Node_Str"");
                bgHopsCalc.add(rbTinseth);
              }
{
                rbRager=new JRadioButton();
                pnlHopsCalc.add(rbRager);
                rbRager.setText(""String_Node_Str"");
                bgHopsCalc.add(rbRager);
              }
{
                rbGaretz=new JRadioButton();
                pnlHopsCalc.add(rbGaretz);
                rbGaretz.setText(""String_Node_Str"");
                bgHopsCalc.add(rbGaretz);
              }
            }
          }
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
{
      costCarbPanel=new JPanel();
      BorderLayout costCarbPanelLayout=new BorderLayout();
      costCarbPanel.setLayout(costCarbPanelLayout);
      jTabbedPane1.addTab(""String_Node_Str"",null,costCarbPanel,null);
{
        carbPanel=new JPanel();
        costCarbPanel.add(carbPanel,BorderLayout.CENTER);
        carbPanel.setBorder(BorderFactory.createTitledBorder(null,""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP));
{
          jLabel3=new JLabel();
          carbPanel.add(jLabel3);
          jLabel3.setText(""String_Node_Str"");
        }
      }
{
        jPanel2=new JPanel();
        costCarbPanel.add(jPanel2,BorderLayout.NORTH);
        GridBagLayout jPanel2Layout=new GridBagLayout();
        jPanel2Layout.rowWeights=new double[]{0.1,0.1,0.4};
        jPanel2Layout.rowHeights=new int[]{7,7,7};
        jPanel2Layout.columnWeights=new double[]{0.1,0.1,0.1};
        jPanel2Layout.columnWidths=new int[]{7,7,7};
        jPanel2.setPreferredSize(new java.awt.Dimension(232,176));
        jPanel2.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
        jPanel2.setLayout(jPanel2Layout);
{
          jLabel1=new JLabel();
          jPanel2.add(jLabel1,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.NORTHEAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
          jLabel1.setText(""String_Node_Str"");
        }
{
          txtOtherCost=new JTextField();
          jPanel2.add(txtOtherCost,new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.NORTHWEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
          txtOtherCost.setText(""String_Node_Str"");
        }
{
          jLabel2=new JLabel();
          jPanel2.add(jLabel2,new GridBagConstraints(0,1,1,1,0.0,0.0,GridBagConstraints.NORTHEAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
          jLabel2.setText(""String_Node_Str"");
        }
{
          cmbBottleSize=new JComboBox();
          cmbBottleSizeModel=new ComboModel();
          cmbBottleSizeModel.setList(new Quantity().getListofUnits(""String_Node_Str""));
          cmbBottleSize.setModel(cmbBottleSizeModel);
          jPanel2.add(cmbBottleSize,new GridBagConstraints(1,1,1,1,0.0,0.0,GridBagConstraints.NORTH,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
          jPanel2.add(getTxtBottleSize(),new GridBagConstraints(1,1,1,1,0.0,0.0,GridBagConstraints.NORTHWEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        }
      }
{
      }
    }
{
      pnlBrewer=new JPanel();
      GridBagLayout pnlBrewerLayout=new GridBagLayout();
      pnlBrewerLayout.rowWeights=new double[]{0.1,0.1,0.3,0.3};
      pnlBrewerLayout.rowHeights=new int[]{2,2,7,7};
      pnlBrewerLayout.columnWeights=new double[]{0.1,0.1,0.1,0.1};
      pnlBrewerLayout.columnWidths=new int[]{7,7,7,7};
      pnlBrewer.setLayout(pnlBrewerLayout);
      jTabbedPane1.addTab(""String_Node_Str"",null,pnlBrewer,null);
{
        jLabel4=new JLabel();
        pnlBrewer.add(jLabel4,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.NORTHEAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel4.setText(""String_Node_Str"");
      }
{
        txtBrewerName=new JTextField();
        pnlBrewer.add(txtBrewerName,new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.NORTH,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
        txtBrewerName.setText(""String_Node_Str"");
      }
{
        jLabel5=new JLabel();
        pnlBrewer.add(jLabel5,new GridBagConstraints(2,0,1,1,0.0,0.0,GridBagConstraints.NORTHEAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel5.setText(""String_Node_Str"");
      }
{
        txtPhone=new JTextField();
        pnlBrewer.add(txtPhone,new GridBagConstraints(3,0,1,1,0.0,0.0,GridBagConstraints.NORTH,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
        txtPhone.setText(""String_Node_Str"");
      }
{
        jLabel6=new JLabel();
        pnlBrewer.add(jLabel6,new GridBagConstraints(0,1,1,1,0.0,0.0,GridBagConstraints.NORTHEAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel6.setText(""String_Node_Str"");
      }
{
        txtClubName=new JTextField();
        pnlBrewer.add(txtClubName,new GridBagConstraints(1,1,1,1,0.0,0.0,GridBagConstraints.NORTH,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
        txtClubName.setText(""String_Node_Str"");
      }
{
        jLabel7=new JLabel();
        pnlBrewer.add(jLabel7,new GridBagConstraints(2,1,1,1,0.0,0.0,GridBagConstraints.NORTHEAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel7.setText(""String_Node_Str"");
      }
{
        txtEmail=new JTextField();
        pnlBrewer.add(txtEmail,new GridBagConstraints(3,1,1,1,0.0,0.0,GridBagConstraints.NORTH,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
        txtEmail.setText(""String_Node_Str"");
      }
    }
{
      pnlDatabase=new JPanel();
      BorderLayout pnlDatabaseLayout=new BorderLayout();
      pnlDatabase.setLayout(pnlDatabaseLayout);
      pnlDatabase.add(getPnlDefaultDB(),BorderLayout.NORTH);
      pnlDatabase.add(getPnlSortOrder(),BorderLayout.WEST);
      jTabbedPane1.addTab(""String_Node_Str"",null,pnlDatabase,null);
      pnlDatabase.setVisible(false);
    }
    newRecipePanel=new JPanel();
    GridBagLayout newRecipePanelLayout=new GridBagLayout();
    newRecipePanelLayout.rowWeights=new double[]{0.1,0.1,0.1,0.1};
    newRecipePanelLayout.rowHeights=new int[]{7,7,7,7};
    newRecipePanelLayout.columnWeights=new double[]{0.1,0.1,0.1,0.1};
    newRecipePanelLayout.columnWidths=new int[]{7,7,7,7};
    newRecipePanel.setLayout(newRecipePanelLayout);
    jTabbedPane1.addTab(""String_Node_Str"",null,newRecipePanel,null);
    appearancePanel=new JPanel();
    BorderLayout appearancePanelLayout=new BorderLayout();
    appearancePanel.setLayout(appearancePanelLayout);
    jTabbedPane1.addTab(""String_Node_Str"",null,appearancePanel,null);
    colourPanel=new JPanel();
    appearancePanel.add(colourPanel,BorderLayout.CENTER);
    GridBagLayout colourPanelLayout=new GridBagLayout();
    colourPanelLayout.rowWeights=new double[]{0.1,0.1,0.1,0.1};
    colourPanelLayout.rowHeights=new int[]{7,7,7,7};
    colourPanelLayout.columnWeights=new double[]{0.1,0.1,0.1,0.1,0.1,0.1};
    colourPanelLayout.columnWidths=new int[]{7,7,7,7,7,7};
    colourPanel.setLayout(colourPanelLayout);
    colourPanel.setPreferredSize(new java.awt.Dimension(340,223));
    colourPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
    landfPanel=new JPanel();
    appearancePanel.add(landfPanel,BorderLayout.NORTH);
    jLabel19=new JLabel();
    landfPanel.add(jLabel19);
    jLabel19.setText(""String_Node_Str"");
    landfCombo=new JComboBox(looks.toArray());
    landfPanel.add(landfCombo);
    colMethod1rb=new JRadioButton();
    colMethod1rb.addActionListener(this);
    colourGroup.add(colMethod1rb);
    colourPanel.add(colMethod1rb,new GridBagConstraints(0,0,3,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
    colMethod1rb.setText(""String_Node_Str"");
    colMethod2rb=new JRadioButton();
    colMethod2rb.addActionListener(this);
    colourGroup.add(colMethod2rb);
    colourPanel.add(colMethod2rb,new GridBagConstraints(3,0,3,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
    colMethod2rb.setText(""String_Node_Str"");
    jLabel13=new JLabel();
    colourPanel.add(jLabel13,new GridBagConstraints(0,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
    jLabel13.setText(""String_Node_Str"");
    jLabel14=new JLabel();
    colourPanel.add(jLabel14,new GridBagConstraints(1,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
    jLabel14.setText(""String_Node_Str"");
    jLabel15=new JLabel();
    colourPanel.add(jLabel15,new GridBagConstraints(2,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
    jLabel15.setText(""String_Node_Str"");
    jLabel16=new JLabel();
    colourPanel.add(jLabel16,new GridBagConstraints(3,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
    jLabel16.setText(""String_Node_Str"");
    jLabel17=new JLabel();
    colourPanel.add(jLabel17,new GridBagConstraints(4,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
    jLabel17.setText(""String_Node_Str"");
    jLabel18=new JLabel();
    colourPanel.add(jLabel18,new GridBagConstraints(5,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
    jLabel18.setText(""String_Node_Str"");
    stawPanel=new JPanel();
    colourPanel.add(stawPanel,new GridBagConstraints(0,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
    stawPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
    palePanel=new JPanel();
    colourPanel.add(palePanel,new GridBagConstraints(1,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
    palePanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
    amberPanel=new JPanel();
    colourPanel.add(amberPanel,new GridBagConstraints(2,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
    amberPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
    copperPanel=new JPanel();
    colourPanel.add(copperPanel,new GridBagConstraints(3,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
    copperPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
    brownPanel=new JPanel();
    colourPanel.add(brownPanel,new GridBagConstraints(4,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
    brownPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
    blackPanel=new JPanel();
    colourPanel.add(blackPanel,new GridBagConstraints(5,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
    blackPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
    mashPanel=new JPanel();
    newRecipePanel.add(mashPanel,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
    mashPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
    jLabel12=new JLabel();
    mashPanel.add(jLabel12);
    jLabel12.setText(""String_Node_Str"");
    boilTempTxt=new JTextField();
    mashPanel.add(boilTempTxt);
    boilTempTxt.setText(""String_Node_Str"");
  }
  getContentPane().add(BorderLayout.CENTER,jTabbedPane1);
  getContentPane().add(BorderLayout.SOUTH,buttons);
  setSize(400,400);
}","private void layoutUi(){
  JPanel buttons=new JPanel();
  okButton=new JButton(""String_Node_Str"");
  okButton.addActionListener(this);
  JButton cancelButton=new JButton(""String_Node_Str"");
  cancelButton.addActionListener(this);
  buttons.setLayout(new FlowLayout(FlowLayout.RIGHT));
  buttons.add(cancelButton);
  buttons.add(okButton);
  getContentPane().setLayout(new BorderLayout());
  this.setFocusTraversalKeysEnabled(false);
{
    jTabbedPane1=new JTabbedPane();
    getContentPane().add(jTabbedPane1,BorderLayout.CENTER);
{
      pnlCalculations=new JPanel();
      jTabbedPane1.addTab(""String_Node_Str"",null,pnlCalculations,null);
{
        try {
{
            GridBagLayout thisLayout=new GridBagLayout();
            thisLayout.rowWeights=new double[]{0.1,0.1,0.1,0.1};
            thisLayout.rowHeights=new int[]{7,7,7,7};
            thisLayout.columnWeights=new double[]{0.1,0.2};
            thisLayout.columnWidths=new int[]{7,7};
            pnlCalculations.setLayout(thisLayout);
            pnlCalculations.setPreferredSize(new java.awt.Dimension(524,372));
{
{
                bgHopsCalc=new ButtonGroup();
{
                  pnlHops=new JPanel();
                  GridLayout pnlHopsLayout=new GridLayout(2,2);
                  pnlHopsLayout.setColumns(2);
                  pnlHopsLayout.setHgap(5);
                  pnlHopsLayout.setVgap(5);
                  pnlHopsLayout.setRows(2);
                  pnlHops.setLayout(pnlHopsLayout);
                  pnlCalculations.add(pnlHops,new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.NORTHWEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
                  pnlHops.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
{
                    jLabelc1=new JLabel();
                    pnlHops.add(jLabelc1);
                    jLabelc1.setText(""String_Node_Str"");
                  }
{
                    txtPellet=new JTextField();
                    pnlHops.add(txtPellet);
                    txtPellet.setPreferredSize(new java.awt.Dimension(20,20));
                  }
{
                    jLabelc2=new JLabel();
                    pnlHops.add(jLabelc2);
                    jLabelc2.setText(""String_Node_Str"");
                  }
{
                    txtTinsethUtil=new JTextField();
                    pnlHops.add(txtTinsethUtil);
                    txtTinsethUtil.setText(""String_Node_Str"");
                  }
                }
{
                  pnlAlc=new JPanel();
                  BoxLayout pnlAlcLayout=new BoxLayout(pnlAlc,javax.swing.BoxLayout.Y_AXIS);
                  pnlAlc.setLayout(pnlAlcLayout);
                  pnlCalculations.add(pnlAlc,new GridBagConstraints(0,1,1,1,0.0,0.0,GridBagConstraints.NORTH,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
                  pnlAlc.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
{
                    rbABV=new JRadioButton();
                    pnlAlc.add(rbABV);
                    bgAlc.add(rbABV);
                    rbABV.setText(""String_Node_Str"");
                  }
{
                    rbABW=new JRadioButton();
                    pnlAlc.add(rbABW);
                    bgAlc.add(rbABW);
                    rbABW.setText(""String_Node_Str"");
                  }
                }
{
                  pnlHopTimes=new JPanel();
                  GridLayout pnlHopTimesLayout=new GridLayout(3,2);
                  pnlHopTimesLayout.setColumns(2);
                  pnlHopTimesLayout.setHgap(5);
                  pnlHopTimesLayout.setVgap(5);
                  pnlHopTimesLayout.setRows(3);
                  pnlHopTimes.setLayout(pnlHopTimesLayout);
                  pnlCalculations.add(pnlHopTimes,new GridBagConstraints(1,1,1,1,0.0,0.0,GridBagConstraints.NORTHWEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
                  pnlHopTimes.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
{
                    jLabelc3=new JLabel();
                    pnlHopTimes.add(jLabelc3);
                    jLabelc3.setText(""String_Node_Str"");
                  }
{
                    txtDryHopTime=new JTextField();
                    pnlHopTimes.add(txtDryHopTime);
                    txtDryHopTime.setText(""String_Node_Str"");
                  }
{
                    jLabelc4=new JLabel();
                    pnlHopTimes.add(jLabelc4);
                    jLabelc4.setText(""String_Node_Str"");
                  }
{
                    txtFWHTime=new JTextField();
                    pnlHopTimes.add(txtFWHTime);
                    txtFWHTime.setText(""String_Node_Str"");
                  }
{
                    jLabelc5=new JLabel();
                    pnlHopTimes.add(jLabelc5);
                    jLabelc5.setText(""String_Node_Str"");
                  }
{
                    txtMashHopTime=new JTextField();
                    pnlHopTimes.add(txtMashHopTime);
                    txtMashHopTime.setText(""String_Node_Str"");
                  }
                }
              }
              pnlHopsCalc=new JPanel();
              BoxLayout pnlHopsCalcLayout=new BoxLayout(pnlHopsCalc,javax.swing.BoxLayout.Y_AXIS);
              pnlHopsCalc.setLayout(pnlHopsCalcLayout);
              pnlCalculations.add(pnlHopsCalc,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.NORTH,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
              pnlCalculations.add(getPnlWaterUsage(),new GridBagConstraints(1,2,1,2,0.0,0.0,GridBagConstraints.NORTHWEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
              pnlCalculations.add(getPnlColourOptions(),new GridBagConstraints(0,2,1,1,0.0,0.0,GridBagConstraints.NORTH,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
              pnlCalculations.add(getPnlEvaporation(),new GridBagConstraints(0,3,1,1,0.0,0.0,GridBagConstraints.NORTH,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
              pnlHopsCalc.setPreferredSize(new java.awt.Dimension(117,107));
              pnlHopsCalc.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
{
                rbTinseth=new JRadioButton();
                pnlHopsCalc.add(rbTinseth);
                rbTinseth.setText(""String_Node_Str"");
                bgHopsCalc.add(rbTinseth);
              }
{
                rbRager=new JRadioButton();
                pnlHopsCalc.add(rbRager);
                rbRager.setText(""String_Node_Str"");
                bgHopsCalc.add(rbRager);
              }
{
                rbGaretz=new JRadioButton();
                pnlHopsCalc.add(rbGaretz);
                rbGaretz.setText(""String_Node_Str"");
                bgHopsCalc.add(rbGaretz);
              }
            }
          }
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
{
      costCarbPanel=new JPanel();
      BorderLayout costCarbPanelLayout=new BorderLayout();
      costCarbPanel.setLayout(costCarbPanelLayout);
      jTabbedPane1.addTab(""String_Node_Str"",null,costCarbPanel,null);
{
        carbPanel=new JPanel();
        costCarbPanel.add(carbPanel,BorderLayout.CENTER);
        carbPanel.setBorder(BorderFactory.createTitledBorder(null,""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP));
{
          jLabel3=new JLabel();
          carbPanel.add(jLabel3);
          jLabel3.setText(""String_Node_Str"");
        }
      }
{
        jPanel2=new JPanel();
        costCarbPanel.add(jPanel2,BorderLayout.NORTH);
        GridBagLayout jPanel2Layout=new GridBagLayout();
        jPanel2Layout.rowWeights=new double[]{0.1,0.1,0.4};
        jPanel2Layout.rowHeights=new int[]{7,7,7};
        jPanel2Layout.columnWeights=new double[]{0.1,0.1,0.1};
        jPanel2Layout.columnWidths=new int[]{7,7,7};
        jPanel2.setPreferredSize(new java.awt.Dimension(232,176));
        jPanel2.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
        jPanel2.setLayout(jPanel2Layout);
{
          jLabel1=new JLabel();
          jPanel2.add(jLabel1,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.NORTHEAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
          jLabel1.setText(""String_Node_Str"");
        }
{
          txtOtherCost=new JTextField();
          jPanel2.add(txtOtherCost,new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.NORTHWEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
          txtOtherCost.setText(""String_Node_Str"");
        }
{
          jLabel2=new JLabel();
          jPanel2.add(jLabel2,new GridBagConstraints(0,1,1,1,0.0,0.0,GridBagConstraints.NORTHEAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
          jLabel2.setText(""String_Node_Str"");
        }
{
          cmbBottleSize=new JComboBox();
          cmbBottleSizeModel=new ComboModel();
          cmbBottleSizeModel.setList(new Quantity().getListofUnits(""String_Node_Str""));
          cmbBottleSize.setModel(cmbBottleSizeModel);
          jPanel2.add(cmbBottleSize,new GridBagConstraints(1,1,1,1,0.0,0.0,GridBagConstraints.NORTH,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
          jPanel2.add(getTxtBottleSize(),new GridBagConstraints(1,1,1,1,0.0,0.0,GridBagConstraints.NORTHWEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        }
      }
{
      }
    }
{
      pnlBrewer=new JPanel();
      GridBagLayout pnlBrewerLayout=new GridBagLayout();
      pnlBrewerLayout.rowWeights=new double[]{0.1,0.1,0.3,0.3};
      pnlBrewerLayout.rowHeights=new int[]{2,2,7,7};
      pnlBrewerLayout.columnWeights=new double[]{0.1,0.1,0.1,0.1};
      pnlBrewerLayout.columnWidths=new int[]{7,7,7,7};
      pnlBrewer.setLayout(pnlBrewerLayout);
      jTabbedPane1.addTab(""String_Node_Str"",null,pnlBrewer,null);
{
        jLabel4=new JLabel();
        pnlBrewer.add(jLabel4,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.NORTHEAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel4.setText(""String_Node_Str"");
      }
{
        txtBrewerName=new JTextField();
        pnlBrewer.add(txtBrewerName,new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.NORTH,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
        txtBrewerName.setText(""String_Node_Str"");
      }
{
        jLabel5=new JLabel();
        pnlBrewer.add(jLabel5,new GridBagConstraints(2,0,1,1,0.0,0.0,GridBagConstraints.NORTHEAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel5.setText(""String_Node_Str"");
      }
{
        txtPhone=new JTextField();
        pnlBrewer.add(txtPhone,new GridBagConstraints(3,0,1,1,0.0,0.0,GridBagConstraints.NORTH,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
        txtPhone.setText(""String_Node_Str"");
      }
{
        jLabel6=new JLabel();
        pnlBrewer.add(jLabel6,new GridBagConstraints(0,1,1,1,0.0,0.0,GridBagConstraints.NORTHEAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel6.setText(""String_Node_Str"");
      }
{
        txtClubName=new JTextField();
        pnlBrewer.add(txtClubName,new GridBagConstraints(1,1,1,1,0.0,0.0,GridBagConstraints.NORTH,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
        txtClubName.setText(""String_Node_Str"");
      }
{
        jLabel7=new JLabel();
        pnlBrewer.add(jLabel7,new GridBagConstraints(2,1,1,1,0.0,0.0,GridBagConstraints.NORTHEAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
        jLabel7.setText(""String_Node_Str"");
      }
{
        txtEmail=new JTextField();
        pnlBrewer.add(txtEmail,new GridBagConstraints(3,1,1,1,0.0,0.0,GridBagConstraints.NORTH,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
        txtEmail.setText(""String_Node_Str"");
      }
    }
{
      pnlDatabase=new JPanel();
      BorderLayout pnlDatabaseLayout=new BorderLayout();
      pnlDatabase.setLayout(pnlDatabaseLayout);
      pnlDatabase.add(getPnlDefaultDB(),BorderLayout.NORTH);
      pnlDatabase.add(getPnlSortOrder(),BorderLayout.WEST);
      jTabbedPane1.addTab(""String_Node_Str"",null,pnlDatabase,null);
      pnlDatabase.setVisible(false);
    }
    newRecipePanel=new JPanel();
    GridBagLayout newRecipePanelLayout=new GridBagLayout();
    newRecipePanelLayout.rowWeights=new double[]{0.1,0.1,0.1,0.1};
    newRecipePanelLayout.rowHeights=new int[]{7,7,7,7};
    newRecipePanelLayout.columnWeights=new double[]{0.1,0.1,0.1,0.1};
    newRecipePanelLayout.columnWidths=new int[]{7,7,7,7};
    newRecipePanel.setLayout(newRecipePanelLayout);
    jTabbedPane1.addTab(""String_Node_Str"",null,newRecipePanel,null);
    appearancePanel=new JPanel();
    BorderLayout appearancePanelLayout=new BorderLayout();
    appearancePanel.setLayout(appearancePanelLayout);
    jTabbedPane1.addTab(""String_Node_Str"",null,appearancePanel,null);
    colourPanel=new JPanel();
    appearancePanel.add(colourPanel,BorderLayout.CENTER);
    GridBagLayout colourPanelLayout=new GridBagLayout();
    colourPanelLayout.rowWeights=new double[]{0.1,0.1,0.1,0.1};
    colourPanelLayout.rowHeights=new int[]{7,7,7,7};
    colourPanelLayout.columnWeights=new double[]{0.1,0.1,0.1,0.1,0.1,0.1};
    colourPanelLayout.columnWidths=new int[]{7,7,7,7,7,7};
    colourPanel.setLayout(colourPanelLayout);
    colourPanel.setPreferredSize(new java.awt.Dimension(340,223));
    colourPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
    landfPanel=new JPanel();
    appearancePanel.add(landfPanel,BorderLayout.NORTH);
    jLabel19=new JLabel();
    landfPanel.add(jLabel19);
    jLabel19.setText(""String_Node_Str"");
    landfCombo=new JComboBox(looks.toArray());
    landfPanel.add(landfCombo);
    colMethod1rb=new JRadioButton();
    colMethod1rb.addActionListener(this);
    colourGroup.add(colMethod1rb);
    colourPanel.add(colMethod1rb,new GridBagConstraints(0,0,3,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
    colMethod1rb.setText(""String_Node_Str"");
    colMethod2rb=new JRadioButton();
    colMethod2rb.addActionListener(this);
    colourGroup.add(colMethod2rb);
    colourPanel.add(colMethod2rb,new GridBagConstraints(3,0,3,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
    colMethod2rb.setText(""String_Node_Str"");
    jLabel13=new JLabel();
    colourPanel.add(jLabel13,new GridBagConstraints(0,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
    jLabel13.setText(""String_Node_Str"");
    jLabel14=new JLabel();
    colourPanel.add(jLabel14,new GridBagConstraints(1,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
    jLabel14.setText(""String_Node_Str"");
    jLabel15=new JLabel();
    colourPanel.add(jLabel15,new GridBagConstraints(2,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
    jLabel15.setText(""String_Node_Str"");
    jLabel16=new JLabel();
    colourPanel.add(jLabel16,new GridBagConstraints(3,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
    jLabel16.setText(""String_Node_Str"");
    jLabel17=new JLabel();
    colourPanel.add(jLabel17,new GridBagConstraints(4,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
    jLabel17.setText(""String_Node_Str"");
    jLabel18=new JLabel();
    colourPanel.add(jLabel18,new GridBagConstraints(5,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
    jLabel18.setText(""String_Node_Str"");
    stawPanel=new JPanel();
    colourPanel.add(stawPanel,new GridBagConstraints(0,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
    stawPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
    palePanel=new JPanel();
    colourPanel.add(palePanel,new GridBagConstraints(1,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
    palePanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
    amberPanel=new JPanel();
    colourPanel.add(amberPanel,new GridBagConstraints(2,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
    amberPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
    copperPanel=new JPanel();
    colourPanel.add(copperPanel,new GridBagConstraints(3,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
    copperPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
    brownPanel=new JPanel();
    colourPanel.add(brownPanel,new GridBagConstraints(4,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
    brownPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
    blackPanel=new JPanel();
    colourPanel.add(blackPanel,new GridBagConstraints(5,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
    blackPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
    mashPanel=new JPanel();
    newRecipePanel.add(mashPanel,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
    mashPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
    jLabel12=new JLabel();
    mashPanel.add(jLabel12);
    jLabel12.setText(""String_Node_Str"");
    boilTempTxt=new JTextField();
    mashPanel.add(boilTempTxt);
    boilTempTxt.setText(""String_Node_Str"");
  }
  getContentPane().add(BorderLayout.CENTER,jTabbedPane1);
  getContentPane().add(BorderLayout.SOUTH,buttons);
  setSize(500,500);
}"
50560,"private void addColumnWidthListeners(){
  TableColumnModel mtcm=maltTable.getColumnModel();
  TableColumnModel htcm=hopsTable.getColumnModel();
  PropertyChangeListener mpcl=new PropertyChangeListener(){
    private int columnCount=maltTable.getColumnCount();
    private int[] width=new int[columnCount];
    public void propertyChange(    PropertyChangeEvent evt){
      if (evt.getPropertyName().equals(""String_Node_Str"")) {
        TableColumnModel tcm=maltTable.getColumnModel();
        TableColumnModel tcmt=tblMaltTotals.getColumnModel();
        int colCount=tcm.getColumnCount();
        for (int i=0; i < colCount; i++) {
          tcmt.getColumn(i).setPreferredWidth(tcm.getColumn(i).getPreferredWidth());
        }
      }
    }
  }
;
  PropertyChangeListener hpcl=new PropertyChangeListener(){
    private int columnCount=hopsTable.getColumnCount();
    private int[] width=new int[columnCount];
    public void propertyChange(    PropertyChangeEvent evt){
      if (evt.getPropertyName().equals(""String_Node_Str"")) {
        TableColumnModel tcm=hopsTable.getColumnModel();
        TableColumnModel tcmt=tblHopsTotals.getColumnModel();
        int columnCount=tcm.getColumnCount();
        for (int i=0; i < columnCount; i++) {
          tcmt.getColumn(i).setPreferredWidth(tcm.getColumn(i).getPreferredWidth());
        }
      }
    }
  }
;
  for (Enumeration e=mtcm.getColumns(); e.hasMoreElements(); ) {
    TableColumn tc=(TableColumn)e.nextElement();
    tc.addPropertyChangeListener(mpcl);
  }
  for (Enumeration e=htcm.getColumns(); e.hasMoreElements(); ) {
    TableColumn tc=(TableColumn)e.nextElement();
    tc.addPropertyChangeListener(hpcl);
  }
}","private void addColumnWidthListeners(){
  TableColumnModel mtcm=maltTable.getColumnModel();
  TableColumnModel htcm=hopsTable.getColumnModel();
  PropertyChangeListener mpcl=new PropertyChangeListener(){
    private int columnCount=maltTable.getColumnCount();
    private int[] width=new int[columnCount];
    public void propertyChange(    PropertyChangeEvent evt){
      if (evt.getPropertyName().equals(""String_Node_Str"")) {
        TableColumnModel tcm=maltTable.getColumnModel();
        TableColumnModel tcmt=tblMaltTotals.getColumnModel();
        int colCount=tcm.getColumnCount();
        for (int i=0; i < colCount; i++) {
          tcmt.getColumn(i).setPreferredWidth(tcm.getColumn(i).getPreferredWidth());
        }
      }
    }
  }
;
  PropertyChangeListener hpcl=new PropertyChangeListener(){
    private int columnCount=hopsTable.getColumnCount();
    private int[] width=new int[columnCount];
    public void propertyChange(    PropertyChangeEvent evt){
      if (evt.getPropertyName().equals(""String_Node_Str"")) {
        TableColumnModel tcm=hopsTable.getColumnModel();
        TableColumnModel tcmt=tblHopsTotals.getColumnModel();
        int colCount=tcm.getColumnCount();
        for (int i=0; i < colCount; i++) {
          tcmt.getColumn(i).setPreferredWidth(tcm.getColumn(i).getPreferredWidth());
        }
      }
    }
  }
;
  for (Enumeration e=mtcm.getColumns(); e.hasMoreElements(); ) {
    TableColumn tc=(TableColumn)e.nextElement();
    tc.addPropertyChangeListener(mpcl);
  }
  for (Enumeration e=htcm.getColumns(); e.hasMoreElements(); ) {
    TableColumn tc=(TableColumn)e.nextElement();
    tc.addPropertyChangeListener(hpcl);
  }
}"
50561,"public void propertyChange(PropertyChangeEvent evt){
  if (evt.getPropertyName().equals(""String_Node_Str"")) {
    TableColumnModel tcm=hopsTable.getColumnModel();
    TableColumnModel tcmt=tblHopsTotals.getColumnModel();
    int columnCount=tcm.getColumnCount();
    for (int i=0; i < columnCount; i++) {
      tcmt.getColumn(i).setPreferredWidth(tcm.getColumn(i).getPreferredWidth());
    }
  }
}","public void propertyChange(PropertyChangeEvent evt){
  if (evt.getPropertyName().equals(""String_Node_Str"")) {
    TableColumnModel tcm=hopsTable.getColumnModel();
    TableColumnModel tcmt=tblHopsTotals.getColumnModel();
    int colCount=tcm.getColumnCount();
    for (int i=0; i < colCount; i++) {
      tcmt.getColumn(i).setPreferredWidth(tcm.getColumn(i).getPreferredWidth());
    }
  }
}"
50562,"public void displayRecipe(){
  if (myRecipe == null)   return;
  txtName.setText(myRecipe.getName());
  brewerNameText.setText(myRecipe.getBrewer());
  txtPreBoil.setValue(new Double(myRecipe.getPreBoilVol(myRecipe.getVolUnits())));
  lblSizeUnits.setText(myRecipe.getVolUnits());
  postBoilText.setValue(new Double(myRecipe.getPostBoilVol(myRecipe.getVolUnits())));
  boilMinText.setText(SBStringUtils.df0.format(myRecipe.getBoilMinutes()));
  evapText.setText(SBStringUtils.df1.format(myRecipe.getEvap()));
  spnEffic.setValue(new Double(myRecipe.getEfficiency()));
  spnAtten.setValue(new Double(myRecipe.getAttenuation()));
  spnOG.setValue(new Double(myRecipe.getEstOg()));
  spnFG.setValue(new Double(myRecipe.getEstFg()));
  txtComments.setText(myRecipe.getComments());
  lblIBUvalue.setText(SBStringUtils.df1.format(myRecipe.getIbu()));
  lblColourValue.setText(SBStringUtils.df1.format(myRecipe.getSrm()));
  lblAlcValue.setText(SBStringUtils.df1.format(myRecipe.getAlcohol()));
  txtDate.setText(dateFormat1.format(myRecipe.getCreated().getTime()));
  Costs=myNF.format(myRecipe.getTotalMaltCost());
  tblMaltTotalsModel.setDataVector(new String[][]{{""String_Node_Str"",""String_Node_Str"" + SBStringUtils.df1.format(myRecipe.getTotalMalt()),myRecipe.getMaltUnits(),""String_Node_Str"" + SBStringUtils.df3.format(myRecipe.getEstOg()),""String_Node_Str"" + SBStringUtils.df1.format(myRecipe.getSrm()),Costs,""String_Node_Str""}},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  Costs=myNF.format(myRecipe.getTotalHopsCost());
  tblHopsTotalsModel.setDataVector(new String[][]{{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + SBStringUtils.df1.format(myRecipe.getTotalHops()),myRecipe.getHopUnits(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + SBStringUtils.df1.format(myRecipe.getIbu()),Costs}},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  String fileName=""String_Node_Str"";
  if (currentFile != null) {
    fileName=currentFile.getName();
  }
  fileNameLabel.setText(""String_Node_Str"" + fileName);
  ibuMethodLabel.setText(""String_Node_Str"" + myRecipe.getIBUMethod());
  alcMethodLabel.setText(""String_Node_Str"" + myRecipe.getAlcMethod());
  colourPanel.setBackground(Recipe.calcRGB(myRecipe.getSrm(),8,30,20));
  colourPanel2.setBackground(Recipe.calcRBG2(myRecipe.getSrm()));
}","public void displayRecipe(){
  if (myRecipe == null)   return;
  txtName.setText(myRecipe.getName());
  brewerNameText.setText(myRecipe.getBrewer());
  txtPreBoil.setValue(new Double(myRecipe.getPreBoilVol(myRecipe.getVolUnits())));
  lblSizeUnits.setText(myRecipe.getVolUnits());
  postBoilText.setValue(new Double(myRecipe.getPostBoilVol(myRecipe.getVolUnits())));
  boilMinText.setText(SBStringUtils.df0.format(myRecipe.getBoilMinutes()));
  evapText.setText(SBStringUtils.df1.format(myRecipe.getEvap()));
  spnEffic.setValue(new Double(myRecipe.getEfficiency()));
  spnAtten.setValue(new Double(myRecipe.getAttenuation()));
  spnOG.setValue(new Double(myRecipe.getEstOg()));
  spnFG.setValue(new Double(myRecipe.getEstFg()));
  txtComments.setText(myRecipe.getComments());
  lblIBUvalue.setText(SBStringUtils.df1.format(myRecipe.getIbu()));
  lblColourValue.setText(SBStringUtils.df1.format(myRecipe.getSrm()));
  lblAlcValue.setText(SBStringUtils.df1.format(myRecipe.getAlcohol()));
  txtDate.setText(dateFormat1.format(myRecipe.getCreated().getTime()));
  Costs=myNF.format(myRecipe.getTotalMaltCost());
  tblMaltTotalsModel.setDataVector(new String[][]{{""String_Node_Str"",""String_Node_Str"" + SBStringUtils.df1.format(myRecipe.getTotalMalt()),myRecipe.getMaltUnits(),""String_Node_Str"" + SBStringUtils.df3.format(myRecipe.getEstOg()),""String_Node_Str"" + SBStringUtils.df1.format(myRecipe.getSrm()),Costs,""String_Node_Str""}},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  Costs=myNF.format(myRecipe.getTotalHopsCost());
  tblHopsTotalsModel.setDataVector(new String[][]{{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + SBStringUtils.df1.format(myRecipe.getTotalHops()),myRecipe.getHopUnits(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + SBStringUtils.df1.format(myRecipe.getIbu()),Costs}},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  String fileName=""String_Node_Str"";
  if (currentFile != null) {
    fileName=currentFile.getName();
  }
  fileNameLabel.setText(""String_Node_Str"" + fileName);
  ibuMethodLabel.setText(""String_Node_Str"" + myRecipe.getIBUMethod());
  alcMethodLabel.setText(""String_Node_Str"" + myRecipe.getAlcMethod());
  colourPanel.setBackground(Recipe.calcRGB(myRecipe.getSrm(),8,30,20));
  colourPanel2.setBackground(Recipe.calcRBG2(myRecipe.getSrm()));
  stylePanel.setStyleData();
}"
50563,"private void initGUI(){
  try {
    this.setSize(600,532);
    this.addWindowListener(new WindowAdapter(){
      public void windowClosed(      WindowEvent evt){
        System.exit(1);
      }
    }
);
{
      pnlMain=new JPanel();
      GridBagLayout jPanel2Layout=new GridBagLayout();
      jPanel2Layout.columnWeights=new double[]{0.1};
      jPanel2Layout.columnWidths=new int[]{7};
      jPanel2Layout.rowWeights=new double[]{0.1,0.1,0.9,0.1};
      jPanel2Layout.rowHeights=new int[]{7,7,7,7};
      pnlMain.setLayout(jPanel2Layout);
      this.getContentPane().add(pnlMain,BorderLayout.CENTER);
{
        jPanel1=new JPanel();
        pnlMain.add(jPanel1,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
        FlowLayout jPanel1Layout=new FlowLayout();
        jPanel1Layout.setAlignment(FlowLayout.LEFT);
        jPanel1.setLayout(jPanel1Layout);
{
          lblName=new JLabel();
          jPanel1.add(lblName);
          lblName.setText(""String_Node_Str"");
        }
{
          txtName=new JTextField();
          jPanel1.add(txtName);
          txtName.setText(""String_Node_Str"");
          txtName.setPreferredSize(new java.awt.Dimension(179,20));
          txtName.addActionListener(this);
          txtName.addFocusListener(this);
        }
      }
{
        jTabbedPane1=new JTabbedPane();
        pnlMain.add(jTabbedPane1,new GridBagConstraints(0,1,1,1,0.1,0.1,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
{
          pnlDetails=new JPanel();
          GridBagLayout pnlDetailsLayout=new GridBagLayout();
          pnlDetailsLayout.columnWeights=new double[]{0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1};
          pnlDetailsLayout.columnWidths=new int[]{7,7,7,7,7,7,7,7,7,7};
          pnlDetailsLayout.rowWeights=new double[]{0.1,0.1,0.1,0.1,0.1,0.1,0.1};
          pnlDetailsLayout.rowHeights=new int[]{7,7,7,7,7,7,7};
          pnlDetails.setLayout(pnlDetailsLayout);
          jTabbedPane1.addTab(""String_Node_Str"",null,pnlDetails,null);
          pnlDetails.setPreferredSize(new java.awt.Dimension(20,16));
{
            lblBrewer=new JLabel();
            pnlDetails.add(lblBrewer,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblBrewer.setText(""String_Node_Str"");
          }
{
            brewerNameText=new JTextField();
            pnlDetails.add(brewerNameText,new GridBagConstraints(1,0,2,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            brewerNameText.setPreferredSize(new java.awt.Dimension(69,20));
            brewerNameText.addFocusListener(this);
            brewerNameText.addActionListener(this);
            brewerNameText.setText(""String_Node_Str"");
          }
{
            lblDate=new JLabel();
            pnlDetails.add(lblDate,new GridBagConstraints(0,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblDate.setText(""String_Node_Str"");
          }
{
            lblStyle=new JLabel();
            pnlDetails.add(lblStyle,new GridBagConstraints(0,2,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblStyle.setText(""String_Node_Str"");
          }
{
            lblYeast=new JLabel();
            pnlDetails.add(lblYeast,new GridBagConstraints(0,3,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblYeast.setText(""String_Node_Str"");
          }
{
            lblPreBoil=new JLabel();
            pnlDetails.add(lblPreBoil,new GridBagConstraints(0,4,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblPreBoil.setText(""String_Node_Str"");
          }
{
            lblPostBoil=new JLabel();
            pnlDetails.add(lblPostBoil,new GridBagConstraints(0,5,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblPostBoil.setText(""String_Node_Str"");
          }
{
            lblEffic=new JLabel();
            pnlDetails.add(lblEffic,new GridBagConstraints(3,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblEffic.setText(""String_Node_Str"");
            lblEffic.setPreferredSize(new java.awt.Dimension(31,14));
          }
{
            lblAtten=new JLabel();
            pnlDetails.add(lblAtten,new GridBagConstraints(3,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblAtten.setText(""String_Node_Str"");
            lblAtten.setPreferredSize(new java.awt.Dimension(34,14));
          }
{
            lblOG=new JLabel();
            pnlDetails.add(lblOG,new GridBagConstraints(5,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblOG.setText(""String_Node_Str"");
          }
{
            lblFG=new JLabel();
            pnlDetails.add(lblFG,new GridBagConstraints(5,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblFG.setText(""String_Node_Str"");
          }
{
            lblIBU=new JLabel();
            pnlDetails.add(lblIBU,new GridBagConstraints(7,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblIBU.setText(""String_Node_Str"");
          }
{
            lblAlc=new JLabel();
            pnlDetails.add(lblAlc,new GridBagConstraints(7,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblAlc.setText(""String_Node_Str"");
          }
{
            lblColour=new JLabel();
            pnlDetails.add(lblColour,new GridBagConstraints(7,2,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblColour.setText(""String_Node_Str"");
          }
{
            txtDate=new JFormattedTextField();
            pnlDetails.add(txtDate,new GridBagConstraints(1,1,2,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            txtDate.setText(""String_Node_Str"");
            txtDate.setPreferredSize(new java.awt.Dimension(73,20));
            txtDate.addFocusListener(this);
            txtDate.addActionListener(this);
          }
{
            cmbStyleModel=new ComboModel();
            cmbStyle=new JComboBox();
            pnlDetails.add(cmbStyle,new GridBagConstraints(1,2,5,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            cmbStyle.setModel(cmbStyleModel);
            cmbStyle.setMaximumSize(new java.awt.Dimension(100,32767));
            cmbStyle.setPreferredSize(new java.awt.Dimension(190,20));
            cmbStyle.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                Style s=(Style)cmbStyleModel.getSelectedItem();
                if (myRecipe != null && s != myRecipe.getStyleObj()) {
                  myRecipe.setStyle(s);
                  stylePanel.setStyle(s);
                }
                cmbStyle.setToolTipText(SBStringUtils.multiLineToolTip(50,s.getDescription()));
              }
            }
);
          }
{
            txtPreBoil=new JFormattedTextField();
            pnlDetails.add(txtPreBoil,new GridBagConstraints(1,4,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            txtPreBoil.setText(""String_Node_Str"");
            txtPreBoil.setPreferredSize(new java.awt.Dimension(37,20));
            txtPreBoil.addFocusListener(this);
            txtPreBoil.addActionListener(this);
          }
{
            postBoilText=new JFormattedTextField();
            pnlDetails.add(postBoilText,new GridBagConstraints(1,5,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            postBoilText.setText(""String_Node_Str"");
            postBoilText.setPreferredSize(new java.awt.Dimension(46,20));
            postBoilText.addFocusListener(new FocusAdapter(){
              public void focusLost(              FocusEvent evt){
                myRecipe.setPostBoil(Double.parseDouble(postBoilText.getText().toString()));
                displayRecipe();
              }
            }
);
            postBoilText.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                myRecipe.setPostBoil(Double.parseDouble(postBoilText.getText().toString()));
                displayRecipe();
              }
            }
);
          }
{
            lblComments=new JLabel();
            pnlDetails.add(lblComments,new GridBagConstraints(6,4,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblComments.setText(""String_Node_Str"");
          }
{
            SpinnerNumberModel spnEfficModel=new SpinnerNumberModel(75.0,0.0,100.0,1.0);
            spnEffic=new JSpinner();
            pnlDetails.add(spnEffic,new GridBagConstraints(4,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            spnEffic.setModel(spnEfficModel);
            spnEffic.setMaximumSize(new java.awt.Dimension(70,32767));
            spnEffic.addChangeListener(new ChangeListener(){
              public void stateChanged(              ChangeEvent evt){
                myRecipe.setEfficiency(Double.parseDouble(spnEffic.getValue().toString()));
                displayRecipe();
              }
            }
);
            spnEffic.setEditor(new JSpinner.NumberEditor(spnEffic,""String_Node_Str""));
            spnEffic.getEditor().setPreferredSize(new java.awt.Dimension(28,16));
            spnEffic.setPreferredSize(new java.awt.Dimension(53,18));
          }
{
            SpinnerNumberModel spnAttenModel=new SpinnerNumberModel(75.0,0.0,100.0,1.0);
            spnAtten=new JSpinner();
            pnlDetails.add(spnAtten,new GridBagConstraints(4,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            spnAtten.setModel(spnAttenModel);
            spnAtten.addChangeListener(new ChangeListener(){
              public void stateChanged(              ChangeEvent evt){
                myRecipe.setAttenuation(Double.parseDouble(spnAtten.getValue().toString()));
                displayRecipe();
              }
            }
);
            spnAtten.setEditor(new JSpinner.NumberEditor(spnAtten,""String_Node_Str""));
            spnAtten.setPreferredSize(new java.awt.Dimension(49,20));
          }
{
            SpinnerNumberModel spnOgModel=new SpinnerNumberModel(1.000,0.900,2.000,0.001);
            spnOG=new JSpinner();
            pnlDetails.add(spnOG,new GridBagConstraints(6,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            spnOG.setModel(spnOgModel);
            spnOG.addChangeListener(new ChangeListener(){
              public void stateChanged(              ChangeEvent evt){
                myRecipe.setEstOg(Double.parseDouble(spnOG.getValue().toString()));
                displayRecipe();
              }
            }
);
            spnOG.setEditor(new JSpinner.NumberEditor(spnOG,""String_Node_Str""));
            spnOG.getEditor().setPreferredSize(new java.awt.Dimension(20,16));
            spnOG.setPreferredSize(new java.awt.Dimension(67,18));
          }
{
            SpinnerNumberModel spnFgModel=new SpinnerNumberModel(1.000,0.900,2.000,0.001);
            spnFG=new JSpinner();
            pnlDetails.add(spnFG,new GridBagConstraints(6,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            spnFG.setModel(spnFgModel);
            spnFG.setEditor(new JSpinner.NumberEditor(spnFG,""String_Node_Str""));
            spnFG.setPreferredSize(new java.awt.Dimension(69,20));
            spnFG.addChangeListener(new ChangeListener(){
              public void stateChanged(              ChangeEvent evt){
                myRecipe.setEstFg(Double.parseDouble(spnFG.getValue().toString()));
                displayRecipe();
              }
            }
);
          }
{
            lblIBUvalue=new JLabel();
            pnlDetails.add(lblIBUvalue,new GridBagConstraints(8,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblIBUvalue.setText(""String_Node_Str"");
          }
{
            lblColourValue=new JLabel();
            pnlDetails.add(lblColourValue,new GridBagConstraints(8,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblColourValue.setText(""String_Node_Str"");
          }
{
            lblAlcValue=new JLabel();
            pnlDetails.add(lblAlcValue,new GridBagConstraints(8,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblAlcValue.setText(""String_Node_Str"");
          }
{
            scpComments=new JScrollPane();
            pnlDetails.add(scpComments,new GridBagConstraints(7,4,3,2,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
{
              txtComments=new JTextArea();
              scpComments.setViewportView(txtComments);
              txtComments.setText(""String_Node_Str"");
              txtComments.setWrapStyleWord(true);
              txtComments.setLineWrap(true);
              txtComments.setPreferredSize(new java.awt.Dimension(263,40));
              txtComments.addFocusListener(new FocusAdapter(){
                public void focusLost(                FocusEvent evt){
                  if (!txtComments.getText().equals(myRecipe.getComments())) {
                    myRecipe.setComments(txtComments.getText());
                  }
                }
              }
);
            }
          }
{
            cmbYeastModel=new ComboModel();
            cmbYeast=new JComboBox();
            pnlDetails.add(cmbYeast,new GridBagConstraints(1,3,5,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            cmbYeast.setModel(cmbYeastModel);
            cmbYeast.setPreferredSize(new java.awt.Dimension(193,20));
            cmbYeast.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                Yeast y=(Yeast)cmbYeastModel.getSelectedItem();
                if (myRecipe != null && y != myRecipe.getYeastObj()) {
                  myRecipe.setYeast(y);
                }
                String st=SBStringUtils.multiLineToolTip(40,y.getDescription());
                cmbYeast.setToolTipText(st);
              }
            }
);
          }
{
            cmbSizeUnitsModel=new ComboModel();
            cmbSizeUnits=new JComboBox();
            pnlDetails.add(cmbSizeUnits,new GridBagConstraints(2,4,2,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            cmbSizeUnits.setModel(cmbSizeUnitsModel);
            cmbSizeUnits.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                String q=(String)cmbSizeUnits.getSelectedItem();
                if (myRecipe != null && q != myRecipe.getVolUnits()) {
                  myRecipe.setVolUnits(q);
                  displayRecipe();
                }
              }
            }
);
          }
{
            lblSizeUnits=new JLabel();
            pnlDetails.add(lblSizeUnits,new GridBagConstraints(2,5,2,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            lblSizeUnits.setText(""String_Node_Str"");
          }
{
            boilTimeLable=new JLabel();
            pnlDetails.add(boilTimeLable,new GridBagConstraints(4,4,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            boilTimeLable.setText(""String_Node_Str"");
          }
{
            evapLabel=new JLabel();
            pnlDetails.add(evapLabel,new GridBagConstraints(4,5,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            evapLabel.setText(""String_Node_Str"");
          }
{
            boilMinText=new JTextField();
            pnlDetails.add(boilMinText,new GridBagConstraints(5,4,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            boilMinText.setText(""String_Node_Str"");
            boilMinText.setPreferredSize(new java.awt.Dimension(22,20));
            boilMinText.addFocusListener(this);
            boilMinText.addActionListener(this);
          }
{
            evapText=new JTextField();
            pnlDetails.add(evapText,new GridBagConstraints(5,5,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            evapText.setText(""String_Node_Str"");
            evapText.setPreferredSize(new java.awt.Dimension(23,20));
            evapText.addFocusListener(this);
            evapText.addActionListener(this);
          }
{
            alcMethodComboModel=new DefaultComboBoxModel(new String[]{""String_Node_Str"",""String_Node_Str""});
            alcMethodCombo=new JComboBox(alcMethodComboModel);
            pnlDetails.add(alcMethodCombo,new GridBagConstraints(9,0,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            alcMethodCombo.setPreferredSize(new java.awt.Dimension(58,20));
            alcMethodCombo.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                recipeSettingsActionPerformed(evt);
              }
            }
);
          }
{
            ibuMethodComboModel=new DefaultComboBoxModel(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
            ibuMethodCombo=new JComboBox(ibuMethodComboModel);
            pnlDetails.add(ibuMethodCombo,new GridBagConstraints(9,1,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            ibuMethodCombo.setPreferredSize(new java.awt.Dimension(59,20));
            ibuMethodCombo.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                recipeSettingsActionPerformed(evt);
              }
            }
);
          }
{
            colourMethodComboModel=new DefaultComboBoxModel(new String[]{""String_Node_Str"",""String_Node_Str""});
            colourMethodCombo=new JComboBox(colourMethodComboModel);
            pnlDetails.add(colourMethodCombo,new GridBagConstraints(9,2,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            colourMethodCombo.setPreferredSize(new java.awt.Dimension(44,20));
            colourMethodCombo.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                recipeSettingsActionPerformed(evt);
              }
            }
);
          }
          ComboBoxModel evapMethodComboModel=new DefaultComboBoxModel(new String[]{""String_Node_Str"",""String_Node_Str""});
          evapMethodCombo=new JComboBox();
          pnlDetails.add(evapMethodCombo,new GridBagConstraints(6,5,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
          evapMethodCombo.setModel(evapMethodComboModel);
          evapMethodCombo.setPreferredSize(new java.awt.Dimension(64,20));
          colourPanel=new JPanel();
          pnlDetails.add(colourPanel,new GridBagConstraints(8,3,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
          colourPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
          colourPanel2=new JPanel();
          pnlDetails.add(colourPanel2,new GridBagConstraints(9,3,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
          colourPanel2.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
          evapMethodCombo.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              recipeSettingsActionPerformed(evt);
            }
          }
);
        }
{
          SBNotifier sbn=new SBNotifier();
          stylePanel=new StylePanel(sbn);
          jTabbedPane1.addTab(""String_Node_Str"",null,stylePanel,null);
        }
{
          miscPanel=new MiscPanel(myRecipe);
          jTabbedPane1.addTab(""String_Node_Str"",null,miscPanel,null);
        }
{
          notesPanel=new NotesPanel();
          jTabbedPane1.addTab(""String_Node_Str"",null,notesPanel,null);
        }
{
          dilutionPanel=new DilutionPanel();
          jTabbedPane1.addTab(""String_Node_Str"",null,dilutionPanel,null);
        }
{
          SBNotifier sbn=new SBNotifier();
          settingsPanel=new SettingsPanel(sbn);
          jTabbedPane1.addTab(""String_Node_Str"",null,settingsPanel,null);
        }
      }
{
        pnlTables=new JPanel();
        BoxLayout pnlMaltsLayout=new BoxLayout(pnlTables,javax.swing.BoxLayout.Y_AXIS);
        pnlMain.add(pnlTables,new GridBagConstraints(0,2,1,1,0.5,0.5,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
        pnlTables.setLayout(pnlMaltsLayout);
{
          pnlMalt=new JPanel();
          pnlTables.add(pnlMalt);
          BorderLayout pnlMaltLayout1=new BorderLayout();
          pnlMalt.setBorder(BorderFactory.createTitledBorder(new LineBorder(new java.awt.Color(0,0,0),1,false),""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP,new java.awt.Font(""String_Node_Str"",1,12),new java.awt.Color(51,51,51)));
          pnlMalt.setLayout(pnlMaltLayout1);
{
            jScrollPane1=new JScrollPane();
            pnlMalt.add(jScrollPane1,BorderLayout.CENTER);
{
              maltTableModel=new MaltTableModel(this);
              maltTable=new JTable(){
                public String getToolTipText(                MouseEvent e){
                  java.awt.Point p=e.getPoint();
                  int rowIndex=rowAtPoint(p);
                  return SBStringUtils.multiLineToolTip(40,maltTableModel.getDescriptionAt(rowIndex));
                }
              }
;
              jScrollPane1.setViewportView(maltTable);
              maltTable.setModel(maltTableModel);
              maltTable.getTableHeader().setReorderingAllowed(false);
              TableColumn maltColumn=maltTable.getColumnModel().getColumn(0);
              JComboBox maltComboBox=new JComboBox();
              cmbMaltModel=new ComboModel();
              maltComboBox.setModel(cmbMaltModel);
              maltColumn.setCellEditor(new DefaultCellEditor(maltComboBox));
              maltComboBox.addActionListener(new ActionListener(){
                public void actionPerformed(                ActionEvent evt){
                  Fermentable f=(Fermentable)cmbMaltModel.getSelectedItem();
                  int i=maltTable.getSelectedRow();
                  if (myRecipe != null && i != -1) {
                    Fermentable f2=myRecipe.getFermentable(i);
                    if (f2 != null) {
                      f2.setLov(f.getLov());
                      f2.setPppg(f.getPppg());
                      f2.setDescription(f.getDescription());
                      f2.setMashed(f.getMashed());
                      f2.setSteep(f.getSteep());
                    }
                  }
                }
              }
);
              JComboBox maltUnitsComboBox=new JComboBox();
              cmbMaltUnitsModel=new ComboModel();
              maltUnitsComboBox.setModel(cmbMaltUnitsModel);
              maltColumn=maltTable.getColumnModel().getColumn(2);
              maltColumn.setCellEditor(new DefaultCellEditor(maltUnitsComboBox));
              maltUnitsComboBox.addActionListener(new ActionListener(){
                public void actionPerformed(                ActionEvent evt){
                  String u=(String)cmbMaltUnitsModel.getSelectedItem();
                  int i=maltTable.getSelectedRow();
                  if (myRecipe != null && i != -1) {
                    Fermentable f2=myRecipe.getFermentable(i);
                    if (f2 != null) {
                      f2.setUnitsFull(u);
                      myRecipe.calcMaltTotals();
                      displayRecipe();
                    }
                  }
                }
              }
);
            }
          }
{
            tblMaltTotalsModel=new DefaultTableModel(new String[][]{{""String_Node_Str""}},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
            tblMaltTotals=new JTable();
            pnlMalt.add(tblMaltTotals,BorderLayout.SOUTH);
            tblMaltTotals.setModel(tblMaltTotalsModel);
            tblMaltTotals.getTableHeader().setEnabled(false);
            tblMaltTotals.setAutoCreateColumnsFromModel(false);
          }
        }
{
          pnlMaltButtons=new JPanel();
          pnlTables.add(pnlMaltButtons);
          FlowLayout pnlMaltButtonsLayout=new FlowLayout();
          pnlMaltButtonsLayout.setAlignment(FlowLayout.LEFT);
          pnlMaltButtonsLayout.setVgap(0);
          pnlMaltButtons.setLayout(pnlMaltButtonsLayout);
          pnlMaltButtons.setPreferredSize(new java.awt.Dimension(592,27));
{
            tlbMalt=new JToolBar();
            pnlMaltButtons.add(tlbMalt);
            tlbMalt.setPreferredSize(new java.awt.Dimension(55,20));
            tlbMalt.setFloatable(false);
{
              btnAddMalt=new JButton();
              tlbMalt.add(btnAddMalt);
              btnAddMalt.setText(""String_Node_Str"");
              btnAddMalt.addActionListener(new ActionListener(){
                public void actionPerformed(                ActionEvent evt){
                  if (myRecipe != null) {
                    Fermentable f=new Fermentable(myRecipe.getMaltUnits());
                    myRecipe.addMalt(f);
                    maltTable.updateUI();
                    displayRecipe();
                  }
                }
              }
);
            }
{
              btnDelMalt=new JButton();
              tlbMalt.add(btnDelMalt);
              btnDelMalt.setText(""String_Node_Str"");
              btnDelMalt.addActionListener(new ActionListener(){
                public void actionPerformed(                ActionEvent evt){
                  if (myRecipe != null) {
                    int i=maltTable.getSelectedRow();
                    myRecipe.delMalt(i);
                    maltTable.updateUI();
                    displayRecipe();
                  }
                }
              }
);
            }
          }
        }
{
          pnlHops=new JPanel();
          BorderLayout pnlHopsLayout=new BorderLayout();
          pnlHops.setBorder(BorderFactory.createTitledBorder(new LineBorder(new java.awt.Color(0,0,0),1,false),""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP,new java.awt.Font(""String_Node_Str"",1,12),new java.awt.Color(51,51,51)));
          pnlHops.setLayout(pnlHopsLayout);
          pnlTables.add(pnlHops);
{
            tblHopsTotalsModel=new DefaultTableModel(new String[][]{{""String_Node_Str""}},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
            tblHopsTotals=new JTable();
            pnlHops.add(tblHopsTotals,BorderLayout.SOUTH);
            tblHopsTotals.setModel(tblHopsTotalsModel);
            tblHopsTotals.setAutoCreateColumnsFromModel(false);
          }
{
            jScrollPane2=new JScrollPane();
            pnlHops.add(jScrollPane2,BorderLayout.CENTER);
{
              hopsTableModel=new HopsTableModel(this);
              hopsTable=new JTable(){
                public String getToolTipText(                MouseEvent e){
                  java.awt.Point p=e.getPoint();
                  int rowIndex=rowAtPoint(p);
                  return SBStringUtils.multiLineToolTip(40,hopsTableModel.getDescriptionAt(rowIndex));
                }
              }
;
              jScrollPane2.setViewportView(hopsTable);
              hopsTable.setModel(hopsTableModel);
              hopsTable.getTableHeader().setReorderingAllowed(false);
              TableColumn hopColumn=hopsTable.getColumnModel().getColumn(0);
              JComboBox hopComboBox=new JComboBox();
              cmbHopsModel=new ComboModel();
              hopComboBox.setModel(cmbHopsModel);
              hopColumn.setCellEditor(new DefaultCellEditor(hopComboBox));
              hopComboBox.addActionListener(new ActionListener(){
                public void actionPerformed(                ActionEvent evt){
                  Hop h=(Hop)cmbHopsModel.getSelectedItem();
                  int i=hopsTable.getSelectedRow();
                  if (myRecipe != null && i != -1) {
                    Hop h2=myRecipe.getHop(i);
                    h2.setAlpha(h.getAlpha());
                    h2.setDescription(h.getDescription());
                  }
                }
              }
);
              JComboBox hopsUnitsComboBox=new JComboBox();
              cmbHopsUnitsModel=new ComboModel();
              hopsUnitsComboBox.setModel(cmbHopsUnitsModel);
              hopColumn=hopsTable.getColumnModel().getColumn(4);
              hopColumn.setCellEditor(new DefaultCellEditor(hopsUnitsComboBox));
              hopsUnitsComboBox.addActionListener(new ActionListener(){
                public void actionPerformed(                ActionEvent evt){
                  String u=(String)cmbHopsUnitsModel.getSelectedItem();
                  int i=hopsTable.getSelectedRow();
                  if (myRecipe != null && i != -1) {
                    Hop h=myRecipe.getHop(i);
                    h.setUnitsFull(u);
                    myRecipe.calcHopsTotals();
                    displayRecipe();
                  }
                }
              }
);
              String[] forms={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
              JComboBox hopsFormComboBox=new JComboBox(forms);
              hopColumn=hopsTable.getColumnModel().getColumn(1);
              hopColumn.setCellEditor(new DefaultCellEditor(hopsFormComboBox));
              String[] add={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
              JComboBox hopsAddComboBox=new JComboBox(add);
              hopColumn=hopsTable.getColumnModel().getColumn(5);
              hopColumn.setCellEditor(new DefaultCellEditor(hopsAddComboBox));
            }
          }
        }
{
          pnlHopsButtons=new JPanel();
          FlowLayout pnlHopsButtonsLayout=new FlowLayout();
          pnlHopsButtonsLayout.setAlignment(FlowLayout.LEFT);
          pnlHopsButtonsLayout.setVgap(0);
          pnlHopsButtons.setLayout(pnlHopsButtonsLayout);
          pnlTables.add(pnlHopsButtons);
          pnlHopsButtons.setPreferredSize(new java.awt.Dimension(512,16));
{
            tlbHops=new JToolBar();
            pnlHopsButtons.add(tlbHops);
            tlbHops.setPreferredSize(new java.awt.Dimension(58,19));
            tlbHops.setFloatable(false);
{
              btnAddHop=new JButton();
              tlbHops.add(btnAddHop);
              btnAddHop.setText(""String_Node_Str"");
              btnAddHop.addActionListener(new ActionListener(){
                public void actionPerformed(                ActionEvent evt){
                  if (myRecipe != null) {
                    Hop h=new Hop(myRecipe.getHopUnits());
                    myRecipe.addHop(h);
                    hopsTable.updateUI();
                    displayRecipe();
                  }
                }
              }
);
            }
{
              btnDelHop=new JButton();
              tlbHops.add(btnDelHop);
              btnDelHop.setText(""String_Node_Str"");
              btnDelHop.addActionListener(new ActionListener(){
                public void actionPerformed(                ActionEvent evt){
                  if (myRecipe != null) {
                    int i=hopsTable.getSelectedRow();
                    myRecipe.delHop(i);
                    hopsTable.updateUI();
                    displayRecipe();
                  }
                }
              }
);
            }
          }
        }
      }
{
        statusPanel=new JPanel();
        FlowLayout statusPanelLayout=new FlowLayout();
        statusPanelLayout.setAlignment(FlowLayout.LEFT);
        statusPanelLayout.setHgap(2);
        statusPanelLayout.setVgap(2);
        statusPanel.setLayout(statusPanelLayout);
        pnlMain.add(statusPanel,new GridBagConstraints(0,3,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
{
          fileNamePanel=new JPanel();
          statusPanel.add(fileNamePanel);
          fileNamePanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
{
            fileNameLabel=new JLabel();
            fileNamePanel.add(fileNameLabel);
            fileNameLabel.setText(""String_Node_Str"");
            fileNameLabel.setFont(new java.awt.Font(""String_Node_Str"",1,10));
          }
        }
{
          ibuMethodPanel=new JPanel();
          statusPanel.add(ibuMethodPanel);
          ibuMethodPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
{
            ibuMethodLabel=new JLabel();
            ibuMethodPanel.add(ibuMethodLabel);
            ibuMethodLabel.setText(""String_Node_Str"");
            ibuMethodLabel.setFont(new java.awt.Font(""String_Node_Str"",1,10));
          }
        }
{
          alcMethodPanel=new JPanel();
          statusPanel.add(alcMethodPanel);
          alcMethodPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
{
            alcMethodLabel=new JLabel();
            alcMethodPanel.add(alcMethodLabel);
            alcMethodLabel.setText(""String_Node_Str"");
            alcMethodLabel.setFont(new java.awt.Font(""String_Node_Str"",1,10));
          }
        }
      }
    }
{
      jMenuBar1=new JMenuBar();
      setJMenuBar(jMenuBar1);
{
        fileMenu=new JMenu();
        jMenuBar1.add(fileMenu);
        fileMenu.setText(""String_Node_Str"");
{
          newFileMenuItem=new JMenuItem();
          fileMenu.add(newFileMenuItem);
          newFileMenuItem.setText(""String_Node_Str"");
          newFileMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              myRecipe=new Recipe();
              currentFile=null;
              attachRecipeData();
              displayRecipe();
            }
          }
);
        }
{
          openFileMenuItem=new JMenuItem();
          fileMenu.add(openFileMenuItem);
          openFileMenuItem.setText(""String_Node_Str"");
          openFileMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              String[] ext={""String_Node_Str"",""String_Node_Str""};
              String desc=""String_Node_Str"";
              sbFileFilter saveFileFilter=new sbFileFilter(ext,desc);
              fileChooser.setFileFilter(saveFileFilter);
              int returnVal=fileChooser.showOpenDialog(jMenuBar1);
              if (returnVal == JFileChooser.APPROVE_OPTION) {
                File file=fileChooser.getSelectedFile();
                Debug.print(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
                ImportXml imp=new ImportXml(file.toString());
                myRecipe=imp.handler.getRecipe();
                myRecipe.calcMaltTotals();
                myRecipe.calcHopsTotals();
                myRecipe.mash.calcMashSchedule();
                attachRecipeData();
                currentFile=file;
                displayRecipe();
              }
 else {
                Debug.print(""String_Node_Str"");
              }
            }
          }
);
        }
{
          findFileMenuItem=new JMenuItem();
          findFileMenuItem.setText(""String_Node_Str"");
          fileMenu.add(findFileMenuItem);
          final JFrame owner=this;
          findFileMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              FindDialog fd=new FindDialog(owner);
              fd.setVisible(true);
            }
          }
);
        }
{
          saveMenuItem=new JMenuItem();
          fileMenu.add(saveMenuItem);
          saveMenuItem.setText(""String_Node_Str"");
          saveMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              int choice=1;
              if (currentFile != null) {
                File file=currentFile;
                try {
                  FileWriter out=new FileWriter(file);
                  out.write(myRecipe.toXML());
                  out.close();
                  Debug.print(""String_Node_Str"" + file.getAbsoluteFile());
                  currentFile=file;
                }
 catch (                Exception e) {
                  showError(e);
                }
              }
 else {
                choice=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
              }
              if (choice == 0) {
                saveAs();
              }
            }
          }
);
        }
{
          saveAsMenuItem=new JMenuItem();
          fileMenu.add(saveAsMenuItem);
          saveAsMenuItem.setText(""String_Node_Str"");
          saveAsMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              Debug.print(myRecipe.toXML());
              saveAs();
            }
          }
);
        }
{
          exportMenu=new JMenu();
          fileMenu.add(exportMenu);
          exportMenu.setText(""String_Node_Str"");
{
            exportHTMLmenu=new JMenuItem();
            exportMenu.add(exportHTMLmenu);
            exportHTMLmenu.setText(""String_Node_Str"");
            exportHTMLmenu.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                String[] ext={""String_Node_Str"",""String_Node_Str""};
                sbFileFilter saveFileFilter=new sbFileFilter(ext,""String_Node_Str"");
                fileChooser.setFileFilter(saveFileFilter);
                fileChooser.setSelectedFile(new File(myRecipe.getName() + ""String_Node_Str""));
                int returnVal=fileChooser.showSaveDialog(jMenuBar1);
                if (returnVal == JFileChooser.APPROVE_OPTION) {
                  File file=fileChooser.getSelectedFile();
                  try {
                    saveAsHTML(file);
                  }
 catch (                  Exception e) {
                    showError(e);
                  }
                }
 else {
                  Debug.print(""String_Node_Str"");
                }
              }
            }
);
            exportTextMenuItem=new JMenuItem();
            exportMenu.add(exportTextMenuItem);
            exportTextMenuItem.setText(""String_Node_Str"");
            exportTextMenuItem.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                String[] ext={""String_Node_Str""};
                sbFileFilter saveFileFilter=new sbFileFilter(ext,""String_Node_Str"");
                fileChooser.setFileFilter(saveFileFilter);
                fileChooser.setSelectedFile(new File(myRecipe.getName() + ""String_Node_Str""));
                int returnVal=fileChooser.showSaveDialog(jMenuBar1);
                if (returnVal == JFileChooser.APPROVE_OPTION) {
                  File file=fileChooser.getSelectedFile();
                  try {
                    FileWriter out=new FileWriter(file);
                    out.write(myRecipe.toText());
                    out.close();
                  }
 catch (                  Exception e) {
                    showError(e);
                  }
                }
 else {
                  Debug.print(""String_Node_Str"");
                }
              }
            }
);
          }
        }
{
          jSeparator2=new JSeparator();
          fileMenu.add(jSeparator2);
        }
{
          exitMenuItem=new JMenuItem();
          fileMenu.add(exitMenuItem);
          exitMenuItem.setText(""String_Node_Str"");
          exitMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              System.exit(0);
            }
          }
);
        }
      }
{
        jMenu4=new JMenu();
        jMenuBar1.add(jMenu4);
        jMenu4.setText(""String_Node_Str"");
{
          final JFrame owner=this;
          editPrefsMenuItem=new JMenuItem();
          jMenu4.add(editPrefsMenuItem);
          editPrefsMenuItem.setText(""String_Node_Str"");
          editPrefsMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              PreferencesDialog d=new PreferencesDialog(owner,preferences);
              d.setVisible(true);
            }
          }
);
        }
{
          jSeparator1=new JSeparator();
          jMenu4.add(jSeparator1);
        }
{
          deleteMenuItem=new JMenuItem();
          jMenu4.add(deleteMenuItem);
          deleteMenuItem.setText(""String_Node_Str"");
          deleteMenuItem.setEnabled(false);
        }
      }
{
        mnuTools=new JMenu();
        jMenuBar1.add(mnuTools);
        mnuTools.setText(""String_Node_Str"");
{
          mashManagerMenuItem=new JMenuItem();
          mnuTools.add(mashManagerMenuItem);
          mashManagerMenuItem.setText(""String_Node_Str"");
          mashManagerMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              mashMgr=new MashManager(myRecipe);
              mashMgr.setVisible(true);
            }
          }
);
          JMenuItem maltPercentMenuItem=new JMenuItem();
          mnuTools.add(maltPercentMenuItem);
          maltPercentMenuItem.setText(""String_Node_Str"");
          final JFrame owner=this;
          maltPercentMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              MaltPercentDialog maltPercent=new MaltPercentDialog(owner);
              maltPercent.setVisible(true);
            }
          }
);
        }
      }
{
        jMenu5=new JMenu();
        jMenuBar1.add(jMenu5);
        jMenu5.setText(""String_Node_Str"");
{
          helpMenuItem=new JMenuItem();
          jMenu5.add(helpMenuItem);
          helpMenuItem.setText(""String_Node_Str"");
        }
{
          aboutMenuItem=new JMenuItem();
          jMenu5.add(aboutMenuItem);
          aboutMenuItem.setText(""String_Node_Str"");
          final JFrame owner=this;
          aboutMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              aboutDlg=new AboutDialog(owner,version);
              aboutDlg.setVisible(true);
            }
          }
);
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","private void initGUI(){
  try {
    this.setSize(600,532);
    this.addWindowListener(new WindowAdapter(){
      public void windowClosed(      WindowEvent evt){
        System.exit(1);
      }
    }
);
{
      pnlMain=new JPanel();
      GridBagLayout jPanel2Layout=new GridBagLayout();
      jPanel2Layout.columnWeights=new double[]{0.1};
      jPanel2Layout.columnWidths=new int[]{7};
      jPanel2Layout.rowWeights=new double[]{0.1,0.1,0.9,0.1};
      jPanel2Layout.rowHeights=new int[]{7,7,7,7};
      pnlMain.setLayout(jPanel2Layout);
      this.getContentPane().add(pnlMain,BorderLayout.CENTER);
{
        jPanel1=new JPanel();
        pnlMain.add(jPanel1,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
        FlowLayout jPanel1Layout=new FlowLayout();
        jPanel1Layout.setAlignment(FlowLayout.LEFT);
        jPanel1.setLayout(jPanel1Layout);
{
          lblName=new JLabel();
          jPanel1.add(lblName);
          lblName.setText(""String_Node_Str"");
        }
{
          txtName=new JTextField();
          jPanel1.add(txtName);
          txtName.setText(""String_Node_Str"");
          txtName.setPreferredSize(new java.awt.Dimension(179,20));
          txtName.addActionListener(this);
          txtName.addFocusListener(this);
        }
      }
{
        jTabbedPane1=new JTabbedPane();
        pnlMain.add(jTabbedPane1,new GridBagConstraints(0,1,1,1,0.1,0.1,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
{
          pnlDetails=new JPanel();
          GridBagLayout pnlDetailsLayout=new GridBagLayout();
          pnlDetailsLayout.columnWeights=new double[]{0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1};
          pnlDetailsLayout.columnWidths=new int[]{7,7,7,7,7,7,7,7,7,7};
          pnlDetailsLayout.rowWeights=new double[]{0.1,0.1,0.1,0.1,0.1,0.1,0.1};
          pnlDetailsLayout.rowHeights=new int[]{7,7,7,7,7,7,7};
          pnlDetails.setLayout(pnlDetailsLayout);
          jTabbedPane1.addTab(""String_Node_Str"",null,pnlDetails,null);
          pnlDetails.setPreferredSize(new java.awt.Dimension(20,16));
{
            lblBrewer=new JLabel();
            pnlDetails.add(lblBrewer,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblBrewer.setText(""String_Node_Str"");
          }
{
            brewerNameText=new JTextField();
            pnlDetails.add(brewerNameText,new GridBagConstraints(1,0,2,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            brewerNameText.setPreferredSize(new java.awt.Dimension(69,20));
            brewerNameText.addFocusListener(this);
            brewerNameText.addActionListener(this);
            brewerNameText.setText(""String_Node_Str"");
          }
{
            lblDate=new JLabel();
            pnlDetails.add(lblDate,new GridBagConstraints(0,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblDate.setText(""String_Node_Str"");
          }
{
            lblStyle=new JLabel();
            pnlDetails.add(lblStyle,new GridBagConstraints(0,2,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblStyle.setText(""String_Node_Str"");
          }
{
            lblYeast=new JLabel();
            pnlDetails.add(lblYeast,new GridBagConstraints(0,3,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblYeast.setText(""String_Node_Str"");
          }
{
            lblPreBoil=new JLabel();
            pnlDetails.add(lblPreBoil,new GridBagConstraints(0,4,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblPreBoil.setText(""String_Node_Str"");
          }
{
            lblPostBoil=new JLabel();
            pnlDetails.add(lblPostBoil,new GridBagConstraints(0,5,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblPostBoil.setText(""String_Node_Str"");
          }
{
            lblEffic=new JLabel();
            pnlDetails.add(lblEffic,new GridBagConstraints(3,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblEffic.setText(""String_Node_Str"");
            lblEffic.setPreferredSize(new java.awt.Dimension(31,14));
          }
{
            lblAtten=new JLabel();
            pnlDetails.add(lblAtten,new GridBagConstraints(3,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblAtten.setText(""String_Node_Str"");
            lblAtten.setPreferredSize(new java.awt.Dimension(34,14));
          }
{
            lblOG=new JLabel();
            pnlDetails.add(lblOG,new GridBagConstraints(5,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblOG.setText(""String_Node_Str"");
          }
{
            lblFG=new JLabel();
            pnlDetails.add(lblFG,new GridBagConstraints(5,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblFG.setText(""String_Node_Str"");
          }
{
            lblIBU=new JLabel();
            pnlDetails.add(lblIBU,new GridBagConstraints(7,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblIBU.setText(""String_Node_Str"");
          }
{
            lblAlc=new JLabel();
            pnlDetails.add(lblAlc,new GridBagConstraints(7,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblAlc.setText(""String_Node_Str"");
          }
{
            lblColour=new JLabel();
            pnlDetails.add(lblColour,new GridBagConstraints(7,2,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblColour.setText(""String_Node_Str"");
          }
{
            txtDate=new JFormattedTextField();
            pnlDetails.add(txtDate,new GridBagConstraints(1,1,2,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            txtDate.setText(""String_Node_Str"");
            txtDate.setPreferredSize(new java.awt.Dimension(73,20));
            txtDate.addFocusListener(this);
            txtDate.addActionListener(this);
          }
{
            cmbStyleModel=new ComboModel();
            cmbStyle=new JComboBox();
            pnlDetails.add(cmbStyle,new GridBagConstraints(1,2,5,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            cmbStyle.setModel(cmbStyleModel);
            cmbStyle.setMaximumSize(new java.awt.Dimension(100,32767));
            cmbStyle.setPreferredSize(new java.awt.Dimension(190,20));
            cmbStyle.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                Style s=(Style)cmbStyleModel.getSelectedItem();
                if (myRecipe != null && s != myRecipe.getStyleObj()) {
                  myRecipe.setStyle(s);
                  stylePanel.setStyle(s);
                }
                cmbStyle.setToolTipText(SBStringUtils.multiLineToolTip(50,s.getDescription()));
              }
            }
);
          }
{
            txtPreBoil=new JFormattedTextField();
            pnlDetails.add(txtPreBoil,new GridBagConstraints(1,4,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            txtPreBoil.setText(""String_Node_Str"");
            txtPreBoil.setPreferredSize(new java.awt.Dimension(37,20));
            txtPreBoil.addFocusListener(this);
            txtPreBoil.addActionListener(this);
          }
{
            postBoilText=new JFormattedTextField();
            pnlDetails.add(postBoilText,new GridBagConstraints(1,5,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            postBoilText.setText(""String_Node_Str"");
            postBoilText.setPreferredSize(new java.awt.Dimension(46,20));
            postBoilText.addFocusListener(new FocusAdapter(){
              public void focusLost(              FocusEvent evt){
                myRecipe.setPostBoil(Double.parseDouble(postBoilText.getText().toString()));
                displayRecipe();
              }
            }
);
            postBoilText.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                myRecipe.setPostBoil(Double.parseDouble(postBoilText.getText().toString()));
                displayRecipe();
              }
            }
);
          }
{
            lblComments=new JLabel();
            pnlDetails.add(lblComments,new GridBagConstraints(6,4,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblComments.setText(""String_Node_Str"");
          }
{
            SpinnerNumberModel spnEfficModel=new SpinnerNumberModel(75.0,0.0,100.0,1.0);
            spnEffic=new JSpinner();
            pnlDetails.add(spnEffic,new GridBagConstraints(4,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            spnEffic.setModel(spnEfficModel);
            spnEffic.setMaximumSize(new java.awt.Dimension(70,32767));
            spnEffic.addChangeListener(new ChangeListener(){
              public void stateChanged(              ChangeEvent evt){
                myRecipe.setEfficiency(Double.parseDouble(spnEffic.getValue().toString()));
                displayRecipe();
              }
            }
);
            spnEffic.setEditor(new JSpinner.NumberEditor(spnEffic,""String_Node_Str""));
            spnEffic.getEditor().setPreferredSize(new java.awt.Dimension(28,16));
            spnEffic.setPreferredSize(new java.awt.Dimension(53,18));
          }
{
            SpinnerNumberModel spnAttenModel=new SpinnerNumberModel(75.0,0.0,100.0,1.0);
            spnAtten=new JSpinner();
            pnlDetails.add(spnAtten,new GridBagConstraints(4,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            spnAtten.setModel(spnAttenModel);
            spnAtten.addChangeListener(new ChangeListener(){
              public void stateChanged(              ChangeEvent evt){
                myRecipe.setAttenuation(Double.parseDouble(spnAtten.getValue().toString()));
                displayRecipe();
              }
            }
);
            spnAtten.setEditor(new JSpinner.NumberEditor(spnAtten,""String_Node_Str""));
            spnAtten.setPreferredSize(new java.awt.Dimension(49,20));
          }
{
            SpinnerNumberModel spnOgModel=new SpinnerNumberModel(1.000,0.900,2.000,0.001);
            spnOG=new JSpinner();
            pnlDetails.add(spnOG,new GridBagConstraints(6,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            spnOG.setModel(spnOgModel);
            spnOG.addChangeListener(new ChangeListener(){
              public void stateChanged(              ChangeEvent evt){
                myRecipe.setEstOg(Double.parseDouble(spnOG.getValue().toString()));
                displayRecipe();
              }
            }
);
            spnOG.setEditor(new JSpinner.NumberEditor(spnOG,""String_Node_Str""));
            spnOG.getEditor().setPreferredSize(new java.awt.Dimension(20,16));
            spnOG.setPreferredSize(new java.awt.Dimension(67,18));
          }
{
            SpinnerNumberModel spnFgModel=new SpinnerNumberModel(1.000,0.900,2.000,0.001);
            spnFG=new JSpinner();
            pnlDetails.add(spnFG,new GridBagConstraints(6,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            spnFG.setModel(spnFgModel);
            spnFG.setEditor(new JSpinner.NumberEditor(spnFG,""String_Node_Str""));
            spnFG.setPreferredSize(new java.awt.Dimension(69,20));
            spnFG.addChangeListener(new ChangeListener(){
              public void stateChanged(              ChangeEvent evt){
                myRecipe.setEstFg(Double.parseDouble(spnFG.getValue().toString()));
                displayRecipe();
              }
            }
);
          }
{
            lblIBUvalue=new JLabel();
            pnlDetails.add(lblIBUvalue,new GridBagConstraints(8,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblIBUvalue.setText(""String_Node_Str"");
          }
{
            lblColourValue=new JLabel();
            pnlDetails.add(lblColourValue,new GridBagConstraints(8,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblColourValue.setText(""String_Node_Str"");
          }
{
            lblAlcValue=new JLabel();
            pnlDetails.add(lblAlcValue,new GridBagConstraints(8,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblAlcValue.setText(""String_Node_Str"");
          }
{
            scpComments=new JScrollPane();
            pnlDetails.add(scpComments,new GridBagConstraints(7,4,3,2,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
{
              txtComments=new JTextArea();
              scpComments.setViewportView(txtComments);
              txtComments.setText(""String_Node_Str"");
              txtComments.setWrapStyleWord(true);
              txtComments.setLineWrap(true);
              txtComments.setPreferredSize(new java.awt.Dimension(263,40));
              txtComments.addFocusListener(new FocusAdapter(){
                public void focusLost(                FocusEvent evt){
                  if (!txtComments.getText().equals(myRecipe.getComments())) {
                    myRecipe.setComments(txtComments.getText());
                  }
                }
              }
);
            }
          }
{
            cmbYeastModel=new ComboModel();
            cmbYeast=new JComboBox();
            pnlDetails.add(cmbYeast,new GridBagConstraints(1,3,5,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            cmbYeast.setModel(cmbYeastModel);
            cmbYeast.setPreferredSize(new java.awt.Dimension(193,20));
            cmbYeast.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                Yeast y=(Yeast)cmbYeastModel.getSelectedItem();
                if (myRecipe != null && y != myRecipe.getYeastObj()) {
                  myRecipe.setYeast(y);
                }
                String st=SBStringUtils.multiLineToolTip(40,y.getDescription());
                cmbYeast.setToolTipText(st);
              }
            }
);
          }
{
            cmbSizeUnitsModel=new ComboModel();
            cmbSizeUnits=new JComboBox();
            pnlDetails.add(cmbSizeUnits,new GridBagConstraints(2,4,2,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            cmbSizeUnits.setModel(cmbSizeUnitsModel);
            cmbSizeUnits.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                String q=(String)cmbSizeUnits.getSelectedItem();
                if (myRecipe != null && q != myRecipe.getVolUnits()) {
                  myRecipe.setVolUnits(q);
                  displayRecipe();
                }
              }
            }
);
          }
{
            lblSizeUnits=new JLabel();
            pnlDetails.add(lblSizeUnits,new GridBagConstraints(2,5,2,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            lblSizeUnits.setText(""String_Node_Str"");
          }
{
            boilTimeLable=new JLabel();
            pnlDetails.add(boilTimeLable,new GridBagConstraints(4,4,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            boilTimeLable.setText(""String_Node_Str"");
          }
{
            evapLabel=new JLabel();
            pnlDetails.add(evapLabel,new GridBagConstraints(4,5,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            evapLabel.setText(""String_Node_Str"");
          }
{
            boilMinText=new JTextField();
            pnlDetails.add(boilMinText,new GridBagConstraints(5,4,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            boilMinText.setText(""String_Node_Str"");
            boilMinText.setPreferredSize(new java.awt.Dimension(22,20));
            boilMinText.addFocusListener(this);
            boilMinText.addActionListener(this);
          }
{
            evapText=new JTextField();
            pnlDetails.add(evapText,new GridBagConstraints(5,5,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            evapText.setText(""String_Node_Str"");
            evapText.setPreferredSize(new java.awt.Dimension(23,20));
            evapText.addFocusListener(this);
            evapText.addActionListener(this);
          }
{
            alcMethodComboModel=new DefaultComboBoxModel(new String[]{""String_Node_Str"",""String_Node_Str""});
            alcMethodCombo=new JComboBox(alcMethodComboModel);
            pnlDetails.add(alcMethodCombo,new GridBagConstraints(9,0,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            alcMethodCombo.setPreferredSize(new java.awt.Dimension(58,20));
            alcMethodCombo.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                recipeSettingsActionPerformed(evt);
              }
            }
);
          }
{
            ibuMethodComboModel=new DefaultComboBoxModel(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
            ibuMethodCombo=new JComboBox(ibuMethodComboModel);
            pnlDetails.add(ibuMethodCombo,new GridBagConstraints(9,1,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            ibuMethodCombo.setPreferredSize(new java.awt.Dimension(59,20));
            ibuMethodCombo.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                recipeSettingsActionPerformed(evt);
              }
            }
);
          }
{
            colourMethodComboModel=new DefaultComboBoxModel(new String[]{""String_Node_Str"",""String_Node_Str""});
            colourMethodCombo=new JComboBox(colourMethodComboModel);
            pnlDetails.add(colourMethodCombo,new GridBagConstraints(9,2,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            colourMethodCombo.setPreferredSize(new java.awt.Dimension(44,20));
            colourMethodCombo.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                recipeSettingsActionPerformed(evt);
              }
            }
);
          }
          ComboBoxModel evapMethodComboModel=new DefaultComboBoxModel(new String[]{""String_Node_Str"",""String_Node_Str""});
          evapMethodCombo=new JComboBox();
          pnlDetails.add(evapMethodCombo,new GridBagConstraints(6,5,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
          evapMethodCombo.setModel(evapMethodComboModel);
          evapMethodCombo.setPreferredSize(new java.awt.Dimension(64,20));
          colourPanel=new JPanel();
          pnlDetails.add(colourPanel,new GridBagConstraints(8,3,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
          colourPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
          colourPanel2=new JPanel();
          pnlDetails.add(colourPanel2,new GridBagConstraints(9,3,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
          colourPanel2.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
          evapMethodCombo.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              recipeSettingsActionPerformed(evt);
            }
          }
);
        }
{
          SBNotifier sbn=new SBNotifier();
          stylePanel=new StylePanel(sbn);
          jTabbedPane1.addTab(""String_Node_Str"",null,stylePanel,null);
        }
{
          miscPanel=new MiscPanel(myRecipe);
          jTabbedPane1.addTab(""String_Node_Str"",null,miscPanel,null);
        }
{
          notesPanel=new NotesPanel();
          jTabbedPane1.addTab(""String_Node_Str"",null,notesPanel,null);
        }
{
          dilutionPanel=new DilutionPanel();
          jTabbedPane1.addTab(""String_Node_Str"",null,dilutionPanel,null);
        }
{
          SBNotifier sbn=new SBNotifier();
          settingsPanel=new SettingsPanel(sbn);
          jTabbedPane1.addTab(""String_Node_Str"",null,settingsPanel,null);
        }
{
        }
      }
{
        pnlTables=new JPanel();
        BoxLayout pnlMaltsLayout=new BoxLayout(pnlTables,javax.swing.BoxLayout.Y_AXIS);
        pnlMain.add(pnlTables,new GridBagConstraints(0,2,1,1,0.5,0.5,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
        pnlTables.setLayout(pnlMaltsLayout);
{
          pnlMalt=new JPanel();
          pnlTables.add(pnlMalt);
          BorderLayout pnlMaltLayout1=new BorderLayout();
          pnlMalt.setBorder(BorderFactory.createTitledBorder(new LineBorder(new java.awt.Color(0,0,0),1,false),""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP,new java.awt.Font(""String_Node_Str"",1,12),new java.awt.Color(51,51,51)));
          pnlMalt.setLayout(pnlMaltLayout1);
{
            jScrollPane1=new JScrollPane();
            pnlMalt.add(jScrollPane1,BorderLayout.CENTER);
{
              maltTableModel=new MaltTableModel(this);
              maltTable=new JTable(){
                public String getToolTipText(                MouseEvent e){
                  java.awt.Point p=e.getPoint();
                  int rowIndex=rowAtPoint(p);
                  return SBStringUtils.multiLineToolTip(40,maltTableModel.getDescriptionAt(rowIndex));
                }
              }
;
              jScrollPane1.setViewportView(maltTable);
              maltTable.setModel(maltTableModel);
              maltTable.getTableHeader().setReorderingAllowed(false);
              TableColumn maltColumn=maltTable.getColumnModel().getColumn(0);
              JComboBox maltComboBox=new JComboBox();
              cmbMaltModel=new ComboModel();
              maltComboBox.setModel(cmbMaltModel);
              maltColumn.setCellEditor(new DefaultCellEditor(maltComboBox));
              maltComboBox.addActionListener(new ActionListener(){
                public void actionPerformed(                ActionEvent evt){
                  Fermentable f=(Fermentable)cmbMaltModel.getSelectedItem();
                  int i=maltTable.getSelectedRow();
                  if (myRecipe != null && i != -1) {
                    Fermentable f2=myRecipe.getFermentable(i);
                    if (f2 != null) {
                      f2.setLov(f.getLov());
                      f2.setPppg(f.getPppg());
                      f2.setDescription(f.getDescription());
                      f2.setMashed(f.getMashed());
                      f2.setSteep(f.getSteep());
                    }
                  }
                }
              }
);
              JComboBox maltUnitsComboBox=new JComboBox();
              cmbMaltUnitsModel=new ComboModel();
              maltUnitsComboBox.setModel(cmbMaltUnitsModel);
              maltColumn=maltTable.getColumnModel().getColumn(2);
              maltColumn.setCellEditor(new DefaultCellEditor(maltUnitsComboBox));
              maltUnitsComboBox.addActionListener(new ActionListener(){
                public void actionPerformed(                ActionEvent evt){
                  String u=(String)cmbMaltUnitsModel.getSelectedItem();
                  int i=maltTable.getSelectedRow();
                  if (myRecipe != null && i != -1) {
                    Fermentable f2=myRecipe.getFermentable(i);
                    if (f2 != null) {
                      f2.setUnitsFull(u);
                      myRecipe.calcMaltTotals();
                      displayRecipe();
                    }
                  }
                }
              }
);
            }
          }
{
            tblMaltTotalsModel=new DefaultTableModel(new String[][]{{""String_Node_Str""}},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
            tblMaltTotals=new JTable();
            pnlMalt.add(tblMaltTotals,BorderLayout.SOUTH);
            tblMaltTotals.setModel(tblMaltTotalsModel);
            tblMaltTotals.getTableHeader().setEnabled(false);
            tblMaltTotals.setAutoCreateColumnsFromModel(false);
          }
        }
{
          pnlMaltButtons=new JPanel();
          pnlTables.add(pnlMaltButtons);
          FlowLayout pnlMaltButtonsLayout=new FlowLayout();
          pnlMaltButtonsLayout.setAlignment(FlowLayout.LEFT);
          pnlMaltButtonsLayout.setVgap(0);
          pnlMaltButtons.setLayout(pnlMaltButtonsLayout);
          pnlMaltButtons.setPreferredSize(new java.awt.Dimension(592,27));
{
            tlbMalt=new JToolBar();
            pnlMaltButtons.add(tlbMalt);
            tlbMalt.setPreferredSize(new java.awt.Dimension(55,20));
            tlbMalt.setFloatable(false);
{
              btnAddMalt=new JButton();
              tlbMalt.add(btnAddMalt);
              btnAddMalt.setText(""String_Node_Str"");
              btnAddMalt.addActionListener(new ActionListener(){
                public void actionPerformed(                ActionEvent evt){
                  if (myRecipe != null) {
                    Fermentable f=new Fermentable(myRecipe.getMaltUnits());
                    myRecipe.addMalt(f);
                    maltTable.updateUI();
                    displayRecipe();
                  }
                }
              }
);
            }
{
              btnDelMalt=new JButton();
              tlbMalt.add(btnDelMalt);
              btnDelMalt.setText(""String_Node_Str"");
              btnDelMalt.addActionListener(new ActionListener(){
                public void actionPerformed(                ActionEvent evt){
                  if (myRecipe != null) {
                    int i=maltTable.getSelectedRow();
                    myRecipe.delMalt(i);
                    maltTable.updateUI();
                    displayRecipe();
                  }
                }
              }
);
            }
          }
        }
{
          pnlHops=new JPanel();
          BorderLayout pnlHopsLayout=new BorderLayout();
          pnlHops.setBorder(BorderFactory.createTitledBorder(new LineBorder(new java.awt.Color(0,0,0),1,false),""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP,new java.awt.Font(""String_Node_Str"",1,12),new java.awt.Color(51,51,51)));
          pnlHops.setLayout(pnlHopsLayout);
          pnlTables.add(pnlHops);
{
            tblHopsTotalsModel=new DefaultTableModel(new String[][]{{""String_Node_Str""}},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
            tblHopsTotals=new JTable();
            pnlHops.add(tblHopsTotals,BorderLayout.SOUTH);
            tblHopsTotals.setModel(tblHopsTotalsModel);
            tblHopsTotals.setAutoCreateColumnsFromModel(false);
          }
{
            jScrollPane2=new JScrollPane();
            pnlHops.add(jScrollPane2,BorderLayout.CENTER);
{
              hopsTableModel=new HopsTableModel(this);
              hopsTable=new JTable(){
                public String getToolTipText(                MouseEvent e){
                  java.awt.Point p=e.getPoint();
                  int rowIndex=rowAtPoint(p);
                  return SBStringUtils.multiLineToolTip(40,hopsTableModel.getDescriptionAt(rowIndex));
                }
              }
;
              jScrollPane2.setViewportView(hopsTable);
              hopsTable.setModel(hopsTableModel);
              hopsTable.getTableHeader().setReorderingAllowed(false);
              TableColumn hopColumn=hopsTable.getColumnModel().getColumn(0);
              JComboBox hopComboBox=new JComboBox();
              cmbHopsModel=new ComboModel();
              hopComboBox.setModel(cmbHopsModel);
              hopColumn.setCellEditor(new DefaultCellEditor(hopComboBox));
              hopComboBox.addActionListener(new ActionListener(){
                public void actionPerformed(                ActionEvent evt){
                  Hop h=(Hop)cmbHopsModel.getSelectedItem();
                  int i=hopsTable.getSelectedRow();
                  if (myRecipe != null && i != -1) {
                    Hop h2=myRecipe.getHop(i);
                    h2.setAlpha(h.getAlpha());
                    h2.setDescription(h.getDescription());
                  }
                }
              }
);
              JComboBox hopsUnitsComboBox=new JComboBox();
              cmbHopsUnitsModel=new ComboModel();
              hopsUnitsComboBox.setModel(cmbHopsUnitsModel);
              hopColumn=hopsTable.getColumnModel().getColumn(4);
              hopColumn.setCellEditor(new DefaultCellEditor(hopsUnitsComboBox));
              hopsUnitsComboBox.addActionListener(new ActionListener(){
                public void actionPerformed(                ActionEvent evt){
                  String u=(String)cmbHopsUnitsModel.getSelectedItem();
                  int i=hopsTable.getSelectedRow();
                  if (myRecipe != null && i != -1) {
                    Hop h=myRecipe.getHop(i);
                    h.setUnitsFull(u);
                    myRecipe.calcHopsTotals();
                    displayRecipe();
                  }
                }
              }
);
              String[] forms={""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
              JComboBox hopsFormComboBox=new JComboBox(forms);
              hopColumn=hopsTable.getColumnModel().getColumn(1);
              hopColumn.setCellEditor(new DefaultCellEditor(hopsFormComboBox));
              String[] add={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
              JComboBox hopsAddComboBox=new JComboBox(add);
              hopColumn=hopsTable.getColumnModel().getColumn(5);
              hopColumn.setCellEditor(new DefaultCellEditor(hopsAddComboBox));
            }
          }
        }
{
          pnlHopsButtons=new JPanel();
          FlowLayout pnlHopsButtonsLayout=new FlowLayout();
          pnlHopsButtonsLayout.setAlignment(FlowLayout.LEFT);
          pnlHopsButtonsLayout.setVgap(0);
          pnlHopsButtons.setLayout(pnlHopsButtonsLayout);
          pnlTables.add(pnlHopsButtons);
          pnlHopsButtons.setPreferredSize(new java.awt.Dimension(512,16));
{
            tlbHops=new JToolBar();
            pnlHopsButtons.add(tlbHops);
            tlbHops.setPreferredSize(new java.awt.Dimension(58,19));
            tlbHops.setFloatable(false);
{
              btnAddHop=new JButton();
              tlbHops.add(btnAddHop);
              btnAddHop.setText(""String_Node_Str"");
              btnAddHop.addActionListener(new ActionListener(){
                public void actionPerformed(                ActionEvent evt){
                  if (myRecipe != null) {
                    Hop h=new Hop(myRecipe.getHopUnits());
                    myRecipe.addHop(h);
                    hopsTable.updateUI();
                    displayRecipe();
                  }
                }
              }
);
            }
{
              btnDelHop=new JButton();
              tlbHops.add(btnDelHop);
              btnDelHop.setText(""String_Node_Str"");
              btnDelHop.addActionListener(new ActionListener(){
                public void actionPerformed(                ActionEvent evt){
                  if (myRecipe != null) {
                    int i=hopsTable.getSelectedRow();
                    myRecipe.delHop(i);
                    hopsTable.updateUI();
                    displayRecipe();
                  }
                }
              }
);
            }
          }
        }
      }
{
        statusPanel=new JPanel();
        FlowLayout statusPanelLayout=new FlowLayout();
        statusPanelLayout.setAlignment(FlowLayout.LEFT);
        statusPanelLayout.setHgap(2);
        statusPanelLayout.setVgap(2);
        statusPanel.setLayout(statusPanelLayout);
        pnlMain.add(statusPanel,new GridBagConstraints(0,3,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
{
          fileNamePanel=new JPanel();
          statusPanel.add(fileNamePanel);
          fileNamePanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
{
            fileNameLabel=new JLabel();
            fileNamePanel.add(fileNameLabel);
            fileNameLabel.setText(""String_Node_Str"");
            fileNameLabel.setFont(new java.awt.Font(""String_Node_Str"",1,10));
          }
        }
{
          ibuMethodPanel=new JPanel();
          statusPanel.add(ibuMethodPanel);
          ibuMethodPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
{
            ibuMethodLabel=new JLabel();
            ibuMethodPanel.add(ibuMethodLabel);
            ibuMethodLabel.setText(""String_Node_Str"");
            ibuMethodLabel.setFont(new java.awt.Font(""String_Node_Str"",1,10));
          }
        }
{
          alcMethodPanel=new JPanel();
          statusPanel.add(alcMethodPanel);
          alcMethodPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));
{
            alcMethodLabel=new JLabel();
            alcMethodPanel.add(alcMethodLabel);
            alcMethodLabel.setText(""String_Node_Str"");
            alcMethodLabel.setFont(new java.awt.Font(""String_Node_Str"",1,10));
          }
        }
      }
    }
{
      jMenuBar1=new JMenuBar();
      setJMenuBar(jMenuBar1);
{
        fileMenu=new JMenu();
        jMenuBar1.add(fileMenu);
        fileMenu.setText(""String_Node_Str"");
{
          newFileMenuItem=new JMenuItem();
          fileMenu.add(newFileMenuItem);
          newFileMenuItem.setText(""String_Node_Str"");
          newFileMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              myRecipe=new Recipe();
              currentFile=null;
              attachRecipeData();
              displayRecipe();
            }
          }
);
        }
{
          openFileMenuItem=new JMenuItem();
          fileMenu.add(openFileMenuItem);
          openFileMenuItem.setText(""String_Node_Str"");
          openFileMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              String[] ext={""String_Node_Str"",""String_Node_Str""};
              String desc=""String_Node_Str"";
              sbFileFilter saveFileFilter=new sbFileFilter(ext,desc);
              fileChooser.setFileFilter(saveFileFilter);
              int returnVal=fileChooser.showOpenDialog(jMenuBar1);
              if (returnVal == JFileChooser.APPROVE_OPTION) {
                File file=fileChooser.getSelectedFile();
                Debug.print(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
                ImportXml imp=new ImportXml(file.toString());
                myRecipe=imp.handler.getRecipe();
                myRecipe.calcMaltTotals();
                myRecipe.calcHopsTotals();
                myRecipe.mash.calcMashSchedule();
                attachRecipeData();
                currentFile=file;
                displayRecipe();
              }
 else {
                Debug.print(""String_Node_Str"");
              }
            }
          }
);
        }
{
          findFileMenuItem=new JMenuItem();
          findFileMenuItem.setText(""String_Node_Str"");
          fileMenu.add(findFileMenuItem);
          final JFrame owner=this;
          findFileMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              FindDialog fd=new FindDialog(owner);
              fd.setVisible(true);
            }
          }
);
        }
{
          saveMenuItem=new JMenuItem();
          fileMenu.add(saveMenuItem);
          saveMenuItem.setText(""String_Node_Str"");
          saveMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              int choice=1;
              if (currentFile != null) {
                File file=currentFile;
                try {
                  FileWriter out=new FileWriter(file);
                  out.write(myRecipe.toXML());
                  out.close();
                  Debug.print(""String_Node_Str"" + file.getAbsoluteFile());
                  currentFile=file;
                }
 catch (                Exception e) {
                  showError(e);
                }
              }
 else {
                choice=JOptionPane.showConfirmDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION);
              }
              if (choice == 0) {
                saveAs();
              }
            }
          }
);
        }
{
          saveAsMenuItem=new JMenuItem();
          fileMenu.add(saveAsMenuItem);
          saveAsMenuItem.setText(""String_Node_Str"");
          saveAsMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              Debug.print(myRecipe.toXML());
              saveAs();
            }
          }
);
        }
{
          exportMenu=new JMenu();
          fileMenu.add(exportMenu);
          exportMenu.setText(""String_Node_Str"");
{
            exportHTMLmenu=new JMenuItem();
            exportMenu.add(exportHTMLmenu);
            exportHTMLmenu.setText(""String_Node_Str"");
            exportHTMLmenu.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                String[] ext={""String_Node_Str"",""String_Node_Str""};
                sbFileFilter saveFileFilter=new sbFileFilter(ext,""String_Node_Str"");
                fileChooser.setFileFilter(saveFileFilter);
                fileChooser.setSelectedFile(new File(myRecipe.getName() + ""String_Node_Str""));
                int returnVal=fileChooser.showSaveDialog(jMenuBar1);
                if (returnVal == JFileChooser.APPROVE_OPTION) {
                  File file=fileChooser.getSelectedFile();
                  try {
                    saveAsHTML(file);
                  }
 catch (                  Exception e) {
                    showError(e);
                  }
                }
 else {
                  Debug.print(""String_Node_Str"");
                }
              }
            }
);
            exportTextMenuItem=new JMenuItem();
            exportMenu.add(exportTextMenuItem);
            exportTextMenuItem.setText(""String_Node_Str"");
            exportTextMenuItem.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                String[] ext={""String_Node_Str""};
                sbFileFilter saveFileFilter=new sbFileFilter(ext,""String_Node_Str"");
                fileChooser.setFileFilter(saveFileFilter);
                fileChooser.setSelectedFile(new File(myRecipe.getName() + ""String_Node_Str""));
                int returnVal=fileChooser.showSaveDialog(jMenuBar1);
                if (returnVal == JFileChooser.APPROVE_OPTION) {
                  File file=fileChooser.getSelectedFile();
                  try {
                    FileWriter out=new FileWriter(file);
                    out.write(myRecipe.toText());
                    out.close();
                  }
 catch (                  Exception e) {
                    showError(e);
                  }
                }
 else {
                  Debug.print(""String_Node_Str"");
                }
              }
            }
);
          }
        }
{
          jSeparator2=new JSeparator();
          fileMenu.add(jSeparator2);
        }
{
          exitMenuItem=new JMenuItem();
          fileMenu.add(exitMenuItem);
          exitMenuItem.setText(""String_Node_Str"");
          exitMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              System.exit(0);
            }
          }
);
        }
      }
{
        jMenu4=new JMenu();
        jMenuBar1.add(jMenu4);
        jMenu4.setText(""String_Node_Str"");
{
          final JFrame owner=this;
          editPrefsMenuItem=new JMenuItem();
          jMenu4.add(editPrefsMenuItem);
          editPrefsMenuItem.setText(""String_Node_Str"");
          editPrefsMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              PreferencesDialog d=new PreferencesDialog(owner,preferences);
              d.setVisible(true);
            }
          }
);
        }
{
          jSeparator1=new JSeparator();
          jMenu4.add(jSeparator1);
        }
{
          deleteMenuItem=new JMenuItem();
          jMenu4.add(deleteMenuItem);
          deleteMenuItem.setText(""String_Node_Str"");
          deleteMenuItem.setEnabled(false);
        }
      }
{
        mnuTools=new JMenu();
        jMenuBar1.add(mnuTools);
        mnuTools.setText(""String_Node_Str"");
{
          mashManagerMenuItem=new JMenuItem();
          mnuTools.add(mashManagerMenuItem);
          mashManagerMenuItem.setText(""String_Node_Str"");
          mashManagerMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              mashMgr=new MashManager(myRecipe);
              mashMgr.setVisible(true);
            }
          }
);
          JMenuItem maltPercentMenuItem=new JMenuItem();
          mnuTools.add(maltPercentMenuItem);
          maltPercentMenuItem.setText(""String_Node_Str"");
          final JFrame owner=this;
          maltPercentMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              MaltPercentDialog maltPercent=new MaltPercentDialog(owner);
              maltPercent.setVisible(true);
            }
          }
);
        }
      }
{
        jMenu5=new JMenu();
        jMenuBar1.add(jMenu5);
        jMenu5.setText(""String_Node_Str"");
{
          helpMenuItem=new JMenuItem();
          jMenu5.add(helpMenuItem);
          helpMenuItem.setText(""String_Node_Str"");
        }
{
          aboutMenuItem=new JMenuItem();
          jMenu5.add(aboutMenuItem);
          aboutMenuItem.setText(""String_Node_Str"");
          final JFrame owner=this;
          aboutMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              aboutDlg=new AboutDialog(owner,version);
              aboutDlg.setVisible(true);
            }
          }
);
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
50564,"public void windowClosed(WindowEvent evt){
  System.exit(1);
}","public void windowClosed(WindowEvent e){
}"
50565,"/** 
 * At the end of each element, we should check if we're looking at a list. If we are, set the list to null. This way, we can tell if we're looking at an element that has (stupidly) the same unit as a list... eg <MASH>is in the recipe (indicating whether it's mashed or not), and the unit of the mash list!
 */
public void endElement(String namespaceURI,String sName,String qName) throws SAXException {
  if (importType == ""String_Node_Str"") {
    if (qName.equalsIgnoreCase(""String_Node_Str"") && currentList.equalsIgnoreCase(""String_Node_Str"")) {
      r.addMalt(m);
      m=null;
    }
 else     if (qName.equalsIgnoreCase(""String_Node_Str"") && currentList.equalsIgnoreCase(""String_Node_Str"")) {
      h.setDescription(descrBuf);
      descrBuf=""String_Node_Str"";
      r.addHop(h);
      h=null;
    }
 else     if (qName.equalsIgnoreCase(""String_Node_Str"") && currentList.equalsIgnoreCase(""String_Node_Str"")) {
      misc.setDescription(descrBuf);
      descrBuf=""String_Node_Str"";
      r.addMisc(misc);
      misc=null;
    }
 else     if (qName.equalsIgnoreCase(""String_Node_Str"") && currentList.equalsIgnoreCase(""String_Node_Str"")) {
      r.addNote(note);
      note=null;
    }
 else     if (qName.equalsIgnoreCase(""String_Node_Str"") && currentList.equalsIgnoreCase(""String_Node_Str"")) {
      r.mash.addStep(type,startTemp,endTemp,""String_Node_Str"",method,minutes,rampMin);
    }
 else     if (qName.equalsIgnoreCase(""String_Node_Str"") || qName.equalsIgnoreCase(""String_Node_Str"") || qName.equalsIgnoreCase(""String_Node_Str"")|| qName.equalsIgnoreCase(""String_Node_Str"")|| qName.equalsIgnoreCase(""String_Node_Str"")) {
      currentList=""String_Node_Str"";
    }
  }
 else   if (importType == ""String_Node_Str"") {
    if (qName.equalsIgnoreCase(""String_Node_Str"")) {
      r.addMalt(m);
      m=null;
    }
 else     if (qName.equalsIgnoreCase(""String_Node_Str"")) {
      r.addHop(h);
      h=null;
    }
 else     if (qName.equalsIgnoreCase(""String_Node_Str"")) {
      r.setName(buffer);
      buffer=""String_Node_Str"";
    }
  }
}","/** 
 * At the end of each element, we should check if we're looking at a list. If we are, set the list to null. This way, we can tell if we're looking at an element that has (stupidly) the same unit as a list... eg <MASH>is in the recipe (indicating whether it's mashed or not), and the unit of the mash list!
 */
public void endElement(String namespaceURI,String sName,String qName) throws SAXException {
  if (importType == ""String_Node_Str"") {
    if (qName.equalsIgnoreCase(""String_Node_Str"") && currentList.equalsIgnoreCase(""String_Node_Str"")) {
      r.addMalt(m);
      m=null;
    }
 else     if (qName.equalsIgnoreCase(""String_Node_Str"") && currentList.equalsIgnoreCase(""String_Node_Str"")) {
      h.setDescription(descrBuf);
      descrBuf=""String_Node_Str"";
      r.addHop(h);
      h=null;
    }
 else     if (qName.equalsIgnoreCase(""String_Node_Str"") && currentList.equalsIgnoreCase(""String_Node_Str"")) {
      misc.setDescription(descrBuf);
      descrBuf=""String_Node_Str"";
      r.addMisc(misc);
      misc=null;
    }
 else     if (qName.equalsIgnoreCase(""String_Node_Str"") && currentList.equalsIgnoreCase(""String_Node_Str"")) {
      r.addNote(note);
      note=null;
    }
 else     if (qName.equalsIgnoreCase(""String_Node_Str"") && currentList.equalsIgnoreCase(""String_Node_Str"")) {
      r.mash.addStep(type,startTemp,endTemp,""String_Node_Str"",method,minutes,rampMin);
    }
 else     if (qName.equalsIgnoreCase(""String_Node_Str"") || qName.equalsIgnoreCase(""String_Node_Str"") || qName.equalsIgnoreCase(""String_Node_Str"")|| qName.equalsIgnoreCase(""String_Node_Str"")|| (qName.equalsIgnoreCase(""String_Node_Str"") && !currentList.equalsIgnoreCase(""String_Node_Str""))) {
      currentList=""String_Node_Str"";
    }
  }
 else   if (importType == ""String_Node_Str"") {
    if (qName.equalsIgnoreCase(""String_Node_Str"")) {
      r.addMalt(m);
      m=null;
    }
 else     if (qName.equalsIgnoreCase(""String_Node_Str"")) {
      r.addHop(h);
      h=null;
    }
 else     if (qName.equalsIgnoreCase(""String_Node_Str"")) {
      r.setName(buffer);
      buffer=""String_Node_Str"";
    }
  }
}"
50566,"/** 
 * Start of an element handler when we know this is a StrangeBrew recipe
 * @param eName
 */
void sbStartElement(String eName){
  if (eName.equalsIgnoreCase(""String_Node_Str"")) {
    currentList=""String_Node_Str"";
  }
 else   if (eName.equalsIgnoreCase(""String_Node_Str"")) {
    currentList=""String_Node_Str"";
  }
 else   if (eName.equalsIgnoreCase(""String_Node_Str"")) {
    currentList=""String_Node_Str"";
  }
 else   if (eName.equalsIgnoreCase(""String_Node_Str"") && currentList.equals(""String_Node_Str"")) {
    currentList=""String_Node_Str"";
  }
 else   if (eName.equalsIgnoreCase(""String_Node_Str"")) {
    currentList=""String_Node_Str"";
  }
 else   if (eName.equalsIgnoreCase(""String_Node_Str"")) {
    currentList=""String_Node_Str"";
  }
 else   if (eName.equalsIgnoreCase(""String_Node_Str"")) {
    if (currentList.equals(""String_Node_Str"")) {
      m=new Fermentable();
    }
 else     if (currentList.equals(""String_Node_Str"")) {
      h=new Hop();
    }
 else     if (currentList.equals(""String_Node_Str"")) {
      misc=new Misc();
    }
 else     if (currentList.equals(""String_Node_Str"")) {
      note=new Note();
    }
  }
}","/** 
 * Start of an element handler when we know this is a StrangeBrew recipe
 * @param eName
 */
void sbStartElement(String eName){
  if (eName.equalsIgnoreCase(""String_Node_Str"")) {
    currentList=""String_Node_Str"";
  }
 else   if (eName.equalsIgnoreCase(""String_Node_Str"")) {
    currentList=""String_Node_Str"";
  }
 else   if (eName.equalsIgnoreCase(""String_Node_Str"")) {
    currentList=""String_Node_Str"";
  }
 else   if (eName.equalsIgnoreCase(""String_Node_Str"") && currentList.equals(""String_Node_Str"")) {
    currentList=""String_Node_Str"";
  }
 else   if (eName.equalsIgnoreCase(""String_Node_Str"")) {
    currentList=""String_Node_Str"";
  }
 else   if (eName.equalsIgnoreCase(""String_Node_Str"") && !currentList.equals(""String_Node_Str"")) {
    currentList=""String_Node_Str"";
  }
 else   if (eName.equalsIgnoreCase(""String_Node_Str"")) {
    if (currentList.equals(""String_Node_Str"")) {
      m=new Fermentable();
    }
 else     if (currentList.equals(""String_Node_Str"")) {
      h=new Hop();
    }
 else     if (currentList.equals(""String_Node_Str"")) {
      misc=new Misc();
    }
 else     if (currentList.equals(""String_Node_Str"")) {
      note=new Note();
    }
  }
}"
50567,"/** 
 * At the end of each element, we should check if we're looking at a list. If we are, set the list to null. This way, we can tell if we're looking at an element that has (stupidly) the same unit as a list... eg <MASH>is in the recipe (indicating whether it's mashed or not), and the unit of the mash list!
 */
public void endElement(String namespaceURI,String sName,String qName) throws SAXException {
  if (importType == ""String_Node_Str"") {
    if (qName.equalsIgnoreCase(""String_Node_Str"") && currentList.equalsIgnoreCase(""String_Node_Str"")) {
      r.addMalt(m);
      m=null;
    }
 else     if (qName.equalsIgnoreCase(""String_Node_Str"") && currentList.equalsIgnoreCase(""String_Node_Str"")) {
      r.addHop(h);
      h=null;
    }
 else     if (qName.equalsIgnoreCase(""String_Node_Str"") && currentList.equalsIgnoreCase(""String_Node_Str"")) {
      r.addMisc(misc);
      misc=null;
    }
 else     if (qName.equalsIgnoreCase(""String_Node_Str"") && currentList.equalsIgnoreCase(""String_Node_Str"")) {
      r.mash.addStep(type,startTemp,endTemp,""String_Node_Str"",method,minutes,rampMin);
    }
 else     if (qName.equalsIgnoreCase(""String_Node_Str"") || qName.equalsIgnoreCase(""String_Node_Str"") || qName.equalsIgnoreCase(""String_Node_Str"")|| qName.equalsIgnoreCase(""String_Node_Str"")) {
      currentList=""String_Node_Str"";
    }
  }
 else   if (importType == ""String_Node_Str"") {
    if (qName.equalsIgnoreCase(""String_Node_Str"")) {
      r.addMalt(m);
      m=null;
    }
 else     if (qName.equalsIgnoreCase(""String_Node_Str"")) {
      r.addHop(h);
      h=null;
    }
  }
}","/** 
 * At the end of each element, we should check if we're looking at a list. If we are, set the list to null. This way, we can tell if we're looking at an element that has (stupidly) the same unit as a list... eg <MASH>is in the recipe (indicating whether it's mashed or not), and the unit of the mash list!
 */
public void endElement(String namespaceURI,String sName,String qName) throws SAXException {
  if (importType == ""String_Node_Str"") {
    if (qName.equalsIgnoreCase(""String_Node_Str"") && currentList.equalsIgnoreCase(""String_Node_Str"")) {
      r.addMalt(m);
      m=null;
    }
 else     if (qName.equalsIgnoreCase(""String_Node_Str"") && currentList.equalsIgnoreCase(""String_Node_Str"")) {
      h.setDescription(descrBuf);
      descrBuf=""String_Node_Str"";
      r.addHop(h);
      h=null;
    }
 else     if (qName.equalsIgnoreCase(""String_Node_Str"") && currentList.equalsIgnoreCase(""String_Node_Str"")) {
      r.addMisc(misc);
      misc=null;
    }
 else     if (qName.equalsIgnoreCase(""String_Node_Str"") && currentList.equalsIgnoreCase(""String_Node_Str"")) {
      r.mash.addStep(type,startTemp,endTemp,""String_Node_Str"",method,minutes,rampMin);
    }
 else     if (qName.equalsIgnoreCase(""String_Node_Str"") || qName.equalsIgnoreCase(""String_Node_Str"") || qName.equalsIgnoreCase(""String_Node_Str"")|| qName.equalsIgnoreCase(""String_Node_Str"")) {
      currentList=""String_Node_Str"";
    }
  }
 else   if (importType == ""String_Node_Str"") {
    if (qName.equalsIgnoreCase(""String_Node_Str"")) {
      r.addMalt(m);
      m=null;
    }
 else     if (qName.equalsIgnoreCase(""String_Node_Str"")) {
      r.addHop(h);
      h=null;
    }
  }
}"
50568,"void sbCharacters(String s){
  if (currentList.equals(""String_Node_Str"")) {
    if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      m.setName(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      m.setAmount(Double.parseDouble(s));
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      m.setPppg(Double.parseDouble(s));
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      m.setCost(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      m.setUnits(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      m.setLov(Double.parseDouble(s));
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      m.setDescription(s);
    }
  }
 else   if (currentList.equalsIgnoreCase(""String_Node_Str"")) {
    if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      h.setName(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      h.setAmount(Double.parseDouble(s));
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      h.setAlpha(Double.parseDouble(s));
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      h.setUnits(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      h.setType(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      h.setCost(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      h.setAdd(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      h.setDescription(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      h.setMinutes(Integer.parseInt(s));
    }
  }
 else   if (currentList.equalsIgnoreCase(""String_Node_Str"")) {
    if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      misc.setName(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      misc.setAmount(Double.parseDouble(s));
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      misc.setUnits(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      misc.setComments(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      h.setAdd(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      misc.setDescription(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      misc.setTime(Integer.parseInt(s));
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      misc.setStage(s);
    }
  }
 else   if (currentList.equalsIgnoreCase(""String_Node_Str"")) {
    if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      type=s;
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      startTemp=Double.parseDouble(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      method=s;
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      minutes=Integer.parseInt(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      endTemp=Double.parseDouble(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      rampMin=Integer.parseInt(s);
    }
  }
 else   if (currentList.equalsIgnoreCase(""String_Node_Str"")) {
    if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setName(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setEfficiency(Double.parseDouble(s));
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setAttenuation(Double.parseDouble(s));
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setPreBoil(Double.parseDouble(s));
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setPostBoil(Double.parseDouble(s));
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setPreBoilVolUnits(s);
      r.setPostBoilVolUnits(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setStyle(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setBoilMinutes(Integer.parseInt(s));
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setHopsUnits(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setMaltUnits(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setMashRatio(Double.parseDouble(s));
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setMashRatioU(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setBrewer(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setMashed(Boolean.valueOf(s).booleanValue());
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setYeastName(s);
    }
  }
 else   s=""String_Node_Str"";
}","void sbCharacters(String s){
  if (currentList.equals(""String_Node_Str"")) {
    if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      m.setName(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      m.setAmount(Double.parseDouble(s));
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      m.setPppg(Double.parseDouble(s));
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      m.setCost(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      m.setUnits(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      m.setLov(Double.parseDouble(s));
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      m.setDescription(s);
    }
  }
 else   if (currentList.equalsIgnoreCase(""String_Node_Str"")) {
    if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      h.setName(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      h.setAmount(Double.parseDouble(s));
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      h.setAlpha(Double.parseDouble(s));
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      h.setUnits(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      h.setType(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      h.setCost(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      h.setAdd(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      descrBuf=descrBuf + s;
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      h.setMinutes(Integer.parseInt(s));
    }
  }
 else   if (currentList.equalsIgnoreCase(""String_Node_Str"")) {
    if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      misc.setName(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      misc.setAmount(Double.parseDouble(s));
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      misc.setUnits(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      misc.setComments(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      h.setAdd(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      misc.setDescription(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      misc.setTime(Integer.parseInt(s));
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      misc.setStage(s);
    }
  }
 else   if (currentList.equalsIgnoreCase(""String_Node_Str"")) {
    if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      type=s;
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      startTemp=Double.parseDouble(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      method=s;
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      minutes=Integer.parseInt(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      endTemp=Double.parseDouble(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      rampMin=Integer.parseInt(s);
    }
  }
 else   if (currentList.equalsIgnoreCase(""String_Node_Str"")) {
    if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setName(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setEfficiency(Double.parseDouble(s));
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setAttenuation(Double.parseDouble(s));
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setPreBoil(Double.parseDouble(s));
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setPostBoil(Double.parseDouble(s));
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setPreBoilVolUnits(s);
      r.setPostBoilVolUnits(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setStyle(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setBoilMinutes(Integer.parseInt(s));
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setHopsUnits(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setMaltUnits(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setMashRatio(Double.parseDouble(s));
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setMashRatioU(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setBrewer(s);
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setMashed(Boolean.valueOf(s).booleanValue());
    }
 else     if (currentElement.equalsIgnoreCase(""String_Node_Str"")) {
      r.setYeastName(s);
    }
  }
 else   s=""String_Node_Str"";
}"
50569,"public void displayRecipe(){
  if (myRecipe == null)   return;
  txtName.setText(myRecipe.getName());
  txtBrewer.setText(myRecipe.getBrewer());
  cmbStyleModel.addOrInsert(myRecipe.getStyleObj());
  cmbYeastModel.addOrInsert(myRecipe.getYeastObj());
  txtPreBoil.setValue(new Double(myRecipe.getPreBoilVol(myRecipe.getVolUnits())));
  txtPostBoil.setValue(new Double(myRecipe.getPostBoilVol(myRecipe.getVolUnits())));
  spnEffic.setValue(new Double(myRecipe.getEfficiency()));
  spnAtten.setValue(new Double(myRecipe.getAttenuation()));
  spnOG.setValue(new Double(myRecipe.getEstOg()));
  spnFG.setValue(new Double(myRecipe.getEstFg()));
  txtComments.setText(myRecipe.getComments());
  lblIBUvalue.setText(df1.format(myRecipe.getIbu()));
  lblColourValue.setText(df1.format(myRecipe.getSrm()));
  lblAlcValue.setText(df1.format(myRecipe.getAlcohol()));
  tblMaltModel.setData(myRecipe.getFermentablesList());
  tblHopsModel.setData(myRecipe.getHopsList());
  tblMaltTotalsModel.setDataVector(new String[][]{{""String_Node_Str"",""String_Node_Str"" + df1.format(myRecipe.getTotalMaltLbs()),myRecipe.getMaltUnits(),""String_Node_Str"" + df3.format(myRecipe.getEstOg()),""String_Node_Str"" + df1.format(myRecipe.getSrm()),""String_Node_Str"" + df2.format(myRecipe.getTotalMaltCost()),""String_Node_Str""}},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  tblHopsTotalsModel.setDataVector(new String[][]{{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + df1.format(myRecipe.getTotalHopsOz()),myRecipe.getHopUnits(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + df1.format(myRecipe.getIbu()),""String_Node_Str"" + df2.format(myRecipe.getTotalHopsCost())}},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
}","public void displayRecipe(){
  if (myRecipe == null)   return;
  txtName.setText(myRecipe.getName());
  txtBrewer.setText(myRecipe.getBrewer());
  cmbStyleModel.addOrInsert(myRecipe.getStyleObj());
  cmbYeastModel.addOrInsert(myRecipe.getYeastObj());
  txtPreBoil.setValue(new Double(myRecipe.getPreBoilVol(myRecipe.getVolUnits())));
  txtPostBoil.setValue(new Double(myRecipe.getPostBoilVol(myRecipe.getVolUnits())));
  spnEffic.setValue(new Double(myRecipe.getEfficiency()));
  spnAtten.setValue(new Double(myRecipe.getAttenuation()));
  spnOG.setValue(new Double(myRecipe.getEstOg()));
  spnFG.setValue(new Double(myRecipe.getEstFg()));
  txtComments.setText(myRecipe.getComments());
  lblIBUvalue.setText(df1.format(myRecipe.getIbu()));
  lblColourValue.setText(df1.format(myRecipe.getSrm()));
  lblAlcValue.setText(df1.format(myRecipe.getAlcohol()));
  tblMaltModel.setData(myRecipe.getFermentablesList());
  tblHopsModel.setData(myRecipe.getHopsList());
  tblMaltTotalsModel.setDataVector(new String[][]{{""String_Node_Str"",""String_Node_Str"" + df1.format(myRecipe.getTotalMaltLbs()),myRecipe.getMaltUnits(),""String_Node_Str"" + df3.format(myRecipe.getEstOg()),""String_Node_Str"" + df1.format(myRecipe.getSrm()),""String_Node_Str"" + df2.format(myRecipe.getTotalMaltCost()),""String_Node_Str""}},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  tblHopsTotalsModel.setDataVector(new String[][]{{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + df1.format(myRecipe.getTotalHopsOz()),myRecipe.getHopUnits(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + df1.format(myRecipe.getIbu()),""String_Node_Str"" + df2.format(myRecipe.getTotalHopsCost())}},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  tblMalt.updateUI();
  tblHops.updateUI();
}"
50570,"private void initGUI(){
  try {
    this.setSize(520,532);
    this.addWindowListener(new WindowAdapter(){
      public void windowClosed(      WindowEvent evt){
        System.exit(1);
      }
    }
);
{
      pnlMain=new JPanel();
      GridBagLayout jPanel2Layout=new GridBagLayout();
      jPanel2Layout.columnWeights=new double[]{0.1};
      jPanel2Layout.columnWidths=new int[]{7};
      jPanel2Layout.rowWeights=new double[]{0.1,0.1,0.1};
      jPanel2Layout.rowHeights=new int[]{7,7,7};
      pnlMain.setLayout(jPanel2Layout);
      this.getContentPane().add(pnlMain,BorderLayout.CENTER);
{
        jPanel1=new JPanel();
        pnlMain.add(jPanel1,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
        FlowLayout jPanel1Layout=new FlowLayout();
        jPanel1Layout.setAlignment(FlowLayout.LEFT);
        jPanel1.setLayout(jPanel1Layout);
{
          lblName=new JLabel();
          jPanel1.add(lblName);
          lblName.setText(""String_Node_Str"");
        }
{
          txtName=new JTextField();
          jPanel1.add(txtName);
          txtName.setText(""String_Node_Str"");
          txtName.setPreferredSize(new java.awt.Dimension(179,20));
          txtName.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              myRecipe.setName(txtName.getText());
            }
          }
);
        }
      }
{
        jTabbedPane1=new JTabbedPane();
        pnlMain.add(jTabbedPane1,new GridBagConstraints(0,1,1,1,0.1,0.1,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
{
          pnlDetails=new JPanel();
          GridBagLayout pnlDetailsLayout=new GridBagLayout();
          pnlDetailsLayout.columnWeights=new double[]{0.1,0.1,0.1,0.1,0.1,0.1,0.1};
          pnlDetailsLayout.columnWidths=new int[]{7,7,7,7,7,7,7};
          pnlDetailsLayout.rowWeights=new double[]{0.1,0.1,0.1,0.1,0.1,0.1,0.1};
          pnlDetailsLayout.rowHeights=new int[]{7,7,7,7,7,7,7};
          pnlDetails.setLayout(pnlDetailsLayout);
          jTabbedPane1.addTab(""String_Node_Str"",null,pnlDetails,null);
{
            lblBrewer=new JLabel();
            pnlDetails.add(lblBrewer,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblBrewer.setText(""String_Node_Str"");
          }
{
            txtBrewer=new JTextField();
            pnlDetails.add(txtBrewer,new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            txtBrewer.setText(""String_Node_Str"");
            txtBrewer.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                myRecipe.setBrewer(txtBrewer.getText());
              }
            }
);
          }
{
            lblDate=new JLabel();
            pnlDetails.add(lblDate,new GridBagConstraints(0,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblDate.setText(""String_Node_Str"");
          }
{
            lblStyle=new JLabel();
            pnlDetails.add(lblStyle,new GridBagConstraints(0,2,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblStyle.setText(""String_Node_Str"");
          }
{
            lblYeast=new JLabel();
            pnlDetails.add(lblYeast,new GridBagConstraints(0,3,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblYeast.setText(""String_Node_Str"");
          }
{
            lblPreBoil=new JLabel();
            pnlDetails.add(lblPreBoil,new GridBagConstraints(0,4,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblPreBoil.setText(""String_Node_Str"");
          }
{
            lblPostBoil=new JLabel();
            pnlDetails.add(lblPostBoil,new GridBagConstraints(0,5,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblPostBoil.setText(""String_Node_Str"");
          }
{
            lblMash=new JLabel();
            pnlDetails.add(lblMash,new GridBagConstraints(0,6,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblMash.setText(""String_Node_Str"");
          }
{
            lblEffic=new JLabel();
            pnlDetails.add(lblEffic,new GridBagConstraints(3,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblEffic.setText(""String_Node_Str"");
          }
{
            lblAtten=new JLabel();
            pnlDetails.add(lblAtten,new GridBagConstraints(3,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblAtten.setText(""String_Node_Str"");
          }
{
            lblOG=new JLabel();
            pnlDetails.add(lblOG,new GridBagConstraints(3,2,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblOG.setText(""String_Node_Str"");
          }
{
            lblFG=new JLabel();
            pnlDetails.add(lblFG,new GridBagConstraints(3,3,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblFG.setText(""String_Node_Str"");
          }
{
            lblIBU=new JLabel();
            pnlDetails.add(lblIBU,new GridBagConstraints(5,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblIBU.setText(""String_Node_Str"");
          }
{
            lblAlc=new JLabel();
            pnlDetails.add(lblAlc,new GridBagConstraints(5,2,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblAlc.setText(""String_Node_Str"");
          }
{
            lblColour=new JLabel();
            pnlDetails.add(lblColour,new GridBagConstraints(5,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblColour.setText(""String_Node_Str"");
          }
{
            txtDate=new JTextField();
            pnlDetails.add(txtDate,new GridBagConstraints(1,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            txtDate.setText(""String_Node_Str"");
          }
{
            cmbStyleModel=new ComboModel();
            cmbStyle=new JComboBox();
            pnlDetails.add(cmbStyle,new GridBagConstraints(1,2,2,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            cmbStyle.setModel(cmbStyleModel);
            cmbStyle.setMaximumSize(new java.awt.Dimension(100,32767));
            cmbStyle.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                Style s=(Style)cmbStyleModel.getSelectedItem();
                if (myRecipe != null && s != myRecipe.getStyleObj()) {
                  myRecipe.setStyle(s);
                }
              }
            }
);
          }
{
            txtPreBoil=new JFormattedTextField();
            pnlDetails.add(txtPreBoil,new GridBagConstraints(1,4,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            txtPreBoil.setText(""String_Node_Str"");
            txtPreBoil.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                myRecipe.setPreBoil(Double.parseDouble(txtPreBoil.getText().toString()));
                displayRecipe();
              }
            }
);
          }
{
            txtPostBoil=new JFormattedTextField();
            pnlDetails.add(txtPostBoil,new GridBagConstraints(1,5,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            txtPostBoil.setText(""String_Node_Str"");
            txtPostBoil.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                System.out.println(""String_Node_Str"" + evt);
                myRecipe.setPostBoil(Double.parseDouble(txtPostBoil.getText().toString()));
                displayRecipe();
              }
            }
);
          }
{
            lblComments=new JLabel();
            pnlDetails.add(lblComments,new GridBagConstraints(3,4,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblComments.setText(""String_Node_Str"");
          }
{
            SpinnerNumberModel spnEfficModel=new SpinnerNumberModel(75.0,0.0,100.0,1.0);
            spnEffic=new JSpinner();
            pnlDetails.add(spnEffic,new GridBagConstraints(4,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            spnEffic.setModel(spnEfficModel);
            spnEffic.setMaximumSize(new java.awt.Dimension(70,32767));
            spnEffic.addChangeListener(new ChangeListener(){
              public void stateChanged(              ChangeEvent evt){
                myRecipe.setEfficiency(Double.parseDouble(spnEffic.getValue().toString()));
                displayRecipe();
              }
            }
);
            spnEffic.setEditor(new JSpinner.NumberEditor(spnEffic,""String_Node_Str""));
          }
{
            SpinnerNumberModel spnAttenModel=new SpinnerNumberModel(75.0,0.0,100.0,1.0);
            spnAtten=new JSpinner();
            pnlDetails.add(spnAtten,new GridBagConstraints(4,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            spnAtten.setModel(spnAttenModel);
            spnAtten.addChangeListener(new ChangeListener(){
              public void stateChanged(              ChangeEvent evt){
                myRecipe.setAttenuation(Double.parseDouble(spnAtten.getValue().toString()));
                displayRecipe();
              }
            }
);
            spnAtten.setEditor(new JSpinner.NumberEditor(spnAtten,""String_Node_Str""));
          }
{
            SpinnerNumberModel spnOgModel=new SpinnerNumberModel(1.000,0.900,2.000,0.001);
            spnOG=new JSpinner();
            pnlDetails.add(spnOG,new GridBagConstraints(4,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            spnOG.setModel(spnOgModel);
            spnOG.addChangeListener(new ChangeListener(){
              public void stateChanged(              ChangeEvent evt){
                myRecipe.setEstOg(Double.parseDouble(spnOG.getValue().toString()));
                displayRecipe();
              }
            }
);
            spnOG.setEditor(new JSpinner.NumberEditor(spnOG,""String_Node_Str""));
          }
{
            SpinnerNumberModel spnFgModel=new SpinnerNumberModel(1.000,0.900,2.000,0.001);
            spnFG=new JSpinner();
            pnlDetails.add(spnFG,new GridBagConstraints(4,3,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            spnFG.setModel(spnFgModel);
            spnFG.setEditor(new JSpinner.NumberEditor(spnFG,""String_Node_Str""));
            spnFG.addChangeListener(new ChangeListener(){
              public void stateChanged(              ChangeEvent evt){
                myRecipe.setEstFg(Double.parseDouble(spnFG.getValue().toString()));
                displayRecipe();
              }
            }
);
          }
{
            lblIBUvalue=new JLabel();
            pnlDetails.add(lblIBUvalue,new GridBagConstraints(6,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblIBUvalue.setText(""String_Node_Str"");
          }
{
            lblColourValue=new JLabel();
            pnlDetails.add(lblColourValue,new GridBagConstraints(6,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblColourValue.setText(""String_Node_Str"");
          }
{
            lblAlcValue=new JLabel();
            pnlDetails.add(lblAlcValue,new GridBagConstraints(6,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblAlcValue.setText(""String_Node_Str"");
          }
{
            scpComments=new JScrollPane();
            pnlDetails.add(scpComments,new GridBagConstraints(3,5,4,2,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
{
              txtComments=new JTextArea();
              scpComments.setViewportView(txtComments);
              txtComments.setText(""String_Node_Str"");
              txtComments.setWrapStyleWord(true);
              txtComments.addFocusListener(new FocusAdapter(){
                public void focusLost(                FocusEvent evt){
                  if (!txtComments.getText().equals(myRecipe.getComments())) {
                    myRecipe.setComments(txtComments.getText());
                  }
                }
              }
);
            }
          }
{
            cmbYeastModel=new ComboModel();
            cmbYeast=new JComboBox();
            pnlDetails.add(cmbYeast,new GridBagConstraints(1,3,2,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            cmbYeast.setModel(cmbYeastModel);
            cmbYeast.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                Yeast y=(Yeast)cmbYeastModel.getSelectedItem();
                if (myRecipe != null && y != myRecipe.getYeastObj()) {
                  myRecipe.setYeast(y);
                }
              }
            }
);
          }
{
            ComboBoxModel cmbSizeUnitsModel=new DefaultComboBoxModel(new String[]{""String_Node_Str"",""String_Node_Str""});
            cmbSizeUnits=new JComboBox();
            pnlDetails.add(cmbSizeUnits,new GridBagConstraints(2,4,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            cmbSizeUnits.setModel(cmbSizeUnitsModel);
          }
{
            lblSizeUnits=new JLabel();
            pnlDetails.add(lblSizeUnits,new GridBagConstraints(2,5,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblSizeUnits.setText(""String_Node_Str"");
          }
        }
{
          pnlStyle=new JPanel();
          FlowLayout pnlStyleLayout=new FlowLayout();
          pnlStyle.setLayout(pnlStyleLayout);
          jTabbedPane1.addTab(""String_Node_Str"",null,pnlStyle,null);
{
            lblStyle2=new JLabel();
            pnlStyle.add(lblStyle2);
            lblStyle2.setText(""String_Node_Str"");
          }
{
            ComboBoxModel cmbStyle2Model=new DefaultComboBoxModel(new String[]{""String_Node_Str"",""String_Node_Str""});
            cmbStyle2=new JComboBox();
            pnlStyle.add(cmbStyle2);
            cmbStyle2.setModel(cmbStyle2Model);
          }
{
            jPanel2=new JPanel();
            GridBagLayout jPanel2Layout1=new GridBagLayout();
            jPanel2Layout1.columnWeights=new double[]{0.1,0.1,0.1,0.1};
            jPanel2Layout1.columnWidths=new int[]{7,7,7,7};
            jPanel2Layout1.rowWeights=new double[]{0.1,0.1,0.1,0.1,0.1,0.1};
            jPanel2Layout1.rowHeights=new int[]{7,7,7,7,7,7};
            jPanel2.setPreferredSize(new java.awt.Dimension(179,120));
            jPanel2.setLayout(jPanel2Layout1);
            pnlStyle.add(jPanel2);
            jPanel2.setBorder(BorderFactory.createTitledBorder(new LineBorder(new java.awt.Color(0,0,0),1,false),""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP,new java.awt.Font(""String_Node_Str"",0,12),new java.awt.Color(0,0,0)));
{
              jLabel5=new JLabel();
              jPanel2.add(jLabel5,new GridBagConstraints(0,4,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
              jLabel5.setText(""String_Node_Str"");
              jLabel5.setBounds(74,3,60,30);
            }
{
              jLabel1=new JLabel();
              jPanel2.add(jLabel1,new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
              GridLayout jLabel1Layout=new GridLayout(1,1);
              jLabel1.setLayout(jLabel1Layout);
              jLabel1.setText(""String_Node_Str"");
            }
{
              jLabel2=new JLabel();
              jPanel2.add(jLabel2,new GridBagConstraints(2,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
              jLabel2.setText(""String_Node_Str"");
            }
{
              jLabel3=new JLabel();
              jPanel2.add(jLabel3,new GridBagConstraints(3,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
              jLabel3.setText(""String_Node_Str"");
            }
{
              jLabel4=new JLabel();
              jPanel2.add(jLabel4,new GridBagConstraints(0,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
              jLabel4.setText(""String_Node_Str"");
            }
{
              jLabel6=new JLabel();
              jPanel2.add(jLabel6,new GridBagConstraints(0,2,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
              jLabel6.setText(""String_Node_Str"");
            }
{
              jLabel7=new JLabel();
              jPanel2.add(jLabel7,new GridBagConstraints(0,3,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
              jLabel7.setText(""String_Node_Str"");
            }
          }
{
            jScrollPane3=new JScrollPane();
            pnlStyle.add(jScrollPane3);
{
              txaStyles=new JTextArea();
              jScrollPane3.setViewportView(txaStyles);
              txaStyles.setText(""String_Node_Str"");
            }
          }
{
            sldMatch=new JSlider();
            pnlStyle.add(sldMatch);
          }
        }
      }
{
        pnlTables=new JPanel();
        BoxLayout pnlMaltsLayout=new BoxLayout(pnlTables,javax.swing.BoxLayout.Y_AXIS);
        pnlMain.add(pnlTables,new GridBagConstraints(0,2,1,1,0.5,0.5,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
        pnlTables.setLayout(pnlMaltsLayout);
{
          pnlMalt=new JPanel();
          pnlTables.add(pnlMalt);
          BorderLayout pnlMaltLayout1=new BorderLayout();
          FlowLayout pnlMaltLayout=new FlowLayout();
          pnlMalt.setBorder(BorderFactory.createTitledBorder(new LineBorder(new java.awt.Color(0,0,0),1,false),""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP,new java.awt.Font(""String_Node_Str"",1,12),new java.awt.Color(51,51,51)));
          pnlMalt.setLayout(pnlMaltLayout1);
{
            jScrollPane1=new JScrollPane();
            pnlMalt.add(jScrollPane1,BorderLayout.CENTER);
{
              tblMaltModel=new MaltTableModel(this);
              tblMalt=new JTable();
              jScrollPane1.setViewportView(tblMalt);
              BorderLayout tblMaltLayout=new BorderLayout();
              tblMalt.setLayout(tblMaltLayout);
              tblMalt.setModel(tblMaltModel);
              TableColumn maltColumn=tblMalt.getColumnModel().getColumn(0);
              JComboBox maltComboBox=new JComboBox();
              cmbMaltModel=new ComboModel();
              maltComboBox.setModel(cmbMaltModel);
              maltColumn.setCellEditor(new DefaultCellEditor(maltComboBox));
              maltComboBox.addActionListener(new ActionListener(){
                public void actionPerformed(                ActionEvent evt){
                  Fermentable f=(Fermentable)cmbMaltModel.getSelectedItem();
                  int i=tblMalt.getSelectedRow();
                  if (myRecipe != null) {
                    Fermentable f2=(Fermentable)myRecipe.getFermentablesList().get(i);
                    f2.setLov(f.getLov());
                    f2.setPppg(f.getPppg());
                  }
                }
              }
);
            }
          }
{
            tblMaltTotalsModel=new DefaultTableModel(new String[][]{{""String_Node_Str""}},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
            tblMaltTotals=new JTable();
            pnlMalt.add(tblMaltTotals,BorderLayout.SOUTH);
            tblMaltTotals.setModel(tblMaltTotalsModel);
            tblMaltTotals.getTableHeader().setEnabled(false);
          }
        }
{
          pnlHops=new JPanel();
          BorderLayout pnlHopsLayout=new BorderLayout();
          pnlHops.setBorder(BorderFactory.createTitledBorder(new LineBorder(new java.awt.Color(0,0,0),1,false),""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP,new java.awt.Font(""String_Node_Str"",1,12),new java.awt.Color(51,51,51)));
          pnlHops.setLayout(pnlHopsLayout);
          pnlTables.add(pnlHops);
{
            tblHopsTotalsModel=new DefaultTableModel(new String[][]{{""String_Node_Str""}},new String[]{""String_Node_Str"",""String_Node_Str""});
            tblHopsTotals=new JTable();
            pnlHops.add(tblHopsTotals,BorderLayout.SOUTH);
            tblHopsTotals.setModel(tblHopsTotalsModel);
          }
{
            jScrollPane2=new JScrollPane();
            pnlHops.add(jScrollPane2,BorderLayout.CENTER);
{
              tblHopsModel=new HopsTableModel(this);
              tblHops=new JTable();
              jScrollPane2.setViewportView(tblHops);
              BorderLayout tblHopsLayout=new BorderLayout();
              tblHops.setLayout(tblHopsLayout);
              tblHops.setModel(tblHopsModel);
              TableColumn hopColumn=tblHops.getColumnModel().getColumn(0);
              JComboBox hopComboBox=new JComboBox();
              cmbHopsModel=new ComboModel();
              hopComboBox.setModel(cmbHopsModel);
              hopColumn.setCellEditor(new DefaultCellEditor(hopComboBox));
            }
          }
        }
      }
    }
{
      jMenuBar1=new JMenuBar();
      setJMenuBar(jMenuBar1);
{
        jMenu3=new JMenu();
        jMenuBar1.add(jMenu3);
        jMenu3.setText(""String_Node_Str"");
{
          newFileMenuItem=new JMenuItem();
          jMenu3.add(newFileMenuItem);
          newFileMenuItem.setText(""String_Node_Str"");
        }
{
          openFileMenuItem=new JMenuItem();
          jMenu3.add(openFileMenuItem);
          openFileMenuItem.setText(""String_Node_Str"");
          openFileMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              String path=getClass().getProtectionDomain().getCodeSource().getLocation().toString().substring(6) + ""String_Node_Str"";
              JFileChooser fc=new JFileChooser(path);
              int returnVal=fc.showOpenDialog(jMenuBar1);
              if (returnVal == JFileChooser.APPROVE_OPTION) {
                File file=fc.getSelectedFile();
                System.out.print(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
                ImportXml imp=new ImportXml(file.toString());
                myRecipe=imp.handler.getRecipe();
                myRecipe.calcMaltTotals();
                myRecipe.calcHopsTotals();
                myRecipe.mash.setMaltWeight(myRecipe.getTotalMashLbs());
                myRecipe.mash.calcMashSchedule();
                displayRecipe();
              }
 else {
                System.out.print(""String_Node_Str"");
              }
            }
          }
);
        }
{
          saveMenuItem=new JMenuItem();
          jMenu3.add(saveMenuItem);
          saveMenuItem.setText(""String_Node_Str"");
        }
{
          saveAsMenuItem=new JMenuItem();
          jMenu3.add(saveAsMenuItem);
          saveAsMenuItem.setText(""String_Node_Str"");
          saveAsMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              System.out.print(myRecipe.toText());
            }
          }
);
        }
{
          exportMenu=new JMenu();
          jMenu3.add(exportMenu);
          exportMenu.setText(""String_Node_Str"");
{
            exportHTMLmenu=new JMenuItem();
            exportMenu.add(exportHTMLmenu);
            exportHTMLmenu.setText(""String_Node_Str"");
            exportHTMLmenu.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                try {
                  saveAsHTML();
                }
 catch (                Exception e) {
                }
              }
            }
);
          }
        }
{
          closeFileMenuItem=new JMenuItem();
          jMenu3.add(closeFileMenuItem);
          closeFileMenuItem.setText(""String_Node_Str"");
        }
{
          jSeparator2=new JSeparator();
          jMenu3.add(jSeparator2);
        }
{
          exitMenuItem=new JMenuItem();
          jMenu3.add(exitMenuItem);
          exitMenuItem.setText(""String_Node_Str"");
          exitMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              System.exit(0);
            }
          }
);
        }
      }
{
        jMenu4=new JMenu();
        jMenuBar1.add(jMenu4);
        jMenu4.setText(""String_Node_Str"");
{
          cutMenuItem=new JMenuItem();
          jMenu4.add(cutMenuItem);
          cutMenuItem.setText(""String_Node_Str"");
        }
{
          copyMenuItem=new JMenuItem();
          jMenu4.add(copyMenuItem);
          copyMenuItem.setText(""String_Node_Str"");
        }
{
          pasteMenuItem=new JMenuItem();
          jMenu4.add(pasteMenuItem);
          pasteMenuItem.setText(""String_Node_Str"");
        }
{
          jSeparator1=new JSeparator();
          jMenu4.add(jSeparator1);
        }
{
          deleteMenuItem=new JMenuItem();
          jMenu4.add(deleteMenuItem);
          deleteMenuItem.setText(""String_Node_Str"");
        }
      }
{
        jMenu5=new JMenu();
        jMenuBar1.add(jMenu5);
        jMenu5.setText(""String_Node_Str"");
{
          helpMenuItem=new JMenuItem();
          jMenu5.add(helpMenuItem);
          helpMenuItem.setText(""String_Node_Str"");
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","private void initGUI(){
  try {
    this.setSize(520,532);
    this.addWindowListener(new WindowAdapter(){
      public void windowClosed(      WindowEvent evt){
        System.exit(1);
      }
    }
);
{
      pnlMain=new JPanel();
      GridBagLayout jPanel2Layout=new GridBagLayout();
      jPanel2Layout.columnWeights=new double[]{0.1};
      jPanel2Layout.columnWidths=new int[]{7};
      jPanel2Layout.rowWeights=new double[]{0.1,0.1,0.1};
      jPanel2Layout.rowHeights=new int[]{7,7,7};
      pnlMain.setLayout(jPanel2Layout);
      this.getContentPane().add(pnlMain,BorderLayout.CENTER);
{
        jPanel1=new JPanel();
        pnlMain.add(jPanel1,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
        FlowLayout jPanel1Layout=new FlowLayout();
        jPanel1Layout.setAlignment(FlowLayout.LEFT);
        jPanel1.setLayout(jPanel1Layout);
{
          lblName=new JLabel();
          jPanel1.add(lblName);
          lblName.setText(""String_Node_Str"");
        }
{
          txtName=new JTextField();
          jPanel1.add(txtName);
          txtName.setText(""String_Node_Str"");
          txtName.setPreferredSize(new java.awt.Dimension(179,20));
          txtName.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              myRecipe.setName(txtName.getText());
            }
          }
);
        }
      }
{
        jTabbedPane1=new JTabbedPane();
        pnlMain.add(jTabbedPane1,new GridBagConstraints(0,1,1,1,0.1,0.1,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
{
          pnlDetails=new JPanel();
          GridBagLayout pnlDetailsLayout=new GridBagLayout();
          pnlDetailsLayout.columnWeights=new double[]{0.1,0.1,0.1,0.1,0.1,0.1,0.1};
          pnlDetailsLayout.columnWidths=new int[]{7,7,7,7,7,7,7};
          pnlDetailsLayout.rowWeights=new double[]{0.1,0.1,0.1,0.1,0.1,0.1,0.1};
          pnlDetailsLayout.rowHeights=new int[]{7,7,7,7,7,7,7};
          pnlDetails.setLayout(pnlDetailsLayout);
          jTabbedPane1.addTab(""String_Node_Str"",null,pnlDetails,null);
{
            lblBrewer=new JLabel();
            pnlDetails.add(lblBrewer,new GridBagConstraints(0,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblBrewer.setText(""String_Node_Str"");
          }
{
            txtBrewer=new JTextField();
            pnlDetails.add(txtBrewer,new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            txtBrewer.setText(""String_Node_Str"");
            txtBrewer.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                myRecipe.setBrewer(txtBrewer.getText());
              }
            }
);
          }
{
            lblDate=new JLabel();
            pnlDetails.add(lblDate,new GridBagConstraints(0,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblDate.setText(""String_Node_Str"");
          }
{
            lblStyle=new JLabel();
            pnlDetails.add(lblStyle,new GridBagConstraints(0,2,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblStyle.setText(""String_Node_Str"");
          }
{
            lblYeast=new JLabel();
            pnlDetails.add(lblYeast,new GridBagConstraints(0,3,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblYeast.setText(""String_Node_Str"");
          }
{
            lblPreBoil=new JLabel();
            pnlDetails.add(lblPreBoil,new GridBagConstraints(0,4,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblPreBoil.setText(""String_Node_Str"");
          }
{
            lblPostBoil=new JLabel();
            pnlDetails.add(lblPostBoil,new GridBagConstraints(0,5,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblPostBoil.setText(""String_Node_Str"");
          }
{
            lblMash=new JLabel();
            pnlDetails.add(lblMash,new GridBagConstraints(0,6,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblMash.setText(""String_Node_Str"");
          }
{
            lblEffic=new JLabel();
            pnlDetails.add(lblEffic,new GridBagConstraints(3,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblEffic.setText(""String_Node_Str"");
          }
{
            lblAtten=new JLabel();
            pnlDetails.add(lblAtten,new GridBagConstraints(3,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblAtten.setText(""String_Node_Str"");
          }
{
            lblOG=new JLabel();
            pnlDetails.add(lblOG,new GridBagConstraints(3,2,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblOG.setText(""String_Node_Str"");
          }
{
            lblFG=new JLabel();
            pnlDetails.add(lblFG,new GridBagConstraints(3,3,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblFG.setText(""String_Node_Str"");
          }
{
            lblIBU=new JLabel();
            pnlDetails.add(lblIBU,new GridBagConstraints(5,0,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblIBU.setText(""String_Node_Str"");
          }
{
            lblAlc=new JLabel();
            pnlDetails.add(lblAlc,new GridBagConstraints(5,2,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblAlc.setText(""String_Node_Str"");
          }
{
            lblColour=new JLabel();
            pnlDetails.add(lblColour,new GridBagConstraints(5,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblColour.setText(""String_Node_Str"");
          }
{
            txtDate=new JTextField();
            pnlDetails.add(txtDate,new GridBagConstraints(1,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            txtDate.setText(""String_Node_Str"");
          }
{
            cmbStyleModel=new ComboModel();
            cmbStyle=new JComboBox();
            pnlDetails.add(cmbStyle,new GridBagConstraints(1,2,2,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            cmbStyle.setModel(cmbStyleModel);
            cmbStyle.setMaximumSize(new java.awt.Dimension(100,32767));
            cmbStyle.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                Style s=(Style)cmbStyleModel.getSelectedItem();
                if (myRecipe != null && s != myRecipe.getStyleObj()) {
                  myRecipe.setStyle(s);
                }
              }
            }
);
          }
{
            txtPreBoil=new JFormattedTextField();
            pnlDetails.add(txtPreBoil,new GridBagConstraints(1,4,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            txtPreBoil.setText(""String_Node_Str"");
            txtPreBoil.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                myRecipe.setPreBoil(Double.parseDouble(txtPreBoil.getText().toString()));
                displayRecipe();
              }
            }
);
          }
{
            txtPostBoil=new JFormattedTextField();
            pnlDetails.add(txtPostBoil,new GridBagConstraints(1,5,1,1,0.0,0.0,GridBagConstraints.WEST,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            txtPostBoil.setText(""String_Node_Str"");
            txtPostBoil.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                System.out.println(""String_Node_Str"" + evt);
                myRecipe.setPostBoil(Double.parseDouble(txtPostBoil.getText().toString()));
                displayRecipe();
              }
            }
);
          }
{
            lblComments=new JLabel();
            pnlDetails.add(lblComments,new GridBagConstraints(3,4,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblComments.setText(""String_Node_Str"");
          }
{
            SpinnerNumberModel spnEfficModel=new SpinnerNumberModel(75.0,0.0,100.0,1.0);
            spnEffic=new JSpinner();
            pnlDetails.add(spnEffic,new GridBagConstraints(4,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            spnEffic.setModel(spnEfficModel);
            spnEffic.setMaximumSize(new java.awt.Dimension(70,32767));
            spnEffic.addChangeListener(new ChangeListener(){
              public void stateChanged(              ChangeEvent evt){
                myRecipe.setEfficiency(Double.parseDouble(spnEffic.getValue().toString()));
                displayRecipe();
              }
            }
);
            spnEffic.setEditor(new JSpinner.NumberEditor(spnEffic,""String_Node_Str""));
          }
{
            SpinnerNumberModel spnAttenModel=new SpinnerNumberModel(75.0,0.0,100.0,1.0);
            spnAtten=new JSpinner();
            pnlDetails.add(spnAtten,new GridBagConstraints(4,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            spnAtten.setModel(spnAttenModel);
            spnAtten.addChangeListener(new ChangeListener(){
              public void stateChanged(              ChangeEvent evt){
                myRecipe.setAttenuation(Double.parseDouble(spnAtten.getValue().toString()));
                displayRecipe();
              }
            }
);
            spnAtten.setEditor(new JSpinner.NumberEditor(spnAtten,""String_Node_Str""));
          }
{
            SpinnerNumberModel spnOgModel=new SpinnerNumberModel(1.000,0.900,2.000,0.001);
            spnOG=new JSpinner();
            pnlDetails.add(spnOG,new GridBagConstraints(4,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            spnOG.setModel(spnOgModel);
            spnOG.addChangeListener(new ChangeListener(){
              public void stateChanged(              ChangeEvent evt){
                myRecipe.setEstOg(Double.parseDouble(spnOG.getValue().toString()));
                displayRecipe();
              }
            }
);
            spnOG.setEditor(new JSpinner.NumberEditor(spnOG,""String_Node_Str""));
          }
{
            SpinnerNumberModel spnFgModel=new SpinnerNumberModel(1.000,0.900,2.000,0.001);
            spnFG=new JSpinner();
            pnlDetails.add(spnFG,new GridBagConstraints(4,3,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            spnFG.setModel(spnFgModel);
            spnFG.setEditor(new JSpinner.NumberEditor(spnFG,""String_Node_Str""));
            spnFG.addChangeListener(new ChangeListener(){
              public void stateChanged(              ChangeEvent evt){
                myRecipe.setEstFg(Double.parseDouble(spnFG.getValue().toString()));
                displayRecipe();
              }
            }
);
          }
{
            lblIBUvalue=new JLabel();
            pnlDetails.add(lblIBUvalue,new GridBagConstraints(6,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblIBUvalue.setText(""String_Node_Str"");
          }
{
            lblColourValue=new JLabel();
            pnlDetails.add(lblColourValue,new GridBagConstraints(6,1,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblColourValue.setText(""String_Node_Str"");
          }
{
            lblAlcValue=new JLabel();
            pnlDetails.add(lblAlcValue,new GridBagConstraints(6,2,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblAlcValue.setText(""String_Node_Str"");
          }
{
            scpComments=new JScrollPane();
            pnlDetails.add(scpComments,new GridBagConstraints(3,5,4,2,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
{
              txtComments=new JTextArea();
              scpComments.setViewportView(txtComments);
              txtComments.setText(""String_Node_Str"");
              txtComments.setWrapStyleWord(true);
              txtComments.addFocusListener(new FocusAdapter(){
                public void focusLost(                FocusEvent evt){
                  if (!txtComments.getText().equals(myRecipe.getComments())) {
                    myRecipe.setComments(txtComments.getText());
                  }
                }
              }
);
            }
          }
{
            cmbYeastModel=new ComboModel();
            cmbYeast=new JComboBox();
            pnlDetails.add(cmbYeast,new GridBagConstraints(1,3,2,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.HORIZONTAL,new Insets(0,0,0,0),0,0));
            cmbYeast.setModel(cmbYeastModel);
            cmbYeast.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                Yeast y=(Yeast)cmbYeastModel.getSelectedItem();
                if (myRecipe != null && y != myRecipe.getYeastObj()) {
                  myRecipe.setYeast(y);
                }
              }
            }
);
          }
{
            ComboBoxModel cmbSizeUnitsModel=new DefaultComboBoxModel(new String[]{""String_Node_Str"",""String_Node_Str""});
            cmbSizeUnits=new JComboBox();
            pnlDetails.add(cmbSizeUnits,new GridBagConstraints(2,4,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            cmbSizeUnits.setModel(cmbSizeUnitsModel);
          }
{
            lblSizeUnits=new JLabel();
            pnlDetails.add(lblSizeUnits,new GridBagConstraints(2,5,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
            lblSizeUnits.setText(""String_Node_Str"");
          }
        }
{
          pnlStyle=new JPanel();
          FlowLayout pnlStyleLayout=new FlowLayout();
          pnlStyle.setLayout(pnlStyleLayout);
          jTabbedPane1.addTab(""String_Node_Str"",null,pnlStyle,null);
{
            lblStyle2=new JLabel();
            pnlStyle.add(lblStyle2);
            lblStyle2.setText(""String_Node_Str"");
          }
{
            ComboBoxModel cmbStyle2Model=new DefaultComboBoxModel(new String[]{""String_Node_Str"",""String_Node_Str""});
            cmbStyle2=new JComboBox();
            pnlStyle.add(cmbStyle2);
            cmbStyle2.setModel(cmbStyle2Model);
          }
{
            jPanel2=new JPanel();
            GridBagLayout jPanel2Layout1=new GridBagLayout();
            jPanel2Layout1.columnWeights=new double[]{0.1,0.1,0.1,0.1};
            jPanel2Layout1.columnWidths=new int[]{7,7,7,7};
            jPanel2Layout1.rowWeights=new double[]{0.1,0.1,0.1,0.1,0.1,0.1};
            jPanel2Layout1.rowHeights=new int[]{7,7,7,7,7,7};
            jPanel2.setPreferredSize(new java.awt.Dimension(179,120));
            jPanel2.setLayout(jPanel2Layout1);
            pnlStyle.add(jPanel2);
            jPanel2.setBorder(BorderFactory.createTitledBorder(new LineBorder(new java.awt.Color(0,0,0),1,false),""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP,new java.awt.Font(""String_Node_Str"",0,12),new java.awt.Color(0,0,0)));
{
              jLabel5=new JLabel();
              jPanel2.add(jLabel5,new GridBagConstraints(0,4,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
              jLabel5.setText(""String_Node_Str"");
              jLabel5.setBounds(74,3,60,30);
            }
{
              jLabel1=new JLabel();
              jPanel2.add(jLabel1,new GridBagConstraints(1,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
              GridLayout jLabel1Layout=new GridLayout(1,1);
              jLabel1.setLayout(jLabel1Layout);
              jLabel1.setText(""String_Node_Str"");
            }
{
              jLabel2=new JLabel();
              jPanel2.add(jLabel2,new GridBagConstraints(2,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
              jLabel2.setText(""String_Node_Str"");
            }
{
              jLabel3=new JLabel();
              jPanel2.add(jLabel3,new GridBagConstraints(3,0,1,1,0.0,0.0,GridBagConstraints.CENTER,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
              jLabel3.setText(""String_Node_Str"");
            }
{
              jLabel4=new JLabel();
              jPanel2.add(jLabel4,new GridBagConstraints(0,1,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
              jLabel4.setText(""String_Node_Str"");
            }
{
              jLabel6=new JLabel();
              jPanel2.add(jLabel6,new GridBagConstraints(0,2,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
              jLabel6.setText(""String_Node_Str"");
            }
{
              jLabel7=new JLabel();
              jPanel2.add(jLabel7,new GridBagConstraints(0,3,1,1,0.0,0.0,GridBagConstraints.EAST,GridBagConstraints.NONE,new Insets(0,0,0,0),0,0));
              jLabel7.setText(""String_Node_Str"");
            }
          }
{
            jScrollPane3=new JScrollPane();
            pnlStyle.add(jScrollPane3);
{
              txaStyles=new JTextArea();
              jScrollPane3.setViewportView(txaStyles);
              txaStyles.setText(""String_Node_Str"");
            }
          }
{
            sldMatch=new JSlider();
            pnlStyle.add(sldMatch);
          }
        }
      }
{
        pnlTables=new JPanel();
        BoxLayout pnlMaltsLayout=new BoxLayout(pnlTables,javax.swing.BoxLayout.Y_AXIS);
        pnlMain.add(pnlTables,new GridBagConstraints(0,2,1,1,0.5,0.5,GridBagConstraints.CENTER,GridBagConstraints.BOTH,new Insets(0,0,0,0),0,0));
        pnlTables.setLayout(pnlMaltsLayout);
{
          pnlMalt=new JPanel();
          pnlTables.add(pnlMalt);
          BorderLayout pnlMaltLayout1=new BorderLayout();
          FlowLayout pnlMaltLayout=new FlowLayout();
          pnlMalt.setBorder(BorderFactory.createTitledBorder(new LineBorder(new java.awt.Color(0,0,0),1,false),""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP,new java.awt.Font(""String_Node_Str"",1,12),new java.awt.Color(51,51,51)));
          pnlMalt.setLayout(pnlMaltLayout1);
{
            jScrollPane1=new JScrollPane();
            pnlMalt.add(jScrollPane1,BorderLayout.CENTER);
{
              tblMaltModel=new MaltTableModel(this);
              tblMalt=new JTable();
              jScrollPane1.setViewportView(tblMalt);
              tblMalt.setModel(tblMaltModel);
              TableColumn maltColumn=tblMalt.getColumnModel().getColumn(0);
              JComboBox maltComboBox=new JComboBox();
              cmbMaltModel=new ComboModel();
              maltComboBox.setModel(cmbMaltModel);
              maltColumn.setCellEditor(new DefaultCellEditor(maltComboBox));
              maltColumn=tblMalt.getColumnModel().getColumn(1);
              JSpinner maltSpin=new JSpinner();
              maltColumn.setCellEditor(new SpinnerEditor());
              for (int i=0; i < tblMalt.getColumnCount(); i++) {
                TableColumn column;
                column=tblMalt.getColumnModel().getColumn(i);
                if (i == 0) {
                  column.setPreferredWidth(100);
                }
 else {
                  column.setPreferredWidth(50);
                }
              }
              maltComboBox.addActionListener(new ActionListener(){
                public void actionPerformed(                ActionEvent evt){
                  Fermentable f=(Fermentable)cmbMaltModel.getSelectedItem();
                  int i=tblMalt.getSelectedRow();
                  if (myRecipe != null) {
                    Fermentable f2=(Fermentable)myRecipe.getFermentablesList().get(i);
                    f2.setLov(f.getLov());
                    f2.setPppg(f.getPppg());
                  }
                }
              }
);
            }
          }
{
            tblMaltTotalsModel=new DefaultTableModel(new String[][]{{""String_Node_Str""}},new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
            tblMaltTotals=new JTable();
            pnlMalt.add(tblMaltTotals,BorderLayout.SOUTH);
            tblMaltTotals.setModel(tblMaltTotalsModel);
            tblMaltTotals.getTableHeader().setEnabled(false);
          }
        }
{
          pnlHops=new JPanel();
          BorderLayout pnlHopsLayout=new BorderLayout();
          pnlHops.setBorder(BorderFactory.createTitledBorder(new LineBorder(new java.awt.Color(0,0,0),1,false),""String_Node_Str"",TitledBorder.LEADING,TitledBorder.TOP,new java.awt.Font(""String_Node_Str"",1,12),new java.awt.Color(51,51,51)));
          pnlHops.setLayout(pnlHopsLayout);
          pnlTables.add(pnlHops);
{
            tblHopsTotalsModel=new DefaultTableModel(new String[][]{{""String_Node_Str""}},new String[]{""String_Node_Str"",""String_Node_Str""});
            tblHopsTotals=new JTable();
            pnlHops.add(tblHopsTotals,BorderLayout.SOUTH);
            tblHopsTotals.setModel(tblHopsTotalsModel);
          }
{
            jScrollPane2=new JScrollPane();
            pnlHops.add(jScrollPane2,BorderLayout.CENTER);
{
              tblHopsModel=new HopsTableModel(this);
              tblHops=new JTable();
              jScrollPane2.setViewportView(tblHops);
              BorderLayout tblHopsLayout=new BorderLayout();
              tblHops.setLayout(tblHopsLayout);
              tblHops.setModel(tblHopsModel);
              TableColumn hopColumn=tblHops.getColumnModel().getColumn(0);
              JComboBox hopComboBox=new JComboBox();
              cmbHopsModel=new ComboModel();
              hopComboBox.setModel(cmbHopsModel);
              hopColumn.setCellEditor(new DefaultCellEditor(hopComboBox));
            }
          }
        }
      }
    }
{
      jMenuBar1=new JMenuBar();
      setJMenuBar(jMenuBar1);
{
        jMenu3=new JMenu();
        jMenuBar1.add(jMenu3);
        jMenu3.setText(""String_Node_Str"");
{
          newFileMenuItem=new JMenuItem();
          jMenu3.add(newFileMenuItem);
          newFileMenuItem.setText(""String_Node_Str"");
        }
{
          openFileMenuItem=new JMenuItem();
          jMenu3.add(openFileMenuItem);
          openFileMenuItem.setText(""String_Node_Str"");
          openFileMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              String path=getClass().getProtectionDomain().getCodeSource().getLocation().toString().substring(6) + ""String_Node_Str"";
              JFileChooser fc=new JFileChooser(path);
              int returnVal=fc.showOpenDialog(jMenuBar1);
              if (returnVal == JFileChooser.APPROVE_OPTION) {
                File file=fc.getSelectedFile();
                System.out.print(""String_Node_Str"" + file.getName() + ""String_Node_Str"");
                ImportXml imp=new ImportXml(file.toString());
                myRecipe=imp.handler.getRecipe();
                myRecipe.calcMaltTotals();
                myRecipe.calcHopsTotals();
                myRecipe.mash.setMaltWeight(myRecipe.getTotalMashLbs());
                myRecipe.mash.calcMashSchedule();
                displayRecipe();
              }
 else {
                System.out.print(""String_Node_Str"");
              }
            }
          }
);
        }
{
          saveMenuItem=new JMenuItem();
          jMenu3.add(saveMenuItem);
          saveMenuItem.setText(""String_Node_Str"");
        }
{
          saveAsMenuItem=new JMenuItem();
          jMenu3.add(saveAsMenuItem);
          saveAsMenuItem.setText(""String_Node_Str"");
          saveAsMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              System.out.print(myRecipe.toText());
            }
          }
);
        }
{
          exportMenu=new JMenu();
          jMenu3.add(exportMenu);
          exportMenu.setText(""String_Node_Str"");
{
            exportHTMLmenu=new JMenuItem();
            exportMenu.add(exportHTMLmenu);
            exportHTMLmenu.setText(""String_Node_Str"");
            exportHTMLmenu.addActionListener(new ActionListener(){
              public void actionPerformed(              ActionEvent evt){
                try {
                  saveAsHTML();
                }
 catch (                Exception e) {
                }
              }
            }
);
          }
        }
{
          closeFileMenuItem=new JMenuItem();
          jMenu3.add(closeFileMenuItem);
          closeFileMenuItem.setText(""String_Node_Str"");
        }
{
          jSeparator2=new JSeparator();
          jMenu3.add(jSeparator2);
        }
{
          exitMenuItem=new JMenuItem();
          jMenu3.add(exitMenuItem);
          exitMenuItem.setText(""String_Node_Str"");
          exitMenuItem.addActionListener(new ActionListener(){
            public void actionPerformed(            ActionEvent evt){
              System.exit(0);
            }
          }
);
        }
      }
{
        jMenu4=new JMenu();
        jMenuBar1.add(jMenu4);
        jMenu4.setText(""String_Node_Str"");
{
          cutMenuItem=new JMenuItem();
          jMenu4.add(cutMenuItem);
          cutMenuItem.setText(""String_Node_Str"");
        }
{
          copyMenuItem=new JMenuItem();
          jMenu4.add(copyMenuItem);
          copyMenuItem.setText(""String_Node_Str"");
        }
{
          pasteMenuItem=new JMenuItem();
          jMenu4.add(pasteMenuItem);
          pasteMenuItem.setText(""String_Node_Str"");
        }
{
          jSeparator1=new JSeparator();
          jMenu4.add(jSeparator1);
        }
{
          deleteMenuItem=new JMenuItem();
          jMenu4.add(deleteMenuItem);
          deleteMenuItem.setText(""String_Node_Str"");
        }
      }
{
        jMenu5=new JMenu();
        jMenuBar1.add(jMenu5);
        jMenu5.setText(""String_Node_Str"");
{
          helpMenuItem=new JMenuItem();
          jMenu5.add(helpMenuItem);
          helpMenuItem.setText(""String_Node_Str"");
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}"
50571,"public void setOutputDirectory(File outputDirectory){
  if (!outputDirectory.isDirectory()) {
    throw new IllegalArgumentException(""String_Node_Str"" + outputDirectory);
  }
  this.outputDirectory=outputDirectory;
}","public void setOutputDirectory(File outputDirectory){
  this.outputDirectory=outputDirectory;
}"
50572,"public void processResult(Request request,List<ResultFile> resultFiles){
  File resultsDir=new File(outputDirectory,String.valueOf(request.getId()));
  if (!resultsDir.mkdir()) {
    throw new RuntimeException(""String_Node_Str"" + resultsDir.getAbsolutePath());
  }
  try {
    for (    ResultFile resultFile : resultFiles) {
      writeFile(resultsDir,resultFile);
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","public void processResult(Request request,List<ResultFile> resultFiles){
  File resultsDir=new File(outputDirectory,String.valueOf(request.getId()));
  if (!resultsDir.mkdirs()) {
    throw new RuntimeException(""String_Node_Str"" + resultsDir.getAbsolutePath());
  }
  try {
    for (    ResultFile resultFile : resultFiles) {
      writeFile(resultsDir,resultFile);
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}"
50573,"public synchronized void measurementFinished(Request request,RequestProcessor processor,List<ResultFile> results){
  if (results != null) {
    resultsMap.put(processor,results);
  }
  finishedProcessors++;
  if (finishedProcessors == processors.size() && !resultsMap.isEmpty()) {
    recordResults(this);
  }
 else {
    terminateRequest(request);
  }
}","public synchronized void measurementFinished(Request request,RequestProcessor processor,List<ResultFile> results){
  if (results != null) {
    resultsMap.put(processor,results);
  }
  finishedProcessors++;
  if (finishedProcessors == processors.size()) {
    if (!resultsMap.isEmpty())     recordResults(this);
 else     terminateRequest(request);
  }
}"
50574,"@Test public void testRequestTimeout(){
  RequestManager requestManager=initRequestManager(15000);
  TestProcessingThread testThread=new TestProcessingThread(5000);
  Request testRequest=new Request();
  testRequest.setThreadId(testThread.getId());
  testThread.start();
  requestManager.requestStarting(testRequest);
  try {
    Thread.sleep(15000);
  }
 catch (  InterruptedException ex) {
  }
  requestManager.shutdown();
  RequestManager.Status status=requestManager.awaitTermination(30000);
  testThread.stopRunning();
  assertEquals(RequestManager.Status.STOPPED,status);
  File resultsFile=new File(""String_Node_Str"" + testRequest.getId() + ""String_Node_Str"");
  assertTrue(resultsFile.exists());
}","@Test public void testRequestTimeout(){
  RequestManager requestManager=initRequestManager(15000);
  TestProcessingThread testThread=new TestProcessingThread(5000);
  Request testRequest=new TestRequest();
  testRequest.setThreadId(testThread.getId());
  testThread.start();
  requestManager.requestStarting(testRequest);
  try {
    Thread.sleep(15000);
  }
 catch (  InterruptedException ex) {
  }
  requestManager.shutdown();
  RequestManager.Status status=requestManager.awaitTermination(30000);
  testThread.stopRunning();
  assertEquals(RequestManager.Status.STOPPED,status);
  File resultsFile=new File(""String_Node_Str"" + testRequest.getId() + ""String_Node_Str"");
  assertTrue(resultsFile.exists());
}"
50575,"@BeforeClass public static void initOutputDirectory(){
  File testOutputDir=new File(""String_Node_Str"");
  if (testOutputDir.exists())   deleteDir(testOutputDir);
  testOutputDir.mkdir();
}","@BeforeClass public static void initOutputDirectory(){
  File testOutputDir=new File(""String_Node_Str"");
  if (testOutputDir.exists())   deleteDir(testOutputDir);
}"
50576,"public RequestManager initRequestManager(long requestTimeout){
  RequestManager requestManager=new RequestManager().withRequestProcessor(new ThreadSamplingRequestProcessor().withRequestLengthSamplingThreshold(5000)).withResultsProcessor(new FileResultsArchiver().withOutputDirectory(new File(""String_Node_Str""))).withRequestTimeout(requestTimeout);
  requestManager.start();
  return requestManager;
}","public RequestManager initRequestManager(long requestTimeout){
  RequestManager requestManager=new RequestManager().withRequestProcessor(new ThreadSamplingRequestProcessor().withRequestLengthSamplingThreshold(5000)).withRequestProcessor(new RequestRecorderRequestProcessor()).withResultsProcessor(new FileResultsArchiver().withOutputDirectory(new File(""String_Node_Str""))).withRequestTimeout(requestTimeout);
  requestManager.start();
  return requestManager;
}"
50577,"static void putPrimitiveInCollection(Object lastObject,Value value,Field field){
  try {
    getOrCreateColl(checkNotNull(lastObject),checkNotNull(field)).add(value.get());
  }
 catch (  RuntimeException re) {
    throw re;
  }
catch (  Exception ex) {
    throw new RuntimeException(ex);
  }
}","static void putPrimitiveInCollection(Object lastObject,Value value,Field field){
  try {
    getOrCreateColl(checkNotNull(lastObject),checkNotNull(field)).add(getValueObject(value,field));
  }
 catch (  RuntimeException re) {
    throw re;
  }
catch (  Exception ex) {
    throw new RuntimeException(ex);
  }
}"
50578,"static void putPrimitiveValue(Object lastObject,Value value,Field field){
  checkNotNull(field);
  try {
    field.set(checkNotNull(lastObject),value.coerce(field.getType(),null));
  }
 catch (  Exception ex) {
    throw new RuntimeException(ex);
  }
}","static void putPrimitiveValue(Object lastObject,Value value,Field field){
  checkNotNull(field);
  try {
    field.set(checkNotNull(lastObject),getValueObject(value,field));
  }
 catch (  Exception ex) {
    throw new RuntimeException(ex);
  }
}"
50579,"private void build(String fieldName,Class<?> clazz){
  final ClassContext ctx=new ClassContext();
  types.put(fieldName,clazz);
  contexts.put(clazz,ctx);
  for (  Field field : clazz.getDeclaredFields()) {
    if (field.isAnnotationPresent(XmlValue.class)) {
      checkBasicClass(field.getType(),field.getName());
      ctx.setXmlValueField(field);
    }
 else     if (field.isAnnotationPresent(XmlAttribute.class)) {
      if (!isEnumType(field.getType()))       checkBasicClass(field.getType(),field.getName());
      ctx.addAttribute(field);
    }
 else     if (field.isAnnotationPresent(XmlElement.class)) {
      Class<?> fieldClass=isCollection(field) ? getParametricClass(field) : field.getType();
      if (isXmlType(fieldClass)) {
        build(getElementName(field),fieldClass);
      }
 else       if (isEnumType(fieldClass)) {
        checkArgument(!isCollection(field),""String_Node_Str"" + fieldName);
      }
 else {
        checkBasicClass(fieldClass,field.getName());
      }
      if (isCollection(field)) {
        ctx.addCollection(field);
      }
 else {
        ctx.addElement(field);
      }
    }
  }
}","private void build(String fieldName,Class<?> clazz){
  final ClassContext ctx=new ClassContext();
  types.put(fieldName,clazz);
  contexts.put(clazz,ctx);
  for (  Field field : clazz.getDeclaredFields()) {
    if (field.isAnnotationPresent(XmlValue.class)) {
      checkBasicClass(field.getType(),field.getName());
      ctx.setXmlValueField(field);
    }
 else     if (field.isAnnotationPresent(XmlAttribute.class)) {
      if (!isEnumType(field.getType()))       checkBasicClass(field.getType(),field.getName());
      ctx.addAttribute(field);
    }
 else     if (field.isAnnotationPresent(XmlElement.class)) {
      Class<?> fieldClass=getFieldClass(field);
      if (isXmlType(fieldClass)) {
        build(getElementName(field),fieldClass);
      }
 else {
        if (!isEnumType(fieldClass))         checkBasicClass(fieldClass,field.getName());
      }
      if (isCollection(field)) {
        ctx.addCollection(field);
      }
 else {
        ctx.addElement(field);
      }
    }
  }
}"
50580,"@Override public void process(Book object){
  ref.set(object);
}","@Override public void process(Book object){
  ref2.set(object);
}"
50581,"@Override public void elementStart(String elementName){
}","@Override public void elementStart(String elementName){
  assertEquals(""String_Node_Str"",elementName);
}"
50582,"@Test public void testParseBook(){
  XPathStaxParser parser=new XPathStaxParser();
  final AtomicReference<Book> ref=new AtomicReference<Book>();
  parser.addHandler(new NodeConverter<Book>(""String_Node_Str""){
    @Override public void process(    Book object){
      ref.set(object);
    }
  }
);
  parser.parse(asStream(""String_Node_Str""));
  Book book=ref.get();
  assertBookDetails(book,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",44.95,Genre.Computer);
  assertTrue(newHashSet(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"").containsAll(book.getTypes()));
  assertDescDetails(book.getDescription(),""String_Node_Str"");
  assertRevisions(book.getRevisions());
}","@Test public void testParseBook(){
  XPathStaxParser parser=new XPathStaxParser();
  final AtomicReference<Book> ref=new AtomicReference<Book>();
  parser.addHandler(new NodeConverter<Book>(""String_Node_Str""){
    @Override public void process(    Book object){
      ref.set(object);
    }
  }
);
  parser.parse(asStream(""String_Node_Str""));
  Book book=ref.get();
  assertBookDetails(book,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",44.95,Genre.Computer);
  assertTrue(newHashSet(Type.Softback,Type.Hardcover,Type.Bounded).containsAll(book.getTypes()));
  assertTrue(newArrayList(""String_Node_Str"",""String_Node_Str"").containsAll(book.getComments()));
  assertDescDetails(book.getDescription(),""String_Node_Str"");
  assertRevisions(book.getRevisions());
}"
50583,"@Test @Ignore public void testParse(){
  XPathStaxParser parser=new XPathStaxParser();
  final AtomicDouble resultCount=new AtomicDouble();
  parser.addHandler(new XPathRequest(""String_Node_Str""),new NodeHandler(){
    @Override public void processNode(    XmlNode xmlNode){
      Value count=xmlNode.getText();
      resultCount.set(count.asDouble(0d));
    }
    @Override public void elementStart(    String elementName){
    }
  }
);
  parser.parse(asStream(""String_Node_Str""));
  assertEquals(44.95,resultCount.get(),0.001);
}","@Test public void testParse(){
  XPathStaxParser parser=new XPathStaxParser();
  parser.addHandler(new XPathRequest(""String_Node_Str""),new NodeHandler(){
    @Override public void processNode(    XmlNode xmlNode){
      Value count=xmlNode.getText();
      assertEquals(44.95,count.asDouble(),0.001);
    }
    @Override public void elementStart(    String elementName){
      assertEquals(""String_Node_Str"",elementName);
    }
  }
);
  parser.parse(asStream(""String_Node_Str""));
}"
50584,"@Override public void processNode(XmlNode xmlNode){
  Value count=xmlNode.getText();
  resultCount.set(count.asDouble(0d));
}","@Override public void processNode(XmlNode xmlNode){
  Value count=xmlNode.getText();
  assertEquals(44.95,count.asDouble(),0.001);
}"
50585,"public void setTypes(Set<String> types){
  this.types=types;
}","public void setTypes(Set<Type> types){
  this.types=types;
}"
50586,"public Set<String> getTypes(){
  return types;
}","public Set<Type> getTypes(){
  return types;
}"
50587,"@Test public void testBinder(){
  XmlBinderContext<Book> ctx=new XmlBinderContext<Book>(Book.class);
  assertNotNull(ctx);
  Map<String,Class<?>> types=ctx.getTypes();
  checkNames(types,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Map<Class<?>,ClassContext> contexts=ctx.getContexts();
  checkClasses(contexts,Book.class,Revision.class,Desc.class);
  ClassContext bookCtx=contexts.get(Book.class);
  checkAttributes(bookCtx,""String_Node_Str"");
  checkElements(bookCtx,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  checkCollections(bookCtx,""String_Node_Str"",""String_Node_Str"");
  ClassContext revCtx=contexts.get(Revision.class);
  checkAttributes(revCtx,""String_Node_Str"",""String_Node_Str"");
  checkXmlValue(revCtx);
  ClassContext descCtx=contexts.get(Desc.class);
  checkXmlValue(descCtx);
}","@Test public void testBinder(){
  XmlBinderContext<Book> ctx=new XmlBinderContext<Book>(Book.class);
  assertNotNull(ctx);
  Map<String,Class<?>> types=ctx.getTypes();
  checkNames(types,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  Map<Class<?>,ClassContext> contexts=ctx.getContexts();
  checkClasses(contexts,Book.class,Revision.class,Desc.class);
  ClassContext bookCtx=contexts.get(Book.class);
  checkAttributes(bookCtx,""String_Node_Str"");
  checkElements(bookCtx,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  checkCollections(bookCtx,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  ClassContext revCtx=contexts.get(Revision.class);
  checkAttributes(revCtx,""String_Node_Str"",""String_Node_Str"");
  checkXmlValue(revCtx);
  ClassContext descCtx=contexts.get(Desc.class);
  checkXmlValue(descCtx);
}"
50588,"/** 
 * Learn the final weight
 */
public double[] executeMethod(){
}","/** 
 * Learn the final weight
 */
public double[] executeMethod(){
  int length=FeatureFactory.getFeatures().length;
  double[] returnweight=new double[length];
  for (int i=0; i < methodEpoch; i++) {
    double[] weight=new double[length];
    double[] totalWeight=new double[length];
    int violation=0;
    Parameter para=new Parameter(weight,totalWeight,violation);
    for (int j=0; j < numberOfFunctions; j++) {
      ResultOutput.writeTextFile(logFile,""String_Node_Str"" + i + ""String_Node_Str""+ j+ ""String_Node_Str"");
      ResultOutput.printParameter(para,logFile);
      para=trainModel(para,i,j);
      ResultOutput.writeTextFile(logFile,""String_Node_Str"" + i + ""String_Node_Str""+ j+ ""String_Node_Str"");
      testModel(generateWeightForTesting(para),i,j);
    }
    if (i == methodEpoch - 1) {
      returnweight=generateWeightForTesting(para);
    }
  }
  return returnweight;
}"
50589,"private Parameter trainModel(Parameter para,int i,int j){
}","/** 
 * train the model
 * @param para
 * @param j
 * @param i
 * @param phaseID
 * @return
 */
private Parameter trainModel(Parameter para,int i,int j){
  ISearch search=EecbConstructor.createSearchMethod(searchMethod);
  Parameter returnPara=para.makeCopy();
  String phaseID=""String_Node_Str"" + i + ""String_Node_Str""+ j;
  for (  String topic : trainingTopics) {
    ResultOutput.writeTextFile(logFile,""String_Node_Str"" + i + ""String_Node_Str""+ j+ ""String_Node_Str""+ topic+ ""String_Node_Str"");
    Document document=ResultOutput.deserialize(topic,serializeOutput,false);
    ResultOutput.printParameter(returnPara,logFile);
    if (j == 0) {
      returnPara=search.trainingBySearch(document,returnPara,phaseID);
    }
 else {
      search.testingBySearch(document,generateWeightForTesting(returnPara),phaseID,true);
      IClassifier classifier=EecbConstructor.createClassifier(classificationMethod);
      List<String> filePaths=getPaths(i,j);
      returnPara=classifier.train(filePaths,returnPara);
    }
  }
  return returnPara.makeCopy();
}"
50590,"private List<String> getPaths(String[] topics,int i,int j){
}","private List<String> getPaths(String[] topics,int i,int j){
  List<String> files=new ArrayList<String>();
  for (  String topic : topics) {
    String topicPath=experimentResultFolder + ""String_Node_Str"" + topic+ ""String_Node_Str"";
    List<String> file=new ArrayList<String>(Arrays.asList(new File(topicPath).list()));
    Map<String,String> fileMap=new HashMap<String,String>();
    for (    String f : file) {
      fileMap.put(f,""String_Node_Str"");
    }
    for (int it=0; it <= i; it++) {
      for (int jt=0; jt <= j; jt++) {
        fileMap.remove(""String_Node_Str"" + it + ""String_Node_Str""+ jt);
        fileMap.remove(""String_Node_Str"" + it + ""String_Node_Str""+ jt);
      }
    }
    List<String> editeFile=new ArrayList<String>();
    for (    String key : fileMap.keySet()) {
      editeFile.add(topicPath + ""String_Node_Str"" + key);
    }
    files.addAll(editeFile);
  }
  return files;
}"
50591,"private void testDocument(String[] topics,double[] weight,int i,int j,boolean postProcess,String phase){
}","private void testDocument(String[] topics,double[] weight,int i,int j,boolean postProcess,String phase){
  String predictedCorefCluster=conllResultPath + ""String_Node_Str"" + i+ ""String_Node_Str""+ j;
  String goldCorefCluster=conllResultPath + ""String_Node_Str"" + i+ ""String_Node_Str""+ j;
  PrintWriter writerPredicted=null;
  PrintWriter writerGold=null;
  try {
    writerPredicted=new PrintWriter(new FileOutputStream(predictedCorefCluster));
    writerGold=new PrintWriter(new FileOutputStream(goldCorefCluster));
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  String phaseID=""String_Node_Str"" + i + ""String_Node_Str""+ j;
  for (  String topic : topics) {
    ResultOutput.writeTextFile(logFile,""String_Node_Str"" + phaseID + ""String_Node_Str""+ topic+ ""String_Node_Str"");
    Document document=ResultOutput.deserialize(topic,serializeOutput,false);
    ISearch search=EecbConstructor.createSearchMethod(searchMethod);
    State<CorefCluster> bestLossState=search.testingBySearch(document,weight,phaseID,false);
    document.corefClusters=bestLossState.getState();
    DocumentAlignment.updateOrderedPredictedMentions(document);
    try {
      DeterministicCorefSieve pronounSieve=(DeterministicCorefSieve)Class.forName(""String_Node_Str"").getConstructor().newInstance();
      CorefSystem cs=new CorefSystem();
      cs.getCorefSystem().coreference(document,pronounSieve);
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
    if (postProcess) {
      SieveCoreferenceSystem.postProcessing(document);
    }
    SieveCoreferenceSystem.printConllOutput(document,writerPredicted,false,postProcess);
    SieveCoreferenceSystem.printConllOutput(document,writerGold,true);
  }
  CoNLLScorerHelper conllScorerHelper=new CoNLLScorerHelper(i * 10 + j,logFile);
  conllScorerHelper.printFinalCoNLLScore(goldCorefCluster,predictedCorefCluster,phase);
  double predictedCoNLL=conllScorerHelper.getFinalCoNllF1Result();
  double predictedScore=conllScorerHelper.getLossScoreF1Result();
}"
50592,"public static void setMap(int mapID){
  setScene(mapID);
  if (mapID == 0) {
    mapName=""String_Node_Str"";
    mapOffset=20;
  }
  if (mapID == 1) {
    mapName=""String_Node_Str"";
    mapOffset=20;
  }
  if (mapID == 2) {
    mapName=""String_Node_Str"";
    mapOffset=100;
  }
}","public static void setMap(int _mapID){
  mapID=_mapID;
  setScene(_mapID);
  if (_mapID == 0) {
    mapName=""String_Node_Str"";
    mapOffset=20;
  }
  if (_mapID == 1) {
    mapName=""String_Node_Str"";
    mapOffset=20;
  }
  if (_mapID == 2) {
    mapName=""String_Node_Str"";
    mapOffset=100;
  }
}"
50593,"public void initControls(){
  HUD mHUD=new HUD();
  mScoreChangeableText=new ChangeableText(5,5,mScoreFont,""String_Node_Str"",""String_Node_Str"".length());
  mScoreChangeableText.setBlendFunction(GL10.GL_SRC_ALPHA,GL10.GL_ONE_MINUS_SRC_ALPHA);
  mScoreChangeableText.setAlpha(0.9f);
  mHUD.attachChild(mScoreChangeableText);
  mRemainingEnemiesChangeableText=new ChangeableText(250,CAMERA_HEIGHT - 40,mScoreFont,""String_Node_Str"",""String_Node_Str"".length());
  mRemainingEnemiesChangeableText.setBlendFunction(GL10.GL_SRC_ALPHA,GL10.GL_ONE_MINUS_SRC_ALPHA);
  mRemainingEnemiesChangeableText.setAlpha(0.9f);
  mRemainingEnemiesChangeableText.setScale(0.8f);
  mHUD.attachChild(mRemainingEnemiesChangeableText);
  Sprite jump=new Sprite(CAMERA_WIDTH - 120,CAMERA_HEIGHT - 175,mJumpTextureRegion){
    @Override public boolean onAreaTouched(    TouchEvent pEvent,    float pX,    float pY){
      if (pEvent.isActionDown() && isLanded) {
        jumpPlayer(player_self_body);
        mCamera.setZoomFactor(0.80f);
        isLanded=false;
        isButtonAreaTouched=true;
      }
      if (pEvent.isActionUp()) {
        mCamera.setZoomFactor(1.0f);
        isButtonAreaTouched=false;
      }
      return false;
    }
  }
;
  jump.setScale(0.70f);
  Sprite shoot=new Sprite(CAMERA_WIDTH - 200,CAMERA_HEIGHT - 110,mShootTextureRegion){
    @Override public boolean onAreaTouched(    TouchEvent pEvent,    float pX,    float pY){
      if (pEvent.isActionDown()) {
        if (!machineGun)         spawnBullet(player_self_sprite,playerDir,""String_Node_Str"");
        mCamera.setZoomFactor(0.80f);
        isButtonAreaTouched=true;
      }
      if (pEvent.isActionUp()) {
        mCamera.setZoomFactor(1.0f);
        machineGun=false;
        isButtonAreaTouched=false;
      }
      return false;
    }
  }
;
  shoot.setScale(0.60f);
  mHealthSprite=new AnimatedSprite(CAMERA_WIDTH - 256,10,mHealthRegion);
  mHealthSprite.setScale(0.5f);
  mHUD.registerTouchArea(shoot);
  mHUD.attachChild(shoot);
  mHUD.registerTouchArea(jump);
  mHUD.attachChild(jump);
  mHUD.attachChild(mHealthSprite);
  mCamera.setHUD(mHUD);
  this.mDigitalOnScreenControl=new DigitalOnScreenControl(10,CAMERA_HEIGHT - this.mOnScreenControlBaseTextureRegion.getHeight() - 5,this.mCamera,this.mOnScreenControlBaseTextureRegion,this.mOnScreenControlKnobTextureRegion,0.1f,new IOnScreenControlListener(){
    @Override public void onControlChange(    final BaseOnScreenControl pBaseOnScreenControl,    final float pValueX,    final float pValueY){
      if (pValueX > 0 && !player_self_sprite.isAnimationRunning()) {
        movePlayerRight(player_self_sprite,player_self_body);
        isButtonAreaTouched=true;
      }
 else       if (pValueX < 0 && !player_self_sprite.isAnimationRunning()) {
        movePlayerLeft(player_self_sprite,player_self_body);
        isButtonAreaTouched=true;
      }
 else       if (pValueX == 0) {
        if (isPlayerMoving) {
          stopPlayer(player_self_sprite,player_self_body);
          isPlayerMoving=false;
          isButtonAreaTouched=false;
        }
      }
    }
  }
);
  this.mDigitalOnScreenControl.getControlBase().setBlendFunction(GL10.GL_SRC_ALPHA,GL10.GL_ONE_MINUS_SRC_ALPHA);
  this.mDigitalOnScreenControl.getControlBase().setAlpha(0.55f);
  this.mDigitalOnScreenControl.getControlBase().setScaleCenter(0,128);
  this.mDigitalOnScreenControl.getControlBase().setScale(1.5f);
  this.mDigitalOnScreenControl.getControlKnob().setAlpha(0.40f);
  this.mDigitalOnScreenControl.getControlKnob().setScale(0.7f);
  this.mDigitalOnScreenControl.refreshControlKnobPosition();
  this.mDigitalOnScreenControl.setAllowDiagonal(false);
}","public void initControls(){
  mHUD=new HUD();
  mScoreChangeableText=new ChangeableText(5,5,mScoreFont,""String_Node_Str"",""String_Node_Str"".length());
  mScoreChangeableText.setBlendFunction(GL10.GL_SRC_ALPHA,GL10.GL_ONE_MINUS_SRC_ALPHA);
  mScoreChangeableText.setAlpha(0.9f);
  mHUD.attachChild(mScoreChangeableText);
  mTimerChangeableText=new ChangeableText(CAMERA_WIDTH - 180,50,mScoreFont,""String_Node_Str"",""String_Node_Str"".length());
  mTimerChangeableText.setBlendFunction(GL10.GL_SRC_ALPHA,GL10.GL_ONE_MINUS_SRC_ALPHA);
  mTimerChangeableText.setColor(0,255,0);
  mTimerChangeableText.setAlpha(0.9f);
  mHUD.attachChild(mTimerChangeableText);
  mRemainingEnemiesChangeableText=new ChangeableText(250,CAMERA_HEIGHT - 40,mScoreFont,""String_Node_Str"",""String_Node_Str"".length());
  mRemainingEnemiesChangeableText.setBlendFunction(GL10.GL_SRC_ALPHA,GL10.GL_ONE_MINUS_SRC_ALPHA);
  mRemainingEnemiesChangeableText.setAlpha(0.9f);
  mRemainingEnemiesChangeableText.setScale(0.8f);
  mHUD.attachChild(mRemainingEnemiesChangeableText);
  Sprite jump=new Sprite(CAMERA_WIDTH - 120,CAMERA_HEIGHT - 175,mJumpTextureRegion){
    @Override public boolean onAreaTouched(    TouchEvent pEvent,    float pX,    float pY){
      if (pEvent.isActionDown() && isLanded) {
        jumpPlayer(player_self_body);
        mCamera.setZoomFactor(0.80f);
        isLanded=false;
        isButtonAreaTouched=true;
      }
      if (pEvent.isActionUp()) {
        mCamera.setZoomFactor(1.0f);
        isButtonAreaTouched=false;
      }
      return false;
    }
  }
;
  jump.setScale(0.70f);
  Sprite shoot=new Sprite(CAMERA_WIDTH - 200,CAMERA_HEIGHT - 110,mShootTextureRegion){
    @Override public boolean onAreaTouched(    TouchEvent pEvent,    float pX,    float pY){
      if (pEvent.isActionDown()) {
        if (!machineGun)         spawnBullet(player_self_sprite,playerDir,""String_Node_Str"");
        mCamera.setZoomFactor(0.80f);
        isButtonAreaTouched=true;
      }
      if (pEvent.isActionUp()) {
        mCamera.setZoomFactor(1.0f);
        machineGun=false;
        isButtonAreaTouched=false;
      }
      return false;
    }
  }
;
  shoot.setScale(0.60f);
  mHealthSprite=new AnimatedSprite(CAMERA_WIDTH - 256,10,mHealthRegion);
  mHealthSprite.setScale(0.5f);
  mHUD.registerTouchArea(shoot);
  mHUD.attachChild(shoot);
  mHUD.registerTouchArea(jump);
  mHUD.attachChild(jump);
  mHUD.attachChild(mHealthSprite);
  mCamera.setHUD(mHUD);
  this.mDigitalOnScreenControl=new DigitalOnScreenControl(10,CAMERA_HEIGHT - this.mOnScreenControlBaseTextureRegion.getHeight() - 5,this.mCamera,this.mOnScreenControlBaseTextureRegion,this.mOnScreenControlKnobTextureRegion,0.1f,new IOnScreenControlListener(){
    @Override public void onControlChange(    final BaseOnScreenControl pBaseOnScreenControl,    final float pValueX,    final float pValueY){
      if (pValueX > 0 && !player_self_sprite.isAnimationRunning()) {
        movePlayerRight(player_self_sprite,player_self_body);
        isButtonAreaTouched=true;
      }
 else       if (pValueX < 0 && !player_self_sprite.isAnimationRunning()) {
        movePlayerLeft(player_self_sprite,player_self_body);
        isButtonAreaTouched=true;
      }
 else       if (pValueX == 0) {
        if (isPlayerMoving) {
          stopPlayer(player_self_sprite,player_self_body);
          isPlayerMoving=false;
          isButtonAreaTouched=false;
        }
      }
    }
  }
);
  this.mDigitalOnScreenControl.getControlBase().setBlendFunction(GL10.GL_SRC_ALPHA,GL10.GL_ONE_MINUS_SRC_ALPHA);
  this.mDigitalOnScreenControl.getControlBase().setAlpha(0.55f);
  this.mDigitalOnScreenControl.getControlBase().setScaleCenter(0,128);
  this.mDigitalOnScreenControl.getControlBase().setScale(1.5f);
  this.mDigitalOnScreenControl.getControlKnob().setAlpha(0.40f);
  this.mDigitalOnScreenControl.getControlKnob().setScale(0.7f);
  this.mDigitalOnScreenControl.refreshControlKnobPosition();
  this.mDigitalOnScreenControl.setAllowDiagonal(false);
}"
50594,"public void destroyGameObject(String name){
  if (mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(name)) != null) {
    if (name.contains(""String_Node_Str"")) {
      remainingEnemies--;
      Debug.d(""String_Node_Str"" + remainingEnemies);
    }
    mScene.detachChild(findShape(name));
    mPhysicsWorld.destroyBody(mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(name)));
    mPhysicsWorld.unregisterPhysicsConnector(mPhysicsWorld.getPhysicsConnectorManager().findPhysicsConnectorByShape(findShape(name)));
  }
}","public void destroyGameObject(String name){
  if (mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(name)) != null) {
    if (name.contains(""String_Node_Str"")) {
      reduceRemainingEnemies();
      Debug.d(""String_Node_Str"" + remainingEnemies);
    }
    mScene.detachChild(findShape(name));
    mPhysicsWorld.destroyBody(mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(name)));
    mPhysicsWorld.unregisterPhysicsConnector(mPhysicsWorld.getPhysicsConnectorManager().findPhysicsConnectorByShape(findShape(name)));
  }
}"
50595,"public void endGame(){
  mPhysicsWorld.destroyBody(player_self_body);
  mPhysicsWorld.unregisterPhysicsConnector(mPhysicsWorld.getPhysicsConnectorManager().findPhysicsConnectorByShape(player_self_sprite));
  mScene.detachChild(player_self_sprite);
  Intent StartIntent=new Intent(BotWars.this,StartMenu.class);
  startActivity(StartIntent);
  finish();
}","public void endGame(int action){
  mCountDownTimer.cancel();
  if (action == 0) {
    Intent StartIntent=new Intent(BotWars.this,StartMenu.class);
    finish();
    startActivity(StartIntent);
  }
  if (action == 1) {
    Intent StartIntent=new Intent(BotWars.this,GameOver.class);
    finish();
    startActivity(StartIntent);
  }
  if (action == 2) {
    Intent StartIntent=new Intent(BotWars.this,LevelComplete.class);
    finish();
    startActivity(StartIntent);
  }
}"
50596,"@Override public boolean onKeyDown(int keyCode,KeyEvent event){
  if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
    Intent openStartMenu=new Intent(BotWars.this,StartMenu.class);
    startActivity(openStartMenu);
    finish();
    return true;
  }
  return super.onKeyDown(keyCode,event);
}","@Override public boolean onKeyDown(int keyCode,KeyEvent event){
  if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
    endGame(0);
    return true;
  }
  return super.onKeyDown(keyCode,event);
}"
50597,"public void createGameUpdateHandler(){
  gameUpdater=new IUpdateHandler(){
    public void onUpdate(    float pSecondsElapsed){
      makeBulletsDefyGravity();
      updateScore();
      doAICalculations(player_self_body);
      mRemainingEnemiesChangeableText.setText(remainingEnemies + ""String_Node_Str"");
      if (desEnemy) {
        if (fix1_name.contains(""String_Node_Str""))         destroyGameObject(fix1_name);
        if (fix2_name.contains(""String_Node_Str""))         destroyGameObject(fix2_name);
        desEnemy=false;
      }
      if (desBull) {
        if (fix1_name.contains(""String_Node_Str""))         destroyGameObject(fix1_name);
        if (fix2_name.contains(""String_Node_Str""))         destroyGameObject(fix2_name);
        desBull=false;
      }
      if (machineGun && test % 4 == 0) {
        test=1;
        spawnBullet(player_self_sprite,playerDir,""String_Node_Str"");
      }
 else       if (machineGun && test % 4 != 0)       test++;
      updateHealthBar();
      if (Player_Max_Health <= 0) {
        endGame();
      }
      if (!mScrollDetector.isEnabled()) {
      }
    }
    @Override public void reset(){
    }
  }
;
}","public void createGameUpdateHandler(){
  gameUpdater=new IUpdateHandler(){
    public void onUpdate(    float pSecondsElapsed){
      makeBulletsDefyGravity();
      updateScore();
      doAICalculations(player_self_body);
      mRemainingEnemiesChangeableText.setText(remainingEnemies + ""String_Node_Str"");
      if (remainingEnemies == 0) {
        endGame(2);
      }
      if (desEnemy) {
        if (fix1_name.contains(""String_Node_Str""))         destroyGameObject(fix1_name);
        if (fix2_name.contains(""String_Node_Str""))         destroyGameObject(fix2_name);
        desEnemy=false;
      }
      if (desBull) {
        if (fix1_name.contains(""String_Node_Str""))         destroyGameObject(fix1_name);
        if (fix2_name.contains(""String_Node_Str""))         destroyGameObject(fix2_name);
        desBull=false;
      }
      if (machineGun && test % 4 == 0) {
        test=1;
        spawnBullet(player_self_sprite,playerDir,""String_Node_Str"");
      }
 else       if (machineGun && test % 4 != 0)       test++;
      updateHealthBar();
      if (Player_Max_Health <= 0) {
        endGame(1);
      }
      if (!mScrollDetector.isEnabled()) {
      }
    }
    @Override public void reset(){
    }
  }
;
}"
50598,"private void updateScore(){
  if (enemyShot) {
    mScore+=10;
    mScoreChangeableText.setText(""String_Node_Str"" + mScore);
    enemyShot=false;
  }
}","public void updateScore(){
  if (enemyShot) {
    mScore+=10;
    mScoreChangeableText.setText(""String_Node_Str"" + mScore);
    enemyShot=false;
  }
}"
50599,"@Override public Scene onLoadScene(){
  this.mEngine.registerUpdateHandler(new FPSLogger());
  mScene=new Scene();
  mScene.setBackground(this.mRepeatingSpriteBackground);
  if (enableMusic) {
    if (mMusic.isPlaying()) {
      mMusic.pause();
    }
 else {
      mMusic.setVolume(mVolume);
      mMusic.play();
    }
  }
  final TMXLayer mTMXLayer=this.mTMXTiledMap.getTMXLayers().get(0);
  mScene.attachChild(mTMXLayer);
  this.mPhysicsWorld=new PhysicsWorld(new Vector2(0,SensorManager.GRAVITY_EARTH),false);
  mScene.registerUpdateHandler(this.mPhysicsWorld);
  createCollisionListener();
  this.mPhysicsWorld.setContactListener(collisionListener);
  createGameUpdateHandler();
  mScene.registerUpdateHandler(gameUpdater);
  initControls();
  mScene.setChildScene(this.mDigitalOnScreenControl);
  loadObjectsFromMap(mTMXTiledMap);
  mEntityList=new ArrayList<IEntity>(mScene.getChildCount());
  for (int i=0; i < mScene.getChildCount(); i++)   mEntityList.add(mScene.getChild(i));
  initCharacters();
  this.mScrollDetector=new SurfaceScrollDetector(this);
  this.mScrollDetector.setEnabled(false);
  createPinchZoomDetector();
  player_self_sprite=(AnimatedSprite)findShape(""String_Node_Str"");
  player_self_body=mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(player_self_sprite);
  enemyLandedArr=new boolean[enemyCount];
  for (int i=0; i < enemyCount; i++) {
    enemyLandedArr[i]=true;
  }
  remainingEnemies=enemyCount;
  mCamera.setBoundsEnabled(true);
  mCamera.setBounds(0,mTMXTiledMap.getTileColumns() * mTMXTiledMap.getTileWidth(),0,mTMXTiledMap.getTileRows() * mTMXTiledMap.getTileHeight());
  mCamera.setChaseEntity(player_self_sprite);
  return mScene;
}","@Override public Scene onLoadScene(){
  this.mEngine.registerUpdateHandler(new FPSLogger());
  mScene=new Scene();
  mScene.setBackground(this.mRepeatingSpriteBackground);
  if (enableMusic) {
    if (mMusic.isPlaying()) {
      mMusic.pause();
    }
 else {
      mMusic.setVolume(mVolume);
      mMusic.play();
    }
  }
  final TMXLayer mTMXLayer=this.mTMXTiledMap.getTMXLayers().get(0);
  mScene.attachChild(mTMXLayer);
  this.mPhysicsWorld=new PhysicsWorld(new Vector2(0,SensorManager.GRAVITY_EARTH),false);
  mScene.registerUpdateHandler(this.mPhysicsWorld);
  createCollisionListener();
  this.mPhysicsWorld.setContactListener(collisionListener);
  createGameUpdateHandler();
  mScene.registerUpdateHandler(gameUpdater);
  initControls();
  mScene.setChildScene(this.mDigitalOnScreenControl);
  loadObjectsFromMap(mTMXTiledMap);
  mEntityList=new ArrayList<IEntity>(mScene.getChildCount());
  for (int i=0; i < mScene.getChildCount(); i++)   mEntityList.add(mScene.getChild(i));
  initCharacters();
  this.mScrollDetector=new SurfaceScrollDetector(this);
  this.mScrollDetector.setEnabled(false);
  createPinchZoomDetector();
  player_self_sprite=(AnimatedSprite)findShape(""String_Node_Str"");
  player_self_body=mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(player_self_sprite);
  enemyLandedArr=new boolean[enemyCount];
  for (int i=0; i < enemyCount; i++) {
    enemyLandedArr[i]=true;
  }
  remainingEnemies=enemyCount;
  mCamera.setBoundsEnabled(true);
  mCamera.setBounds(0,mTMXTiledMap.getTileColumns() * mTMXTiledMap.getTileWidth(),0,mTMXTiledMap.getTileRows() * mTMXTiledMap.getTileHeight());
  mCamera.setChaseEntity(player_self_sprite);
  if (mapID == 0)   totalTime=120000;
  if (mapID == 1)   totalTime=60000;
  if (mapID == 2)   totalTime=240000;
  startCountDownTimer();
  return mScene;
}"
50600,"public void onUpdate(float pSecondsElapsed){
  makeBulletsDefyGravity();
  updateScore();
  doAICalculations(player_self_body);
  mRemainingEnemiesChangeableText.setText(remainingEnemies + ""String_Node_Str"");
  if (desEnemy) {
    if (fix1_name.contains(""String_Node_Str""))     destroyGameObject(fix1_name);
    if (fix2_name.contains(""String_Node_Str""))     destroyGameObject(fix2_name);
    desEnemy=false;
  }
  if (desBull) {
    if (fix1_name.contains(""String_Node_Str""))     destroyGameObject(fix1_name);
    if (fix2_name.contains(""String_Node_Str""))     destroyGameObject(fix2_name);
    desBull=false;
  }
  if (machineGun && test % 4 == 0) {
    test=1;
    spawnBullet(player_self_sprite,playerDir,""String_Node_Str"");
  }
 else   if (machineGun && test % 4 != 0)   test++;
  updateHealthBar();
  if (Player_Max_Health <= 0) {
    endGame();
  }
  if (!mScrollDetector.isEnabled()) {
  }
}","public void onUpdate(float pSecondsElapsed){
  makeBulletsDefyGravity();
  updateScore();
  doAICalculations(player_self_body);
  mRemainingEnemiesChangeableText.setText(remainingEnemies + ""String_Node_Str"");
  if (remainingEnemies == 0) {
    endGame(2);
  }
  if (desEnemy) {
    if (fix1_name.contains(""String_Node_Str""))     destroyGameObject(fix1_name);
    if (fix2_name.contains(""String_Node_Str""))     destroyGameObject(fix2_name);
    desEnemy=false;
  }
  if (desBull) {
    if (fix1_name.contains(""String_Node_Str""))     destroyGameObject(fix1_name);
    if (fix2_name.contains(""String_Node_Str""))     destroyGameObject(fix2_name);
    desBull=false;
  }
  if (machineGun && test % 4 == 0) {
    test=1;
    spawnBullet(player_self_sprite,playerDir,""String_Node_Str"");
  }
 else   if (machineGun && test % 4 != 0)   test++;
  updateHealthBar();
  if (Player_Max_Health <= 0) {
    endGame(1);
  }
  if (!mScrollDetector.isEnabled()) {
  }
}"
50601,"@Override public void onTimePassed(TimerHandler pTimerHandler){
  if (mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(""String_Node_Str"")) != null) {
    sendMessage(""String_Node_Str"" + mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(""String_Node_Str"")).getPosition().x + ""String_Node_Str""+ mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(""String_Node_Str"")).getPosition().y);
  }
  for (int i=0; i < enemyLandedArr.length; i++) {
    if (enemyLandedArr[i] && mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(""String_Node_Str"" + i)) != null) {
      sendMessage(""String_Node_Str"" + i + ""String_Node_Str""+ mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(""String_Node_Str"" + i)).getPosition().x+ ""String_Node_Str""+ mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(""String_Node_Str"" + i)).getPosition().y);
    }
  }
}","@Override public void onTimePassed(TimerHandler pTimerHandler){
  if (mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(""String_Node_Str"")) != null) {
    sendMessage(""String_Node_Str"" + mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(""String_Node_Str"")).getPosition().x + ""String_Node_Str""+ mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(""String_Node_Str"")).getPosition().y);
  }
  for (int i=0; i < enemyLandedArr.length; i++) {
    if (mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(""String_Node_Str"" + i)) != null) {
      sendMessage(""String_Node_Str"" + i + ""String_Node_Str""+ mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(""String_Node_Str"" + i)).getPosition().x+ ""String_Node_Str""+ mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(""String_Node_Str"" + i)).getPosition().y);
    }
  }
}"
50602,"public void endGame(int action){
}","@Override public void endGame(int action){
  sendMessage(""String_Node_Str"");
  isRunning=false;
  super.endGame(action);
}"
50603,"@Override public boolean onKeyDown(int keyCode,KeyEvent event){
  if ((keyCode == KeyEvent.KEYCODE_BACK || keyCode == KeyEvent.KEYCODE_HOME) && event.getRepeatCount() == 0) {
    isRunning=false;
    Intent openStartMenu=new Intent(BotWars_MultiPlayer.this,StartMenu.class);
    startActivity(openStartMenu);
    finish();
    return true;
  }
  return super.onKeyDown(keyCode,event);
}","@Override public boolean onKeyDown(int keyCode,KeyEvent event){
  if ((keyCode == KeyEvent.KEYCODE_BACK || keyCode == KeyEvent.KEYCODE_HOME) && event.getRepeatCount() == 0) {
    isRunning=false;
    super.onKeyDown(keyCode,event);
    return true;
  }
  return super.onKeyDown(keyCode,event);
}"
50604,"@Override protected void onDestroy(){
  isRunning=false;
  super.onDestroy();
}","@Override protected void onDestroy(){
  super.onDestroy();
}"
50605,"@Override public Scene onLoadScene(){
  super.onLoadScene();
  spawnPlayer(""String_Node_Str"",super.mPlayer_MPTextureRegion);
  createLocationErrorCorrectionHandler();
  createMPHandler();
  player_mp_sprite=(AnimatedSprite)findShape(""String_Node_Str"");
  player_mp_body=super.mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(player_mp_sprite);
  startReceiverThread();
  return super.mScene;
}","@Override public Scene onLoadScene(){
  super.onLoadScene();
  spawnPlayer(""String_Node_Str"",super.mPlayer_MPTextureRegion);
  createLocationErrorCorrectionHandler();
  createMPHandler();
  player_mp_sprite=(AnimatedSprite)findShape(""String_Node_Str"");
  player_mp_body=super.mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(player_mp_sprite);
  startReceiverThread();
  mTeamScoreChangeableText=new ChangeableText(5,35,mScoreFont,""String_Node_Str"",""String_Node_Str"".length());
  mTeamScoreChangeableText.setBlendFunction(GL10.GL_SRC_ALPHA,GL10.GL_ONE_MINUS_SRC_ALPHA);
  mTeamScoreChangeableText.setAlpha(0.9f);
  mHUD.attachChild(mTeamScoreChangeableText);
  return super.mScene;
}"
50606,"private void createLocationErrorCorrectionHandler(){
  this.getEngine().registerUpdateHandler(new TimerHandler(5,true,new ITimerCallback(){
    @Override public void onTimePassed(    TimerHandler pTimerHandler){
      if (mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(""String_Node_Str"")) != null) {
        sendMessage(""String_Node_Str"" + mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(""String_Node_Str"")).getPosition().x + ""String_Node_Str""+ mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(""String_Node_Str"")).getPosition().y);
      }
      for (int i=0; i < enemyLandedArr.length; i++) {
        if (enemyLandedArr[i] && mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(""String_Node_Str"" + i)) != null) {
          sendMessage(""String_Node_Str"" + i + ""String_Node_Str""+ mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(""String_Node_Str"" + i)).getPosition().x+ ""String_Node_Str""+ mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(""String_Node_Str"" + i)).getPosition().y);
        }
      }
    }
  }
));
}","private void createLocationErrorCorrectionHandler(){
  this.getEngine().registerUpdateHandler(new TimerHandler(5,true,new ITimerCallback(){
    @Override public void onTimePassed(    TimerHandler pTimerHandler){
      if (mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(""String_Node_Str"")) != null) {
        sendMessage(""String_Node_Str"" + mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(""String_Node_Str"")).getPosition().x + ""String_Node_Str""+ mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(""String_Node_Str"")).getPosition().y);
      }
      for (int i=0; i < enemyLandedArr.length; i++) {
        if (mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(""String_Node_Str"" + i)) != null) {
          sendMessage(""String_Node_Str"" + i + ""String_Node_Str""+ mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(""String_Node_Str"" + i)).getPosition().x+ ""String_Node_Str""+ mPhysicsWorld.getPhysicsConnectorManager().findBodyByShape(findShape(""String_Node_Str"" + i)).getPosition().y);
        }
      }
    }
  }
));
}"
50607,"private void createMPHandler(){
  this.getEngine().registerUpdateHandler(new IUpdateHandler(){
    @Override public void onUpdate(    float pSecondsElapsed){
      if (spawnBullet_MP) {
        spawnBullet(player_mp_sprite,playerDir_MP,""String_Node_Str"");
        spawnBullet_MP=false;
      }
      if (desPlayerMP) {
        destroyGameObject(""String_Node_Str"");
        TextPopupScene mTextPopupScene=new TextPopupScene(BotWars_MultiPlayer.this.getEngine().getCamera(),BotWars_MultiPlayer.this.getEngine().getScene(),mScoreFont,""String_Node_Str"",5.0f);
        desPlayerMP=false;
      }
      doAICalculations(player_mp_body);
      if (remEnemy) {
        destroyGameObject(""String_Node_Str"" + remEnemyName);
      }
    }
    @Override public void reset(){
    }
  }
);
}","private void createMPHandler(){
  this.getEngine().registerUpdateHandler(new IUpdateHandler(){
    @Override public void onUpdate(    float pSecondsElapsed){
      if (spawnBullet_MP) {
        spawnBullet(player_mp_sprite,playerDir_MP,""String_Node_Str"");
        spawnBullet_MP=false;
      }
      if (desPlayerMP) {
        destroyGameObject(""String_Node_Str"");
        TextPopupScene mTextPopupScene=new TextPopupScene(BotWars_MultiPlayer.this.getEngine().getCamera(),mScene.getChildScene(),mScoreFont,""String_Node_Str"",5.0f);
        desPlayerMP=false;
      }
      doAICalculations(player_mp_body);
      if (remEnemy) {
        destroyGameObject(""String_Node_Str"" + remEnemyName);
      }
      mTeamScoreChangeableText.setText(""String_Node_Str"" + mTeamScore);
    }
    @Override public void reset(){
    }
  }
);
}"
50608,"@Override public void onUpdate(float pSecondsElapsed){
  if (spawnBullet_MP) {
    spawnBullet(player_mp_sprite,playerDir_MP,""String_Node_Str"");
    spawnBullet_MP=false;
  }
  if (desPlayerMP) {
    destroyGameObject(""String_Node_Str"");
    TextPopupScene mTextPopupScene=new TextPopupScene(BotWars_MultiPlayer.this.getEngine().getCamera(),BotWars_MultiPlayer.this.getEngine().getScene(),mScoreFont,""String_Node_Str"",5.0f);
    desPlayerMP=false;
  }
  doAICalculations(player_mp_body);
  if (remEnemy) {
    destroyGameObject(""String_Node_Str"" + remEnemyName);
  }
}","@Override public void onUpdate(float pSecondsElapsed){
  if (spawnBullet_MP) {
    spawnBullet(player_mp_sprite,playerDir_MP,""String_Node_Str"");
    spawnBullet_MP=false;
  }
  if (desPlayerMP) {
    destroyGameObject(""String_Node_Str"");
    TextPopupScene mTextPopupScene=new TextPopupScene(BotWars_MultiPlayer.this.getEngine().getCamera(),mScene.getChildScene(),mScoreFont,""String_Node_Str"",5.0f);
    desPlayerMP=false;
  }
  doAICalculations(player_mp_body);
  if (remEnemy) {
    destroyGameObject(""String_Node_Str"" + remEnemyName);
  }
  mTeamScoreChangeableText.setText(""String_Node_Str"" + mTeamScore);
}"
50609,"@Override public void prepareConfigObject(@NotNull BuildConfiguration buildConfiguration){
  super.prepareConfigObject(buildConfiguration);
  log.debug(""String_Node_Str"");
  String strHostName=buildConfiguration.getString(REPOSITORY_GERRIT_REPOSITORY_HOSTNAME,""String_Node_Str"").trim();
  buildConfiguration.setProperty(REPOSITORY_GERRIT_REPOSITORY_HOSTNAME,strHostName);
  String strPort=buildConfiguration.getString(REPOSITORY_GERRIT_REPOSITORY_PORT,""String_Node_Str"").trim();
  buildConfiguration.setProperty(REPOSITORY_GERRIT_REPOSITORY_PORT,strPort);
  String strProject=buildConfiguration.getString(REPOSITORY_GERRIT_PROJECT,""String_Node_Str"").trim();
  buildConfiguration.setProperty(REPOSITORY_GERRIT_PROJECT,strProject);
  String strUserName=buildConfiguration.getString(REPOSITORY_GERRIT_USERNAME,""String_Node_Str"").trim();
  buildConfiguration.setProperty(REPOSITORY_GERRIT_USERNAME,strUserName);
  String strPhrase=buildConfiguration.getString(TEMPORARY_GERRIT_SSH_PASSPHRASE);
  if (buildConfiguration.getBoolean(TEMPORARY_GERRIT_SSH_PASSPHRASE_CHANGE)) {
    buildConfiguration.setProperty(REPOSITORY_GERRIT_SSH_PASSPHRASE,encryptionService.encrypt(strPhrase));
  }
  String decryptedKey=""String_Node_Str"";
  if (buildConfiguration.getBoolean(TEMPORARY_GERRIT_SSH_KEY_CHANGE)) {
    final Object o=buildConfiguration.getProperty(TEMPORARY_GERRIT_SSH_KEY_FROM_FILE);
    if (o instanceof File) {
      File f=(File)o;
      try {
        decryptedKey=FileUtils.readFileToString(f);
      }
 catch (      IOException e) {
        log.error(textProvider.getText(""String_Node_Str""),e);
        return;
      }
      buildConfiguration.setProperty(REPOSITORY_GERRIT_SSH_KEY,encryptionService.encrypt(decryptedKey));
    }
 else {
      buildConfiguration.clearProperty(REPOSITORY_GERRIT_SSH_KEY);
    }
  }
 else {
    decryptedKey=encryptionService.decrypt(buildConfiguration.getString(REPOSITORY_GERRIT_SSH_KEY,""String_Node_Str""));
  }
  relativeConfigPath=this.getRelativeConfigDirectory(buildConfiguration);
  buildConfiguration.setProperty(REPOSITORY_GERRIT_CONFIG_DIR,relativeConfigPath);
  relativeSSHKeyFilePath=getRelativeRepoPath(buildConfiguration);
  File f=prepareSSHKeyFile(relativeSSHKeyFilePath,decryptedKey);
  if (f != null) {
    buildConfiguration.setProperty(REPOSITORY_GERRIT_SSH_KEY_FILE,relativeSSHKeyFilePath);
  }
}","@Override public void prepareConfigObject(@NotNull BuildConfiguration buildConfiguration){
  super.prepareConfigObject(buildConfiguration);
  log.debug(""String_Node_Str"");
  String strHostName=buildConfiguration.getString(REPOSITORY_GERRIT_REPOSITORY_HOSTNAME,""String_Node_Str"").trim();
  buildConfiguration.setProperty(REPOSITORY_GERRIT_REPOSITORY_HOSTNAME,strHostName);
  String strPort=buildConfiguration.getString(REPOSITORY_GERRIT_REPOSITORY_PORT,""String_Node_Str"").trim();
  buildConfiguration.setProperty(REPOSITORY_GERRIT_REPOSITORY_PORT,strPort);
  String strProject=buildConfiguration.getString(REPOSITORY_GERRIT_PROJECT,""String_Node_Str"").trim();
  buildConfiguration.setProperty(REPOSITORY_GERRIT_PROJECT,strProject);
  String strUserName=buildConfiguration.getString(REPOSITORY_GERRIT_USERNAME,""String_Node_Str"").trim();
  buildConfiguration.setProperty(REPOSITORY_GERRIT_USERNAME,strUserName);
  String strPhrase=buildConfiguration.getString(TEMPORARY_GERRIT_SSH_PASSPHRASE);
  if (buildConfiguration.getBoolean(TEMPORARY_GERRIT_SSH_PASSPHRASE_CHANGE)) {
    buildConfiguration.setProperty(REPOSITORY_GERRIT_SSH_PASSPHRASE,encryptionService.encrypt(strPhrase));
  }
  String decryptedKey=""String_Node_Str"";
  if (buildConfiguration.getBoolean(TEMPORARY_GERRIT_SSH_KEY_CHANGE)) {
    final Object o=buildConfiguration.getProperty(TEMPORARY_GERRIT_SSH_KEY_FROM_FILE);
    if (o instanceof File) {
      File f=(File)o;
      try {
        decryptedKey=FileUtils.readFileToString(f);
      }
 catch (      IOException e) {
        log.error(textProvider.getText(""String_Node_Str""),e);
        return;
      }
      buildConfiguration.setProperty(REPOSITORY_GERRIT_SSH_KEY,encryptionService.encrypt(decryptedKey));
    }
 else {
      buildConfiguration.clearProperty(REPOSITORY_GERRIT_SSH_KEY);
    }
  }
 else {
    decryptedKey=encryptionService.decrypt(buildConfiguration.getString(REPOSITORY_GERRIT_SSH_KEY,""String_Node_Str""));
  }
  relativeConfigPath=this.getRelativeConfigDirectory(buildConfiguration);
  buildConfiguration.setProperty(REPOSITORY_GERRIT_CONFIG_DIR,relativeConfigPath);
  relativeSSHKeyFilePath=getRelativeRepoPath(buildConfiguration);
  File f=prepareSSHKeyFile(relativeSSHKeyFilePath,decryptedKey);
  if (f != null) {
    buildConfiguration.setProperty(REPOSITORY_GERRIT_SSH_KEY_FILE,relativeSSHKeyFilePath);
  }
  String strDefBranch=buildConfiguration.getString(REPOSITORY_GERRIT_DEFAULT_BRANCH,""String_Node_Str"");
  String strCustBranch=buildConfiguration.getString(REPOSITORY_GERRIT_CUSTOM_BRANCH,""String_Node_Str"");
  if (strDefBranch.equals(MASTER_BRANCH.getName()) || strDefBranch.equals(ALL_BRANCH.getName())) {
    buildConfiguration.setProperty(REPOSITORY_GERRIT_DEFAULT_BRANCH,strDefBranch);
    buildConfiguration.setProperty(REPOSITORY_GERRIT_CUSTOM_BRANCH,strDefBranch);
    buildConfiguration.setProperty(REPOSITORY_GERRIT_BRANCH,strDefBranch);
  }
 else {
    buildConfiguration.setProperty(REPOSITORY_GERRIT_DEFAULT_BRANCH,CUSTOM_BRANCH_SET);
    buildConfiguration.setProperty(REPOSITORY_GERRIT_CUSTOM_BRANCH,strCustBranch);
    buildConfiguration.setProperty(REPOSITORY_GERRIT_BRANCH,strCustBranch);
  }
}"
50610,"@Override public void populateFromConfig(HierarchicalConfiguration config){
  super.populateFromConfig(config);
  hostname=StringUtils.trimToEmpty(config.getString(REPOSITORY_GERRIT_REPOSITORY_HOSTNAME));
  username=config.getString(REPOSITORY_GERRIT_USERNAME);
  userEmail=config.getString(REPOSITORY_GERRIT_EMAIL);
  sshKey=config.getString(REPOSITORY_GERRIT_SSH_KEY,""String_Node_Str"");
  sshPassphrase=encryptionService.decrypt(config.getString(REPOSITORY_GERRIT_SSH_PASSPHRASE));
  port=config.getInt(REPOSITORY_GERRIT_REPOSITORY_PORT,29418);
  project=config.getString(REPOSITORY_GERRIT_PROJECT);
  String strBranch=config.getString(REPOSITORY_GERRIT_BRANCH,""String_Node_Str"");
  if (StringUtils.isEmpty(strBranch)) {
    vcsBranch=DEFAULT_BRANCH;
  }
 else {
    vcsBranch=new VcsBranchImpl(strBranch);
  }
  useShallowClones=config.getBoolean(REPOSITORY_GERRIT_USE_SHALLOW_CLONES);
  useSubmodules=config.getBoolean(REPOSITORY_GERRIT_USE_SUBMODULES);
  commandTimeout=config.getInt(REPOSITORY_GERRIT_COMMAND_TIMEOUT,DEFAULT_COMMAND_TIMEOUT_IN_MINUTES);
  verboseLogs=config.getBoolean(REPOSITORY_GERRIT_VERBOSE_LOGS,false);
  String gitRepoUrl=""String_Node_Str"" + username + ""String_Node_Str""+ hostname+ ""String_Node_Str""+ port+ ""String_Node_Str""+ project;
  String tmpCP=config.getString(REPOSITORY_GERRIT_CONFIG_DIR);
  if (tmpCP == null || tmpCP.isEmpty()) {
    tmpCP=GerritService.SYSTEM_DIRECTORY + File.separator + GerritService.CONFIG_DIRECTORY;
  }
  relativeConfigPath=tmpCP.replace(""String_Node_Str"",""String_Node_Str"");
  absConfigPath=prepareConfigDir(relativeConfigPath).getAbsolutePath();
  String tmpSSHKFP=config.getString(REPOSITORY_GERRIT_SSH_KEY_FILE);
  if (tmpSSHKFP == null || tmpSSHKFP.isEmpty()) {
    tmpSSHKFP=GerritService.SYSTEM_DIRECTORY + File.separator + GerritService.CONFIG_DIRECTORY;
  }
  relativeSSHKeyFilePath=tmpSSHKFP.replace(""String_Node_Str"",""String_Node_Str"");
  String decryptedKey=encryptionService.decrypt(sshKey);
  sshKeyFile=prepareSSHKeyFile(relativeSSHKeyFilePath,decryptedKey);
  gc.setHost(hostname);
  gc.setPort(port);
  gc.setRepositoryUrl(gitRepoUrl);
  gc.setWorkingDirectory(absConfigPath);
  gc.setSshKeyFile(sshKeyFile);
  gc.setSshKey(decryptedKey);
  gc.setSshPassphrase(sshPassphrase);
  gc.setUsername(username);
  gc.setUserEmail(userEmail);
  gc.setUseShallowClones(useShallowClones);
  gc.setUseSubmodules(useSubmodules);
  gc.setVerboseLogs(verboseLogs);
  gc.setCommandTimeout(commandTimeout);
  try {
    initializeGerritService();
  }
 catch (  RepositoryException e) {
    log.error(e.getMessage());
  }
}","@Override public void populateFromConfig(HierarchicalConfiguration config){
  super.populateFromConfig(config);
  hostname=StringUtils.trimToEmpty(config.getString(REPOSITORY_GERRIT_REPOSITORY_HOSTNAME));
  username=config.getString(REPOSITORY_GERRIT_USERNAME);
  userEmail=config.getString(REPOSITORY_GERRIT_EMAIL);
  sshKey=config.getString(REPOSITORY_GERRIT_SSH_KEY,""String_Node_Str"");
  sshPassphrase=encryptionService.decrypt(config.getString(REPOSITORY_GERRIT_SSH_PASSPHRASE));
  port=config.getInt(REPOSITORY_GERRIT_REPOSITORY_PORT,29418);
  project=config.getString(REPOSITORY_GERRIT_PROJECT);
  String strDefBranch=config.getString(REPOSITORY_GERRIT_DEFAULT_BRANCH,""String_Node_Str"");
  String strCustBranch=config.getString(REPOSITORY_GERRIT_CUSTOM_BRANCH,""String_Node_Str"");
  if (strDefBranch.equals(MASTER_BRANCH.getName()) || strDefBranch.equals(ALL_BRANCH.getName())) {
    vcsBranch=new VcsBranchImpl(strDefBranch);
  }
 else {
    vcsBranch=new VcsBranchImpl(strCustBranch);
  }
  useShallowClones=config.getBoolean(REPOSITORY_GERRIT_USE_SHALLOW_CLONES);
  useSubmodules=config.getBoolean(REPOSITORY_GERRIT_USE_SUBMODULES);
  commandTimeout=config.getInt(REPOSITORY_GERRIT_COMMAND_TIMEOUT,DEFAULT_COMMAND_TIMEOUT_IN_MINUTES);
  verboseLogs=config.getBoolean(REPOSITORY_GERRIT_VERBOSE_LOGS,false);
  String gitRepoUrl=""String_Node_Str"" + username + ""String_Node_Str""+ hostname+ ""String_Node_Str""+ port+ ""String_Node_Str""+ project;
  String tmpCP=config.getString(REPOSITORY_GERRIT_CONFIG_DIR);
  if (tmpCP == null || tmpCP.isEmpty()) {
    tmpCP=GerritService.SYSTEM_DIRECTORY + File.separator + GerritService.CONFIG_DIRECTORY;
  }
  relativeConfigPath=tmpCP.replace(""String_Node_Str"",""String_Node_Str"");
  absConfigPath=prepareConfigDir(relativeConfigPath).getAbsolutePath();
  String tmpSSHKFP=config.getString(REPOSITORY_GERRIT_SSH_KEY_FILE);
  if (tmpSSHKFP == null || tmpSSHKFP.isEmpty()) {
    tmpSSHKFP=GerritService.SYSTEM_DIRECTORY + File.separator + GerritService.CONFIG_DIRECTORY;
  }
  relativeSSHKeyFilePath=tmpSSHKFP.replace(""String_Node_Str"",""String_Node_Str"");
  String decryptedKey=encryptionService.decrypt(sshKey);
  sshKeyFile=prepareSSHKeyFile(relativeSSHKeyFilePath,decryptedKey);
  gc.setHost(hostname);
  gc.setPort(port);
  gc.setRepositoryUrl(gitRepoUrl);
  gc.setWorkingDirectory(absConfigPath);
  gc.setSshKeyFile(sshKeyFile);
  gc.setSshKey(decryptedKey);
  gc.setSshPassphrase(sshPassphrase);
  gc.setUsername(username);
  gc.setUserEmail(userEmail);
  gc.setUseShallowClones(useShallowClones);
  gc.setUseSubmodules(useSubmodules);
  gc.setVerboseLogs(verboseLogs);
  gc.setCommandTimeout(commandTimeout);
  try {
    initializeGerritService();
  }
 catch (  RepositoryException e) {
    log.error(e.getMessage());
  }
}"
50611,"@Override public HierarchicalConfiguration toConfiguration(){
  HierarchicalConfiguration configuration=super.toConfiguration();
  configuration.setProperty(REPOSITORY_GERRIT_REPOSITORY_HOSTNAME,hostname);
  configuration.setProperty(REPOSITORY_GERRIT_USERNAME,username);
  configuration.setProperty(REPOSITORY_GERRIT_EMAIL,userEmail);
  configuration.setProperty(REPOSITORY_GERRIT_PROJECT,project);
  configuration.setProperty(REPOSITORY_GERRIT_BRANCH,vcsBranch.getName());
  configuration.setProperty(REPOSITORY_GERRIT_SSH_KEY,sshKey);
  configuration.setProperty(REPOSITORY_GERRIT_SSH_PASSPHRASE,encryptionService.encrypt(sshPassphrase));
  configuration.setProperty(REPOSITORY_GERRIT_CONFIG_DIR,relativeConfigPath);
  configuration.setProperty(REPOSITORY_GERRIT_SSH_KEY_FILE,relativeSSHKeyFilePath);
  configuration.setProperty(REPOSITORY_GERRIT_REPOSITORY_PORT,port);
  configuration.setProperty(REPOSITORY_GERRIT_USE_SHALLOW_CLONES,useShallowClones);
  configuration.setProperty(REPOSITORY_GERRIT_USE_SUBMODULES,useSubmodules);
  configuration.setProperty(REPOSITORY_GERRIT_COMMAND_TIMEOUT,commandTimeout);
  configuration.setProperty(REPOSITORY_GERRIT_VERBOSE_LOGS,verboseLogs);
  return configuration;
}","@Override public HierarchicalConfiguration toConfiguration(){
  HierarchicalConfiguration configuration=super.toConfiguration();
  configuration.setProperty(REPOSITORY_GERRIT_REPOSITORY_HOSTNAME,hostname);
  configuration.setProperty(REPOSITORY_GERRIT_USERNAME,username);
  configuration.setProperty(REPOSITORY_GERRIT_EMAIL,userEmail);
  configuration.setProperty(REPOSITORY_GERRIT_PROJECT,project);
  if (!vcsBranch.equals(MASTER_BRANCH) && !vcsBranch.equals(ALL_BRANCH)) {
    configuration.setProperty(REPOSITORY_GERRIT_DEFAULT_BRANCH,CUSTOM_BRANCH_SET);
    configuration.setProperty(REPOSITORY_GERRIT_CUSTOM_BRANCH,vcsBranch.getName());
  }
 else {
    String br=vcsBranch.getName();
    configuration.setProperty(REPOSITORY_GERRIT_DEFAULT_BRANCH,br);
    configuration.setProperty(REPOSITORY_GERRIT_CUSTOM_BRANCH,br);
  }
  configuration.setProperty(REPOSITORY_GERRIT_BRANCH,vcsBranch.getName());
  configuration.setProperty(REPOSITORY_GERRIT_SSH_KEY,sshKey);
  configuration.setProperty(REPOSITORY_GERRIT_SSH_PASSPHRASE,encryptionService.encrypt(sshPassphrase));
  configuration.setProperty(REPOSITORY_GERRIT_CONFIG_DIR,relativeConfigPath);
  configuration.setProperty(REPOSITORY_GERRIT_SSH_KEY_FILE,relativeSSHKeyFilePath);
  configuration.setProperty(REPOSITORY_GERRIT_REPOSITORY_PORT,port);
  configuration.setProperty(REPOSITORY_GERRIT_USE_SHALLOW_CLONES,useShallowClones);
  configuration.setProperty(REPOSITORY_GERRIT_USE_SUBMODULES,useSubmodules);
  configuration.setProperty(REPOSITORY_GERRIT_COMMAND_TIMEOUT,commandTimeout);
  configuration.setProperty(REPOSITORY_GERRIT_VERBOSE_LOGS,verboseLogs);
  return configuration;
}"
50612,"@Override public BuildRepositoryChanges collectChangesSinceLastBuild(String planKey,String lastVcsRevisionKey) throws RepositoryException {
  final BuildLogger buildLogger=buildLoggerManager.getLogger(PlanKeys.getPlanKey(planKey));
  List<Commit> commits=new ArrayList<Commit>();
  GerritChangeVO change=null;
  if (this.getVcsBranch().equals(DEFAULT_BRANCH)) {
    change=getGerritDAO().getLastUnverifiedChange(project);
    if (change == null) {
      change=getGerritDAO().getLastChange(project);
    }
  }
 else {
    change=getGerritDAO().getLastUnverifiedChange(project,this.getVcsBranch().getName());
    if (change == null) {
      change=getGerritDAO().getLastChange(project,this.getVcsBranch().getName());
    }
  }
  log.debug(String.format(""String_Node_Str"",change.getBranch(),change.getId(),change.getCurrentPatchSet().getRef()));
  buildLogger.addBuildLogEntry(textProvider.getText(""String_Node_Str""));
  if ((change == null) && ((lastVcsRevisionKey == null) || lastVcsRevisionKey.isEmpty())) {
    throw new RepositoryException(textProvider.getText(""String_Node_Str""));
  }
 else   if (lastVcsRevisionKey == null) {
    buildLogger.addBuildLogEntry(textProvider.getText(""String_Node_Str"",Arrays.asList(change.getLastRevision())));
  }
 else   if (change.getLastRevision().equals(lastVcsRevisionKey)) {
    Object lastRevForChange=bandanaManager.getValue(PlanAwareBandanaContext.GLOBAL_CONTEXT,change.getId());
    if ((lastRevForChange != null) && lastRevForChange.equals(change.getLastRevision()))     return new BuildRepositoryChangesImpl(change.getLastRevision());
  }
  commits.add(convertChangeToCommit(change,true));
  BuildRepositoryChanges buildChanges=new BuildRepositoryChangesImpl(change.getLastRevision(),commits);
  bandanaManager.setValue(PlanAwareBandanaContext.GLOBAL_CONTEXT,change.getId(),change.getLastRevision());
  return buildChanges;
}","@Override public BuildRepositoryChanges collectChangesSinceLastBuild(String planKey,String lastVcsRevisionKey) throws RepositoryException {
  final BuildLogger buildLogger=buildLoggerManager.getLogger(PlanKeys.getPlanKey(planKey));
  List<Commit> commits=new ArrayList<Commit>();
  GerritChangeVO change=null;
  if (this.getVcsBranch().equals(ALL_BRANCH)) {
    change=getGerritDAO().getLastUnverifiedChange(project);
    if (change == null) {
      change=getGerritDAO().getLastChange(project);
    }
  }
 else {
    change=getGerritDAO().getLastUnverifiedChange(project,this.getVcsBranch().getName());
    if (change == null) {
      change=getGerritDAO().getLastChange(project,this.getVcsBranch().getName());
    }
  }
  log.debug(String.format(""String_Node_Str"",change.getBranch(),change.getId(),change.getCurrentPatchSet().getRef()));
  buildLogger.addBuildLogEntry(textProvider.getText(""String_Node_Str""));
  if ((change == null) && ((lastVcsRevisionKey == null) || lastVcsRevisionKey.isEmpty())) {
    throw new RepositoryException(textProvider.getText(""String_Node_Str""));
  }
 else   if (lastVcsRevisionKey == null) {
    buildLogger.addBuildLogEntry(textProvider.getText(""String_Node_Str"",Arrays.asList(change.getLastRevision())));
  }
 else   if (change.getLastRevision().equals(lastVcsRevisionKey)) {
    Object lastRevForChange=bandanaManager.getValue(PlanAwareBandanaContext.GLOBAL_CONTEXT,change.getId());
    if ((lastRevForChange != null) && lastRevForChange.equals(change.getLastRevision()))     return new BuildRepositoryChangesImpl(change.getLastRevision());
  }
  commits.add(convertChangeToCommit(change,true));
  BuildRepositoryChanges buildChanges=new BuildRepositoryChangesImpl(change.getLastRevision(),commits);
  bandanaManager.setValue(PlanAwareBandanaContext.GLOBAL_CONTEXT,change.getId(),change.getLastRevision());
  return buildChanges;
}"
50613,"public GerritService(String strHost,Authentication auth){
  this.strHost=strHost;
  this.auth=auth;
}","public GerritService(String strHost,int port,Authentication auth){
  this.strHost=strHost;
  this.port=port;
  this.auth=auth;
}"
50614,"private void updateChangeVerification(RepositoryDefinition rd,String buildPlanKey,CurrentBuildResult results) throws RepositoryException {
  final GerritRepositoryAdapter gra=(GerritRepositoryAdapter)rd.getRepository();
  final String revision=buildContext.getBuildChanges().getVcsRevisionKey(rd.getId());
  final GerritService service=new GerritService(gra.getHostname(),gra.getGerritAuthentication());
  final GerritChangeVO change=service.getChangeByRevision(revision);
  if (change == null) {
    logger.error(textProvider.getText(""String_Node_Str""));
    return;
  }
 else   if (change.isMerged()) {
    logger.info(textProvider.getText(""String_Node_Str"",Arrays.asList(change.getId())));
    return;
  }
  if ((results.getBuildReturnCode() == 0) && results.getBuildState().equals(BuildState.SUCCESS)) {
    if (service.verifyChange(true,change.getNumber(),change.getCurrentPatchSet().getNumber(),buildStatusString(results)))     logger.info(textProvider.getText(""String_Node_Str""));
 else {
      logger.error(textProvider.getText(""String_Node_Str"",Arrays.asList(change.getId())));
    }
  }
 else   if (service.verifyChange(false,change.getNumber(),change.getCurrentPatchSet().getNumber(),buildStatusString(results))) {
    logger.info(textProvider.getText(""String_Node_Str""));
  }
 else {
    logger.error(textProvider.getText(""String_Node_Str"",Arrays.asList(change.getId())));
  }
}","private void updateChangeVerification(RepositoryDefinition rd,String buildPlanKey,CurrentBuildResult results) throws RepositoryException {
  final GerritRepositoryAdapter gra=(GerritRepositoryAdapter)rd.getRepository();
  final String revision=buildContext.getBuildChanges().getVcsRevisionKey(rd.getId());
  final GerritService service=new GerritService(gra.getHostname(),gra.getPort(),gra.getGerritAuthentication());
  final GerritChangeVO change=service.getChangeByRevision(revision);
  if (change == null) {
    logger.error(textProvider.getText(""String_Node_Str""));
    return;
  }
 else   if (change.isMerged()) {
    logger.info(textProvider.getText(""String_Node_Str"",Arrays.asList(change.getId())));
    return;
  }
  if ((results.getBuildReturnCode() == 0) && results.getBuildState().equals(BuildState.SUCCESS)) {
    if (service.verifyChange(true,change.getNumber(),change.getCurrentPatchSet().getNumber(),buildStatusString(results)))     logger.info(textProvider.getText(""String_Node_Str""));
 else {
      logger.error(textProvider.getText(""String_Node_Str"",Arrays.asList(change.getId())));
    }
  }
 else   if (service.verifyChange(false,change.getNumber(),change.getCurrentPatchSet().getNumber(),buildStatusString(results))) {
    logger.info(textProvider.getText(""String_Node_Str""));
  }
 else {
    logger.error(textProvider.getText(""String_Node_Str"",Arrays.asList(change.getId())));
  }
}"
50615,"@Override public void prepareConfigObject(@NotNull BuildConfiguration buildConfiguration){
  String strHostName=buildConfiguration.getString(REPOSITORY_GERRIT_REPOSITORY_HOSTNAME,""String_Node_Str"").trim();
  buildConfiguration.setProperty(REPOSITORY_GERRIT_REPOSITORY_HOSTNAME,strHostName);
  String strPort=buildConfiguration.getString(REPOSITORY_GERRIT_REPOSITORY_PORT,""String_Node_Str"").trim();
  buildConfiguration.setProperty(REPOSITORY_GERRIT_REPOSITORY_PORT,strPort);
  String strProject=buildConfiguration.getString(REPOSITORY_GERRIT_PROJECT,""String_Node_Str"").trim();
  buildConfiguration.setProperty(REPOSITORY_GERRIT_PROJECT,strProject);
  String strUserName=buildConfiguration.getString(REPOSITORY_GERRIT_USERNAME,""String_Node_Str"").trim();
  buildConfiguration.setProperty(REPOSITORY_GERRIT_USERNAME,strUserName);
  String strPhrase=buildConfiguration.getString(TEMPORARY_GERRIT_SSH_PASSPHRASE);
  if (buildConfiguration.getBoolean(TEMPORARY_GERRIT_SSH_PASSPHRASE_CHANGE)) {
    buildConfiguration.setProperty(REPOSITORY_GERRIT_SSH_PASSPHRASE,encrypterRef.get().encrypt(strPhrase));
  }
 else   if (strPhrase == null) {
    strPhrase=buildConfiguration.getString(REPOSITORY_GERRIT_SSH_PASSPHRASE,""String_Node_Str"");
  }
  String key=""String_Node_Str"";
  if (buildConfiguration.getBoolean(TEMPORARY_GERRIT_SSH_KEY_CHANGE)) {
    final Object o=buildConfiguration.getProperty(TEMPORARY_GERRIT_SSH_KEY_FROM_FILE);
    if (o instanceof File) {
      File f=(File)o;
      try {
        key=FileUtils.readFileToString(f);
      }
 catch (      IOException e) {
        log.error(textProvider.getText(""String_Node_Str""),e);
        return;
      }
      buildConfiguration.setProperty(REPOSITORY_GERRIT_SSH_KEY,encrypterRef.get().encrypt(key));
    }
 else {
      buildConfiguration.clearProperty(REPOSITORY_GERRIT_SSH_KEY);
    }
  }
 else   if (key.isEmpty()) {
    key=encrypterRef.get().decrypt(buildConfiguration.getString(REPOSITORY_GERRIT_SSH_KEY,""String_Node_Str""));
  }
  File file=prepareSSHKeyFile(buildConfiguration,key);
  buildConfiguration.setProperty(REPOSITORY_GERRIT_SSH_KEY_FILE,file.getAbsolutePath());
}","@Override public void prepareConfigObject(@NotNull BuildConfiguration buildConfiguration){
  String strHostName=buildConfiguration.getString(REPOSITORY_GERRIT_REPOSITORY_HOSTNAME,""String_Node_Str"").trim();
  buildConfiguration.setProperty(REPOSITORY_GERRIT_REPOSITORY_HOSTNAME,strHostName);
  String strPort=buildConfiguration.getString(REPOSITORY_GERRIT_REPOSITORY_PORT,""String_Node_Str"").trim();
  buildConfiguration.setProperty(REPOSITORY_GERRIT_REPOSITORY_PORT,strPort);
  String strProject=buildConfiguration.getString(REPOSITORY_GERRIT_PROJECT,""String_Node_Str"").trim();
  buildConfiguration.setProperty(REPOSITORY_GERRIT_PROJECT,strProject);
  String strUserName=buildConfiguration.getString(REPOSITORY_GERRIT_USERNAME,""String_Node_Str"").trim();
  buildConfiguration.setProperty(REPOSITORY_GERRIT_USERNAME,strUserName);
  String strPhrase=buildConfiguration.getString(TEMPORARY_GERRIT_SSH_PASSPHRASE);
  if (buildConfiguration.getBoolean(TEMPORARY_GERRIT_SSH_PASSPHRASE_CHANGE)) {
    buildConfiguration.setProperty(REPOSITORY_GERRIT_SSH_PASSPHRASE,encrypterRef.get().encrypt(strPhrase));
  }
 else   if (strPhrase == null) {
    strPhrase=buildConfiguration.getString(REPOSITORY_GERRIT_SSH_PASSPHRASE,""String_Node_Str"");
  }
  String key=""String_Node_Str"";
  if (buildConfiguration.getBoolean(TEMPORARY_GERRIT_SSH_KEY_CHANGE)) {
    final Object o=buildConfiguration.getProperty(TEMPORARY_GERRIT_SSH_KEY_FROM_FILE);
    if (o instanceof File) {
      File f=(File)o;
      try {
        key=FileUtils.readFileToString(f);
      }
 catch (      IOException e) {
        log.error(textProvider.getText(""String_Node_Str""),e);
        return;
      }
      buildConfiguration.setProperty(REPOSITORY_GERRIT_SSH_KEY,encrypterRef.get().encrypt(key));
    }
 else {
      buildConfiguration.clearProperty(REPOSITORY_GERRIT_SSH_KEY);
    }
  }
 else   if (key.isEmpty()) {
    key=encrypterRef.get().decrypt(buildConfiguration.getString(REPOSITORY_GERRIT_SSH_KEY,""String_Node_Str""));
  }
  relativeSSHKeyFilePath=getRelativeRepoPath(buildConfiguration);
  File f=prepareSSHKeyFile(relativeSSHKeyFilePath,key);
  if (f != null) {
    buildConfiguration.setProperty(REPOSITORY_GERRIT_SSH_KEY_FILE,relativeSSHKeyFilePath);
  }
}"
50616,"@Override public void populateFromConfig(HierarchicalConfiguration config){
  super.populateFromConfig(config);
  hostname=StringUtils.trimToEmpty(config.getString(REPOSITORY_GERRIT_REPOSITORY_HOSTNAME));
  username=config.getString(REPOSITORY_GERRIT_USERNAME);
  sshKey=config.getString(REPOSITORY_GERRIT_SSH_KEY,""String_Node_Str"");
  sshKeyFile=new File(config.getString(REPOSITORY_GERRIT_SSH_KEY_FILE));
  sshPassphrase=config.getString(REPOSITORY_GERRIT_SSH_PASSPHRASE);
  port=config.getInt(REPOSITORY_GERRIT_REPOSITORY_PORT,29418);
  project=config.getString(REPOSITORY_GERRIT_PROJECT);
  useShallowClones=config.getBoolean(REPOSITORY_GERRIT_USE_SHALLOW_CLONES);
  useSubmodules=config.getBoolean(REPOSITORY_GERRIT_USE_SUBMODULES);
  commandTimeout=config.getInt(REPOSITORY_GERRIT_COMMAND_TIMEOUT,DEFAULT_COMMAND_TIMEOUT_IN_MINUTES);
  verboseLogs=config.getBoolean(REPOSITORY_GERRIT_VERBOSE_LOGS,false);
  String gitRepoUrl=""String_Node_Str"" + username + ""String_Node_Str""+ hostname+ ""String_Node_Str""+ port+ ""String_Node_Str""+ project;
  GitRepoFactory.configureSSHGitRepository(this.gitRepository,gitRepoUrl,username,""String_Node_Str"",GitRepoFactory.MASTER_BRANCH,this.sshKeyFile,sshPassphrase,this.useShallowClones,this.useSubmodules,this.commandTimeout,this.verboseLogs,this.textProvider);
}","@Override public void populateFromConfig(HierarchicalConfiguration config){
  super.populateFromConfig(config);
  hostname=StringUtils.trimToEmpty(config.getString(REPOSITORY_GERRIT_REPOSITORY_HOSTNAME));
  username=config.getString(REPOSITORY_GERRIT_USERNAME);
  sshKey=config.getString(REPOSITORY_GERRIT_SSH_KEY,""String_Node_Str"");
  sshPassphrase=config.getString(REPOSITORY_GERRIT_SSH_PASSPHRASE);
  port=config.getInt(REPOSITORY_GERRIT_REPOSITORY_PORT,29418);
  project=config.getString(REPOSITORY_GERRIT_PROJECT);
  useShallowClones=config.getBoolean(REPOSITORY_GERRIT_USE_SHALLOW_CLONES);
  useSubmodules=config.getBoolean(REPOSITORY_GERRIT_USE_SUBMODULES);
  commandTimeout=config.getInt(REPOSITORY_GERRIT_COMMAND_TIMEOUT,DEFAULT_COMMAND_TIMEOUT_IN_MINUTES);
  verboseLogs=config.getBoolean(REPOSITORY_GERRIT_VERBOSE_LOGS,false);
  String gitRepoUrl=""String_Node_Str"" + username + ""String_Node_Str""+ hostname+ ""String_Node_Str""+ port+ ""String_Node_Str""+ project;
  relativeSSHKeyFilePath=config.getString(REPOSITORY_GERRIT_SSH_KEY_FILE);
  String decryptedKey=encrypterRef.get().decrypt(sshKey);
  sshKeyFile=prepareSSHKeyFile(relativeSSHKeyFilePath,decryptedKey);
  GitRepoFactory.configureSSHGitRepository(this.gitRepository,gitRepoUrl,username,""String_Node_Str"",GitRepoFactory.MASTER_BRANCH,this.sshKeyFile,sshPassphrase,this.useShallowClones,this.useSubmodules,this.commandTimeout,this.verboseLogs,this.textProvider);
}"
50617,"@Override public HierarchicalConfiguration toConfiguration(){
  HierarchicalConfiguration configuration=super.toConfiguration();
  configuration.setProperty(REPOSITORY_GERRIT_REPOSITORY_HOSTNAME,hostname);
  configuration.setProperty(REPOSITORY_GERRIT_USERNAME,username);
  configuration.setProperty(REPOSITORY_GERRIT_PROJECT,project);
  configuration.setProperty(REPOSITORY_GERRIT_SSH_KEY,sshKey);
  configuration.setProperty(REPOSITORY_GERRIT_SSH_PASSPHRASE,sshPassphrase);
  configuration.setProperty(REPOSITORY_GERRIT_SSH_KEY_FILE,sshKeyFile);
  configuration.setProperty(REPOSITORY_GERRIT_REPOSITORY_PORT,port);
  configuration.setProperty(REPOSITORY_GERRIT_USE_SHALLOW_CLONES,useShallowClones);
  configuration.setProperty(REPOSITORY_GERRIT_USE_SUBMODULES,useSubmodules);
  configuration.setProperty(REPOSITORY_GERRIT_COMMAND_TIMEOUT,commandTimeout);
  configuration.setProperty(REPOSITORY_GERRIT_VERBOSE_LOGS,verboseLogs);
  return configuration;
}","@Override public HierarchicalConfiguration toConfiguration(){
  HierarchicalConfiguration configuration=super.toConfiguration();
  configuration.setProperty(REPOSITORY_GERRIT_REPOSITORY_HOSTNAME,hostname);
  configuration.setProperty(REPOSITORY_GERRIT_USERNAME,username);
  configuration.setProperty(REPOSITORY_GERRIT_PROJECT,project);
  configuration.setProperty(REPOSITORY_GERRIT_SSH_KEY,sshKey);
  configuration.setProperty(REPOSITORY_GERRIT_SSH_PASSPHRASE,sshPassphrase);
  configuration.setProperty(REPOSITORY_GERRIT_SSH_KEY_FILE,relativeSSHKeyFilePath);
  configuration.setProperty(REPOSITORY_GERRIT_REPOSITORY_PORT,port);
  configuration.setProperty(REPOSITORY_GERRIT_USE_SHALLOW_CLONES,useShallowClones);
  configuration.setProperty(REPOSITORY_GERRIT_USE_SUBMODULES,useSubmodules);
  configuration.setProperty(REPOSITORY_GERRIT_COMMAND_TIMEOUT,commandTimeout);
  configuration.setProperty(REPOSITORY_GERRIT_VERBOSE_LOGS,verboseLogs);
  return configuration;
}"
50618,"@Override public ErrorCollection validate(BuildConfiguration buildConfiguration){
  boolean error=false;
  ErrorCollection errorCollection=super.validate(buildConfiguration);
  String hostame=StringUtils.trim(buildConfiguration.getString(REPOSITORY_GERRIT_REPOSITORY_HOSTNAME));
  if (!StringUtils.isNotBlank(hostame)) {
    errorCollection.addError(REPOSITORY_GERRIT_REPOSITORY_HOSTNAME,""String_Node_Str"");
    error=true;
  }
  String strPort=buildConfiguration.getString(REPOSITORY_GERRIT_REPOSITORY_PORT,""String_Node_Str"").trim();
  if (!StringUtils.isNotBlank(strPort)) {
    errorCollection.addError(REPOSITORY_GERRIT_REPOSITORY_PORT,""String_Node_Str"");
    error=true;
  }
  String strProject=buildConfiguration.getString(REPOSITORY_GERRIT_PROJECT,""String_Node_Str"").trim();
  if (!StringUtils.isNotBlank(strProject)) {
    errorCollection.addError(REPOSITORY_GERRIT_PROJECT,""String_Node_Str"");
    error=true;
  }
  String username=StringUtils.trim(buildConfiguration.getString(REPOSITORY_GERRIT_USERNAME));
  if (!StringUtils.isNotBlank(username)) {
    errorCollection.addError(REPOSITORY_GERRIT_USERNAME,""String_Node_Str"");
    error=true;
  }
  if (buildConfiguration.getBoolean(TEMPORARY_GERRIT_SSH_KEY_CHANGE)) {
    final Object o=buildConfiguration.getProperty(TEMPORARY_GERRIT_SSH_KEY_FROM_FILE);
    if (o == null) {
      errorCollection.addError(REPOSITORY_GERRIT_SSH_KEY,textProvider.getText(""String_Node_Str""));
      error=true;
    }
  }
  String key=encrypterRef.get().decrypt(buildConfiguration.getString(REPOSITORY_GERRIT_SSH_KEY,""String_Node_Str""));
  if (!StringUtils.isNotBlank(key)) {
    errorCollection.addError(REPOSITORY_GERRIT_SSH_KEY,textProvider.getText(""String_Node_Str""));
    error=true;
  }
  String strPhrase=buildConfiguration.getString(TEMPORARY_GERRIT_SSH_PASSPHRASE);
  if (buildConfiguration.getBoolean(TEMPORARY_GERRIT_SSH_PASSPHRASE_CHANGE)) {
    strPhrase=encrypterRef.get().encrypt(strPhrase);
  }
 else   if (strPhrase == null) {
    strPhrase=buildConfiguration.getString(REPOSITORY_GERRIT_SSH_PASSPHRASE,""String_Node_Str"");
  }
  String keyFilePath=buildConfiguration.getString(REPOSITORY_GERRIT_SSH_KEY_FILE);
  if (!StringUtils.isNotBlank(keyFilePath)) {
    errorCollection.addError(REPOSITORY_GERRIT_SSH_KEY_FILE,""String_Node_Str"");
    error=true;
  }
  if (error)   return errorCollection;
  try {
    testGerritConnection(keyFilePath,hostame,Integer.valueOf(strPort),username,strProject,strPhrase);
  }
 catch (  RepositoryException e) {
    errorCollection.addError(REPOSITORY_GERRIT_REPOSITORY_HOSTNAME,e.getMessage());
  }
  return errorCollection;
}","@Override public ErrorCollection validate(BuildConfiguration buildConfiguration){
  boolean error=false;
  ErrorCollection errorCollection=super.validate(buildConfiguration);
  String hostame=StringUtils.trim(buildConfiguration.getString(REPOSITORY_GERRIT_REPOSITORY_HOSTNAME));
  if (!StringUtils.isNotBlank(hostame)) {
    errorCollection.addError(REPOSITORY_GERRIT_REPOSITORY_HOSTNAME,""String_Node_Str"");
    error=true;
  }
  String strPort=buildConfiguration.getString(REPOSITORY_GERRIT_REPOSITORY_PORT,""String_Node_Str"").trim();
  if (!StringUtils.isNotBlank(strPort)) {
    errorCollection.addError(REPOSITORY_GERRIT_REPOSITORY_PORT,""String_Node_Str"");
    error=true;
  }
  String strProject=buildConfiguration.getString(REPOSITORY_GERRIT_PROJECT,""String_Node_Str"").trim();
  if (!StringUtils.isNotBlank(strProject)) {
    errorCollection.addError(REPOSITORY_GERRIT_PROJECT,""String_Node_Str"");
    error=true;
  }
  String username=StringUtils.trim(buildConfiguration.getString(REPOSITORY_GERRIT_USERNAME));
  if (!StringUtils.isNotBlank(username)) {
    errorCollection.addError(REPOSITORY_GERRIT_USERNAME,""String_Node_Str"");
    error=true;
  }
  if (buildConfiguration.getBoolean(TEMPORARY_GERRIT_SSH_KEY_CHANGE)) {
    final Object o=buildConfiguration.getProperty(TEMPORARY_GERRIT_SSH_KEY_FROM_FILE);
    if (o == null) {
      errorCollection.addError(REPOSITORY_GERRIT_SSH_KEY,textProvider.getText(""String_Node_Str""));
      error=true;
    }
  }
  String key=encrypterRef.get().decrypt(buildConfiguration.getString(REPOSITORY_GERRIT_SSH_KEY,""String_Node_Str""));
  if (!StringUtils.isNotBlank(key)) {
    errorCollection.addError(REPOSITORY_GERRIT_SSH_KEY,textProvider.getText(""String_Node_Str""));
    error=true;
  }
  String strPhrase=buildConfiguration.getString(TEMPORARY_GERRIT_SSH_PASSPHRASE);
  if (buildConfiguration.getBoolean(TEMPORARY_GERRIT_SSH_PASSPHRASE_CHANGE)) {
    strPhrase=encrypterRef.get().encrypt(strPhrase);
  }
 else   if (strPhrase == null) {
    strPhrase=buildConfiguration.getString(REPOSITORY_GERRIT_SSH_PASSPHRASE,""String_Node_Str"");
  }
  String keyFilePath=buildConfiguration.getString(REPOSITORY_GERRIT_SSH_KEY_FILE);
  if (!StringUtils.isNotBlank(keyFilePath)) {
    errorCollection.addError(REPOSITORY_GERRIT_SSH_KEY_FILE,""String_Node_Str"");
    error=true;
  }
  if (error)   return errorCollection;
  try {
    testGerritConnection(keyFilePath,key,hostame,Integer.valueOf(strPort),username,strProject,strPhrase);
  }
 catch (  RepositoryException e) {
    errorCollection.addError(REPOSITORY_GERRIT_REPOSITORY_HOSTNAME,e.getMessage());
  }
  return errorCollection;
}"
50619,"public File prepareSSHKeyFile(BuildConfiguration buildConfiguration,String sshKey){
  String planKey=buildConfiguration.getString(REPOSITORY_GERRIT_PLAN_KEY);
  String repoDisplayName=buildConfiguration.getString(REPOSITORY_GERRIT_REPO_DISP_NAME);
  File parentDirectoryFile=this.buildDirectoryManager.getBaseBuildWorkingDirectory();
  String parentDirectory=parentDirectoryFile.getAbsolutePath();
  String workingDirectory=parentDirectory + File.separator + this.getShortKey();
  if (planKey != null) {
    workingDirectory=workingDirectory + File.separator + planKey;
  }
  workingDirectory=workingDirectory + File.separator + REPOSITORY_GERRIT_STORAGE;
  if (repoDisplayName != null) {
    workingDirectory=workingDirectory + File.separator + repoDisplayName;
  }
  File f=new File(workingDirectory + ""String_Node_Str"");
  try {
    FileUtils.writeStringToFile(f,sshKey);
  }
 catch (  IOException e) {
    log.error(e.getMessage());
  }
  return f;
}","public File prepareSSHKeyFile(String strRelativePath,String sshKey){
  String filePath=getBaseBuildWorkingDirectory() + File.separator + strRelativePath;
  File f=new File(filePath);
  try {
    FileUtils.writeStringToFile(f,sshKey);
  }
 catch (  IOException e) {
    log.error(e.getMessage());
    return null;
  }
  return f;
}"
50620,"public void testGerritConnection(String sshKeyFile,String strHost,int port,String strUsername,String strProject,String phrase) throws RepositoryException {
  SshConnection sshConnection=null;
  File f=new File(sshKeyFile);
  if (!f.isFile()) {
    throw new RepositoryException(textProvider.getText(""String_Node_Str""));
  }
  Authentication auth=new Authentication(f,strUsername,phrase);
  try {
    sshConnection=SshConnectionFactory.getConnection(strHost,port,auth);
  }
 catch (  IOException e) {
    throw new RepositoryException(textProvider.getText(""String_Node_Str""));
  }
  if (!sshConnection.isConnected()) {
    throw new RepositoryException(textProvider.getText(""String_Node_Str""));
  }
 else {
    sshConnection.disconnect();
  }
}","public void testGerritConnection(String sshKeyFile,String key,String strHost,int port,String strUsername,String strProject,String phrase) throws RepositoryException {
  SshConnection sshConnection=null;
  File f=prepareSSHKeyFile(sshKeyFile,key);
  if (!f.isFile()) {
    throw new RepositoryException(textProvider.getText(""String_Node_Str""));
  }
  Authentication auth=new Authentication(f,strUsername,phrase);
  try {
    sshConnection=SshConnectionFactory.getConnection(strHost,port,auth);
  }
 catch (  IOException e) {
    throw new RepositoryException(textProvider.getText(""String_Node_Str""));
  }
  if (!sshConnection.isConnected()) {
    throw new RepositoryException(textProvider.getText(""String_Node_Str""));
  }
 else {
    sshConnection.disconnect();
  }
}"
50621,"/** 
 * Sets the flag that indicates whether the input field is required or not
 * @author Alec Erasmus<alec.erasmus@a24group.com>
 * @since 08 July 2013
 * @param required - The flag that indicates whether the input field is required or not
 */
@Override public void setRequired(boolean required){
  this.required=required;
}","/** 
 * Sets the flag that indicates whether the input field is required or not
 * @author Ruan Naude <ruan.naude@a24group.com>
 * @since 15 June 2015
 * @param required - The flag that indicates whether the input field is required or not
 */
@Override public void setRequired(boolean required){
  this.required=required;
}"
50622,"/** 
 * Class constructor
 * @author Ruan Naude <runa.naude@a24group.com>
 * @since 12 June 2015
 * @param minDate - The minimum start date
 * @param maxDate - The maximum start date
 * @param selectedDate - The default selected date
 * @param minShiftTime - The minimum shift length in milliseconds
 * @param maxShiftTime - The maximum shift length in milliseconds
 * @param hoursStep - The step to increase the hours with
 * @param minuteStep - The step to increase the minutes with
 */
public ShiftInputField(SSDate minDate,SSDate maxDate,SSDate selectedDate,long minShiftTime,long maxShiftTime,int hoursStep,int minuteStep){
  super(minDate,maxDate,selectedDate,minShiftTime,maxShiftTime,hoursStep,minuteStep);
}","/** 
 * Class constructor
 * @author Ruan Naude <ruan.naude@a24group.com>
 * @since 12 June 2015
 * @param minDate - The minimum start date
 * @param maxDate - The maximum start date
 * @param selectedDate - The default selected date
 * @param minShiftTime - The minimum shift length in milliseconds
 * @param maxShiftTime - The maximum shift length in milliseconds
 * @param hoursStep - The step to increase the hours with
 * @param minuteStep - The step to increase the minutes with
 */
public ShiftInputField(SSDate minDate,SSDate maxDate,SSDate selectedDate,long minShiftTime,long maxShiftTime,int hoursStep,int minuteStep){
  super(minDate,maxDate,selectedDate,minShiftTime,maxShiftTime,hoursStep,minuteStep);
}"
50623,"/** 
 * This method will be used to reset the time to 00:00:00
 * @author Michael Barnard <michael.barnard@a24group.com>
 * @since  21 July 2015
 * @return void
 */
public void resetTime(){
  this.setHours(0);
  this.setMinutes(0);
  this.setSeconds(0);
}","/** 
 * This method will be used to reset the time to 00:00:00
 * @author Michael Barnard <michael.barnard@a24group.com>
 * @since  21 July 2015
 * @return void
 */
public void resetTime(){
  this.setDirectTime(0,0,0);
}"
50624,"/** 
 * Get the total number min and hours of a shift. Note the max date time is 24 hours. If the the diff is 0 is seen as a 24h shift
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since 15 May 2013
 * @param startDate - The shift start date
 * @param endDate - The shift end date
 * @return the shift is format ""(H.M)""
 */
public String getShiftTimeDiff(SSDate startDate,SSDate endDate){
  if (minutesStep == 15) {
    boolean reversed=false;
    if (endDate.getTime() < startDate.getTime() - 1000) {
      reversed=true;
    }
    int shiftTotalHours=(int)(((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60)));
    int shiftTotalMin=(int)(((endDate.getTime() - startDate.getTime()) / (1000 * 60)) % 60);
    if (shiftTotalMin == 59) {
      shiftTotalMin=0;
      shiftTotalHours++;
    }
 else     if (shiftTotalMin % 15 == 14) {
      shiftTotalMin++;
    }
    int totalMinAndHours=(shiftTotalHours * 60) + shiftTotalMin;
    if (totalMinAndHours >= 1441 || totalMinAndHours <= 1439) {
      if (endDate.getTime() - startDate.getTime() > 86399000) {
        shiftTotalHours=24;
        totalMinAndHours=1440;
        shiftTotalMin=0;
      }
    }
    if (((15 - (shiftTotalMin % 15) < 1)) || (totalMinAndHours > 1440) || reversed) {
      return ""String_Node_Str"";
    }
    if (shiftTotalMin == 0) {
      return ""String_Node_Str"" + shiftTotalHours + ""String_Node_Str"";
    }
    String displayedMinutes=String.valueOf((int)((Math.ceil(shiftTotalMin) / 60) * 100)).replaceAll(""String_Node_Str"",""String_Node_Str"");
    return ""String_Node_Str"" + shiftTotalHours + ""String_Node_Str""+ displayedMinutes+ ""String_Node_Str"";
  }
 else {
    float shiftTotalMinutes=(endDate.getTime() - startDate.getTime()) / 1000 / 60;
    int hours=(int)(shiftTotalMinutes / 60);
    int min=(int)(shiftTotalMinutes - (hours * 60));
    String totalTimeString=TOTAL_TIME_FORMAT_START + hours + TOTAL_TIME_FORMAT_HOURS;
    if (min < 10) {
      totalTimeString+=""String_Node_Str"" + 0;
    }
 else {
      totalTimeString+=""String_Node_Str"";
    }
    totalTimeString+=min + TOTAL_TIME_FORMAT_MINUTES + TOTAL_TIME_FORMAT_END;
    return totalTimeString;
  }
}","/** 
 * Get the total number min and hours of a shift. Note the max date time is 24 hours. If the the diff is 0 is seen as a 24h shift
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since 15 May 2013
 * @param startDate - The shift start date
 * @param endDate - The shift end date
 * @return the shift is format ""(H.M)""
 */
public String getShiftTimeDiff(SSDate startDate,SSDate endDate){
  if (minutesStep == 15) {
    boolean reversed=false;
    if (endDate.getTime() < startDate.getTime() - 1000) {
      reversed=true;
    }
    int shiftTotalHours=(int)(((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60)));
    int shiftTotalMin=(int)(((endDate.getTime() - startDate.getTime()) / (1000 * 60)) % 60);
    if (shiftTotalMin == 59) {
      shiftTotalMin=0;
      shiftTotalHours++;
    }
 else     if (shiftTotalMin % 15 == 14) {
      shiftTotalMin++;
    }
    int totalMinAndHours=(shiftTotalHours * 60) + shiftTotalMin;
    if (totalMinAndHours >= 1441 || totalMinAndHours <= 1439) {
      if (endDate.getTime() - startDate.getTime() > 86399000) {
        shiftTotalHours=24;
        totalMinAndHours=1440;
        shiftTotalMin=0;
      }
    }
    if (((15 - (shiftTotalMin % 15) < 1)) || (totalMinAndHours > 1440) || reversed) {
      return ""String_Node_Str"";
    }
    if (shiftTotalMin == 0) {
      return ""String_Node_Str"" + shiftTotalHours + ""String_Node_Str"";
    }
    String displayedMinutes=String.valueOf((int)((Math.ceil(shiftTotalMin) / 60) * 100)).replaceAll(""String_Node_Str"",""String_Node_Str"");
    return ""String_Node_Str"" + shiftTotalHours + ""String_Node_Str""+ displayedMinutes+ ""String_Node_Str"";
  }
 else {
    startDate=startDatePicker.getValue();
    startDate.setDirectTime(startTimePicker.getDateTime().getHours(),startTimePicker.getDateTime().getMinutes(),startTimePicker.getDateTime().getSeconds());
    endDate=endDatePicker.getValue();
    endDate.setDirectTime(endTimePicker.getDateTime().getHours(),endTimePicker.getDateTime().getMinutes(),endTimePicker.getDateTime().getSeconds());
    float shiftTotalMinutes=(endDate.getTime() - startDate.getTime()) / 1000 / 60;
    int hours=(int)(shiftTotalMinutes / 60);
    int min=(int)(shiftTotalMinutes - (hours * 60));
    String totalTimeString=TOTAL_TIME_FORMAT_START + hours + TOTAL_TIME_FORMAT_HOURS;
    if (min < 10) {
      totalTimeString+=""String_Node_Str"" + 0;
    }
 else {
      totalTimeString+=""String_Node_Str"";
    }
    totalTimeString+=min + TOTAL_TIME_FORMAT_MINUTES + TOTAL_TIME_FORMAT_END;
    return totalTimeString;
  }
}"
50625,"/** 
 * Sets the selected display item
 * @author Michael Barnard <michael.barnard@a24group.com>
 * @since  10 Jul 2014
 * @param selectedDisplayItem - The display item the user clicked on in the drop down
 */
public void setSelectedDisplayItem(FilterDropdownRecordWidget<ListType> selectedDisplayItem){
  if (selectedDisplayItem != null) {
    this.selectedDisplayItem=selectedDisplayItem;
    this.selectedObject=this.selectedDisplayItem.getItemValue();
    textBox.setText(this.selectedDisplayItem.getItemSelectionText());
    destroyDropDownPopup();
  }
}","/** 
 * Sets the selected display item
 * @author Michael Barnard <michael.barnard@a24group.com>
 * @since  10 Jul 2014
 * @param selectedDisplayItem - The display item the user clicked on in the drop down
 */
public void setSelectedDisplayItem(FilterDropdownRecordWidget<ListType> selectedDisplayItem){
  if (selectedDisplayItem != null) {
    this.selectedDisplayItem=selectedDisplayItem;
    this.selectedDisplayItem.setSelectedState(false);
    this.selectedObject=this.selectedDisplayItem.getItemValue();
    textBox.setText(this.selectedDisplayItem.getItemSelectionText());
    destroyDropDownPopup();
  }
}"
50626,"/** 
 * The key up event handler
 * @param event - The key up event that is being handled
 * @author Michael Barnard <michael.barnard@a24group.com>
 * @since  10 Jul 2014
 */
@Override public void onKeyUp(KeyUpEvent event){
  if (event.isLeftArrow() || event.isRightArrow()) {
  }
 else   if (event.isDownArrow()) {
    if (dropDownPopup != null) {
      String itemText=dropDownPopup.selectNextItem();
      if (itemText != null) {
        textBox.setText(itemText);
      }
    }
  }
 else   if (event.isUpArrow()) {
    if (dropDownPopup != null) {
      String itemText=dropDownPopup.selectPreviousItem();
      if (itemText != null) {
        textBox.setText(itemText);
      }
 else {
        textBox.setText(previousSearchString);
      }
    }
  }
 else   if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
    if (dropDownPopup != null) {
      setSelectedDisplayItem(dropDownPopup.getSelectedItem());
    }
  }
 else   if (textBox.getText().length() >= this.minCharCount && !textBox.getText().equals(previousSearchString)) {
    selectedObject=null;
    previousSearchString=textBox.getText();
    this.setValue(textBox.getText());
    createDropDownPopup();
    applyFilter();
  }
 else   if (textBox.getText().length() < this.minCharCount) {
    selectedObject=null;
    previousSearchString=textBox.getText();
    this.setValue(textBox.getText());
    destroyDropDownPopup();
  }
}","/** 
 * The key up event handler
 * @param event - The key up event that is being handled
 * @author Michael Barnard <michael.barnard@a24group.com>
 * @since  10 Jul 2014
 */
@Override public void onKeyUp(KeyUpEvent event){
  if (event.isLeftArrow() || event.isRightArrow()) {
  }
 else   if (event.isDownArrow()) {
    if (dropDownPopup != null) {
      String itemText=dropDownPopup.selectNextItem();
      if (itemText != null) {
        textBox.setText(itemText);
      }
    }
  }
 else   if (event.isUpArrow()) {
    if (dropDownPopup != null) {
      String itemText=dropDownPopup.selectPreviousItem();
      if (itemText != null) {
        textBox.setText(itemText);
      }
 else {
        textBox.setText(previousSearchString);
      }
    }
  }
 else   if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
    if (dropDownPopup != null) {
      setSelectedDisplayItem(dropDownPopup.getSelectedItem());
    }
  }
 else   if (textBox.getText().length() >= this.minCharCount && !textBox.getText().equals(previousSearchString)) {
    selectedObject=null;
    previousSearchString=textBox.getText();
    createDropDownPopup();
    applyFilter();
  }
 else   if (textBox.getText().length() < this.minCharCount) {
    selectedObject=null;
    previousSearchString=textBox.getText();
    destroyDropDownPopup();
  }
}"
50627,"private void setValue(SSDate oldDate,SSDate date,boolean fireEvents){
  if (date != null) {
    picker.setCurrentMonth(date);
  }
  picker.setValue(date,false);
  format.reset(this,false);
  box.setText(getFormat().format(this,date));
  if (fireEvents) {
    DateChangeEvent.fireIfNotEqualDates(this,oldDate,date);
  }
}","private void setValue(SSDate oldDate,SSDate date,boolean fireEvents){
  SSDate pickerDate=date;
  if (date != null && this.getDatePicker().getMinimumDate().getTime() > date.getTime()) {
    System.out.println(""String_Node_Str"");
    pickerDate=new SSDate(this.getDatePicker().getMinimumDate().getTime());
    pickerDate.setDate(this.getDatePicker().getMinimumDate().getDate() + 1);
  }
  if (pickerDate != null) {
    picker.setCurrentMonth(pickerDate);
  }
  picker.setValue(date,false);
  format.reset(this,false);
  box.setText(getFormat().format(this,date));
  if (fireEvents) {
    DateChangeEvent.fireIfNotEqualDates(this,oldDate,date);
  }
}"
50628,"/** 
 * Adds the given number of months to a date.
 * @param date the date
 * @param months number of months
 */
@SuppressWarnings(""String_Node_Str"") public static void addMonthsToDate(SSDate date,int months){
  if (months != 0) {
    int month=date.getMonth();
    int year=date.getYear();
    int resultMonthCount=year * 12 + month + months;
    int resultYear=resultMonthCount / 12;
    int resultMonth=resultMonthCount - resultYear * 12;
    date.setMonth(resultMonth);
    date.setYear(resultYear);
  }
}","/** 
 * Adds the given number of months to a date. This method will add a number of months onto the current month. If the resultant month has fewer days, we will set the date to max day for that month. If the calculated month has more days than the current date that has been passed into the method, the month is simply incremented by the requested number of months passed into the method.
 * @param date the date
 * @param months number of months
 */
@SuppressWarnings(""String_Node_Str"") public static void addMonthsToDate(SSDate date,int months){
  if (months != 0) {
    int month=date.getMonth();
    int year=date.getYear();
    int resultMonthCount=year * 12 + month + months;
    int resultYear=resultMonthCount / 12;
    int resultMonth=resultMonthCount - resultYear * 12;
    if (resultMonth == 1 && date.getDate() > 28) {
      if (((resultYear % 4 == 0) && (resultYear % 100 != 0)) || (resultYear % 400 == 0)) {
        date.setDate(29);
      }
 else {
        date.setDate(28);
      }
    }
 else     if (date.getDate() == 31 && (resultMonth == 3 || resultMonth == 5 || resultMonth == 8 || resultMonth == 10)) {
      date.setDate(30);
    }
    date.setMonth(resultMonth);
    date.setYear(resultYear);
  }
}"
50629,"/** 
 * Selects the previous item in the drop down and change the item to it's selected style
 * @author Johannes Gryffenberg <johannes.gryffenberg@gmail.com>
 * @since  22 January 2013
 * @return The display text for the item
 */
public String selectPreviousItem(){
  if (hasResults && selectedIndex >= 0) {
    resultDisplayItems.get(selectedIndex).setSelectedState(false);
    selectedIndex--;
    if (selectedIndex >= 0) {
      resultDisplayItems.get(selectedIndex).setSelectedState(true);
      resultDisplayItems.get(selectedIndex).getElement().scrollIntoView();
    }
  }
  if (selectedIndex >= 0) {
    return resultDisplayItems.get(selectedIndex).getItemSelectionText();
  }
 else {
    return null;
  }
}","/** 
 * Selects the previous item in the drop down and change the item to it's selected style
 * @author Johannes Gryffenberg <johannes.gryffenberg@gmail.com>
 * @author Saurabh Chawla <saurabh.chawla@a24group.com>
 * @since  22 January 2013
 * @return The display text for the item
 */
public String selectPreviousItem(){
  if (hasResults && selectedIndex >= 0) {
    resultDisplayItems.get(selectedIndex).setSelectedState(false);
    selectedIndex--;
    if (selectedIndex >= 0) {
      resultDisplayItems.get(selectedIndex).setSelectedState(true);
      resultDisplayItems.get(selectedIndex).getElement().scrollIntoView();
    }
  }
  if (selectedIndex >= 0 && resultDisplayItems.size() > selectedIndex) {
    return resultDisplayItems.get(selectedIndex).getItemSelectionText();
  }
 else {
    return null;
  }
}"
50630,"/** 
 * This function will set the popup into a loading state to indicate that data is being loaded for popup
 * @author Ruan Naude <naudeuran777@gmail.com>
 * @since 15 July 2013
 * @param loading - Whether to set popup into loading state
 */
public void setLoadingState(boolean loading){
  this.loadingState=loading;
  setLoaderStateSize();
  loaderFlowPanel.setVisible(loading);
  popupContent.setVisible(!loading);
}","/** 
 * This function will set the popup into a loading state to indicate that data is being loaded for popup
 * @author Ruan Naude <naudeuran777@gmail.com>
 * @since 15 July 2013
 * @param loading - Whether to set popup into loading state
 */
public void setLoadingState(boolean loading){
  if (useArrow == false) {
    this.center();
  }
  this.loadingState=loading;
  setLoaderStateSize();
  loaderFlowPanel.setVisible(loading);
  popupContent.setVisible(!loading);
  if (useArrow == false) {
    this.center();
  }
}"
50631,"/** 
 * This will create a image with the url passed in by the constructor
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since 03 June 2013
 * @param context -The context the cell is in
 * @param value - The value to be added in the cell but not the image thats going to be displayed
 * @param sb -The safe html builder.
 */
@Override public void render(Context context,T value,SafeHtmlBuilder sb){
  actionList=column.getActions(value);
  boolean firstItem=true;
  for (  String action : actionList) {
    if (firstItem) {
      sb.append(template.firstAction(action));
      firstItem=false;
    }
 else {
      sb.append(template.actionSeparator(this.spacerSize));
      sb.append(template.action(action,this.spacerSize));
    }
  }
}","/** 
 * This will create a image with the url passed in by the constructor
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since 03 June 2013
 * @param context -The context the cell is in
 * @param value - The value to be added in the cell but not the image thats going to be displayed
 * @param sb -The safe html builder.
 */
@Override public void render(Context context,T value,SafeHtmlBuilder sb){
  displayActionList=column.getActions(value);
  boolean firstItem=true;
  for (  String action : displayActionList) {
    if (!actionList.contains(action)) {
      actionList.add(action);
    }
    if (firstItem) {
      sb.append(template.firstAction(action));
      firstItem=false;
    }
 else {
      sb.append(template.actionSeparator(this.spacerSize));
      sb.append(template.action(action,this.spacerSize));
    }
  }
}"
50632,"/** 
 * Set the complete list of values to display on one page
 * @param startRow - The start row the data is for
 * @param data - The data the should be displayed on the data grid
 * @author Lodewyk Duminy
 * @since 29 June 2012
 */
public void setRowData(int startRow,List<T> data){
  if (!firstDataSetGiven) {
    firstDataSetGiven=true;
    firstDataSet=true;
  }
  previousRange=dataGrid.getVisibleRange();
  if (data != null) {
    noContentLabel.setVisible(false);
    dataGrid.setRowData(startRow,data);
    refresh();
  }
 else {
    noContentLabel.setVisible(true);
  }
  if (previousRange.equals(dataGrid.getVisibleRange())) {
    doRangeChange=true;
    firstDataSet=false;
  }
}","/** 
 * Set the complete list of values to display on one page
 * @param startRow - The start row the data is for
 * @param data - The data the should be displayed on the data grid
 * @param rowsPerPage - The amount of records to display per page
 * @author Lodewyk Duminy
 * @since 29 June 2012
 */
public void setRowData(int startRow,List<T> data,int rowsPerPage){
  if (!firstDataSetGiven) {
    firstDataSetGiven=true;
    firstDataSet=true;
  }
  previousRange=dataGrid.getVisibleRange();
  if (data != null) {
    doRangeChange=false;
    noContentLabel.setVisible(false);
    if (rowsPerPage != 0) {
      Range range=new Range(startRow,rowsPerPage);
      dataGrid.setVisibleRangeAndClearData(range,true);
    }
    dataGrid.setRowData(startRow,data);
    refresh();
  }
 else {
    noContentLabel.setVisible(true);
  }
  if (previousRange.equals(dataGrid.getVisibleRange())) {
    doRangeChange=true;
    firstDataSet=false;
  }
}"
50633,"/** 
 * This function will check if there is already a default resource to use for the generic popup and if not one will be create a default resource
 * @author Ruan Naude <naudeuran777@gmail.com>
 * @since 15 July 2013
 * @return The default resource for the LeftMenuItem
 */
private static GenericPopupResource getDefaultResources(){
  if (DEFAULT_RESOURCE == null) {
    DEFAULT_RESOURCE=GWT.create(GenericPopupResource.class);
  }
  return DEFAULT_RESOURCE;
}","/** 
 * This function will check if there is already a default resource to use for the generic popup and if not one will be created
 * @author Ruan Naude <naudeuran777@gmail.com>
 * @since 15 July 2013
 * @return The default resource for the LeftMenuItem
 */
private static GenericPopupResource getDefaultResources(){
  if (DEFAULT_RESOURCE == null) {
    DEFAULT_RESOURCE=GWT.create(GenericPopupResource.class);
  }
  return DEFAULT_RESOURCE;
}"
50634,"/** 
 * calcDate uses all the field available so far to fill a Date object. For those information that is not provided, the existing value in 'date' will be kept. Ambiguous year will be resolved after the date/time values are resolved. If the strict option is set to true, calcDate will calculate certain invalid dates by wrapping around as needed. For example, February 30 will wrap to March 2.
 * @param date The Date object being filled. Its value should be set to anacceptable default before pass in to this method
 * @param strict true to be strict when parsing
 * @return true if successful, otherwise false.
 */
public boolean calcDate(SSDate date,boolean strict){
  if (this.era == 0 && this.year > 0) {
    this.year=-(this.year - 1);
  }
  if (this.year > Integer.MIN_VALUE) {
    date.setYear(this.year - JS_START_YEAR);
  }
  int orgDayOfMonth=date.getDate();
  date.setDate(1);
  if (this.month >= 0) {
    date.setMonth(this.month);
  }
  if (this.dayOfMonth >= 0) {
    date.setDate(this.dayOfMonth);
  }
 else   if (this.month >= 0) {
    SSDate tmp=new SSDate(date.getYear(),date.getMonth(),35);
    int daysInCurrentMonth=35 - tmp.getDate();
    date.setDate(Math.min(daysInCurrentMonth,orgDayOfMonth));
  }
 else {
    date.setDate(orgDayOfMonth);
  }
  if (this.hours < 0) {
    this.hours=date.getHours();
  }
  if (this.ampm > 0) {
    if (this.hours < 12) {
      this.hours+=12;
    }
  }
  date.setHours(this.hours);
  if (this.minutes >= 0) {
    date.setMinutes(this.minutes);
  }
  if (this.seconds >= 0) {
    date.setSeconds(this.seconds);
  }
  if (this.milliseconds >= 0) {
    date.setTime(date.getTime() / 1000 * 1000 + this.milliseconds);
  }
  if (strict) {
    if ((this.year > Integer.MIN_VALUE) && ((this.year - JS_START_YEAR) != date.getYear())) {
      return false;
    }
    if ((this.month >= 0) && (this.month != date.getMonth())) {
      return false;
    }
    if ((this.dayOfMonth >= 0) && (this.dayOfMonth != date.getDate())) {
      return false;
    }
    if (this.hours >= 24) {
      return false;
    }
    if (this.minutes >= 60) {
      return false;
    }
    if (this.seconds >= 60) {
      return false;
    }
    if (this.milliseconds >= 1000) {
      return false;
    }
  }
  if (this.ambiguousYear) {
    SSDate defaultCenturyStart=new SSDate();
    defaultCenturyStart.setYear(defaultCenturyStart.getYear() - 80);
    if (date.before(defaultCenturyStart)) {
      date.setYear(defaultCenturyStart.getYear() + 100);
    }
  }
  if (this.dayOfWeek >= 0) {
    if (this.dayOfMonth == -1) {
      int adjustment=(7 + this.dayOfWeek - date.getDay()) % 7;
      if (adjustment > 3) {
        adjustment-=7;
      }
      int orgMonth=date.getMonth();
      date.setDate(date.getDate() + adjustment);
      if (date.getMonth() != orgMonth) {
        date.setDate(date.getDate() + (adjustment > 0 ? -7 : 7));
      }
    }
 else {
      if (date.getDay() != this.dayOfWeek) {
        return false;
      }
    }
  }
  if (this.tzOffset > Integer.MIN_VALUE) {
    date.setTimezoneOffset(this.tzOffset);
    date.setTime(date.getTime());
  }
  return true;
}","/** 
 * calcDate uses all the field available so far to fill a Date object. For those information that is not provided, the existing value in 'date' will be kept. Ambiguous year will be resolved after the date/time values are resolved. If the strict option is set to true, calcDate will calculate certain invalid dates by wrapping around as needed. For example, February 30 will wrap to March 2.
 * @param date The Date object being filled. Its value should be set to anacceptable default before pass in to this method
 * @param strict true to be strict when parsing
 * @return true if successful, otherwise false.
 */
public boolean calcDate(SSDate date,boolean strict){
  if (this.era == 0 && this.year > 0) {
    this.year=-(this.year - 1);
  }
  if (this.year > Integer.MIN_VALUE) {
    date.setYear(this.year - JS_START_YEAR);
  }
  int orgDayOfMonth=date.getDate();
  date.setDate(1);
  if (this.month >= 0) {
    date.setMonth(this.month);
  }
  if (this.dayOfMonth >= 0) {
    date.setDate(this.dayOfMonth);
  }
 else   if (this.month >= 0) {
    SSDate tmp=new SSDate(date.getYear(),date.getMonth(),35);
    int daysInCurrentMonth=35 - tmp.getDate();
    date.setDate(Math.min(daysInCurrentMonth,orgDayOfMonth));
  }
 else {
    date.setDate(orgDayOfMonth);
  }
  if (this.hours < 0) {
    this.hours=date.getHours();
  }
  if (this.ampm > 0) {
    if (this.hours < 12) {
      this.hours+=12;
    }
  }
  date.setHours(this.hours);
  if (this.minutes >= 0) {
    date.setMinutes(this.minutes);
  }
  if (this.seconds >= 0) {
    date.setSeconds(this.seconds);
  }
  if (this.milliseconds >= 0) {
    date.setTime(date.getTime() / 1000 * 1000 + this.milliseconds);
  }
  if (strict) {
    if ((this.year > Integer.MIN_VALUE) && ((this.year - JS_START_YEAR) != date.getYear())) {
      return false;
    }
    if ((this.month >= 0) && (this.month != date.getMonth())) {
      return false;
    }
    if ((this.dayOfMonth >= 0) && (this.dayOfMonth != date.getDate())) {
      return false;
    }
    if (this.hours >= 24) {
      return false;
    }
    if (this.minutes >= 60) {
      return false;
    }
    if (this.seconds >= 60) {
      return false;
    }
    if (this.milliseconds >= 1000) {
      return false;
    }
  }
  if (this.ambiguousYear) {
    SSDate defaultCenturyStart=new SSDate();
    defaultCenturyStart.setYear(defaultCenturyStart.getYear() - 80);
    if (date.before(defaultCenturyStart)) {
      date.setYear(defaultCenturyStart.getYear() + 100);
    }
  }
  if (this.dayOfWeek >= 0) {
    if (this.dayOfMonth == -1) {
      int adjustment=(7 + this.dayOfWeek - date.getDay()) % 7;
      if (adjustment > 3) {
        adjustment-=7;
      }
      int orgMonth=date.getMonth();
      date.setDate(date.getDate() + adjustment);
      if (date.getMonth() != orgMonth) {
        date.setDate(date.getDate() + (adjustment > 0 ? -7 : 7));
      }
    }
 else {
      if (date.getDay() != this.dayOfWeek) {
        return false;
      }
    }
  }
  if (this.tzOffset > Integer.MIN_VALUE) {
    long timeStamp=date.getTime();
    date.setTimezoneOffset(this.tzOffset);
    date.setTime(timeStamp);
  }
  return true;
}"
50635,"/** 
 * Function used to update the input fields
 * @author Michael Barnard <michael.barnard@a24group.com>
 * @since  11 January 2012
 */
@Override protected void updateFieldData(){
  checkBox.setValue(getCriteria().isFindEmptyEntriesOnly());
  int index=0;
  if (bIsAdvancedMap) {
    index=findAdvancedIndexValue(getCriteria().getCriteria());
  }
 else {
    index=findIndexOf(getCriteria().getCriteria());
  }
  if (index != -1) {
    listBox.setSelectedIndex(index);
  }
 else {
    listBox.setSelectedIndex(0);
  }
  listBox.setEnabled(!checkBox.getValue());
}","/** 
 * Function used to update the input fields
 * @author Michael Barnard <michael.barnard@a24group.com>
 * @since  11 January 2012
 */
@Override protected void updateFieldData(){
  checkBox.setValue(getCriteria().isFindEmptyEntriesOnly());
  if (isMultiSelect()) {
    setMultiSelectListBoxValues();
  }
 else {
    setSingleSelectListBoxValue();
  }
  listBox.setEnabled(!checkBox.getValue());
}"
50636,"/** 
 * Class constructor
 * @param value - The initial value
 * @param min - The minimum value
 * @param max - The maximum value
 * @param minStep - The minimum value for stepping
 * @param maxStep - The maximum value for stepping
 * @param constrained - If set to false min and max value will not have any effect
 * @param valueBoxLabelText - The text to display on the value box label
 * @param resources - The styles and images used by this widget
 * @param images - The images used by the spinner
 */
public HourSpinner(long value,double min,double max,int minStep,int maxStep,boolean constrained,String valueBoxLabelText,ValueSpinnerResources resources,SpinnerResources images){
  super();
  setStylePrimaryName(STYLENAME_DEFAULT);
  long spinnerMin=(long)(min * 100);
  long spinnerMax=(long)(max * 100);
  if (images == null) {
    spinner=new Spinner(spinnerListener,value,spinnerMin,spinnerMax,minStep,maxStep,constrained);
  }
 else {
    spinner=new Spinner(spinnerListener,value,spinnerMin,spinnerMax,minStep,maxStep,constrained,images);
  }
  valueBox.setStyleName(TEXTBOX_STYLE);
  valueBox.addKeyPressHandler(keyPressHandler);
  spinnerContainer.add(valueBox);
  FlowPanel arrowsPanel=new FlowPanel();
  arrowsPanel.setStylePrimaryName(ARROW_STYLE);
  arrowsPanel.add(spinner.getIncrementArrow());
  arrowsPanel.add(spinner.getDecrementArrow());
  spinnerContainer.add(arrowsPanel);
  valueBoxLabel=new Label(valueBoxLabelText);
  add(spinnerContainer);
  add(valueBoxLabel);
}","/** 
 * Class constructor
 * @param value - The initial value
 * @param min - The minimum value
 * @param max - The maximum value
 * @param minStep - The minimum value for stepping
 * @param maxStep - The maximum value for stepping
 * @param constrained - If set to false min and max value will not have any effect
 * @param valueBoxLabelText - The text to display on the value box label
 * @param resources - The styles and images used by this widget
 * @param images - The images used by the spinner
 */
public HourSpinner(long value,double min,double max,int minStep,int maxStep,boolean constrained,String valueBoxLabelText,ValueSpinnerResources resources,SpinnerResources images){
  super();
  setStylePrimaryName(STYLENAME_DEFAULT);
  if (resources != null) {
    defaultResources=resources;
  }
  long spinnerMin=(long)(min * 100);
  long spinnerMax=(long)(max * 100);
  if (images == null) {
    spinner=new Spinner(spinnerListener,value,spinnerMin,spinnerMax,minStep,maxStep,constrained);
  }
 else {
    spinner=new Spinner(spinnerListener,value,spinnerMin,spinnerMax,minStep,maxStep,constrained,images);
  }
  valueBox.setStyleName(TEXTBOX_STYLE);
  valueBox.addKeyPressHandler(keyPressHandler);
  spinnerContainer.add(valueBox);
  FlowPanel arrowsPanel=new FlowPanel();
  arrowsPanel.setStylePrimaryName(ARROW_STYLE);
  arrowsPanel.add(spinner.getIncrementArrow());
  arrowsPanel.add(spinner.getDecrementArrow());
  spinnerContainer.add(arrowsPanel);
  valueBoxLabel=new Label(valueBoxLabelText);
  add(spinnerContainer);
  add(valueBoxLabel);
}"
50637,"/** 
 * Sets whether this widget is enabled.
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since  08 July 2013
 * @param enabled - true to enable the widget, false to disable it
 */
public void setTextBoxReadOnly(boolean enabled){
  valueBox.setReadOnly(enabled);
}","/** 
 * Sets the text box to ready only or not.
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since  08 July 2013
 * @param enabled - true to set the textbox to read only, false to enable it
 */
public void setTextBoxReadOnly(boolean enabled){
  valueBox.setReadOnly(enabled);
}"
50638,"/** 
 * On the value change of the spinner
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since  08 July 2013
 */
@Override public void onSpinning(long value){
  if (getSpinner() != null) {
    getSpinner().setValue(value,false);
  }
  valueBox.setText(formatValue(value));
}","/** 
 * On the value change of the spinner
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since  08 July 2013
 * @param value - The new value to set on the spinner
 */
@Override public void onSpinning(long value){
  if (getSpinner() != null) {
    getSpinner().setValue(value,false);
  }
  valueBox.setText(formatValue(value));
}"
50639,"/** 
 * Displays the popup relative to the cell
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since  17 June 2013
 * @param data - The data that will be set in the popup
 */
private void displayPopup(){
  this.popup.center();
  this.popup.setData(column.getRowData());
  this.popup.setPopupPosition(this.parent.getAbsoluteLeft(),(this.parent.getAbsoluteTop() + this.parent.getOffsetHeight() + 10));
}","/** 
 * Displays the popup relative to the cell
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since  17 June 2013
 */
private void displayPopup(){
  this.popup.center();
  this.popup.setData(column.getRowData());
  this.popup.setPopupPosition(this.parent.getAbsoluteLeft(),(this.parent.getAbsoluteTop() + this.parent.getOffsetHeight() + 10));
}"
50640,"/** 
 * This function return the data represented by the row. If you use a custom popup fir the tool tip you need to override this function
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since  17 June 2013
 * @return the data in the row
 */
public T getRowData(){
  System.out.println(""String_Node_Str"");
  return null;
}","/** 
 * This function return the data represented by the row. If you use a custom popup fir the tool tip you need to override this function
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since  17 June 2013
 * @return the data in the row
 */
public T getRowData(){
  return null;
}"
50641,"/** 
 * Get the filters added to the datagrid and if the column is a sort able column, the field name
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since  05 June 2013
 * @return HashMap - Key is the filter and the value(if column is a sort able column else empty) is field name
 */
public HashMap<AbstractHeaderFilter,String> getFilters(){
  return filterColumns;
}","/** 
 * Get the filters added to the datagrid and if the column is a sortable column, the field name
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since  05 June 2013
 * @return HashMap - Key is the filter and the value(if column is a sortable column else empty) is field name
 */
public HashMap<AbstractHeaderFilter,String> getFilters(){
  return filterColumns;
}"
50642,"/** 
 * The function that is called on the value change of the startTimePicker Reset the start time picker date(not time) if the time picker have made a loop. Set the new max and end date, selectable by the end date date picker. Reset the end date fields to the same as the start date fields
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since 15 May 2013
 * @param date - The new date selected
 */
private void onStartTimePickerValueChange(Date date){
  if (date.getMinutes() % 15 != 0) {
    startTimePicker.setDateTime(getRestDate(date));
  }
  if (date.getHours() % 24 == 0) {
    startTimePicker.setDate(startDateBox.getValue());
  }
  if (startTimePicker.getDateTime().getDay() != startDateBox.getValue().getDay()) {
    startTimePicker.setDate(startDateBox.getValue());
  }
  endTimePicker.setMinDate(getShiftMinDate());
  endTimePicker.setMaxDate(getShiftMaxDate());
  endTimePicker.setDateTime(getShiftMinDate());
  endDateBox.setValue(startDateBox.getValue());
  totalTime.setText(getShiftTimeDiff(startTimePicker.getDateTime(),endTimePicker.getDateTime()));
}","/** 
 * The function that is called on the value change of the startTimePicker Reset the start time picker date(not time) if the time picker have made a loop. Set the new max and end date, selectable by the end date date picker. Reset the end date fields to the same as the start date fields
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since 15 May 2013
 * @param date - The new date selected
 */
private void onStartTimePickerValueChange(Date date){
  if (date.getMinutes() % 15 != 0) {
    startTimePicker.setDateTime(getRestDate(date));
  }
  if (date.getHours() % 24 == 0) {
    startTimePicker.setDate(startDateBox.getValue());
  }
  if (startTimePicker.getDateTime().getDay() != startDateBox.getValue().getDay()) {
    startTimePicker.setDate(startDateBox.getValue());
  }
  endTimePicker.setMinDate(getShiftMinDate());
  endTimePicker.setMaxDate(getShiftMaxDate());
  endTimePicker.setDateTime(getShiftMinDate());
  endDateBox.setValue(startDateBox.getValue());
  onEndDateBoxValueChange(startDateBox.getValue());
  totalTime.setText(getShiftTimeDiff(startTimePicker.getDateTime(),endTimePicker.getDateTime()));
}"
50643,"/** 
 * Get the total number min and hours of a shift. Note the max date time is 24 hours. If the the diff is 0 is seen as a 24h shift
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since 15 May 2013
 * @param startDate - The shift start date
 * @param endDate - The shift end date
 * @return the shift is format ""(H.M)""
 */
public String getShiftTimeDiff(Date startDate,Date endDate){
  boolean reversed=false;
  if (endDate.getTime() < startDate.getTime()) {
    reversed=true;
  }
  int shiftTotalHours=(int)(((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60)));
  int shiftTotalMin=(int)(((endDate.getTime() - startDate.getTime()) / (1000 * 60)) % 60);
  if (shiftTotalMin == 59) {
    shiftTotalMin=0;
    shiftTotalHours++;
  }
 else   if (shiftTotalMin % 15 == 14) {
    shiftTotalMin++;
  }
  int totalMinAndHours=(shiftTotalHours * 60) + shiftTotalMin;
  if (totalMinAndHours >= 1441 || totalMinAndHours <= 1439) {
    if (endDate.getTime() - startDate.getTime() > 86399000) {
      shiftTotalHours=24;
      totalMinAndHours=1440;
      shiftTotalMin=0;
    }
  }
  if (((15 - (shiftTotalMin % 15) < 1)) || (totalMinAndHours > 1440) || reversed == true) {
    return ""String_Node_Str"";
  }
  if (shiftTotalMin == 0) {
    return ""String_Node_Str"" + shiftTotalHours + ""String_Node_Str"";
  }
  String displayedMinutes=String.valueOf((int)((Math.ceil(shiftTotalMin) / 60) * 100)).replaceAll(""String_Node_Str"",""String_Node_Str"");
  return ""String_Node_Str"" + shiftTotalHours + ""String_Node_Str""+ displayedMinutes+ ""String_Node_Str"";
}","/** 
 * Get the total number min and hours of a shift. Note the max date time is 24 hours. If the the diff is 0 is seen as a 24h shift
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since 15 May 2013
 * @param startDate - The shift start date
 * @param endDate - The shift end date
 * @return the shift is format ""(H.M)""
 */
public String getShiftTimeDiff(Date startDate,Date endDate){
  boolean reversed=false;
  if (endDate.getTime() < startDate.getTime() - 1000) {
    reversed=true;
  }
  int shiftTotalHours=(int)(((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60)));
  int shiftTotalMin=(int)(((endDate.getTime() - startDate.getTime()) / (1000 * 60)) % 60);
  if (shiftTotalMin == 59) {
    shiftTotalMin=0;
    shiftTotalHours++;
  }
 else   if (shiftTotalMin % 15 == 14) {
    shiftTotalMin++;
  }
  int totalMinAndHours=(shiftTotalHours * 60) + shiftTotalMin;
  if (totalMinAndHours >= 1441 || totalMinAndHours <= 1439) {
    if (endDate.getTime() - startDate.getTime() > 86399000) {
      shiftTotalHours=24;
      totalMinAndHours=1440;
      shiftTotalMin=0;
    }
  }
  if (((15 - (shiftTotalMin % 15) < 1)) || (totalMinAndHours > 1440) || reversed) {
    return ""String_Node_Str"";
  }
  if (shiftTotalMin == 0) {
    return ""String_Node_Str"" + shiftTotalHours + ""String_Node_Str"";
  }
  String displayedMinutes=String.valueOf((int)((Math.ceil(shiftTotalMin) / 60) * 100)).replaceAll(""String_Node_Str"",""String_Node_Str"");
  return ""String_Node_Str"" + shiftTotalHours + ""String_Node_Str""+ displayedMinutes+ ""String_Node_Str"";
}"
50644,"/** 
 * Setter that updates the state of the filter
 * @param filterActive - Flag indicating if the filter is active
 */
public void setFilterActive(boolean filterActive){
  this.filterActive=filterActive;
  if (parent != null) {
    Element filterImageElement=getImageElement(parent);
    Element filterImageParentElement=filterImageElement.getParentElement();
    if (filterActive) {
      replaceImageElement(resources.filterIconActive(),filterImageElement,filterImageParentElement);
    }
 else {
      replaceImageElement(resources.filterIconInactive(),filterImageElement,filterImageParentElement);
    }
    FilterChangeEvent.fire(this);
  }
}","/** 
 * Setter that updates the state of the filter
 * @param filterActive - Flag indicating if the filter is active
 * @author Ruan Naude <ruan.naude@a24group.com>
 * @since 04 April 2013
 */
public void setFilterActive(boolean filterActive){
  this.filterActive=filterActive;
  setFilterActiveUpdateOnParent(true);
}"
50645,"/** 
 * Adds a column to the data grid with a FilterSortHeader as a header
 * @param col - The column that should be added to the data grid
 * @param label - The label that should be displayed in the header
 * @param filterWidget - The filter widget that should be displayed if the user clicks on the filter icon
 */
public void addFilterColumn(Column<T,?> col,String label,AbstractHeaderFilter filterWidget){
  FilterSortHeader header=new FilterSortHeader(label,filterWidget);
  this.addColumn(col,header);
}","/** 
 * Adds a column to the data grid with a FilterSortHeader as a header
 * @param col - The column that should be added to the data grid
 * @param label - The label that should be displayed in the header
 * @param filterWidget - The filter widget that should be displayed if the user clicks on the filter icon
 */
public void addFilterColumn(Column<T,?> col,String label,AbstractHeaderFilter filterWidget){
  filterWidgets.put(label,filterWidget);
  FilterSortHeader header=new FilterSortHeader(label,filterWidget);
  this.addColumn(col,header);
}"
50646,"/** 
 * This function will determin whether the DataGridRangeChangeEvent should be fired.
 * @param event The range change event being handled
 * @author Ruan Naude <nauderuan777@gmail.com>
 * @since 04 March 2013
 */
@Override public void onRangeChange(RangeChangeEvent event){
  if (doRangeChange && !firstDataSet) {
    DataGridRangeChangeEvent.fire(this,event.getNewRange());
  }
 else {
    doRangeChange=true;
    firstDataSet=false;
  }
}","/** 
 * This function will determine whether the DataGridRangeChangeEvent should be fired.
 * @param event The range change event being handled
 * @author Ruan Naude <nauderuan777@gmail.com>
 * @since 04 March 2013
 */
@Override public void onRangeChange(RangeChangeEvent event){
  if (doRangeChange && !firstDataSet) {
    DataGridRangeChangeEvent.fire(this,event.getNewRange());
  }
 else {
    doRangeChange=true;
    firstDataSet=false;
  }
}"
50647,"/** 
 * This will set the organisation record to the selected state by updating style accordingly
 * @author Michael Barnard <michael.barnard@a24group.com>
 * @since  19 March 2013
 */
@Override public void setSelectedState(boolean selected){
  if (selected) {
    searchBoxClientRecord.addStyleName(resources.searchBoxClientRecordStyle().searchBoxClientRecordSelected());
    siteLabel.addStyleName(resources.searchBoxClientRecordStyle().organisationLabelSelected());
    avatarImage.addStyleName(resources.searchBoxClientRecordStyle().avatarImageSelected());
  }
 else {
    searchBoxClientRecord.removeStyleName(resources.searchBoxClientRecordStyle().searchBoxClientRecordSelected());
    siteLabel.removeStyleName(resources.searchBoxClientRecordStyle().organisationLabelSelected());
    avatarImage.removeStyleName(resources.searchBoxClientRecordStyle().avatarImageSelected());
  }
}","/** 
 * This will set the organisation record to the selected state by updating style accordingly
 * @author Michael Barnard <michael.barnard@a24group.com>
 * @since  19 March 2013
 */
@Override public void setSelectedState(boolean selected){
  if (selected) {
    searchBoxClientRecord.addStyleName(resources.searchBoxClientRecordStyle().searchBoxClientRecordSelected());
    siteLabel.addStyleName(resources.searchBoxClientRecordStyle().siteLabelSelected());
    avatarImage.addStyleName(resources.searchBoxClientRecordStyle().avatarImageSelected());
  }
 else {
    searchBoxClientRecord.removeStyleName(resources.searchBoxClientRecordStyle().searchBoxClientRecordSelected());
    siteLabel.removeStyleName(resources.searchBoxClientRecordStyle().siteLabelSelected());
    avatarImage.removeStyleName(resources.searchBoxClientRecordStyle().avatarImageSelected());
  }
}"
50648,"/** 
 * This will create a image with with the url passed in by the constructor
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since 02 April 2013
 * @param context -The context the cell is in
 * @param value - The value to be added in the cell but not the image thats going to be displayed
 * @param sb -The save html builder.
 */
@Override public void render(Context context,Boolean value,SafeHtmlBuilder sb){
  String columnString;
  if (value == null) {
    value=false;
  }
  if (value) {
    if (tImageUrl == null) {
      columnString=""String_Node_Str"" + value + ""String_Node_Str"";
    }
 else {
      columnString=""String_Node_Str"" + value + ""String_Node_Str""+ tImageUrl+ ""String_Node_Str"";
    }
  }
 else {
    if (fImageUrl == null) {
      columnString=""String_Node_Str"" + value + ""String_Node_Str"";
    }
 else {
      columnString=""String_Node_Str"" + value + ""String_Node_Str""+ fImageUrl+ ""String_Node_Str"";
    }
  }
  sb.appendHtmlConstant(columnString);
}","/** 
 * This will create a image with the url passed in by the constructor
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since 02 April 2013
 * @param context -The context the cell is in
 * @param value - The value to be added in the cell but not the image thats going to be displayed
 * @param sb -The safe html builder.
 */
@Override public void render(Context context,Boolean value,SafeHtmlBuilder sb){
  String columnString;
  if (value == null) {
    value=false;
  }
  if (value) {
    if (tImageUrl == null) {
      columnString=""String_Node_Str"" + value + ""String_Node_Str"";
    }
 else {
      columnString=""String_Node_Str"" + value + ""String_Node_Str""+ tImageUrl+ ""String_Node_Str"";
    }
  }
 else {
    if (fImageUrl == null) {
      columnString=""String_Node_Str"" + value + ""String_Node_Str"";
    }
 else {
      columnString=""String_Node_Str"" + value + ""String_Node_Str""+ fImageUrl+ ""String_Node_Str"";
    }
  }
  sb.appendHtmlConstant(columnString);
}"
50649,"/** 
 * This will create a label with text and a tooltip with the same text value
 * @author Ruan Naude <nauderuan777@gmail.com>
 * @since 14 March 2013
 * @param context -The context the cell is in
 * @param value - The value to be added in the cell
 * @param sb -The save html builder.
 */
@Override public void render(Context context,String value,SafeHtmlBuilder sb){
  if (value == null) {
    value=""String_Node_Str"";
  }
  sb.appendHtmlConstant(""String_Node_Str"" + value + ""String_Node_Str""+ value+ ""String_Node_Str"");
}","/** 
 * This will create a label with text and a tooltip with the same text value
 * @author Ruan Naude <nauderuan777@gmail.com>
 * @since 14 March 2013
 * @param context -The context the cell is in
 * @param value - The value to be added in the cell
 * @param sb -The safe html builder.
 */
@Override public void render(Context context,String value,SafeHtmlBuilder sb){
  if (value == null) {
    value=""String_Node_Str"";
  }
  sb.appendHtmlConstant(""String_Node_Str"" + value + ""String_Node_Str""+ value+ ""String_Node_Str"");
}"
50650,"/** 
 * The SSBooleanImageCell constructor
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since 02 April 2013
 * @param tImageUrl - The image to display if the the boolean value is true
 * @param fImageUrl - The image to display if the the boolean value is false
 */
public SSBooleanImageCell(String tImageUrl,String fImageUrl){
  super();
  this.tImageUrl=tImageUrl;
  this.fImageUrl=fImageUrl;
}","/** 
 * The SSBooleanImageCell constructor
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since 02 April 2013
 * @param trueImageUrl - The image to display if the the boolean value is true
 * @param falseImageUrl - The image to display if the the boolean value is false
 */
public SSBooleanImageCell(String trueImageUrl,String falseImageUrl){
  super();
  this.trueImageUrl=trueImageUrl;
  this.falseImageUrl=falseImageUrl;
}"
50651,"/** 
 * This will create a image with the url passed in by the constructor
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since 02 April 2013
 * @param context -The context the cell is in
 * @param value - The value to be added in the cell but not the image thats going to be displayed
 * @param sb -The safe html builder.
 */
@Override public void render(Context context,Boolean value,SafeHtmlBuilder sb){
  String columnString;
  if (value == null) {
    value=false;
  }
  if (value) {
    if (tImageUrl == null) {
      columnString=""String_Node_Str"" + value + ""String_Node_Str"";
    }
 else {
      columnString=""String_Node_Str"" + value + ""String_Node_Str""+ tImageUrl+ ""String_Node_Str"";
    }
  }
 else {
    if (fImageUrl == null) {
      columnString=""String_Node_Str"" + value + ""String_Node_Str"";
    }
 else {
      columnString=""String_Node_Str"" + value + ""String_Node_Str""+ fImageUrl+ ""String_Node_Str"";
    }
  }
  sb.appendHtmlConstant(columnString);
}","/** 
 * This will create a image with the url passed in by the constructor
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since 02 April 2013
 * @param context -The context the cell is in
 * @param value - The value to be added in the cell but not the image thats going to be displayed
 * @param sb -The safe html builder.
 */
@Override public void render(Context context,Boolean value,SafeHtmlBuilder sb){
  String columnString;
  if (value == null) {
    value=false;
  }
  if (value) {
    if (trueImageUrl == null) {
      columnString=""String_Node_Str"" + value + ""String_Node_Str"";
    }
 else {
      columnString=""String_Node_Str"" + value + ""String_Node_Str""+ trueImageUrl+ ""String_Node_Str"";
    }
  }
 else {
    if (falseImageUrl == null) {
      columnString=""String_Node_Str"" + value + ""String_Node_Str"";
    }
 else {
      columnString=""String_Node_Str"" + value + ""String_Node_Str""+ falseImageUrl+ ""String_Node_Str"";
    }
  }
  sb.appendHtmlConstant(columnString);
}"
50652,"/** 
 * Construct a new BooleanImageColumn.
 * @author Alec Erasmus
 * @since 02 April 2013
 * @param tImageUrl - The image to display if the the boolean value is true
 * @param fImageUrl - The image to display if the the boolean value is false
 */
public SSBooleanImageColumn(String tImageUrl,String fImageUrl){
  super(new SSBooleanImageCell(tImageUrl,fImageUrl));
}","/** 
 * Construct a new BooleanImageColumn.
 * @author Alec Erasmus
 * @since 02 April 2013
 * @param trueImageUrl - The image to display if the the boolean value is true
 * @param falseImageUrl - The image to display if the the boolean value is false
 */
public SSBooleanImageColumn(String trueImageUrl,String falseImageUrl){
  super(new SSBooleanImageCell(trueImageUrl,falseImageUrl));
}"
50653,"/** 
 * This function will clear the listbox items
 * @author Michael Barnard <michael.barnard@a24group.com>
 * @since  16 January 2013
 */
public void emptyListBox(){
  int listCount=listBox.getItemCount();
  for (int x=0; x < listCount; x++) {
    listBox.removeItem(x);
  }
}","/** 
 * This function will clear the listbox items
 * @author Michael Barnard <michael.barnard@a24group.com>
 * @since  16 January 2013
 */
public void emptyListBox(){
  int listCount=listBox.getItemCount();
  for (int x=listCount; x > 0; x--) {
    listBox.removeItem(x - 1);
  }
}"
50654,"/** 
 * This function will clear the listbox items
 * @author Michael Barnard <michael.barnard@a24group.com>
 * @since  16 January 2013
 */
public void emptyListBox(){
  int listCount=listBox.getItemCount();
  for (int x=0; x < listCount; x++) {
    listBox.removeItem(x);
  }
}","/** 
 * This function will clear the listbox items
 * @author Michael Barnard <michael.barnard@a24group.com>
 * @since  16 January 2013
 */
public void emptyListBox(){
  int listCount=listBox.getItemCount();
  for (int x=listCount; x > 0; x--) {
    listBox.removeItem(x - 1);
  }
}"
50655,"/** 
 * Class constructor
 * @param inputField - The input field that should be displayed on the dynamic form
 * @param label - The label that should be displayed above the input field
 * @param embeded - Whether the component is an embeded object or not
 * @param layout - The layout of the field. If an incorrect value is passed, it will default to vertical
 * @param customStyleName - The custom style to apply to the field
 */
public Field(InputField inputField,String label,boolean embeded,int layout,String customStyleName){
  initWidget(container);
  this.inputField=inputField;
  this.fieldLabel.setText(label);
  if (!this.fieldLabel.getText().equals(""String_Node_Str"")) {
    this.container.add(this.fieldLabel);
  }
  this.fieldLabel.addStyleName(labelStyleName);
  this.container.add(this.inputFieldContainer);
  this.inputFieldContainer.add(this.inputField.getInputFieldWidget());
  this.inputFieldContainer.add(this.requiredStar);
  this.requiredStar.setVisible(this.inputField.isRequired());
  this.inputField.getInputFieldWidget().addStyleName(inputFieldStyleName);
  if (!customStyleName.equals(""String_Node_Str"")) {
    this.addStyleName(customStyleName);
  }
  if (embeded) {
    this.container.setStyleName(containerEmbeddedStyleName);
    this.inputField.getInputFieldWidget().addStyleName(inputFieldAdditionalEmbeddedStyleName);
  }
 else {
    this.inputField.getInputFieldWidget().addStyleName(inputFieldAdditionalNormalStyleName);
    this.container.addStyleName(containerDefaultStyleName);
    this.requiredStar.addStyleName(requiredIndicatorStyle);
    this.inputField.setReadOnly(readOnly);
  }
switch (layout) {
case DynamicForm.LAYOUT_HORIZONTAL:
    this.container.addStyleName(horizontalDefaultStyleName);
  this.container.setWidth(""String_Node_Str"");
break;
case DynamicForm.LAYOUT_VERTICAL:
default :
if (customStyleName.equals(""String_Node_Str"")) {
this.inputField.getInputFieldWidget().setWidth(fieldWidth);
}
break;
}
}","/** 
 * Class constructor
 * @param inputField - The input field that should be displayed on the dynamic form
 * @param label - The label that should be displayed above the input field
 * @param embeded - Whether the component is an embeded object or not
 * @param layout - The layout of the field. If an incorrect value is passed, it will default to vertical
 * @param customStyleName - The custom style to apply to the field
 */
public Field(InputField inputField,String label,boolean embeded,int layout,String customStyleName){
  initWidget(container);
  this.embeded=embeded;
  this.inputField=inputField;
  this.fieldLabel.setText(label);
  if (!this.fieldLabel.getText().equals(""String_Node_Str"")) {
    this.container.add(this.fieldLabel);
  }
  this.fieldLabel.addStyleName(labelStyleName);
  this.container.add(this.inputFieldContainer);
  this.inputFieldContainer.add(this.inputField.getInputFieldWidget());
  this.inputFieldContainer.add(this.requiredStar);
  this.requiredStar.setVisible(this.inputField.isRequired());
  this.inputField.getInputFieldWidget().addStyleName(inputFieldStyleName);
  if (!customStyleName.equals(""String_Node_Str"")) {
    this.addStyleName(customStyleName);
  }
  if (this.embeded) {
    this.container.setStyleName(containerEmbeddedStyleName);
    this.inputField.getInputFieldWidget().addStyleName(inputFieldAdditionalEmbeddedStyleName);
  }
 else {
    this.inputField.getInputFieldWidget().addStyleName(inputFieldAdditionalNormalStyleName);
    this.container.addStyleName(containerDefaultStyleName);
    this.requiredStar.addStyleName(requiredIndicatorStyle);
    this.inputField.setReadOnly(readOnly);
  }
switch (layout) {
case DynamicForm.LAYOUT_HORIZONTAL:
    this.container.addStyleName(horizontalDefaultStyleName);
  this.container.setWidth(""String_Node_Str"");
break;
case DynamicForm.LAYOUT_VERTICAL:
default :
if (customStyleName.equals(""String_Node_Str"")) {
this.inputField.getInputFieldWidget().setWidth(fieldWidth);
}
break;
}
}"
50656,"/** 
 * Updates styles of the fields and hides the required star if the required state of a field changes
 */
public void redraw(){
  for (  Field field : fields.values()) {
    field.fieldLabel.setStyleName(labelStyleName);
    field.inputField.getInputFieldWidget().setStyleName(inputFieldStyleName);
    field.requiredStar.setStyleName(requiredIndicatorStyle);
    field.requiredStar.setVisible(field.inputField.isRequired());
    field.inputField.setReadOnly(this.readOnly);
  }
}","/** 
 * Updates styles of the fields and hides the required star if the required state of a field changes
 */
public void redraw(){
  for (  Field field : fields.values()) {
    field.fieldLabel.addStyleName(labelStyleName);
    field.inputField.getInputFieldWidget().addStyleName(inputFieldStyleName);
    field.requiredStar.addStyleName(requiredIndicatorStyle);
    field.requiredStar.setVisible(field.inputField.isRequired());
    field.inputField.setReadOnly(this.readOnly);
  }
}"
50657,"/** 
 * Function to construct all the components and add it to the main panel
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since  22 November 2012
 */
public void constructor(){
  messagePanel=new FlowPanel();
  messageTable=new FlowPanel();
  messageRow=new FlowPanel();
  messageCell=new Label();
  messageContainer=new FlowPanel();
  messageContainer.add(messagePanel);
  messagePanel.setVisible(false);
  mainPanel.add(messagePanel);
  dynamicFormPanel.add(getDynamicForm());
  dynamicFormPanel.addStyleName(displayInline);
  viewPanel.add(getUiBinder());
  viewPanel.setStyleName(displayInline);
  viewPanel.setVisible(false);
  dataPanel.add(dynamicFormPanel);
  dataPanel.add(viewPanel);
  dataPanel.setStyleName(displayInline);
  viewButtons.add(editLabel);
  editLabel.setStyleName(displayInline,true);
  editLabel.setStyleName(languageInputClickLabels,true);
  editLabel.setStyleName(complexLabelButton,true);
  viewButtons.add(removeLabel);
  removeLabel.setStyleName(displayInline,true);
  removeLabel.setStyleName(languageInputClickLabels,true);
  removeLabel.setStyleName(complexLabelButton,true);
  viewButtons.setStyleName(displayInline,true);
  editButtons.add(saveButton);
  saveButton.setStyleName(complexSaveButton);
  editButtons.add(undoButton);
  undoButton.setStyleName(displayInline);
  undoButton.setStyleName(complexUndoButton,true);
  editButtons.setStyleName(displayInline);
  addButton.setStyleName(complexAddButton);
  actionPanel.add(addButton);
  actionPanel.addStyleName(displayInline);
  actionPanel.addStyleName(complexActionContainer);
  mainPanel.add(dataPanel);
  mainPanel.add(actionPanel);
  editLabel.addClickHandler(new ClickHandler(){
    /** 
 * Event cached on click of the component.
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since  22 November 2012
 * @param event - The click event
 */
    @Override public void onClick(    ClickEvent event){
      setEditState();
      mainPanel.removeStyleName(grayRowStyling);
    }
  }
);
  removeLabel.addClickHandler(new ClickHandler(){
    /** 
 * Event cached on click of the component.
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since  22 November 2012
 * @param event - The click event
 */
    @Override public void onClick(    ClickEvent event){
      removeField();
    }
  }
);
  addButton.addClickHandler(new ClickHandler(){
    /** 
 * Event cached on click of the component.
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since  22 November 2012
 * @param event - The click event
 */
    @Override public void onClick(    ClickEvent event){
      addField();
    }
  }
);
  saveButton.addClickHandler(new ClickHandler(){
    /** 
 * Event cached on click of the component.
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since  22 November 2012
 * @param event - The click event
 */
    @Override public void onClick(    ClickEvent event){
      saveField();
    }
  }
);
  undoButton.addClickHandler(new ClickHandler(){
    /** 
 * Event cached on click of the component.
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since  22 November 2012
 * @param event - The click event
 */
    @Override public void onClick(    ClickEvent event){
      addUndo();
    }
  }
);
}","/** 
 * Function to construct all the components and add it to the main panel
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since  22 November 2012
 */
public void constructor(){
  messagePanel=new FlowPanel();
  messageTable=new FlowPanel();
  messageRow=new FlowPanel();
  messageCell=new Label();
  messageContainer=new FlowPanel();
  messageContainer.add(messagePanel);
  messagePanel.setVisible(false);
  mainPanel.add(messagePanel);
  dynamicFormPanel.add(getDynamicForm());
  dynamicFormPanel.addStyleName(displayInline);
  viewPanel.add(getUiBinder());
  viewPanel.setStyleName(displayInline);
  viewPanel.setVisible(false);
  dataPanel.add(dynamicFormPanel);
  dataPanel.add(viewPanel);
  dataPanel.setStyleName(displayInline);
  viewButtons.add(editLabel);
  editLabel.setStyleName(displayInline,true);
  editLabel.setStyleName(languageInputClickLabels,true);
  editLabel.setStyleName(complexLabelButton,true);
  viewButtons.add(removeLabel);
  removeLabel.setStyleName(displayInline,true);
  removeLabel.setStyleName(languageInputClickLabels,true);
  removeLabel.setStyleName(complexLabelButton,true);
  viewButtons.setStyleName(displayInline,true);
  editButtons.add(saveButton);
  saveButton.addStyleName(complexSaveButton);
  editButtons.add(undoButton);
  undoButton.addStyleName(displayInline);
  undoButton.addStyleName(complexUndoButton);
  editButtons.setStyleName(displayInline);
  addButton.setStyleName(complexAddButton);
  actionPanel.add(addButton);
  actionPanel.addStyleName(displayInline);
  actionPanel.addStyleName(complexActionContainer);
  mainPanel.add(dataPanel);
  mainPanel.add(actionPanel);
  editLabel.addClickHandler(new ClickHandler(){
    /** 
 * Event cached on click of the component.
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since  22 November 2012
 * @param event - The click event
 */
    @Override public void onClick(    ClickEvent event){
      setEditState();
      mainPanel.removeStyleName(grayRowStyling);
    }
  }
);
  removeLabel.addClickHandler(new ClickHandler(){
    /** 
 * Event cached on click of the component.
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since  22 November 2012
 * @param event - The click event
 */
    @Override public void onClick(    ClickEvent event){
      removeField();
    }
  }
);
  addButton.addClickHandler(new ClickHandler(){
    /** 
 * Event cached on click of the component.
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since  22 November 2012
 * @param event - The click event
 */
    @Override public void onClick(    ClickEvent event){
      addField();
    }
  }
);
  saveButton.addClickHandler(new ClickHandler(){
    /** 
 * Event cached on click of the component.
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since  22 November 2012
 * @param event - The click event
 */
    @Override public void onClick(    ClickEvent event){
      saveField();
    }
  }
);
  undoButton.addClickHandler(new ClickHandler(){
    /** 
 * Event cached on click of the component.
 * @author Alec Erasmus <alec.erasmus@a24group.com>
 * @since  22 November 2012
 * @param event - The click event
 */
    @Override public void onClick(    ClickEvent event){
      addUndo();
    }
  }
);
}"
50658,"@ClassName(""String_Node_Str"") String noContentLabelStyle();","/** 
 * Applied to the ""No Content"" label displayed.
 */
@ClassName(""String_Node_Str"") String noContentLabelStyle();"
50659,"/** 
 * Set global dynamic form keybord keypress handler on each field
 * @param handler - The handler tp apply to the fields 
 */
public void setKeyPressFieldsHandler(KeyPressHandler handler){
  for (  InputField inputField : fields.keySet()) {
    inputField.getInputFieldWidget().addDomHandler(handler,KeyPressEvent.getType());
  }
}","/** 
 * Set global dynamic form keyboard keypress handler on each field.
 * @param handler - The handler type apply to the fields 
 */
public void setKeyPressFieldsHandler(KeyPressHandler handler){
  for (  InputField inputField : fields.keySet()) {
    inputField.getInputFieldWidget().addDomHandler(handler,KeyPressEvent.getType());
  }
}"
50660,"/** 
 * The event that fires once you click on the button
 * @param event - The event that fires
 */
@Override public void onClick(ClickEvent event){
  SSFileSelector.clickOnInputFile(fileUpload.getElement());
  if (isForm) {
    Timer timer=new Timer(){
      /** 
 * This method will be called when a timer fires.
 */
      public void run(){
        if (!getFileSelectedComplete()) {
          this.schedule(500);
        }
 else {
          if (isValidation) {
            error=null;
            int x=getFileName().lastIndexOf(""String_Node_Str"");
            if (x == -1) {
              setError();
            }
 else {
              String extension=getFileName().substring(x);
              if (allowedFiles.contains(extension)) {
                form.submit();
              }
 else {
                setError();
              }
            }
          }
 else {
            form.submit();
          }
        }
      }
    }
;
    timer.run();
  }
}","/** 
 * The event that fires once you click on the button
 * @param event - The event that fires
 */
@Override public void onClick(ClickEvent event){
  SSFileSelector.clickOnInputFile(fileUpload.getElement());
  if (isForm) {
    Timer timer=new Timer(){
      /** 
 * This method will be called when a timer fires.
 */
      public void run(){
        if (!getFileSelectedComplete()) {
          this.schedule(500);
        }
 else {
          if (isValidation) {
            error=null;
            int x=getFileName().lastIndexOf(""String_Node_Str"");
            if (x == -1) {
              setError();
            }
 else {
              String extension=getFileName().substring(x + 1);
              if (allowedFiles.contains(extension)) {
                form.submit();
              }
 else {
                setError();
              }
            }
          }
 else {
            form.submit();
          }
        }
      }
    }
;
    timer.run();
  }
}"
50661,"/** 
 * Set the style on the component
 * @param style The stile name
 */
public void setStyleName(String style){
  button.setStyleName(style);
}","/** 
 * Set the style on the component
 * @param style The style name
 */
public void setStyleName(String style){
  button.setStyleName(style);
}"
50662,"/** 
 * Class constructor
 * @param label The label to display on the button
 */
public SSFileSelector(String label){
  FlowPanel mainContainer=new FlowPanel();
  fileUpload=new FileUpload();
  fileUpload.setWidth(""String_Node_Str"");
  fileUpload.setHeight(""String_Node_Str"");
  mainContainer.add(fileUpload);
  button=new Button(label);
  button.addClickHandler(new ClickHandler(){
    /** 
 * The event that fires once you click on the button
 * @param event - The event that fires
 */
    @Override public void onClick(    ClickEvent event){
      SSFileSelector.clickOnInputFile(fileUpload.getElement());
      if (isForm) {
        Timer timer=new Timer(){
          /** 
 * This method will be called when a timer fires.
 */
          public void run(){
            if (!getFileSelectedComplete()) {
              this.schedule(500);
            }
 else {
              if (isValidation) {
                error=null;
                int x=getFileName().lastIndexOf(""String_Node_Str"");
                if (x == -1) {
                  setError();
                }
 else {
                  String extension=getFileName().substring(x);
                  if (allowedFiles.contains(extension)) {
                    form.submit();
                  }
 else {
                    setError();
                  }
                }
              }
 else {
                form.submit();
              }
            }
          }
        }
;
        timer.run();
      }
    }
  }
);
  mainContainer.add(button);
  initWidget(mainContainer);
}","/** 
 * Class constructor
 * @param label The label to display on the button
 */
public SSFileSelector(String label){
  FlowPanel mainContainer=new FlowPanel();
  fileUpload=new FileUpload();
  fileUpload.setWidth(""String_Node_Str"");
  fileUpload.setHeight(""String_Node_Str"");
  mainContainer.add(fileUpload);
  button=new Button(label);
  button.addClickHandler(new ClickHandler(){
    /** 
 * The event that fires once you click on the button
 * @param event - The event that fires
 */
    @Override public void onClick(    ClickEvent event){
      SSFileSelector.clickOnInputFile(fileUpload.getElement());
      if (isForm) {
        Timer timer=new Timer(){
          /** 
 * This method will be called when a timer fires.
 */
          public void run(){
            if (!getFileSelectedComplete()) {
              this.schedule(500);
            }
 else {
              if (isValidation) {
                error=null;
                int x=getFileName().lastIndexOf(""String_Node_Str"");
                if (x == -1) {
                  setError();
                }
 else {
                  String extension=getFileName().substring(x + 1);
                  if (allowedFiles.contains(extension)) {
                    form.submit();
                  }
 else {
                    setError();
                  }
                }
              }
 else {
                form.submit();
              }
            }
          }
        }
;
        timer.run();
      }
    }
  }
);
  mainContainer.add(button);
  initWidget(mainContainer);
}"
50663,"/** 
 * This method will be called when a timer fires.
 */
public void run(){
  if (!getFileSelectedComplete()) {
    this.schedule(500);
  }
 else {
    if (isValidation) {
      error=null;
      int x=getFileName().lastIndexOf(""String_Node_Str"");
      if (x == -1) {
        setError();
      }
 else {
        String extension=getFileName().substring(x);
        if (allowedFiles.contains(extension)) {
          form.submit();
        }
 else {
          setError();
        }
      }
    }
 else {
      form.submit();
    }
  }
}","/** 
 * This method will be called when a timer fires.
 */
public void run(){
  if (!getFileSelectedComplete()) {
    this.schedule(500);
  }
 else {
    if (isValidation) {
      error=null;
      int x=getFileName().lastIndexOf(""String_Node_Str"");
      if (x == -1) {
        setError();
      }
 else {
        String extension=getFileName().substring(x + 1);
        if (allowedFiles.contains(extension)) {
          form.submit();
        }
 else {
          setError();
        }
      }
    }
 else {
      form.submit();
    }
  }
}"
50664,"/** 
 * Hides or shows the action bar
 * @param visible - The visibility of the action bar
 */
public void setActionBarVisible(boolean visible){
  actionBar.setVisible(visible);
}","/** 
 * Hides or shows the action bar
 * @param visible - The visibility of the action bar
 */
public void setActionBarVisible(boolean visible){
  actionBar.setVisible(visible);
  int actionBarHeight=0;
  if (visible) {
    actionBarHeight=32;
  }
  mainContainer.setWidgetBottomHeight(actionBar,0,Unit.PX,actionBarHeight,Unit.PX);
  mainContainer.setWidgetTopBottom(dataGrid,actionBarHeight,Unit.PX,0,Unit.PX);
}"
50665,"/** 
 * This function will set the state of the left menu item to the selected state
 * @author Ruan Naude <ruan.naude@a24group.com>
 * @since 09 July 2012
 */
public void setSelected(){
  if (!isAnimating) {
    LeftMenuItem.this.menuItem.getCommand().execute();
    isAnimating=true;
    leftMenuItem.setWidgetLeftRight(selectedPanel,0,Unit.PX,0,Unit.PX);
    leftMenuItem.setWidgetLeftWidth(notSelectedFlowPanel,-100,Unit.PCT,100,Unit.PCT);
    leftMenuItem.animate(600);
    Timer timer=new Timer(){
      public void run(){
        isAnimating=false;
        if (isUnselectQued) {
          isUnselectQued=false;
          setUnselected();
        }
      }
    }
;
    timer.schedule(680);
  }
}","/** 
 * This function will set the state of the left menu item to the selected state
 * @author Ruan Naude <ruan.naude@a24group.com>
 * @since 09 July 2012
 */
public void setSelected(){
  if (!isAnimating) {
    LeftMenuItem.this.menuItem.getCommand().execute();
    isAnimating=true;
    leftMenuItem.setWidgetLeftRight(selectedPanel,0,Unit.PX,0,Unit.PX);
    leftMenuItem.setWidgetLeftWidth(notSelectedFlowPanel,-100,Unit.PCT,100,Unit.PCT);
    Scheduler.get().scheduleDeferred(new Scheduler.ScheduledCommand(){
      public void execute(){
        leftMenuItem.animate(600);
      }
    }
);
    Timer timer=new Timer(){
      public void run(){
        isAnimating=false;
        if (isUnselectQued) {
          isUnselectQued=false;
          setUnselected();
        }
      }
    }
;
    timer.schedule(680);
  }
}"
50666,"/** 
 * Hides the placeholder by removing the placeholder text from the datepicker and also removing the placeholder style name from the datepicker.
 * @author Michael Barnard <michael.barnard@a24group.com>
 * @since 18 July 2012
 */
public void hidePlaceholder(){
  if (super.getTextBox().getText().equals(this.getPlaceholderText())) {
    super.getTextBox().setText(""String_Node_Str"");
    super.getTextBox().removeStyleName(this.getPlaceholderStyleName());
  }
}","/** 
 * Hides the placeholder by removing the placeholder text from the datepicker and also removing the placeholder style name from the datepicker.
 * @author Michael Barnard <michael.barnard@a24group.com>
 * @since 18 July 2012
 */
public void hidePlaceholder(){
  if (super.getTextBox().getText().equals(this.getPlaceholderText())) {
    super.getTextBox().setText(""String_Node_Str"");
  }
  super.getTextBox().removeStyleName(this.getPlaceholderStyleName());
}"
50667,"/** 
 * Sets the inner text of the element.
 * @param value The new value
 */
private void setText(String value){
  Element divChild;
  if (getElement().getChild(0).getNodeType() == Node.ELEMENT_NODE) {
    divChild=(Element)getElement().getChild(0);
  }
 else {
    divChild=DOM.createDiv();
    divChild.addClassName(css().wrap(""String_Node_Str""));
    getElement().appendChild(divChild);
  }
  DOM.setInnerText(divChild,value);
  DOM.setInnerText(getElement(),""String_Node_Str"");
  DOM.appendChild(getElement(),divChild);
}","/** 
 * Sets the inner text of the element.
 * @param value The new value
 */
private void setText(String value){
  Element divChild;
  if (getElement().getChild(0).getNodeType() == Node.ELEMENT_NODE) {
    divChild=(Element)getElement().getChild(0);
  }
 else {
    divChild=DOM.createDiv();
    divChild.addClassName(css().wrap(""String_Node_Str""));
    getElement().appendChild(divChild);
  }
  DOM.setInnerText(getElement(),""String_Node_Str"");
  DOM.setInnerText(divChild,value);
  DOM.appendChild(getElement(),divChild);
}"
50668,"/** 
 * Sets the inner text of the element.
 * @param value The new value
 */
private void setText(String value){
  Element divChild;
  if (getElement().getChild(0).getNodeType() == Node.ELEMENT_NODE) {
    divChild=(Element)getElement().getChild(0);
  }
 else {
    divChild=DOM.createDiv();
    divChild.addClassName(css().wrap(""String_Node_Str""));
    getElement().appendChild(divChild);
  }
  DOM.setInnerText(divChild,value);
  DOM.setInnerText(getElement(),""String_Node_Str"");
  DOM.appendChild(getElement(),divChild);
}","/** 
 * Sets the inner text of the element.
 * @param value The new value
 */
private void setText(String value){
  Element divChild;
  if (getElement().getChild(0).getNodeType() == Node.ELEMENT_NODE) {
    divChild=(Element)getElement().getChild(0);
  }
 else {
    divChild=DOM.createDiv();
    divChild.addClassName(css().wrap(""String_Node_Str""));
    getElement().appendChild(divChild);
  }
  DOM.setInnerText(getElement(),""String_Node_Str"");
  DOM.setInnerText(divChild,value);
  DOM.appendChild(getElement(),divChild);
}"
50669,"/** 
 * Handle a browser event that took place within the cell. The default implementation returns null.
 * @param context - the {@link Context} of the cell
 * @param parent - the parent Element
 * @param value - the value associated with the cell
 * @param event - the native browser event
 * @param valueUpdater - a {@link ValueUpdater}, or null if not specified
 */
@Override public void onBrowserEvent(Context context,Element parent,HeaderDetails value,NativeEvent event,ValueUpdater<HeaderDetails> valueUpdater){
  super.onBrowserEvent(context,parent,value,event,valueUpdater);
  Element filterImageElement=getImageElement(parent);
  Element filterImageParentElement=filterImageElement.getParentElement();
  if (event.getEventTarget().equals(filterImageElement)) {
    if (""String_Node_Str"".equals(event.getType())) {
      replaceImageElement(resources.filterIconDown(),filterImageElement,filterImageParentElement);
    }
 else     if (""String_Node_Str"".equals(event.getType())) {
      replaceImageElement(resources.filterIconOver(),filterImageElement,filterImageParentElement);
    }
 else     if (""String_Node_Str"".equals(event.getType())) {
      if (filterActive) {
        replaceImageElement(resources.filterIconActive(),filterImageElement,filterImageParentElement);
      }
 else {
        replaceImageElement(resources.filterIconInactive(),filterImageElement,filterImageParentElement);
      }
    }
 else     if (""String_Node_Str"".equals(event.getType())) {
      replaceImageElement(resources.filterIconOver(),filterImageElement,filterImageParentElement);
    }
  }
}","/** 
 * Handle a browser event that took place within the cell. The default implementation returns null.
 * @param context - the {@link Context} of the cell
 * @param parent - the parent Element
 * @param value - the value associated with the cell
 * @param event - the native browser event
 * @param valueUpdater - a {@link ValueUpdater}, or null if not specified
 */
@Override public void onBrowserEvent(Context context,Element parent,HeaderDetails value,NativeEvent event,ValueUpdater<HeaderDetails> valueUpdater){
  super.onBrowserEvent(context,parent,value,event,valueUpdater);
  Element filterImageElement=getImageElement(parent);
  Element filterImageParentElement=filterImageElement.getParentElement();
  if (event.getEventTarget().equals(filterImageElement)) {
    if (""String_Node_Str"".equals(event.getType())) {
      replaceImageElement(resources.filterIconDown(),filterImageElement,filterImageParentElement);
    }
 else     if (""String_Node_Str"".equals(event.getType())) {
      if (doMouseOver && Window.Navigator.getAppName().equals(""String_Node_Str"")) {
        doMouseOver=false;
        replaceImageElement(resources.filterIconOver(),filterImageElement,filterImageParentElement);
      }
 else       if (!Window.Navigator.getAppName().equals(""String_Node_Str"")) {
        replaceImageElement(resources.filterIconOver(),filterImageElement,filterImageParentElement);
      }
    }
 else     if (""String_Node_Str"".equals(event.getType())) {
      if (Window.Navigator.getAppName().equals(""String_Node_Str"")) {
        doMouseOver=true;
      }
      if (filterActive) {
        replaceImageElement(resources.filterIconActive(),filterImageElement,filterImageParentElement);
      }
 else {
        replaceImageElement(resources.filterIconInactive(),filterImageElement,filterImageParentElement);
      }
    }
 else     if (""String_Node_Str"".equals(event.getType())) {
      replaceImageElement(resources.filterIconOver(),filterImageElement,filterImageParentElement);
    }
  }
}"
50670,"@Override public void onSelectAllEvent(SelectAllEvent event){
  DataGrid dataGrid=SSDataGrid.this.dataGrid;
  Range rows=dataGrid.getVisibleRange();
  int end=rows.getStart() + rows.getLength();
  int numRecordsDisplayed=rows.getLength();
  if (end > dataGrid.getRowCount()) {
    end=dataGrid.getRowCount();
    numRecordsDisplayed=end % numRecordsDisplayed;
  }
  boolean allSelected=true;
  for (int i=rows.getStart(); i < end; i++) {
    if (!dataProvider.getList().get(i).isSelected()) {
      allSelected=false;
      break;
    }
  }
  for (int i=rows.getStart(); i < end; i++) {
    dataProvider.getList().get(i).setSelected(!allSelected);
  }
  dataProvider.refresh();
  for (int i=0; i < numRecordsDisplayed; i++) {
    setRowSelectedStyle(i,!allSelected);
  }
}","/** 
 * Event triggered when the select all button is clicked
 * @param event - The event that was fired
 */
@Override public void onSelectAllEvent(SelectAllEvent event){
  DataGrid dataGrid=SSDataGrid.this.dataGrid;
  Range rows=dataGrid.getVisibleRange();
  int end=rows.getStart() + rows.getLength();
  int numRecordsDisplayed=rows.getLength();
  if (end > dataGrid.getRowCount()) {
    end=dataGrid.getRowCount();
    numRecordsDisplayed=end % numRecordsDisplayed;
  }
  boolean allSelected=true;
  for (int i=rows.getStart(); i < end; i++) {
    if (!dataProvider.getList().get(i).isSelected()) {
      allSelected=false;
      break;
    }
  }
  for (int i=rows.getStart(); i < end; i++) {
    dataProvider.getList().get(i).setSelected(!allSelected);
  }
  refresh();
}"
50671,"/** 
 * Update the selection state 
 * @param index - the index of the row to be updated
 * @param object - The object currently being referenced
 * @param value - the selected state of the current row
 */
@Override public void update(int index,T object,Boolean value){
  setRowSelectedStyle((index - SSDataGrid.this.dataGrid.getVisibleRange().getStart()),value);
  object.setSelected(value);
}","/** 
 * Update the selection state 
 * @param index - the index of the row to be updated
 * @param object - The object currently being referenced
 * @param value - the selected state of the current row
 */
@Override public void update(int index,T object,Boolean value){
  object.setSelected(value);
  refresh();
}"
50672,"/** 
 * Add a field that supports multiple selection
 */
public void addMultiSelectField(){
  Cell<Boolean> booleanCell=(Cell<Boolean>)new CheckboxCell();
  Column<T,Boolean> selectedColumn=new Column<T,Boolean>(booleanCell){
    /** 
 * Get the value of the multi select field
 * @return the selected state of the row
 */
    @Override public Boolean getValue(    T object){
      return object.isSelected();
    }
  }
;
  SelectAllHeader header=new SelectAllHeader();
  header.addEventHandler(new ISelectAllEventHandler(){
    @Override public void onSelectAllEvent(    SelectAllEvent event){
      DataGrid dataGrid=SSDataGrid.this.dataGrid;
      Range rows=dataGrid.getVisibleRange();
      int end=rows.getStart() + rows.getLength();
      int numRecordsDisplayed=rows.getLength();
      if (end > dataGrid.getRowCount()) {
        end=dataGrid.getRowCount();
        numRecordsDisplayed=end % numRecordsDisplayed;
      }
      boolean allSelected=true;
      for (int i=rows.getStart(); i < end; i++) {
        if (!dataProvider.getList().get(i).isSelected()) {
          allSelected=false;
          break;
        }
      }
      for (int i=rows.getStart(); i < end; i++) {
        dataProvider.getList().get(i).setSelected(!allSelected);
      }
      dataProvider.refresh();
      for (int i=0; i < numRecordsDisplayed; i++) {
        setRowSelectedStyle(i,!allSelected);
      }
    }
  }
);
  dataGrid.addColumn(selectedColumn,header);
  dataGrid.setColumnWidth(selectedColumn,""String_Node_Str"");
  selectedColumn.setFieldUpdater(new FieldUpdater<T,Boolean>(){
    /** 
 * Update the selection state 
 * @param index - the index of the row to be updated
 * @param object - The object currently being referenced
 * @param value - the selected state of the current row
 */
    @Override public void update(    int index,    T object,    Boolean value){
      setRowSelectedStyle((index - SSDataGrid.this.dataGrid.getVisibleRange().getStart()),value);
      object.setSelected(value);
    }
  }
);
}","/** 
 * Add a field that supports multiple selection
 */
public void addMultiSelectField(){
  Cell<Boolean> booleanCell=(Cell<Boolean>)new CheckboxCell();
  Column<T,Boolean> selectedColumn=new Column<T,Boolean>(booleanCell){
    /** 
 * Get the value of the multi select field
 * @return the selected state of the row
 */
    @Override public Boolean getValue(    T object){
      return object.isSelected();
    }
  }
;
  SelectAllHeader header=new SelectAllHeader();
  header.addEventHandler(new ISelectAllEventHandler(){
    /** 
 * Event triggered when the select all button is clicked
 * @param event - The event that was fired
 */
    @Override public void onSelectAllEvent(    SelectAllEvent event){
      DataGrid dataGrid=SSDataGrid.this.dataGrid;
      Range rows=dataGrid.getVisibleRange();
      int end=rows.getStart() + rows.getLength();
      int numRecordsDisplayed=rows.getLength();
      if (end > dataGrid.getRowCount()) {
        end=dataGrid.getRowCount();
        numRecordsDisplayed=end % numRecordsDisplayed;
      }
      boolean allSelected=true;
      for (int i=rows.getStart(); i < end; i++) {
        if (!dataProvider.getList().get(i).isSelected()) {
          allSelected=false;
          break;
        }
      }
      for (int i=rows.getStart(); i < end; i++) {
        dataProvider.getList().get(i).setSelected(!allSelected);
      }
      refresh();
    }
  }
);
  dataGrid.addColumn(selectedColumn,header);
  dataGrid.setColumnWidth(selectedColumn,""String_Node_Str"");
  selectedColumn.setFieldUpdater(new FieldUpdater<T,Boolean>(){
    /** 
 * Update the selection state 
 * @param index - the index of the row to be updated
 * @param object - The object currently being referenced
 * @param value - the selected state of the current row
 */
    @Override public void update(    int index,    T object,    Boolean value){
      object.setSelected(value);
      refresh();
    }
  }
);
}"
50673,"private void setRowSelectedStyle(int rowIndex,boolean selected){
  TableRowElement tableRow=dataGrid.getRowElement(rowIndex);
  String styleNames=tableRow.getAttribute(""String_Node_Str"");
  String newStyles=styleNames;
  boolean containsStyle=styleNames.contains(""String_Node_Str"");
  if (containsStyle && !selected) {
    newStyles=""String_Node_Str"";
    String[] styles=styleNames.split(""String_Node_Str"");
    for (int i=0; i < styles.length; i++) {
      if (!styles[i].equals(""String_Node_Str"")) {
        newStyles+=""String_Node_Str"" + styles[i];
      }
    }
  }
 else   if (!containsStyle && selected) {
    newStyles+=""String_Node_Str"";
  }
  tableRow.setAttribute(""String_Node_Str"",newStyles);
}","/** 
 * Sets the style of a selected row at a certain index
 * @param rowIndex - The index of the row that needs to change
 * @param selected - Whether or not the row is selected
 */
private void setRowSelectedStyle(int rowIndex,boolean selected){
  TableRowElement tableRow=dataGrid.getRowElement(rowIndex);
  String styleNames=tableRow.getClassName();
  String newStyles=styleNames;
  boolean containsStyle=styleNames.contains(""String_Node_Str"");
  if (containsStyle && !selected) {
    newStyles=""String_Node_Str"";
    String[] styles=styleNames.split(""String_Node_Str"");
    for (int i=0; i < styles.length; i++) {
      if (!styles[i].equals(""String_Node_Str"")) {
        newStyles+=""String_Node_Str"" + styles[i];
      }
    }
  }
 else   if (!containsStyle && selected) {
    if (!newStyles.equals(""String_Node_Str"")) {
      newStyles+=""String_Node_Str"";
    }
    newStyles+=""String_Node_Str"";
  }
  tableRow.setClassName(newStyles);
  Label l=new Label(""String_Node_Str"");
  if (Window.Navigator.getAppName().equals(""String_Node_Str"")) {
    tableRow.appendChild(l.getElement());
    tableRow.removeChild(l.getElement());
  }
}"
50674,"/** 
 * Class Constructor
 * @author Michael Barnard
 * @since 02 July 2012
 * @param dataGridResource - The resource that needs to be used for the data grid
 * @param pagerResource - The resource  that needs to be used for the pager
 * @param multiSelect - Whether the data grid supports multiple selects
 */
public SSDataGrid(DataGrid.Resources dataGridResource,SSPager.Resources pagerResource,boolean multiSelect){
  dataGrid=new DataGrid<T>(10,dataGridResource);
  dataGrid.addColumnSortHandler(new ColumnSortEvent.Handler(){
    /** 
 * Will be called on a column sort event
 * @param event - The event that initialise the handler
 */
    @Override public void onColumnSort(    ColumnSortEvent event){
      ColumnSortInfo columnSortInfo;
      if ((columnSortInfo=columnSortDetail.get(event.getColumn())) != null) {
        columnSortDetail.remove(event.getColumn());
        columnSortDetail.put(event.getColumn(),new ColumnSortInfo(event.getColumn(),!columnSortInfo.isAscending()));
      }
 else {
        columnSortDetail.put(event.getColumn(),new ColumnSortInfo(event.getColumn(),true));
      }
      SSDataGrid.this.dataGrid.getColumnSortList().push(columnSortDetail.get(event.getColumn()));
      fireEvent(new DataGridSortEvent(event.getColumn(),columnSortDetail.get(event.getColumn()).isAscending()));
    }
  }
);
  dataProvider.addDataDisplay(dataGrid);
  pager=new SSPager(TextLocation.CENTER,pagerResource,false,0,true);
  pager.setDisplay(dataGrid);
  setMultiSelect(multiSelect);
  setClickAction(false);
  this.initWidget(uiBinder.createAndBindUi(this));
  Resources.INSTANCE.dataGridStyle().ensureInjected();
  actionBar.setStyleName(Resources.INSTANCE.dataGridStyle().actionBarStyle());
}","/** 
 * Class Constructor
 * @author Michael Barnard
 * @since 02 July 2012
 * @param dataGridResource - The resource that needs to be used for the data grid
 * @param pagerResource - The resource  that needs to be used for the pager
 * @param multiSelect - Whether the data grid supports multiple selects
 */
public SSDataGrid(DataGrid.Resources dataGridResource,SSPager.Resources pagerResource,boolean multiSelect){
  dataGrid=new DataGrid<T>(10,dataGridResource);
  dataGrid.addColumnSortHandler(new ColumnSortEvent.Handler(){
    /** 
 * Will be called on a column sort event
 * @param event - The event that initialise the handler
 */
    @Override public void onColumnSort(    ColumnSortEvent event){
      ColumnSortInfo columnSortInfo;
      if ((columnSortInfo=columnSortDetail.get(event.getColumn())) != null) {
        columnSortDetail.remove(event.getColumn());
        columnSortDetail.put(event.getColumn(),new ColumnSortInfo(event.getColumn(),!columnSortInfo.isAscending()));
      }
 else {
        columnSortDetail.put(event.getColumn(),new ColumnSortInfo(event.getColumn(),true));
      }
      SSDataGrid.this.dataGrid.getColumnSortList().push(columnSortDetail.get(event.getColumn()));
      fireEvent(new DataGridSortEvent(event.getColumn(),columnSortDetail.get(event.getColumn()).isAscending()));
    }
  }
);
  dataProvider.addDataDisplay(dataGrid);
  pager=new SSPager(TextLocation.CENTER,pagerResource,false,0,true);
  pager.setDisplay(dataGrid);
  setMultiSelect(multiSelect);
  setClickAction(false);
  this.initWidget(uiBinder.createAndBindUi(this));
  Resources.INSTANCE.dataGridStyle().ensureInjected();
  actionBar.setStyleName(Resources.INSTANCE.dataGridStyle().actionBarStyle());
  dataGrid.addRangeChangeHandler(new RangeChangeEvent.Handler(){
    /** 
 * Event that is called when the pager navigation buttons are clicked
 * @param event - The event that is triggered
 */
    @Override public void onRangeChange(    RangeChangeEvent event){
      refresh();
    }
  }
);
}"
50675,"/** 
 * Hides the action bar by setting it invisible
 */
public void hideActionBar(){
  actionBar.setVisible(false);
}","/** 
 * Hides or shows the action bar
 * @param visible - The visibility of the action bar
 */
public void hideActionBar(boolean visible){
  actionBar.setVisible(visible);
}"
50676,"/** 
 * Does the validation and sets styles accordingly
 * @return String - The error string or null if the validation passes
 */
public String doValidation(){
  for (int i=0; i < fields.size(); i++) {
    if (fields.get(i).errorStyleName != null) {
      fields.get(i).uiField.removeStyleName(fields.get(i).errorStyleName.toString());
    }
  }
  for (int i=0; i < fields.size(); i++) {
    ValidatorInterface<String> validator=(ValidatorInterface<String>)validatorFactory(fields.get(i).validatorReferenceName);
    validator.setConfiguration(fields.get(i).config);
    boolean valid=validator.isValid(((AdvancedTextbox)fields.get(i).uiField).getValue());
    if (!valid) {
      if (fields.get(i).errorStyleName != null) {
        fields.get(i).uiField.addStyleName(fields.get(i).errorStyleName.toString());
      }
      if (fields.get(i).errorMessage != null) {
        return fields.get(i).errorMessage;
      }
 else {
        return validator.getDefaultValidationMessage();
      }
    }
  }
  return null;
}","/** 
 * Does the validation and sets styles accordingly
 * @return String - The error string or null if the validation passes
 */
public String doValidation(){
  int fieldSize=fields.size();
  for (int i=0; i < fieldSize; i++) {
    if (fields.get(i).errorStyleName != null) {
      fields.get(i).uiField.removeStyleName(fields.get(i).errorStyleName.toString());
    }
  }
  for (int i=0; i < fieldSize; i++) {
    ValidatorInterface<String> validator=(ValidatorInterface<String>)validatorFactory(fields.get(i).validatorReferenceName);
    validator.setConfiguration(fields.get(i).config);
    boolean valid=validator.isValid(((AdvancedTextbox)fields.get(i).uiField).getValue());
    if (!valid) {
      if (fields.get(i).errorStyleName != null) {
        fields.get(i).uiField.addStyleName(fields.get(i).errorStyleName.toString());
      }
      if (fields.get(i).errorMessage != null) {
        return fields.get(i).errorMessage;
      }
 else {
        return validator.getDefaultValidationMessage();
      }
    }
  }
  return null;
}"
50677,"@Override public LocalOperation adaptTo(CRDT replica){
  int sizeDoc=((MergeAlgorithm)replica).getDoc().viewLength();
  if (getType() == OpType.insert) {
    if (position > sizeDoc) {
      position=sizeDoc;
    }
  }
 else   if (this.position >= sizeDoc) {
    position=sizeDoc - 1;
  }
  if ((getType() == OpType.delete || getType() == OpType.update) && position + argument > sizeDoc) {
    argument=sizeDoc - position;
  }
  if ((getType() == OpType.update || getType() == OpType.move) && position + content.size() > sizeDoc) {
    content=content.subList(0,sizeDoc - position);
  }
  return this;
}","@Override public LocalOperation adaptTo(CRDT replica){
  int sizeDoc=((MergeAlgorithm)replica).getDoc().viewLength();
  if (getType() == OpType.insert) {
    if (position > sizeDoc) {
      position=sizeDoc;
    }
  }
 else   if (this.type == OpType.delete && sizeDoc == 0) {
    return new SequenceOperation(OpType.noop,0,0,null);
  }
 else   if (this.position >= sizeDoc) {
    position=sizeDoc - 1;
  }
  if ((getType() == OpType.delete || getType() == OpType.update) && position + argument > sizeDoc) {
    argument=sizeDoc - position;
  }
  if ((getType() == OpType.update || getType() == OpType.move) && position + content.size() > sizeDoc) {
    content=content.subList(0,sizeDoc - position);
  }
  return this;
}"
50678,"@Override void delBlock(int begin,int end,int nbElement){
  nbElement-=nbElement;
}","@Override void delBlock(int begin,int end,int nbElement){
  this.nbElement-=nbElement;
}"
50679,"@Override public void remove(int position,int offset){
  idTable.removeRangeOffset(position + 1,offset);
  document.delete(position,position + offset);
}","@Override public void remove(int position,int offset){
  idTable.removeRangeOffset(position + 1,offset);
  document.delete(position,position + offset + 1);
}"
50680,"@Override public int viewLength(){
  return document.length();
}","@Override public int viewLength(){
  return documentStr.length();
}"
50681,"@Override public String view(){
  return document.toString();
}","@Override public String view(){
  return documentStr.toString();
}"
50682,"@Override public void apply(Operation op){
  LogootOperation lg=(LogootOperation)op;
  ListIdentifier idToSearch=lg.getIdentifiant();
  int pos=dicho(idToSearch);
  if (lg.getType() == SequenceMessage.MessageType.ins) {
    idTable.add(pos,idToSearch);
    document.insert(pos - 1,lg.getContent());
  }
 else   if (idTable.get(pos).equals(idToSearch)) {
    idTable.remove(pos);
    document.deleteCharAt(pos - 1);
  }
}","@Override public void apply(Operation op){
  LogootOperation lg=(LogootOperation)op;
  ListIdentifier idToSearch=lg.getIdentifiant();
  int pos=dicho(idToSearch);
  if (lg.getType() == SequenceMessage.MessageType.ins) {
    idTable.add(pos,idToSearch);
    documentStr.insert(pos - 1,lg.getContent());
  }
 else   if (idTable.get(pos).equals(idToSearch)) {
    idTable.remove(pos);
    documentStr.deleteCharAt(pos - 1);
  }
}"
50683,"public LogootDocumentChar(int r,LogootStrategy strategy){
  super(r,strategy);
  document=new StringBuilder();
  this.replicaNumber=r;
  myClock=0;
}","public LogootDocumentChar(int r,LogootStrategy strategy){
  super(r,strategy);
  documentStr=new StringBuilder();
  this.replicaNumber=r;
  myClock=0;
}"
50684,"@Override public int hashCode(){
  int hash=7;
  hash=97 * hash + (this.idTable != null ? this.idTable.hashCode() : 0);
  hash=97 * hash + (this.document != null ? this.document.hashCode() : 0);
  return hash;
}","@Override public int hashCode(){
  int hash=7;
  hash=97 * hash + (this.idTable != null ? this.idTable.hashCode() : 0);
  hash=97 * hash + (this.documentStr != null ? this.documentStr.hashCode() : 0);
  return hash;
}"
50685,"@Override public boolean equals(Object obj){
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  final LogootDocumentChar other=(LogootDocumentChar)obj;
  if (this.idTable != other.idTable && (this.idTable == null || !this.idTable.equals(other.idTable))) {
    return false;
  }
  if (this.document != other.document && (this.document == null || !this.document.equals(other.document))) {
    return false;
  }
  return true;
}","@Override public boolean equals(Object obj){
  if (obj == null) {
    return false;
  }
  if (getClass() != obj.getClass()) {
    return false;
  }
  final LogootDocumentChar other=(LogootDocumentChar)obj;
  if (this.idTable != other.idTable && (this.idTable == null || !this.idTable.equals(other.idTable))) {
    return false;
  }
  if (this.documentStr != other.documentStr && (this.documentStr == null || !this.documentStr.equals(other.documentStr))) {
    return false;
  }
  return true;
}"
50686,"@Override public void insert(int position,List<ListIdentifier> patch,List<Character> lc){
  idTable.addAll(position + 1,patch);
  document.insert(position,makeChar(lc));
}","@Override public void insert(int position,List<ListIdentifier> patch,List<Character> lc){
  idTable.addAll(position + 1,patch);
  documentStr.insert(position,makeChar(lc));
}"
50687,"@Override public void remove(int position,int offset){
  idTable.removeRangeOffset(position + 1,offset);
  document.delete(position,position + offset + 1);
}","@Override public void remove(int position,int offset){
  idTable.removeRangeOffset(position + 1,offset);
  documentStr.delete(position,position + offset);
}"
50688,"@Override public LocalOperation adaptTo(CRDT replica){
  OrderedNode root=(OrderedNode)replica.lookup();
  int i=0;
  List<Integer> nPath=new LinkedList();
  OrderedNode node=adaptPath(this.path,root,nPath);
  int nPos=this.position;
switch (this.type) {
case add:
    if (nPos > node.getChildrenNumber()) {
      nPos=node.getChildrenNumber();
    }
  return new OrderedTreeOperation(nPath,nPos,this.content);
case del:
return new OrderedTreeOperation(nPath);
case move:
List<Integer> nPathDst=new LinkedList();
OrderedNode nodedst=adaptPath(this.dstPath,root,nPathDst);
if (nPos > nodedst.getChildrenNumber()) {
nPos=nodedst.getChildrenNumber();
}
return new OrderedTreeOperation(type,nPath,nPathDst,nPos,null);
case chContent:
return new OrderedTreeOperation(type,nPath,null,0,this.content);
default :
throw new UnsupportedOperationException(""String_Node_Str"");
}
}","@Override public LocalOperation adaptTo(CRDT replica){
  OrderedNode root=(OrderedNode)replica.lookup();
  int i=0;
  List<Integer> nPath=new LinkedList();
  OrderedNode node=adaptPath(this.path,root,nPath);
  int nPos=this.position;
switch (this.type) {
case add:
    if (nPos > node.getChildrenNumber()) {
      nPos=node.getChildrenNumber();
    }
  return new OrderedTreeOperation(nPath,nPos,this.content);
case del:
if (nPath.isEmpty()) {
  return new OrderedTreeOperation(nPath,nPos,root.getValue());
}
 else {
  return new OrderedTreeOperation(nPath);
}
case move:
List<Integer> nPathDst=new LinkedList();
OrderedNode nodedst=adaptPath(this.dstPath,root,nPathDst);
if (nPos > nodedst.getChildrenNumber()) {
nPos=nodedst.getChildrenNumber();
}
return new OrderedTreeOperation(type,nPath,nPathDst,nPos,null);
case chContent:
return new OrderedTreeOperation(type,nPath,null,0,this.content);
default :
throw new UnsupportedOperationException(""String_Node_Str"");
}
}"
50689,"@Override public void postDel(Del operation,FCNode node){
  for (  Object n : node.getElements()) {
    postDel(operation,node);
    tree.getMap().remove((FCNode)n);
  }
}","@Override public void postDel(Del operation,FCNode node){
  for (  Object n : node.getElements()) {
    postDel(operation,node);
    tree.getMap().remove(((FCNode)n).getId());
  }
}"
50690,"@Override public void run(Trace trace,boolean detail,boolean saveTrace,int nbrTrace,boolean o) throws IncorrectTraceException, PreconditionException, IOException {
  this.detail=detail;
  this.nbrTrace=nbrTrace;
  overhead=o;
  long tmp;
  final Map<Integer,VectorClock> clocks=new HashMap<Integer,VectorClock>();
  final VectorClock globalClock=new VectorClock();
  final List<TraceOperation> concurrentOps=new LinkedList<TraceOperation>();
  final Enumeration<TraceOperation> it=trace.enumeration();
  orderTrace=new HashMap();
  int numTrace=0;
  if (saveTrace) {
    writer=new ObjectOutputStream(new FileOutputStream(""String_Node_Str""));
  }
  setOp=new HashSet();
  history=new HashMap<Integer,List<TraceOperation>>();
  genHistory=new HashMap<Integer,List<CRDTMessage>>();
  while (it.hasMoreElements()) {
    tour++;
    final TraceOperation opt=it.nextElement();
    final int r=opt.getReplica();
    CRDT localReplica=this.getReplicas().get(r);
    if (localReplica == null) {
      localReplica=this.newReplica(r);
      clocks.put(r,new VectorClock());
      genHistory.put(r,new ArrayList<CRDTMessage>());
      history.put(r,new ArrayList<TraceOperation>());
    }
    VectorClock vc=clocks.get(r);
    if (!vc.readyFor(r,opt.getVectorClock())) {
      Iterator<Integer> i=opt.getVectorClock().keySet().iterator();
      concurrentOps.clear();
      while (i.hasNext()) {
        int e=i.next();
        if (e != r) {
          for (int j=opt.getVectorClock().get(e); j > vc.getSafe(e); j--) {
            insertCausalOrder(concurrentOps,history.get(e).get(j - 1));
          }
        }
      }
      play(localReplica,vc,concurrentOps);
    }
    LocalOperation op=opt.getOperation();
    op=op.adaptTo(localReplica);
    if (saveTrace) {
      storeOp(opt);
    }
    history.get(r).add(opt);
    if (detail) {
      orderTrace.put(opt,numTrace++);
    }
    if (!vc.readyFor(r,opt.getVectorClock())) {
      throw new IncorrectTraceException(""String_Node_Str"" + r + ""String_Node_Str""+ vc+ ""String_Node_Str""+ opt.getVectorClock());
    }
    tmp=System.nanoTime();
    final CRDTMessage m=localReplica.applyLocal(op);
    long after=System.nanoTime();
    localSum+=(after - tmp);
    if (detail) {
      genTime.add(after - tmp);
      genSize.add(m.size());
      remoteTime.add(0L);
    }
    nbLocal++;
    final CRDTMessage msg=m.clone();
    genHistory.get(r).add(msg);
    clocks.get(r).inc(r);
    globalClock.inc(r);
    ifSerializ();
  }
  ifSerializ();
  for (  CRDT r : replicas.values()) {
    int n=r.getReplicaNumber();
    concurrentOps.clear();
    VectorClock vc=clocks.get(n);
    for (    Entry<Integer,Integer> e : globalClock.entrySet()) {
      for (int j=vc.getSafe(e.getKey()); j < e.getValue(); ++j) {
        insertCausalOrder(concurrentOps,history.get(e.getKey()).get(j));
      }
    }
    play(r,vc,concurrentOps);
  }
  if (writer != null) {
    writer.close();
  }
}","@Override public void run(Trace trace,boolean detail,boolean saveTrace,int nbrTrace,boolean overhead) throws IncorrectTraceException, PreconditionException, IOException {
  this.detail=detail;
  this.nbrTrace=nbrTrace;
  this.overhead=overhead;
  long tmp;
  final Map<Integer,VectorClock> clocks=new HashMap<Integer,VectorClock>();
  final VectorClock globalClock=new VectorClock();
  final List<TraceOperation> concurrentOps=new LinkedList<TraceOperation>();
  final Enumeration<TraceOperation> it=trace.enumeration();
  orderTrace=new HashMap();
  int numTrace=0;
  if (saveTrace) {
    writer=new ObjectOutputStream(new FileOutputStream(""String_Node_Str""));
  }
  setOp=new HashSet();
  history=new HashMap<Integer,List<TraceOperation>>();
  genHistory=new HashMap<Integer,List<CRDTMessage>>();
  while (it.hasMoreElements()) {
    tour++;
    final TraceOperation opt=it.nextElement();
    final int r=opt.getReplica();
    CRDT localReplica=this.getReplicas().get(r);
    if (localReplica == null) {
      localReplica=this.newReplica(r);
      clocks.put(r,new VectorClock());
      genHistory.put(r,new ArrayList<CRDTMessage>());
      history.put(r,new ArrayList<TraceOperation>());
    }
    VectorClock vc=clocks.get(r);
    if (!vc.readyFor(r,opt.getVectorClock())) {
      Iterator<Integer> i=opt.getVectorClock().keySet().iterator();
      concurrentOps.clear();
      while (i.hasNext()) {
        int e=i.next();
        if (e != r) {
          for (int j=opt.getVectorClock().get(e); j > vc.getSafe(e); j--) {
            insertCausalOrder(concurrentOps,history.get(e).get(j - 1));
          }
        }
      }
      play(localReplica,vc,concurrentOps);
    }
    LocalOperation op=opt.getOperation();
    op=op.adaptTo(localReplica);
    if (saveTrace) {
      storeOp(opt);
    }
    history.get(r).add(opt);
    if (detail) {
      orderTrace.put(opt,numTrace++);
    }
    if (!vc.readyFor(r,opt.getVectorClock())) {
      throw new IncorrectTraceException(""String_Node_Str"" + r + ""String_Node_Str""+ vc+ ""String_Node_Str""+ opt.getVectorClock());
    }
    tmp=System.nanoTime();
    final CRDTMessage m=localReplica.applyLocal(op);
    long after=System.nanoTime();
    localSum+=(after - tmp);
    if (detail) {
      genTime.add(after - tmp);
      genSize.add(m.size());
      remoteTime.add(0L);
    }
    nbLocal++;
    final CRDTMessage msg=m.clone();
    genHistory.get(r).add(msg);
    clocks.get(r).inc(r);
    globalClock.inc(r);
    ifSerializ();
  }
  ifSerializ();
  for (  CRDT r : replicas.values()) {
    int n=r.getReplicaNumber();
    concurrentOps.clear();
    VectorClock vc=clocks.get(n);
    for (    Entry<Integer,Integer> e : globalClock.entrySet()) {
      for (int j=vc.getSafe(e.getKey()); j < e.getValue(); ++j) {
        insertCausalOrder(concurrentOps,history.get(e.getKey()).get(j));
      }
    }
    play(r,vc,concurrentOps);
  }
  if (writer != null) {
    writer.close();
  }
}"
50691,"public String view(){
  StringBuilder s=new StringBuilder();
  RGANode node=head.getNext();
  while (node != null) {
    if (node.isVisible()) {
      s.append(node.getContent());
    }
    node=node.getNext();
  }
  return s.toString();
}","@Override public String view(){
  StringBuilder s=new StringBuilder();
  RGANode node=head.getNext();
  while (node != null) {
    if (node.isVisible()) {
      s.append(node.getContent());
    }
    node=node.getNext();
  }
  return s.toString();
}"
50692,"public static void main(String[] args) throws IOException, GitAPIException, IncorrectTraceException, PreconditionException, ClassNotFoundException, InstantiationException, IllegalAccessException {
  if (args.length < 1) {
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  String gitdir=args[0];
  List<String> paths=new LinkedList<String>();
  if (args.length > 1 && !args[1].startsWith(""String_Node_Str"") && !args[1].matches(""String_Node_Str"")) {
    paths.add(args[1]);
  }
 else {
    extractFiles(new File(gitdir),gitdir,paths);
  }
  int end=paths.size();
  boolean save=Arrays.asList(args).contains(""String_Node_Str"");
  boolean clean=Arrays.asList(args).contains(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + paths.size());
  String file=getNameFile(args);
  writeTofile(file,""String_Node_Str"");
  int nbrExec=Integer.parseInt(args[args.length - 2]);
  Factory<CRDT> rf=(Factory<CRDT>)Class.forName(args[args.length - 1]).newInstance();
  int nb=(nbrExec > 1) ? nbrExec + 1 : nbrExec;
  boolean calculTimeEx=true;
  int i=0;
  CouchConnector cc=new CouchConnector(dbURL);
  for (  String path : paths.subList(i,end)) {
    for (int retry=0; retry < 10; ++retry) {
      try {
        long ltime[][]=null, mem[][]=null, rtime[][]=null;
        int cop=0, uop=0, nbReplica=0, mop=0;
        int minCop=0, minUop=0, minMop=0;
        String stat=""String_Node_Str"";
        GitTrace trace=GitTrace.create(gitdir,cc,path,clean);
        for (int k=0; k < nbrExec; k++) {
          CausalSimulator cd=new CausalSimulator(rf);
          cd.run(trace,calculTimeEx,true,100,true);
          if (k == 0) {
            cop=cd.splittedGenTime().size();
            uop=cd.replicaGenerationTimes().size();
            mop=cd.getMemUsed().size();
            nbReplica=cd.replicas.keySet().size();
            ltime=new long[nb][uop];
            rtime=new long[nb][cop];
            mem=new long[nb][mop];
            minCop=cop;
            minUop=uop;
            minMop=mop;
            stat=path + ';' + ++i+ ';'+ cd.replicas.keySet().size()+ ';'+ trace.nbMerge+ ';'+ trace.nbBlockMerge+ ';'+ trace.mergeSize+ ';'+ trace.nbCommit+ ';'+ trace.nbInsBlock+ ';'+ trace.nbDelBlock+ ';'+ trace.nbUpdBlock+ ';'+ trace.insertSize+ ';'+ trace.deleteSize;
          }
          if (nbReplica == 0) {
            break;
          }
          if (minCop > cd.splittedGenTime().size()) {
            minCop=cd.splittedGenTime().size();
          }
          if (minUop > cd.replicaGenerationTimes().size()) {
            minUop=cd.replicaGenerationTimes().size();
          }
          if (calculTimeEx) {
            toArrayLong(ltime[k],cd.replicaGenerationTimes(),minUop);
            toArrayLong(rtime[k],cd.splittedGenTime(),minCop);
          }
          if (k == 0) {
            toArrayLong(mem[k],cd.getMemUsed(),minMop);
          }
          for (int j=0; j < minCop - 1; j++) {
            if (nbReplica > 1)             rtime[k][j]/=nbReplica - 1;
          }
          cd=null;
        }
        System.out.println(path + ""String_Node_Str"" + i);
        double thresold=2.0;
        if (nbrExec > 1) {
          computeAverage(ltime,thresold,minUop);
          computeAverage(rtime,thresold,minCop);
        }
        long avgGen=calculAvg(ltime,minUop,""String_Node_Str"");
        long avgUsr=calculAvg(rtime,minCop,""String_Node_Str"");
        long avgMem=calculAvg(mem,minMop,""String_Node_Str"");
        stat=stat + ';' + minCop+ ';'+ avgGen / 1000 + ';' + avgUsr / 1000 + ';' + avgMem;
        writeTofile(file,stat);
        break;
      }
 catch (      DbAccessException e) {
        if (retry == 9) {
          throw e;
        }
      }
    }
  }
}","public static void main(String[] args) throws IOException, GitAPIException, IncorrectTraceException, PreconditionException, ClassNotFoundException, InstantiationException, IllegalAccessException {
  if (args.length < 1) {
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.err.println(""String_Node_Str"");
    System.exit(1);
  }
  String gitdir=args[0];
  List<String> paths=new LinkedList<String>();
  if (args.length > 1 && !args[1].startsWith(""String_Node_Str"") && !args[1].matches(""String_Node_Str"")) {
    paths.add(args[1]);
  }
 else {
    extractFiles(new File(gitdir),gitdir,paths);
  }
  int end=paths.size();
  boolean save=Arrays.asList(args).contains(""String_Node_Str"");
  boolean clean=Arrays.asList(args).contains(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + paths.size());
  String file=getNameFile(args);
  if (save) {
    writeTofile(file,""String_Node_Str"");
  }
  int nbrExec=Integer.parseInt(args[args.length - 2]);
  Factory<CRDT> rf=(Factory<CRDT>)Class.forName(args[args.length - 1]).newInstance();
  int nb=(nbrExec > 1) ? nbrExec + 1 : nbrExec;
  boolean calculTimeEx=true;
  int i=0;
  CouchConnector cc=new CouchConnector(dbURL);
  for (  String path : paths.subList(i,end)) {
    long ltime[][]=null, mem[][]=null, rtime[][]=null;
    int cop=0, uop=0, nbReplica=0, mop=0;
    int minCop=0, minUop=0, minMop=0;
    String stat=""String_Node_Str"";
    GitTrace trace=GitTrace.create(gitdir,cc,path,clean);
    for (int k=0; k < nbrExec; k++) {
      CausalSimulator cd=new CausalSimulator(rf);
      cd.run(trace,calculTimeEx,save,100,save);
      if (k == 0) {
        cop=cd.splittedGenTime().size();
        uop=cd.replicaGenerationTimes().size();
        mop=cd.getMemUsed().size();
        nbReplica=cd.replicas.keySet().size();
        ltime=new long[nb][uop];
        rtime=new long[nb][cop];
        mem=new long[nb][mop];
        minCop=cop;
        minUop=uop;
        minMop=mop;
        stat=path + ';' + ++i+ ';'+ cd.replicas.keySet().size()+ ';'+ trace.nbMerge+ ';'+ trace.nbBlockMerge+ ';'+ trace.mergeSize+ ';'+ trace.nbCommit+ ';'+ trace.nbInsBlock+ ';'+ trace.nbDelBlock+ ';'+ trace.nbUpdBlock+ ';'+ trace.insertSize+ ';'+ trace.deleteSize;
      }
      if (nbReplica == 0 || !save) {
        break;
      }
      if (minCop > cd.splittedGenTime().size()) {
        minCop=cd.splittedGenTime().size();
      }
      if (minUop > cd.replicaGenerationTimes().size()) {
        minUop=cd.replicaGenerationTimes().size();
      }
      if (calculTimeEx) {
        toArrayLong(ltime[k],cd.replicaGenerationTimes(),minUop);
        toArrayLong(rtime[k],cd.splittedGenTime(),minCop);
      }
      if (k == 0) {
        toArrayLong(mem[k],cd.getMemUsed(),minMop);
      }
      for (int j=0; j < minCop - 1; j++) {
        if (nbReplica > 1) {
          rtime[k][j]/=nbReplica - 1;
        }
      }
      cd=null;
    }
    System.out.println(stat);
    double thresold=2.0;
    if (save) {
      if (nbrExec > 1) {
        computeAverage(ltime,thresold,minUop);
        computeAverage(rtime,thresold,minCop);
      }
      long avgGen=calculAvg(ltime,minUop,""String_Node_Str"");
      long avgUsr=calculAvg(rtime,minCop,""String_Node_Str"");
      long avgMem=calculAvg(mem,minMop,""String_Node_Str"");
      stat=stat + ';' + minCop+ ';'+ avgGen / 1000 + ';' + avgUsr / 1000 + ';' + avgMem;
      writeTofile(file,stat);
    }
  }
}"
50693,"@Test public void testDelete() throws PreconditionException {
  String content=""String_Node_Str"";
  int pos=3, off=4;
  replica.applyLocal(SequenceOperation.insert(0,content));
  assertEquals(content,replica.lookup());
  replica.localDelete(SequenceOperation.delete(pos,off));
  assertEquals(content.substring(0,pos) + content.substring(pos + off),replica.lookup());
}","@Test public void testDelete() throws PreconditionException {
  String content=""String_Node_Str"";
  int pos=3, off=4;
  replica.applyLocal(SequenceOperation.insert(0,content));
  assertEquals(content,replica.lookup());
  replica.applyLocal(SequenceOperation.delete(pos,off));
  assertEquals(content.substring(0,pos) + content.substring(pos + off),replica.lookup());
}"
50694,"@Override protected List<SequenceMessage> localDelete(SequenceOperation opt) throws IncorrectTraceException {
  final TreedocDocument doc=((TreedocDocument)getDoc());
  final List<SequenceMessage> ops=new LinkedList<SequenceMessage>();
  for (int i=opt.getPosition(); i < opt.getPosition() + opt.getLenghOfADel(); i++) {
    final TreedocIdentifier deletedId=doc.deleteAt(restrictedIndex(i,false));
    ops.add(new TreedocOperation(opt,deletedId));
  }
  return ops;
}","@Override protected List<SequenceMessage> localDelete(SequenceOperation opt) throws IncorrectTraceException {
  final TreedocDocument doc=((TreedocDocument)getDoc());
  final List<SequenceMessage> ops=new LinkedList<SequenceMessage>();
  for (int i=opt.getPosition(); i < opt.getPosition() + opt.getLenghOfADel(); i++) {
    final TreedocIdentifier deletedId=doc.deleteAt(restrictedIndex(opt.getPosition(),false));
    ops.add(new TreedocOperation(opt,deletedId));
  }
  return ops;
}"
50695,"@Override protected List<SequenceMessage> generateLocal(SequenceOperation opt) throws IncorrectTraceException {
  final TreedocDocument doc=((TreedocDocument)getDoc());
  final List<SequenceMessage> ops=new LinkedList<SequenceMessage>();
switch (opt.getType()) {
case ins:
    final TreedocIdentifier id=doc.insertAt(restrictedIndex(opt.getPosition(),true),opt.getContentAsString());
  ops.add(new TreedocOperation(opt,id,opt.getContentAsString()));
break;
case del:
for (int i=opt.getPosition(); i < opt.getPosition() + opt.getNumberOf(); i++) {
final TreedocIdentifier deletedId=doc.deleteAt(restrictedIndex(i,false));
ops.add(new TreedocOperation(opt,deletedId));
}
break;
default :
throw new IncorrectTraceException(""String_Node_Str"");
}
return ops;
}","@Override protected List<SequenceMessage> generateLocal(SequenceOperation opt) throws IncorrectTraceException {
  final TreedocDocument doc=((TreedocDocument)getDoc());
  final List<SequenceMessage> ops=new LinkedList<SequenceMessage>();
switch (opt.getType()) {
case ins:
    final TreedocIdentifier id=doc.insertAt(restrictedIndex(opt.getPosition(),true),opt.getContentAsString(),getReplicaNumber());
  ops.add(new TreedocOperation(opt,id,opt.getContentAsString()));
break;
case del:
for (int i=opt.getPosition(); i < opt.getPosition() + opt.getNumberOf(); i++) {
final TreedocIdentifier deletedId=doc.deleteAt(restrictedIndex(i,false));
ops.add(new TreedocOperation(opt,deletedId));
}
break;
default :
throw new IncorrectTraceException(""String_Node_Str"");
}
return ops;
}"
50696,"public TreedocMerge(int r){
  super(new TreedocDocument(UniqueTag.createGenerator(r)),r);
}","public TreedocMerge(int r){
  super(new TreedocDocument(UniqueTag.createGenerator()),r);
}"
50697,"public TreedocIdentifier insertAt(final int index,final String content){
  final TreedocNode newNode=new TreedocNode(tagGenerator.nextTag());
  newNode.createBalancedSubtreeOfContent(content,0,content.length());
  final Recorder idRecorder=new Recorder();
  final TreedocNode precedingNode;
  if (index == 0) {
    precedingNode=this;
    precedingNode.subtreeSize+=content.length();
  }
 else {
    precedingNode=findNthContentAndAlterSize(new DecreasingCounter(index),idRecorder,content.length());
  }
  precedingNode.insertAfter(newNode,idRecorder);
  return idRecorder.createIdentifier();
}","public TreedocIdentifier insertAt(final int index,final String content,final int replicaId){
  final TreedocNode newNode=new TreedocNode(tagGenerator.nextTag(replicaId));
  newNode.createBalancedSubtreeOfContent(content,0,content.length());
  final Recorder idRecorder=new Recorder();
  final TreedocNode precedingNode;
  if (index == 0) {
    precedingNode=this;
    precedingNode.subtreeSize+=content.length();
  }
 else {
    precedingNode=findNthContentAndAlterSize(new DecreasingCounter(index),idRecorder,content.length());
  }
  precedingNode.insertAfter(newNode,idRecorder);
  return idRecorder.createIdentifier();
}"
50698,"@Override public UniqueTag nextTag(){
  return new UniqueTag(replicaId,currentStamp++);
}","@Override public UniqueTag nextTag(final int replicaId){
  return new UniqueTag(replicaId,currentStamp++);
}"
50699,"public static UniqueTagGenerator createGenerator(final int replicaId){
  return new UniqueTagGenerator(){
    int currentStamp;
    @Override public UniqueTag nextTag(){
      return new UniqueTag(replicaId,currentStamp++);
    }
  }
;
}","public static UniqueTagGenerator createGenerator(){
  return new UniqueTagGenerator(){
    int currentStamp;
    @Override public UniqueTag nextTag(    final int replicaId){
      return new UniqueTag(replicaId,currentStamp++);
    }
  }
;
}"
50700,UniqueTag nextTag();,UniqueTag nextTag(int replicaId);
50701,"@Test public void testCreateSingle(){
  root.insertAt(0,""String_Node_Str"");
  assertEquals(1,root.getSubtreeSize());
  assertEquals(""String_Node_Str"",root.getContent());
}","@Test public void testCreateSingle(){
  root.insertAt(0,""String_Node_Str"",REPLICA_ID);
  assertEquals(1,root.getSubtreeSize());
  assertEquals(""String_Node_Str"",root.getContent());
}"
50702,"@Test public void test(){
  root.insertAt(0,""String_Node_Str"");
  root.deleteAt(0);
  root.insertAt(0,""String_Node_Str"");
}","@Test public void test(){
  root.insertAt(0,""String_Node_Str"",REPLICA_ID);
  root.deleteAt(0);
  root.insertAt(0,""String_Node_Str"",REPLICA_ID);
}"
50703,"@Test public void testInsertAtMiddle(){
  root.insertAt(0,""String_Node_Str"");
  root.insertAt(1,""String_Node_Str"");
  root.insertAt(1,""String_Node_Str"");
  assertEquals(""String_Node_Str"",root.getContent());
}","@Test public void testInsertAtMiddle(){
  root.insertAt(0,""String_Node_Str"",REPLICA_ID);
  root.insertAt(1,""String_Node_Str"",REPLICA_ID);
  root.insertAt(1,""String_Node_Str"",REPLICA_ID);
  assertEquals(""String_Node_Str"",root.getContent());
}"
50704,"@Test public void testInsertAtBeginning(){
  root.insertAt(0,""String_Node_Str"");
  root.insertAt(0,""String_Node_Str"");
  assertEquals(2,root.getSubtreeSize());
  assertEquals(""String_Node_Str"",root.getContent());
}","@Test public void testInsertAtBeginning(){
  root.insertAt(0,""String_Node_Str"",REPLICA_ID);
  root.insertAt(0,""String_Node_Str"",REPLICA_ID);
  assertEquals(2,root.getSubtreeSize());
  assertEquals(""String_Node_Str"",root.getContent());
}"
50705,"@Before public void setUp() throws Exception {
  root=new TreedocRoot(UniqueTag.createGenerator(0));
}","@Before public void setUp() throws Exception {
  root=new TreedocRoot(UniqueTag.createGenerator());
}"
50706,"@Test public void testInsertAtEnd(){
  root.insertAt(0,""String_Node_Str"");
  root.insertAt(1,""String_Node_Str"");
  assertEquals(2,root.getSubtreeSize());
  assertEquals(""String_Node_Str"",root.getContent());
}","@Test public void testInsertAtEnd(){
  root.insertAt(0,""String_Node_Str"",REPLICA_ID);
  root.insertAt(1,""String_Node_Str"",REPLICA_ID);
  assertEquals(2,root.getSubtreeSize());
  assertEquals(""String_Node_Str"",root.getContent());
}"
50707,"@Test public void testInsertsDeletesInterleaved(){
  root.insertAt(0,""String_Node_Str"");
  root.insertAt(1,""String_Node_Str"");
  root.insertAt(1,""String_Node_Str"");
  root.deleteAt(1);
  root.insertAt(1,""String_Node_Str"");
  root.deleteAt(0);
  root.insertAt(0,""String_Node_Str"");
  root.deleteAt(2);
  root.insertAt(2,""String_Node_Str"");
  assertEquals(""String_Node_Str"",root.getContent());
}","@Test public void testInsertsDeletesInterleaved(){
  root.insertAt(0,""String_Node_Str"",REPLICA_ID);
  root.insertAt(1,""String_Node_Str"",REPLICA_ID);
  root.insertAt(1,""String_Node_Str"",REPLICA_ID);
  root.deleteAt(1);
  root.insertAt(1,""String_Node_Str"",REPLICA_ID);
  root.deleteAt(0);
  root.insertAt(0,""String_Node_Str"",REPLICA_ID);
  root.deleteAt(2);
  root.insertAt(2,""String_Node_Str"",REPLICA_ID);
  assertEquals(""String_Node_Str"",root.getContent());
}"
50708,"@Test public void testInsertsDeletesInserts(){
  root.insertAt(0,""String_Node_Str"");
  root.deleteAt(0);
  root.insertAt(0,""String_Node_Str"");
  root.insertAt(1,""String_Node_Str"");
  root.insertAt(2,""String_Node_Str"");
  assertEquals(""String_Node_Str"",root.getContent());
}","@Test public void testInsertsDeletesInserts(){
  root.insertAt(0,""String_Node_Str"",REPLICA_ID);
  root.deleteAt(0);
  root.insertAt(0,""String_Node_Str"",REPLICA_ID);
  root.insertAt(1,""String_Node_Str"",REPLICA_ID);
  root.insertAt(2,""String_Node_Str"",REPLICA_ID);
  assertEquals(""String_Node_Str"",root.getContent());
}"
50709,"@Test public void testGenerator(){
  final UniqueTagGenerator generator=UniqueTag.createGenerator(123);
  assertEquals(new UniqueTag(123,0),generator.nextTag());
  assertEquals(new UniqueTag(123,1),generator.nextTag());
}","@Test public void testGenerator(){
  final UniqueTagGenerator generator=UniqueTag.createGenerator();
  assertEquals(new UniqueTag(123,0),generator.nextTag(123));
  assertEquals(new UniqueTag(123,1),generator.nextTag(123));
}"
50710,"@Override protected List<SequenceMessage> generateLocal(SequenceOperation opt) throws IncorrectTraceException {
  TTFDocument doc=(TTFDocument)this.getDoc();
  List<SequenceMessage> generatedOperations=new ArrayList<SequenceMessage>();
  int mpos=doc.viewToModel(opt.getPosition());
  if (opt.getType() == SequenceOperation.OpType.del) {
    for (int i=0; i < opt.getOffset(); i++) {
      TTFOperation op=TTFOperation.delete(opt,mpos + i,new VectorClock(this.siteVC));
      this.siteVC.inc(this.getReplicaNumber());
      generatedOperations.add(op);
      this.log.add(op);
      doc.apply(op);
    }
  }
 else {
    for (int i=0; i < opt.getContent().length(); i++) {
      TTFOperation op=TTFOperation.insert(opt,mpos + i,opt.getContent().charAt(i),new VectorClock(this.siteVC));
      this.siteVC.inc(this.getReplicaNumber());
      generatedOperations.add(op);
      this.log.add(op);
      doc.apply(op);
    }
  }
  return generatedOperations;
}","@Override protected List<SequenceMessage> generateLocal(SequenceOperation opt) throws IncorrectTraceException {
  TTFDocument doc=(TTFDocument)this.getDoc();
  List<SequenceMessage> generatedOperations=new ArrayList<SequenceMessage>();
  int mpos=doc.viewToModel(opt.getPosition());
  if (opt.getType() == SequenceOperation.OpType.del) {
    int visibleIndex=0;
    for (int i=0; i < opt.getOffset(); i++) {
      while (!doc.getChar(mpos + visibleIndex).isVisible()) {
        visibleIndex++;
      }
      TTFOperation op=TTFOperation.delete(opt,mpos + visibleIndex,new VectorClock(this.siteVC));
      this.siteVC.inc(this.getReplicaNumber());
      generatedOperations.add(op);
      this.log.add(op);
      doc.apply(op);
    }
  }
 else {
    for (int i=0; i < opt.getContent().length(); i++) {
      TTFOperation op=TTFOperation.insert(opt,mpos + i,opt.getContent().charAt(i),new VectorClock(this.siteVC));
      this.siteVC.inc(this.getReplicaNumber());
      generatedOperations.add(op);
      this.log.add(op);
      doc.apply(op);
    }
  }
  return generatedOperations;
}"
50711,"@Override protected List<SequenceMessage> generateLocal(SequenceOperation opt) throws IncorrectTraceException {
  List<SequenceMessage> lop=new ArrayList<SequenceMessage>();
  RGADocument rgadoc=(RGADocument)(this.getDoc());
  RGAS4Vector s4vtms, s4vpos=null;
  RGAOperation rgaop;
  RGANode target=null;
  int p=opt.getPosition();
  int offset;
  if (opt.getType() == SequenceOperation.OpType.del) {
    offset=opt.getOffset();
    target=rgadoc.getVisibleNode(p + 1);
  }
 else {
    offset=opt.getContent().length();
    if (p == 0)     s4vpos=null;
 else     s4vpos=rgadoc.getVisibleS4V(p);
  }
  for (int i=0; i < offset; i++) {
    this.siteVC.inc(this.getReplicaNumber());
    s4vtms=new RGAS4Vector(this.getReplicaNumber(),this.siteVC);
    if (opt.getType() == SequenceOperation.OpType.del) {
      rgaop=new RGAOperation(opt,p + 1,target.getKey(),s4vtms);
      target=target.getNextVisible();
    }
 else {
      rgaop=new RGAOperation(opt,p + i,s4vpos,opt.getContent().charAt(i),s4vtms);
      s4vpos=s4vtms;
    }
    lop.add(rgaop);
    rgadoc.apply(rgaop);
    purger.setLastVC(this.getReplicaNumber(),this.siteVC);
  }
  return lop;
}","@Override protected List<SequenceMessage> generateLocal(SequenceOperation opt) throws IncorrectTraceException {
  List<SequenceMessage> lop=new ArrayList<SequenceMessage>();
  RGADocument rgadoc=(RGADocument)(this.getDoc());
  RGAS4Vector s4vtms, s4vpos=null;
  RGAOperation rgaop;
  RGANode target=null;
  int p=opt.getPosition();
  int offset;
  if (opt.getType() == SequenceOperation.OpType.del) {
    offset=opt.getOffset();
    target=rgadoc.getVisibleNode(p + 1);
  }
 else {
    offset=opt.getContent().length();
    if (p == 0)     s4vpos=null;
 else     s4vpos=rgadoc.getVisibleS4V(p);
  }
  for (int i=0; i < offset; i++) {
    this.siteVC.inc(this.getReplicaNumber());
    s4vtms=new RGAS4Vector(this.getReplicaNumber(),this.siteVC);
    if (opt.getType() == SequenceOperation.OpType.del) {
      rgaop=new RGAOperation(opt,p + 1,target.getKey(),s4vtms);
      target=target.getNextVisible();
    }
 else {
      rgaop=new RGAOperation(opt,p + i,s4vpos,opt.getContent().charAt(i),s4vtms);
      s4vpos=s4vtms;
    }
    lop.add(rgaop);
    rgadoc.apply(rgaop);
  }
  return lop;
}"
50712,"public RGAMerge(Document doc,int r){
  super(doc,r);
  siteVC=new VectorClock();
  purger=new RGAPurger((RGADocument)this.getDoc());
}","public RGAMerge(Document doc,int r){
  super(doc,r);
  siteVC=new VectorClock();
}"
50713,"@Override protected void integrateLocal(SequenceMessage op) throws IncorrectTraceException {
  RGAOperation rgaop=(RGAOperation)op;
  RGADocument rgadoc=(RGADocument)(this.getDoc());
  this.siteVC.inc(rgaop.getOriginalOp().getReplica());
  rgadoc.apply(rgaop);
  purger.setLastVC(rgaop.getS4VTms().sid,rgaop.getOriginalOp().getVectorClock());
}","@Override protected void integrateLocal(SequenceMessage op) throws IncorrectTraceException {
  RGAOperation rgaop=(RGAOperation)op;
  RGADocument rgadoc=(RGADocument)(this.getDoc());
  this.siteVC.inc(rgaop.getOriginalOp().getReplica());
  rgadoc.apply(rgaop);
}"
50714,"@Override public CommutativeMessage clone(){
  CommutativeMessage clone=copy();
  clone.msgs=(LinkedList<CommutativeMessage>)msgs.clone();
  return clone;
}","@Override public CommutativeMessage clone(){
  CommutativeMessage clone=copy();
  for (  CommutativeMessage m : msgs) {
    clone.msgs.add(m.copy());
  }
  return clone;
}"
50715,"public int compareTo(RGAS4Vector s4v){
  if (this.ssn > s4v.ssn)   return AFTER;
 else   if (this.ssn < s4v.ssn)   return BEFORE;
 else {
    if (this.sum > s4v.sum)     return AFTER;
 else     if (this.sum < s4v.ssn)     return BEFORE;
 else {
      if (this.sid > s4v.sid)       return AFTER;
 else       if (this.sid < s4v.sid)       return BEFORE;
 else       return EQUAL;
    }
  }
}","public int compareTo(RGAS4Vector s4v){
  if (this.ssn > s4v.ssn)   return AFTER;
 else   if (this.ssn < s4v.ssn)   return BEFORE;
 else {
    if (this.sum > s4v.sum)     return AFTER;
 else     if (this.sum < s4v.sum)     return BEFORE;
 else {
      if (this.sid > s4v.sid)       return AFTER;
 else       if (this.sid < s4v.sid)       return BEFORE;
 else       return EQUAL;
    }
  }
}"
50716,"public void rebuildKnowledgeBaseViaKnowledgeAgent() throws ConnectException {
  this.createKnowledgeBaseViaKnowledgeAgent(true);
}","public synchronized void rebuildKnowledgeBaseViaKnowledgeAgent() throws ConnectException {
  this.createKnowledgeBaseViaKnowledgeAgent(true);
}"
50717,"public void createOrRebuildKnowledgeBaseViaKnowledgeAgentOrBuilder(){
  try {
    this.createKnowledgeBaseViaKnowledgeAgent(true);
  }
 catch (  ConnectException x) {
    log.warn(""String_Node_Str"");
    rebuildKnowledgeBaseViaKnowledgeBuilder();
  }
}","public synchronized void createOrRebuildKnowledgeBaseViaKnowledgeAgentOrBuilder(){
  try {
    this.createKnowledgeBaseViaKnowledgeAgent(true);
  }
 catch (  ConnectException x) {
    log.warn(""String_Node_Str"");
    rebuildKnowledgeBaseViaKnowledgeBuilder();
  }
}"
50718,"protected void checkKAgentAndBaseHealth(){
  long kAgentRefreshLapsedTime=System.currentTimeMillis() - lastKAgentRefresh;
  long kAgentRefreshMillis=1000 * 60 * kAgentRefreshHours;
  if (kbase == null || (kAgentMonitor && (kAgentRefreshLapsedTime > kAgentRefreshMillis))) {
    log.info(""String_Node_Str"" + kAgentRefreshLapsedTime + ""String_Node_Str""+ kAgentRefreshMillis);
    kbase=null;
    createKnowledgeBaseViaKnowledgeAgentOrBuilder();
  }
}","protected synchronized void checkKAgentAndBaseHealth(){
  long kAgentRefreshLapsedTime=System.currentTimeMillis() - lastKAgentRefresh;
  long kAgentRefreshMillis=1000 * 60 * kAgentRefreshHours;
  if (kbase == null || (kAgentMonitor && (kAgentRefreshLapsedTime > kAgentRefreshMillis))) {
    log.info(""String_Node_Str"" + kAgentRefreshLapsedTime + ""String_Node_Str""+ kAgentRefreshMillis);
    createKnowledgeBaseViaKnowledgeAgentOrBuilder();
  }
}"
50719,"public void createKnowledgeBaseViaKnowledgeAgentOrBuilder(){
  try {
    this.createKnowledgeBaseViaKnowledgeAgent();
  }
 catch (  ConnectException x) {
    log.warn(""String_Node_Str"");
    rebuildKnowledgeBaseViaKnowledgeBuilder();
  }
}","public synchronized void createKnowledgeBaseViaKnowledgeAgentOrBuilder(){
  try {
    this.createKnowledgeBaseViaKnowledgeAgent();
  }
 catch (  ConnectException x) {
    log.warn(""String_Node_Str"");
    rebuildKnowledgeBaseViaKnowledgeBuilder();
  }
}"
50720,"public void rebuildKnowledgeBaseViaKnowledgeBuilder(){
  guvnorProps=new Properties();
  try {
    KnowledgeBuilder kbuilder=KnowledgeBuilderFactory.newKnowledgeBuilder();
    if (guvnorUtils.guvnorExists()) {
      guvnorProps.load(BaseKnowledgeSessionBean.class.getResourceAsStream(""String_Node_Str""));
      StringBuilder guvnorSBuilder=new StringBuilder();
      guvnorSBuilder.append(guvnorProps.getProperty(GuvnorConnectionUtils.GUVNOR_PROTOCOL_KEY));
      guvnorSBuilder.append(""String_Node_Str"");
      guvnorSBuilder.append(guvnorProps.getProperty(GuvnorConnectionUtils.GUVNOR_HOST_KEY));
      guvnorSBuilder.append(""String_Node_Str"");
      guvnorSBuilder.append(guvnorProps.getProperty(GuvnorConnectionUtils.GUVNOR_SUBDOMAIN_KEY));
      String guvnorURI=guvnorSBuilder.toString();
      List<String> packages=guvnorUtils.getPackageNames();
      if (packages.size() > 0) {
        for (        String pkg : packages) {
          GuvnorRestApi guvnorRestApi=new GuvnorRestApi(guvnorURI);
          try {
            InputStream binaryPackage=guvnorRestApi.getBinaryPackage(pkg);
            kbuilder.add(new InputStreamResource(binaryPackage),ResourceType.PKG);
            guvnorRestApi.close();
          }
 catch (          java.io.IOException y) {
            log.error(""String_Node_Str"" + pkg + ""String_Node_Str""+ y);
          }
        }
      }
 else {
        log.warn(""String_Node_Str"");
      }
    }
 else     if (StringUtils.isNotEmpty(System.getProperty(IKnowledgeSession.CHANGE_SET_URLS))) {
      processEventListeners=System.getProperty(IKnowledgeSession.SPACE_DELIMITED_PROCESS_EVENT_LISTENERS).split(""String_Node_Str"");
      String[] changeSetUrls=System.getProperty(IKnowledgeSession.CHANGE_SET_URLS).split(""String_Node_Str"");
      for (      String changeSetUrl : changeSetUrls) {
        InputStream iStream=null;
        try {
          iStream=new FileInputStream(changeSetUrl);
          Resource rObj=new InputStreamResource(iStream);
          kbuilder.add(rObj,ResourceType.PKG);
        }
  finally {
          if (iStream != null)           iStream.close();
        }
      }
    }
 else {
      log.warn(""String_Node_Str"" + IKnowledgeSession.CHANGE_SET_URLS);
    }
    kbase=kbuilder.newKnowledgeBase();
    log.info(""String_Node_Str"");
  }
 catch (  RuntimeException x) {
    throw x;
  }
catch (  Exception x) {
    throw new RuntimeException(x);
  }
}","public synchronized void rebuildKnowledgeBaseViaKnowledgeBuilder(){
  guvnorProps=new Properties();
  try {
    KnowledgeBuilder kbuilder=KnowledgeBuilderFactory.newKnowledgeBuilder();
    if (guvnorUtils.guvnorExists()) {
      guvnorProps.load(BaseKnowledgeSessionBean.class.getResourceAsStream(""String_Node_Str""));
      StringBuilder guvnorSBuilder=new StringBuilder();
      guvnorSBuilder.append(guvnorProps.getProperty(GuvnorConnectionUtils.GUVNOR_PROTOCOL_KEY));
      guvnorSBuilder.append(""String_Node_Str"");
      guvnorSBuilder.append(guvnorProps.getProperty(GuvnorConnectionUtils.GUVNOR_HOST_KEY));
      guvnorSBuilder.append(""String_Node_Str"");
      guvnorSBuilder.append(guvnorProps.getProperty(GuvnorConnectionUtils.GUVNOR_SUBDOMAIN_KEY));
      String guvnorURI=guvnorSBuilder.toString();
      List<String> packages=guvnorUtils.getPackageNames();
      if (packages.size() > 0) {
        for (        String pkg : packages) {
          GuvnorRestApi guvnorRestApi=new GuvnorRestApi(guvnorURI);
          try {
            InputStream binaryPackage=guvnorRestApi.getBinaryPackage(pkg);
            kbuilder.add(new InputStreamResource(binaryPackage),ResourceType.PKG);
            guvnorRestApi.close();
          }
 catch (          java.io.IOException y) {
            log.error(""String_Node_Str"" + pkg + ""String_Node_Str""+ y);
          }
        }
      }
 else {
        log.warn(""String_Node_Str"");
      }
    }
 else     if (StringUtils.isNotEmpty(System.getProperty(IKnowledgeSession.CHANGE_SET_URLS))) {
      processEventListeners=System.getProperty(IKnowledgeSession.SPACE_DELIMITED_PROCESS_EVENT_LISTENERS).split(""String_Node_Str"");
      String[] changeSetUrls=System.getProperty(IKnowledgeSession.CHANGE_SET_URLS).split(""String_Node_Str"");
      for (      String changeSetUrl : changeSetUrls) {
        InputStream iStream=null;
        try {
          iStream=new FileInputStream(changeSetUrl);
          Resource rObj=new InputStreamResource(iStream);
          kbuilder.add(rObj,ResourceType.PKG);
        }
  finally {
          if (iStream != null)           iStream.close();
        }
      }
    }
 else {
      log.warn(""String_Node_Str"" + IKnowledgeSession.CHANGE_SET_URLS);
    }
    kbase=kbuilder.newKnowledgeBase();
    log.info(""String_Node_Str"");
  }
 catch (  RuntimeException x) {
    throw x;
  }
catch (  Exception x) {
    throw new RuntimeException(x);
  }
}"
50721,"/** 
 * Copy response body data (the entity) from the proxy to the servlet client.
 * @param proxyResponse The response from the target server
 * @param servletResponse The response back to the client
 * @throws IOException Failed to copy content
 */
protected void copyResponseContent(HttpResponse proxyResponse,HttpServletResponse servletResponse) throws IOException {
  OutputStream servletOutputStream=servletResponse.getOutputStream();
  try {
    proxyResponse.getEntity().writeTo(servletOutputStream);
  }
  finally {
    try {
      servletOutputStream.close();
    }
 catch (    Exception e) {
      log(e.getMessage(),e);
    }
  }
}","/** 
 * Copy response body data (the entity) from the proxy to the servlet client. Ensures that proxyInputStream will be closed in any case by closing the inputStream
 * @see org.apache.http.HttpEntity.getContent()
 * @param proxyResponse The response from the target server
 * @param servletResponse The response back to the client
 * @throws IOException Failed to copy content
 */
protected void copyResponseContent(HttpResponse proxyResponse,HttpServletResponse servletResponse) throws IOException {
  InputStream proxyInputStream=null;
  OutputStream servletOutputStream=null;
  try {
    proxyInputStream=proxyResponse.getEntity().getContent();
    servletOutputStream=servletResponse.getOutputStream();
    proxyResponse.getEntity().writeTo(servletOutputStream);
  }
  finally {
    secureCloseStream(proxyInputStream);
    secureCloseStream(servletOutputStream);
  }
}"
50722,"@Override public void doOnReturn(Integer deleteCount){
  notificationService.completeProgressNotification(notificationBean.getUuid(),i18n.format(""String_Node_Str""),i18n.format(""String_Node_Str"",deleteCount));
}","@Override public void doOnReturn(String deleteCount){
  notificationService.completeProgressNotification(notificationBean.getUuid(),i18n.format(""String_Node_Str""),i18n.format(""String_Node_Str"",deleteCount));
}"
50723,"@Override public void doOnComplete(org.overlord.rtgov.ui.client.local.services.rpc.IRpcServiceInvocationHandler.RpcResult<Integer> result){
  situationsTable.clear();
}","@Override public void doOnComplete(org.overlord.rtgov.ui.client.local.services.rpc.IRpcServiceInvocationHandler.RpcResult<String> result){
  situationsTable.clear();
}"
50724,"@EventHandler(""String_Node_Str"") public void onDeleteClick(ClickEvent event){
  if (!Window.confirm(""String_Node_Str"" + (applyActionToFilteredRowsOnly ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"")) {
    return;
  }
  SituationsFilterBean situationsFilterBean=applyActionToFilteredRowsOnly ? filtersPanel.getValue() : new SituationsFilterBean();
  final NotificationBean notificationBean=notificationService.startProgressNotification(i18n.format(""String_Node_Str""),i18n.format(""String_Node_Str""));
  situationsService.delete(situationsFilterBean,new RpcServiceInvocationHandlerAdapter<Integer>(){
    @Override public void doOnReturn(    Integer deleteCount){
      notificationService.completeProgressNotification(notificationBean.getUuid(),i18n.format(""String_Node_Str""),i18n.format(""String_Node_Str"",deleteCount));
    }
    @Override public void doOnError(    Throwable error){
      notificationService.completeProgressNotification(notificationBean.getUuid(),i18n.format(""String_Node_Str""),error);
    }
    @Override public void doOnComplete(    org.overlord.rtgov.ui.client.local.services.rpc.IRpcServiceInvocationHandler.RpcResult<Integer> result){
      situationsTable.clear();
    }
  }
);
}","@EventHandler(""String_Node_Str"") public void onDeleteClick(ClickEvent event){
  if (!Window.confirm(""String_Node_Str"" + (applyActionToFilteredRowsOnly ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"")) {
    return;
  }
  SituationsFilterBean situationsFilterBean=applyActionToFilteredRowsOnly ? filtersPanel.getValue() : new SituationsFilterBean();
  final NotificationBean notificationBean=notificationService.startProgressNotification(i18n.format(""String_Node_Str""),i18n.format(""String_Node_Str""));
  situationsService.delete(situationsFilterBean,new RpcServiceInvocationHandlerAdapter<String>(){
    @Override public void doOnReturn(    String deleteCount){
      notificationService.completeProgressNotification(notificationBean.getUuid(),i18n.format(""String_Node_Str""),i18n.format(""String_Node_Str"",deleteCount));
    }
    @Override public void doOnError(    Throwable error){
      notificationService.completeProgressNotification(notificationBean.getUuid(),i18n.format(""String_Node_Str""),error);
    }
    @Override public void doOnComplete(    org.overlord.rtgov.ui.client.local.services.rpc.IRpcServiceInvocationHandler.RpcResult<String> result){
      situationsTable.clear();
    }
  }
);
}"
50725,"/** 
 * @see org.overlord.rtgov.ui.client.shared.services.ISituationsService#delete(SituationsFilterBean)
 */
public void delete(SituationsFilterBean situationsFilterBean,IRpcServiceInvocationHandler<Integer> handler){
  RemoteCallback<Integer> successCallback=new DelegatingRemoteCallback<Integer>(handler);
  ErrorCallback<?> errorCallback=new DelegatingErrorCallback(handler);
  try {
    remoteSituationsService.call(successCallback,errorCallback).delete(situationsFilterBean);
  }
 catch (  UiException e) {
    errorCallback.error(null,e);
  }
}","/** 
 * @see org.overlord.rtgov.ui.client.shared.services.ISituationsService#delete(SituationsFilterBean)
 */
public void delete(SituationsFilterBean situationsFilterBean,IRpcServiceInvocationHandler<String> handler){
  RemoteCallback<String> successCallback=new DelegatingRemoteCallback<String>(handler);
  ErrorCallback<?> errorCallback=new DelegatingErrorCallback(handler);
  try {
    remoteSituationsService.call(successCallback,errorCallback).delete(situationsFilterBean);
  }
 catch (  UiException e) {
    errorCallback.error(null,e);
  }
}"
50726,"/** 
 * Deletes all situation's matching the given filter.
 * @param situationsFilterBean
 * @throws UiException
 */
@POST @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) public int delete(SituationsFilterBean situationsFilterBean) throws UiException ;","/** 
 * Deletes all situation's matching the given filter.
 * @param situationsFilterBean
 * @throws UiException
 */
@POST @Path(""String_Node_Str"") @Consumes(MediaType.APPLICATION_JSON) public String delete(SituationsFilterBean situationsFilterBean) throws UiException ;"
50727,"@Override public int delete(SituationsFilterBean situationsFilterBean) throws UiException {
  return impl.delete(situationsFilterBean);
}","@Override public String delete(SituationsFilterBean situationsFilterBean) throws UiException {
  return ""String_Node_Str"" + impl.delete(situationsFilterBean);
}"
50728,"/** 
 * @param isTakeoverPossible
 */
public void setTakeoverPossible(boolean isTakeoverPossible){
  this.isTakeoverPossible=isTakeoverPossible;
}","/** 
 * @param isTakeoverPossible
 */
public void setTakeoverPossible(boolean isTakeoverPossible){
  this.takeoverPossible=isTakeoverPossible;
}"
50729,"/** 
 * @return whether this situation is assigned to the currently logged-in user
 */
public boolean isAssignedToCurrentUser(){
  return isAssignedToCurrentUser;
}","/** 
 * @return whether this situation is assigned to the currently logged-in user
 */
public boolean isAssignedToCurrentUser(){
  return assignedToCurrentUser;
}"
50730,"/** 
 * @param isResubmitPossible the isResubmitPossible to set
 */
public void setResubmitPossible(boolean isResubmitPossible){
  this.isResubmitPossible=isResubmitPossible;
}","/** 
 * @param isResubmitPossible the isResubmitPossible to set
 */
public void setResubmitPossible(boolean isResubmitPossible){
  this.resubmitPossible=isResubmitPossible;
}"
50731,"/** 
 * @return the isResubmitPossible
 */
public boolean isResubmitPossible(){
  return isResubmitPossible;
}","/** 
 * @return the isResubmitPossible
 */
public boolean isResubmitPossible(){
  return resubmitPossible;
}"
50732,"/** 
 * @return whether this {@link Situation} can be taken over by the currently logged-in user
 */
public boolean isTakeoverPossible(){
  return isTakeoverPossible;
}","/** 
 * @return whether this {@link Situation} can be taken over by the currently logged-in user
 */
public boolean isTakeoverPossible(){
  return takeoverPossible;
}"
50733,"/** 
 * @param isAssignedToCurrentUser
 */
public void setAssignedToCurrentUser(boolean isAssignedToCurrentUser){
  this.isAssignedToCurrentUser=isAssignedToCurrentUser;
}","/** 
 * @param isAssignedToCurrentUser
 */
public void setAssignedToCurrentUser(boolean isAssignedToCurrentUser){
  this.assignedToCurrentUser=isAssignedToCurrentUser;
}"
50734,"/** 
 * @see org.overlord.rtgov.ui.client.shared.services.IServicesService#getReference(String)
 */
public void getReference(String id,IRpcServiceInvocationHandler<ReferenceBean> handler){
  RemoteCallback<ReferenceBean> successCallback=new DelegatingRemoteCallback<ReferenceBean>(handler);
  ErrorCallback<?> errorCallback=new DelegatingErrorCallback(handler);
  try {
    remoteServicesService.call(successCallback,errorCallback).getReference(id);
  }
 catch (  UiException e) {
    errorCallback.error(null,e);
  }
}","/** 
 * @see org.overlord.rtgov.ui.client.shared.services.IServicesService#getReference(String)
 */
public void getReference(String id,IRpcServiceInvocationHandler<ReferenceBean> handler){
  RemoteCallback<ReferenceBean> successCallback=new DelegatingRemoteCallback<ReferenceBean>(handler);
  ErrorCallback<?> errorCallback=new DelegatingErrorCallback(handler);
  try {
    String encodedId=com.google.gwt.http.client.URL.encode(id);
    remoteServicesService.call(successCallback,errorCallback).getReference(encodedId);
  }
 catch (  UiException e) {
    errorCallback.error(null,e);
  }
}"
50735,"/** 
 * @see org.overlord.rtgov.ui.client.shared.services.IServicesService#getService(String)
 */
public void getService(String id,IRpcServiceInvocationHandler<ServiceBean> handler){
  RemoteCallback<ServiceBean> successCallback=new DelegatingRemoteCallback<ServiceBean>(handler);
  ErrorCallback<?> errorCallback=new DelegatingErrorCallback(handler);
  try {
    remoteServicesService.call(successCallback,errorCallback).getService(id);
  }
 catch (  UiException e) {
    errorCallback.error(null,e);
  }
}","/** 
 * @see org.overlord.rtgov.ui.client.shared.services.IServicesService#getService(String)
 */
public void getService(String id,IRpcServiceInvocationHandler<ServiceBean> handler){
  RemoteCallback<ServiceBean> successCallback=new DelegatingRemoteCallback<ServiceBean>(handler);
  ErrorCallback<?> errorCallback=new DelegatingErrorCallback(handler);
  try {
    String encodedId=com.google.gwt.http.client.URL.encode(id);
    remoteServicesService.call(successCallback,errorCallback).getService(encodedId);
  }
 catch (  UiException e) {
    errorCallback.error(null,e);
  }
}"
50736,"/** 
 * @see org.overlord.rtgov.ui.client.shared.services.IServicesService#getReference(java.lang.String)
 */
@Override public ReferenceBean getReference(String id) throws UiException {
  return impl.getReference(id);
}","/** 
 * @see org.overlord.rtgov.ui.client.shared.services.IServicesService#getReference(java.lang.String)
 */
@Override public ReferenceBean getReference(String id) throws UiException {
  try {
    id=java.net.URLDecoder.decode(id,""String_Node_Str"");
  }
 catch (  Exception e) {
    LOG.log(Level.SEVERE,""String_Node_Str"",e);
  }
  return impl.getReference(id);
}"
50737,"/** 
 * @see org.overlord.dtgov.ui.client.shared.services.IServicesService#getService(java.lang.String)
 */
@Override public ServiceBean getService(String id) throws UiException {
  return impl.getService(id);
}","/** 
 * @see org.overlord.dtgov.ui.client.shared.services.IServicesService#getService(java.lang.String)
 */
@Override public ServiceBean getService(String id) throws UiException {
  try {
    id=java.net.URLDecoder.decode(id,""String_Node_Str"");
  }
 catch (  Exception e) {
    LOG.log(Level.SEVERE,""String_Node_Str"",e);
  }
  return impl.getService(id);
}"
50738,"/** 
 * This class creates a proxy for reporting activities based on the caller invoking methods on the callee, via the supplied interface.
 * @param intf The interface definition for the component being invoked
 * @param caller The caller
 * @param callee The service component
 * @return The proxy
 */
@SuppressWarnings(""String_Node_Str"") public static <T>T createClientProxy(final Class<T> intf,final Object caller,final T callee){
  return ((T)Proxy.newProxyInstance(callee.getClass().getClassLoader(),new Class<?>[]{intf},new InvocationHandler(){
    public Object invoke(    Object proxy,    Method method,    Object[] args) throws Throwable {
      String content=null;
      String mesgType=null;
      String reqId=null;
      String respId=null;
      boolean scopeStarted=false;
      boolean supportedMethod=!method.getName().equals(""String_Node_Str"");
      if (supportedMethod) {
        if (!_collector.isScopeActive()) {
          _collector.startScope();
          scopeStarted=true;
        }
        reqId=UUID.randomUUID().toString();
        respId=UUID.randomUUID().toString();
        if (caller != null) {
          RequestSent rs=new RequestSent();
          rs.setMessageId(reqId);
          rs.setOperation(method.getName());
          rs.setInterface(intf.getName());
          rs.setServiceType(caller.getClass().getName());
          if (args != null && args.length > 0) {
            mesgType=""String_Node_Str"";
            try {
              for (int i=0; i < args.length; i++) {
                if (i > 0) {
                  mesgType+=""String_Node_Str"";
                }
                mesgType+=args[i].getClass().getName();
                String data=_collector.processInformation(null,args[i].getClass().getName(),args[i],null,rs);
                if (content == null) {
                  content=data;
                }
              }
            }
 catch (            Exception e) {
              LOG.log(Level.SEVERE,MessageFormat.format(java.util.PropertyResourceBundle.getBundle(""String_Node_Str"").getString(""String_Node_Str""),method.getName()),e);
            }
          }
          rs.setContent(content);
          rs.setMessageType(mesgType);
          _collector.validate(rs);
          _collector.record(rs);
        }
      }
      String respContent=null;
      Object resp=null;
      Throwable excResp=null;
      try {
        resp=method.invoke(callee,args);
      }
 catch (      java.lang.reflect.InvocationTargetException e) {
        excResp=e.getCause();
      }
      if (supportedMethod) {
        if (caller != null) {
          ResponseReceived rr=new ResponseReceived();
          rr.setMessageId(respId);
          rr.setReplyToId(reqId);
          rr.setOperation(method.getName());
          rr.setInterface(intf.getName());
          rr.setServiceType(caller.getClass().getName());
          rr.setContent(respContent);
          if (resp != null) {
            rr.setMessageType(resp.getClass().getName());
            rr.setContent(_collector.processInformation(null,resp.getClass().getName(),resp,null,rr));
          }
 else           if (excResp != null) {
            Class<?> excType=getDefinedException(method,excResp);
            if (excType != null) {
              String faultName=excType.getSimpleName();
              if (faultName != null && faultName.endsWith(""String_Node_Str"") && faultName.length() > 9) {
                faultName=faultName.substring(0,faultName.length() - 9);
              }
              rr.setFault(faultName);
              rr.setContent(_collector.processInformation(null,excResp.getClass().getName(),excResp,null,rr));
            }
 else {
              rr.setFault(""String_Node_Str"");
              rr.setContent(excResp.toString());
            }
          }
          _collector.record(rr);
        }
        if (scopeStarted) {
          _collector.endScope();
        }
      }
      if (excResp != null) {
        throw excResp;
      }
      return (resp);
    }
  }
));
}","/** 
 * This class creates a proxy for reporting activities based on the caller invoking methods on the callee, via the supplied interface.
 * @param intf The interface definition for the component being invoked
 * @param caller The caller
 * @param callee The service component
 * @param < T > Client type
 * @return The proxy
 */
@SuppressWarnings(""String_Node_Str"") public static <T>T createClientProxy(final Class<T> intf,final Object caller,final T callee){
  return ((T)Proxy.newProxyInstance(callee.getClass().getClassLoader(),new Class<?>[]{intf},new InvocationHandler(){
    public Object invoke(    Object proxy,    Method method,    Object[] args) throws Throwable {
      String content=null;
      String mesgType=null;
      String reqId=null;
      String respId=null;
      boolean scopeStarted=false;
      boolean supportedMethod=!method.getName().equals(""String_Node_Str"");
      if (supportedMethod) {
        if (!_collector.isScopeActive()) {
          _collector.startScope();
          scopeStarted=true;
        }
        reqId=UUID.randomUUID().toString();
        respId=UUID.randomUUID().toString();
        if (caller != null) {
          RequestSent rs=new RequestSent();
          rs.setMessageId(reqId);
          rs.setOperation(method.getName());
          rs.setInterface(intf.getName());
          rs.setServiceType(caller.getClass().getName());
          if (args != null && args.length > 0) {
            mesgType=""String_Node_Str"";
            try {
              for (int i=0; i < args.length; i++) {
                if (i > 0) {
                  mesgType+=""String_Node_Str"";
                }
                mesgType+=args[i].getClass().getName();
                String data=_collector.processInformation(null,args[i].getClass().getName(),args[i],null,rs);
                if (content == null) {
                  content=data;
                }
              }
            }
 catch (            Exception e) {
              LOG.log(Level.SEVERE,MessageFormat.format(java.util.PropertyResourceBundle.getBundle(""String_Node_Str"").getString(""String_Node_Str""),method.getName()),e);
            }
          }
          rs.setContent(content);
          rs.setMessageType(mesgType);
          _collector.validate(rs);
          _collector.record(rs);
        }
      }
      String respContent=null;
      Object resp=null;
      Throwable excResp=null;
      try {
        resp=method.invoke(callee,args);
      }
 catch (      java.lang.reflect.InvocationTargetException e) {
        excResp=e.getCause();
      }
      if (supportedMethod) {
        if (caller != null) {
          ResponseReceived rr=new ResponseReceived();
          rr.setMessageId(respId);
          rr.setReplyToId(reqId);
          rr.setOperation(method.getName());
          rr.setInterface(intf.getName());
          rr.setServiceType(caller.getClass().getName());
          rr.setContent(respContent);
          if (resp != null) {
            rr.setMessageType(resp.getClass().getName());
            rr.setContent(_collector.processInformation(null,resp.getClass().getName(),resp,null,rr));
          }
 else           if (excResp != null) {
            Class<?> excType=getDefinedException(method,excResp);
            if (excType != null) {
              String faultName=excType.getSimpleName();
              if (faultName != null && faultName.endsWith(""String_Node_Str"") && faultName.length() > 9) {
                faultName=faultName.substring(0,faultName.length() - 9);
              }
              rr.setFault(faultName);
              rr.setContent(_collector.processInformation(null,excResp.getClass().getName(),excResp,null,rr));
            }
 else {
              rr.setFault(""String_Node_Str"");
              rr.setContent(excResp.toString());
            }
          }
          _collector.record(rr);
        }
        if (scopeStarted) {
          _collector.endScope();
        }
      }
      if (excResp != null) {
        throw excResp;
      }
      return (resp);
    }
  }
));
}"
50739,"/** 
 * This method sets the activity collector.
 * @param collector The activity collector
 */
public static ActivityProxyHelper setActivityCollector(ActivityCollector collector){
  if (LOG.isLoggable(Level.FINER)) {
    LOG.finer(""String_Node_Str"" + collector);
  }
  _collector=collector;
  return (new ActivityProxyHelper());
}","/** 
 * This method sets the activity collector.
 * @param collector The activity collector
 * @return The activity proxy helper
 */
public static ActivityProxyHelper setActivityCollector(ActivityCollector collector){
  if (LOG.isLoggable(Level.FINER)) {
    LOG.finer(""String_Node_Str"" + collector);
  }
  _collector=collector;
  return (new ActivityProxyHelper());
}"
50740,"MVELEvaluateAction(final ActiveCollectionContext context,final Serializable expressionCompiled,final Object item){
  this.context=context;
  this.expressionCompiled=expressionCompiled;
  this.item=item;
}","MVELEvaluateAction(final ActiveCollectionContext context,final Serializable expressionCompiled,final Object item){
  _context=context;
  _expressionCompiled=expressionCompiled;
  _item=item;
}"
50741,"public Boolean run(){
  Boolean ret=null;
  java.util.Map<String,Object> vars=new java.util.HashMap<String,Object>();
  vars.put(""String_Node_Str"",context);
  Object result=org.mvel2.MVEL.executeExpression(expressionCompiled,item,vars);
  if (result instanceof Boolean) {
    ret=Boolean.class.cast(result);
  }
 else {
    LOG.severe(MessageFormat.format(java.util.PropertyResourceBundle.getBundle(""String_Node_Str"").getString(""String_Node_Str""),_expression,result,item));
  }
  return ret;
}","public Boolean run(){
  Boolean ret=null;
  java.util.Map<String,Object> vars=new java.util.HashMap<String,Object>();
  vars.put(""String_Node_Str"",_context);
  Object result=org.mvel2.MVEL.executeExpression(_expressionCompiled,_item,vars);
  if (result instanceof Boolean) {
    ret=Boolean.class.cast(result);
  }
 else {
    LOG.severe(MessageFormat.format(java.util.PropertyResourceBundle.getBundle(""String_Node_Str"").getString(""String_Node_Str""),_expression,result,_item));
  }
  return ret;
}"
50742,"/** 
 * This method updates the endpoint context value when the process type and/or instance id are changed.
 */
protected void updateEndpointContext(){
  try {
    Context current=null;
    for (    Context context : getContext()) {
      if (context.getType() == Context.Type.Endpoint) {
        current=context;
        break;
      }
    }
    if (current == null) {
      current=new Context();
      current.setType(Context.Type.Endpoint);
      getContext().add(current);
    }
    String endpoint=""String_Node_Str"";
    if (_processType != null) {
      endpoint=_processType;
      if (_instanceId != null) {
        endpoint+=""String_Node_Str"";
      }
    }
    if (_instanceId != null) {
      endpoint+=_instanceId;
    }
    current.setValue(endpoint);
  }
 catch (  Throwable t) {
  }
}","/** 
 * This method updates the endpoint context value when the process type and/or instance id are changed.
 */
protected void updateEndpointContext(){
  Context current=null;
  try {
    for (    Context context : getContext()) {
      if (context.getType() == Context.Type.Endpoint) {
        current=context;
        break;
      }
    }
    if (current == null) {
      current=new Context();
      current.setType(Context.Type.Endpoint);
      getContext().add(current);
    }
    String endpoint=""String_Node_Str"";
    if (_processType != null) {
      endpoint=_processType;
      if (_instanceId != null) {
        endpoint+=""String_Node_Str"";
      }
    }
    if (_instanceId != null) {
      endpoint+=_instanceId;
    }
    current.setValue(endpoint);
  }
 catch (  Throwable t) {
    current=null;
  }
}"
50743,"/** 
 * This method returns a resolved object for the supplied type.
 * @param cls The required type
 * @return The resolved object, or null if not found
 */
@SuppressWarnings(""String_Node_Str"") public static <T>T getBean(Class<T> cls){
  T ret=null;
  try {
    javax.enterprise.inject.spi.BeanManager bm=javax.naming.InitialContext.doLookup(""String_Node_Str"");
    java.util.Set<javax.enterprise.inject.spi.Bean<?>> beans=bm.getBeans(cls);
    for (    javax.enterprise.inject.spi.Bean<?> b : beans) {
      javax.enterprise.context.spi.CreationalContext<Object> cc=new javax.enterprise.context.spi.CreationalContext<Object>(){
        public void push(        Object arg0){
        }
        public void release(){
        }
      }
;
      ret=(T)((javax.enterprise.inject.spi.Bean<Object>)b).create(cc);
      if (LOG.isLoggable(java.util.logging.Level.FINE)) {
        LOG.fine(""String_Node_Str"" + ret + ""String_Node_Str""+ b);
      }
      if (ret != null) {
        break;
      }
    }
  }
 catch (  Throwable e) {
    LOG.log(java.util.logging.Level.SEVERE,""String_Node_Str"" + cls + ""String_Node_Str"",e);
  }
  return (ret);
}","/** 
 * This method returns a resolved object for the supplied type.
 * @param cls The required type
 * @param < T > The bean type
 * @return The resolved object, or null if not found
 */
@SuppressWarnings(""String_Node_Str"") public static <T>T getBean(Class<T> cls){
  T ret=null;
  try {
    javax.enterprise.inject.spi.BeanManager bm=javax.naming.InitialContext.doLookup(""String_Node_Str"");
    java.util.Set<javax.enterprise.inject.spi.Bean<?>> beans=bm.getBeans(cls);
    for (    javax.enterprise.inject.spi.Bean<?> b : beans) {
      javax.enterprise.context.spi.CreationalContext<Object> cc=new javax.enterprise.context.spi.CreationalContext<Object>(){
        public void push(        Object arg0){
        }
        public void release(){
        }
      }
;
      ret=(T)((javax.enterprise.inject.spi.Bean<Object>)b).create(cc);
      if (LOG.isLoggable(java.util.logging.Level.FINE)) {
        LOG.fine(""String_Node_Str"" + ret + ""String_Node_Str""+ b);
      }
      if (ret != null) {
        break;
      }
    }
  }
 catch (  Throwable e) {
    LOG.log(java.util.logging.Level.SEVERE,""String_Node_Str"" + cls + ""String_Node_Str"",e);
  }
  return (ret);
}"
50744,"/** 
 * This method resolves multiple objects of the required type.
 * @param cls The required type
 * @param list The result list
 */
public static <T>void getBeans(Class<T> cls,java.util.List<T> list){
  try {
    javax.enterprise.inject.spi.BeanManager bm=javax.naming.InitialContext.doLookup(""String_Node_Str"");
    java.util.Set<javax.enterprise.inject.spi.Bean<?>> beans=bm.getBeans(cls);
    for (    javax.enterprise.inject.spi.Bean<?> b : beans) {
      javax.enterprise.context.spi.CreationalContext<Object> cc=new javax.enterprise.context.spi.CreationalContext<Object>(){
        public void push(        Object arg0){
        }
        public void release(){
        }
      }
;
      @SuppressWarnings(""String_Node_Str"") T entry=(T)((javax.enterprise.inject.spi.Bean<Object>)b).create(cc);
      if (LOG.isLoggable(java.util.logging.Level.FINE)) {
        LOG.fine(""String_Node_Str"" + entry + ""String_Node_Str""+ b);
      }
      list.add(entry);
    }
  }
 catch (  Throwable e) {
    LOG.log(java.util.logging.Level.SEVERE,""String_Node_Str"" + cls + ""String_Node_Str"",e);
  }
}","/** 
 * This method resolves multiple objects of the required type.
 * @param cls The required type
 * @param list The result list
 * @param < T > The bean type
 */
public static <T>void getBeans(Class<T> cls,java.util.List<T> list){
  try {
    javax.enterprise.inject.spi.BeanManager bm=javax.naming.InitialContext.doLookup(""String_Node_Str"");
    java.util.Set<javax.enterprise.inject.spi.Bean<?>> beans=bm.getBeans(cls);
    for (    javax.enterprise.inject.spi.Bean<?> b : beans) {
      javax.enterprise.context.spi.CreationalContext<Object> cc=new javax.enterprise.context.spi.CreationalContext<Object>(){
        public void push(        Object arg0){
        }
        public void release(){
        }
      }
;
      @SuppressWarnings(""String_Node_Str"") T entry=(T)((javax.enterprise.inject.spi.Bean<Object>)b).create(cc);
      if (LOG.isLoggable(java.util.logging.Level.FINE)) {
        LOG.fine(""String_Node_Str"" + entry + ""String_Node_Str""+ b);
      }
      list.add(entry);
    }
  }
 catch (  Throwable e) {
    LOG.log(java.util.logging.Level.SEVERE,""String_Node_Str"" + cls + ""String_Node_Str"",e);
  }
}"
50745,"/** 
 * This method loads the rule base associated with the Drools event processor.
 * @return The knowledge base
 * @throws Exception Failed to load rule base
 */
private KieBase loadRuleBase() throws Exception {
  String droolsRuleBase=getRuleName() + ""String_Node_Str"";
  try {
    KieServices ks=KieServices.Factory.get();
    KieRepository kr=ks.getRepository();
    KieModuleModel kmm=ks.newKieModuleModel();
    KieBaseModel kbm=kmm.newKieBaseModel(getRuleName()).setEqualsBehavior(EqualityBehaviorOption.EQUALITY).setEventProcessingMode(EventProcessingOption.STREAM);
    kbm.setDefault(true);
    KieFileSystem kfs=ks.newKieFileSystem();
    kfs.write(""String_Node_Str"" + kbm.getName() + ""String_Node_Str"",ks.getResources().newClassPathResource(droolsRuleBase));
    kfs.writeKModuleXML(kmm.toXML());
    KieBuilder kb=ks.newKieBuilder(kfs);
    kb.buildAll();
    KieContainer container=ks.newKieContainer(kr.getDefaultReleaseId());
    KieBase kbase=container.getKieBase();
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    return kbase;
  }
 catch (  Throwable e) {
    String mesg=MessageFormat.format(java.util.PropertyResourceBundle.getBundle(""String_Node_Str"").getString(""String_Node_Str""),droolsRuleBase,getRuleName());
    LOG.log(Level.SEVERE,mesg,e);
    throw new Exception(mesg,e);
  }
}","/** 
 * This method loads the rule base associated with the Drools event processor.
 * @return The knowledge base
 * @throws Exception Failed to load rule base
 */
@SuppressWarnings(""String_Node_Str"") private KieBase loadRuleBase() throws Exception {
  String droolsRuleBase=getRuleName() + ""String_Node_Str"";
  try {
    KnowledgeBuilderConfiguration kBuilderConfiguration=KnowledgeBuilderFactory.newKnowledgeBuilderConfiguration(null,Thread.currentThread().getContextClassLoader());
    KnowledgeBuilder kbuilder=KnowledgeBuilderFactory.newKnowledgeBuilder(kBuilderConfiguration);
    kbuilder.add(ResourceFactory.newClassPathResource(droolsRuleBase),ResourceType.DRL);
    if (kbuilder.hasErrors()) {
      String mesg=MessageFormat.format(java.util.PropertyResourceBundle.getBundle(""String_Node_Str"").getString(""String_Node_Str""),droolsRuleBase,getRuleName());
      mesg+=""String_Node_Str"" + kbuilder.getErrors().toString();
      LOG.log(Level.SEVERE,mesg);
      throw new Exception(mesg);
    }
    KieBaseConfiguration config=KnowledgeBaseFactory.newKnowledgeBaseConfiguration(null,Thread.currentThread().getContextClassLoader());
    config.setOption(EventProcessingOption.STREAM);
    KnowledgeBase kbase=KnowledgeBaseFactory.newKnowledgeBase(config);
    kbase.addKnowledgePackages(kbuilder.getKnowledgePackages());
    return kbase;
  }
 catch (  Throwable e) {
    String mesg=MessageFormat.format(java.util.PropertyResourceBundle.getBundle(""String_Node_Str"").getString(""String_Node_Str""),droolsRuleBase,getRuleName());
    LOG.log(Level.SEVERE,mesg,e);
    throw new Exception(mesg,e);
  }
}"
50746,"@Test public void testGetWorkingDurationAcrossDayBoundary(){
  Calendar cal=new Calendar();
  Calendar.WorkingDay monday=new Calendar.WorkingDay();
  monday.setStartHour(9);
  monday.setEndHour(17);
  monday.setEndMinute(30);
  cal.setMonday(monday);
  Calendar.WorkingDay tuesday=new Calendar.WorkingDay();
  tuesday.setStartHour(9);
  tuesday.setEndHour(17);
  tuesday.setEndMinute(30);
  cal.setTuesday(tuesday);
  java.util.Calendar from1=java.util.Calendar.getInstance();
  from1.set(java.util.Calendar.DAY_OF_MONTH,24);
  from1.set(java.util.Calendar.MONTH,java.util.Calendar.JUNE);
  from1.set(java.util.Calendar.YEAR,2013);
  from1.set(java.util.Calendar.HOUR_OF_DAY,16);
  from1.set(java.util.Calendar.MINUTE,0);
  java.util.Calendar to1=java.util.Calendar.getInstance();
  to1.set(java.util.Calendar.DAY_OF_MONTH,25);
  to1.set(java.util.Calendar.MONTH,java.util.Calendar.JUNE);
  to1.set(java.util.Calendar.YEAR,2013);
  to1.set(java.util.Calendar.HOUR_OF_DAY,10);
  to1.set(java.util.Calendar.MINUTE,0);
  if (cal.getWorkingDuration(from1.getTimeInMillis(),to1.getTimeInMillis()) != 2.5 * 60 * 60* 1000) {
    fail(""String_Node_Str"" + cal.getWorkingDuration(from1.getTimeInMillis(),to1.getTimeInMillis()));
  }
}","@Test public void testGetWorkingDurationAcrossDayBoundary(){
  Calendar cal=new Calendar();
  Calendar.WorkingDay monday=new Calendar.WorkingDay();
  monday.setStartHour(9);
  monday.setEndHour(17);
  monday.setEndMinute(30);
  cal.setMonday(monday);
  Calendar.WorkingDay tuesday=new Calendar.WorkingDay();
  tuesday.setStartHour(9);
  tuesday.setEndHour(17);
  tuesday.setEndMinute(30);
  cal.setTuesday(tuesday);
  java.util.Calendar from1=java.util.Calendar.getInstance();
  from1.set(java.util.Calendar.DAY_OF_MONTH,24);
  from1.set(java.util.Calendar.MONTH,java.util.Calendar.JUNE);
  from1.set(java.util.Calendar.YEAR,2013);
  from1.set(java.util.Calendar.HOUR_OF_DAY,16);
  from1.set(java.util.Calendar.MINUTE,0);
  java.util.Calendar to1=java.util.Calendar.getInstance();
  to1.set(java.util.Calendar.DAY_OF_MONTH,25);
  to1.set(java.util.Calendar.MONTH,java.util.Calendar.JUNE);
  to1.set(java.util.Calendar.YEAR,2013);
  to1.set(java.util.Calendar.HOUR_OF_DAY,10);
  to1.set(java.util.Calendar.MINUTE,0);
  double val=Math.abs(cal.getWorkingDuration(from1.getTimeInMillis(),to1.getTimeInMillis()) - 2.5 * 60 * 60* 1000);
  if (val > 10) {
    fail(""String_Node_Str"" + cal.getWorkingDuration(from1.getTimeInMillis(),to1.getTimeInMillis()));
  }
}"
50747,"@Test @OperateOnDeployment(""String_Node_Str"") public void testSLAReport(){
  try {
    java.util.Calendar startDateTime=java.util.Calendar.getInstance();
    Thread.sleep(2000);
    SOAPConnectionFactory factory=SOAPConnectionFactory.newInstance();
    SOAPConnection con=factory.createConnection();
    java.net.URL url=new java.net.URL(ORDER_SERVICE_URL);
    String mesg=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    java.io.InputStream is=new java.io.ByteArrayInputStream(mesg.getBytes());
    SOAPMessage request=MessageFactory.newInstance().createMessage(null,is);
    is.close();
    SOAPMessage response=con.call(request,url);
    java.io.ByteArrayOutputStream baos=new java.io.ByteArrayOutputStream();
    response.writeTo(baos);
    baos.close();
    Thread.sleep(4000);
    java.util.Calendar endDateTime=java.util.Calendar.getInstance();
    java.util.Map<String,String> params=new java.util.HashMap<String,String>();
    params.put(""String_Node_Str"",""String_Node_Str"");
    params.put(""String_Node_Str"",""String_Node_Str"");
    params.put(""String_Node_Str"",""String_Node_Str"");
    params.put(""String_Node_Str"",""String_Node_Str"" + startDateTime.get(java.util.Calendar.DAY_OF_MONTH));
    params.put(""String_Node_Str"",""String_Node_Str"" + (startDateTime.get(java.util.Calendar.MONTH) + 1));
    params.put(""String_Node_Str"",""String_Node_Str"" + startDateTime.get(java.util.Calendar.YEAR));
    params.put(""String_Node_Str"",""String_Node_Str"" + startDateTime.get(java.util.Calendar.HOUR_OF_DAY));
    params.put(""String_Node_Str"",""String_Node_Str"" + startDateTime.get(java.util.Calendar.MINUTE));
    params.put(""String_Node_Str"",""String_Node_Str"" + startDateTime.get(java.util.Calendar.SECOND));
    params.put(""String_Node_Str"",""String_Node_Str"" + endDateTime.get(java.util.Calendar.DAY_OF_MONTH));
    params.put(""String_Node_Str"",""String_Node_Str"" + (endDateTime.get(java.util.Calendar.MONTH) + 1));
    params.put(""String_Node_Str"",""String_Node_Str"" + endDateTime.get(java.util.Calendar.YEAR));
    params.put(""String_Node_Str"",""String_Node_Str"" + endDateTime.get(java.util.Calendar.HOUR_OF_DAY));
    params.put(""String_Node_Str"",""String_Node_Str"" + endDateTime.get(java.util.Calendar.MINUTE));
    params.put(""String_Node_Str"",""String_Node_Str"" + endDateTime.get(java.util.Calendar.SECOND));
    String reportjson=getReport(""String_Node_Str"",params);
    if (reportjson == null) {
      fail(""String_Node_Str"");
    }
    System.out.println(""String_Node_Str"" + reportjson);
    Report report=ReportsUtil.deserializeReport(reportjson.getBytes());
    if (report == null) {
      fail(""String_Node_Str"");
    }
    if (report.getSections().size() != 1) {
      fail(""String_Node_Str"" + report.getSections().size());
    }
    Tabular section=(Tabular)report.getSections().get(0);
    if (section.getRows().size() != 1) {
      fail(""String_Node_Str"" + section.getRows().size());
    }
    if (section.getSummary() == null) {
      fail(""String_Node_Str"");
    }
    if ((section.getSummary().getValues().get(1) instanceof Number) == false) {
      fail(""String_Node_Str"");
    }
    if (((Number)section.getSummary().getValues().get(1)).intValue() != 450) {
      fail(""String_Node_Str"" + section.getSummary().getValues().get(1));
    }
    if (!section.getSummary().getProperties().containsKey(""String_Node_Str"")) {
      fail(""String_Node_Str"");
    }
    if (((Number)section.getSummary().getProperties().get(""String_Node_Str"")).doubleValue() != 6.43) {
      fail(""String_Node_Str"" + section.getSummary().getProperties().get(""String_Node_Str""));
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + e);
  }
}","@Test @OperateOnDeployment(""String_Node_Str"") public void testSLAReport(){
  try {
    java.util.Calendar startDateTime=java.util.Calendar.getInstance();
    Thread.sleep(2000);
    SOAPConnectionFactory factory=SOAPConnectionFactory.newInstance();
    SOAPConnection con=factory.createConnection();
    java.net.URL url=new java.net.URL(ORDER_SERVICE_URL);
    String mesg=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
    java.io.InputStream is=new java.io.ByteArrayInputStream(mesg.getBytes());
    SOAPMessage request=MessageFactory.newInstance().createMessage(null,is);
    is.close();
    SOAPMessage response=con.call(request,url);
    java.io.ByteArrayOutputStream baos=new java.io.ByteArrayOutputStream();
    response.writeTo(baos);
    baos.close();
    Thread.sleep(4000);
    java.util.Calendar endDateTime=java.util.Calendar.getInstance();
    boolean f_enableCalendar=false;
    if (startDateTime.get(java.util.Calendar.DAY_OF_WEEK) >= java.util.Calendar.MONDAY && startDateTime.get(java.util.Calendar.DAY_OF_WEEK) >= java.util.Calendar.FRIDAY && startDateTime.get(java.util.Calendar.HOUR_OF_DAY) >= 9 && startDateTime.get(java.util.Calendar.HOUR_OF_DAY) <= 5) {
      f_enableCalendar=true;
    }
    java.util.Map<String,String> params=new java.util.HashMap<String,String>();
    params.put(""String_Node_Str"",""String_Node_Str"");
    params.put(""String_Node_Str"",""String_Node_Str"");
    if (f_enableCalendar) {
      params.put(""String_Node_Str"",""String_Node_Str"");
    }
    params.put(""String_Node_Str"",""String_Node_Str"" + startDateTime.get(java.util.Calendar.DAY_OF_MONTH));
    params.put(""String_Node_Str"",""String_Node_Str"" + (startDateTime.get(java.util.Calendar.MONTH) + 1));
    params.put(""String_Node_Str"",""String_Node_Str"" + startDateTime.get(java.util.Calendar.YEAR));
    params.put(""String_Node_Str"",""String_Node_Str"" + startDateTime.get(java.util.Calendar.HOUR_OF_DAY));
    params.put(""String_Node_Str"",""String_Node_Str"" + startDateTime.get(java.util.Calendar.MINUTE));
    params.put(""String_Node_Str"",""String_Node_Str"" + startDateTime.get(java.util.Calendar.SECOND));
    params.put(""String_Node_Str"",""String_Node_Str"" + endDateTime.get(java.util.Calendar.DAY_OF_MONTH));
    params.put(""String_Node_Str"",""String_Node_Str"" + (endDateTime.get(java.util.Calendar.MONTH) + 1));
    params.put(""String_Node_Str"",""String_Node_Str"" + endDateTime.get(java.util.Calendar.YEAR));
    params.put(""String_Node_Str"",""String_Node_Str"" + endDateTime.get(java.util.Calendar.HOUR_OF_DAY));
    params.put(""String_Node_Str"",""String_Node_Str"" + endDateTime.get(java.util.Calendar.MINUTE));
    params.put(""String_Node_Str"",""String_Node_Str"" + endDateTime.get(java.util.Calendar.SECOND));
    String reportjson=getReport(""String_Node_Str"",params);
    if (reportjson == null) {
      fail(""String_Node_Str"");
    }
    System.out.println(""String_Node_Str"" + reportjson);
    Report report=ReportsUtil.deserializeReport(reportjson.getBytes());
    if (report == null) {
      fail(""String_Node_Str"");
    }
    if (report.getSections().size() != 1) {
      fail(""String_Node_Str"" + report.getSections().size());
    }
    Tabular section=(Tabular)report.getSections().get(0);
    if (section.getRows().size() == 0) {
      fail(""String_Node_Str"" + section.getRows().size());
    }
    if (section.getSummary() == null) {
      fail(""String_Node_Str"");
    }
    if ((section.getSummary().getValues().get(1) instanceof Number) == false) {
      fail(""String_Node_Str"");
    }
    if (((Number)section.getSummary().getValues().get(1)).intValue() == 0) {
      fail(""String_Node_Str"" + section.getSummary().getValues().get(1));
    }
    if (f_enableCalendar) {
      if (!section.getSummary().getProperties().containsKey(""String_Node_Str"")) {
        fail(""String_Node_Str"");
      }
      if (((Number)section.getSummary().getProperties().get(""String_Node_Str"")).doubleValue() > 0) {
        fail(""String_Node_Str"" + section.getSummary().getProperties().get(""String_Node_Str""));
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + e);
  }
}"
50748,"/** 
 * This method calculates the number of milliseconds of working time during the supplied timestamps.
 * @param from The from timestamp
 * @param to The to timestamp
 * @return The duration in milliseconds
 */
public long getWorkingDuration(long from,long to){
  long ret=0;
  if (to > from) {
    java.util.Calendar fromDateTime=createCalendar(from);
    do {
      WorkingDay wd=findWorkingDay(fromDateTime);
      if (wd != null) {
        if (!isExcluded(fromDateTime)) {
          if (wd.getStartHour() > fromDateTime.get(java.util.Calendar.HOUR_OF_DAY)) {
            fromDateTime.set(java.util.Calendar.HOUR_OF_DAY,wd.getStartHour());
            fromDateTime.set(java.util.Calendar.MINUTE,wd.getStartMinute());
          }
 else           if (wd.getStartHour() == fromDateTime.get(java.util.Calendar.HOUR_OF_DAY) && wd.getStartMinute() > fromDateTime.get(java.util.Calendar.MINUTE)) {
            fromDateTime.set(java.util.Calendar.MINUTE,wd.getStartMinute());
          }
          long startOfDay=fromDateTime.getTimeInMillis();
          fromDateTime.set(java.util.Calendar.HOUR_OF_DAY,wd.getEndHour());
          fromDateTime.set(java.util.Calendar.MINUTE,wd.getEndMinute());
          long endOfDay=fromDateTime.getTimeInMillis();
          if (endOfDay > to) {
            endOfDay=to;
          }
          ret+=(endOfDay - startOfDay);
        }
      }
      fromDateTime=createCalendar(fromDateTime.getTimeInMillis() + (24 * 60 * 60* 1000));
      fromDateTime.set(java.util.Calendar.HOUR_OF_DAY,0);
      fromDateTime.set(java.util.Calendar.MINUTE,0);
    }
 while (fromDateTime.getTimeInMillis() < to);
  }
  return (ret);
}","/** 
 * This method calculates the number of milliseconds of working time during the supplied timestamps.
 * @param from The from timestamp
 * @param to The to timestamp
 * @return The duration in milliseconds
 */
public long getWorkingDuration(long from,long to){
  long ret=0;
  if (to > from) {
    java.util.Calendar fromDateTime=createCalendar(from);
    do {
      WorkingDay wd=findWorkingDay(fromDateTime);
      if (wd != null) {
        if (!isExcluded(fromDateTime)) {
          if (wd.getStartHour() > fromDateTime.get(java.util.Calendar.HOUR_OF_DAY)) {
            fromDateTime.set(java.util.Calendar.HOUR_OF_DAY,wd.getStartHour());
            fromDateTime.set(java.util.Calendar.MINUTE,wd.getStartMinute());
          }
 else           if (wd.getStartHour() == fromDateTime.get(java.util.Calendar.HOUR_OF_DAY) && wd.getStartMinute() > fromDateTime.get(java.util.Calendar.MINUTE)) {
            fromDateTime.set(java.util.Calendar.MINUTE,wd.getStartMinute());
          }
          long startOfDay=fromDateTime.getTimeInMillis();
          fromDateTime.set(java.util.Calendar.HOUR_OF_DAY,wd.getEndHour());
          fromDateTime.set(java.util.Calendar.MINUTE,wd.getEndMinute());
          long endOfDay=fromDateTime.getTimeInMillis();
          if (endOfDay > to) {
            endOfDay=to;
          }
          ret+=(endOfDay - startOfDay);
        }
      }
      fromDateTime.set(java.util.Calendar.DAY_OF_MONTH,fromDateTime.get(java.util.Calendar.DAY_OF_MONTH) + 1);
      fromDateTime.set(java.util.Calendar.HOUR_OF_DAY,0);
      fromDateTime.set(java.util.Calendar.MINUTE,0);
    }
 while (fromDateTime.getTimeInMillis() < to);
  }
  return (ret);
}"
50749,"/** 
 * This method initializes the active collection source.
 * @throws Exception Failed to initialize source
 */
public void init(ActiveCollectionContext context) throws Exception {
  _context=context;
  preInit();
  if (_listeners.size() > 0) {
    for (    AbstractActiveChangeListener l : _listeners) {
      if (LOG.isLoggable(Level.FINER)) {
        LOG.finer(""String_Node_Str"" + getName() + ""String_Node_Str""+ l);
      }
      l.init();
      if (_activeCollection != null) {
        _activeCollection.addActiveChangeListener(l);
      }
    }
  }
  if (_groupBy != null) {
    _groupByExpression=MVEL.compileExpression(_groupBy);
    if (_aggregationDuration > 0) {
      _aggregator=new Aggregator();
    }
  }
  if (_scheduledScriptExpression != null && _scheduledInterval > 0) {
    _scheduledTimer=new java.util.Timer();
    _scheduledTimer.scheduleAtFixedRate(new TimerTask(){
      public void run(){
        java.util.Map<String,Object> vars=new java.util.HashMap<String,Object>();
        vars.put(""String_Node_Str"",ActiveCollectionSource.this);
        vars.put(""String_Node_Str"",_variables);
        if (LOG.isLoggable(Level.FINE)) {
          LOG.fine(""String_Node_Str"" + getName() + ""String_Node_Str""+ _variables);
        }
synchronized (ActiveCollectionSource.this) {
          MVEL.executeExpression(_scheduledScriptExpression,vars);
        }
      }
    }
,0,_scheduledInterval);
  }
}","/** 
 * This method initializes the active collection source.
 * @param context The context
 * @throws Exception Failed to initialize source
 */
public void init(ActiveCollectionContext context) throws Exception {
  _context=context;
  preInit();
  if (_listeners.size() > 0) {
    for (    AbstractActiveChangeListener l : _listeners) {
      if (LOG.isLoggable(Level.FINER)) {
        LOG.finer(""String_Node_Str"" + getName() + ""String_Node_Str""+ l);
      }
      l.init();
      if (_activeCollection != null) {
        _activeCollection.addActiveChangeListener(l);
      }
    }
  }
  if (_groupBy != null) {
    _groupByExpression=MVEL.compileExpression(_groupBy);
    if (_aggregationDuration > 0) {
      _aggregator=new Aggregator();
    }
  }
  if (_scheduledScriptExpression != null && _scheduledInterval > 0) {
    _scheduledTimer=new java.util.Timer();
    _scheduledTimer.scheduleAtFixedRate(new TimerTask(){
      public void run(){
        java.util.Map<String,Object> vars=new java.util.HashMap<String,Object>();
        vars.put(""String_Node_Str"",ActiveCollectionSource.this);
        vars.put(""String_Node_Str"",_variables);
        if (LOG.isLoggable(Level.FINE)) {
          LOG.fine(""String_Node_Str"" + getName() + ""String_Node_Str""+ _variables);
        }
synchronized (ActiveCollectionSource.this) {
          MVEL.executeExpression(_scheduledScriptExpression,vars);
        }
      }
    }
,0,_scheduledInterval);
  }
}"
50750,"/** 
 * This method calculates the number of milliseconds of working time during the supplied timestamps.
 * @param from
 * @param to
 * @return
 */
public long getWorkingDuration(long from,long to){
  long ret=0;
  if (to > from) {
    java.util.Calendar fromDateTime=createCalendar(from);
    do {
      WorkingDay wd=findWorkingDay(fromDateTime);
      if (wd != null) {
        if (!isExcluded(fromDateTime)) {
          if (wd.getStartHour() > fromDateTime.get(java.util.Calendar.HOUR_OF_DAY)) {
            fromDateTime.set(java.util.Calendar.HOUR_OF_DAY,wd.getStartHour());
            fromDateTime.set(java.util.Calendar.MINUTE,wd.getStartMinute());
          }
 else           if (wd.getStartHour() == fromDateTime.get(java.util.Calendar.HOUR_OF_DAY) && wd.getStartMinute() > fromDateTime.get(java.util.Calendar.MINUTE)) {
            fromDateTime.set(java.util.Calendar.MINUTE,wd.getStartMinute());
          }
          long startOfDay=fromDateTime.getTimeInMillis();
          fromDateTime.set(java.util.Calendar.HOUR_OF_DAY,wd.getEndHour());
          fromDateTime.set(java.util.Calendar.MINUTE,wd.getEndMinute());
          long endOfDay=fromDateTime.getTimeInMillis();
          if (endOfDay > to) {
            endOfDay=to;
          }
          ret+=(endOfDay - startOfDay);
        }
      }
      fromDateTime=createCalendar(fromDateTime.getTimeInMillis() + (24 * 60 * 60* 1000));
      fromDateTime.set(java.util.Calendar.HOUR_OF_DAY,0);
      fromDateTime.set(java.util.Calendar.MINUTE,0);
    }
 while (fromDateTime.getTimeInMillis() < to);
  }
  return (ret);
}","/** 
 * This method calculates the number of milliseconds of working time during the supplied timestamps.
 * @param from The from timestamp
 * @param to The to timestamp
 * @return The duration in milliseconds
 */
public long getWorkingDuration(long from,long to){
  long ret=0;
  if (to > from) {
    java.util.Calendar fromDateTime=createCalendar(from);
    do {
      WorkingDay wd=findWorkingDay(fromDateTime);
      if (wd != null) {
        if (!isExcluded(fromDateTime)) {
          if (wd.getStartHour() > fromDateTime.get(java.util.Calendar.HOUR_OF_DAY)) {
            fromDateTime.set(java.util.Calendar.HOUR_OF_DAY,wd.getStartHour());
            fromDateTime.set(java.util.Calendar.MINUTE,wd.getStartMinute());
          }
 else           if (wd.getStartHour() == fromDateTime.get(java.util.Calendar.HOUR_OF_DAY) && wd.getStartMinute() > fromDateTime.get(java.util.Calendar.MINUTE)) {
            fromDateTime.set(java.util.Calendar.MINUTE,wd.getStartMinute());
          }
          long startOfDay=fromDateTime.getTimeInMillis();
          fromDateTime.set(java.util.Calendar.HOUR_OF_DAY,wd.getEndHour());
          fromDateTime.set(java.util.Calendar.MINUTE,wd.getEndMinute());
          long endOfDay=fromDateTime.getTimeInMillis();
          if (endOfDay > to) {
            endOfDay=to;
          }
          ret+=(endOfDay - startOfDay);
        }
      }
      fromDateTime=createCalendar(fromDateTime.getTimeInMillis() + (24 * 60 * 60* 1000));
      fromDateTime.set(java.util.Calendar.HOUR_OF_DAY,0);
      fromDateTime.set(java.util.Calendar.MINUTE,0);
    }
 while (fromDateTime.getTimeInMillis() < to);
  }
  return (ret);
}"
50751,"/** 
 * This method sets the reason for exclusion.
 * @param val The reason
 */
public ExcludedDay setReason(String val){
  _reason=val;
  return (this);
}","/** 
 * This method sets the reason for exclusion.
 * @param val The reason
 * @return The excluded day
 */
public ExcludedDay setReason(String val){
  _reason=val;
  return (this);
}"
50752,"/** 
 * This method sets the day.
 * @param val The day
 */
public ExcludedDay setDay(int val){
  _day=val;
  return (this);
}","/** 
 * This method sets the day.
 * @param val The day
 * @return The excluded day
 */
public ExcludedDay setDay(int val){
  _day=val;
  return (this);
}"
50753,"/** 
 * This method sets the end minute.
 * @param val The end minute
 */
public WorkingDay setEndMinute(int val){
  _endMinute=val;
  return (this);
}","/** 
 * This method sets the end minute.
 * @param val The end minute
 * @return The working day
 */
public WorkingDay setEndMinute(int val){
  _endMinute=val;
  return (this);
}"
50754,"/** 
 * This method sets the month. January is represented by 1, through to December which is represented by 12.
 * @param val The month
 */
public ExcludedDay setMonth(int val){
  _month=val;
  return (this);
}","/** 
 * This method sets the month. January is represented by 1, through to December which is represented by 12.
 * @param val The month
 * @return The excluded day
 */
public ExcludedDay setMonth(int val){
  _month=val;
  return (this);
}"
50755,"/** 
 * This method sets the year.
 * @param val The year
 */
public ExcludedDay setYear(int val){
  _year=val;
  return (this);
}","/** 
 * This method sets the year.
 * @param val The year
 * @return The excluded day
 */
public ExcludedDay setYear(int val){
  _year=val;
  return (this);
}"
50756,"/** 
 * This method sets the end hour.
 * @param val The end hour
 */
public WorkingDay setEndHour(int val){
  _endHour=val;
  return (this);
}","/** 
 * This method sets the end hour.
 * @param val The end hour
 * @return The working day
 */
public WorkingDay setEndHour(int val){
  _endHour=val;
  return (this);
}"
50757,"/** 
 * This method sets the start minute.
 * @param val The start minute
 */
public WorkingDay setStartMinute(int val){
  _startMinute=val;
  return (this);
}","/** 
 * This method sets the start minute.
 * @param val The start minute
 * @return The working day
 */
public WorkingDay setStartMinute(int val){
  _startMinute=val;
  return (this);
}"
50758,"/** 
 * This method sets the start hour.
 * @param val The start hour
 */
public WorkingDay setStartHour(int val){
  _startHour=val;
  return (this);
}","/** 
 * This method sets the start hour.
 * @param val The start hour
 * @return The working day
 */
public WorkingDay setStartHour(int val){
  _startHour=val;
  return (this);
}"
50759,"/** 
 * This method returns the service node associated with the supplied service interface.
 * @param intf The interface
 * @return The service node, or null if not found
 */
public ServiceNode getServiceNode(String serviceType){
  ServiceNode ret=null;
  for (  ServiceNode sn : _nodes) {
    if (sn.getService().getServiceType().equals(serviceType)) {
      ret=sn;
      break;
    }
  }
  return (ret);
}","/** 
 * This method returns the service node associated with the supplied service interface.
 * @param serviceType The service type
 * @return The service node, or null if not found
 */
public ServiceNode getServiceNode(String serviceType){
  ServiceNode ret=null;
  for (  ServiceNode sn : _nodes) {
    if (sn.getService().getServiceType().equals(serviceType)) {
      ret=sn;
      break;
    }
  }
  return (ret);
}"
50760,"/** 
 * {@inheritDoc}
 */
public void handleEvent(EventObject event){
  org.apache.camel.Exchange exch=((org.apache.camel.management.event.AbstractExchangeEvent)event).getExchange();
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + exch);
  }
  org.switchyard.bus.camel.CamelMessage mesg=(org.switchyard.bus.camel.CamelMessage)exch.getIn();
  ExchangePhase phase=exch.getProperty(""String_Node_Str"",ExchangePhase.class);
  if (phase == null) {
    LOG.severe(""String_Node_Str"" + exch);
    return;
  }
  if (mesg == null) {
    LOG.severe(""String_Node_Str"" + phase + ""String_Node_Str""+ exch);
    return;
  }
  org.switchyard.Context context=new org.switchyard.bus.camel.CamelCompositeContext(exch,mesg);
  Service provider=exch.getProperty(""String_Node_Str"",Service.class);
  ServiceReference consumer=exch.getProperty(""String_Node_Str"",ServiceReference.class);
  SecurityContext securityContext=exch.getProperty(""String_Node_Str"",SecurityContext.class);
  BaseExchangeContract contract=exch.getProperty(""String_Node_Str"",BaseExchangeContract.class);
  String messageId=null;
  String relatesTo=null;
  String contentType=null;
  java.util.Set<Property> props=context.getProperties(org.switchyard.Scope.MESSAGE);
  for (  Property p : props) {
    if (LOG.isLoggable(Level.FINEST)) {
      LOG.finest(""String_Node_Str"" + p.getName() + ""String_Node_Str""+ p.getValue());
    }
    if (p.getName().equals(""String_Node_Str"")) {
      messageId=(String)p.getValue();
    }
 else     if (p.getName().equals(""String_Node_Str"")) {
      relatesTo=(String)p.getValue();
    }
 else     if (p.getName().equals(""String_Node_Str"")) {
      contentType=((QName)p.getValue()).toString();
    }
  }
  QName serviceType=consumer.getName();
  String opName=contract.getConsumerOperation().getName();
  if (phase == ExchangePhase.IN) {
    String intf=getInterface(consumer,provider);
    if (consumer.getConsumerMetadata().isBinding()) {
      getActivityCollector().startScope();
    }
 else {
      RequestSent sent=new RequestSent();
      if (provider == null || !provider.getProviderMetadata().isBinding()) {
        sent.setServiceType(serviceType.toString());
      }
      sent.setInterface(intf);
      sent.setOperation(opName);
      sent.setMessageId(messageId);
      record(mesg,contentType,sent,securityContext,exch);
      if (intf == null) {
        exch.setProperty(""String_Node_Str"",sent);
      }
    }
    if (provider == null || !provider.getProviderMetadata().isBinding()) {
      RequestReceived recvd=new RequestReceived();
      recvd.setServiceType(serviceType.toString());
      recvd.setInterface(intf);
      recvd.setOperation(opName);
      recvd.setMessageId(messageId);
      record(mesg,contentType,recvd,securityContext,exch);
      if (intf == null) {
        exch.setProperty(""String_Node_Str"",recvd);
      }
    }
  }
 else   if (phase == ExchangePhase.OUT) {
    if (contentType == null) {
      if (LOG.isLoggable(Level.FINEST)) {
        LOG.finest(""String_Node_Str"");
      }
      return;
    }
    String intf=getInterface(consumer,provider);
    RequestReceived rr=(RequestReceived)exch.getProperty(""String_Node_Str"");
    RequestSent rs=(RequestSent)exch.getProperty(""String_Node_Str"");
    if (intf != null) {
      if (rr != null) {
        rr.setInterface(intf);
      }
      if (rs != null) {
        rs.setInterface(intf);
      }
    }
    if (provider == null || !provider.getProviderMetadata().isBinding()) {
      ResponseSent sent=new ResponseSent();
      if (provider == null || !provider.getProviderMetadata().isBinding()) {
        sent.setServiceType(serviceType.toString());
      }
      sent.setInterface(intf);
      sent.setOperation(opName);
      sent.setMessageId(messageId);
      sent.setReplyToId(relatesTo);
      record(mesg,contentType,sent,securityContext,exch);
    }
    if (consumer.getConsumerMetadata().isBinding()) {
      getActivityCollector().endScope();
    }
 else {
      ResponseReceived recvd=new ResponseReceived();
      recvd.setServiceType(serviceType.toString());
      recvd.setInterface(intf);
      recvd.setOperation(opName);
      recvd.setMessageId(messageId);
      recvd.setReplyToId(relatesTo);
      record(mesg,contentType,recvd,securityContext,exch);
    }
  }
}","/** 
 * {@inheritDoc}
 */
public void handleEvent(EventObject event){
  org.apache.camel.Exchange exch=((org.apache.camel.management.event.AbstractExchangeEvent)event).getExchange();
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + exch);
  }
  org.switchyard.bus.camel.CamelMessage mesg=(org.switchyard.bus.camel.CamelMessage)exch.getIn();
  ExchangePhase phase=exch.getProperty(""String_Node_Str"",ExchangePhase.class);
  if (phase == null) {
    LOG.severe(""String_Node_Str"" + exch);
    return;
  }
  if (mesg == null) {
    LOG.severe(""String_Node_Str"" + phase + ""String_Node_Str""+ exch);
    return;
  }
  org.switchyard.Context context=new org.switchyard.bus.camel.CamelCompositeContext(exch,mesg);
  Service provider=exch.getProperty(""String_Node_Str"",Service.class);
  ServiceReference consumer=exch.getProperty(""String_Node_Str"",ServiceReference.class);
  String messageId=null;
  String relatesTo=null;
  String contentType=null;
  java.util.Set<Property> props=context.getProperties(org.switchyard.Scope.MESSAGE);
  for (  Property p : props) {
    if (LOG.isLoggable(Level.FINEST)) {
      LOG.finest(""String_Node_Str"" + p.getName() + ""String_Node_Str""+ p.getValue());
    }
    if (p.getName().equals(""String_Node_Str"")) {
      messageId=(String)p.getValue();
    }
 else     if (p.getName().equals(""String_Node_Str"")) {
      relatesTo=(String)p.getValue();
    }
 else     if (p.getName().equals(""String_Node_Str"")) {
      contentType=((QName)p.getValue()).toString();
    }
  }
  if (phase == ExchangePhase.IN) {
    handleInExchange(exch,provider,consumer,messageId,contentType,mesg);
  }
 else   if (phase == ExchangePhase.OUT) {
    if (contentType == null) {
      if (LOG.isLoggable(Level.FINEST)) {
        LOG.finest(""String_Node_Str"");
      }
      return;
    }
    handleOutExchange(exch,provider,consumer,messageId,relatesTo,contentType,mesg);
  }
}"
50761,"/** 
 * This method returns activity types (events) associated with the supplied context value.
 * @param type The type
 * @param value The value
 * @return The list of activity types
 * @throws Exception Failed to obtain activity types
 */
@GET @Path(""String_Node_Str"") @Produces(""String_Node_Str"") public String getActivityTypes(@QueryParam(""String_Node_Str"") String type,@QueryParam(""String_Node_Str"") String value,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") long from,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") long to) throws Exception {
  String ret=""String_Node_Str"";
  Context context=new Context();
  if (type != null) {
    context.setType(Context.Type.valueOf(type));
  }
  context.setValue(value);
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + context);
  }
  if (_activityServer == null) {
    throw new Exception(""String_Node_Str"");
  }
  java.util.List<ActivityType> list=null;
  if (from > 0 || to > 0) {
    list=_activityServer.getActivityTypes(context,from,to);
  }
 else {
    list=_activityServer.getActivityTypes(context);
  }
  if (list != null) {
    byte[] b=ActivityUtil.serializeActivityTypeList(list);
    ret=new String(b);
  }
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + ret);
  }
  return (ret);
}","/** 
 * This method returns activity types (events) associated with the supplied context value.
 * @param type The type
 * @param value The value
 * @param from The optional 'from' timestamp
 * @param to The optional 'to' timestamp
 * @return The list of activity types
 * @throws Exception Failed to obtain activity types
 */
@GET @Path(""String_Node_Str"") @Produces(""String_Node_Str"") public String getActivityTypes(@QueryParam(""String_Node_Str"") String type,@QueryParam(""String_Node_Str"") String value,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") long from,@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") long to) throws Exception {
  String ret=""String_Node_Str"";
  Context context=new Context();
  if (type != null) {
    context.setType(Context.Type.valueOf(type));
  }
  context.setValue(value);
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + context);
  }
  if (_activityServer == null) {
    throw new Exception(""String_Node_Str"");
  }
  java.util.List<ActivityType> list=null;
  if (from > 0 || to > 0) {
    list=_activityServer.getActivityTypes(context,from,to);
  }
 else {
    list=_activityServer.getActivityTypes(context);
  }
  if (list != null) {
    byte[] b=ActivityUtil.serializeActivityTypeList(list);
    ret=new String(b);
  }
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + ret);
  }
  return (ret);
}"
50762,"/** 
 * This method processes the supplied activity unit to create a set of trace nodes.
 * @param state The state
 * @param startau The activity unit being processed
 * @param topLevel The top level activity units
 */
protected static void processAU(CTState state,ActivityUnit startau,java.util.List<ActivityUnit> topLevel){
  ActivityType cur=null;
  Call call=(state.getCallStack().size() > 0 ? state.getCallStack().peek() : null);
  java.util.List<TraceNode> tasks=(state.getTasksStack().size() > 0 ? state.getTasksStack().peek() : null);
  ActivityType prev=null;
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + startau);
  }
  java.util.List<ActivityUnit> aus=state.getActivityUnits();
  int aupos=aus.indexOf(startau);
  if (aupos == -1) {
    LOG.severe(""String_Node_Str"" + startau);
    return;
  }
  boolean f_end=false;
  boolean f_scopeFinalized=false;
  for (int i=aupos; !f_end && i < aus.size(); i++) {
    ActivityUnit au=aus.get(i);
    if (i != aupos && topLevel.contains(au)) {
      continue;
    }
    if (i != aupos && !processSubsequentAU(startau,au)) {
      if (LOG.isLoggable(Level.FINEST)) {
        LOG.finest(""String_Node_Str"" + au + ""String_Node_Str""+ ""String_Node_Str"");
      }
      f_scopeFinalized=true;
      break;
    }
    if (LOG.isLoggable(Level.FINEST)) {
      LOG.finest(""String_Node_Str"" + aus.get(i));
    }
    ActivityUnitCursor cursor=state.getCursor(au);
    while ((cur=cursor.next()) != null) {
      if (LOG.isLoggable(Level.FINEST)) {
        LOG.finest(""String_Node_Str"" + cur);
      }
      if (shouldPostpone(state,au,topLevel,cur)) {
        break;
      }
      if (cur instanceof RPCActivityType) {
        if (cur instanceof RequestSent || (cur instanceof RequestReceived && call == null)) {
          call=createCall((RPCActivityType)cur);
          if (tasks != null) {
            tasks.add(call);
          }
 else           if (LOG.isLoggable(Level.FINE)) {
            LOG.fine(""String_Node_Str"");
          }
          tasks=call.getTasks();
          if (LOG.isLoggable(Level.FINEST)) {
            LOG.finest(""String_Node_Str"" + call);
            LOG.finest(""String_Node_Str"" + tasks);
          }
          state.getCallStack().push(call);
          state.getTasksStack().push(tasks);
          state.getTriggerActivities().put(call,(RPCActivityType)cur);
        }
        if (cur instanceof RequestSent) {
          instrumentCall(call,au,(RequestSent)cur);
          RPCActivityType rr=state.getSOAActivity(RequestReceived.class,((RequestSent)cur).getServiceType(),((RequestSent)cur).getOperation());
          if (rr != null) {
            call.setRequestLatency(rr.getTimestamp() - cur.getTimestamp());
            ActivityUnit subAU=state.getActivityUnit(rr.getUnitId());
            if (subAU != null) {
              processAU(state,subAU,topLevel);
              call=(state.getCallStack().size() > 0 ? state.getCallStack().peek() : null);
              tasks=(state.getTasksStack().size() > 0 ? state.getTasksStack().peek() : null);
            }
          }
        }
 else         if (cur instanceof RequestReceived) {
          instrumentCall(call,au,(RequestReceived)cur);
          call.setRequest(((RequestReceived)cur).getContent());
        }
 else         if (cur instanceof ResponseSent) {
          initializeResponseSent(state,(ResponseSent)cur,call);
          state.finalizeScope();
          f_scopeFinalized=true;
          call=(state.getCallStack().size() > 0 ? state.getCallStack().peek() : null);
          tasks=(state.getTasksStack().size() > 0 ? state.getTasksStack().peek() : null);
          if (state.getCallStack().size() > 0) {
            if (LOG.isLoggable(Level.FINEST)) {
              LOG.finest(""String_Node_Str"");
            }
            f_end=true;
            break;
          }
        }
 else         if (cur instanceof ResponseReceived) {
          initializeResponseReceived(state,(ResponseReceived)cur);
          f_end=true;
        }
      }
 else {
        Task task=createTask(cur);
        tasks.add(task);
        if (prev != null) {
          task.setDuration(cur.getTimestamp() - prev.getTimestamp());
        }
      }
      for (      Context con : cur.getContext()) {
        if (con.getType() == Context.Type.Link && !state.isLinkProcessed(con)) {
          state.linkProcessed(con);
          for (          ActivityUnit other : state.getActivityUnits(con)) {
            if (other != au) {
              if (LOG.isLoggable(Level.FINEST)) {
                LOG.finest(""String_Node_Str"" + other);
              }
              processAU(state,other,topLevel);
            }
          }
        }
      }
      prev=cur;
    }
  }
  if (!f_scopeFinalized) {
    state.finalizeScope();
  }
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + startau);
  }
}","/** 
 * This method processes the supplied activity unit to create a set of trace nodes.
 * @param state The state
 * @param startau The activity unit being processed
 * @param topLevel The top level activity units
 */
protected static void processAU(CTState state,ActivityUnit startau,java.util.List<ActivityUnit> topLevel){
  ActivityType cur=null;
  Call call=(state.getCallStack().size() > 0 ? state.getCallStack().peek() : null);
  java.util.List<TraceNode> tasks=(state.getTasksStack().size() > 0 ? state.getTasksStack().peek() : null);
  ActivityType prev=null;
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + startau);
  }
  java.util.List<ActivityUnit> aus=state.getActivityUnits();
  int aupos=aus.indexOf(startau);
  if (aupos == -1) {
    LOG.severe(""String_Node_Str"" + startau);
    return;
  }
  boolean f_end=false;
  boolean f_scopeFinalized=false;
  for (int i=aupos; !f_end && i < aus.size(); i++) {
    ActivityUnit au=aus.get(i);
    if (i != aupos) {
      if (topLevel.contains(au)) {
        continue;
      }
 else       if (!processSubsequentAU(startau,au)) {
        if (LOG.isLoggable(Level.FINEST)) {
          LOG.finest(""String_Node_Str"" + au + ""String_Node_Str""+ ""String_Node_Str"");
        }
        f_scopeFinalized=true;
        break;
      }
    }
    if (LOG.isLoggable(Level.FINEST)) {
      LOG.finest(""String_Node_Str"" + aus.get(i));
    }
    ActivityUnitCursor cursor=state.getCursor(au);
    while ((cur=cursor.next()) != null) {
      if (LOG.isLoggable(Level.FINEST)) {
        LOG.finest(""String_Node_Str"" + cur);
      }
      if (shouldPostpone(state,au,topLevel,cur)) {
        break;
      }
      if (cur instanceof RPCActivityType) {
        if (cur instanceof RequestSent || (cur instanceof RequestReceived && call == null)) {
          call=createCall((RPCActivityType)cur);
          if (tasks != null) {
            tasks.add(call);
          }
 else           if (LOG.isLoggable(Level.FINE)) {
            LOG.fine(""String_Node_Str"");
          }
          tasks=call.getTasks();
          if (LOG.isLoggable(Level.FINEST)) {
            LOG.finest(""String_Node_Str"" + call);
            LOG.finest(""String_Node_Str"" + tasks);
          }
          state.getCallStack().push(call);
          state.getTasksStack().push(tasks);
          state.getTriggerActivities().put(call,(RPCActivityType)cur);
        }
        if (cur instanceof RequestSent) {
          instrumentCall(call,au,(RequestSent)cur);
          RPCActivityType rr=state.getSOAActivity(RequestReceived.class,((RequestSent)cur).getServiceType(),((RequestSent)cur).getOperation());
          if (rr != null) {
            call.setRequestLatency(rr.getTimestamp() - cur.getTimestamp());
            ActivityUnit subAU=state.getActivityUnit(rr.getUnitId());
            if (subAU != null) {
              processAU(state,subAU,topLevel);
              call=(state.getCallStack().size() > 0 ? state.getCallStack().peek() : null);
              tasks=(state.getTasksStack().size() > 0 ? state.getTasksStack().peek() : null);
            }
          }
        }
 else         if (cur instanceof RequestReceived) {
          instrumentCall(call,au,(RequestReceived)cur);
          call.setRequest(((RequestReceived)cur).getContent());
        }
 else         if (cur instanceof ResponseSent) {
          initializeResponseSent(state,(ResponseSent)cur,call);
          state.finalizeScope();
          f_scopeFinalized=true;
          call=(state.getCallStack().size() > 0 ? state.getCallStack().peek() : null);
          tasks=(state.getTasksStack().size() > 0 ? state.getTasksStack().peek() : null);
          if (state.getCallStack().size() > 0) {
            if (LOG.isLoggable(Level.FINEST)) {
              LOG.finest(""String_Node_Str"");
            }
            f_end=true;
            break;
          }
        }
 else         if (cur instanceof ResponseReceived) {
          initializeResponseReceived(state,(ResponseReceived)cur);
          f_end=true;
        }
      }
 else {
        Task task=createTask(cur);
        tasks.add(task);
        if (prev != null) {
          task.setDuration(cur.getTimestamp() - prev.getTimestamp());
        }
      }
      checkForLinkedAU(cur,state,au,topLevel);
      prev=cur;
    }
  }
  if (!f_scopeFinalized) {
    state.finalizeScope();
  }
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + startau);
  }
}"
50763,"/** 
 * This method builds a service graph from a collection of service definitions.
 * @param sds The service definitions
 * @param sits The situations
 * @return The service graph
 */
public static ServiceGraph buildGraph(java.util.Set<ServiceDefinition> sds,java.util.List<Situation> sits){
  ServiceGraph ret=new ServiceGraph();
  java.util.Set<ServiceDefinition> initialNodes=getInitialServices(sds);
  for (  ServiceDefinition sd : sds) {
    ServiceNode sn=new ServiceNode();
    sn.setService(sd);
    for (    OperationDefinition op : sd.getOperations()) {
      OperationNode opn=new OperationNode();
      opn.setService(sd);
      opn.setOperation(op);
      String subject=sn.getService().getInterface() + ""String_Node_Str"" + op.getName();
      if (sits != null) {
        for (        Situation s : sits) {
          if (s.getSubject() != null && (s.getSubject().equals(subject) || s.getSubject().startsWith(subject + ""String_Node_Str""))) {
            opn.getSituations().add(s);
          }
        }
      }
      sn.getOperations().add(opn);
    }
    sn.getProperties().put(ServiceNode.INITIAL_NODE,initialNodes.contains(sd));
    if (sits != null) {
      for (      Situation s : sits) {
        if (s.getSubject() != null && s.getSubject().equals(sn.getService().getInterface())) {
          sn.getSituations().add(s);
        }
      }
    }
    ret.getServiceNodes().add(sn);
  }
  for (  ServiceDefinition sd : sds) {
    for (    OperationDefinition op : sd.getOperations()) {
      ServiceNode sn=ret.getServiceNode(sd.getInterface());
      OperationNode opn=sn.getOperation(op.getName());
      for (      OperationImplDefinition stod : op.getImplementations()) {
        if (stod.getRequestResponse() != null) {
          linkOperationNodes(ret,sn,opn,stod.getRequestResponse().getInvocations());
        }
        for (        RequestFaultDefinition rfd : stod.getRequestFaults()) {
          linkOperationNodes(ret,sn,opn,rfd.getInvocations());
        }
      }
    }
  }
  return (ret);
}","/** 
 * This method builds a service graph from a collection of service definitions.
 * @param sds The service definitions
 * @param sits The situations
 * @return The service graph
 */
public static ServiceGraph buildGraph(java.util.Set<ServiceDefinition> sds,java.util.List<Situation> sits){
  ServiceGraph ret=new ServiceGraph();
  java.util.Set<ServiceDefinition> initialNodes=getInitialServices(sds);
  for (  ServiceDefinition sd : sds) {
    ServiceNode sn=new ServiceNode();
    sn.setService(sd);
    for (    OperationDefinition op : sd.getOperations()) {
      OperationNode opn=new OperationNode();
      opn.setService(sd);
      opn.setOperation(op);
      if (sits != null) {
        for (        Situation s : sits) {
          String[] parts=s.subjectAsParts();
          if (parts.length > 1 && parts[0].equals(sn.getService().getInterface()) && parts[1].equals(op.getName())) {
            opn.getSituations().add(s);
          }
        }
      }
      sn.getOperations().add(opn);
    }
    sn.getProperties().put(ServiceNode.INITIAL_NODE,initialNodes.contains(sd));
    if (sits != null) {
      for (      Situation s : sits) {
        String[] parts=s.subjectAsParts();
        if (parts.length == 1 && parts[0].equals(sn.getService().getInterface())) {
          sn.getSituations().add(s);
        }
      }
    }
    ret.getServiceNodes().add(sn);
  }
  for (  ServiceDefinition sd : sds) {
    for (    OperationDefinition op : sd.getOperations()) {
      ServiceNode sn=ret.getServiceNode(sd.getInterface());
      OperationNode opn=sn.getOperation(op.getName());
      for (      OperationImplDefinition stod : op.getImplementations()) {
        if (stod.getRequestResponse() != null) {
          linkOperationNodes(ret,sn,opn,stod.getRequestResponse().getInvocations());
        }
        for (        RequestFaultDefinition rfd : stod.getRequestFaults()) {
          linkOperationNodes(ret,sn,opn,rfd.getInvocations());
        }
      }
    }
  }
  return (ret);
}"
50764,"@Test public void testBuildGraph(){
  ServiceDefinition sd1=new ServiceDefinition();
  sd1.setInterface(INTERFACE1);
  OperationDefinition op1=new OperationDefinition();
  op1.setName(OP1);
  sd1.getOperations().add(op1);
  OperationImplDefinition stod1=new OperationImplDefinition();
  op1.getImplementations().add(stod1);
  RequestResponseDefinition rrd1=new RequestResponseDefinition();
  stod1.setRequestResponse(rrd1);
  InvocationDefinition id1=new InvocationDefinition();
  id1.setInterface(INTERFACE2);
  id1.setOperation(OP2);
  rrd1.getInvocations().add(id1);
  ServiceDefinition sd2=new ServiceDefinition();
  sd2.setInterface(INTERFACE2);
  OperationDefinition op2=new OperationDefinition();
  op2.setName(OP2);
  sd2.getOperations().add(op2);
  OperationImplDefinition stod2=new OperationImplDefinition();
  op2.getImplementations().add(stod2);
  RequestResponseDefinition rrd2=new RequestResponseDefinition();
  stod2.setRequestResponse(rrd2);
  InvocationDefinition id2a=new InvocationDefinition();
  id2a.setInterface(INTERFACE1);
  id2a.setOperation(OP1);
  rrd2.getInvocations().add(id2a);
  InvocationDefinition id2c=new InvocationDefinition();
  id2c.setInterface(INTERFACE3);
  id2c.setOperation(OP3);
  rrd2.getInvocations().add(id2c);
  RequestFaultDefinition rfd2=new RequestFaultDefinition();
  stod2.getRequestFaults().add(rfd2);
  InvocationDefinition id2b=new InvocationDefinition();
  id2b.setInterface(INTERFACE3);
  id2b.setOperation(OP3);
  rfd2.getInvocations().add(id2b);
  ServiceDefinition sd3=new ServiceDefinition();
  sd3.setInterface(INTERFACE3);
  OperationDefinition op3=new OperationDefinition();
  op3.setName(OP3);
  sd3.getOperations().add(op3);
  java.util.Set<ServiceDefinition> sds=new java.util.HashSet<ServiceDefinition>();
  sds.add(sd1);
  sds.add(sd2);
  sds.add(sd3);
  java.util.List<Situation> sits=new java.util.ArrayList<Situation>();
  Situation sit1=new Situation();
  sit1.setSeverity(Situation.Severity.Critical);
  sit1.setSubject(INTERFACE1);
  sit1.setType(""String_Node_Str"");
  sit1.setDescription(""String_Node_Str"");
  sits.add(sit1);
  Situation sit2=new Situation();
  sit2.setSeverity(Situation.Severity.High);
  sit2.setSubject(INTERFACE1);
  sit2.setType(""String_Node_Str"");
  sit2.setDescription(""String_Node_Str"");
  sits.add(sit2);
  Situation sit3=new Situation();
  sit3.setSeverity(Situation.Severity.High);
  sit3.setSubject(INTERFACE2 + ""String_Node_Str"" + OP2+ ""String_Node_Str""+ SERVICE_TYPE2+ ""String_Node_Str""+ FAULT2);
  sit3.setType(""String_Node_Str"");
  sit3.setDescription(""String_Node_Str"");
  sits.add(sit3);
  ServiceGraph result=ServiceDependencyBuilder.buildGraph(sds,sits);
  if (result == null) {
    fail(""String_Node_Str"");
  }
  if (result.getServiceNodes().size() != 3) {
    fail(""String_Node_Str"" + result.getServiceNodes().size());
  }
  if (result.getUsageLinks().size() != 3) {
    fail(""String_Node_Str"" + result.getUsageLinks().size());
  }
  if (result.getInvocationLinks().size() != 3) {
    fail(""String_Node_Str"" + result.getInvocationLinks().size());
  }
  ServiceNode sn1=result.getServiceNode(INTERFACE1);
  OperationNode opn1=sn1.getOperation(OP1);
  ServiceNode sn2=result.getServiceNode(INTERFACE2);
  OperationNode opn2=sn2.getOperation(OP2);
  ServiceNode sn3=result.getServiceNode(INTERFACE3);
  OperationNode opn3=sn3.getOperation(OP3);
  if (!result.getUsageLinks().contains(new UsageLink(sn1,sn2))) {
    fail(""String_Node_Str"");
  }
  if (!result.getUsageLinks().contains(new UsageLink(sn2,sn1))) {
    fail(""String_Node_Str"");
  }
  if (!result.getUsageLinks().contains(new UsageLink(sn2,sn3))) {
    fail(""String_Node_Str"");
  }
  if (result.getUsageLinks().contains(new UsageLink(sn3,sn2))) {
    fail(""String_Node_Str"");
  }
  int idcount=0;
  for (  UsageLink ul : result.getUsageLinks()) {
    idcount+=ul.getInvocations().size();
  }
  if (idcount != 4) {
    fail(""String_Node_Str"" + idcount);
  }
  if (!result.getInvocationLinks().contains(new InvocationLink(opn1,opn2))) {
    fail(""String_Node_Str"");
  }
  if (!result.getInvocationLinks().contains(new InvocationLink(opn2,opn1))) {
    fail(""String_Node_Str"");
  }
  if (!result.getInvocationLinks().contains(new InvocationLink(opn2,opn3))) {
    fail(""String_Node_Str"");
  }
  if (result.getInvocationLinks().contains(new InvocationLink(opn3,opn2))) {
    fail(""String_Node_Str"");
  }
  idcount=0;
  for (  InvocationLink il : result.getInvocationLinks()) {
    idcount+=il.getInvocations().size();
  }
  if (idcount != 4) {
    fail(""String_Node_Str"" + idcount);
  }
  if (sn1.getSituations().size() != 2) {
    fail(""String_Node_Str"" + sn1.getSituations().size());
  }
  if (!sn1.getSituations().contains(sit1)) {
    fail(""String_Node_Str"");
  }
  if (!sn1.getSituations().contains(sit2)) {
    fail(""String_Node_Str"");
  }
  if (opn2.getSituations().size() != 1) {
    fail(""String_Node_Str"" + opn2.getSituations().size());
  }
  if (opn2.getSituations().get(0) != sit3) {
    fail(""String_Node_Str"");
  }
}","@Test public void testBuildGraph(){
  ServiceDefinition sd1=new ServiceDefinition();
  sd1.setInterface(INTERFACE1);
  OperationDefinition op1=new OperationDefinition();
  op1.setName(OP1);
  sd1.getOperations().add(op1);
  OperationImplDefinition stod1=new OperationImplDefinition();
  op1.getImplementations().add(stod1);
  RequestResponseDefinition rrd1=new RequestResponseDefinition();
  stod1.setRequestResponse(rrd1);
  InvocationDefinition id1=new InvocationDefinition();
  id1.setInterface(INTERFACE2);
  id1.setOperation(OP2);
  rrd1.getInvocations().add(id1);
  ServiceDefinition sd2=new ServiceDefinition();
  sd2.setInterface(INTERFACE2);
  OperationDefinition op2=new OperationDefinition();
  op2.setName(OP2);
  sd2.getOperations().add(op2);
  OperationImplDefinition stod2=new OperationImplDefinition();
  op2.getImplementations().add(stod2);
  RequestResponseDefinition rrd2=new RequestResponseDefinition();
  stod2.setRequestResponse(rrd2);
  InvocationDefinition id2a=new InvocationDefinition();
  id2a.setInterface(INTERFACE1);
  id2a.setOperation(OP1);
  rrd2.getInvocations().add(id2a);
  InvocationDefinition id2c=new InvocationDefinition();
  id2c.setInterface(INTERFACE3);
  id2c.setOperation(OP3);
  rrd2.getInvocations().add(id2c);
  RequestFaultDefinition rfd2=new RequestFaultDefinition();
  stod2.getRequestFaults().add(rfd2);
  InvocationDefinition id2b=new InvocationDefinition();
  id2b.setInterface(INTERFACE3);
  id2b.setOperation(OP3);
  rfd2.getInvocations().add(id2b);
  ServiceDefinition sd3=new ServiceDefinition();
  sd3.setInterface(INTERFACE3);
  OperationDefinition op3=new OperationDefinition();
  op3.setName(OP3);
  sd3.getOperations().add(op3);
  java.util.Set<ServiceDefinition> sds=new java.util.HashSet<ServiceDefinition>();
  sds.add(sd1);
  sds.add(sd2);
  sds.add(sd3);
  java.util.List<Situation> sits=new java.util.ArrayList<Situation>();
  Situation sit1=new Situation();
  sit1.setSeverity(Situation.Severity.Critical);
  sit1.setSubject(Situation.createSubject(INTERFACE1));
  sit1.setType(""String_Node_Str"");
  sit1.setDescription(""String_Node_Str"");
  sits.add(sit1);
  Situation sit2=new Situation();
  sit2.setSeverity(Situation.Severity.High);
  sit2.setSubject(Situation.createSubject(INTERFACE1));
  sit2.setType(""String_Node_Str"");
  sit2.setDescription(""String_Node_Str"");
  sits.add(sit2);
  Situation sit3=new Situation();
  sit3.setSeverity(Situation.Severity.High);
  sit3.setSubject(Situation.createSubject(INTERFACE2,OP2,SERVICE_TYPE2,FAULT2));
  sit3.setType(""String_Node_Str"");
  sit3.setDescription(""String_Node_Str"");
  sits.add(sit3);
  ServiceGraph result=ServiceDependencyBuilder.buildGraph(sds,sits);
  if (result == null) {
    fail(""String_Node_Str"");
  }
  if (result.getServiceNodes().size() != 3) {
    fail(""String_Node_Str"" + result.getServiceNodes().size());
  }
  if (result.getUsageLinks().size() != 3) {
    fail(""String_Node_Str"" + result.getUsageLinks().size());
  }
  if (result.getInvocationLinks().size() != 3) {
    fail(""String_Node_Str"" + result.getInvocationLinks().size());
  }
  ServiceNode sn1=result.getServiceNode(INTERFACE1);
  OperationNode opn1=sn1.getOperation(OP1);
  ServiceNode sn2=result.getServiceNode(INTERFACE2);
  OperationNode opn2=sn2.getOperation(OP2);
  ServiceNode sn3=result.getServiceNode(INTERFACE3);
  OperationNode opn3=sn3.getOperation(OP3);
  if (!result.getUsageLinks().contains(new UsageLink(sn1,sn2))) {
    fail(""String_Node_Str"");
  }
  if (!result.getUsageLinks().contains(new UsageLink(sn2,sn1))) {
    fail(""String_Node_Str"");
  }
  if (!result.getUsageLinks().contains(new UsageLink(sn2,sn3))) {
    fail(""String_Node_Str"");
  }
  if (result.getUsageLinks().contains(new UsageLink(sn3,sn2))) {
    fail(""String_Node_Str"");
  }
  int idcount=0;
  for (  UsageLink ul : result.getUsageLinks()) {
    idcount+=ul.getInvocations().size();
  }
  if (idcount != 4) {
    fail(""String_Node_Str"" + idcount);
  }
  if (!result.getInvocationLinks().contains(new InvocationLink(opn1,opn2))) {
    fail(""String_Node_Str"");
  }
  if (!result.getInvocationLinks().contains(new InvocationLink(opn2,opn1))) {
    fail(""String_Node_Str"");
  }
  if (!result.getInvocationLinks().contains(new InvocationLink(opn2,opn3))) {
    fail(""String_Node_Str"");
  }
  if (result.getInvocationLinks().contains(new InvocationLink(opn3,opn2))) {
    fail(""String_Node_Str"");
  }
  idcount=0;
  for (  InvocationLink il : result.getInvocationLinks()) {
    idcount+=il.getInvocations().size();
  }
  if (idcount != 4) {
    fail(""String_Node_Str"" + idcount);
  }
  if (sn1.getSituations().size() != 2) {
    fail(""String_Node_Str"" + sn1.getSituations().size());
  }
  if (!sn1.getSituations().contains(sit1)) {
    fail(""String_Node_Str"");
  }
  if (!sn1.getSituations().contains(sit2)) {
    fail(""String_Node_Str"");
  }
  if (sn2.getSituations().size() != 0) {
    fail(""String_Node_Str"" + sn2.getSituations().size());
  }
  if (opn2.getSituations().size() != 1) {
    fail(""String_Node_Str"" + opn2.getSituations().size());
  }
  if (opn2.getSituations().get(0) != sit3) {
    fail(""String_Node_Str"");
  }
}"
50765,"@Test public void testPurchasingResponseTime(){
  CEPEventProcessor ep=new CEPEventProcessor();
  ep.setRuleName(""String_Node_Str"");
  ActivityUnit e1=new ActivityUnit();
  e1.setId(""String_Node_Str"");
  RequestReceived me1=new RequestReceived();
  me1.setTimestamp(System.currentTimeMillis());
  me1.setMessageId(""String_Node_Str"");
  e1.getActivityTypes().add(me1);
  ActivityUnit e2=new ActivityUnit();
  e2.setId(""String_Node_Str"");
  ResponseSent me2=new ResponseSent();
  me2.setMessageId(""String_Node_Str"");
  me2.setReplyToId(""String_Node_Str"");
  e2.getActivityTypes().add(me2);
  ActivityUnit e3=new ActivityUnit();
  e3.setId(""String_Node_Str"");
  ResponseSent me3=new ResponseSent();
  me3.setTimestamp(me1.getTimestamp() + TIME_INTERVAL);
  me3.setMessageId(""String_Node_Str"");
  me3.setReplyToId(""String_Node_Str"");
  e3.getActivityTypes().add(me3);
  try {
    ep.init();
    java.util.Properties props1=(java.util.Properties)ep.process(""String_Node_Str"",me1,0);
    if (props1 != null) {
      fail(""String_Node_Str"");
    }
    java.util.Properties props2=(java.util.Properties)ep.process(""String_Node_Str"",me2,0);
    if (props2 != null) {
      fail(""String_Node_Str"");
    }
    java.util.Properties props3=(java.util.Properties)ep.process(""String_Node_Str"",me3,0);
    if (props3 == null) {
      fail(""String_Node_Str"");
    }
    String reqId=(String)props3.get(""String_Node_Str"");
    String respId=(String)props3.get(""String_Node_Str"");
    if (!reqId.equals(me1.getMessageId())) {
      fail(""String_Node_Str"");
    }
    if (!respId.equals(me3.getMessageId())) {
      fail(""String_Node_Str"");
    }
    if (!props3.containsKey(""String_Node_Str"")) {
      fail(""String_Node_Str"");
    }
    long responseTime=(Long)props3.get(""String_Node_Str"");
    if ((responseTime - TIME_INTERVAL) > 1 || (responseTime - TIME_INTERVAL) < 0) {
      fail(""String_Node_Str"" + TIME_INTERVAL + ""String_Node_Str""+ responseTime);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + e);
  }
}","@Test public void testPurchasingResponseTime(){
  CEPEventProcessor ep=new CEPEventProcessor();
  ep.setRuleName(""String_Node_Str"");
  ActivityUnit e1=new ActivityUnit();
  e1.setId(""String_Node_Str"");
  RequestReceived me1=new RequestReceived();
  me1.setTimestamp(System.currentTimeMillis());
  me1.setMessageId(""String_Node_Str"");
  e1.getActivityTypes().add(me1);
  ActivityUnit e2=new ActivityUnit();
  e2.setId(""String_Node_Str"");
  ResponseSent me2=new ResponseSent();
  me2.setMessageId(""String_Node_Str"");
  me2.setReplyToId(""String_Node_Str"");
  e2.getActivityTypes().add(me2);
  ActivityUnit e3=new ActivityUnit();
  e3.setId(""String_Node_Str"");
  ResponseSent me3=new ResponseSent();
  me3.setTimestamp(me1.getTimestamp() + TIME_INTERVAL);
  me3.setMessageId(""String_Node_Str"");
  me3.setReplyToId(""String_Node_Str"");
  e3.getActivityTypes().add(me3);
  try {
    ep.init();
    java.util.Properties props1=(java.util.Properties)ep.process(""String_Node_Str"",me1,0);
    if (props1 != null) {
      fail(""String_Node_Str"");
    }
    java.util.Properties props2=(java.util.Properties)ep.process(""String_Node_Str"",me2,0);
    if (props2 != null) {
      fail(""String_Node_Str"");
    }
    java.util.Properties props3=(java.util.Properties)ep.process(""String_Node_Str"",me3,0);
    if (props3 == null) {
      fail(""String_Node_Str"");
    }
    String reqId=(String)props3.get(""String_Node_Str"");
    String respId=(String)props3.get(""String_Node_Str"");
    if (!reqId.equals(me1.getMessageId())) {
      fail(""String_Node_Str"");
    }
    if (!respId.equals(me3.getMessageId())) {
      fail(""String_Node_Str"");
    }
    if (!props3.containsKey(""String_Node_Str"")) {
      fail(""String_Node_Str"");
    }
    long responseTime=(Long)props3.get(""String_Node_Str"");
    if (responseTime != TIME_INTERVAL) {
      fail(""String_Node_Str"" + TIME_INTERVAL + ""String_Node_Str""+ responseTime);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + e);
  }
}"
50766,"@Test public void testPurchasingResponseTimeOutOfOrder(){
  CEPEventProcessor ep=new CEPEventProcessor();
  ep.setRuleName(""String_Node_Str"");
  ActivityUnit e4=new ActivityUnit();
  e4.setId(""String_Node_Str"");
  RequestReceived me4=new RequestReceived();
  me4.setTimestamp(System.currentTimeMillis() + GAP_INTERVAL);
  me4.setMessageId(""String_Node_Str"");
  e4.getActivityTypes().add(me4);
  ActivityUnit e5=new ActivityUnit();
  e5.setId(""String_Node_Str"");
  ResponseSent me5=new ResponseSent();
  me5.setTimestamp(System.currentTimeMillis() + GAP_INTERVAL + TIME_INTERVAL);
  me5.setMessageId(""String_Node_Str"");
  me5.setReplyToId(""String_Node_Str"");
  e5.getActivityTypes().add(me5);
  try {
    ep.init();
    java.util.Properties props3=(java.util.Properties)ep.process(""String_Node_Str"",me5,0);
    if (props3 != null) {
      fail(""String_Node_Str"");
    }
    java.util.Properties props1=(java.util.Properties)ep.process(""String_Node_Str"",me4,0);
    if (props1 == null) {
      fail(""String_Node_Str"");
    }
    String reqId=(String)props1.get(""String_Node_Str"");
    String respId=(String)props1.get(""String_Node_Str"");
    if (!reqId.equals(me4.getMessageId())) {
      fail(""String_Node_Str"");
    }
    if (!respId.equals(me5.getMessageId())) {
      fail(""String_Node_Str"");
    }
    if (!props1.containsKey(""String_Node_Str"")) {
      fail(""String_Node_Str"");
    }
    long responseTime=(Long)props1.get(""String_Node_Str"");
    if ((responseTime - TIME_INTERVAL) > 1 || (responseTime - TIME_INTERVAL) < 0) {
      fail(""String_Node_Str"" + TIME_INTERVAL + ""String_Node_Str""+ responseTime);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + e);
  }
}","@Test public void testPurchasingResponseTimeOutOfOrder(){
  CEPEventProcessor ep=new CEPEventProcessor();
  ep.setRuleName(""String_Node_Str"");
  ActivityUnit e4=new ActivityUnit();
  e4.setId(""String_Node_Str"");
  RequestReceived me4=new RequestReceived();
  me4.setTimestamp(System.currentTimeMillis() + GAP_INTERVAL);
  me4.setMessageId(""String_Node_Str"");
  e4.getActivityTypes().add(me4);
  ActivityUnit e5=new ActivityUnit();
  e5.setId(""String_Node_Str"");
  ResponseSent me5=new ResponseSent();
  me5.setTimestamp(me4.getTimestamp() + TIME_INTERVAL);
  me5.setMessageId(""String_Node_Str"");
  me5.setReplyToId(""String_Node_Str"");
  e5.getActivityTypes().add(me5);
  try {
    ep.init();
    java.util.Properties props3=(java.util.Properties)ep.process(""String_Node_Str"",me5,0);
    if (props3 != null) {
      fail(""String_Node_Str"");
    }
    java.util.Properties props1=(java.util.Properties)ep.process(""String_Node_Str"",me4,0);
    if (props1 == null) {
      fail(""String_Node_Str"");
    }
    String reqId=(String)props1.get(""String_Node_Str"");
    String respId=(String)props1.get(""String_Node_Str"");
    if (!reqId.equals(me4.getMessageId())) {
      fail(""String_Node_Str"");
    }
    if (!respId.equals(me5.getMessageId())) {
      fail(""String_Node_Str"");
    }
    if (!props1.containsKey(""String_Node_Str"")) {
      fail(""String_Node_Str"");
    }
    long responseTime=(Long)props1.get(""String_Node_Str"");
    if (responseTime != TIME_INTERVAL) {
      fail(""String_Node_Str"" + TIME_INTERVAL + ""String_Node_Str""+ responseTime);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + e);
  }
}"
50767,"/** 
 * This method handles queries.
 * @param width The optional width
 * @return The list of objects
 * @throws Exception Failed to query
 */
@GET @Path(""String_Node_Str"") @Produces(""String_Node_Str"") public String instance(@QueryParam(""String_Node_Str"") String identifier) throws Exception {
  String ret=""String_Node_Str"";
  CallTrace ct=getCallTrace(identifier);
  if (ct != null) {
    byte[] b=CallTraceUtil.serializeCallTrace(ct);
    if (b != null) {
      ret=new String(b);
    }
  }
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + ret);
  }
  return (ret);
}","/** 
 * This method returns the call trace for the specified identifier.
 * @param identifier The identifier
 * @return The call trace for the identifier
 * @throws Exception Failed to obtain call trace
 */
@GET @Path(""String_Node_Str"") @Produces(""String_Node_Str"") public String instance(@QueryParam(""String_Node_Str"") String identifier) throws Exception {
  String ret=""String_Node_Str"";
  CallTrace ct=getCallTrace(identifier);
  if (ct != null) {
    byte[] b=CallTraceUtil.serializeCallTrace(ct);
    if (b != null) {
      ret=new String(b);
    }
  }
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + ret);
  }
  return (ret);
}"
50768,"/** 
 * {@inheritDoc}
 */
public InfinispanActiveMap(String name,Map<Object,Object> map,long itemExpiration,int maxItems,int highWaterMark){
  super(name,map,itemExpiration,maxItems,highWaterMark);
  if (map instanceof Cache) {
    Cache<Object,Object> cache=(Cache<Object,Object>)map;
    cache.addListener(_listener);
  }
}","/** 
 * This constructor initializes the active map.
 * @param name The name
 * @param map The map
 * @param itemExpiration Item expiration time, or 0 if not relevant
 * @param maxItems Max number of items, or 0 if not relevant
 * @param highWaterMark Generate warning if number of items exceed high water mark
 */
public InfinispanActiveMap(String name,Map<Object,Object> map,long itemExpiration,int maxItems,int highWaterMark){
  super(name,map,itemExpiration,maxItems,highWaterMark);
  if (map instanceof Cache) {
    Cache<Object,Object> cache=(Cache<Object,Object>)map;
    cache.addListener(_listener);
  }
}"
50769,"/** 
 * This method identifies whether processing should be postponed  based on the current activity type.
 * @param state The state
 * @param au The activity unit
 * @param topLevel The top level units
 * @param cur The current activity type
 * @return Whether the processing of this unit should be postponed
 */
protected static boolean shouldPostpone(CTState state,ActivityUnit au,java.util.List<ActivityUnit> topLevel,ActivityType cur){
  boolean ret=false;
  Call call=(state.getCallStack().size() > 0 ? state.getCallStack().peek() : null);
  if (cur instanceof RequestReceived && call == null && !topLevel.contains(au)) {
    if (LOG.isLoggable(Level.FINEST)) {
      LOG.finest(""String_Node_Str"");
    }
    ret=true;
  }
  return (ret);
}","/** 
 * This method identifies whether processing should be postponed  based on the current activity type.
 * @param state The state
 * @param au The activity unit
 * @param topLevel The top level units
 * @param cur The current activity type
 * @return Whether the processing of this unit should be postponed
 */
protected static boolean shouldPostpone(CTState state,ActivityUnit au,java.util.List<ActivityUnit> topLevel,ActivityType cur){
  boolean ret=false;
  Call call=(state.getCallStack().size() > 0 ? state.getCallStack().peek() : null);
  if (cur instanceof RequestReceived && call == null && !topLevel.contains(au)) {
    if (LOG.isLoggable(Level.FINEST)) {
      LOG.finest(""String_Node_Str"");
    }
    ret=true;
  }
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + au + ""String_Node_Str""+ cur+ ""String_Node_Str""+ ret);
  }
  return (ret);
}"
50770,"/** 
 * This method processes the supplied activity unit to create a set of trace nodes.
 * @param state The state
 * @param startau The activity unit being processed
 * @param toplevel The top level activity units
 */
protected static void processAU(CTState state,ActivityUnit startau,java.util.List<ActivityUnit> topLevel){
  ActivityType cur=null;
  Call call=(state.getCallStack().size() > 0 ? state.getCallStack().peek() : null);
  java.util.List<TraceNode> tasks=state.getTasksStack().peek();
  ActivityType prev=null;
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + startau);
  }
  java.util.List<ActivityUnit> aus=state.getActivityUnits();
  int aupos=aus.indexOf(startau);
  if (aupos == -1) {
    LOG.severe(""String_Node_Str"" + startau);
    return;
  }
  boolean f_end=false;
  boolean f_scopeFinalized=false;
  for (int i=aupos; !f_end && i < aus.size(); i++) {
    ActivityUnit au=aus.get(i);
    if (i != aupos && topLevel.contains(au)) {
      continue;
    }
    if (LOG.isLoggable(Level.FINEST)) {
      LOG.finest(""String_Node_Str"" + aus.get(i));
    }
    ActivityUnitCursor cursor=state.getCursor(au);
    while ((cur=cursor.next()) != null) {
      if (LOG.isLoggable(Level.FINEST)) {
        LOG.finest(""String_Node_Str"" + cur);
      }
      if (shouldPostpone(state,au,topLevel,cur)) {
        if (LOG.isLoggable(Level.FINEST)) {
          LOG.finest(""String_Node_Str"" + au + ""String_Node_Str""+ cur);
        }
        break;
      }
      if (cur instanceof RPCActivityType) {
        if (cur instanceof RequestSent || (cur instanceof RequestReceived && call == null)) {
          call=createCall((RPCActivityType)cur);
          if (LOG.isLoggable(Level.FINEST)) {
            LOG.finest(""String_Node_Str"" + call);
          }
          tasks.add(call);
          tasks=call.getTasks();
          if (LOG.isLoggable(Level.FINEST)) {
            LOG.finest(""String_Node_Str"" + call);
            LOG.finest(""String_Node_Str"" + tasks);
          }
          state.getCallStack().push(call);
          state.getTasksStack().push(tasks);
          state.getTriggerActivities().put(call,(RPCActivityType)cur);
        }
        if (cur instanceof RequestSent) {
          RPCActivityType rr=state.getSOAActivity(RequestReceived.class,((RequestSent)cur).getServiceType(),((RequestSent)cur).getOperation());
          if (rr != null) {
            call.setRequestLatency(rr.getTimestamp() - cur.getTimestamp());
            ActivityUnit subAU=state.getActivityUnit(rr.getUnitId());
            if (subAU != null) {
              processAU(state,subAU,topLevel);
              call=state.getCallStack().peek();
              tasks=state.getTasksStack().peek();
            }
          }
        }
 else         if (cur instanceof RequestReceived) {
          call.setRequest(((RequestReceived)cur).getContent());
        }
 else         if (cur instanceof ResponseSent) {
          ResponseSent rs=(ResponseSent)cur;
          call.setResponse(rs.getContent());
          call.getProperties().putAll(cur.getProperties());
          RPCActivityType rr=state.getSOAActivity(ResponseReceived.class,rs.getServiceType(),rs.getOperation());
          if (rr != null) {
            call.setResponseLatency(rr.getTimestamp() - rs.getTimestamp());
          }
          if (state.getTriggerActivities().get(call) instanceof RequestReceived) {
            call.setDuration(cur.getTimestamp() - state.getTriggerActivities().get(call).getTimestamp());
          }
          if (rs.getFault() != null && rs.getFault().trim().length() > 0) {
            call.setFault(rs.getFault());
            call.setStatus(Status.Fail);
          }
          state.finalizeScope();
          f_scopeFinalized=true;
          call=(state.getCallStack().size() > 0 ? state.getCallStack().peek() : null);
          tasks=state.getTasksStack().peek();
          if (state.getCallStack().size() > 0) {
            if (LOG.isLoggable(Level.FINEST)) {
              LOG.finest(""String_Node_Str"");
            }
            f_end=true;
            break;
          }
        }
 else         if (cur instanceof ResponseReceived) {
          ResponseReceived rr=(ResponseReceived)cur;
          for (int j=state.getCompletedCallStack().size() - 1; j >= 0; j--) {
            Call c=state.getCompletedCallStack().get(j);
            if (state.getTriggerActivities().get(c) instanceof RequestSent) {
              RequestSent rs=(RequestSent)state.getTriggerActivities().get(c);
              if (rs.getOperation().equals(rr.getOperation()) && rs.getServiceType().equals(rr.getServiceType())) {
                c.setDuration(rr.getTimestamp() - rs.getTimestamp());
                break;
              }
            }
          }
          f_end=true;
        }
      }
 else {
        Task task=createTask(cur);
        tasks.add(task);
        if (prev != null) {
          task.setDuration(cur.getTimestamp() - prev.getTimestamp());
        }
      }
      prev=cur;
    }
  }
  if (!f_scopeFinalized) {
    state.finalizeScope();
  }
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + startau);
  }
}","/** 
 * This method processes the supplied activity unit to create a set of trace nodes.
 * @param state The state
 * @param startau The activity unit being processed
 * @param topLevel The top level activity units
 */
protected static void processAU(CTState state,ActivityUnit startau,java.util.List<ActivityUnit> topLevel){
  ActivityType cur=null;
  Call call=(state.getCallStack().size() > 0 ? state.getCallStack().peek() : null);
  java.util.List<TraceNode> tasks=state.getTasksStack().peek();
  ActivityType prev=null;
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + startau);
  }
  java.util.List<ActivityUnit> aus=state.getActivityUnits();
  int aupos=aus.indexOf(startau);
  if (aupos == -1) {
    LOG.severe(""String_Node_Str"" + startau);
    return;
  }
  boolean f_end=false;
  boolean f_scopeFinalized=false;
  for (int i=aupos; !f_end && i < aus.size(); i++) {
    ActivityUnit au=aus.get(i);
    if (i != aupos && topLevel.contains(au)) {
      continue;
    }
    if (LOG.isLoggable(Level.FINEST)) {
      LOG.finest(""String_Node_Str"" + aus.get(i));
    }
    ActivityUnitCursor cursor=state.getCursor(au);
    while ((cur=cursor.next()) != null) {
      if (LOG.isLoggable(Level.FINEST)) {
        LOG.finest(""String_Node_Str"" + cur);
      }
      if (shouldPostpone(state,au,topLevel,cur)) {
        break;
      }
      if (cur instanceof RPCActivityType) {
        if (cur instanceof RequestSent || (cur instanceof RequestReceived && call == null)) {
          call=createCall((RPCActivityType)cur);
          tasks.add(call);
          tasks=call.getTasks();
          if (LOG.isLoggable(Level.FINEST)) {
            LOG.finest(""String_Node_Str"" + call);
            LOG.finest(""String_Node_Str"" + tasks);
          }
          state.getCallStack().push(call);
          state.getTasksStack().push(tasks);
          state.getTriggerActivities().put(call,(RPCActivityType)cur);
        }
        if (cur instanceof RequestSent) {
          RPCActivityType rr=state.getSOAActivity(RequestReceived.class,((RequestSent)cur).getServiceType(),((RequestSent)cur).getOperation());
          if (rr != null) {
            call.setRequestLatency(rr.getTimestamp() - cur.getTimestamp());
            ActivityUnit subAU=state.getActivityUnit(rr.getUnitId());
            if (subAU != null) {
              processAU(state,subAU,topLevel);
              call=state.getCallStack().peek();
              tasks=state.getTasksStack().peek();
            }
          }
        }
 else         if (cur instanceof RequestReceived) {
          call.setRequest(((RequestReceived)cur).getContent());
        }
 else         if (cur instanceof ResponseSent) {
          initializeResponseSent(state,(ResponseSent)cur,call);
          state.finalizeScope();
          f_scopeFinalized=true;
          call=(state.getCallStack().size() > 0 ? state.getCallStack().peek() : null);
          tasks=state.getTasksStack().peek();
          if (state.getCallStack().size() > 0) {
            if (LOG.isLoggable(Level.FINEST)) {
              LOG.finest(""String_Node_Str"");
            }
            f_end=true;
            break;
          }
        }
 else         if (cur instanceof ResponseReceived) {
          initializeResponseReceived(state,(ResponseReceived)cur);
          f_end=true;
        }
      }
 else {
        Task task=createTask(cur);
        tasks.add(task);
        if (prev != null) {
          task.setDuration(cur.getTimestamp() - prev.getTimestamp());
        }
      }
      prev=cur;
    }
  }
  if (!f_scopeFinalized) {
    state.finalizeScope();
  }
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + startau);
  }
}"
50771,"/** 
 * This method returns a call node associated with the supplied activity event.
 * @param at The activity event
 * @return The Call node
 */
protected static Call createCall(RPCActivityType at){
  Call call=new Call();
  call.setComponent(at.getServiceType());
  call.setOperation(at.getOperation());
  call.getProperties().putAll(at.getProperties());
  return (call);
}","/** 
 * This method returns a call node associated with the supplied activity event.
 * @param at The activity event
 * @return The Call node
 */
protected static Call createCall(RPCActivityType at){
  Call call=new Call();
  call.setComponent(at.getServiceType());
  call.setOperation(at.getOperation());
  call.getProperties().putAll(at.getProperties());
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + call);
  }
  return (call);
}"
50772,"/** 
 * This method deserializes a call trace from a JSON representation.
 * @param act The JSON representation of the call trace
 * @return The call trace
 * @throws Exception Failed to deserialize
 */
public static CallTrace deserializeCallTrace(byte[] node) throws Exception {
  CallTrace ret=null;
  java.io.ByteArrayInputStream bais=new java.io.ByteArrayInputStream(node);
  ret=MAPPER.readValue(bais,CallTrace.class);
  bais.close();
  return (ret);
}","/** 
 * This method deserializes a call trace from a JSON representation.
 * @param node The JSON representation of the call trace
 * @return The call trace
 * @throws Exception Failed to deserialize
 */
public static CallTrace deserializeCallTrace(byte[] node) throws Exception {
  CallTrace ret=null;
  java.io.ByteArrayInputStream bais=new java.io.ByteArrayInputStream(node);
  ret=MAPPER.readValue(bais,CallTrace.class);
  bais.close();
  return (ret);
}"
50773,"@GET @Path(""String_Node_Str"") @Produces(""String_Node_Str"") public String getActivityTypes(@QueryParam(""String_Node_Str"") String context) throws Exception {
  String ret=""String_Node_Str"";
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + context);
  }
  if (_activityServer == null) {
    throw new Exception(""String_Node_Str"");
  }
  java.util.List<ActivityType> list=_activityServer.getActivityTypes(context);
  if (list != null) {
    byte[] b=ActivityUtil.serializeActivityTypeList(list);
    ret=new String(b);
  }
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + ret);
  }
  return (ret);
}","/** 
 * This method returns activity types (events) associated with the supplied context value.
 * @param context The context
 * @return The list of activity types
 * @throws Exception Failed to obtain activity types
 */
@GET @Path(""String_Node_Str"") @Produces(""String_Node_Str"") public String getActivityTypes(@QueryParam(""String_Node_Str"") String context) throws Exception {
  String ret=""String_Node_Str"";
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + context);
  }
  if (_activityServer == null) {
    throw new Exception(""String_Node_Str"");
  }
  java.util.List<ActivityType> list=_activityServer.getActivityTypes(context);
  if (list != null) {
    byte[] b=ActivityUtil.serializeActivityTypeList(list);
    ret=new String(b);
  }
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + ret);
  }
  return (ret);
}"
50774,"/** 
 * This method handles queries for activity events.
 * @param qspec The query spec
 * @return The list of activity events
 * @throws Exception Failed to query activity events
 */
@GET @Path(""String_Node_Str"") @Produces(""String_Node_Str"") public String getActivityUnit(@QueryParam(""String_Node_Str"") String id) throws Exception {
  String ret=""String_Node_Str"";
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + id);
  }
  if (_activityServer == null) {
    throw new Exception(""String_Node_Str"");
  }
  ActivityUnit au=_activityServer.getActivityUnit(id);
  if (au != null) {
    byte[] b=ActivityUtil.serializeActivityUnit(au);
    ret=new String(b);
  }
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + ret);
  }
  return (ret);
}","/** 
 * This method handles queries for activity events.
 * @param id The id
 * @return The list of activity events
 * @throws Exception Failed to query activity events
 */
@GET @Path(""String_Node_Str"") @Produces(""String_Node_Str"") public String getActivityUnit(@QueryParam(""String_Node_Str"") String id) throws Exception {
  String ret=""String_Node_Str"";
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + id);
  }
  if (_activityServer == null) {
    throw new Exception(""String_Node_Str"");
  }
  ActivityUnit au=_activityServer.getActivityUnit(id);
  if (au != null) {
    byte[] b=ActivityUtil.serializeActivityUnit(au);
    ret=new String(b);
  }
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + ret);
  }
  return (ret);
}"
50775,"/** 
 * This method handles queries.
 * @param qspec The query spec
 * @return The list of objects
 * @throws Exception Failed to query
 */
@GET @Path(""String_Node_Str"") @Produces(""String_Node_Str"") public String overview(@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") int width) throws Exception {
  String ret=""String_Node_Str"";
  if (_acmManager != null && _servDefns == null) {
    _servDefns=_acmManager.getActiveCollection(""String_Node_Str"");
  }
  if (_acmManager != null && _situations == null) {
    _situations=_acmManager.getActiveCollection(""String_Node_Str"");
  }
  if (_servDefns == null) {
    throw new Exception(""String_Node_Str"");
  }
  if (_situations == null) {
    throw new Exception(""String_Node_Str"");
  }
  java.util.Set<ServiceDefinition> sds=new java.util.HashSet<ServiceDefinition>();
  for (  Object entry : _servDefns) {
    if (entry instanceof ActiveMap.Entry && ((ActiveMap.Entry)entry).getValue() instanceof ServiceDefinition) {
      sds.add((ServiceDefinition)((ActiveMap.Entry)entry).getValue());
    }
  }
  java.util.List<Situation> situations=new java.util.ArrayList<Situation>();
  for (  Object obj : _situations) {
    if (obj instanceof Situation) {
      situations.add((Situation)obj);
    }
  }
  ServiceGraph graph=ServiceDependencyBuilder.buildGraph(sds,situations);
  if (graph == null) {
    throw new Exception(""String_Node_Str"");
  }
  graph.setDescription(""String_Node_Str"" + new java.util.Date());
  ServiceGraphLayoutImpl layout=new ServiceGraphLayoutImpl();
  layout.layout(graph);
  SVGServiceGraphGenerator generator=new SVGServiceGraphGenerator();
  MVELColorSelector selector=new MVELColorSelector();
  selector.setScriptLocation(""String_Node_Str"");
  try {
    selector.init();
    generator.setColorSelector(selector);
  }
 catch (  Exception e) {
    LOG.log(Level.SEVERE,""String_Node_Str"",e);
  }
  java.io.ByteArrayOutputStream os=new java.io.ByteArrayOutputStream();
  generator.generate(graph,width,os);
  os.close();
  ret=new String(os.toByteArray());
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + ret);
  }
  return (ret);
}","/** 
 * This method handles queries.
 * @param width The optional width
 * @return The list of objects
 * @throws Exception Failed to query
 */
@GET @Path(""String_Node_Str"") @Produces(""String_Node_Str"") public String overview(@DefaultValue(""String_Node_Str"") @QueryParam(""String_Node_Str"") int width) throws Exception {
  String ret=""String_Node_Str"";
  if (_acmManager != null && _servDefns == null) {
    _servDefns=_acmManager.getActiveCollection(""String_Node_Str"");
  }
  if (_acmManager != null && _situations == null) {
    _situations=_acmManager.getActiveCollection(""String_Node_Str"");
  }
  if (_servDefns == null) {
    throw new Exception(""String_Node_Str"");
  }
  if (_situations == null) {
    throw new Exception(""String_Node_Str"");
  }
  java.util.Set<ServiceDefinition> sds=new java.util.HashSet<ServiceDefinition>();
  for (  Object entry : _servDefns) {
    if (entry instanceof ActiveMap.Entry && ((ActiveMap.Entry)entry).getValue() instanceof ServiceDefinition) {
      sds.add((ServiceDefinition)((ActiveMap.Entry)entry).getValue());
    }
  }
  java.util.List<Situation> situations=new java.util.ArrayList<Situation>();
  for (  Object obj : _situations) {
    if (obj instanceof Situation) {
      situations.add((Situation)obj);
    }
  }
  ServiceGraph graph=ServiceDependencyBuilder.buildGraph(sds,situations);
  if (graph == null) {
    throw new Exception(""String_Node_Str"");
  }
  graph.setDescription(""String_Node_Str"" + new java.util.Date());
  ServiceGraphLayoutImpl layout=new ServiceGraphLayoutImpl();
  layout.layout(graph);
  SVGServiceGraphGenerator generator=new SVGServiceGraphGenerator();
  MVELColorSelector selector=new MVELColorSelector();
  selector.setScriptLocation(""String_Node_Str"");
  try {
    selector.init();
    generator.setColorSelector(selector);
  }
 catch (  Exception e) {
    LOG.log(Level.SEVERE,""String_Node_Str"",e);
  }
  java.io.ByteArrayOutputStream os=new java.io.ByteArrayOutputStream();
  generator.generate(graph,width,os);
  os.close();
  ret=new String(os.toByteArray());
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + ret);
  }
  return (ret);
}"
50776,"/** 
 * Copy constructor.
 */
public InvocationDefinition(InvocationDefinition id){
  _serviceType=id.getServiceType();
  _operation=id.getOperation();
  _fault=id.getFault();
  if (id.getMetrics() != null) {
    _metrics=new InvocationMetric(id.getMetrics());
  }
}","/** 
 * Copy constructor.
 * @param id The invocation definition to copy
 */
public InvocationDefinition(InvocationDefinition id){
  _serviceType=id.getServiceType();
  _operation=id.getOperation();
  _fault=id.getFault();
  if (id.getMetrics() != null) {
    _metrics=new InvocationMetric(id.getMetrics());
  }
}"
50777,"/** 
 * Copy constructor.
 */
public MEPDefinition(MEPDefinition md){
  for (  InvocationDefinition id : md.getInvocations()) {
    _invocations.add(new InvocationDefinition(id));
  }
  if (md.getMetrics() != null) {
    _metrics=new InvocationMetric(md.getMetrics());
  }
}","/** 
 * Copy constructor.
 * @param md The source to copy
 */
public MEPDefinition(MEPDefinition md){
  for (  InvocationDefinition id : md.getInvocations()) {
    _invocations.add(new InvocationDefinition(id));
  }
  if (md.getMetrics() != null) {
    _metrics=new InvocationMetric(md.getMetrics());
  }
}"
50778,"/** 
 * Copy constructor.
 */
public OperationDefinition(OperationDefinition od){
  _name=od.getName();
  if (od.getRequestResponse() != null) {
    _requestResponse=new RequestResponseDefinition(od.getRequestResponse());
  }
  for (  RequestFaultDefinition rfd : od.getRequestFaults()) {
    _requestFaults.add(new RequestFaultDefinition(rfd));
  }
}","/** 
 * Copy constructor.
 * @param od The source to copy
 */
public OperationDefinition(OperationDefinition od){
  _name=od.getName();
  if (od.getRequestResponse() != null) {
    _requestResponse=new RequestResponseDefinition(od.getRequestResponse());
  }
  for (  RequestFaultDefinition rfd : od.getRequestFaults()) {
    _requestFaults.add(new RequestFaultDefinition(rfd));
  }
}"
50779,"/** 
 * Copy constructor.
 */
public RequestFaultDefinition(RequestFaultDefinition rfd){
  super(rfd);
  _fault=rfd.getFault();
}","/** 
 * Copy constructor.
 * @param rfd The source to copy
 */
public RequestFaultDefinition(RequestFaultDefinition rfd){
  super(rfd);
  _fault=rfd.getFault();
}"
50780,"/** 
 * Copy constructor.
 */
public RequestResponseDefinition(RequestResponseDefinition rrd){
  super(rrd);
}","/** 
 * Copy constructor.
 * @param rrd The source to copy
 */
public RequestResponseDefinition(RequestResponseDefinition rrd){
  super(rrd);
}"
50781,"/** 
 * Copy constructor.
 */
public ResponseTime(ResponseTime rt){
  _serviceType=rt.getServiceType();
  _operation=rt.getOperation();
  _fault=rt.getFault();
  _avg=rt.getAverage();
  _max=rt.getMax();
  _min=rt.getMin();
  _timestamp=rt.getTimestamp();
}","/** 
 * Copy constructor.
 * @param rt The source to copy
 */
public ResponseTime(ResponseTime rt){
  _serviceType=rt.getServiceType();
  _operation=rt.getOperation();
  _fault=rt.getFault();
  _avg=rt.getAverage();
  _max=rt.getMax();
  _min=rt.getMin();
  _timestamp=rt.getTimestamp();
}"
50782,"/** 
 * Copy constructor.
 */
public ServiceDefinition(ServiceDefinition sd){
  _serviceType=sd.getServiceType();
  for (  OperationDefinition op : sd.getOperations()) {
    _operations.add(new OperationDefinition(op));
  }
}","/** 
 * Copy constructor.
 * @param sd The source to copy
 */
public ServiceDefinition(ServiceDefinition sd){
  _serviceType=sd.getServiceType();
  for (  OperationDefinition op : sd.getOperations()) {
    _operations.add(new OperationDefinition(op));
  }
}"
50783,"/** 
 * This method merges the supplied service definition snapshots.
 * @return The merged service definitions
 */
public static java.util.Map<String,ServiceDefinition> mergeSnapshots(java.util.List<java.util.Map<String,ServiceDefinition>> snapshots){
  java.util.Map<String,ServiceDefinition> ret=new java.util.HashMap<String,ServiceDefinition>();
  if (LOG.isLoggable(Level.FINER)) {
    LOG.finer(""String_Node_Str"" + snapshots);
  }
  java.util.Set<String> keys=new java.util.HashSet<String>();
  for (  java.util.Map<String,ServiceDefinition> sds : snapshots) {
    keys.addAll(sds.keySet());
  }
  for (  String key : keys) {
    ServiceDefinition sd=new ServiceDefinition();
    sd.setServiceType(key);
    for (    java.util.Map<String,ServiceDefinition> sds : snapshots) {
      if (sds.containsKey(key)) {
        try {
          sd.merge(sds.get(key));
        }
 catch (        Exception e) {
          LOG.log(Level.SEVERE,""String_Node_Str"",e);
        }
      }
    }
    ret.put(key,sd);
  }
  if (LOG.isLoggable(Level.FINER)) {
    LOG.finer(""String_Node_Str"" + ret);
  }
  return (ret);
}","/** 
 * This method merges the supplied service definition snapshots.
 * @param snapshots The snapshots to merge
 * @return The merged service definitions
 */
public static java.util.Map<String,ServiceDefinition> mergeSnapshots(java.util.List<java.util.Map<String,ServiceDefinition>> snapshots){
  java.util.Map<String,ServiceDefinition> ret=new java.util.HashMap<String,ServiceDefinition>();
  if (LOG.isLoggable(Level.FINER)) {
    LOG.finer(""String_Node_Str"" + snapshots);
  }
  java.util.Set<String> keys=new java.util.HashSet<String>();
  for (  java.util.Map<String,ServiceDefinition> sds : snapshots) {
    keys.addAll(sds.keySet());
  }
  for (  String key : keys) {
    ServiceDefinition sd=new ServiceDefinition();
    sd.setServiceType(key);
    for (    java.util.Map<String,ServiceDefinition> sds : snapshots) {
      if (sds.containsKey(key)) {
        try {
          sd.merge(sds.get(key));
        }
 catch (        Exception e) {
          LOG.log(Level.SEVERE,""String_Node_Str"",e);
        }
      }
    }
    ret.put(key,sd);
  }
  if (LOG.isLoggable(Level.FINER)) {
    LOG.finer(""String_Node_Str"" + ret);
  }
  return (ret);
}"
50784,"/** 
 * This method sets the script location.
 * @param script The script location
 */
public void setScriptLocation(String location){
  _scriptLocation=location;
}","/** 
 * This method sets the script location.
 * @param location The script location
 */
public void setScriptLocation(String location){
  _scriptLocation=location;
}"
50785,"/** 
 * This method returns the cache associated with the supplied name.
 * @param name The name of the required cache
 * @return The cache, or null if not found
 */
public abstract <K,V>Map<K,V> getCache(String name);","/** 
 * This method returns the cache associated with the supplied name.
 * @param name The name of the required cache
 * @return The cache, or null if not found
 * @param < K > The key type
 * @param < V > The value type
 */
public abstract <K,V>Map<K,V> getCache(String name);"
50786,"/** 
 * {@inheritDoc}
 */
public void forward(Object result){
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + this + ""String_Node_Str""+ result);
  }
  _result.set(result);
}","/** 
 * {@inheritDoc}
 */
public void forward(Object result){
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + this + ""String_Node_Str""+ result);
  }
  RESULT.set(result);
}"
50787,"/** 
 * This method retrieves the result forwarded by the rule.
 * @return The result, or null if not defined
 */
public Object getResult(){
  Object ret=_result.get();
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + this + ""String_Node_Str""+ ret);
  }
  return (ret);
}","/** 
 * This method retrieves the result forwarded by the rule.
 * @return The result, or null if not defined
 */
public Object getResult(){
  Object ret=RESULT.get();
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + this + ""String_Node_Str""+ ret);
  }
  return (ret);
}"
50788,"/** 
 * This method sets the count change (if applicable).
 * @param count The count change percentage
 */
public void setCountChange(int change){
  _countChange=change;
}","/** 
 * This method sets the count change (if applicable).
 * @param change The count change percentage
 */
public void setCountChange(int change){
  _countChange=change;
}"
50789,"/** 
 * This method sets the minimum duration change (if applicable).
 * @param time The minimum duration change percentage
 */
public void setMinChange(int change){
  _minChange=change;
}","/** 
 * This method sets the minimum duration change (if applicable).
 * @param change The minimum duration change percentage
 */
public void setMinChange(int change){
  _minChange=change;
}"
50790,"/** 
 * This method sets the maximum duration change (if applicable).
 * @param time The maximum duration change percentage
 */
public void setMaxChange(int change){
  _maxChange=change;
}","/** 
 * This method sets the maximum duration change (if applicable).
 * @param change The maximum duration change percentage
 */
public void setMaxChange(int change){
  _maxChange=change;
}"
50791,"/** 
 * This method sets the average duration change (if applicable).
 * @param time The average duration change percentage
 */
public void setAverageChange(int change){
  _avgChange=change;
}","/** 
 * This method sets the average duration change (if applicable).
 * @param change The average duration change percentage
 */
public void setAverageChange(int change){
  _avgChange=change;
}"
50792,"/** 
 * @return the severity
 */
public String getSeverity(){
  return _severity;
}","/** 
 * This method returns the severity value.
 * @return The severity
 */
public String getSeverity(){
  return _severity;
}"
50793,"/** 
 * @param severity the severity to set
 */
public void setSeverity(String severity){
  _severity=severity;
}","/** 
 * This method sets the severity value.
 * @param severity The severity value
 */
public void setSeverity(String severity){
  _severity=severity;
}"
50794,"/** 
 * This method handles queries for activity events.
 * @param qs The query spec
 * @return The list of activity events
 * @throws Exception Failed to query activity events
 */
@POST @Path(""String_Node_Str"") @Produces(""String_Node_Str"") public String query(String qspec) throws Exception {
  String ret=""String_Node_Str"";
  QuerySpec qs=ActivityUtil.deserializeQuerySpec(qspec.getBytes());
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + qs);
  }
  if (_activityServer == null) {
    throw new Exception(""String_Node_Str"");
  }
  java.util.List<ActivityUnit> list=_activityServer.query(qs);
  if (list != null) {
    byte[] b=ActivityUtil.serializeActivityUnitList(list);
    ret=new String(b);
  }
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + ret);
  }
  return (ret);
}","/** 
 * This method handles queries for activity events.
 * @param qspec The query spec
 * @return The list of activity events
 * @throws Exception Failed to query activity events
 */
@POST @Path(""String_Node_Str"") @Produces(""String_Node_Str"") public String query(String qspec) throws Exception {
  String ret=""String_Node_Str"";
  QuerySpec qs=ActivityUtil.deserializeQuerySpec(qspec.getBytes());
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + qs);
  }
  if (_activityServer == null) {
    throw new Exception(""String_Node_Str"");
  }
  java.util.List<ActivityUnit> list=_activityServer.query(qs);
  if (list != null) {
    byte[] b=ActivityUtil.serializeActivityUnitList(list);
    ret=new String(b);
  }
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + ret);
  }
  return (ret);
}"
50795,"/** 
 * The sub-expression constructor.
 */
public Expression(Operator operator,Expression... expr){
  _operator=operator;
  for (  Expression e : expr) {
    _expressions.add(e);
  }
}","/** 
 * The sub-expression constructor.
 * @param operator The operator
 * @param expr The list of sub-expressions
 */
public Expression(Operator operator,Expression... expr){
  _operator=operator;
  for (  Expression e : expr) {
    _expressions.add(e);
  }
}"
50796,"/** 
 * This method performs the cleanup task on the top level active collections.
 */
protected void cleanup(){
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"");
  }
synchronized (_activeCollections) {
    for (    ActiveCollection ac : _activeCollections.values()) {
      ac.cleanup();
      if (ac.getHighWaterMark() > 0) {
        if (ac.getHighWaterMarkWarningIssued()) {
          if (ac.getSize() < ac.getHighWaterMark()) {
            LOG.info(""String_Node_Str"" + ac.getName() + ""String_Node_Str""+ ac.getHighWaterMark()+ ""String_Node_Str"");
            ac.setHighWaterMarkWarningIssued(false);
          }
        }
 else         if (ac.getSize() > ac.getHighWaterMark()) {
          LOG.warning(""String_Node_Str"" + ac.getName() + ""String_Node_Str""+ ac.getHighWaterMark()+ ""String_Node_Str"");
          ac.setHighWaterMarkWarningIssued(true);
        }
      }
    }
  }
}","/** 
 * This method performs the cleanup task on the top level active collections.
 */
protected void cleanup(){
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"");
  }
synchronized (_activeCollections) {
    for (    ActiveCollection ac : _activeCollections.values()) {
      try {
        ac.cleanup();
      }
 catch (      Exception e) {
        LOG.log(Level.SEVERE,""String_Node_Str"" + ac.getName() + ""String_Node_Str"",e);
      }
      if (ac.getHighWaterMark() > 0) {
        if (ac.getHighWaterMarkWarningIssued()) {
          if (ac.getSize() < ac.getHighWaterMark()) {
            LOG.info(""String_Node_Str"" + ac.getName() + ""String_Node_Str""+ ac.getHighWaterMark()+ ""String_Node_Str"");
            ac.setHighWaterMarkWarningIssued(false);
          }
        }
 else         if (ac.getSize() > ac.getHighWaterMark()) {
          LOG.warning(""String_Node_Str"" + ac.getName() + ""String_Node_Str""+ ac.getHighWaterMark()+ ""String_Node_Str"");
          ac.setHighWaterMarkWarningIssued(true);
        }
      }
    }
  }
}"
50797,"/** 
 * {@inheritDoc}
 */
protected void cleanup(){
  if (getMaxItems() > 0) {
synchronized (_list) {
      int num=getSize() - getMaxItems();
      if (num > 0) {
        for (int i=getSize() - 1; i >= getMaxItems(); i--) {
          remove(i,null);
        }
      }
    }
  }
  if (getItemExpiration() > 0) {
synchronized (_list) {
      long expiration=System.currentTimeMillis() - getItemExpiration();
      for (int i=getSize() - 1; i >= 0; i--) {
        if (_listTimestamps.get(i) < expiration) {
          remove(i,null);
        }
      }
    }
  }
}","/** 
 * {@inheritDoc}
 */
protected void cleanup(){
  if (getMaxItems() > 0) {
synchronized (_list) {
      int num=getSize() - getMaxItems();
      while (num > 0) {
        remove(0,null);
        num--;
      }
    }
  }
  if (getItemExpiration() > 0) {
synchronized (_list) {
      long expiration=System.currentTimeMillis() - getItemExpiration();
      for (int i=getSize() - 1; i >= 0; i--) {
        if (_listTimestamps.get(i) < expiration) {
          remove(i,null);
        }
      }
    }
  }
}"
50798,"/** 
 * {@inheritDoc}
 */
public void inserted(Object key,Object value){
  Notification notification=new Notification(_insertType,this,_sequenceNumber++,value.toString());
  for (  NotificationDetails n : _notificationDetails) {
    n.getListener().handleNotification(notification,n.getHandback());
  }
}","/** 
 * {@inheritDoc}
 */
public void inserted(Object key,Object value){
  if (_insertType != null) {
    Notification notification=new Notification(_insertType,this,_sequenceNumber++,value.toString());
    for (    NotificationDetails n : _notificationDetails) {
      n.getListener().handleNotification(notification,n.getHandback());
    }
  }
}"
50799,"/** 
 * {@inheritDoc}
 */
public void removed(Object key,Object value){
  Notification notification=new Notification(_removeType,this,_sequenceNumber++,value.toString());
  for (  NotificationDetails n : _notificationDetails) {
    n.getListener().handleNotification(notification,n.getHandback());
  }
}","/** 
 * {@inheritDoc}
 */
public void removed(Object key,Object value){
  if (_removeType != null) {
    Notification notification=new Notification(_removeType,this,_sequenceNumber++,value.toString());
    for (    NotificationDetails n : _notificationDetails) {
      n.getListener().handleNotification(notification,n.getHandback());
    }
  }
}"
50800,"/** 
 * {@inheritDoc}
 */
public void updated(Object key,Object value){
  Notification notification=new Notification(_updateType,this,_sequenceNumber++,value.toString());
  for (  NotificationDetails n : _notificationDetails) {
    n.getListener().handleNotification(notification,n.getHandback());
  }
}","/** 
 * {@inheritDoc}
 */
public void updated(Object key,Object value){
  if (_updateType != null) {
    Notification notification=new Notification(_updateType,this,_sequenceNumber++,value.toString());
    for (    NotificationDetails n : _notificationDetails) {
      n.getListener().handleNotification(notification,n.getHandback());
    }
  }
}"
50801,"@Test public void testCleanupMaxItems(){
  ActiveList list=new ActiveList(TEST_ACTIVE_COLLECTION);
  TestActiveChangeListener l=new TestActiveChangeListener();
  list.addActiveChangeListener(l);
  list.setMaxItems(10);
  for (int i=0; i < 15; i++) {
    list.insert(null,new TestObject(i));
  }
  if (list.getSize() != 15) {
    fail(""String_Node_Str"" + list.getSize());
  }
  list.cleanup();
  if (list.getSize() != 10) {
    fail(""String_Node_Str"" + list.getSize());
  }
  if (l._removedKey.size() != 5) {
    fail(""String_Node_Str"" + l._removedKey.size());
  }
}","@Test public void testCleanupMaxItems(){
  ActiveList list=new ActiveList(TEST_ACTIVE_COLLECTION);
  TestActiveChangeListener l=new TestActiveChangeListener();
  list.addActiveChangeListener(l);
  list.setMaxItems(10);
  for (int i=0; i < 15; i++) {
    list.insert(null,new TestObject(i));
  }
  if (list.getSize() != 15) {
    fail(""String_Node_Str"" + list.getSize());
  }
  list.cleanup();
  if (list.getSize() != 10) {
    fail(""String_Node_Str"" + list.getSize());
  }
  TestObject to=(TestObject)list.iterator().next();
  if (to.getNumber() != 5) {
    fail(""String_Node_Str"");
  }
  if (l._removedKey.size() != 5) {
    fail(""String_Node_Str"" + l._removedKey.size());
  }
}"
50802,"/** 
 * {@inheritDoc}
 */
public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(VERSION);
  out.writeObject(_id);
  out.writeObject(_origin);
  int len=_context.size();
  out.writeInt(len);
  for (int i=0; i < len; i++) {
    out.writeObject(_context.get(i));
  }
  len=_activityTypes.size();
  out.writeInt(len);
  for (int i=0; i < len; i++) {
    out.writeObject(_activityTypes.get(i));
  }
}","/** 
 * {@inheritDoc}
 */
public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(VERSION);
  out.writeObject(_id);
  out.writeObject(_origin);
  int len=_contexts.size();
  out.writeInt(len);
  for (int i=0; i < len; i++) {
    out.writeObject(_contexts.get(i));
  }
  len=_activityTypes.size();
  out.writeInt(len);
  for (int i=0; i < len; i++) {
    out.writeObject(_activityTypes.get(i));
  }
}"
50803,"/** 
 * The copy constructor.
 * @param act The activity to copy.
 */
public ActivityUnit(ActivityUnit act){
  _id=act._id;
  if (act._origin != null) {
    _origin=new Origin(act._origin);
  }
  for (  Context context : act._context) {
    _context.add(new Context(context));
  }
  for (  ActivityType actType : _activityTypes) {
    try {
      Constructor<? extends ActivityType> con=actType.getClass().getConstructor(actType.getClass());
      if (con != null) {
        _activityTypes.add(con.newInstance(actType));
      }
 else {
        LOG.severe(""String_Node_Str"" + actType.getClass().getName() + ""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      LOG.log(Level.SEVERE,""String_Node_Str"",e);
    }
  }
}","/** 
 * The copy constructor.
 * @param act The activity to copy.
 */
public ActivityUnit(ActivityUnit act){
  _id=act._id;
  if (act._origin != null) {
    _origin=new Origin(act._origin);
  }
  for (  Context context : act._contexts) {
    _contexts.add(new Context(context));
  }
  for (  ActivityType actType : _activityTypes) {
    try {
      Constructor<? extends ActivityType> con=actType.getClass().getConstructor(actType.getClass());
      if (con != null) {
        _activityTypes.add(con.newInstance(actType));
      }
 else {
        LOG.severe(""String_Node_Str"" + actType.getClass().getName() + ""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      LOG.log(Level.SEVERE,""String_Node_Str"",e);
    }
  }
}"
50804,"/** 
 * This method sets the context.
 * @param context The context
 */
public void setContext(java.util.List<Context> context){
  _context=context;
}","/** 
 * This method sets the context.
 * @param context The context
 */
public void setContext(java.util.List<Context> context){
  _contexts=context;
}"
50805,"/** 
 * {@inheritDoc}
 */
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  in.readInt();
  _id=(String)in.readObject();
  _origin=(Origin)in.readObject();
  int len=in.readInt();
  for (int i=0; i < len; i++) {
    _context.add((Context)in.readObject());
  }
  len=in.readInt();
  for (int i=0; i < len; i++) {
    _activityTypes.add((ActivityType)in.readObject());
  }
}","/** 
 * {@inheritDoc}
 */
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  in.readInt();
  _id=(String)in.readObject();
  _origin=(Origin)in.readObject();
  int len=in.readInt();
  for (int i=0; i < len; i++) {
    _contexts.add((Context)in.readObject());
  }
  len=in.readInt();
  for (int i=0; i < len; i++) {
    _activityTypes.add((ActivityType)in.readObject());
  }
}"
50806,"/** 
 * This method gets the context.
 * @return The context
 */
public java.util.List<Context> getContext(){
  return (_context);
}","/** 
 * This method gets the context.
 * @return The context
 */
public java.util.List<Context> getContext(){
  return (_contexts);
}"
50807,"/** 
 * {@inheritDoc}
 */
public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(VERSION);
  out.writeObject(_processType);
  out.writeObject(_instanceId);
}","/** 
 * {@inheritDoc}
 */
public void writeExternal(ObjectOutput out) throws IOException {
  super.writeExternal(out);
  out.writeInt(VERSION);
  out.writeObject(_processType);
  out.writeObject(_instanceId);
}"
50808,"/** 
 * {@inheritDoc}
 */
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  in.readInt();
  _processType=(String)in.readObject();
  _instanceId=(String)in.readObject();
}","/** 
 * {@inheritDoc}
 */
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  super.readExternal(in);
  in.readInt();
  _processType=(String)in.readObject();
  _instanceId=(String)in.readObject();
}"
50809,"/** 
 * {@inheritDoc}
 */
public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(VERSION);
  out.writeObject(_status);
}","/** 
 * {@inheritDoc}
 */
public void writeExternal(ObjectOutput out) throws IOException {
  super.writeExternal(out);
  out.writeInt(VERSION);
  out.writeObject(_status);
}"
50810,"/** 
 * {@inheritDoc}
 */
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  in.readInt();
  _status=(Status)in.readObject();
}","/** 
 * {@inheritDoc}
 */
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  super.readExternal(in);
  in.readInt();
  _status=(Status)in.readObject();
}"
50811,"/** 
 * {@inheritDoc}
 */
public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(VERSION);
  out.writeObject(_version);
}","/** 
 * {@inheritDoc}
 */
public void writeExternal(ObjectOutput out) throws IOException {
  super.writeExternal(out);
  out.writeInt(VERSION);
  out.writeObject(_version);
}"
50812,"/** 
 * {@inheritDoc}
 */
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  in.readInt();
  _version=(String)in.readObject();
}","/** 
 * {@inheritDoc}
 */
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  super.readExternal(in);
  in.readInt();
  _version=(String)in.readObject();
}"
50813,"/** 
 * {@inheritDoc}
 */
public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(VERSION);
  out.writeObject(_messageType);
  out.writeObject(_content);
  out.writeObject(_destination);
}","/** 
 * {@inheritDoc}
 */
public void writeExternal(ObjectOutput out) throws IOException {
  super.writeExternal(out);
  out.writeInt(VERSION);
  out.writeObject(_messageType);
  out.writeObject(_content);
  out.writeObject(_destination);
}"
50814,"/** 
 * {@inheritDoc}
 */
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  in.readInt();
  _messageType=(String)in.readObject();
  _content=(String)in.readObject();
  _destination=(String)in.readObject();
}","/** 
 * {@inheritDoc}
 */
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  super.readExternal(in);
  in.readInt();
  _messageType=(String)in.readObject();
  _content=(String)in.readObject();
  _destination=(String)in.readObject();
}"
50815,"/** 
 * {@inheritDoc}
 */
public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(VERSION);
}","/** 
 * {@inheritDoc}
 */
public void writeExternal(ObjectOutput out) throws IOException {
  super.writeExternal(out);
  out.writeInt(VERSION);
}"
50816,"/** 
 * {@inheritDoc}
 */
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  in.readInt();
}","/** 
 * {@inheritDoc}
 */
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  super.readExternal(in);
  in.readInt();
}"
50817,"/** 
 * {@inheritDoc}
 */
public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(VERSION);
}","/** 
 * {@inheritDoc}
 */
public void writeExternal(ObjectOutput out) throws IOException {
  super.writeExternal(out);
  out.writeInt(VERSION);
}"
50818,"/** 
 * {@inheritDoc}
 */
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  in.readInt();
}","/** 
 * {@inheritDoc}
 */
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  super.readExternal(in);
  in.readInt();
}"
50819,"/** 
 * {@inheritDoc}
 */
public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(VERSION);
  out.writeObject(_serviceType);
  out.writeObject(_operation);
  out.writeObject(_fault);
  out.writeObject(_messageType);
  out.writeObject(_content);
  out.writeObject(_messageId);
}","/** 
 * {@inheritDoc}
 */
public void writeExternal(ObjectOutput out) throws IOException {
  super.writeExternal(out);
  out.writeInt(VERSION);
  out.writeObject(_serviceType);
  out.writeObject(_operation);
  out.writeObject(_fault);
  out.writeObject(_messageType);
  out.writeObject(_content);
  out.writeObject(_messageId);
}"
50820,"/** 
 * {@inheritDoc}
 */
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  in.readInt();
  _serviceType=(String)in.readObject();
  _operation=(String)in.readObject();
  _fault=(String)in.readObject();
  _messageType=(String)in.readObject();
  _content=(String)in.readObject();
  _messageId=(String)in.readObject();
}","/** 
 * {@inheritDoc}
 */
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  super.readExternal(in);
  in.readInt();
  _serviceType=(String)in.readObject();
  _operation=(String)in.readObject();
  _fault=(String)in.readObject();
  _messageType=(String)in.readObject();
  _content=(String)in.readObject();
  _messageId=(String)in.readObject();
}"
50821,"/** 
 * {@inheritDoc}
 */
public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(VERSION);
}","/** 
 * {@inheritDoc}
 */
public void writeExternal(ObjectOutput out) throws IOException {
  super.writeExternal(out);
  out.writeInt(VERSION);
}"
50822,"/** 
 * {@inheritDoc}
 */
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  in.readInt();
}","/** 
 * {@inheritDoc}
 */
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  super.readExternal(in);
  in.readInt();
}"
50823,"/** 
 * {@inheritDoc}
 */
public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(VERSION);
}","/** 
 * {@inheritDoc}
 */
public void writeExternal(ObjectOutput out) throws IOException {
  super.writeExternal(out);
  out.writeInt(VERSION);
}"
50824,"/** 
 * {@inheritDoc}
 */
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  in.readInt();
}","/** 
 * {@inheritDoc}
 */
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  super.readExternal(in);
  in.readInt();
}"
50825,"/** 
 * {@inheritDoc}
 */
public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(VERSION);
  out.writeObject(_replyToId);
}","/** 
 * {@inheritDoc}
 */
public void writeExternal(ObjectOutput out) throws IOException {
  super.writeExternal(out);
  out.writeInt(VERSION);
  out.writeObject(_replyToId);
}"
50826,"/** 
 * {@inheritDoc}
 */
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  in.readInt();
  _replyToId=(String)in.readObject();
}","/** 
 * {@inheritDoc}
 */
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  super.readExternal(in);
  in.readInt();
  _replyToId=(String)in.readObject();
}"
50827,"/** 
 * {@inheritDoc}
 */
public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(VERSION);
  out.writeObject(_replyToId);
}","/** 
 * {@inheritDoc}
 */
public void writeExternal(ObjectOutput out) throws IOException {
  super.writeExternal(out);
  out.writeInt(VERSION);
  out.writeObject(_replyToId);
}"
50828,"/** 
 * {@inheritDoc}
 */
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  in.readInt();
  _replyToId=(String)in.readObject();
}","/** 
 * {@inheritDoc}
 */
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  super.readExternal(in);
  in.readInt();
  _replyToId=(String)in.readObject();
}"
50829,"@Test public void testJSONBinarySerialization(){
  ActivityUnit act=createTestActivityUnit(""String_Node_Str"");
  try {
    java.io.ByteArrayOutputStream os=new java.io.ByteArrayOutputStream();
    java.io.ObjectOutputStream oos=new java.io.ObjectOutputStream(os);
    oos.writeObject(act);
    oos.close();
    os.close();
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + e);
  }
}","@Test public void testJSONBinarySerialization(){
  ActivityUnit act1=createTestActivityUnit(""String_Node_Str"");
  try {
    java.io.ByteArrayOutputStream os=new java.io.ByteArrayOutputStream();
    java.io.ObjectOutputStream oos=new java.io.ObjectOutputStream(os);
    oos.writeObject(act1);
    oos.close();
    os.close();
    java.io.ByteArrayInputStream is=new java.io.ByteArrayInputStream(os.toByteArray());
    java.io.ObjectInputStream ois=new java.io.ObjectInputStream(is);
    ActivityUnit act2=(ActivityUnit)ois.readObject();
    ois.close();
    is.close();
    String s1=new String(ActivityUtil.serialize(act1));
    String s2=new String(ActivityUtil.serialize(act2));
    if (!s1.equals(s2)) {
      fail(""String_Node_Str"" + s1 + ""String_Node_Str""+ s2);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    fail(""String_Node_Str"" + e);
  }
}"
50830,"/** 
 * {@inheritDoc}
 */
protected void sendMessage() throws Exception {
  if (_activities != null) {
    _activityServer.store(_activities);
  }
}","/** 
 * {@inheritDoc}
 */
protected void sendMessage() throws Exception {
  if (_activities != null) {
    _activityServer.store(_activities);
    _activities.clear();
  }
}"
50831,"/** 
 * {@inheritDoc}
 */
public void endTransaction(){
  _activityUnit.remove();
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"");
  }
}","/** 
 * {@inheritDoc}
 */
public void endTransaction(){
  ActivityUnit au=_activityUnit.get();
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + au);
  }
  if (au != null) {
    _activityLogger.log(au);
    _activityUnit.remove();
  }
}"
50832,"@PostConstruct public void init(){
  try {
    InitialContext ctx=new InitialContext();
    _transactionManager=(TransactionManager)ctx.lookup(TRANSACTION_MANAGER);
  }
 catch (  Exception e) {
    LOG.log(Level.SEVERE,""String_Node_Str"",e);
  }
}","/** 
 * This method initializes the collector context.
 */
@PostConstruct public void init(){
  try {
    InitialContext ctx=new InitialContext();
    _transactionManager=(TransactionManager)ctx.lookup(TRANSACTION_MANAGER);
  }
 catch (  Exception e) {
    LOG.log(Level.SEVERE,""String_Node_Str"",e);
  }
}"
50833,"protected void startScope(ActivityUnit au){
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"");
  }
  _activityUnit.set(au);
}","/** 
 * This method starts the scope associated with the supplied activity unit.
 * @param au The activity unit
 */
protected void startScope(ActivityUnit au){
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"");
  }
  _activityUnit.set(au);
}"
50834,"/** 
 * This method returns the network version.
 * @return The network version
 */
protected String getVersion(){
  return (_version);
}","/** 
 * This method returns the network version.
 * @return The network version
 */
protected String getVersion(){
  return (_network.getVersion());
}"
50835,"/** 
 * This method returns the network name.
 * @return The network name
 */
protected String getNetworkName(){
  return (_networkName);
}","/** 
 * This method returns the network name.
 * @return The network name
 */
protected String getNetworkName(){
  return (_network.getName());
}"
50836,"/** 
 * This method registers the network's entry point against its list of subscription subjects.
 * @param network The network
 */
protected void registerEntryPoints(Network network){
synchronized (_entryPoints) {
    Node rootNode=network.getNodes().get(network.getRootNodeName());
    for (    String subject : network.getSubjects()) {
      java.util.List<EmbeddedChannel> channels=_entryPoints.get(subject);
      if (channels == null) {
        channels=new java.util.ArrayList<EmbeddedChannel>();
        _entryPoints.put(subject,channels);
      }
      channels.add(new EmbeddedChannel(network.getName(),network.getVersion(),network.getRootNodeName(),rootNode,null));
    }
  }
}","/** 
 * This method registers the network's entry point against its list of subscription subjects.
 * @param network The network
 */
protected void registerEntryPoints(Network network){
synchronized (_entryPoints) {
    Node rootNode=network.getNodes().get(network.getRootNodeName());
    for (    String subject : network.getSubjects()) {
      java.util.List<EmbeddedChannel> channels=_entryPoints.get(subject);
      if (channels == null) {
        channels=new java.util.ArrayList<EmbeddedChannel>();
        _entryPoints.put(subject,channels);
      }
      channels.add(new EmbeddedChannel(network,network.getRootNodeName(),rootNode,null));
    }
  }
}"
50837,"/** 
 * This is the constructor for the task.
 * @param networkName The network name
 * @param version The version
 * @param nodeName The node name
 * @param node The node
 * @param source The source node name
 * @param events The list of events
 * @param retriesLeft The number of retries left
 * @param channel The channel
 */
public EPNTask(String networkName,String version,String nodeName,Node node,String source,EventList events,int retriesLeft,EmbeddedChannel channel){
  _networkName=networkName;
  _version=version;
  _nodeName=nodeName;
  _node=node;
  _source=source;
  _events=events;
  _retriesLeft=retriesLeft;
  _channel=channel;
}","/** 
 * This is the constructor for the task.
 * @param network The network
 * @param nodeName The node name
 * @param node The node
 * @param source The source node name
 * @param events The list of events
 * @param retriesLeft The number of retries left
 * @param channel The channel
 */
public EPNTask(Network network,String nodeName,Node node,String source,EventList events,int retriesLeft,EmbeddedChannel channel){
  _networkName=network.getName();
  _version=network.getVersion();
  _nodeName=nodeName;
  _node=node;
  _source=source;
  _events=events;
  _retriesLeft=retriesLeft;
  _channel=channel;
}"
50838,"/** 
 * {@inheritDoc}
 */
public void send(EventList events,int retriesLeft) throws Exception {
  if (_subject != null) {
    publish(_subject,events);
  }
 else {
    if (retriesLeft == -1) {
      retriesLeft=_node.getMaxRetries();
    }
    _executor.execute(new EPNTask(_networkName,_version,_nodeName,_node,_source,events,retriesLeft,this));
  }
}","/** 
 * {@inheritDoc}
 */
public void send(EventList events,int retriesLeft) throws Exception {
  if (_subject != null) {
    publish(_subject,events);
  }
 else {
    if (retriesLeft == -1) {
      retriesLeft=_node.getMaxRetries();
    }
    _executor.execute(new EPNTask(_network,_nodeName,_node,_source,events,retriesLeft,this));
  }
}"
50839,"/** 
 * This method returns the version.
 * @return The version
 */
public String getVersion(){
  return (_version);
}","/** 
 * This method returns the version.
 * @return The version
 */
public String getVersion(){
  return (_network.getVersion());
}"
50840,"/** 
 * This method returns the network name.
 * @return The network name
 */
public String getNetworkName(){
  return (_networkName);
}","/** 
 * This method returns the network name.
 * @return The network name
 */
public String getNetworkName(){
  return (_network.getName());
}"
50841,"/** 
 * {@inheritDoc}
 */
public void send(EventList events,int retriesLeft) throws Exception {
  javax.jms.ObjectMessage mesg=_session.createObjectMessage(events);
  if (_subject != null) {
    mesg.setStringProperty(JMSEPNManagerImpl.EPN_SUBJECTS,_subject);
    if (LOG.isLoggable(Level.FINEST)) {
      LOG.finest(""String_Node_Str"" + events + ""String_Node_Str""+ _subject);
    }
  }
 else {
    mesg.setStringProperty(JMSEPNManagerImpl.EPN_NETWORK,_networkName);
    mesg.setStringProperty(JMSEPNManagerImpl.EPN_DESTINATION_NODES,_destinationNode);
    mesg.setStringProperty(JMSEPNManagerImpl.EPN_SOURCE_NODE,_sourceNode);
    mesg.setIntProperty(JMSEPNManagerImpl.EPN_RETRIES_LEFT,retriesLeft);
    if (LOG.isLoggable(Level.FINEST)) {
      LOG.finest(""String_Node_Str"" + events + ""String_Node_Str""+ _networkName+ ""String_Node_Str""+ _destinationNode);
    }
  }
  _producer.send(mesg);
}","/** 
 * {@inheritDoc}
 */
public void send(EventList events,int retriesLeft) throws Exception {
  javax.jms.ObjectMessage mesg=_session.createObjectMessage(events);
  if (_subject != null) {
    mesg.setStringProperty(JMSEPNManagerImpl.EPN_SUBJECTS,_subject);
    if (LOG.isLoggable(Level.FINEST)) {
      LOG.finest(""String_Node_Str"" + events + ""String_Node_Str""+ _subject);
    }
  }
 else {
    mesg.setStringProperty(JMSEPNManagerImpl.EPN_NETWORK,_network.getName());
    mesg.setStringProperty(JMSEPNManagerImpl.EPN_VERSION,_network.getVersion());
    mesg.setStringProperty(JMSEPNManagerImpl.EPN_DESTINATION_NODES,_destinationNode);
    mesg.setStringProperty(JMSEPNManagerImpl.EPN_SOURCE_NODE,_sourceNode);
    mesg.setIntProperty(JMSEPNManagerImpl.EPN_RETRIES_LEFT,retriesLeft);
    if (LOG.isLoggable(Level.FINEST)) {
      LOG.finest(""String_Node_Str"" + events + ""String_Node_Str""+ _network.getName()+ ""String_Node_Str""+ _network.getVersion()+ ""String_Node_Str""+ _destinationNode);
    }
  }
  _producer.send(mesg);
}"
50842,"/** 
 * This method adds a new instance of the Network to the list.
 * @param network The network
 */
public void add(Network network){
synchronized (_networks) {
    boolean f_inserted=false;
    for (int i=0; i < _networks.size(); i++) {
      if (NetworkUtil.isNewerVersion(_networks.get(i).getVersion(),network.getVersion())) {
        _networks.add(i,network);
        f_inserted=true;
        break;
      }
    }
    if (!f_inserted) {
      _networks.add(network);
    }
  }
}","/** 
 * This method adds a new instance of the Network to the list.
 * @param network The network
 */
public void add(Network network){
synchronized (_networks) {
    boolean inserted=false;
    for (int i=0; i < _networks.size(); i++) {
      if (NetworkUtil.isNewerVersion(_networks.get(i).getVersion(),network.getVersion())) {
        _networks.add(i,network);
        inserted=true;
        break;
      }
    }
    if (!inserted) {
      _networks.add(network);
    }
  }
}"
50843,"/** 
 * This method initializes the network.
 * @param container The container
 * @throws Exception Failed to initialize the network
 */
protected void init(EPNContainer container) throws Exception {
  for (  String name : _nodes.keySet()) {
    Node node=_nodes.get(name);
    if (node.getDestinationNodes() != null) {
      for (      String nodeName : node.getDestinationNodes()) {
        node.getChannels().add(container.getChannel(getName(),getVersion(),name,nodeName));
      }
    }
    if (node.getDestinationSubjects() != null) {
      for (      String subject : node.getDestinationSubjects()) {
        node.getChannels().add(container.getChannel(subject));
      }
    }
    node.init(container);
    if (name.equals(getRootNodeName())) {
      _root=node;
    }
  }
  if (_root == null) {
    throw new Exception(""String_Node_Str"" + getRootNodeName() + ""String_Node_Str"");
  }
}","/** 
 * This method initializes the network.
 * @param container The container
 * @throws Exception Failed to initialize the network
 */
protected void init(EPNContainer container) throws Exception {
  for (  String name : _nodes.keySet()) {
    Node node=_nodes.get(name);
    if (node.getDestinationNodes() != null) {
      for (      String nodeName : node.getDestinationNodes()) {
        node.getChannels().add(container.getChannel(this,name,nodeName));
      }
    }
    if (node.getDestinationSubjects() != null) {
      for (      String subject : node.getDestinationSubjects()) {
        node.getChannels().add(container.getChannel(subject));
      }
    }
    node.init(container);
    if (name.equals(getRootNodeName())) {
      _root=node;
    }
  }
  if (_root == null) {
    throw new Exception(""String_Node_Str"" + getRootNodeName() + ""String_Node_Str"");
  }
}"
50844,"/** 
 * This method dispatches a set of events directly to the named network and node. If the node is not specified, then it will be dispatched to the 'root' node of the network.
 * @param networkName The name of the network
 * @param nodeName The optional node name, or root node if not specified
 * @param source The source node, or null if sending to root
 * @param events The list of events to be processed
 * @param retriesLeft The number of retries left, or -1 if should be max value
 * @throws Exception Failed to dispatch the events for processing
 */
protected void dispatch(String networkName,String nodeName,String source,EventList events,int retriesLeft) throws Exception {
  Node node=getNode(networkName,nodeName);
  if (retriesLeft == -1) {
    retriesLeft=node.getMaxRetries();
  }
  EventList retries=process(networkName,nodeName,node,source,events,retriesLeft);
  if (retries != null) {
    retry(networkName,nodeName,source,events,retriesLeft - 1);
  }
}","/** 
 * This method dispatches a set of events directly to the named network and node. If the node is not specified, then it will be dispatched to the 'root' node of the network.
 * @param networkName The name of the network
 * @param nodeName The optional node name, or root node if not specified
 * @param source The source node, or null if sending to root
 * @param events The list of events to be processed
 * @param retriesLeft The number of retries left, or -1 if should be max value
 * @throws Exception Failed to dispatch the events for processing
 */
protected void dispatch(String networkName,String nodeName,String source,EventList events,int retriesLeft) throws Exception {
  Node node=getNode(networkName,nodeName);
  if (retriesLeft == -1) {
    retriesLeft=node.getMaxRetries();
  }
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + networkName + ""String_Node_Str""+ nodeName+ ""String_Node_Str""+ node+ ""String_Node_Str""+ events+ ""String_Node_Str""+ retriesLeft);
  }
  EventList retries=process(networkName,nodeName,node,source,events,retriesLeft);
  if (retries != null) {
    retry(networkName,nodeName,source,retries,retriesLeft - 1);
  }
}"
50845,"/** 
 * {@inheritDoc}
 */
@Override protected void notifyEventsProcessed(String networkName,String nodeName,EventList events) throws Exception {
  javax.jms.ObjectMessage mesg=_session.createObjectMessage(events);
  mesg.setStringProperty(JMSEPNManagerImpl.EPN_NETWORK,networkName);
  mesg.setStringProperty(JMSEPNManagerImpl.EPN_DESTINATION_NODE,nodeName);
  _notificationsProducer.send(mesg);
}","/** 
 * {@inheritDoc}
 */
@Override protected void notifyEventsProcessed(String networkName,String nodeName,EventList events) throws Exception {
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + networkName + ""String_Node_Str""+ nodeName+ ""String_Node_Str""+ events);
  }
  javax.jms.ObjectMessage mesg=_session.createObjectMessage(events);
  mesg.setStringProperty(JMSEPNManagerImpl.EPN_NETWORK,networkName);
  mesg.setStringProperty(JMSEPNManagerImpl.EPN_DESTINATION_NODE,nodeName);
  _notificationsProducer.send(mesg);
}"
50846,"/** 
 * This method handles retrying the supplied set of events, if the number of retries left is greater than 0.
 * @param networkName The name of the network
 * @param nodeName The optional node name, or root node if not specified
 * @param source The source
 * @param events The events
 * @param retriesLeft The number of retries now remaining after this failure to process them
 * @throws Exception Failed to retry the events processing
 */
protected void retry(String networkName,String nodeName,String source,EventList events,int retriesLeft) throws Exception {
  if (retriesLeft > 0) {
    javax.jms.ObjectMessage mesg=_session.createObjectMessage(events);
    mesg.setStringProperty(JMSEPNManagerImpl.EPN_NETWORK,networkName);
    mesg.setStringProperty(JMSEPNManagerImpl.EPN_DESTINATION_NODE,nodeName);
    mesg.setStringProperty(JMSEPNManagerImpl.EPN_SOURCE_NODE,source);
    mesg.setIntProperty(JMSEPNManagerImpl.EPN_RETRIES_LEFT,retriesLeft);
    _eventsProducer.send(mesg);
  }
 else {
    LOG.severe(""String_Node_Str"");
  }
}","/** 
 * This method handles retrying the supplied set of events, if the number of retries left is greater than 0.
 * @param networkName The name of the network
 * @param nodeName The optional node name, or root node if not specified
 * @param source The source
 * @param events The events
 * @param retriesLeft The number of retries now remaining after this failure to process them
 * @throws Exception Failed to retry the events processing
 */
protected void retry(String networkName,String nodeName,String source,EventList events,int retriesLeft) throws Exception {
  if (LOG.isLoggable(Level.FINEST)) {
    LOG.finest(""String_Node_Str"" + networkName + ""String_Node_Str""+ nodeName+ ""String_Node_Str""+ events+ ""String_Node_Str""+ retriesLeft);
  }
  if (retriesLeft > 0) {
    javax.jms.ObjectMessage mesg=_session.createObjectMessage(events);
    mesg.setStringProperty(JMSEPNManagerImpl.EPN_NETWORK,networkName);
    mesg.setStringProperty(JMSEPNManagerImpl.EPN_DESTINATION_NODE,nodeName);
    mesg.setStringProperty(JMSEPNManagerImpl.EPN_SOURCE_NODE,source);
    mesg.setIntProperty(JMSEPNManagerImpl.EPN_RETRIES_LEFT,retriesLeft);
    _eventsProducer.send(mesg);
  }
 else {
    LOG.severe(""String_Node_Str"");
  }
}"
50847,"public void enqueue(String network,java.util.List<java.io.Serializable> events) throws Exception {
  Channel channel=_entryPoints.get(network);
  if (channel == null) {
    throw new Exception(""String_Node_Str"" + network + ""String_Node_Str"");
  }
  channel.send(new EventList(events));
}","/** 
 * {@inheritDoc}
 */
public void enqueue(String network,java.util.List<java.io.Serializable> events) throws Exception {
  Channel channel=_entryPoints.get(network);
  if (channel == null) {
    throw new Exception(""String_Node_Str"" + network + ""String_Node_Str"");
  }
  channel.send(new EventList(events));
}"
50848,"public Channel getChannel(String source,Destination dest) throws Exception {
  return (new EmbeddedChannel(dest.getNetwork(),dest.getNode(),getNode(dest.getNetwork(),dest.getNode()),source));
}","/** 
 * {@inheritDoc}
 */
public Channel getChannel(String source,Destination dest) throws Exception {
  return (new EmbeddedChannel(dest.getNetwork(),dest.getNode(),getNode(dest.getNetwork(),dest.getNode()),source));
}"
50849,"public void unregister(String networkName) throws Exception {
  super.unregister(networkName);
  _entryPoints.remove(networkName);
}","/** 
 * {@inheritDoc}
 */
public void unregister(String networkName) throws Exception {
  super.unregister(networkName);
  _entryPoints.remove(networkName);
}"
50850,"public EmbeddedChannel(String networkName,String nodeName,Node node,String source){
  _networkName=networkName;
  _nodeName=nodeName;
  _node=node;
  _source=source;
}","/** 
 * The constructor.
 * @param networkName The network name
 * @param nodeName The node name
 * @param node The node
 * @param source The source node name
 */
public EmbeddedChannel(String networkName,String nodeName,Node node,String source){
  _networkName=networkName;
  _nodeName=nodeName;
  _node=node;
  _source=source;
}"
50851,"public void run(){
  EventList retries=null;
  try {
    retries=process(_networkName,_nodeName,_node,_source,_events,_retriesLeft);
  }
 catch (  Exception e) {
    LOG.log(Level.SEVERE,""String_Node_Str"",e);
    retries=_events;
  }
  if (retries != null) {
    if (_retriesLeft > 0) {
      try {
        _channel.send(retries,_retriesLeft - 1);
      }
 catch (      Exception e) {
        LOG.log(Level.SEVERE,""String_Node_Str"",e);
      }
    }
 else {
    }
  }
}","/** 
 * {@inheritDoc}
 */
public void run(){
  EventList retries=null;
  try {
    retries=process(_networkName,_nodeName,_node,_source,_events,_retriesLeft);
  }
 catch (  Exception e) {
    LOG.log(Level.SEVERE,""String_Node_Str"",e);
    retries=_events;
  }
  if (retries != null) {
    if (_retriesLeft > 0) {
      try {
        _channel.send(retries,_retriesLeft - 1);
      }
 catch (      Exception e) {
        LOG.log(Level.SEVERE,""String_Node_Str"",e);
      }
    }
 else {
      LOG.severe(""String_Node_Str"");
    }
  }
}"
50852,"public EPNTask(String networkName,String nodeName,Node node,String source,EventList events,int retriesLeft,Channel channel){
  _networkName=networkName;
  _nodeName=nodeName;
  _node=node;
  _source=source;
  _events=events;
  _retriesLeft=retriesLeft;
  _channel=channel;
}","/** 
 * This is the constructor for the task.
 * @param networkName The network name
 * @param nodeName The node name
 * @param node The node
 * @param source The source node name
 * @param events The list of events
 * @param retriesLeft The number of retries left
 * @param channel The channel
 */
public EPNTask(String networkName,String nodeName,Node node,String source,EventList events,int retriesLeft,Channel channel){
  _networkName=networkName;
  _nodeName=nodeName;
  _node=node;
  _source=source;
  _events=events;
  _retriesLeft=retriesLeft;
  _channel=channel;
}"
50853,"protected EPNContext getContext(){
  return (_context);
}","/** 
 * {@inheritDoc}
 */
protected EPNContext getContext(){
  return (_context);
}"
50854,"public void close() throws Exception {
}","/** 
 * {@inheritDoc}
 */
public void close() throws Exception {
}"
50855,"public void send(EventList events,int retriesLeft) throws Exception {
  _executor.execute(new EPNTask(_networkName,_nodeName,_node,_source,events,retriesLeft,this));
}","/** 
 * {@inheritDoc}
 */
public void send(EventList events,int retriesLeft) throws Exception {
  _executor.execute(new EPNTask(_networkName,_nodeName,_node,_source,events,retriesLeft,this));
}"
50856,"public void register(Network network) throws Exception {
  super.register(network);
  Node rootNode=network.getNodes().get(network.getRootNodeName());
  _entryPoints.put(network.getName(),new EmbeddedChannel(network.getName(),network.getRootNodeName(),rootNode,null));
}","/** 
 * {@inheritDoc}
 */
public void register(Network network) throws Exception {
  super.register(network);
  Node rootNode=network.getNodes().get(network.getRootNodeName());
  _entryPoints.put(network.getName(),new EmbeddedChannel(network.getName(),network.getRootNodeName(),rootNode,null));
}"
50857,"@PostConstruct public void init(){
  LOG.info(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  try {
    InitialContext context=new InitialContext();
    _epnManager=(JMSEPNManager)context.lookup(""String_Node_Str"");
  }
 catch (  Exception e) {
    LOG.log(Level.SEVERE,""String_Node_Str"",e);
  }
}","/** 
 * The initialize method.
 */
@PostConstruct public void init(){
  LOG.info(""String_Node_Str"");
  try {
    InitialContext context=new InitialContext();
    _epnManager=(JMSEPNManager)context.lookup(""String_Node_Str"");
  }
 catch (  Exception e) {
    LOG.log(Level.SEVERE,""String_Node_Str"",e);
  }
}"
50858,"public EPNEventsServer(){
}","/** 
 * The default constructor.
 */
public EPNEventsServer(){
}"
50859,"public void onMessage(Message message){
  if (_epnManager != null) {
    _epnManager.handleEventsMessage(message);
  }
}","/** 
 * {@inheritDoc}
 */
public void onMessage(Message message){
  if (_epnManager != null) {
    _epnManager.handleEventsMessage(message);
  }
}"
50860,"@PreDestroy public void close(){
  LOG.info(""String_Node_Str"");
}","/** 
 * The close method.
 */
@PreDestroy public void close(){
  LOG.info(""String_Node_Str"");
}"
50861,"@PostConstruct public void init(){
  LOG.info(""String_Node_Str"");
  try {
    InitialContext context=new InitialContext();
    _epnManager=(JMSEPNManager)context.lookup(""String_Node_Str"");
  }
 catch (  Exception e) {
    LOG.log(Level.SEVERE,""String_Node_Str"",e);
  }
}","/** 
 * The initialize method.
 */
@PostConstruct public void init(){
  LOG.info(""String_Node_Str"");
  try {
    InitialContext context=new InitialContext();
    _epnManager=(JMSEPNManager)context.lookup(""String_Node_Str"");
  }
 catch (  Exception e) {
    LOG.log(Level.SEVERE,""String_Node_Str"",e);
  }
}"
50862,"public void onMessage(Message message){
  if (_epnManager != null) {
    _epnManager.handleNotificationsMessage(message);
  }
}","/** 
 * {@inheritDoc}
 */
public void onMessage(Message message){
  if (_epnManager != null) {
    _epnManager.handleNotificationsMessage(message);
  }
}"
50863,"@PreDestroy public void close(){
  LOG.info(""String_Node_Str"");
}","/** 
 * The close method.
 */
@PreDestroy public void close(){
  LOG.info(""String_Node_Str"");
}"
50864,"public EPNNotificationServer(){
}","/** 
 * This is the default constructor.
 */
public EPNNotificationServer(){
}"
50865,"/** 
 * This is the constructor for the JMS channel.
 * @param session The session
 * @param producer The producer
 * @param source The source
 * @param destination The node destination
 */
public JMSChannel(javax.jms.Session session,javax.jms.MessageProducer producer,String source,Destination dest){
  _session=session;
  _producer=producer;
  _source=source;
  _destination=dest;
}","/** 
 * This is the constructor for the JMS channel.
 * @param session The session
 * @param producer The producer
 * @param source The source
 * @param dest The node destination
 */
public JMSChannel(javax.jms.Session session,javax.jms.MessageProducer producer,String source,Destination dest){
  _session=session;
  _producer=producer;
  _source=source;
  _destination=dest;
}"
50866,"public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(VERSION);
  out.writeUTF(_id);
  out.writeLong(_timestamp);
  out.writeObject(_context);
  out.writeObject(_component);
  out.writeObject(_activityType);
}","/** 
 * {@inheritDoc}
 */
public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(VERSION);
  out.writeUTF(_id);
  out.writeLong(_timestamp);
  out.writeObject(_context);
  out.writeObject(_component);
  out.writeObject(_activityType);
}"
50867,"public Activity(Activity act){
  _id=act._id;
  _timestamp=act._timestamp;
  if (act._context != null) {
    _context=new Context(act._context);
  }
  if (act._component != null) {
    _component=new Component(act._component);
  }
  _activityType=act._activityType;
}","/** 
 * The copy constructor.
 * @param act The activity to copy.
 */
public Activity(Activity act){
  _id=act._id;
  _timestamp=act._timestamp;
  if (act._context != null) {
    _context=new Context(act._context);
  }
  if (act._component != null) {
    _component=new Component(act._component);
  }
  _activityType=act._activityType;
}"
50868,"public String getId(){
  return (_id);
}","/** 
 * This method gets the activity id.
 * @return The id
 */
public String getId(){
  return (_id);
}"
50869,"public void setComponent(Component component){
  _component=component;
}","/** 
 * This method sets the component.
 * @param component The component
 */
public void setComponent(Component component){
  _component=component;
}"
50870,"public long getTimestamp(){
  return (_timestamp);
}","/** 
 * This method gets the timestamp.
 * @return The timestamp
 */
public long getTimestamp(){
  return (_timestamp);
}"
50871,"public ActivityType getActivityType(){
  return (_activityType);
}","/** 
 * This method gets the activity type.
 * @return The activity type
 */
public ActivityType getActivityType(){
  return (_activityType);
}"
50872,"public void setContext(Context context){
  _context=context;
}","/** 
 * This method sets the context.
 * @param context The context
 */
public void setContext(Context context){
  _context=context;
}"
50873,"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  in.readInt();
  _id=in.readUTF();
  _timestamp=in.readLong();
  _context=(Context)in.readObject();
  _component=(Component)in.readObject();
  _activityType=(ActivityType)in.readObject();
}","/** 
 * {@inheritDoc}
 */
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  in.readInt();
  _id=in.readUTF();
  _timestamp=in.readLong();
  _context=(Context)in.readObject();
  _component=(Component)in.readObject();
  _activityType=(ActivityType)in.readObject();
}"
50874,"public void setId(String id){
  _id=id;
}","/** 
 * This method sets the activity id.
 * @param id The id
 */
public void setId(String id){
  _id=id;
}"
50875,"public void setActivityType(ActivityType activityType){
  _activityType=activityType;
}","/** 
 * This method sets the activity type.
 * @param activityType The activity type
 */
public void setActivityType(ActivityType activityType){
  _activityType=activityType;
}"
50876,"public Component getComponent(){
  return (_component);
}","/** 
 * This method gets the component.
 * @return The component
 */
public Component getComponent(){
  return (_component);
}"
50877,"public Context getContext(){
  return (_context);
}","/** 
 * This method gets the context.
 * @return The context
 */
public Context getContext(){
  return (_context);
}"
50878,"public void setTimestamp(long timestamp){
  _timestamp=timestamp;
}","/** 
 * This method sets the timestamp.
 * @param timestamp The timestamp
 */
public void setTimestamp(long timestamp){
  _timestamp=timestamp;
}"
50879,"public String getProcessInstance(){
  return (_processInstance);
}","/** 
 * This method gets the process instance.
 * @return The process instance
 */
public String getProcessInstance(){
  return (_processInstance);
}"
50880,"public void setService(String service){
  _service=service;
}","/** 
 * This method sets the service.
 * @param service The service
 */
public void setService(String service){
  _service=service;
}"
50881,"public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(VERSION);
  out.writeUTF(_service);
  out.writeUTF(_processDefinition);
  out.writeUTF(_processInstance);
  out.writeUTF(_task);
}","/** 
 * {@inheritDoc}
 */
public void writeExternal(ObjectOutput out) throws IOException {
  out.writeInt(VERSION);
  out.writeUTF(_service);
  out.writeUTF(_processDefinition);
  out.writeUTF(_processInstance);
  out.writeUTF(_task);
}"
50882,"public String getProcessDefinition(){
  return (_processDefinition);
}","/** 
 * This method gets the process definition.
 * @return The process definition
 */
public String getProcessDefinition(){
  return (_processDefinition);
}"
50883,"public void setProcessInstance(String pi){
  _processInstance=pi;
}","/** 
 * This method sets the process instance.
 * @param pi The process instance
 */
public void setProcessInstance(String pi){
  _processInstance=pi;
}"
50884,"public void setTask(String task){
  _task=task;
}","/** 
 * This method sets the task.
 * @param task The task
 */
public void setTask(String task){
  _task=task;
}"
50885,"public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  in.readInt();
  _service=in.readUTF();
  _processDefinition=in.readUTF();
  _processInstance=in.readUTF();
  _task=in.readUTF();
}","/** 
 * {@inheritDoc}
 */
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
  in.readInt();
  _service=in.readUTF();
  _processDefinition=in.readUTF();
  _processInstance=in.readUTF();
  _task=in.readUTF();
}"
50886,"public Component(Component comp){
  _service=comp._service;
  _processDefinition=comp._processDefinition;
  _processInstance=comp._processInstance;
  _task=comp._task;
}","/** 
 * The copy constructor.
 * @param comp The component to copy.
 */
public Component(Component comp){
  _service=comp._service;
  _processDefinition=comp._processDefinition;
  _processInstance=comp._processInstance;
  _task=comp._task;
}"
50887,"public String getService(){
  return (_service);
}","/** 
 * This method gets the service.
 * @return The service
 */
public String getService(){
  return (_service);
}"
50888,"public void setProcessDefinition(String pd){
  _processDefinition=pd;
}","/** 
 * This method sets the process definition.
 * @param pd The process definition
 */
public void setProcessDefinition(String pd){
  _processDefinition=pd;
}"
50889,"public String getTask(){
  return (_task);
}","/** 
 * This method gets the task.
 * @return The task
 */
public String getTask(){
  return (_task);
}"
50890,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.stopchooser);
  db=((BusFollowerApplication)getApplication()).getDatabase();
  stopSearchField=(AutoCompleteTextView)findViewById(R.id.stopSearch);
  final Button chooseMapButton=(Button)findViewById(R.id.chooseMap);
  if (savedInstanceState != null) {
    if (fetchRoutesTask != null) {
      fetchRoutesTask.setActivityContext(this);
    }
    if (fetchTripsTask != null) {
      fetchTripsTask.setActivityContext(this);
    }
  }
  SimpleCursorAdapter adapter;
  if (android.os.Build.VERSION.SDK_INT < 11) {
    adapter=new SimpleCursorAdapter(this,android.R.layout.simple_dropdown_item_1line,null,new String[]{""String_Node_Str""},new int[]{android.R.id.text1});
  }
 else {
    adapter=new SimpleCursorAdapter(this,android.R.layout.simple_dropdown_item_1line,null,new String[]{""String_Node_Str""},new int[]{android.R.id.text1},0);
  }
  stopSearchField.setAdapter(adapter);
  adapter.setCursorToStringConverter(new CursorToStringConverter(){
    @Override public String convertToString(    Cursor cursor){
      return cursor.getString(cursor.getColumnIndexOrThrow(""String_Node_Str""));
    }
  }
);
  adapter.setFilterQueryProvider(new FilterQueryProvider(){
    @Override public Cursor runQuery(    CharSequence constraint){
      Log.d(TAG,""String_Node_Str"");
      if (constraint == null) {
        return null;
      }
      String constraintStr=constraint.toString();
      String[] pieces=constraintStr.split(""String_Node_Str"");
      String query=""String_Node_Str"";
      ArrayList<String> params=new ArrayList<>();
      boolean validQuery=false;
      for (      String piece : pieces) {
        if (piece.length() > 0) {
          validQuery=true;
          query+=""String_Node_Str"";
          params.add(""String_Node_Str"" + piece + ""String_Node_Str"");
          if (piece.matches(""String_Node_Str"")) {
            query+=""String_Node_Str"";
            params.add(piece + ""String_Node_Str"");
          }
          query+=""String_Node_Str"";
        }
      }
      if (!validQuery) {
        return null;
      }
      query+=""String_Node_Str"";
      Cursor cursor=db.rawQuery(query,params.toArray(new String[params.size()]));
      if (cursor != null) {
        cursor.moveToFirst();
        Log.d(TAG,""String_Node_Str"");
        return cursor;
      }
      Log.d(TAG,""String_Node_Str"");
      return null;
    }
  }
);
  stopSearchField.setOnEditorActionListener(new OnEditorActionListener(){
    @Override public boolean onEditorAction(    TextView v,    int actionId,    KeyEvent event){
      if (actionId == EditorInfo.IME_ACTION_GO || (actionId == EditorInfo.IME_NULL && event.getKeyCode() == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_DOWN)) {
        fetchRoutesTask=new FetchRoutesTask(StopChooserActivity.this,db);
        fetchRoutesTask.execute(stopSearchField.getText().toString());
        return true;
      }
      return false;
    }
  }
);
  stopSearchField.setOnItemClickListener(new OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
      fetchRoutesTask=new FetchRoutesTask(StopChooserActivity.this,db);
      fetchRoutesTask.execute(stopSearchField.getText().toString());
    }
  }
);
  chooseMapButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      Intent intent=new Intent(StopChooserActivity.this,MapChooserActivity.class);
      startActivity(intent);
    }
  }
);
  ListView recentList=(ListView)findViewById(R.id.recentList);
  recentQueryAdapter=new RecentQueryAdapter(this,android.R.layout.simple_list_item_1,new ArrayList<RecentQuery>());
  recentList.setAdapter(recentQueryAdapter);
  recentList.setOnItemClickListener(new OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View v,    int position,    long id){
      RecentQuery query=recentQueryAdapter.getItem(position);
      if (query.getRoute() == null) {
        fetchRoutesTask=new FetchRoutesTask(StopChooserActivity.this,db);
        fetchRoutesTask.execute(query.getStop().getNumber());
      }
 else {
        fetchTripsTask=new FetchTripsTask(StopChooserActivity.this,db);
        fetchTripsTask.execute(query);
      }
    }
  }
);
  checkPlayServices();
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.stopchooser);
  db=((BusFollowerApplication)getApplication()).getDatabase();
  stopSearchField=(AutoCompleteTextView)findViewById(R.id.stopSearch);
  final Button chooseMapButton=(Button)findViewById(R.id.chooseMap);
  if (savedInstanceState != null) {
    if (fetchRoutesTask != null) {
      fetchRoutesTask.setActivityContext(this);
    }
    if (fetchTripsTask != null) {
      fetchTripsTask.setActivityContext(this);
    }
  }
  SimpleCursorAdapter adapter;
  if (android.os.Build.VERSION.SDK_INT < 11) {
    adapter=new SimpleCursorAdapter(this,android.R.layout.simple_dropdown_item_1line,null,new String[]{""String_Node_Str""},new int[]{android.R.id.text1});
  }
 else {
    adapter=new SimpleCursorAdapter(this,android.R.layout.simple_spinner_dropdown_item,null,new String[]{""String_Node_Str""},new int[]{android.R.id.text1},0);
  }
  stopSearchField.setAdapter(adapter);
  adapter.setCursorToStringConverter(new CursorToStringConverter(){
    @Override public String convertToString(    Cursor cursor){
      return cursor.getString(cursor.getColumnIndexOrThrow(""String_Node_Str""));
    }
  }
);
  adapter.setFilterQueryProvider(new FilterQueryProvider(){
    @Override public Cursor runQuery(    CharSequence constraint){
      Log.d(TAG,""String_Node_Str"");
      if (constraint == null) {
        return null;
      }
      String constraintStr=constraint.toString();
      String[] pieces=constraintStr.split(""String_Node_Str"");
      String query=""String_Node_Str"";
      ArrayList<String> params=new ArrayList<>();
      boolean validQuery=false;
      for (      String piece : pieces) {
        if (piece.length() > 0) {
          validQuery=true;
          query+=""String_Node_Str"";
          params.add(""String_Node_Str"" + piece + ""String_Node_Str"");
          if (piece.matches(""String_Node_Str"")) {
            query+=""String_Node_Str"";
            params.add(piece + ""String_Node_Str"");
          }
          query+=""String_Node_Str"";
        }
      }
      if (!validQuery) {
        return null;
      }
      query+=""String_Node_Str"";
      Cursor cursor=db.rawQuery(query,params.toArray(new String[params.size()]));
      if (cursor != null) {
        cursor.moveToFirst();
        Log.d(TAG,""String_Node_Str"");
        return cursor;
      }
      Log.d(TAG,""String_Node_Str"");
      return null;
    }
  }
);
  stopSearchField.setOnEditorActionListener(new OnEditorActionListener(){
    @Override public boolean onEditorAction(    TextView v,    int actionId,    KeyEvent event){
      if (actionId == EditorInfo.IME_ACTION_GO || (actionId == EditorInfo.IME_NULL && event.getKeyCode() == KeyEvent.KEYCODE_ENTER && event.getAction() == KeyEvent.ACTION_DOWN)) {
        fetchRoutesTask=new FetchRoutesTask(StopChooserActivity.this,db);
        fetchRoutesTask.execute(stopSearchField.getText().toString());
        return true;
      }
      return false;
    }
  }
);
  stopSearchField.setOnItemClickListener(new OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View view,    int position,    long id){
      fetchRoutesTask=new FetchRoutesTask(StopChooserActivity.this,db);
      fetchRoutesTask.execute(stopSearchField.getText().toString());
    }
  }
);
  chooseMapButton.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      Intent intent=new Intent(StopChooserActivity.this,MapChooserActivity.class);
      startActivity(intent);
    }
  }
);
  ListView recentList=(ListView)findViewById(R.id.recentList);
  recentQueryAdapter=new RecentQueryAdapter(this,android.R.layout.simple_list_item_1,new ArrayList<RecentQuery>());
  recentList.setAdapter(recentQueryAdapter);
  recentList.setOnItemClickListener(new OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View v,    int position,    long id){
      RecentQuery query=recentQueryAdapter.getItem(position);
      if (query.getRoute() == null) {
        fetchRoutesTask=new FetchRoutesTask(StopChooserActivity.this,db);
        fetchRoutesTask.execute(query.getStop().getNumber());
      }
 else {
        fetchTripsTask=new FetchTripsTask(StopChooserActivity.this,db);
        fetchTripsTask.execute(query);
      }
    }
  }
);
  checkPlayServices();
}"
50891,"/** 
 * Called when the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.busfollower);
  dataFetcher=new OCTranspoDataFetcher(this);
  db=(new DatabaseHelper(this)).getReadableDatabase();
  mapView=(MapView)findViewById(R.id.mapView);
  mapView.setBuiltInZoomControls(true);
  stopNumberField=(EditText)findViewById(R.id.stopNumber);
  routeNumberField=(EditText)findViewById(R.id.routeNumber);
  stop=(Stop)getIntent().getSerializableExtra(""String_Node_Str"");
  route=(Route)getIntent().getSerializableExtra(""String_Node_Str"");
  if (stop != null) {
  }
 else   if (savedInstanceState != null) {
    result=(GetNextTripsForStopResult)savedInstanceState.getSerializable(""String_Node_Str"");
    stop=(Stop)savedInstanceState.getSerializable(""String_Node_Str"");
    route=(Route)savedInstanceState.getSerializable(""String_Node_Str"");
  }
  stopNumberField.setText(stop.getNumber());
  routeNumberField.setText(route.getNumber());
  if (result != null) {
    displayGetNextTripsForStopResult(result);
  }
 else {
    MapController mapController=mapView.getController();
    mapController.zoomToSpan((globalMaxLatitude - globalMinLatitude),(globalMaxLongitude - globalMinLongitude));
    mapController.setCenter(new GeoPoint((globalMaxLatitude + globalMinLatitude) / 2,(globalMaxLongitude + globalMinLongitude) / 2));
  }
  final Button updateButton=(Button)findViewById(R.id.updateButton);
  updateButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      updateButton.setEnabled(false);
      InputMethodManager imm=(InputMethodManager)BusFollowerActivity.this.getSystemService(Context.INPUT_METHOD_SERVICE);
      imm.hideSoftInputFromWindow(updateButton.getWindowToken(),0);
      new Thread(new Runnable(){
        public void run(){
          String errorString;
          try {
            result=dataFetcher.getNextTripsForStop(BusFollowerActivity.this,db,stop.getNumber(),route.getNumber());
            errorString=Util.getErrorString(BusFollowerActivity.this,result.getError());
          }
 catch (          IOException e) {
            errorString=BusFollowerActivity.this.getString(R.string.server_error);
          }
catch (          XmlPullParserException e) {
            errorString=BusFollowerActivity.this.getString(R.string.invalid_response);
          }
catch (          IllegalArgumentException e) {
            errorString=e.getMessage();
          }
          final String errorStringFinal=errorString;
          if (errorString != null) {
            BusFollowerActivity.this.runOnUiThread(new Runnable(){
              public void run(){
                AlertDialog.Builder builder=new AlertDialog.Builder(BusFollowerActivity.this);
                builder.setTitle(R.string.error).setMessage(errorStringFinal).setNegativeButton(BusFollowerActivity.this.getString(R.string.ok),new DialogInterface.OnClickListener(){
                  public void onClick(                  DialogInterface dialog,                  int id){
                    dialog.cancel();
                  }
                }
);
                AlertDialog alert=builder.create();
                alert.show();
                updateButton.setEnabled(true);
              }
            }
);
            return;
          }
          BusFollowerActivity.this.displayGetNextTripsForStopResult(result);
          mapView.post(new Runnable(){
            public void run(){
              mapView.invalidate();
              updateButton.setEnabled(true);
            }
          }
);
        }
      }
).start();
    }
  }
);
  routeNumberField.setOnEditorActionListener(new TextView.OnEditorActionListener(){
    @Override public boolean onEditorAction(    TextView v,    int actionId,    KeyEvent event){
      if (actionId == EditorInfo.IME_ACTION_DONE) {
        updateButton.performClick();
        return true;
      }
      return false;
    }
  }
);
}","/** 
 * Called when the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.busfollower);
  dataFetcher=new OCTranspoDataFetcher(this);
  db=(new DatabaseHelper(this)).getReadableDatabase();
  mapView=(MapView)findViewById(R.id.mapView);
  mapView.setBuiltInZoomControls(true);
  stopNumberField=(EditText)findViewById(R.id.stopNumber);
  routeNumberField=(EditText)findViewById(R.id.routeNumber);
  stop=(Stop)getIntent().getSerializableExtra(""String_Node_Str"");
  route=(Route)getIntent().getSerializableExtra(""String_Node_Str"");
  if (savedInstanceState != null) {
    result=(GetNextTripsForStopResult)savedInstanceState.getSerializable(""String_Node_Str"");
    stop=(Stop)savedInstanceState.getSerializable(""String_Node_Str"");
    route=(Route)savedInstanceState.getSerializable(""String_Node_Str"");
  }
  stopNumberField.setText(stop.getNumber());
  routeNumberField.setText(route.getNumber());
  if (result != null) {
    displayGetNextTripsForStopResult(result);
  }
 else {
    MapController mapController=mapView.getController();
    mapController.zoomToSpan((globalMaxLatitude - globalMinLatitude),(globalMaxLongitude - globalMinLongitude));
    mapController.setCenter(new GeoPoint((globalMaxLatitude + globalMinLatitude) / 2,(globalMaxLongitude + globalMinLongitude) / 2));
  }
  final Button updateButton=(Button)findViewById(R.id.updateButton);
  updateButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      updateButton.setEnabled(false);
      InputMethodManager imm=(InputMethodManager)BusFollowerActivity.this.getSystemService(Context.INPUT_METHOD_SERVICE);
      imm.hideSoftInputFromWindow(updateButton.getWindowToken(),0);
      new Thread(new Runnable(){
        public void run(){
          String errorString;
          try {
            result=dataFetcher.getNextTripsForStop(BusFollowerActivity.this,db,stop.getNumber(),route.getNumber());
            errorString=Util.getErrorString(BusFollowerActivity.this,result.getError());
          }
 catch (          IOException e) {
            errorString=BusFollowerActivity.this.getString(R.string.server_error);
          }
catch (          XmlPullParserException e) {
            errorString=BusFollowerActivity.this.getString(R.string.invalid_response);
          }
catch (          IllegalArgumentException e) {
            errorString=e.getMessage();
          }
          final String errorStringFinal=errorString;
          if (errorString != null) {
            BusFollowerActivity.this.runOnUiThread(new Runnable(){
              public void run(){
                AlertDialog.Builder builder=new AlertDialog.Builder(BusFollowerActivity.this);
                builder.setTitle(R.string.error).setMessage(errorStringFinal).setNegativeButton(BusFollowerActivity.this.getString(R.string.ok),new DialogInterface.OnClickListener(){
                  public void onClick(                  DialogInterface dialog,                  int id){
                    dialog.cancel();
                  }
                }
);
                AlertDialog alert=builder.create();
                alert.show();
                updateButton.setEnabled(true);
              }
            }
);
            return;
          }
          BusFollowerActivity.this.displayGetNextTripsForStopResult(result);
          mapView.post(new Runnable(){
            public void run(){
              mapView.invalidate();
              updateButton.setEnabled(true);
            }
          }
);
        }
      }
).start();
    }
  }
);
  routeNumberField.setOnEditorActionListener(new TextView.OnEditorActionListener(){
    @Override public boolean onEditorAction(    TextView v,    int actionId,    KeyEvent event){
      if (actionId == EditorInfo.IME_ACTION_DONE) {
        updateButton.performClick();
        return true;
      }
      return false;
    }
  }
);
}"
50892,"/** 
 * Called when the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.main);
  dataFetcher=new OCTranspoDataFetcher(this);
  Log.d(TAG,""String_Node_Str"");
  db=(new DatabaseHelper(this)).getReadableDatabase();
  Log.d(TAG,""String_Node_Str"");
  mapView=(MapView)findViewById(R.id.mapView);
  mapView.setBuiltInZoomControls(true);
  stopNumberField=(EditText)findViewById(R.id.stopNumber);
  routeNumberField=(EditText)findViewById(R.id.routeNumber);
  if (savedInstanceState != null) {
    result=(GetNextTripsForStopResult)savedInstanceState.getSerializable(""String_Node_Str"");
    stopNumberField.setText(savedInstanceState.getString(""String_Node_Str""));
    routeNumberField.setText(savedInstanceState.getString(""String_Node_Str""));
  }
  if (result != null) {
    GeoPoint stopLocation=null;
    try {
      getStopLocation(result.getStopNumber());
    }
 catch (    IllegalArgumentException e) {
    }
    displayGetNextTripsForStopResult(result,stopLocation);
  }
 else {
    MapController mapController=mapView.getController();
    mapController.zoomToSpan((globalMaxLatitude - globalMinLatitude),(globalMaxLongitude - globalMinLongitude));
    mapController.setCenter(new GeoPoint((globalMaxLatitude + globalMinLatitude) / 2,(globalMaxLongitude + globalMinLongitude) / 2));
  }
  final Button updateButton=(Button)findViewById(R.id.updateButton);
  updateButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      updateButton.setEnabled(false);
      InputMethodManager imm=(InputMethodManager)BusFollowerActivity.this.getSystemService(Context.INPUT_METHOD_SERVICE);
      imm.hideSoftInputFromWindow(updateButton.getWindowToken(),0);
      final String stopNumber=stopNumberField.getText().toString();
      final String routeNumber=routeNumberField.getText().toString();
      new Thread(new Runnable(){
        public void run(){
          GeoPoint stopLocation=null;
          String errorString;
          try {
            stopLocation=getStopLocation(stopNumber);
            result=dataFetcher.getNextTripsForStop(stopNumber,routeNumber);
            errorString=getErrorString(result.getError());
          }
 catch (          IOException e) {
            errorString=BusFollowerActivity.this.getString(R.string.server_error);
          }
catch (          XmlPullParserException e) {
            errorString=BusFollowerActivity.this.getString(R.string.invalid_response);
          }
catch (          IllegalArgumentException e) {
            errorString=e.getMessage();
          }
          final String errorStringFinal=errorString;
          if (errorString != null) {
            BusFollowerActivity.this.runOnUiThread(new Runnable(){
              public void run(){
                AlertDialog.Builder builder=new AlertDialog.Builder(BusFollowerActivity.this);
                builder.setTitle(R.string.error).setMessage(errorStringFinal).setNegativeButton(BusFollowerActivity.this.getString(R.string.ok),new DialogInterface.OnClickListener(){
                  public void onClick(                  DialogInterface dialog,                  int id){
                    dialog.cancel();
                  }
                }
);
                AlertDialog alert=builder.create();
                alert.show();
                updateButton.setEnabled(true);
              }
            }
);
            return;
          }
          BusFollowerActivity.this.displayGetNextTripsForStopResult(result,stopLocation);
          mapView.post(new Runnable(){
            public void run(){
              mapView.invalidate();
              updateButton.setEnabled(true);
            }
          }
);
        }
      }
).start();
    }
  }
);
  routeNumberField.setOnEditorActionListener(new TextView.OnEditorActionListener(){
    @Override public boolean onEditorAction(    TextView v,    int actionId,    KeyEvent event){
      if (actionId == EditorInfo.IME_ACTION_DONE) {
        updateButton.performClick();
        return true;
      }
      return false;
    }
  }
);
}","/** 
 * Called when the activity is first created. 
 */
@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.main);
  dataFetcher=new OCTranspoDataFetcher(this);
  Log.d(TAG,""String_Node_Str"");
  db=(new DatabaseHelper(this)).getReadableDatabase();
  Log.d(TAG,""String_Node_Str"");
  mapView=(MapView)findViewById(R.id.mapView);
  mapView.setBuiltInZoomControls(true);
  stopNumberField=(EditText)findViewById(R.id.stopNumber);
  routeNumberField=(EditText)findViewById(R.id.routeNumber);
  if (savedInstanceState != null) {
    result=(GetNextTripsForStopResult)savedInstanceState.getSerializable(""String_Node_Str"");
    stopNumberField.setText(savedInstanceState.getString(""String_Node_Str""));
    routeNumberField.setText(savedInstanceState.getString(""String_Node_Str""));
  }
  if (result != null) {
    GeoPoint stopLocation=null;
    try {
      stopLocation=getStopLocation(result.getStopNumber());
    }
 catch (    IllegalArgumentException e) {
    }
    displayGetNextTripsForStopResult(result,stopLocation);
  }
 else {
    MapController mapController=mapView.getController();
    mapController.zoomToSpan((globalMaxLatitude - globalMinLatitude),(globalMaxLongitude - globalMinLongitude));
    mapController.setCenter(new GeoPoint((globalMaxLatitude + globalMinLatitude) / 2,(globalMaxLongitude + globalMinLongitude) / 2));
  }
  final Button updateButton=(Button)findViewById(R.id.updateButton);
  updateButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      updateButton.setEnabled(false);
      InputMethodManager imm=(InputMethodManager)BusFollowerActivity.this.getSystemService(Context.INPUT_METHOD_SERVICE);
      imm.hideSoftInputFromWindow(updateButton.getWindowToken(),0);
      final String stopNumber=stopNumberField.getText().toString();
      final String routeNumber=routeNumberField.getText().toString();
      new Thread(new Runnable(){
        public void run(){
          GeoPoint stopLocation=null;
          String errorString;
          try {
            stopLocation=getStopLocation(stopNumber);
            result=dataFetcher.getNextTripsForStop(stopNumber,routeNumber);
            errorString=getErrorString(result.getError());
          }
 catch (          IOException e) {
            errorString=BusFollowerActivity.this.getString(R.string.server_error);
          }
catch (          XmlPullParserException e) {
            errorString=BusFollowerActivity.this.getString(R.string.invalid_response);
          }
catch (          IllegalArgumentException e) {
            errorString=e.getMessage();
          }
          final String errorStringFinal=errorString;
          if (errorString != null) {
            BusFollowerActivity.this.runOnUiThread(new Runnable(){
              public void run(){
                AlertDialog.Builder builder=new AlertDialog.Builder(BusFollowerActivity.this);
                builder.setTitle(R.string.error).setMessage(errorStringFinal).setNegativeButton(BusFollowerActivity.this.getString(R.string.ok),new DialogInterface.OnClickListener(){
                  public void onClick(                  DialogInterface dialog,                  int id){
                    dialog.cancel();
                  }
                }
);
                AlertDialog alert=builder.create();
                alert.show();
                updateButton.setEnabled(true);
              }
            }
);
            return;
          }
          BusFollowerActivity.this.displayGetNextTripsForStopResult(result,stopLocation);
          mapView.post(new Runnable(){
            public void run(){
              mapView.invalidate();
              updateButton.setEnabled(true);
            }
          }
);
        }
      }
).start();
    }
  }
);
  routeNumberField.setOnEditorActionListener(new TextView.OnEditorActionListener(){
    @Override public boolean onEditorAction(    TextView v,    int actionId,    KeyEvent event){
      if (actionId == EditorInfo.IME_ACTION_DONE) {
        updateButton.performClick();
        return true;
      }
      return false;
    }
  }
);
}"
50893,"@Override public @Bean Mongo mongo() throws PhrescoException {
  Mongo mongo=null;
  try {
    mongo=new Mongo(""String_Node_Str"",config.getDbPort());
  }
 catch (  UnknownHostException e) {
    throw new PhrescoException(EX_PHEX00002);
  }
catch (  MongoException e) {
    throw new PhrescoException(EX_PHEX00003);
  }
  return mongo;
}","@Override public @Bean Mongo mongo() throws PhrescoException {
  Mongo mongo=null;
  try {
    mongo=new Mongo(config.getDbHost(),config.getDbPort());
  }
 catch (  UnknownHostException e) {
    throw new PhrescoException(EX_PHEX00002);
  }
catch (  MongoException e) {
    throw new PhrescoException(EX_PHEX00003);
  }
  return mongo;
}"
50894,"public void setContactNumber(String contactNumber){
  this.contactNumber=contactNumber;
}","/** 
 * @param contactNumber
 */
public void setContactNumber(String contactNumber){
  this.contactNumber=contactNumber;
}"
50895,"public void setCountry(String country){
  this.country=country;
}","/** 
 * @param country
 */
public void setCountry(String country){
  this.country=country;
}"
50896,"public String getHelpText(){
  return helpText;
}","/** 
 * @return
 */
public String getHelpText(){
  return helpText;
}"
50897,"public String getCountry(){
  return country;
}","/** 
 * @return
 */
public String getCountry(){
  return country;
}"
50898,"public Customer(String id,String name,String description){
  this.id=id;
  this.name=name;
  this.description=description;
}","/** 
 * @param id
 * @param name
 * @param description
 */
public Customer(String id,String name,String description){
  super(id,name,description);
}"
50899,"public void setEmailId(String emailId){
  this.emailId=emailId;
}","/** 
 * @param emailId
 */
public void setEmailId(String emailId){
  this.emailId=emailId;
}"
50900,"public void setValidFrom(String validFrom){
  this.validFrom=validFrom;
}","/** 
 * @param validFrom
 */
public void setValidFrom(Date validFrom){
  this.validFrom=validFrom;
}"
50901,"public String getEmailId(){
  return emailId;
}","/** 
 * @return
 */
public String getEmailId(){
  return emailId;
}"
50902,"public int getStatus(){
  return status;
}","/** 
 * @return
 */
public CustomerStatus getStatus(){
  return status;
}"
50903,"public String getZipcode(){
  return zipcode;
}","/** 
 * @return
 */
public String getZipcode(){
  return zipcode;
}"
50904,"public void setFax(String fax){
  this.fax=fax;
}","/** 
 * @param fax
 */
public void setFax(String fax){
  this.fax=fax;
}"
50905,"public String getAddress(){
  return address;
}","/** 
 * @return
 */
public String getAddress(){
  return address;
}"
50906,"public String getContactNumber(){
  return contactNumber;
}","/** 
 * @return
 */
public String getContactNumber(){
  return contactNumber;
}"
50907,"public void setAddress(String address){
  this.address=address;
}","/** 
 * @param address
 */
public void setAddress(String address){
  this.address=address;
}"
50908,"public void setValidUpto(String validUpto){
  this.validUpto=validUpto;
}","/** 
 * @param validUpto
 */
public void setValidUpto(Date validUpto){
  this.validUpto=validUpto;
}"
50909,"public void setRepoURL(String repoURL){
  this.repoURL=repoURL;
}","/** 
 * @param repoURL
 */
public void setRepoURL(URL repoURL){
  this.repoURL=repoURL;
}"
50910,"public String getValidFrom(){
  return validFrom;
}","/** 
 * @return
 */
public Date getValidFrom(){
  return validFrom;
}"
50911,"public void setType(int type){
  this.type=type;
}","/** 
 * @param type
 */
public void setType(int type){
  this.type=type;
}"
50912,"public String getRepoURL(){
  return repoURL;
}","/** 
 * @return
 */
public URL getRepoURL(){
  return repoURL;
}"
50913,"public void setStatus(int status){
  this.status=status;
}","/** 
 * @param status
 */
public void setStatus(CustomerStatus status){
  this.status=status;
}"
50914,"public String getFax(){
  return fax;
}","/** 
 * @return
 */
public String getFax(){
  return fax;
}"
50915,"public void setHelpText(String helpText){
  this.helpText=helpText;
}","/** 
 * @param helpText
 */
public void setHelpText(String helpText){
  this.helpText=helpText;
}"
50916,"public void setZipcode(String zipcode){
  this.zipcode=zipcode;
}","/** 
 * @param zipcode
 */
public void setZipcode(String zipcode){
  this.zipcode=zipcode;
}"
50917,"public String getState(){
  return state;
}","/** 
 * @return
 */
public String getState(){
  return state;
}"
50918,"public int getType(){
  return type;
}","/** 
 * @return
 */
public int getType(){
  return type;
}"
50919,"public void setState(String state){
  this.state=state;
}","/** 
 * @param state
 */
public void setState(String state){
  this.state=state;
}"
50920,"@Override public String toString(){
  return ""String_Node_Str"" + emailId + ""String_Node_Str""+ address+ ""String_Node_Str""+ country+ ""String_Node_Str""+ state+ ""String_Node_Str""+ zipcode+ ""String_Node_Str""+ contactNumber+ ""String_Node_Str""+ fax+ ""String_Node_Str""+ helpText+ ""String_Node_Str""+ type+ ""String_Node_Str""+ validFrom+ ""String_Node_Str""+ validUpto+ ""String_Node_Str""+ repoURL+ ""String_Node_Str""+ status+ ""String_Node_Str""+ id+ ""String_Node_Str""+ name+ ""String_Node_Str""+ description+ ""String_Node_Str""+ creationDate+ ""String_Node_Str"";
}","public String toString(){
  return new ToStringBuilder(this,ToStringStyle.DEFAULT_STYLE).append(super.toString()).append(""String_Node_Str"",emailId).append(""String_Node_Str"",address).append(""String_Node_Str"",country).append(""String_Node_Str"",state).append(""String_Node_Str"",zipcode).append(""String_Node_Str"",contactNumber).append(""String_Node_Str"",fax).append(""String_Node_Str"",helpText).append(""String_Node_Str"",validFrom).append(""String_Node_Str"",validUpto).append(""String_Node_Str"",repoURL).append(""String_Node_Str"",status).append(""String_Node_Str"",type).toString();
}"
50921,"public String getValidUpto(){
  return validUpto;
}","/** 
 * @return
 */
public Date getValidUpto(){
  return validUpto;
}"
50922,"public void setName(String name){
  this.name=name;
}","/** 
 * @param name
 */
public void setName(String name){
  this.name=name;
}"
50923,"public String getCreationDate(){
  return creationDate;
}","/** 
 * @return
 */
public Date getCreationDate(){
  return creationDate;
}"
50924,"public String getName(){
  return name;
}","/** 
 * @return
 */
public String getName(){
  return name;
}"
50925,"public void setCreationDate(String creationDate){
  this.creationDate=creationDate;
}","/** 
 * @param creationDate
 */
public void setCreationDate(Date creationDate){
  this.creationDate=creationDate;
}"
50926,"public Element(String name,String description){
  super();
  this.name=name;
  this.description=description;
}","protected Element(String name,String description){
  super();
  this.name=name;
  this.description=description;
}"
50927,"public void setId(String id){
  this.id=id;
}","/** 
 * @param id
 */
public void setId(String id){
  this.id=id;
}"
50928,"public String getId(){
  return id;
}","/** 
 * @return
 */
public String getId(){
  return id;
}"
50929,"public void setDescription(String description){
  this.description=description;
}","/** 
 * @param description
 */
public void setDescription(String description){
  this.description=description;
}"
50930,"public String getDescription(){
  return description;
}","/** 
 * @return
 */
public String getDescription(){
  return description;
}"
50931,"public Permission(String name,String description){
  super(name,description);
}","/** 
 * @param name
 * @param description
 */
public Permission(String name,String description){
  super(name,description);
}"
50932,"@Override public String toString(){
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"");
  builder.append(id);
  builder.append(""String_Node_Str"");
  builder.append(name);
  builder.append(""String_Node_Str"");
  builder.append(description);
  builder.append(""String_Node_Str"");
  builder.append(creationDate);
  builder.append(""String_Node_Str"");
  return builder.toString();
}","public String toString(){
  return new ToStringBuilder(this,ToStringStyle.DEFAULT_STYLE).append(super.toString()).toString();
}"
50933,"public Role(String name,String description){
  super(name,description);
}","/** 
 * @param name
 * @param description
 */
public Role(String name,String description){
  super(name,description);
}"
50934,"public List<Permission> getPermissions(){
  return permissions;
}","/** 
 * @return
 */
public List<Permission> getPermissions(){
  return permissions;
}"
50935,"@Override public String toString(){
  StringBuilder builder=new StringBuilder();
  builder.append(""String_Node_Str"");
  builder.append(id);
  builder.append(""String_Node_Str"");
  builder.append(permissions);
  builder.append(""String_Node_Str"");
  builder.append(name);
  builder.append(""String_Node_Str"");
  builder.append(description);
  builder.append(""String_Node_Str"");
  builder.append(creationDate);
  builder.append(""String_Node_Str"");
  return builder.toString();
}","public String toString(){
  return new ToStringBuilder(this,ToStringStyle.DEFAULT_STYLE).append(super.toString()).append(""String_Node_Str"",permissions).toString();
}"
50936,"public void setPermissions(List<Permission> roles){
  this.permissions=roles;
}","/** 
 * @param roles
 */
public void setPermissions(List<Permission> roles){
  this.permissions=roles;
}"
50937,"public void setId(String id){
  this.id=id;
}","/** 
 * @param id
 */
public void setId(String id){
  this.id=id;
}"
50938,"public String getMessage(){
  return message;
}","/** 
 * @return
 */
public String getMessage(){
  return message;
}"
50939,"public String getId(){
  return id;
}","/** 
 * @return
 */
public String getId(){
  return id;
}"
50940,"@Override public String toString(){
  return ""String_Node_Str"" + id + ""String_Node_Str""+ message+ ""String_Node_Str"";
}","public String toString(){
  return new ToStringBuilder(this,ToStringStyle.DEFAULT_STYLE).append(""String_Node_Str"",id).append(""String_Node_Str"",message).toString();
}"
50941,"public void setMessage(String message){
  this.message=message;
}","/** 
 * @param message
 */
public void setMessage(String message){
  this.message=message;
}"
50942,"/** 
 * Returns the list of modules
 * @return
 */
@GET @Path(REST_API_MODULES) @Produces(MediaType.APPLICATION_JSON) public Response findModules(@QueryParam(REST_QUERY_TECHID) String techId,@QueryParam(REST_QUERY_TYPE) String type,@QueryParam(REST_QUERY_CUSTOMERID) String customerId){
  if (isDebugEnabled) {
    S_LOGGER.debug(""String_Node_Str"" + techId + type);
  }
  List<ModuleGroup> foundModules=new ArrayList<ModuleGroup>();
  try {
    if (techId != null && type != null && customerId != null && type.equals(REST_QUERY_TYPE_MODULE)) {
      Criteria criteria=Criteria.where(REST_QUERY_TECHID).is(techId).and(REST_QUERY_TYPE).is(REST_QUERY_TYPE_MODULE).and(REST_QUERY_CUSTOMERID).is(DEFAULT_CUSTOMER_NAME);
      foundModules=mongoOperation.find(MODULES_COLLECTION_NAME,new Query(criteria),ModuleGroup.class);
      if (!customerId.equals(DEFAULT_CUSTOMER_NAME)) {
        Criteria customerCriteria=Criteria.where(REST_QUERY_TECHID).is(techId).and(REST_QUERY_TYPE).is(REST_QUERY_TYPE_MODULE).and(REST_QUERY_CUSTOMERID).is(customerId);
        foundModules.addAll(mongoOperation.find(MODULES_COLLECTION_NAME,new Query(customerCriteria),ModuleGroup.class));
      }
      return Response.status(Response.Status.OK).entity(foundModules).build();
    }
    if (techId != null && type != null && customerId != null && type.equals(REST_QUERY_TYPE_JS)) {
      Criteria criteria=Criteria.where(REST_QUERY_TECHID).is(techId).and(REST_QUERY_TYPE).is(REST_QUERY_TYPE_MODULE).and(REST_QUERY_CUSTOMERID).is(DEFAULT_CUSTOMER_NAME);
      foundModules=mongoOperation.find(MODULES_COLLECTION_NAME,new Query(criteria),ModuleGroup.class);
      if (!customerId.equals(DEFAULT_CUSTOMER_NAME)) {
        Criteria customerCriteria=Criteria.where(REST_QUERY_TECHID).is(techId).and(REST_QUERY_TYPE).is(REST_QUERY_TYPE_MODULE).and(REST_QUERY_CUSTOMERID).is(customerId);
        foundModules.addAll(mongoOperation.find(MODULES_COLLECTION_NAME,new Query(customerCriteria),ModuleGroup.class));
      }
      return Response.status(Response.Status.OK).entity(foundModules).build();
    }
    if (techId != null && type != null) {
      foundModules=mongoOperation.find(MODULES_COLLECTION_NAME,new Query(Criteria.where(REST_QUERY_CUSTOMERID).is(DEFAULT_CUSTOMER_NAME)),ModuleGroup.class);
      return Response.status(Response.Status.OK).entity(foundModules).build();
    }
  }
 catch (  Exception e) {
    throw new PhrescoWebServiceException(e,EX_PHEX00005,MODULES_COLLECTION_NAME);
  }
  return Response.status(Response.Status.BAD_REQUEST).build();
}","/** 
 * Returns the list of modules
 * @return
 */
@GET @Path(REST_API_MODULES) @Produces(MediaType.APPLICATION_JSON) public Response findModules(@QueryParam(REST_QUERY_TECHID) String techId,@QueryParam(REST_QUERY_TYPE) String type,@QueryParam(REST_QUERY_CUSTOMERID) String customerId){
  if (isDebugEnabled) {
    S_LOGGER.debug(""String_Node_Str"" + techId + type);
  }
  List<ModuleGroup> foundModules=new ArrayList<ModuleGroup>();
  try {
    if (techId != null && type != null && customerId != null && type.equals(REST_QUERY_TYPE_MODULE)) {
      Criteria criteria=Criteria.where(REST_QUERY_TECHID).is(techId).and(REST_QUERY_TYPE).is(REST_QUERY_TYPE_MODULE).and(REST_QUERY_CUSTOMERID).is(DEFAULT_CUSTOMER_NAME);
      foundModules=mongoOperation.find(MODULES_COLLECTION_NAME,new Query(criteria),ModuleGroup.class);
      if (!customerId.equals(DEFAULT_CUSTOMER_NAME)) {
        Criteria customerCriteria=Criteria.where(REST_QUERY_TECHID).is(techId).and(REST_QUERY_TYPE).is(REST_QUERY_TYPE_MODULE).and(REST_QUERY_CUSTOMERID).is(customerId);
        foundModules.addAll(mongoOperation.find(MODULES_COLLECTION_NAME,new Query(customerCriteria),ModuleGroup.class));
      }
      return Response.status(Response.Status.OK).entity(foundModules).build();
    }
    if (techId != null && type != null && customerId != null && type.equals(REST_QUERY_TYPE_JS)) {
      Criteria criteria=Criteria.where(REST_QUERY_TECHID).is(techId).and(REST_QUERY_TYPE).is(REST_QUERY_TYPE_JS).and(REST_QUERY_CUSTOMERID).is(DEFAULT_CUSTOMER_NAME);
      foundModules=mongoOperation.find(MODULES_COLLECTION_NAME,new Query(criteria),ModuleGroup.class);
      if (!customerId.equals(DEFAULT_CUSTOMER_NAME)) {
        Criteria customerCriteria=Criteria.where(REST_QUERY_TECHID).is(techId).and(REST_QUERY_TYPE).is(REST_QUERY_TYPE_JS).and(REST_QUERY_CUSTOMERID).is(customerId);
        foundModules.addAll(mongoOperation.find(MODULES_COLLECTION_NAME,new Query(customerCriteria),ModuleGroup.class));
      }
      return Response.status(Response.Status.OK).entity(foundModules).build();
    }
    if (techId != null && type != null) {
      foundModules=mongoOperation.find(MODULES_COLLECTION_NAME,new Query(Criteria.where(REST_QUERY_CUSTOMERID).is(DEFAULT_CUSTOMER_NAME)),ModuleGroup.class);
      return Response.status(Response.Status.OK).entity(foundModules).build();
    }
  }
 catch (  Exception e) {
    throw new PhrescoWebServiceException(e,EX_PHEX00005,MODULES_COLLECTION_NAME);
  }
  return Response.status(Response.Status.BAD_REQUEST).build();
}"
50943,"private void renameWar(String context) throws MojoExecutionException {
  String contextName=context + ""String_Node_Str"";
  String warFileName=""String_Node_Str"";
  String[] list=tempDir.list(new JDWarFileNameFilter());
  if (list.length > 0) {
    warFileName=list[0];
    if (!warFileName.contains(contextName)) {
      File oldWar=new File(tempDir.getPath() + ""String_Node_Str"" + warFileName);
      File newWar=new File(tempDir.getPath() + ""String_Node_Str"" + contextName);
      oldWar.renameTo(newWar);
    }
  }
}","private void renameWar(String context) throws MojoExecutionException {
  String contextName=context + ""String_Node_Str"";
  String warFileName=""String_Node_Str"";
  String[] list=tempDir.list(new JDWarFileNameFilter());
  if (list.length > 0) {
    warFileName=list[0];
    if (!warFileName.equals(contextName)) {
      File oldWar=new File(tempDir.getPath() + ""String_Node_Str"" + warFileName);
      File newWar=new File(tempDir.getPath() + ""String_Node_Str"" + contextName);
      oldWar.renameTo(newWar);
    }
  }
}"
50944,"private void addJBossPlugin(File pomFile) throws PhrescoException {
  try {
    PomProcessor pomProcessor=new PomProcessor(pomFile);
    Plugin plugin=pomProcessor.getPlugin(""String_Node_Str"",""String_Node_Str"");
    if (plugin != null) {
      return;
    }
    pomProcessor.addPlugin(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    List<Element> configList=new ArrayList<Element>();
    DocumentBuilderFactory dbfac=DocumentBuilderFactory.newInstance();
    DocumentBuilder docBuilder=dbfac.newDocumentBuilder();
    Document doc=docBuilder.newDocument();
    Element containerElement=doc.createElement(""String_Node_Str"");
    Element containerId=doc.createElement(""String_Node_Str"");
    containerId.setTextContent(""String_Node_Str"");
    containerElement.appendChild(containerId);
    Element type=doc.createElement(""String_Node_Str"");
    type.setTextContent(""String_Node_Str"");
    containerElement.appendChild(type);
    Element home=doc.createElement(""String_Node_Str"");
    home.setTextContent(""String_Node_Str"");
    containerElement.appendChild(home);
    Element configurationElement=doc.createElement(""String_Node_Str"");
    Element innerType=doc.createElement(""String_Node_Str"");
    innerType.setTextContent(""String_Node_Str"");
    configurationElement.appendChild(innerType);
    Element propertyElement=doc.createElement(""String_Node_Str"");
    configurationElement.appendChild(propertyElement);
    Element cargoHome=doc.createElement(""String_Node_Str"");
    cargoHome.setTextContent(""String_Node_Str"");
    propertyElement.appendChild(cargoHome);
    Element cargoMgmtPort=doc.createElement(""String_Node_Str"");
    cargoMgmtPort.setTextContent(""String_Node_Str"");
    propertyElement.appendChild(cargoMgmtPort);
    Element cargoRmiPort=doc.createElement(""String_Node_Str"");
    cargoRmiPort.setTextContent(""String_Node_Str"");
    propertyElement.appendChild(cargoRmiPort);
    Element cargoUserName=doc.createElement(""String_Node_Str"");
    cargoUserName.setTextContent(""String_Node_Str"");
    propertyElement.appendChild(cargoUserName);
    Element cargoPwd=doc.createElement(""String_Node_Str"");
    cargoPwd.setTextContent(""String_Node_Str"");
    propertyElement.appendChild(cargoPwd);
    configurationElement.appendChild(propertyElement);
    configList.add(containerElement);
    configList.add(configurationElement);
    pomProcessor.addConfiguration(""String_Node_Str"",""String_Node_Str"",configList);
    Dependency dependency=new Dependency();
    dependency.setGroupId(""String_Node_Str"");
    dependency.setArtifactId(""String_Node_Str"");
    dependency.setVersion(""String_Node_Str"");
    pomProcessor.addPluginDependency(""String_Node_Str"",""String_Node_Str"",dependency);
    pomProcessor.save();
  }
 catch (  JAXBException e) {
    throw new PhrescoException(e);
  }
catch (  IOException e) {
    throw new PhrescoException(e);
  }
catch (  ParserConfigurationException e) {
    throw new PhrescoException(e);
  }
catch (  PhrescoPomException e) {
    throw new PhrescoException(e);
  }
}","private void addJBossPlugin(File pomFile) throws PhrescoException {
  try {
    PomProcessor pomProcessor=new PomProcessor(pomFile);
    Plugin plugin=pomProcessor.getPlugin(""String_Node_Str"",""String_Node_Str"");
    if (plugin != null) {
      return;
    }
    pomProcessor.addPlugin(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    List<Element> configList=new ArrayList<Element>();
    DocumentBuilderFactory dbfac=DocumentBuilderFactory.newInstance();
    DocumentBuilder docBuilder=dbfac.newDocumentBuilder();
    Document doc=docBuilder.newDocument();
    Element containerElement=doc.createElement(""String_Node_Str"");
    Element containerId=doc.createElement(""String_Node_Str"");
    containerId.setTextContent(""String_Node_Str"");
    containerElement.appendChild(containerId);
    Element type=doc.createElement(""String_Node_Str"");
    type.setTextContent(""String_Node_Str"");
    containerElement.appendChild(type);
    Element home=doc.createElement(""String_Node_Str"");
    home.setTextContent(""String_Node_Str"");
    containerElement.appendChild(home);
    Element configurationElement=doc.createElement(""String_Node_Str"");
    Element innerType=doc.createElement(""String_Node_Str"");
    innerType.setTextContent(""String_Node_Str"");
    configurationElement.appendChild(innerType);
    Element propertyElement=doc.createElement(""String_Node_Str"");
    configurationElement.appendChild(propertyElement);
    Element cargoHome=doc.createElement(""String_Node_Str"");
    cargoHome.setTextContent(""String_Node_Str"");
    propertyElement.appendChild(cargoHome);
    Element cargoMgmtPort=doc.createElement(""String_Node_Str"");
    cargoMgmtPort.setTextContent(""String_Node_Str"");
    propertyElement.appendChild(cargoMgmtPort);
    Element cargoRmiPort=doc.createElement(""String_Node_Str"");
    cargoRmiPort.setTextContent(""String_Node_Str"");
    propertyElement.appendChild(cargoRmiPort);
    Element cargoUserName=doc.createElement(""String_Node_Str"");
    cargoUserName.setTextContent(""String_Node_Str"");
    propertyElement.appendChild(cargoUserName);
    Element cargoPwd=doc.createElement(""String_Node_Str"");
    cargoPwd.setTextContent(""String_Node_Str"");
    propertyElement.appendChild(cargoPwd);
    configurationElement.appendChild(propertyElement);
    Element deployables=doc.createElement(""String_Node_Str"");
    Element deployable=doc.createElement(""String_Node_Str"");
    deployables.appendChild(deployable);
    Element location=doc.createElement(""String_Node_Str"");
    location.setTextContent(""String_Node_Str"");
    deployable.appendChild(location);
    configurationElement.appendChild(deployables);
    configList.add(containerElement);
    configList.add(configurationElement);
    pomProcessor.addConfiguration(""String_Node_Str"",""String_Node_Str"",configList);
    Dependency dependency=new Dependency();
    dependency.setGroupId(""String_Node_Str"");
    dependency.setArtifactId(""String_Node_Str"");
    dependency.setVersion(""String_Node_Str"");
    pomProcessor.addPluginDependency(""String_Node_Str"",""String_Node_Str"",dependency);
    pomProcessor.save();
  }
 catch (  JAXBException e) {
    throw new PhrescoException(e);
  }
catch (  IOException e) {
    throw new PhrescoException(e);
  }
catch (  ParserConfigurationException e) {
    throw new PhrescoException(e);
  }
catch (  PhrescoPomException e) {
    throw new PhrescoException(e);
  }
}"
50945,"private void deployToWeblogicServer(String serverprotocol,String serverhost,String serverport,String serverusername,String serverpassword) throws MojoExecutionException {
  try {
    StringBuilder sb=new StringBuilder();
    sb.append(MVN_CMD);
    sb.append(STR_SPACE);
    sb.append(WEBLOGIC_GOAL);
    sb.append(STR_SPACE);
    sb.append(SERVER_HOST);
    sb.append(serverhost);
    sb.append(STR_SPACE);
    sb.append(SERVER_PORT);
    sb.append(serverport);
    sb.append(STR_SPACE);
    sb.append(SERVER_USERNAME);
    sb.append(serverusername);
    sb.append(STR_SPACE);
    sb.append(SERVER_PASSWORD);
    sb.append(serverpassword);
    sb.append(STR_SPACE);
    sb.append(SKIP_TESTS);
    Commandline cl=new Commandline(sb.toString());
    cl.setWorkingDirectory(baseDir);
    Process process=cl.execute();
    getLog().info(""String_Node_Str"" + serverprotocol + ""String_Node_Str""+ serverhost+ ""String_Node_Str""+ serverport+ ""String_Node_Str""+ context);
  }
 catch (  CommandLineException e) {
    throw new MojoExecutionException(e.getMessage(),e);
  }
}","private void deployToWeblogicServer(String serverprotocol,String serverhost,String serverport,String serverusername,String serverpassword) throws MojoExecutionException {
  BufferedReader in=null;
  boolean errorParam=false;
  try {
    StringBuilder sb=new StringBuilder();
    sb.append(MVN_CMD);
    sb.append(STR_SPACE);
    sb.append(WEBLOGIC_GOAL);
    sb.append(STR_SPACE);
    sb.append(SERVER_HOST);
    sb.append(serverhost);
    sb.append(STR_SPACE);
    sb.append(SERVER_PORT);
    sb.append(serverport);
    sb.append(STR_SPACE);
    sb.append(SERVER_USERNAME);
    sb.append(serverusername);
    sb.append(STR_SPACE);
    sb.append(SERVER_PASSWORD);
    sb.append(serverpassword);
    sb.append(STR_SPACE);
    sb.append(SKIP_TESTS);
    Commandline cl=new Commandline(sb.toString());
    cl.setWorkingDirectory(baseDir);
    Process process=cl.execute();
    in=new BufferedReader(new InputStreamReader(process.getInputStream()));
    String line=null;
    while ((line=in.readLine()) != null) {
      if (line.startsWith(""String_Node_Str"")) {
        System.out.println(line);
        errorParam=true;
      }
    }
    if (errorParam) {
      throw new MojoExecutionException(""String_Node_Str"");
    }
 else {
      getLog().info(""String_Node_Str"" + serverprotocol + ""String_Node_Str""+ serverhost+ ""String_Node_Str""+ serverport+ ""String_Node_Str""+ context);
    }
  }
 catch (  CommandLineException e) {
    throw new MojoExecutionException(e.getMessage(),e);
  }
catch (  IOException e) {
    throw new MojoExecutionException(e.getMessage(),e);
  }
}"
50946,"private void deployToJbossServer(String serverport,String serverprotocol,String serverhost,String serverusername,String serverpassword) throws MojoExecutionException {
  try {
    StringBuilder sb=new StringBuilder();
    sb.append(MVN_CMD);
    sb.append(STR_SPACE);
    sb.append(JBOSS_GOAL);
    sb.append(STR_SPACE);
    sb.append(SERVER_HOST);
    sb.append(serverhost);
    sb.append(STR_SPACE);
    sb.append(SERVER_USERNAME);
    sb.append(serverusername);
    sb.append(STR_SPACE);
    sb.append(SERVER_PASSWORD);
    sb.append(serverpassword);
    sb.append(STR_SPACE);
    sb.append(SKIP_TESTS);
    Commandline cl=new Commandline(sb.toString());
    cl.setWorkingDirectory(baseDir);
    Process process=cl.execute();
    getLog().info(""String_Node_Str"" + serverprotocol + ""String_Node_Str""+ serverhost+ ""String_Node_Str""+ serverport+ ""String_Node_Str""+ context);
  }
 catch (  CommandLineException e) {
    throw new MojoExecutionException(e.getMessage(),e);
  }
}","private void deployToJbossServer(String serverport,String serverprotocol,String serverhost,String serverusername,String serverpassword) throws MojoExecutionException {
  BufferedReader in=null;
  boolean errorParam=false;
  try {
    StringBuilder sb=new StringBuilder();
    sb.append(MVN_CMD);
    sb.append(STR_SPACE);
    sb.append(JBOSS_GOAL);
    sb.append(STR_SPACE);
    sb.append(SERVER_HOST);
    sb.append(serverhost);
    sb.append(STR_SPACE);
    sb.append(SERVER_USERNAME);
    sb.append(serverusername);
    sb.append(STR_SPACE);
    sb.append(SERVER_PASSWORD);
    sb.append(serverpassword);
    sb.append(STR_SPACE);
    sb.append(SKIP_TESTS);
    Commandline cl=new Commandline(sb.toString());
    cl.setWorkingDirectory(baseDir);
    Process process=cl.execute();
    in=new BufferedReader(new InputStreamReader(process.getInputStream()));
    String line=null;
    while ((line=in.readLine()) != null) {
      if (line.startsWith(""String_Node_Str"")) {
        System.out.println(line);
        errorParam=true;
      }
    }
    if (errorParam) {
      throw new MojoExecutionException(""String_Node_Str"");
    }
 else {
      getLog().info(""String_Node_Str"" + serverprotocol + ""String_Node_Str""+ serverhost+ ""String_Node_Str""+ serverport+ ""String_Node_Str""+ context);
    }
  }
 catch (  CommandLineException e) {
    throw new MojoExecutionException(e.getMessage(),e);
  }
catch (  IOException e) {
    throw new MojoExecutionException(e.getMessage(),e);
  }
}"
50947,"public void execute() throws MojoExecutionException {
  init();
  updateFinalName();
  createDb();
  extractBuild();
  deployToServer();
  cleanUp();
}","public void execute() throws MojoExecutionException {
  init();
  createDb();
  extractBuild();
  deployToServer();
  cleanUp();
}"
50948,"private void deployToTomcatServer(String serverprotocol,String serverhost,String serverport,String serverusername,String serverpassword) throws MojoExecutionException {
  try {
    StringBuilder sb=new StringBuilder();
    sb.append(MVN_CMD);
    sb.append(STR_SPACE);
    sb.append(TOMCAT_GOAL);
    sb.append(STR_SPACE);
    sb.append(SERVER_HOST);
    sb.append(serverhost);
    sb.append(STR_SPACE);
    sb.append(SERVER_PORT);
    sb.append(serverport);
    sb.append(STR_SPACE);
    sb.append(SERVER_USERNAME);
    sb.append(serverusername);
    sb.append(STR_SPACE);
    sb.append(SERVER_PASSWORD);
    sb.append(serverpassword);
    sb.append(STR_SPACE);
    sb.append(SKIP_TESTS);
    Commandline cl=new Commandline(sb.toString());
    cl.setWorkingDirectory(baseDir);
    Process process=cl.execute();
    getLog().info(""String_Node_Str"" + serverprotocol + ""String_Node_Str""+ serverhost+ ""String_Node_Str""+ serverport+ ""String_Node_Str""+ context);
  }
 catch (  CommandLineException e) {
    throw new MojoExecutionException(e.getMessage(),e);
  }
}","private void deployToTomcatServer(String serverprotocol,String serverhost,String serverport,String serverusername,String serverpassword) throws MojoExecutionException {
  BufferedReader in=null;
  boolean errorParam=false;
  try {
    StringBuilder sb=new StringBuilder();
    sb.append(MVN_CMD);
    sb.append(STR_SPACE);
    sb.append(TOMCAT_GOAL);
    sb.append(STR_SPACE);
    sb.append(SERVER_HOST);
    sb.append(serverhost);
    sb.append(STR_SPACE);
    sb.append(SERVER_PORT);
    sb.append(serverport);
    sb.append(STR_SPACE);
    sb.append(SERVER_USERNAME);
    sb.append(serverusername);
    sb.append(STR_SPACE);
    sb.append(SERVER_PASSWORD);
    sb.append(serverpassword);
    sb.append(STR_SPACE);
    sb.append(SKIP_TESTS);
    Commandline cl=new Commandline(sb.toString());
    Process process=cl.execute();
    cl.setWorkingDirectory(baseDir);
    in=new BufferedReader(new InputStreamReader(process.getInputStream()));
    String line=null;
    while ((line=in.readLine()) != null) {
      if (line.startsWith(""String_Node_Str"")) {
        System.out.println(line);
        errorParam=true;
      }
    }
    if (errorParam) {
      throw new MojoExecutionException(""String_Node_Str"");
    }
 else {
      getLog().info(""String_Node_Str"" + serverprotocol + ""String_Node_Str""+ serverhost+ ""String_Node_Str""+ serverport+ ""String_Node_Str""+ context);
    }
  }
 catch (  CommandLineException e) {
    throw new MojoExecutionException(e.getMessage(),e);
  }
catch (  IOException e) {
    throw new MojoExecutionException(e.getMessage(),e);
  }
}"
50949,"public String createAndroidProfile() throws IOException {
  S_LOGGER.debug(""String_Node_Str"");
  boolean hasSigning=false;
  try {
    StringBuilder builder=new StringBuilder(Utility.getProjectHome());
    builder.append(projectCode);
    builder.append(File.separatorChar);
    builder.append(POM_XML);
    File pomPath=new File(builder.toString());
    AndroidPomProcessor processor=new AndroidPomProcessor(pomPath);
    hasSigning=processor.hasSigning();
    String profileId=PROFILE_ID;
    String defaultGoal=GOAL_INSTALL;
    Plugin plugin=new Plugin();
    plugin.setGroupId(ANDROID_PROFILE_PLUGIN_GROUP_ID);
    plugin.setArtifactId(ANDROID_PROFILE_PLUGIN_ARTIFACT_ID);
    plugin.setVersion(ANDROID_PROFILE_PLUGIN_VERSION);
    PluginExecution execution=new PluginExecution();
    execution.setId(ANDROID_EXECUTION_ID);
    Goals goal=new Goals();
    goal.getGoal().add(GOAL_SIGN);
    execution.setGoals(goal);
    execution.setPhase(PHASE_PACKAGE);
    execution.setInherited(TRUE);
    AndroidProfile androidProfile=new AndroidProfile();
    androidProfile.setKeystore(keystore);
    androidProfile.setStorepass(storepass);
    androidProfile.setKeypass(keypass);
    androidProfile.setAlias(alias);
    androidProfile.setVerbose(true);
    androidProfile.setVerify(true);
    DocumentBuilderFactory dbfac=DocumentBuilderFactory.newInstance();
    DocumentBuilder docBuilder=dbfac.newDocumentBuilder();
    Document doc=docBuilder.newDocument();
    List<Element> executionConfig=new ArrayList<Element>();
    executionConfig.add(doc.createElement(ELEMENT_ARCHIVE_DIR));
    Element removeExistSignature=doc.createElement(ELEMENT_REMOVE_EXIST_SIGN);
    Element includeElement=doc.createElement(ELEMENT_INCLUDES);
    Element doNotCheckInBuildInclude=doc.createElement(ELEMENT_INCLUDE);
    doNotCheckInBuildInclude.setTextContent(ELEMENT_BUILD);
    Element doNotCheckinTargetInclude=doc.createElement(ELEMENT_INCLUDE);
    doNotCheckinTargetInclude.setTextContent(ELEMENT_TARGET);
    includeElement.appendChild(doNotCheckInBuildInclude);
    includeElement.appendChild(doNotCheckinTargetInclude);
    executionConfig.add(includeElement);
    removeExistSignature.setTextContent(TRUE);
    executionConfig.add(removeExistSignature);
    Element verbos=doc.createElement(ELEMENT_VERBOS);
    verbos.setTextContent(TRUE);
    executionConfig.add(verbos);
    Element verify=doc.createElement(ELEMENT_VERIFY);
    verbos.setTextContent(TRUE);
    executionConfig.add(verify);
    Configuration configValues=new Configuration();
    configValues.getAny().addAll(executionConfig);
    execution.setConfiguration(configValues);
    List<Element> additionalConfigs=new ArrayList<Element>();
    processor.setProfile(profileId,false,defaultGoal,plugin,androidProfile,execution,null,additionalConfigs);
    processor.save();
    profileCreationStatus=true;
    if (hasSigning) {
      profileCreationMessage=getText(PROFILE_UPDATE_SUCCESS);
    }
 else {
      profileCreationMessage=getText(PROFILE_CREATE_SUCCESS);
    }
  }
 catch (  Exception e) {
    S_LOGGER.error(""String_Node_Str"" + FrameworkUtil.getStackTraceAsString(e));
    profileCreationStatus=false;
    if (hasSigning) {
      profileCreationMessage=getText(PROFILE_UPDATE_ERROR);
    }
 else {
      profileCreationMessage=getText(PROFILE_CREATE_ERROR);
    }
  }
  return SUCCESS;
}","public String createAndroidProfile() throws IOException {
  S_LOGGER.debug(""String_Node_Str"");
  boolean hasSigning=false;
  try {
    StringBuilder builder=new StringBuilder(Utility.getProjectHome());
    builder.append(projectCode);
    builder.append(File.separatorChar);
    builder.append(POM_XML);
    File pomPath=new File(builder.toString());
    AndroidPomProcessor processor=new AndroidPomProcessor(pomPath);
    hasSigning=processor.hasSigning();
    String profileId=PROFILE_ID;
    String defaultGoal=GOAL_INSTALL;
    Plugin plugin=new Plugin();
    plugin.setGroupId(ANDROID_PROFILE_PLUGIN_GROUP_ID);
    plugin.setArtifactId(ANDROID_PROFILE_PLUGIN_ARTIFACT_ID);
    plugin.setVersion(ANDROID_PROFILE_PLUGIN_VERSION);
    PluginExecution execution=new PluginExecution();
    execution.setId(ANDROID_EXECUTION_ID);
    Goals goal=new Goals();
    goal.getGoal().add(GOAL_SIGN);
    execution.setGoals(goal);
    execution.setPhase(PHASE_PACKAGE);
    execution.setInherited(TRUE);
    AndroidProfile androidProfile=new AndroidProfile();
    androidProfile.setKeystore(keystore);
    androidProfile.setStorepass(storepass);
    androidProfile.setKeypass(keypass);
    androidProfile.setAlias(alias);
    androidProfile.setVerbose(true);
    androidProfile.setVerify(true);
    DocumentBuilderFactory dbfac=DocumentBuilderFactory.newInstance();
    DocumentBuilder docBuilder=dbfac.newDocumentBuilder();
    Document doc=docBuilder.newDocument();
    List<Element> executionConfig=new ArrayList<Element>();
    executionConfig.add(doc.createElement(ELEMENT_ARCHIVE_DIR));
    Element removeExistSignature=doc.createElement(ELEMENT_REMOVE_EXIST_SIGN);
    Element includeElement=doc.createElement(ELEMENT_INCLUDES);
    Element doNotCheckInBuildInclude=doc.createElement(ELEMENT_INCLUDE);
    doNotCheckInBuildInclude.setTextContent(ELEMENT_BUILD);
    Element doNotCheckinTargetInclude=doc.createElement(ELEMENT_INCLUDE);
    doNotCheckinTargetInclude.setTextContent(ELEMENT_TARGET);
    includeElement.appendChild(doNotCheckInBuildInclude);
    includeElement.appendChild(doNotCheckinTargetInclude);
    executionConfig.add(includeElement);
    removeExistSignature.setTextContent(TRUE);
    executionConfig.add(removeExistSignature);
    Element verbos=doc.createElement(ELEMENT_VERBOS);
    verbos.setTextContent(TRUE);
    executionConfig.add(verbos);
    Element verify=doc.createElement(ELEMENT_VERIFY);
    verbos.setTextContent(TRUE);
    executionConfig.add(verify);
    Configuration configValues=new Configuration();
    configValues.getAny().addAll(executionConfig);
    execution.setConfiguration(configValues);
    List<Element> additionalConfigs=new ArrayList<Element>();
    processor.setProfile(profileId,defaultGoal,plugin,androidProfile,execution,null,additionalConfigs);
    processor.save();
    profileCreationStatus=true;
    if (hasSigning) {
      profileCreationMessage=getText(PROFILE_UPDATE_SUCCESS);
    }
 else {
      profileCreationMessage=getText(PROFILE_CREATE_SUCCESS);
    }
  }
 catch (  Exception e) {
    S_LOGGER.error(""String_Node_Str"" + FrameworkUtil.getStackTraceAsString(e));
    profileCreationStatus=false;
    if (hasSigning) {
      profileCreationMessage=getText(PROFILE_UPDATE_ERROR);
    }
 else {
      profileCreationMessage=getText(PROFILE_CREATE_ERROR);
    }
  }
  return SUCCESS;
}"
50950,"/** 
 * @param profileId
 * @param activationbyDefault
 * @param defaultGoal
 * @param plugin
 * @param androidProfile
 * @param execution
 * @param goalElement
 * @param additionalConfig
 * @param finalName
 * @throws JAXBException
 * @throws PhrescoPomException
 * @throws ParserConfigurationException
 */
public void setProfile(String profileId,Boolean activationbyDefault,String defaultGoal,Plugin plugin,AndroidProfile androidProfile,PluginExecution execution,Element goalElement,List<Element> additionalConfig) throws JAXBException, PhrescoPomException, ParserConfigurationException {
  BuildBase base=new BuildBase();
  Plugins plugins=new Plugins();
  Executions executions=new Executions();
  Goals goals=new Goals();
  Activation activation=new Activation();
  removeProfile(profileId);
  DocumentBuilderFactory dbfac=DocumentBuilderFactory.newInstance();
  DocumentBuilder docBuilder=dbfac.newDocumentBuilder();
  Document doc=docBuilder.newDocument();
  Element element=doc.createElement(PomConstants.KEYSTORE);
  element.setTextContent(androidProfile.getKeystore());
  additionalConfig.add(element);
  element=doc.createElement(PomConstants.STOREPASS);
  element.setTextContent(androidProfile.getStorepass());
  additionalConfig.add(element);
  element=doc.createElement(PomConstants.KEYPASS);
  element.setTextContent(androidProfile.getKeypass());
  additionalConfig.add(element);
  element=doc.createElement(PomConstants.ALIAS);
  element.setTextContent(androidProfile.getAlias());
  additionalConfig.add(element);
  if (androidProfile.getKeystore() != null && androidProfile.getKeypass() != null && androidProfile.getStorepass() != null) {
    base.setDefaultGoal(defaultGoal);
    base.setFinalName(PomConstants.FINAL_NAME);
    activation.setActiveByDefault(activationbyDefault);
    plugin.setExecutions(executions);
    plugin.setGoals(goals);
    plugin.getGoals().getAny().add(goalElement);
    if (plugin.getGoals().getAny().isEmpty()) {
      plugin.setGoals(null);
    }
    execution.getConfiguration().getAny().addAll(additionalConfig);
    plugin.getExecutions().getExecution().add(execution);
    plugins.getPlugin().add(plugin);
    base.setPlugins(plugins);
    addProfile(profileId,activation,base,null);
    save();
  }
 else {
    throw new PhrescoPomException(POMErrorCode.KEYSTORE_NOT_FOUND);
  }
}","/** 
 * @param profileId
 * @param defaultGoal
 * @param plugin
 * @param androidProfile
 * @param execution
 * @param goalElement
 * @param additionalConfig
 * @param finalName
 * @throws JAXBException
 * @throws PhrescoPomException
 * @throws ParserConfigurationException
 */
public void setProfile(String profileId,String defaultGoal,Plugin plugin,AndroidProfile androidProfile,PluginExecution execution,Element goalElement,List<Element> additionalConfig) throws JAXBException, PhrescoPomException, ParserConfigurationException {
  BuildBase base=new BuildBase();
  Plugins plugins=new Plugins();
  Executions executions=new Executions();
  Goals goals=new Goals();
  removeProfile(profileId);
  DocumentBuilderFactory dbfac=DocumentBuilderFactory.newInstance();
  DocumentBuilder docBuilder=dbfac.newDocumentBuilder();
  Document doc=docBuilder.newDocument();
  Element element=doc.createElement(PomConstants.KEYSTORE);
  element.setTextContent(androidProfile.getKeystore());
  additionalConfig.add(element);
  element=doc.createElement(PomConstants.STOREPASS);
  element.setTextContent(androidProfile.getStorepass());
  additionalConfig.add(element);
  element=doc.createElement(PomConstants.KEYPASS);
  element.setTextContent(androidProfile.getKeypass());
  additionalConfig.add(element);
  element=doc.createElement(PomConstants.ALIAS);
  element.setTextContent(androidProfile.getAlias());
  additionalConfig.add(element);
  if (androidProfile.getKeystore() != null && androidProfile.getKeypass() != null && androidProfile.getStorepass() != null) {
    base.setDefaultGoal(defaultGoal);
    base.setFinalName(PomConstants.FINAL_NAME);
    plugin.setExecutions(executions);
    plugin.setGoals(goals);
    plugin.getGoals().getAny().add(goalElement);
    if (plugin.getGoals().getAny().isEmpty()) {
      plugin.setGoals(null);
    }
    execution.getConfiguration().getAny().addAll(additionalConfig);
    plugin.getExecutions().getExecution().add(execution);
    plugins.getPlugin().add(plugin);
    base.setPlugins(plugins);
    addProfile(profileId,base,null);
    save();
  }
 else {
    throw new PhrescoPomException(POMErrorCode.KEYSTORE_NOT_FOUND);
  }
}"
50951,"public String check(){
  S_LOGGER.debug(""String_Node_Str"");
  StringBuilder sb=new StringBuilder();
  try {
    Properties sysProps=System.getProperties();
    S_LOGGER.debug(""String_Node_Str"" + PHRESCO_FILE_SERVER_PORT_NO + ""String_Node_Str""+ sysProps.getProperty(PHRESCO_FILE_SERVER_PORT_NO));
    String phrescoFileServerNumber=sysProps.getProperty(PHRESCO_FILE_SERVER_PORT_NO);
    FrameworkConfiguration frameworkConfig=PhrescoFrameworkFactory.getFrameworkConfig();
    ProjectAdministrator administrator=PhrescoFrameworkFactory.getProjectAdministrator();
    Project project=administrator.getProject(projectCode);
    String technology=project.getProjectInfo().getTechnology().getId();
    if (TechnologyTypes.IPHONES.contains(technology)) {
      StringBuilder codeValidatePath=new StringBuilder(Utility.getProjectHome());
      codeValidatePath.append(projectCode);
      codeValidatePath.append(File.separatorChar);
      codeValidatePath.append(DO_NOT_CHECKIN_DIR);
      codeValidatePath.append(File.separatorChar);
      codeValidatePath.append(STATIC_ANALYSIS_REPORT);
      codeValidatePath.append(File.separatorChar);
      codeValidatePath.append(INDEX_HTML);
      File indexPath=new File(codeValidatePath.toString());
      if (indexPath.isFile() && StringUtils.isNotEmpty(phrescoFileServerNumber)) {
        sb.append(HTTP_PROTOCOL);
        sb.append(PROTOCOL_POSTFIX);
        sb.append(LOCALHOST);
        sb.append(COLON);
        sb.append(phrescoFileServerNumber);
        sb.append(FORWARD_SLASH);
        sb.append(projectCode);
        sb.append(FORWARD_SLASH);
        sb.append(DO_NOT_CHECKIN_DIR);
        sb.append(FORWARD_SLASH);
        sb.append(STATIC_ANALYSIS_REPORT);
        sb.append(FORWARD_SLASH);
        sb.append(INDEX_HTML);
      }
 else {
        getHttpRequest().setAttribute(REQ_ERROR,getText(FAILURE_CODE_REVIEW));
      }
    }
 else {
      String serverUrl=""String_Node_Str"";
      if (StringUtils.isNotEmpty(frameworkConfig.getSonarUrl())) {
        serverUrl=frameworkConfig.getSonarUrl();
      }
 else {
        serverUrl=getHttpRequest().getRequestURL().toString();
        StringBuilder tobeRemoved=new StringBuilder();
        tobeRemoved.append(getHttpRequest().getContextPath());
        tobeRemoved.append(getHttpRequest().getServletPath());
        Pattern pattern=Pattern.compile(tobeRemoved.toString());
        Matcher matcher=pattern.matcher(serverUrl);
        serverUrl=matcher.replaceAll(""String_Node_Str"");
      }
      StringBuilder builder=new StringBuilder(Utility.getProjectHome());
      builder.append(projectCode);
      builder.append(File.separatorChar);
      builder.append(POM_XML);
      File pomPath=new File(builder.toString());
      PomProcessor processor=new PomProcessor(pomPath);
      String groupId=processor.getModel().getGroupId();
      String artifactId=processor.getModel().getArtifactId();
      sb.append(serverUrl);
      sb.append(frameworkConfig.getSonarReportPath());
      sb.append(groupId);
      sb.append(COLON);
      sb.append(artifactId);
      if (StringUtils.isNotEmpty(report) && !SOURCE_DIR.equals(report)) {
        sb.append(COLON);
        sb.append(report);
      }
      try {
        URL sonarURL=new URL(sb.toString());
        HttpURLConnection connection=(HttpURLConnection)sonarURL.openConnection();
        int responseCode=connection.getResponseCode();
        S_LOGGER.info(""String_Node_Str"" + responseCode);
        S_LOGGER.debug(""String_Node_Str"" + responseCode);
        if (responseCode != 200) {
          getHttpRequest().setAttribute(REQ_ERROR,getText(FAILURE_CODE_REVIEW));
          S_LOGGER.debug(""String_Node_Str"" + APP_CODE);
          return APP_CODE;
        }
      }
 catch (      Exception e) {
        S_LOGGER.error(""String_Node_Str"" + FrameworkUtil.getStackTraceAsString(e));
        new LogErrorReport(e,""String_Node_Str"");
        getHttpRequest().setAttribute(REQ_ERROR,getText(FAILURE_CODE_REVIEW));
        return APP_CODE;
      }
    }
  }
 catch (  Exception e) {
    S_LOGGER.error(""String_Node_Str"" + FrameworkUtil.getStackTraceAsString(e));
  }
  getHttpRequest().setAttribute(REQ_PROJECT_CODE,projectCode);
  getHttpRequest().setAttribute(REQ_SONAR_PATH,sb.toString());
  return APP_CODE;
}","public String check(){
  S_LOGGER.debug(""String_Node_Str"");
  StringBuilder sb=new StringBuilder();
  String technology=null;
  try {
    Properties sysProps=System.getProperties();
    S_LOGGER.debug(""String_Node_Str"" + PHRESCO_FILE_SERVER_PORT_NO + ""String_Node_Str""+ sysProps.getProperty(PHRESCO_FILE_SERVER_PORT_NO));
    String phrescoFileServerNumber=sysProps.getProperty(PHRESCO_FILE_SERVER_PORT_NO);
    FrameworkConfiguration frameworkConfig=PhrescoFrameworkFactory.getFrameworkConfig();
    ProjectAdministrator administrator=PhrescoFrameworkFactory.getProjectAdministrator();
    Project project=administrator.getProject(projectCode);
    technology=project.getProjectInfo().getTechnology().getId();
    if (TechnologyTypes.IPHONES.contains(technology)) {
      StringBuilder codeValidatePath=new StringBuilder(Utility.getProjectHome());
      codeValidatePath.append(projectCode);
      codeValidatePath.append(File.separatorChar);
      codeValidatePath.append(DO_NOT_CHECKIN_DIR);
      codeValidatePath.append(File.separatorChar);
      codeValidatePath.append(STATIC_ANALYSIS_REPORT);
      codeValidatePath.append(File.separatorChar);
      codeValidatePath.append(INDEX_HTML);
      File indexPath=new File(codeValidatePath.toString());
      if (indexPath.isFile() && StringUtils.isNotEmpty(phrescoFileServerNumber)) {
        sb.append(HTTP_PROTOCOL);
        sb.append(PROTOCOL_POSTFIX);
        sb.append(LOCALHOST);
        sb.append(COLON);
        sb.append(phrescoFileServerNumber);
        sb.append(FORWARD_SLASH);
        sb.append(projectCode);
        sb.append(FORWARD_SLASH);
        sb.append(DO_NOT_CHECKIN_DIR);
        sb.append(FORWARD_SLASH);
        sb.append(STATIC_ANALYSIS_REPORT);
        sb.append(FORWARD_SLASH);
        sb.append(INDEX_HTML);
      }
 else {
        getHttpRequest().setAttribute(REQ_ERROR,getText(FAILURE_CODE_REVIEW));
      }
    }
 else {
      String serverUrl=""String_Node_Str"";
      if (StringUtils.isNotEmpty(frameworkConfig.getSonarUrl())) {
        serverUrl=frameworkConfig.getSonarUrl();
      }
 else {
        serverUrl=getHttpRequest().getRequestURL().toString();
        StringBuilder tobeRemoved=new StringBuilder();
        tobeRemoved.append(getHttpRequest().getContextPath());
        tobeRemoved.append(getHttpRequest().getServletPath());
        Pattern pattern=Pattern.compile(tobeRemoved.toString());
        Matcher matcher=pattern.matcher(serverUrl);
        serverUrl=matcher.replaceAll(""String_Node_Str"");
      }
      StringBuilder builder=new StringBuilder(Utility.getProjectHome());
      builder.append(projectCode);
      builder.append(File.separatorChar);
      builder.append(POM_XML);
      File pomPath=new File(builder.toString());
      PomProcessor processor=new PomProcessor(pomPath);
      String groupId=processor.getModel().getGroupId();
      String artifactId=processor.getModel().getArtifactId();
      sb.append(serverUrl);
      sb.append(frameworkConfig.getSonarReportPath());
      sb.append(groupId);
      sb.append(COLON);
      sb.append(artifactId);
      if (StringUtils.isNotEmpty(report) && !SOURCE_DIR.equals(report)) {
        sb.append(COLON);
        sb.append(report);
      }
      try {
        URL sonarURL=new URL(sb.toString());
        HttpURLConnection connection=(HttpURLConnection)sonarURL.openConnection();
        int responseCode=connection.getResponseCode();
        S_LOGGER.info(""String_Node_Str"" + responseCode);
        S_LOGGER.debug(""String_Node_Str"" + responseCode);
        if (responseCode != 200) {
          getHttpRequest().setAttribute(REQ_ERROR,getText(FAILURE_CODE_REVIEW));
          S_LOGGER.debug(""String_Node_Str"" + APP_CODE);
          return APP_CODE;
        }
      }
 catch (      Exception e) {
        S_LOGGER.error(""String_Node_Str"" + FrameworkUtil.getStackTraceAsString(e));
        new LogErrorReport(e,""String_Node_Str"");
        getHttpRequest().setAttribute(REQ_ERROR,getText(FAILURE_CODE_REVIEW));
        return APP_CODE;
      }
    }
  }
 catch (  Exception e) {
    S_LOGGER.error(""String_Node_Str"" + FrameworkUtil.getStackTraceAsString(e));
  }
  getHttpRequest().setAttribute(REQ_PROJECT_CODE,projectCode);
  getHttpRequest().setAttribute(REQ_TECHNOLOGY,technology);
  getHttpRequest().setAttribute(REQ_SONAR_PATH,sb.toString());
  return APP_CODE;
}"
50952,"public void setDefaultEnvironment(String environmentName,File sourceConfigXML) throws PhrescoException {
  try {
    DocumentBuilderFactory docFactory=DocumentBuilderFactory.newInstance();
    docFactory.setNamespaceAware(false);
    DocumentBuilder docBuilder=docFactory.newDocumentBuilder();
    Document doc=docBuilder.parse(sourceConfigXML);
    NodeList environmentList=doc.getElementsByTagName(""String_Node_Str"");
    for (int i=0; i < environmentList.getLength(); i++) {
      Element environment=(Element)environmentList.item(i);
      String envName=environment.getAttribute(""String_Node_Str"");
      String[] envs=environmentName.split(""String_Node_Str"");
      for (      String envsName : envs) {
        if (envsName.equals(envName)) {
          environment.setAttribute(""String_Node_Str"",""String_Node_Str"");
          TransformerFactory transformerFactory=TransformerFactory.newInstance();
          Transformer transformer=transformerFactory.newTransformer();
          DOMSource source=new DOMSource(doc);
          StreamResult result=new StreamResult(sourceConfigXML);
          transformer.transform(source,result);
        }
      }
    }
  }
 catch (  ParserConfigurationException e) {
    throw new PhrescoException(e);
  }
catch (  TransformerException e) {
    throw new PhrescoException(e);
  }
catch (  IOException e) {
    throw new PhrescoException(e);
  }
catch (  SAXException e) {
    throw new PhrescoException(e);
  }
}","public void setDefaultEnvironment(String environmentName,File sourceConfigXML) throws PhrescoException {
  try {
    DocumentBuilderFactory docFactory=DocumentBuilderFactory.newInstance();
    docFactory.setNamespaceAware(false);
    DocumentBuilder docBuilder=docFactory.newDocumentBuilder();
    Document doc=docBuilder.parse(sourceConfigXML);
    NodeList environmentList=doc.getElementsByTagName(""String_Node_Str"");
    for (int i=0; i < environmentList.getLength(); i++) {
      Element environment=(Element)environmentList.item(i);
      String envName=environment.getAttribute(""String_Node_Str"");
      String[] envs=environmentName.split(""String_Node_Str"");
      for (      String envsName : envs) {
        if (envsName.equals(envName)) {
          environment.setAttribute(""String_Node_Str"",""String_Node_Str"");
          TransformerFactory transformerFactory=TransformerFactory.newInstance();
          Transformer transformer=transformerFactory.newTransformer();
          DOMSource source=new DOMSource(doc);
          StreamResult result=new StreamResult(sourceConfigXML.toURI().getPath());
          transformer.transform(source,result);
        }
      }
    }
  }
 catch (  ParserConfigurationException e) {
    throw new PhrescoException(e);
  }
catch (  TransformerException e) {
    throw new PhrescoException(e);
  }
catch (  IOException e) {
    throw new PhrescoException(e);
  }
catch (  SAXException e) {
    throw new PhrescoException(e);
  }
}"
50953,"private void executeSql(SettingsInfo info,File basedir,List<String> filepaths) throws PhrescoException {
  initDriverMap();
  String host=info.getPropertyInfo(Constants.DB_HOST).getValue();
  String port=info.getPropertyInfo(Constants.DB_PORT).getValue();
  String userName=info.getPropertyInfo(Constants.DB_USERNAME).getValue();
  String password=info.getPropertyInfo(Constants.DB_PASSWORD).getValue();
  String databaseName=info.getPropertyInfo(Constants.DB_NAME).getValue();
  String databaseType=info.getPropertyInfo(Constants.DB_TYPE).getValue();
  String connectionProtocol=findConnectionProtocol(databaseType,host,port,databaseName);
  Connection con=null;
  FileInputStream fis=null;
  Statement st=null;
  try {
    Class.forName(getDbDriver(databaseType)).newInstance();
    con=DriverManager.getConnection(connectionProtocol,userName,password);
    con.setAutoCommit(false);
    for (    String sqlFile : filepaths) {
      fis=new FileInputStream(basedir.getPath() + sqlFile);
      Scanner s=new Scanner(fis);
      s.useDelimiter(""String_Node_Str"");
      st=con.createStatement();
      while (s.hasNext()) {
        String line=s.next().trim();
        if (databaseType.equals(""String_Node_Str"")) {
          if (line.startsWith(""String_Node_Str"")) {
            String comment=line.substring(line.indexOf(""String_Node_Str""),line.lastIndexOf(""String_Node_Str""));
            line=line.replace(comment,""String_Node_Str"");
            line=line.replace(""String_Node_Str"",""String_Node_Str"");
          }
          if (line.startsWith(Constants.REM_DELIMETER)) {
            String comment=line.substring(0,line.lastIndexOf(""String_Node_Str""));
            line=line.replace(comment,""String_Node_Str"");
          }
        }
        if (line.startsWith(""String_Node_Str"") && line.endsWith(""String_Node_Str"")) {
          line=line.substring(line.indexOf(""String_Node_Str""),line.indexOf(""String_Node_Str"") + 2);
        }
        if (line.trim().length() > 0) {
          st.execute(line);
        }
      }
    }
  }
 catch (  SQLException e) {
    Utility.closeConnection(con);
  }
catch (  FileNotFoundException e) {
    throw new PhrescoException(e);
  }
catch (  InstantiationException e) {
    throw new PhrescoException(e);
  }
catch (  IllegalAccessException e) {
    throw new PhrescoException(e);
  }
catch (  ClassNotFoundException e) {
    throw new PhrescoException(e);
  }
 finally {
    Utility.closeStream(fis);
    try {
      if (con != null) {
        con.commit();
        con.close();
      }
    }
 catch (    Exception e) {
      throw new PhrescoException(e);
    }
  }
}","private void executeSql(SettingsInfo info,File basedir,List<String> filepaths) throws PhrescoException {
  initDriverMap();
  String host=info.getPropertyInfo(Constants.DB_HOST).getValue();
  String port=info.getPropertyInfo(Constants.DB_PORT).getValue();
  String userName=info.getPropertyInfo(Constants.DB_USERNAME).getValue();
  String password=info.getPropertyInfo(Constants.DB_PASSWORD).getValue();
  String databaseName=info.getPropertyInfo(Constants.DB_NAME).getValue();
  String databaseType=info.getPropertyInfo(Constants.DB_TYPE).getValue();
  String connectionProtocol=findConnectionProtocol(databaseType,host,port,databaseName);
  Connection con=null;
  FileInputStream fis=null;
  Statement st=null;
  try {
    Class.forName(getDbDriver(databaseType)).newInstance();
    con=DriverManager.getConnection(connectionProtocol,userName,password);
    con.setAutoCommit(false);
    for (    String sqlFile : filepaths) {
      fis=new FileInputStream(basedir.getPath() + sqlFile);
      Scanner s=new Scanner(fis);
      s.useDelimiter(""String_Node_Str"");
      st=con.createStatement();
      while (s.hasNext()) {
        String line=s.next().trim();
        if (databaseType.equals(""String_Node_Str"")) {
          if (line.startsWith(""String_Node_Str"")) {
            String comment=line.substring(line.indexOf(""String_Node_Str""),line.lastIndexOf(""String_Node_Str""));
            line=line.replace(comment,""String_Node_Str"");
            line=line.replace(""String_Node_Str"",""String_Node_Str"");
          }
          if (line.startsWith(Constants.REM_DELIMETER)) {
            String comment=line.substring(0,line.lastIndexOf(""String_Node_Str""));
            line=line.replace(comment,""String_Node_Str"");
          }
        }
        if (line.startsWith(""String_Node_Str"") && line.endsWith(""String_Node_Str"")) {
          line=line.substring(line.indexOf(""String_Node_Str""),line.indexOf(""String_Node_Str"") + 2);
        }
        if (line.trim().length() > 0) {
          st.execute(line);
        }
      }
    }
  }
 catch (  SQLException e) {
    try {
      if (con != null) {
        con.rollback();
      }
    }
 catch (    SQLException e1) {
      throw new PhrescoException(e1);
    }
  }
catch (  FileNotFoundException e) {
    throw new PhrescoException(e);
  }
catch (  InstantiationException e) {
    throw new PhrescoException(e);
  }
catch (  IllegalAccessException e) {
    throw new PhrescoException(e);
  }
catch (  ClassNotFoundException e) {
    throw new PhrescoException(e);
  }
 finally {
    Utility.closeStream(fis);
    try {
      if (con != null) {
        con.commit();
        con.close();
      }
    }
 catch (    Exception e) {
      throw new PhrescoException(e);
    }
  }
}"
50954,"/** 
 * @param id
 * @return
 * @throws PhrescoPomException
 */
public AndroidProfile getProfileElement(String id) throws PhrescoPomException {
  Profile profile=getProfile(id);
  AndroidProfile androidProfile=new AndroidProfile();
  List<Plugin> plugin=profile.getBuild().getPlugins().getPlugin();
  for (  Plugin plugin2 : plugin) {
    List<PluginExecution> execution=plugin2.getExecutions().getExecution();
    for (    PluginExecution pluginExecution : execution) {
      List<Element> any=pluginExecution.getConfiguration().getAny();
      processProfiles(androidProfile,any);
    }
  }
  return androidProfile;
}","/** 
 * @param id
 * @return
 * @throws PhrescoPomException
 */
public AndroidProfile getProfileElement(String id) throws PhrescoPomException {
  Profile profile=getProfile(id);
  AndroidProfile androidProfile=new AndroidProfile();
  List<Plugin> plugin=profile.getBuild().getPlugins().getPlugin();
  for (  Plugin plugin2 : plugin) {
    List<PluginExecution> execution=plugin2.getExecutions().getExecution();
    if (execution != null) {
      for (      PluginExecution pluginExecution : execution) {
        if (pluginExecution.getConfiguration() != null) {
          List<Element> any=pluginExecution.getConfiguration().getAny();
          processProfiles(androidProfile,any);
        }
      }
    }
  }
  return androidProfile;
}"
50955,"/** 
 * @return
 */
public String getSigningProfile(){
  if (model.getProfiles() != null && model.getProfiles().getProfile() != null) {
    for (    Profile profile : model.getProfiles().getProfile()) {
      List<Plugin> plugin=profile.getBuild().getPlugins().getPlugin();
      for (      Plugin plugin2 : plugin) {
        List<PluginExecution> execution=plugin2.getExecutions().getExecution();
        return getSigningProfilePlugin(profile,execution);
      }
    }
  }
  return ""String_Node_Str"";
}","/** 
 * @return
 */
public String getSigningProfile(){
  if (model.getProfiles() != null && model.getProfiles().getProfile() != null) {
    for (    Profile profile : model.getProfiles().getProfile()) {
      List<Plugin> plugin=profile.getBuild().getPlugins().getPlugin();
      for (      Plugin plugin2 : plugin) {
        List<PluginExecution> execution=plugin2.getExecutions().getExecution();
        if (getSigningProfilePlugin(profile,execution).equals(profile.getId())) {
          return getSigningProfilePlugin(profile,execution);
        }
      }
    }
  }
  return ""String_Node_Str"";
}"
50956,"/** 
 * @param androidProfile
 * @param any
 */
private void processProfiles(AndroidProfile androidProfile,List<Element> any){
  for (  Element element : any) {
    String tagName=element.getTagName();
    if (tagName.equals(""String_Node_Str"")) {
      androidProfile.setKeystore(element.getTextContent());
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      androidProfile.setStorepass(element.getTextContent());
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      androidProfile.setKeypass(element.getTextContent());
    }
 else     if (tagName.equals(""String_Node_Str"")) {
      androidProfile.setAlias(element.getTextContent());
    }
  }
}","/** 
 * @param androidProfile
 * @param any
 */
private void processProfiles(AndroidProfile androidProfile,List<Element> any){
  for (  Element element : any) {
    String tagName=element.getTagName();
    if (tagName.equals(PomConstants.KEYSTORE)) {
      androidProfile.setKeystore(element.getTextContent());
    }
 else     if (tagName.equals(PomConstants.STOREPASS)) {
      androidProfile.setStorepass(element.getTextContent());
    }
 else     if (tagName.equals(PomConstants.KEYPASS)) {
      androidProfile.setKeypass(element.getTextContent());
    }
 else     if (tagName.equals(PomConstants.ALIAS)) {
      androidProfile.setAlias(element.getTextContent());
    }
  }
}"
50957,"/** 
 * @return
 */
public String getSigningProfile(){
  if (model.getProfiles().getProfile() != null) {
    for (    Profile profile : model.getProfiles().getProfile()) {
      List<Plugin> plugin=profile.getBuild().getPlugins().getPlugin();
      for (      Plugin plugin2 : plugin) {
        List<PluginExecution> execution=plugin2.getExecutions().getExecution();
        return getSigningProfilePlugin(profile,execution);
      }
    }
  }
  return ""String_Node_Str"";
}","/** 
 * @return
 */
public String getSigningProfile(){
  if (model.getProfiles() != null && model.getProfiles().getProfile() != null) {
    for (    Profile profile : model.getProfiles().getProfile()) {
      List<Plugin> plugin=profile.getBuild().getPlugins().getPlugin();
      for (      Plugin plugin2 : plugin) {
        List<PluginExecution> execution=plugin2.getExecutions().getExecution();
        return getSigningProfilePlugin(profile,execution);
      }
    }
  }
  return ""String_Node_Str"";
}"
50958,"private String getSigningProfilePlugin(Profile profile,List<PluginExecution> execution){
  for (  PluginExecution pluginExecution : execution) {
    List<Element> any=pluginExecution.getConfiguration().getAny();
    for (    Element element : any) {
      if (element.getTagName().equals(""String_Node_Str"")) {
        return profile.getId();
      }
    }
  }
  return ""String_Node_Str"";
}","/** 
 * @param profile
 * @param execution
 * @return
 */
private String getSigningProfilePlugin(Profile profile,List<PluginExecution> execution){
  if (model.getProfiles() != null && model.getProfiles().getProfile() != null) {
    for (    PluginExecution pluginExecution : execution) {
      if (pluginExecution.getConfiguration() != null) {
        List<Element> any=pluginExecution.getConfiguration().getAny();
        for (        Element element : any) {
          if (element.getTagName().equals(PomConstants.KEYSTORE)) {
            return profile.getId();
          }
        }
      }
    }
  }
  return ""String_Node_Str"";
}"
50959,"/** 
 * @param reports
 * @param file
 */
public void addReportPlugin(List<Reports> reports,List<ReportCategories> reportCategories,File file){
  for (  Reports iterateReport : reports) {
    addReportPlugin(iterateReport,reportCategories,file);
  }
}","/** 
 * @param file
 * @return
 * @deprecated
 */
public void addReportPlugin(List<Reports> reports,File file){
  addReportPlugin(reports,null,file);
}"
50960,"/** 
 * @param file
 * @return
 */
public List<Reports> getReports(File file){
  try {
    PomProcessor processor=new PomProcessor(file);
    List<ReportPlugin> reportPlugin=processor.getReportPlugin();
    if (reportPlugin != null) {
      List<Reports> reports=new ArrayList<Reports>();
      List<ReportCategories> categories=new ArrayList<ReportCategories>();
      for (      ReportPlugin reportPlugin2 : reportPlugin) {
        Reports reports1=new Reports();
        reports1.setGroupId(reportPlugin2.getGroupId());
        reports1.setArtifactId(reportPlugin2.getArtifactId());
        List<String> projectInfoReportCategories=processor.getProjectInfoReportCategories();
        if (projectInfoReportCategories != null && reportPlugin2.getArtifactId().equals(Reports.PROJECT_INFO.getArtifactId())) {
          for (          String name : projectInfoReportCategories) {
            ReportCategories reportCategories=new ReportCategories();
            reportCategories.setName(name);
            categories.add(reportCategories);
            reports1.setReportCategories(categories);
          }
        }
        reports.add(reports1);
      }
      return reports;
    }
  }
 catch (  JAXBException e) {
    LOGGER.debug(e);
  }
catch (  IOException e) {
    LOGGER.debug(e);
  }
  return null;
}","public List<Reports> getReports(File file){
  try {
    PomProcessor processor=new PomProcessor(file);
    List<ReportPlugin> reportPlugin=processor.getReportPlugin();
    if (reportPlugin != null) {
      List<Reports> reports=new ArrayList<Reports>();
      List<ReportCategories> categories=new ArrayList<ReportCategories>();
      for (      ReportPlugin reportPlugin2 : reportPlugin) {
        Reports reports1=new Reports();
        reports1.setGroupId(reportPlugin2.getGroupId());
        reports1.setArtifactId(reportPlugin2.getArtifactId());
        List<String> projectInfoReportCategories=processor.getProjectInfoReportCategories();
        if (projectInfoReportCategories != null && reportPlugin2.getArtifactId().equals(Reports.PROJECT_INFO.getArtifactId())) {
          for (          String name : projectInfoReportCategories) {
            ReportCategories reportCategories=new ReportCategories();
            reportCategories.setName(name);
            categories.add(reportCategories);
            reports1.setReportCategories(categories);
          }
        }
        reports.add(reports1);
      }
      return reports;
    }
  }
 catch (  JAXBException e) {
    LOGGER.debug(e);
  }
catch (  IOException e) {
    LOGGER.debug(e);
  }
  return null;
}"
50961,"public static void updateProjectInfo(ProjectInfo info,File phrescoFolder) throws PhrescoException {
  BufferedWriter out=null;
  FileWriter fstream=null;
  BufferedReader reader=null;
  try {
    Gson gson=new Gson();
    reader=new BufferedReader(new FileReader(phrescoFolder));
    ProjectInfo projectInfos=gson.fromJson(reader,ProjectInfo.class);
    List<ModuleGroup> ProjectInfomodules=projectInfos.getTechnology().getModules();
    List<ModuleGroup> projectInfojsLibraries=projectInfos.getTechnology().getJsLibraries();
    List<ModuleGroup> selectedInfomodules=info.getTechnology().getModules();
    List<ModuleGroup> selectedInfojsLibraries=info.getTechnology().getJsLibraries();
    if (ProjectInfomodules != null && !ProjectInfomodules.isEmpty()) {
      selectedInfomodules.addAll(ProjectInfomodules);
    }
    if (projectInfojsLibraries != null && !projectInfojsLibraries.isEmpty() && selectedInfojsLibraries != null) {
      selectedInfojsLibraries.addAll(projectInfojsLibraries);
    }
    info.getTechnology().setModules(selectedInfomodules);
    info.getTechnology().setJsLibraries(selectedInfojsLibraries);
    String infoJSON=gson.toJson(info);
    fstream=new FileWriter(phrescoFolder.getPath());
    out=new BufferedWriter(fstream);
    out.write(infoJSON);
  }
 catch (  IOException e) {
    throw new PhrescoException(e);
  }
 finally {
    try {
      if (out != null) {
        out.close();
      }
      if (fstream != null) {
        fstream.close();
      }
    }
 catch (    IOException e) {
      throw new PhrescoException(e);
    }
  }
}","public static void updateProjectInfo(ProjectInfo info,File phrescoFolder) throws PhrescoException {
  BufferedWriter out=null;
  FileWriter fstream=null;
  BufferedReader reader=null;
  try {
    Gson gson=new Gson();
    reader=new BufferedReader(new FileReader(phrescoFolder));
    ProjectInfo projectInfos=gson.fromJson(reader,ProjectInfo.class);
    List<ModuleGroup> ProjectInfomodules=projectInfos.getTechnology().getModules();
    List<ModuleGroup> projectInfojsLibraries=projectInfos.getTechnology().getJsLibraries();
    List<ModuleGroup> selectedInfomodules=info.getTechnology().getModules();
    List<ModuleGroup> selectedInfojsLibraries=info.getTechnology().getJsLibraries();
    if (ProjectInfomodules != null && !ProjectInfomodules.isEmpty() && selectedInfomodules != null) {
      selectedInfomodules.addAll(ProjectInfomodules);
      info.getTechnology().setModules(selectedInfomodules);
    }
 else     if (ProjectInfomodules != null) {
      info.getTechnology().setModules(ProjectInfomodules);
    }
    if (projectInfojsLibraries != null && !projectInfojsLibraries.isEmpty() && selectedInfojsLibraries != null) {
      selectedInfojsLibraries.addAll(projectInfojsLibraries);
      info.getTechnology().setModules(selectedInfojsLibraries);
    }
 else     if (projectInfojsLibraries != null) {
      info.getTechnology().setModules(ProjectInfomodules);
    }
    String infoJSON=gson.toJson(info);
    fstream=new FileWriter(phrescoFolder.getPath());
    out=new BufferedWriter(fstream);
    out.write(infoJSON);
  }
 catch (  IOException e) {
    throw new PhrescoException(e);
  }
 finally {
    Utility.closeStream(reader);
    try {
      if (out != null) {
        out.close();
      }
      if (fstream != null) {
        fstream.close();
      }
    }
 catch (    IOException e) {
      throw new PhrescoException(e);
    }
  }
}"
50962,"public static void updatePomProject(ProjectInfo projectInfo) throws PhrescoException, JDOMException, IOException {
  File path=new File(Utility.getProjectHome() + File.separator + projectInfo.getCode()+ File.separator+ POM_FILE);
  try {
    SAXBuilder builder=new SAXBuilder();
    Document doc=(Document)builder.build(path);
    Element rootNode=doc.getRootElement();
    Element dependencies=rootNode.getChild(""String_Node_Str"",rootNode.getNamespace());
    Namespace ns=rootNode.getNamespace();
    List<ModuleGroup> modules=projectInfo.getTechnology().getModules();
    if (CollectionUtils.isEmpty(modules)) {
      return;
    }
    for (    ModuleGroup moduleGroup : modules) {
      Element dependency=new Element(""String_Node_Str"",ns);
      dependency.addContent(new Element(""String_Node_Str"",ns).setText(moduleGroup.getGroupId()));
      dependency.addContent(new Element(""String_Node_Str"",ns).setText(moduleGroup.getArtifactId()));
      List<Module> versions=moduleGroup.getVersions();
      for (      Module version : versions) {
        dependency.addContent(new Element(""String_Node_Str"",ns).setText(version.getVersion()));
      }
      dependencies.addContent(dependency);
    }
    XMLOutputter xmlOutput=new XMLOutputter();
    xmlOutput.setFormat(Format.getPrettyFormat());
    xmlOutput.output(doc,new FileWriter(path));
  }
 catch (  Exception e) {
    throw new PhrescoException(e);
  }
}","public static void updatePomProject(ProjectInfo projectInfo) throws PhrescoException, PhrescoPomException {
  File path=new File(Utility.getProjectHome() + File.separator + projectInfo.getCode()+ File.separator+ POM_FILE);
  try {
    PomProcessor pomProcessor=new PomProcessor(path);
    List<ModuleGroup> modules=projectInfo.getTechnology().getModules();
    if (CollectionUtils.isEmpty(modules)) {
      return;
    }
    for (    ModuleGroup moduleGroup : modules) {
      pomProcessor.addDependency(moduleGroup.getGroupId(),moduleGroup.getArtifactId(),moduleGroup.getVersions().get(0).getVersion());
      pomProcessor.save();
    }
  }
 catch (  JAXBException e) {
    throw new PhrescoException(e);
  }
catch (  IOException e) {
    throw new PhrescoException(e);
  }
}"
50963,"/** 
 * Updates a project based on the given project information
 * @return Project based on the given information
 */
public Project updateProject(ProjectInfo delta,ProjectInfo projectInfo,File path,User userInfo) throws PhrescoException {
  S_LOGGER.debug(""String_Node_Str"");
  S_LOGGER.debug(""String_Node_Str"" + delta.getName());
  if (StringUtils.isEmpty(delta.getVersion())) {
    delta.setVersion(PROJECT_VERSION);
  }
  ClientResponse response=null;
  String techId=delta.getTechnology().getId();
  if (techId.equals(TechnologyTypes.PHP_DRUPAL6) || techId.equals(TechnologyTypes.PHP_DRUPAL7)) {
    excludeModule(delta);
  }
  boolean flag=!techId.equals(TechnologyTypes.JAVA_WEBSERVICE) && !techId.equals(TechnologyTypes.JAVA_STANDALONE) && !techId.equals(TechnologyTypes.ANDROID_NATIVE);
  ProjectInfo projectInfoClone=projectInfo.clone();
  updateDocument(projectInfo,path);
  response=PhrescoFrameworkFactory.getServiceManager().updateProject(delta,userInfo);
  if (response.getStatus() == 401) {
    throw new PhrescoException(""String_Node_Str"");
  }
 else   if (flag) {
    if (response.getStatus() != 200) {
      throw new PhrescoException(""String_Node_Str"");
    }
  }
  if (techId.equals(TechnologyTypes.JAVA_WEBSERVICE)) {
    createSqlFolder(delta,path);
  }
  updatePomProject(delta,projectInfoClone);
  try {
    if (flag) {
      extractArchive(response,delta);
    }
    ProjectUtils.updateProjectInfo(delta,path);
    updateProjectPOM(projectInfo);
  }
 catch (  FileNotFoundException e) {
    throw new PhrescoException(e);
  }
catch (  IOException e) {
    throw new PhrescoException(e);
  }
  return new ProjectImpl(delta);
}","/** 
 * Updates a project based on the given project information
 * @return Project based on the given information
 */
public Project updateProject(ProjectInfo delta,ProjectInfo projectInfo,File path,User userInfo) throws PhrescoException {
  S_LOGGER.debug(""String_Node_Str"");
  S_LOGGER.debug(""String_Node_Str"" + delta.getName());
  if (StringUtils.isEmpty(delta.getVersion())) {
    delta.setVersion(PROJECT_VERSION);
  }
  ClientResponse response=null;
  String techId=delta.getTechnology().getId();
  if (techId.equals(TechnologyTypes.PHP_DRUPAL6) || techId.equals(TechnologyTypes.PHP_DRUPAL7)) {
    excludeModule(delta);
  }
  boolean flag=!techId.equals(TechnologyTypes.JAVA_WEBSERVICE) && !techId.equals(TechnologyTypes.JAVA_STANDALONE) && !techId.equals(TechnologyTypes.ANDROID_NATIVE);
  updateDocument(projectInfo,path);
  response=PhrescoFrameworkFactory.getServiceManager().updateProject(delta,userInfo);
  if (response.getStatus() == 401) {
    throw new PhrescoException(""String_Node_Str"");
  }
 else   if (flag) {
    if (response.getStatus() != 200) {
      throw new PhrescoException(""String_Node_Str"");
    }
  }
  if (techId.equals(TechnologyTypes.JAVA_WEBSERVICE)) {
    createSqlFolder(delta,path);
  }
  updatePomProject(delta,projectInfo);
  try {
    if (flag) {
      extractArchive(response,delta);
    }
    ProjectUtils.updateProjectInfo(projectInfo,path);
    updateProjectPOM(projectInfo);
  }
 catch (  FileNotFoundException e) {
    throw new PhrescoException(e);
  }
catch (  IOException e) {
    throw new PhrescoException(e);
  }
  return new ProjectImpl(delta);
}"
50964,"@Override public void process(ProjectInfo info,File path) throws PhrescoException {
  if (isDebugEnabled) {
    S_LOGGER.debug(""String_Node_Str"");
    S_LOGGER.debug(""String_Node_Str"" + info.getCode());
    S_LOGGER.debug(""String_Node_Str"" + path.getPath());
  }
  Technology technology=info.getTechnology();
  if (StringUtils.isNotBlank(info.getPilotProjectName())) {
    List<ProjectInfo> pilotProjects=getRepositoryManager().getPilotProjects(technology.getId());
    if (CollectionUtils.isEmpty(pilotProjects)) {
      return;
    }
    for (    ProjectInfo projectInfo : pilotProjects) {
      String urls[]=projectInfo.getPilotProjectUrls();
      if (urls != null) {
        for (        String url : urls) {
          DependencyUtils.extractFiles(url,path);
        }
      }
    }
  }
  updateAndroidVersion(path,info);
  POMUpdater.updatePOM(path,technology);
  AndroidTestPOMUpdater.updatePOM(path);
  if (technology.getId().equals(TechnologyTypes.ANDROID_HYBRID)) {
    extractJsLibraries(path,info.getTechnology().getJsLibraries());
  }
}","@Override public void process(ProjectInfo info,File path) throws PhrescoException {
  if (isDebugEnabled) {
    S_LOGGER.debug(""String_Node_Str"");
    S_LOGGER.debug(""String_Node_Str"" + info.getCode());
    S_LOGGER.debug(""String_Node_Str"" + path.getPath());
  }
  Technology technology=info.getTechnology();
  if (StringUtils.isNotBlank(info.getPilotProjectName())) {
    List<ProjectInfo> pilotProjects=getRepositoryManager().getPilotProjects(technology.getId());
    if (CollectionUtils.isEmpty(pilotProjects)) {
      return;
    }
    for (    ProjectInfo projectInfo : pilotProjects) {
      String urls[]=projectInfo.getPilotProjectUrls();
      if (urls != null) {
        for (        String url : urls) {
          DependencyUtils.extractFiles(url,path);
        }
      }
    }
  }
  updateAndroidVersion(path,info);
  try {
    List<ModuleGroup> modules=technology.getModules();
    if ((CollectionUtils.isNotEmpty(modules)) && modules != null) {
      updatePOMModules(path,modules);
    }
  }
 catch (  JAXBException e) {
    e.printStackTrace();
  }
catch (  PhrescoPomException e) {
    e.printStackTrace();
  }
  AndroidTestPOMUpdater.updatePOM(path);
  if (technology.getId().equals(TechnologyTypes.ANDROID_HYBRID)) {
    extractJsLibraries(path,info.getTechnology().getJsLibraries());
  }
}"
50965,"@Override protected String getModulePathKey(){
  return null;
}","@Override protected String getModulePathKey(){
  return ""String_Node_Str"";
}"
50966,"@Test public void testGetModuleById(){
  String techId=""String_Node_Str"";
  List<ModuleGroup> modules=new ArrayList<ModuleGroup>();
  try {
    List<ModuleGroup> modulesList=mongoOperation.getCollection(MODULES_COLLECTION_NAME,ModuleGroup.class);
    for (    ModuleGroup moduleGroup : modulesList) {
      if (moduleGroup.getTechId().equals(techId)) {
        modules.add(moduleGroup);
      }
    }
    String json=new Gson().toJson(modules);
    System.out.println(json);
  }
 catch (  Exception e) {
  }
}","@Test public void testGetModuleById(){
  String techId=""String_Node_Str"";
  List<ModuleGroup> modules=new ArrayList<ModuleGroup>();
  try {
    List<ModuleGroup> modulesList=mongoOperation.getCollection(MODULES_COLLECTION_NAME,ModuleGroup.class);
    for (    ModuleGroup moduleGroup : modulesList) {
    }
    String json=new Gson().toJson(modules);
    System.out.println(json);
  }
 catch (  Exception e) {
  }
}"
50967,"/** 
 * Updates List of objects for the given type 
 * @param infos
 * @param type
 * @return
 * @throws PhrescoException
 */
@SuppressWarnings(""String_Node_Str"") public List<E> update(List<E> infos,GenericType<List<E>> gtype,String accept,String type) throws PhrescoException {
  S_LOGGER.debug(""String_Node_Str"");
  builder=resource.accept(accept).type(type);
  ClientResponse clientResponse=builder.put(ClientResponse.class,infos);
  isErrorThrow(clientResponse);
  return clientResponse.getEntity(gtype);
}","/** 
 * Updates List of objects for the given type 
 * @param infos
 * @param type
 * @return
 * @throws PhrescoException
 */
public List<E> update(List<E> infos,GenericType<List<E>> gtype,String accept,String type) throws PhrescoException {
  S_LOGGER.debug(""String_Node_Str"");
  builder=resource.accept(accept).type(type);
  ClientResponse clientResponse=builder.put(ClientResponse.class,infos);
  isErrorThrow(clientResponse);
  return clientResponse.getEntity(gtype);
}"
50968,"/** 
 * Update the given object by using the type given
 * @param obj
 * @param type
 * @return
 * @throws PhrescoException
 */
@SuppressWarnings(""String_Node_Str"") public ClientResponse updateById(E obj,Type gType,String accept,String type) throws PhrescoException {
  S_LOGGER.debug(""String_Node_Str"");
  builder=resource.accept(accept).type(type);
  ClientResponse clientResponse=builder.put(ClientResponse.class,new Gson().toJson(obj));
  isErrorThrow(clientResponse);
  return clientResponse;
}","/** 
 * Update the given object by using the type given
 * @param obj
 * @param type
 * @return
 * @throws PhrescoException
 */
public E updateById(E obj,GenericType<E> genericType,String accept,String type) throws PhrescoException {
  S_LOGGER.debug(""String_Node_Str"");
  builder=resource.accept(accept).type(type);
  ClientResponse clientResponse=builder.put(ClientResponse.class,obj);
  isErrorThrow(clientResponse);
  return clientResponse.getEntity(genericType);
}"
50969,"/** 
 * Get List of objects for the specified generic type object
 * @param genericType
 * @return
 */
@SuppressWarnings(""String_Node_Str"") public List<E> get(GenericType<List<E>> genericType,String accept,String type){
  S_LOGGER.debug(""String_Node_Str"");
  builder=resource.accept(accept).type(type);
  return builder.get(genericType);
}","/** 
 * Get List of objects for the specified generic type object
 * @param genericType
 * @return
 */
public List<E> get(GenericType<List<E>> genericType,String accept,String type){
  S_LOGGER.debug(""String_Node_Str"");
  builder=resource.accept(accept).type(type);
  return builder.get(genericType);
}"
50970,"@Test public void testGetTechnologies(){
  try {
    serviceManager=ServiceClientFactory.getServiceManager(context);
    RestClient<Technology> techClient=serviceManager.getRestClient(""String_Node_Str"");
    techClient.setPath(""String_Node_Str"");
    GenericType<List<Technology>> genericType=new GenericType<List<Technology>>(){
    }
;
    List<Technology> list=techClient.get(genericType);
    for (    Technology tech : list) {
      System.out.println(""String_Node_Str"" + tech.getName() + ""String_Node_Str""+ tech.getId());
    }
  }
 catch (  PhrescoException e) {
    e.printStackTrace();
  }
}","@Test public void testGetTechnologies(){
  try {
    serviceManager=ServiceClientFactory.getServiceManager(context);
    RestClient<Technology> techClient=serviceManager.getRestClient(""String_Node_Str"");
    techClient.setPath(""String_Node_Str"");
    GenericType<List<Technology>> genericType=new GenericType<List<Technology>>(){
    }
;
    List<Technology> list=techClient.get(genericType);
    id=list.get(0).getId();
    id2=list.get(1).getId();
    id3=list.get(2).getId();
    for (    Technology tech : list) {
      System.out.println(""String_Node_Str"" + tech.getName() + ""String_Node_Str""+ tech.getId());
      System.out.println(""String_Node_Str"" + tech);
    }
  }
 catch (  PhrescoException e) {
    e.printStackTrace();
  }
}"
50971,"@Test public void testCreateServer() throws PhrescoException {
  List<Technology> techs=new ArrayList<Technology>();
  Technology tech=new Technology();
  tech.setName(""String_Node_Str"");
  List<String> versions=new ArrayList<String>();
  versions.add(""String_Node_Str"");
  versions.add(""String_Node_Str"");
  versions.add(""String_Node_Str"");
  tech.setVersions(versions);
  techs.add(tech);
  serviceManager=ServiceClientFactory.getServiceManager(context);
  RestClient<Technology> techClient=serviceManager.getRestClient(""String_Node_Str"");
  ClientResponse create=techClient.create(techs);
}","@Test public void testCreateServer() throws PhrescoException {
  List<Technology> techs=new ArrayList<Technology>();
  Technology tech=new Technology();
  tech.setName(""String_Node_Str"");
  List<String> versions=new ArrayList<String>();
  versions.add(""String_Node_Str"");
  versions.add(""String_Node_Str"");
  versions.add(""String_Node_Str"");
  tech.setVersions(versions);
  techs.add(tech);
  Technology tech2=new Technology();
  tech2.setName(""String_Node_Str"");
  List<String> versions2=new ArrayList<String>();
  versions2.add(""String_Node_Str"");
  versions2.add(""String_Node_Str"");
  tech2.setVersions(versions2);
  techs.add(tech2);
  Technology tech3=new Technology();
  tech2.setName(""String_Node_Str"");
  List<String> versions3=new ArrayList<String>();
  versions3.add(""String_Node_Str"");
  versions3.add(""String_Node_Str"");
  tech3.setVersions(versions3);
  techs.add(tech3);
  serviceManager=ServiceClientFactory.getServiceManager(context);
  RestClient<Technology> techClient=serviceManager.getRestClient(""String_Node_Str"");
  ClientResponse response=techClient.create(techs);
  System.out.println(""String_Node_Str"" + response.getStatus());
}"
50972,"@Ignore public void testDeleteServerById() throws PhrescoException {
  String id=""String_Node_Str"";
  serviceManager=ServiceClientFactory.getServiceManager(context);
  RestClient<Technology> techClient=serviceManager.getRestClient(""String_Node_Str"" + id);
  ClientResponse response=techClient.deleteById();
}","@Test public void testDeleteServerById() throws PhrescoException {
  serviceManager=ServiceClientFactory.getServiceManager(context);
  RestClient<Technology> techClient=serviceManager.getRestClient(""String_Node_Str"");
  techClient.setPath(id3);
  ClientResponse response=techClient.deleteById();
  System.out.println(response.getStatus());
}"
50973,"@Ignore public void testPutServer() throws PhrescoException {
  List<Technology> techs=new ArrayList<Technology>();
  Technology tech=new Technology();
  tech.setId(""String_Node_Str"");
  tech.setName(""String_Node_Str"");
  List<String> versions=new ArrayList<String>();
  versions.add(""String_Node_Str"");
  versions.add(""String_Node_Str"");
  tech.setVersions(versions);
  techs.add(tech);
  serviceManager=ServiceClientFactory.getServiceManager(context);
  RestClient<Technology> techClient=serviceManager.getRestClient(""String_Node_Str"");
  GenericType<List<Technology>> type=new GenericType<List<Technology>>(){
  }
;
  List<Technology> entity=techClient.update(techs,type);
  for (  Technology technology : entity) {
    System.out.println(""String_Node_Str"" + technology);
  }
}","@Test public void testPutServer() throws PhrescoException {
  List<Technology> techs=new ArrayList<Technology>();
  Technology tech=new Technology();
  System.out.println(""String_Node_Str"" + id);
  tech.setId(id);
  tech.setName(""String_Node_Str"");
  List<String> versions=new ArrayList<String>();
  versions.add(""String_Node_Str"");
  versions.add(""String_Node_Str"");
  tech.setVersions(versions);
  techs.add(tech);
  serviceManager=ServiceClientFactory.getServiceManager(context);
  RestClient<Technology> techClient=serviceManager.getRestClient(""String_Node_Str"");
  GenericType<List<Technology>> type=new GenericType<List<Technology>>(){
  }
;
  List<Technology> entity=techClient.update(techs,type);
  for (  Technology technology : entity) {
    System.out.println(""String_Node_Str"" + technology);
  }
}"
50974,"@Ignore public void testGetServerById() throws PhrescoException {
  try {
    String id=""String_Node_Str"";
    serviceManager=ServiceClientFactory.getServiceManager(context);
    RestClient<Technology> techClient=serviceManager.getRestClient(""String_Node_Str"" + id);
    GenericType<Technology> genericType=new GenericType<Technology>(){
    }
;
    Technology tech=techClient.getById(genericType);
    System.out.println(""String_Node_Str"" + tech);
  }
 catch (  PhrescoException e) {
    e.printStackTrace();
  }
}","@Test public void testGetServerById() throws PhrescoException {
  try {
    serviceManager=ServiceClientFactory.getServiceManager(context);
    RestClient<Technology> techClient=serviceManager.getRestClient(""String_Node_Str"");
    techClient.setPath(id2);
    GenericType<Technology> genericType=new GenericType<Technology>(){
    }
;
    Technology tech=techClient.getById(genericType);
    System.out.println(""String_Node_Str"" + tech);
  }
 catch (  PhrescoException e) {
    e.printStackTrace();
  }
}"
50975,"@Ignore public void testPutServerById() throws PhrescoException {
  String id=""String_Node_Str"";
  Technology tech=new Technology();
  tech.setId(""String_Node_Str"");
  tech.setName(""String_Node_Str"");
  List<String> versions=new ArrayList<String>();
  versions.add(""String_Node_Str"");
  versions.add(""String_Node_Str"");
  tech.setVersions(versions);
  serviceManager=ServiceClientFactory.getServiceManager(context);
  RestClient<Technology> techClient=serviceManager.getRestClient(""String_Node_Str"" + id);
  Type type=new TypeToken<Technology>(){
  }
.getType();
  ClientResponse clientResponse=techClient.updateById(tech,type);
}","@Test public void testPutServerById() throws PhrescoException {
  Technology tech=new Technology();
  tech.setId(id2);
  tech.setName(""String_Node_Str"");
  List<String> versions=new ArrayList<String>();
  versions.add(""String_Node_Str"");
  versions.add(""String_Node_Str"");
  tech.setVersions(versions);
  serviceManager=ServiceClientFactory.getServiceManager(context);
  RestClient<Technology> techClient=serviceManager.getRestClient(""String_Node_Str"");
  techClient.setPath(id2);
  GenericType<Technology> genericType=new GenericType<Technology>(){
  }
;
  Technology technology=techClient.updateById(tech,genericType);
  System.out.println(technology);
}"
50976,"public String update() throws PhrescoException {
  S_LOGGER.debug(""String_Node_Str"");
  try {
    if (validateForm()) {
      setErrorFound(true);
      return SUCCESS;
    }
    SimpleDateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
    Customer customer=new Customer(customerId,name,description);
    if (StringUtils.isNotEmpty(validFrom)) {
      customer.setValidFrom(dateFormat.parse(validFrom));
    }
    if (StringUtils.isNotEmpty(validUpTo)) {
      customer.setValidUpto(dateFormat.parse(validUpTo));
    }
    customer.setRepoURL(repoURL);
    RestClient<Customer> editCustomer=getServiceManager().getRestClient(""String_Node_Str"" + REST_API_CUSTOMERS + ""String_Node_Str""+ customerId);
    Type type=new TypeToken<Customer>(){
    }
.getType();
    ClientResponse clientResponse=editCustomer.updateById(customer,type);
    if (clientResponse.getStatus() != 200) {
      addActionError(getText(CUSTOMER_NOT_UPDATED,Collections.singletonList(oldName)));
    }
 else {
      addActionMessage(getText(CUSTOMER_UPDATED,Collections.singletonList(oldName)));
    }
  }
 catch (  Exception e) {
    throw new PhrescoException(e);
  }
  return list();
}","public String update() throws PhrescoException {
  S_LOGGER.debug(""String_Node_Str"");
  try {
    if (validateForm()) {
      setErrorFound(true);
      return SUCCESS;
    }
    SimpleDateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
    Customer customer=new Customer(customerId,name,description);
    if (StringUtils.isNotEmpty(validFrom)) {
      customer.setValidFrom(dateFormat.parse(validFrom));
    }
    if (StringUtils.isNotEmpty(validUpTo)) {
      customer.setValidUpto(dateFormat.parse(validUpTo));
    }
    customer.setRepoURL(repoURL);
    RestClient<Customer> editCustomer=getServiceManager().getRestClient(""String_Node_Str"" + REST_API_CUSTOMERS + ""String_Node_Str""+ customerId);
    GenericType<Customer> genericType=new GenericType<Customer>(){
    }
;
    Customer updatedCustomer=editCustomer.updateById(customer,genericType);
    if (updatedCustomer == null) {
      addActionError(getText(CUSTOMER_NOT_UPDATED,Collections.singletonList(oldName)));
    }
 else {
      addActionMessage(getText(CUSTOMER_UPDATED,Collections.singletonList(oldName)));
    }
  }
 catch (  Exception e) {
    throw new PhrescoException(e);
  }
  return list();
}"
50977,"public String browse(){
  S_LOGGER.debug(""String_Node_Str"");
  try {
    String projectLocation=Utility.getProjectHome() + projectCode;
    getHttpRequest().setAttribute(REQ_PROJECT_LOCATION,projectLocation);
    getHttpRequest().setAttribute(REQ_PROJECT_CODE,projectCode);
  }
 catch (  Exception e) {
    S_LOGGER.error(""String_Node_Str"" + FrameworkUtil.getStackTraceAsString(e));
    new LogErrorReport(e,""String_Node_Str"");
  }
  return SUCCESS;
}","public String browse(){
  S_LOGGER.debug(""String_Node_Str"");
  try {
    String projectLocation=Utility.getProjectHome() + projectCode;
    getHttpRequest().setAttribute(REQ_PROJECT_LOCATION,projectLocation.replace(File.separator,FORWARD_SLASH));
    getHttpRequest().setAttribute(REQ_PROJECT_LOCATION,projectLocation);
    getHttpRequest().setAttribute(REQ_PROJECT_CODE,projectCode);
  }
 catch (  Exception e) {
    S_LOGGER.error(""String_Node_Str"" + FrameworkUtil.getStackTraceAsString(e));
    new LogErrorReport(e,""String_Node_Str"");
  }
  return SUCCESS;
}"
50978,"public static void experiment(boolean fullGraph){
  long[] seeds={11,21,31,41,51,61,71,81,91,101};
  double[] cs={1,10,100,1000,10000,100000,1000000};
  List<EvaluationFunction> evalFuncs=new ArrayList<EvaluationFunction>();
  evalFuncs.add(new Error());
  evalFuncs.add(new F1());
  List<Double> target=EvaluationUtils.createTarget(labels);
  LibSVMParameters svmParms=new LibSVMParameters(LibSVMParameters.C_SVC,cs);
  svmParms.setNumFolds(10);
  svmParms.setWeightLabels(EvaluationUtils.computeWeightLabels(target));
  svmParms.setWeights(EvaluationUtils.computeWeights(target));
  List<Statement> allStmts3=GraphUtils.getStatements4Depth(dataset,instances,4,false);
  List<Statement> allStmts4;
  if (fullGraph) {
    allStmts4=dataset.getStatements(null,null,null,false);
  }
 else {
    allStmts4=GraphUtils.getStatements4Depth(dataset,instances,5,false);
  }
  allStmts3.removeAll(blackList);
  allStmts4.removeAll(blackList);
  DTGraph<String,String> graph3=org.nodes.data.RDF.createDirectedGraph(allStmts3,null,null);
  DTGraph<String,String> graph4=org.nodes.data.RDF.createDirectedGraph(allStmts4,null,null);
  System.out.println(""String_Node_Str"" + graph3.nodes().size() + ""String_Node_Str""+ graph4.nodes().size());
  List<DTNode<String,String>> instanceNodes3=new ArrayList<DTNode<String,String>>();
  List<DTNode<String,String>> instanceNodes4=new ArrayList<DTNode<String,String>>();
  for (  Resource i : instances) {
    instanceNodes3.add(graph3.node(i.toString()));
    instanceNodes4.add(graph4.node(i.toString()));
  }
  int maxHubs=1000;
  List<DTNode<String,String>> RDFTypeHubs=GraphUtils.getTypeHubs(graph4);
  Comparator<Node<String>> compRegDeg=new DegreeComparator<String>();
  MaxObserver<Node<String>> obsRegDeg=new MaxObserver<Node<String>>(maxHubs + instances.size(),compRegDeg);
  obsRegDeg.observe(graph4.nodes());
  List<DTNode<String,String>> regDegreeHubs=new ArrayList<DTNode<String,String>>();
  for (  Node<String> n : obsRegDeg.elements()) {
    regDegreeHubs.add((DTNode<String,String>)n);
  }
  Comparator<DTNode<String,String>> compSigDeg=new SlashBurn.SignatureComparator<String,String>();
  MaxObserver<DTNode<String,String>> obsSigDeg=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compSigDeg);
  obsSigDeg.observe(graph4.nodes());
  List<DTNode<String,String>> sigDegreeHubs=new ArrayList<DTNode<String,String>>(obsSigDeg.elements());
  List<Integer> classes=new ArrayList<Integer>();
  for (  double d : target) {
    classes.add((int)d);
  }
  Classified<DTNode<String,String>> classified=Classification.combine(instanceNodes4,classes);
  InformedAvoidance ia=new InformedAvoidance(graph4,classified,4);
  Comparator<DTNode<String,String>> compUnInformed=ia.uninformedComparator(4);
  MaxObserver<DTNode<String,String>> obsUnInformed=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compUnInformed);
  obsUnInformed.observe(graph4.nodes());
  List<DTNode<String,String>> unInformedDegreeHubs=new ArrayList<DTNode<String,String>>(obsUnInformed.elements());
  Iterator<DTNode<String,String>> ite=unInformedDegreeHubs.iterator();
  while (ite.hasNext())   if (!ia.viableHub(ite.next(),4,4))   ite.remove();
  Comparator<DTNode<String,String>> compInformed=ia.informedComparator(4);
  MaxObserver<DTNode<String,String>> obsInformed=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compInformed);
  obsInformed.observe(graph4.nodes());
  List<DTNode<String,String>> informedDegreeHubs=new ArrayList<DTNode<String,String>>(obsInformed.elements());
  ite=informedDegreeHubs.iterator();
  while (ite.hasNext())   if (!ia.viableHub(ite.next(),4,4))   ite.remove();
  List<DTNode<String,String>> rn=new ArrayList<DTNode<String,String>>();
  Set<String> is=new HashSet<String>();
  for (  Resource r : instances) {
    is.add(r.toString());
  }
  for (  DTNode<String,String> n : graph4.nodes()) {
    if (is.contains(n.label())) {
      rn.add(n);
    }
  }
  RDFTypeHubs.removeAll(rn);
  regDegreeHubs.removeAll(rn);
  sigDegreeHubs.removeAll(rn);
  unInformedDegreeHubs.removeAll(rn);
  informedDegreeHubs.removeAll(rn);
  List<List<DTNode<String,String>>> hubLists=new ArrayList<List<DTNode<String,String>>>();
  hubLists.add(regDegreeHubs);
  System.out.println(sigDegreeHubs);
  boolean forward=true;
  int[] it={0,2,4,6};
  int depth=3;
  int[] hubThs={0,1,2,3,4,5,10,20,30,40,50,100};
  ResultsTable resTableWL=new ResultsTable();
  resTableWL.setDigits(3);
  ResultsTable resTableIST=new ResultsTable();
  resTableIST.setDigits(3);
  MoleculeListMultiGraphExperiment<DTGraph<String,String>> expWL;
  MoleculeListSingleGraphExperiment expIST;
  for (  int th : hubThs) {
    resTableWL.newRow(""String_Node_Str"" + th);
    resTableIST.newRow(""String_Node_Str"" + th);
    for (    List<DTNode<String,String>> hubList : hubLists) {
      boolean regDegree=false;
      int maxSize=hubList.size();
      if (hubList == regDegreeHubs) {
        regDegree=true;
      }
      List<List<DTNode<String,String>>> newIN=new ArrayList<List<DTNode<String,String>>>();
      List<DTGraph<String,String>> newGs=GraphUtils.simplifyGraph3Way(graph3,GraphUtils.createHubMap(hubList.subList(0,Math.min(maxSize,th)),th,regDegree),instanceNodes3,newIN);
      List<WLSubTreeKernel> kernelsWL=new ArrayList<WLSubTreeKernel>();
      for (      int iti : it) {
        kernelsWL.add(new WLSubTreeKernel(iti,true,forward));
      }
      expWL=new MoleculeListMultiGraphExperiment<DTGraph<String,String>>(kernelsWL,seeds,svmParms,GraphUtils.getSubGraphs(newGs.get(0),newIN.get(0),depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expWL.run();
      for (      Result res : expWL.getResults()) {
        resTableWL.addResult(res);
      }
      kernelsWL=new ArrayList<WLSubTreeKernel>();
      for (      int iti : it) {
        kernelsWL.add(new WLSubTreeKernel(iti,true,forward));
      }
      expWL=new MoleculeListMultiGraphExperiment<DTGraph<String,String>>(kernelsWL,seeds,svmParms,GraphUtils.getSubGraphs(newGs.get(1),newIN.get(1),depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expWL.run();
      for (      Result res : expWL.getResults()) {
        resTableWL.addResult(res);
      }
      kernelsWL=new ArrayList<WLSubTreeKernel>();
      for (      int iti : it) {
        kernelsWL.add(new WLSubTreeKernel(iti,true,forward));
      }
      expWL=new MoleculeListMultiGraphExperiment<DTGraph<String,String>>(kernelsWL,seeds,svmParms,GraphUtils.getSubGraphs(newGs.get(2),newIN.get(2),depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expWL.run();
      for (      Result res : expWL.getResults()) {
        resTableWL.addResult(res);
      }
      List<RDFDTGraphIntersectionSubTreeKernel> kernelsIST=new ArrayList<RDFDTGraphIntersectionSubTreeKernel>();
      kernelsIST.add(new RDFDTGraphIntersectionSubTreeKernel(depth,1,true));
      expIST=new MoleculeListSingleGraphExperiment(kernelsIST,seeds,svmParms,newGs.get(0),newIN.get(0),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expIST.run();
      for (      Result res : expIST.getResults()) {
        resTableIST.addResult(res);
      }
      kernelsIST=new ArrayList<RDFDTGraphIntersectionSubTreeKernel>();
      kernelsIST.add(new RDFDTGraphIntersectionSubTreeKernel(depth,1,true));
      expIST=new MoleculeListSingleGraphExperiment(kernelsIST,seeds,svmParms,newGs.get(1),newIN.get(1),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expIST.run();
      for (      Result res : expIST.getResults()) {
        resTableIST.addResult(res);
      }
      kernelsIST=new ArrayList<RDFDTGraphIntersectionSubTreeKernel>();
      kernelsIST.add(new RDFDTGraphIntersectionSubTreeKernel(depth,1,true));
      expIST=new MoleculeListSingleGraphExperiment(kernelsIST,seeds,svmParms,newGs.get(2),newIN.get(2),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expIST.run();
      for (      Result res : expIST.getResults()) {
        resTableIST.addResult(res);
      }
    }
    System.out.println(resTableWL);
    System.out.println(resTableIST);
  }
  resTableWL.addCompResults(resTableWL.getBestResults(resTableIST.getBestResults()));
  resTableIST.addCompResults(resTableIST.getBestResults(resTableWL.getBestResults()));
  System.out.println(resTableWL);
  System.out.println(resTableWL.allScoresToString());
  System.out.println(resTableIST);
  System.out.println(resTableIST.allScoresToString());
  saveResults(resTableWL.toString() + ""String_Node_Str"" + resTableIST.toString(),""String_Node_Str"" + System.currentTimeMillis() + ""String_Node_Str"");
  saveResults(resTableWL.allScoresToString() + ""String_Node_Str"" + resTableIST.allScoresToString(),""String_Node_Str"" + System.currentTimeMillis() + ""String_Node_Str"");
}","public static void experiment(boolean fullGraph){
  long[] seeds={11,21,31,41,51,61,71,81,91,101};
  double[] cs={1,10,100,1000,10000,100000,1000000};
  List<EvaluationFunction> evalFuncs=new ArrayList<EvaluationFunction>();
  evalFuncs.add(new Error());
  evalFuncs.add(new F1());
  List<Double> target=EvaluationUtils.createTarget(labels);
  LibSVMParameters svmParms=new LibSVMParameters(LibSVMParameters.C_SVC,cs);
  svmParms.setNumFolds(10);
  svmParms.setWeightLabels(EvaluationUtils.computeWeightLabels(target));
  svmParms.setWeights(EvaluationUtils.computeWeights(target));
  List<Statement> allStmts3=GraphUtils.getStatements4Depth(dataset,instances,4,false);
  List<Statement> allStmts4;
  if (fullGraph) {
    allStmts4=dataset.getStatements(null,null,null,false);
  }
 else {
    allStmts4=GraphUtils.getStatements4Depth(dataset,instances,5,false);
  }
  allStmts3.removeAll(blackList);
  allStmts4.removeAll(blackList);
  DTGraph<String,String> graph3=org.nodes.data.RDF.createDirectedGraph(allStmts3,null,null);
  DTGraph<String,String> graph4=org.nodes.data.RDF.createDirectedGraph(allStmts4,null,null);
  System.out.println(""String_Node_Str"" + graph3.nodes().size() + ""String_Node_Str""+ graph4.nodes().size());
  List<DTNode<String,String>> instanceNodes3=new ArrayList<DTNode<String,String>>();
  List<DTNode<String,String>> instanceNodes4=new ArrayList<DTNode<String,String>>();
  for (  Resource i : instances) {
    instanceNodes3.add(graph3.node(i.toString()));
    instanceNodes4.add(graph4.node(i.toString()));
  }
  int maxHubs=1000;
  List<DTNode<String,String>> RDFTypeHubs=GraphUtils.getTypeHubs(graph4);
  Comparator<Node<String>> compRegDeg=new DegreeComparator<String>();
  MaxObserver<Node<String>> obsRegDeg=new MaxObserver<Node<String>>(maxHubs + instances.size(),compRegDeg);
  obsRegDeg.observe(graph4.nodes());
  List<DTNode<String,String>> regDegreeHubs=new ArrayList<DTNode<String,String>>();
  for (  Node<String> n : obsRegDeg.elements()) {
    regDegreeHubs.add((DTNode<String,String>)n);
  }
  Comparator<DTNode<String,String>> compSigDeg=new SlashBurn.SignatureComparator<String,String>();
  MaxObserver<DTNode<String,String>> obsSigDeg=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compSigDeg);
  obsSigDeg.observe(graph4.nodes());
  List<DTNode<String,String>> sigDegreeHubs=new ArrayList<DTNode<String,String>>(obsSigDeg.elements());
  List<Integer> classes=new ArrayList<Integer>();
  for (  double d : target) {
    classes.add((int)d);
  }
  Classified<DTNode<String,String>> classified=Classification.combine(instanceNodes4,classes);
  InformedAvoidance ia=new InformedAvoidance(graph4,classified,4);
  Comparator<DTNode<String,String>> compUnInformed=ia.uninformedComparator(4);
  MaxObserver<DTNode<String,String>> obsUnInformed=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compUnInformed);
  obsUnInformed.observe(graph4.nodes());
  List<DTNode<String,String>> unInformedDegreeHubs=new ArrayList<DTNode<String,String>>(obsUnInformed.elements());
  Iterator<DTNode<String,String>> ite=unInformedDegreeHubs.iterator();
  while (ite.hasNext())   if (!ia.viableHub(ite.next(),4,4))   ite.remove();
  Comparator<DTNode<String,String>> compInformed=ia.informedComparator(4);
  MaxObserver<DTNode<String,String>> obsInformed=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compInformed);
  obsInformed.observe(graph4.nodes());
  List<DTNode<String,String>> informedDegreeHubs=new ArrayList<DTNode<String,String>>(obsInformed.elements());
  ite=informedDegreeHubs.iterator();
  while (ite.hasNext())   if (!ia.viableHub(ite.next(),4,4))   ite.remove();
  List<DTNode<String,String>> rn=new ArrayList<DTNode<String,String>>();
  Set<String> is=new HashSet<String>();
  for (  Resource r : instances) {
    is.add(r.toString());
  }
  for (  DTNode<String,String> n : graph4.nodes()) {
    if (is.contains(n.label())) {
      rn.add(n);
    }
  }
  RDFTypeHubs.removeAll(rn);
  regDegreeHubs.removeAll(rn);
  sigDegreeHubs.removeAll(rn);
  unInformedDegreeHubs.removeAll(rn);
  informedDegreeHubs.removeAll(rn);
  List<List<DTNode<String,String>>> hubLists=new ArrayList<List<DTNode<String,String>>>();
  hubLists.add(regDegreeHubs);
  System.out.println(sigDegreeHubs);
  boolean forward=true;
  int[] it={0,2,4,6};
  int depth=3;
  int[] hubThs={1,2,3,4,5,10,20,30,40,50,100};
  ResultsTable resTableWL=new ResultsTable();
  resTableWL.setDigits(3);
  ResultsTable resTableIST=new ResultsTable();
  resTableIST.setDigits(3);
  MoleculeListMultiGraphExperiment<DTGraph<String,String>> expWL;
  MoleculeListSingleGraphExperiment expIST;
  for (  int th : hubThs) {
    resTableWL.newRow(""String_Node_Str"" + th);
    resTableIST.newRow(""String_Node_Str"" + th);
    for (    List<DTNode<String,String>> hubList : hubLists) {
      boolean regDegree=false;
      int maxSize=hubList.size();
      if (hubList == regDegreeHubs) {
        regDegree=true;
      }
      List<List<DTNode<String,String>>> newIN=new ArrayList<List<DTNode<String,String>>>();
      List<DTGraph<String,String>> newGs=GraphUtils.simplifyGraph3Way(graph3,GraphUtils.createHubMap(hubList.subList(0,Math.min(maxSize,th)),10000,regDegree),instanceNodes3,newIN);
      List<WLSubTreeKernel> kernelsWL=new ArrayList<WLSubTreeKernel>();
      for (      int iti : it) {
        kernelsWL.add(new WLSubTreeKernel(iti,true,forward));
      }
      expWL=new MoleculeListMultiGraphExperiment<DTGraph<String,String>>(kernelsWL,seeds,svmParms,GraphUtils.getSubGraphs(newGs.get(0),newIN.get(0),depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expWL.run();
      for (      Result res : expWL.getResults()) {
        resTableWL.addResult(res);
      }
      kernelsWL=new ArrayList<WLSubTreeKernel>();
      for (      int iti : it) {
        kernelsWL.add(new WLSubTreeKernel(iti,true,forward));
      }
      expWL=new MoleculeListMultiGraphExperiment<DTGraph<String,String>>(kernelsWL,seeds,svmParms,GraphUtils.getSubGraphs(newGs.get(1),newIN.get(1),depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expWL.run();
      for (      Result res : expWL.getResults()) {
        resTableWL.addResult(res);
      }
      kernelsWL=new ArrayList<WLSubTreeKernel>();
      for (      int iti : it) {
        kernelsWL.add(new WLSubTreeKernel(iti,true,forward));
      }
      expWL=new MoleculeListMultiGraphExperiment<DTGraph<String,String>>(kernelsWL,seeds,svmParms,GraphUtils.getSubGraphs(newGs.get(2),newIN.get(2),depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expWL.run();
      for (      Result res : expWL.getResults()) {
        resTableWL.addResult(res);
      }
    }
    System.out.println(resTableWL);
    System.out.println(resTableIST);
  }
  resTableWL.addCompResults(resTableWL.getBestResults(resTableIST.getBestResults()));
  resTableIST.addCompResults(resTableIST.getBestResults(resTableWL.getBestResults()));
  System.out.println(resTableWL);
  System.out.println(resTableWL.allScoresToString());
  System.out.println(resTableIST);
  System.out.println(resTableIST.allScoresToString());
  saveResults(resTableWL.toString() + ""String_Node_Str"" + resTableIST.toString(),""String_Node_Str"" + System.currentTimeMillis() + ""String_Node_Str"");
  saveResults(resTableWL.allScoresToString() + ""String_Node_Str"" + resTableIST.allScoresToString(),""String_Node_Str"" + System.currentTimeMillis() + ""String_Node_Str"");
}"
50979,"public static void experiment(List<UGraph<String>> graphs,List<Double> labels){
  long[] seeds={11,21,31,41,51,61,71,81,91,101};
  double[] cs={0.0001,0.001,0.01,0.1,1,10,100,1000,10000};
  List<EvaluationFunction> evalFuncs=new ArrayList<EvaluationFunction>();
  evalFuncs.add(new Error());
  evalFuncs.add(new F1());
  List<Double> target=EvaluationUtils.createTarget(labels);
  LibSVMParameters svmParms=new LibSVMParameters(LibSVMParameters.C_SVC,cs);
  svmParms.setNumFolds(10);
  List<List<Statement>> rdfTriples2=createMoleculeRDFGraphs(graphs,false);
  RDFDataSet ts=new RDFSingleDataSet();
  for (  List<Statement> trips : rdfTriples2) {
    ts.addStatements(trips);
  }
  List<Resource> instances=new ArrayList<Resource>();
  List<Statement> stmts=ts.getStatementsFromStrings(null,RDF.TYPE.stringValue(),GraphUtils.NAMESPACE + ""String_Node_Str"");
  for (  Statement stmt : stmts) {
    instances.add(stmt.getSubject());
  }
  DTGraph<String,String> sGraph=org.nodes.data.RDF.createDirectedGraph(ts.getStatements(null,null,null,false),null,null);
  ResultsTable resTable=new ResultsTable();
  resTable.setDigits(3);
  List<DTNode<String,String>> instanceNodes=new ArrayList<DTNode<String,String>>();
  for (  Resource i : instances) {
    instanceNodes.add(sGraph.node(i.toString()));
  }
  int maxHubs=1000;
  List<DTNode<String,String>> RDFTypeHubs=GraphUtils.getTypeHubs(sGraph);
  Comparator<Node<String>> compRegDeg=new DegreeComparator<String>();
  MaxObserver<Node<String>> obsRegDeg=new MaxObserver<Node<String>>(maxHubs + instances.size(),compRegDeg);
  obsRegDeg.observe(sGraph.nodes());
  List<DTNode<String,String>> regDegreeHubs=new ArrayList<DTNode<String,String>>();
  for (  Node<String> n : obsRegDeg.elements()) {
    regDegreeHubs.add((DTNode<String,String>)n);
  }
  Comparator<DTNode<String,String>> compSigDeg=new SlashBurn.SignatureComparator<String,String>();
  MaxObserver<DTNode<String,String>> obsSigDeg=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compSigDeg);
  obsSigDeg.observe(sGraph.nodes());
  List<DTNode<String,String>> sigDegreeHubs=new ArrayList<DTNode<String,String>>(obsSigDeg.elements());
  List<Integer> classes=new ArrayList<Integer>();
  for (  double d : target) {
    classes.add((int)d);
  }
  Classified<DTNode<String,String>> classified=Classification.combine(instanceNodes,classes);
  InformedAvoidance ia=new InformedAvoidance(sGraph,classified,4);
  Comparator<DTNode<String,String>> compUnInformed=ia.uninformedComparator(4);
  MaxObserver<DTNode<String,String>> obsUnInformed=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compUnInformed);
  obsUnInformed.observe(sGraph.nodes());
  List<DTNode<String,String>> unInformedDegreeHubs=new ArrayList<DTNode<String,String>>(obsUnInformed.elements());
  Iterator<DTNode<String,String>> ite=unInformedDegreeHubs.iterator();
  while (ite.hasNext())   if (!ia.viableHub(ite.next(),4,4))   ite.remove();
  Comparator<DTNode<String,String>> compInformed=ia.informedComparator(4);
  MaxObserver<DTNode<String,String>> obsInformed=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compInformed);
  obsInformed.observe(sGraph.nodes());
  List<DTNode<String,String>> informedDegreeHubs=new ArrayList<DTNode<String,String>>(obsInformed.elements());
  ite=informedDegreeHubs.iterator();
  while (ite.hasNext())   if (!ia.viableHub(ite.next(),4,4))   ite.remove();
  List<DTNode<String,String>> rn=new ArrayList<DTNode<String,String>>();
  Set<String> is=new HashSet<String>();
  for (  Resource r : instances) {
    is.add(r.toString());
  }
  for (  DTNode<String,String> n : sGraph.nodes()) {
    if (is.contains(n.label())) {
      rn.add(n);
    }
  }
  RDFTypeHubs.removeAll(rn);
  regDegreeHubs.removeAll(rn);
  sigDegreeHubs.removeAll(rn);
  unInformedDegreeHubs.removeAll(rn);
  informedDegreeHubs.removeAll(rn);
  List<List<DTNode<String,String>>> hubLists=new ArrayList<List<DTNode<String,String>>>();
  hubLists.add(RDFTypeHubs);
  hubLists.add(regDegreeHubs);
  hubLists.add(sigDegreeHubs);
  boolean forward=true;
  int it=6;
  int depth=3;
  int[] hubThs={0,1,2,3,4,5,6,7,8,9};
  int[] iterations={0,1,2,3,4,5,6};
  int[] iterations2={0,2,4,6,8,10,12};
  List<WLUSubTreeKernel> kernelsUWL=new ArrayList<WLUSubTreeKernel>();
  for (  int i : iterations) {
    kernelsUWL.add(new WLUSubTreeKernel(i,true));
  }
  MoleculeListMultiGraphExperiment<UGraph<String>> exp=new MoleculeListMultiGraphExperiment<UGraph<String>>(kernelsUWL,seeds,svmParms,graphs,labels,evalFuncs);
  System.out.println(""String_Node_Str"");
  exp.run();
  for (  Result res : exp.getResults()) {
    resTable.addResult(res);
  }
  System.out.println(resTable);
  MoleculeListMultiGraphExperiment<DTGraph<String,String>> exp2;
  for (  int th : hubThs) {
    resTable.newRow(""String_Node_Str"" + th);
    for (    List<DTNode<String,String>> hubList : hubLists) {
      List<WLSubTreeKernel> kernelsWL=new ArrayList<WLSubTreeKernel>();
      for (      int i : iterations2) {
        kernelsWL.add(new WLSubTreeKernel(i,true,forward));
      }
      List<DTNode<String,String>> newIN=new ArrayList<DTNode<String,String>>(instanceNodes);
      DTGraph<String,String> newG=GraphUtils.simplifyGraph(sGraph,GraphUtils.createHubMap(hubList,th),newIN,false,true);
      exp2=new MoleculeListMultiGraphExperiment<DTGraph<String,String>>(kernelsWL,seeds,svmParms,GraphUtils.getSubGraphs(newG,newIN,depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      exp2.run();
      for (      Result res : exp2.getResults()) {
        resTable.addResult(res);
      }
      kernelsWL=new ArrayList<WLSubTreeKernel>();
      for (      int i : iterations2) {
        kernelsWL.add(new WLSubTreeKernel(i,true,forward));
      }
      newIN=new ArrayList<DTNode<String,String>>(instanceNodes);
      newG=GraphUtils.simplifyGraph(sGraph,GraphUtils.createHubMap(hubList,th),newIN,true,false);
      exp2=new MoleculeListMultiGraphExperiment<DTGraph<String,String>>(kernelsWL,seeds,svmParms,GraphUtils.getSubGraphs(newG,newIN,depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      exp2.run();
      for (      Result res : exp2.getResults()) {
        resTable.addResult(res);
      }
      kernelsWL=new ArrayList<WLSubTreeKernel>();
      for (      int i : iterations2) {
        kernelsWL.add(new WLSubTreeKernel(i,true,forward));
      }
      newIN=new ArrayList<DTNode<String,String>>(instanceNodes);
      newG=GraphUtils.simplifyGraph(sGraph,GraphUtils.createHubMap(hubList,th),newIN,true,true);
      exp2=new MoleculeListMultiGraphExperiment<DTGraph<String,String>>(kernelsWL,seeds,svmParms,GraphUtils.getSubGraphs(newG,newIN,depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      exp2.run();
      for (      Result res : exp2.getResults()) {
        resTable.addResult(res);
      }
    }
    System.out.println(resTable);
  }
  resTable.addCompResults(resTable.getBestResults());
  System.out.println(resTable);
  System.out.println(resTable.allScoresToString());
}","public static void experiment(List<UGraph<String>> graphs,List<Double> labels){
  long[] seeds={11,21,31,41,51,61,71,81,91,101};
  double[] cs={1,10,100,1000,10000};
  List<EvaluationFunction> evalFuncs=new ArrayList<EvaluationFunction>();
  evalFuncs.add(new Error());
  evalFuncs.add(new F1());
  List<Double> target=EvaluationUtils.createTarget(labels);
  LibSVMParameters svmParms=new LibSVMParameters(LibSVMParameters.C_SVC,cs);
  svmParms.setNumFolds(10);
  List<List<Statement>> rdfTriples2=createMoleculeRDFGraphs(graphs,false);
  RDFDataSet ts=new RDFSingleDataSet();
  for (  List<Statement> trips : rdfTriples2) {
    ts.addStatements(trips);
  }
  List<Resource> instances=new ArrayList<Resource>();
  List<Statement> stmts=ts.getStatementsFromStrings(null,RDF.TYPE.stringValue(),GraphUtils.NAMESPACE + ""String_Node_Str"");
  for (  Statement stmt : stmts) {
    instances.add(stmt.getSubject());
  }
  DTGraph<String,String> sGraph=org.nodes.data.RDF.createDirectedGraph(ts.getStatements(null,null,null,false),null,null);
  ResultsTable resTable=new ResultsTable();
  resTable.setDigits(3);
  List<DTNode<String,String>> instanceNodes=new ArrayList<DTNode<String,String>>();
  for (  Resource i : instances) {
    instanceNodes.add(sGraph.node(i.toString()));
  }
  int maxHubs=1000;
  List<DTNode<String,String>> RDFTypeHubs=GraphUtils.getTypeHubs(sGraph);
  Comparator<Node<String>> compRegDeg=new DegreeComparator<String>();
  MaxObserver<Node<String>> obsRegDeg=new MaxObserver<Node<String>>(maxHubs + instances.size(),compRegDeg);
  obsRegDeg.observe(sGraph.nodes());
  List<DTNode<String,String>> regDegreeHubs=new ArrayList<DTNode<String,String>>();
  for (  Node<String> n : obsRegDeg.elements()) {
    regDegreeHubs.add((DTNode<String,String>)n);
  }
  Comparator<DTNode<String,String>> compSigDeg=new SlashBurn.SignatureComparator<String,String>();
  MaxObserver<DTNode<String,String>> obsSigDeg=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compSigDeg);
  obsSigDeg.observe(sGraph.nodes());
  List<DTNode<String,String>> sigDegreeHubs=new ArrayList<DTNode<String,String>>(obsSigDeg.elements());
  List<Integer> classes=new ArrayList<Integer>();
  for (  double d : target) {
    classes.add((int)d);
  }
  Classified<DTNode<String,String>> classified=Classification.combine(instanceNodes,classes);
  InformedAvoidance ia=new InformedAvoidance(sGraph,classified,4);
  Comparator<DTNode<String,String>> compUnInformed=ia.uninformedComparator(4);
  MaxObserver<DTNode<String,String>> obsUnInformed=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compUnInformed);
  obsUnInformed.observe(sGraph.nodes());
  List<DTNode<String,String>> unInformedDegreeHubs=new ArrayList<DTNode<String,String>>(obsUnInformed.elements());
  Iterator<DTNode<String,String>> ite=unInformedDegreeHubs.iterator();
  while (ite.hasNext())   if (!ia.viableHub(ite.next(),4,4))   ite.remove();
  Comparator<DTNode<String,String>> compInformed=ia.informedComparator(4);
  MaxObserver<DTNode<String,String>> obsInformed=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compInformed);
  obsInformed.observe(sGraph.nodes());
  List<DTNode<String,String>> informedDegreeHubs=new ArrayList<DTNode<String,String>>(obsInformed.elements());
  ite=informedDegreeHubs.iterator();
  while (ite.hasNext())   if (!ia.viableHub(ite.next(),4,4))   ite.remove();
  List<DTNode<String,String>> rn=new ArrayList<DTNode<String,String>>();
  Set<String> is=new HashSet<String>();
  for (  Resource r : instances) {
    is.add(r.toString());
  }
  for (  DTNode<String,String> n : sGraph.nodes()) {
    if (is.contains(n.label())) {
      rn.add(n);
    }
  }
  RDFTypeHubs.removeAll(rn);
  regDegreeHubs.removeAll(rn);
  sigDegreeHubs.removeAll(rn);
  unInformedDegreeHubs.removeAll(rn);
  informedDegreeHubs.removeAll(rn);
  List<List<DTNode<String,String>>> hubLists=new ArrayList<List<DTNode<String,String>>>();
  hubLists.add(RDFTypeHubs);
  hubLists.add(regDegreeHubs);
  hubLists.add(sigDegreeHubs);
  boolean forward=true;
  int it=6;
  int depth=3;
  int[] hubThs={0,1,2,3,4,5,6,7,8,9};
  int[] iterations={1,2,3,4,5,6};
  int[] iterations2={0,2,4,6,8,10,12};
  List<WLUSubTreeKernel> kernelsUWL=new ArrayList<WLUSubTreeKernel>();
  for (  int i : iterations) {
    kernelsUWL.add(new WLUSubTreeKernel(i,true));
  }
  MoleculeListMultiGraphExperiment<UGraph<String>> exp=new MoleculeListMultiGraphExperiment<UGraph<String>>(kernelsUWL,seeds,svmParms,graphs,labels,evalFuncs);
  System.out.println(""String_Node_Str"");
  exp.run();
  resTable.newRow(""String_Node_Str"");
  for (  Result res : exp.getResults()) {
    resTable.addResult(res);
  }
  System.out.println(resTable);
  MoleculeListMultiGraphExperiment<DTGraph<String,String>> exp2;
  for (  int th : hubThs) {
    resTable.newRow(""String_Node_Str"" + th);
    for (    List<DTNode<String,String>> hubList : hubLists) {
      List<WLSubTreeKernel> kernelsWL=new ArrayList<WLSubTreeKernel>();
      for (      int i : iterations2) {
        kernelsWL.add(new WLSubTreeKernel(i,true,forward));
      }
      List<DTNode<String,String>> newIN=new ArrayList<DTNode<String,String>>(instanceNodes);
      DTGraph<String,String> newG=GraphUtils.simplifyGraph(sGraph,GraphUtils.createHubMap(hubList,th),newIN,false,true);
      exp2=new MoleculeListMultiGraphExperiment<DTGraph<String,String>>(kernelsWL,seeds,svmParms,GraphUtils.getSubGraphs(newG,newIN,depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      exp2.run();
      for (      Result res : exp2.getResults()) {
        resTable.addResult(res);
      }
      kernelsWL=new ArrayList<WLSubTreeKernel>();
      for (      int i : iterations2) {
        kernelsWL.add(new WLSubTreeKernel(i,true,forward));
      }
      newIN=new ArrayList<DTNode<String,String>>(instanceNodes);
      newG=GraphUtils.simplifyGraph(sGraph,GraphUtils.createHubMap(hubList,th),newIN,true,false);
      exp2=new MoleculeListMultiGraphExperiment<DTGraph<String,String>>(kernelsWL,seeds,svmParms,GraphUtils.getSubGraphs(newG,newIN,depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      exp2.run();
      for (      Result res : exp2.getResults()) {
        resTable.addResult(res);
      }
      kernelsWL=new ArrayList<WLSubTreeKernel>();
      for (      int i : iterations2) {
        kernelsWL.add(new WLSubTreeKernel(i,true,forward));
      }
      newIN=new ArrayList<DTNode<String,String>>(instanceNodes);
      newG=GraphUtils.simplifyGraph(sGraph,GraphUtils.createHubMap(hubList,th),newIN,true,true);
      exp2=new MoleculeListMultiGraphExperiment<DTGraph<String,String>>(kernelsWL,seeds,svmParms,GraphUtils.getSubGraphs(newG,newIN,depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      exp2.run();
      for (      Result res : exp2.getResults()) {
        resTable.addResult(res);
      }
    }
    System.out.println(resTable);
  }
  resTable.addCompResults(resTable.getBestResults());
  System.out.println(resTable);
  System.out.println(resTable.allScoresToString());
}"
50980,"public static void main(String[] args){
  List<UGraph<String>> graphs=new ArrayList<UGraph<String>>();
  List<Double> labels=new ArrayList<Double>();
  createDataSet(MUTAG_DIR,graphs,labels);
  experiment(graphs,labels);
  graphs=new ArrayList<UGraph<String>>();
  labels=new ArrayList<Double>();
  createDataSet(ENZYMES_DIR,graphs,labels);
  experiment(graphs,labels);
}","public static void main(String[] args){
  List<UGraph<String>> graphs=new ArrayList<UGraph<String>>();
  List<Double> labels=new ArrayList<Double>();
  graphs=new ArrayList<UGraph<String>>();
  labels=new ArrayList<Double>();
  createDataSet(ENZYMES_DIR,graphs,labels);
  experiment(graphs,labels);
}"
50981,"public static void experiment(boolean fullGraph){
  long[] seeds={11,21,31,41,51,61,71,81,91,101};
  double[] cs={1,10,100,1000,10000,100000,1000000};
  List<EvaluationFunction> evalFuncs=new ArrayList<EvaluationFunction>();
  evalFuncs.add(new Error());
  evalFuncs.add(new F1());
  List<Double> target=EvaluationUtils.createTarget(labels);
  LibSVMParameters svmParms=new LibSVMParameters(LibSVMParameters.C_SVC,cs);
  svmParms.setNumFolds(10);
  svmParms.setWeightLabels(EvaluationUtils.computeWeightLabels(target));
  svmParms.setWeights(EvaluationUtils.computeWeights(target));
  List<Statement> allStmts3=GraphUtils.getStatements4Depth(dataset,instances,4,false);
  List<Statement> allStmts4;
  if (fullGraph) {
    allStmts4=dataset.getStatements(null,null,null,false);
  }
 else {
    allStmts4=GraphUtils.getStatements4Depth(dataset,instances,5,false);
  }
  allStmts3.removeAll(blackList);
  allStmts4.removeAll(blackList);
  DTGraph<String,String> graph3=org.nodes.data.RDF.createDirectedGraph(allStmts3,null,null);
  DTGraph<String,String> graph4=org.nodes.data.RDF.createDirectedGraph(allStmts4,null,null);
  System.out.println(""String_Node_Str"" + graph3.nodes().size() + ""String_Node_Str""+ graph4.nodes().size());
  List<DTNode<String,String>> instanceNodes3=new ArrayList<DTNode<String,String>>();
  List<DTNode<String,String>> instanceNodes4=new ArrayList<DTNode<String,String>>();
  for (  Resource i : instances) {
    instanceNodes3.add(graph3.node(i.toString()));
    instanceNodes4.add(graph4.node(i.toString()));
  }
  int maxHubs=1000;
  List<DTNode<String,String>> RDFTypeHubs=GraphUtils.getTypeHubs(graph4);
  Comparator<Node<String>> compRegDeg=new DegreeComparator<String>();
  MaxObserver<Node<String>> obsRegDeg=new MaxObserver<Node<String>>(maxHubs + instances.size(),compRegDeg);
  obsRegDeg.observe(graph4.nodes());
  List<DTNode<String,String>> regDegreeHubs=new ArrayList<DTNode<String,String>>();
  for (  Node<String> n : obsRegDeg.elements()) {
    regDegreeHubs.add((DTNode<String,String>)n);
  }
  Comparator<DTNode<String,String>> compSigDeg=new SlashBurn.SignatureComparator<String,String>();
  MaxObserver<DTNode<String,String>> obsSigDeg=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compSigDeg);
  obsSigDeg.observe(graph4.nodes());
  List<DTNode<String,String>> sigDegreeHubs=new ArrayList<DTNode<String,String>>(obsSigDeg.elements());
  List<Integer> classes=new ArrayList<Integer>();
  for (  double d : target) {
    classes.add((int)d);
  }
  Classified<DTNode<String,String>> classified=Classification.combine(instanceNodes4,classes);
  InformedAvoidance ia=new InformedAvoidance(graph4,classified,4);
  Comparator<DTNode<String,String>> compUnInformed=ia.uninformedComparator(4);
  MaxObserver<DTNode<String,String>> obsUnInformed=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compUnInformed);
  obsUnInformed.observe(graph4.nodes());
  List<DTNode<String,String>> unInformedDegreeHubs=new ArrayList<DTNode<String,String>>(obsUnInformed.elements());
  Iterator<DTNode<String,String>> ite=unInformedDegreeHubs.iterator();
  while (ite.hasNext())   if (!ia.viableHub(ite.next(),4,4))   ite.remove();
  Comparator<DTNode<String,String>> compInformed=ia.informedComparator(4);
  MaxObserver<DTNode<String,String>> obsInformed=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compInformed);
  obsInformed.observe(graph4.nodes());
  List<DTNode<String,String>> informedDegreeHubs=new ArrayList<DTNode<String,String>>(obsInformed.elements());
  ite=informedDegreeHubs.iterator();
  while (ite.hasNext())   if (!ia.viableHub(ite.next(),4,4))   ite.remove();
  List<DTNode<String,String>> rn=new ArrayList<DTNode<String,String>>();
  Set<String> is=new HashSet<String>();
  for (  Resource r : instances) {
    is.add(r.toString());
  }
  for (  DTNode<String,String> n : graph4.nodes()) {
    if (is.contains(n.label())) {
      rn.add(n);
    }
  }
  RDFTypeHubs.removeAll(rn);
  regDegreeHubs.removeAll(rn);
  sigDegreeHubs.removeAll(rn);
  unInformedDegreeHubs.removeAll(rn);
  informedDegreeHubs.removeAll(rn);
  List<List<DTNode<String,String>>> hubLists=new ArrayList<List<DTNode<String,String>>>();
  hubLists.add(sigDegreeHubs);
  System.out.println(sigDegreeHubs);
  boolean forward=true;
  int[] it={0,2,4,6};
  int depth=3;
  int[] hubThs={25,26,27,28,29,30,31,32,33,34,35};
  ResultsTable resTableWL=new ResultsTable();
  resTableWL.setDigits(3);
  ResultsTable resTableIST=new ResultsTable();
  resTableIST.setDigits(3);
  MoleculeListMultiGraphExperiment<DTGraph<String,String>> expWL;
  MoleculeListSingleGraphExperiment expIST;
  for (  int th : hubThs) {
    resTableWL.newRow(""String_Node_Str"" + th);
    resTableIST.newRow(""String_Node_Str"" + th);
    for (    List<DTNode<String,String>> hubList : hubLists) {
      List<List<DTNode<String,String>>> newIN=new ArrayList<List<DTNode<String,String>>>();
      List<DTGraph<String,String>> newGs=GraphUtils.simplifyGraph3Way(graph3,GraphUtils.createHubMap(hubList,th),instanceNodes3,newIN);
      List<WLSubTreeKernel> kernelsWL=new ArrayList<WLSubTreeKernel>();
      kernelsWL=new ArrayList<WLSubTreeKernel>();
      for (      int iti : it) {
        kernelsWL.add(new WLSubTreeKernel(iti,true,forward));
      }
      expWL=new MoleculeListMultiGraphExperiment<DTGraph<String,String>>(kernelsWL,seeds,svmParms,GraphUtils.getSubGraphs(newGs.get(2),newIN.get(2),depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expWL.run();
      for (      Result res : expWL.getResults()) {
        resTableWL.addResult(res);
      }
    }
    System.out.println(resTableWL);
    System.out.println(resTableIST);
  }
  resTableWL.addCompResults(resTableWL.getBestResults(resTableIST.getBestResults()));
  resTableIST.addCompResults(resTableIST.getBestResults(resTableWL.getBestResults()));
  System.out.println(resTableWL);
  System.out.println(resTableWL.allScoresToString());
  System.out.println(resTableIST);
  System.out.println(resTableIST.allScoresToString());
  saveResults(resTableWL.toString() + ""String_Node_Str"" + resTableIST.toString(),""String_Node_Str"" + System.currentTimeMillis() + ""String_Node_Str"");
  saveResults(resTableWL.allScoresToString() + ""String_Node_Str"" + resTableIST.allScoresToString(),""String_Node_Str"" + System.currentTimeMillis() + ""String_Node_Str"");
}","public static void experiment(boolean fullGraph){
  long[] seeds={11,21,31,41,51,61,71,81,91,101};
  double[] cs={1,10,100,1000,10000,100000,1000000};
  List<EvaluationFunction> evalFuncs=new ArrayList<EvaluationFunction>();
  evalFuncs.add(new Error());
  evalFuncs.add(new F1());
  List<Double> target=EvaluationUtils.createTarget(labels);
  LibSVMParameters svmParms=new LibSVMParameters(LibSVMParameters.C_SVC,cs);
  svmParms.setNumFolds(10);
  svmParms.setWeightLabels(EvaluationUtils.computeWeightLabels(target));
  svmParms.setWeights(EvaluationUtils.computeWeights(target));
  List<Statement> allStmts3=GraphUtils.getStatements4Depth(dataset,instances,4,false);
  List<Statement> allStmts4;
  if (fullGraph) {
    allStmts4=dataset.getStatements(null,null,null,false);
  }
 else {
    allStmts4=GraphUtils.getStatements4Depth(dataset,instances,5,false);
  }
  allStmts3.removeAll(blackList);
  allStmts4.removeAll(blackList);
  DTGraph<String,String> graph3=org.nodes.data.RDF.createDirectedGraph(allStmts3,null,null);
  DTGraph<String,String> graph4=org.nodes.data.RDF.createDirectedGraph(allStmts4,null,null);
  System.out.println(""String_Node_Str"" + graph3.nodes().size() + ""String_Node_Str""+ graph4.nodes().size());
  List<DTNode<String,String>> instanceNodes3=new ArrayList<DTNode<String,String>>();
  List<DTNode<String,String>> instanceNodes4=new ArrayList<DTNode<String,String>>();
  for (  Resource i : instances) {
    instanceNodes3.add(graph3.node(i.toString()));
    instanceNodes4.add(graph4.node(i.toString()));
  }
  int maxHubs=1000;
  List<DTNode<String,String>> RDFTypeHubs=GraphUtils.getTypeHubs(graph4);
  Comparator<Node<String>> compRegDeg=new DegreeComparator<String>();
  MaxObserver<Node<String>> obsRegDeg=new MaxObserver<Node<String>>(maxHubs + instances.size(),compRegDeg);
  obsRegDeg.observe(graph4.nodes());
  List<DTNode<String,String>> regDegreeHubs=new ArrayList<DTNode<String,String>>();
  for (  Node<String> n : obsRegDeg.elements()) {
    regDegreeHubs.add((DTNode<String,String>)n);
  }
  Comparator<DTNode<String,String>> compSigDeg=new SlashBurn.SignatureComparator<String,String>();
  MaxObserver<DTNode<String,String>> obsSigDeg=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compSigDeg);
  obsSigDeg.observe(graph4.nodes());
  List<DTNode<String,String>> sigDegreeHubs=new ArrayList<DTNode<String,String>>(obsSigDeg.elements());
  List<Integer> classes=new ArrayList<Integer>();
  for (  double d : target) {
    classes.add((int)d);
  }
  Classified<DTNode<String,String>> classified=Classification.combine(instanceNodes4,classes);
  InformedAvoidance ia=new InformedAvoidance(graph4,classified,4);
  Comparator<DTNode<String,String>> compUnInformed=ia.uninformedComparator(4);
  MaxObserver<DTNode<String,String>> obsUnInformed=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compUnInformed);
  obsUnInformed.observe(graph4.nodes());
  List<DTNode<String,String>> unInformedDegreeHubs=new ArrayList<DTNode<String,String>>(obsUnInformed.elements());
  Iterator<DTNode<String,String>> ite=unInformedDegreeHubs.iterator();
  while (ite.hasNext())   if (!ia.viableHub(ite.next(),4,4))   ite.remove();
  Comparator<DTNode<String,String>> compInformed=ia.informedComparator(4);
  MaxObserver<DTNode<String,String>> obsInformed=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compInformed);
  obsInformed.observe(graph4.nodes());
  List<DTNode<String,String>> informedDegreeHubs=new ArrayList<DTNode<String,String>>(obsInformed.elements());
  ite=informedDegreeHubs.iterator();
  while (ite.hasNext())   if (!ia.viableHub(ite.next(),4,4))   ite.remove();
  List<DTNode<String,String>> rn=new ArrayList<DTNode<String,String>>();
  Set<String> is=new HashSet<String>();
  for (  Resource r : instances) {
    is.add(r.toString());
  }
  for (  DTNode<String,String> n : graph4.nodes()) {
    if (is.contains(n.label())) {
      rn.add(n);
    }
  }
  RDFTypeHubs.removeAll(rn);
  regDegreeHubs.removeAll(rn);
  sigDegreeHubs.removeAll(rn);
  unInformedDegreeHubs.removeAll(rn);
  informedDegreeHubs.removeAll(rn);
  List<List<DTNode<String,String>>> hubLists=new ArrayList<List<DTNode<String,String>>>();
  hubLists.add(regDegreeHubs);
  System.out.println(sigDegreeHubs);
  boolean forward=true;
  int[] it={0,2,4,6};
  int depth=3;
  int[] hubThs={0,1,2,3,4,5,10,20,30,40,50,100};
  ResultsTable resTableWL=new ResultsTable();
  resTableWL.setDigits(3);
  ResultsTable resTableIST=new ResultsTable();
  resTableIST.setDigits(3);
  MoleculeListMultiGraphExperiment<DTGraph<String,String>> expWL;
  MoleculeListSingleGraphExperiment expIST;
  for (  int th : hubThs) {
    resTableWL.newRow(""String_Node_Str"" + th);
    resTableIST.newRow(""String_Node_Str"" + th);
    for (    List<DTNode<String,String>> hubList : hubLists) {
      boolean regDegree=false;
      int maxSize=hubList.size();
      if (hubList == regDegreeHubs) {
        regDegree=true;
      }
      List<List<DTNode<String,String>>> newIN=new ArrayList<List<DTNode<String,String>>>();
      List<DTGraph<String,String>> newGs=GraphUtils.simplifyGraph3Way(graph3,GraphUtils.createHubMap(hubList.subList(0,Math.min(maxSize,th)),th,regDegree),instanceNodes3,newIN);
      List<WLSubTreeKernel> kernelsWL=new ArrayList<WLSubTreeKernel>();
      for (      int iti : it) {
        kernelsWL.add(new WLSubTreeKernel(iti,true,forward));
      }
      expWL=new MoleculeListMultiGraphExperiment<DTGraph<String,String>>(kernelsWL,seeds,svmParms,GraphUtils.getSubGraphs(newGs.get(0),newIN.get(0),depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expWL.run();
      for (      Result res : expWL.getResults()) {
        resTableWL.addResult(res);
      }
      kernelsWL=new ArrayList<WLSubTreeKernel>();
      for (      int iti : it) {
        kernelsWL.add(new WLSubTreeKernel(iti,true,forward));
      }
      expWL=new MoleculeListMultiGraphExperiment<DTGraph<String,String>>(kernelsWL,seeds,svmParms,GraphUtils.getSubGraphs(newGs.get(1),newIN.get(1),depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expWL.run();
      for (      Result res : expWL.getResults()) {
        resTableWL.addResult(res);
      }
      kernelsWL=new ArrayList<WLSubTreeKernel>();
      for (      int iti : it) {
        kernelsWL.add(new WLSubTreeKernel(iti,true,forward));
      }
      expWL=new MoleculeListMultiGraphExperiment<DTGraph<String,String>>(kernelsWL,seeds,svmParms,GraphUtils.getSubGraphs(newGs.get(2),newIN.get(2),depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expWL.run();
      for (      Result res : expWL.getResults()) {
        resTableWL.addResult(res);
      }
      List<RDFDTGraphIntersectionSubTreeKernel> kernelsIST=new ArrayList<RDFDTGraphIntersectionSubTreeKernel>();
      kernelsIST.add(new RDFDTGraphIntersectionSubTreeKernel(depth,1,true));
      expIST=new MoleculeListSingleGraphExperiment(kernelsIST,seeds,svmParms,newGs.get(0),newIN.get(0),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expIST.run();
      for (      Result res : expIST.getResults()) {
        resTableIST.addResult(res);
      }
      kernelsIST=new ArrayList<RDFDTGraphIntersectionSubTreeKernel>();
      kernelsIST.add(new RDFDTGraphIntersectionSubTreeKernel(depth,1,true));
      expIST=new MoleculeListSingleGraphExperiment(kernelsIST,seeds,svmParms,newGs.get(1),newIN.get(1),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expIST.run();
      for (      Result res : expIST.getResults()) {
        resTableIST.addResult(res);
      }
      kernelsIST=new ArrayList<RDFDTGraphIntersectionSubTreeKernel>();
      kernelsIST.add(new RDFDTGraphIntersectionSubTreeKernel(depth,1,true));
      expIST=new MoleculeListSingleGraphExperiment(kernelsIST,seeds,svmParms,newGs.get(2),newIN.get(2),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expIST.run();
      for (      Result res : expIST.getResults()) {
        resTableIST.addResult(res);
      }
    }
    System.out.println(resTableWL);
    System.out.println(resTableIST);
  }
  resTableWL.addCompResults(resTableWL.getBestResults(resTableIST.getBestResults()));
  resTableIST.addCompResults(resTableIST.getBestResults(resTableWL.getBestResults()));
  System.out.println(resTableWL);
  System.out.println(resTableWL.allScoresToString());
  System.out.println(resTableIST);
  System.out.println(resTableIST.allScoresToString());
  saveResults(resTableWL.toString() + ""String_Node_Str"" + resTableIST.toString(),""String_Node_Str"" + System.currentTimeMillis() + ""String_Node_Str"");
  saveResults(resTableWL.allScoresToString() + ""String_Node_Str"" + resTableIST.allScoresToString(),""String_Node_Str"" + System.currentTimeMillis() + ""String_Node_Str"");
}"
50982,"@Override public void run(){
  long tic, toc;
  List<Double> tempLabels=new ArrayList<Double>();
  tempLabels.addAll(labels);
  Map<String,double[][]> matrices=new HashMap<String,double[][]>();
  tic=System.currentTimeMillis();
  System.out.println(""String_Node_Str"");
  for (  RDFDTGraphIntersectionSubTreeKernel kernel : kernels) {
    double[][] matrix=kernel.compute(graph,iNodes);
    matrices.put(kernel.getLabel(),matrix);
  }
  toc=System.currentTimeMillis();
  compR.setLabel(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  for (int j=0; j < seeds.length; j++) {
    for (    String k : matrices.keySet()) {
      matrices.put(k,KernelUtils.shuffle(matrices.get(k),seeds[j]));
    }
    Collections.shuffle(tempLabels,new Random(seeds[j]));
    double[] target=new double[tempLabels.size()];
    for (int i=0; i < target.length; i++) {
      target[i]=tempLabels.get(i);
    }
    Prediction[] pred=LibSVM.crossValidateWithMultipleKernels(matrices,target,svmParms,svmParms.getNumFolds());
    for (    EvaluationFunction ef : evalFunctions) {
      resultMap.get(ef)[j]=ef.computeScore(target,pred);
    }
  }
  double[] comp={toc - tic};
  compR.setScores(comp);
}","@Override public void run(){
  long tic, toc;
  List<Double> tempLabels=new ArrayList<Double>();
  tempLabels.addAll(labels);
  Map<String,double[][]> matrices=new HashMap<String,double[][]>();
  tic=System.currentTimeMillis();
  System.out.println(""String_Node_Str"");
  for (  RDFDTGraphIntersectionSubTreeKernel kernel : kernels) {
    double[][] matrix=kernel.compute(graph,iNodes);
    matrices.put(kernel.getLabel(),matrix);
  }
  toc=System.currentTimeMillis();
  System.out.println(""String_Node_Str"" + (toc - tic) + ""String_Node_Str"");
  compR.setLabel(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  for (int j=0; j < seeds.length; j++) {
    for (    String k : matrices.keySet()) {
      matrices.put(k,KernelUtils.shuffle(matrices.get(k),seeds[j]));
    }
    Collections.shuffle(tempLabels,new Random(seeds[j]));
    double[] target=new double[tempLabels.size()];
    for (int i=0; i < target.length; i++) {
      target[i]=tempLabels.get(i);
    }
    Prediction[] pred=LibSVM.crossValidateWithMultipleKernels(matrices,target,svmParms,svmParms.getNumFolds());
    for (    EvaluationFunction ef : evalFunctions) {
      resultMap.get(ef)[j]=ef.computeScore(target,pred);
    }
  }
  double[] comp={toc - tic};
  compR.setScores(comp);
}"
50983,"public static void experiment(boolean fullGraph){
  long[] seeds={11,21,31,41,51,61,71,81,91,101};
  double[] cs={0.0001,0.001,0.01,0.1,1,10,100,1000,10000};
  List<EvaluationFunction> evalFuncs=new ArrayList<EvaluationFunction>();
  evalFuncs.add(new Error());
  evalFuncs.add(new F1());
  List<Double> target=EvaluationUtils.createTarget(labels);
  LibSVMParameters svmParms=new LibSVMParameters(LibSVMParameters.C_SVC,cs);
  svmParms.setNumFolds(10);
  svmParms.setWeightLabels(EvaluationUtils.computeWeightLabels(target));
  svmParms.setWeights(EvaluationUtils.computeWeights(target));
  List<Statement> allStmts3=GraphUtils.getStatements4Depth(dataset,instances,4,false);
  List<Statement> allStmts4;
  if (fullGraph) {
    allStmts4=dataset.getStatements(null,null,null,false);
  }
 else {
    allStmts4=GraphUtils.getStatements4Depth(dataset,instances,5,false);
  }
  allStmts3.removeAll(blackList);
  allStmts4.removeAll(blackList);
  DTGraph<String,String> graph3=org.nodes.data.RDF.createDirectedGraph(allStmts3,null,null);
  DTGraph<String,String> graph4=org.nodes.data.RDF.createDirectedGraph(allStmts4,null,null);
  System.out.println(""String_Node_Str"" + graph3.nodes().size() + ""String_Node_Str""+ graph4.nodes().size());
  List<DTNode<String,String>> instanceNodes3=new ArrayList<DTNode<String,String>>();
  List<DTNode<String,String>> instanceNodes4=new ArrayList<DTNode<String,String>>();
  for (  Resource i : instances) {
    instanceNodes3.add(graph3.node(i.toString()));
    instanceNodes4.add(graph4.node(i.toString()));
  }
  int maxHubs=1000;
  List<DTNode<String,String>> RDFTypeHubs=GraphUtils.getTypeHubs(graph4);
  Comparator<Node<String>> compRegDeg=new DegreeComparator<String>();
  MaxObserver<Node<String>> obsRegDeg=new MaxObserver<Node<String>>(maxHubs + instances.size(),compRegDeg);
  obsRegDeg.observe(graph4.nodes());
  List<DTNode<String,String>> regDegreeHubs=new ArrayList<DTNode<String,String>>();
  for (  Node<String> n : obsRegDeg.elements()) {
    regDegreeHubs.add((DTNode<String,String>)n);
  }
  Comparator<DTNode<String,String>> compSigDeg=new SlashBurn.SignatureComparator<String,String>();
  MaxObserver<DTNode<String,String>> obsSigDeg=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compSigDeg);
  obsSigDeg.observe(graph4.nodes());
  List<DTNode<String,String>> sigDegreeHubs=new ArrayList<DTNode<String,String>>(obsSigDeg.elements());
  List<Integer> classes=new ArrayList<Integer>();
  for (  double d : target) {
    classes.add((int)d);
  }
  Classified<DTNode<String,String>> classified=Classification.combine(instanceNodes4,classes);
  InformedAvoidance ia=new InformedAvoidance(graph4,classified,4);
  Comparator<DTNode<String,String>> compUnInformed=ia.uninformedComparator(4);
  MaxObserver<DTNode<String,String>> obsUnInformed=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compUnInformed);
  obsUnInformed.observe(graph4.nodes());
  List<DTNode<String,String>> unInformedDegreeHubs=new ArrayList<DTNode<String,String>>(obsUnInformed.elements());
  Iterator<DTNode<String,String>> ite=unInformedDegreeHubs.iterator();
  while (ite.hasNext())   if (!ia.viableHub(ite.next(),4,4))   ite.remove();
  Comparator<DTNode<String,String>> compInformed=ia.informedComparator(4);
  MaxObserver<DTNode<String,String>> obsInformed=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compInformed);
  obsInformed.observe(graph4.nodes());
  List<DTNode<String,String>> informedDegreeHubs=new ArrayList<DTNode<String,String>>(obsInformed.elements());
  ite=informedDegreeHubs.iterator();
  while (ite.hasNext())   if (!ia.viableHub(ite.next(),4,4))   ite.remove();
  List<DTNode<String,String>> rn=new ArrayList<DTNode<String,String>>();
  Set<String> is=new HashSet<String>();
  for (  Resource r : instances) {
    is.add(r.toString());
  }
  for (  DTNode<String,String> n : graph4.nodes()) {
    if (is.contains(n.label())) {
      rn.add(n);
    }
  }
  RDFTypeHubs.removeAll(rn);
  regDegreeHubs.removeAll(rn);
  sigDegreeHubs.removeAll(rn);
  unInformedDegreeHubs.removeAll(rn);
  informedDegreeHubs.removeAll(rn);
  List<List<DTNode<String,String>>> hubLists=new ArrayList<List<DTNode<String,String>>>();
  hubLists.add(RDFTypeHubs);
  hubLists.add(regDegreeHubs);
  hubLists.add(sigDegreeHubs);
  boolean forward=true;
  int[] it={0,2,4,6};
  int depth=3;
  int[] hubThs={0,1,2,3,4,5,10,20,30,40,50,100};
  ResultsTable resTableWL=new ResultsTable();
  resTableWL.setDigits(3);
  ResultsTable resTableIST=new ResultsTable();
  resTableIST.setDigits(3);
  MoleculeListMultiGraphExperiment<DTGraph<String,String>> expWL;
  MoleculeListSingleGraphExperiment expIST;
  for (  int th : hubThs) {
    resTableWL.newRow(""String_Node_Str"" + th);
    resTableIST.newRow(""String_Node_Str"" + th);
    for (    List<DTNode<String,String>> hubList : hubLists) {
      List<List<DTNode<String,String>>> newIN=new ArrayList<List<DTNode<String,String>>>();
      List<DTGraph<String,String>> newGs=GraphUtils.simplifyGraph3Way(graph3,GraphUtils.createHubMap(hubList,th),instanceNodes3,newIN);
      List<WLSubTreeKernel> kernelsWL=new ArrayList<WLSubTreeKernel>();
      for (      int iti : it) {
        kernelsWL.add(new WLSubTreeKernel(iti,true,forward));
      }
      expWL=new MoleculeListMultiGraphExperiment<DTGraph<String,String>>(kernelsWL,seeds,svmParms,GraphUtils.getSubGraphs(newGs.get(0),newIN.get(0),depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expWL.run();
      for (      Result res : expWL.getResults()) {
        resTableWL.addResult(res);
      }
      kernelsWL=new ArrayList<WLSubTreeKernel>();
      for (      int iti : it) {
        kernelsWL.add(new WLSubTreeKernel(iti,true,forward));
      }
      expWL=new MoleculeListMultiGraphExperiment<DTGraph<String,String>>(kernelsWL,seeds,svmParms,GraphUtils.getSubGraphs(newGs.get(1),newIN.get(1),depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expWL.run();
      for (      Result res : expWL.getResults()) {
        resTableWL.addResult(res);
      }
      kernelsWL=new ArrayList<WLSubTreeKernel>();
      for (      int iti : it) {
        kernelsWL.add(new WLSubTreeKernel(iti,true,forward));
      }
      expWL=new MoleculeListMultiGraphExperiment<DTGraph<String,String>>(kernelsWL,seeds,svmParms,GraphUtils.getSubGraphs(newGs.get(2),newIN.get(2),depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expWL.run();
      for (      Result res : expWL.getResults()) {
        resTableWL.addResult(res);
      }
      List<RDFDTGraphIntersectionSubTreeKernel> kernelsIST=new ArrayList<RDFDTGraphIntersectionSubTreeKernel>();
      kernelsIST.add(new RDFDTGraphIntersectionSubTreeKernel(depth,1,true));
      expIST=new MoleculeListSingleGraphExperiment(kernelsIST,seeds,svmParms,newGs.get(0),newIN.get(0),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expIST.run();
      for (      Result res : expIST.getResults()) {
        resTableIST.addResult(res);
      }
      kernelsIST=new ArrayList<RDFDTGraphIntersectionSubTreeKernel>();
      kernelsIST.add(new RDFDTGraphIntersectionSubTreeKernel(3,1,true));
      expIST=new MoleculeListSingleGraphExperiment(kernelsIST,seeds,svmParms,newGs.get(1),newIN.get(1),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expIST.run();
      for (      Result res : expIST.getResults()) {
        resTableIST.addResult(res);
      }
      kernelsIST=new ArrayList<RDFDTGraphIntersectionSubTreeKernel>();
      kernelsIST.add(new RDFDTGraphIntersectionSubTreeKernel(3,1,true));
      expIST=new MoleculeListSingleGraphExperiment(kernelsIST,seeds,svmParms,newGs.get(2),newIN.get(2),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expIST.run();
      for (      Result res : expIST.getResults()) {
        resTableIST.addResult(res);
      }
    }
    System.out.println(resTableWL);
    System.out.println(resTableIST);
  }
  resTableWL.addCompResults(resTableWL.getBestResults(resTableIST.getBestResults()));
  resTableIST.addCompResults(resTableIST.getBestResults(resTableWL.getBestResults()));
  System.out.println(resTableWL);
  System.out.println(resTableWL.allScoresToString());
  System.out.println(resTableIST);
  System.out.println(resTableIST.allScoresToString());
  saveResults(resTableWL.toString() + ""String_Node_Str"" + resTableIST.toString(),""String_Node_Str"" + System.currentTimeMillis() + ""String_Node_Str"");
  saveResults(resTableWL.allScoresToString() + ""String_Node_Str"" + resTableIST.allScoresToString(),""String_Node_Str"" + System.currentTimeMillis() + ""String_Node_Str"");
}","public static void experiment(boolean fullGraph){
  long[] seeds={11,21,31,41,51,61,71,81,91,101};
  double[] cs={0.0001,0.001,0.01,0.1,1,10,100,1000,10000};
  List<EvaluationFunction> evalFuncs=new ArrayList<EvaluationFunction>();
  evalFuncs.add(new Error());
  evalFuncs.add(new F1());
  List<Double> target=EvaluationUtils.createTarget(labels);
  LibSVMParameters svmParms=new LibSVMParameters(LibSVMParameters.C_SVC,cs);
  svmParms.setNumFolds(10);
  svmParms.setWeightLabels(EvaluationUtils.computeWeightLabels(target));
  svmParms.setWeights(EvaluationUtils.computeWeights(target));
  List<Statement> allStmts3=GraphUtils.getStatements4Depth(dataset,instances,4,false);
  List<Statement> allStmts4;
  if (fullGraph) {
    allStmts4=dataset.getStatements(null,null,null,false);
  }
 else {
    allStmts4=GraphUtils.getStatements4Depth(dataset,instances,5,false);
  }
  allStmts3.removeAll(blackList);
  allStmts4.removeAll(blackList);
  DTGraph<String,String> graph3=org.nodes.data.RDF.createDirectedGraph(allStmts3,null,null);
  DTGraph<String,String> graph4=org.nodes.data.RDF.createDirectedGraph(allStmts4,null,null);
  System.out.println(""String_Node_Str"" + graph3.nodes().size() + ""String_Node_Str""+ graph4.nodes().size());
  List<DTNode<String,String>> instanceNodes3=new ArrayList<DTNode<String,String>>();
  List<DTNode<String,String>> instanceNodes4=new ArrayList<DTNode<String,String>>();
  for (  Resource i : instances) {
    instanceNodes3.add(graph3.node(i.toString()));
    instanceNodes4.add(graph4.node(i.toString()));
  }
  int maxHubs=1000;
  List<DTNode<String,String>> RDFTypeHubs=GraphUtils.getTypeHubs(graph4);
  Comparator<Node<String>> compRegDeg=new DegreeComparator<String>();
  MaxObserver<Node<String>> obsRegDeg=new MaxObserver<Node<String>>(maxHubs + instances.size(),compRegDeg);
  obsRegDeg.observe(graph4.nodes());
  List<DTNode<String,String>> regDegreeHubs=new ArrayList<DTNode<String,String>>();
  for (  Node<String> n : obsRegDeg.elements()) {
    regDegreeHubs.add((DTNode<String,String>)n);
  }
  Comparator<DTNode<String,String>> compSigDeg=new SlashBurn.SignatureComparator<String,String>();
  MaxObserver<DTNode<String,String>> obsSigDeg=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compSigDeg);
  obsSigDeg.observe(graph4.nodes());
  List<DTNode<String,String>> sigDegreeHubs=new ArrayList<DTNode<String,String>>(obsSigDeg.elements());
  List<Integer> classes=new ArrayList<Integer>();
  for (  double d : target) {
    classes.add((int)d);
  }
  Classified<DTNode<String,String>> classified=Classification.combine(instanceNodes4,classes);
  InformedAvoidance ia=new InformedAvoidance(graph4,classified,4);
  Comparator<DTNode<String,String>> compUnInformed=ia.uninformedComparator(4);
  MaxObserver<DTNode<String,String>> obsUnInformed=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compUnInformed);
  obsUnInformed.observe(graph4.nodes());
  List<DTNode<String,String>> unInformedDegreeHubs=new ArrayList<DTNode<String,String>>(obsUnInformed.elements());
  Iterator<DTNode<String,String>> ite=unInformedDegreeHubs.iterator();
  while (ite.hasNext())   if (!ia.viableHub(ite.next(),4,4))   ite.remove();
  Comparator<DTNode<String,String>> compInformed=ia.informedComparator(4);
  MaxObserver<DTNode<String,String>> obsInformed=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compInformed);
  obsInformed.observe(graph4.nodes());
  List<DTNode<String,String>> informedDegreeHubs=new ArrayList<DTNode<String,String>>(obsInformed.elements());
  ite=informedDegreeHubs.iterator();
  while (ite.hasNext())   if (!ia.viableHub(ite.next(),4,4))   ite.remove();
  List<DTNode<String,String>> rn=new ArrayList<DTNode<String,String>>();
  Set<String> is=new HashSet<String>();
  for (  Resource r : instances) {
    is.add(r.toString());
  }
  for (  DTNode<String,String> n : graph4.nodes()) {
    if (is.contains(n.label())) {
      rn.add(n);
    }
  }
  RDFTypeHubs.removeAll(rn);
  regDegreeHubs.removeAll(rn);
  sigDegreeHubs.removeAll(rn);
  unInformedDegreeHubs.removeAll(rn);
  informedDegreeHubs.removeAll(rn);
  List<List<DTNode<String,String>>> hubLists=new ArrayList<List<DTNode<String,String>>>();
  hubLists.add(RDFTypeHubs);
  hubLists.add(regDegreeHubs);
  hubLists.add(sigDegreeHubs);
  boolean forward=true;
  int[] it={0,2,4,6};
  int depth=3;
  int[] hubThs={0,1,2,3,4,5,10,20,30,40,50,100};
  ResultsTable resTableWL=new ResultsTable();
  resTableWL.setDigits(3);
  ResultsTable resTableIST=new ResultsTable();
  resTableIST.setDigits(3);
  MoleculeListMultiGraphExperiment<DTGraph<String,String>> expWL;
  MoleculeListSingleGraphExperiment expIST;
  for (  int th : hubThs) {
    resTableWL.newRow(""String_Node_Str"" + th);
    resTableIST.newRow(""String_Node_Str"" + th);
    for (    List<DTNode<String,String>> hubList : hubLists) {
      List<List<DTNode<String,String>>> newIN=new ArrayList<List<DTNode<String,String>>>();
      List<DTGraph<String,String>> newGs=GraphUtils.simplifyGraph3Way(graph3,GraphUtils.createHubMap(hubList,th),instanceNodes3,newIN);
      List<WLSubTreeKernel> kernelsWL=new ArrayList<WLSubTreeKernel>();
      for (      int iti : it) {
        kernelsWL.add(new WLSubTreeKernel(iti,true,forward));
      }
      expWL=new MoleculeListMultiGraphExperiment<DTGraph<String,String>>(kernelsWL,seeds,svmParms,GraphUtils.getSubGraphs(newGs.get(0),newIN.get(0),depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expWL.run();
      for (      Result res : expWL.getResults()) {
        resTableWL.addResult(res);
      }
      kernelsWL=new ArrayList<WLSubTreeKernel>();
      for (      int iti : it) {
        kernelsWL.add(new WLSubTreeKernel(iti,true,forward));
      }
      expWL=new MoleculeListMultiGraphExperiment<DTGraph<String,String>>(kernelsWL,seeds,svmParms,GraphUtils.getSubGraphs(newGs.get(1),newIN.get(1),depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expWL.run();
      for (      Result res : expWL.getResults()) {
        resTableWL.addResult(res);
      }
      kernelsWL=new ArrayList<WLSubTreeKernel>();
      for (      int iti : it) {
        kernelsWL.add(new WLSubTreeKernel(iti,true,forward));
      }
      expWL=new MoleculeListMultiGraphExperiment<DTGraph<String,String>>(kernelsWL,seeds,svmParms,GraphUtils.getSubGraphs(newGs.get(2),newIN.get(2),depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expWL.run();
      for (      Result res : expWL.getResults()) {
        resTableWL.addResult(res);
      }
      List<RDFDTGraphIntersectionSubTreeKernel> kernelsIST=new ArrayList<RDFDTGraphIntersectionSubTreeKernel>();
      kernelsIST.add(new RDFDTGraphIntersectionSubTreeKernel(depth,1,true));
      expIST=new MoleculeListSingleGraphExperiment(kernelsIST,seeds,svmParms,newGs.get(0),newIN.get(0),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expIST.run();
      for (      Result res : expIST.getResults()) {
        resTableIST.addResult(res);
      }
      kernelsIST=new ArrayList<RDFDTGraphIntersectionSubTreeKernel>();
      kernelsIST.add(new RDFDTGraphIntersectionSubTreeKernel(depth,1,true));
      expIST=new MoleculeListSingleGraphExperiment(kernelsIST,seeds,svmParms,newGs.get(1),newIN.get(1),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expIST.run();
      for (      Result res : expIST.getResults()) {
        resTableIST.addResult(res);
      }
      kernelsIST=new ArrayList<RDFDTGraphIntersectionSubTreeKernel>();
      kernelsIST.add(new RDFDTGraphIntersectionSubTreeKernel(depth,1,true));
      expIST=new MoleculeListSingleGraphExperiment(kernelsIST,seeds,svmParms,newGs.get(2),newIN.get(2),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      expIST.run();
      for (      Result res : expIST.getResults()) {
        resTableIST.addResult(res);
      }
    }
    System.out.println(resTableWL);
    System.out.println(resTableIST);
  }
  resTableWL.addCompResults(resTableWL.getBestResults(resTableIST.getBestResults()));
  resTableIST.addCompResults(resTableIST.getBestResults(resTableWL.getBestResults()));
  System.out.println(resTableWL);
  System.out.println(resTableWL.allScoresToString());
  System.out.println(resTableIST);
  System.out.println(resTableIST.allScoresToString());
  saveResults(resTableWL.toString() + ""String_Node_Str"" + resTableIST.toString(),""String_Node_Str"" + System.currentTimeMillis() + ""String_Node_Str"");
  saveResults(resTableWL.allScoresToString() + ""String_Node_Str"" + resTableIST.allScoresToString(),""String_Node_Str"" + System.currentTimeMillis() + ""String_Node_Str"");
}"
50984,"public static void main(String[] args){
  List<UGraph<String>> graphs=new ArrayList<UGraph<String>>();
  List<Double> labels=new ArrayList<Double>();
  createDataSet(ENZYMES_DIR,graphs,labels);
  long[] seeds={11,21,31,41,51,61,71,81,91,101};
  double[] cs={0.0001,0.001,0.01,0.1,1,10,100,1000,10000};
  List<EvaluationFunction> evalFuncs=new ArrayList<EvaluationFunction>();
  evalFuncs.add(new Error());
  evalFuncs.add(new F1());
  List<Double> target=EvaluationUtils.createTarget(labels);
  LibSVMParameters svmParms=new LibSVMParameters(LibSVMParameters.C_SVC,cs);
  svmParms.setNumFolds(10);
  List<List<Statement>> rdfTriples2=createMoleculeRDFGraphs(graphs,false);
  RDFDataSet ts=new RDFSingleDataSet();
  for (  List<Statement> trips : rdfTriples2) {
    ts.addStatements(trips);
  }
  List<Resource> instances=new ArrayList<Resource>();
  List<Statement> stmts=ts.getStatementsFromStrings(null,RDF.TYPE.stringValue(),GraphUtils.NAMESPACE + ""String_Node_Str"");
  for (  Statement stmt : stmts) {
    instances.add(stmt.getSubject());
  }
  DTGraph<String,String> sGraph=org.nodes.data.RDF.createDirectedGraph(ts.getStatements(null,null,null,false),null,null);
  ResultsTable resTable=new ResultsTable();
  resTable.setDigits(3);
  List<DTNode<String,String>> instanceNodes=new ArrayList<DTNode<String,String>>();
  for (  Resource i : instances) {
    instanceNodes.add(sGraph.node(i.toString()));
  }
  int maxHubs=1000;
  List<DTNode<String,String>> RDFTypeHubs=GraphUtils.getTypeHubs(sGraph);
  Comparator<Node<String>> compRegDeg=new DegreeComparator<String>();
  MaxObserver<Node<String>> obsRegDeg=new MaxObserver<Node<String>>(maxHubs + instances.size(),compRegDeg);
  obsRegDeg.observe(sGraph.nodes());
  List<DTNode<String,String>> regDegreeHubs=new ArrayList<DTNode<String,String>>();
  for (  Node<String> n : obsRegDeg.elements()) {
    regDegreeHubs.add((DTNode<String,String>)n);
  }
  Comparator<DTNode<String,String>> compSigDeg=new SlashBurn.SignatureComparator<String,String>();
  MaxObserver<DTNode<String,String>> obsSigDeg=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compSigDeg);
  obsSigDeg.observe(sGraph.nodes());
  List<DTNode<String,String>> sigDegreeHubs=new ArrayList<DTNode<String,String>>(obsSigDeg.elements());
  List<Integer> classes=new ArrayList<Integer>();
  for (  double d : target) {
    classes.add((int)d);
  }
  Classified<DTNode<String,String>> classified=Classification.combine(instanceNodes,classes);
  InformedAvoidance ia=new InformedAvoidance(sGraph,classified,4);
  Comparator<DTNode<String,String>> compUnInformed=ia.uninformedComparator(4);
  MaxObserver<DTNode<String,String>> obsUnInformed=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compUnInformed);
  obsUnInformed.observe(sGraph.nodes());
  List<DTNode<String,String>> unInformedDegreeHubs=new ArrayList<DTNode<String,String>>(obsUnInformed.elements());
  Iterator<DTNode<String,String>> ite=unInformedDegreeHubs.iterator();
  while (ite.hasNext())   if (!ia.viableHub(ite.next(),4,4))   ite.remove();
  Comparator<DTNode<String,String>> compInformed=ia.informedComparator(4);
  MaxObserver<DTNode<String,String>> obsInformed=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compInformed);
  obsInformed.observe(sGraph.nodes());
  List<DTNode<String,String>> informedDegreeHubs=new ArrayList<DTNode<String,String>>(obsInformed.elements());
  ite=informedDegreeHubs.iterator();
  while (ite.hasNext())   if (!ia.viableHub(ite.next(),4,4))   ite.remove();
  List<DTNode<String,String>> rn=new ArrayList<DTNode<String,String>>();
  Set<String> is=new HashSet<String>();
  for (  Resource r : instances) {
    is.add(r.toString());
  }
  for (  DTNode<String,String> n : sGraph.nodes()) {
    if (is.contains(n.label())) {
      rn.add(n);
    }
  }
  RDFTypeHubs.removeAll(rn);
  regDegreeHubs.removeAll(rn);
  sigDegreeHubs.removeAll(rn);
  unInformedDegreeHubs.removeAll(rn);
  informedDegreeHubs.removeAll(rn);
  List<List<DTNode<String,String>>> hubLists=new ArrayList<List<DTNode<String,String>>>();
  hubLists.add(RDFTypeHubs);
  hubLists.add(regDegreeHubs);
  hubLists.add(sigDegreeHubs);
  hubLists.add(unInformedDegreeHubs);
  hubLists.add(informedDegreeHubs);
  boolean forward=true;
  int it=6;
  int depth=3;
  int[] hubThs={0,1,2,3,4,5,6,7,8,9};
  int[] iterations={1,2,3,4,5,6};
  for (  int i : iterations) {
    resTable.newRow(""String_Node_Str"" + it);
    MoleculeGraphExperiment<UGraph<String>> exp=new MoleculeGraphExperiment<UGraph<String>>(new WLUSubTreeKernel(i,true),seeds,svmParms,graphs,labels,evalFuncs);
    System.out.println(""String_Node_Str"" + i);
    exp.run();
    for (    Result res : exp.getResults()) {
      resTable.addResult(res);
    }
  }
  System.out.println(resTable);
  MoleculeGraphExperiment<DTGraph<String,String>> exp;
  for (  int th : hubThs) {
    resTable.newRow(""String_Node_Str"" + th);
    for (    List<DTNode<String,String>> hubList : hubLists) {
      List<DTNode<String,String>> newIN=new ArrayList<DTNode<String,String>>(instanceNodes);
      DTGraph<String,String> newG=GraphUtils.simplifyGraph(sGraph,GraphUtils.createHubMap(hubList,th),newIN,false,true);
      exp=new MoleculeGraphExperiment<DTGraph<String,String>>(new WLSubTreeKernel(it,true,forward),seeds,svmParms,GraphUtils.getSubGraphs(newG,newIN,depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      exp.run();
      for (      Result res : exp.getResults()) {
        resTable.addResult(res);
      }
      newIN=new ArrayList<DTNode<String,String>>(instanceNodes);
      newG=GraphUtils.simplifyGraph(sGraph,GraphUtils.createHubMap(hubList,th),newIN,true,false);
      exp=new MoleculeGraphExperiment<DTGraph<String,String>>(new WLSubTreeKernel(it,true,forward),seeds,svmParms,GraphUtils.getSubGraphs(newG,newIN,depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      exp.run();
      for (      Result res : exp.getResults()) {
        resTable.addResult(res);
      }
      newIN=new ArrayList<DTNode<String,String>>(instanceNodes);
      newG=GraphUtils.simplifyGraph(sGraph,GraphUtils.createHubMap(hubList,th),newIN,true,true);
      exp=new MoleculeGraphExperiment<DTGraph<String,String>>(new WLSubTreeKernel(it,true,forward),seeds,svmParms,GraphUtils.getSubGraphs(newG,newIN,depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      exp.run();
      for (      Result res : exp.getResults()) {
        resTable.addResult(res);
      }
    }
    System.out.println(resTable);
  }
  resTable.addCompResults(resTable.getBestResults());
  System.out.println(resTable);
  System.out.println(resTable.allScoresToString());
}","public static void main(String[] args){
  List<UGraph<String>> graphs=new ArrayList<UGraph<String>>();
  List<Double> labels=new ArrayList<Double>();
  createDataSet(MUTAG_DIR,graphs,labels);
  long[] seeds={11,21,31,41,51,61,71,81,91,101};
  double[] cs={0.0001,0.001,0.01,0.1,1,10,100,1000,10000};
  List<EvaluationFunction> evalFuncs=new ArrayList<EvaluationFunction>();
  evalFuncs.add(new Error());
  evalFuncs.add(new F1());
  List<Double> target=EvaluationUtils.createTarget(labels);
  LibSVMParameters svmParms=new LibSVMParameters(LibSVMParameters.C_SVC,cs);
  svmParms.setNumFolds(10);
  List<List<Statement>> rdfTriples2=createMoleculeRDFGraphs(graphs,false);
  RDFDataSet ts=new RDFSingleDataSet();
  for (  List<Statement> trips : rdfTriples2) {
    ts.addStatements(trips);
  }
  List<Resource> instances=new ArrayList<Resource>();
  List<Statement> stmts=ts.getStatementsFromStrings(null,RDF.TYPE.stringValue(),GraphUtils.NAMESPACE + ""String_Node_Str"");
  for (  Statement stmt : stmts) {
    instances.add(stmt.getSubject());
  }
  DTGraph<String,String> sGraph=org.nodes.data.RDF.createDirectedGraph(ts.getStatements(null,null,null,false),null,null);
  ResultsTable resTable=new ResultsTable();
  resTable.setDigits(3);
  List<DTNode<String,String>> instanceNodes=new ArrayList<DTNode<String,String>>();
  for (  Resource i : instances) {
    instanceNodes.add(sGraph.node(i.toString()));
  }
  int maxHubs=1000;
  List<DTNode<String,String>> RDFTypeHubs=GraphUtils.getTypeHubs(sGraph);
  Comparator<Node<String>> compRegDeg=new DegreeComparator<String>();
  MaxObserver<Node<String>> obsRegDeg=new MaxObserver<Node<String>>(maxHubs + instances.size(),compRegDeg);
  obsRegDeg.observe(sGraph.nodes());
  List<DTNode<String,String>> regDegreeHubs=new ArrayList<DTNode<String,String>>();
  for (  Node<String> n : obsRegDeg.elements()) {
    regDegreeHubs.add((DTNode<String,String>)n);
  }
  Comparator<DTNode<String,String>> compSigDeg=new SlashBurn.SignatureComparator<String,String>();
  MaxObserver<DTNode<String,String>> obsSigDeg=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compSigDeg);
  obsSigDeg.observe(sGraph.nodes());
  List<DTNode<String,String>> sigDegreeHubs=new ArrayList<DTNode<String,String>>(obsSigDeg.elements());
  List<Integer> classes=new ArrayList<Integer>();
  for (  double d : target) {
    classes.add((int)d);
  }
  Classified<DTNode<String,String>> classified=Classification.combine(instanceNodes,classes);
  InformedAvoidance ia=new InformedAvoidance(sGraph,classified,4);
  Comparator<DTNode<String,String>> compUnInformed=ia.uninformedComparator(4);
  MaxObserver<DTNode<String,String>> obsUnInformed=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compUnInformed);
  obsUnInformed.observe(sGraph.nodes());
  List<DTNode<String,String>> unInformedDegreeHubs=new ArrayList<DTNode<String,String>>(obsUnInformed.elements());
  Iterator<DTNode<String,String>> ite=unInformedDegreeHubs.iterator();
  while (ite.hasNext())   if (!ia.viableHub(ite.next(),4,4))   ite.remove();
  Comparator<DTNode<String,String>> compInformed=ia.informedComparator(4);
  MaxObserver<DTNode<String,String>> obsInformed=new MaxObserver<DTNode<String,String>>(maxHubs + instances.size(),compInformed);
  obsInformed.observe(sGraph.nodes());
  List<DTNode<String,String>> informedDegreeHubs=new ArrayList<DTNode<String,String>>(obsInformed.elements());
  ite=informedDegreeHubs.iterator();
  while (ite.hasNext())   if (!ia.viableHub(ite.next(),4,4))   ite.remove();
  List<DTNode<String,String>> rn=new ArrayList<DTNode<String,String>>();
  Set<String> is=new HashSet<String>();
  for (  Resource r : instances) {
    is.add(r.toString());
  }
  for (  DTNode<String,String> n : sGraph.nodes()) {
    if (is.contains(n.label())) {
      rn.add(n);
    }
  }
  RDFTypeHubs.removeAll(rn);
  regDegreeHubs.removeAll(rn);
  sigDegreeHubs.removeAll(rn);
  unInformedDegreeHubs.removeAll(rn);
  informedDegreeHubs.removeAll(rn);
  List<List<DTNode<String,String>>> hubLists=new ArrayList<List<DTNode<String,String>>>();
  hubLists.add(RDFTypeHubs);
  hubLists.add(regDegreeHubs);
  hubLists.add(sigDegreeHubs);
  hubLists.add(unInformedDegreeHubs);
  hubLists.add(informedDegreeHubs);
  boolean forward=true;
  int it=6;
  int depth=3;
  int[] hubThs={0,1,2,3,4,5,6,7,8,9};
  int[] iterations={1,2,3,4,5,6};
  for (  int i : iterations) {
    resTable.newRow(""String_Node_Str"" + i);
    MoleculeGraphExperiment<UGraph<String>> exp=new MoleculeGraphExperiment<UGraph<String>>(new WLUSubTreeKernel(i,true),seeds,svmParms,graphs,labels,evalFuncs);
    System.out.println(""String_Node_Str"" + i);
    exp.run();
    for (    Result res : exp.getResults()) {
      resTable.addResult(res);
    }
  }
  System.out.println(resTable);
  MoleculeGraphExperiment<DTGraph<String,String>> exp;
  for (  int th : hubThs) {
    resTable.newRow(""String_Node_Str"" + th);
    for (    List<DTNode<String,String>> hubList : hubLists) {
      List<DTNode<String,String>> newIN=new ArrayList<DTNode<String,String>>(instanceNodes);
      DTGraph<String,String> newG=GraphUtils.simplifyGraph(sGraph,GraphUtils.createHubMap(hubList,th),newIN,false,true);
      exp=new MoleculeGraphExperiment<DTGraph<String,String>>(new WLSubTreeKernel(it,true,forward),seeds,svmParms,GraphUtils.getSubGraphs(newG,newIN,depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      exp.run();
      for (      Result res : exp.getResults()) {
        resTable.addResult(res);
      }
      newIN=new ArrayList<DTNode<String,String>>(instanceNodes);
      newG=GraphUtils.simplifyGraph(sGraph,GraphUtils.createHubMap(hubList,th),newIN,true,false);
      exp=new MoleculeGraphExperiment<DTGraph<String,String>>(new WLSubTreeKernel(it,true,forward),seeds,svmParms,GraphUtils.getSubGraphs(newG,newIN,depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      exp.run();
      for (      Result res : exp.getResults()) {
        resTable.addResult(res);
      }
      newIN=new ArrayList<DTNode<String,String>>(instanceNodes);
      newG=GraphUtils.simplifyGraph(sGraph,GraphUtils.createHubMap(hubList,th),newIN,true,true);
      exp=new MoleculeGraphExperiment<DTGraph<String,String>>(new WLSubTreeKernel(it,true,forward),seeds,svmParms,GraphUtils.getSubGraphs(newG,newIN,depth),target,evalFuncs);
      System.out.println(""String_Node_Str"" + th);
      exp.run();
      for (      Result res : exp.getResults()) {
        resTable.addResult(res);
      }
    }
    System.out.println(resTable);
  }
  resTable.addCompResults(resTable.getBestResults());
  System.out.println(resTable);
  System.out.println(resTable.allScoresToString());
}"
50985,"public double computeScore(double[] target,Prediction[] prediction){
  Map<Double,Double> counts=new HashMap<Double,Double>();
  for (int i=0; i < target.length; i++) {
    if (!counts.containsKey(target[i])) {
      counts.put(target[i],1.0);
    }
 else {
      counts.put(target[i],counts.get(target[i]) + 1);
    }
  }
  double f1=0, temp1=0, temp2=0;
  for (  double label : counts.keySet()) {
    for (int i=0; i < prediction.length; i++) {
      if ((prediction[i].getLabel() == label && target[i] == label)) {
        temp1+=1;
      }
      if ((prediction[i].getLabel() == label || target[i] == label)) {
        temp2+=1;
      }
    }
    f1+=temp1 / temp2;
    temp1=0;
    temp2=0;
  }
  return f1 / ((double)counts.size());
}","public double computeScore(double[] target,Prediction[] prediction){
  Map<Double,Double> counts=new HashMap<Double,Double>();
  for (int i=0; i < target.length; i++) {
    if (!counts.containsKey(target[i])) {
      counts.put(target[i],1.0);
    }
 else {
      counts.put(target[i],counts.get(target[i]) + 1);
    }
  }
  double f1=0, temp1=0, temp2=0;
  for (  double label : counts.keySet()) {
    for (int i=0; i < prediction.length; i++) {
      if ((prediction[i].getLabel() == label && target[i] == label)) {
        temp1+=1;
      }
 else       if ((prediction[i].getLabel() == label || target[i] == label)) {
        temp2+=1;
      }
    }
    f1+=(2 * temp1) / ((2 * temp1) + temp2);
    temp1=0;
    temp2=0;
  }
  return f1 / ((double)counts.size());
}"
50986,"/** 
 * Compute the F1 score for a prediction.  It computes the F1 per class and returns the average of these F1's, this is called the macro F1
 * @param target
 * @param prediction
 * @return use {@link org.data2semantics.proppred.learners.evaluation.F1}
 */
public static double computeF1(double[] target,double[] prediction){
  Map<Double,Double> targetCounts=computeClassCounts(target);
  double f1=0, temp1=0, temp2=0;
  for (  double label : targetCounts.keySet()) {
    for (int i=0; i < prediction.length; i++) {
      if ((prediction[i] == label && target[i] == label)) {
        temp1+=1;
      }
      if ((prediction[i] == label || target[i] == label)) {
        temp2+=1;
      }
    }
    f1+=temp1 / temp2;
    temp1=0;
    temp2=0;
  }
  return f1 / ((double)targetCounts.size());
}","/** 
 * Compute the F1 score for a prediction.  It computes the F1 per class and returns the average of these F1's, this is called the macro F1
 * @param target
 * @param prediction
 * @return use {@link org.data2semantics.proppred.learners.evaluation.F1}
 */
public static double computeF1(double[] target,double[] prediction){
  Map<Double,Double> targetCounts=computeClassCounts(target);
  double f1=0, temp1=0, temp2=0;
  for (  double label : targetCounts.keySet()) {
    for (int i=0; i < prediction.length; i++) {
      if ((prediction[i] == label && target[i] == label)) {
        temp1+=1;
      }
 else       if ((prediction[i] == label || target[i] == label)) {
        temp2+=1;
      }
    }
    f1+=(2 * temp1) / ((2 * temp1) + temp2);
    temp1=0;
    temp2=0;
  }
  return f1 / ((double)targetCounts.size());
}"
50987,"private void moduleOutput(Module module,File moduleDir) throws IOException {
  Map<String,Object> templateData=new LinkedHashMap<String,Object>();
  templateData.put(""String_Node_Str"",module.name());
  templateData.put(""String_Node_Str"",module.name());
  templateData.put(""String_Node_Str"",""String_Node_Str"");
  templateData.put(""String_Node_Str"",module.workflow().name());
  templateData.put(""String_Node_Str"",module.instantiated());
  List<Map<String,Object>> instances=new ArrayList<Map<String,Object>>();
  if (module.instantiated()) {
    List<String> inputNames=new ArrayList<String>();
    for (    Input input : module.inputs())     if (input.print())     inputNames.add(input.name());
    templateData.put(""String_Node_Str"",inputNames);
    int i=0;
    int padding=1 + (int)Math.log10(module.instances().size());
    for (    ModuleInstance instance : module.instances()) {
      List<String> instanceInputs=new ArrayList<String>();
      for (      InstanceInput input : instance.inputs())       if (input.original().print())       instanceInputs.add(input.value().toString());
      Map<String,Object> instanceMap=new LinkedHashMap<String,Object>();
      instanceMap.put(""String_Node_Str"",String.format(""String_Node_Str"" + padding + ""String_Node_Str"",i));
      instanceMap.put(""String_Node_Str"",instanceInputs);
      instances.add(instanceMap);
      i++;
    }
  }
  templateData.put(""String_Node_Str"",instances);
  List<Map<String,Object>> outputs=new ArrayList<Map<String,Object>>();
  for (  Output output : module.outputs())   if (output.print()) {
    Map<String,Object> outputMap=new LinkedHashMap<String,Object>();
    outputMap.put(""String_Node_Str"",output.name());
    outputMap.put(""String_Node_Str"",output.description());
    List<Map<String,Object>> outputInstances=new ArrayList<Map<String,Object>>();
    List<Object> values=new ArrayList<Object>();
    for (    ModuleInstance instance : module.instances()) {
      Map<String,Object> instanceMap=new LinkedHashMap<String,Object>();
      List<String> inputs=new ArrayList<String>();
      for (      InstanceInput input : instance.inputs())       if (input.original().print())       inputs.add(input.value().toString());
      instanceMap.put(""String_Node_Str"",inputs);
      Object value=instance.output(output.name()).value();
      instanceMap.put(""String_Node_Str"",Functions.toString(value));
      values.add(value);
      outputInstances.add(instanceMap);
    }
    outputMap.put(""String_Node_Str"",outputInstances);
    boolean isNumeric=isNumeric(values);
    outputMap.put(""String_Node_Str"",isNumeric);
    FrequencyModel<Object> fm=new FrequencyModel<Object>(values);
    outputMap.put(""String_Node_Str"",Functions.toString(fm.sorted().get(0)));
    outputMap.put(""String_Node_Str"",fm.frequency(fm.sorted().get(0)));
    outputMap.put(""String_Node_Str"",values.size());
    outputMap.put(""String_Node_Str"",fm.entropy());
    if (isNumeric) {
      List<Number> numbers=numbers(values);
      outputMap.put(""String_Node_Str"",mean(numbers));
      outputMap.put(""String_Node_Str"",standardDeviation(numbers));
      outputMap.put(""String_Node_Str"",median(numbers));
    }
    outputs.add(outputMap);
  }
  templateData.put(""String_Node_Str"",outputs);
  List<Map<String,Object>> inputs=new ArrayList<Map<String,Object>>();
  for (  Input input : module.inputs())   if (input.print()) {
    Map<String,Object> inputMap=new LinkedHashMap<String,Object>();
    inputMap.put(""String_Node_Str"",input.name());
    inputMap.put(""String_Node_Str"",input.description());
    List<String> values=new ArrayList<String>();
    for (    ModuleInstance instance : module.instances())     values.add(Functions.toString(instance.input(input.name()).value()));
    inputMap.put(""String_Node_Str"",values);
    inputs.add(inputMap);
  }
  templateData.put(""String_Node_Str"",inputs);
  JadeTemplate tpl=getTemplate(""String_Node_Str"");
  moduleDir.mkdirs();
  try {
    BufferedWriter out=new BufferedWriter(new FileWriter(new File(moduleDir,""String_Node_Str"")));
    config.renderTemplate(tpl,templateData,out);
    out.flush();
  }
 catch (  IOException e) {
    Global.log().warning(""String_Node_Str"" + e.getMessage() + ""String_Node_Str""+ Arrays.toString(e.getStackTrace()));
    return;
  }
}","private void moduleOutput(Module module,File moduleDir) throws IOException {
  Map<String,Object> templateData=new LinkedHashMap<String,Object>();
  templateData.put(""String_Node_Str"",module.name());
  templateData.put(""String_Node_Str"",module.name());
  templateData.put(""String_Node_Str"",""String_Node_Str"");
  templateData.put(""String_Node_Str"",module.workflow().name());
  templateData.put(""String_Node_Str"",module.instantiated());
  List<Map<String,Object>> instances=new ArrayList<Map<String,Object>>();
  if (module.instantiated()) {
    List<String> inputNames=new ArrayList<String>();
    for (    Input input : module.inputs())     if (input.print())     inputNames.add(input.name());
    templateData.put(""String_Node_Str"",inputNames);
    int i=0;
    int padding=1 + (int)Math.log10(module.instances().size());
    for (    ModuleInstance instance : module.instances()) {
      List<String> instanceInputs=new ArrayList<String>();
      for (      InstanceInput input : instance.inputs())       if (input.original().print())       instanceInputs.add(input.value().toString());
      Map<String,Object> instanceMap=new LinkedHashMap<String,Object>();
      instanceMap.put(""String_Node_Str"",String.format(""String_Node_Str"" + padding + ""String_Node_Str"",i));
      instanceMap.put(""String_Node_Str"",instanceInputs);
      instances.add(instanceMap);
      i++;
    }
  }
  templateData.put(""String_Node_Str"",instances);
  List<Map<String,Object>> outputs=new ArrayList<Map<String,Object>>();
  for (  Output output : module.outputs())   if (output.print()) {
    Map<String,Object> outputMap=new LinkedHashMap<String,Object>();
    outputMap.put(""String_Node_Str"",output.name());
    outputMap.put(""String_Node_Str"",output.description());
    List<Map<String,Object>> outputInstances=new ArrayList<Map<String,Object>>();
    List<Object> values=new ArrayList<Object>();
    for (    ModuleInstance instance : module.instances()) {
      Map<String,Object> instanceMap=new LinkedHashMap<String,Object>();
      List<String> inputs=new ArrayList<String>();
      for (      InstanceInput input : instance.inputs())       if (input.original().print())       inputs.add(input.value().toString());
      instanceMap.put(""String_Node_Str"",inputs);
      Object value=instance.output(output.name()).value();
      instanceMap.put(""String_Node_Str"",Functions.toString(value));
      values.add(value);
      outputInstances.add(instanceMap);
    }
    outputMap.put(""String_Node_Str"",outputInstances);
    boolean isNumeric=isNumeric(values);
    outputMap.put(""String_Node_Str"",isNumeric);
    FrequencyModel<Object> fm=new FrequencyModel<Object>(values);
    outputMap.put(""String_Node_Str"",(fm.distinct() > 0) ? Functions.toString(fm.sorted().get(0)) : ""String_Node_Str"");
    outputMap.put(""String_Node_Str"",(fm.distinct() > 0) ? fm.frequency(fm.sorted().get(0)) : 0);
    outputMap.put(""String_Node_Str"",values.size());
    outputMap.put(""String_Node_Str"",fm.entropy());
    if (isNumeric) {
      List<Number> numbers=numbers(values);
      outputMap.put(""String_Node_Str"",mean(numbers));
      outputMap.put(""String_Node_Str"",standardDeviation(numbers));
      outputMap.put(""String_Node_Str"",median(numbers));
    }
    outputs.add(outputMap);
  }
  templateData.put(""String_Node_Str"",outputs);
  List<Map<String,Object>> inputs=new ArrayList<Map<String,Object>>();
  for (  Input input : module.inputs())   if (input.print()) {
    Map<String,Object> inputMap=new LinkedHashMap<String,Object>();
    inputMap.put(""String_Node_Str"",input.name());
    inputMap.put(""String_Node_Str"",input.description());
    List<String> values=new ArrayList<String>();
    for (    ModuleInstance instance : module.instances())     values.add(Functions.toString(instance.input(input.name()).value()));
    inputMap.put(""String_Node_Str"",values);
    inputs.add(inputMap);
  }
  templateData.put(""String_Node_Str"",inputs);
  JadeTemplate tpl=getTemplate(""String_Node_Str"");
  moduleDir.mkdirs();
  try {
    BufferedWriter out=new BufferedWriter(new FileWriter(new File(moduleDir,""String_Node_Str"")));
    config.renderTemplate(tpl,templateData,out);
    out.flush();
  }
 catch (  IOException e) {
    Global.log().warning(""String_Node_Str"" + e.getMessage() + ""String_Node_Str""+ Arrays.toString(e.getStackTrace()));
    return;
  }
}"
50988,"public static void main(String[] args) throws IOException {
  Run run=new Run();
  CmdLineParser parser=new CmdLineParser(run);
  try {
    parser.parseArgument(args);
  }
 catch (  CmdLineException e) {
    usageExit(e.getMessage(),parser);
  }
  if (run.arguments.size() > 1)   usageExit(""String_Node_Str"" + run.arguments,parser);
  File file;
  if (run.arguments.isEmpty())   file=new File(""String_Node_Str"");
 else   file=new File(run.arguments.get(0));
  if (!file.exists())   usageExit(""String_Node_Str"" + run.arguments.get(0) + ""String_Node_Str"",parser);
  Workflow workflow=WorkflowParser.parseYAML(file);
  ExecutionProfile executionProfile;
switch (execProfile) {
case LOCAL:
    executionProfile=new LocalExecutionProfile();
  break;
case THREADED:
executionProfile=new ThreadedLocalExecutionProfile();
break;
default :
executionProfile=new LocalExecutionProfile();
}
ResourceSpace rp=new ResourceSpace();
List<Reporter> reporters=Arrays.asList(new HTMLReporter(workflow,new File(output,""String_Node_Str"")),new CSVReporter(workflow,new File(output,""String_Node_Str"")),new PROVReporter(workflow,new File(output,""String_Node_Str"")));
Orchestrator orchestrator=new Orchestrator(workflow,executionProfile,rp,reporters);
orchestrator.orchestrate();
for (Reporter reporter : reporters) reporter.report();
Global.log().info(""String_Node_Str"");
}","public static void main(String[] args) throws IOException {
  Run run=new Run();
  CmdLineParser parser=new CmdLineParser(run);
  try {
    parser.parseArgument(args);
  }
 catch (  CmdLineException e) {
    usageExit(e.getMessage(),parser);
  }
  if (run.arguments.size() > 1)   usageExit(""String_Node_Str"" + run.arguments,parser);
  File file;
  if (run.arguments.isEmpty())   file=new File(""String_Node_Str"");
 else   file=new File(run.arguments.get(0));
  if (!file.exists())   usageExit(""String_Node_Str"" + file + ""String_Node_Str"",parser);
  Workflow workflow=WorkflowParser.parseYAML(file);
  ExecutionProfile executionProfile;
switch (execProfile) {
case LOCAL:
    executionProfile=new LocalExecutionProfile();
  break;
case THREADED:
executionProfile=new ThreadedLocalExecutionProfile();
break;
default :
executionProfile=new LocalExecutionProfile();
}
ResourceSpace rp=new ResourceSpace();
List<Reporter> reporters=Arrays.asList(new HTMLReporter(workflow,new File(output,""String_Node_Str"")),new CSVReporter(workflow,new File(output,""String_Node_Str"")),new PROVReporter(workflow,new File(output,""String_Node_Str"")));
Orchestrator orchestrator=new Orchestrator(workflow,executionProfile,rp,reporters);
orchestrator.orchestrate();
for (Reporter reporter : reporters) reporter.report();
Global.log().info(""String_Node_Str"");
}"
50989,"private void moduleOutput(Module module) throws IOException {
  File file=new File(root,ReporterTools.safe(module.name()) + ""String_Node_Str"");
  CSVWriter writer=new CSVWriter(new BufferedWriter(new FileWriter(file)));
  Set<Input> allUniverse=new HashSet<Input>();
  for (  ModuleInstance instance : module.instances()) {
    allUniverse.addAll(instance.universe().keySet());
  }
  List<Input> universeKeys=new ArrayList<Input>(allUniverse);
  Comparator<Input> inputNameComparator=new Comparator<Input>(){
    @Override public int compare(    Input o1,    Input o2){
      return (o1.module().name() + o1.name()).compareTo(o2.module().name() + o2.name());
    }
  }
;
  Collections.sort(universeKeys,inputNameComparator);
  int n=universeKeys.size() + module.inputs().size() + module.outputs().size()+ 2;
  String[] line=new String[n];
  int i=0;
  for (  Input universeKey : universeKeys) {
    line[i++]=universeKey.module().name() + ""String_Node_Str"" + universeKey.name();
  }
  line[i++]=""String_Node_Str"";
  for (  Input input : module.inputs())   line[i++]=input.name();
  line[i++]=""String_Node_Str"";
  for (  Output output : module.outputs())   line[i++]=output.name();
  writer.writeNext(line);
  for (  ModuleInstance instance : module.instances()) {
    i=0;
    for (    Input universeKey : universeKeys) {
      if (instance.universe().containsKey(universeKey))       line[i++]=instance.universe().get(universeKey).value().toString();
 else       line[i++]=""String_Node_Str"";
    }
    line[i++]=""String_Node_Str"";
    for (    InstanceInput input : instance.inputs())     line[i++]=input.value().toString();
    line[i++]=""String_Node_Str"";
    for (    InstanceOutput output : instance.outputs())     line[i++]=output.value().toString();
    writer.writeNext(line);
  }
  writer.close();
}","private void moduleOutput(Module module) throws IOException {
  File file=new File(root,ReporterTools.safe(module.name()) + ""String_Node_Str"");
  CSVWriter writer=new CSVWriter(new BufferedWriter(new FileWriter(file)));
  Set<Input> allUniverse=new HashSet<Input>();
  for (  ModuleInstance instance : module.instances()) {
    allUniverse.addAll(instance.universe().keySet());
  }
  List<Input> universeKeys=new ArrayList<Input>(allUniverse);
  Comparator<Input> inputNameComparator=new Comparator<Input>(){
    @Override public int compare(    Input o1,    Input o2){
      return (o1.module().name() + o1.name()).compareTo(o2.module().name() + o2.name());
    }
  }
;
  Collections.sort(universeKeys,inputNameComparator);
  int n=universeKeys.size() + module.inputs().size() + module.outputs().size()+ 2;
  String[] line=new String[n];
  int i=0;
  for (  Input universeKey : universeKeys) {
    line[i++]=universeKey.module().name() + ""String_Node_Str"" + universeKey.name();
  }
  line[i++]=""String_Node_Str"";
  for (  Input input : module.inputs())   line[i++]=input.name();
  line[i++]=""String_Node_Str"";
  for (  Output output : module.outputs())   line[i++]=output.name();
  writer.writeNext(line);
  for (  ModuleInstance instance : module.instances()) {
    i=0;
    for (    Input universeKey : universeKeys) {
      if (instance.universe().containsKey(universeKey))       line[i++]=instance.universe().get(universeKey).value().toString();
 else       line[i++]=""String_Node_Str"";
    }
    line[i++]=""String_Node_Str"";
    for (    InstanceInput input : instance.inputs())     line[i++]=input.value().toString();
    line[i++]=""String_Node_Str"";
    for (    InstanceOutput output : instance.outputs())     line[i++]=Functions.toString(output.value());
    writer.writeNext(line);
  }
  writer.close();
}"
50990,"/** 
 * Prepare and write a specific module instance to an HTML page.
 * @param instance
 * @param instanceDir
 */
private void instanceOutput(ModuleInstance instance,File instanceDir,int i) throws IOException {
  Map<String,Object> templateData=new LinkedHashMap<String,Object>();
  templateData.put(""String_Node_Str"",instance.module().workflow().name());
  templateData.put(""String_Node_Str"",instance.module().name());
  templateData.put(""String_Node_Str"",instance.module().name() + ""String_Node_Str"" + i+ ""String_Node_Str"");
  templateData.put(""String_Node_Str"",""String_Node_Str"");
  templateData.put(""String_Node_Str"",i);
  List<Map<String,Object>> inputs=new ArrayList<Map<String,Object>>();
  for (  InstanceInput input : instance.inputs()) {
    Map<String,Object> inputMap=new LinkedHashMap<String,Object>();
    inputMap.put(""String_Node_Str"",input.name());
    inputMap.put(""String_Node_Str"",input.description());
    inputMap.put(""String_Node_Str"",input.value());
    inputs.add(inputMap);
  }
  templateData.put(""String_Node_Str"",inputs);
  List<Map<String,Object>> outputs=new ArrayList<Map<String,Object>>();
  for (  InstanceOutput output : instance.outputs()) {
    Map<String,Object> outputMap=new LinkedHashMap<String,Object>();
    outputMap.put(""String_Node_Str"",output.name());
    outputMap.put(""String_Node_Str"",output.description());
    outputMap.put(""String_Node_Str"",output.value().toString());
    outputs.add(outputMap);
  }
  templateData.put(""String_Node_Str"",outputs);
  JadeTemplate tpl=getTemplate(""String_Node_Str"");
  instanceDir.mkdirs();
  try {
    BufferedWriter out=new BufferedWriter(new FileWriter(new File(instanceDir,""String_Node_Str"")));
    config.renderTemplate(tpl,templateData,out);
    out.flush();
  }
 catch (  IOException e) {
    Global.log().warning(""String_Node_Str"" + e.getMessage() + ""String_Node_Str""+ Arrays.toString(e.getStackTrace()));
    return;
  }
}","/** 
 * Prepare and write a specific module instance to an HTML page.
 * @param instance
 * @param instanceDir
 */
private void instanceOutput(ModuleInstance instance,File instanceDir,int i) throws IOException {
  Map<String,Object> templateData=new LinkedHashMap<String,Object>();
  templateData.put(""String_Node_Str"",instance.module().workflow().name());
  templateData.put(""String_Node_Str"",instance.module().name());
  templateData.put(""String_Node_Str"",instance.module().name() + ""String_Node_Str"" + i+ ""String_Node_Str"");
  templateData.put(""String_Node_Str"",""String_Node_Str"");
  templateData.put(""String_Node_Str"",i);
  List<Map<String,Object>> inputs=new ArrayList<Map<String,Object>>();
  for (  InstanceInput input : instance.inputs()) {
    Map<String,Object> inputMap=new LinkedHashMap<String,Object>();
    inputMap.put(""String_Node_Str"",input.name());
    inputMap.put(""String_Node_Str"",input.description());
    inputMap.put(""String_Node_Str"",input.value());
    inputs.add(inputMap);
  }
  templateData.put(""String_Node_Str"",inputs);
  List<Map<String,Object>> outputs=new ArrayList<Map<String,Object>>();
  for (  InstanceOutput output : instance.outputs()) {
    Map<String,Object> outputMap=new LinkedHashMap<String,Object>();
    outputMap.put(""String_Node_Str"",output.name());
    outputMap.put(""String_Node_Str"",output.description());
    outputMap.put(""String_Node_Str"",Functions.toString(output.value().toString()));
    outputs.add(outputMap);
  }
  templateData.put(""String_Node_Str"",outputs);
  JadeTemplate tpl=getTemplate(""String_Node_Str"");
  instanceDir.mkdirs();
  try {
    BufferedWriter out=new BufferedWriter(new FileWriter(new File(instanceDir,""String_Node_Str"")));
    config.renderTemplate(tpl,templateData,out);
    out.flush();
  }
 catch (  IOException e) {
    Global.log().warning(""String_Node_Str"" + e.getMessage() + ""String_Node_Str""+ Arrays.toString(e.getStackTrace()));
    return;
  }
}"
50991,"/** 
 * Add a multivalue input to the workflow
 * @param module
 * @param name
 * @param value
 * @return
 */
public WorkflowBuilder multiInput(String moduleName,String description,String name,List<Object> value,DataType type){
  check();
  if (!workflow.modules.containsKey(moduleName))   throw new IllegalArgumentException(""String_Node_Str"" + name + ""String_Node_Str"");
  ModuleImpl module=workflow.modules.get(moduleName);
  module.addMultiInput(name,description,value,type);
  return this;
}","/** 
 * Add a multivalue input to the workflow
 * @param module
 * @param name
 * @param value
 * @return
 */
public WorkflowBuilder multiInput(String moduleName,String description,String name,List<Object> value,DataType type){
  check();
  if (!workflow.modules.containsKey(moduleName))   throw new IllegalArgumentException(""String_Node_Str"" + moduleName + ""String_Node_Str"");
  ModuleImpl module=workflow.modules.get(moduleName);
  module.addMultiInput(name,description,value,type);
  return this;
}"
50992,"public static Workflow parseYAML(File yamlFile) throws IOException {
  Workflow.WorkflowBuilder builder=Workflow.builder();
  BufferedInputStream bis=new BufferedInputStream(new FileInputStream(yamlFile));
  Map<?,?> loadMap=(Map<?,?>)yaml.load(bis);
  Map<?,?> workflowMap=(Map<?,?>)loadMap.get(""String_Node_Str"");
  ArrayList<Map<?,?>> modules=(ArrayList<Map<?,?>>)workflowMap.get(""String_Node_Str"");
  String workflowName=(String)workflowMap.get(""String_Node_Str"");
  builder.name(workflowName);
  for (  Map m : modules) {
    Map module=(Map)m.get(""String_Node_Str"");
    String name=(String)module.get(""String_Node_Str"");
    String source=(String)module.get(""String_Node_Str"");
    Domain domain;
    String domainPrefix, sourceTail;
    if (!source.contains(""String_Node_Str"")) {
      domain=Global.defaultDomain();
      domainPrefix=""String_Node_Str"";
      sourceTail=source;
    }
 else {
      domainPrefix=source.split(""String_Node_Str"")[0];
      sourceTail=source.split(""String_Node_Str"",2)[1];
      if (!Global.domainExists(domainPrefix))       throw new RuntimeException(""String_Node_Str"" + domainPrefix + ""String_Node_Str"");
      domain=Global.domain(name);
    }
    builder.module(name,domain);
    builder.source(name,sourceTail);
    Map inputMap=(Map)module.get(""String_Node_Str"");
    for (    Object inputKey : inputMap.keySet()) {
      String inputName=inputKey.toString();
      if (inputMap.get(inputKey) instanceof Map) {
        Map ref=(Map)inputMap.get(inputKey);
        String referenceString=(String)ref.get(""String_Node_Str"");
        String referencedModule=referenceString.split(""String_Node_Str"")[0];
        String referencedOutput=referenceString.split(""String_Node_Str"")[1];
        DataType inputType=domain.inputType(sourceTail,inputName);
        String description=domain.inputDescription(sourceTail,inputName);
        builder.refInput(name,inputName,description,referencedModule,referencedOutput,inputType);
      }
 else {
        Object value=inputMap.get(inputKey);
        DataType dataType=domain.inputType(sourceTail,inputName);
        String description=domain.inputDescription(sourceTail,inputName);
        if (domain.valueMatches(value,dataType))         builder.rawInput(name,inputName,description,value,domain.inputType(sourceTail,inputName));
 else         if ((value instanceof List<?>) && listItemsMatch((List<Object>)value,dataType,domain))         builder.multiInput(name,inputName,description,(List<Object>)value,dataType);
 else         throw new InconsistentWorkflowException(""String_Node_Str"" + name + ""String_Node_Str""+ inputName+ ""String_Node_Str""+ value+ ""String_Node_Str""+ dataType+ ""String_Node_Str"");
      }
    }
    Map<String,DataType> outputTypeMap=getOutputTypes(source,domain);
    for (    String outputName : outputTypeMap.keySet()) {
      String description=domain.outputDescription(sourceTail,outputName);
      builder.output(name,outputName,description,outputTypeMap.get(outputName));
    }
  }
  return builder.workflow();
}","public static Workflow parseYAML(File yamlFile) throws IOException {
  Workflow.WorkflowBuilder builder=Workflow.builder();
  BufferedInputStream bis=new BufferedInputStream(new FileInputStream(yamlFile));
  Map<?,?> loadMap=(Map<?,?>)yaml.load(bis);
  Map<?,?> workflowMap=(Map<?,?>)loadMap.get(""String_Node_Str"");
  ArrayList<Map<?,?>> modules=(ArrayList<Map<?,?>>)workflowMap.get(""String_Node_Str"");
  String workflowName=(String)workflowMap.get(""String_Node_Str"");
  builder.name(workflowName);
  for (  Map m : modules) {
    Map module=(Map)m.get(""String_Node_Str"");
    String name=(String)module.get(""String_Node_Str"");
    String source=(String)module.get(""String_Node_Str"");
    Domain domain;
    String domainPrefix, sourceTail;
    if (!source.contains(""String_Node_Str"")) {
      domain=Global.defaultDomain();
      domainPrefix=""String_Node_Str"";
      sourceTail=source;
    }
 else {
      domainPrefix=source.split(""String_Node_Str"")[0];
      sourceTail=source.split(""String_Node_Str"",2)[1];
      if (!Global.domainExists(domainPrefix))       throw new RuntimeException(""String_Node_Str"" + domainPrefix + ""String_Node_Str"");
      domain=Global.domain(name);
    }
    builder.module(name,domain);
    builder.source(name,sourceTail);
    Map inputMap=(Map)module.get(""String_Node_Str"");
    for (    Object inputKey : inputMap.keySet()) {
      String inputName=inputKey.toString();
      if (inputMap.get(inputKey) instanceof Map) {
        Map ref=(Map)inputMap.get(inputKey);
        String referenceString=(String)ref.get(""String_Node_Str"");
        String referencedModule=referenceString.split(""String_Node_Str"")[0];
        String referencedOutput=referenceString.split(""String_Node_Str"")[1];
        DataType inputType=domain.inputType(sourceTail,inputName);
        String description=domain.inputDescription(sourceTail,inputName);
        builder.refInput(name,inputName,description,referencedModule,referencedOutput,inputType);
      }
 else {
        Object value=inputMap.get(inputKey);
        DataType dataType=domain.inputType(sourceTail,inputName);
        String description=domain.inputDescription(sourceTail,inputName);
        if (domain.valueMatches(value,dataType))         builder.rawInput(name,inputName,description,value,domain.inputType(sourceTail,inputName));
 else         if ((value instanceof List<?>) && listItemsMatch((List<Object>)value,dataType,domain))         builder.multiInput(name,description,inputName,(List<Object>)value,dataType);
 else         throw new InconsistentWorkflowException(""String_Node_Str"" + name + ""String_Node_Str""+ inputName+ ""String_Node_Str""+ value+ ""String_Node_Str""+ dataType+ ""String_Node_Str"");
      }
    }
    Map<String,DataType> outputTypeMap=getOutputTypes(source,domain);
    for (    String outputName : outputTypeMap.keySet()) {
      String description=domain.outputDescription(sourceTail,outputName);
      builder.output(name,outputName,description,outputTypeMap.get(outputName));
    }
  }
  return builder.workflow();
}"
50993,"@MainMethod public RDFFileDataSet processRDFData(@InputParameter(name=""String_Node_Str"") Double fraction,@InputParameter(name=""String_Node_Str"") String dataDirectory,@InputParameter(name=""String_Node_Str"") String objectFilter1,@InputParameter(name=""String_Node_Str"") String predicateFilter1,@InputParameter(name=""String_Node_Str"") String predicateFilter2){
  LOG.info(""String_Node_Str"");
  dataset=new RDFFileDataSet(dataDirectory,RDFFormat.NTRIPLES);
  createGeoDataSet(2,fraction,123,predicateFilter2);
  LOG.info(""String_Node_Str"");
  return dataset;
}","@MainMethod public RDFFileDataSet processRDFData(@InputParameter(name=""String_Node_Str"") Double fraction,@InputParameter(name=""String_Node_Str"") String dataDirectory,@InputParameter(name=""String_Node_Str"") String objectFilter1,@InputParameter(name=""String_Node_Str"") String predicateFilter1,@InputParameter(name=""String_Node_Str"") String predicateFilter2){
  LOG.info(""String_Node_Str"");
  dataset=new RDFFileDataSet(dataDirectory,RDFFormat.NTRIPLES);
  createGeoDataSet(10,fraction,123,predicateFilter2);
  LOG.info(""String_Node_Str"");
  return dataset;
}"
50994,"public static void main(String[] args){
  long[] seeds={11,21,31,41,51,61,71,81,91,101};
  double[] cs={0.001,0.01,0.1,1,10,100,1000};
  int[] depths={1,2,3};
  int[] depths2={1,2,3};
  int[] iterations={0,2,4,6};
  createAffiliationPredictionDataSet(1);
  boolean inference=false;
  List<EvaluationFunction> evalFuncs=new ArrayList<EvaluationFunction>();
  evalFuncs.add(new Accuracy());
  evalFuncs.add(new F1());
  List<Double> targets=EvaluationUtils.createTarget(labels);
  LibLINEARParameters linParms=new LibLINEARParameters(LibLINEARParameters.SVC_DUAL,cs);
  linParms.setEvalFunction(new Accuracy());
  linParms.setDoCrossValidation(true);
  linParms.setSplitFraction((float)0.8);
  linParms.setEps(0.1);
  Map<Double,Double> counts=EvaluationUtils.computeClassCounts(targets);
  int[] wLabels=new int[counts.size()];
  double[] weights=new double[counts.size()];
  for (  double label : counts.keySet()) {
    wLabels[(int)label - 1]=(int)label;
    weights[(int)label - 1]=1 / counts.get(label);
  }
  linParms.setWeightLabels(wLabels);
  linParms.setWeights(weights);
  ResultsTable resTable=new ResultsTable();
  for (  int depth : depths2) {
    resTable.newRow(""String_Node_Str"");
    RDFLinearKernelExperiment exp=new RDFLinearKernelExperiment(new RDFIntersectionTreeEdgePathKernel(depth,inference,true),seeds,linParms,dataset,instances,targets,blackList,evalFuncs);
    System.out.println(""String_Node_Str"" + depth);
    exp.setDoCV(true);
    exp.run();
    for (    Result res : exp.getResults()) {
      resTable.addResult(res);
    }
  }
  System.out.println(resTable);
  for (  int depth : depths2) {
    resTable.newRow(""String_Node_Str"");
    RDFLinearKernelExperiment exp=new RDFLinearKernelExperiment(new RDFIntersectionTreeEdgeVertexPathKernel(depth,inference,true),seeds,linParms,dataset,instances,targets,blackList,evalFuncs);
    System.out.println(""String_Node_Str"" + depth);
    exp.setDoCV(true);
    exp.run();
    for (    Result res : exp.getResults()) {
      resTable.addResult(res);
    }
  }
  System.out.println(resTable);
  for (  int depth : depths) {
    resTable.newRow(""String_Node_Str"");
    for (    int it : iterations) {
      RDFLinearKernelExperiment exp=new RDFLinearKernelExperiment(new RDFWLSubTreeKernel(it,depth,inference,true),seeds,linParms,dataset,instances,targets,blackList,evalFuncs);
      System.out.println(""String_Node_Str"" + depth + ""String_Node_Str""+ it);
      exp.setDoCV(true);
      exp.run();
      for (      Result res : exp.getResults()) {
        resTable.addResult(res);
      }
    }
  }
  resTable.addCompResults(resTable.getBestResults());
  System.out.println(resTable);
}","public static void main(String[] args){
  long[] seeds={11,21,31,41,51,61,71,81,91,101};
  double[] cs={0.001,0.01,0.1,1,10,100,1000};
  int[] depths={1,2,3};
  int[] depths2={1,2,3};
  int[] iterations={0,2,4,6};
  createAffiliationPredictionDataSet(1);
  boolean inference=true;
  List<EvaluationFunction> evalFuncs=new ArrayList<EvaluationFunction>();
  evalFuncs.add(new Accuracy());
  evalFuncs.add(new F1());
  List<Double> targets=EvaluationUtils.createTarget(labels);
  LibLINEARParameters linParms=new LibLINEARParameters(LibLINEARParameters.SVC_DUAL,cs);
  linParms.setEvalFunction(new Accuracy());
  linParms.setDoCrossValidation(true);
  linParms.setSplitFraction((float)0.8);
  linParms.setEps(0.1);
  Map<Double,Double> counts=EvaluationUtils.computeClassCounts(targets);
  int[] wLabels=new int[counts.size()];
  double[] weights=new double[counts.size()];
  for (  double label : counts.keySet()) {
    wLabels[(int)label - 1]=(int)label;
    weights[(int)label - 1]=1 / counts.get(label);
  }
  linParms.setWeightLabels(wLabels);
  linParms.setWeights(weights);
  ResultsTable resTable=new ResultsTable();
  for (  int depth : depths2) {
    resTable.newRow(""String_Node_Str"");
    RDFLinearKernelExperiment exp=new RDFLinearKernelExperiment(new RDFIntersectionTreeEdgePathKernel(depth,inference,true),seeds,linParms,dataset,instances,targets,blackList,evalFuncs);
    System.out.println(""String_Node_Str"" + depth);
    exp.setDoCV(true);
    exp.run();
    for (    Result res : exp.getResults()) {
      resTable.addResult(res);
    }
  }
  System.out.println(resTable);
  for (  int depth : depths2) {
    resTable.newRow(""String_Node_Str"");
    RDFLinearKernelExperiment exp=new RDFLinearKernelExperiment(new RDFIntersectionTreeEdgeVertexPathKernel(depth,inference,true),seeds,linParms,dataset,instances,targets,blackList,evalFuncs);
    System.out.println(""String_Node_Str"" + depth);
    exp.setDoCV(true);
    exp.run();
    for (    Result res : exp.getResults()) {
      resTable.addResult(res);
    }
  }
  System.out.println(resTable);
  for (  int depth : depths) {
    resTable.newRow(""String_Node_Str"");
    for (    int it : iterations) {
      RDFLinearKernelExperiment exp=new RDFLinearKernelExperiment(new RDFWLSubTreeKernel(it,depth,inference,true),seeds,linParms,dataset,instances,targets,blackList,evalFuncs);
      System.out.println(""String_Node_Str"" + depth + ""String_Node_Str""+ it);
      exp.setDoCV(true);
      exp.run();
      for (      Result res : exp.getResults()) {
        resTable.addResult(res);
      }
    }
  }
  resTable.addCompResults(resTable.getBestResults());
  System.out.println(resTable);
}"
50995,"public static void main(String[] args){
  long[] seeds={11,21,31,41,51,61,71,81,91,101};
  double[] cs={1,10,100,1000};
  int[] depths={1,2,3};
  int[] iterations={0,2,4,6};
  double fraction=0.1;
  dataset=new RDFFileDataSet(""String_Node_Str"",RDFFormat.TURTLE);
  List<EvaluationFunction> evalFuncs=new ArrayList<EvaluationFunction>();
  evalFuncs.add(new Accuracy());
  evalFuncs.add(new F1());
  ResultsTable resTable=new ResultsTable();
  resTable.setManWU(0.05);
  resTable.setDigits(3);
  boolean inference=true;
  for (  int d : depths) {
    resTable.newRow(""String_Node_Str"");
    for (    int it : iterations) {
      List<List<Result>> res=new ArrayList<List<Result>>();
      for (      long seed : seeds) {
        long[] s2={seed};
        loadDataSet(fraction,seed);
        List<Double> targets=EvaluationUtils.createTarget(labels);
        LibLINEARParameters linParms=new LibLINEARParameters(LibLINEARParameters.SVC_DUAL,cs);
        linParms.setEvalFunction(new Accuracy());
        linParms.setDoCrossValidation(false);
        linParms.setSplitFraction((float)0.8);
        linParms.setEps(0.1);
        Map<Double,Double> counts=EvaluationUtils.computeClassCounts(targets);
        int[] wLabels=new int[counts.size()];
        double[] weights=new double[counts.size()];
        for (        double label : counts.keySet()) {
          wLabels[(int)label - 1]=(int)label;
          weights[(int)label - 1]=1 / counts.get(label);
        }
        linParms.setWeightLabels(wLabels);
        linParms.setWeights(weights);
        RDFLinearKernelExperiment exp=new RDFLinearKernelExperiment(new RDFWLSubTreeKernel(it,d,inference,true),s2,linParms,dataset,instances,targets,blackList,evalFuncs);
        res.add(exp.getResults());
        System.out.println(""String_Node_Str"" + d + ""String_Node_Str""+ it);
        exp.run();
      }
      for (      Result res2 : Result.mergeResultLists(res)) {
        resTable.addResult(res2);
      }
    }
  }
  resTable.addCompResults(resTable.getBestResults());
  System.out.println(resTable);
}","public static void main(String[] args){
  long[] seeds={11,21,31,41,51,61,71,81,91,101};
  double[] cs={1,10,100,1000};
  int[] depths={1,2,3};
  int[] iterations={0};
  double fraction=0.1;
  dataset=new RDFFileDataSet(""String_Node_Str"",RDFFormat.TURTLE);
  List<EvaluationFunction> evalFuncs=new ArrayList<EvaluationFunction>();
  evalFuncs.add(new Accuracy());
  evalFuncs.add(new F1());
  ResultsTable resTable=new ResultsTable();
  resTable.setManWU(0.05);
  resTable.setDigits(3);
  boolean inference=true;
  for (  int d : depths) {
    resTable.newRow(""String_Node_Str"");
    for (    int it : iterations) {
      List<List<Result>> res=new ArrayList<List<Result>>();
      for (      long seed : seeds) {
        long[] s2={seed};
        loadDataSet(fraction,seed);
        List<Double> targets=EvaluationUtils.createTarget(labels);
        LibLINEARParameters linParms=new LibLINEARParameters(LibLINEARParameters.SVC_DUAL,cs);
        linParms.setEvalFunction(new Accuracy());
        linParms.setDoCrossValidation(false);
        linParms.setSplitFraction((float)0.8);
        linParms.setEps(0.1);
        Map<Double,Double> counts=EvaluationUtils.computeClassCounts(targets);
        int[] wLabels=new int[counts.size()];
        double[] weights=new double[counts.size()];
        for (        double label : counts.keySet()) {
          wLabels[(int)label - 1]=(int)label;
          weights[(int)label - 1]=1 / counts.get(label);
        }
        linParms.setWeightLabels(wLabels);
        linParms.setWeights(weights);
        RDFLinearKernelExperiment exp=new RDFLinearKernelExperiment(new RDFWLSubTreeKernel(it,d,inference,true),s2,linParms,dataset,instances,targets,blackList,evalFuncs);
        res.add(exp.getResults());
        System.out.println(""String_Node_Str"" + d + ""String_Node_Str""+ it);
        exp.run();
      }
      for (      Result res2 : Result.mergeResultLists(res)) {
        resTable.addResult(res2);
      }
    }
  }
  resTable.addCompResults(resTable.getBestResults());
  System.out.println(resTable);
}"
50996,"public static void main(String[] args){
  long seed=1;
  createTask1DataSet(1,seed);
  double[] bins={0.5,1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,12.5,15.5,18.5,23.5};
  long[] seeds={11,21,31,41,51,61,71,81,91,101};
  double[] cs={1,10,100,1000,10000};
  int[] depths={1,2,3};
  int[] iterations={0};
  double[] ps1={1};
  double[] ps2={0.000001,0.00001,0.0001,0.001,0.01};
  List<Double> target=new ArrayList<Double>();
  List<Double> targetBins=new ArrayList<Double>();
  for (  Value label : labels) {
    double val=LiteralUtil.getDoubleValue(label,0);
    target.add(val);
    for (int i=0; i < bins.length - 1; i++) {
      if (val > bins[i] && val <= bins[i + 1]) {
        targetBins.add(i + 1.0);
      }
    }
  }
  ResultsTable resTable=new ResultsTable();
  resTable.setManWU(0.05);
  boolean inference=true;
  List<EvaluationFunction> evalFuncs1=new ArrayList<EvaluationFunction>();
  evalFuncs1.add(new Task1ScoreForBins(bins));
  List<EvaluationFunction> evalFuncs2=new ArrayList<EvaluationFunction>();
  evalFuncs2.add(new Task1Score());
  evalFuncs2.add(new MeanSquaredError());
  evalFuncs2.add(new MeanAbsoluteError());
  for (  int d : depths) {
    for (    int it : iterations) {
      resTable.newRow(""String_Node_Str"");
      LibLINEARParameters linParms=new LibLINEARParameters(LibLINEARParameters.SVC_DUAL,cs);
      linParms.setEvalFunction(new Task1ScoreForBothBins(bins));
      linParms.setDoCrossValidation(false);
      linParms.setSplitFraction((float)0.8);
      linParms.setEps(0.00001);
      linParms.setPs(ps1);
      Map<Double,Double> counts=EvaluationUtils.computeClassCounts(targetBins);
      int[] wLabels=new int[counts.size()];
      double[] weights=new double[counts.size()];
      for (      double label : counts.keySet()) {
        wLabels[(int)label - 1]=(int)label;
        weights[(int)label - 1]=1 / counts.get(label);
      }
      linParms.setWeightLabels(wLabels);
      linParms.setWeights(weights);
      LibLINEARParameters linParms2=new LibLINEARParameters(LibLINEARParameters.SVR_DUAL,cs);
      linParms2.setEvalFunction(new Task1Score());
      linParms2.setDoCrossValidation(false);
      linParms2.setSplitFraction((float)0.8);
      linParms2.setEps(0.00001);
      linParms2.setPs(ps2);
      linParms2.setBias(1);
      List<RDFFeatureVectorKernel> kernels=new ArrayList<RDFFeatureVectorKernel>();
      kernels.add(new RDFIntersectionTreeEdgeVertexPathWithTextKernel(d,inference,true));
      RDFFeatureVectorKernel kernel=new RDFCombinedKernel(kernels,true);
      System.out.println(""String_Node_Str"" + d + ""String_Node_Str""+ it);
      Map<EvaluationFunction,double[]> resultMap=new HashMap<EvaluationFunction,double[]>();
      Map<EvaluationFunction,double[]> resultMap2=new HashMap<EvaluationFunction,double[]>();
      List<Result> results=new ArrayList<Result>();
      for (      EvaluationFunction evalFunc : evalFuncs1) {
        Result res=new Result();
        double[] resA=new double[seeds.length];
        res.setLabel(evalFunc.getLabel());
        res.setScores(resA);
        res.setHigherIsBetter(evalFunc.isHigherIsBetter());
        results.add(res);
        resultMap.put(evalFunc,resA);
      }
      for (      EvaluationFunction evalFunc : evalFuncs2) {
        Result res=new Result();
        double[] resA=new double[seeds.length];
        res.setLabel(evalFunc.getLabel());
        res.setScores(resA);
        res.setHigherIsBetter(evalFunc.isHigherIsBetter());
        results.add(res);
        resultMap2.put(evalFunc,resA);
      }
      Result compR=new Result();
      results.add(compR);
      long tic, toc;
      List<Double> tempLabels=new ArrayList<Double>();
      List<Double> tempLabelsBins=new ArrayList<Double>();
      tempLabels.addAll(target);
      tempLabelsBins.addAll(targetBins);
      tic=System.currentTimeMillis();
      SparseVector[] fv=kernel.computeFeatureVectors(dataset,instances,blackList);
      toc=System.currentTimeMillis();
      List<SparseVector> fvList=Arrays.asList(fv);
      compR.setLabel(""String_Node_Str"");
      for (int j=0; j < seeds.length; j++) {
        Collections.shuffle(fvList,new Random(seeds[j]));
        Collections.shuffle(tempLabels,new Random(seeds[j]));
        Collections.shuffle(tempLabelsBins,new Random(seeds[j]));
        fv=fvList.toArray(new SparseVector[1]);
        double[] targetA=new double[tempLabels.size()];
        double[] targetABins=new double[tempLabelsBins.size()];
        for (int i=0; i < targetA.length; i++) {
          targetA[i]=tempLabels.get(i);
          targetABins[i]=tempLabelsBins.get(i);
        }
        Prediction[] pred=LibLINEAR.trainTestSplit(fv,targetABins,linParms,linParms.getSplitFraction());
        Prediction[] pred2=LibLINEAR.trainTestSplit(fv,targetA,linParms2,linParms2.getSplitFraction());
        double[] targetSplit=LibLINEAR.splitTestTarget(targetA,linParms.getSplitFraction());
        for (        EvaluationFunction ef : evalFuncs1) {
          resultMap.get(ef)[j]=ef.computeScore(targetSplit,pred);
        }
        for (        EvaluationFunction ef : evalFuncs2) {
          resultMap2.get(ef)[j]=ef.computeScore(targetSplit,pred2);
        }
      }
      double[] comp={toc - tic};
      compR.setScores(comp);
      for (      Result res : results) {
        resTable.addResult(res);
      }
    }
  }
  saveResults(resTable,""String_Node_Str"" + seed + ""String_Node_Str"");
  resTable.addCompResults(resTable.getBestResults());
  System.out.println(resTable);
  saveResults(resTable.toString(),""String_Node_Str"" + seed + ""String_Node_Str"");
}","public static void main(String[] args){
  long seed=1;
  createTask1DataSet(1,seed);
  double[] bins={0.5,1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,12.5,15.5,18.5,23.5};
  long[] seeds={11,21,31,41,51,61,71,81,91,101};
  double[] cs={0.0001,0.001,0.01,0.1,1,10,100,1000,10000};
  int[] depths={1,2,3};
  int[] iterations={0};
  double[] ps1={1};
  double[] ps2={0.000001,0.00001,0.0001,0.001,0.01};
  List<Double> target=new ArrayList<Double>();
  List<Double> targetBins=new ArrayList<Double>();
  for (  Value label : labels) {
    double val=LiteralUtil.getDoubleValue(label,0);
    target.add(val);
    for (int i=0; i < bins.length - 1; i++) {
      if (val > bins[i] && val <= bins[i + 1]) {
        targetBins.add(i + 1.0);
      }
    }
  }
  ResultsTable resTable=new ResultsTable();
  resTable.setManWU(0.05);
  boolean inference=true;
  List<EvaluationFunction> evalFuncs1=new ArrayList<EvaluationFunction>();
  evalFuncs1.add(new Task1ScoreForBins(bins));
  List<EvaluationFunction> evalFuncs2=new ArrayList<EvaluationFunction>();
  evalFuncs2.add(new Task1Score());
  evalFuncs2.add(new MeanSquaredError());
  evalFuncs2.add(new MeanAbsoluteError());
  for (  int d : depths) {
    for (    int it : iterations) {
      resTable.newRow(""String_Node_Str"");
      LibLINEARParameters linParms=new LibLINEARParameters(LibLINEARParameters.SVC_DUAL,cs);
      linParms.setEvalFunction(new Task1ScoreForBothBins(bins));
      linParms.setDoCrossValidation(false);
      linParms.setSplitFraction((float)0.8);
      linParms.setEps(0.00001);
      linParms.setPs(ps1);
      Map<Double,Double> counts=EvaluationUtils.computeClassCounts(targetBins);
      int[] wLabels=new int[counts.size()];
      double[] weights=new double[counts.size()];
      for (      double label : counts.keySet()) {
        wLabels[(int)label - 1]=(int)label;
        weights[(int)label - 1]=1 / counts.get(label);
      }
      linParms.setWeightLabels(wLabels);
      linParms.setWeights(weights);
      LibLINEARParameters linParms2=new LibLINEARParameters(LibLINEARParameters.SVR_DUAL,cs);
      linParms2.setEvalFunction(new Task1Score());
      linParms2.setDoCrossValidation(false);
      linParms2.setSplitFraction((float)0.8);
      linParms2.setEps(0.00001);
      linParms2.setPs(ps2);
      linParms2.setBias(1);
      List<RDFFeatureVectorKernel> kernels=new ArrayList<RDFFeatureVectorKernel>();
      kernels.add(new RDFIntersectionTreeEdgeVertexPathWithTextKernel(d,inference,true));
      RDFFeatureVectorKernel kernel=new RDFCombinedKernel(kernels,true);
      System.out.println(""String_Node_Str"" + d + ""String_Node_Str""+ it);
      Map<EvaluationFunction,double[]> resultMap=new HashMap<EvaluationFunction,double[]>();
      Map<EvaluationFunction,double[]> resultMap2=new HashMap<EvaluationFunction,double[]>();
      List<Result> results=new ArrayList<Result>();
      for (      EvaluationFunction evalFunc : evalFuncs1) {
        Result res=new Result();
        double[] resA=new double[seeds.length];
        res.setLabel(evalFunc.getLabel());
        res.setScores(resA);
        res.setHigherIsBetter(evalFunc.isHigherIsBetter());
        results.add(res);
        resultMap.put(evalFunc,resA);
      }
      for (      EvaluationFunction evalFunc : evalFuncs2) {
        Result res=new Result();
        double[] resA=new double[seeds.length];
        res.setLabel(evalFunc.getLabel());
        res.setScores(resA);
        res.setHigherIsBetter(evalFunc.isHigherIsBetter());
        results.add(res);
        resultMap2.put(evalFunc,resA);
      }
      Result compR=new Result();
      results.add(compR);
      long tic, toc;
      List<Double> tempLabels=new ArrayList<Double>();
      List<Double> tempLabelsBins=new ArrayList<Double>();
      tempLabels.addAll(target);
      tempLabelsBins.addAll(targetBins);
      tic=System.currentTimeMillis();
      SparseVector[] fv=kernel.computeFeatureVectors(dataset,instances,blackList);
      toc=System.currentTimeMillis();
      List<SparseVector> fvList=Arrays.asList(fv);
      compR.setLabel(""String_Node_Str"");
      for (int j=0; j < seeds.length; j++) {
        Collections.shuffle(fvList,new Random(seeds[j]));
        Collections.shuffle(tempLabels,new Random(seeds[j]));
        Collections.shuffle(tempLabelsBins,new Random(seeds[j]));
        fv=fvList.toArray(new SparseVector[1]);
        double[] targetA=new double[tempLabels.size()];
        double[] targetABins=new double[tempLabelsBins.size()];
        for (int i=0; i < targetA.length; i++) {
          targetA[i]=tempLabels.get(i);
          targetABins[i]=tempLabelsBins.get(i);
        }
        Prediction[] pred=LibLINEAR.trainTestSplit(fv,targetABins,linParms,linParms.getSplitFraction());
        Prediction[] pred2=LibLINEAR.trainTestSplit(fv,targetA,linParms2,linParms2.getSplitFraction());
        double[] targetSplit=LibLINEAR.splitTestTarget(targetA,linParms.getSplitFraction());
        for (        EvaluationFunction ef : evalFuncs1) {
          resultMap.get(ef)[j]=ef.computeScore(targetSplit,pred);
        }
        for (        EvaluationFunction ef : evalFuncs2) {
          resultMap2.get(ef)[j]=ef.computeScore(targetSplit,pred2);
        }
      }
      double[] comp={toc - tic};
      compR.setScores(comp);
      for (      Result res : results) {
        resTable.addResult(res);
      }
    }
  }
  saveResults(resTable,""String_Node_Str"" + seed + ""String_Node_Str"");
  resTable.addCompResults(resTable.getBestResults());
  System.out.println(resTable);
  saveResults(resTable.toString(),""String_Node_Str"" + seed + ""String_Node_Str"");
}"
50997,"public static void main(String[] args){
  long[] seeds={11,21,31,41,51,61,71,81,91,101};
  double[] cs={0.001,0.01,0.1,1,10,100,1000};
  int[] depths={2};
  int[] depths2={1,2,3};
  int[] iterations={4};
  createAffiliationPredictionDataSet(1);
  boolean inference=true;
  List<EvaluationFunction> evalFuncs=new ArrayList<EvaluationFunction>();
  evalFuncs.add(new Accuracy());
  evalFuncs.add(new F1());
  List<Double> targets=EvaluationUtils.createTarget(labels);
  LibLINEARParameters linParms=new LibLINEARParameters(LibLINEARParameters.SVC_DUAL,cs);
  linParms.setEvalFunction(new Accuracy());
  linParms.setDoCrossValidation(true);
  linParms.setSplitFraction((float)0.8);
  linParms.setEps(0.1);
  Map<Double,Double> counts=EvaluationUtils.computeClassCounts(targets);
  int[] wLabels=new int[counts.size()];
  double[] weights=new double[counts.size()];
  for (  double label : counts.keySet()) {
    wLabels[(int)label - 1]=(int)label;
    weights[(int)label - 1]=1 / counts.get(label);
  }
  linParms.setWeightLabels(wLabels);
  linParms.setWeights(weights);
  ResultsTable resTable=new ResultsTable();
  resTable.setDigits(3);
  for (  int depth : depths) {
    resTable.newRow(""String_Node_Str"");
    for (    int it : iterations) {
      RDFLinearKernelExperiment exp=new RDFLinearKernelExperiment(new RDFWLSubTreeKernel(it,depth,inference,false),seeds,linParms,dataset,instances,targets,blackList,evalFuncs);
      System.out.println(""String_Node_Str"" + depth + ""String_Node_Str""+ it);
      exp.setDoCV(true);
      exp.setDoTFIDF(true);
      exp.run();
      for (      Result res : exp.getResults()) {
        resTable.addResult(res);
      }
    }
  }
  System.out.println(resTable);
  resTable.addCompResults(resTable.getBestResults());
  System.out.println(resTable);
}","public static void main(String[] args){
  long[] seeds={11,21,31,41,51,61,71,81,91,101};
  double[] cs={0.001,0.01,0.1,1,10,100,1000};
  int[] depths={2};
  int[] depths2={1,2,3};
  int[] iterations={4};
  createAffiliationPredictionDataSet(1);
  boolean inference=true;
  List<EvaluationFunction> evalFuncs=new ArrayList<EvaluationFunction>();
  evalFuncs.add(new Accuracy());
  evalFuncs.add(new F1());
  List<Double> targets=EvaluationUtils.createTarget(labels);
  LibLINEARParameters linParms=new LibLINEARParameters(LibLINEARParameters.SVC_DUAL,cs);
  linParms.setEvalFunction(new Accuracy());
  linParms.setDoCrossValidation(true);
  linParms.setSplitFraction((float)0.8);
  linParms.setEps(0.1);
  Map<Double,Double> counts=EvaluationUtils.computeClassCounts(targets);
  int[] wLabels=new int[counts.size()];
  double[] weights=new double[counts.size()];
  for (  double label : counts.keySet()) {
    wLabels[(int)label - 1]=(int)label;
    weights[(int)label - 1]=1 / counts.get(label);
  }
  linParms.setWeightLabels(wLabels);
  linParms.setWeights(weights);
  ResultsTable resTable=new ResultsTable();
  resTable.setDigits(3);
  for (  int depth : depths) {
    resTable.newRow(""String_Node_Str"");
    for (    int it : iterations) {
      RDFLinearKernelExperiment exp=new RDFLinearKernelExperiment(new RDFWLSubTreeKernel(it,depth,inference,false),seeds,linParms,dataset,instances,targets,blackList,evalFuncs);
      System.out.println(""String_Node_Str"" + depth + ""String_Node_Str""+ it);
      exp.setDoTFIDF(true);
      exp.run();
      for (      Result res : exp.getResults()) {
        resTable.addResult(res);
      }
    }
  }
  System.out.println(resTable);
  resTable.addCompResults(resTable.getBestResults());
  System.out.println(resTable);
}"
50998,"public void run(){
  long tic, toc;
  List<Double> tempLabels=new ArrayList<Double>();
  tempLabels.addAll(labels);
  tic=System.currentTimeMillis();
  SparseVector[] fv=kernel.computeFeatureVectors(dataset,instances,blackList);
  toc=System.currentTimeMillis();
  if (doTFIDF) {
    fv=TextUtils.computeTFIDF(Arrays.asList(fv)).toArray(new SparseVector[1]);
    fv=KernelUtils.normalize(fv);
  }
  if (doBinary) {
    fv=KernelUtils.convert2BinaryFeatureVectors(fv);
    fv=KernelUtils.normalize(fv);
  }
  List<SparseVector> fvList=Arrays.asList(fv);
  compR.setLabel(""String_Node_Str"");
  for (int j=0; j < seeds.length; j++) {
    Collections.shuffle(fvList,new Random(seeds[j]));
    Collections.shuffle(tempLabels,new Random(seeds[j]));
    fv=fvList.toArray(new SparseVector[1]);
    double[] target=new double[tempLabels.size()];
    for (int i=0; i < target.length; i++) {
      target[i]=tempLabels.get(i);
    }
    Prediction[] pred=null;
    double[] targetSplit=null;
    if (doCV) {
      pred=LibLINEAR.crossValidate(fv,target,linearParms,linearParms.getNumFolds());
      targetSplit=target;
    }
 else {
      pred=LibLINEAR.trainTestSplit(fv,target,linearParms,linearParms.getSplitFraction());
      targetSplit=LibLINEAR.splitTestTarget(target,linearParms.getSplitFraction());
      if (kernel instanceof RDFWLSubTreeKernel) {
        RDFWLSubTreeKernel k=(RDFWLSubTreeKernel)kernel;
        LibLINEARModel model=LibLINEAR.trainLinearModel(fv,target,linearParms);
        LibLINEARModel.WeightIndexPair[][] fw=model.getFeatureWeights();
        Map<String,String> lm=k.getInverseLabelMap();
        for (        LibLINEARModel.WeightIndexPair[] fwc : fw) {
          Arrays.sort(fwc);
          for (int i=0; i < 10 && i < fwc.length; i++) {
            System.out.print(lm.get(Integer.toString(fwc[i].getIndex())));
            System.out.print(""String_Node_Str"");
          }
          System.out.println(""String_Node_Str"");
        }
      }
    }
    for (    EvaluationFunction ef : evalFunctions) {
      resultMap.get(ef)[j]=ef.computeScore(targetSplit,pred);
    }
  }
  double[] comp={toc - tic};
  compR.setScores(comp);
}","public void run(){
  long tic, toc;
  List<Double> tempLabels=new ArrayList<Double>();
  tempLabels.addAll(labels);
  tic=System.currentTimeMillis();
  SparseVector[] fv=kernel.computeFeatureVectors(dataset,instances,blackList);
  toc=System.currentTimeMillis();
  if (doTFIDF) {
    fv=TextUtils.computeTFIDF(Arrays.asList(fv)).toArray(new SparseVector[1]);
    fv=KernelUtils.normalize(fv);
  }
  if (doBinary) {
    fv=KernelUtils.convert2BinaryFeatureVectors(fv);
    fv=KernelUtils.normalize(fv);
  }
  List<SparseVector> fvList=Arrays.asList(fv);
  compR.setLabel(""String_Node_Str"");
  for (int j=0; j < seeds.length; j++) {
    Collections.shuffle(fvList,new Random(seeds[j]));
    Collections.shuffle(tempLabels,new Random(seeds[j]));
    fv=fvList.toArray(new SparseVector[1]);
    double[] target=new double[tempLabels.size()];
    for (int i=0; i < target.length; i++) {
      target[i]=tempLabels.get(i);
    }
    Prediction[] pred=null;
    double[] targetSplit=null;
    if (doCV) {
      pred=LibLINEAR.crossValidate(fv,target,linearParms,linearParms.getNumFolds());
      targetSplit=target;
    }
 else {
      pred=LibLINEAR.trainTestSplit(fv,target,linearParms,linearParms.getSplitFraction());
      targetSplit=LibLINEAR.splitTestTarget(target,linearParms.getSplitFraction());
      if (kernel instanceof RDFWLSubTreeKernel) {
        RDFWLSubTreeKernel k=(RDFWLSubTreeKernel)kernel;
        LibLINEARModel model=LibLINEAR.trainLinearModel(fv,target,linearParms);
        LibLINEARModel.WeightIndexPair[][] fw=model.getFeatureWeights();
        Map<String,String> lm=k.getInverseLabelMap();
        System.out.println(""String_Node_Str"" + lm.size() + ""String_Node_Str""+ fw[0].length+ ""String_Node_Str""+ fv[0].getLastIndex());
        for (        LibLINEARModel.WeightIndexPair[] fwc : fw) {
          Arrays.sort(fwc);
          for (int i=0; i < 10 && i < fwc.length; i++) {
            System.out.print(lm.get(Integer.toString(fwc[i].getIndex())));
            System.out.print(""String_Node_Str"");
          }
          System.out.println(""String_Node_Str"");
        }
      }
    }
    for (    EvaluationFunction ef : evalFunctions) {
      resultMap.get(ef)[j]=ef.computeScore(targetSplit,pred);
    }
  }
  double[] comp={toc - tic};
  compR.setScores(comp);
}"
50999,"private DirectedGraph<Vertex<Map<Integer,StringBuilder>>,Edge<Map<Integer,StringBuilder>>> createGraphFromRDF(RDFDataSet dataset,List<Resource> instances,List<Statement> blackList){
  Map<String,Vertex<Map<Integer,StringBuilder>>> literalMap=new HashMap<String,Vertex<Map<Integer,StringBuilder>>>();
  Map<String,Vertex<Map<Integer,StringBuilder>>> vertexMap=new HashMap<String,Vertex<Map<Integer,StringBuilder>>>();
  Map<String,Edge<Map<Integer,StringBuilder>>> edgeMap=new HashMap<String,Edge<Map<Integer,StringBuilder>>>();
  DirectedGraph<Vertex<Map<Integer,StringBuilder>>,Edge<Map<Integer,StringBuilder>>> graph=new DirectedSparseMultigraph<Vertex<Map<Integer,StringBuilder>>,Edge<Map<Integer,StringBuilder>>>();
  List<Resource> queryNodes=new ArrayList<Resource>();
  List<Resource> newQueryNodes;
  List<Statement> result;
  Vertex<Map<Integer,StringBuilder>> startV;
  Vertex<Map<Integer,StringBuilder>> newV;
  Edge<Map<Integer,StringBuilder>> newE;
  String idStr, idStr2;
  for (  Resource instance : instances) {
    idStr=instance.toString();
    if (vertexMap.containsKey(idStr)) {
      startV=vertexMap.get(idStr);
      for (      int di : startV.getLabel().keySet()) {
        startV.getLabel().put(di,new StringBuilder(ROOT_LABEL));
      }
    }
 else {
      startV=new Vertex<Map<Integer,StringBuilder>>(new HashMap<Integer,StringBuilder>());
      vertexMap.put(idStr,startV);
      graph.addVertex(startV);
    }
    startV.getLabel().put(depth,new StringBuilder(ROOT_LABEL));
    labelMap.put(idStr,ROOT_LABEL);
    instanceVertices.put(idStr,startV);
    queryNodes.add(instance);
    for (int i=depth - 1; i >= 0; i--) {
      newQueryNodes=new ArrayList<Resource>();
      for (      Resource queryNode : queryNodes) {
        result=dataset.getStatements(queryNode,null,null,inference);
        for (        Statement stmt : result) {
          newV=null;
          if (stmt.getObject() instanceof Literal) {
            if (!ignoreLiterals) {
              idStr=stmt.toString();
              idStr2=stmt.getObject().toString();
              if (literalMap.containsKey(idStr)) {
                newV=literalMap.get(idStr);
                newV.getLabel().put(i,new StringBuilder(labelMap.get(idStr2)));
              }
 else {
                newV=new Vertex<Map<Integer,StringBuilder>>(new HashMap<Integer,StringBuilder>());
                labelMap.put(idStr2,Integer.toString(labelCounter));
                newV.getLabel().put(i,new StringBuilder(Integer.toString(labelCounter)));
                labelCounter++;
                literalMap.put(idStr,newV);
                graph.addVertex(newV);
              }
            }
          }
 else {
            idStr=stmt.getObject().toString();
            if (vertexMap.containsKey(idStr)) {
              newV=vertexMap.get(idStr);
              newV.getLabel().put(i,new StringBuilder(labelMap.get(idStr)));
            }
 else {
              newV=new Vertex<Map<Integer,StringBuilder>>(new HashMap<Integer,StringBuilder>());
              labelMap.put(idStr,Integer.toString(labelCounter));
              newV.getLabel().put(i,new StringBuilder(Integer.toString(labelCounter)));
              labelCounter++;
              vertexMap.put(idStr,newV);
              graph.addVertex(newV);
            }
          }
          if (newV != null) {
            idStr=stmt.toString();
            idStr2=stmt.getPredicate().toString();
            if (edgeMap.containsKey(idStr)) {
              newE=edgeMap.get(idStr);
              newE.getLabel().put(i,new StringBuilder(labelMap.get(idStr2)));
            }
 else {
              newE=new Edge<Map<Integer,StringBuilder>>(new HashMap<Integer,StringBuilder>());
              if (!labelMap.containsKey(idStr2)) {
                labelMap.put(idStr2,Integer.toString(labelCounter));
                labelCounter++;
              }
              newE.getLabel().put(i,new StringBuilder(labelMap.get(idStr2)));
              edgeMap.put(idStr,newE);
              graph.addEdge(newE,vertexMap.get(stmt.getSubject().toString()),newV,EdgeType.DIRECTED);
            }
          }
          if (i > 0 && stmt.getObject() instanceof Resource) {
            newQueryNodes.add((Resource)stmt.getObject());
          }
        }
      }
      queryNodes=newQueryNodes;
    }
  }
  for (  Statement stmt : blackList) {
    graph.removeEdge(edgeMap.get(stmt.toString()));
  }
  return graph;
}","private DirectedGraph<Vertex<Map<Integer,StringBuilder>>,Edge<Map<Integer,StringBuilder>>> createGraphFromRDF(RDFDataSet dataset,List<Resource> instances,List<Statement> blackList){
  Map<String,Vertex<Map<Integer,StringBuilder>>> literalMap=new HashMap<String,Vertex<Map<Integer,StringBuilder>>>();
  Map<String,Vertex<Map<Integer,StringBuilder>>> vertexMap=new HashMap<String,Vertex<Map<Integer,StringBuilder>>>();
  Map<String,Edge<Map<Integer,StringBuilder>>> edgeMap=new HashMap<String,Edge<Map<Integer,StringBuilder>>>();
  DirectedGraph<Vertex<Map<Integer,StringBuilder>>,Edge<Map<Integer,StringBuilder>>> graph=new DirectedSparseMultigraph<Vertex<Map<Integer,StringBuilder>>,Edge<Map<Integer,StringBuilder>>>();
  List<Resource> queryNodes=new ArrayList<Resource>();
  List<Resource> newQueryNodes;
  List<Statement> result;
  Vertex<Map<Integer,StringBuilder>> startV;
  Vertex<Map<Integer,StringBuilder>> newV;
  Edge<Map<Integer,StringBuilder>> newE;
  String idStr, idStr2;
  for (  Resource instance : instances) {
    idStr=instance.toString();
    if (vertexMap.containsKey(idStr)) {
      startV=vertexMap.get(idStr);
      for (      int di : startV.getLabel().keySet()) {
        startV.getLabel().put(di,new StringBuilder(ROOT_LABEL));
      }
    }
 else {
      startV=new Vertex<Map<Integer,StringBuilder>>(new HashMap<Integer,StringBuilder>());
      vertexMap.put(idStr,startV);
      graph.addVertex(startV);
    }
    startV.getLabel().put(depth,new StringBuilder(ROOT_LABEL));
    labelMap.put(idStr,ROOT_LABEL);
    instanceVertices.put(idStr,startV);
    queryNodes.add(instance);
    for (int i=depth - 1; i >= 0; i--) {
      newQueryNodes=new ArrayList<Resource>();
      for (      Resource queryNode : queryNodes) {
        result=dataset.getStatements(queryNode,null,null,inference);
        for (        Statement stmt : result) {
          newV=null;
          if (stmt.getObject() instanceof Literal) {
            if (!ignoreLiterals) {
              idStr=stmt.toString();
              idStr2=stmt.getObject().toString();
              if (literalMap.containsKey(idStr)) {
                newV=literalMap.get(idStr);
                newV.getLabel().put(i,new StringBuilder(labelMap.get(idStr2)));
              }
 else {
                newV=new Vertex<Map<Integer,StringBuilder>>(new HashMap<Integer,StringBuilder>());
                if (!labelMap.containsKey(idStr2)) {
                  labelMap.put(idStr2,Integer.toString(labelCounter));
                  labelCounter++;
                }
                newV.getLabel().put(i,new StringBuilder(labelMap.get(idStr2)));
                literalMap.put(idStr,newV);
                graph.addVertex(newV);
              }
            }
          }
 else {
            idStr=stmt.getObject().toString();
            if (vertexMap.containsKey(idStr)) {
              newV=vertexMap.get(idStr);
              newV.getLabel().put(i,new StringBuilder(labelMap.get(idStr)));
            }
 else {
              newV=new Vertex<Map<Integer,StringBuilder>>(new HashMap<Integer,StringBuilder>());
              labelMap.put(idStr,Integer.toString(labelCounter));
              newV.getLabel().put(i,new StringBuilder(Integer.toString(labelCounter)));
              labelCounter++;
              vertexMap.put(idStr,newV);
              graph.addVertex(newV);
            }
          }
          if (newV != null) {
            idStr=stmt.toString();
            idStr2=stmt.getPredicate().toString();
            if (edgeMap.containsKey(idStr)) {
              newE=edgeMap.get(idStr);
              newE.getLabel().put(i,new StringBuilder(labelMap.get(idStr2)));
            }
 else {
              newE=new Edge<Map<Integer,StringBuilder>>(new HashMap<Integer,StringBuilder>());
              if (!labelMap.containsKey(idStr2)) {
                labelMap.put(idStr2,Integer.toString(labelCounter));
                labelCounter++;
              }
              newE.getLabel().put(i,new StringBuilder(labelMap.get(idStr2)));
              edgeMap.put(idStr,newE);
              graph.addEdge(newE,vertexMap.get(stmt.getSubject().toString()),newV,EdgeType.DIRECTED);
            }
          }
          if (i > 0 && stmt.getObject() instanceof Resource) {
            newQueryNodes.add((Resource)stmt.getObject());
          }
        }
      }
      queryNodes=newQueryNodes;
    }
  }
  for (  Statement stmt : blackList) {
    graph.removeEdge(edgeMap.get(stmt.toString()));
  }
  return graph;
}"
51000,"public SparseVector[] computeFeatureVectors(RDFDataSet dataset,List<Resource> instances,List<Statement> blackList){
  SparseVector[] featureVectors=new SparseVector[instances.size()];
  for (int i=0; i < featureVectors.length; i++) {
    featureVectors[i]=new SparseVector();
  }
  DirectedGraph<Vertex<Map<Integer,StringBuilder>>,Edge<Map<Integer,StringBuilder>>> graph=createGraphFromRDF(dataset,instances,blackList);
  createInstanceIndexMaps(graph,instances);
  if (blankLabels) {
    setBlankLabels(graph);
  }
  computeFVs(graph,instances,Math.sqrt(1.0 / ((double)(iterations + 1))),featureVectors);
  int startLabel=1;
  for (int i=0; i < iterations; i++) {
    relabelGraph2MultisetLabels(graph,startLabel);
    startLabel=labelCounter;
    compressGraphLabels(graph);
    computeFVs(graph,instances,Math.sqrt((2.0 + i) / ((double)(iterations + 1))),featureVectors);
  }
  if (this.normalize) {
    featureVectors=KernelUtils.normalize(featureVectors);
  }
  return featureVectors;
}","public SparseVector[] computeFeatureVectors(RDFDataSet dataset,List<Resource> instances,List<Statement> blackList){
  SparseVector[] featureVectors=new SparseVector[instances.size()];
  for (int i=0; i < featureVectors.length; i++) {
    featureVectors[i]=new SparseVector();
  }
  DirectedGraph<Vertex<Map<Integer,StringBuilder>>,Edge<Map<Integer,StringBuilder>>> graph=createGraphFromRDF(dataset,instances,blackList);
  createInstanceIndexMaps(graph,instances);
  if (blankLabels) {
    setBlankLabels(graph);
  }
  computeFVs(graph,instances,Math.sqrt(1.0 / ((double)(iterations + 1))),featureVectors);
  for (int i=0; i < iterations; i++) {
    relabelGraph2MultisetLabels(graph);
    startLabel=labelCounter;
    compressGraphLabels(graph);
    computeFVs(graph,instances,Math.sqrt((2.0 + i) / ((double)(iterations + 1))),featureVectors);
  }
  if (this.normalize) {
    featureVectors=KernelUtils.normalize(featureVectors);
  }
  return featureVectors;
}"
